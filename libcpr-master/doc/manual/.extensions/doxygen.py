# -*- coding: utf-8 -*-
#
# Sphinx extension for parsing XML files generated by Doxygen.
#
# Written by Arto Bendiken <http://ar.to/>.
#
# This is free and unencumbered software released into the public domain.

#from lxml import etree as ElementTree
from xml.etree import cElementTree as ElementTree

ATTR_TYPES  = {'const': bool, 'explicit': bool, 'id': str, 'inline': bool,
               'kind': str, 'mutable': bool, 'prot': str, 'static': bool,
               'virt': str, 'volatile': bool}
MEMBER_TAGS = ['type', 'definition', 'argsstring', 'name', 'initializer', 'briefdescription'] # TODO
PARAM_TAGS  = ['type', 'declname', 'defname', 'array', 'defval', 'briefdescription']

__index__ = None

def index():
  global __index__
  if __index__ is None:
    __index__ = DoxygenIndex('../doxygen/xml/')
  return __index__

class DoxygenIndex(object):
  def __init__(self, path):
    self.path = path
    self.symbols = parse_index(ElementTree.parse(path + '/index.xml'))

  def get(self, symbol, default=None):
    if symbol in self.symbols:
      compound_refid, member_refid = self.symbols[symbol]
      tree = ElementTree.parse((self.path + '/%s.xml') % (compound_refid))
      for memberdef in tree.findall(".//sectiondef/memberdef[@id='%s']" % (member_refid)):
        return DoxygenMemberDef(memberdef)
    return default

  def __getitem__(self, symbol):
    result = self.get(symbol)
    if result is None:
      raise KeyError, symbol
    return result

  def __iter__(self):
    for symbol in self.symbols:
      yield symbol

  def __str__(self):
    return "<class %s %r>" % (type(self).__name__, self.__dict__)

class DoxygenMemberDef(object):
  def __init__(self, node):
    ElementTree.dump(node) # DEBUG

    # Extract the <memberdef> attributes:
    self.__dict__ = extract_attrs(node)

    # Parse the basic tags:
    for node_name in MEMBER_TAGS:
      self.__dict__[node_name] = extract_text(node.find(node_name))

    # Parse the <param> tags:
    if self.argsstring == '' or self.argsstring == '(void)':
      self.params = []
    else:
      self.params = parse_param_tags(node.findall('param'))

    # Parse the <detaileddescription> tag:
    detaileddescription = node.find('detaileddescription')
    self.exceptions = parse_parameterlist_tag(
      detaileddescription.find('./para/parameterlist[@kind="exception"]'))
    self.returns = parse_simplesect_tag(
      detaileddescription.find('./para/simplesect[@kind="return"]'))
    self.warning = parse_simplesect_tag(
      detaileddescription.find('./para/simplesect[@kind="warning"]'))

    # Parse the <inbodydescription> tag:
    parse_inbodydescription_tag(node.find('inbodydescription'))

    # Parse the <location> tag:
    location = parse_location_tag(node.find('location'))

  def __str__(self):
    return "<class %s %r>" % (type(self).__name__, self.__dict__)

def parse_index(tree):
  result = {}
  for compound in tree.findall('compound'):
    compound_refid = compound.get('refid')
    for member in compound.findall('member'):
      member_refid = member.get('refid')
      member_name = member.findtext('name')
      result[member_name] = (compound_refid, member_refid)
  # TODO: handle duplicate names?
  return result

def extract_attrs(node):
  result = {}
  for (attr_name, attr_value) in node.items():
    attr_type = ATTR_TYPES.get(attr_name)
    if attr_type == bool:
      attr_value = (attr_value == 'yes')
    result[attr_name] = attr_value
  return result

def parse_param_tags(nodes):
  result = []
  for node in nodes:
    param = {}
    for node_name in PARAM_TAGS:
      tag = node.find(node_name)
      if tag is not None:
        param[node_name] = extract_text(tag)
    result.append(param)
  return result

def parse_parameterlist_tag(parameterlist):
  result = {}
  if parameterlist is not None:
    for parameteritem in parameterlist:
      description = extract_text(parameteritem.find('parameterdescription'))
      for parametername in parameteritem.findall('./parameternamelist/parametername'):
        result[extract_text(parametername)] = description
  return result

def parse_simplesect_tag(simplesect):
  if simplesect is None:
    return None
  return extract_text(simplesect)

def parse_inbodydescription_tag(node):
  pass # TODO

def parse_location_tag(node):
  if node is not None:
    return (node.get('file'), node.get('line'))
  return None

def extract_text(node):
  buffer = []
  for text in collect_text(node):
    buffer.append(text)
  return ''.join(buffer).strip()

def collect_text(node):
  if node is not None:
    if node.text is not None:
      yield node.text
    for subnode in node:
      for text in collect_text(subnode):
        yield text
    if node.tail is not None:
      yield node.tail

def setup(app):
  # Sphinx integration:
  if type(app).__name__ == 'sphinx.application.Sphinx':
    app.require_sphinx('1.0')

if __name__ == '__main__':
  for symbol in index():
    print index().get(symbol)
  print index().get('cpr_list_alloca')
