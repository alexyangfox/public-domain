%{

/*
** Allow for a recursive version of Bison parser.
*/

#undef YY_DECL
#define YY_DECL int yylex( YYSTYPE *yylval, YYLTYPE *yylloc)
#define YY_NO_UNISTD_H 

// For some reason, freeBSD chokes on "getc", so the following
// redefines the FLEX YY_INPUT macro to use fgetc, instead.

#ifdef freeBSD_c
#define YY_INPUT(buf,result,max_size) \
    if ( yy_current_buffer->yy_is_interactive ) \
        { \
        int c = '*', n; \
        for ( n = 0; n < max_size && \
                 (c = fgetc( yyin )) != EOF && c != '\n'; ++n ) \
            buf[n] = (char) c; \
        if ( c == '\n' ) \
            buf[n++] = (char) c; \
        if ( c == EOF && ferror( yyin ) ) \
            YY_FATAL_ERROR( "input in flex scanner failed" ); \
        result = n; \
        } \
    else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
          && ferror( yyin ) ) \
        YY_FATAL_ERROR( "input in flex scanner failed" );
#endif





 /*
 ** "Magic" token values in use:
 **
 ** 255/FF - Terminates a macro expansion.
 **
 ** 253/FD - This token is returned to grab a string expression for @text
 ** 252/FC - This token instructs bison to process macro parameters.
 ** 251/FB - Recursive call to process "?" operator.
 ** 250/FA - Recursive call to process expressions.
 ** 249/F9 - unused (used to be used for fetching lines for #while expansion).
 ** 248/F8 - return a #keyword token on the next call.
 ** 247/F7 - return a #terminator token on the next call.
 ** 246/F6 - return an #endmacro token on the next call.
 ** 245/F5 - recursive call to process an HLA identifier (usually an object).
 ** 244/F4 - recursive call to process an HLA class identifier + dot name.
 ** 243/F3 - Marks the end of an _Initialize_ or _Finalize_ string.
 ** 242/F2 - Process a list of items for the #print token.
 ** 241/F1 - Process #text( id ) .. #endtext block.               
 ** 240/F0 - Used when processing the @memory function.
 ** 239/EF - Also used when processing the @memory function.
 ** 238/EE - Used to handle #CODE       (no longer used!)
 ** 237/ED - Used to handle #STATIC     (no longer used!)
 ** 236/EC - Used to handle #READONLY   (no longer used!)
 ** 235/EB - Used to handle #STORAGE    (no longer used!)
 ** 234/EA - Used to handle #CONST      (no longer used!)
 ** 233/E9 - This token leads off a #for statement
 ** 232/E8 - Fetch a new line of text from the #FOR list.
 ** 231/E7 - Handle #Macro declaration.
 ** 230/E6 - Also for handling #macro declaration.
 ** 229/E5 - Handle #RegEx declaration.
 ** 228/E4 - Also for handling #RegEx declaration.
 ** 227/E3 - Return a #endregex token on the next call.
 ** 226/E2 - Used to inform the parser that we have a regex to compile.
 ** 225/E1 - Used to inform the lexer that it needs to record a #return expr.
 ** 240/E0 - Process #string( id ) .. #endstring block.               
 ** 239/DF - Process #match( id ) .. #endmatch block.
 ** 238/DE - Return "ovldClassTkn".               
 ** 237/DD - Sets "delayCollect" to zero.               
 */



#include "debug.h"  /* Must be first! */
/*
** Note that this file must include "common.h" before
** "hla.h".  hla.h is generated automatically by bison,         
** and it uses symbols defined in "common.h", so the
** following sequence must be maintained manually.
*/

#include "common.h"

#ifdef DEBUGFLX
#define PathLogging
/*#define TestStmtCoverage*/
#define LogFuncCalls
#endif
#define _nameDefault "HLAFlex"
#include "ratc.h"


#include "symbol.h"
#include "asm.h"
#include "hlaparse.h"
#include "output.h"

#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#define YYACCEPT return(0)
#define YYABORT return(1)
#define YYERROR goto yyerrlab


char 	collectBuf[ 65536 ];
int		doCollect 		= 0;
int		collectIndex 	= 0;
int		delayCollect 	= 0;

static void collectYYtext( void );

#define YY_USER_ACTION	if( doCollect ) collectYYtext();



extern union YYSTYPE *yylval;

int LineCnt = 1;
int TotalLines = 1;

int SkipLookup = 0;

static int StartParm;


static char numstr[256];

/*
** The following array determines whether a reserved word is
** treated as a reserved word or an ID:
*/

static int doID( YYSTYPE *yylval );
unsigned char ReservedWords[ 2048 ];

#define testRW(rw)                              \
    do{                                         \
        int Token;                              \
        _returnif( ReservedWords[ rw ] ) rw;    \
        Token = doID( yylval );                 \
        _returnif( Token >= 0 ) Token;          \
    }while(0)
    

                 
    


/*
** Variables used to process input buffers (macros, text objects,
** include files, pushback strings, etc.)
*/

#define maxBuffers 8192

        int         BufSP = -1;
struct  SourceBuf   BufferStack[ maxBuffers ];

void deleteSourceBuf( void );


/*
** Variables used to process include files and pushback strings.
*/

#define maxIncStack 4096
#define maxInputLineLen 4096

static  int         IncFilesCnt = 0;
static  char        *IncFilesList[ maxIncStack ];



/*
** Variables used to record macro objects.
*/

typedef struct
{
    char    *text;
    int     len;
} MacroHead_t;

MacroHead_t *macroHead;
int         MacroIndex = 0;
int         NestedMacroCnt;
char        CurLine[ maxInputLineLen+104 ];


MacroHead_t *regexHead;
int         RegexIndex = 0;


/*
** Variables used to play back macros:
*/

      
int                         MacroSP  = -1;
struct MacroStkType         MacroStack[ maxNestedMacros ];
int                         W4TermSP = -1;
struct SymNode              *Wait4Term[ maxNestedMacros ];

struct SymNode              *ActiveMacros = NULL;

ParmLine_t                  *ParmLine;


static  struct SymNode      *yySymbol;
static  int                 MacroCntr = 0;

static  void    EndMacroExpansion( void );

#define appendChParmLine(ch)                                    \
    do{                                                         \
    _here;                                                      \
    assert( ParmLine != NULL );                                 \
    if( ParmLine->Line == NULL ){                               \
        ParmLine->Line = malloc2( 256 );                        \
        ParmLine->LineSize = 256;                               \
        ParmLine->Index = 0;                                    \
    }else if( (ParmLine->Index + 1) >= ParmLine->LineSize ){    \
        ParmLine->LineSize *= 2;                                \
        ParmLine->Line =                                        \
            realloc2( ParmLine->Line, ParmLine->LineSize );     \
    }                                                           \
    ParmLine->Line[ ParmLine->Index++ ] = (ch);                 \
    }while(0)


#define appendStrParmLine(s,l)                                  \
    do{                                                         \
    _here;                                                      \
    assert( ParmLine != NULL );                                 \
    if( ParmLine->Line == NULL ){                               \
        ParmLine->Line = malloc2( 256 );                        \
        ParmLine->LineSize = 256;                               \
        ParmLine->Index = 0;                                    \
    }else if( (ParmLine->Index + (l)) >= ParmLine->LineSize ){  \
        ParmLine->LineSize *= 2;                                \
        ParmLine->Line =                                        \
            realloc2( ParmLine->Line, ParmLine->LineSize );     \
    }                                                           \
    memcpy                                                      \
    (                                                           \
        &ParmLine->Line[ ParmLine->Index ],                     \
        s,                                                      \
        l                                                       \
    );                                                          \
    ParmLine->Index += (l);                                     \
    }while(0)


/*
** Variables used to process #WHILE loops.
*/

        int                 WhileSP = -1;
static  int                 WhileIndex = 0;
static  int                 WhileLen = 0;
static  int                 WhileLineCnt = 0;
static  int                 NestedWhileCnt = 0;
static  char                *WhileHead;
static  struct  WhlListType WhileStack[ maxNestedMacros ];

static void AppendWhileLine( void );

                                                                       



/*
** Variables used to process #FOR loops.
*/

        int                 ForSP = -1;
static  int                 ForIndex = 0;
static  int                 ForLen = 0;
static  int                 NestedForCnt = 0;
static  char                *ForHead;
static  struct  ForListType ForStack[ maxNestedMacros ];
                                                                       



/*
** Variables used to process #text..#endtext blocks.
*/

struct TextList
{
    struct TextList *next;
    char            *line;
};

static char                 TextCurLine[ maxInputLineLen ];
static int                  TextCurIndex;
static struct TextList      *TextHead;
static struct TextList      *TextTail;

/*
** Variable used to process #string..#endstring blocks
*/

static	char	*stringBody;
static	int		stringBodySize;
static	int		stringBodyIndex;

/*
** Variable used to process #match..#endmatch blocks
*/

static	char	*matchBody;
static	int		matchBodySize;
static	int		matchBodyIndex;

/*
** Variables used to process conditional assembly statements
*/

static  int                 ifcnt;
static  int                 NestedIfCnt;
static  int                 IfState;







/*
** The following are needed to process namespace and class objects;
*/

        struct  SymNode     *LastMacroObject =  NULL;
		struct  SymNode     *CurSymTbl       =  NULL;
static  struct  SymNode     *CurObject       =  NULL;
        struct  SymNode     *LastRefdObject  =  NULL;
static          char        ClassID[ maxInputLineLen ];
				char		CurNamespaceID[maxInputLineLen];


/*
** The parser returns ConstExpr values in d1ceReturnVal,
** it returns "dotName" values in d1dnReturnVal.
*/

extern  union   YYSTYPE     d1ceReturnVal;
extern  union   YYSTYPE     d1dnReturnVal;
extern  union   YYSTYPE     forReturnVal;



/*
** Prototypes for local functions.
*/


static void  strip_( void );
static char* MakeStr( void );
static char* MakeUStr( void );
static void  SetArray( YYSTYPE *, struct SymNode * );
static void  AppendMacroLine( void );
static void  AppendRegexLine( void );
static void  AppendForLine( void );
static void  CleanUpWhile( void );
static void  CleanUpFor( void );
static char* trim( char *, int );
static int   ParmTooLong( union YYSTYPE *);
static void  RsvdWordErr( char *RW );
static int   ProcessID
( 
            char    *ID, 
            int     symLexLevel, 
    struct  SymNode *symbol, 
            YYSTYPE *yylval 
);

static int ProcessMacro( struct SymNode *symbol );

static void prefixName( char *filename, char *result );


/*
** Here are the (negative) constants that ProcessID returns to indicate
** the need for further processing.  If ProcessID returns a positive
** value, the return result is a token value that needs no further
** processing by the lexer.
*/

#define PIDtext         -1
#define PIDMacro        -2
#define PIDNameSpace    -3
#define PIDClassName    -4
#define PIDIgnore       -5




/*
** The following function adds include file names to
** the IncFilesList array.
*/

int AddIncFilesList( char *filename );

%}





%x comment 
 //cmnt0 cmnt1 cmnt2 cmnt3 cmnt4 cmnt5 cmnt6 cmnt7 cmnt8 cmnt9
%x RMcomment 
%x RRcomment 
 //RMcmnt0 RMcmnt1 RMcmnt2 RMcmnt3 RMcmnt4 RMcmnt5 RMcmnt6 
 //%x RMcmnt7 RMcmnt8 RMcmnt9
%x RecordMacro
%x RecordRegex
%x MacroParm
%x MPcomment 
 //MPcmnt0 MPcmnt1 MPcmnt2 MPcmnt3 MPcmnt4 MPcmnt5 MPcmnt6 
 //%x MPcmnt7 MPcmnt8 MPcmnt9
%x GetAllOfParm GetAllOfParm2 EndMacroParm GAoPcomment
%x SkipToNext SkippingELSEIFs SkipToEndif
%x SIcomment 
%x SEcomment 

%x RecordWhile
%x RWcomment RWcmnt0 RWcmnt1 RWcmnt2 RWcmnt3 RWcmnt4 RWcmnt5 RWcmnt6 
%x RWcmnt7 RWcmnt8 RWcmnt9

%x InASM
%x recASM
%x NameSpace
%x ThisID

%x InText
%x InString
%x InMatch

%x RecordWhileExpr RecordWhileExpr2
%x For_Record RFcomment

%x poundID poundRW endIDRW

%s UnprocessedID

 /*
 ** create definitions for the reserved words so we can put 
 ** them all in one spot (easier to extract them for documentation
 ** purposes this way).
 */
 
p_append        	#append
p_asm           	#asm
p_closeread     	#closeread
p_closewrite    	#closewrite
p_else          	#else
p_elseif        	#elseif
p_emit          	#emit
p_endasm        	#endasm
p_endfor        	#endfor
p_endif         	#endif
p_endmacro      	#endmacro
p_endmatch			#endmatch
p_endregex      	#endregex
p_endstring			#endstring
p_endtext       	#endtext
p_endwhile      	#endwhile
p_error         	#error
p_for           	#for
p_id            	#id
p_if            	#if
p_include       	#include
p_includeonce   	#includeonce
p_linker			#linker
p_keyword       	#keyword
p_macro         	#macro
p_match				#match
p_openread      	#openread
p_openwrite     	#openwrite
p_print         	#print
p_regex         	#regex
p_return        	#return
p_rw            	#rw
p_string			#string
p_system        	#system
p_terminator    	#terminator
p_text          	#text
p_while         	#while
p_write         	#write



a_a				    @a
a_abs        	    @abs        
a_abstract          @abstract       
a_ae			    @ae
a_align             @align          
a_alignstack        @alignstack 
a_arb				@arb    
a_arity      		@arity 
a_at				@at     
a_b				    @b
a_baseptype  		@baseptype  
a_basereg    		@basereg    
a_basetype   		@basetype   
a_be			    @be
a_boolean			@boolean 
a_bound      		@bound      
a_byte			    @byte
a_c				    @c
a_cdecl             @cdecl          
a_ceil       	    @ceil       
a_char			    @char
a_class      		@class      
a_cos        	    @cos        
a_cset			    @cset
a_curdir    		@curdir    
a_curlex    		@curlex    
a_curobject 		@curobject 
a_curoffset 		@curoffset 
a_date       	    @date       
a_debughla		    @debughla
a_defined    		@defined    
a_delete   			@delete   
a_dim        		@dim        
a_display           @display        
a_dword			    @dword
a_e				    @e
a_elements   		@elements   
a_elementsize		@elementsize
a_enter             @enter          
a_enumsize   		@enumsize   
a_env        	    @env        
a_eos         		@eos         
a_eval              @eval
a_exactlynchar   	@exactlynchar   
a_exactlyncset   	@exactlyncset   
a_exactlynichar   	@exactlynichar   
a_exactlyntomchar	@exactlyntomchar
a_exactlyntomcset	@exactlyntomcset
a_exactlyntomichar	@exactlyntomichar
a_exceptions 		@exceptions 
a_exp        	    @exp        
a_external          @external       
a_extract    	    @extract    
a_fast              @fast           
a_filename  		@filename  
a_firstnchar     	@firstnchar     
a_firstncset     	@firstncset     
a_firstnichar     	@firstnichar     
a_floor      	    @floor      
a_forward           @forward        
a_fpureg			@fpureg
a_frame             @frame          
a_g				    @g
a_ge			    @ge
a_global			@global
a_here              @here
a_index    			@index    
a_insert   			@insert   
a_int128		    @int128
a_int16			    @int16
a_int32			    @int32
a_int64			    @int64
a_int8			    @int8
a_into       		@into       
a_isalpha    	    @isalpha    
a_isalphanum 	    @isalphanum 
a_isclass 			@isclass 
a_isconst 			@isconst 
a_isdigit    	    @isdigit    
a_IsExternal 		@IsExternal 
a_isfreg 			@isfreg 
a_islower    	    @islower    
a_ismem   			@ismem   
a_isreg  			@isreg  
a_isreg16			@isreg16
a_isreg32			@isreg32
a_isreg8 			@isreg8 
a_isspace    	    @isspace    
a_istype  			@istype  
a_isupper    	    @isupper    
a_isxdigit   	    @isxdigit   
a_l				    @l
a_label				@label
a_lastobject		@lastobject
a_le			    @le
a_leave             @leave          
a_length   			@length   
a_lex        		@lex        
a_linenumber		@linenumber
a_localoffset		@localoffset
a_localsyms  		@localsyms  
a_log        	    @log        
a_log10      	    @log10      
a_lowercase			@lowercase
a_lword			    @lword
a_match      		@match      
a_match2      		@match2      
a_matchchar      	@matchchar      
a_matchcset      	@matchcset      
a_matchichar      	@matchichar      
a_matchid          	@matchid          
a_matchintconst    	@matchintconst    
a_matchistr  		@matchistr  
a_matchiword		@matchiword 
a_matchnumericconst	@matchnumericconst
a_matchrealconst   	@matchrealconst   
a_matchstr   		@matchstr   
a_matchstrconst    	@matchstrconst    
a_matchtoistr		@matchtoistr
a_matchtostr 		@matchtostr
a_matchword			@matchword 
a_max        	    @max        
a_min        	    @min        
a_mmxreg			@mmxreg
a_na			    @na
a_nae			    @nae
a_name       		@name       
a_nb			    @nb
a_nbe			    @nbe
a_nc			    @nc
a_ne			    @ne
a_ng			    @ng
a_nge			    @nge
a_nl			    @nl
a_nle			    @nle
a_no			    @no
a_noalignstack      @noalignstack
a_nodisplay         @nodisplay      
a_noenter           @noenter        
a_noframe           @noframe        
a_noleave           @noleave        
a_norlesschar       @norlesschar             
a_norlesscset    	@norlesscset    
a_norlessichar    	@norlessichar    
a_normorechar    	@normorechar    
a_normorecset    	@normorecset    
a_normoreichar    	@normoreichar    
a_nostackalign      @nostackalign
a_nostorage         @nostorage      
a_np			    @np
a_ns			    @ns
a_ntomchar       	@ntomchar       
a_ntomcset       	@ntomcset       
a_ntomichar       	@ntomichar       
a_nz			    @nz
a_o				    @o
a_odd        	    @odd        
a_offset     		@offset     
a_onechar        	@onechar        
a_onecset        	@onecset        
a_oneichar        	@oneichar        
a_oneormorechar  	@oneormorechar  
a_oneormorecset  	@oneormorecset  
a_oneormoreichar  	@oneormoreichar  
a_oneormorews 		@oneormorews 
a_optstrings 		@optstrings 
a_p				    @p
a_parmoffset 		@parmoffset 
a_parms      		@parms      
a_pascal            @pascal         
a_pclass     		@pclass     
a_pe			    @pe
a_peekchar       	@peekchar       
a_peekcset       	@peekcset       
a_peekichar       	@peekichar       
a_peekistr       	@peekistr       
a_peekstr       	@peekstr       
a_peekws      		@peekws      
a_po			    @po
a_pointer		    @pointer
a_pos				@pos
a_ptype      		@ptype      
a_qword			    @qword
a_random     	    @random     
a_randomize  	    @randomize  
a_read              @read
a_real128			@real128
a_real32		    @real32
a_real64		    @real64
a_real80		    @real80
a_reg   			@reg   
a_reg16 			@reg16 
a_reg32 			@reg32 
a_reg8  			@reg8  
a_regex				@regex
a_returns           @returns        
a_rindex   			@rindex   
a_s				    @s
a_section   		@section   
a_sin        	    @sin        
a_size       		@size       
a_sort       	    @sort       
a_sqrt       	    @sqrt       
a_stackalign        @stackalign     
a_staticname 		@staticname 
a_stdcall           @stdcall        
a_strbrk   			@strbrk   
a_string		    @string
a_strset   			@strset   
a_strspan  			@strspan  
a_substr   			@substr   
a_system     	    @system 
a_tab				@tab    
a_tan        	    @tan        
a_tbyte			    @tbyte
a_text              @text
a_thread       	    @thread       
a_time       	    @time       
a_tokenize 			@tokenize 
a_tostring			@tostring
a_trace      		@trace      
a_trim     			@trim     
a_type       		@type       
a_typename   		@typename   
a_uns128		    @uns128
a_uns16			    @uns16
a_uns32			    @uns32
a_uns64			    @uns64
a_uns8			    @uns8
a_uppercase			@uppercase
a_uptochar       	@uptochar       
a_uptocset       	@uptocset       
a_uptoichar       	@uptoichar       
a_uptoistr   		@uptoistr   
a_uptostr    		@uptostr    
a_use               @use            
a_volatile          @volatile       
a_wchar			    @wchar
a_word			    @word
a_ws          		@ws          
a_wsoreos     		@wsoreos     
a_wstheneos   		@wstheneos   
a_wstring		    @wstring
a_xmmreg			@xmmreg
a_z				    @z
a_zeroormorechar 	@zeroormorechar 
a_zeroormorecset 	@zeroormorecset 
a_zeroormoreichar 	@zeroormoreichar 
a_zeroormorews		@zeroormorews
a_zerooronechar  	@zerooronechar  
a_zerooronecset  	@zerooronecset  
a_zerooroneichar  	@zerooroneichar  
a_zstring		    @zstring


            


_aaa            aaa           
_aad            aad           
_aam            aam           
_aas            aas           
_abstract       abstract    
_adc            adc           
_add            add           
_addpd          addpd      
_addps          addps      
_addsd          addsd      
_addss          addss      
_addsubpd       addsubpd   
_addsubps       addsubps   
_ah    			ah    
_al    			al    
_align          align       
_and            and           
_andnpd         andnpd     
_andnps         andnps     
_andpd          andpd      
_andps          andps      
_anyexception   anyexception
_arpl           arpl          
_ax    			ax    
_begin          begin       
_bh    			bh    
_bl    			bl    
_boolean		boolean 
_bound          bound         
_bp    			bp    
_break          break       
_breakif        breakif     
_bsf            bsf           
_bsr            bsr           
_bswap          bswap         
_bt             bt            
_btc            btc           
_btr            btr           
_bts            bts           
_bx    			bx    
_byte			byte
_call           call
_case			case          
_cbw            cbw           
_cdq            cdq           
_ch    			ch    
_char			char
_cl    			cl    
_class          class       
_clc            clc           
_cld            cld           
_clflush        clflush    
_cli            cli           
_clts           clts          
_cmc            cmc           
_cmova          cmova         
_cmovae         cmovae        
_cmovb          cmovb         
_cmovbe         cmovbe        
_cmovc          cmovc         
_cmove          cmove         
_cmovg          cmovg         
_cmovge         cmovge        
_cmovl          cmovl         
_cmovle         cmovle        
_cmovna         cmovna        
_cmovnae        cmovnae       
_cmovnb         cmovnb        
_cmovnbe        cmovnbe       
_cmovnc         cmovnc        
_cmovne         cmovne        
_cmovng         cmovng        
_cmovnge        cmovnge       
_cmovnl         cmovnl        
_cmovnle        cmovnle       
_cmovno         cmovno        
_cmovnp         cmovnp        
_cmovns         cmovns        
_cmovnz         cmovnz        
_cmovo          cmovo         
_cmovp          cmovp         
_cmovpe         cmovpe        
_cmovpo         cmovpo        
_cmovs          cmovs         
_cmovz          cmovz         
_cmp            cmp           
_cmpeqpd        cmpeqpd    
_cmpeqps        cmpeqps    
_cmpeqsd        cmpeqsd    
_cmpeqss        cmpeqss    
_cmplepd        cmplepd    
_cmpleps        cmpleps    
_cmplesd        cmplesd    
_cmpless        cmpless    
_cmpltpd        cmpltpd    
_cmpltps        cmpltps    
_cmpltsd        cmpltsd    
_cmpltss        cmpltss    
_cmpneqpd       cmpneqpd   
_cmpneqps       cmpneqps   
_cmpneqsd       cmpneqsd   
_cmpneqss       cmpneqss   
_cmpnlepd       cmpnlepd   
_cmpnleps       cmpnleps   
_cmpnlesd       cmpnlesd   
_cmpnless       cmpnless   
_cmpnltpd       cmpnltpd   
_cmpnltps       cmpnltps   
_cmpnltsd       cmpnltsd   
_cmpnltss       cmpnltss   
_cmpordpd       cmpordpd   
_cmpordps       cmpordps   
_cmpordsd       cmpordsd   
_cmpordss       cmpordss   
_cmppd          cmppd      
_cmpps          cmpps      
_cmpsb          cmpsb         
_cmpsd          cmpsd         
_cmpss          cmpss      
_cmpsw          cmpsw         
_cmpunordpd     cmpunordpd 
_cmpunordps     cmpunordps 
_cmpunordsd     cmpunordsd 
_cmpunordss     cmpunordss 
_cmpxchg        cmpxchg       
_cmpxchg8b      cmpxchg8b     
_comisd         comisd     
_comiss         comiss     
_const          const       
_continue       continue    
_continueif     continueif  
_cpuid          cpuid         
_cr0			cr0
_cr1			cr1
_cr2			cr2
_cr3			cr3
_cr4			cr4
_cr5			cr5
_cr6			cr6
_cr7			cr7
_cseg			cseg
_cset			cset
_cvtdq2pd       cvtdq2pd   
_cvtdq2ps       cvtdq2ps   
_cvtpd2dq       cvtpd2dq   
_cvtpd2pi       cvtpd2pi   
_cvtpd2ps       cvtpd2ps   
_cvtpi2pd       cvtpi2pd   
_cvtpi2ps       cvtpi2ps   
_cvtps2dq       cvtps2dq   
_cvtps2pd       cvtps2pd   
_cvtps2pi       cvtps2pi   
_cvtsd2si       cvtsd2si   
_cvtsd2ss       cvtsd2ss   
_cvtsi2sd       cvtsi2sd   
_cvtsi2ss       cvtsi2ss   
_cvtss2sd       cvtss2sd   
_cvtss2si       cvtss2si   
_cvttpd2dq      cvttpd2dq  
_cvttpd2pi      cvttpd2pi  
_cvttps2dq      cvttps2dq  
_cvttps2pi      cvttps2pi  
_cvttsd2si      cvttsd2si  
_cvttss2si      cvttss2si  
_cwd            cwd           
_cwde           cwde          
_cx    			cx    
_daa            daa           
_das            das           
_dec            dec 
_default		default          
_dh    			dh    
_di    			di    
_div            div           
_divpd          divpd      
_divps          divps      
_divsd          divsd      
_divss          divss      
_dl    			dl    
_do             do          
_downto         downto      
_dr0			dr0
_dr1			dr1
_dr2			dr2
_dr3			dr3
_dr4			dr4
_dr5			dr5
_dr6			dr6
_dr7			dr7
_dseg			dseg
_dup            dup
_dword			dword       
_dx    			dx    
_dxax  			dx:ax  
_eax   			eax   
_ebp   			ebp   
_ebx   			ebx   
_ecx   			ecx   
_edi   			edi   
_edx   			edx   
_edxeax			edx:eax
_else           else        
_elseif         elseif      
_emms           emms     
_end            end         
_endclass       endclass    
_endconst       endconst    
_endfor         endfor      
_endif          endif       
_endlabel       endlabel    
_endproc        endproc
_endreadonly    endreadonly
_endrecord      endrecord   
_endstatic      endstatic   
_endstorage     endstorage 
_endswitch		endswitch 
_endtry         endtry      
_endtype        endtype     
_endunion       endunion    
_endval         endval      
_endvar         endvar      
_endwhile       endwhile    
_enter          enter         
_enum           enum        
_eseg			eseg
_esi   			esi   
_esp   			esp   
_exception      exception   
_exit           exit        
_exitif         exitif      
_external       external    
_f2xm1          f2xm1   
_fabs           fabs    
_fadd           fadd    
_faddp          faddp   
_fbld           fbld    
_fbstp          fbstp   
_fchs           fchs    
_fclex          fclex   
_fcmova         fcmova  
_fcmovae        fcmovae 
_fcmovb         fcmovb  
_fcmovbe        fcmovbe 
_fcmove         fcmove  
_fcmovna        fcmovna 
_fcmovnae       fcmovnae
_fcmovnb        fcmovnb 
_fcmovnbe       fcmovnbe
_fcmovne        fcmovne 
_fcmovnu        fcmovnu 
_fcmovu         fcmovu  
_fcom           fcom    
_fcomi          fcomi   
_fcomip         fcomip  
_fcomp          fcomp   
_fcompp         fcompp  
_fcos           fcos    
_fdecstp        fdecstp 
_fdiv           fdiv    
_fdivp          fdivp   
_fdivr          fdivr   
_fdivrp         fdivrp  
_felse          felse       
_ffree          ffree   
_fiadd          fiadd   
_ficom          ficom   
_ficomp         ficomp  
_fidiv          fidiv   
_fidivr         fidivr  
_fild           fild    
_fimul          fimul   
_fincstp        fincstp 
_finit          finit   
_fist           fist    
_fistp          fistp   
_fisttp         fisttp  
_fisub          fisub   
_fisubr         fisubr  
_fld            fld     
_fld1           fld1    
_fldcw          fldcw   
_fldenv         fldenv  
_fldl2e         fldl2e  
_fldl2t         fldl2t  
_fldlg2         fldlg2  
_fldln2         fldln2  
_fldpi          fldpi   
_fldz           fldz    
_fmul           fmul    
_fmulp          fmulp   
_fnclex         fnclex  
_fninit         fninit  
_fnop           fnop    
_fnsave         fnsave  
_fnstcw         fnstcw  
_fnstenv        fnstenv 
_fnstsw         fnstsw  
_for            for         
_foreach        foreach     
_forever        forever     
_forward        forward     
_fpatan         fpatan  
_fprem          fprem   
_fprem1         fprem1  
_fptan          fptan   
_frndint        frndint 
_frstor         frstor  
_fsave          fsave   
_fscale         fscale  
_fseg			fseg
_fsin           fsin    
_fsincos        fsincos 
_fsqrt          fsqrt   
_fst            fst     
_fstcw          fstcw   
_fstenv         fstenv  
_fstp           fstp    
_fstsw          fstsw   
_fsub           fsub    
_fsubp          fsubp   
_fsubr          fsubr   
_fsubrp         fsubrp  
_ftst           ftst    
_fucom          fucom   
_fucomi         fucomi  
_fucomip        fucomip 
_fucomp         fucomp  
_fucompp        fucompp 
_fwait          fwait   
_fxam           fxam    
_fxch           fxch    
_fxrstor        fxrstor    
_fxsave         fxsave     
_fxtract        fxtract 
_fyl2x          fyl2x   
_fyl2xp1        fyl2xp1 
_gseg			gseg
_haddpd         haddpd     
_haddps         haddps     
_hlt            hlt           
_hsubpd         hsubpd     
_hsubps         hsubps     
_idiv           idiv          
_if             if          
_imod           imod          
_imul           imul          
_in             in            
_inc            inc           
_inherits       inherits    
_insb           insb          
_insd           insd          
_insw           insw          
_int            int           
_int128			int128
_int16			int16
_int32			int32
_int64			int64
_int8			int8
_intmul         intmul        
_into           into          
_invd           invd          
_invlpg         invlpg        
_iret           iret          
_iretd          iretd         
_iterator       iterator    
_ja             ja            
_jae            jae           
_jb             jb            
_jbe            jbe           
_jc             jc            
_jcxz           jcxz          
_je             je            
_jecxz          jecxz         
_jf             jf          
_jg             jg            
_jge            jge           
_jl             jl            
_jle            jle           
_jmp            jmp           
_jna            jna           
_jnae           jnae          
_jnb            jnb           
_jnbe           jnbe          
_jnc            jnc           
_jne            jne           
_jng            jng           
_jnge           jnge          
_jnl            jnl           
_jnle           jnle          
_jno            jno           
_jnp            jnp           
_jns            jns           
_jnz            jnz           
_jo             jo            
_jp             jp            
_jpe            jpe           
_jpo            jpo           
_js             js            
_jt             jt          
_jz             jz            
_label          label       
_lahf           lahf          
_lar            lar           
_lazy           lazy    
_lddqu          lddqu      
_ldmxcsr        ldmxcsr    
_lds            lds           
_lea            lea           
_leave          leave         
_les            les           
_lfence         lfence     
_lfs            lfs           
_lgdt           lgdt          
_lgs            lgs           
_lidt           lidt          
_lldt           lldt          
_lmsw           lmsw          
_lock__adc      lock\.adc     
_lock__add      lock\.add     
_lock__and      lock\.and     
_lock__btc      lock\.btc     
_lock__btr      lock\.btr     
_lock__bts      lock\.bts     
_lock__cmpxchg  lock\.cmpxchg 
_lock__dec      lock\.dec     
_lock__inc      lock\.inc     
_lock__neg      lock\.neg     
_lock__not      lock\.not     
_lock__or       lock\.or      
_lock__sbb      lock\.sbb     
_lock__sub      lock\.sub     
_lock__xadd     lock\.xadd    
_lock__xchg     lock\.xchg    
_lock__xor      lock\.xor     
_lodsb          lodsb         
_lodsd          lodsd         
_lodsw          lodsw         
_loop           loop          
_loope          loope         
_loopne         loopne        
_loopnz         loopnz        
_loopz          loopz         
_lsl            lsl           
_lss            lss           
_ltreg          ltreg         
_lword			lword
_maskmovdqu     maskmovdqu 
_maskmovq       maskmovq   
_maxpd          maxpd      
_maxps          maxps      
_maxsd          maxsd      
_maxss          maxss      
_method         method      
_mfence         mfence     
_minpd          minpd      
_minps          minps      
_minsd          minsd      
_minss          minss      
_mm0			mm0
_mm1			mm1
_mm2			mm2
_mm3			mm3
_mm4			mm4
_mm5			mm5
_mm6			mm6
_mm7			mm7
_mod            mod
_monitor        monitor    
_mov            mov           
_movapd         movapd     
_movaps         movaps     
_movd           movd     
_movddup        movddup    
_movdq2q        movdq2q    
_movdqa         movdqa     
_movdqu         movdqu     
_movhlps        movhlps    
_movhpd         movhpd     
_movhps         movhps     
_movlhps        movlhps    
_movlpd         movlpd     
_movlps         movlps     
_movmskpd       movmskpd   
_movmskps       movmskps   
_movntdq        movntdq    
_movnti         movnti     
_movntpd        movntpd    
_movntps        movntps    
_movntq         movntq     
_movq           movq     
_movq2dq        movq2dq    
_movsb          movsb         
_movsd          movsd         
_movshdup       movshdup   
_movsldup       movsldup   
_movss          movss      
_movsw          movsw         
_movsx          movsx         
_movupd         movupd     
_movups         movups     
_movzx          movzx         
_mul            mul           
_mulpd          mulpd      
_mulps          mulps      
_mulsd          mulsd      
_mulss          mulss      
_mwait          mwait      
_name           name    
_namespace      namespace   
_neg            neg           
_nop            nop           
_not            not           
_null           null
_or             or            
_orpd           orpd       
_orps           orps       
_out            out           
_outsb          outsb         
_outsd          outsd         
_outsw          outsw
_overloads		overloads         
_override       override    
_overrides      overrides   
_packssdw       packssdw 
_packsswb       packsswb 
_packuswb       packuswb 
_paddb          paddb    
_paddd          paddd    
_paddq          paddq    
_paddsb         paddsb   
_paddsw         paddsw   
_paddusb        paddusb  
_paddusw        paddusw  
_paddw          paddw    
_pand           pand     
_pandn          pandn    
_pause          pause      
_pavgb          pavgb    
_pavgw          pavgw    
_pcmpeqb        pcmpeqb  
_pcmpeqd        pcmpeqd  
_pcmpeqw        pcmpeqw  
_pcmpgtb        pcmpgtb  
_pcmpgtd        pcmpgtd  
_pcmpgtw        pcmpgtw  
_pextrw         pextrw   
_pinsrw         pinsrw   
_pmaddwd        pmaddwd  
_pmaxsw         pmaxsw   
_pmaxub         pmaxub   
_pminsw         pminsw   
_pminub         pminub   
_pmovmskb       pmovmskb 
_pmulhuw        pmulhuw  
_pmulhw         pmulhw   
_pmullw         pmullw   
_pmuludq        pmuludq    
_pointer        pointer     
_pop            pop           
_popa           popa          
_popad          popad         
_popf           popf          
_popfd          popfd         
_por            por      
_prefetchnta    prefetchnta
_prefetcht0     prefetcht0 
_prefetcht1     prefetcht1 
_prefetcht2     prefetcht2
_proc			proc
_procedure      procedure
_program        program     
_psadbw         psadbw   
_pshufd         pshufd     
_pshufhw        pshufhw    
_pshuflw        pshuflw    
_pshufw         pshufw   
_pslld          pslld    
_pslldq         pslldq     
_psllq          psllq    
_psllw          psllw    
_psrad          psrad    
_psraw          psraw    
_psrld          psrld    
_psrldq         psrldq     
_psrlq          psrlq    
_psrlw          psrlw    
_psubb          psubb    
_psubd          psubd    
_psubq          psubq    
_psubsb         psubsb   
_psubsw         psubsw   
_psubusb        psubusb  
_psubusw        psubusw  
_psubw          psubw    
_punpckhbw      punpckhbw
_punpckhdq      punpckhdq
_punpckhqdq     punpckhqdq 
_punpckhwd      punpckhwd
_punpcklbw      punpcklbw
_punpckldq      punpckldq
_punpcklqdq     punpcklqdq 
_punpcklwd      punpcklwd
_push           push          
_pusha          pusha         
_pushad         pushad        
_pushd          pushd         
_pushf          pushf         
_pushfd         pushfd        
_pushw          pushw         
_pxor           pxor     
_qword			qword
_raise          raise
_rcl            rcl           
_rcpps          rcpps      
_rcpss          rcpss      
_rcr            rcr           
_rdmsr          rdmsr         
_rdpmc          rdpmc         
_rdtsc          rdtsc         
_readonly       readonly    
_real128		real128
_real32			real32
_real64			real64
_real80			real80
_record         record      
_regex			regex
_rep__insb      rep\.insb     
_rep__insd      rep\.insd     
_rep__insw      rep\.insw     
_rep__movsb     rep\.movsb    
_rep__movsd     rep\.movsd    
_rep__movsw     rep\.movsw    
_rep__outsb     rep\.outsb    
_rep__outsd     rep\.outsd    
_rep__outsw     rep\.outsw    
_rep__stosb     rep\.stosb    
_rep__stosd     rep\.stosd    
_rep__stosw     rep\.stosw    
_repe__cmpsb    repe\.cmpsb   
_repe__cmpsd    repe\.cmpsd   
_repe__cmpsw    repe\.cmpsw   
_repe__scasb    repe\.scasb   
_repe__scasd    repe\.scasd   
_repe__scasw    repe\.scasw   
_repeat         repeat      
_repne__cmpsb   repne\.cmpsb  
_repne__cmpsd   repne\.cmpsd  
_repne__cmpsw   repne\.cmpsw  
_repne__scasb   repne\.scasb  
_repne__scasd   repne\.scasd  
_repne__scasw   repne\.scasw  
_repnz__cmpsb   repnz\.cmpsb  
_repnz__cmpsd   repnz\.cmpsd  
_repnz__cmpsw   repnz\.cmpsw  
_repnz__scasb   repnz\.scasb  
_repnz__scasd   repnz\.scasd  
_repnz__scasw   repnz\.scasw  
_repz__cmpsb    repz\.cmpsb   
_repz__cmpsd    repz\.cmpsd   
_repz__cmpsw    repz\.cmpsw   
_repz__scasb    repz\.scasb   
_repz__scasd    repz\.scasd   
_repz__scasw    repz\.scasw   
_result         result
_ret            ret           
_returns        returns     
_rol            rol           
_ror            ror           
_rsm            rsm           
_rsqrtps        rsqrtps    
_rsqrtss        rsqrtss    
_sahf           sahf          
_sal            sal           
_sar            sar           
_sbb            sbb           
_scasb          scasb         
_scasd          scasd         
_scasw          scasw         
_segment        segment 
    
_seta           seta          
_setae          setae         
_setb           setb          
_setbe          setbe         
_setc           setc          
_sete           sete          
_setg           setg          
_setge          setge         
_setl           setl          
_setle          setle         
_setna          setna         
_setnae         setnae        
_setnb          setnb         
_setnbe         setnbe        
_setnc          setnc         
_setne          setne         
_setng          setng         
_setnge         setnge        
_setnl          setnl         
_setnle         setnle        
_setno          setno         
_setnp          setnp         
_setns          setns         
_setnz          setnz         
_seto           seto          
_setp           setp          
_setpe          setpe         
_setpo          setpo         
_sets           sets          
_setz           setz
          
_sfence         sfence     
_sgdt           sgdt          
_shl            shl           
_shld           shld          
_shr            shr           
_shrd           shrd          
_shufpd         shufpd     
_shufps         shufps     
_si    			si    
_sidt           sidt          
_sldt           sldt          
_smsw           smsw          
_sp    			sp    
_sqrtpd         sqrtpd     
_sqrtps         sqrtps     
_sqrtsd         sqrtsd     
_sqrtss         sqrtss     
_sseg			sseg
_st0			st0
_st1			st1
_st2			st2
_st3			st3
_st4			st4
_st5			st5
_st6			st6
_st7			st7
_static         static      
_stc            stc           
_std            std           
_sti            sti           
_stmxcsr        stmxcsr    
_storage        storage     
_stosb          stosb         
_stosd          stosd         
_stosw          stosw         
_streg          streg         
_string			string
_sub            sub           
_subpd          subpd      
_subps          subps      
_subsd          subsd      
_subss          subss 
_switch			switch     
_sysenter       sysenter   
_sysexit        sysexit    
_tbyte			tbyte
_test           test          
_text			text
_then           then        
_this			this
_thunk          thunk
_to             to          
_try            try         
_type           type        
_ucomisd        ucomisd    
_ucomiss        ucomiss    
_ud2            ud2           
_union          union       
_unit           unit        
_unpckhpd       unpckhpd   
_unpckhps       unpckhps   
_unpcklpd       unpcklpd   
_unpcklps       unpcklps   
_unprotected    unprotected 
_uns128			uns128
_uns16			uns16
_uns32			uns32
_uns64			uns64
_uns8			uns8
_until          until       
_val            val         
_valres         valres
_var            var         
_verr           verr          
_verw           verw          
_vmt            vmt         
_wait           wait          
_wbinvd         wbinvd        
_wchar			wchar
_welse          welse       
_while          while       
_word			word       
_wrmsr          wrmsr         
_wstring		wstring
_xadd           xadd          
_xchg           xchg          
_xlat           xlat          
_xmm0			xmm0
_xmm1			xmm1
_xmm2			xmm2
_xmm3			xmm3
_xmm4			xmm4
_xmm5			xmm5
_xmm6			xmm6
_xmm7			xmm7
_xor            xor           
_xorpd          xorpd      
_xorps          xorps      
_zstring		zstring




%%

"//".*                                  {}


\/\*                                    { BEGIN comment;        }
<comment>.                              {}
<comment>\n                             { ++LineCnt; ++TotalLines;  }
<comment>\*\/                           { BEGIN 0;              }



 /*
 ** Handle the #ID and #RW items here
 */

{p_id}[ \t\n]*\([ \t\n]*    {   BEGIN poundID;  }

<poundID>[a-z][a-z0-9]* {
                            int Token;
                            char theRW[128];
                            
                            _here;
                            BEGIN 0;
                            theRW[0] = '~';
                            strcpy( &theRW[1], yytext );
                            PushBackStr( theRW );
                            Token = yylex( yylval, yylloc );
                            _if
                            ( 
                                    Token >= 256 
                                &&  Token <= 2047 
                            )
                            
                                ReservedWords[ Token ] = 0;
                                
                            _else
                            
                                yyerror( "#ID requires a reserved word" );
                                
                            _endif
                            BEGIN endIDRW;
                        }

<poundID>.              {
                            yyerror( "Syntax error in #ID directive" );
                            BEGIN 0;
                        }
                        
<endIDRW>[ \t\n]*\)     {   BEGIN 0;    }


{p_rw}[ \t\n]*\([ \t\n]*    {   BEGIN poundRW;  }

<poundRW>[a-z][a-z0-9]* {
                            int Token;
                            char theRW[128];
                            
                            _here;
                            BEGIN 0;
                            theRW[0] = '~';
                            strcpy( &theRW[1], yytext );
                            PushBackStr( theRW );
                            Token = yylex( yylval, yylloc );
                            _if
                            ( 
                                    Token >= 256 
                                &&  Token <= 2047 
                            )
                            
                                ReservedWords[ Token ] = 1;
                                
                            _else
                            
                                yyerror( "#RW requires a reserved word" );
                                
                            _endif
                            BEGIN endIDRW;
                        }

<poundRW>.              {
                            yyerror( "Syntax error in #RW directive" );
                            BEGIN 0;
                        }
                        


 /*
 ** Compile-time file I/O directives:
 */
 
{p_openwrite}   {

                /*
                ** Call the parser to read a string constant
                ** expression surrounded by parentheses.  The
                ** return value comes back in d1ceReturnVal
                */

                _here;
                PushBackStr( "\xFA" );
                yyparse();

                _if( !IsStr( d1ceReturnVal.v.pType ))

                    yyerror( "#openwrite requires a string expression" );

                _elseif( writeHandle != NULL )
                
                    yyerror( "There is already an output file open" );
                    
                _else

                    writeHandle = fopen( d1ceReturnVal.v.u.strval, "w" );
                    _if( writeHandle == NULL )
                    
                        yyerror( "Could not open file for writing" );
                        
                    _endif

                _endif
                FreeValue( &d1ceReturnVal );
                _here;

            }
 
{p_append}  {

                /*
                ** Call the parser to read a string constant
                ** expression surrounded by parentheses.  The
                ** return value comes back in d1ceReturnVal
                */

                _here;
                PushBackStr( "\xFA" );
                yyparse();

                _if( !IsStr( d1ceReturnVal.v.pType ))

                    yyerror( "#append requires a string expression" );

                _elseif( writeHandle != NULL )
                
                    yyerror( "There is already an output file open" );
                    
                _else

                    writeHandle = fopen( d1ceReturnVal.v.u.strval, "a" );
                    _if( writeHandle == NULL )
                    
                        yyerror( "Could not open file for writing" );
                        
                    _endif

                _endif
                FreeValue( &d1ceReturnVal );
                _here;

            }
            
{p_write}       {
                FILE *SavePrintOut;
                
                _here;
                
                _if( writeHandle == NULL )
                
                
                    yyerror( "Attempted #write without open file" );
                    
                _else
                
                    /*
                    ** We're going to cheat big time here and
                    ** just set SavePrintOut to writeHandle and then
                    ** let #print do all the work.
                    */
                    
                    SavePrintOut = PrintOut;
                    PrintOut = writeHandle;

                    /*
                    ** Call the parser to read a string constant
                    ** expression surrounded by parentheses.  The
                    ** return value comes back in d1ceReturnVal
                    */

                    PushBackStr( "\xF2" );
                    yyparse();
                    PrintOut = SavePrintOut;
                    
                _endif
                _here;
            }

{p_closewrite}  {
                _if( writeHandle == NULL )
                
                    yyerror( "Write file is not open" );
                    
                _else
                
                    fclose( writeHandle );
                    writeHandle = NULL;
                    
                _endif;
            }
            

    


 
{p_openread}    {

                /*
                ** Call the parser to read a string constant
                ** expression surrounded by parentheses.  The
                ** return value comes back in d1ceReturnVal
                */

                _here;
                PushBackStr( "\xFA" );
                yyparse();

                _if( !IsStr( d1ceReturnVal.v.pType ))

                    yyerror( "#openread requires a string expression" );

                _elseif( readHandle != NULL )
                
                    yyerror( "There is already an input file open" );
                    
                _else

                    readHandle = fopen( d1ceReturnVal.v.u.strval, "r" );
                    _if( readHandle == NULL )
                    
                        yyerror( "Could not open file for reading" );
                        
                    _endif

                _endif
                FreeValue( &d1ceReturnVal );
                _here;

            }
            
{a_read}    {   _return readTkn; }

{p_closeread}   {
                _if( readHandle == NULL )
                
                    yyerror( "Read file is not open" );
                    
                _else
                
                    fclose( readHandle );
                    readHandle = NULL;
                    
                _endif;
            }
            

    


 /*
 ** Regular expressions that record text for a user-defined macro
 **
 ** RE: macro
 **
 **     This regular expression notes that we have a nested macro
 **     definition (that is, a macro expansion will define a new
 **     macro).  It is important that we note how many nested macro
 **     definitions we encounter because we need count off this same
 **     number of "endmacros" before we terminate recording the current
 **     macro.
 **
 ** RE: endmacro
 **
 **     This regular expression finds the end of the macro we are
 **     recording.  However, if there are any nested macro definitions,
 **     we need to record the endmacro unless this is the final endmacro
 **     for our current definition.
 */

<RecordMacro>{p_macro}      {
                                strcpy
                                ( 
                                    &CurLine[ MacroIndex ],
                                    " #macro "
                                );
                                MacroIndex += 8;
                                ++NestedMacroCnt;
                                _if( MacroIndex >= maxInputLineLen )

                                    char msg[256];

                                    sprintf
                                    (
                                        msg,
                                        "Macro definition is too long "
                                        "(starts on line %d)",
                                        StartParm
                                    );
                                    yyerror( msg );
                                    MacroIndex = 0;

                                _endif
                            }


<RecordMacro>{p_keyword}    {
                                _if( NestedMacroCnt == 1 )

                                    AppendMacroLine(); 
                                    yylval->m.Text = macroHead->text;
                                    free2( (void**) &macroHead );
                                    PushBackStr( "\xF8" );
                                    _return endMacDefTkn;
                                
                                _else
                                
                                    strcpy
                                    (
                                        &CurLine[ MacroIndex ],
                                        " #keyword "
                                    );
                                    MacroIndex += 10;
                                    _if( MacroIndex >= maxInputLineLen )

                                        char msg[256];

                                        sprintf
                                        (
                                            msg,
                                            "Macro definition is too long "
                                            "(starts on line %d)",
                                            StartParm
                                        );
                                        yyerror( msg );
                                        MacroIndex = 0;

                                    _endif

                                _endif
                            }

<RecordMacro>\xF8           { BEGIN 0; _return keywordTkn;  }


<RecordMacro>{p_terminator} {
                                _if( NestedMacroCnt == 1 )

                                    AppendMacroLine(); 
                                    yylval->m.Text = macroHead->text;
                                    free2( (void **) &macroHead );
                                    PushBackStr( "\xF7" );
                                    _return endMacDefTkn;
                                
                                _else
                                
                                    strcpy
                                    (
                                        &CurLine[ MacroIndex ],
                                        " #terminator "
                                    );
                                    MacroIndex += 13;
                                    _if( MacroIndex >= maxInputLineLen )

                                        char msg[256];

                                        sprintf
                                        (
                                            msg,
                                            "Macro definition is too long "
                                            "(starts on line %d)",
                                            StartParm
                                        );
                                        yyerror( msg );
                                        MacroIndex = 0;

                                    _endif

                                _endif
                            }


<RecordMacro>\xF7           { BEGIN 0; _return terminatorTkn;   }


<RecordMacro>{p_endmacro}   { 
                                _here;
                                --NestedMacroCnt;
                                _if( NestedMacroCnt == 0 )

                                    AppendMacroLine(); 
                                    yylval->m.Text = macroHead->text;
                                    free2( (void **) &macroHead );
                                    PushBackStr( "\xF6" );
                                    _return endMacDefTkn;
                                
                                _else
                                
                                    strcpy
                                    (
                                        &CurLine[ MacroIndex ],
                                        " #endmacro "
                                    );
                                    MacroIndex += 11;
                                    _if( MacroIndex >= maxInputLineLen )

                                        char msg[256];

                                        sprintf
                                        (
                                            msg,
                                            "Macro definition is too long "
                                            "(starts on line %d)",
                                            StartParm
                                        );
                                        yyerror( msg );
                                        MacroIndex = 0;

                                    _endif

                                _endif
                                _here;
                            }


<RecordMacro>\xF6   { 
                        BEGIN 0;
                        _return endmacroTkn;    
                    }



 /*
 ** We need to process strings here.  This prevents accidentally
 ** treating the words "#macro" and "#endmacro" inside strings as
 ** new macro definitions or as the end of the current macro definition.
 */

<RecordMacro>\"([^\"\n]|\"\")*\"    {
                                        _here; 
                                        strcpy
                                        (
                                            &CurLine[ MacroIndex ],
                                            yytext
                                        );
                                        MacroIndex += yyleng;   
                                        _if( MacroIndex >= maxInputLineLen )

                                            char msg[256];

                                            sprintf
                                            (
                                                msg,
                                                "Macro definition is too long "
                                                "(starts on line %d)",
                                                StartParm
                                            );
                                            yyerror( msg );
                                            MacroIndex = 0;

                                        _endif
                                        _here;
                                    }


 /*
 ** If EOF occurs while recording a macro, switch buffers:
 */
 
<RecordMacro><<EOF>> {
                        _returnif( BufSP < 0 ) -1; 
                        deleteSourceBuf(); 
                     }

<RecordMacro>\xff   {
                        EndMacroExpansion();
                    }
                    



 /*


 ** If none of the above <RecordMacro> REs process the current
 ** character(s), then the next two REs will record the characters
 ** as part of the current macro (exception: comments inside macro
 ** defintions which are handled a little later).
 */

<RecordMacro>.              {
                                CurLine[ MacroIndex++ ] = *yytext; 
                                _if( MacroIndex >= maxInputLineLen )

                                    char msg[256];

                                    sprintf
                                    (
                                        msg,
                                        "Macro definition is too long "
                                        "(starts on line %d)",
                                        StartParm
                                    );
                                    yyerror( msg );
                                    MacroIndex = 0;

                                _endif
                            }

<RecordMacro>\n             {
                                int SaveLine = LineCnt;

                                _here;
                                CurLine[ MacroIndex++ ] = '\n';
                                AppendMacroLine();
                                LineCnt = SaveLine + 1;
                                _if( MacroIndex >= maxInputLineLen )

                                    char msg[256];

                                    sprintf
                                    (
                                        msg,
                                        "Macro definition is too long "
                                        "(starts on line %d)",
                                        StartParm
                                    );
                                    yyerror( msg );
                                    MacroIndex = 0;

                                _endif
                            }


 /*
 ** If a comment appears within a macro definition, don't bother
 ** recording the macro text.  Besides saving space, this prevents
 ** problems with the words "macro" and "endmacro" appearing within
 ** the body of the comment.
 */

<RecordMacro>"//".*                     {}


<RecordMacro>\/\*                       { BEGIN RMcomment;      }
<RMcomment>.                            {}
<RMcomment>\n                           { ++LineCnt; ++TotalLines;  }
<RMcomment>\*\/                         { BEGIN RecordMacro;    }






  /* 
  ** Handle the @eval(--) function here.  This function
  ** evaluates its parameter as a constant expression,
  ** translates the result to a string, and then pushes
  ** the string back onto the lexer input.
  **
  ** Note: this code was stuck in this unusual spot
  ** because the <UnprocessedID> context generates
  ** some warnings (in certain versions of FLEX)
  ** if it follows the other @eval items appearing
  ** in this file. 
  */                
   
<UnprocessedID>{a_eval} {
            union YYSTYPE strResult;

            _here;
            BEGIN 0;
            PushBackStr( "\xFA" );
            yyparse();
            StrFunc( &strResult, &d1ceReturnVal );
            PushBackStr( strResult.v.u.strval );
            
            FreeValue( &d1ceReturnVal );
            FreeValue( &strResult );
            BEGIN UnprocessedID;
            _here;
        }

                                                                                  
{a_eval}    {
            union YYSTYPE strResult;

            _here;
            PushBackStr( "\xFA" );
            yyparse();
            StrFunc( &strResult, &d1ceReturnVal );
            PushBackStr( strResult.v.u.strval );
            
            FreeValue( &d1ceReturnVal );
            FreeValue( &strResult );
            _here;
        }






 /*
 ** Grand Kludge Ahead!
 **
 ** Regular expressions to record actual macro parameter text.
 **
 ** The following regular expressions process actual (vs formal) macro
 ** parameters.  Unfortunately, it is not possible to come up with a
 ** grammar that handles macro parameters that works within the confines
 ** of the HLA grammar.  The solution is to switch context upon encountering
 ** a macro identifier and use a special lexical analyzer/parser combo
 ** to recognize and record the text of the macro parameters.
 **
 ** HLA macro parameters consist of a sequence of characters that end with
 ** either a comma or a closing parentheses subject to the following rules:
 **
 ** (1) If an opening parenthesis is encountered, all text (including
 **     matched parentheses and commas) is included as part of the
 **     parameter until HLA encounters the corresponding closing paren.
 **
 ** (2) All text between the "#(" and ")#" symbols is included as part
 **     of a macro parameter, including commas and unmatched parentheses.
 **
 ** (3) All text enclosed within quotes or apostrophes (including commas,
 **     parentheses, and the "#(" and ")#" symbols) is included as part
 **     of the macro parameter text.
 **
 ** Note that HLA eliminates any leading and trailing white space and
 ** control characters from a macro parameter (even if you enclose the
 ** text with "#(" and ")#").
 **
 ** HLA also eliminates any comment text appearing inside a macro
 ** parameter.
 **
 */


 /*
 ** Capture all text enclosed by "#(" and ")#".
 */

<MacroParm>"#("             {   
                                _here;  
                                BEGIN GetAllOfParm;
                                StartParm = LineCnt;
                                _here;                  
                            }
               
<GetAllOfParm>")#"          {
                                _here;
                                BEGIN MacroParm; 
                            }


 /*
 ** If we encounter the @eval(--) function within the macro
 ** parameter enclosed by #( and )#, then evaluate the expression
 ** and translate it to a string for emission as the macro parameter.
 */
   
<GetAllOfParm>{a_eval}  {
                        union YYSTYPE strResult;

                        _here;
                        PushBackStr( "\xFA" );

                        BEGIN 0;
                        yyparse();
                        BEGIN GetAllOfParm;

                        StrFunc( &strResult, &d1ceReturnVal );
                        PushBackStr( strResult.v.u.strval );
                        
                        FreeValue( &d1ceReturnVal );
                        FreeValue( &strResult );
                        _here;
                    }

 /*
 ** If we encounter a "@text" function within the parameter list surrounded
 ** by #( and )#, immediately expand the text.
 */

<GetAllOfParm>{a_text}      {
                                _here;
                                PushBackStr( "\xFD" );
                                BEGIN 0;
                                yyparse();
                                BEGIN GetAllOfParm;
                                _here;
                            }


<GetAllOfParm>.             {
                                _here;
                                appendChParmLine( *yytext );    
                                _here;

                            }

<GetAllOfParm>\n            {
                                _here;
                                ++LineCnt;
                                ++TotalLines; 
                                appendChParmLine( ' ' );
                                _here;
                            }

<GetAllOfParm>"//".*        {}
<GetAllOfParm>\/\*          { BEGIN GAoPcomment;    }
<GAoPcomment>.              {}
<GAoPcomment>\n             { ++LineCnt; ++TotalLines;  }
<GAoPcomment>\*\/           { BEGIN GetAllOfParm;   }



    /*
    ** #text..#endtext inside a macro parameter maintains *all* text between
    ** the #text and #endtext.
    */

<MacroParm>{p_text}         {   
                                _here;  
                                BEGIN GetAllOfParm2;
                                StartParm = LineCnt;
                                _here;                  
                            }
               
<GetAllOfParm2>{p_endtext}  {
                                _here;
                                BEGIN MacroParm; 
                            }




<GetAllOfParm2>.                {
                                _here;
                                appendChParmLine( *yytext );    
                                _here;

                            }

<GetAllOfParm2>\n           {
                                _here;
                                ++LineCnt;
                                ++TotalLines; 
                                appendChParmLine( '\n' );
                                _here;
                            }





 /*
 ** If we encounter an @eval(expr) within the macro parameter,
 ** immediately evaluate the constant expression and expand the
 ** result as a TEXT string.
 */
   
<MacroParm>{a_eval} {
                        union YYSTYPE strResult;
                        ParmLine_t *pl;

                        _here;
                        PushBackStr( "\xFA" );

                        pl = ParmLine;
                        ParmLine = NULL;
                        BEGIN 0;
                        yyparse();
                        BEGIN MacroParm;
                        ParmLine = pl;

                        StrFunc( &strResult, &d1ceReturnVal );
                        PushBackStr( strResult.v.u.strval );

                        FreeValue( &d1ceReturnVal );
                        FreeValue( &strResult );
                        _here;
                    }


 /*
 ** If we encounter a "{a_text}" function within the parameter list,
 ** immediately expand the text.
 */

<MacroParm>{a_text} {
                    ParmLine_t *pl;
                    
                    _here;
                    pl = ParmLine;
                    ParmLine = NULL;
                    PushBackStr( "\xFD" );
                    BEGIN 0;
                    yyparse();
                    ParmLine = pl;
                    BEGIN MacroParm;
                    _here;
                 }



 /*
 ** If we encounter an identifier in the actual parameter list,
 ** we need to look it up.  If it is a text ID, we need to expand it
 ** on the spot.
 */
                                           
<MacroParm>[a-z_][a-z0-9_]* {

                        struct  SymNode *symbol;
                        
                        _here;
                        symbol = lookup( yytext, 1 );
                        yylval->s = symbol;
                        _if
                        ( 
                                symbol != NULL
                            &&  symbol->pType == tText
                            &&  (
                                        symbol->SymClass == cConstant
                                    ||  symbol->SymClass == cValue
                                ) 
                        )

                            PushBackStr( symbol->u.strval );

                        _else

                            appendStrParmLine( yytext, yyleng );

                        _endif
                }
                          
 /*
 ** To prevent problems with built-in functions, we need to parse
 ** those right here.  Otherwise, the identifier code above will
 ** treat a string like "@linenumber" as though it were "@" followed
 ** by the identifier "linenumber".  This creates problems if the
 ** program already contains an identifier like "LineNumber".
 */

<MacroParm>@[a-z_][a-z0-9_]*    {

                    _here;
                    appendStrParmLine( yytext, yyleng );
                    _here;
                }



 /*
 ** A comma (that isn't inside a string or a "#(" / ")#" pair) marks the
 ** end of the current macro parameter.
 **
 ** Note, however, that if we are inside a pair of braces ("{".."}") or
 ** a pair of brackets, then we treat the comma just like any other
 ** character.
 */

<MacroParm>","  {
                    ParmLine_t  *prev;
                    
                    _if
                    ( 
                            ParmLine->BraceCnt == 0 
                        &&  ParmLine->BracketCnt == 0 
                        &&  ParmLine->ParenCnt == 0 
                    )

                        appendChParmLine( '\0' );
                        yylval->v.u.strval = 
                            trim( ParmLine->Line, ParmLine->Index-1 );
                            
                        PushBackStr( "," );
                        BEGIN 0;
                        free2( (void **) &ParmLine->Line );
                        prev = ParmLine->prev;
                        free2( (void **) &ParmLine );
                        ParmLine = prev;
                        ParmLine = NULL;
                        _return MacroParmTkn;

                    _else

                        appendChParmLine( ',' );

                    _endif

                }


 /*
 ** We need to count parentheses.  Once the number of right parens
 ** exceeds the number of left parens seen thus far, we're done
 ** processing the macro parameter list.
 */

<MacroParm>"("      {
                        _here;
                        ++ParmLine->ParenCnt; 
                        appendChParmLine( '(' );
                        _here;
                    }

<MacroParm>")"      {
                        ParmLine_t *prev;
                        
                        _here;
                        --ParmLine->ParenCnt;
                        _if( ParmLine->ParenCnt >= 0 )

                            appendChParmLine( ')' );

                        _else

                            int IsEmpty = 1;
                            char *s;
                            int  slen;

                            appendChParmLine( '\0' );
                            s = trim( ParmLine->Line, ParmLine->Index - 1 );
                            slen = strlen( s );
                            free2( (void **) &ParmLine->Line );
                            prev = ParmLine->prev;
                            free2( (void **) &ParmLine );
                            ParmLine = prev;
                            _for( int i=0, i < slen, ++i )

                                IsEmpty = IsEmpty && ( s[i] == ' ' );

                            _endfor
                            _if( IsEmpty )

                                BEGIN 0;
                                _return ')';

                            _endif
                            PushBackStr( ")" );
                            yylval->v.u.strval = s;
                            BEGIN EndMacroParm;
                            _return LastMacroParmTkn;

                        _endif

                    }


<EndMacroParm>")"   {
                        _here;
                        BEGIN 0;
                        _return ')';

                    }



 /*
 ** We need to count braces.
 ** Between braces we don't use commas to separate macro
 ** parameters (since we're processing a set constant).
 */

<MacroParm>"{"      {
                        _here;
                        ++ParmLine->BraceCnt;
                        appendChParmLine( '{' ); 
//                      ParmLine[ ParmIndex++ ] = *yytext;
//                      _returnif( ParmTooLong( yylval ) ) MacroParmTkn;
                        _here;
                    }

<MacroParm>"}"      {
                        _here;
                        appendChParmLine( '}' );
                        _if( ParmLine->BraceCnt > 0 )
                        
                            --ParmLine->BraceCnt;

                        _endif
//                      ParmLine[ ParmIndex++ ] = *yytext;
                        _here;
                    }


 /*
 ** We need to count brackets.
 ** Between braces we don't use commas to separate macro
 ** parameters (since we're processing a set constant).
 */

<MacroParm>"["      {
                        _here;
                        ++ParmLine->BracketCnt;
                        appendChParmLine( '[' ); 
//                      ParmLine[ ParmIndex++ ] = *yytext;
//                      _returnif( ParmTooLong( yylval ) ) MacroParmTkn;
                        _here;
                    }

<MacroParm>"]"      {
                        _here;
                        appendChParmLine( ']' );
                        _if( ParmLine->BracketCnt > 0 )
                        
                            --ParmLine->BracketCnt;

                        _endif
//                      ParmLine[ ParmIndex++ ] = *yytext;
                        _here;
                    }


 /*
 ** We need to process strings here.  This prevents accidentally
 ** treating commas and other objects inside strings as
 ** parameter delimiters.
 */

<MacroParm>\"([^\"\n]|\"\")*\"  {
                        _here;
                        appendStrParmLine( yytext, yyleng ); 
                        _here;
                    }


<MacroParm>u\"([^\"\n]|\"\")*\" {
                        _here; 
                        appendStrParmLine( yytext, yyleng ); 
                        _here;
                    }


<MacroParm>\'.\'    { 
                        _here;
                        appendStrParmLine( yytext, yyleng ); 
                        _here;
                    }

<MacroParm>u\'.\'   { 
                        _here;
                        appendStrParmLine( yytext, yyleng ); 
                        _here;
                    }



 /*
 ** If we encounter ## inside a macro parameter list,
 ** immediately substitute the current macro counter value
 ** so that we get the correct value (if we were to substitute
 ** on macro parameter expansion, we wouldn't get the semantically
 ** correct value, ## always needs to expand immediately).
 */

<MacroParm>"##" {
                    char    macNumber[32];
                    int     len;
                    
                    _here;
                    _if( MacroSP >= 0 )

                        len =
                            sprintf
                            ( 
                                macNumber, 
                                "%d", 
                                MacroStack[ MacroSP ].cnt 
                            );
                            
                        appendStrParmLine( macNumber, len );
                        

                    _else

                        appendChParmLine( '0' );

                    _endif
                    _here;
                }


 /*
 ** If we hit EOF, end of macro, end of..., while processing parms,
 ** switch buffers.
 */
 
<MacroParm><<EOF>>  {
                        _returnif( BufSP < 0 ) -1; 
                        deleteSourceBuf(); 
                    }

<MacroParm>\xff     {
                        EndMacroExpansion();
                    }


 /*
 ** If none of the above <RecordMacro> REs process the current
 ** character(s), then the next two REs will record the characters
 ** as part of the current macro (exception: comments inside macro
 ** defintions which are handled a little later).
 */

<MacroParm>.        {
                        _here;
                        appendChParmLine( *yytext );
                        _here;
                    }

<MacroParm>\n       {
                        _here;
                        appendChParmLine( ' ' );
                        ++LineCnt;
                        ++TotalLines; 
                        _here;
                    }


 /*
 ** If a comment appears within a macro definition, don't bother
 ** recording the macro text.  Besides saving space, this prevents
 ** problems with the words "macro" and "endmacro" appearing within
 ** the body of the comment.
 */

<MacroParm>"//".*                       { _here;                    }


<MacroParm>\/\*                         { _here; BEGIN MPcomment;   }
<MPcomment>.                            {}
<MPcomment>\n                           { ++LineCnt;  ++TotalLines; _here;  }
<MPcomment>\*\/                         { _here; BEGIN MacroParm;   }




 /******************************************************************************/
 /******************************************************************************/

 /*
 ** Regular expressions that record text for a user-defined regular expression
 **
 ** RE: #regex
 **
 **     This regular expression notes that we have a nested macro
 **     definition (that is, a macro expansion will define a new
 **     macro).  It is important that we note how many nested macro
 **     definitions we encounter because we need count off this same
 **     number of "endmacros" before we terminate recording the current
 **     macro.
 **
 ** RE: #endregex
 **
 **     This regular expression finds the end of the macro we are
 **     recording.  However, if there are any nested macro definitions,
 **     we need to record the endmacro unless this is the final endmacro
 **     for our current definition.
 */



<RecordRegex>{p_endregex}	{
                                _here;
								CurLine[ RegexIndex ] = '\xE3';
								++RegexIndex;
                                _if( RegexIndex >= maxInputLineLen )

                                    char msg[256];

                                    sprintf
                                    (
                                        msg,
                                        "Regex definition is too long "
                                        "(starts on line %d)",
                                        StartParm
                                    );
                                    yyerror( msg );
                                    RegexIndex = 0;

                                _endif
								
								// Okay, save a pointer to the "returns"
								// string expression in the m.returns field:
								
                                AppendRegexLine();
								yylval->m.Text = regexHead->text;
								free2( (void **) &regexHead );
								PushBackStr( "\xE3" );
								_return endRegexDefTkn;
							}
							

<RecordRegex>\xE3           { 
                                BEGIN 0;
                                _return endregexTkn;    
                            }



 /*
 ** We need to process strings here.  This prevents accidentally
 ** treating the word "#endregex" inside strings as
 ** the end of the current macro definition.
 */

<RecordRegex>\"([^\"\n]|\"\")*\"    {
                                        _here; 
                                        strcpy
                                        (
                                            &CurLine[ RegexIndex ],
                                            yytext
                                        );
                                        RegexIndex += yyleng;   
                                        _if( RegexIndex >= maxInputLineLen )

                                            char msg[256];

                                            sprintf
                                            (
                                                msg,
                                                "Regex definition is too long "
                                                "(starts on line %d)",
                                                StartParm
                                            );
                                            yyerror( msg );
                                            RegexIndex = 0;

                                        _endif
                                        _here;
                                    }


 /*
 ** If EOF occurs while recording a regular expression, switch buffers:
 */
 
<RecordRegex><<EOF>> {
                        _returnif( BufSP < 0 ) -1; 
                        deleteSourceBuf(); 
                     }

<RecordRegex>\xff   {
                        EndMacroExpansion();
                    }
                    



 /*


 ** If none of the above <RecordRegex> REs process the current
 ** character(s), then the next two REs will record the characters
 ** as part of the current regular expression (exception: comments inside
 ** regular expression definitions which are handled a little later).
 */

<RecordRegex>.              {
                                CurLine[ RegexIndex++ ] = *yytext; 
                                _if( RegexIndex >= maxInputLineLen )

                                    char msg[256];

                                    sprintf
                                    (
                                        msg,
                                        "Regex definition is too long "
                                        "(starts on line %d)",
                                        StartParm
                                    );
                                    yyerror( msg );
                                    RegexIndex = 0;

                                _endif
                            }

<RecordRegex>\n             {
                                int SaveLine = LineCnt;

                                _here;
                                CurLine[ RegexIndex++ ] = '\n';
                                AppendRegexLine();
                                LineCnt = SaveLine + 1;
                                _if( RegexIndex >= maxInputLineLen )

                                    char msg[256];

                                    sprintf
                                    (
                                        msg,
                                        "Regex definition is too "
                                        "long (starts on line %d)",
                                        StartParm
                                    );
                                    yyerror( msg );
                                    RegexIndex = 0;

                                _endif
                            }


 /*
 ** If a comment appears within a regex definition, don't bother
 ** recording the ergex text.  Besides saving space, this prevents
 ** problems with the word "#endregex" appearing within
 ** the body of the comment.
 */

<RecordRegex>"//".*                     {}


<RecordRegex>\/\*                       { BEGIN RRcomment;      }
<RRcomment>.                            {}
<RRcomment>\n                           { ++LineCnt; ++TotalLines;  }
<RRcomment>\*\/                         { BEGIN RecordRegex;    }



 /******************************************************************************/
 /******************************************************************************/






 /*
 ** Handle the "#error" directive here.
 */

{p_error}       {

                /*
                ** Call the parser to read a string constant
                ** expression surrounded by parentheses.  The
                ** return value comes back in d1ceReturnVal
                */

                _here;
                PushBackStr( "\xFA" );
                yyparse();

                _if( !IsStr( d1ceReturnVal.v.pType ))

                    yyerror( "#error requires a string expression" );

                _else

                    yyerror( d1ceReturnVal.v.u.strval );

                _endif
                FreeValue( &d1ceReturnVal );
                _here;

            }








 /*
 ** Handle the "#system" directive here.
 */

{p_system}      {

                /*
                ** Call the parser to read a string constant
                ** expression surrounded by parentheses.  The
                ** return value comes back in d1ceReturnVal
                */

                _here;
                PushBackStr( "\xFA" );
                yyparse();

                _if( !IsStr( d1ceReturnVal.v.pType ))

                    yyerror( "#system requires a string expression" );

                _else

                    system( d1ceReturnVal.v.u.strval );

                _endif
                FreeValue( &d1ceReturnVal );
                _here;

            }








 /*
 ** Handle the "#print" directive here.
 */

{p_print}       {
                FILE *savePrintOut;
                
                savePrintOut = PrintOut;
                PrintOut = MsgOut;

                /*
                ** Call the parser to read a string constant
                ** expression surrounded by parentheses.  The
                ** return value comes back in d1ceReturnVal
                */

                _here;
                PushBackStr( "\xF2" );
                yyparse();
                
                PrintOut = savePrintOut;
                _here;
            }


 



 






 /*
 ** Handle conditional assembly stuff here.
 **
 ** Notes:  "ifcnt" counts the number of #if statements
 **         we've encountered while actually processing statements
 **         (i.e., #if statements *not* appearing in code we're
 **         skipping over due to a false conditional).
 **
 **         "NestedIfCnt" counts the number of nested #if statements
 **         appearing inside code we are skipping over (i.e., code
 **         within a false conditional section).
 */

{p_if}          {

                /*
                ** First, call the parser to read a constant
                ** expression surrounded by parentheses.  Return
                ** value comes back in d1ceReturnVal.
                */

                _here;
                PushBackStr( "\xFA" );
                yyparse();

                _if( d1ceReturnVal.v.pType != tBoolean )

                    yyerror( "#if requires a boolean expression" );

                _endif

                _if( d1ceReturnVal.v.u.unsval == 0 )

                    /*
                    ** Okay, it's a false expression.  Begin skipping
                    ** statements until we hit an #ELSEIF, #ELSE, or
                    ** #ENDIF.
                    */

                    BEGIN SkipToNext;
                    NestedIfCnt = 0;    /* Just starting false conditional  */

                _endif
                ++ifcnt;                /* Need a matching #endif           */

                /*
                ** If the boolean expression was true, ignore all following
                ** #elseif statement.  If it was false, then we need to
                ** consider the #elseifs connected to this #if.
                */

                IfState = d1ceReturnVal.v.u.unsval;
                FreeValue( &d1ceReturnVal );
                _here;
            }




{p_elseif}      {
                /*
                ** If "ifcnt" is zero, then this #elseif came out of the
                ** blue, we're not inside a #if..#endif sequence.
                */

                _here;
                _if( ifcnt <= 0 )

                    yyerror( "Unexpected #ELSEIF" );
                    ifcnt = 0;
                    NestedIfCnt = 0;

                _else

                    /*
                    ** If we get to this point, then we've been
                    ** processing statements in an #if sequence or
                    ** an #elseif sequence.  In either case, we need
                    ** to ignore all further statements through to the
                    ** #endif.
                    */

                    BEGIN SkipToEndif;
                    NestedIfCnt = 0;

                _endif
                _here;
            }



{p_else}        {
                /*
                ** If "ifcnt" is zero, then this #else came out of the
                ** blue, we're not inside a #if..#endif sequence.
                */

                _here;
                _if( ifcnt <= 0 || IfState == 2 )

                    ErrorNear
                    ( 
                        "Unexpected #ELSE",
                        "#ELSE",
                        __LINE__,
                        __FILE__
                    );
                    ifcnt = 0;
                    NestedIfCnt = 0;

                _else

                    /*
                    ** If we get to this point, then we've been
                    ** processing the statements inside an #if (or
                    ** #elseif) statement and we've got to start
                    ** ignoring statements until we hit the #endif.
                    */

                    BEGIN SkipToEndif;
                    NestedIfCnt = 0;

                _endif
                _here;
            }




{p_endif}       {
                _here;
                _if( ifcnt <= 0 )

                    yyerror( "Unexpected #ENDIF" );
                    ifcnt = 0;
                    NestedIfCnt = 0;

                _else

                    /*
                    ** If we've been processing statements
                    ** inside an #if or #elseif, decrement the
                    ** ifcnt variable.  If there are nested
                    ** #if statements, we will continue
                    ** looking for #else or #elseif statements.
                    ** If not, we're done and "ifcnt" will contain zero.
                    */

                    --ifcnt;

                _endif                 
                IfState = 1;
                _here;
            }
            


 /*
 ** At this point, we are skipping statements in the code until we find
 ** the next #if, #elseif, #else, or #endif directive.  
 */

   
<SkipToNext>{p_if}  { 
                        /*
                        ** If we encounter a #if at this point, it must
                        ** be a nested conditional compilation statement.
                        ** Note that fact and skip over all statements
                        ** (through to the corresponding #endif) associated
                        ** with this #if.
                        */

                        _here;
                        ++NestedIfCnt; 
                    }






<SkipToNext>{p_elseif} {

                    /*
                    ** We just encountered a #elseif statement.
                    ** If we're not in a nested #if (false) statement
                    ** process the expression to determine if we
                    ** need to compile the statements following this.
                    */

                    _here;
                    _if( NestedIfCnt == 0 )

                        BEGIN 0;
                        PushBackStr( "\xFA" );
                        yyparse();

                        _if( d1ceReturnVal.v.pType != tBoolean )

                            yyerror
                            ( 
                                "#ELSEIF requires a boolean expression" 
                            );
                            BEGIN SkipToEndif;
                            IfState = 1;

                        _else

                            _if( d1ceReturnVal.v.u.unsval == 0 )

                                /*
                                ** If the expression is false, then
                                ** skip over the statements in this
                                ** #elseif section.
                                */

                                BEGIN SkipToNext;
                                NestedIfCnt = 0;

                            _else

                                /*
                                ** If the expression is true, then begin
                                ** processing the statements in this
                                ** section.
                                */

                                BEGIN 0;
                                NestedIfCnt = 0;
                                IfState = 1;

                            _endif

                        _endif

                    _endif
                    FreeValue( &d1ceReturnVal );
                    _here;

                }




<SkipToNext>{p_else}    {
                        /*
                        ** If we aren't skipping #else
                        ** statements attached to a nested
                        ** #if (with a false expression), 
                        ** begin processing the statements
                        ** after the #else.   (Note: NestedIfCnt
                        ** is greater than zero if we are in the
                        ** false portion of an #if statement
                        ** and there were nested #if statements
                        ** in this false section).
                        */

                        _here;
                        _if( NestedIfCnt == 0 )

                            BEGIN 0;
                            IfState = 2;

                        _endif
                        _here;
                    }





<SkipToNext>{p_endif}   {
                        /*
                        ** If we encounter an #endif while skipping
                        ** statements after a false #if, then one
                        ** of two situations exists: (1) This #endif
                        ** matches the false #if statement, so we
                        ** need to decrement "ifcnt" and begin
                        ** processing the statements after the #endif;
                        ** or, (2) this #endif matches a #if that was
                        ** nested inside the original #if with the
                        ** false expression.  In this later case,
                        ** NestedIfCnt will be greater than zero.
                        */
                        
                        _here;
                        _if( NestedIfCnt == 0 )

                            --ifcnt;
                            BEGIN 0;

                        _else

                            /*
                            ** We've just finished processing a nested
                            ** #if inside a false conditional section.
                            ** Adjust for this by decrementing NestedIfCnt.
                            */

                            --NestedIfCnt;

                        _endif
                        IfState = 1;
                        _here;
                    }

<SkipToNext>\n      { ++LineCnt;  ++TotalLines; _here; }


 /*
 ** End of macro, file, etc., causes a buffer switch.
 */
 
<SkipToNext><<EOF>> {
                        _returnif( BufSP < 0 ) -1; 
                        deleteSourceBuf(); 
                    }

<SkipToNext>\xff    {
                        EndMacroExpansion();
                    }



<SkipToNext>.       {
                        /*
                        ** Since this is a false conditional, we throw
                        ** away all characters we're not directly interested
                        ** in.
                        */
                    }


 /*
 ** We need to process strings here.  This prevents accidentally
 ** treating the words "#if", "#else", and "#endif" inside strings as
 ** the (in)appropriate reserved words.
 */

<SkipToNext>\"([^\"\n]|\"\")*\"     { _here; }


<SkipToNext>u\"([^\"\n]|\"\")*\"        { _here; }


            
 /*
 ** If a comment appears within a conditional assembly sequence, 
 ** don't bother processing it.  This prevents problems with
 ** conditional assembly keywords appearing within
 ** the body of the comment.
 */

<SkipToNext>"//".*                      { _here; }


<SkipToNext>\/\*                        { BEGIN SIcomment;  _here;  }
<SIcomment>.                            {}
<SIcomment>\n                           { ++LineCnt; ++TotalLines; _here;   }
<SIcomment>\*\/                         { BEGIN SkipToNext; _here;  }




 


            






 














 

 /*
 ** If the following RE is matched, then we've been processing statements
 ** inside an #if because of a true expression.  If this isn't a nested
 ** if, let's skip the following asm stmts.
 */
   

<SkipToEndif>{p_if}     { ++NestedIfCnt; _here; }


<SkipToEndif>{p_elseif} {
                        }



<SkipToEndif>{p_else}       {
                            _here;
                        }

<SkipToEndif>{p_endif}      {
                            _here;
                            _if( NestedIfCnt <= 0 )

                                --ifcnt;
                                BEGIN 0;

                            _else

                                --NestedIfCnt;

                            _endif
                            IfState = 1;
                            _here;
                        }


<SkipToEndif>\n         { ++LineCnt; ++TotalLines; _here; }


<SkipToEndif><<EOF>>    {
                            _returnif( BufSP < 0 ) -1; 
                            deleteSourceBuf(); 
                        }

<SkipToEndif>\xff       {
                            EndMacroExpansion();
                        }




<SkipToEndif>.          {}
            

 /*
 ** We need to process strings here.  This prevents accidentally
 ** treating the words "#if", "#else", and "#endif" inside strings as
 ** the (in)appropriate reserved words.
 */

<SkipToEndif>\"([^\"\n]|\"\")*\"        { _here; }
<SkipToEndif>u\"([^\"\n]|\"\")*\"       { _here; }


            



 /*
 ** If a comment appears within a conditional assembly sequence, 
 ** don't bother processing it.  This prevents problems with
 ** conditional assembly keywords appearing within
 ** the body of the comment.
 */

<SkipToEndif>"//".*                     { _here; }


<SkipToEndif>\/\*                       { BEGIN SEcomment; _here;   }
<SEcomment>.                            {}
<SEcomment>\n                           { ++LineCnt; ++TotalLines; _here; }
<SEcomment>\*\/                         { BEGIN SkipToEndif; _here; }






 /**********************************************************************/
 /*
 ** Process the #for loop here.
 */
 
{p_for}     {
                _here;
                PushBackStr( "\xe9" );
                yyparse();

                ForIndex = 0;
                ForLen = 0;
                ForHead = NULL;
                NestedForCnt = 1;
                ++ForSP;
                _if( ForSP >= maxNestedMacros )

                    yyerror( "#FOR stack overflow" );
                    --ForSP;

                _endif
                ForStack[ ForSP ].loopControlVar = 
                    forReturnVal.forInfo.ControlVar;
                    
                ForStack[ ForSP ].endVal = 
                    forReturnVal.forInfo.endVal;
                    
                ForStack[ ForSP ].byVal = 
                    forReturnVal.forInfo.byVal;

                ForStack[ ForSP ].index = 0;
                
                ForStack[ ForSP ].LineCnt = LineCnt;
                
                ForStack[ ForSP ].inVal = 
                    (struct SymNode *)forReturnVal.forInfo.inVal;
                    
                ForStack[ ForSP ].pType = forReturnVal.forInfo.pType;

                BEGIN( For_Record );
                _here;
            }
            
\xe9        {
                _here;
                _return ctforTkn;
            }
            
            
{p_endfor}      {
                int doLoop;
                
                _here;
                _if( ForSP >= 0 )

                    
                    // Bump up the loop control variable by one:
                    
                    ForStack[ ForSP ].loopControlVar->u.intval +=
                        ForStack[ ForSP ].byVal;
                    
                    // See if the loop is done:

                        
                    _if( ForStack[ ForSP ].byVal < 0 )
                    
                        doLoop = 
                            ForStack[ ForSP ].loopControlVar->u.intval >=
                                ForStack[ ForSP ].endVal;
                    
                    _elseif( ForStack[ ForSP ].byVal > 0 )
                    
                        doLoop = 
                            ForStack[ ForSP ].loopControlVar->u.intval <=
                                ForStack[ ForSP ].endVal;
                    
                    _else // We got a #for( var in expr ) loop:
                    
                        union   YYSTYPE v;
                        
                        _switch( ForStack[ ForSP ].pType )
                        
                            _case( tString )
                            _case( tZString )
                                
                                v.v.u.charval = 
                                    ForStack[ ForSP ].inVal->u.strval
                                    [
                                        ForStack[ ForSP ].index
                                    ];
                                    
                                SetSym
                                (
                                    ForStack[ ForSP ].loopControlVar,
                                    &char_ste,  // Type
                                    tChar,      // pType
                                    0,          // Arity
                                    NULL,       // Dimensions
                                    0,          // NumElements
                                    YYS &v,     // Value
                                    1,          // ObjectSize
                                    0,          // CurOffset
                                    NULL,       // StaticName
                                    NULL,       // Base
                                    NULL,       // Fields
                                    0,          // FieldCnt
                                    NULL,       // CurField
                                    0           // CurIndex
                                );
                                doLoop = 
                                    ForStack[ ForSP ].loopControlVar->u.charval
                                        != '\0';
                                        
                                ForStack[ ForSP ].index += doLoop;
                                
                            _endcase
                            
                            
                        
                            _case( tCset )
                            {
                                int byteIndex;
                                int bitPosition;
                                
                                
                                // Extract a character from the character
                                // set:
                                
                                _while( ForStack[ ForSP ].index < 128 )
                                
                                    byteIndex = ForStack[ ForSP ].index >> 3;
                                    bitPosition = 
                                        1 << (ForStack[ ForSP ].index & 0x7);
                                        
                                    _breakif
                                    ( 
                                        ForStack[ ForSP ].inVal->u.csetval
                                        [
                                            byteIndex
                                        ] & bitPosition
                                    );
                                    ++ForStack[ ForSP ].index;
                                    
                                _endwhile
                                doLoop = ForStack[ ForSP ].index < 128;

                                _if( doLoop )
                                
                                    v.v.u.charval = ForStack[ ForSP ].index;
                                    SetSym
                                    (
                                        ForStack[ ForSP ].loopControlVar,
                                        &char_ste,  // Type
                                        tChar,      // pType
                                        0,          // Arity
                                        NULL,       // Dimensions
                                        0,          // NumElements
                                        YYS &v,     // Value
                                        1,          // ObjectSize
                                        0,          // CurOffset
                                        NULL,       // StaticName
                                        NULL,       // Base
                                        NULL,       // Fields
                                        0,          // FieldCnt
                                        NULL,       // CurField
                                        0           // CurIndex
                                    );
                                    ++ForStack[ ForSP ].index;
                                    
                                _endif
                            
                            }
                            _endcase
                            

                            _case( tArray )
                            
                                // Extract an element from the array:

                                doLoop =
                                        ForStack[ ForSP ].index
                                    <   ForStack
                                        [ 
                                            ForSP 
                                        ].inVal->NumElements;
                                    
                                        
                                _if( doLoop )
                                    SetSym
                                    (
                                        ForStack[ ForSP ].loopControlVar,
                                        ForStack[ ForSP ].inVal->Type,
                                        ForStack[ ForSP ].inVal->Type->pType,
                                        0,          // Arity
                                        NULL,       // Dimensions
                                        0,          // NumElements
                                        YYS &ForStack[ ForSP ].inVal->
                                            u.ArrayOfValues
                                            [
                                                ForStack[ ForSP ].index
                                            ],
                                        1,          // ObjectSize
                                        0,          // CurOffset
                                        NULL,       // StaticName
                                        
                                        ForStack[ ForSP ].inVal->
                                            u.ArrayOfValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Base,
                                            
                                        ForStack[ ForSP ].inVal->
                                            u.ArrayOfValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Fields,
                                        ForStack[ ForSP ].inVal->
                                            u.ArrayOfValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].FieldCnt,
                                        NULL,       // CurField
                                        0           // CurIndex
                                    );
                                    ++ForStack[ ForSP ].index;
                                    
                                _endif
                                
                            _endcase



                            

                        
                            _case( tRecord )
                            {
                                struct  SymNode *f;
                            
                                // Extract a field from the record:

                                doLoop = ForStack[ ForSP ].index >= 0;
                                    
                                        
                                _if( doLoop )
                                
                                    // First, find the field:
                                    
                                    f = 
                                        &ForStack[ ForSP ].inVal->u.FieldValues
                                        [
                                            ForStack[ ForSP ].index
                                        ];

                                    SetSym
                                    (
                                        ForStack[ ForSP ].loopControlVar,
                                        f->Type,
                                        f->pType,
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Arity,
                                            
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Dimensions,
                                            
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].NumElements,
                                            
                                        YYS f,
                                        1,          // ObjectSize
                                        0,          // CurOffset
                                        NULL,       // StaticName
                                        
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Base,
                                            
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Fields,
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].FieldCnt,
                                        NULL,       // CurField
                                        0           // CurIndex
                                    );
                                    --ForStack[ ForSP ].index;
                                    
                                _endif
                                
                            }
                            _endcase




                            _default
                            
                                doLoop = 0;
                                
                        _endswitch
                        
                    
                    _endif

                    _if( !doLoop )

                        // Clean up after the #for loop, 'cause we're done.
                        
                        CleanUpFor();

                    _else

                        // Reset to the beginning of the #FOR loop:
                        
                        LineCnt = ForStack[ ForSP ].LineCnt;
                        
                        // Tell the scanner to fetch the next line from
                        // the beginning of the #FOR text:
                        
                        //PushBackChar( '\xe8' );
                        yy_delete_buffer( YY_CURRENT_BUFFER );

                        FileName = BufferStack[ BufSP ].FileName;
                        yy_scan_string( ForStack[ ForSP ].line );
                        

                    _endif
                    

                _else

                    yyerror( "Unexpected #endfor" );

                _endif
                _here;

            }

        
 /*
 ** The following statements handle all the text in the
 ** #for loop after the expression.
 **
 ** Handle the end of the for loop here.
 */

<For_Record>{p_endfor}  {

                int doLoop;
                
                _here;
                --NestedForCnt;
                strcpy
                (
                    &CurLine[ ForIndex ],
                    yytext
                );
                ForIndex += yyleng;
                _if( ForIndex >= maxInputLineLen )

                    yyerror
                    (
                        "#FOR loop is too long"
                    );
                    ForIndex = 0;

                _endif
                _if( NestedForCnt <= 0 )                                       

                    AppendForLine();
                    
                    ForStack[ ForSP ].line = ForHead;

                    /*
                    ** Okay, tell the system to begin
                    ** processing the #FOR text.
                    */
                    
                    BEGIN 0;
                    _if( ForStack[ ForSP ].byVal < 0 )
                    
                        doLoop = 
                            ForStack[ ForSP ].loopControlVar->u.intval >=
                                ForStack[ ForSP ].endVal;
                    
                    _elseif( ForStack[ ForSP ].byVal > 0 )
                    
                        doLoop = 
                            ForStack[ ForSP ].loopControlVar->u.intval <=
                                ForStack[ ForSP ].endVal;
                    
                    _else // We got a #for( var in expr ) loop:
                    
                        struct  SymNode *s;
                        union   YYSTYPE v;

                        _switch( ForStack[ ForSP ].pType )
                        
                            _case( tString )
                            _case( tZString )
                            
                                // Extract a character from the string:
                                
                                v.v.u.charval = 
                                    ForStack[ ForSP ].inVal->u.strval
                                    [
                                        ForStack[ ForSP ].index
                                    ];
                                    
                                SetSym
                                (
                                    ForStack[ ForSP ].loopControlVar,
                                    &char_ste,  // Type
                                    tChar,      // pType
                                    0,          // Arity
                                    NULL,       // Dimensions
                                    0,          // NumElements
                                    YYS &v,     // Value
                                    1,          // ObjectSize
                                    0,          // CurOffset
                                    NULL,       // StaticName
                                    NULL,       // Base
                                    NULL,       // Fields
                                    0,          // FieldCnt
                                    NULL,       // CurField
                                    0           // CurIndex
                                );
                                doLoop = 
                                    ForStack[ ForSP ].loopControlVar->u.charval
                                        != '\0';
                                        
                                ForStack[ ForSP ].index += doLoop;
                                
                            _endcase
                            
                            
                            _case( tCset )
                            {
                                int byteIndex;
                                int bitPosition;
                                
                                
                                // Extract a character from the character
                                // set:
                                
                                _while( ForStack[ ForSP ].index < 128 )
                                

                                    byteIndex = ForStack[ ForSP ].index >> 3;
                                    bitPosition = 
                                        1 << (ForStack[ ForSP ].index & 0x7);
                                        
                                    _breakif
                                    ( 
                                        ForStack[ ForSP ].inVal->u.csetval
                                        [
                                            byteIndex
                                        ] & bitPosition
                                    );
                                    ++ForStack[ ForSP ].index;
                                    
                                _endwhile
                                doLoop = ForStack[ ForSP ].index < 128;

                                _if( doLoop )
                                
                                    v.v.u.charval = ForStack[ ForSP ].index;
                                    SetSym
                                    (
                                        ForStack[ ForSP ].loopControlVar,
                                        &char_ste,  // Type
                                        tChar,      // pType

                                        0,          // Arity
                                        NULL,       // Dimensions
                                        0,          // NumElements
                                        YYS &v,     // Value
                                        1,          // ObjectSize
                                        0,          // CurOffset
                                        NULL,       // StaticName
                                        NULL,       // Base
                                        NULL,       // Fields
                                        0,          // FieldCnt
                                        NULL,       // CurField
                                        0           // CurIndex
                                    );
                                    ++ForStack[ ForSP ].index;
                                    
                                _endif
                            
                            }
                            _endcase
                            

                        
                            _case( tArray )
                            
                                // Extract an element from the array:

                                doLoop =
                                        ForStack[ ForSP ].index
                                    <   ForStack
                                        [ 
                                            ForSP 
                                        ].inVal->NumElements;
                                    
                                        
                                _if( doLoop )
                                    
                                    SetSym
                                    (
                                        ForStack[ ForSP ].loopControlVar,
                                        ForStack[ ForSP ].inVal->Type,
                                        ForStack[ ForSP ].inVal->Type->pType,
                                        0,          // Arity
                                        NULL,       // Dimensions
                                        0,          // NumElements
                                        YYS &ForStack[ ForSP ].inVal->
                                            u.ArrayOfValues
                                            [
                                                ForStack[ ForSP ].index
                                            ],
                                        1,          // ObjectSize
                                        0,          // CurOffset
                                        NULL,       // StaticName
                                        
                                        ForStack[ ForSP ].inVal->
                                            u.ArrayOfValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Base,
                                            
                                        ForStack[ ForSP ].inVal->
                                            u.ArrayOfValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Fields,
                                        ForStack[ ForSP ].inVal->
                                            u.ArrayOfValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].FieldCnt,
                                        NULL,       // CurField
                                        0           // CurIndex
                                    );
                                    ++ForStack[ ForSP ].index;
                                    
                                _endif
                                
                            _endcase
                            

                        
                            _case( tRecord )
                            {
                                struct  SymNode *f;
                            
                                // Extract a field from the record:

                                doLoop = 
                                    ForStack[ ForSP ].inVal->FieldCnt > 0;
                                        
                                _if( doLoop )
                                
                                    // First, find the field:
                                    
                                    ForStack[ ForSP ].index = 
                                        ForStack[ ForSP ].inVal->FieldCnt - 1;

                                    f = 
                                        &ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ];
                                            
                                        
                                    SetSym
                                    (
                                        ForStack[ ForSP ].loopControlVar,
                                        f->Type,
                                        f->pType,
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Arity,
                                            
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Dimensions,
                                            
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].NumElements,
                                            
                                        YYS f,
                                        1,          // ObjectSize
                                        0,          // CurOffset
                                        NULL,       // StaticName
                                        
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Base,
                                            
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].Fields,
                                        ForStack[ ForSP ].inVal->
                                            u.FieldValues
                                            [
                                                ForStack[ ForSP ].index
                                            ].FieldCnt,
                                        NULL,       // CurField
                                        0           // CurIndex
                                    );
                                    --ForStack[ ForSP ].index;
                                    
                                _endif
                                
                            }
                            _endcase
                            
                            
                            _default
                            
                                doLoop = 0;
                                
                        _endswitch
                        
                    _endif

                    _if( !doLoop )

                        --ForSP;

                    _else

                        pushBufStack( FileName, LineCnt, NULL, 0 );
                        LineCnt = ForStack[ ForSP ].LineCnt;
                        yy_scan_string( ForStack[ ForSP ].line );

                    _endif

                _endif
                _here;  
            }


 /*
 ** Look for nested #FOR loops here.
 */

<For_Record>{p_for} {

                _here;
                ++NestedForCnt;
                strcpy
                (
                    &CurLine[ ForIndex ],
                    yytext
                );
                ForIndex += yyleng; 
                _if( ForIndex >= maxInputLineLen )

                    yyerror
                    (
                        "#FOR loop is too long"
                    );
                    ForIndex = 0;

                _endif
                _here;
            }


 /*
 ** We need to process strings here.  This prevents accidentally
 ** treating the words "#For" and "#endFor" inside strings as
 ** new For definitions or as the end of the current For loop.
 */

<For_Record>\"([^\"\n]|\"\")*\" { 
                                        _here;
                                        strcpy
                                        (
                                            &CurLine[ ForIndex ],
                                            yytext
                                        );
                                        ForIndex += yyleng; 
                                        _if( ForIndex >= maxInputLineLen )

                                            yyerror
                                            (
                                                "#FOR loop is too long"
                                            );
                                            ForIndex = 0;

                                        _endif
                                        _here;
                                    }


<For_Record>u\"([^\"\n]|\"\")*\"    { 
                                        _here;
                                        strcpy
                                        (
                                            &CurLine[ ForIndex ],
                                            yytext
                                        );
                                        ForIndex += yyleng; 
                                        _if( ForIndex >= maxInputLineLen )

                                            yyerror
                                            (

                                                "#FOR loop is too long"
                                            );
                                            ForIndex = 0;

                                        _endif
                                        _here;
                                    }




<For_Record><<EOF>> {
                        _returnif( BufSP < 0 ) -1; 
                        deleteSourceBuf(); 
                    }

<For_Record>\xff    {
                        EndMacroExpansion();
                    }





 /*
 ** If none of the above <RecordFor> REs process the current
 ** character(s), then the next two REs will record the characters
 ** as part of the current For loop (exception: comments inside loop
 ** definitions are handled a little later).
 */

<For_Record>.               {
                                _here;
                                CurLine[ ForIndex++ ] = *yytext; 
                                _if( ForIndex >= maxInputLineLen )

                                    yyerror( "#FOR loop is too long" );
                                    ForIndex = 0;

                                _endif
                                _here;
                            }

<For_Record>\n              {
                                _here;
                                CurLine[ ForIndex++ ] = '\n';

                                AppendForLine();
                                ++LineCnt;
                                ++TotalLines; 
                                _if( ForIndex >= maxInputLineLen )

                                    yyerror( "#FOR loop is too long" );
                                    ForIndex = 0;

                                _endif
                                _here;
                            }


 /*
 ** If a comment appears within a For loop, don't bother
 ** recording the comment text.  Besides saving space, this prevents
 ** problems with the words "#For" and "#endFor" appearing within
 ** the body of the comment.
 */

<For_Record>"//".*                      { _here; }


<For_Record>\/\*                        { BEGIN RFcomment;   _here; }
<RFcomment>.                            {}
<RFcomment>\n                           { ++LineCnt; ++TotalLines; _here;   }
<RFcomment>\*\/                         { BEGIN For_Record; _here;  }   











 /**********************************************************************/
 /*
 ** Record the body of a while loop here.
 */

{p_while}       {
                _here;
                WhileIndex = 0;
                WhileLen = 0;
                WhileHead = NULL;
                NestedWhileCnt = 1;
                ++WhileSP;
                _if( WhileSP >= maxNestedMacros )

                    yyerror( "While stack overflow" );
                    --WhileSP;

                _endif
                WhileStack[ WhileSP ].StartingLineNum = LineCnt;
                BEGIN( RecordWhileExpr );
                _here;
            }



{p_endwhile}    {
                _here;
                _if( WhileSP >= 0 )

                    yy_delete_buffer( YY_CURRENT_BUFFER );
                    LineCnt = WhileStack[ WhileSP ].StartingLineNum;
                    FileName = BufferStack[ BufSP ].FileName;
                    yy_scan_string( WhileStack[ WhileSP ].line );

                    yyparse();

                    _if( d1ceReturnVal.v.pType != tBoolean )

                        yyerror
                        ( 
                            "#while requires a boolean expression" 
                        );
                        CleanUpWhile();

                    _elseif( d1ceReturnVal.v.u.unsval == 0 )

                        CleanUpWhile();

                    _endif

                _else

                    yyerror( "Unexpected #endwhile" );

                _endif
                FreeValue( &d1ceReturnVal );
                _here;
            }


 /*
 ** Record a #while expression here.
 ** This is a sequence of characters between a pair of balanced
 ** parentheses.
 **
 ** Okay, granted this is really ugly and kludgy.
 ** The idea is this: an expression surrounded by parentheses
 ** must immediately follow the "#while".  There may, however,
 ** be whitespace (including newlines) sprinkled before and
 ** in the middle of this expression.  Unfortunately, the expression
 ** parsing algorithm for #while expressions requires the expression
 ** to appear within a single string object.  The following
 ** (context-sensitive) regular expressions capture everything
 ** between the opening parenthesis and the matching closing paren
 ** and stick all of this data into a single string.  No check is
 ** done at this point to verify that the expression is correct (the
 ** parser will do that later).
 **
 ** Step 1 (RecordWhileExpr): throw away any leading white space
 ** up to the opening parenthesis.  If the first non-white space
 ** character is not an open paren, we've got an error.
 */


<RecordWhileExpr>[\ \t]+    {}
<RecordWhileExpr>\n         { ++LineCnt; ++TotalLines; }

<RecordWhileExpr>\( {

                _here;
                CurLine[ WhileIndex++ ] = '(';
                WhileStack[ WhileSP ].ParenCnt = 1; 
                WhileStack[ WhileSP ].LineCnt = 0; 
                BEGIN RecordWhileExpr2;
                _here;

            }

<RecordWhileExpr>[^\ \t\n\(]+ {

                yyerror( "Illegal character(s) in #while expression" );
                BEGIN RecordWhile;

            }


 /*
 ** Step 2: Capture all characters until we encounter
 ** the matching closing parenthesis.  Note that this code
 ** replaces any newlines it finds by a single space since
 ** the parser chokes if there is a new line in the middle
 ** of a #while expression.
 */

<RecordWhileExpr2>\) {

                /*
                ** Okay, we've got a closing parenthesis, add
                ** it to the end of the string we are building.
                */

                int LinesInExpr;

                _here;
                CurLine[ WhileIndex++ ] = ')';


                _if( WhileIndex >= maxInputLineLen )

                    yyerror( "While loop is too long" );
                    WhileIndex = 0;

                _endif

                /*
                ** If this is the matching parenthesis, then
                ** we're done collecting the expression.  Otherwise
                ** we treat this parenthesis just like any other
                ** character.
                */

                _if( --WhileStack[ WhileSP ].ParenCnt == 0 )

                    LinesInExpr = WhileStack[ WhileSP ].LineCnt;
                    _for( int i=0, i < LinesInExpr, ++i )

                        CurLine[ WhileIndex++ ] = '\n';

                    _endfor
                    BEGIN RecordWhile;

                _endif
                _here;
                
            } 
            
 /*
 ** If we encounter an opening parenthesis, we need to bump
 ** our counter up by one so we stop on the balanced paren.
 */
    
<RecordWhileExpr2>\( {

                _here;
                CurLine[ WhileIndex++ ] = '(';
                ++WhileStack[ WhileSP ].ParenCnt;
                _here;
            }
        
 /*
 ** To save space in the CurLine array, compress all adjacent
 ** whitespace characters to a single space:
 */
        
<RecordWhileExpr2>[\ \t]+ {

                _here;
                CurLine[ WhileIndex++ ] = ' ';
                _here;
            }

 /*
 ** Convert newlines to a space, but count the newlines
 ** so we can insert a sufficient number of blank lines
 ** into the #while list to make up for the newlines
 ** we've removed (so line numbers in error messages will
 ** roughly match the line the error is on).
 */

<RecordWhileExpr2>[\n] {

                _here;
                CurLine[ WhileIndex++ ] = ' ';
                ++WhileStack[ WhileSP ].LineCnt;
                ++LineCnt;
                ++TotalLines;
                _here;
            }
    
 /*
 ** If a string appears in an expression, handle it specially
 ** because we don't want to stop on a parenthesis inside a string
 */
 
<RecordWhileExpr2>\"([^\"\n]|\"\")*\"   { 
                _here;
                CurLine[ WhileIndex] = 0;
                strcpy( &CurLine[ WhileIndex ], yytext );
                WhileIndex += yyleng;
                _here;
            }
            

 /*
 ** If it's some other character, just add it to the current line.
 */

<RecordWhileExpr2>. {

                _here;
                CurLine[ WhileIndex++ ] = *yytext;
                _if( WhileIndex >= maxInputLineLen )

                    yyerror( "While loop is too long" );
                    WhileIndex = 0;

                _endif
                _here;

            }



 /*
 ** The following statements handle all the text in the
 ** #while loop after the boolean expression.
 **
 ** Handle the end of the while loop here.
 */

<RecordWhile>{p_endwhile}   {

                _here;
                --NestedWhileCnt;
                strcpy
                (
                    &CurLine[ WhileIndex ],
                    yytext
                );
                WhileIndex += yyleng;
                _if( WhileIndex >= maxInputLineLen )

                    yyerror
                    (
                        "While loop is too long"
                    );
                    WhileIndex = 0;

                _endif
                _if( NestedWhileCnt <= 0 )                                     

                    AppendWhileLine();
                    WhileStack[ WhileSP ].line = WhileHead;
                    pushBufStack( FileName, LineCnt, NULL, 0 );
                    LineCnt = WhileStack[ WhileSP ].StartingLineNum;                

                    /*
                    ** Okay, tell the system to begin
                    ** processing the while text and
                    ** recursively calling the parser in order
                    ** to process the boolean expression.
                    */
                    
                    BEGIN 0;
                    yy_scan_string( WhileHead );
                    
                    // Note: first character of the WhileHead string
                    // is 0xFA, which forces evaluation of the expression:
                    //PushBackChar( '\xFA' );
                    
                    yyparse();


                    _if( d1ceReturnVal.v.pType != tBoolean )

                        yyerror
                        ( 
                            "Boolean expression required by #while"
                        );
                        CleanUpWhile();

                    _elseif( d1ceReturnVal.v.u.unsval == 0 )

                        CleanUpWhile();

                    _endif
                    FreeValue( &d1ceReturnVal );
                
                _endif
                _here;  
            }


<RecordWhile>{p_while}  {

                _here;
                ++NestedWhileCnt;
                strcpy
                (
                    &CurLine[ WhileIndex ],
                    yytext
                );
                WhileIndex += yyleng;   
                _if( WhileIndex >= maxInputLineLen )

                    yyerror
                    (
                        "While loop is too long"
                    );
                    WhileIndex = 0;

                _endif
                _here;
            }


 /*
 ** We need to process strings here.  This prevents accidentally
 ** treating the words "#while" and "#endwhile" inside strings as
 ** new while definitions or as the end of the current while loop.
 */

<RecordWhile>\"([^\"\n]|\"\")*\"    { 
                                        _here;
                                        strcpy
                                        (
                                            &CurLine[ WhileIndex ],
                                            yytext
                                        );
                                        WhileIndex += yyleng;   
                                        _if( WhileIndex >= maxInputLineLen )

                                            yyerror
                                            (
                                                "While loop is too long"
                                            );
                                            WhileIndex = 0;

                                        _endif
                                        _here;
                                    }


<RecordWhile>u\"([^\"\n]|\"\")*\"   { 
                                        _here;
                                        strcpy
                                        (
                                            &CurLine[ WhileIndex ],
                                            yytext
                                        );
                                        WhileIndex += yyleng;   
                                        _if( WhileIndex >= maxInputLineLen )

                                            yyerror
                                            (
                                                "While loop is too long"
                                            );
                                            WhileIndex = 0;

                                        _endif
                                        _here;
                                    }



<RecordWhile><<EOF>>    {
                            _returnif( BufSP < 0 ) -1; 
                            deleteSourceBuf(); 
                        }

<RecordWhile>\xff       {
                            EndMacroExpansion();
                        }





 /*
 ** If none of the above <RecordWhile> REs process the current
 ** character(s), then the next two REs will record the characters
 ** as part of the current while loop (exception: comments inside loop
 ** definitions are handled a little later).
 */

<RecordWhile>.              {
                                _here;
                                CurLine[ WhileIndex++ ] = *yytext; 
                                _if( WhileIndex >= maxInputLineLen )

                                    yyerror( "While loop is too long" );
                                    WhileIndex = 0;

                                _endif
                                _here;
                            }

<RecordWhile>\n             {
                                _here;
                                CurLine[ WhileIndex++ ] = '\n';

                                AppendWhileLine();
                                ++LineCnt;
                                ++TotalLines; 
                                _if( WhileIndex >= maxInputLineLen )

                                    yyerror( "While loop is too long" );
                                    WhileIndex = 0;

                                _endif
                                _here;
                            }


 /*
 ** If a comment appears within a while loop, don't bother
 ** recording the comment text.  Besides saving space, this prevents
 ** problems with the words "#while" and "#endwhile" appearing within
 ** the body of the comment.
 */

<RecordWhile>"//".*                     { _here; }


<RecordWhile>\/\*                       { BEGIN RWcomment;   _here; }
<RWcomment>.                            {}
<RWcomment>\n                           { ++LineCnt; ++TotalLines; _here;   }
<RWcomment>\*\/                         { BEGIN RecordWhile; _here; }










 /*
 ** Code to handle include files goes here.
 */

                

{p_include}     {
                    FILE *theFile;
                    char prefix[256];
                    char path[ 256];

                    /*
                    ** Get the string expression that follows #include
                    ** (the expression must be surrounded by parens).
                    */

                    _here;
                    PushBackStr( "\xFA" );
                    yyparse();

                    _if( !IsStr( d1ceReturnVal.v.pType ))

                        yyerror
                        ( 
                            "#include requires a string expression" 
                        );

                    _else
                    
                        theFile = fopen( d1ceReturnVal.v.u.strval, "r" );                       
                        strcpy( path, d1ceReturnVal.v.u.strval );

                        // If we couldn't open the file, try looking
                        // in the same directory containing the .hla file:
                        
                        _if( theFile == NULL )

                            int  len;
                            prefixName( FileName, prefix );
                            len = strlen( prefix );
                            strcpy( path, prefix );
                            _if
                            ( 
                                    path[ len - 1 ] != '/' 
                                &&  path[ len - 1 ] != '\\' 

                            )

                                path[ len ] = DIR_SEP_CHAR;
                                path[ len+1 ] = '\0';

                            _endif
                            strcat( path, d1ceReturnVal.v.u.strval );

                            theFile = fopen( path, "r" );
                        
                        _endif

                        _if( theFile == NULL && hlaauxinc != NULL )

                            int  len;

                            len = strlen( hlaauxinc );
                            strcpy( path, hlaauxinc );
                            _if
                            ( 
                                    path[ len - 1 ] != '/' 
                                &&  path[ len - 1 ] != '\\' 
                            )

                                path[ len ] = DIR_SEP_CHAR;
                                path[ len+1 ] = '\0';

                            _endif
                            strcat( path, d1ceReturnVal.v.u.strval );

                            theFile = fopen( path, "r" );

                        _endif

                        _if( theFile == NULL && hlainc != NULL )

                            int  len;

                            len = strlen( hlainc );
                            strcpy( path, hlainc );
                            _if
                            ( 
                                    path[ len - 1 ] != '/' 
                                &&  path[ len - 1 ] != '\\' 
                            )

                                path[ len ] = DIR_SEP_CHAR;
                                path[ len+1 ] = '\0';

                            _endif
                            strcat( path, d1ceReturnVal.v.u.strval );

                            theFile = fopen( path, "r" );

                        _endif
                        AddIncFilesList( path );

                        _if( theFile == NULL )

                            char msg[256];

                            sprintf
                            ( 
                                msg, 
                                "Could not open include file \"%s\"\n(path=\"%s\")", 
                                d1ceReturnVal.v.u.strval,
                                path
                            );

                            yyerror( msg );
                            exit(1);

                        _endif
                        pushBufStack( FileName, LineCnt, theFile, 1 ); 
                        yy_switch_to_buffer
                        ( 
                            yy_create_buffer
                            ( 
                                theFile, 
                                YY_BUF_SIZE 
                            )
                        );
                        LineCnt = 1;
                        FileName = hlastrdup2( path );                  

                    _endif
                    FreeValue( &d1ceReturnVal );
                    _here;
                }


{p_includeonce} {
                    FILE    *theFile;
                    char    prefix[256];
                    char    path[ 256];

                    /*
                    ** Get the string expression that follows #include
                    ** (the expression must be surrounded by parens).
                    */

                    _here;
                    PushBackStr( "\xFA" );
                    yyparse();

                    _if( !IsStr( d1ceReturnVal.v.pType ))

                        yyerror
                        ( 
                            "#includeonce requires a string expression" 
                        );

                    _elseif( AddIncFilesList( d1ceReturnVal.v.u.strval ) )
                          
                        theFile = fopen( d1ceReturnVal.v.u.strval, "r" );
                        
                        // If we couldn't open the file, try looking
                        // in the same directory containing the .hla file:
                        
                        _if( theFile == NULL )

                            int  len;

                            prefixName( FileName, prefix );
                            len = strlen( prefix );
                            strcpy( path, prefix );
                            _if
                            ( 
                                    prefix[ len - 1 ] != '/' 
                                &&  prefix[ len - 1 ] != '\\' 
                            )

                                prefix[ len ] = DIR_SEP_CHAR;
                                prefix[ len+1 ] = '\0';

                            _endif
                            strcat( prefix, d1ceReturnVal.v.u.strval );

                            theFile = fopen( prefix, "r" );
                        
                        _endif

                        _if( theFile == NULL && hlaauxinc != NULL )

                            int  len;

                            len = strlen( hlaauxinc );
                            strcpy( path, hlaauxinc );
                            _if
                            ( 
                                    path[ len - 1 ] != '/' 
                                &&  path[ len - 1 ] != '\\' 
                            )

                                path[ len ] = DIR_SEP_CHAR;
                                path[ len+1 ] = '\0';

                            _endif
                            strcat( path, d1ceReturnVal.v.u.strval );
                            theFile = fopen( path, "r" );

                        _endif
						
                        _if( theFile == NULL && hlainc != NULL )

                            int  len;

                            len = strlen( hlainc );
                            strcpy( path, hlainc );
                            _if
                            ( 
                                    path[ len - 1 ] != '/' 
                                &&  path[ len - 1 ] != '\\' 
                            )

                                path[ len ] = DIR_SEP_CHAR;
                                path[ len+1 ] = '\0';

                            _endif
                            strcat( path, d1ceReturnVal.v.u.strval );
                            theFile = fopen( path, "r" );

                        _else

                            strcpy( path, d1ceReturnVal.v.u.strval );

                        _endif
                        _if( theFile == NULL )

                            char msg[256];

                            sprintf
                            ( 
                                msg, 
                                "Could not open include file \"%s\"", 
                                d1ceReturnVal.v.u.strval 
                            );
                            yyerror( msg );

                        _else

                            pushBufStack( FileName, LineCnt, theFile, 1 ); 
                            yy_switch_to_buffer
                            ( 
                                yy_create_buffer
                                ( 
                                    theFile, 
                                    YY_BUF_SIZE 
                                )
                            );
                            LineCnt = 1;
                            FileName = hlastrdup2( path );

                        _endif
    
                    _endif
                    FreeValue( &d1ceReturnVal );
                    _here;
                }



 /* #linker( "string" ) adds the string argument to a list of strings */
 /* that the main compiler emits to the linker response file.			  */

{p_linker} {
                    includeLibList_t 	*temp;
					int					exists;

                    /*
                    ** Get the string expression that follows #linker
                    ** (the expression must be surrounded by parens).
                    */

                    _here;
                    PushBackStr( "\xFA" );
                    yyparse();

                    _if( !IsStr( d1ceReturnVal.v.pType ))

                        yyerror
                        ( 
                            "#linker requires a string expression" 
                        );

                    _else
					
						// First, see if we already have this linker
						// option in the includeLibList:
						
						exists = 0;
						temp = includeLibList;
						_while( temp != NULL )
						
							exists = 
								strcmp
								( 
									temp->lib, 
									d1ceReturnVal.v.u.strval 
								) == 0;
								
							_breakif( exists );
							temp = temp->next;
							
						_endwhile
						
						_if( !exists )
					
							temp = malloc( sizeof( includeLibList_t ));
							_if( includeLibList == NULL )

								includeLibList = temp;
								includeLibList->next = NULL;

							_else
							
								temp->next = includeLibList;
								includeLibList = temp;

							_endif
							includeLibList->lib = strdup( d1ceReturnVal.v.u.strval );
							
						_endif
							 
                    _endif
                    FreeValue( &d1ceReturnVal );
                    _here;
                }




 /*
 ** Code to handle the #TEXT..#ENDTEXT directives goes here.
 */

{p_text}            {   
                        _here;
                        PushBackStr( "\xF1" );
                        TextCurIndex = 0;
                        TextHead = NULL;
                        TextTail = NULL;
                        BEGIN 0;
                        yyparse();
                        _here;
                    }

<InText>.           {
                        _here;
                        TextCurLine[ TextCurIndex ] = *yytext;
                        _if( TextCurIndex < 4095 )

                            ++TextCurIndex;

                        _endif
                        _here;
                    }

<InText>\n          {
                        struct TextList *temp;

                        _here;
                        ++LineCnt;
                        ++TotalLines;
                        TextCurLine[ TextCurIndex ] = '\0';
                        temp = malloc2( sizeof( struct TextList ));
                        temp->next = NULL;
                        temp->line = hlastrdup2( TextCurLine );

                        _if( TextTail == NULL )

                            TextHead = temp;
                            TextTail = temp;
                            
                        _else

                            TextTail->next = temp;
                            TextTail = temp;

                        _endif
                        TextCurIndex = 0;
                        _here;
                    }

<InText>{p_endtext} {
                        struct TextList *temp;
                        int cnt = 0;
                        int i;

                        _here;

                        /*
                        ** Grab the text up to, but not including
                        ** the "#endtext" directive:
                        */

                        TextCurLine[ TextCurIndex ] = '\0';
                        temp = malloc2( sizeof( struct TextList ));
                        temp->next = NULL;
                        temp->line = hlastrdup2( TextCurLine );

                        _if( TextTail == NULL )

                            TextHead = temp;
                            TextTail = temp;
                            
                        _else


                            TextTail->next = temp;
                            TextTail = temp;

                        _endif
                        TextCurIndex = 0;

                        /*
                        ** Count the number of lines
                        ** in the text block.
                        */

                        temp = TextHead;
                        _while( temp != NULL )

                            temp = temp->next;
                            ++cnt;

                        _endwhile

                        /*
                        ** Construct the $<v>$ object for the parser.
                        ** Begin by clearing out unimportant fields.
                        */


                        yylval->v.Name =  "";
                        yylval->v.TrueName = yylval->v.Name;
                        yylval->v.StaticName = NULL;
                        yylval->v.Offset = 0;
                        yylval->v.Base = NULL;
                        yylval->v.Fields = NULL;
                        yylval->v.FieldCnt = 0; 

                        /*
                        ** For an yylval constant, here are the important
                        ** assignments.
                        */

                        yylval->v.pType = tArray;
                        yylval->v.SymClass = cConstant;
                        yylval->v.Type = &string_ste;
                        yylval->v.Arity = 1;
                        yylval->v.Dimensions = malloc2( sizeof( int ));
                        yylval->v.Dimensions[0] = cnt;
                        yylval->v.NumElements = cnt;
                        yylval->v.u.ArrayOfValues = malloc2( cnt * sizeofSymNode );
                        yylval->v.ObjectSize = cnt * sizeof( char* );

                        _for( i=0, i<cnt, ++i )

                            yylval->v.u.ArrayOfValues[i].Name = hlastrdup2( "" );
                            yylval->v.u.ArrayOfValues[i].TrueName = hlastrdup2( "" );
                            yylval->v.u.ArrayOfValues[i].SymClass = cConstant;
                            yylval->v.u.ArrayOfValues[i].StaticName = NULL;
                            yylval->v.u.ArrayOfValues[i].Base = NULL;
                            yylval->v.u.ArrayOfValues[i].Fields = NULL;
                            yylval->v.u.ArrayOfValues[i].FieldCnt = 0;
                            yylval->v.u.ArrayOfValues[i].pType = tString;
                            yylval->v.u.ArrayOfValues[i].Type = &string_ste;
                            yylval->v.u.ArrayOfValues[i].Arity = 0;
                            yylval->v.u.ArrayOfValues[i].Dimensions = NULL;
                            yylval->v.u.ArrayOfValues[i].NumElements = 0;

                            yylval->v.u.ArrayOfValues[i].u.strval = 
                                TextHead->line;
                                
                            temp = TextHead->next;
                            free2( vss TextHead );
                            TextHead = temp;

                        _endfor
                        BEGIN 0;
                        _here;
                        _return endtextTkn;
                    }






 /*
 ** Code to handle the #STRING..#ENDSTRING directives goes here.
 */

{p_string}          {   
                        _here;
						stringBodySize = 256;
						stringBodyIndex = 0;
						stringBody = malloc2( 256 );
                        BEGIN 0;
						
						// Go process the string name parameter:
						
                        PushBackStr( "\xE0" );
                        yyparse();
						
                        _here;
                    }

<InString>.         {
                        _here;
						stringBody[ stringBodyIndex ] = *yytext;
						++stringBodyIndex;
						_if( stringBodyIndex >= stringBodySize )
						
							stringBodySize += stringBodySize;
							stringBody = realloc( stringBody, stringBodySize );
							
						_endif
                        _here;
                    }

<InString>\n        {
                        _here;
                        ++LineCnt;
                        ++TotalLines;
						stringBody[ stringBodyIndex ] = *yytext;
						++stringBodyIndex;
						_if( stringBodyIndex >= stringBodySize )
						
							stringBodySize += stringBodySize;
							stringBody = realloc( stringBody, stringBodySize );
							assert( stringBody != NULL );
							
						_endif
                        _here;
                    }

<InString>{p_endstring} {
                        struct TextList *temp;
                        int cnt = 0;
                        int i;

                        _here;
						stringBody[ stringBodyIndex ] = '\0';


                        /*
                        ** Construct the $<v>$ object for the parser.
                        ** Begin by clearing out unimportant fields.
                        */


                        yylval->v.Name =  hlastrdup("");
                        yylval->v.TrueName = yylval->v.Name;
                        yylval->v.StaticName = NULL;
                        yylval->v.Offset = 0;
                        yylval->v.Base = NULL;
                        yylval->v.Fields = NULL;
                        yylval->v.FieldCnt = 0; 

                        /*
                        ** For an yylval constant, here are the important
                        ** assignments.
                        */

                        yylval->v.pType = tString;
                        yylval->v.SymClass = cConstant;
                        yylval->v.Type = &string_ste;
                        yylval->v.Arity = 0;
                        yylval->v.Dimensions = NULL;
                        yylval->v.NumElements = 0;
                        yylval->v.u.strval = 
							realloc( stringBody, stringBodyIndex+2 );
							
                        yylval->v.ObjectSize = cnt * sizeof( char* );
                        BEGIN 0;
                        _here;
                        _return endstringTkn;
                    }







 /*
 ** Code to handle the #MATCH..#ENDMATCH directives goes here.
 */

{p_match}          {   
                        _here;
						matchBodySize = 256;
						matchBodyIndex = 0;
						matchBody = malloc2( 256 );
                        BEGIN 0;
						
						// Go process the string name parameter:
						
                        PushBackStr( "\xDF" );
                        yyparse();
						
                        _here;
                    }

<InMatch>.          {
                        _here;
						matchBody[ matchBodyIndex ] = *yytext;
						++matchBodyIndex;
						_if( matchBodyIndex >= matchBodySize )
						
							matchBodySize += matchBodySize;
							matchBody = realloc( matchBody, matchBodySize );
							
						_endif
                        _here;
                    }

<InMatch>\n         {
                        _here;
                        ++LineCnt;
                        ++TotalLines;
						matchBody[ matchBodyIndex ] = *yytext;
						++matchBodyIndex;
						_if( matchBodyIndex >= matchBodySize )
						
							matchBodySize += matchBodySize;
							matchBody = realloc( matchBody, matchBodySize );
							assert( matchBody != NULL );
							
						_endif
                        _here;
                    }

<InMatch>{p_endmatch} {
                        struct TextList *temp;
                        int cnt = 0;
                        int i;

                        _here;
						matchBody[ matchBodyIndex ] = '\0';


                        /*
                        ** Construct the $<v>$ object for the parser.
                        ** Begin by clearing out unimportant fields.
                        */


                        yylval->v.Name =  hlastrdup("");
                        yylval->v.TrueName = yylval->v.Name;
                        yylval->v.StaticName = NULL;
                        yylval->v.Offset = 0;
                        yylval->v.Base = NULL;
                        yylval->v.Fields = NULL;
                        yylval->v.FieldCnt = 0; 

                        /*
                        ** For an yylval constant, here are the important
                        ** assignments.
                        */

                        yylval->v.pType = tString;
                        yylval->v.SymClass = cConstant;
                        yylval->v.Type = &string_ste;
                        yylval->v.Arity = 0;
                        yylval->v.Dimensions = NULL;
                        yylval->v.NumElements = 0;
                        yylval->v.u.strval = matchBody;
							
                        yylval->v.ObjectSize = cnt * sizeof( char* );
                        BEGIN 0;
                        _here;
                        _return endmatchTkn;
                    }


 /*
 ** Code to handle the #asm and #endasm directives goes here.
 */
 
{p_asm}         { 
                    _here; 
                    BEGIN InASM;        
                }

<InASM><<EOF>>  {
                    _returnif( BufSP < 0 ) -1; 
                    deleteSourceBuf(); 
                }

<InASM>\xff     {
                    EndMacroExpansion();
                }




  /*
  ** Emit the text between #asm and #endasm:
  */

<InASM>.        	{ asmPutc( *yytext );  }
<InASM>\n       	{ asmPuts( "\n" ); ++LineCnt; ++TotalLines; }
<InASM>{p_endasm}   { _here; BEGIN 0; }



 /*
 ** Handle the "#emit" directive here.
 */

{p_emit}        {

                /*
                ** Call the parser to read a string constant
                ** expression surrounded by parentheses.  The
                ** return value comes back in d1ceReturnVal
                */

                _here;
                PushBackStr( "\xFA" );
                yyparse();

                _if( !IsStr( d1ceReturnVal.v.pType ))

                    yyerror( "#emit requires a string expression" );

                _else

                    asmPuts( d1ceReturnVal.v.u.strval );
					asmPuts( "\n" );

                _endif
                FreeValue( &d1ceReturnVal );
                _here;
            }




 
 /* "Normal" lexical analyzer stuff.
 **
 ** These are the normal terminal symbols that HLA uses:
 */


"*"             { _return '*';          }
"/"             { _return '/';          }
"+"             { _return '+';          }
"-"             { _return '-';          }
"("             { _return '(';          }
")"             { _return ')';          }
"{"             { _return '{';          }
"}"             { _return '}';          }
"["             { _return '[';          }
"]"             { _return ']';          }
"<"             { _return '<';          }
">"             { _return '>';          }
":"             { _return ':';          }
";"             { _return ';';          }
","             { _return ',';          }
"."             { _return '.';          }
"="             { _return '=';          }
"=="            { _return '=';          }
"@"             { _return '@';          }
"&"             { _return '&';          }
"|"             { _return '|';          }
"^"             { _return '^';          }
"!"             { _return '!';          }

"&&"            { _return landTkn;      }
"||"            { _return lorTkn;       }
"<<"            { _return shlopTkn;     }
">>"            { _return shropTkn;     }
"<="            { _return leTkn;        }
">="            { _return geTkn;        }
"<>"            { _return neTkn;        }
"!="            { _return neTkn;        }
"::"            { _return coloncolonTkn;}
":="            { _return assignTkn;    }
"+="            { _return addassignTkn; }
"-="            { _return subassignTkn; }
".."            { _return DotDot;       }
"#{"            { _return stmtsTkn;     }
"}#"            { _return endstmtsTkn;  }
"##"            {
                    _here;
                    _if( MacroSP >= 0 )
                     
                        yylval->v.u.unsval = MacroStack[ MacroSP ].cnt;

                    _else

                        yylval->v.u.unsval = 0;

                    _endif
                    _here;
                    _return intconst;
                }



 /*
 ** Operator keywords
 */

{_dup}                                  { testRW(dupTkn);       }
{_mod}                                  { testRW(modTkn);       }
~dup                                    { _return dupTkn;       }
~mod                                    { _return modTkn;       }


 /*
 ** Program structure keywords
 */

{_begin}                                { testRW( beginTkn );       }
{_end}                                  { testRW( endTkn );         }
{_proc}		                            { testRW( procTkn );   		}
{_endproc}		                        { testRW( endprocTkn );   	}
{_procedure}                            { testRW( procedureTkn );   }
{_iterator}                             { testRW( iteratorTkn );    }
{_method}                               { testRW( methodTkn );      }
{_program}                              { testRW( programTkn );     }
{_unit}                                 { testRW( unitTkn );        }

~begin                                  { _return beginTkn;         }
~end                                    { _return endTkn;           }
~proc		                            { _return procTkn;     		}
~endproc		                        { _return endprocTkn;     	}
~procedure                              { _return procedureTkn;     }
~iterator                               { _return iteratorTkn;      }
~method                                 { _return methodTkn;        }
~program                                { _return programTkn;       }
~unit                                   { _return unitTkn;          }

{p_macro}                               { 
                                            _here;
                                            PushBackStr( "\xe7\xe6" );
                                            yyparse();
                                            _here;
                                        }
                                        
\xE7                                    {
                                            _here;
                                            _return DoMacroDclTkn;
                                        }
\xE6                                    {   _return macroTkn; }
    
{p_terminator}                          { yyerror( "Unexpected #terminator" );  }
{p_keyword}                             { yyerror( "Unexpected #keyword" ); }
{p_endmacro}                            { yyerror( "Unexpected #endmacro" ); }



{p_regex}                               { 
                                            _here;
                                            PushBackStr( "\xe5\xe4" );
                                            yyparse();
                                            _here;
                                        }
                                        
\xE5                                    {
                                            _here;
                                            _return DoRegexDclTkn;
                                        }
\xE4                                    {   _return regexMacroTkn; }

{p_endregex}                            { yyerror( "Unexpected #endregex" ); }
{p_return}								{ _return regexReturnTkn; }    

 /*
 ** Declaration keywords
 */

{_label}                                { testRW( labelTkn );           }
{_endlabel}                             { testRW( endlabelTkn );        }
{_const}                                { testRW( constTkn );           }
{_endconst}                             { testRW( endconstTkn );        }
{_val}                                  { testRW( valTkn );             }
{_endval}                               { testRW( endvalTkn );          }
{_type}                                 { testRW( typeTkn );            }
{_endtype}                              { testRW( endtypeTkn );         }
{_align}                                { testRW( alignTkn );           }
{_var}                                  { testRW( varTkn );             }
{_endvar}                               { testRW( endvarTkn );          }
{_static}                               { testRW( staticTkn );          }
{_endstatic}                            { testRW( endstaticTkn );       }
{_storage}                              { testRW( uninitializedTkn );   }
{_endstorage}                           { testRW( endstorageTkn );      }
{_readonly}                             { testRW( readonlyTkn );        }
{_endreadonly}                          { testRW( endreadonlyTkn );     }
{_enum}                                 { testRW( enumTkn );            }
{_record}                               { testRW( recordTkn );          }
{_endrecord}                            { testRW( endrecordTkn );       }
{_union}                                { testRW( unionTkn );           }
{_endunion}                             { testRW( endunionTkn );        }
{_class}                                { testRW( classTkn );           }
{_endclass}                             { testRW( endclassTkn );        }
{_inherits}                             { testRW( inheritsTkn );        }
{_vmt}                                  { testRW( vmtTkn );             }
{_pointer}                              { testRW( pointerTkn );         }
{_to}                                   { testRW( toTkn );              }
{_downto}                               { testRW( downtoTkn );          }
{_external}                             { testRW( externalTkn );        }
{_abstract}                             { testRW( abstractTkn );        }
{_overloads}                            { testRW( overloadsTkn );       }
{_override}                             { testRW( overrideTkn );        }
{_overrides}                            { testRW( overridesTkn );       }
{_forward}                              { testRW( forwardTkn );         }
{_returns}                              { testRW( returnsTkn );         }
{_namespace}                            { testRW( namespaceTkn );       }
{_segment}                              { testRW( segmentTkn );         }

~{_label}                               { _return labelTkn;         }
~{_endlabel}                            { _return endlabelTkn;      }
~{_const}                               { _return constTkn;         }
~{_endconst}                            { _return endconstTkn;      }
~{_val}                                 { _return valTkn;           }
~{_endval}                              { _return endvalTkn;        }
~{_type}                                { _return typeTkn;          }
~{_endtype}                             { _return endtypeTkn;       }
~{_align}                               { _return alignTkn;         }
~{_var}                                 { _return varTkn;           }
~{_endvar}                              { _return endvarTkn;        }
~{_static}                              { _return staticTkn;        }
~{_endstatic}                           { _return endstaticTkn;     }
~{_storage}                             { _return uninitializedTkn; }
~{_endstorage}                          { _return endstorageTkn;    }
~{_readonly}                            { _return readonlyTkn;      }
~{_endreadonly}                         { _return endreadonlyTkn;   }
~{_enum}                                { _return enumTkn;          }
~{_record}                              { _return recordTkn;        }
~{_endrecord}                           { _return endrecordTkn;     }
~{_union}                               { _return unionTkn;         }
~{_endunion}                            { _return endunionTkn;      }
~{_class}                               { _return classTkn;         }
~{_endclass}                            { _return endclassTkn;      }
~{_inherits}                            { _return inheritsTkn;      }
~{_vmt}                                 { _return vmtTkn;           }
~{_pointer}                             { _return pointerTkn;       }
~{_to}                                  { _return toTkn;            }
~{_downto}                              { _return downtoTkn;        }
~{_external}                            { _return externalTkn;      }
~{_abstract}                            { _return abstractTkn;      }
~{_overloads}                           { _return overloadsTkn;     }
~{_override}                            { _return overrideTkn;      }
~{_overrides}                           { _return overridesTkn;     }
~{_forward}                             { _return forwardTkn;       }
~{_returns}                             { _return returnsTkn;       }
~{_namespace}                           { _return namespaceTkn;     }
~{_segment}                             { _return segmentTkn;       }

{a_fast}                                { _return fastTkn;          }
{a_noframe}                             { _return noframeTkn;       }
{a_frame}                               { _return frameTkn;         }
{a_nodisplay}                           { _return nodisplayTkn;     }
{a_display}                             { _return displayTkn;       }
{a_noalignstack}                        { _return noalignstkTkn;    }
{a_alignstack}                          { _return alignstkTkn;      }
{a_nostackalign}                        { _return noalignstkTkn;    }
{a_stackalign}                          { _return alignstkTkn;      }
{a_align}                               { _return alignprocTkn;     }
{a_nostorage}                           { _return nostorageTkn;     }
{a_use}                                 { _return useTkn;           }
{a_enter}                               { _return useenterTkn;      }
{a_noenter}                             { _return noenterTkn;       }
{a_leave}                               { _return useleaveTkn;      }
{a_noleave}                             { _return noleaveTkn;       }
{a_volatile}                            { _return volatileTkn;      }
{a_pascal}                              { _return pascalTkn;        }
{a_cdecl}                               { _return cdeclTkn;         }
{a_stdcall}                             { _return stdcallTkn;       }
{a_returns}                             { _return atreturnsTkn;     }
{a_forward}                             { _return forwardTkn;       }
{a_external}                            { _return externalTkn;      }
{a_abstract}                            { _return abstractTkn;      }
{a_here}                                { _return hereTkn;          }
{a_label}								{ _return atlabelTkn;		}

 /*
 ** Parameter passing mechanism keywords
 */

{_name}                                 { testRW( nameTkn );        }
{_result}                               { testRW( resultTkn );      }
{_valres}                               { testRW( valresTkn );      }
{_lazy}                                 { testRW( lazyTkn );        }
{_thunk}                                { testRW( thunkTkn );       }

~{_name}                                { _return nameTkn;          }
~{_result}                              { _return resultTkn;        }
~{_valres}                              { _return valresTkn;        }
~{_lazy}                                { _return lazyTkn;          }
~{_thunk}                               { _return thunkTkn;         }


 /*
 ** NULL is the reserved word that corresponds to the NULL pointer.
 */
 
{_null}     { testRW( nullTkn ); }
~{_null}    { _return nullTkn;   }



 /*
 ** High level language tokens.
 */

{_jf}              { testRW( jfTkn );          }
{_jt}              { testRW( jtTkn );          }
{_if}              { testRW( ifTkn );          }
{_then}            { testRW( thenTkn );        }
{_elseif}          { testRW( elseifTkn );      }
{_else}            { testRW( elseTkn );        }
{_endif}           { testRW( endifTkn );       }
{_switch}          { testRW( switchTkn );      }
{_case}            { testRW( caseTkn );        }
{_default}         { testRW( defaultTkn );     }
{_endswitch}       { testRW( endswitchTkn );   }
{_while}           { testRW( whileTkn );       }
{_do}              { testRW( doTkn );          }
{_endwhile}        { testRW( endwhileTkn );    }
{_welse}           { testRW( welseTkn );       }
{_repeat}          { testRW( repeatTkn );      }
{_until}           { testRW( untilTkn );       }
{_for}             { testRW( forTkn );         }
{_forever}         { testRW( foreverTkn );     }
{_foreach}         { testRW( foreachTkn );     }
{_endfor}          { testRW( endforTkn );      }
{_felse}           { testRW( felseTkn );       }
{_break}           { testRW( breakTkn );       }
{_breakif}         { testRW( breakifTkn );     }
{_continue}        { testRW( continueTkn );    }
{_continueif}      { testRW( continueifTkn );  }
{_exit}            { testRW( exitTkn );        }
{_exitif}          { testRW( exitifTkn );      }
{_try}             { testRW( tryTkn );         }
{_unprotected}     { testRW( unprotectedTkn ); }
{_exception}       { testRW( exceptionTkn );   }
{_anyexception}    { testRW( anyexceptionTkn );}
{_endtry}          { testRW( endtryTkn );      }
{_raise}           { testRW( raiseTkn );       }




~{_jf}            { _return jfTkn;            }
~{_jt}            { _return jtTkn;            }
~{_if}            { _return ifTkn;            }
~{_then}          { _return thenTkn;          }
~{_elseif}        { _return elseifTkn;        }
~{_else}          { _return elseTkn;          }
~{_endif}         { _return endifTkn;         }
~{_switch}        { _return switchTkn;        }
~{_case}          { _return caseTkn;          }
~{_default}       { _return defaultTkn;       }
~{_endswitch}     { _return endswitchTkn;     }
~{_while}         { _return whileTkn;         }
~{_do}            { _return doTkn;            }
~{_endwhile}      { _return endwhileTkn;      }
~{_welse}         { _return welseTkn;         }
~{_repeat}        { _return repeatTkn;        }
~{_until}         { _return untilTkn;         }
~{_for}           { _return forTkn;           }
~{_forever}       { _return foreverTkn;       }
~{_foreach}       { _return foreachTkn;       }
~{_endfor}        { _return endforTkn;        }
~{_felse}         { _return felseTkn;         }
~{_break}         { _return breakTkn;         }
~{_breakif}       { _return breakifTkn;       }
~{_continue}      { _return continueTkn;      }
~{_continueif}    { _return continueifTkn;    }
~{_exit}          { _return exitTkn;          }
~{_exitif}        { _return exitifTkn;        }
~{_try}           { _return tryTkn;           }
~{_unprotected}   { _return unprotectedTkn;   }
~{_exception}     { _return exceptionTkn;     }
~{_anyexception}  { _return anyexceptionTkn;  }
~{_endtry}        { _return endtryTkn;        }
~{_raise}         { _return raiseTkn;         }




                    

 /*
 ** Data type reserved words
 */

<UnprocessedID>{_byte} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }
    
<UnprocessedID>{_word} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_dword} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_qword} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_tbyte} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }


<UnprocessedID>{_lword} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_boolean} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_int8} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_int16} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_int32} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_int64} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_int128} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_char} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_wchar} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_real32} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_real64} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_real80} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_real128} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_uns8} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_uns16} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_uns32} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_uns64} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_uns128} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_string} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_wstring} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }

<UnprocessedID>{_cset} {
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
    }





{_byte}            {
                    _here;
                    yylval->v.Type= &byte_ste;
                    yylval->v.pType = tByte; 
                    _here;
                    testRW( byteTkn );      
                }

~{_byte}        {
                    _here;
                    yylval->v.Type= &byte_ste;
                    yylval->v.pType = tByte; 
                    _here;
                    _return byteTkn;        
                }

{a_byte}        {
                    _here;
                    _return atbyteTkn;      
                }

{_word}         { 
                    _here;
                    yylval->v.Type= &word_ste;
                    yylval->v.pType = tWord; 
                    _here;
                    testRW( wordTkn );      
                }
                
~{_word}        { 
                    _here;
                    yylval->v.Type= &word_ste;
                    yylval->v.pType = tWord; 
                    _here;
                    _return wordTkn;        
                }
                
{a_word}        {
                    _here;
                    _return atwordTkn;      
                }

{_dword}        { 
                    _here;
                    yylval->v.Type= &dword_ste;
                    yylval->v.pType = tDWord; 
                    _here;
                    testRW( dwordTkn ); 
                }

~{_dword}       { 
                    _here;
                    yylval->v.Type= &dword_ste;
                    yylval->v.pType = tDWord; 
                    _here;
                    _return dwordTkn;   
                }

{a_dword}       { 
                    _here;
                    _return atdwordTkn; 
                }

{_qword}        { 
                    _here;
                    yylval->v.Type= &qword_ste;
                    yylval->v.pType = tQWord; 
                    _here;
                    testRW( qwordTkn ); 
                }

~{_qword}       { 
                    _here;
                    yylval->v.Type= &qword_ste;
                    yylval->v.pType = tQWord; 
                    _here;
                    _return qwordTkn;   
                }

{a_qword}       { 
                    _here;
                    _return atqwordTkn; 
                }

{_tbyte}        { 
                    _here;
                    yylval->v.Type= &tbyte_ste;
                    yylval->v.pType = tTByte; 
                    _here;
                    testRW( tbyteTkn ); 
                }

~{_tbyte}       { 
                    _here;
                    yylval->v.Type= &tbyte_ste;
                    yylval->v.pType = tTByte; 
                    _here;
                    _return tbyteTkn;   
                }

{_lword}        { 
                    _here;
                    yylval->v.Type= &lword_ste;
                    yylval->v.pType = tLWord; 
                    _here;
                    testRW( lwordTkn );   
                }


~{_lword}       { 
                    _here;
                    yylval->v.Type= &lword_ste;
                    yylval->v.pType = tLWord; 
                    _here;
                    _return lwordTkn;   
                }


{a_lword}       { 
                    _here;
                    _return atlwordTkn; 
                }

{_boolean}      { 
                    _here;
                    yylval->v.Type= &boolean_ste;
                    yylval->v.pType = tBoolean; 
                    _here;
                    testRW( booleanTkn );   
                }

~{_boolean}     { 
                    _here;
                    yylval->v.Type= &boolean_ste;
                    yylval->v.pType = tBoolean; 
                    _here;
                    _return booleanTkn; 
                }


{_int8}         { 
                    _here;
                    yylval->v.Type= &int8_ste;
                    yylval->v.pType = tInt8; 
                    _here;
                    testRW( int8Tkn );          
                }

~{_int8}        { 
                    _here;
                    yylval->v.Type= &int8_ste;
                    yylval->v.pType = tInt8; 
                    _here;
                    _return int8Tkn;            
                }

{a_int8}        { 
                    _here;
                    _return atint8Tkn;  
                }

{_int16}        { 
                    _here;
                    yylval->v.Type= &int16_ste;
                    yylval->v.pType = tInt16; 
                    _here;
                    testRW( int16Tkn ); 
                }

~{_int16}       { 
                    _here;
                    yylval->v.Type= &int16_ste;
                    yylval->v.pType = tInt16; 
                    _here;
                    _return int16Tkn;   
                }

{a_int16}       { 
                    _here;
                    _return atint16Tkn; 
                }

{_int32}        { 
                    _here;
                    yylval->v.Type= &int32_ste;
                    yylval->v.pType = tInt32; 
                    _here;
                    testRW( int32Tkn ); 
                }

~{_int32}       { 
                    _here;
                    yylval->v.Type= &int32_ste;
                    yylval->v.pType = tInt32; 
                    _here;
                    _return int32Tkn;   
                }

{a_int32}      { 
                    _here;
                    _return atint32Tkn; 
                }

{_int64}        { 
                    _here;
                    yylval->v.Type= &int64_ste;
                    yylval->v.pType = tInt64; 
                    _here;
                    testRW( int64Tkn ); 
                }

~{_int64}       { 
                    _here;
                    yylval->v.Type= &int64_ste;
                    yylval->v.pType = tInt64; 
                    _here;
                    _return int64Tkn;   
                }

{a_int64}       { 
                    _here;
                    _return atint64Tkn; 
                }

{_int128}       { 
                    _here;
                    yylval->v.Type= &int128_ste;
                    yylval->v.pType = tInt128; 
                    _here;
                    testRW( int128Tkn );    
                }

~{_int128}      { 
                    _here;
                    yylval->v.Type= &int128_ste;
                    yylval->v.pType = tInt128; 
                    _here;
                    _return int128Tkn;  
                }


{a_int128}     { 
                    _here;
                    _return atint128Tkn;    
                }

{_char}         { 
                    _here;
                    yylval->v.Type= &char_ste;
                    yylval->v.pType = tChar; 
                    _here;
                    testRW( charTkn );      
                }

~{_char}        { 
                    _here;
                    yylval->v.Type= &char_ste;
                    yylval->v.pType = tChar; 
                    _here;
                    _return charTkn;        
                }

{a_char}        { 
                    _here;
                    _return atcharTkn;  
                }

{_wchar}        { 
                    _here;
                    yylval->v.Type= &wchar_ste;
                    yylval->v.pType = tWChar; 
                    _here;
                    testRW( wcharTkn );     
                }

~{_wchar}       { 
                    _here;
                    yylval->v.Type= &wchar_ste;
                    yylval->v.pType = tWChar; 
                    _here;
                    _return wcharTkn;       
                }

{a_wchar}       { 
                    _here;
                    _return atwcharTkn; 
                }

{_real32}       { 
                    _here;
                    yylval->v.Type= &real32_ste;
                    yylval->v.pType = tReal32; 
                    _here;
                    testRW( real32Tkn );    
                }

~{_real32}      { 
                    _here;
                    yylval->v.Type= &real32_ste;
                    yylval->v.pType = tReal32; 
                    _here;
                    _return real32Tkn;  
                }

{a_real32}      { 
                    _here;
                    _return atreal32Tkn;    
                }

{_real64}       { 
                    _here;
                    yylval->v.Type= &real64_ste;
                    yylval->v.pType = tReal64; 
                    _here;
                    testRW( real64Tkn );    
                }

~{_real64}      { 
                    _here;
                    yylval->v.Type= &real64_ste;
                    yylval->v.pType = tReal64; 
                    _here;
                    _return real64Tkn;  
                }

{a_real64}      { 
                    _here;
                    _return atreal64Tkn;    
                }

{_real80}       { 
                    _here;
                    yylval->v.Type= &real80_ste;
                    yylval->v.pType = tReal80; 
                    _here;
                    testRW( real80Tkn );    
                }

~{_real80}      { 
                    _here;
                    yylval->v.Type= &real80_ste;
                    yylval->v.pType = tReal80; 
                    _here;
                    _return real80Tkn;  
                }

{a_real80}      { 
                    _here;
                    _return atreal80Tkn;    
                }
                
{_real128}      { 
                    _here;
                    yylval->v.Type= &real128_ste;
                    yylval->v.pType = tReal128; 
                    _here;
                    testRW( real128Tkn );   
                }

                
~{_real128}     { 
                    _here;
                    yylval->v.Type= &real128_ste;
                    yylval->v.pType = tReal128; 
                    _here;
                    _return real128Tkn; 
                }

                

{_uns8}         { 
                    _here;
                    yylval->v.Type= &uns8_ste;
                    yylval->v.pType = tUns8; 
                    _here;
                    testRW( uns8Tkn );
                }
                
~{_uns8}        { 
                    _here;
                    yylval->v.Type= &uns8_ste;
                    yylval->v.pType = tUns8; 
                    _here;
                    _return uns8Tkn;    
                }
                
{a_uns8}        { 
                    _here;
                    _return atuns8Tkn;  
                }

{_uns16}        { 
                    _here;
                    yylval->v.Type= &uns16_ste;
                    yylval->v.pType = tUns16; 
                    _here;
                    testRW( uns16Tkn );
                }
                
~{_uns16}       { 
                    _here;
                    yylval->v.Type= &uns16_ste;
                    yylval->v.pType = tUns16; 
                    _here;
                    _return uns16Tkn;   
                }
                
{a_uns16}       { 
                    _here;
                    _return atuns16Tkn; 
                }

{_uns32}        { 
                    _here;
                    yylval->v.Type= &uns32_ste;
                    yylval->v.pType = tUns32; 
                    _here;
                    testRW( uns32Tkn ); 
                }
                
~{_uns32}       { 
                    _here;
                    yylval->v.Type= &uns32_ste;
                    yylval->v.pType = tUns32; 
                    _here;
                    _return uns32Tkn;   
                }
                
{a_uns32}       { 
                    _here;
                    _return atuns32Tkn; 
                }

{_uns64}        { 
                    _here;
                    yylval->v.Type= &uns64_ste;
                    yylval->v.pType = tUns64; 
                    _here;
                    testRW( uns64Tkn ); 
                }
                
~{_uns64}       { 
                    _here;
                    yylval->v.Type= &uns64_ste;
                    yylval->v.pType = tUns64; 
                    _here;
                    _return uns64Tkn;   
                }
                
{a_uns64}       { 
                    _here;
                    _return atuns64Tkn; 
                }

{_uns128}       { 
                    _here;
                    yylval->v.Type= &uns128_ste;
                    yylval->v.pType = tUns128; 
                    _here;
                    testRW( uns128Tkn );    
                }
                
~{_uns128}      { 
                    _here;
                    yylval->v.Type= &uns128_ste;
                    yylval->v.pType = tUns128; 
                    _here;
                    _return uns128Tkn;  
                }
                
{a_uns128}      { 
                    _here;
                    _return atuns128Tkn;    
                }

{_string}       { 
                    _here;
                    yylval->v.Type= &string_ste;
                    yylval->v.pType = tString; 
                    _here;
                    testRW( stringTkn );    
                }
                
~{_string}      { 
                    _here;
                    yylval->v.Type= &string_ste;
                    yylval->v.pType = tString; 
                    _here;
                    _return stringTkn;  
                }
                
{a_string}      { 
                    _here;
                    _return atstringTkn;    
                }

{_zstring}      { 
                    _here;
                    yylval->v.Type= &zstring_ste;
                    yylval->v.pType = tZString; 
                    _here;
                    testRW( zstringTkn );   
                }
                
~{_zstring}     { 
                    _here;
                    yylval->v.Type= &zstring_ste;
                    yylval->v.pType = tZString; 
                    _here;
                    _return zstringTkn; 
                }
                
{a_zstring}     { 
                    _here;
                    _return atstringTkn;    
                }

{_wstring}      { 
                    _here;
                    yylval->v.Type= &wstring_ste;
                    yylval->v.pType = tWString; 
                    _here;
                    testRW( wstringTkn );   
                }
                
~{_wstring}     { 
                    _here;
                    yylval->v.Type= &wstring_ste;
                    yylval->v.pType = tWString; 
                    _here;
                    _return wstringTkn; 
                }
                
{a_wstring}     { 
                    _here;
                    _return atwstringTkn;   
                }

{_regex}        { 
                    _here;
                    yylval->v.Type= &regex_ste;
                    yylval->v.pType = tRegex; 
                    _here;
                    testRW( regexTkn );     
                }
                
~{_regex}        { 
                    _here;
                    yylval->v.Type= &regex_ste;
                    yylval->v.pType = tRegex; 
                    _here;
                    _return regexTkn;       
                }
                
{_cset}         { 
                    _here;
                    yylval->v.Type= &cset_ste;
                    yylval->v.pType = tCset; 
                    _here;
                    testRW( csetTkn );      
                }
                
~{_cset}        { 
                    _here;
                    yylval->v.Type= &cset_ste;
                    yylval->v.pType = tCset; 
                    _here;
                    _return csetTkn;        
                }
                
{a_cset}        { 
                    _here;
                    _return atcsetTkn;  
                }

{a_pointer}     { 
                    _here;
                    _return atpointerTkn;   
                }

{_text}         {
                    _here;
                    yylval->v.Type= &text_ste;
                    yylval->v.pType = tText; 
                    _here;
                    testRW( textTkn );      
                }

~{_text}        {
                    _here;
                    yylval->v.Type= &text_ste;
                    yylval->v.pType = tText; 
                    _here;
                    _return textTkn;        
                }

 /*
 ** Machine Registers
 */

 /* FPU registers */
 
{_st0}             { testRW( st0Tkn ); }
{_st1}             { testRW( st1Tkn ); }
{_st2}             { testRW( st2Tkn ); }
{_st3}             { testRW( st3Tkn ); }
{_st4}             { testRW( st4Tkn ); }
{_st5}             { testRW( st5Tkn ); }
{_st6}             { testRW( st6Tkn ); }
{_st7}             { testRW( st7Tkn ); }

~{_st0}            { _return st0Tkn;   }
~{_st1}            { _return st1Tkn;   }
~{_st2}            { _return st2Tkn;   }
~{_st3}            { _return st3Tkn;   }
~{_st4}            { _return st4Tkn;   }
~{_st5}            { _return st5Tkn;   }
~{_st6}            { _return st6Tkn;   }
~{_st7}            { _return st7Tkn;   }

 /* MMX Registers */
 
{_mm0}             { testRW( mm0Tkn ); }
{_mm1}             { testRW( mm1Tkn ); }
{_mm2}             { testRW( mm2Tkn ); }
{_mm3}             { testRW( mm3Tkn ); }
{_mm4}             { testRW( mm4Tkn ); }
{_mm5}             { testRW( mm5Tkn ); }
{_mm6}             { testRW( mm6Tkn ); }
{_mm7}             { testRW( mm7Tkn ); }

~{_mm0}            { _return mm0Tkn;   }
~{_mm1}            { _return mm1Tkn;   }
~{_mm2}            { _return mm2Tkn;   }
~{_mm3}            { _return mm3Tkn;   }
~{_mm4}            { _return mm4Tkn;   }
~{_mm5}            { _return mm5Tkn;   }
~{_mm6}            { _return mm6Tkn;   }
~{_mm7}            { _return mm7Tkn;   }


 /* SIMD Registers */
 
{_xmm0}            { testRW( xmm0Tkn );    }
{_xmm1}            { testRW( xmm1Tkn );    }
{_xmm2}            { testRW( xmm2Tkn );    }
{_xmm3}            { testRW( xmm3Tkn );    }
{_xmm4}            { testRW( xmm4Tkn );    }
{_xmm5}            { testRW( xmm5Tkn );    }
{_xmm6}            { testRW( xmm6Tkn );    }
{_xmm7}            { testRW( xmm7Tkn );    }

~{_xmm0}           { _return xmm0Tkn;      }
~{_xmm1}           { _return xmm1Tkn;      }
~{_xmm2}           { _return xmm2Tkn;      }
~{_xmm3}           { _return xmm3Tkn;      }
~{_xmm4}           { _return xmm4Tkn;      }
~{_xmm5}           { _return xmm5Tkn;      }
~{_xmm6}           { _return xmm6Tkn;      }
~{_xmm7}           { _return xmm7Tkn;      }

 /* Segment Registers   */
 
{_cseg}            { testRW( csTkn );  }
{_dseg}            { testRW( dsTkn );  }
{_eseg}            { testRW( esTkn );  }
{_fseg}            { testRW( fsTkn );  }
{_gseg}            { testRW( gsTkn );  }
{_sseg}            { testRW( ssTkn );  }

~{_cseg}           { _return csTkn;    }
~{_dseg}           { _return dsTkn;    }
~{_eseg}           { _return esTkn;    }
~{_fseg}           { _return fsTkn;    }
~{_gseg}           { _return gsTkn;    }
~{_sseg}           { _return ssTkn;    }

 /* Control and Debug Registers */
 
{_cr0}             { testRW( cr0Tkn ); }
{_cr1}             { testRW( cr1Tkn ); }
{_cr2}             { testRW( cr2Tkn ); }
{_cr3}             { testRW( cr3Tkn ); }
{_cr4}             { testRW( cr4Tkn ); }
{_cr5}             { testRW( cr5Tkn ); }
{_cr6}             { testRW( cr6Tkn ); }
{_cr7}             { testRW( cr7Tkn ); }

~{_cr0}            { _return cr0Tkn;   }
~{_cr1}            { _return cr1Tkn;   }
~{_cr2}            { _return cr2Tkn;   }
~{_cr3}            { _return cr3Tkn;   }
~{_cr4}            { _return cr4Tkn;   }
~{_cr5}            { _return cr5Tkn;   }
~{_cr6}            { _return cr6Tkn;   }
~{_cr7}            { _return cr7Tkn;   }

{_dr0}             { testRW( dr0Tkn ); }
{_dr1}             { testRW( dr1Tkn ); }
{_dr2}             { testRW( dr2Tkn ); }
{_dr3}             { testRW( dr3Tkn ); }
{_dr4}             { testRW( dr4Tkn ); }
{_dr5}             { testRW( dr5Tkn ); }
{_dr6}             { testRW( dr6Tkn ); }
{_dr7}             { testRW( dr7Tkn ); }

~{_dr0}            { _return dr0Tkn;   }
~{_dr1}            { _return dr1Tkn;   }
~{_dr2}            { _return dr2Tkn;   }
~{_dr3}            { _return dr3Tkn;   }
~{_dr4}            { _return dr4Tkn;   }
~{_dr5}            { _return dr5Tkn;   }
~{_dr6}            { _return dr6Tkn;   }
~{_dr7}            { _return dr7Tkn;   }



 /* Integer registers */

{_al}            { testRW( alTkn );      }
{_ah}            { testRW( ahTkn );      }
{_ax}            { testRW( axTkn );      }
{_eax}           { testRW( eaxTkn );     }
{_bl}            { testRW( blTkn );      }
{_bh}            { testRW( bhTkn );      }
{_bx}            { testRW( bxTkn );      }
{_ebx}           { testRW( ebxTkn );     }
{_cl}            { testRW( clTkn );      }
{_ch}            { testRW( chTkn );      }
{_cx}            { testRW( cxTkn );      }
{_ecx}           { testRW( ecxTkn );     }
{_dl}            { testRW( dlTkn );      }
{_dh}            { testRW( dhTkn );      }
{_dx}            { testRW( dxTkn );      }
{_edx}           { testRW( edxTkn );     }
{_si}            { testRW( siTkn );      }
{_esi}           { testRW( esiTkn );     }
{_di}            { testRW( diTkn );      }
{_edi}           { testRW( ediTkn );     }
{_bp}            { testRW( bpTkn );      }
{_ebp}           { testRW( ebpTkn );     }
{_sp}            { testRW( spTkn );      }
{_esp}           { testRW( espTkn );     }
{_dxax}          { testRW( dxaxTkn );    }
{_edxeax}        { testRW( edxeaxTkn );  }


~{_al}           { _return alTkn;    }
~{_ah}           { _return ahTkn;    }
~{_ax}           { _return axTkn;    }
~{_eax}          { _return eaxTkn;   }
~{_bl}           { _return blTkn;    }
~{_bh}           { _return bhTkn;    }
~{_bx}           { _return bxTkn;    }
~{_ebx}          { _return ebxTkn;   }
~{_cl}           { _return clTkn;    }
~{_ch}           { _return chTkn;    }
~{_cx}           { _return cxTkn;    }
~{_ecx}          { _return ecxTkn;   }
~{_dl}           { _return dlTkn;    }
~{_dh}           { _return dhTkn;    }
~{_dx}           { _return dxTkn;    }
~{_edx}          { _return edxTkn;   }
~{_si}           { _return siTkn;    }
~{_esi}          { _return esiTkn;   }
~{_di}           { _return diTkn;    }
~{_edi}          { _return ediTkn;   }
~{_bp}           { _return bpTkn;    }
~{_ebp}          { _return ebpTkn;   }
~{_sp}           { _return spTkn;    }
~{_esp}          { _return espTkn;   }
~{_dxax}         { _return dxaxTkn;  }
~{_edxeax}       { _return edxeaxTkn;}


 /*
 ** Flags and conditions
 */

{a_c}              { _return cTkn;     }
{a_nc}             { _return ncTkn;    }
{a_s}              { _return sTkn;     }
{a_ns}             { _return nsTkn;    }
{a_o}              { _return oTkn;     }
{a_no}             { _return noTkn;    }
{a_z}              { _return zTkn;     }
{a_nz}             { _return nzTkn;    }
{a_a}              { _return aTkn;     }
{a_na}             { _return naTkn;    }
{a_ae}             { _return aeTkn;    }
{a_nae}            { _return naeTkn;   }
{a_b}              { _return bTkn;     }
{a_nb}             { _return nbTkn;    }
{a_be}             { _return beTkn;    }
{a_nbe}            { _return nbeTkn;   }
{a_l}              { _return lTkn;     }
{a_nl}             { _return nlTkn;    }
{a_le}             { _return leTkn;    }
{a_nle}            { _return nleTkn;   }
{a_g}              { _return gTkn;     }
{a_ng}             { _return ngTkn;    }
{a_ge}             { _return geTkn;    }
{a_nge}            { _return ngeTkn;   }
{a_e}              { _return eTkn;     }
{a_ne}             { _return neTkn;    }
{a_pe}             { _return peTkn;    }
{a_po}             { _return poTkn;    }
{a_p}              { _return pTkn; }
{a_np}             { _return npTkn;    }


 /*
 ** Machine instructions
 */

{_aaa}              { testRW( aaaTkn );         }
{_aad}              { testRW( aadTkn );         }
{_aam}              { testRW( aamTkn );         }
{_aas}              { testRW( aasTkn );         }
{_adc}              { testRW( adcTkn );         }
{_lock__adc}        { testRW( lockadcTkn );     }
{_add}              { testRW( addTkn );         }
{_lock__add}        { testRW( lockaddTkn );     }
{_and}              { testRW( andTkn );         }
{_lock__and}        { testRW( lockandTkn );     }
{_arpl}             { testRW( arplTkn );        }
{_bound}            { testRW( boundTkn );       }
{_bsf}              { testRW( bsfTkn );         }
{_bsr}              { testRW( bsrTkn );         }
{_bswap}            { testRW( bswapTkn );       }
{_bt}               { testRW( btTkn );          }
{_btc}              { testRW( btcTkn );         }
{_lock__btc}        { testRW( lockbtcTkn );     }
{_btr}              { testRW( btrTkn );         }
{_lock__btr}        { testRW( lockbtrTkn );     }
{_bts}              { testRW( btsTkn );         }
{_lock__bts}        { testRW( lockbtsTkn );     }
{_call}             { testRW( callTkn );        }
{_cbw}              { testRW( cbwTkn );         }
{_cdq}              { testRW( cdqTkn );         }
{_clc}              { testRW( clcTkn );         }
{_cld}              { testRW( cldTkn );         }
{_cli}              { testRW( cliTkn );         }
{_clts}             { testRW( cltsTkn );        }
{_cmc}              { testRW( cmcTkn );         }


{_cmova}            { testRW( cmovnbeTkn );     }
{_cmovae}           { testRW( cmovnbTkn );      }
{_cmovb}            { testRW( cmovbTkn );       }
{_cmovbe}           { testRW( cmovbeTkn );      }
{_cmovc}            { testRW( cmovbTkn );       }
{_cmove}            { testRW( cmoveTkn );       }
{_cmovg}            { testRW( cmovnleTkn );     }
{_cmovge}           { testRW( cmovnlTkn );      }
{_cmovl}            { testRW( cmovlTkn );       }
{_cmovle}           { testRW( cmovleTkn );      }
{_cmovna}           { testRW( cmovbeTkn );      }
{_cmovnae}          { testRW( cmovbTkn );       }
{_cmovnb}           { testRW( cmovnbTkn );      }
{_cmovnbe}          { testRW( cmovnbeTkn );     }
{_cmovnc}           { testRW( cmovnbTkn );      }
{_cmovne}           { testRW( cmovneTkn );      }
{_cmovng}           { testRW( cmovleTkn );      }
{_cmovnge}          { testRW( cmovlTkn );       }
{_cmovnl}           { testRW( cmovnlTkn );      }
{_cmovnle}          { testRW( cmovnleTkn );     }
{_cmovno}           { testRW( cmovnoTkn );      }
{_cmovnp}           { testRW( cmovnpTkn );      }
{_cmovns}           { testRW( cmovnsTkn );      }
{_cmovnz}           { testRW( cmovneTkn );      }
{_cmovo}            { testRW( cmovoTkn );       }
{_cmovp}            { testRW( cmovpTkn );       }
{_cmovpe}           { testRW( cmovpTkn );       }
{_cmovpo}           { testRW( cmovnpTkn );      }
{_cmovs}            { testRW( cmovsTkn );       }
{_cmovz}            { testRW( cmoveTkn );       }

{_cmp}              { testRW( cmpTkn );         }
{_cmpsb}            { testRW( cmpsbTkn );       }
{_cmpsd}            { testRW( cmpsdTkn );       }
{_cmpsw}            { testRW( cmpswTkn );       }
{_cmpxchg}          { testRW( cmpxchgTkn );     }
{_lock__cmpxchg}    { testRW( lockcmpxchgTkn ); }
{_cmpxchg8b}        { testRW( cmpxchg8bTkn );   }
{_cpuid}            { testRW( cpuidTkn );       }
{_cwd}              { testRW( cwdTkn );         }
{_cwde}             { testRW( cwdeTkn );        }
{_daa}              { testRW( daaTkn );         }
{_das}              { testRW( dasTkn );         }
{_dec}              { testRW( decTkn );         }
{_lock__dec}        { testRW( lockdecTkn );     }
{_div}              { testRW( divTkn );         }
{_enter}            { testRW( enterTkn );       }
{_hlt}              { testRW( hltTkn );         }
{_idiv}             { testRW( idivTkn );        }
{_imod}             { testRW( imodTkn );        }
{_imul}             { testRW( imulTkn );        }
{_intmul}           { testRW( intmulTkn );      }
{_in}               { testRW( inTkn );          }
{_inc}              { testRW( incTkn );         }
{_lock__inc}        { testRW( lockincTkn );     }
{_insb}             { testRW( insbTkn );        }
{_insd}             { testRW( insdTkn );        }
{_insw}             { testRW( inswTkn );        }
{_int}              { testRW( intTkn );         }
{_into}             { testRW( intoTkn );        }
{_invd}             { testRW( invdTkn );        }
{_invlpg}           { testRW( invlpgTkn );      }
{_iret}             { testRW( iretTkn );        }
{_iretd}            { testRW( iretdTkn );       }
{_jcxz}             { testRW( jcxzTkn );        }
{_jecxz}            { testRW( jecxzTkn );       }
{_ja}               { testRW( jaTkn );          }
{_jae}              { testRW( jaeTkn );         }
{_jb}               { testRW( jbTkn );          }
{_jbe}              { testRW( jbeTkn );         }
{_jc}               { testRW( jcTkn );          }
{_je}               { testRW( jeTkn );          }
{_jg}               { testRW( jgTkn );          }
{_jge}              { testRW( jgeTkn );         }
{_jl}               { testRW( jlTkn );          }
{_jle}              { testRW( jleTkn );         }
{_jna}              { testRW( jnaTkn );         }
{_jnae}             { testRW( jnaeTkn );        }
{_jnb}              { testRW( jnbTkn );         }
{_jnbe}             { testRW( jnbeTkn );        }
{_jnc}              { testRW( jncTkn );         }
{_jne}              { testRW( jneTkn );         }
{_jng}              { testRW( jngTkn );         }
{_jnge}             { testRW( jngeTkn );        }
{_jnl}              { testRW( jnlTkn );         }
{_jnle}             { testRW( jnleTkn );        }
{_jno}              { testRW( jnoTkn );         }
{_jnp}              { testRW( jnpTkn );         }
{_jns}              { testRW( jnsTkn );         }
{_jnz}              { testRW( jnzTkn );         }
{_jo}               { testRW( joTkn );          }
{_jp}               { testRW( jpTkn );          }
{_jpe}              { testRW( jpeTkn );         }
{_jpo}              { testRW( jpoTkn );         }
{_js}               { testRW( jsTkn );          }
{_jz}               { testRW( jzTkn );          }
{_jmp}              { testRW( jmpTkn );         }
{_lahf}             { testRW( lahfTkn );        }
{_lar}              { testRW( larTkn );         }
{_lea}              { testRW( leaTkn );         }
{_leave}            { testRW( leaveTkn );       }
{_lds}              { testRW( ldsTkn );         }
{_les}              { testRW( lesTkn );         }
{_lfs}              { testRW( lfsTkn );         }
{_lgs}              { testRW( lgsTkn );         }
{_lss}              { testRW( lssTkn );         }
{_lsl}              { testRW( lslTkn );         }
{_lgdt}             { testRW( lgdtTkn );        }
{_lidt}             { testRW( lidtTkn );        }
{_sgdt}             { testRW( sgdtTkn );        }
{_sidt}             { testRW( sidtTkn );        }
{_lldt}             { testRW( lldtTkn );        }
{_sldt}             { testRW( sldtTkn );        }
{_lodsb}            { testRW( lodsbTkn );       }
{_lodsd}            { testRW( lodsdTkn );       }
{_lodsw}            { testRW( lodswTkn );       }
{_loop}             { testRW( loopTkn );        }
{_loope}            { testRW( loopeTkn );       }
{_loopz}            { testRW( loopzTkn );       }
{_loopne}           { testRW( loopneTkn );      }
{_loopnz}           { testRW( loopnzTkn );      }
{_ltreg}            { testRW( ltrTkn );         }
{_streg}            { testRW( strTkn );         }
{_mov}              { testRW( movTkn );         }
{_movsb}            { testRW( movsbTkn );       }
{_movsd}            { testRW( movsdTkn );       }
{_movsw}            { testRW( movswTkn );       }
{_movsx}            { testRW( movsxTkn );       }
{_movzx}            { testRW( movzxTkn );       }
{_mul}              { testRW( mulTkn );         }
{_neg}              { testRW( negTkn );         }
{_lock__neg}        { testRW( locknegTkn );     }
{_nop}              { testRW( nopTkn );         }
{_not}              { testRW( notTkn );         }
{_lock__not}        { testRW( locknotTkn );     }
{_or}               { testRW( orTkn );          }
{_lock__or}         { testRW( lockorTkn );      }
{_out}              { testRW( outTkn );         }
{_outsb}            { testRW( outsbTkn );       }
{_outsd}            { testRW( outsdTkn );       }
{_outsw}            { testRW( outswTkn );       }
{_pop}              { testRW( popTkn );         }
{_popa}             { testRW( popaTkn );        }
{_popad}            { testRW( popadTkn );       }
{_popf}             { testRW( popfTkn );        }
{_popfd}            { testRW( popfdTkn );       }
{_push}             { testRW( pushTkn );        }
{_pusha}            { testRW( pushaTkn );       }
{_pushad}           { testRW( pushadTkn );      }
{_pushd}            { testRW( pushdTkn );       }
{_pushf}            { testRW( pushfTkn );       }
{_pushfd}           { testRW( pushfdTkn );      }
{_pushw}            { testRW( pushwTkn );       }
{_rcl}              { testRW( rclTkn );         }
{_rcr}              { testRW( rcrTkn );         }
{_rdmsr}            { testRW( rdmsrTkn );       }
{_rdpmc}            { testRW( rdpmcTkn );       }
{_rdtsc}            { testRW( rdtscTkn );       }
{_rsm}              { testRW( rsmTkn );         }
{_smsw}             { testRW( smswTkn );        }
{_lmsw}             { testRW( lmswTkn );        }
{_rep__movsb}       { testRW( repmovsbTkn );    }
{_rep__movsw}       { testRW( repmovswTkn );    }
{_rep__movsd}       { testRW( repmovsdTkn );    }
{_rep__insb}        { testRW( repinsbTkn );     }
{_rep__insw}        { testRW( repinswTkn );     }
{_rep__insd}        { testRW( repinsdTkn );     }
{_rep__outsb}       { testRW( repoutsbTkn );    }
{_rep__outsw}       { testRW( repoutswTkn );    }
{_rep__outsd}       { testRW( repoutsdTkn );    }
{_rep__stosb}       { testRW( repstosbTkn );    }
{_rep__stosw}       { testRW( repstoswTkn );    }
{_rep__stosd}       { testRW( repstosdTkn );    }
{_repe__cmpsb}      { testRW( repecmpsbTkn );   }
{_repe__cmpsw}      { testRW( repecmpswTkn );   }
{_repe__cmpsd}      { testRW( repecmpsdTkn );   }
{_repe__scasb}      { testRW( repescasbTkn );   }
{_repe__scasw}      { testRW( repescaswTkn );   }
{_repe__scasd}      { testRW( repescasdTkn );   }
{_repz__cmpsb}      { testRW( repecmpsbTkn );   }
{_repz__cmpsw}      { testRW( repecmpswTkn );   }
{_repz__cmpsd}      { testRW( repecmpsdTkn );   }
{_repz__scasb}      { testRW( repescasbTkn );   }
{_repz__scasw}      { testRW( repescaswTkn );   }
{_repz__scasd}      { testRW( repescasdTkn );   }
{_repne__cmpsb}     { testRW( repnecmpsbTkn );  }
{_repne__cmpsw}     { testRW( repnecmpswTkn );  }
{_repne__cmpsd}     { testRW( repnecmpsdTkn );  }
{_repne__scasb}     { testRW( repnescasbTkn );  }
{_repne__scasw}     { testRW( repnescaswTkn );  }
{_repne__scasd}     { testRW( repnescasdTkn );  }
{_repnz__cmpsb}     { testRW( repnecmpsbTkn );  }
{_repnz__cmpsw}     { testRW( repnecmpswTkn );  }
{_repnz__cmpsd}     { testRW( repnecmpsdTkn );  }
{_repnz__scasb}     { testRW( repnescasbTkn );  }
{_repnz__scasw}     { testRW( repnescaswTkn );  }
{_repnz__scasd}     { testRW( repnescasdTkn );  }
{_ret}              { testRW( retTkn );         }
{_rol}              { testRW( rolTkn );         }
{_ror}              { testRW( rorTkn );         }
{_sahf}             { testRW( sahfTkn );        }
{_sal}              { testRW( salTkn );         }
{_sar}              { testRW( sarTkn );         }
{_sbb}              { testRW( sbbTkn );         }
{_lock__sbb}        { testRW( locksbbTkn );     }
{_scasb}            { testRW( scasbTkn );       }
{_scasd}            { testRW( scasdTkn );       }
{_scasw}            { testRW( scaswTkn );       }

{_seta}             { testRW( setnbeTkn );      }
{_setae}            { testRW( setnbTkn );       }
{_setb}             { testRW( setbTkn );        }
{_setbe}            { testRW( setbeTkn );       }
{_setc}             { testRW( setbTkn );        }
{_sete}             { testRW( setzTkn );        }
{_setg}             { testRW( setnleTkn );      }
{_setge}            { testRW( setnlTkn );       }
{_setl}             { testRW( setlTkn );        }
{_setle}            { testRW( setleTkn );       }
{_setna}            { testRW( setbeTkn );       }
{_setnae}           { testRW( setbTkn );      	}
{_setnb}            { testRW( setnbTkn );       }
{_setnbe}           { testRW( setnbeTkn );      }
{_setnc}            { testRW( setnbTkn );       }
{_setne}            { testRW( setnzTkn );       }
{_setng}            { testRW( setleTkn );       }
{_setnge}           { testRW( setlTkn );        }
{_setnl}            { testRW( setnlTkn );       }
{_setnle}           { testRW( setnleTkn );      }
{_setno}            { testRW( setnoTkn );       }
{_setnp}            { testRW( setnpTkn );       }
{_setns}            { testRW( setnsTkn );       }
{_setnz}            { testRW( setnzTkn );       }
{_seto}             { testRW( setoTkn );        }
{_setp}             { testRW( setpTkn );        }
{_setpe}            { testRW( setpTkn );        }
{_setpo}            { testRW( setnpTkn );       }
{_sets}             { testRW( setsTkn );        }
{_setz}             { testRW( setzTkn );        }

{_shl}              { testRW( shlTkn );         }
{_shld}             { testRW( shldTkn );        }
{_shr}              { testRW( shrTkn );         }
{_shrd}             { testRW( shrdTkn );        }
{_stc}              { testRW( stcTkn );         }
{_std}              { testRW( stdTkn );         }
{_sti}              { testRW( stiTkn );         }
{_stosb}            { testRW( stosbTkn );       }
{_stosd}            { testRW( stosdTkn );       }
{_stosw}            { testRW( stoswTkn );       }
{_sub}              { testRW( subTkn );         }
{_lock__sub}        { testRW( locksubTkn );     }
{_test}             { testRW( testTkn );        }
{_wait}             { testRW( waitTkn );        }
{_xadd}             { testRW( xaddTkn );        }
{_lock__xadd}       { testRW( lockxaddTkn );    }
{_xchg}             { testRW( xchgTkn );        }
{_lock__xchg}       { testRW( lockxchgTkn );    }
{_xlat}             { testRW( xlatTkn );        }
{_xor}              { testRW( xorTkn );         }
{_lock__xor}        { testRW( lockxorTkn );     }
{_ud2}              { testRW( ud2Tkn );         }
{_verr}             { testRW( verrTkn );        }
{_verw}             { testRW( verwTkn );        }
{_wbinvd}           { testRW( wbinvdTkn );      }
{_wrmsr}            { testRW( wrmsrTkn );       }





~{_aaa}              { _return  aaaTkn ;         }
~{_aad}              { _return  aadTkn ;         }
~{_aam}              { _return  aamTkn ;         }
~{_aas}              { _return  aasTkn ;         }
~{_adc}              { _return  adcTkn ;         }
~{_lock__adc}        { _return  lockadcTkn ;     }
~{_add}              { _return  addTkn ;         }
~{_lock__add}        { _return  lockaddTkn ;     }
~{_and}              { _return  andTkn ;         }
~{_lock__and}        { _return  lockandTkn ;     }
~{_arpl}             { _return  arplTkn ;        }
~{_bound}            { _return  boundTkn ;       }
~{_bsf}              { _return  bsfTkn ;         }
~{_bsr}              { _return  bsrTkn ;         }
~{_bswap}            { _return  bswapTkn ;       }
~{_bt}               { _return  btTkn ;          }
~{_btc}              { _return  btcTkn ;         }
~{_lock__btc}        { _return  lockbtcTkn ;     }
~{_btr}              { _return  btrTkn ;         }
~{_lock__btr}        { _return  lockbtrTkn ;     }
~{_bts}              { _return  btsTkn ;         }
~{_lock__bts}        { _return  lockbtsTkn ;     }
~{_call}             { _return  callTkn ;        }
~{_cbw}              { _return  cbwTkn ;         }
~{_cdq}              { _return  cdqTkn ;         }
~{_clc}              { _return  clcTkn ;         }
~{_cld}              { _return  cldTkn ;         }
~{_cli}              { _return  cliTkn ;         }
~{_clts}             { _return  cltsTkn ;        }
~{_cmc}              { _return  cmcTkn ;         }
~{_cmova}            { _return  cmovnbeTkn ;     }
~{_cmovae}           { _return  cmovnbTkn ;      }
~{_cmovb}            { _return  cmovbTkn ;       }
~{_cmovbe}           { _return  cmovbeTkn ;      }
~{_cmovc}            { _return  cmovbTkn ;       }
~{_cmove}            { _return  cmoveTkn ;       }
~{_cmovg}            { _return  cmovnleTkn ;     }
~{_cmovge}           { _return  cmovnlTkn ;      }
~{_cmovl}            { _return  cmovlTkn ;       }
~{_cmovle}           { _return  cmovleTkn ;      }
~{_cmovna}           { _return  cmovbeTkn ;      }
~{_cmovnae}          { _return  cmovbTkn ;       }
~{_cmovnb}           { _return  cmovnbTkn ;      }
~{_cmovnbe}          { _return  cmovnbeTkn ;     }
~{_cmovnc}           { _return  cmovnbTkn ;      }
~{_cmovne}           { _return  cmovneTkn ;      }
~{_cmovng}           { _return  cmovleTkn ;      }
~{_cmovnge}          { _return  cmovlTkn ;       }
~{_cmovnl}           { _return  cmovnlTkn ;      }
~{_cmovnle}          { _return  cmovnleTkn ;     }
~{_cmovno}           { _return  cmovnoTkn ;      }
~{_cmovnp}           { _return  cmovnpTkn ;      }
~{_cmovns}           { _return  cmovnsTkn ;      }
~{_cmovnz}           { _return  cmovneTkn ;      }
~{_cmovo}            { _return  cmovoTkn ;       }
~{_cmovp}            { _return  cmovpTkn ;       }
~{_cmovpe}           { _return  cmovpTkn ;       }
~{_cmovpo}           { _return  cmovnpTkn ;      }
~{_cmovs}            { _return  cmovsTkn ;       }
~{_cmovz}            { _return  cmoveTkn ;       }
~{_cmp}              { _return  cmpTkn ;         }
~{_cmpsb}            { _return  cmpsbTkn ;       }
~{_cmpsd}            { _return  cmpsdTkn ;       }
~{_cmpsw}            { _return  cmpswTkn ;       }
~{_cmpxchg}          { _return  cmpxchgTkn ;     }
~{_lock__cmpxchg}    { _return  lockcmpxchgTkn ; }
~{_cmpxchg8b}        { _return  cmpxchg8bTkn ;   }
~{_cpuid}            { _return  cpuidTkn ;       }
~{_cwd}              { _return  cwdTkn ;         }
~{_cwde}             { _return  cwdeTkn ;        }
~{_daa}              { _return  daaTkn ;         }
~{_das}              { _return  dasTkn ;         }
~{_dec}              { _return  decTkn ;         }
~{_lock__dec}        { _return  lockdecTkn ;     }
~{_div}              { _return  divTkn ;         }
~{_enter}            { _return  enterTkn ;       }
~{_hlt}              { _return  hltTkn ;         }
~{_idiv}             { _return  idivTkn ;        }
~{_imod}             { _return  imodTkn ;        }
~{_imul}             { _return  imulTkn ;        }
~{_intmul}           { _return  intmulTkn ;      }
~{_in}               { _return  inTkn ;          }
~{_inc}              { _return  incTkn ;         }
~{_lock__inc}        { _return  lockincTkn ;     }
~{_insb}             { _return  insbTkn ;        }
~{_insd}             { _return  insdTkn ;        }
~{_insw}             { _return  inswTkn ;        }
~{_int}              { _return  intTkn ;         }
~{_into}             { _return  intoTkn ;        }
~{_invd}             { _return  invdTkn ;        }
~{_invlpg}           { _return  invlpgTkn ;      }
~{_iret}             { _return  iretTkn ;        }
~{_iretd}            { _return  iretdTkn ;       }
~{_jcxz}             { _return  jcxzTkn ;        }
~{_jecxz}            { _return  jecxzTkn ;       }
~{_ja}               { _return  jaTkn  ;         }
~{_jae}              { _return  jaeTkn ;         }
~{_jb}               { _return  jbTkn  ;         }
~{_jbe}              { _return  jbeTkn ;         }
~{_jc}               { _return  jcTkn  ;         }
~{_je}               { _return  jeTkn  ;         }
~{_jg}               { _return  jgTkn  ;         }
~{_jge}              { _return  jgeTkn ;         }
~{_jl}               { _return  jlTkn  ;         }
~{_jle}              { _return  jleTkn ;         }
~{_jna}              { _return  jnaTkn ;         }
~{_jnae}             { _return  jnaeTkn;         }
~{_jnb}              { _return  jnbTkn ;         }
~{_jnbe}             { _return  jnbeTkn;         }
~{_jnc}              { _return  jncTkn ;         }
~{_jne}              { _return  jneTkn ;         }
~{_jng}              { _return  jngTkn ;         }
~{_jnge}             { _return  jngeTkn;         }
~{_jnl}              { _return  jnlTkn ;         }
~{_jnle}             { _return  jnleTkn;         }
~{_jno}              { _return  jnoTkn ;         }
~{_jnp}              { _return  jnpTkn ;         }
~{_jns}              { _return  jnsTkn ;         }
~{_jnz}              { _return  jnzTkn ;         }
~{_jo}               { _return  joTkn  ;         }
~{_jp}               { _return  jpTkn  ;         }
~{_jpe}              { _return  jpeTkn ;         }
~{_jpo}              { _return  jpoTkn ;         }
~{_js}               { _return  jsTkn  ;         }
~{_jz}               { _return  jzTkn  ;         }
~{_jmp}              { _return  jmpTkn ;         }
~{_lahf}             { _return  lahfTkn;         }
~{_lar}              { _return  larTkn ;         }
~{_lea}              { _return  leaTkn ;         }
~{_leave}            { _return  leaveTkn ;       }
~{_lds}              { _return  ldsTkn ;         }
~{_les}              { _return  lesTkn ;         }
~{_lfs}              { _return  lfsTkn ;         }
~{_lgs}              { _return  lgsTkn ;         }
~{_lss}              { _return  lssTkn ;         }
~{_lsl}              { _return  lslTkn ;         }
~{_lgdt}             { _return  lgdtTkn ;        }
~{_lidt}             { _return  lidtTkn ;        }
~{_sgdt}             { _return  sgdtTkn ;        }
~{_sidt}             { _return  sidtTkn ;        }
~{_lldt}             { _return  lldtTkn ;        }
~{_sldt}             { _return  sldtTkn ;        }
~{_lodsb}            { _return  lodsbTkn ;       }
~{_lodsd}            { _return  lodsdTkn ;       }
~{_lodsw}            { _return  lodswTkn ;       }
~{_loop}             { _return  loopTkn ;        }
~{_loope}            { _return  loopeTkn ;       }
~{_loopz}            { _return  loopzTkn ;       }
~{_loopne}           { _return  loopneTkn ;      }
~{_loopnz}           { _return  loopnzTkn ;      }
~{_ltreg}            { _return  ltrTkn ;         }
~{_streg}            { _return  strTkn ;         }
~{_mov}              { _return  movTkn ;         }
~{_movsb}            { _return  movsbTkn ;       }
~{_movsd}            { _return  movsdTkn ;       }
~{_movsw}            { _return  movswTkn ;       }
~{_movsx}            { _return  movsxTkn ;       }
~{_movzx}            { _return  movzxTkn ;       }
~{_mul}              { _return  mulTkn ;         }
~{_neg}              { _return  negTkn ;         }
~{_lock__neg}        { _return  locknegTkn ;     }
~{_nop}              { _return  nopTkn ;         }
~{_not}              { _return  notTkn ;         }
~{_lock__not}        { _return  locknotTkn ;     }
~{_or}               { _return  orTkn ;          }
~{_lock__or}         { _return  lockorTkn ;      }
~{_out}              { _return  outTkn ;         }
~{_outsb}            { _return  outsbTkn ;       }
~{_outsd}            { _return  outsdTkn ;       }
~{_outsw}            { _return  outswTkn ;       }
~{_pop}              { _return  popTkn ;         }
~{_popa}             { _return  popaTkn ;        }
~{_popad}            { _return  popadTkn ;       }
~{_popf}             { _return  popfTkn ;        }
~{_popfd}            { _return  popfdTkn ;       }
~{_push}             { _return  pushTkn ;        }
~{_pusha}            { _return  pushaTkn ;       }
~{_pushad}           { _return  pushadTkn ;      }
~{_pushd}            { _return  pushdTkn ;       }
~{_pushf}            { _return  pushfTkn ;       }
~{_pushfd}           { _return  pushfdTkn ;      }
~{_pushw}            { _return  pushwTkn ;       }
~{_rcl}              { _return  rclTkn ;         }
~{_rcr}              { _return  rcrTkn ;         }
~{_rdmsr}            { _return  rdmsrTkn ;       }
~{_rdpmc}            { _return  rdpmcTkn ;       }
~{_rdtsc}            { _return  rdtscTkn ;       }
~{_rsm}              { _return  rsmTkn ;         }
~{_smsw}             { _return  smswTkn ;        }
~{_lmsw}             { _return  lmswTkn ;        }
~{_rep__movsb}       { _return  repmovsbTkn ;    }
~{_rep__movsw}       { _return  repmovswTkn ;    }
~{_rep__movsd}       { _return  repmovsdTkn ;    }
~{_rep__insb}        { _return  repinsbTkn ;     }
~{_rep__insw}        { _return  repinswTkn ;     }
~{_rep__insd}        { _return  repinsdTkn ;     }
~{_rep__outsb}       { _return  repoutsbTkn ;    }
~{_rep__outsw}       { _return  repoutswTkn ;    }
~{_rep__outsd}       { _return  repoutsdTkn ;    }
~{_rep__stosb}       { _return  repstosbTkn ;    }
~{_rep__stosw}       { _return  repstoswTkn ;    }
~{_rep__stosd}       { _return  repstosdTkn ;    }
~{_repe__cmpsb}      { _return  repecmpsbTkn ;   }
~{_repe__cmpsw}      { _return  repecmpswTkn ;   }
~{_repe__cmpsd}      { _return  repecmpsdTkn ;   }
~{_repe__scasb}      { _return  repescasbTkn ;   }
~{_repe__scasw}      { _return  repescaswTkn ;   }
~{_repe__scasd}      { _return  repescasdTkn ;   }
~{_repz__cmpsb}      { _return  repecmpsbTkn ;   }
~{_repz__cmpsw}      { _return  repecmpswTkn ;   }
~{_repz__cmpsd}      { _return  repecmpsdTkn ;   }
~{_repz__scasb}      { _return  repescasbTkn ;   }
~{_repz__scasw}      { _return  repescaswTkn ;   }
~{_repz__scasd}      { _return  repescasdTkn ;   }
~{_repne__cmpsb}     { _return  repnecmpsbTkn ;  }
~{_repne__cmpsw}     { _return  repnecmpswTkn ;  }
~{_repne__cmpsd}     { _return  repnecmpsdTkn ;  }
~{_repne__scasb}     { _return  repnescasbTkn ;  }
~{_repne__scasw}     { _return  repnescaswTkn ;  }
~{_repne__scasd}     { _return  repnescasdTkn ;  }
~{_repnz__cmpsb}     { _return  repnecmpsbTkn ;  }
~{_repnz__cmpsw}     { _return  repnecmpswTkn ;  }
~{_repnz__cmpsd}     { _return  repnecmpsdTkn ;  }
~{_repnz__scasb}     { _return  repnescasbTkn ;  }
~{_repnz__scasw}     { _return  repnescaswTkn ;  }
~{_repnz__scasd}     { _return  repnescasdTkn ;  }
~{_ret}              { _return  retTkn ;         }
~{_rol}              { _return  rolTkn ;         }
~{_ror}              { _return  rorTkn ;         }
~{_sahf}             { _return  sahfTkn ;        }
~{_sal}              { _return  salTkn ;         }
~{_sar}              { _return  sarTkn ;         }
~{_sbb}              { _return  sbbTkn ;         }
~{_lock__sbb}        { _return  locksbbTkn ;     }
~{_scasb}            { _return  scasbTkn ;       }
~{_scasd}            { _return  scasdTkn ;       }
~{_scasw}            { _return  scaswTkn ;       }

~{_seta}             { _return  setnbeTkn ;      }
~{_setae}            { _return  setnbTkn ;       }
~{_setb}             { _return  setbTkn ;        }
~{_setbe}            { _return  setbeTkn ;       }
~{_setc}             { _return  setbTkn ;        }
~{_sete}             { _return  setzTkn ;        }
~{_setg}             { _return  setnleTkn ;      }
~{_setge}            { _return  setnlTkn ;       }
~{_setl}             { _return  setlTkn ;        }
~{_setle}            { _return  setleTkn ;       }
~{_setna}            { _return  setbeTkn ;       }
~{_setnae}           { _return  setbTkn ;        }
~{_setnb}            { _return  setnbTkn ;       }
~{_setnbe}           { _return  setnbeTkn ;      }
~{_setnc}            { _return  setnbTkn ;       }
~{_setne}            { _return  setnzTkn ;       }
~{_setng}            { _return  setleTkn ;       }
~{_setnge}           { _return  setlTkn ;        }
~{_setnl}            { _return  setnlTkn ;       }
~{_setnle}           { _return  setnleTkn ;      }
~{_setno}            { _return  setnoTkn ;       }
~{_setnp}            { _return  setnpTkn ;       }
~{_setns}            { _return  setnsTkn ;       }
~{_setnz}            { _return  setnzTkn ;       }
~{_seto}             { _return  setoTkn ;        }
~{_setp}             { _return  setpTkn ;        }
~{_setpe}            { _return  setpTkn ;        }
~{_setpo}            { _return  setnpTkn ;       }
~{_sets}             { _return  setsTkn ;        }
~{_setz}             { _return  setzTkn ;        }

~{_shl}              { _return  shlTkn ;         }
~{_shld}             { _return  shldTkn ;        }
~{_shr}              { _return  shrTkn ;         }
~{_shrd}             { _return  shrdTkn ;        }
~{_stc}              { _return  stcTkn ;         }
~{_std}              { _return  stdTkn ;         }
~{_sti}              { _return  stiTkn ;         }
~{_stosb}            { _return  stosbTkn ;       }
~{_stosd}            { _return  stosdTkn ;       }
~{_stosw}            { _return  stoswTkn ;       }
~{_sub}              { _return  subTkn ;         }
~{_lock__sub}        { _return  locksubTkn ;     }
~{_test}             { _return  testTkn ;        }
~{_wait}             { _return  waitTkn ;        }
~{_xadd}             { _return  xaddTkn ;        }
~{_lock__xadd}       { _return  lockxaddTkn ;    }
~{_xchg}             { _return  xchgTkn ;        }
~{_lock__xchg}       { _return  lockxchgTkn ;    }
~{_xlat}             { _return  xlatTkn ;        }
~{_xor}              { _return  xorTkn ;         }
~{_lock__xor}        { _return  lockxorTkn ;     }
~{_ud2}              { _return  ud2Tkn ;         }
~{_verr}             { _return  verrTkn ;        }
~{_verw}             { _return  verwTkn ;        }
~{_wbinvd}           { _return  wbinvdTkn ;      }
~{_wrmsr}            { _return  wrmsrTkn ;       }








 /*
 ** Floating point instructions.
 */

{_fld}             { testRW( fldTkn );     }
{_fild}            { testRW( fildTkn );    }
{_fbld}            { testRW( fbldTkn );    }
{_fst}             { testRW( fstTkn );     }
{_fstp}            { testRW( fstpTkn );    }
{_fist}            { testRW( fistTkn );    }
{_fistp}           { testRW( fistpTkn );   }
{_fisttp}          { testRW( fisttpTkn );  }
{_fbstp}           { testRW( fbstpTkn );   }
{_fxch}            { testRW( fxchTkn );    }
{_fxam}            { testRW( fxamTkn );    }
{_fadd}            { testRW( faddTkn );    }
{_faddp}           { testRW( faddpTkn );   }
{_fiadd}           { testRW( fiaddTkn );   }
{_fmul}            { testRW( fmulTkn );    }
{_fmulp}           { testRW( fmulpTkn );   }
{_fimul}           { testRW( fimulTkn );   }
{_fsub}            { testRW( fsubTkn );    }
{_fsubp}           { testRW( fsubpTkn );   }
{_fsubr}           { testRW( fsubrTkn );   }
{_fsubrp}          { testRW( fsubrpTkn );  }
{_fisub}           { testRW( fisubTkn );   }
{_fisubr}          { testRW( fisubrTkn );  }
{_fdiv}            { testRW( fdivTkn );    }
{_fdivp}           { testRW( fdivpTkn );   }
{_fdivr}           { testRW( fdivrTkn );   }
{_fdivrp}          { testRW( fdivrpTkn );  }
{_fidiv}           { testRW( fidivTkn );   }
{_fidivr}          { testRW( fidivrTkn );  }
{_fcom}            { testRW( fcomTkn );    }
{_fcomp}           { testRW( fcompTkn );   }
{_fcompp}          { testRW( fcomppTkn );  }
{_ficom}           { testRW( ficomTkn );   }
{_ficomp}          { testRW( ficompTkn );  }
{_fucom}           { testRW( fucomTkn );   }
{_fucomp}          { testRW( fucompTkn );  }
{_fucompp}         { testRW( fucomppTkn ); }
{_fsqrt}           { testRW( fsqrtTkn );   }
{_fabs}            { testRW( fabsTkn );    }
{_fchs}            { testRW( fchsTkn );    }
{_ftst}            { testRW( ftstTkn );    }
{_fscale}          { testRW( fscaleTkn );  }
{_fprem}           { testRW( fpremTkn );   }
{_fprem1}          { testRW( fprem1Tkn );  }
{_frndint}         { testRW( frndintTkn ); }
{_fxtract}         { testRW( fxtractTkn ); }
{_fldz}            { testRW( fldzTkn );    }
{_fld1}            { testRW( fld1Tkn );    }
{_fldpi}           { testRW( fldpiTkn );   }
{_fldl2t}          { testRW( fldl2tTkn );  }
{_fldl2e}          { testRW( fldl2eTkn );  }
{_fldlg2}          { testRW( fldlg2Tkn );  }
{_fldln2}          { testRW( fldln2Tkn );  }
{_f2xm1}           { testRW( f2xm1Tkn );   }
{_fsin}            { testRW( fsinTkn );    }
{_fcos}            { testRW( fcosTkn );    }
{_fsincos}         { testRW( fsincosTkn ); }
{_fptan}           { testRW( fptanTkn );   }
{_fpatan}          { testRW( fpatanTkn );  }
{_fyl2x}           { testRW( fyl2xTkn );   }
{_fyl2xp1}         { testRW( fyl2xp1Tkn ); }
{_finit}           { testRW( finitTkn );   }
{_fninit}          { testRW( fninitTkn );  }
{_fwait}           { testRW( fwaitTkn );   }
{_fldcw}           { testRW( fldcwTkn );   }
{_fstcw}           { testRW( fstcwTkn );   }
{_fnstcw}          { testRW( fnstcwTkn );  }
{_fclex}           { testRW( fclexTkn );   }
{_fnclex}          { testRW( fnclexTkn );  }
{_fldenv}          { testRW( fldenvTkn );  }
{_fstenv}          { testRW( fstenvTkn );  }
{_fnstenv}         { testRW( fnstenvTkn ); }
{_fsave}           { testRW( fsaveTkn );   }
{_fnsave}          { testRW( fnsaveTkn );  }
{_frstor}          { testRW( frstorTkn );  }
{_fstsw}           { testRW( fstswTkn );   }
{_fnstsw}          { testRW( fnstswTkn );  }
{_fincstp}         { testRW( fincstpTkn ); }
{_fdecstp}         { testRW( fdecstpTkn ); }
{_fnop}            { testRW( fnopTkn );    }
{_ffree}           { testRW( ffreeTkn );   }
{_fcmova}          { testRW( fcmovaTkn );  }
{_fcmovae}         { testRW( fcmovaeTkn ); }
{_fcmovb}          { testRW( fcmovbTkn );  }
{_fcmovbe}         { testRW( fcmovbeTkn ); }
{_fcmove}          { testRW( fcmoveTkn );  }
{_fcmovna}         { testRW( fcmovnaTkn ); }
{_fcmovnae}        { testRW( fcmovnaeTkn );}
{_fcmovnb}         { testRW( fcmovnbTkn ); }
{_fcmovnbe}        { testRW( fcmovnbeTkn );}
{_fcmovne}         { testRW( fcmovneTkn ); }
{_fcmovnu}         { testRW( fcmovnuTkn ); }
{_fcmovu}          { testRW( fcmovuTkn );  }
{_fcomi}           { testRW( fcomiTkn );   }
{_fcomip}          { testRW( fcomipTkn );  }
{_fucomi}          { testRW( fucomiTkn );  }
{_fucomip}         { testRW( fucomipTkn ); }



~{_fld}             { _return  fldTkn ;     }
~{_fild}            { _return  fildTkn ;    }
~{_fbld}            { _return  fbldTkn ;    }
~{_fst}             { _return  fstTkn ;     }
~{_fstp}            { _return  fstpTkn ;    }
~{_fist}            { _return  fistTkn ;    }
~{_fistp}           { _return  fistpTkn ;   }
~{_fisttp}          { _return  fisttpTkn ;  }
~{_fbstp}           { _return  fbstpTkn ;   }
~{_fxch}            { _return  fxchTkn ;    }
~{_fxam}            { _return  fxamTkn ;    }
~{_fadd}            { _return  faddTkn ;    }
~{_faddp}           { _return  faddpTkn ;   }
~{_fiadd}           { _return  fiaddTkn ;   }
~{_fmul}            { _return  fmulTkn ;    }
~{_fmulp}           { _return  fmulpTkn ;   }
~{_fimul}           { _return  fimulTkn ;   }
~{_fsub}            { _return  fsubTkn ;    }
~{_fsubp}           { _return  fsubpTkn ;   }
~{_fsubr}           { _return  fsubrTkn ;   }
~{_fsubrp}          { _return  fsubrpTkn ;  }
~{_fisub}           { _return  fisubTkn ;   }
~{_fisubr}          { _return  fisubrTkn ;  }
~{_fdiv}            { _return  fdivTkn ;    }
~{_fdivp}           { _return  fdivpTkn ;   }
~{_fdivr}           { _return  fdivrTkn ;   }
~{_fdivrp}          { _return  fdivrpTkn ;  }
~{_fidiv}           { _return  fidivTkn ;   }
~{_fidivr}          { _return  fidivrTkn ;  }
~{_fcom}            { _return  fcomTkn ;    }
~{_fcomp}           { _return  fcompTkn ;   }
~{_fcompp}          { _return  fcomppTkn ;  }
~{_ficom}           { _return  ficomTkn ;   }
~{_ficomp}          { _return  ficompTkn ;  }
~{_fucom}           { _return  fucomTkn ;   }
~{_fucomp}          { _return  fucompTkn ;  }
~{_fucompp}         { _return  fucomppTkn ; }
~{_fsqrt}           { _return  fsqrtTkn ;   }
~{_fabs}            { _return  fabsTkn ;    }
~{_fchs}            { _return  fchsTkn ;    }
~{_ftst}            { _return  ftstTkn ;    }
~{_fscale}          { _return  fscaleTkn ;  }
~{_fprem}           { _return  fpremTkn ;   }
~{_fprem1}          { _return  fprem1Tkn ;  }
~{_frndint}         { _return  frndintTkn ; }
~{_fxtract}         { _return  fxtractTkn ; }
~{_fldz}            { _return  fldzTkn ;    }
~{_fld1}            { _return  fld1Tkn ;    }
~{_fldpi}           { _return  fldpiTkn ;   }
~{_fldl2t}          { _return  fldl2tTkn ;  }
~{_fldl2e}          { _return  fldl2eTkn ;  }
~{_fldlg2}          { _return  fldlg2Tkn ;  }
~{_fldln2}          { _return  fldln2Tkn ;  }
~{_f2xm1}           { _return  f2xm1Tkn ;   }
~{_fsin}            { _return  fsinTkn ;    }
~{_fcos}            { _return  fcosTkn ;    }
~{_fsincos}         { _return  fsincosTkn ; }
~{_fptan}           { _return  fptanTkn ;   }
~{_fpatan}          { _return  fpatanTkn ;  }
~{_fyl2x}           { _return  fyl2xTkn ;   }
~{_fyl2xp1}         { _return  fyl2xp1Tkn ; }
~{_finit}           { _return  finitTkn ;   }
~{_fninit}          { _return  fninitTkn ;  }
~{_fwait}           { _return  fwaitTkn ;   }
~{_fldcw}           { _return  fldcwTkn ;   }
~{_fstcw}           { _return  fstcwTkn ;   }
~{_fnstcw}          { _return  fnstcwTkn ;  }
~{_fclex}           { _return  fclexTkn ;   }
~{_fnclex}          { _return  fnclexTkn ;  }
~{_fldenv}          { _return  fldenvTkn ;  }
~{_fstenv}          { _return  fstenvTkn ;  }
~{_fnstenv}         { _return  fnstenvTkn ; }
~{_fsave}           { _return  fsaveTkn ;   }
~{_fnsave}          { _return  fnsaveTkn ;  }
~{_frstor}          { _return  frstorTkn ;  }
~{_fstsw}           { _return  fstswTkn ;   }
~{_fnstsw}          { _return  fnstswTkn ;  }
~{_fincstp}         { _return  fincstpTkn ; }
~{_fdecstp}         { _return  fdecstpTkn ; }
~{_fnop}            { _return  fnopTkn ;    }
~{_ffree}           { _return  ffreeTkn ;   }
~{_fcmova}          { _return  fcmovaTkn ;  }
~{_fcmovae}         { _return  fcmovaeTkn ; }
~{_fcmovb}          { _return  fcmovbTkn ;  }
~{_fcmovbe}         { _return  fcmovbeTkn ; }
~{_fcmove}          { _return  fcmoveTkn ;  }
~{_fcmovna}         { _return  fcmovnaTkn ; }
~{_fcmovnae}        { _return  fcmovnaeTkn ;}
~{_fcmovnb}         { _return  fcmovnbTkn ; }
~{_fcmovnbe}        { _return  fcmovnbeTkn ;}
~{_fcmovne}         { _return  fcmovneTkn ; }
~{_fcmovnu}         { _return  fcmovnuTkn ; }
~{_fcmovu}          { _return  fcmovuTkn ;  }
~{_fcomi}           { _return  fcomiTkn ;   }
~{_fcomip}          { _return  fcomipTkn ;  }
~{_fucomi}          { _return  fucomiTkn ;  }
~{_fucomip}         { _return  fucomipTkn ; }



 /*
 ** MMX Instructions:
 */
 
{_paddb}           { testRW( paddbTkn );           }
{_paddw}           { testRW( paddwTkn );           }
{_paddd}           { testRW( padddTkn );           }
{_paddq}           { testRW( paddqTkn );           }
{_paddsb}          { testRW( paddsbTkn );          }
{_paddsw}          { testRW( paddswTkn );          }
{_paddusb}         { testRW( paddusbTkn );         }
{_paddusw}         { testRW( padduswTkn );         }
{_psubb}           { testRW( psubbTkn );           }
{_psubw}           { testRW( psubwTkn );           }
{_psubd}           { testRW( psubdTkn );           }
{_psubq}           { testRW( psubqTkn );           }
{_psubsb}          { testRW( psubsbTkn );          }
{_psubsw}          { testRW( psubswTkn );          }
{_psubusb}         { testRW( psubusbTkn );         }
{_psubusw}         { testRW( psubuswTkn );         }
{_pmulhuw}         { testRW( pmulhuwTkn );         }
{_pmulhw}          { testRW( pmulhwTkn );          }
{_pmullw}          { testRW( pmullwTkn );          }
{_pmaddwd}         { testRW( pmaddwdTkn );         }
{_pavgb}           { testRW( pavgbTkn );           }
{_pavgw}           { testRW( pavgwTkn );           }
{_pcmpeqb}         { testRW( pcmpeqbTkn );         }
{_pcmpeqw}         { testRW( pcmpeqwTkn );         }
{_pcmpeqd}         { testRW( pcmpeqdTkn );         }
{_pcmpgtb}         { testRW( pcmpgtbTkn );         }
{_pcmpgtw}         { testRW( pcmpgtwTkn );         }
{_pcmpgtd}         { testRW( pcmpgtdTkn );         }
{_packuswb}        { testRW( packuswbTkn );        }
{_packsswb}        { testRW( packsswbTkn );        }
{_packssdw}        { testRW( packssdwTkn );        }
{_punpcklbw}       { testRW( punpcklbwTkn );       }
{_punpcklwd}       { testRW( punpcklwdTkn );       }
{_punpckldq}       { testRW( punpckldqTkn );       }
{_punpckhbw}       { testRW( punpckhbwTkn );       }
{_punpckhwd}       { testRW( punpckhwdTkn );       }
{_punpckhdq}       { testRW( punpckhdqTkn );       }
{_pand}            { testRW( pandTkn );            }
{_pandn}           { testRW( pandnTkn );           }
{_por}             { testRW( porTkn );             }
{_pxor}            { testRW( pxorTkn );            }
{_psllw}           { testRW( psllwTkn );           }
{_pslld}           { testRW( pslldTkn );           }
{_psllq}           { testRW( psllqTkn );           }
{_psrlw}           { testRW( psrlwTkn );           }
{_psrld}           { testRW( psrldTkn );           }
{_psrlq}           { testRW( psrlqTkn );           }
{_psraw}           { testRW( psrawTkn );           }
{_psrad}           { testRW( psradTkn );           }
{_pmaxsw}          { testRW( pmaxswTkn );          }
{_pmaxub}          { testRW( pmaxubTkn );          }
{_pminsw}          { testRW( pminswTkn );          }
{_pminub}          { testRW( pminubTkn );          }
{_psadbw}          { testRW( psadbwTkn );          }
{_pextrw}          { testRW( pextrwTkn );          }
{_pinsrw}          { testRW( pinsrwTkn );          }
{_pmovmskb}        { testRW( pmovmskbTkn );        }
{_pshufw}          { testRW( pshufwTkn );          }
{_movd}            { testRW( movdTkn );            }
{_movq}            { testRW( movqTkn );            }
{_emms}            { testRW( emmsTkn );            }

~{_paddb}           { _return  paddbTkn ;           }
~{_paddw}           { _return  paddwTkn ;           }
~{_paddd}           { _return  padddTkn ;           }
~{_paddq}           { _return  paddqTkn ;           }
~{_paddsb}          { _return  paddsbTkn ;          }
~{_paddsw}          { _return  paddswTkn ;          }
~{_paddusb}         { _return  paddusbTkn ;         }
~{_paddusw}         { _return  padduswTkn ;         }
~{_psubb}           { _return  psubbTkn ;           }
~{_psubw}           { _return  psubwTkn ;           }
~{_psubd}           { _return  psubdTkn ;           }
~{_psubq}           { _return  psubqTkn ;           }
~{_psubsb}          { _return  psubsbTkn ;          }
~{_psubsw}          { _return  psubswTkn ;          }
~{_psubusb}         { _return  psubusbTkn ;         }
~{_psubusw}         { _return  psubuswTkn ;         }
~{_pmulhuw}         { _return  pmulhuwTkn ;         }
~{_pmulhw}          { _return  pmulhwTkn ;          }
~{_pmullw}          { _return  pmullwTkn ;          }
~{_pmaddwd}         { _return  pmaddwdTkn ;         }
~{_pavgb}           { _return  pavgbTkn ;           }
~{_pavgw}           { _return  pavgwTkn ;           }
~{_pcmpeqb}         { _return  pcmpeqbTkn ;         }
~{_pcmpeqw}         { _return  pcmpeqwTkn ;         }
~{_pcmpeqd}         { _return  pcmpeqdTkn ;         }
~{_pcmpgtb}         { _return  pcmpgtbTkn ;         }
~{_pcmpgtw}         { _return  pcmpgtwTkn ;         }
~{_pcmpgtd}         { _return  pcmpgtdTkn ;         }
~{_packuswb}        { _return  packuswbTkn ;        }
~{_packsswb}        { _return  packsswbTkn ;        }
~{_packssdw}        { _return  packssdwTkn ;        }
~{_punpcklbw}       { _return  punpcklbwTkn ;       }
~{_punpcklwd}       { _return  punpcklwdTkn ;       }
~{_punpckldq}       { _return  punpckldqTkn ;       }
~{_punpckhbw}       { _return  punpckhbwTkn ;       }
~{_punpckhwd}       { _return  punpckhwdTkn ;       }
~{_punpckhdq}       { _return  punpckhdqTkn ;       }
~{_pand}            { _return  pandTkn ;            }
~{_pandn}           { _return  pandnTkn ;           }
~{_por}             { _return  porTkn ;             }
~{_pxor}            { _return  pxorTkn ;            }
~{_psllw}           { _return  psllwTkn ;           }
~{_pslld}           { _return  pslldTkn ;           }
~{_psllq}           { _return  psllqTkn ;           }
~{_psrlw}           { _return  psrlwTkn ;           }
~{_psrld}           { _return  psrldTkn ;           }
~{_psrlq}           { _return  psrlqTkn ;           }
~{_psraw}           { _return  psrawTkn ;           }
~{_psrad}           { _return  psradTkn ;           }
~{_pmaxsw}          { _return  pmaxswTkn ;          }
~{_pmaxub}          { _return  pmaxubTkn ;          }
~{_pminsw}          { _return  pminswTkn ;          }
~{_pminub}          { _return  pminubTkn ;          }
~{_psadbw}          { _return  psadbwTkn ;          }
~{_pextrw}          { _return  pextrwTkn ;          }
~{_pinsrw}          { _return  pinsrwTkn ;          }
~{_pmovmskb}        { _return  pmovmskbTkn ;        }
~{_pshufw}          { _return  pshufwTkn ;          }
~{_movd}            { _return  movdTkn ;            }
~{_movq}            { _return  movqTkn ;            }
~{_emms}            { _return  emmsTkn ;            }




 /*
 ** SSE Instructions:
 */
 
{_addsd}           { testRW( addsdTkn );       }
{_addpd}           { testRW( addpdTkn );       }
{_addps}           { testRW( addpsTkn );       }
{_addss}           { testRW( addssTkn );       }
{_addsubpd}        { testRW( addsubpdTkn );    }
{_addsubps}        { testRW( addsubpsTkn );    }
{_andnpd}          { testRW( andnpdTkn );      }
{_andnps}          { testRW( andnpsTkn );      }
{_andpd}           { testRW( andpdTkn );       }
{_andps}           { testRW( andpsTkn );       }
{_clflush}         { testRW( clflushTkn );     }
{_cmppd}           { testRW( cmppdTkn );       }
{_cmpps}           { testRW( cmppsTkn );       }
{_cmpss}           { testRW( cmpssTkn );       }
{_cmpeqss}         { testRW( cmpeqssTkn );     }
{_cmpltss}         { testRW( cmpltssTkn );     }
{_cmpless}         { testRW( cmplessTkn );     }
{_cmpneqss}        { testRW( cmpneqssTkn );    }
{_cmpnltss}        { testRW( cmpnltssTkn );    }
{_cmpnless}        { testRW( cmpnlessTkn );    }
{_cmpordss}        { testRW( cmpordssTkn );    }
{_cmpunordss}      { testRW( cmpunordssTkn );  }
{_cmpeqsd}         { testRW( cmpeqsdTkn );     }
{_cmpltsd}         { testRW( cmpltsdTkn );     }
{_cmplesd}         { testRW( cmplesdTkn );     }
{_cmpneqsd}        { testRW( cmpneqsdTkn );    }
{_cmpnltsd}        { testRW( cmpnltsdTkn );    }
{_cmpnlesd}        { testRW( cmpnlesdTkn );    }
{_cmpordsd}        { testRW( cmpordsdTkn );    }
{_cmpunordsd}      { testRW( cmpunordsdTkn );  }
{_cmpeqps}         { testRW( cmpeqpsTkn );     }
{_cmpltps}         { testRW( cmpltpsTkn );     }
{_cmpleps}         { testRW( cmplepsTkn );     }
{_cmpneqps}        { testRW( cmpneqpsTkn );    }
{_cmpnltps}        { testRW( cmpnltpsTkn );    }
{_cmpnleps}        { testRW( cmpnlepsTkn );    }
{_cmpordps}        { testRW( cmpordpsTkn );    }
{_cmpunordps}      { testRW( cmpunordpsTkn );  }
{_cmpeqpd}         { testRW( cmpeqpdTkn );     }
{_cmpltpd}         { testRW( cmpltpdTkn );     }
{_cmplepd}         { testRW( cmplepdTkn );     }
{_cmpneqpd}        { testRW( cmpneqpdTkn );    }
{_cmpnltpd}        { testRW( cmpnltpdTkn );    }
{_cmpnlepd}        { testRW( cmpnlepdTkn );    }
{_cmpordpd}        { testRW( cmpordpdTkn );    }
{_cmpunordpd}      { testRW( cmpunordpdTkn );  }
{_comisd}          { testRW( comisdTkn );      }
{_comiss}          { testRW( comissTkn );      }
{_cvtdq2pd}        { testRW( cvtdq2pdTkn );    }
{_cvtdq2ps}        { testRW( cvtdq2psTkn );    }
{_cvtpd2dq}        { testRW( cvtpd2dqTkn );    }
{_cvtpd2pi}        { testRW( cvtpd2piTkn );    }
{_cvtpd2ps}        { testRW( cvtpd2psTkn );    }
{_cvtpi2pd}        { testRW( cvtpi2pdTkn );    }
{_cvtpi2ps}        { testRW( cvtpi2psTkn );    }
{_cvtps2dq}        { testRW( cvtps2dqTkn );    }
{_cvtps2pd}        { testRW( cvtps2pdTkn );    }
{_cvtps2pi}        { testRW( cvtps2piTkn );    }
{_cvtsd2si}        { testRW( cvtsd2siTkn );    }
{_cvtsi2sd}        { testRW( cvtsi2sdTkn );    }
{_cvtsi2ss}        { testRW( cvtsi2ssTkn );    }
{_cvtss2sd}        { testRW( cvtss2sdTkn );    }
{_cvtsd2ss}        { testRW( cvtsd2ssTkn );    }
{_cvtss2si}        { testRW( cvtss2siTkn );    }
{_cvttpd2pi}       { testRW( cvttpd2piTkn );   }
{_cvttpd2dq}       { testRW( cvttpd2dqTkn );   }
{_cvttps2dq}       { testRW( cvttps2dqTkn );   }
{_cvttps2pi}       { testRW( cvttps2piTkn );   }
{_cvttsd2si}       { testRW( cvttsd2siTkn );   }
{_cvttss2si}       { testRW( cvttss2siTkn );   }
{_divpd}           { testRW( divpdTkn );       }
{_divps}           { testRW( divpsTkn );       }
{_divsd}           { testRW( divsdTkn );       }
{_divss}           { testRW( divssTkn );       }
{_fxsave}          { testRW( fxsaveTkn );      }
{_fxrstor}         { testRW( fxrstorTkn );     }
{_haddpd}          { testRW( haddpdTkn );      }
{_haddps}          { testRW( haddpsTkn );      }
{_hsubpd}          { testRW( hsubpdTkn );      }
{_hsubps}          { testRW( hsubpsTkn );      }
{_ldmxcsr}         { testRW( ldmxcsrTkn );     }
{_lfence}          { testRW( lfenceTkn );      }
{_lddqu}           { testRW( lddquTkn );       }
{_maskmovdqu}      { testRW( maskmovdquTkn );  }
{_maskmovq}        { testRW( maskmovqTkn );    }
{_maxpd}           { testRW( maxpdTkn );       }
{_maxps}           { testRW( maxpsTkn );       }
{_maxsd}           { testRW( maxsdTkn );       }
{_maxss}           { testRW( maxssTkn );       }
{_mfence}          { testRW( mfenceTkn );      }
{_minpd}           { testRW( minpdTkn );       }
{_minps}           { testRW( minpsTkn );       }
{_minsd}           { testRW( minsdTkn );       }
{_minss}           { testRW( minssTkn );       }
{_monitor}         { testRW( monitorTkn );     }
{_movapd}          { testRW( movapdTkn );      }
{_movaps}          { testRW( movapsTkn );      }
{_movddup}         { testRW( movddupTkn );     }
{_movdqa}          { testRW( movdqaTkn );      }
{_movdqu}          { testRW( movdquTkn );      }
{_movdq2q}         { testRW( movdq2qTkn );     }
{_movhlps}         { testRW( movhlpsTkn );     }
{_movhpd}          { testRW( movhpdTkn );      }
{_movhps}          { testRW( movhpsTkn );      }
{_movlpd}          { testRW( movlpdTkn );      }
{_movlps}          { testRW( movlpsTkn );      }
{_movlhps}         { testRW( movlhpsTkn );     }
{_movmskpd}        { testRW( movmskpdTkn );    }
{_movmskps}        { testRW( movmskpsTkn );    }
{_movnti}          { testRW( movntiTkn );      }
{_movntpd}         { testRW( movntpdTkn );     }
{_movntps}         { testRW( movntpsTkn );     }
{_movntq}          { testRW( movntqTkn );      }
{_movntdq}         { testRW( movntdqTkn );     }
{_movq2dq}         { testRW( movq2dqTkn );     }
{_movshdup}        { testRW( movshdupTkn );    }
{_movsldup}        { testRW( movsldupTkn );    }
{_movss}           { testRW( movssTkn );       }
{_movupd}          { testRW( movupdTkn );      }
{_movups}          { testRW( movupsTkn );      }
{_mulpd}           { testRW( mulpdTkn );       }
{_mulps}           { testRW( mulpsTkn );       }
{_mulss}           { testRW( mulssTkn );       }
{_mulsd}           { testRW( mulsdTkn );       }
{_mwait}           { testRW( mwaitTkn );       }
{_orpd}            { testRW( orpdTkn );        }
{_orps}            { testRW( orpsTkn );        }
{_pause}           { testRW( pauseTkn );       }
{_pmuludq}         { testRW( pmuludqTkn );     }
{_pshufd}          { testRW( pshufdTkn );      }
{_pshufhw}         { testRW( pshufhwTkn );     }
{_pshuflw}         { testRW( pshuflwTkn );     }
{_prefetcht0}      { testRW( prefetcht0Tkn );  }
{_prefetcht1}      { testRW( prefetcht1Tkn );  }
{_prefetcht2}      { testRW( prefetcht2Tkn );  }
{_prefetchnta}     { testRW( prefetchntaTkn ); }
{_pslldq}          { testRW( pslldqTkn );      }
{_psrldq}          { testRW( psrldqTkn );      }
{_punpckhqdq}      { testRW( punpckhqdqTkn );  }
{_punpcklqdq}      { testRW( punpcklqdqTkn );  }
{_rcpps}           { testRW( rcppsTkn );       }
{_rcpss}           { testRW( rcpssTkn );       }
{_rsqrtps}         { testRW( rsqrtpsTkn );     }
{_rsqrtss}         { testRW( rsqrtssTkn );     }
{_sfence}          { testRW( sfenceTkn );      }
{_shufpd}          { testRW( shufpdTkn );      }
{_shufps}          { testRW( shufpsTkn );      }
{_sqrtpd}          { testRW( sqrtpdTkn );      }
{_sqrtps}          { testRW( sqrtpsTkn );      }
{_sqrtsd}          { testRW( sqrtsdTkn );      }
{_sqrtss}          { testRW( sqrtssTkn );      }
{_stmxcsr}         { testRW( stmxcsrTkn );     }
{_subps}           { testRW( subpsTkn );       }
{_subpd}           { testRW( subpdTkn );       }
{_subsd}           { testRW( subsdTkn );       }
{_subss}           { testRW( subssTkn );       }
{_sysenter}        { testRW( sysenterTkn );    }
{_sysexit}         { testRW( sysexitTkn );     }
{_ucomisd}         { testRW( ucomisdTkn );     }
{_ucomiss}         { testRW( ucomissTkn );     }
{_unpckhpd}        { testRW( unpckhpdTkn );    }
{_unpckhps}        { testRW( unpckhpsTkn );    }
{_unpcklpd}        { testRW( unpcklpdTkn );    }
{_unpcklps}        { testRW( unpcklpsTkn );    }
{_xorpd}           { testRW( xorpdTkn );       }
{_xorps}           { testRW( xorpsTkn );       }



~{_addsd}           { _return  addsdTkn ;       }
~{_addpd}           { _return  addpdTkn ;       }
~{_addps}           { _return  addpsTkn ;       }
~{_addss}           { _return  addssTkn ;       }
~{_addsubpd}        { _return  addsubpdTkn ;    }
~{_addsubps}        { _return  addsubpsTkn ;    }
~{_andnpd}          { _return  andnpdTkn ;      }
~{_andnps}          { _return  andnpsTkn ;      }
~{_andpd}           { _return  andpdTkn ;       }
~{_andps}           { _return  andpsTkn ;       }
~{_clflush}         { _return  clflushTkn ;     }
~{_cmppd}           { _return  cmppdTkn ;       }
~{_cmpps}           { _return  cmppsTkn ;       }
~{_cmpss}           { _return  cmpssTkn ;       }
~{_cmpeqss}         { _return  cmpeqssTkn ;     }
~{_cmpltss}         { _return  cmpltssTkn ;     }
~{_cmpless}         { _return  cmplessTkn ;     }
~{_cmpneqss}        { _return  cmpneqssTkn ;    }
~{_cmpnltss}        { _return  cmpnltssTkn ;    }
~{_cmpnless}        { _return  cmpnlessTkn ;    }
~{_cmpordss}        { _return  cmpordssTkn ;    }
~{_cmpunordss}      { _return  cmpunordssTkn ;  }
~{_cmpeqsd}         { _return  cmpeqsdTkn ;     }
~{_cmpltsd}         { _return  cmpltsdTkn ;     }
~{_cmplesd}         { _return  cmplesdTkn ;     }
~{_cmpneqsd}        { _return  cmpneqsdTkn ;    }
~{_cmpnltsd}        { _return  cmpnltsdTkn ;    }
~{_cmpnlesd}        { _return  cmpnlesdTkn ;    }
~{_cmpordsd}        { _return  cmpordsdTkn ;    }
~{_cmpunordsd}      { _return  cmpunordsdTkn ;  }
~{_cmpeqps}         { _return  cmpeqpsTkn ;     }
~{_cmpltps}         { _return  cmpltpsTkn ;     }
~{_cmpleps}         { _return  cmplepsTkn ;     }
~{_cmpneqps}        { _return  cmpneqpsTkn ;    }
~{_cmpnltps}        { _return  cmpnltpsTkn ;    }
~{_cmpnleps}        { _return  cmpnlepsTkn ;    }
~{_cmpordps}        { _return  cmpordpsTkn ;    }
~{_cmpunordps}      { _return  cmpunordpsTkn ;  }
~{_cmpeqpd}         { _return  cmpeqpdTkn ;     }
~{_cmpltpd}         { _return  cmpltpdTkn ;     }
~{_cmplepd}         { _return  cmplepdTkn ;     }
~{_cmpneqpd}        { _return  cmpneqpdTkn ;    }
~{_cmpnltpd}        { _return  cmpnltpdTkn ;    }
~{_cmpnlepd}        { _return  cmpnlepdTkn ;    }
~{_cmpordpd}        { _return  cmpordpdTkn ;    }
~{_cmpunordpd}      { _return  cmpunordpdTkn ;  }
~{_comisd}          { _return  comisdTkn ;      }
~{_comiss}          { _return  comissTkn ;      }
~{_cvtdq2pd}        { _return  cvtdq2pdTkn ;    }
~{_cvtdq2ps}        { _return  cvtdq2psTkn ;    }
~{_cvtpd2dq}        { _return  cvtpd2dqTkn ;    }
~{_cvtpd2pi}        { _return  cvtpd2piTkn ;    }
~{_cvtpd2ps}        { _return  cvtpd2psTkn ;    }
~{_cvtpi2pd}        { _return  cvtpi2pdTkn ;    }
~{_cvtpi2ps}        { _return  cvtpi2psTkn ;    }
~{_cvtps2dq}        { _return  cvtps2dqTkn ;    }
~{_cvtps2pd}        { _return  cvtps2pdTkn ;    }
~{_cvtps2pi}        { _return  cvtps2piTkn ;    }
~{_cvtsd2si}        { _return  cvtsd2siTkn ;    }
~{_cvtsi2sd}        { _return  cvtsi2sdTkn ;    }
~{_cvtsi2ss}        { _return  cvtsi2ssTkn ;    }
~{_cvtss2sd}        { _return  cvtss2sdTkn ;    }
~{_cvtsd2ss}        { _return  cvtsd2ssTkn ;    }
~{_cvtss2si}        { _return  cvtss2siTkn ;    }
~{_cvttpd2pi}       { _return  cvttpd2piTkn ;   }
~{_cvttpd2dq}       { _return  cvttpd2dqTkn ;   }
~{_cvttps2dq}       { _return  cvttps2dqTkn ;   }
~{_cvttps2pi}       { _return  cvttps2piTkn ;   }
~{_cvttsd2si}       { _return  cvttsd2siTkn ;   }
~{_cvttss2si}       { _return  cvttss2siTkn ;   }
~{_divpd}           { _return  divpdTkn ;       }
~{_divps}           { _return  divpsTkn ;       }
~{_divsd}           { _return  divsdTkn ;       }
~{_divss}           { _return  divssTkn ;       }
~{_fxsave}          { _return  fxsaveTkn ;      }
~{_fxrstor}         { _return  fxrstorTkn ;     }
~{_haddpd}          { _return  haddpdTkn ;      }
~{_haddps}          { _return  haddpsTkn ;      }
~{_hsubpd}          { _return  hsubpdTkn ;      }
~{_hsubps}          { _return  hsubpsTkn ;      }
~{_ldmxcsr}         { _return  ldmxcsrTkn ;     }
~{_lfence}          { _return  lfenceTkn ;      }
~{_lddqu}           { _return  lddquTkn ;       }
~{_maskmovdqu}      { _return  maskmovdquTkn ;  }
~{_maskmovq}        { _return  maskmovqTkn ;    }
~{_maxpd}           { _return  maxpdTkn ;       }
~{_maxps}           { _return  maxpsTkn ;       }
~{_maxsd}           { _return  maxsdTkn ;       }
~{_maxss}           { _return  maxssTkn ;       }
~{_mfence}          { _return  mfenceTkn ;      }
~{_minpd}           { _return  minpdTkn ;       }
~{_minps}           { _return  minpsTkn ;       }
~{_minsd}           { _return  minsdTkn ;       }
~{_minss}           { _return  minssTkn ;       }
~{_monitor}         { _return  monitorTkn ;     }
~{_movapd}          { _return  movapdTkn ;      }
~{_movaps}          { _return  movapsTkn ;      }
~{_movddup}         { _return  movddupTkn ;     }
~{_movdqa}          { _return  movdqaTkn ;      }
~{_movdqu}          { _return  movdquTkn ;      }
~{_movdq2q}         { _return  movdq2qTkn ;     }
~{_movhlps}         { _return  movhlpsTkn ;     }
~{_movhpd}          { _return  movhpdTkn ;      }
~{_movhps}          { _return  movhpsTkn ;      }
~{_movlpd}          { _return  movlpdTkn ;      }
~{_movlps}          { _return  movlpsTkn ;      }
~{_movlhps}         { _return  movlhpsTkn ;     }
~{_movmskpd}        { _return  movmskpdTkn ;    }
~{_movmskps}        { _return  movmskpsTkn ;    }
~{_movnti}          { _return  movntiTkn ;      }
~{_movntpd}         { _return  movntpdTkn ;     }
~{_movntps}         { _return  movntpsTkn ;     }
~{_movntq}          { _return  movntqTkn ;      }
~{_movntdq}         { _return  movntdqTkn ;     }
~{_movq2dq}         { _return  movq2dqTkn ;     }
~{_movshdup}        { _return  movshdupTkn ;    }
~{_movsldup}        { _return  movsldupTkn ;    }
~{_movss}           { _return  movssTkn ;       }
~{_movupd}          { _return  movupdTkn ;      }
~{_movups}          { _return  movupsTkn ;      }
~{_mulpd}           { _return  mulpdTkn ;       }
~{_mulps}           { _return  mulpsTkn ;       }
~{_mulss}           { _return  mulssTkn ;       }
~{_mulsd}           { _return  mulsdTkn ;       }
~{_mwait}           { _return  mwaitTkn ;       }
~{_orpd}            { _return  orpdTkn ;        }
~{_orps}            { _return  orpsTkn ;        }
~{_pause}           { _return  pauseTkn ;       }
~{_pmuludq}         { _return  pmuludqTkn ;     }
~{_pshufd}          { _return  pshufdTkn ;      }
~{_pshufhw}         { _return  pshufhwTkn ;     }
~{_pshuflw}         { _return  pshuflwTkn ;     }
~{_prefetcht0}      { _return  prefetcht0Tkn ;  }
~{_prefetcht1}      { _return  prefetcht1Tkn ;  }
~{_prefetcht2}      { _return  prefetcht2Tkn ;  }
~{_prefetchnta}     { _return  prefetchntaTkn ; }
~{_pslldq}          { _return  pslldqTkn ;      }
~{_psrldq}          { _return  psrldqTkn ;      }
~{_punpckhqdq}      { _return  punpckhqdqTkn ;  }
~{_punpcklqdq}      { _return  punpcklqdqTkn ;  }
~{_rcpps}           { _return  rcppsTkn ;       }
~{_rcpss}           { _return  rcpssTkn ;       }
~{_rsqrtps}         { _return  rsqrtpsTkn ;     }
~{_rsqrtss}         { _return  rsqrtssTkn ;     }
~{_sfence}          { _return  sfenceTkn ;      }
~{_shufpd}          { _return  shufpdTkn ;      }
~{_shufps}          { _return  shufpsTkn ;      }
~{_sqrtpd}          { _return  sqrtpdTkn ;      }
~{_sqrtps}          { _return  sqrtpsTkn ;      }
~{_sqrtsd}          { _return  sqrtsdTkn ;      }
~{_sqrtss}          { _return  sqrtssTkn ;      }
~{_stmxcsr}         { _return  stmxcsrTkn ;     }
~{_subps}           { _return  subpsTkn ;       }
~{_subpd}           { _return  subpdTkn ;       }
~{_subsd}           { _return  subsdTkn ;       }
~{_subss}           { _return  subssTkn ;       }
~{_sysenter}        { _return  sysenterTkn ;    }
~{_sysexit}         { _return  sysexitTkn ;     }
~{_ucomisd}         { _return  ucomisdTkn ;     }
~{_ucomiss}         { _return  ucomissTkn ;     }
~{_unpckhpd}        { _return  unpckhpdTkn ;    }
~{_unpckhps}        { _return  unpckhpsTkn ;    }
~{_unpcklpd}        { _return  unpcklpdTkn ;    }
~{_unpcklps}        { _return  unpcklpsTkn ;    }
~{_xorpd}           { _return  xorpdTkn ;       }
~{_xorps}           { _return  xorpsTkn ;       }



 /*
 ** @debughla-
 ** This "reserved word" exists solely as an HLA
 ** debugging aid.  It immediately stops the assembly
 ** with an assertion failure.
 */
 
{a_debughla}   {
                    // This assertion always fails:
                     
                    assert( ("debugHLA assertion", 0)); 
                }

 /*
 ** Assember function tokens
 */

{a_abs}            { _return absTkn;               }
{a_ceil}           { _return ceilTkn;              }
{a_cos}            { _return cosTkn;               }
{a_date}           { _return dateTkn;              }
{a_env}            { _return envTkn;               }       
{a_exp}            { _return expTkn;               }
{a_extract}        { _return extractTkn;           }
{a_floor}          { _return floorTkn;             }
{a_isalpha}        { _return isalphaTkn;           }
{a_isalphanum}     { _return isalphanumTkn;        }
{a_isdigit}        { _return isdigitTkn;           }
{a_islower}        { _return islowerTkn;           }
{a_isspace}        { _return isspaceTkn;           }
{a_isupper}        { _return isupperTkn;           }
{a_isxdigit}       { _return isxdigitTkn;          }
{a_log}            { _return logTkn;               }
{a_log10}          { _return log10Tkn;             }
{a_max}            { _return maxTkn;               }
{a_min}            { _return minTkn;               }
{a_odd}            { _return oddTkn;               }
{a_random}         { _return randomTkn;            }
{a_randomize}      { _return randomizeTkn;         }
{a_sin}            { _return sinTkn;               }
{a_sort}           { _return sortTkn;              }
{a_sqrt}           { _return sqrtTkn;              }
{a_system}         { _return systemTkn;            }
{a_tan}            { _return tanTkn;               }
{a_thread}         { _return threadTkn;            }
{a_time}           { _return timeTkn;              }


 /*
 ** Assembler string functions.
 */

{a_delete}         { _return deleteTkn;            }
{a_index}          { _return indexTkn;             }
{a_insert}         { _return insertTkn;            }
{a_length}         { _return lengthTkn;            }
{a_lowercase}      { _return lowercaseTkn;         }
{a_rindex}         { _return rindexTkn;            }
{a_strbrk}         { _return strbrkTkn;            }
{a_strset}         { _return strsetTkn;            }
{a_strspan}        { _return strspanTkn;           }
{a_substr}         { _return substrTkn;            }
{a_tokenize}       { _return tokenizeTkn;          }
{a_trim}           { _return trimTkn;              }
{a_uppercase}      { _return uppercaseTkn;         }

 /*
 ** Pattern Matching Functions
 */

{a_peekcset}           	{ _return peekcsetTkn;          }
{a_onecset}            	{ _return onecsetTkn;           }
{a_matchcset}          	{ _return onecsetTkn;           }
{a_uptocset}           	{ _return uptocsetTkn;          }
{a_zerooronecset}      	{ _return zerooronecsetTkn;     }
{a_zeroormorecset}     	{ _return zeroormorecsetTkn;    }
{a_oneormorecset}      	{ _return oneormorecsetTkn;     }
{a_exactlyncset}       	{ _return exactlyncsetTkn;      }
{a_firstncset}         	{ _return firstncsetTkn;        }
{a_norlesscset}        	{ _return norlesscsetTkn;       }
{a_normorecset}        	{ _return normorecsetTkn;       }
{a_ntomcset}           	{ _return ntomcsetTkn;          }
{a_exactlyntomcset}    	{ _return exactlyntomcsetTkn;   }
{a_peekchar}           	{ _return peekcharTkn;          }
{a_onechar}            	{ _return onecharTkn;           }
{a_matchchar}          	{ _return onecharTkn;           }
{a_uptochar}           	{ _return uptocharTkn;          }
{a_zerooronechar}      	{ _return zerooronecharTkn;     }
{a_zeroormorechar}     	{ _return zeroormorecharTkn;    }
{a_oneormorechar}      	{ _return oneormorecharTkn;     }
{a_exactlynchar}       	{ _return exactlyncharTkn;      }
{a_firstnchar}         	{ _return firstncharTkn;        }
{a_norlesschar}        	{ _return norlesscharTkn;       }
{a_normorechar}        	{ _return normorecharTkn;       }
{a_ntomchar}           	{ _return ntomcharTkn;          }
{a_exactlyntomchar}    	{ _return exactlyntomcharTkn;   }
{a_peekichar}          	{ _return peekicharTkn;         }
{a_oneichar}           	{ _return oneicharTkn;          }
{a_matchichar}         	{ _return oneicharTkn;          }
{a_uptoichar}          	{ _return uptoicharTkn;         }
{a_zerooroneichar}     	{ _return zerooroneicharTkn;    }
{a_zeroormoreichar}    	{ _return zeroormoreicharTkn;   }
{a_oneormoreichar}     	{ _return oneormoreicharTkn;    }
{a_exactlynichar}      	{ _return exactlynicharTkn;     }
{a_firstnichar}        	{ _return firstnicharTkn;       }
{a_norlessichar}       	{ _return norlessicharTkn;      }
{a_normoreichar}       	{ _return normoreicharTkn;      }
{a_ntomichar}          	{ _return ntomicharTkn;         }
{a_exactlyntomichar}   	{ _return exactlyntomicharTkn;  }
{a_match}              	{ _return matchTkn;             }
{a_match2}             	{ _return match2Tkn;            }
{a_matchstr}           	{ _return matchstrTkn;          }
{a_matchistr}          	{ _return matchistrTkn;         }
{a_uptostr}            	{ _return uptostrTkn;           }
{a_uptoistr}           	{ _return uptoistrTkn;          }
{a_matchtostr}         	{ _return matchtostrTkn;        }
{a_matchtoistr}        	{ _return matchtoistrTkn;       }
{a_zeroormorews}       	{ _return zeroormorewsTkn;      }
{a_oneormorews}        	{ _return oneormorewsTkn;       }
{a_wsoreos}            	{ _return wsoreosTkn;           }
{a_wstheneos}          	{ _return wstheneosTkn;         }
{a_peekws}             	{ _return peekwsTkn;            }
{a_eos}                	{ _return eosTkn;               }
{a_ws}                 	{ _return wsTkn;                }


{a_arb}					{ _return arbTkn;				}
{a_tab}					{ _return tabTkn;				}
{a_at}					{ _return atTkn;				}
{a_pos}					{ _return posTkn;				}
{a_peekstr}            	{ _return peekstrTkn;           }
{a_peekistr}           	{ _return peekistrTkn;          }
{a_matchword}          	{ _return matchwordTkn;         }
{a_matchiword}         	{ _return matchiwordTkn;        }
{a_matchid}            	{ _return matchidTkn;           }
{a_matchintconst}      	{ _return matchintconstTkn;     }
{a_matchrealconst}     	{ _return matchrealconstTkn;    }
{a_matchnumericconst}  	{ _return matchnumericconstTkn; }
{a_matchstrconst}      	{ _return matchstrconstTkn;     }

{a_reg}               	{ _return matchregTkn;          }
{a_reg8}              	{ _return matchreg8Tkn;         }
{a_reg16}             	{ _return matchreg16Tkn;        }
{a_reg32}             	{ _return matchreg32Tkn;        }
{a_fpureg}            	{ _return matchfpuregTkn;       }
{a_mmxreg}            	{ _return matchmmxregTkn;       }
{a_xmmreg}            	{ _return matchxmmregTkn;       }





 /*
 ** Symbol table access functions.
 */

{a_name}           { _return symNameTkn;           }
{a_type}           { _return symTypeTkn;           }
{a_typename}       { _return symTypeNameTkn;       }
{a_ptype}          { _return sympTypeTkn;          }
{a_baseptype}      { _return symBasepTypeTkn;      }
{a_basetype}       { _return symBaseTypeNameTkn;   }
{a_class}          { _return symClassTkn;          }
{a_size}           { _return symSizeTkn;           }
{a_elementsize}    { _return symElementSizeTkn;    }
{a_offset}         { _return symOffsetTkn;         }
{a_localsyms}      { _return symLocalsymsTkn;      }
{a_parms}          { _return symParmsTkn;          }
{a_staticname}     { _return symStaticNameTkn;     }
{a_lex}            { _return symLexTkn;            }
{a_IsExternal}     { _return symIsExternalTkn;     }
{a_arity}          { _return symArityTkn;          }
{a_dim}            { _return symDimTkn;            }
{a_elements}       { _return symNumelementsTkn;    }
{a_defined}        { _return symDefinedTkn;        }
{a_pclass}         { _return sympClassTkn;         }
{a_isclass}        { _return symIsClassTkn;        }
{a_ismem}          { _return symIsMemTkn;          }
{a_istype}         { _return symIsTypeTkn;         }
{a_isconst}        { _return symIsConstTkn;        }
{a_isreg}          { _return symIsRegTkn;          }
{a_isreg8}         { _return symIsReg8Tkn;         }
{a_isreg16}        { _return symIsReg16Tkn;        }
{a_isreg32}        { _return symIsReg32Tkn;        }
{a_isfreg}         { _return symIsfRegTkn;         }


 /*
 ** Special built-in constants.
 */

{a_curlex}         { _return curLexTkn;            }
{a_curoffset}      { _return curOffsetTkn;         }
{a_curdir}         { _return curDirTkn;            }
{a_lastobject}     { _return lastMacroObjectTkn;   }
{a_curobject}      { _return curObjectNameTkn;     }
{a_linenumber}     { _return lineNumberTkn;        }
{a_filename}       { _return filenameTkn;          }
{a_section}        { _return sectionTkn;           }

 /*
 ** Special built-in variables (may appear on the
 ** left hand size of ":=" within a value section).
 */

{a_parmoffset}     { _return startParmOfsTkn;      }
{a_localoffset}    { _return startLclOfsTkn;       }
{a_enumsize}       { _return enumSizeTkn;          }
{a_bound}          { _return boundvarTkn;          }
{a_into}           { _return intovarTkn;           }
{a_trace}          { _return traceTkn;             }
{a_exceptions}     { _return exceptsTkn;           }
{a_optstrings}     { _return optstringsTkn;        }
{a_basereg}        { _return baseregTkn;           }

 /*
 ** @text needs a little special handling.
 ** We have to make a recursive call to the parser
 ** to get the string that we are going to feed
 ** back through the lexer.  We do this by pushing
 ** back a special character (\253) that will cause
 ** the parser to process the @text parameter list.
 */

<UnprocessedID>{a_text} {
                    _here;
                    BEGIN 0;
                    PushBackStr( "\xFD" );
                    yyparse();
                    BEGIN UnprocessedID;
                    _here;
                }

{a_text}            {
                    _here;
                    PushBackStr( "\xFD" );
                    yyparse();
                    _here;
                }

\xFD            {   _here; _return TextParameters; }




 /*
 ** UnprocessedID-
 **
 ** This start state is activated by the parser when
 ** it wants IDs returned strictly as strings without
 ** further processing.  These regular expressions
 ** override all the following ID-related REs.
 */



<UnprocessedID>{a_global}:[a-z_][\.a-z0-9_]* {
        
        yylval->idStr = hlastrdup2( yytext + 8 );   
        _return UndefID;
    }



<UnprocessedID>[a-z_][a-z0-9_]*(\.[a-z_][a-z0-9_]*)* {
        
        struct SymNode *s;

        s=ClassifyLookup( yytext, SymbolTable );
        _if( s != NULL )

            /*
            ** If this symbol is defined, see if it's a macro
            ** or a text object.  We need to immediately expand
            ** those.
            */

            _if( s->pType == tText )

                PushBackStr( s->u.strval );


            _elseif( s->pType == tMacro )

                ProcessMacro( s );

            _else

                /*
                ** Some other ID type, so return it.
                */

                yylval->idStr = hlastrdup2( yytext );   
                _return UndefID;

            _endif


        _else
                    
            /*
            ** It's an undefined identifier, so just return it.
            */

            yylval->idStr = hlastrdup2( yytext );   
            _return UndefID;

        _endif
    }




 /*
 ** @string:id is a special token that converts a text ID
 ** into a string constant.
 */


 
{a_string}:[a-z_][a-z0-9_]* {

            int     LastWasGraph = 0;
            int     CurIsGraph;
            char    *s;
            char    DestStr[ maxInputLineLen ];
            char    temp[ maxInputLineLen ];
            struct  SymNode *sym;

            _here;
            sym = lookup( yytext + 8, 1 );
            _if( sym == NULL || sym->pType != tText )
            
                ErrorNear
                (
                    "Expected TEXT constant identifier",
                    yytext,
                    __LINE__,
                    __FILE__
                );
                s = " ";    // Return one char to keep the parser happy.
                
            _else
            
                s = sym->u.strval;
                
            _endif
            DestStr[ 0 ] = '\0';
            _while( *s != '\0' )
            
                /*
                ** if the character is printable, go ahead and
                ** print it, if not, print it in hexadecimal
                ** notation.
                **
                ** Note: this code prints the quotes as a hexadecimal value.
                */
                
                CurIsGraph = ( isgraph( *s ) && *s != '"') || *s == ' ';
                _if( CurIsGraph && !LastWasGraph )

                    strcat( DestStr, " \"" );

                _endif
                _if( CurIsGraph )
                
                    sprintf
                    (
                        temp, 
                        "%c", 
                        *s
                    );
                    strcat( DestStr, temp );

                _else

                    _if( LastWasGraph )

                        strcat( DestStr, "\" " );

                    _endif
                    sprintf( temp, "#$%x", *s );
                    strcat( DestStr, temp );

                _endif
                    
                ++s;
                LastWasGraph = CurIsGraph;
            
            _endwhile
            _if( LastWasGraph )

                strcat( DestStr, "\"" );

            _endif
            PushBackStr( DestStr );
            _here;
        }


 /*
 ** @tostring:id is a special token that converts a TEXT ID to a string ID
 ** and then returns the ID.
 */
 
{a_tostring}:[a-z_][a-z0-9_]* {

            int     CurIsGraph;
            char    *s;
            char    DestStr[ maxInputLineLen ];
            char    temp[ maxInputLineLen ];
            struct  SymNode *sym;

            _here;
            sym = lookup( yytext + 10, 1 );
            _if( sym == NULL || sym->pType != tText )
            
                ErrorNear
                (
                    "Expected TEXT constant identifier",
                    yytext,
                    __LINE__,
                    __FILE__
                );
                
            _else
            
                sym->pType = tString;
                sym->Type = &string_ste;
                
            _endif
            PushBackStr( yytext + 10 );
            _here;
        }

 /*
 ** @global:identifier- tells lookup function to use
 ** NSGlobal as pointer to symbol table.
 */

{a_global}:[a-z_][a-z0-9_]*    {

        /*
        ** Just ignore the @global: prefix if we're not in a namespace.
        */
        
        _if( NSGlobal == NULL )
        
            PushBackStr( yytext+8 );
            
        _else // We're currently in a namespace.
        
            struct  SymNode *symbol;
            int             Token;
            int             symLexLevel;

            int             saveInNamespace = inNamespace;
        

            /*
            ** In the event we are processing a class ID,
            ** initialize the "ClassID" string to empty
            ** so we can capture the full "path" of the
            ** class identifier sequence (in case we have
            ** to push the name back onto the lexer
            ** input).
            */

            _here;
            ClassID[0] = '\0';


            /*
            ** Begin by assuming that this is *not* a
            ** class identifier.
            */

            CurObject = NULL;

            /*
            ** Parser expects us to look up the symbol
            ** before returning the ID token.  If we're
            ** currently in a namespace, search for the
            ** symbol outside that namespace.
            */

            symbol = NULL;
            symLexLevel = 0;

                
            inNamespace = 0;
            symbol = lookupin( yytext+8, NSGlobal );
            symLexLevel = NSGlobal->LexLevel;
            inNamespace = saveInNamespace;

            yylval->s = symbol;
            Token = ProcessID( yytext+8, symLexLevel, symbol, yylval );

            /*
            ** Namespace, text, and macro symbols
            ** do not return control directly to the
            ** parser.  ProcessID, above, returns -1/-2
            ** for text/macro symbols, and -3 for namespace
            ** symbols.  In the
            ** case of namespace and class symbols, ProcessID
            ** also sets the start condition to either
            ** <namespace> allows the
            ** lexer to handle the rest of the identifier.
            ** For all other symbol types, the following 
            ** statement returns control to the parser.
            */

            _returnif( Token >= 0 ) Token;

            /*
            ** If this is a class object, CurObject
            ** needs to point at the leftmost name (the
            ** object name) in the "dot-path" (fully qualified)
            ** list of identifiers.  Since this regular expression
            ** matches that leftmost identifier, save
            ** the address of this symbol before passing
            ** control to the <ClassSpace> regular
            ** expression.
            */

            CurObject = symbol;
            _if( Token == -3 && symbol->SymClass != cNamespace )
            
                LastRefdObject = symbol;

            _endif
            
        _endif
        _here;
    }





 /*
 ** Here's a special token to trap any other identifiers
 ** that look like built-in functions.
 */

@[a-z0-9_]*     {
                    char msg[ 256 ];

                    sprintf
                    ( 
                        msg,
                        "Unknown HLA compiler ID (%s)",
                        yytext
                    );
                    yyerror( msg );
                }




 /*
 ** Here's a special token to trap any other identifiers
 ** that look like a reserved word.
 */

~[a-z0-9_]*         {
                    char msg[ 256 ];

                    sprintf
                    ( 
                        msg,
                        "Unknown HLA reserved word (%s)",
                        yytext
                    );
                    yyerror( msg );
                }




 /*
 ** This is a special symbol that will cause yyparse to
 ** process macro parameters on a recursive call to yyparse.
 */


\xFC            {
                    _here;  
                    yylval->s = yySymbol;
                    _return MacroID;    
                }


 /*
 ** This is a special symbol that will cause yyparse to process
 ** one VAL statement via a recursive call to yyparse.  This
 ** handles the "?" operator.
 */

"?"             { 
                    _here;
                    PushBackStr( "\xFB" );
                    yyparse();
                    _here;
                }   

\xFB            {
                    _here;
                    _return DoOneValStmt;
                }

 /*
 ** This is a special symbol that will cause yyparse to process
 ** a constant expression enclosed within parentheses.
 ** This is used for conditional assembly and other places we need
 ** to process an expression inside the lexer.
 */

\xFA            {
                    _here;
                    _return DoOneConstExpr;
                }




 /*
 ** If a 0xF5 byte comes along, we need to call the parser to
 ** process an HLA identifier (generally, a class/object reference).
 */

\xF5    {
            _here;
            yylval->s = CurObject;  /* CurObject was set up by ProcessID */
            _return parseHLAIDTkn;
        }



 /*
 ** If a 0xF4 byte comes along, we need to call the parser to
 ** process an HLA identifier ( a class reference).
 */

\xF4    {
            _here;
            yylval->s = CurObject;  /* CurObject was set up by ProcessID */
            _return parseClassIDTkn;
        }

 /*
 ** If a 0xF3 byte comes along, set the "InvisibleCode" string to NULL
 ** since we're done processing the _Initialize_ or _Finalize_ strings.
 */

\xF3    {
            InvisibleCode = NULL;
        }



 /*
 ** If a 0xF2 byte comes along, we need to call the parser to
 ** process the #print parameter list.
 */

\xF2    {
            _here;
            _return parsePrintTkn;
        }


 /*
 ** If a 0xF1 byte comes along, we need to call the parser to
 ** process the #text( ID ) .. #endtext block.
 */

\xF1    {
            _here;
            _return textblockTkn;
        }


 /*
 ** If an 0xE0 byte comes along, we need to call the parser to
 ** process the #string( ID ) .. #endstring block.
 */

\xE0    {
            _here;
            _return stringblockTkn;
        }


 /*
 ** If a 0xDF byte comes along, we need to call the parser to
 ** process the #match( ID ) .. #endmatch block.
 */

\xDF    {
            _here;
            _return matchblockTkn;
        }


 /*
 ** If a 0xE2 byte comes along, we need to tell the
 ** parser to begin compiling a regular expression.
 */

\xE2    {
            _here;
            _return compileRegexTkn;
        }

 /*
 ** E3 bytes mean that we've seen a #endregex, either at the
 ** end of a #regex definition (handled elsewhere) or while
 ** compiling a regex in memory (which is what this case handles).
 */

\xE3    {
            _here; 
            _return endregexTkn;    
        }
		
 /*
 ** If an E1 byte comes along, then the lexer needs to grab everything up
 ** to the \xE3 byte and return all this as a string to the parser.
 ** This data is the #return expression for a regular expression. We need
 ** to have the lexer process everything in order to expand local regex
 ** symbols and parameters.
 */
 
\xE1		{
			int 	Token;
			int		resultLen;
			char	*resultStr;
			
			resultLen = 0;
			resultStr = hlastrdup( "" );
			
			_do
			
				Token = yylex( yylval, yylloc );
				_if( Token != endregexTkn )
				
					resultStr = realloc( resultStr, resultLen+yyleng+2 );
					resultStr[ resultLen ] = ' ';
					strncpy( resultStr+resultLen+1, yytext, yyleng );
					resultLen += yyleng+1;
					resultStr[ resultLen ] = '\0';
					
				_endif
				
			_until( Token == endregexTkn );
			PushBackStr( "\xE3" ); // So the parser will see this, too.
			
            yylval->v.u.lwordval[0] = 0;
            yylval->v.u.lwordval[1] = 0;
            yylval->v.u.lwordval[2] = 0;
            yylval->v.u.lwordval[3] = 0;
            yylval->v.u.strval = resultStr;
            yylval->v.pType     = tString;
            yylval->v.Type      = &string_ste;
            yylval->v.SymClass  = cConstant;
            ClrArray( yylval );
            _return strconst;   
		}




 /*
 ** If a 0xDE byte comes along, we need to return ovldClassTkn
 ** so the parser can handle an overloaded class ID.
 */

\xDE    {
            _here;
            _return ovldClassTkn;
        }



 /*
 ** If a 0xDD byte comes along, we need to set delayCollect to false.
 */

\xDD    {
            _here;
            delayCollect = 0;
        }



 /*
 ** Identifiers
 */
 
 /*
 ** Handle the "this" keyword here.  "This" is valid only inside
 ** a method or class procedure.  If we are inside such a program
 ** unit, then the "ThisPtr" variable will be non-null and will
 ** point at the class definition's symbol table entry.
 */

{_this}             {
                        _here;
                        _if( ThisPtr == NULL )

                            yyerror
                            ( 
                                "Misuse of THIS reserved word outside class" 
                            );

                        _else


                            CurSymTbl = ThisPtr;
                            CurObject = ThisPtr;
                            BEGIN ThisID;

                        _endif
                        _here;
                    }

 

 /*
 ** Handle fields of a class identifier down here.
 **
 ** Hack: This code needs to expand TEXT and MACRO IDs
 ** directly but pass all other IDs to the parser for
 ** further processing.  This code processes the field
 ** names down to the first field that is not a class type.
 ** If the specified object is a TEXT or MACRO object, then
 ** this code directly expands that object.  If the first
 ** non-class field is a constant, then this code returns
 ** that constant (or value) object as though the lexer had
 ** only seen a single identifier (no fields).  If we've got
 ** some sort of variable access, this code pushes the string
 ** it has scanned back onto the lexer input and leaves it
 ** up to the parser to extract each field from this string.
 ** This kludge is necessary in order to properly process
 ** text and macro objects.
 */


<ThisID>"."[a-z_][a-z0-9_]* {

                        int             Token;
                        struct  SymNode *SaveSym;
                        struct  SymNode *s;
                        struct  SymNode *symbol;
                        char            msg[ 256 ];

                        
                        /*
                        ** Look up this field name in the local
                        ** symbol table for the class.  CurSymTbl
                        ** points at the last fieldname we've processed.
                        ** yytext (+1) is pointing at the current field name.
                        */

                        _here;

                        symbol = lookupthis( yytext+1, CurSymTbl->Fields );
                        BEGIN 0;
                        _if( symbol != NULL )


                            /*
                            ** If this is a macro or text object,
                            ** expand it here.  If it is a constant,
                            ** return a pointer to the constant's (or
                            ** value's) symbol table entry. If it is
                            ** not one of these classes, then reconstruct
                            ** the id for reprocessing via the lexer.
                            */

                            Token = 
                                ProcessID
                                ( 
                                    yytext+1, 
                                    CurSymTbl->Fields->LexLevel,
                                    symbol, 
                                    yylval 
                                );

                        _else
                        
                            Token = -1;  // Arbitrary negative value to
                                         // signal an error.

                        _endif

                        _if( Token >= 0 )

                            /*
                            ** If what we've got is a constant,
                            ** value, procedure, iterator, or method object, 
                            ** just return that symbol.
                            */

                            _if
                            ( 
                                    Token == LocalConstID
                                ||  Token == NonLocalConstID
                            )

                                yylval->s = symbol;
                                _return Token;

                            _elseif
                            (
                                    Token == LocalProcID
                                ||  Token == ClassProcID
                                ||  Token == ClassIterID
                                ||  Token == LocalMethodID 
                                ||  Token == NonLocalProcID
                                ||  Token == NonLocalMethodID 
                                ||  Token == OverloadedID 
                            )

                                /*
                                ** If it's a procedure name
                                ** following "this.", then
                                ** emit "(type classname [esi])."
                                ** in place of "this."
                                */

                                sprintf
                                (
                                    msg,
                                    "(type %s [esi])%s",
                                    CurSymTbl->TrueName,
                                    yytext
                                );
                                PushBackStr( msg );

                            _else

                                /*
                                ** Because this is a class object, the
                                ** symbol is always non-local. Just check
                                ** to see if it's a static, var, or other
                                ** type object.
                                */

                                yylval->s = symbol;
                                _returnif
                                ( 
                                        symbol->SymClass == cVar 
                                    ||  symbol->SymClass == cParm 
                                )
                                    ClassVarID;
									
                                _returnif( symbol->SymClass == cStatic )
                                        ClassStaticID;
										
                                _return NonLocalID;

                            _endif

                        _else

                            /*
                            ** We've got something unexpected if we
                            ** get to this point.
                            */

                            sprintf
                            (
                                msg,
                                "Unexpected symbol 'this.%s' at line %d in lexer",
                                yytext+1,
                                __LINE__,
                                __FILE__
                            );
                            yyerror( msg );

                        _endif
                        _here;
                    }


 /*
 ** If we get down here, something other than a fieldname followed
 ** the "this" keyword.
 */

<ThisID>(.|\n)      {
                        ErrorNear
                        ( 
                            "Illegal use of THIS keyword", 
                            yytext,
                            __LINE__,
                            __FILE__ 
                        );
                        PushBackStr( yytext );
                        BEGIN 0;
                    }







 /*
 ** Handle standard IDs here.
 */

\`$[a-f0-9]+:[a-z_][a-z0-9_]*   { 
                        int Token;
                        
                        Token =  doID( yylval ); 
                        _returnif( Token >= 0 ) Token;
                    }
                    
        
\`[a-z_][a-z0-9_]*  { 
                        int Token;
                        
                        Token = doID( yylval ); 
                        _returnif( Token >= 0 ) Token;
                    }
                    
[a-z_][a-z0-9_]*    { 
                        int Token;
                        Token = doID( yylval ); 
                        _returnif( Token >= 0 ) Token;
                    }
                    
        




 /*
 ** Handle fields of a namespace identifier down here.
 */


<NameSpace>"."[a-z_][a-z0-9_]* {

            int             Token;
            int             LexLevel;
			int				saveIndex;
            struct  SymNode *symbol;
            struct  SymNode *saveCurNS;
            struct  SymNode *saveSymTbl;
            struct  SymNode *NS;

            _here;

            saveCurNS 	= currentNS;
            currentNS 	= CurSymTbl;
			NS			= CurSymTbl;
            saveSymTbl 	= SymbolTable;
            SymbolTable = CurSymTbl->Fields;

            symbol = NSlookup( yytext + 1, 1, currentNS );
            
            SymbolTable = saveSymTbl;
            currentNS = saveCurNS;

            LexLevel = CurSymTbl->Fields->LexLevel;
            
            /*
            ** If the symbol is not defined, see if we're constructing
            ** a namespace at this point.  If we are, search in the
            ** global symbol table for this object.
            */

            _if( symbol == NULL && NSGlobal != NULL )

                symbol = lookupin( yytext+1, NSGlobal );
                LexLevel = NSGlobal->LexLevel;

            _endif

            _if( symbol != NULL && symbol->pType == tNamespace )

                CurSymTbl = symbol;

            _else

                BEGIN 0;
				saveIndex = collectIndex;
                Token = 
                    ProcessID
                    ( 
                        yytext + 1, 
                        LexLevel, 
                        symbol, 
                        yylval 
                    );

                _returnif( Token >= 0 ) Token;
				
				// If it was a text object delete the original namespace name:
				
				_if( Token == PIDtext && doCollect )
				
					collectIndex -= ( strlen( NS->TrueName ) + 1);
					collectBuf[ collectIndex ] = '\0';
					
				_endif

            _endif
            _here;
        }



<NameSpace>(.|\n)   {

            _here;
            PushBackStr( yytext );
            BEGIN 0;

            _if( CurSymTbl->LexLevel == CurLexLevel )

                yylval->s = CurSymTbl;
                _return LocalID;

            _else

                yylval->s = CurSymTbl;
                _return NonLocalID;

            _endif
            _here;
        }





 /*
 ** Single digit integer constants (this definition is necessary in order
 ** to make it easy to differentiate floating point and integer literal 
 ** constants).  Note also the version that allows ".." afterwards.
 ** This is to differentiate the zero in "if( al in 0..10 ) then" from a 
 ** floating point constant.
 */
    
[0-9]   {
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tUns8,
                &uns8_ste
            );
            yylval->v.u.unsval = *yytext - '0';
            yylval->v.ObjectSize = 1;
            yylval->v.MaxObjectSize = 1;
            _return intconst;   
        }

[0-9]/".."  {
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tUns8,
                &uns8_ste
            );
            yylval->v.u.unsval = *yytext - '0';
            yylval->v.ObjectSize = 1;
            yylval->v.MaxObjectSize = 1;
            _return intconst;   
        }

 /*
 ** Integer (unsigned) constants containing two or more digits.
 ** Interior characters may include underscores.  See the note
 ** above about the version with "..".
 */

[0-9][0-9_]*[0-9]   {
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tUns32,
                &uns32_ste
            );
            strip_();
            DecStrToInt
            ( 
                numstr, 
                yylval->v.u.lwordval,
                &yylval->v.Type,
                &yylval->v.pType                 
            );
            yylval->v.ObjectSize = yylval->v.Type->ObjectSize;
            yylval->v.MaxObjectSize = yylval->v.Type->MaxObjectSize;
            _here;
            _return intconst;   
        }

[0-9][0-9_]*[0-9]/".."  {
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tUns8,
                &uns8_ste
            );
            strip_();
            DecStrToInt
            ( 
                numstr, 
                yylval->v.u.lwordval,
                &yylval->v.Type,
                &yylval->v.pType                 
            );
            yylval->v.ObjectSize = yylval->v.Type->ObjectSize;
            yylval->v.MaxObjectSize = yylval->v.Type->MaxObjectSize;
            _here;
            _return intconst;   
        }

 /*
 ** Hexadecimal literal constants.
 ** Interior characters may include underscores.
 */

\$[0-9a-f]([0-9a-f_]*[0-9a-f])? {
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tDWord,
                &dword_ste
            );
            strip_();
            HexStrToInt
            ( 
                numstr, 
                yylval->v.u.lwordval,
                &yylval->v.Type,
                &yylval->v.pType                 
            );
            yylval->v.ObjectSize = yylval->v.Type->ObjectSize;
            yylval->v.MaxObjectSize = yylval->v.Type->MaxObjectSize;
            _here;
            _return hexconst;   
        }


 /*
 ** Binary literal constants.
 ** Interior characters may include underscores.
 */

\%[0-1]([0-1_]*[0-1])?  {
            ClrConst
            (
                YYS &yylval->v,
                tDWord,
                &dword_ste
            );
            strip_();
            BinStrToInt
            ( 
                numstr, 
                yylval->v.u.lwordval,
                &yylval->v.Type,
                &yylval->v.pType                 
            );
            yylval->v.ObjectSize = yylval->v.Type->ObjectSize;
            yylval->v.MaxObjectSize = yylval->v.Type->MaxObjectSize;
            _here;
            _return binconst;
        }

 /*
 ** Floating point literal constants.
 ** Interior characters may include underscores.
 */

[0-9]([0-9_]*[0-9])?(\.(([0-9][0-9_]*[0-9])|[0-9]+)?)?(e[-+]?[0-9]+)?  {
 
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tReal80,
                &real80_ste
            );
            strip_();
            atold( &yylval->v.u.fltval, numstr );
            yylval->v.ObjectSize = 10;
            yylval->v.MaxObjectSize = 10;
            _here;
            _return fltconst;   
        }

 /*
 ** The apostrophe literal character constant ('''').
 */

\'\'\'\'  { 
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tChar,
                &char_ste
            );
            yylval->v.u.charval = '\'';
            _return charconst; 
        }

u\'\'\'\'  { 
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tWChar,
                &wchar_ste
            );
            yylval->v.u.charval = '\'';
            _return wcharconst; 
        }

 /*
 ** Single character literal constants.
 ** These come in two varieties: literal character constants surrounded by
 ** a pair of apostrophes and numeric character constants that consist of
 ** a "#" followed by a decimal, binary, or hexadecimal constant.  
 ** Note that underscores are *not* allowed in the hex or decimal constants
 ** (because they are always three digits or less [ignoring leading zeros])
 ** but they are allowed in binary constants.
 */


\'.\'   { 
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tChar,
                &char_ste
            );
            yylval->v.u.charval = yytext[1];
            _return charconst; 
        }



u\'.\'  { 
            _here;
            ClrConst
            (
                YYS &yylval->v,
                tWChar,
                &wchar_ste
            );
            yylval->v.u.charval = yytext[2];
            _return wcharconst; 
        }



 /*
 ** Character literal constants that use binary numbers.
 */

#%[0-1]([0-1_]*[0-1])?  {
                unsigned value = 0;
                char *s=yytext+2;

                _here;
                _while( *s != '\0' )

                    _if( *s != '_' )
                    
                        value = ( value << 1 ) | ( *s & 1 );

                    _endif
                    ++s;

                _endwhile
                _if( !IntRange( value, 0, 255 ))
                
                    yyerror( "ASCII codes must be in the range 0..255" );
                    value &= 0xff;

                _endif
                ClrConst
                (
                    YYS &yylval->v,
                    tChar,
                    &char_ste
                );
                yylval->v.u.charval = value; 
                _here;
                _return charconst;  
            }




u#%[0-1]([0-1_]*[0-1])? {
                unsigned value = 0;
                char *s=yytext+3;

                _here;
                _while( *s != '\0' )

                    _if( *s != '_' )
                    
                        value = ( value << 1 ) | ( *s & 1 );

                    _endif
                    ++s;

                _endwhile
                _if( !IntRange( value, 0, 65535 ))
                
                    yyerror( "Unicode must be in the range 0..65535" );
                    value &= 0xffff;

                _endif
                ClrConst
                (
                    YYS &yylval->v,
                    tWChar,
                    &wchar_ste
                );
                yylval->v.u.unsval = value; 
                _here;
                _return wcharconst; 
            }



 /*
 ** Handle character hexadecimal literal constants here.
 */

#$[0-9a-f]+ {
                _here;
                ClrConst
                (
                    YYS &yylval->v,
                    tChar,
                    &char_ste
                );
                sscanf
                ( 
                    yytext+2, 
                    "%x", 
                    &yylval->v.u.charval 
                );
                _if( !IntRange( yylval->v.u.charval, 0, 255 ))
                
                    yyerror( "ASCII codes must be in the range 0..255" );
                    yylval->v.u.charval &= 0xff;

                _endif 
                _here;
                _return charconst;  
            }



u#$[0-9a-f]+    {
                _here;
                ClrConst
                (
                    YYS &yylval->v,
                    tWChar,
                    &wchar_ste
                );
                sscanf
                ( 
                    yytext+3, 
                    "%x", 
                    &yylval->v.u.unsval 
                );
                _if( !IntRange( yylval->v.u.unsval, 0, 65535 ))
                
                    yyerror( "Unicode values must be in the range 0..65535" );
                    yylval->v.u.unsval &= 0xffff;

                _endif 
                _here;
                _return wcharconst; 
            }



 /*
 ** Handle character decimal literal constants here.  Since only
 ** three digits are necessary to specify an eight-bit ASCII code, don't
 ** bother dealing with underscores.
 */

#[0-9]+     {
                _here;
                ClrConst
                (
                    YYS &yylval->v,
                    tChar,
                    &char_ste
                );
                yylval->v.u.charval = atol( yytext+1 );
                _if( !IntRange( yylval->v.u.charval, 0, 255 ))
                
                    yyerror( "ASCII codes must be in the range 0..255" );
                    yylval->v.u.charval &= 0xff;

                _endif
                _here;
                _return charconst;  
            }



u#[0-9]+        {
                _here;
                ClrConst
                (
                    YYS &yylval->v,
                    tWChar,
                    &wchar_ste
                );
                yylval->v.u.unsval = atol( yytext+2 );
                _if( !IntRange( yylval->v.u.unsval, 0, 65535 ))
                
                    yyerror( "Unicode must be in the range 0..65535" );
                    yylval->v.u.unsval &= 0xffff;

                _endif
                _here;
                _return wcharconst; 
            }



 /*
 ** #{identifier}
 **
 ** Handle illegal compiler directives here.
 */

#[a-z_][a-z0-9_]*   { 
                        ErrorNear
                        ( 
                            "Illegal compiler directive", 
                            yytext ,
                            __LINE__,
                            __FILE__
                        );  
                    }



 /*
 ** Literal string constants.
 */

\"([^\"\n]|\"\")*\" { 
                        _here;
                        yylval->v.u.lwordval[0] = 0;
                        yylval->v.u.lwordval[1] = 0;
                        yylval->v.u.lwordval[2] = 0;
                        yylval->v.u.lwordval[3] = 0;
                        yylval->v.u.strval = MakeStr();
                        yylval->v.pType     = tString;
                        yylval->v.Type      = &string_ste;
                        yylval->v.SymClass  = cConstant;
                        ClrArray( yylval );
                        _return strconst;   
                    }

u\"([^\"\n]|\"\")*\"    { 
                        _here;
                        yylval->v.u.lwordval[0] = 0;
                        yylval->v.u.lwordval[1] = 0;
                        yylval->v.u.lwordval[2] = 0;
                        yylval->v.u.lwordval[3] = 0;
                        yylval->v.u.strval = MakeUStr();
                        yylval->v.pType     = tWString;
                        yylval->v.Type      = &wstring_ste;
                        yylval->v.SymClass  = cConstant;
                        ClrArray( yylval );
                        _return wstrconst;  
                    }

 /*
 ** Whitespace
 ** Note: Because saving Windows files to other file systems (e.g., 
 ** Mac/Linux) can sometimes result in NUL characters being added to
 ** the end of the file (bad editor!), we'll treat NUL characters
 ** like white space characters. 
 */

[\ \t\000]+ {}
\r\n        { 
                _here;
                ++LineCnt;
                ++TotalLines;

            }

\n          { 
                _here;
                ++LineCnt;
                ++TotalLines;
            }

\r          { 
                _here;
                ++LineCnt;
                ++TotalLines;
            }



 /*
 ** End of file
 */
 
<<EOF>>     {
                _returnif( BufSP < 0 ) -1; 
                deleteSourceBuf(); 
            }

 /*
 ** End of macro expansion
 */
 
\xff        {
                EndMacroExpansion();
            }



    


 /*
 ** Leftover characters not handled by the above regular expressions.
 */

.           {
                sprintf
                ( 
                    numstr, 
                    "Illegal character in file: <%c>(%d/$%x)", 
                    *yytext,
                    *yytext,
                    *yytext 
                ); 
                yyerror( numstr );
            }

%%


int
yywrap( void )
_begin( yywrap )

    _return 1;
    
_end( yywrap )

// prefixName - Returns a string containing the prefix
// of a filename

static void
prefixName( char *filename, char *result )
_begin( prefixName )

    char *root;
    int  len;
    
    root = strrchr( filename, '\\' );
	_if( root == NULL )
	
		root = strrchr( filename, '/' );
		
	_endif
    _if( root == NULL )

        strcpy( result, "" );

    _else

        len = root - filename + 1;
        strncpy( result, filename, len );
        result[ len ] = '\0';

    _endif

_end( prefixName )

/*
** Add an include file to the IncFilesList array.
** Return false if the file was already in the list.
** Return true if we added the file to the list (because it wasn't
** already there).  Raise an exception if we exceed 'maxNestedMacros' include
** files.
*/

int 
AddIncFilesList( char *filename )
_begin( AddIncFilesList )

    int i;
    int Result = 0;

    assert( filename != NULL );
    i = 0; 
    _while
    ( 
            ( i < IncFilesCnt )
        &&  ( stricmp( filename, IncFilesList[ i ] ) != 0 )
    )

        ++i;

    _endwhile

    _if( i == IncFilesCnt )

        IncFilesList[ i ] = hlastrdup2( filename );
        Result = 1;
        ++IncFilesCnt;
        assert( IncFilesCnt < maxIncStack );

    _endif
    _return( Result );

_end( AddIncFileList )




int
lexInput( void )
_begin( lexInput )
    
    _return input();

_end( lexInput )


/***********************************************/
/*                                             */
/* startUnprocessedID-                         */
/*                                             */
/* This function switches on the UnprocessedID */
/* state so that the lexer doesn't process IDs */
/* (by calling ProcessID) it encounters during */
/* scanning.                                   */
/*                                             */
/***********************************************/

void
startUnprocessedID( void )
_begin( startUnprocessedID )

    BEGIN UnprocessedID;

_end( startUnprocessedID )

void
Begin0( void )
_begin( Begin0 )

    BEGIN 0;

_end( Begin0 )



/*********************************************************/
/*                                                       */
/* startGetTextBlock-                                    */
/*                                                       */
/* This function is used by the #text..#endtext sequence */
/* to enable capturing the text between the #text and    */
/* the #endtext clauses.                                 */
/*                                                       */
/*********************************************************/

void
startGetTextBlock( void )
_begin( startGetTextBlock )

    BEGIN InText;

_end( startGetTextBlock )



/*************************************************************/
/*                                                           */
/* startGetStringBlock-                                      */
/*                                                           */
/* This function is used by the #string..#endstring sequence */
/* to enable capturing the text between the #string and      */
/* the #endstring clauses.                                   */
/*                                                           */
/*************************************************************/

void
startGetStringBlock( void )
_begin( startGetStringBlock )

    BEGIN InString;

_end( startGetStringBlock )



/*************************************************************/
/*                                                           */
/* startGetMatchBlock-                                       */
/*                                                           */
/* This function is used by the #match..#endmatch sequence   */
/* to enable capturing the text between the #match and       */
/* the #endmatch clauses.                                    */
/*                                                           */
/*************************************************************/

void
startGetMatchBlock( void )
_begin( startGetMatchBlock )

    BEGIN InMatch;

_end( startGetMatchBlock )



///////////////////////////////////////////////////////////////////////////////
//
// Regular Expression recording support:

void
doRecRegex( void )
_begin( doRecRegex )

    _here;
    regexHead = NULL;
    
    // Shove 0xE2 at the beginning of the
    // regular expression text so that the
    // parser will know to compile the
    // regular expression.
    
    CurLine[ 0 ] = '\xE2'; 
    RegexIndex = 1;
    BEGIN RecordRegex;
    _here;

_end( doRecRegex )





static void
AppendRegexLine( void )
_begin( AppendRegexLine )

    struct MacroListType *NewLine;

    _here;
    
    _if( regexHead == NULL )
    
        regexHead = malloc2( sizeof( MacroHead_t ));
        regexHead->text = malloc2( RegexIndex + 2 );
        memcpy( regexHead->text, CurLine, RegexIndex );
        regexHead->len = RegexIndex;
        regexHead->text[ RegexIndex ] = '\0';
        regexHead->text[ RegexIndex + 1 ] = '\0';
        RegexIndex = 0;
        
    _else
    
        regexHead->text = 
            realloc2( regexHead->text, RegexIndex+regexHead->len + 2 );

        memcpy( &regexHead->text[regexHead->len], CurLine, RegexIndex );
        regexHead->len += RegexIndex;
        regexHead->text[ regexHead->len ] = '\0';
        regexHead->text[ regexHead->len + 1 ] = '\0';
        RegexIndex = 0;
        
    _endif 
    _here;

_end( AppendRegexLine )



    


/***********************************************/
/*                                             */
/* doRecMac-                                   */
/*                                             */
/* This function enables recording of a macro. */
/*                                             */
/***********************************************/


void
doRecMac( void )
_begin( doRecMac )

    _here;
    macroHead = NULL;
    MacroIndex = 0;
    BEGIN RecordMacro;
    NestedMacroCnt = 1;
    _here;

_end( doRecMac )



static void
AppendMacroLine( void )
_begin( AppendMacroLine )

    struct MacroListType *NewLine;

    _here;
    
    _if( macroHead == NULL )
    
        macroHead = malloc2( sizeof( MacroHead_t ));
        macroHead->text = malloc2( MacroIndex + 2 );
        memcpy( macroHead->text, CurLine, MacroIndex );
        macroHead->len = MacroIndex;
        macroHead->text[ MacroIndex ] = '\0';
        macroHead->text[ MacroIndex + 1 ] = '\0';
        MacroIndex = 0;
        
    _else
    
        macroHead->text = 
            realloc2( macroHead->text, MacroIndex+macroHead->len + 2 );

        memcpy( &macroHead->text[macroHead->len], CurLine, MacroIndex );
        macroHead->len += MacroIndex;
        macroHead->text[ macroHead->len ] = '\0';
        macroHead->text[ macroHead->len + 1 ] = '\0';
        MacroIndex = 0;
        
    _endif 
    _here;

_end( AppendMacroLine )



    



void
doMacParm( void )
_begin( doMacParm )

    ParmLine_t  *prev;

    _here;
    prev = ParmLine;
    ParmLine = malloc2( sizeof( ParmLine_t ));
    BEGIN MacroParm;
    ParmLine->prev = prev;
    ParmLine->Line = NULL;
    ParmLine->LineSize = 0;
    ParmLine->Index = 0;
    ParmLine->ParenCnt = 0;
    ParmLine->BraceCnt = 0;
    ParmLine->BracketCnt = 0;
    _here;

_end( doMacParm )


/*
** RmvActiveMacro-
**
**  A macro has just terminated.  This routine cleans up all the
**  dynamically allocated storage associated with that macro.
**  This, effectively, undoes the mess created by the ID regular
**  expression when it encounters a macro symbol.
**
**  mac2rmv- Symbol to remove from the active list.
**
**  FreeMem- Controls whether we free the memory associated with
**           this macro and whether we attempt to remove it from
**           the active list.
**
**              0- Just remove from the active list, do not free memory.
**              1- Free memory and remove from the active list.
**              2- Just free the memory (already removed from list).
*/

void
RmvActiveMacro( struct SymNode *mac2rmv )
_begin( RmvActiveMacro )

    struct  SymNode *LclSym;
    struct  SymNode *tmp;
    struct  SymNode **AList;

    assert( ActiveMacros != NULL );
    assert( mac2rmv != NULL );

    /*
    ** If this is a terminator, remove the parent macro as well.
    */

    _here;
    _if( mac2rmv->SymClass == cTerminator )

        assert( mac2rmv->u.MacroData.Parent != NULL );
        RmvActiveMacro( mac2rmv->u.MacroData.Parent );
        FileName = mac2rmv->u.MacroData.Parent->u.MacroData.Filename;
        LineCnt = mac2rmv->u.MacroData.Parent->u.MacroData.LineCnt;

    _endif

    /*
    ** Next, delete this entry from the ActiveMacros list, if this
    ** is not a recursive call to clean up the storage.
    */

    AList  = &ActiveMacros;
    LclSym = ActiveMacros;
    _while( LclSym != mac2rmv )

        assert( LclSym != NULL );

        AList  = &LclSym->Next;
        LclSym = LclSym->Next;

    _endwhile
    *AList = LclSym->Next;


    /*
    ** Now, free up the storage associated with this symbol.
    */

    LclSym = 
        _ifx
        (
            mac2rmv->u.MacroData.Terminator != NULL,
            mac2rmv->u.MacroData.Terminator,
            _ifx
            (
                mac2rmv->u.MacroData.Locals != NULL,
                mac2rmv->u.MacroData.Locals,
                mac2rmv->u.MacroData.Parameters
            )
        );

    _while( LclSym != NULL )

        tmp = LclSym;
        LclSym = LclSym->Next;

        _if( tmp->pType != tMacro )

            FreeValue( YYS tmp );

        _endif
        free2( vss tmp );

    _endwhile
    free2( vss mac2rmv );
    _here;


_end( RmvActiveMacro )


/*
** pushBufStack - pushes an item onto the SourceBuffer stack.
*/

void 
pushBufStack( char *filename, int linecnt, FILE *theFile, char IncOrStr )
_begin( pushBufStack )

    _here;
    ++BufSP;
    _if( BufSP < maxBuffers )
    
        BufferStack[ BufSP ].LineCnt = linecnt;
        BufferStack[ BufSP ].PreviousBuffer = YY_CURRENT_BUFFER;
        BufferStack[ BufSP ].IncFile = theFile;
        BufferStack[ BufSP ].FileName = filename;
        BufferStack[ BufSP ].IncludeOrString = IncOrStr;        
    
    _else
    
        yyerror( "HLA text buffer redirection stack overflow" );
        exit( 1 );
        
    _endif
    _here;

_end( pushBufStack )


 /*
 ** deleteSourceBuf - pops an input buffer from the input
 ** buffer stack.
 */

void
deleteSourceBuf( void )
_begin( deleteSourceBuf )

    assert( BufSP >= 0 );
    yy_delete_buffer( YY_CURRENT_BUFFER );
    yy_switch_to_buffer( BufferStack[ BufSP ].PreviousBuffer );
    _if( BufferStack[ BufSP ].IncludeOrString )
    
        fclose( BufferStack[ BufSP ].IncFile );

    _endif
    LineCnt =  BufferStack[ BufSP ].LineCnt;
    FileName = BufferStack[ BufSP ].FileName;
    --BufSP;

_end( deleteSourceBuf )


/*
** EndMacroExpansion
*/

void
EndMacroExpansion( void )
_begin( EndMacroExpansion )

    _here;
    assert( MacroSP >= 0 );

    _if( MacroStack[ MacroSP ].Macro->SymClass == cTerminator )

                char    msg[ 256 ];
        struct  SymNode *s;

        _if( W4TermSP < 0 )

            /*
            ** This error should never happen (since terminators
            ** should be on the Wait4Term stack if they are in scope),
            ** but just in case...
            */

            sprintf
            ( 
                msg, 
                "Unexpected terminator (%s)",
                MacroStack[ MacroSP ].Macro->u.MacroData.Terminator->
                                                                TrueName 
            ); 
            yyerror( msg );
            RmvActiveMacro( MacroStack[ MacroSP ].Macro );
            
        _elseif
        ( 
            _strne
            (   
                MacroStack[ MacroSP ].Macro->TrueName,
                Wait4Term[ W4TermSP ]->TrueName
            )
        )

            sprintf
            (
                msg,
                "Unexpected terminator \"%s\", was expecting \"%s\"",
                MacroStack[ MacroSP ].Macro->TrueName,
                Wait4Term[ W4TermSP ]->TrueName
            );
            yyerror( msg );

            --W4TermSP;
            RmvActiveMacro( MacroStack[ MacroSP ].Macro );

        _else


            /*
            ** We've got a terminator that has just finished.
            ** Let's look up it's parent in the ActiveMacros
            ** list and change the parent field of any keywords
            ** (that could still be executing) to NULL so they
            ** cannot refer to free'd memory (since the RmvActiveMacro
            ** call below will free up memory associated with the
            ** parent).
            **
            **  Admittedly, this is very ugly.  Here's how it works:
            **
            **  1.  The top of the MacroStack points at the terminator
            **      that we are shutting down.  The ActiveMacros list
            **      also points at this terminator (actually, the top
            **      of the MacroStack and ActiveMacros point at the
            **      same malloc'd object).
            **
            **  2.  The macro that requires this terminator has
            **      *probably* terminated already, but there is
            **      no guarantee that this has happened (the user
            **      could have invoked the terminator inside the
            **      macro, though this is unlikely). If the parent
            **      macro has not yet terminated, then we cannot
            **      free the storage associated with the parent macro.
            **
            **  3.  It is possible that a keyword for this terminator's
            **      parent is still active (i.e., the keyword invoked
            **      the terminator), if this is the case then we must
            **      clear the keyword's Parent field since we are about
            **      to free the storage associated with the parent.
            **
            **  4.  We begin by locating the parent of the current
            **      terminator macro and search through it's local
            **      symbols list for any keyword entries.  The code
            **      sets the "Parent" field of any such keyword
            **      entries to NULL, effectively cutting off access
            **      to the parent's local symbols.
            */

            struct  SymNode *parent;
            struct  SymNode *pLocals;
            struct  SymNode *AMList;

            parent = MacroStack[ MacroSP ].Macro->u.MacroData.Parent;
            pLocals = parent->u.MacroData.Terminator->Next;
            _while
            ( 
                    pLocals != NULL 
                &&  pLocals != parent->u.MacroData.Locals 
            )

                /*
                ** pLocals points at the first keyword entry for
                ** the parent macro (if such an item exists).
                ** The following loop compares each keyword associated
                ** with this parent against all the active macros.
                ** It bails if it discovers that the parent is still
                ** active (case [2] above or a recursive invocation)
                ** or if it encounters the current keyword.  If it
                ** does encounter the keyword, it sets the Parent
                ** field to NULL.
                */

                AMList = ActiveMacros;
                _forever

                    _breakif( AMList == NULL );
                    _breakif
                    ( 
                        _streq( AMList->TrueName, parent->TrueName )
                    );
                    _if( _streq( AMList->TrueName, pLocals->TrueName) )

                        AMList->u.MacroData.Parent = NULL;
                        break;

                    _endif
                    AMList = AMList->Next;

                _endfor
                pLocals=pLocals->Next;

            _endwhile

            /*
            ** Okay, we just finished execution of a terminator
            ** that we were expecting.  Pop the Wait4Term stack
            ** and remove the terminator from the active macro list.
            */

            RmvActiveMacro( MacroStack[ MacroSP ].Macro );
            --W4TermSP;

        _endif

    _elseif( MacroStack[ MacroSP ].Macro->u.MacroData.Terminator == NULL ) 

        /*
        ** If this macro does not have a terminator
        ** associated with it, remove it from the
        ** active macro list and free its memory.
        **
        */

        RmvActiveMacro( MacroStack[ MacroSP ].Macro );

    _else

        /*
        ** If this macro has a terminator, we'll leave it around
        ** in memory and make it the responsibility of the terminator
        ** to remove it later on.  
        */
        
        struct SymNode  *CurMac;

        CurMac = ActiveMacros;
        _while( CurMac != NULL && CurMac != MacroStack[ MacroSP ].Macro )

            CurMac = CurMac->Next;

        _endwhile
        _if( CurMac != NULL )

            CurMac->u.MacroData.Text = NULL;

        _endif

    _endif

    /*
    ** Since we just concluded playing back this macro/keyword/terminator,
    ** pop the macro stack.
    */

    --MacroSP;
        
    _here;

_end( EndMacroExpansion )






/*******************************/
/*                             */
/* While loop support routines */
/*                             */
/*******************************/


static void
AppendWhileLine( void )
_begin( AppendWhileLine )

    _here;
    _if( WhileHead == NULL )
    
        WhileHead = malloc2( WhileIndex + 3 );
        
        // Sneak a 0xFA character into the first position to force
        // Bison to evaluate an expression:
        
        WhileHead[0] = '\xFA';
        memcpy( WhileHead+1, CurLine, WhileIndex );
        WhileLen = WhileIndex + 1;
        WhileHead[ WhileLen ] = '\0';
        WhileHead[ WhileLen + 1 ] = '\0';
        WhileIndex = 0;
        
    _else
    
        WhileHead = realloc2( WhileHead, WhileIndex + WhileLen + 2 );
        memcpy( WhileHead+WhileLen, CurLine, WhileIndex );
        WhileLen += WhileIndex;
        WhileHead[ WhileLen ] = '\0';
        WhileHead[ WhileLen + 1 ] = '\0';
        WhileIndex = 0;
        
    _endif 
    _here;

_end( AppendWhileLine )



static void
CleanUpWhile( void )
_begin( CleanUpWhile )

    _here;
    _if( WhileSP >= 0 )

        deleteSourceBuf();
        free2( vss WhileStack[ WhileSP ].line );
        --WhileSP;

    _endif

    _here;

_end( CleanUpWhile )


/*******************************/
/*                             */
/* For loop support routines   */
/*                             */
/*******************************/


static void
AppendForLine( void )
_begin( AppendForLine ) 

    _here;
    _if( ForHead == NULL )
    
        ForHead = malloc2( ForIndex + 2 );
        
        // Sneak a 0xFA character into the first position to force
        // Bison to evaluate an expression:
        
        memcpy( ForHead, CurLine, ForIndex );
        ForLen = ForIndex;
        ForHead[ ForLen ] = '\0';
        ForHead[ ForLen + 1 ] = '\0';
        ForIndex = 0;
        
    _else
    
        ForHead = realloc2( ForHead, ForIndex + ForLen + 2 );
        memcpy( ForHead+ForLen, CurLine, ForIndex );
        ForLen += ForIndex;
        ForHead[ ForLen ] = '\0';
        ForHead[ ForLen + 1 ] = '\0';
        ForIndex = 0;
        
    _endif 
    _here;

_end( AppendForLine )



static void
CleanUpFor( void )
_begin( CleanUpFor )

    _here;
    _if( ForSP >= 0 )

        deleteSourceBuf();
        
        // Probably should free inVal here, could be a memory leak.
        
        ForStack[ ForSP ].loopControlVar->pType = tBoolean;
        ForStack[ ForSP ].loopControlVar->Type = &boolean_ste;
        free2( vss ForStack[ ForSP ].line );
        --ForSP;

    _endif
    _here;

_end( CleanUpFor )


/**********************************************************************************/
/*                                                                                */
/* strip_                                                                         */
/*                                                                                */
/* This function removes any underscore characters appearing in the middle of     */
/* a numeric constant (integer, hexadecimal, or float).  HLA allows you to insert */
/* these characters in place of commas.  Atoi, etc., however, do not allow        */
/* embedded underscores;  so this function removes them from the yytext string    */
/* so we can use the string to number conversion functions.                       */
/*                                                                                */
/* To avoid flex character backup programs, this function copies the converted    */
/* string constant to the "numstr" global character array.                        */
/*                                                                                */
/**********************************************************************************/

void
strip_( void )
_begin( strip_ )

    char *src, *dest;

    _here;
    src = yytext;
    dest = numstr;
    _while( *src != '\0' )

        /*
        ** If not an underscore character, copy the source character from
        ** yytext to numstr.
        */
         
        _if( *src != '_' )

            *dest = *src;
            ++dest;

        _endif
        ++src;

    _endwhile
    *dest = '\0';
    _here;

_end( strip_ )


/*********************************************************************************/
/*                                                                               */
/* MakeStr-                                                                      */
/*                                                                               */
/* This function converts the string matched by the Flex regular expression into */
/* a string suitable for use by HLA.  Primarily, this consists of converting any */
/* internal "" pairs into a single quotation symbol.                             */
/*                                                                               */
/*********************************************************************************/

char*
MakeStr( void )
_begin( MakeStr )

    char *src;
    char *dest;
    char *result;
    int  len;
    int  i;

    _here;
    
    len = strlen( yytext );
    result = dest = src = malloc2( len + 1 );
    memcpy( src, yytext + 1, len );
    len = len - 2;
    i = 0;
    _while( i<len )

        *dest++ = *src++;
        _if( *(src-1) == '"' && *src == '"' )

             ++src;
             ++i;

        _endif
        ++i;

    _endwhile
    *dest = '\0';
    _here;
    _return result;
    
_end( MakeStr ); 





char*
MakeUStr( void )
_begin( MakeUStr )

    char *src;
    char *dest;
    char *result;

    _here;
    
    // Note: we don't have to allow for the extra zero word
    // at the end of the string because the 'u' at the beginning
    // of the string provides the extra needed space.
    
    src = yytext;
    dest = malloc2( strlen( yytext ) * 2 );
    result = dest;
    src += 2; /* skip initial 'u' and quote */
    _while( *src != '\0' )

        _if( *src == '"' )

            ++src;
             _if( *src == '\"' )

                *dest++ = *src++;
                *dest++ = '\0';

             _endif

        _else

            *dest++ = *src++;
            *dest++ = '\0';

        _endif

    _endwhile 
    *dest++ = '\0';
    *dest = '\0';
    _here;
    _return result;
    
_end( MakeUStr ); 






/******************************************************/
/*                                                    */
/* PushBackStr-                                       */
/*                                                    */
/* Pushes a string of characters back onto the input. */
/*                                                    */
/******************************************************/




void
PushBackStr( char *s )
_begin( PushBackStr )

    _if( s != NULL && *s != '\0' )

        pushBufStack( FileName, LineCnt, NULL, 0 );
        _here;
        yy_scan_string( s );
		_here;

    _endif

_end( PushBackStr )





/***********************************************************/
/*                                                         */
/* SetArray-                                               */
/*                                                         */
/* Copies important array information from the src operand */
/* to the dest operand.                                    */
/*                                                         */
/***********************************************************/

static void
SetArray
(
            YYSTYPE *dest,
    struct  SymNode *src

)
_begin( SetArray )

    _here;
    dest->v.NumElements =
        src->NumElements;

    dest->v.Arity = src -> Arity;

    dest->v.Dimensions = src->Dimensions;

    dest->v.u.ArrayOfValues = src->u.ArrayOfValues;
    _here;

_end( SetArray )



/*****************************************************************/
/*                                                               */
/* trim-                                                         */
/*                                                               */
/* Eliminates spaces at the beginning and end of the specified   */
/* string and returns a pointer to a copy of the trimmed string. */
/*                                                               */
/*****************************************************************/

static char*
trim( char *str, int LastPosn )
_begin( trim )

    int fromBack = LastPosn;
    char *s;

    _here;
    _if( fromBack > 0 )

        _while( fromBack > 0  &&  str[ fromBack ] <= ' ' )

            --fromBack;

        _endwhile
    
        str[ fromBack + 1 ] = '\0';
        
    _endif

    _while( *str != '\0'  &&  *str <= ' ' )
    
        ++str;

    _endwhile
    _here;
    s = hlastrdup2( str );
    _return s;

_end( trim )




/*****************************************************************/
/*                                                               */
/* RsvdWordErr - Misuse of MASM reserved word or special symbol. */
/*                                                               */
/*****************************************************************/

static void
RsvdWordErr( char *RW )
_begin( RsvdWordErr )

    char msg[256];

    sprintf( msg, "'%s' is a special symbol that cannot be used", RW );
    yyerror( msg );

_end( RsvdWordErr )


/*************************************************************/
/*                                                           */
/* processMacroID-                                           */
/*                                                           */
/* Given a macro or regular expression symbol, the following */
/* function process an actual parameter list for that macro  */
/* invocation. The resultant strings are returned in         */
/* symbol->u.MacroData.Parameters (a linear list of SymNodes */
/* containing the text values).                              */
/*                                                           */
/*************************************************************/

void
processMacroID( struct SymNode *symbol )
_begin( processMacroID )

    yySymbol = symbol;
    PushBackStr( "\xFC" );
    yyparse();

_end( processMacroID )


/**************************************************************/
/*                                                            */
/* ProcessMacro-                                              */
/*                                                            */
/* Called by ProcessID whenever it encounters a macro symbol. */
/* The purpose of this procedure is to parse any necessary    */
/* macro parameters and begin the expansion of the specified  */
/* macro.                                                     */
/*                                                            */
/**************************************************************/


static int
ProcessMacro( struct SymNode *symbol )
_begin( ProcessMacro )

    /*
    ** Macros are like text objects.
    ** Expand their text in-line and then
    ** return to the lexer to process this
    ** newly expanded text.
    */


            int     CurMacCntr;
            int     LocalVarMacParms;
            char    ThisLbl[256];
    struct  SymNode *LocalIDs;
    struct  SymNode v;
    struct  SymNode *MacroListItem;
    struct  SymNode *LclSym;
    struct  SymNode *NewSym;
    struct  SymNode *LastSym;
    struct  SymNode *AMList;

    /*
    ** Save the global object VarMacParms
    ** in case there is a recursive macro
    ** invocation inside a parameter list.
    */

    _here;
    LocalVarMacParms = VarMacParms;


    /*
    ** Create a deep copy of the current symbol
    ** so we can make assignments to the local
    ** values and the parameters.  This prevents
    ** a recursive macro invocation from wiping
    ** out the local and parameter values of the
    ** calling macro.
    */

    MacroListItem = malloc2( sizeofSymNode );
    memcpy( MacroListItem, symbol, sizeofSymNode );
    MacroListItem->u.MacroData.Terminator   = NULL;
    MacroListItem->u.MacroData.Locals       = NULL;
    MacroListItem->u.MacroData.Parameters   = NULL;
    MacroListItem->u.MacroData.Filename   = FileName;
    MacroListItem->u.MacroData.LineCnt = LineCnt;


    LclSym =
        _ifx
        (
                symbol->u.MacroData.Terminator
            !=  NULL,
            symbol->u.MacroData.Terminator,
            _ifx
            (
                    symbol->u.MacroData.Locals
                !=  NULL,
                symbol->u.MacroData.Locals,
                symbol->u.MacroData.Parameters
            )
        );
        
    NewSym = NULL;
    _while( LclSym != NULL )

        /*
        ** Allocate storage for a new symbol node
        ** and append the node to the end of the
        ** list we are creating (if the list already
        ** exists, that is).
        */

        _if( NewSym != NULL )

            NewSym->Next = malloc2( sizeofSymNode );
            memcpy
            ( 
                NewSym->Next, 
                LclSym, 
                sizeofSymNode 
            );
            NewSym = NewSym->Next;

        _else

            NewSym = malloc2( sizeofSymNode );
            memcpy
            ( 
                NewSym, 
                LclSym, 
                sizeofSymNode 
            );

        _endif

        /*
        ** If we've just hit the terminator symbol,
        ** the first Local symbol, or the first
        ** parameter, then set up the appropriate
        ** pointer in the Macro symbol we've just
        ** created.
        */

        _if( LclSym == symbol->u.MacroData.Terminator )

            MacroListItem->u.MacroData.Terminator = NewSym;

        _elseif
        ( 
            LclSym == symbol->u.MacroData.Locals
        )

            MacroListItem->u.MacroData.Locals = NewSym;

        _elseif
        ( 
            LclSym == symbol->u.MacroData.Parameters
        )

            MacroListItem->u.MacroData.Parameters = NewSym;

        _endif


        /*
        ** Okay, if the current symbol is a macro
        ** object, do a shallow copy on it.  If
        ** it's not a macro object, just set the
        ** strval field (since this must be a tText
        ** object) to the empty string.
        */

        _if( LclSym->pType == tMacro )

            memcpy( NewSym, LclSym, sizeofSymNode );
            NewSym->Next = NULL;

            /*
            ** If this is a Terminator symbol, 
            ** then point the Parent field
            ** at the macro we are setting up.
            ** This will allow access to the parent's
            ** symbols during expansion and will give
            ** a terminator a handle by which it can
            ** delete the parent from the active macro
            ** list when the terminator is done.
            */

            _if
            ( 
                    NewSym->SymClass == cTerminator 
                ||  NewSym->SymClass == cKeyword
            )

                NewSym->u.MacroData.Parent = MacroListItem;

            _else
            
                NewSym->u.MacroData.Parent = NULL;

            _endif


        _elseif( LclSym->pType == tArray )

            /*
            ** This code kicks in if we have
            ** a variable number of parameters.
            ** It makes a copy of all the (empty)
            ** strings associated with the last
            ** (the variable) parameter.
            */

            memcpy( NewSym, LclSym, sizeofSymNode );
            DeepCopy( NewSym, LclSym );

        _else

            /*
            ** This entry handles normal parameters,
            ** string parameters, and local symbols 
            ** (which are always tText or tString objects).
            */

            memcpy( NewSym, LclSym, sizeofSymNode );
            NewSym->u.strval = hlastrdup2( "" );
            NewSym->Next = NULL;


        _endif


        /*
        ** Okay, move on to the next symbol
        ** in the macro's local symbol table.
        */

        LclSym = LclSym->Next;

    _endwhile

    /*
    ** If the current macro symbol is a keyword
    ** or a terminator, point its parent field
    ** at the original invocation of the parent
    ** macro in the active list.
    */

    _if
    ( 
            symbol->SymClass == cTerminator
        ||  symbol->SymClass == cKeyword
    )
    
        AMList = ActiveMacros;
        assert( symbol->u.MacroData.Parent != NULL );
        _forever

            _breakif( AMList == NULL );
            _if
            ( 
                _streq
                ( 
                    AMList->TrueName, 
                    symbol->u.MacroData.Parent->TrueName
                )
            )

                MacroListItem->u.MacroData.Parent = 
                                                AMList;
                break;

            _endif
            AMList = AMList->Next;

        _endfor

    _else

        MacroListItem->u.MacroData.Parent = NULL;

    _endif
                    

    /*
    ** Get the macro parameters and store their
    ** values into the copy of the macro object
    ** we just created.
    */

    _if( MacroListItem->u.MacroData.Parameters != NULL )

        processMacroID( MacroListItem );

    _endif


    /*
    ** Define any local symbols associated with
    ** this macro.  Remember, locals are just
    ** text objects.  What this code does is to
    ** assign a unique ID to each local object's
    ** strval.
    */

    LocalIDs = MacroListItem->u.MacroData.Locals;
    _while
    (
            LocalIDs != NULL
        &&  LocalIDs != 
                MacroListItem->u.MacroData.Parameters
    )

        sprintf( ThisLbl, "_%04x_%s_", LblCntr++, LocalIDs->TrueName );
        v.u.strval = hlastrdup2( ThisLbl );
        SetSym
        (
            LocalIDs,
            &text_ste,
            tText,
            0,
            NULL,
            0,
            YYS &v,
            0,
            0,
            NULL,
            NULL,
            NULL,
            0,          // FieldCnt
            NULL,       // CurField
            0           // CurIndex
        );
        LocalIDs = LocalIDs->Next;

    _endwhile

    /*
    ** Set up the data structures so we
    ** can play back this macro.
    */

	_if( doCollect )
	
		PushBackStr( "\xdd" );
		delayCollect = 1;
		
	_endif
    PushBackStr( "\xff" );  // Mark the end of the macro expansion.

    ++MacroSP;
    assert( MacroSP < maxNestedMacros );
    CurMacCntr = ++MacroCntr;
    MacroListItem->Offset = CurMacCntr;

    MacroStack[ MacroSP ].Macro = MacroListItem;
    MacroStack[ MacroSP ].cnt = CurMacCntr;
    MacroStack[ MacroSP ].text = 
        MacroListItem->u.MacroData.Text;
        
    MacroStack[ MacroSP].SourceBufIndex = BufSP;

    pushBufStack( FileName, LineCnt, NULL, 0 );
        
    FileName = symbol->u.MacroData.Filename;
    LineCnt = symbol->u.MacroData.LineCnt - 1; 

    /*
    ** If this macro has an associated terminator,
    ** then we need to append it to the
    ** Wait4Term list.
    */

    _if
    ( 
        symbol->u.MacroData.Terminator != NULL 
    )

        Wait4Term[ ++W4TermSP ] = 
            symbol->u.MacroData.Terminator;

    _endif

    /*
    ** Now, add this macro to the active
    ** macros list so we can search its local
    ** symbol table during macro expansion.
    */

    MacroListItem->Next = ActiveMacros;
    ActiveMacros = MacroListItem;

    /*
    ** Play back the text of the macro.
    */

    assert( MacroStack[ MacroSP ].text != NULL );
    yy_scan_string( MacroStack[ MacroSP ].text );

            

    /*
    ** Restore the global VarMacParms object.
    */

    VarMacParms = LocalVarMacParms;

    /*
    ** Continue processing via the lexer.
    */

    _here;
    _return PIDMacro;

_end( ProcessMacro )





/************************************************************************************************************/
/*                                                                                                          */
/* ProcessRegex-                                                                                            */
/*                                                                                                          */
/* Called by ProcessID whenever it encounters a Regex symbol.                                               */
/* The purpose of this procedure is to parse any necessary                                                  */
/* regex parameters and compile the regular expression.                                                     */
/*                                                                                                          */
/************************************************************************************************************/


int
ProcessRegex( struct SymNode *symbol, union YYSTYPE *yylval )
_begin( ProcessRegex )

    /*
    ** Regular expressions are different from macros.
    ** Rather than expanding the text in-place, we
    ** have to compile the regular expression into
    ** an in-memory data structure.
    */


            int     CurMacCntr;
            char    ThisLbl[256];
    struct  SymNode *LocalIDs;
    struct  SymNode v;
    struct  SymNode *RegexListItem;
    struct  SymNode *LclSym;
    struct  SymNode *NewSym;
    struct  SymNode *LastSym;
    struct  SymNode *ARList;
    
    _here;

    // If we are compiling a regular expression, bail out
    // right now because recursive compilations would produce
    // an infinite loop. Defer the compilation until we actually
    // use the regex.
    
    _if( inRegex )
    
        _return RegexID;
    
    _endif


    /*
    ** Create a deep copy of the current symbol
    ** so we can make assignments to the local
    ** values and the parameters.  This prevents
    ** a recursive regex invocation from wiping
    ** out the local and parameter values of the
    ** calling regex.
    */

    RegexListItem = malloc2( sizeofSymNode );
    memcpy( RegexListItem, symbol, sizeofSymNode );
    RegexListItem->u.MacroData.Terminator   = NULL;
    RegexListItem->u.MacroData.Locals       = NULL;
    RegexListItem->u.MacroData.Parameters   = NULL;
    RegexListItem->u.MacroData.Filename     = FileName;
    RegexListItem->u.MacroData.LineCnt      = LineCnt;


    LclSym =
        _ifx
        (
            symbol->u.MacroData.Locals !=NULL,
            symbol->u.MacroData.Locals,
            symbol->u.MacroData.Parameters
        );
        
    NewSym = NULL;
    _while( LclSym != NULL )

        /*
        ** Allocate storage for a new symbol node
        ** and append the node to the end of the
        ** list we are creating (if the list already
        ** exists, that is).
        */

        _if( NewSym != NULL )

            NewSym->Next = malloc2( sizeofSymNode );
            memcpy
            ( 
                NewSym->Next, 
                LclSym, 
                sizeofSymNode 
            );
            NewSym = NewSym->Next;

        _else

            NewSym = malloc2( sizeofSymNode );
            memcpy
            ( 
                NewSym, 
                LclSym, 
                sizeofSymNode 
            );

        _endif

        /*
        ** If we've just hit the first Local symbol, 
        ** or the first parameter, then set up the 
        ** appropriate pointer in the Macro symbol 
        ** we've just created.
        */

        _if
        ( 
            LclSym == symbol->u.MacroData.Locals
        )

            RegexListItem->u.MacroData.Locals = NewSym;

        _elseif
        ( 
            LclSym == symbol->u.MacroData.Parameters
        )

            RegexListItem->u.MacroData.Parameters = NewSym;

        _endif


        /*
        ** Okay, if the current symbol is a Regex
        ** object, do a shallow copy on it.  If
        ** it's not a Regex object, just set the
        ** strval field (since this must be a tText
        ** object) to the empty string.
        */

        _if( LclSym->pType == tRegexMac )

            memcpy( NewSym, LclSym, sizeofSymNode );
            NewSym->Next = NULL;

        _elseif( LclSym->pType == tArray )

            /*
            ** This code kicks in if we have
            ** a variable number of parameters.
            ** It makes a copy of all the (empty)
            ** strings associated with the last
            ** (the variable) parameter.
            */

            memcpy( NewSym, LclSym, sizeofSymNode );
            DeepCopy( NewSym, LclSym );

        _else

            /*
            ** This entry handles normal parameters
            ** and local symbols (which are always
            ** tText objects).
            */

            memcpy( NewSym, LclSym, sizeofSymNode );
            NewSym->u.strval = hlastrdup2( "" );
            NewSym->Next = NULL;


        _endif


        /*
        ** Okay, move on to the next symbol
        ** in the Regex's local symbol table.
        */

        LclSym = LclSym->Next;

    _endwhile


    // The parent field is only used by macros.
    // Set it to NULL for Regexes:
    
    RegexListItem->u.MacroData.Parent = NULL;
                    

    /*
    ** Get the regex parameters and store their
    ** values into the copy of the regex object
    ** we just created.
    */

    _if( RegexListItem->u.MacroData.Parameters != NULL )

        processMacroID( RegexListItem );

    _endif


    /*
    ** Define any local symbols associated with
    ** this regex.  Remember, locals are just
    ** text objects.  What this code does is to
    ** assign a unique ID to each local object's
    ** strval.
    */

    LocalIDs = RegexListItem->u.MacroData.Locals;
    _while
    (
            LocalIDs != NULL
        &&  LocalIDs != 
                RegexListItem->u.MacroData.Parameters
    )

        sprintf( ThisLbl, "_%04x_%s_", LblCntr++, LocalIDs->TrueName );
        v.u.strval = hlastrdup2( ThisLbl );
        SetSym
        (
            LocalIDs,
            &text_ste,
            tText,
            0,
            NULL,
            0,
            YYS &v,
            0,
            0,
            NULL,
            NULL,
            NULL,
            0,          // FieldCnt
            NULL,       // CurField
            0           // CurIndex
        );
        LocalIDs = LocalIDs->Next;

    _endwhile

    /*
    ** Set up the data structures so we
    ** can play back this regex while
    ** compiling it.
    */

    PushBackStr( "\xff" );  // Mark the end of the regex expansion.

    // We have to push this guy onto the macro stack because
    // macros found in the regular expression need access to
    // our symbols. Also, we're redirecting the input to come
    // from the regex, and this code uses the macro stack for
    // that purpose.
    
    ++MacroSP;
    assert( MacroSP < maxNestedMacros );
    CurMacCntr = ++MacroCntr;
    RegexListItem->Offset = CurMacCntr;

    MacroStack[ MacroSP ].Macro = RegexListItem;
    MacroStack[ MacroSP ].cnt = CurMacCntr;
    MacroStack[ MacroSP ].text = 
        RegexListItem->u.MacroData.Text;
        
    MacroStack[ MacroSP].SourceBufIndex = BufSP;

    pushBufStack( FileName, LineCnt, NULL, 0 );
        
    FileName = symbol->u.MacroData.Filename;
    LineCnt = symbol->u.MacroData.LineCnt - 1; 


    /*
    ** Now, add this regex to the active
    ** macros list so we can search its local
    ** symbol table during regex compilation.
    */

    RegexListItem->Next = ActiveMacros;
    ActiveMacros = RegexListItem;

    /*
    ** Play back the text of the regular expression.
    */

    assert( MacroStack[ MacroSP ].text != NULL );
    yy_scan_string( MacroStack[ MacroSP ].text );

    yyparse();

    _if( d1ceReturnVal.v.pType != tRegex )

        yyerror( "Error compiling regular expression" );
        FreeValue( &d1ceReturnVal );
        _return PIDIgnore;

    _endif

    memcpy( yylval, &d1ceReturnVal, sizeof( d1ceReturnVal ));
    _return regexconst;

_end( ProcessRegex )



/********************************************************************************
**
** doID-
** Handles the work when the scanner discovers an identifier.
*/

static int
doID( YYSTYPE *yylval )
_begin( doID )

    struct  SymNode *symbol;
    struct  SymNode *temp;
    int             Token;


    
    // In the event we are processing a class ID,
    // initialize the "ClassID" string to empty
    // so we can capture the full "path" of the
    // class identifier sequence (in case we have
    // to push the name back onto the lexer
    // input).
    
    _here;
    ClassID[0] = '\0';


    
    // Begin by assuming that this is *not* a
    // class identifier.
    

    CurObject = NULL;

    
    // Parser expects us to look up the symbol
    // before returning the ID token.
    

    _if( (fastNamespace && fastLookup) || SkipLookup )

        symbol = NULL;
        
    _else

        symbol = lookup( yytext, 0 );
        
    _endif
    fastLookup = 0;
    yylval->s = symbol;
    Token = 
        ProcessID
        ( 
            yytext,
            CurLexLevel, 
            symbol, 
            yylval 
        );


    
    // Namespace, text, and macro symbols
    // do not return control directly to the
    // parser.  ProcessID, above, returns -1/-2
    // for text/macro symbols, and -3 for namespace
    // symbols.  In the
    // case of namespace and class symbols, ProcessID
    // also sets the start condition to either
    // <namespace> allows the
    // lexer to handle the rest of the identifier.
    // For all other symbol types, the following 
    // statement returns control to the parser.
    

    _returnif( Token >= 0 ) Token;

    
    // If this is a class object, CurObject
    // needs to point at the leftmost name (the
    // object name) in the "dot-path" (fully qualified)
    // list of identifiers.  Since this regular expression
    // matches that leftmost identifier, save
    // the address of this symbol before passing
    // control to the <ClassSpace> regular
    // expression.
    

    CurObject = symbol;
    _if( Token == -3 && symbol->SymClass != cNamespace )
    
        LastRefdObject = symbol;

    _endif
    _return Token;

_end( doID )




/**********************************************************************/
/*                                                                    */
/* ProcessID-                                                         */
/*                                                                    */
/* Whenever the lexer encounters an ID, the following code determimes */
/* the type of the ID and figures out how to handle it (e.g., return  */
/* info to the parser, process a macro, process a namespace, etc.)    */
/*                                                                    */
/* Entry:                                                             */
/*  symbol- Pointer to symbol table entry of the identifier.          */
/*          This value is NULL if the symbol is undefined.            */
/*                                                                    */
/*  IDlen-  # of identifiers in qualified name (i.e., the number of   */
/*          identifiers between the periods in a qualified name).     */
/*          Normally zero unless processing additional names after    */
/*          a class, record, union, or namespace identifier.          */
/*                                                                    */
/* Exit-                                                              */
/*                                                                    */
/*  yylval- contains a pointer to appropriate symbol table            */
/*          entry if this is a "normal" symbol.                       */
/*                                                                    */
/* Returns:                                                           */
/*                                                                    */
/*  The function returns a token value if this is a normal            */
/*  symbol and control should return to the bison code.  It           */
/*  returns a negative value if this is a text, macro, namespace, or  */
/*  class object and further processing by the lexer is necessary.    */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/* ProcessID return values:                                           */
/*                                                                    */
/* If positive: ID token to return to parser.                         */
/* If negative, this indicates that the lexer needs to                */
/* do additional processing on the value.  Here are                   */
/* the negative return results:                                       */
/*                                                                    */
/* PIDtext      -1                                                    */
/* PIDMacro     -2                                                    */
/* PIDNameSpace -3                                                    */
/* PIDClassName -4                                                    */
/*                                                                    */
/**********************************************************************/




static int
ProcessID
( 
            char    *ID, 
            int     symLexLevel, 
    struct  SymNode *symbol, 
            YYSTYPE *yylval
)
_begin( ProcessID )

    /*
    ** If the current symbol is undefined, just return
    ** the UndefID token.
    */

    _here;
    _if( symbol == NULL )
    
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;

    _endif


    // Check for case neutrality here (but only if checkCN is true;
    // it gets set false for recursive calls involving class objects).

    _if( _strne( ID, symbol->TrueName ))

        // Okay, the case is different.
        // Now, if the lex levels are different, return an undefined
        // identifier.  If the lex levels are the same, then we've got an
        // error.

        _if( symLexLevel == symbol->LexLevel )

            char msg[ 256 ];
        
            sprintf
            ( 
                msg, 
                "Mispelled identifier, perhaps you meant << %s >>", 
                symbol->TrueName
            );
            yyerror( msg );
        
        _endif
        yylval->idStr = hlastrdup2( yytext );
        _return UndefID;
         
    _endif

    /*
    ** If the symbol was defined and it's a text constant or
    ** value object, expand the text in-line and then let
    ** the lexer operate on this text (do not return directly
    ** to the parser).
    */


    _if
    ( 
            symbol->pType == tText
        &&  !InAtString
        &&  (
                    symbol->SymClass == cConstant
                ||  symbol->SymClass == cValue
            ) 
    )

		// If it was a text constant ID, keep the ID in the
		// collection buffer (rather than the expanded string):
		
		_if( doCollect )
		
			collectIndex -= strlen( ID );
			collectBuf[ collectIndex ] = '\0';
			
		_endif
        PushBackStr( symbol->u.strval );
        _return PIDtext;
        
    _endif


    _if( symbol->pType == tNamespace )

        /*
        ** Namespace IDs have to be handled specially
        ** because we don't return the namespace
        ** identifier to the bison code.  Instead, we
        ** locate the namespace field identifier and
        ** return that value to the bison code.
        */

        CurSymTbl = symbol;
        BEGIN NameSpace;
        _return PIDNameSpace;
        
    _endif


    /*
    ** If we have a class name (type, not variable), then check
    ** to see if there is a constant or macro name following
    ** the class name (separating the two is a single period).
    */
    
    _if
    ( 
            symbol->pType == tClass
        &&  symbol->SymClass == cType 
        &&  CurObject == NULL 
    )

        /*
        ** Like namespace IDs, class IDs have to be
        ** handled specially in order to process
        ** macro, text constant, and other objects
        ** directly.
        */

        struct  SymNode *SaveSymTbl;
                char    *DotLocation;
                char    msg[ 256 ];
                
        #define cn d1dnReturnVal.dotName

        CurSymTbl = symbol;
        LastRefdObject = symbol;
        SaveSymTbl = symbol;


        PushBackStr( "\xF4" );  /* Process one dot name             */
        CurObject = symbol;
        yyparse();

        /*
        ** If the type name appeared alone (no dotted name following
        ** it), then just return the class name.
        */
        
        _if( cn.FullName == NULL || cn.Sym == NULL )
        
			_if( doCollect )
			
				collectIndex -= yyleng;
				collectBuf[ collectIndex ] = '\0';
				
			_endif
            PushBackStr( yytext );
            yylval->s = symbol;
            _returnif( symbol->LexLevel == CurLexLevel ) LocalID;
            _return NonLocalID;
            
        _endif
        
        yylval->s = cn.Sym;
		
        /*
        ** Okay, return if it's a constant, macro, class procedure,
        ** or class method.
        **
        **  Note special case for text constants - we've got to
        ** expand them here in place.
        */
                
        _if
        ( 
                cn.Sym->pType == tText 
            &&  !InAtString
            &&  (
                        cn.Sym->SymClass == cConstant
                    ||  cn.Sym->SymClass == cValue
                ) 
        )
        
				PushBackStr( "\xDD" );	// Don't collect the pushback.
				delayCollect = 1;
                PushBackStr( cn.Sym->u.strval );
                _return PIDtext;
        
        _endif

        _if( IsConstant( cn.Sym->SymClass )) 
			_return LocalConstID;
			
		_endif
        _if( cn.Sym->pType == tMacro ) 
        
            LastMacroObject = SaveSymTbl;
            _return ProcessMacro( cn.Sym );
            
        _endif
        
        
        /*
        ** Handle class procedures and methods here.
        */

        _if( cn.Sym->SymClass == cClassProc ) 
        
            yylval->s->u.proc.BaseClass = SaveSymTbl;
            _return ClassProcID;
            
        _endif
        
        _if( cn.Sym->SymClass == cClassIter ) 
        
            yylval->s->u.proc.BaseClass = SaveSymTbl;
            _return ClassIterID;
            
        _endif
		
        _if( cn.Sym->SymClass == cMethod ) 
        
            yylval->s->u.proc.BaseClass = SaveSymTbl;
            _return ClassMethodID;
            
        _endif
        

        _if( cn.Sym->SymClass == cOverloads )
		 
            yylval->s->u.proc.BaseClass = SaveSymTbl;
			_return OverloadedID;
			
		_endif
		
        
        _if( cn.Sym->SymClass == cStatic ) 

			yylval->s = cn.Sym;
			_return ClassStaticID;
            
        _endif
        
        PushBackStr( yytext );
        PushBackStr( "." );
        yylval->s = symbol;
        
        /*
        ** All the processing above has handled a single
        ** identifier after a class name.  This special
        ** case deals with macros, methods, class procedures,
        ** and class static variables.  If we get to this
        ** point, those cases don't apply here.  However, it
        ** is possible that we have a record or class variable
        ** that contains class, macro, or static object fields
        ** that need processing like class variables.  Deal with
        ** that here.
        */
        


        PushBackStr( "\xF5" );
        CurObject = symbol;
        yyparse();
		PushBackStr( "\xDD" );	// Don't collect the pushback.
		delayCollect = 1;		// Because we've already collected it.
        PushBackStr( yytext );  /* Look ahead eats the next symbol */
        
        yylval->s = cn.Sym;

        /*
        ** Okay, return if it's a constant or a macro.
        */
                
        _returnif( IsConstant( cn.Sym->SymClass )) LocalConstID;
        _if( cn.Sym->pType == tMacro ) 
            
            _return ProcessMacro( cn.Sym );
        
        _endif

            
        /*
        ** If it's not a constant or a macro, we've got to
        ** push the fieldnames back onto the input and
        ** return only the object name as our attribute.
        */

        
        yylval->s = CurObject;  /* Retrieve ptr to original object */
        
        
        /*
        ** Determine if this is a qualified name by searching for
        ** a dot in the full name that was parsed.  If no dot is
        ** present, then this is just an object name.  If a dot
        ** is present, then it's a qualified object name and we
        ** need to push the dot and everything beyond it back onto
        ** the input.
        */
        
        DotLocation = strchr( cn.FullName, '.' );
        _if( DotLocation != NULL )
        
            PushBackStr( DotLocation );
            
        _endif
        
        /*
        ** Because we know this is a variable (see the original _if
        ** that started all this), all we've got to do is differentiate
        ** between static and local objects.
        */
        
                
        ErrorNear
        ( 
            "Unexpected field class for object type",
            cn.FullName,
            __LINE__,
            __FILE__
        );
        yylval->s = &error_ste;
        _return LocalVarID;     /* arbitrary return token */
                            
    

    /*
    ** If a class variable (object) is encountered, we have to
    ** check to see if it is a fully qualified name (i.e., has
    ** the appropriate dots and fieldnames), and if it is, we
    ** need to see if the fully qualified name is a constant,
    ** value, or a macro.  If so, we've got to process the
    ** whole thing right here.  Otherwise, we just pass the
    ** object name (without the fields) back to the parser.
    */
    
    _elseif
    ( 
            (
                    symbol->pType == tClass 
                ||  (
                            symbol->pType == tPointer
                        &&  symbol->Base != NULL
                        &&  symbol->Base->pType == tClass
                    )
            )

        &&  IsVar( symbol->SymClass )
    )
    
        struct  SymNode *SaveObject;
                char    *DotLocation;
                
        #define dn d1dnReturnVal.dotName

        PushBackStr( "\xF5" );
        CurObject = symbol;
        LastRefdObject = symbol;
        SaveObject = symbol;
        yyparse();
		
		// Look ahead eats the next symbol 
		
		_if( doCollect )
		
			collectIndex -= yyleng;
			collectBuf[ collectIndex ] = '\0';
		_endif
        PushBackStr( yytext );  

        /*
        ** Well, it could be that there is no sequence of
        ** fieldnames after the class variable.  In that case,
        ** dn.Sym will contain NULL.  Deal with that here.
        */
        
        _if( dn.Sym == NULL )

            yylval->s = SaveObject;
            _if
            ( 
                    SaveObject->SymClass == cVar 
                ||  SaveObject->SymClass == cParm 
            )
				_returnif( SaveObject->LexLevel == CurLexLevel ) LocalVarID;
				_return NonLocalVarID;
				
			_endif
                
            _if( SaveObject->SymClass == cStatic ) 
            
                _returnif( SaveObject->LexLevel == CurLexLevel ) LocalStaticID;
				_return NonLocalStaticID;
                
            _endif
            assert( ("Unexpected Symbol Class", 0 ));
        
        _endif

        yylval->s = dn.Sym;
        

        /*
        ** Okay, return if it's a constant or a macro.
        */
            
        _if
        ( 
                dn.Sym->pType == tText 
            &&  !InAtString
            &&  (
                        dn.Sym->SymClass == cConstant
                    ||  dn.Sym->SymClass == cValue
                ) 
        )
        
				PushBackStr( "\xDD" );	// Don't collect the pushback.
				delayCollect = 1;
                PushBackStr( dn.Sym->u.strval );
                _return PIDtext;
        
        _endif
                
        _returnif( IsConstant( dn.Sym->SymClass )) LocalConstID;
        _if( dn.Sym->pType == tMacro ) 
        
            LastMacroObject = SaveObject;
            _return ProcessMacro( dn.Sym );
            
        _endif

            
        /*
        ** If it's not a constant or a macro, we've got to
        ** push the fieldnames back onto the input and
        ** return only the object name as our attribute.
        */
        
        yylval->s = SaveObject; /* Retrieve ptr to original object */


        /*
        ** Determine if this is a qualified name by searching for
        ** a dot in the full name that was parsed.  If no dot is
        ** present, then this is just an object name.  If a dot
        ** is present, then it's a qualified object name and we
        ** need to push the dot and everything beyond it back onto
        ** the input.
        */
        
        DotLocation = strchr( dn.FullName, '.' );
        _if( DotLocation != NULL )
        
			PushBackStr( "\xDD" );	// Don't collect the pushback.
			delayCollect = 1;		// Cause we already have it.
            PushBackStr( DotLocation );
            
        _endif
        
        /*
        ** Because we know this is a variable (see the original _if
        ** that started all this), all we've got to do is differentiate
        ** between static and local objects.
        */
        
        _returnif
        ( 
                SaveObject->SymClass == cVar 
            ||  SaveObject->SymClass == cParm 
        )
            LocalVarID;
            
        _returnif( SaveObject->SymClass == cStatic ) 
            LocalStaticID;

        /*
        ** Just in case the impossible happens, force an assert.
        ** The _return is there in case NDEBUG is defined.
        */
                
        assert( ("Unexpected symbol class", 0) );
        _return LocalID;
                            
    
    _endif
        
    /*
    ** If it's a macro symbol, call ProcessMacro to begin
    ** the expansion of the macro.
    */
            
    _if( symbol->pType == tMacro )
        int i;

        i=  ProcessMacro( symbol );
        _return i;
        
    _endif
    

    /*
    ** If it's a regular expression, call ProcessRegex to begin
    ** compiling the regular expression.
    */
    
            
    _if( symbol->pType == tRegexMac )
        int i;

        i=  ProcessRegex( symbol, yylval );
        _return i;
        
    _endif


	// If the symbol is a parameter and the regnum field is not -1,
	// then we've got a parameter passed in a register. Convert that
	// symbol to text at this point and reprocess it.
	
	_if( symbol->regnum != -1 && parmLookup != 1 )
	
		PushBackStr( symbol->StaticName );
		_return PIDtext;
		
	_endif
	

    // Must be some regular type of identifier here:
    
    _if( symbol->LexLevel == CurLexLevel )



        yylval->s = symbol;
        _returnif( IsConstant( symbol->SymClass )) LocalConstID;
        _returnif
        ( 
                symbol->SymClass == cVar 
            ||  symbol->SymClass == cParm
        ) 
            LocalVarID;
        
        _returnif( symbol->SymClass == cStatic ) 
            LocalStaticID;
        _returnif( symbol->SymClass == cProc )
            LocalProcID;
        _returnif( symbol->SymClass == cIterator ) 
            LocalIterID;
        _returnif( symbol->SymClass == cClassProc ) 
            ClassProcID;
        _returnif( symbol->SymClass == cClassIter ) 
            ClassIterID;
        _returnif( symbol->SymClass == cMethod ) 
            LocalMethodID;
        _returnif( symbol->SymClass == cOverloads ) 
            OverloadedID;
        _returnif( symbol->SymClass == cLabel ) 
            LocalLabelID;
        _return LocalID;

    _endif


    yylval->s = symbol;
    _returnif( IsConstant( symbol->SymClass ))
        NonLocalConstID;
    _returnif
    ( 
            symbol->SymClass == cVar 
        ||  symbol->SymClass == cParm
    ) 
        NonLocalVarID;
    
    _returnif( symbol->SymClass == cStatic ) 
        NonLocalStaticID;
    _returnif( symbol->SymClass == cProc ) 
		NonLocalProcID;
    _returnif( symbol->SymClass == cIterator ) 
        NonLocalIterID;
    _returnif( symbol->SymClass == cClassProc ) 
        ClassProcID;
    _returnif( symbol->SymClass == cClassIter ) 
        ClassIterID;
    _returnif( symbol->SymClass == cMethod ) 
        NonLocalMethodID;
    _returnif( symbol->SymClass == cOverloads ) 
        OverloadedID;
    _returnif( symbol->SymClass == cLabel ) 
        NonLocalLabelID;
    _return NonLocalID;

_end( ProcessID )




void
parseExpression( char *strToParse, union YYSTYPE *putValueHere )
_begin( parseExpression )

		char *temp;
		int	 len;

        _here;
		len = strlen( strToParse );
		temp = malloc2( len + 4 );
		temp[0] = '\xFA';
		temp[1] = '(';
		memcpy( &temp[2], strToParse, len );
		temp[len+2] = ')';
		temp[len+3] = '\0';
        PushBackStr( temp );
        yyparse();

		memcpy( putValueHere, &d1ceReturnVal.v, sizeof( union YYSTYPE ));
		free2( vss temp );		
        _here;

_end( parseExpression )


void
_yyless( int n )
_begin( _yyless )

	yyless(n);
	
_end( _yyless );





static void
collectYYtext( void )
{

	if( !delayCollect )
	{
		switch( yyleng )
		{
			case 1:
			
				// Don't capture special codes!
				
				if( (unsigned char) *yytext < (unsigned char) 0x80 )
				{
					collectBuf[ collectIndex++ ]   = yytext[0];
					collectBuf[ collectIndex ] = '\0';
				}
				return;
			
			case 2:
			
				collectBuf[ collectIndex ]   = yytext[0];
				collectBuf[ collectIndex+1 ] = yytext[1];
				collectIndex += 2;
				collectBuf[ collectIndex ] = '\0';
				return;
			
			case 3:
			
				collectBuf[ collectIndex ]   = yytext[0];
				collectBuf[ collectIndex+1 ] = yytext[1];
				collectBuf[ collectIndex+2 ] = yytext[2];
				collectIndex += 3;
				collectBuf[ collectIndex ] = '\0';
				return;
			
			case 4:
			
				collectBuf[ collectIndex ]   = yytext[0];
				collectBuf[ collectIndex+1 ] = yytext[1];
				collectBuf[ collectIndex+2 ] = yytext[2];
				collectBuf[ collectIndex+3 ] = yytext[3];
				collectIndex += 4;
				collectBuf[ collectIndex ] = '\0';
				return;
				
			default:
				memcpy( &collectBuf[ collectIndex ], yytext, yyleng );
				collectIndex += yyleng;
				collectBuf[ collectIndex ] = '\0';
		}
	}	
}



