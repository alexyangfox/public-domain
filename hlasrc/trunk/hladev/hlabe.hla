// hlabeUnit-
//
//	Backend for HLA that produces an object code file.

unit hlabeUnit;																  
?@nodisplay := true;		 
?@noalignstack := true;

?runFromHLA := false;	// Set to true if calling from an HLA program.

#includeOnce( "stdlib.hhf" )
#includeOnce( "hlabe.hhf" )


label QuitMain; @external( "QuitMain__hla_" );

const
	coffSymEBX		:text := "(type w.IMAGE_SYMBOL [ebx])";
	elfSymEAX		:text := "(type Elf32_Sym [eax])";
	elfSymEBX		:text := "(type Elf32_Sym [ebx])";
	MachoSymEBX		:text := "(type nlist [ebx])";
	 
type
	pRelocations	:pointer to byte; //w.IMAGE_RELOCATION or Elf32_Rel;
	pSym			:pointer to byte; //w.IMAGE_SYMBOL/Elf32_sym;
	pByte			:pointer to byte;
	
static
    align( 4 );
	COFFsyms		:pSym;
	numCOFFsyms		:uns32;
	coffSymSize		:dword;
	
	ELFsyms			:pSym;
	numELFsyms		:uns32;
	elfSymSize		:dword;
	
	MachoSyms		:dword;
	MachoSymSize	:dword;
	numMachoSyms	:uns32;
	
	
	stringTable		:pByte;
	strTblOffset	:dword;
	strTblSize		:uns32;

	codeSize		:dword;
	codeStart		:dword;
	codeEnd			:dword;
	numCodeRelocs	:dword;
	
	dataSize		:dword;
	dataStart		:dword;
	dataEnd			:dword;
	numDataRelocs	:dword;
	
	bssSize			:dword;
	bssStart		:dword;
	bssEnd			:dword;
	
    symbolTable     :table_t;
    equatesTable    :table_t;
	
	currentSection  :section_t	:= code_c;
	verboseDebug	:boolean	:= verbose_c;
	

#if( !runFromHLA )

	// The following procs are needed because we're compiling a unit that
	// believes it's a standalone HLA program:

		
	#if( @defined( WINDOWS ) )

		procedure HardwareException; 		@external( "HardwareException__hla_" );
		procedure HWexcept; 				@external( "HWexcept__hla_" );
		procedure HardwareException__hla_; 	@external;
		procedure HWexcept__hla_;			@external;

		procedure HWexcept__hla_;
		begin HWexcept__hla_; 
			
			jmp HardwareException__hla_;
			
		end HWexcept__hla_;
			
		
	#endif
	 

	procedure DefaultExceptionHandler;			
			@external( "DefaultExceptionHandler__hla_" );
			
	procedure DefaultExceptionHandler__hla_;	@external;
	procedure DfltExHndlr__hla_;				@external;
	procedure DfltExHndlr; 						@external( "DfltExHndlr__hla_" );
		
	procedure DfltExHndlr__hla_;
	begin DfltExHndlr__hla_;
		
		jmp DefaultExceptionHandler__hla_;
		
	end DfltExHndlr__hla_; 


	#if( @defined( UNIX ) )

	    procedure excepts_install_signals;		@external;
		procedure InstallSignals__hla_;			@external;
		procedure InstallSignals__hla_;
		begin InstallSignals__hla_;
		end InstallSignals__hla_;
		 
	#endif

	// These are declarations for procedures that exist in the HLA
	// standard library, but are "shrouded" in the sense that there
	// aren't corresponding declarations in the stdlib.hhf file (these
	// routines generally get called by HLA generated code, and nothing
	// else; however, as we have to simulate "HLA generated code" here,
	// we have to manually provide these declarations):

	procedure BuildExcepts; @external("BuildExcepts__hla_");

	 
	// The following are forward/external declarations for procedures
	// that are normally created by the HLA compiler when you write
	// a "main program." As we are not using an HLA main program here,
	// we have to manually create these procedures.




	static
		#if( !@defined( WINDOWS ) )
		
			ExceptionPtr		:dword;	@external( "ExceptionPtr__hla_" );
			
		#endif
		
		align(4);
		MainPgmVMT			:dword := &QuitMain;
		
		MainPgmCoroutine	:dword;		@nostorage;
							 dword		&MainPgmVMT, 0, 0;
		SaveSEHPointer		:dword := 0;
							 dword	0, 0;
		

	 

#endif // !runFromHLA

static
		saveESP				:dword;


/////////////////////////////////////////////////////////////////////////////////
//
// Support code for the symbol table:


// freeTableRecord
//
//  Called by the table destructor for each entry in the table.
// On entry, EBX points at the tableNode_t record for the table entry.
// This routine frees the storage associated with the Value field,
// which is a pointer to a symbol_t object in memory.

procedure freeTableRecord;
var
_begin( freeTableRecord );

    mem.free( (type tableNode_t [ebx]).Value );
	 
_end( freeTableRecord );





///////////////////////////////////////////////////////////////////////////////
//
// printLineNumberChain-
//
// EBX points at a disp_t record. Print the chain of filenames and line numbers
// pointed at by the line field.

procedure printLineNumberChain( var dispRec:disp_t in ebx );
var
_begin( printLineNumberChain );

	push( ebx );
	mov( dispEBX.line, ebx );
	while( ebx <> NULL ) do
	
		stderr.put( stdio.tab, srcEBX.filename, ':', srcEBX.lineNumber );
		mov( srcEBX.next, ebx );
		if( ebx <> NULL ) then
		
			stderr.put( ", " );
			
		endif; 
	
	endwhile;
	stderr.newln();
	pop( ebx );
	
_end( printLineNumberChain );



/////////////////////////////////////////////////////////////////////////////////
//
// Scan an HLABE (HLA back engine) assembly file.  Such files contain the
// following statements:
//
// .a	<x>						Alignment
// .b	<blist>					Byte data
// .c							Code section
// .d	<dlist>					Dword data (includes relocatable)	
// .e	l1, l2					Equate
// .f	l						End of function
// .l	<llist>					Lword data
// .o	<string>				sOurce file name
// .p	l						Public symbol
// .q	<qlist>					Qword data
// .r	<x>						Reserve Storage
// .s							Static/Data section
// .t	<tlist>					TByte data
// .ub	<x1>,<x2>				Duplicated byte data
// .uw	<x1>,<x2>				Duplicated word data
// .ud	<x1>,<x2>				Duplicated dword data
// .v							BSS section
// .w	<wlist>					Word data
// .x	lbl						External symbol
// .y							READONLY/CONST section
// .z							End of source
//
// :lbl				Defines label at current program counter location.
//
// Except for label (which is terminated by a newline character), there
// is always at least one space between the statement and any operands.

// Numbers beginning with '$' are hexadecimal values, decimal if no '$' prefix.
// Decimal numbers may contain chars 0..9 and '_'. Hexadecimal numbers may
// also contain 'a'..'f' and 'A'..'F'.
//
// Labels always begin with alpha or '_' character and may contain
// alphanumeric, '_', '$', '?', and "@" characters after the first char.
// In general, labels can be any length, but the object file format or specific
// linkers may enforce their own limits. As a general rule, symbols should be
// unique within the first 32 characters.
//
//
// <x>, <x1>, <x2>, and <x3> are simplified (absolute) arithmetic expressions 
// defined as follows:
//
//	$<hex digits>	-- Hexadecimal value
//	<dec digits>	-- Decimal (base 10) value
//	<x1> + <x2>		-- Sum of two subexpressions
//	<x1> - <x2>		-- Difference of two subexpressions
//
// Evaluation of subexpressions is strictly left-to-right with no precedence.
//
// Relocatable expressions are a vector with a label component and an
// absolute expression component.  This is generally specified as <r+x>.
// The syntax for a relative expression is one of the following:
//
//	<x>				-- An absolute expression (which has a NULL relocatable value)
//	id				-- A relocatable identifier.
//	id + <x>		-- An identifier (relocatable) followed by an abs expr.
//	id - <x>		-- A relocatable identifier followed by an abs expr.
//
//
//
//
// Blank lines are permissible in the source file.
// Comments begin with a ';' and consume everything to the end of the line.
//
//
// .a <expr>
//
// The alignment statement will align the next byte emitted in the current
// section to some boundary that is a power of two. The operand is a single
// expression that evaluates to a small integer value. The alignment value 
// must always be a power of two. It should also be in the range 1..16.  
//
// Alignment statement will fill with zeros in static/data section, with no-
// operations in a code section (this could be "multi-byte NOPs", not
// necessarily a sequence of individual NOP instructions), 
// and will do a reserve storage operation in the BSS section.
//
// .c, .s, .v, .y
//
//	These four statements begin (or continue) a code (.c), readonly/const (.y),
// data/static (.s), BSS (.v) section in the program. Note that multiple 
// instances of each section statement may appear within a single source file. 
// When multiple instances of a given section in the source file exist, 
// HLABE will combine the different instances into a single section.
//
// Within a section, order of data/code is strictly maintained, but if multiple
// section declarations for the same section appear in a source file, there is
// no guarantee of the order the subsections will be combined. If strict ordering
// is required, the caller should combine the sections and emit them as a single
// section when creating the HLABE source file.
//
//  No explicit alignment is assumed when a section begins. Calling code
// must explicitly issue a ".a" statement if alignment is desired or required.
// 
// .b, .w, .d, .q, .t, .l
//
// These directives	emit bytes, word, doublewords, quadwords, tbytes, or
// lbytes (128-bit values) to the current section (code or data/static, these
// directives cannot appear in a BSS section).  These directives have the
// following syntax and semantics:
//
// .b <blist>	
//		<blist> is a list of one or more byte items. A byte item is either an
//		expression that evaluates to a value in the range 0..$ff
//		(or -128..+127) or a sequence of characters surrounded by
//		quotes. If more than one byte item appears in a <blist>, the
//		byte items are comma-separated. Note that quote
//		characters never appear within a string (they must be converted 
//		to '$22' byte items). Also, only printable ASCII characters 
//		may appear within a quoted string (characters whose codes are
//		in the range $20..$7e).	All other characters must be converted
//		to numeric byte item entries.
//
// .w <wlist>
//		A <wlist> is a list of one or more word items. Word items are 
//		expressions that evaluate to 16-bit (or smaller) values. Multiple 
//		items in a <wlist> are comma-separated.  
//
// .d <dlist>	
//		A <dlist> is a list of one or more dword items. Dword items are 
//		relocatable or absolute expressions that evaluate to 32-bit (or smaller) 
//		values. Multiple items in a <dlist> are comma-separated. Pointer 
//		constants (relocatable objects) are also valid dword items.  A pointer 
//		constant is one of the following:
//
//			lbl
//			lbl+<x>
//			lbl-<x>
//			(lbl+<x>)
//			(lbl-<x>)
//
//		where "lbl" is a relocatable statement label and <x>
//		is any valid dword expression. HLABE always emits a
//		relocatable offset value for these items ( <r+x> ).
//		Note that all dword constants are always a tuple. If
//		the dword constant is absolute, then the relocatable component (<r>)
//		is set to the NULL pointer.  
//
// .q <qlist>	
//		A <qlist> is a list of one or more qword items. Qword items are 
//		numeric operands that evaluate to 64-bit (or smaller) values. Multiple 
//		items in a <qlist> are comma-separated.  
//
// .t <tlist>
//		A <tlist> is a list of one or more tbyte items. TByte items are 
//		numeric operands that evaluate to 80-bit (or smaller) values. Multiple 
//		items in a <tlist> are comma-separated.  
//
// .l <llist>
//		A <llist> is a list of one or more lword items. Lword items are 
//		numeric operands that evaluate to 128-bit (or smaller) values. Multiple 
//		items in an <llist> are comma-separated. 
//
// .ub <x1>,<x2>
//		<x1> is a duplication count. <x2>  is a data value, which should be
//		a byte. This directive, which is valid only in the
//		code and static/data sections (illegal in the BSS section) is used to
//		fill a block of memory with a specific value. The values must be
//		absolute.
//
// .uw <x1>,<x2>
//		<x1> is a duplication count. <x2>  is a data value, which should be
//		a word. This directive, which is valid only in the
//		code and static/data sections (illegal in the BSS section) is used to
//		fill a block of memory with a specific value. The values must be
//		absolute.
//
// .ud <x1>,<x2>
//		<x1> is a duplication count. <x2>  is a data value, which should be
//		a relocatable dword value. This directive, which is valid only in the
//		code and static/data sections (illegal in the BSS section) is used to
//		fill a block of memory with a specific value. The values can be
//		absolute or relative (absolute dword values are <r+x> values with
//		the relocatable field set to NULL).
//
// .r <x>
//		Reserves <x> bytes of data at the current program counter location in
//		the current section. If a code section, the reserved storage is filled
//		with NOP-style instructions, if a data/static section, the reserved
//		storage is filled with zeros. This statement is valid in, and is
//		mainly intended for use in, a BSS section.
//
//
// .e lbl, <text>
//
// Equates simply do a textual substitution of the <text> operand for the label
// operand. I.e., everywhere "lbl" appears (in the example above), HLABE 
// substitutes the remaining text on the line (up to the end of the line or up
// to a comment beginning with a ";") for the symbol. After substitution, HLABE
// continues processing the source line as though the <text> data originally
// appeared in place of the symbol. Note that if the <text> string contains 
// other equate symbols, they will be processed as well. There is no check
// for infinite loops in the text substitution process. It is the responsibility
// of whomever created the equate(s) to ensure that a recursive definition
// does not exist. Note that only a single line of text substitution is
// possible (i.e., this is not a generalized macro facility).
//
//
// .f lbl
//
//	Marks the end of a function. When generating ELF code, this will
// change the symbol type (of the corresponding label) in the symbol
// table and set the length of the function.
//
//
// In addition to the above statements, an HLABE program may also contain
// jmp, call, and any of the following conditional jump instructions:
// ja, jae, jb, jbe, jc, je, jg, jge, jl, jle, jna, jnae, jnb, jnbe,		
// jnc, jne, jng, jnge, jnl, jnle, jno, jnp, jns, jnz, jo, jp, jpe, jpo,		
// js, jz, jcxz, jecxz, loop, loope, loopne, loopz, or loopnz.
//
// Any number of spaces and/or tabs may precede these statements. Any number
// of spaces and/or tabs may appear between the instruction mnemonic and
// the single label operand. After the label, at least one space will appear.
// After each jump, call, or conditional jump instruction, there will always
// be a comment of the form:
//
//	";filename, line#"
//	";filename, line# ;filename line#; ..."
//
// This is a list of filenames and line numbers in the original source
// file where the statement that emitted this code can be found. If the
// statement was emitted from a macro or include file, there will be more than
// one filename/line# pair (with the last entry being the file/line# of the
// actual statement within the macro or include file). The HLABE compiler
// should parse this information and display it if there is an error
// compiling the statement (e.g., branch out of range).  Line numbers are always
// unsigned decimal integers.
//
// Note that call and jmp statements only appear in a source file for
// relative jumps and calls. Those that do indirect jumps or calls must be
// compiled directly to machine code by the caller.
//
// All reserved words use lower case characters only. Labels, however, may
// contain upper and lower case characters (and are case sensitive).

_proc( lexer )
( 
			start_source		:dword; 
			end_src 			:dword; 
	result	codeListHead		:tokenList_t;
	result	dataListHead		:tokenList_t;
	result	bssListHead			:tokenList_t
);
const
	bbx			:text := "(type byte [ebx])";

var
	scannedSrc	:dword;
	identifier	:string;
	byteIndex	:dword;
	idBuf		:char[1024];
	byteString	:byte[4096];
	
static

	lineNumber		:uns32 := 1;

    // Make tknListTail static so we can globally access it within
	// lexer support functions. 
	
	tknListTail	    	:dword;
	lastTailPtr     	:dword;
	codeListTail    	:dword;
	dataListTail    	:dword;
	bssListTail     	:dword;
	
	// end_source never changes in lexer, so make it static so we can
	// globally access it within lexer support functions.
	
	end_source  :dword;
	
	// start_stmt is only used for error reporting, so make it static so we
	// can access it globally.
	
	start_stmt	:dword;
	

	_proc( skipToEoln ); @noframe;
	var
	_begin( skipToEoln );
	
		while( ebx < end_source && (type char [ebx]) <> stdio.lf ) do
		
			inc( ebx );
			
		endwhile;
		inc( ebx );		// Skip over newline.
		inc( lineNumber );
		ret();
		 
	_end( skipToEoln );
	
	
	
	// skipSpaces-
	//
	//	Skips leading whitespace (space and tab) characters.
	// Callable only from within the lexer procedure
	
	_proc( skipSpaces ); @noframe;
	var
	_begin( skipSpaces );
	
		dec( ebx );
		skipSpcs:
			inc( ebx );
			cmp( ebx, end_source );
			jae skippedSpaces;
			
			mov( [ebx], al );
			cmp( al, ' ' );
			je skipSpcs;
			cmp( al, stdio.tab );
			je skipSpcs;
			cmp( al, stdio.cr );
			je skipSpcs;
			
		skippedSpaces:
			ret( _parms_ );

	_end( skipSpaces );
	
	// skipSpaces2-
	//
	//	Skips leading whitespace (space and tab) characters.
	// Raises an exception (conversion error) if we exceed the
	// bounds of the file.
	
	_proc( skipSpaces2 ); @noframe;
	var
	_begin( skipSpaces2 );
	
		dec( ebx );
		skipSpcs:
			inc( ebx );
			cmp( ebx, end_source );
			jae skippedSpaces;
			
			mov( [ebx], al );
			cmp( al, ' ' );
			je skipSpcs;
			cmp( al, stdio.tab );
			je skipSpcs;
			cmp( al, stdio.cr );
			je skipSpcs;
			ret();
			
		skippedSpaces:
			stdout.put( "Attempted to scan beyond the end of the file" nl );
			raise( ex.ConversionError );

	_end( skipSpaces2 );
	
	// grabID-
	//
	//	Extracts all the text up to the next ID delimiter in the 
	// input file and stores the data into the string specified by rslt.
	//
	//	Returns 1 in EAX if successful. Returns 0 if the string is empty
	// or if it goes past the end of the file.
	//
	//	Leaves EBX pointing at the first space that it found.
	//	Whacks ECX and EDX.
	//
	//	Untested assertion:  rslt string is assumed to be large enough
	//	to hold the result.
	 
	_proc( grabID )( rslt:string );	@noframe;
	readonly
		idSet	:cset := 
			{ 
				'a'..'z', 
				'A'..'Z', 
				'0'..'9', 
				'_', '@', '?', '$', '.' 
			};
			cset {};	// Handle illegal chars with bit 7 set.
		
	_begin( grabID );
	
		// Grab everything up to the next space or EOLN:
		
		mov( [esp+4], ecx );	// rslt string
		forever
		
			breakif( ebx >= end_source );
			movzx( (type char [ebx]), eax );
			bt( eax, idSet );
			breakif( @nc );
			mov( al, [ecx] );
			inc( ebx );
			inc( ecx );
			
		endfor;
		mov( 0, (type byte [ecx]));		// Zero-terminate string
		
		// Set the length of the identifier string:
		
		mov( [esp+4], edx );
		sub( edx, ecx );
		mov( ecx, (type str.strRec [edx]).length );
		
		// If we find the identifier in the equatesTable, then
		// replace the identifier with its equate value.
		
		push( esi );
		push( edi );
		repeat
		
			equatesTable.lookup( edx );
			if( eax <> NULL ) then
			
				mov( (type tableNode_t [eax]).Value, eax );
				str.cpy( eax, edx ); 
			
			endif;
			
		until( eax = NULL );
		pop( edi );
		pop( esi );		
		
		cmp( ebx, end_source );
		setb( al );
		movzx( al, eax );
		ret( 4 );
		
	_end( grabID );
	
	
	// emit an error message if the token is unknown:
	
	_proc( unknownStmt ); @noframe;
	var
	_begin( unknownStmt );

		stdout.put( "Unknown statement: " );
		mov( start_stmt, ebx );
		while( ebx < end_source && (type char [ebx]) <> stdio.lf ) do
		
			stdout.putc( [ebx] );
			inc( ebx );
			
		endwhile;
		inc( ebx );
		inc( lineNumber );
		stdout.newln();
		ret();

	_end( unknownStmt );
	
	
	
	
	
	// RelExpr-
	//
	// Evaluate a relocatable expression.
	// EBX points at the start of the expression text. Evaluate all text
	// until we encounter something that is not part of an expression
	// (which should be a comma or EOLN).
	//
	// Returns with the numeric value of the expression in EAX (or the
	// offset portion if relocatable). Returns with EDX containing NULL
	// if the expression is absolute and returns with EDX containing the
	// address of a symbol table entry if the expression is relocatable.
	//
	// Expressions have the following syntax:
	//
	//	$<hex digits>		-- Hexadecimal value
	//	<dec digits>		-- Decimal (base 10) value
	//							0 for all other statements.
	//	<x1> + <x2>			-- Sum of two subexpressions
	//	<x1> - <x2>			-- Difference of two subexpressions
	//	RelocLabel			-- Relocatable expression
	//	RelocLabel + <x1>	-- Relocatable expression
	//	RelocLabel - <x1>	-- Relocatable expression
	//	(RelocLabel + <x1>)	-- Relocatable expression
	//	(RelocLabel - <x1>)	-- Relocatable expression
	
	_proc( RelExpr );
	var
		accResult	:dword;				// Displacement/immediate value
		symbol		:tableNodePtr_t;	// Pointer to relocatable object.
		
		
		#macro testReloc;
		
			if( edx <> NULL ) then
			
				stderr.put
				( 
					"Illegal relocatable object at line ",
					lineNumber, 
					nl 
				);
				raise( ex.InvalidArgument );
				
			endif
		
		#endmacro
		
		
		// getOperand extracts a single hex or decimal constant,
		// or a relocatable operand.
		// It returns the operand's value in EAX. It returns EBX pointing
		// at the next symbol in the input stream.
		
		_proc( getOperand );
		var
			idStr		:string;
			idStrBuf	:char[1024];
						
		_begin( getOperand );
		
			push( esi );
			skipSpaces2();
			movzx( (type byte [ebx]), eax );
			switch( eax )
			
				// Process hexadecimal constants with a leading "$" here:
				
				case( '$' )
				
					conv.atoh32( [ebx+1] );
					mov( esi, ebx );
					xor( edx, edx );	// Absolute operand
											
				
				// Process decimal constants here:
				
				case( '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' )
				
					conv.atou32( [ebx] );
					mov( esi, ebx );
					xor( edx, edx );	// Absolute operand
				
					
				// Process relocatable labels here:
				
				case
				(
					'_', 
					'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
					'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
					't', 'u', 'v', 'w', 'x', 'y', 'z',  
					'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
					'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
					'T', 'U', 'V', 'W', 'X', 'Y', 'Z'  
				)
				
					str.init( idStrBuf, @size( idStrBuf ) );
					mov( eax, idStr );
					grabID( idStr );
					symbolTable.getNode( idStr );
					if( (type tableNode_t [eax]).Value = 0 ) then

					    // Brand-new symbol, so we need to allocate
						// storage for a symbol_t object and initialize
						// it appropriately:
						
						mov( eax, edx );
						mem.alloc( @size( symbol_t ));
						mov( eax, (type tableNode_t [edx]).Value );
						mov( isReferenced_c, symEAX.flags );
						mov( (type tableNode_t [edx]).id, ecx );
						mov( ecx, symEAX.id );
						mov( 0, symEAX.offset );
						mov( NULL, symEAX.next );

						// Note: do not set the section field as we may
						// not be operating in the section where the
						// symbol is actually defined.
						
						mov( undefinedSection_c, symEAX.section );
						
					else    // Symbol is already defined
					
						mov( (type tableNode_t [eax]).Value, edx );
						or( isReferenced_c, symEDX.flags );
						mov( eax, edx );
						
					endif;
					xor( eax, eax );		// return offset = 0.

					
				case( '(' )
				
					add( 1, ebx );
					RelExpr();
					push( eax );
					skipSpaces2();
					if( al <> ')' ) then
					
						stderr.put
						( 
							"Expected ')' in expression at line ",
							lineNumber,
							nl 
						);
						raise( ex.IllegalChar );
						
					endif;
					add( 1, ebx );
					pop( eax );
					
				
				default
				
					stdout.put
					( 
						"Unexpected character in expression: '",
						(type char al),
						"' at line ", lineNumber, nl 
					);
					raise( ex.ConversionError );
				
			endswitch;
			pop( esi );
			
		_end( getOperand );
		
	_begin( RelExpr );
	
		// Handle any generic sequence of expression operands.
		//
		// All expressions must begin with at least one operand:
		
		getOperand();
		mov( eax, accResult );
		mov( edx, symbol );
		
		// For every operator we encounter (if any), process the following
		// operand and do the operation requested:
		
		forever
		
			movzx( (type byte [ebx]), eax );
			switch( eax )
			
				// Handle "x+y" here:
				
				case( '+' )
				
					add( 1, ebx );		// skip '+'
					getOperand();
					testReloc;
					add( eax, accResult );
				
				// Handle "x-y" here:
				
				case( '-' )
				
					add( 1, ebx );		// skip '-'
					getOperand();
					testReloc;
					neg( eax );
					add( eax, accResult );
				
				
				default
				
					// If not an operator symbol, then
					// bail out of the forever loop:
					
					break;
				
			endswitch; 
			
		endfor;
		mov( accResult, eax );
		mov( symbol, edx );
		
	_end( RelExpr );
	
	
	
	
	// Parse a relocatable expression.
	//
	// Returns the Relative component in EDX and the absolute component in EAX.
	
	_proc( EvalExpr );
	var
	_begin( EvalExpr );
	
		push( edx );
		RelExpr();
		if( edx <> NULL ) then
		
			stderr.put
			( 
				"Expression cannot contain relocatable items at line ",
				lineNumber,
				nl 
			);
			raise( ex.InvalidArgument );
			
		endif;
		pop( edx );
		
	_end( EvalExpr );
	
	
	
	
	
	
	// parseBytes-
	//
	//	Processes operands following a .b statement.
	//	Returns a pointer to the allocated data (on the heap) in EAX
	//	and the size of the block in ECX.
	
	_proc( parseBytes )( curSize:dword );
	var
		strStart	:dword;
		strEnd		:dword;
		byteVal		:byte;
		
	_begin( parseBytes );
	
		skipSpaces2();
		if( (type char [ebx]) = '"' ) then
		
			// It's a string, so we need to save pointers to the
			// beginning and end of the string
			
			add( 1, ebx );
			mov( ebx, strStart );
			while( (type char [ebx]) <> '"' ) do
			
				add( 1, ebx );
				
			endwhile;
			mov( ebx, strEnd );
			skipSpaces2();
			if( (type char [ebx]) = ',' ) then
			
				//  If there is additional data to process, do so
				
				add( 1, ebx );					// Skip ','
				mov( strEnd, eax );				// Add in the string size to
				sub( strStart, eax );			// get new curSize.
				add( curSize, eax );
				parseBytes( eax );
				
				
			else	// No comma separator
				
				// If there was no comma separator, then we've reached the
				// end of the byte list. So allocate an appropriate amount
				// of storage to allow us to store the string at the end
				// of the current buffer.
				//
				// Note that the memory allocation includes room for the
				// byteStmt_t header information. This code adjusts the
				// pointer in EAX to point at the first byte of the
				// byteVal buffer in the structure (this will be fixed
				// upon the final return from parseBytes).
			
				mov( strEnd, ecx );			// Add in the string size to
				sub( strStart, ecx );		// get new curSize.
				add( curSize, ecx );
				add( @size( varLen_t ), ecx );
				mem.alloc( ecx );			// Allocate storage for the buffer
				
				// Compute actual buffer size:
				
				sub( @size( varLen_t ), ecx );
				
				// Set up the byteStmt_t record and link into the
				// statement list:
				
				push( edx );
				mov( tknListTail, edx );
				mov( bytes_tkn, (type byteStmt_t [eax]).token );
				mov( NULL, (type byteStmt_t [eax]).next );
				mov( edx, (type byteStmt_t [eax]).prev ); 
				mov( eax, (type byteStmt_t [edx]).next );
				mov( ecx, (type byteStmt_t [eax]).numBytes );
				mov( eax, tknListTail );
				pop( edx );
				
				// Adjust address to point at the start of the buffer:
				
				add( @size( varLen_t ), eax );
				
				
				
			endif;
		
			// Copy the string data to the appropriate spot in the
			// buffer that was allocated by parseBytes or mem.alloc.
			
			push( esi );
			push( edi );
			push( ecx );
			cld();
			
			mov( strStart, esi );
			mov( eax, edi );
			add( curSize, edi );	// Index to string starting position.
			mov( strEnd, ecx );		// Compute string length
			sub( esi, ecx );
			cld();
			rep.movsb();
			
			pop( ecx );
			pop( edi );
			pop( esi );
				
		
		else
		
			// Must be a single byte expression.
			
			EvalExpr();
			if( eax >= $100 ) then
			
				stdout.put( ".b operand out of range" nl );
				raise( ex.ValueOutOfRange );
				
			endif;
			mov( al, byteVal );
			skipSpaces2();
			if( (type char [ebx]) = ',' ) then
			
				//  If there is additional data to process, do so
				
				add( 1, ebx );					// Skip ','
				mov( curSize, eax );
				add( 1, eax );
				parseBytes( eax );
				
				
			else	// No comma separator
				
				// If there was no comma separator, then we've reached the
				// end of the byte list. So allocate an appropriate amount
				// of storage to allow us to store the byte at the end
				// of the current buffer.
			
				mov( curSize, ecx );
				add( @size( varLen_t )+1, ecx );
				mem.alloc( ecx );			// Allocate storage for the buffer
				
				// Compute actual buffer size:
				
				sub( @size( varLen_t ), ecx );
				
				// Set up the byteStmt_t record and link into the
				// statement list:
				
				push( edx );
				mov( tknListTail, edx );
				mov( bytes_tkn, (type byteStmt_t [eax]).token );
				mov( NULL, (type byteStmt_t [eax]).next );
				mov( edx, (type byteStmt_t [eax]).prev ); 
				mov( eax, (type byteStmt_t [edx]).next );
				mov( ecx, (type byteStmt_t [eax]).numBytes );
				mov( eax, tknListTail );
				pop( edx );
				
				
				
				// Adjust address to point at the start of the buffer:
				
				add( @size( varLen_t ), eax );
				
				
			endif;
			
			// Okay, store the byte we processed at the end of the buffer:
			
			push( ebx );
			push( edx );
			mov( byteVal, bl );
			mov( curSize, edx );
			mov( bl, [eax+edx] );
			pop( edx );
			pop( ebx );
			
		endif;
			
		
	_end( parseBytes );
	
	
	
	// parseWords-
	//
	//	Processes operands following a .w statement.
	//	Returns a pointer to the allocated data (on the heap) in EAX
	//	and the size of the block in ECX.
	
	_proc( parseWords )( curSize:dword );
	var
		strStart	:dword;
		strEnd		:dword;
		wordVal		:word;
		
	_begin( parseWords );
	
		push( edx );
		skipSpaces2();
		
		// Must be a single word expression.
		
		EvalExpr();
		if( eax >= $1_0000 ) then
		
			stdout.put( ".w operand out of range" nl );
			raise( ex.ValueOutOfRange );
			
		endif;
		mov( ax, wordVal );
		skipSpaces2();
		if( (type char [ebx]) = ',' ) then
		
			//  If there is additional data to process, do so
			
			add( 1, ebx );					// Skip ','
			mov( curSize, eax );
			add( 2, eax );
			parseWords( eax );
			
			
		else	// No comma separator
			
			// If there was no comma separator, then we've reached the
			// end of the word list. So allocate an appropriate amount
			// of storage to allow us to store the word at the end
			// of the current buffer.
		
			mov( curSize, ecx );
			add( @size( varLen_t )+2, ecx );
			mem.alloc( ecx );			// Allocate storage for the buffer
			
			// Compute actual buffer size:
			
			sub( @size( varLen_t ), ecx );
			
			// Set up the byteStmt_t record and link into the
			// statement list:
			
			mov( tknListTail, edx );
			mov( bytes_tkn, (type byteStmt_t [eax]).token );
			mov( NULL, (type byteStmt_t [eax]).next );
			mov( edx, (type byteStmt_t [eax]).prev ); 
			mov( eax, (type byteStmt_t [edx]).next );
			mov( ecx, (type byteStmt_t [eax]).numBytes );
			mov( eax, tknListTail );
						
			// Adjust address to point at the start of the buffer:
			
			add( @size( varLen_t ), eax );
							
			// Okay, store the word we processed at the end of the buffer:
			
			push( ebx );
			mov( wordVal, bx );
			mov( curSize, edx );
			mov( bx, [eax+edx] );
			pop( ebx );
			
		endif;
		pop( edx );
			
	_end( parseWords );
	
	
	
	
	
	
	
	
	
	// parseDwords-
	//
	//	Processes operands following a .d statement.
	//	Returns a pointer to the allocated data (on the heap) in EAX
	//	and the size of the block in ECX.
	
	_proc( parseDwords )( curSize:dword );
	var
		strStart	:dword;
		strEnd		:dword;
		dwordVal	:dword;
		relocVal	:dword;
		
	_begin( parseDwords );
	
		push( edx );
		skipSpaces2();
		
		// Must be a single dword expression.
		
		RelExpr();
		mov( eax, dwordVal );
		
		if( edx = NULL ) then
			// Allocate an appropriate amount of storage to 
			// allow us to store the non-relocatable dword value.
		
			mem.alloc( @size( varLen_t )+4 );	// Allocate storage for the buffer
			
			
			// Set up the byteStmt_t record and link into the
			// statement list:
			
			mov( tknListTail, edx );
			mov( bytes_tkn, (type byteStmt_t [eax]).token );
			mov( NULL, (type byteStmt_t [eax]).next );
			mov( edx, (type byteStmt_t [eax]).prev ); 
			mov( eax, (type byteStmt_t [edx]).next );
			mov( 4, (type byteStmt_t [eax]).numBytes );
			mov( eax, tknListTail );
						
			// Okay, store the dword we processed at the end of the buffer:
			
			mov( dwordVal, edx );
			mov( edx, (type dword (type byteStmt_t [eax]).byteData) );
			clc();	// Return carry clear for byte array
						
		else	// Relocatable object:
					
			mem.alloc( @size( relocStmt_t ));

			// Set up the relocStmt_t record and link into the
			// statement list:
			
			push( edx );
			mov( tknListTail, edx );
			mov( reloc_tkn, (type relocStmt_t [eax]).token );
			mov( NULL, (type relocStmt_t [eax]).next );
			mov( edx, (type relocStmt_t [eax]).prev ); 
			mov( eax, (type relocStmt_t [edx]).next );
			mov( eax, tknListTail );
			pop( edx );
			
			// Initialize the data fields of the relocStmt_t record:
			
			mov( edx, (type relocStmt_t [eax]).symbol );
			mov( dwordVal, edx );
			mov( edx, (type relocStmt_t [eax]).offset );
			stc();	// Return carry set for reloc object.
			
		endif;
			
		pop( edx );
			
	_end( parseDwords );
	
	
	
	
	
	
	// parseQWords-
	//
	//	Processes operands following a .q statement.
	//	Returns a pointer to the allocated data (on the heap) in EAX
	//	and the size of the block in ECX.
	
	_proc( parseQWords )( curSize:dword );
	var
		strStart	:dword;
		strEnd		:dword;
		qwordVal	:qword;

        _proc( EvalQWord );
		var
		_begin( EvalQWord );
		
		    push( esi );
		    mov( [ebx], al );
			if( al = '$' ) then
			
			    add( 1, ebx );
				conv.atoh64( [ebx] );
				mov( esi, ebx );
				
			else
			
			    conv.atou64( [ebx] );
				mov( esi, ebx );
				
			endif;
            pop( esi );			
			    
		_end( EvalQWord );
		
	_begin( parseQWords );
	
	    push( edx );
		skipSpaces2();
		
		// Must be a single qword expression.
		
		EvalQWord();
		mov( edx:eax, qwordVal );
		skipSpaces2();
		if( (type char [ebx]) = ',' ) then
		
			//  If there is additional data to process, do so
			
			add( 1, ebx );					// Skip ','
			mov( curSize, eax );
			add( 8, eax );
			parseQWords( eax );
			
			
		else	// No comma separator
			
			// If there was no comma separator, then we've reached the
			// end of the qword list. So allocate an appropriate amount
			// of storage to allow us to store the qword at the end
			// of the current buffer.
		
			mov( curSize, ecx );
			add( @size( varLen_t )+8, ecx );
			mem.alloc( ecx );			// Allocate storage for the buffer
			
			// Compute actual buffer size:
			
			sub( @size( varLen_t ), ecx );
			
			// Set up the byteStmt_t record and link into the
			// statement list:
			
			mov( tknListTail, edx );
			mov( bytes_tkn, (type byteStmt_t [eax]).token );
			mov( NULL, (type byteStmt_t [eax]).next );
			mov( edx, (type byteStmt_t [eax]).prev ); 
			mov( eax, (type byteStmt_t [edx]).next );
			mov( ecx, (type byteStmt_t [eax]).numBytes );
			mov( eax, tknListTail );
						
			// Adjust address to point at the start of the buffer:
			
			add( @size( varLen_t ), eax );
							
			// Okay, store the word we processed at the end of the buffer:
			
			push( ebx );
			mov( (type dword qwordVal), ebx );
			mov( curSize, edx );
			mov( ebx, [eax+edx] );
			mov( (type dword qwordVal[4]), ebx );
			mov( ebx, [eax+edx+4] );
			pop( ebx );
			
		endif;
		pop( edx );
			
	_end( parseQWords );
	
	
	
	
	
	
	// parseTBytes-
	//
	//	Processes operands following a .t statement.
	//	Returns a pointer to the allocated data (on the heap) in EAX
	//	and the size of the block in ECX.
	
	_proc( parseTBytes )( curSize:dword );
	var
		strStart	:dword;
		strEnd		:dword;
		tbyteVal	:lword;

        _proc( EvalTByte ); @noframe;
		var
		_begin( EvalTByte );
		
		    push( esi );
		    mov( [ebx], al );
			if( al = '$' ) then
			
			    add( 1, ebx );
				conv.atoh80( [ebx], (type tbyte ebp::tbyteVal) );
				mov( esi, ebx );
				
			else
			
			    conv.atou128( [ebx], ebp::tbyteVal );
				mov( esi, ebx );
				movzx( (type word ebp::tbyteVal[10]), eax );
				or( (type dword ebp::tbyteVal[12]), eax );
				if( eax <> 0 ) then
				
				    stdout.put( "TByte value out of range" nl );
					raise( ex.ValueOutOfRange );
					
				endif;
				
			endif;
            pop( esi );			
			ret();
			    
		_end( EvalTByte );
		
	_begin( parseTBytes );
	
	    push( edx );
		skipSpaces2();
		
		// Must be a single tbyte expression.
		
		EvalTByte();
		skipSpaces2();
		if( (type char [ebx]) = ',' ) then
		
			//  If there is additional data to process, do so
			
			add( 1, ebx );					// Skip ','
			mov( curSize, eax );
			add( 10, eax );
			parseTBytes( eax );
			
			
		else	// No comma separator
			
			// If there was no comma separator, then we've reached the
			// end of the qword list. So allocate an appropriate amount
			// of storage to allow us to store the qword at the end
			// of the current buffer.
		
			mov( curSize, ecx );
			add( @size( varLen_t )+10, ecx );
			mem.alloc( ecx );			// Allocate storage for the buffer
			
			// Compute actual buffer size:
			
			sub( @size( varLen_t ), ecx );
			
			// Set up the byteStmt_t record and link into the
			// statement list:
			
			mov( tknListTail, edx );
			mov( bytes_tkn, (type byteStmt_t [eax]).token );
			mov( NULL, (type byteStmt_t [eax]).next );
			mov( edx, (type byteStmt_t [eax]).prev ); 
			mov( eax, (type byteStmt_t [edx]).next );
			mov( ecx, (type byteStmt_t [eax]).numBytes );
			mov( eax, tknListTail );
						
			// Adjust address to point at the start of the buffer:
			
			add( @size( varLen_t ), eax );
							
			// Okay, store the word we processed at the end of the buffer:
			
			push( ebx );
			mov( (type dword tbyteVal), ebx );
			mov( curSize, edx );
			mov( ebx, [eax+edx] );
			mov( (type dword tbyteVal[4]), ebx );
			mov( ebx, [eax+edx+4] );
			mov( (type word tbyteVal[8]), bx );
			mov( bx, [eax+edx+8] );
			pop( ebx );
			
		endif;
		pop( edx );
			
	_end( parseTBytes );
	
	
	
	
	
	
	
	
	
	// parseLWords-
	//
	//	Processes operands following a .l statement.
	//	Returns a pointer to the allocated data (on the heap) in EAX
	//	and the size of the block in ECX.
	
	_proc( parseLWords )( curSize:dword );
	var
		strStart	:dword;
		strEnd		:dword;
		lwordVal	:lword;

        _proc( EvalLWord ); @noframe;
		var
		_begin( EvalLWord );
		
		    push( esi );
		    mov( [ebx], al );
			if( al = '$' ) then
			
			    add( 1, ebx );
				conv.atoh128( [ebx], ebp::lwordVal );
				mov( esi, ebx );
				
			else
			
			    conv.atou128( [ebx], ebp::lwordVal );
				mov( esi, ebx );
				
			endif;
            pop( esi );			
			ret();
			    
		_end( EvalLWord );
		
	_begin( parseLWords );
	
	    push( edx );
		skipSpaces2();
		
		// Must be a single lword expression.
		
		EvalLWord();
		skipSpaces2();
		if( (type char [ebx]) = ',' ) then
		
			//  If there is additional data to process, do so
			
			add( 1, ebx );					// Skip ','
			mov( curSize, eax );
			add( 16, eax );
			parseTBytes( eax );
			
			
		else	// No comma separator
			
			// If there was no comma separator, then we've reached the
			// end of the qword list. So allocate an appropriate amount
			// of storage to allow us to store the qword at the end
			// of the current buffer.
		
			mov( curSize, ecx );
			add( @size( varLen_t )+16, ecx );
			mem.alloc( ecx );			// Allocate storage for the buffer
			
			// Compute actual buffer size:
			
			sub( @size( varLen_t ), ecx );
			
			// Set up the byteStmt_t record and link into the
			// statement list:
			
			mov( tknListTail, edx );
			mov( bytes_tkn, (type byteStmt_t [eax]).token );
			mov( NULL, (type byteStmt_t [eax]).next );
			mov( edx, (type byteStmt_t [eax]).prev ); 
			mov( eax, (type byteStmt_t [edx]).next );
			mov( ecx, (type byteStmt_t [eax]).numBytes );
			mov( eax, tknListTail );
						
			// Adjust address to point at the start of the buffer:
			
			add( @size( varLen_t ), eax );
							
			// Okay, store the word we processed at the end of the buffer:
			
			push( ebx );
			mov( (type dword lwordVal), ebx );
			mov( curSize, edx );
			mov( ebx, [eax+edx] );
			mov( (type dword lwordVal[4]), ebx );
			mov( ebx, [eax+edx+4] );
			mov( (type dword lwordVal[8]), ebx );
			mov( ebx, [eax+edx+8] );
			mov( (type dword lwordVal[12]), ebx );
			mov( ebx, [eax+edx+12] );
			pop( ebx );
			
		endif;
		pop( edx );
			
	_end( parseLWords );
	
	
	
	// coalesce-
	//
	//  Coalesces two varLen_t records into a single record.
	// The assumption here is that "lastRec" is already linked into
	// the list (and is the last item in the list) and lastRec.prev
	// is the same type as lastRec.
	
	_proc( coalesce )( var lastRec:varLen_t );
	var
	    newPrev     :dword;
		prevRec     :dword;
		newSize     :dword;
		eaxSave     :dword;
		ecxSave     :dword;
		edxSave     :dword;
		esiSave     :dword;
		ediSave     :dword;
		
	_begin( coalesce );
	
	    mov( eax, eaxSave );
		mov( ecx, ecxSave );
		mov( edx, edxSave );
		mov( esi, esiSave );
		mov( edi, ediSave );
		
		// Save away pointers to lastRec's prev record (the one we will
		// be concatenating data to) and it's previous record (that we
		// will need to use when linking the new record into the system).
		
		mov( lastRec, edx );
		mov( (type varLen_t [edx]).prev, esi );
		mov( esi, prevRec );
		mov( (type tokenStmt_t [esi]).prev, eax );
		mov( eax, newPrev );
		
		// Compute the size of the new record as the sum of the
		// numBytes fields of the two parameters plus the size
		// of a varLen_t header and then allocate storage for
		// the new object.
		
		mov( (type varLen_t [edx]).numBytes, ecx );
		add( (type varLen_t [esi]).numBytes, ecx );
		mov( ecx, newSize );
		add( @size( varLen_t ), ecx );
		mem.alloc( ecx );
		
		// Copy all of prev to the new record (including header info):
		
		mov( (type varLen_t [esi]).numBytes, ecx );
		add( @size( varLen_t ), ecx );
		mov( eax, edi );
		cld();
		rep.movsb();
		
		// Set up the new length in the record:
		
		mov( newSize, ecx );
		mov( ecx, (type varLen_t [eax]).numBytes );
		
		// Copy the data from lastRec to the new record (where the
		// previous movsb left off):
		
		mov( lastRec, esi );
		mov( (type varLen_t [esi]).numBytes, ecx );
		add( @size( varLen_t ), esi );
		cld();
		rep.movsb();
		
		// Okay, link the new record into the list after newPrev:
		
		mov( newPrev, edx );
		mov( eax, (type tokenStmt_t [edx]).next );
		mov( edx, (type tokenStmt_t [eax]).prev );
		mov( NULL, (type tokenStmt_t [eax]).next );
		mov( eax, tknListTail );
		
		// Free the original two records, we don't need them anymore:

		mem.free( (type dword lastRec) );
		mem.free( prevRec );   
		
		
	    mov( eaxSave, eax );
		mov( ecxSave, ecx );
		mov( edxSave, edx );
		mov( esiSave, esi );
		mov( ediSave, edi );
		
	_end( coalesce );
	
	
	// Initialize an object-code record with all the common stuff.
	// Returns a pointer to the new record in EAX.
	
	_proc( initStmt )( recSize:dword );
	var
	_begin( initStmt );

		push( ecx );
        mem.alloc( recSize );
		mov( tknListTail, ecx );
		mov( ecx, (type tokenStmt_t [eax]).prev );
		mov( NULL, (type tokenStmt_t [eax]).next );
		mov( eax, (type tokenStmt_t [ecx]).next );
		mov( eax, tknListTail );
		pop( ecx );

	_end( initStmt );
	
	
	
	// parseSourceFileList-
	//
	//	Parses the comments at the end of a control-transfer instruction
	// to pick out the list of source files and line numbers that
	// appear there. The list takes the following form:
	//
	//	{ ; <sourcefile>, <line #>  { ; <sourcefile>, <line #> {...}}}
	//
	// The ptr argument points at a dword where the address of the first
	// record (sourceFileList_t) appears.  This procedure initializes
	// that pointer with the address of the list (may be NULL if no
	// list appears, though this would be unusual). List is terminated with
	// a NULL in the next field.
	
	_proc( parseSourceFileList )( var listPtr:dword );
	readonly
		filenameDelims	:cset := { #0..#$1f, ' ', ',', ';' };
		 
	_begin( parseSourceFileList );
	
		push( edx );
		skipSpaces2();
		if( (type char [ebx]) = ';' ) then
		
			push( ecx );
			push( esi );
			push( edi );
			
			add( 1, ebx );
			skipSpaces2();
			
			// Grab everything up to a comma (or whitespace).
			// Note that filenames are not the same as identifiers,
			// so we can't use grabID here.
			
			mov( ebx, ecx );	// Save ptr to start of filename.
			sub( 1, ebx );
			repeat
			
				add( 1, ebx );
				movzx( (type byte [ebx]), eax );
				bt( eax, filenameDelims );

			until( @c );
			mov( ebx, eax );
			sub( ecx, eax );
			if( eax > 512 ) then
			
				stderr.put( "Filename too long at line ", lineNumber, nl );
				raise( ex.ValueOutOfRange );
				
			endif;
			mem.alloc( @size( sourceFileList_t ));
			mov( listPtr, edx );
			mov( eax, [edx] );
			mov( eax, edx );
			str.a_bufToStr2( ecx, ebx );
			add( 1, ebx );		// skip delimiter character.
			mov( eax, (type sourceFileList_t [edx]).filename );
			if( (type char [ebx]) = ',' ) then
			
				add( 1, ebx );
				
			endif;
			skipSpaces2();
			mov( ebx, esi );
			conv.atou32( [esi] );
			mov( esi, ebx );
			mov( eax, (type sourceFileList_t [edx]).lineNumber );
			mov( NULL, (type sourceFileList_t [edx]).next );
			lea( eax, (type sourceFileList_t [edx]).next );	// For recursive call
			
			pop( edi );
			pop( esi );
			pop( ecx );
			
			// Recursively process the remainder of the list:
			
			parseSourceFileList( [eax] );
			
		else
			
			// NULL-terminate list at the end:
			
			mov( listPtr, edx );
			mov( NULL, (type dword [edx]) );

		endif;
		pop( edx );
				
		
	_end( parseSourceFileList );
	



	// Get the target address for a jump or call instruction:
	
	_proc( getDisp )( dispRecPtr:dword in eax );
	var
	_begin( getDisp );
	
		push( eax );
		skipSpaces();
		RelExpr();
		pop( ecx );
		mov( eax, (type disp_t [ecx]).offset );
		mov( edx, (type disp_t [ecx]).symbol );
		mov( 0, (type disp_t [ecx]).disp );
		lea( eax, (type disp_t [ecx]).line );
		parseSourceFileList( [eax] );
		skipToEoln();
		
	_end( getDisp );

	
	
	_proc( emitDummy );
	var
	_begin( emitDummy );
	
		push( eax );
		push( ecx );
		
		mem.alloc( @size( tokenStmt_t ));
		mov( tknListTail, ecx );
		mov( eax, (type tokenStmt_t [ecx]).next );
		mov( ecx, (type tokenStmt_t [eax]).prev );
		mov( NULL, (type tokenStmt_t [eax]).next );
		mov( dummy_tkn, (type tokenStmt_t [eax]).token );
		mov( eax, tknListTail );
		
		pop( ecx );
		pop( eax );
	
	_end( emitDummy );
	
	
_begin( lexer );

	mov( 0, byteIndex );
	mov( NULL, scannedSrc );
	str.init( idBuf, 1024 );
	mov( eax, identifier );
	mov( end_src, eax );
	mov( eax, end_source );
	
	// Create a new code list with at least one element (start_tkn):
	
	mem.alloc( @size( tokenStmt_t ));
	mov( NULL, (type tokenStmt_t [eax]).next );			// NULL-terminate list
	mov( NULL, (type tokenStmt_t [eax]).prev );
	mov( start_tkn, (type tokenStmt_t [eax]).token );	// Start of list
	mov( eax, codeListHead );
	mov( eax, codeListTail );
	mov( eax, tknListTail );
	mov( &codeListTail, lastTailPtr );
	mov( code_c, currentSection );
	
	
	// Create a new data list with at least one element (start_tkn):
	
	mem.alloc( @size( tokenStmt_t ));
	mov( NULL, (type tokenStmt_t [eax]).next );			// NULL-terminate list
	mov( NULL, (type tokenStmt_t [eax]).prev );
	mov( start_tkn, (type tokenStmt_t [eax]).token );	// Start of list
	mov( eax, dataListHead );
	mov( eax, dataListTail );
	
	// Create a new bss list with at least one element (start_tkn):
	
	mem.alloc( @size( tokenStmt_t ));
	mov( NULL, (type tokenStmt_t [eax]).next );			// NULL-terminate list
	mov( NULL, (type tokenStmt_t [eax]).prev );
	mov( start_tkn, (type tokenStmt_t [eax]).token );	// Start of list
	mov( eax, bssListHead );
	mov( eax, bssListTail );
	
	// Convert the source file to tokens:
	
	mov( start_source, ebx );	// Save in case there is an error
	forever
	
	
	
		// On each line, remove any leading spaces:
		
		mov( ebx, start_stmt );		
		dec( ebx );
		skipSpcs:
			inc( ebx );
			breakif( ebx >= end_source );
			mov( [ebx], al );
			cmp( al, ' ' );
			je skipSpcs;
			cmp( al, stdio.tab );
			je skipSpcs;
			cmp( al, stdio.cr );
			je skipSpcs;

		// Skip blank lines
		
		if( al = stdio.lf ) then
		
			inc( ebx );
			inc( lineNumber );
			continue;
			
		endif;
		
		// Skip comment lines
		
		if( al = ';' ) then
		
			skipToEoln();
			continue;
			
		endif;
		
		// Lexical analysis of the reserved words. Ugly brute-force algorithm
		// used here. Not pretty, but fast.
		
		if( al = '.') then
		
			add( 1, ebx );
			movzx( (type byte [ebx]), eax );
			switch( eax );
			
				case( 'a' )	// Align stmt
				
					mem.alloc( @size( alignStmt_t ));
					mov( tknListTail, ecx );
					mov( eax, (type tokenStmt_t [ecx]).next );
					mov( ecx, (type tokenStmt_t [eax]).prev );
					mov( NULL, (type tokenStmt_t [eax]).next );
					mov( align_tkn, (type tokenStmt_t [eax]).token );
					mov( eax, tknListTail );
					add( 1, ebx );
					EvalExpr();
					mov( tknListTail, ecx );
					mov( eax, (type alignStmt_t [ecx]).alignExpr );
					skipToEoln();



				case( 'b' )	// Byte data
				
					add( 1, ebx );						// skip ".b"
					parseBytes( 0 );
					
					// EAX comes back pointing at the buffer.
					// Adjust it so that it points at the
					// start of the byteStmt_t record:
					
					sub( @size( varLen_t ), eax );
					
					
					// If the previous record is also a .b statement,
					// then coalesce the two records:
					
					mov( (type tokenStmt_t [eax]).prev, ecx );
					assert( ecx <> NULL );
					if( (type tokenStmt_t [ecx]).token = bytes_tkn ) then
					
					    // If the previous entry in the list was a
						// .b statement, then coalesce the two
						// statements into a single statement.

						coalesce( [eax] );
											
					endif; 
					skipToEoln();
					
				

				case( 'c', 'y' ) // Code section
				
					// When switching to a new section, first emit
					// a "dummy" statement so that we're guaranteed
					// to have a non-code emitting statement at the end
					// of the section.
					
					emitDummy();
				
				    mov( code_c, currentSection );
					
				    // Must copy tknListTail to the appropriate variable:
					
					mov( lastTailPtr, eax );
					mov( tknListTail, ecx );
					mov( ecx, [eax] );
					
					// Must point lastTailPtr at codeListTail
					
					mov( &codeListTail, lastTailPtr );
					
					// Must set up tknListTail to be codeListTail.
					
					mov( codeListTail, eax );
					mov( eax,tknListTail );

				    // Create a code section record so we know where we've
					// left and reentered each code section.
					
					mem.alloc( @size( tokenStmt_t ));
					mov( tknListTail, ecx );
					mov( eax, (type tokenStmt_t [ecx]).next );
					mov( ecx, (type tokenStmt_t [eax]).prev );
					mov( NULL, (type tokenStmt_t [eax]).next );
					mov( code_tkn, (type tokenStmt_t [eax]).token );
					mov( eax, tknListTail );
                    skipToEoln();



				case( 'd' )	// Dword data
				
				
					add( 1, ebx );						// skip ".d"
					parseDwords( 0 );
					if( @nc ) then	// A byteStmt_t object.
					
					
						// If the previous record and the current
						// record are byteStmt_t statements,
						// then coalesce the two records:
							
						mov( (type tokenStmt_t [eax]).prev, ecx );
						assert( ecx <> NULL );
						if( (type tokenStmt_t [ecx]).token = bytes_tkn ) then
						
						    // If the previous entry in the list was a
							// byteStmt_t statement, then coalesce the two
							// statements into a single statement.
							
							coalesce( [eax] );
												
						endif;
						
					endif; 
					skipToEoln();
					
				



				case( 'e' )	// Equate
				
		
					// Handle equate label definitions
					
					add( 1, ebx );  // Skip over 'e'
					skipSpaces2();
					grabID( identifier );
					equatesTable.getNode( identifier );
					if( (type tableNode_t [eax]).Value = 0 ) then

						// Brand-new symbol. Get the second identifer
						// and save as the value field of the table entry:
						
						push( eax );	// Save pointer to table entry.
						skipSpaces2();
						if( (type char [ebx]) <> ',' ) then
						
							stderr.put
							(
								"Syntax error at line ",
								lineNumber, 
								", expected at ','" nl
							);
							raise( ex.InvalidArgument );
							
						endif;
						add( 1, ebx );	// Skip ',' char;
						skipSpaces2();
						grabID( identifier );
						str.a_cpy( identifier );
						pop( edx );
						mov( eax, (type tableNode_t [edx]).Value );
						
						
					else    // Symbol is already defined -- this is an error
					
						stderr.put
						( 
							"Equate attempted to redefine a symbol at line ",
							lineNumber,
							nl
						);
						raise( ex.InvalidArgument );
												
					endif;
			

					
				


				case( 'f' )	// end Function statement
				
				    add( 1, ebx );			// Skip over ".f"
				    skipSpaces2();
					grabID( identifier );
					symbolTable.getNode( identifier );
					if( (type tableNode_t [eax]).Value <> NULL ) then
					
					    // Emit an ENDFUNCTION record. Used by
						// ELF code emission to set the function's
						// length and change the type to FUNC.
						
						mov( eax, edx );    // Save ptr to symbol table node.			
						mem.alloc( @size( endFuncStmt_t ));
						mov( endfunc_tkn, (type endFuncStmt_t [eax]).token ); 			
						mov( edx, (type endFuncStmt_t [eax]).symTabEntry );
						mov( tknListTail, ecx );
						mov( ecx, (type endFuncStmt_t [eax]).prev );
						mov( NULL, (type endFuncStmt_t [eax]).next );
						mov( eax, (type tokenStmt_t [ecx]).next );
						mov( eax, tknListTail );
						
												
					else    // Symbol is not defined
					
					    stderr.put
						( 
						    "End Function symbol must be predefined "
							"at line ",
							lineNumber, 
							nl 
						);
						raise( ex.InvalidArgument );
						
					endif;
                    skipToEoln();


				case( 'l' )	// Lword data
				
					add( 1, ebx );						// skip ".w"
					parseLWords( 0 );
					
					// EAX comes back pointing at the buffer.
					// Adjust it so that it points at the
					// start of the byteStmt_t record:
					
					sub( @size( varLen_t ), eax );
					
					
					// If the previous record is also a byteStmt_t statement,
					// then coalesce the two records:
					
					mov( (type tokenStmt_t [eax]).prev, ecx );
					assert( ecx <> NULL );
					if( (type tokenStmt_t [ecx]).token = bytes_tkn ) then
					
					    // If the previous entry in the list was a
						// byteStmt_t statement, then coalesce the two
						// statements into a single statement.
						
						coalesce( [eax] );
											
					endif; 
					skipToEoln();
					
				


				case( 'p' )	// Public declaration
				
				    add( 1, ebx );
				    skipSpaces2();
					grabID( identifier );
					symbolTable.getNode( identifier );
					if( (type tableNode_t [eax]).Value = 0 ) then
					
					    // Brand-new symbol, so we need to allocate
						// storage for a symbol_t object and initialize
						// it appropriately:
						
						mov( eax, ecx );
						mem.alloc( @size( symbol_t ));
						mov( eax, (type tableNode_t [ecx]).Value );
						mov( isPublic_c, symEAX.flags );
						mov( 0, symEAX.offset );
						mov( NULL, symEAX.next );
						mov( (type tableNode_t [ecx]).id, ecx );
						mov( ecx, symEAX.id );

						// Must define the section later:
						
						mov( undefinedSection_c, symEAX.section );
						
					else    // Symbol is already defined
					
					    // Make sure it's not already extern:
						
					    mov( (type tableNode_t [eax]).Value, ecx );
						test
						( 
						    isExtern_c, 
							symECX.flags 
						);
						if( @nz ) then
						
						    stderr.put
							( 
							    "Public symbol cannot also be extern at line ",
								lineNumber, 
								nl 
							);
							raise( ex.InvalidArgument );
							
						endif;
						
						// Mark the symbol as public:
						
						or( isPublic_c, symECX.flags );
						
						// Note: leave the section number alone.
												
					endif;
                    skipToEoln();
					
					
					
					

				case( 'q' )	// Qword data 
				
					add( 1, ebx );						// skip ".w"
					parseQWords( 0 );
					
					// EAX comes back pointing at the buffer.
					// Adjust it so that it points at the
					// start of the byteStmt_t record:
					
					sub( @size( varLen_t ), eax );
					
					
					// If the previous record is also a byteStmt_t statement,
					// then coalesce the two records:
					
					mov( (type tokenStmt_t [eax]).prev, ecx );
					assert( ecx <> NULL );
					if( (type tokenStmt_t [ecx]).token = bytes_tkn ) then
					
					    // If the previous entry in the list was a
						// byteStmt_t statement, then coalesce the two
						// statements into a single statement.
						
						coalesce( [eax] );
											
					endif; 
					skipToEoln();
					
				


				case( 'r' )	// Reserve storage
				
					mem.alloc( @size( reserveStmt_t ));
					mov( tknListTail, ecx );
					mov( eax, (type tokenStmt_t [ecx]).next );
					mov( ecx, (type tokenStmt_t [eax]).prev );
					mov( NULL, (type tokenStmt_t [eax]).next );
					mov( reserve_tkn, (type tokenStmt_t [eax]).token );
					mov( eax, tknListTail );
					add( 1, ebx );
					EvalExpr();
					mov( tknListTail, ecx );
					mov( eax, (type reserveStmt_t [ecx]).sizeExpr );
					skipToEoln();



				case( 's' )	// Static/Data section
				
				
					// When switching to a new section, first emit
					// a "dummy" statement so that we're guaranteed
					// to have a non-code emitting statement at the end
					// of the section.
										
					emitDummy();
				
				
				    mov( data_c, currentSection );
				
				    // Must copy tknListTail to the appropriate variable:
					
					mov( lastTailPtr, eax );
					mov( tknListTail, ecx );
					mov( ecx, [eax] );
					
					// Must point lastTailPtr at dataListTail
					
					mov( &dataListTail, lastTailPtr );
					
					// Must set up tknListTail to be dataListTail.
					
					mov( dataListTail, eax );
					mov( eax,tknListTail );
				
				    // Create a data section record in the data section
					// so we can determine which definitions are all in
					// the same section or are in different sections.
					
					mem.alloc( @size( tokenStmt_t ));
					mov( tknListTail, ecx );
					mov( eax, (type tokenStmt_t [ecx]).next );
					mov( ecx, (type tokenStmt_t [eax]).prev );
					mov( NULL, (type tokenStmt_t [eax]).next );
					mov( data_tkn, (type tokenStmt_t [eax]).token );
					mov( eax, tknListTail );
                    skipToEoln();




				case( 't' )	// Tbyte data
				
					add( 1, ebx );						// skip ".w"
					parseTBytes( 0 );
					
					// EAX comes back pointing at the buffer.
					// Adjust it so that it points at the
					// start of the byteStmt_t record:
					
					sub( @size( varLen_t ), eax );
					
					
					// If the previous record is also a byteStmt_t statement,
					// then coalesce the two records:
					
					mov( (type tokenStmt_t [eax]).prev, ecx );
					assert( ecx <> NULL );
					if( (type tokenStmt_t [ecx]).token = bytes_tkn ) then
					
					    // If the previous entry in the list was a
						// byteStmt_t statement, then coalesce the two
						// statements into a single statement.
						
						coalesce( [eax] );
											
					endif; 
					skipToEoln();
					
				


				case( 'u' )	// Duplicated data
				
					// Note: actual instructions are .ub, .uw, and .ud
					// so we must check the character following .u:
					
					add( 1, ebx );
					mov( (type byte [ebx]), al );
					if( al = 'b' ) then
					
						mem.alloc( @size( dupStmt_t ));
						mov( tknListTail, ecx );
						mov( eax, (type tokenStmt_t [ecx]).next );
						mov( ecx, (type tokenStmt_t [eax]).prev );
						mov( NULL, (type tokenStmt_t [eax]).next );
						mov( dupByte_tkn, (type tokenStmt_t [eax]).token );
						mov( eax, tknListTail );
						add( 1, ebx );
						EvalExpr();
						mov( tknListTail, ecx );
						mov( eax, (type dupStmt_t [ecx]).count );
						skipSpaces2();
						if( (type char [ebx]) <> ',' ) then
						
							stderr.put
							( 
								".ub expected a ',' -- Syntax error at line",
								lineNumber, 
								nl 
							);
							raise( ex.InvalidArgument );
							
						endif;
						

						add( 1, ebx );
						EvalExpr();
						mov( tknListTail, ecx );
						mov( eax, (type dupStmt_t [ecx]).data );
						mov( 1, (type dupStmt_t [ecx]).size );

					elseif( al = 'w' ) then
					
						mem.alloc( @size( dupStmt_t ));
						mov( tknListTail, ecx );
						mov( eax, (type tokenStmt_t [ecx]).next );
						mov( ecx, (type tokenStmt_t [eax]).prev );
						mov( NULL, (type tokenStmt_t [eax]).next );
						mov( dupWord_tkn, (type tokenStmt_t [eax]).token );
						mov( eax, tknListTail );
						add( 1, ebx );
						EvalExpr();
						mov( tknListTail, ecx );
						mov( eax, (type dupStmt_t [ecx]).count );
						skipSpaces2();
						if( (type char [ebx]) <> ',' ) then
						
							stderr.put
							( 
								".uw expected a ',' -- Syntax error at line ",
								lineNumber, 
								nl 
							);
							raise( ex.InvalidArgument );
							
						endif;
						

						add( 1, ebx );
						EvalExpr();
						mov( tknListTail, ecx );
						mov( eax, (type dupStmt_t [ecx]).data );
						mov( 2, (type dupStmt_t [ecx]).size );

					elseif( al = 'd' ) then
					
						mem.alloc( @size( dupStmt_t ));
						mov( tknListTail, ecx );
						mov( eax, (type tokenStmt_t [ecx]).next );
						mov( ecx, (type tokenStmt_t [eax]).prev );
						mov( NULL, (type tokenStmt_t [eax]).next );
						mov( dupDword_tkn, (type tokenStmt_t [eax]).token );
						mov( eax, tknListTail );
						add( 1, ebx );
						EvalExpr();
						mov( tknListTail, ecx );
						mov( eax, (type dupStmt_t [ecx]).count );
						skipSpaces2();
						if( (type char [ebx]) <> ',' ) then
						
							stderr.put
							( 
								".ud expected a ',' -- Syntax error at line ",
								lineNumber,
								 nl 
							);
							raise( ex.InvalidArgument );
							
						endif;

						add( 1, ebx );
						EvalExpr();
						mov( tknListTail, ecx );
						mov( eax, (type dupStmt_t [ecx]).data );
						mov( 4, (type dupStmt_t [ecx]).size );

					else
					
						unknownStmt();
											
					endif;
					skipToEoln();
					
					
					
					

				case( 'v' )	// BSS section
				
				
					// When switching to a new section, first emit
					// a "dummy" statement so that we're guaranteed
					// to have a non-code emitting statement at the end
					// of the section.
					
					emitDummy();
				
				    mov( bss_c, currentSection );
					
				    // Must copy tknListTail to the appropriate variable:
					
					mov( lastTailPtr, eax );
					mov( tknListTail, ecx );
					mov( ecx, [eax] );
					
					// Must point lastTailPtr at bssListTail
					
					mov( &bssListTail, lastTailPtr );
					
					// Must set up tknListTail to be codeListTail.
					
					mov( bssListTail, eax );
					mov( eax,tknListTail );
					
					
				    // Create a bss section record in the BSS section
					// we just created so that we know where each block
					// of the BSS declarations is at.
					
					mem.alloc( @size( tokenStmt_t ));
					mov( tknListTail, ecx );
					mov( eax, (type tokenStmt_t [ecx]).next );
					mov( ecx, (type tokenStmt_t [eax]).prev );
					mov( NULL, (type tokenStmt_t [eax]).next );
					mov( bss_tkn, (type tokenStmt_t [eax]).token );
					mov( eax, tknListTail );
                    skipToEoln();




				case( 'w' )	// Word data
				
					add( 1, ebx );						// skip ".w"
					parseWords( 0 );
					
					// EAX comes back pointing at the buffer.
					// Adjust it so that it points at the
					// start of the byteStmt_t record:
					
					sub( @size( varLen_t ), eax );
					
					
					// If the previous record is also a byteStmt_t statement,
					// then coalesce the two records:
					
					mov( (type tokenStmt_t [eax]).prev, ecx );
					assert( ecx <> NULL );
					if( (type tokenStmt_t [ecx]).token = bytes_tkn ) then
					
					    // If the previous entry in the list was a
						// byteStmt_t statement, then coalesce the two
						// statements into a single statement.
						
						coalesce( [eax] );
											
					endif; 
					skipToEoln();
					
				


				case( 'x' )	// External declaration
				
				    add( 1, ebx );
				    skipSpaces2();
					grabID( identifier );
					symbolTable.getNode( identifier );
					if( (type tableNode_t [eax]).Value = 0 ) then
					
					    // Brand-new symbol, so we need to allocate
						// storage for a symbol_t object and initialize
						// it appropriately:
						
						mov( eax, ecx );
						mem.alloc( @size( symbol_t ));
						mov( eax, (type tableNode_t [ecx]).Value );
						mov
						( 
							isExtern_c, 
							(type symbol_t [eax]).flags 
						);
						mov( 0, symEAX.offset );
						mov( NULL, symEAX.next );
						mov( (type tableNode_t [ecx]).id, ecx );
						mov( ecx, symEAX.id );
						mov( currentSection, cl );
						mov( cl, symEAX.section );
						
						
					else    // Symbol is already defined
					
					    mov( (type tableNode_t [eax]).Value, ecx );
						test
						( 
						    isExtern_c, 
							(type symbol_t [ecx]).flags 
						);
						if( @nz ) then
						
							mov( (type tableNode_t [eax]).id, eax );
						    stderr.put
							( 
							    "External symbol '",
								(type string eax), 
								"' is already defined. "
								"Error in HLABE code at line ", 
								lineNumber,
								nl 
							);
							raise( ex.InvalidArgument );
							
						else
						
							test( isDefined_c,  (type symbol_t [ecx]).flags );
							if( @nz ) then
							
								or( isPublic_c, (type symbol_t [ecx]).flags );
								
							else
							
								or( isExtern_c, (type symbol_t [ecx]).flags );
							
							endif;
							
						endif;
						mov( ecx, eax );
						
						// Set the section to the current section number
						
						mov( currentSection, cl );
						mov( cl, symEAX.section );
						
						
					endif;
                    skipToEoln();


				case( 'z' )	// End of source file.
				
                    skipToEoln();

				default
				
					unknownStmt();
				
			endswitch;
		
			
		elseif( al = ':' ) then
		
			// Handle label definitions
			
			add( 1, ebx );  // Skip over ':'
			skipSpaces2();
			grabID( identifier );
			mem.alloc( @size( labelStmt_t ));
			mov( eax, edx );
			symbolTable.getNode( identifier );
			
			if( (type tableNode_t [eax]).Value = 0 ) then
			
				// Brand-new symbol, so we need to allocate
				// storage for a symbol_t object and initialize
				// it appropriately:
				
				mov( eax, ecx );
				mem.alloc( @size( symbol_t ));
				mov( eax, (type tableNode_t [ecx]).Value );
				mov( isDefined_c, symEAX.flags );
				mov( 0, symEAX.offset );
				mov( NULL, symEAX.next );
				mov( (type tableNode_t [ecx]).id, edx );
				mov( edx, symEAX.id );
				mov( currentSection, dl );
				mov( dl, symEAX.section );
				mov( false, symEAX.isFunc ); 			
				mov( 0, symEAX.size ); 			
				
				mov( ecx, eax );
				
			else    // Symbol is already defined
			
				mov( (type tableNode_t [eax]).Value, ecx );
				test
				( 
					isDefined_c, 
					(type symbol_t [ecx]).flags 
				);
				if( @nz ) then
				
					stderr.put
					( 
						"Symbol ",
						(type tableNode_t [eax]).id,
						" is already defined. Error at line ", 
						lineNumber,
						nl 
					);
					raise( ex.InvalidArgument );
					
				endif;
				
				// If it's externally declared, we'll allow that
				// and eliminate the external declaration and
				// make it public:
				
				test( isExtern_c, (type symbol_t [ecx]).flags );
				if( @nz ) then
				
					and( isExtern_c ^ $FF, (type symbol_t [ecx]).flags );
					or( isPublic_c, (type symbol_t [ecx]).flags ); 
				
				endif;
				or( isDefined_c, (type symbol_t [ecx]).flags );
				
				// Set the section to the current section number
				
				mov( currentSection, dl );
				mov( dl, (type symbol_t [ecx]).section );
				mov( false, (type symbol_t [ecx]).isFunc ); 			
				mov( 0, (type symbol_t [ecx]).size ); 			
						
				
				
			endif;
			
            // Emit a label statement to the current output stream:
			
			mov( eax, edx );    // Save ptr to symbol table node.			
            mem.alloc( @size( labelStmt_t ));
			mov( label_tkn, (type labelStmt_t [eax]).token ); 			
			mov( edx, (type labelStmt_t [eax]).symTabEntry );
			mov( tknListTail, ecx );
			mov( ecx, (type labelStmt_t [eax]).prev );
			mov( NULL, (type labelStmt_t [eax]).next );
			mov( eax, (type tokenStmt_t [ecx]).next );
			mov( eax, tknListTail );
			
            skipToEoln();

		else
		
			// call, jmp, ja, jae, jb, jbe, jc, je, jg, jge, jl, jle, jna, jnae, 
			// jnb, jnbe, jnc, jne, jng, jnge, jnl, jnle, jno, jnp, jns, 
			// jnz, jo, jp, jpe, jpo, js, jz, jcxz, or jecxz.
		
			lea( ecx, [ebx+10] );		// must have at least 10 chars left
			if( ecx > end_source ) then	// e.g., "ja l ;f,1<nl>"
			
				unknownStmt();
			
			elseif( al = 'j' ) then 	// need further decoding
			
				// Get the next four characters into EAX
				
				mov( [ebx+1], eax );
				mov( eax, edx );
				bswap( edx );
				
				// Check for the 2-char mnemonics:
				// ja, jb, jc, je, jl, jo, jp, js, and jz
				
				if( ah = ' ' ) then
				
					cmp( al, 'a' );
					je ja_instr;
					cmp( al, 'b' );
					je jb_instr;
					cmp( al, 'c' );
					je jc_instr;
					cmp( al, 'e' );
					je je_instr;
					cmp( al, 'g' );
					je jg_instr;
					cmp( al, 'l' );
					je jl_instr;
					cmp( al, 'o' );
					je jo_instr;
					cmp( al, 'p' );
					je jp_instr;
					cmp( al, 's' );
					je js_instr;
					cmp( al, 'z' );
					je jz_instr;
					
						unknownStmt();
						jmp Done;
					
					jnbe_instr:
						add( 2, ebx );	// Skip part of jnbe instr.
					ja_instr:
						add( 2, ebx );	// Skip "ja/jnbe"
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $77, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $870f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
						
					
					jnae_instr:
						add( 2, ebx );	// Skip part of jnae instr.
					jb_instr:
					jc_instr:
						add( 2, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $72, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $820f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					je_instr:
					jz_instr:
						add( 2, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $74, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $840f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					jnle_instr:
						add( 2, ebx );	// Skip part of jnle instr.
					jg_instr:
						add( 2, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $7f, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $8f0f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					
					jnge_instr:
						add( 2, ebx );	// Skip part of jnge instr.
					jl_instr:
						add( 2, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $7c, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $8c0f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					jo_instr:
						add( 2, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $70, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $800f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					jpe_instr:
						add( 1, ebx );	// Skip part of jpe instruction
					jp_instr:
						add( 2, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $7a, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $8a0f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					js_instr:
						add( 2, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $78, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $880f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
						
						
						
						
				// Check for the 3-char mnemonics:
				// jmp, jae, jbe, jge, jle, jna, jnb, jnc, jne, jng, jnl, jno,
				// jnp, jns, jnz, jpe, and jpo.
				
				elseif( dh = ' ' ) then
				
					cmp( ax, hla.asWord( "mp" ));
					je jmp_instr;
					cmp( ax, hla.asWord( "ae" ));
					je jae_instr;
					cmp( ax, hla.asWord( "be" ));
					je jbe_instr;
					cmp( ax, hla.asWord( "ge" ));
					je jge_instr;
					cmp( ax, hla.asWord( "le" ));
					je jle_instr;
					cmp( ax, hla.asWord( "na" ));
					je jna_instr;
					cmp( ax, hla.asWord( "nb" ));
					je jnb_instr;
					cmp( ax, hla.asWord( "nc" ));
					je jnc_instr;
					cmp( ax, hla.asWord( "ne" ));
					je jne_instr;
					cmp( ax, hla.asWord( "ng" ));
					je jng_instr;
					cmp( ax, hla.asWord( "nl" ));
					je jnl_instr;
					cmp( ax, hla.asWord( "no" ));
					je jno_instr;
					cmp( ax, hla.asWord( "np" ));
					je jnp_instr;
					cmp( ax, hla.asWord( "ns" ));
					je jns_instr;
					cmp( ax, hla.asWord( "nz" ));
					je jnz_instr;
					cmp( ax, hla.asWord( "pe" ));
					je jpe_instr;
					cmp( ax, hla.asWord( "po" ));
					je jpo_instr;
					
						unknownStmt();
						jmp Done;
					
					jmp_instr:
						initStmt( @size( jmp_Stmt_t ));
						mov( jmp_tkn, (type jmp_Stmt_t [eax]).token );
						mov( $eb, (type jmp_Stmt_t [eax]).opcode1 );
						mov( $e9, (type jmp_Stmt_t [eax]).opcode2 );
						mov( 1, (type jmp_Stmt_t [eax]).curOfsSize );
						add( 3, ebx );	// Skip "jmp"
						getDisp( eax );
						jmp Done;
					
					jnc_instr:
					jnb_instr:	
					jae_instr:
						add( 3, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $73, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $830f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					jna_instr:
					jbe_instr:
						add( 3, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $76, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $860f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					
					jnl_instr:
					jge_instr:
						add( 3, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $7d, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $8d0f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					
					jng_instr:
					jle_instr:
						add( 3, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $7e, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $8e0f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					
					jne_instr:
					jnz_instr:
						add( 3, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $75, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $850f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					
					jno_instr:
						add( 3, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $71, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $810f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					
					jnp_instr:
					jpo_instr:
						add( 3, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $7b, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $8b0f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;
					
					
					jns_instr:
						add( 3, ebx );	// Skip instruction
						initStmt( @size( rel_1_4_Stmt_t ));
						mov( rel1_4_tkn, (type rel_1_4_Stmt_t [eax]).token );
						mov( $79, (type rel_1_4_Stmt_t [eax]).opcode1 );
						mov( $890f, (type rel_1_4_Stmt_t [eax]).opcode2 );
						mov( 1, (type rel_1_4_Stmt_t [eax]).curOfsSize );
						getDisp( eax );
						jmp Done;


					
				// Check for the 4-character mnemonics here:
				//
				// jnae, jnbe, jnge, jnle, and jcxz
				
				elseif( dl = ' ' ) then
				
					cmp( eax, hla.asDword( "nae " ));
					je jnae_instr;
					cmp( eax, hla.asDword( "nbe " ));
					je jnbe_instr;
					cmp( eax, hla.asDword( "nge " ));
					je jnge_instr;
					cmp( eax, hla.asDword( "nle " ));
					je jnle_instr;
					cmp( eax, hla.asDword( "cxz " ));
					je jcxz_instr;
					
						unknownStmt();
						jmp Done;
					
					jcxz_instr:
						add( 4, ebx );	// Skip instruction
						initStmt( @size( rel_2_Stmt_t ));
						mov( rel2_tkn, (type rel_2_Stmt_t [eax]).token );
						mov( $e367, (type rel_2_Stmt_t [eax]).opcode );
						getDisp( eax );
						jmp Done;

					
				elseif
				( 
						eax = hla.asDword( "ecxz" ) 
					&&	(type byte [ebx+5]) = ' ' 
				) then
				
					add( 5, ebx );	// Skip instruction
					initStmt( @size( rel_1_Stmt_t ));
					mov( rel1_tkn, (type rel_1_Stmt_t [eax]).token );
					mov( $e3, (type rel_1_Stmt_t [eax]).opcode );
					getDisp( eax );
					jmp Done;

					
				else

					unknownStmt();
					
				endif;
				
			// LOOP, LOOPNE/LOOPNZ, and LOOPE/LOOPZ instructions:
			
			elseif
			( 
					al = 'l'
				&&	returns( {lea( ecx, [ebx+7] );}, "ecx<end_source" )
				&&	bbx[1] = 'o' 
				&&	bbx[2] = 'o' 
				&&	bbx[3] = 'p'
				&&	(
							returns( {mov( bbx[4], al);}, "al = ' '" )
						||	(
									(al = 'e' && bbx[5] = ' ')
								||	(al = 'z' && bbx[5] = ' ')
							)
						||	(
									returns( {mov( bbx[5], ah);}, "al='n'" )
								&&	(
											(ah = 'e' && bbx[6] = ' ')
										||	(ah = 'z' && bbx[6] = ' ')
									)
							)
					)
			) then
			
				// At this point, AL = ' ' if loop,
				// AL = 'e' for loope
				// AL = 'z' for loopz
				// AL = 'n' for loopne/loopnz
				// AH = 'e' for loopne
				// AH = 'z' for loopnz
				
				if( al = ' ' ) then // loop
				
					add( 4, ebx );	// Skip instruction
					initStmt( @size( rel_1_Stmt_t ));
					mov( rel1_tkn, (type rel_1_Stmt_t [eax]).token );
					mov( $e2, (type rel_1_Stmt_t [eax]).opcode );
					getDisp( eax );
					jmp Done;
					
						
				elseif( al = 'e' || al = 'z' ) then 			// loope/loopz
				
					add( 5, ebx );	// Skip instruction
					initStmt( @size( rel_1_Stmt_t ));
					mov( rel1_tkn, (type rel_1_Stmt_t [eax]).token );
					mov( $e1, (type rel_1_Stmt_t [eax]).opcode );
					getDisp( eax );
					jmp Done;
					
						
				elseif( al = 'n' && (ah='e' || ah = 'z')) then	// loopne/loopnz
				
					add( 6, ebx );	// Skip instruction
					initStmt( @size( rel_1_Stmt_t ));
					mov( rel1_tkn, (type rel_1_Stmt_t [eax]).token );
					mov( $e0, (type rel_1_Stmt_t [eax]).opcode );
					getDisp( eax );
					jmp Done;
					
						
				else
				
					// error
					
					skipToEoln();
					
				endif;
				



			// CALL instruction:
			
			elseif
			(		al = 'c'
				&&	returns( {add(5, ebx );}, "ebx<end_source" )
				&&	(type byte [ebx-4]) = 'a' 
				&&	(type byte [ebx-3]) = 'l' 
				&&	(type byte [ebx-2]) = 'l' 
				&&	(type byte [ebx-1]) = ' ' 
			) then
			
				initStmt( @size( rel_4_Stmt_t ));
				mov( rel4_tkn, (type rel_4_Stmt_t [eax]).token );
				mov( $e8, (type rel_4_Stmt_t [eax]).opcode );
				getDisp( eax );
						
				
			else	// Unexpected statement
			
				unknownStmt();
					
			endif;
			
			Done:
			
		endif;
	
	endfor;
	emitDummy();
	
	
_end( lexer );






///////////////////////////////////////////////////////////////////////////////
//
// addCOFFsym-
//
//	Adds a symbol to the COFF symbol table.
//
//	Returns:
//		EAX-	Zero-based index into COFFsyms table where the symbol was placed.

_proc( addCOFFsym )
(
		theName				:string;
		theValue			:dword;
		sectionNumber		:word;
		theType				:word;
		storageClass		:byte;
		numberOfAuxSymbols	:byte;
	var	auxSymbols			:w.IMAGE_SYMBOL
);
var
_begin( addCOFFsym );

	push( ebx );
	push( ecx );
	push( edx );
	push( esi );
	push( edi );
	cld();
	
	
	// See if we have room in the symbol table for the new symbol
	// (and any aux symbols it requires):
	
	push( numCOFFsyms );	// Save for return result.
	intmul( @size( w.IMAGE_SYMBOL ), numCOFFsyms, ebx );
	
	movzx( numberOfAuxSymbols, eax );
	add( 1, eax );
	intmul( @size( w.IMAGE_SYMBOL ), eax );
	add( ebx, eax );
	if( eax > coffSymSize ) then 
	
		// We've exceeded the size of the currently allocated
		// COFF symbol table, so make a bigger one:
		
		shl( 1, coffSymSize );		// Double the size
		mem.realloc( COFFsyms, coffSymSize );
		mov( eax, COFFsyms );
		
	endif;
	
	// Compute pointer to next free symbol slot:
	
	add( COFFsyms, ebx );
	
	// Copy the name to the symbol table entry (or to the strings table
	// if the name is longer than 8 chars):
	 
	mov( theName, esi );
	str.length( esi );
	mov( eax, ecx );
	if( eax <= 8 ) then
	
		// We can store the filename directly in the symbol table entry:
		
		mov( 0, coffSymEBX.N.LongName[0] );
		mov( 0, coffSymEBX.N.LongName[4] );
		lea( edi, coffSymEBX.N.ShortName );
		cld();
		rep.movsb(); 
	
	else
	
		// We have to create a strings table entry and copy the string there:
		
		mov( strTblOffset, edx );
		lea( eax, [edx+ecx+1] );	// New "end of string table" value.
		mov( eax, strTblOffset );
		
		// See if there is room for the new string in the table.
		
		if( eax > strTblSize ) then
		
			// Must allocate more storage for the strings table:
			
			push( eax );
			shl( 1, strTblSize );	// Double existing size
			mem.realloc( stringTable, strTblSize );
			mov( eax, stringTable );
			pop( eax );
			
		endif;
			
		mov( edx, edi );
		add( stringTable, edi );
		cld();
		rep.movsb();
		
		// Must zero-terminate the name in the strings table:
		
		mov( 0, (type byte [edi]));
				
		// Must have a zero in the first four bytes of the short name:
		
		mov( 0, coffSymEBX.N.LongName[0] );
		
		// Must have the offset into the string table in the second four
		// bytes of the short name:
		
		mov( edx, coffSymEBX.N.LongName[4] );
	
	endif;
	
	// Okay, copy the remaining fields to the symbol table entry:
	 
	mov( theValue, eax );
	mov( eax, coffSymEBX.Value );
	mov( sectionNumber, ax );
	mov( ax, coffSymEBX.SectionNumber );
	mov( theType, ax );
	mov( ax, coffSymEBX.Type1 );
	mov( storageClass, al );
	mov( al, coffSymEBX.StorageClass );
	movzx( numberOfAuxSymbols, eax );
	mov( al, coffSymEBX.NumberOfAuxSymbols );
	
	// If there were any aux symbol records, copy them to
	// the symbol table:
	
	if( al <> 0 ) then
	
		mov( auxSymbols, esi );
		intmul( @size( w.IMAGE_SYMBOL ), numCOFFsyms, edi );
		add( @size( w.IMAGE_SYMBOL ), edi ); 
		add( COFFsyms, edi );
		intmul( @size( w.IMAGE_SYMBOL ), eax, ecx );
		cld();
		rep.movsb();
		
	endif;
	
	// Adjust the number of symbols in the table:
			 	    
	movzx( numberOfAuxSymbols, eax );
	add( 1, eax );
	add( eax, numCOFFsyms );
	
	pop( eax );	// Retrieve symbol index for use as return result.
	
	pop( edi );
	pop( esi );
	pop( edx );
	pop( ecx );
	pop( ebx );

	
_end( addCOFFsym );




///////////////////////////////////////////////////////////////////////////////
//
// addELFsym-
//
//	Adds a symbol to the ELF symbol table.
//
//	Returns:
//		EAX-	Zero-based index into ELFsyms table where the symbol was placed.

_proc( addELFsym )
(
		theName				:string;
		theValue			:Elf32_Addr;
		theSize				:Elf32_Word;
		bindingAndType		:byte;
		sectionNumber		:word;
		visibility			:byte
);
var
_begin( addELFsym );

	push( ebx );
	push( ecx );
	push( edx );
	push( esi );
	push( edi );
	cld();
	
	
	// See if we have room in the symbol table for the new symbol
	// (and any aux symbols it requires):
	
	intmul( @size( Elf32_Sym ), numELFsyms, ebx );
	lea( eax, [ebx+@size(Elf32_Sym)] );
	if( eax > elfSymSize ) then 
			
		// We've exceeded the size of the currently allocated
		// ELF symbol table, so make a bigger one:
		
		shl( 1, elfSymSize );		// Double the size
		mem.realloc( ELFsyms, elfSymSize );
		mov( eax, ELFsyms );
		
	endif;
	
	// Compute pointer to next free symbol slot:
	
	add( ELFsyms, ebx );
	
	// We have to create a strings table entry and copy the name there.
	// Note that NULL is passed as the name for .text, .data, and .bss
	// section names.
	 
	xor( edx, edx );		// Use NULL as the symbol offset if theName=NULL.
	mov( theName, esi );
	if( esi <> NULL ) then
	
		str.length( esi );
		mov( eax, ecx );
		mov( strTblOffset, edx );
		lea( eax, [edx+ecx+1] );	// New "end of string table" value.
		mov( eax, strTblOffset );
		
		// See if there is room for the new string in the table.
		
		if( eax > strTblSize ) then
		
			// Must allocate more storage for the strings table:
			
			shl( 1, strTblSize );	// Double existing size
			mem.realloc( stringTable, strTblSize );
			mov( eax, stringTable );
			
		endif;
			
		mov( edx, edi );
		add( stringTable, edi );
		cld();
		rep.movsb();

		// Must zero-terminate the name in the strings table:
		
		mov( 0, (type byte [edi]));
			
		
	endif;
	
	// Must have the offset into the string table in the symbol table entry:
	
	mov( edx, elfSymEBX.st_name );
	
	
	// Okay, copy the remaining fields to the symbol table entry:
	 
	mov( theValue, eax );
	mov( eax, elfSymEBX.st_value );
	mov( theSize, eax );
	mov( eax, elfSymEBX.st_size );
	mov( bindingAndType, al );
	mov( al, elfSymEBX.st_info );
	mov( visibility, al );
	and( %11, al );
	mov( al, elfSymEBX.st_other );
	mov( sectionNumber, ax );
	mov( ax, elfSymEBX.st_shndx );
	
	
	
	pop( edi );
	pop( esi );
	pop( edx );
	pop( ecx );
	pop( ebx );

	
_end( addELFsym );















///////////////////////////////////////////////////////////////////////////////
//
// addMachoSym-
//
//	Adds a symbol to the ELF symbol table.

_proc( addMachoSym )
(
		theName				:string;
		theValue			:dword;
		theType				:byte;
		sectionNumber		:byte
);
var
_begin( addMachoSym );

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	push( esi );
	push( edi );
	
	
	// See if we have room in the symbol table for the new symbol:
	
	intmul( @size( nlist ), numMachoSyms, ebx );
	lea( eax, [ebx+@size(nlist)] );
	if( eax > MachoSymSize ) then 
			
		// We've exceeded the size of the currently allocated
		// Mach-O symbol table, so make a bigger one:
		
		shl( 1, MachoSymSize );		// Double the size
		mem.realloc( MachoSyms, MachoSymSize );
		mov( eax, MachoSyms );
		
	endif;
	
	// Compute pointer to next free symbol slot:
	
	add( MachoSyms, ebx );
	
	// We have to create a strings table entry and copy the name there.
	 
	mov( theName, esi );
	assert( esi <> NULL );
	
	str.length( esi );
	mov( eax, ecx );
	mov( strTblOffset, edx );
	lea( eax, [edx+ecx+1] );	// New "end of string table" value.
	mov( eax, strTblOffset );
	
	// See if there is room for the new string in the table.
	
	if( eax > strTblSize ) then
	
		// Must allocate more storage for the strings table:
		
		shl( 1, strTblSize );	// Double existing size
		mem.realloc( stringTable, strTblSize );
		mov( eax, stringTable );
		
	endif;
		
	mov( edx, edi );
	add( stringTable, edi );
	cld();
	rep.movsb();

	// Must zero-terminate the name in the strings table:
	
	mov( 0, (type byte [edi]));
			
		
	
	// Must have the offset into the string table in the symbol table entry:
	
	mov( edx, MachoSymEBX.n_strx );
	
	// Okay, copy the remaining fields to the symbol table entry:
	 
	mov( theValue, eax );
	mov( eax, MachoSymEBX.n_value );
	mov( theType, al );
	mov( al, MachoSymEBX.n_type );
	mov( sectionNumber, al );
	mov( al, MachoSymEBX.n_sect );
	mov( 0, MachoSymEBX.n_desc );
	
	
	
	pop( edi );
	pop( esi );
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );
	
_end( addMachoSym );











///////////////////////////////////////////////////////////////////////////////
//
// buildRaw-
//
//	Fills in the raw data for a section and builds the relocation list.
//
//	On Entry:
//
//		list-
//			Points at the data or code list
//
//		relocations-
//			Points at the (already allocated) block of memory that
//			will hold all the relocations.
//
//		numRelocs-
//			Total number of relocations for this list.  If this
//			value is $FFFF or greater, then the first relocation
//			record is already initialized with the total number
//			of relocations (32 bits).
//
//		rawCode-
//			Pointer to (already allocated) block of memory that
//			will receive the raw code for this section.
//
//		curSection-
//			code_c or data_c (buildRaw is not called for BSS sections). 

_proc( buildRaw )
(
	list			:tokenList_t;
	sectionStart	:dword;
	relocations		:pRelocations;
	numRelocs		:uns32;
	rawInfo			:pByte;
	curSection		:section_t;
	objType			:obj_t 
);	@use eax;
var;
_begin( buildRaw );

	push( ebx );
	push( ecx );
	push( edx );
	push( edi );
	push( esi );

	mov( relocations, esi );
	if( objType = pecoff_c ) then
	
		// If we have 65,535 or more relocations, then the
		// first relocation record contains the actual number
		// of relocations.
		
		mov( numRelocs, eax );
		if( eax >= $ffff ) then
		
			mov( eax, relocESI.RelocCount );
			add( @size( w.IMAGE_RELOCATION ), esi );
			
		endif;
		
	endif;
	
	// Convert the list to a raw data section:
	
	mov( list, ebx );
	mov( rawInfo, edi );
	while( ebx <> NULL ) do
	
		// Process the particular record:
		
		movzx( tknEBX.token, eax );
		switch( eax )
		
			case
			( 
				start_tkn,
				public_tkn,
				extern_tkn,
				label_tkn,
				endfunc_tkn,
				dummy_tkn
			)
				// Ignore these tokens.
							  
			case( align_tkn )
			
				
				// Align ECX (current offset) to the
				// value specified by this record. Note that
				// the alignment expression is always a power
				// of two.
				
				mov( tknEBX.instrOffset, ecx );
				mov( ecx, edx );
				mov( (type alignStmt_t [ebx]).alignExpr, eax );
				
				// Because the alignment expression is always a power
				// of two, subtracting one from it (and NOTing it) gives
				// is a mask we can use for rounding.
				
				sub( 1, eax );
				add( eax, ecx );	// Round up to must below the next pwr of 2.
				not( eax );			// Create the mask
				and( eax, ecx );	// Round back down to previous pwr of 2.
				
				// Compute the # of bytes of fill that are necessary
				// to align to the specified boundary.
				
				sub( edx, ecx );
				if( @nz ) then	// Align by adding ECX bytes, if ECX <> 0
				
					if( curSection = code_c ) then
					
						// In a code section, fill with NOPs
						//
						//	Emit multi-byte NOP instructions to reduce
						// execution time if we actually execute this:
						
						while( ecx >= 7 ) do
						
							mov( $24a48d, eax );
							stosd();
							mov( $0, ax );
							stosw();
							stosb();
							sub( 7, ecx );
							
						endwhile;
						if( ecx = 6 ) then
						
							mov( $9b8d, eax );
							stosd();
							mov( 0, ax );
							stosw();
							
						endif;
						if( ecx = 5 ) then
						
							mov( $24648d, eax );
							stosd();
							mov( $90, al );
							stosb();
							
						endif;
						if( ecx = 4 ) then
						
							mov( $24648d, eax );
							stosd();
							
						endif;
						if( ecx = 3 ) then
						
							mov( $498d, ax );
							stosw();
							mov( 0, al );
							stosb();
							
						endif;
						if( ecx = 2 ) then
						
							mov( $ff8b, ax );
							stosw();
							
						endif;
						if( ecx = 1 ) then
						
							mov( $90, al );
							stosb();
							
						endif;							
						
						
					
					else	// readonly_c or data_c
					
						// In a readonly or data section, fill with zeros.
						
						xor( eax, eax );
						cld();
						rep.stosb();
					
					endif;
					
				endif;	
				
				
			
			case( bss_tkn )
			
				// The following expression should always be true,
				// as we don't call this function for BSS sections:
				
				if( curSection <> bss_c ) then
				
					stderr.put
					(
						"Error: Unexpected bss directive encountered "
						"in non-bss section" nl
					);
					raise( ex.InvalidArgument );
					
				endif;
				
				
							
			case( bytes_tkn )
			
				push( esi );
				mov( (type byteStmt_t [ebx]).numBytes, ecx );
				if( ecx <> 0 ) then
				
					lea( esi, (type byteStmt_t [ebx]).byteData );
					cld();
					rep.movsb();
									
				endif;
				pop( esi );
				
				
					
			case( code_tkn )
			
				if( curSection <> code_c ) then
				
					stderr.put
					(
						"Error: Unexpected code directive encountered "
						"in non-code section" nl
					);
					raise( ex.InvalidArgument );
					
				endif;
				
				
							
			case( data_tkn )
			
				if( curSection <> data_c ) then
				
					stderr.put
					(
						"Error: Unexpected data directive encountered "
						"in non-data section" nl
					);
					raise( ex.InvalidArgument );
					
				endif;
			
			
			
							
			case
			( 
				dupByte_tkn,
				dupWord_tkn,
				dupDword_tkn
			)
			
				mov( dupEBX.count, ecx );
				mov( dupEBX.data, eax );
				cmp( dupEBX.size, 2 );
				jb byteDup;
				ja dwordDup;
				
					cld();
					rep.stosw();
					jmp done;
					
				byteDup:
				
					cld();
					rep.stosb();
					jmp done;
					
				dwordDup:
				
					cld();
					rep.stosd();
					
				done:
			
			
			
			case( rel1_tkn )
			
				// For rel1_tkn instructions (jecxz and loop*) we
				// need to emit the opcode and the displacement:
				
				mov( rel1EBX.opcode, al );
				stosb();
				mov( rel1EBX.disp, eax );
				stosb();
				
								  
			
			case( rel2_tkn )	 
			
				// For rel2_tkn instructions (jcxz) we
				// need to emit the 2-byte opcode and the displacement:
				
				mov( rel2EBX.opcode, ax );
				stosw();
				mov( rel2EBX.disp, eax );
				stosb();
				
				
				
			case( rel1_4_tkn )

				if( rel14EBX.curOfsSize = 1 ) then
				
					// 1-byte opcode + 1-byte displacement:
					
					mov( rel14EBX.opcode1, al );
					stosb();
					mov( rel14EBX.disp, eax );
					add( rel14EBX.offset, eax );
					stosb();
					
				else
				
					// 2-byte opcode + 4-byte displacement:
					
					mov( rel14EBX.opcode2, ax );
					stosw();
					mov( rel14EBX.disp, eax );
					add( rel14EBX.offset, eax );
					stosd();
					
					// If the displacement references an
					// external symbol, or a symbol that is
					// not in the current section, then we must emit
					// a relocation record for this guy.
					
					if( rel14EBX.symbol <> NULL ) then
					
						mov( rel14EBX.symbol, eax );
						mov( tblEAX.Value, eax );
						mov( symEAX.section, dl );
						test( isExtern_c, symEAX.flags );
						if
						(
								@nz 
							||	dl <> curSection
						) then
						
							mov( objType, dl );
							if( dl = pecoff_c ) then
							
								mov( symEAX.symIndex, eax );
								mov( eax, relocESI.SymbolTableIndex );
								mov( tknEBX.instrOffset, eax );
								add( 2, eax );
								mov( eax, relocESI.VirtualAddress );
								mov( w.IMAGE_REL_I386_REL32, relocESI.Type1 );
								add( @size( w.IMAGE_RELOCATION ), esi );
								
								// Need to store offset field into the
								// displacement rather than the disp field:
								
								mov( rel14EBX.offset, eax );
								mov( eax, [edi-4] );
								
							elseif( dl in minElf_c..maxElf_c ) then
							
								mov( tknEBX.instrOffset, edx );
								add( 2, edx );
								mov( edx, relocElfESI.r_offset );
								
								mov( symEAX.symIndex, eax );
								shl( 8, eax );
								or( R_386_PC32, eax );
								mov( eax, relocElfESI.r_info );
								
								add( @size( Elf32_Rel ), esi );
							
								// Need to store offset field into the
								// displacement rather than the disp field:
								
								mov( rel14EBX.offset, eax );
								mov( eax, [edi-4] );
							
							elseif( dl = macho_c ) then
							
								mov( tknEBX.instrOffset, edx );
								add( 2, edx );
								mov( edx, relocMachoESI.r_address );
								
								mov( symEAX.symIndex, eax );
								or( r_pcrel | r_length_d | r_extern, eax );
								mov( eax, relocMachoESI.r_symbolnum );
								add( @size( relocation_info ), esi );
								
								// Need to store the distance to the beginning
								// of the section into the instruction's 
								// displacement field:
							
								mov( rel4EBX.instrOffset, eax );
								add( 6, eax );
								neg( eax );
								mov( eax, [edi-4] );
							
							else
							
								stderr.put
								( 
									"Object code type is not supported" nl
								);
								
							endif;
							
							
						endif;
						
					endif;
					
				endif;
				


			case( jmp_tkn )
			
				if( jmpEBX.curOfsSize = 1 ) then
				
					// 1-byte opcode + 1-byte displacement:
					
					mov( jmpEBX.opcode1, al );
					stosb();
					mov( jmpEBX.disp, eax );
					add( jmpEBX.offset, eax );
					stosb();
					
				else
				
					// 1-byte opcode + 4-byte displacement:
					
					mov( jmpEBX.opcode2, al );
					stosb();
					mov( jmpEBX.disp, eax );
					add( jmpEBX.offset, eax );
					stosd();
					
					
					// If the displacement references an
					// external symbol, or a symbol that is
					// not in the current section, then we must emit
					// a relocation record for this guy.
					
					if( jmpEBX.symbol <> NULL ) then
					
						mov( jmpEBX.symbol, eax );
						mov( tblEAX.Value, eax );
						mov( symEAX.section, dl );
						mov( symEAX.flags, dh );
						and( isExtern_c | isPublic_c, dh );
						test( isExtern_c, dh );
						if
						(
								@nz 
							||	dl <> curSection
							||	(
										dh
									&&	objType in minElf_c..maxElf_c
								)
						) then
						
							mov( objType, dl );
							if( dl = pecoff_c ) then
						
								mov( symEAX.symIndex, eax );
								mov( eax, relocESI.SymbolTableIndex );
								mov( tknEBX.instrOffset, eax );
								add( 1, eax );
								mov( eax, relocESI.VirtualAddress );
								mov( w.IMAGE_REL_I386_REL32, relocESI.Type1 );
								add( @size( w.IMAGE_RELOCATION ), esi );
								
								// Need to store offset field into the
								// displacement rather than the disp field:
								
								mov( jmpEBX.offset, eax );
								mov( eax, [edi-4] );
								
							elseif( dl in minElf_c..maxElf_c ) then 
							
								mov( tknEBX.instrOffset, edx );
								add( 1, edx );
								mov( edx, relocElfESI.r_offset );
								
								mov( symEAX.symIndex, edx );
								shl( 8, edx );
								or( R_386_PC32, edx );
								mov( edx, relocElfESI.r_info );
								
								add( @size( Elf32_Rel ), esi );
							
								// ELF needs this magic value here:
								
								test( isExtern_c, symEAX.flags );
								if( @nz ) then
								
									mov( $FFFF_FFFC, (type dword [edi-4]) );
									
								endif;
								
							
							elseif( dl = macho_c ) then
							
								mov( tknEBX.instrOffset, edx );
								add( 1, edx );
								mov( edx, relocMachoESI.r_address );
								
								mov( symEAX.symIndex, eax );
								or( r_pcrel | r_length_d | r_extern, eax );
								mov( eax, relocMachoESI.r_symbolnum );
								add( @size( relocation_info ), esi );
							
								// Need to store the distance to the beginning
								// of the section into the instruction's 
								// displacement field:
							
								mov( rel4EBX.instrOffset, eax );
								add( 5, eax );
								neg( eax );
								mov( eax, [edi-4] );
							
							else
							
								stderr.put
								( 
									"Object code type is not supported" nl
								);
								
							endif;
							
						endif;
						
					endif;
					
				endif;
				


				
				
					 
			case( rel4_tkn )
				 
				// CALL instruction.
				// 1-byte opcode + 4-byte displacement:
				
				mov( rel4EBX.opcode, al );
				stosb();
				mov( rel4EBX.disp, eax );
				add( rel4EBX.offset, eax );
				stosd();
				
				
				// If the displacement references an
				// external symbol, or a symbol that is
				// not in the current section, then we must emit
				// a relocation record for this guy.
				
				if( rel4EBX.symbol <> NULL ) then
				
					mov( rel4EBX.symbol, eax );
					mov( tblEAX.Value, eax );
					mov( symEAX.section, dl );
					mov( symEAX.flags, dh );
					and( isExtern_c | isPublic_c, dh );
					test( isExtern_c, dh );
					if
					(
							@nz 
						||	dl <> curSection
						||	(
									dh
								&&	objType in minElf_c..maxElf_c
							)
					) then
					
						mov( objType, dl );
						if( dl = pecoff_c ) then
							
							mov( symEAX.symIndex, eax );
							mov( eax, relocESI.SymbolTableIndex );
							mov( tknEBX.instrOffset, eax );
							add( 1, eax );
							mov( eax, relocESI.VirtualAddress );
							mov( w.IMAGE_REL_I386_REL32, relocESI.Type1 );
							add( @size( w.IMAGE_RELOCATION ), esi );
							
							// Need to store offset field into the
							// displacement rather than the disp field:
							
							mov( rel4EBX.offset, eax );
							add( rel4EBX.disp, eax );
							mov( eax, [edi-4] );
						
						elseif( dl in minElf_c..maxElf_c ) then
						
							mov( tknEBX.instrOffset, edx );
							add( 1, edx );
							mov( edx, relocElfESI.r_offset );
							
							mov( symEAX.flags, dl );
							mov( symEAX.symIndex, eax );
							shl( 8, eax );
							or( R_386_PC32, eax );
							mov( eax, relocElfESI.r_info );
							
							add( @size( Elf32_Rel ), esi );
						
							
							// ELF needs this magic value here:
							
							mov( $FFFF_FFFC, (type dword [edi-4]) );
						
						elseif( dl = macho_c ) then
						
							mov( tknEBX.instrOffset, edx );
							add( 1, edx );
							mov( edx, relocMachoESI.r_address );
							
							mov( symEAX.symIndex, eax );
							or( r_pcrel | r_length_d | r_extern, eax );
							mov( eax, relocMachoESI.r_symbolnum );
							add( @size( relocation_info ), esi );
							
							// Need to store the distance to the beginning
							// of the section into the instruction's displacement
							// field:
						
							mov( rel4EBX.instrOffset, eax );
							add( 5, eax );
							neg( eax );
							mov( eax, [edi-4] );
						
						else
						
							stderr.put
							( 
								"Object code type is not supported" nl
							);
							
						endif;
						
					endif;
					
				endif;
				
				
					 
			case( reloc_tkn ) 	 
			
				
				// For reloc_tkn we must emit a relocation record
				// along with a four-byte offset.
				
				if( relocEBX.symbol <> NULL ) then
				
					mov( objType, dl );
					if( dl = pecoff_c ) then
							
						mov( relocEBX.symbol, eax );
						mov( tblEAX.Value, eax );
						mov( symEAX.symIndex, eax );
						mov( eax, relocESI.SymbolTableIndex );
						mov( tknEBX.instrOffset, eax );
						mov( eax, relocESI.VirtualAddress );
						mov( w.IMAGE_REL_I386_DIR32, relocESI.Type1 );
						add( @size( w.IMAGE_RELOCATION ), esi );
						
						// Store the address of the symbol plus any
						// offset from the symbol into the object code:
						
						mov( relocEBX.offset, eax );
						stosd();
						
					elseif( dl in minElf_c..maxElf_c ) then
					
						mov( tknEBX.instrOffset, edx );
						mov( edx, relocElfESI.r_offset );
						
						mov( relocEBX.symbol, eax );
						mov( tblEAX.Value, eax );
						mov( symEAX.symIndex, edx );
						shl( 8, edx );
						or( R_386_32, edx );
						mov( edx, relocElfESI.r_info );
						
						add( @size( Elf32_Rel ), esi );
						
						// Store the address of the symbol plus any
						// offset from the symbol into the object code:
						
						mov( relocEBX.symbol, eax );
						mov( (type tableNode_t [eax]).Value, eax );
						//mov( symEAX.offset, eax );
						mov( relocEBX.offset, eax );
						stosd();
					
					elseif( dl = macho_c ) then
					
						// If the symbol is external, or if the offset
						// from the symbol is zero, then we've got a
						// standard relocation entry. If the symbol is
						// not external and the offset is non-zero, then
						// we need to create a scattered relocation entry:
						
						mov( relocEBX.symbol, eax );
						mov( tblEAX.Value, eax );
						mov( tknEBX.instrOffset, edx );
						sub( sectionStart, edx );
						test( isExtern_c, symEAX.flags );
						if( @nz || relocEBX.offset = 0 ) then	
						
							// Standard relocation entry
						
							mov( edx, relocMachoESI.r_address );
							test( isExtern_c, symEAX.flags );
							if( @nz ) then
							
								mov( symEAX.symIndex, eax );
								or( r_length_d | r_extern, eax );	
								mov( eax, relocMachoESI.r_symbolnum );
								add( @size( relocation_info ), esi );							
								
							
								// Store the offset from the symbol into the 
								// object code:
								
								mov( relocEBX.offset, eax );
								stosd();
							
							
							else
							
								movzx( symEAX.section, eax );
								if( al = code_c ) then
								
									mov( 1, al );
									
								elseif( al = data_c ) then
								
									mov( 2, al );
									
								elseif( al = bss_c ) then
								
									mov( 3, al );
									
								else
								
									stdout.put
									( 
										"HLABE Internal error (Bad section):",
										(type uns8 al), 
										nl 
									);
									raise( ex.ValueOutOfRange );
									
								endif;
								or( r_length_d, eax );
								mov( eax, relocMachoESI.r_symbolnum );
								add( @size( relocation_info ), esi );							
								
							
								// Store the address of the symbol into the 
								// object code:
								
								mov( relocEBX.symbol, eax );
								mov( (type tableNode_t [eax]).Value, eax );
								mov( symEAX.offset, eax );
								stosd();
								
							endif;
							
						else	// Scattered relocation entry
						
							mov( edx, scRelocMachoESI.r_address );
							or( r_scattered, scRelocMachoESI.r_address );
							mov( symEAX.offset, eax );
							mov( eax, scRelocMachoESI.r_value );
							add( relocEBX.offset, eax );
							stosd();
							add( @size( scattered_relocation_info ), esi );
						
						endif;
						
						
					else
					
						stderr.put
						( 
							"Object code type is not supported" nl
						);
						
					endif;
					
				endif;
		
		
			 
			case( reserve_tkn )
			
				// For reserve, emit the number of zero bytes specified
				// by the sizeExpr field:
				
				mov( (type reserveStmt_t [ebx]).sizeExpr, ecx );
				if( ecx <> 0 ) then
				
					xor( eax, eax );
					cld();
					rep.stosb();
				
				endif;
				
				
				
					
			default
			
				stderr.put
				( 
					"Internal error: illegal token value:",
					(type uns8 al),
					nl 
				);
				//raise( ex.InvalidArgument );
				
		endswitch;
		mov( tknEBX.next, ebx );
	
	endwhile;
	
	pop( esi );
	pop( edi );
	pop( edx );
	pop( ecx );
	pop( ebx );
	
_end( buildRaw );  




///////////////////////////////////////////////////////////////////////////////
//
// optimizeDisps-
//
//	Optimizes branch displacements and checks for jumps out of range
// throughout all the code and data sections.

_proc( optimizeDisps )
( 
	codeList	:tokenList_t;
	dataList	:tokenList_t;
	bssList	    :tokenList_t;
	verbose		:boolean;
	objType		:obj_t
);
var
	passes	:uns32;
	codeRelocs	:dword;
	dataRelocs	:dword;
	
	

	// firstPass-
	//
	//	Fills in the initial offset of each binary record and
	// sets the initial address of each of the symbols.
	//
	//	initialDispSize contains 1 for standard optimization pass
	// (small->large); it contains 4 for fallback optimization pass
	// (large->small).
	//
	//	Returns the number of code relocations in EAX and the number
	// of data relocations in EDX.
	
	_proc( firstPass )
	( 
		codeList		:tokenList_t;
		dataList		:tokenList_t;
		bssList	    	:tokenList_t;
		initialDispSize	:uns32;
		objType			:obj_t
	);
	var
		codeRelocs	:dword;
		dataRelocs	:dword;
		
	
		// sectionPass-
		//
		//	Does a pass over one of the sections.
		
		_proc( sectionPass )
		( 
			list			:tokenList_t; 
			initialDispSize	:uns32;
			initialOffset	:dword 
		);
		var
		_begin( sectionPass );
		
			push( ebx );
			push( ecx );
			push( edx );
			
			mov( initialOffset, ecx );
			mov( list, ebx );
			while( ebx <> NULL ) do
			
				// First, set the instrOffset field
				
				mov( ecx, tknEBX.instrOffset );

				// Now process the particular record:
				
				movzx( (type tokenStmt_t [ebx]).token, eax );
				switch( eax )
				
					case
					( 
						start_tkn,
						public_tkn,
						extern_tkn,
						endfunc_tkn,
						dummy_tkn
					)
					
						// Ignore these tokens on the first pass.
										
					case( code_tkn );
					
						mov( code_c, currentSection );
						
					case( data_tkn );
					
						mov( data_c, currentSection );
						
					case( bss_tkn );
					
						mov( bss_c, currentSection );
						
					case( align_tkn )
					
						// Now align ECX (current offset) to the
						// value specified by this record. Note that
						// the alignment expression is always a power
						// of two.
						
						mov( (type alignStmt_t [ebx]).alignExpr, eax );
						
						// 2**(n-1) yields a bit mask that can be used
						// (inverted) to round the value up to the next
						// power of two.
						
						sub( 1, eax );		// 2**(n-1)
						add( eax, ecx );	// Round displacement up
						not( eax );			// Create the inverted bit mask.
						and( eax, ecx );	// Align to next 2**n boundary.
							 
							 
							 
					case( bytes_tkn )
					
						// As we don't have to do anything special with
						// "bytes" records, simply add the size of this
						// "bytes" record to ECX:
						
						add( (type byteStmt_t [ebx]).numBytes, ecx );
						
						
						 
					case( label_tkn )	 
					
						// Now set the offset field of the symbol table
						// entry to the value in ECX.
						
						mov( (type labelStmt_t [ebx]).symTabEntry, eax );
						mov( (type tableNode_t [eax]).Value, eax );
						mov( ecx, symEAX.offset );
						mov( currentSection, dl );
						mov( dl, symEAX.section );

						
						
					case( reserve_tkn )
					
						// reserve only needs to bump ECX by the 
						// value of reserveStmt_t.sizeExpr
						
						add( (type reserveStmt_t [ebx]).sizeExpr, ecx );
						
						
						 
					case( dupByte_tkn, dupWord_tkn, dupDword_tkn )
						
						
						// Now bump ECX by the product of the size and count
						// fields:
						
						mov( (type dupStmt_t [ebx]).size, eax );
						intmul( (type dupStmt_t [ebx]).count, eax );
						add( eax, ecx );
						
						
					case( rel1_tkn )
					
						// rel1_tkn is easy, just bump ECX by 2.
						// This code also checks the displacement field to
						// ensure that the instruction (typically jecxz, jcxz,
						// or loop*) does not reference an external identifier
						// (which is not allowed for technical reasons).
						
						add( 2, ecx );	// Instructions are two bytes long.
						mov( rel1EBX.symbol, eax );
						if( eax <> NULL ) then
						
							mov( (type tableNode_t [eax]).Value, edx );
							if( edx <> NULL ) then
							
								mov( (type symbol_t [edx]).flags, dl );
								test( isExtern_c, dl );
								if( @nz ) then
								
									stderr.put
									(
										"Instruction cannot reference an "
										"external symbol (",
										(type tableNode_t [eax]).id,
										")" nl
									);
									printLineNumberChain( [ebx] );
									raise( ex.ValueOutOfRange );
									
								endif;
								
							endif;
							
						endif; 
						  
					
					case( rel1_4_tkn )
					
						// initialDispSize contains 1 or 4, depending
						// upon whether we're doing a standard optimization
						// (small->large) or a fallback optimization 
						// (large->small)
						
						add( 1, ecx );		// Assume a 1-byte opcode.
						mov( initialDispSize, eax );
						add( eax, ecx );
						
						mov( al, (type rel_1_4_Stmt_t [ebx]).curOfsSize );
						if( al > 1 ) then
						
							// If the initial displacement size is greater
							// than 1, we also have a 2-byte opcode:
							
							add( 1, ecx );
							
						endif;
						
							


					case( jmp_tkn )
					
												
						mov( initialDispSize, eax );
						lea( ecx, [ecx+eax+1] );		// Always a 1-byte opcode
						mov( al, jmpEBX.curOfsSize );
						
						
							 
					case( rel2_tkn )	 
					
						// rel2_tkn is easy, just bump ECX by 3.
						
						add( 3, ecx );
						
						
							 
					case( rel4_tkn )	 
					
						// rel4_tkn is easy, just bump ECX by 5.
						
						add( 5, ecx );
						
						
							 
					case( reloc_tkn )	 
					
						// reloc_tkn is easy, just bump ECX by 4.
						
						add( 4, ecx );
						
						
							 
					default
					
						stderr.put
						( 
							"Internal error: illegal token value:",
							(type uns8 al),
							nl 
						);
						raise( ex.InvalidArgument );
						
				endswitch;
				mov( (type tokenStmt_t [ebx]).next, ebx );
				
			endwhile;
			mov( ecx, eax );	// Return final displacement value.
			pop( edx );
			pop( ecx );
			pop( ebx );
			
		_end( sectionPass );
		
	_begin( firstPass );
	
		mov( code_c, currentSection );
		mov( 0, codeStart );
		sectionPass( codeList, initialDispSize, codeStart );
		mov( eax, codeEnd );
		
		// If Mach-O (Mac OSX), then DATA section displacement
		// must follow the TEXT section (rounded to 16-byte address):
		
		if( objType = macho_c ) then
		
			add( 15, eax );
			and( $FFFF_FFF0, eax );
			mov( eax, dataStart );
			
		else
		
			mov( 0, dataStart );
			
		endif;
		mov( data_c, currentSection );
		sectionPass( dataList, initialDispSize, dataStart );
		mov( eax, dataEnd );
		
		// If Mach-O (Mac OSX), then BSS section displacement
		// must follow the DATA section (rounded to 16-byte address):
		
		if( objType = macho_c ) then
		
			add( 15, eax );
			and( $FFFF_FFF0, eax );
			
		else
		
			xor( eax, eax );
			
		endif;
		mov( eax, bssStart );
		mov( bss_c, currentSection );
		sectionPass( bssList, initialDispSize, eax );
		mov( eax, bssEnd );
		
	_end( firstPass );
	

	// dispPhase-
	//
	//	Makes a pass over the code and data sections and
	// adjusts all the displacements and label addresses,
	// lengthening the displacement fields if needed.
	//
	//	Returns:
	//
	//		EAX =	# of passes required.
	 
	_proc( dispPhase )
	( 
		codeList	:tokenList_t;
		dataList	:tokenList_t;
		bssList		:tokenList_t;
		destSize	:byte;
		objType		:obj_t
	);
		
	var
		ebxSave		:dword;
		ecxSave		:dword;
		edxSave		:dword;
		passes		:uns32;
		lengthened	:boolean;
		
		// computeDisplacement-
		//
		//	Computes the displacement value and size for a record
		// containing a disp_t component. Updates the disp_t field
		// as appropriate and returns the size (in bytes) of the
		// displacement field in EAX.
		//
		//	curOffset is the offset to the object where the branch
		// displacement is to be computed from (generally, the byte
		// immediately following the branch instruction). 
		//
		// dispRecord is the address of the displacement record.  
		// Uses the global currentSection to see if the symbol is 
		// within the current section. If it is not, the displacement 
		// is always four bytes long.  If the symbol is external, then
		// it is always four bytes long.
		
		_proc( computeDisplacement )
		( 
				curOffset	:dword; 
			var	dispRecord	:disp_t 
		);
			
		var
		_begin( computeDisplacement );
		
			push( ebx );
			push( ecx );
			push( edx );
			mov( curOffset, ecx );
			mov( dispRecord, ebx );
		
			mov( dispEBX.symbol, eax );
			mov( tblEAX.Value, edx );
			test( isExtern_c | isDefined_c, symEDX.flags );
			if( @z ) then
			
				stderr.put
				(
					"Undefined symbol:",  
					tblEAX.id,
					nl
				);
				printLineNumberChain( [ebx] );
				raise( ex.ValueOutOfRange );
				
			endif;
			mov( symEDX.section, al );
			mov( symEDX.flags, ah );
			and( isExtern_c | isPublic_c, ah );
			if( al = undefinedSection_c ) then
			
				// If the symbol's section isn't yet defined,
				// then assume it's still a one-byte displacement
				
				mov( 1, eax );
				
			elseif( ah = isExtern_c ) then
			
				// External references are always four bytes
				
				mov( 4, eax );
				
			elseif( al <> currentSection ) then
	
				// References outside the current section
				// are always four bytes long:
				
				mov( 4, eax );
				
			else
			
				// In the current section, not external, and
				// defined. So we can compute the displacement.
				
				mov( symEDX.offset, eax );
				sub( ecx, eax );
				
				mov( eax, dispEBX.disp );
				if( (type int32 eax) >= -128 && (type int32 eax) <=127 ) then
				
					mov( 1, eax );
					
				else
				
					mov( 4, eax );
					
				endif;
				
			endif;
			pop( edx );
			pop( ecx );
			pop( ebx );
			
		_end( computeDisplacement );
		
		
		// doPhase-
		//
		//	Does one of the intermediate passes over the internal representation
		// trying to shorten (if destSize=1) or lengthen (if destSize=4) the
		// branch displacements.
		//
		//	Inputs-
		//
		//		list-	Internal representation of the code.
		//		lengthened	- Points at a flag that must be set to true if any
		//						of the displacements in the list change size.
		//		destSize	- If a displacement changes size, force it to this
		//						size (1 or 4).
		_proc( doPhase )
		( 
				list			:tokenList_t;
			var	lengthened		:boolean;
				destSize		:byte;
				initialOffset	:dword	 
		);
		var
			origOffset	:dword;
			
		_begin( doPhase );
		
			mov( initialOffset, ecx );
			mov( list, ebx );
			while( ebx <> NULL ) do
			
				// First, set the instrOffset field.  Save the
				// original offset to use for displacement calcs.
				
				mov( tknEBX.instrOffset, eax );
				mov( eax, origOffset );
				mov( ecx, tknEBX.instrOffset );
				
				// Now process the particular record:
						
				movzx( tknEBX.token, eax );
				switch( eax );
				
					case
					( 
						start_tkn,
						public_tkn,
						extern_tkn,
						endfunc_tkn,
						label_tkn
					)
						// Ignore these tokens.
						
					case( code_tkn );
					
						mov( code_c, currentSection );
						
					case( data_tkn );
					
						mov( data_c, currentSection );
						
					case( bss_tkn );
					
						mov( bss_c, currentSection );
						
					case( dummy_tkn )
					
						// We'll use dummy_tkn to determine if the
						// offsets have change from one phase to the
						// next (which will force another phase if
						// they have).
						
						mov( origOffset, eax );
						if( eax <> tknEBX.instrOffset ) then
						
							mov( lengthened, eax );
							mov( true, (type boolean [eax]));
							
						endif;
							
										
					case( align_tkn )
					
						// Align ECX (current offset) to the
						// value specified by this record. Note that
						// the alignment expression is always a power
						// of two.
						
						mov( (type alignStmt_t [ebx]).alignExpr, eax );
						sub( 1, eax );
						add( eax, ecx );
						not( eax );
						and( eax, ecx );
						mov( (type alignStmt_t [ebx]).next, eax );
						
						// If the new location pointer value doesn't match
						// the offset of the next instruction, assume we've
						// changed the length of the file:
						
						if( ecx <> (type tokenStmt_t [eax]).instrOffset ) then

							mov( lengthened, edx );
							mov( true, (type boolean [edx]));
							
						endif;
							 
							 
							 
					case( bytes_tkn )
					
						// Add the size of this "bytes" record to ECX:
						
						add( (type byteStmt_t [ebx]).numBytes, ecx );
						
						
						 
					case( reserve_tkn )
					
						// reserve only needs to bump ECX by the 
						// value of reserveStmt_t.sizeExpr
						
						add( (type reserveStmt_t [ebx]).sizeExpr, ecx );
						
						
						 
					case( dupByte_tkn, dupWord_tkn, dupDword_tkn )
						
						// Bump ECX by the product of the size and count
						// fields:
						
						mov( (type dupStmt_t [ebx]).size, eax );
						intmul( (type dupStmt_t [ebx]).count, eax );
						add( eax, ecx );
						
						
					case( rel1_tkn )
					
						// rel_1 token is for instructions like
						// jecxz, and loop* that only support a one-byte
						// displacement.  We need to compute the numeric
						// displacement and determine if it is within
						// range. If not, abort the compilation with an
						// appropriate fatal error.
						
						add( 2, ecx );		// Size is always two bytes.
						mov( origOffset, eax );
						add( 2, eax );
						computeDisplacement( eax, [ebx] );
						
						
					
					case( rel1_4_tkn )
					
						// For relative jumps, the opcode is one byte
						// long if curOfsSize is 1:
						
						mov( 2, eax );
						mov( 1, edx );
						if( (type rel_1_4_Stmt_t [ebx]).curOfsSize = 4 ) then
						
							// For relative jumps, the opcode is two
							// bytes long if curOfsSize is not 1:
							// (note that we already added 2 above)
							
							add( 3, edx );	// Disp is 4 bytes.
							add( 4, eax );	// Instr is 6 bytes
						
						endif;
						add( eax, ecx );
						
						// ComputeDisplacement expect the offset to be
						// computed from the start of the next instruction:
						
						add( origOffset, eax );
						computeDisplacement( eax, [ebx] );
						if( al <> dl && al = destSize ) then
						
							// Displacement has changed in size,
							// adjust for that.  Note that the computed
							// displacement is now incorrect, but we're
							// forcing a new pass and the displacement
							// will be corrected on the next pass.
							
							mov( al, (type rel_1_4_Stmt_t [ebx]).curOfsSize );
							mov( lengthened, edx );
							mov( true, (type boolean [edx]));
							
						endif;

					case( jmp_tkn )
					
						// For jumps, the opcode size is always one
						// byte long.
						
						add( 1, ecx );
						movzx( jmpEBX.curOfsSize, edx );
						add( edx, ecx );
						mov( origOffset, eax );
						add( 1, eax );
						add( edx, eax );
						computeDisplacement( eax, [ebx] );
						if( al <> dl && al = destSize ) then
						
							// Displacement has changed in size,
							// adjust for that.  Again, the displacement
							// just computed is wrong, but we'll fix
							// that on the next pass.

							mov( destSize, al );
							mov( al, jmpEBX.curOfsSize );
							mov( lengthened, edx );
							mov( true, (type boolean [edx]));
							
						endif;
						
						
						
							 
					case( rel2_tkn )	 
					
						// jcxz instruction, must bump ECX by 3 and
						// verify that the displacement is one byte.
						
						add( 3, ecx );
						mov( origOffset, eax );
						add( 3, eax );
						computeDisplacement( eax, [ebx] );
						
							 
					case( rel4_tkn )	 
					
						// rel4_tkn is easy, must bump ECX by 5 and
						// compute the displacement (CALL instr).
						
						add( 5, ecx );
						mov( origOffset, eax );
						add( 5, eax );
						computeDisplacement( eax, [ebx] );
						
							 
					case( reloc_tkn )	 
					
						// reloc_tkn is easy, just bump ECX by 4.
						
						add( 4, ecx );
						
						
							 
					default
					
						stderr.put
						( 
							"Internal error: illegal token value:",
							(type uns8 al),
							nl 
						);
						raise( ex.InvalidArgument );
					
				endswitch;
				mov( tknEBX.next, ebx );
				
			endwhile;
			
			
			// Make another quick pass to set all the label offsets:
			
			mov( list, ebx );
			while( ebx <> NULL ) do
			
				if( (type labelStmt_t [ebx]).token = label_tkn ) then
				
					mov( (type labelStmt_t [ebx]).instrOffset, edx );
					mov( (type labelStmt_t [ebx]).symTabEntry, eax );
					mov( tblEAX.Value, eax );
					if( edx <> symEAX.offset ) then
					
						mov( edx, symEAX.offset );
						mov( lengthened, edx );
						mov( true, (type boolean [edx]));
						
					endif;
			
				endif;
				mov( tknEBX.next, ebx );
				
			endwhile;
			
		_end( doPhase );
		
	_begin( dispPhase );
	
		mov( ebx, ebxSave );
		mov( ecx, ecxSave );
		mov( edx, edxSave );
		mov( 0, passes );
		repeat
		
			mov( false, lengthened );
			mov( 0, codeStart );
			doPhase( codeList, lengthened, destSize, codeStart );
			mov( ecx, codeEnd );
			if( objType = macho_c ) then
			
				add( 15, ecx );
				and( $FFFF_FFF0, ecx );
				
			else
			
				xor( ecx, ecx );
				
			endif;
			mov( ecx, dataStart );
			doPhase( dataList, lengthened, destSize, ecx  );
			mov( ecx, dataEnd );
			
			// BSS never changes size, but for Mach-O files
			// the starting displacement might change.
			if( objType = macho_c ) then
			
				add( 15, ecx );
				and( $FFFF_FFF0, ecx );
				mov( ecx, bssStart );
				doPhase( bssList, lengthened, destSize, ecx  );
				mov( ecx, bssEnd );
				
			endif;
			add( 1, passes );
						
			// Optimization is an NP-Complete problem.
			// Bail if optimization takes more than 16,384 
			// passes. For the small->large optimization
			// scheme, we will have to do a large->small
			// optimization operation; for the large->small
			// optimization scheme, we can call it quits
			// (possibly not optimal, but the code generation
			// will still be runnable).
			
			breakif( passes > 16384 );
			
		until( !lengthened );
		mov( passes, eax );
		
		mov( ebxSave, ebx );
		mov( ecxSave, ecx );
		mov( edxSave, edx );
		
	_end( dispPhase );
	
	
	
	// finalPass-
	//
	//	Checks for branches that are out of range (once optimization
	// is complete), looks for undefined symbols,  and handles any 
	// other necessary cleanup before code generation.
	
	_proc( finalPass )
	( 
		codeList		:tokenList_t;
		dataList		:tokenList_t;
		bssList	    	:tokenList_t;
		objType			:obj_t
	);
	var
		codeRelocs	:dword;
		dataRelocs	:dword;
		
	
		// cleanupPass-
		//
		//	Does a cleanup pass over one of the sections.
		//
		//	Returns:
		//
		//		EAX-	Size of section (in bytes)
		//		EDX-	# of relocations in section
		
		_proc( cleanupPass )
		( 
			list		:tokenList_t; 
			curSection	:section_t;
			objType		:obj_t 
		);
		var
		_begin( cleanupPass );
		
			push( ebx );
			push( ecx );
			push( esi );
			
			mov( list, ebx );
			xor( esi, esi );
			while( ebx <> NULL ) do
			
				// Save the offset (which is the current size):
				
				mov( tknEBX.instrOffset, ecx );
				
				// Process the particular record:
				
				movzx( tknEBX.token, eax );
				switch( eax )
				
					case
					( 
						start_tkn,
						code_tkn,
						data_tkn,
						bss_tkn,
						public_tkn,
						extern_tkn,
						align_tkn,
						bytes_tkn,
						reserve_tkn,
						dupByte_tkn, 
						dupWord_tkn, 
						dupDword_tkn,
						dummy_tkn
					)
						// Ignore these tokens on the cleanup pass.
							
							
					case( endfunc_tkn )
					
						mov( (type endFuncStmt_t [ebx]).symTabEntry, edx );
						mov( (type tableNode_t [edx]).Value, eax );
						
						// Tell the ELF code generator that this is a
						// function:
						
						mov( true, symEAX.isFunc );
						
						// Compute the size of the function:
						
						mov( ecx, edx );
						sub( symEAX.offset, edx );
						mov( edx, symEAX.size );
						
					
					case( label_tkn )	 
					
						// For labels, make sure they are defined
						// by the end of the compilation.
						
						mov( (type labelStmt_t [ebx]).symTabEntry, edx );
						mov( (type tableNode_t [edx]).Value, eax );
						mov( ecx, symEAX.offset );
						test
						( 
							isExtern_c | isDefined_c, 
							(type symbol_t [eax]).flags 
						);
						if( @z ) then
						
							stderr.put
							(
								"Symbol '",
								(type tableNode_t [edx]).id,
								"' is undefined"
								nl
							);
							printLineNumberChain( [ebx] );
							raise( ex.InvalidArgument );
							
						endif;

						
						
					case( rel1_tkn )
					
						// For rel1_tkn statments (jecxz and loop*) we
						// need to ensure that the displacement is in the
						// range -128..+127.
						
						mov( rel1EBX.disp, eax );
						if( (type int32 eax) < -128 || (type int32 eax) >127 ) then
						
							stderr.put
							(
								"Branch target is out of range. " nl
								"(displacement=",
								(type int32 eax),
								" and must be in the range -128..+127)."
								nl
							);
							printLineNumberChain( [ebx] );
							raise( ex.ValueOutOfRange );
							
						endif;
						  
					
					case( rel2_tkn )	 
					
						// For rel1_tkn statments (jcxz) we
						// need to ensure that the displacement is in the
						// range -128..+127.
						
						mov( rel2EBX.disp, eax );
						if
						( 
								(type int32 eax) < -128 
							||	(type int32 eax) > 127 
						) then
						
							stderr.put
							(
								"Branch target is out of range. " nl
								"(displacement=",
								(type int32 eax),
								" and must be in the range -128..+127)."
								nl
							);
							printLineNumberChain( [ebx] );
							raise( ex.ValueOutOfRange );
							
						endif;
						
						
					case( rel1_4_tkn )
					
						// If we've got a 4-byte displacement and
						// it references an external symbol or a symbol
						// that is not in the current section, then we
						// need a relocation record:
						
						if( rel14EBX.curOfsSize = 4 ) then
						
							if( rel14EBX.symbol <> NULL ) then
							
								mov( rel14EBX.symbol, eax );
								mov( tblEAX.Value, eax );
								mov( symEAX.section, dl );
								mov( symEAX.flags, dh );
								and( isExtern_c | isPublic_c, dh );
								if
								( 
										dh = isExtern_c 
									||	dl <> curSection 
								) then
								 
									add( 1, esi );
									
								endif;
								
							endif;
							
						endif;
						


					case( jmp_tkn )
					
						// If we've got a 4-byte displacement and
						// it references an external symbol or a symbol
						// that is not in the current section, then we
						// need a relocation record:
						
						if( jmpEBX.curOfsSize = 4 ) then
						
							if( jmpEBX.symbol <> NULL ) then
							
								mov( jmpEBX.symbol, eax );
								mov( tblEAX.Value, eax );
								mov( symEAX.section, dl );
								mov( symEAX.flags, dh );
								and( isExtern_c | isPublic_c, dh );
								if
								( 
										dh = isExtern_c 
									||	dl <> curSection 
									||	(
												dh
											&&	objType in minElf_c..maxElf_c
										)
								) then
								 
									add( 1, esi );
									
								endif;
								
							endif;
							
						endif;
						
						
							 
					case( rel4_tkn )	 
					
					
						// If we've got a 4-byte displacement and
						// it references an external symbol or a symbol
						// that is not in the current section, then we
						// need a relocation record:
						
						if( rel4EBX.symbol <> NULL ) then
						
							mov( rel4EBX.symbol, eax );
							mov( tblEAX.Value, eax );
							mov( symEAX.section, dl );
							mov( symEAX.flags, dh );
							and( isExtern_c | isPublic_c, dh );
							test( isExtern_c, dh );
							if
							( 
									@nz 
								||	dl <> curSection								 
								||	(
											dh
										&&	objType in minElf_c..maxElf_c
									)
							) then
							 
								add( 1, esi );
								
							endif;
							
						endif;
						
						
							 
					case( reloc_tkn )	 
					
						// reloc_tkn is easy, just bump reloc cnt by 1.
						
						add( 1, esi );
				
				
					 
					default
					
						stderr.put
						( 
							"Internal error: illegal token value:",
							(type uns8 al),
							nl 
						);
						raise( ex.InvalidArgument );
						
				endswitch;
				mov( tknEBX.next, ebx );
				
			endwhile;
			mov( ecx, eax );
			mov( esi, edx );
			pop( esi );
			pop( ecx );
			pop( ebx );
			
		_end( cleanupPass );
		
	_begin( finalPass );
	
		push( eax );
		push( ebx );
		push( ecx );
		push( edx );
		
		cleanupPass( codeList, code_c, objType );
		mov( eax, codeEnd );
		mov( edx, numCodeRelocs );
		
		cleanupPass( dataList, data_c, objType );
		mov( eax, dataEnd );
		mov( edx, numDataRelocs );
		
		cleanupPass( bssList, bss_c, objType );
		mov( eax, bssEnd );
		if( edx <> 0 ) then
		
			stderr.put( "Internal error (relocations in BSS section)" nl );
			raise( ex.ValueOutOfRange );
					
		endif;
		
		// Make sure all the referenced symbols are also defined:
		
		foreach symbolTable.item() do
		
			mov( (type tableNode_t [eax]).Value, ebx );
			assert( ebx <> NULL );
			mov( symEBX.flags, cl );
			and( isReferenced_c | isDefined_c | isExtern_c, cl );
			if( cl = isReferenced_c ) then
			
				stderr.put
				( 
					"Undefined symbol: ", 
					(type tableNode_t [eax]).id, 
					nl 
				);
				raise( ex.InvalidArgument );
				
			endif; 
		endfor;
		
		pop( edx );
		pop( ecx );
		pop( ebx );
		pop( eax );
		
	_end( finalPass );
	

	
	 

_begin( optimizeDisps );

	if( verboseDebug ) then
	
		stdout.put( "optimizeDisps:" nl );
		
	endif;
	firstPass
	( 
		codeList,
		dataList,
		bssList,
		1,
		objType	
	);
	
	dispPhase( codeList, dataList, bssList, 4, objType );
	mov( eax, passes );
	if( eax > 16384 ) then

		stdout.put
		( 
			"Could not optimize (small->large) in 16,384 passes." nl
			"Reverting to large->small optimization." nl
		);
		firstPass
		( 
			codeList,
			dataList,
			bssList,
			4,
			objType	
		);
		mov( eax, codeRelocs );
		mov( edx, dataRelocs );
		
		dispPhase( codeList, dataList, bssList, 1, objType );
		mov( eax, passes );
	
		finalPass( codeList, dataList, bssList, objType );		
		if( verbose ) then
		
			stdout.put( "Optimization passes: ", passes, "+16386" nl );
			
		endif;
		
		
	else
	
		finalPass( codeList, dataList, bssList, objType );
		if( verbose ) then
		
			stdout.put( "Optimization passes: ", passes, "+2" nl );
			
		endif;
		
	endif;
	mov( codeEnd, eax );
	sub( codeStart, eax );
	mov( eax, codeSize );
	
	mov( dataEnd, eax );
	sub( dataStart, eax );
	mov( eax, dataSize );
	
	mov( bssEnd, eax );
	sub( bssStart, eax );
	mov( eax, bssSize );
	
_end( optimizeDisps );


///////////////////////////////////////////////////////////////////////////////
//
// generateCOFF-
//
//	Generates a PE/COFF file.

_proc( generateCOFF )
(
	inputFilename	:string;
	outputFilename	:string; 
	codeList		:tokenList_t;
	dataList		:tokenList_t;
	bssList			:tokenList_t
);
var
	DMY					:date.daterec;
	HMS					:time.timerec;
	uTime				:dword;
	
	CoffFileHeader		:w.IMAGE_FILE_HEADER;
	
	codeSectionHeader	:w.IMAGE_SECTION_HEADER;
	dataSectionHeader	:w.IMAGE_SECTION_HEADER;
	bssSectionHeader	:w.IMAGE_SECTION_HEADER;
	
	codeRelocations		:pRelocations;
	dataRelocations		:pRelocations;
	
	rawCode				:pByte;
	rawData				:pByte;
	
	textSection			:dword;
	dataSection			:dword;
	bssSection			:dword;
	
	COFFfile			:dword;
	COFFsize			:dword;
	fileHandle			:dword;
	
	
	
type
	Section: record	//  Section
		Length				:dword;		// section length
		NumberOfRelocations	:word;		// number of relocation entries
		NumberOfLinenumbers	:word;		// number of line numbers
		CheckSum			:dword;		// checksum for communal
		Number				:dword;		// section number to associate with
		Selection			:byte;		// communal selection type
	endrecord;

static
	CodeAuxSection		:Section :=
							Section:
							[
								0,	// section length
								0,	// number of relocation entries
								0,	// number of line numbers
								0,	// checksum for communal
								1,	// section number to associate with
								0	// communal selection type
							];

	DataAuxSection		:Section :=
							Section:
							[
								0,	// section length
								0,	// number of relocation entries
								0,	// number of line numbers
								0,	// checksum for communal
								2,	// section number to associate with
								0	// communal selection type
							];

	BssAuxSection		:Section :=
							Section:
							[
								0,	// section length
								0,	// number of relocation entries
								0,	// number of line numbers
								0,	// checksum for communal
								3,	// section number to associate with
								0	// communal selection type
							];
							
			
	_proc( getSymbol )
	( 
		index	:dword; 
		destStr	:string 
	);
	var
	_begin( getSymbol );
	
		push( eax );
		push( ebx );
		
		// Compute the address of the COFF symbol table entry specified
		// by index:
		
		intmul( @size( w.IMAGE_SYMBOL), index, ebx );
		add( COFFsyms, ebx );
		
		mov( coffSymEBX.N.LongName[0], eax );
		if( eax <> 0 ) then
		
			push( (type dword coffSymEBX.N.LongName[2*4]));
			mov( 0, (type dword coffSymEBX.N.LongName[2*4]));
			lea( eax, (type dword coffSymEBX.N.LongName[0*4]));
			str.cpyz( (type zstring eax), destStr );
			pop( (type dword coffSymEBX.N.LongName[2*4]));
			
		else
		
			mov( coffSymEBX.N.LongName[1*4], eax );
			add( stringTable, eax );
			str.cpyz( (type zstring eax), destStr );
			
		endif;
		pop( ebx );
		pop( eax );
		 
	_end( getSymbol );	
	
				
							
	_proc( dumpRelocs )
	( 
		msg			:string; 
		relocPtr	:dword; 
		numRelocs	:uns32 
	);
	var
		symStr	:string;
		symBuf	:char[1024];
		
		
	_begin( dumpRelocs );
	
		push( eax );
		push( ebx );
		push( ecx );
		
		str.init( symBuf, 1024 );
		mov( eax, symStr );
		
		stdout.put( nl, msg, nl nl );
		mov( relocPtr, ebx );
		for( mov( 0, ecx ); ecx < numRelocs; inc( ecx )) do
		
			getSymbol( (type w.IMAGE_RELOCATION [ebx]).SymbolTableIndex, symStr );
			stdout.put
			( 
				(type uns32 ecx), 
				": ", 
				(type w.IMAGE_RELOCATION [ebx]).VirtualAddress,
				", '",
				symStr,
				"', "
			);
			movzx( (type w.IMAGE_RELOCATION [ebx]).Type1, eax );
			switch( eax )
			
				case( w.IMAGE_REL_I386_ABSOLUTE )
					stdout.put( "IMAGE_REL_I386_ABSOLUTE" );
					
				case( w.IMAGE_REL_I386_DIR32 )
					stdout.put( "IMAGE_REL_I386_DIR32" );
					
				case( w.IMAGE_REL_I386_DIR32NB );
					stdout.put( "IMAGE_REL_I386_DIR32NB" );
					
				case( w.IMAGE_REL_I386_REL32 )
					stdout.put( "IMAGE_REL_I386_REL32" );
					
				default
					stdout.put( "???? relocation type = $", eax );
					
			endswitch;  
			stdout.newln();
			add( @size( w.IMAGE_RELOCATION ), ebx );
			
		endfor;
		
		pop( ecx );
		pop( ebx );
		pop( eax );
		
		
	_end( dumpRelocs );

_begin( generateCOFF );

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	push( esi ); 
	push( edi );
	
	if( verboseDebug ) then
	
		stdout.put
		(
			"generateCOFF:" nl 
			"Input filename:  ", inputFilename, nl 
			"Output filename: ", outputFilename, nl 
		);
		
	endif;
	
	
	// Initial strings table size will be 64K
	
	mov( 65536, strTblSize );
	mem.alloc( 65536 );
	mov( eax, stringTable );
	mov( 4, strTblOffset );
	
	// Initial symbol table size will be 4096 symbols
	
	mem.alloc( 4096 * @size( w.IMAGE_SYMBOL ));
	mov( eax, COFFsyms );
	mov( eax, ebx );
	mov( 4096 * @size( w.IMAGE_SYMBOL ), coffSymSize );
	mov( 0, numCOFFsyms );
	
	
	// Write the filename record to the COFF symbol table:
	
	mov( '.', coffSymEBX.N.ShortName[0] );
	mov( 'f', coffSymEBX.N.ShortName[1] );
	mov( 'i', coffSymEBX.N.ShortName[2] );
	mov( 'l', coffSymEBX.N.ShortName[3] );
	mov( 'e', coffSymEBX.N.ShortName[4] );
	mov( 0, coffSymEBX.N.ShortName[5] );
	mov( 0, coffSymEBX.N.ShortName[6] );
	mov( 0, coffSymEBX.N.ShortName[7] );

	mov( 0, coffSymEBX.Value );
	mov( w.IMAGE_SYM_DEBUG, coffSymEBX.SectionNumber );
	mov( w.IMAGE_SYM_TYPE_NULL, coffSymEBX.Type1 );
	mov( w.IMAGE_SYM_CLASS_FILE, coffSymEBX.StorageClass );
	
	str.length( inputFilename );			// Don't forget to allow for zero byte.
	add( @size( w.IMAGE_SYMBOL ), eax );	// Round up if remainder <> 0 
	xor( edx, edx );
	div( @size( w.IMAGE_SYMBOL ), edx:eax );
	mov( al, coffSymEBX.NumberOfAuxSymbols );
	add( 1, eax );							// Add in ".file" symbol
	mov( eax, numCOFFsyms );

	// Copy the actual filename:
	
	lea( eax, [ebx+@size(w.IMAGE_SYMBOL)] ); 	
	zstr.cpy( (type zstring inputFilename), eax ); 
	
	
	
	// Write the .text section record to the COFF symbol table:
	
	mov( numCodeRelocs, eax );
	if( eax >= $ffff ) then
	
		mov( $ffff, ax );
		add( 1, numCodeRelocs );	// Allow for size added to reloc table
		
	endif;
	mov( ax, CodeAuxSection.NumberOfRelocations );
	mov( codeSize, eax );
	mov( eax, CodeAuxSection.Length );
	addCOFFsym
	(
		".text",
		0,							// Offset
		1,							// Section #
		0,							// Type -- not a function value.
		w.IMAGE_SYM_CLASS_STATIC,	// Storage class
		1,							// # of aux symbols
		&CodeAuxSection				// Empty initial aux section data
	);
	add( COFFsyms, eax );
	mov( eax, textSection );




	// Write the .data section record to the COFF symbol table:
	
	mov( numDataRelocs, eax );
	if( eax >= $ffff ) then
	
		mov( $ffff, ax );
		add( 1, numDataRelocs );	// Allow for size added to reloc table
		
	endif;
	mov( ax, DataAuxSection.NumberOfRelocations );
	mov( dataSize, eax );
	mov( eax, DataAuxSection.Length );
	addCOFFsym
	(
		".data",
		0,							// Offset
		2,							// Section #
		0,							// Type -- not a function value.
		w.IMAGE_SYM_CLASS_STATIC,	// Storage class
		1,							// # of aux symbols
		&DataAuxSection				// Empty initial aux section data
	);
	add( COFFsyms, eax );
	mov( eax, dataSection );
	  


	// Write the .bss section record to the COFF symbol table:
	
	mov( bssSize, eax );
	mov( eax, BssAuxSection.Length );
	addCOFFsym
	(
		".bss",
		0,							// Offset
		3,							// Section #
		0,							// Type -- not a function value.
		w.IMAGE_SYM_CLASS_STATIC,	// Storage class
		1,							// # of aux symbols
		&BssAuxSection				// Empty initial aux section data
	);
	add( COFFsyms, eax );
	mov( eax, bssSection );
	  



	// Copy all the symbols from the generic symbol table to
	// the COFF symbol table:
	
	foreach symbolTable.item() do
	
		mov( eax, edx );
		mov( (type tableNode_t [edx]).Value, ebx );
		movzx( symEBX.section, cx );
		mov( symEBX.offset, edi );
		test( isExtern_c, symEBX.flags );
		if( @nz ) then
		
			// External symbols have storage class
			// w.IMAGE_SYM_CLASS_EXTERNAL, a section number
			// of zero, and an offset of zero.
			
			mov( w.IMAGE_SYM_CLASS_EXTERNAL, al );
			mov( w.IMAGE_SYM_UNDEFINED, cx );
			xor( edi, edi );
			
		else
		
			test( isPublic_c, symEBX.flags );
			if( @nz ) then
			
				// Public symbols have storage class
				// w.IMAGE_SYM_CLASS_EXTERNAL and a section
				// number that is not zero.
				
				mov( w.IMAGE_SYM_CLASS_EXTERNAL, al );
				
				
			else	// Standard symbol
			
				mov( w.IMAGE_SYM_CLASS_STATIC, al );
				
			endif;
			
		endif; 
		
		addCOFFsym
		(
			(type tableNode_t [edx]).id,
			symEBX.offset,
			cx,
			0,		// Type -- not a function value.
			al,		// Storage class
			0,		// # of aux symbols
			NULL	// No aux symbols data
		);
		
		// Save index to this COFF symbol table entry so
		// we can quickly find it when generating all the reloc data.
		
		mov( eax, symEBX.symIndex );
			
			
	endfor;	


	// Initialize the COFF file header:
	
	// It's an x86 (32-bit):
	
	mov( w.IMAGE_FILE_MACHINE_I386, CoffFileHeader.Machine );
	
	// Start off assuming we have three sections (code, data, bss):
	
	mov( 3, CoffFileHeader.NumberOfSections );
	
	// Get the timestamp value
	
	time.utcDateTime( DMY, HMS );
	time.toUnixTime( DMY, HMS);
	mov( eax, CoffFileHeader.TimeDateStamp );

	// Generic initialization to be replace later:
	
	mov( 0, CoffFileHeader.PointerToSymbolTable );
	mov( 0, CoffFileHeader.NumberOfSymbols );
	
	// Optional Header size is zero for object files:
	
	mov( 0, CoffFileHeader.SizeOfOptionalHeader );
	
	// Flags for the object file:
	
	mov( w.IMAGE_FILE_32BIT_MACHINE, CoffFileHeader.Characteristics );
	
	
	// Fill in the three section headers, starting with the code section:
	
	mov( '.', codeSectionHeader.Name1[0] );
	mov( 't', codeSectionHeader.Name1[1] );
	mov( 'e', codeSectionHeader.Name1[2] );
	mov( 'x', codeSectionHeader.Name1[3] );
	mov( 't', codeSectionHeader.Name1[4] );
	mov( 0, codeSectionHeader.Name1[5] );
	mov( 0, codeSectionHeader.Name1[6] );
	mov( 0, codeSectionHeader.Name1[7] );
	
	mov( codeSize, eax );
	mov( eax, codeSectionHeader.Misc.VirtualSize );
	mov( eax, codeSectionHeader.SizeOfRawData );
	mem.alloc( eax );
	mov( eax, rawCode );
	
	mov( numCodeRelocs, edx );
	if( edx < $ffff ) then
	
		mov( dx, codeSectionHeader.NumberOfRelocations );
		movzx( dx, eax );
		intmul( @size( w.IMAGE_RELOCATION ), eax );
		mem.alloc( eax );
		mov( eax, codeRelocations );
		mov
		(
				w.IMAGE_SCN_CNT_CODE
			|	w.IMAGE_SCN_ALIGN_16BYTES
			|	w.IMAGE_SCN_MEM_EXECUTE
			|	w.IMAGE_SCN_MEM_READ,
			codeSectionHeader.Characteristics
		);
		
	else
	
		// For 65,535 or more relocations, we must set the NumberOfRelocations
		// to $FFFF and set the IMAGE_SCN_LNK_NRELOC_OVFL bit to denote
		// a 32-bit relocation count.
		
		mov( $FFFF, codeSectionHeader.NumberOfRelocations );
		intmul( @size( w.IMAGE_RELOCATION ), edx, eax );
		mem.alloc( eax );
		mov( eax, codeRelocations );
		
		// Initialize the first relocation record with the actual
		// number of relocation records.
		
		mov( edx, (type w.IMAGE_RELOCATION [eax]).RelocCount );
		mov( 0, (type w.IMAGE_RELOCATION [eax]).SymbolTableIndex );
		mov( 0, (type w.IMAGE_RELOCATION [eax]).Type1 );
		mov
		(
				w.IMAGE_SCN_CNT_CODE
			|	w.IMAGE_SCN_ALIGN_16BYTES
			|	w.IMAGE_SCN_LNK_NRELOC_OVFL
			|	w.IMAGE_SCN_MEM_EXECUTE
			|	w.IMAGE_SCN_MEM_READ,
			codeSectionHeader.Characteristics
		);
		
	endif;
	
	mov( 0, codeSectionHeader.VirtualAddress );
	mov( 0, codeSectionHeader.PointerToRawData );
	mov( 0, codeSectionHeader.PointerToRelocations );
	mov( 0, codeSectionHeader.PointerToLinenumbers );
	mov( 0, codeSectionHeader.NumberOfLinenumbers );
	
	buildRaw
	( 
		codeList,
		codeStart, 
		codeRelocations, 
		numCodeRelocs, 
		rawCode, 
		code_c, 
		pecoff_c 
	);  
	


	// Now fill in the DATA section:
	
	mov( '.', dataSectionHeader.Name1[0] );
	mov( 'd', dataSectionHeader.Name1[1] );
	mov( 'a', dataSectionHeader.Name1[2] );
	mov( 't', dataSectionHeader.Name1[3] );
	mov( 'a', dataSectionHeader.Name1[4] );
	mov( 0, dataSectionHeader.Name1[5] );
	mov( 0, dataSectionHeader.Name1[6] );
	mov( 0, dataSectionHeader.Name1[7] );
	
	mov( dataSize, eax );
	mov( eax, dataSectionHeader.Misc.VirtualSize );
	mov( eax, dataSectionHeader.SizeOfRawData );
	mem.alloc( eax );
	mov( eax, rawData );

	mov( numDataRelocs, edx );
	if( edx < $ffff ) then
	
		mov( dx, dataSectionHeader.NumberOfRelocations );
		movzx( dx, eax );
		intmul( @size( w.IMAGE_RELOCATION ), eax );
		mem.alloc( eax );
		mov( eax, dataRelocations );
		mov
		(
				w.IMAGE_SCN_CNT_INITIALIZED_DATA
			|	w.IMAGE_SCN_ALIGN_16BYTES
			|	w.IMAGE_SCN_MEM_WRITE
			|	w.IMAGE_SCN_MEM_READ,
			dataSectionHeader.Characteristics
		);
		
	else
	
		mov( $FFFF, dataSectionHeader.NumberOfRelocations );
		intmul( @size( w.IMAGE_RELOCATION ), edx, eax );
		mem.alloc( eax );
		mov( eax, dataRelocations );
		
		mov( edx, (type w.IMAGE_RELOCATION [eax]).RelocCount );
		mov( 0, (type w.IMAGE_RELOCATION [eax]).SymbolTableIndex );
		mov( 0, (type w.IMAGE_RELOCATION [eax]).Type1 );
		mov
		(
				w.IMAGE_SCN_CNT_INITIALIZED_DATA
			|	w.IMAGE_SCN_ALIGN_16BYTES
			|	w.IMAGE_SCN_LNK_NRELOC_OVFL
			|	w.IMAGE_SCN_MEM_WRITE
			|	w.IMAGE_SCN_MEM_READ,
			dataSectionHeader.Characteristics
		);
		
	endif;
	
	mov( 0, dataSectionHeader.VirtualAddress );
	mov( 0, dataSectionHeader.PointerToRawData );
	mov( 0, dataSectionHeader.PointerToRelocations );
	mov( 0, dataSectionHeader.PointerToLinenumbers );
	mov( 0, dataSectionHeader.NumberOfLinenumbers );

	buildRaw
	( 
		dataList,
		dataStart, 
		dataRelocations, 
		numDataRelocs, 
		rawData, 
		data_c, 
		pecoff_c 
	);  

	
	

	// Now fill in the BSS section:
	
	mov( '.', bssSectionHeader.Name1[0] );
	mov( 'b', bssSectionHeader.Name1[1] );
	mov( 's', bssSectionHeader.Name1[2] );
	mov( 's', bssSectionHeader.Name1[3] );
	mov( 0, (type dword bssSectionHeader.Name1[4]) );
	
	mov( bssSize, eax );	
	mov( eax, bssSectionHeader.SizeOfRawData );
	mov( 0, bssSectionHeader.Misc.VirtualSize );
	mov( 0, bssSectionHeader.NumberOfRelocations );
	
	mov( 0, bssSectionHeader.VirtualAddress );
	mov( 0, bssSectionHeader.PointerToRawData );
	mov( 0, bssSectionHeader.PointerToRelocations );
	mov( 0, bssSectionHeader.PointerToLinenumbers );
	mov( 0, bssSectionHeader.NumberOfLinenumbers );
	mov
	(
			w.IMAGE_SCN_CNT_UNINITIALIZED_DATA
		|	w.IMAGE_SCN_ALIGN_16BYTES
		|	w.IMAGE_SCN_MEM_WRITE
		|	w.IMAGE_SCN_MEM_READ,
		bssSectionHeader.Characteristics
	);
	
	
	
	// Okay, time to build the actual COFF file and write it to disk.
	// Begin by computing the size of the COFF file.
	//
	//                                   Size
	// +----------------------------+
	// |  COFF File Header          |    w.IMAGE_FILE_HEADER
	// +----------------------------+
	// |  .text Section Header      |    w.IMAGE_SECTION_HEADER
	// +----------------------------+
	// |  .data Section Header      |    w.IMAGE_SECTION_HEADER
	// +----------------------------+
	// |  .bss Section Header       |    w.IMAGE_SECTION_HEADER
	// +----------------------------+
	// |  Raw Code                  |    codeSize
	// +----------------------------+
	// |  Code Relocations          |    numCodeRelocs * w.IMAGE_RELOCATION
	// +----------------------------+
	// |  Raw Data                  |    dataSize
	// +----------------------------+
	// |  Data Relocations          |    numDataRelocs * w.IMAGE_RELOCATION
	// +----------------------------+
	// |  COFF Symbol Table         |    numCOFFsyms * w.IMAGE_SYMBOL
	// +----------------------------+
	// |  COFF Strings Table        |    strTblOffset
	// +----------------------------+

	// Compute the size of the COFF file. While we're doing this, also
	// fill in various file header and section header fields. Note that
	// all of the sections above must be dword aligned.
	
	mov
	(
		@size( w.IMAGE_FILE_HEADER ) +
			3 * @size( w.IMAGE_SECTION_HEADER ),
		ecx
	);
	mov( ecx, codeSectionHeader.PointerToRawData );	// Already dword aligned
	add( codeSize, ecx );
	add( 3, ecx );				// Dword-align the code relocation section
	and( $FFFF_FFFc, ecx );
	
	mov( ecx, codeSectionHeader.PointerToRelocations );
	intmul( @size( w.IMAGE_RELOCATION ), numCodeRelocs, eax );
	add( eax, ecx );
	add( 3, ecx );				// Dword-align the raw data section
	and( $FFFF_FFFc, ecx );

	 	
	mov( ecx, dataSectionHeader.PointerToRawData );	
	add( dataSize, ecx );
	add( 3, ecx );				// Dword-align the data relocation section
	and( $FFFF_FFFc, ecx );
	
	mov( ecx, dataSectionHeader.PointerToRelocations );
	intmul( @size( w.IMAGE_RELOCATION ), numDataRelocs, eax );
	add( eax, ecx );
	
	
	// At this point, ECX contains the offset to the COFF symbol table.
	// Use this value to fill in the CoffFileHeader.PointerToSymbolTable
	// field in the COFF file header:
	
	mov( ecx, CoffFileHeader.PointerToSymbolTable );
	mov( numCOFFsyms, eax );
	mov( eax, CoffFileHeader.NumberOfSymbols );
	intmul( @size( w.IMAGE_SYMBOL ), eax );
	add( eax, ecx );
	
	
	add( strTblOffset, ecx );
	mov( ecx, COFFsize );
	
		
	// Allocate storage for the COFF file:
	
	mem.zalloc( ecx );
	mov( eax, COFFfile );
	
	// Okay, copy all the data to the block of memory we just allocated:
	
	mov( COFFfile, edi );
	lea( esi, CoffFileHeader );
	mov( @size( w.IMAGE_FILE_HEADER ), ecx );
	cld();
	rep.movsb();
	
	lea( esi, codeSectionHeader );
	mov( @size( w.IMAGE_SECTION_HEADER ), ecx );
	rep.movsb(); 
	
	lea( esi, dataSectionHeader );
	mov( @size( w.IMAGE_SECTION_HEADER ), ecx );
	rep.movsb(); 
	
	lea( esi, bssSectionHeader );
	mov( @size( w.IMAGE_SECTION_HEADER ), ecx );
	rep.movsb();
	
	mov( rawCode, esi );
	mov( codeSize, ecx );
	rep.movsb();
	
	add( 3, edi );				// Dword align the code relocations
	and( $FFFF_FFFc, edi );
	
	mov( codeRelocations, esi );
	intmul( @size( w.IMAGE_RELOCATION ), numCodeRelocs, ecx );
	rep.movsb();
	
	add( 3, edi );				// Dword align the raw data
	and( $FFFF_FFFc, edi );
	
	mov( rawData, esi );
	mov( dataSize, ecx );
	rep.movsb();
	
	add( 3, edi );				// Dword align the data relocations
	and( $FFFF_FFFc, edi );
	
	mov( dataRelocations, esi );
	intmul( @size( w.IMAGE_RELOCATION ), numDataRelocs, ecx );
	rep.movsb();
	
	mov( COFFsyms, esi );
	intmul( @size( w.IMAGE_SYMBOL ), numCOFFsyms, ecx );
	rep.movsb();
	
	mov( stringTable, esi );
	mov( strTblOffset, eax );
	stosd();
	add( 4, esi );
	lea( ecx, [eax-4] );
	rep.movsb();
	
	// Okay, write the file to disk:
	
	fileio.openNew( outputFilename );
	mov( eax, fileHandle );
	fileio.write( fileHandle, val COFFfile, COFFsize );
	fileio.close( fileHandle );
	
	
	
	
	if( verboseDebug ) then
	
		// For debugging, dump the COFF file data:
		
		
		// Dump the symbol table:
		
		stdout.put( nl "COFF Symbol table (#syms: ", numCOFFsyms, ")" nl nl );
		mov( COFFsyms, ebx );
		xor( ecx, ecx );
		while( ecx < numCOFFsyms ) do
		
			stdout.put( (type uns32 ecx), ": " );
			mov( coffSymEBX.N.LongName[0], eax );
			if( eax = 0 ) then	// Long name
			
				mov( coffSymEBX.N.LongName[4], eax );
				add( stringTable, eax );
				stdout.putz( eax );
			
			else // Short name
			
				push( (type dword [ebx+8]) );
				mov( 0, (type dword [ebx+8]));
				
				stdout.putz( ebx );
				pop( (type dword [ebx+8]));
			
			endif;
			stdout.put( " :" );
			
			if( coffSymEBX.StorageClass = w.IMAGE_SYM_CLASS_FILE ) then
			
				lea( eax, [ebx+@size( w.IMAGE_SYMBOL)]);
				stdout.putz( eax );
				
			elseif( coffSymEBX.StorageClass = w.IMAGE_SYM_CLASS_STATIC ) then
			
				stdout.put( "static" );
				
			elseif( coffSymEBX.StorageClass = w.IMAGE_SYM_CLASS_EXTERNAL ) then
			
				if( coffSymEBX.SectionNumber = w.IMAGE_SYM_UNDEFINED ) then  

					stdout.put( "external" );
				
				else
				
					stdout.put( "public" );
					
				endif;
				
			else
			
				stdout.put( "????" );
				
			endif;
			stdout.newln();
			
			movzx( coffSymEBX.NumberOfAuxSymbols, eax );
			add( 1, eax );
			add( eax, ecx );
			intmul( @size( w.IMAGE_SYMBOL), eax );
			add( eax, ebx );
			 
		endwhile;
		
		
		// Dump the relocation records:
		
		dumpRelocs( "Code Section Relocations:", codeRelocations, numCodeRelocs );
		dumpRelocs( "Data Section Relocations:", dataRelocations, numDataRelocs );
		 		
	endif;
	
	pop( edi );
	pop( esi );
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );
		
_end( generateCOFF );


	
///////////////////////////////////////////////////////////////////////////////
//
// generateELF-
//
//	Generates an ELF file.
//
// Here's the ELF file layout this program produces:
//
//                                   Size
// +------------------------------+
// |  ELF File Header             |    Elf32_Ehdr
// +------------------------------+
//  Section Header Table:
// +------------------------------+
// |  0: NULL Section Header      |    Elf32_Shdr
// +------------------------------+
// |  1: .shstrtab Section Header |    Elf32_Shdr
// +------------------------------+
// |  2: .symtab Section Header   |    Elf32_Shdr
// +------------------------------+
// |  3: .strtab Section Header   |    Elf32_Shdr
// +------------------------------+
// |  4: .text Section Header     |    Elf32_Shdr
// +------------------------------+
// |  5: .data Section Header     |    Elf32_Shdr
// +------------------------------+
// |  6: .bss Section Header      |    Elf32_Shdr
// +------------------------------+
// |  x: .rel.text Section Header |    Elf32_Shdr (optional)
// +------------------------------+
// |  x: .rel.data Section Header |    Elf32_Shdr (optional)
// +------------------------------+
//
// +------------------------------+
// |  sh_strtable                 |    strTblLen_c
// +------------------------------+
// |  ELF Symbol Table            |    numELFsyms * Elf32_Sym
// +------------------------------+
// |  ELF Strings Table           |    strTblOffset
// +------------------------------+
//	  The following sections
//    are optional
// +------------------------------+
// |  Raw Code                    |    codeSize
// +------------------------------+
// |  Code Relocations            |    numCodeRelocs * Elf32_Rel
// +------------------------------+
// |  Raw Data                    |    dataSize
// +------------------------------+
// |  Data Relocations            |    numDataRelocs * Elf32_Rel
// +------------------------------+
	


_proc( generateELF )
(
	inputFilename	:string;
	outputFilename	:string; 
	codeList		:tokenList_t;
	dataList		:tokenList_t;
	bssList			:tokenList_t;
	brand			:obj_t
);

		
var
	numSections			:dword;
	shstrtab			:zstring;
	
	ElfFile				:dword;
	ELFsize				:dword;
	fileHandle			:dword;
	ElfFileHeader		:Elf32_Ehdr;
	codeRelocations		:pRelocations;
	dataRelocations		:pRelocations;
	
	rawCode				:pByte;
	rawData				:pByte;
	
	shOffset			:dword;
	shSize				:dword;
	
	shstrTabOffset		:dword;
	shstrtabSize		:dword;
	
	symtabOffset		:dword;
	symtabSize			:dword;
	
	strtabOffset		:dword;
	codeOffset			:dword;
	relCodeOffset		:dword;
	dataOffset			:dword;
	relDataOffset		:dword;
	bssOffset			:dword;
	
	shst_textIndex		:dword;
	shst_dataIndex		:dword;
	shst_bssIndex		:dword;
	
	
static
	
	

	NULLsection		:Elf32_Shdr := Elf32_Shdr:[ 0,0,0,0,0,0,0,0,0,0 ];
	
	shstrtabSection	:Elf32_Shdr :=
			Elf32_Shdr:
			[
				1,				// Offset to ".shstrtab" in string table
				SHT_STRTAB,
				0,				// Flags
				0,				// Address
				0,				// Offset	-- TBD
				0,				// Size		-- TBD
				0,				// Link
				0,				// Info
				1,				// Align
				0				// entSize	
			];
					
	symtabSection	:Elf32_Shdr :=
			Elf32_Shdr:
			[
				0,					// ".symtab" in string table -- TBD
				SHT_SYMTAB,
				0,					// Flags
				0,					// Address
				0,					// Offset	- TBD
				0,					// Size		- TBD
				3,					// Link -- Strings section header index
				0,					// Info -- Number of local symbols (TBD)
				4,					// Align
				@size(Elf32_Sym)	// entSize	
			];
					
	strtabSection	:Elf32_Shdr :=
			Elf32_Shdr:
			[
				0,					// ".strtab" in string table -- TBD
				SHT_STRTAB,
				0,	// Flags
				0,	// Address
				0,	// Offset	- TBD
				0,	// Size		- TBD
				0,	// Link
				0,	// Info
				1,	// Align
				0	// entSize	
			];
	
	
	textSection		:Elf32_Shdr :=
			Elf32_Shdr:
			[
				0,					// ".text" in string table -- TBD
				SHT_PROGBITS,
				SHF_ALLOC | SHF_EXECINSTR,
				0,	// Address
				0,	// Offset - TBD
				0,	// Size   - TBD
				0,	// Link
				0,	// Info
				4,	// Align
				0	// entSize	
			];
	
	dataSection		:Elf32_Shdr :=
			Elf32_Shdr:
			[
				0,					// ".data" in string table -- TBD
				SHT_PROGBITS,
				SHF_ALLOC | SHF_WRITE,
				0,	// Address
				0,	// Offset - TBD
				0,	// Size   - TBD
				0,	// Link
				0,	// Info
				4,	// Align
				0	// entSize	
			];
			

	bssSection		:Elf32_Shdr :=			
			Elf32_Shdr:
			[
				0,					// ".bss" in strings table -- TBD
				SHT_NOBITS,
				SHF_ALLOC | SHF_WRITE,
				0,					// Address
				0,					// Offset -- TBD
				0,					// Size   -- TBD
				0,					// Link
				0,					// Info
				4,					// Align
				0					// entSize	
			];


	relTextSection	:Elf32_Shdr :=
			Elf32_Shdr:
			[
				0,					// ".rel.text" in string table -- TBD
				SHT_REL,
				0,					// Flags
				0,					// Address
				0,					// Offset - TBD
				0,					// Size   - TBD
				2,					// Link - symtab section header
				4,					// Info - text section header
				4,					// Align
				@size( Elf32_Rel )	// entSize	
			];
			

	relDataSection	:Elf32_Shdr :=			
			Elf32_Shdr:
			[
				0,					// ".rel.data" in strings table -- TBD
				SHT_REL,
				0,					// Flags
				0,					// Address
				0,					// Offset - TBD
				0,					// Size   - TBD
				2,					// Link - symtab section header
				5,					// Info - data section header
				4,					// Align
				@size( Elf32_Rel )	// entSize	
			];
			
			
	
		
_begin( generateELF );

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	push( esi ); 
	push( edi );
	
	if( verboseDebug ) then
	
		stdout.put
		(
			"generateELF:" nl 
			"Input filename:  ", inputFilename, nl 
			"Output filename: ", outputFilename, nl 
		);
		
	endif;
		
	
	
	
	// There are at least sections:
	//
	//	0	:null		
	//	1	:.shstrtab	
	//	2	:.symtab	
	//	3	:.strtab	
	//	4	:.text		
	//	5	:.data		
	//	6	:.bss
	//
	// Plus the following two optional sections which are present if there
	// are any code or data relocations:
	//		
	//	7	:.rel.text	
	//	8	:.rel.data	
	
	// Construct the shstrtab data section.
	// Begin by allocating the maximum amount of storage we'll need
	// for the section's data: 
	
	mem.zalloc
	(
		1 +
		@length( ".shstrtab" )	+ 1 +
		@length( ".symtab" )	+ 1 +
		@length( ".strtab" )	+ 1 +
		@length( ".text" )		+ 1 +
		@length( ".data" )		+ 1 +
		@length( ".bss" )		+ 1 +
		@length( ".rel.text" )	+ 1 +
		@length( ".rel.data" )	+ 1
	);
	mov( eax, shstrtab );
	
	// Fill in the section header string table
	
	mov( 4, shst_textIndex );
	mov( 5, shst_dataIndex );
	mov( 6, shst_bssIndex );
	
	lea( edi, [eax+1] );			// Leave an empty string at offset 0.
	mov( 1, shstrtabSection.sh_name );
	zstr.cpy( ".shstrtab", edi );
	lea( edi, [edi+eax+1] );
		
	mov( @length( ".shstrtab" )	+ 2, symtabSection.sh_name );
	zstr.cpy( ".symtab", edi );
	lea( edi, [edi+eax+1] );
	
	mov
	(
		@length( ".shstrtab" ) + @length( ".symtab" ) + 3,
		strtabSection.sh_name
	); 
	zstr.cpy( ".strtab", edi );
	lea( edi, [edi+eax+1] );
	
	mov
	(
		@length( ".shstrtab" ) + @length( ".symtab" ) + 
			@length( ".strtab" ) + 4,
		ebx
	); 
	
	// Set up the text section:
	
	mov( ebx, textSection.sh_name );
	add( @length( ".text" ) + 1, ebx );
	
	zstr.cpy( ".text", edi );
	lea( edi, [edi+eax+1] );
	
	// Set up the data section:
	
	mov( ebx, dataSection.sh_name );
	add( @length( ".data" ) + 1, ebx );
	
	zstr.cpy( ".data", edi );
	lea( edi, [edi+eax+1] );
		
	
	// Set up the bss section:
	
	
	mov( ebx, bssSection.sh_name );
	add( @length( ".bss" ) + 1, ebx );
	
	zstr.cpy( ".bss", edi );
	lea( edi, [edi+eax+1] );
	
	
	
	// Although the rel.text and rel.data sections are
	// optional, we will always add their names to the
	// section header string table (it's okay if there
	// is extra data in the table, so we will put it 
	// there just be consistent).
	//
	// Set up the rel.text section:
	
	mov( ebx, relTextSection.sh_name );
	add( @length( ".rel.text" ) + 1, ebx );

	zstr.cpy( ".rel.text", edi );
	lea( edi, [edi+eax+1] );
	
	
	// Set up the rel.data section:
		
		
	mov( ebx, relDataSection.sh_name );
	add( @length( ".rel.data" ) + 1, ebx );
	
	zstr.cpy( ".rel.data", edi );
	lea( edi, [edi+eax+1] );
	
	
	// Save the section header string table size:
	
	mov( ebx, shstrtabSize );
	
	
	// Set the size of the section header table:
	
	mov( 7, numSections );
	if( numCodeRelocs <> 0 ) then
	
		add( 1, numSections );
		
	endif;
	if( numDataRelocs <> 0 ) then
	
		add( 1, numSections );
		
	endif;
	intmul( @size( Elf32_Shdr ), numSections, eax );
	mov( eax, shSize );	
	
		 
	
	
	// Construct the ELF symbol table and the ELF strings table.
	//	 
	// Initial strings table size will be 256K
	
	mov( 256*1024, strTblSize );
	mem.zalloc( 256*1024 );
	mov( eax, stringTable );
	mov( 1, strTblOffset );
	
	// Initial symbol table size will be 65536 symbols
	
	mem.zalloc( 65536 * @size( Elf32_Sym ));
	mov( eax, ELFsyms );
	mov( eax, ebx );
	mov( 65536 * @size( Elf32_Sym ), elfSymSize );
	mov( 1, numELFsyms );	// Must have one dummy entry.
	
	// Copy all the symbols from the generic symbol table to
	// the ELF symbol table.  We have to emit the section
	// names first, the local symbols second, and then the 
	// global symbols last.
	
	// Emit the section names:
	
	addELFsym
	(
		NULL,						// This will be .text
		0,
		0,							// Size -- no known size
		STT_SECTION,				// Binding << 4 | Type.
		(type word shst_textIndex),	// Section number
		STV_DEFAULT					// Visibility
	);
	add( 1, numELFsyms );
	
	addELFsym
	(
		NULL,						// This will be .data
		0,
		0,							// Size -- no known size
		STT_SECTION,				// Binding << 4 | Type.
		(type word shst_dataIndex),	// Section number
		STV_DEFAULT					// Visibility
	);
	add( 1, numELFsyms );
	
	addELFsym
	(
		NULL,						// This will be .bss
		0,
		0,							// Size -- no known size
		STT_SECTION,				// Binding << 4 | Type.
		(type word shst_bssIndex),	// Section number
		STV_DEFAULT					// Visibility
	);
	add( 1, numELFsyms );
	
	
	// Emit the local symbols:
	
	foreach symbolTable.item() do
	
		mov( eax, edx );
		mov( (type tableNode_t [eax]).Value, ebx );
		
		// Map generic section number to ELF section numbers:
		
		movzx( symEBX.section, ecx );
		if( ecx = code_c ) then
		
			mov( shst_textIndex, ecx );
		
		elseif( ecx = data_c ) then
		
			mov( shst_dataIndex, ecx );
	
		elseif( ecx = bss_c ) then
		
			mov( shst_bssIndex, ecx );
	
		else	// Undefined section.
		
			xor( ecx, ecx );
			
		endif;
		
		
		// Get the offset value for this symbol:
		
		mov( symEBX.offset, edi );
		
		
		test( isExtern_c, symEBX.flags );
		if( @z ) then

			test( isPublic_c, symEBX.flags );
			if( @z ) then	// Local symbol
			
				if( symEBX.isFunc ) then
				
					addELFsym
					(
						(type tableNode_t [edx]).id,	// Name
						edi,							// Offset
						symEBX.size,					// Size
						(STB_LOCAL << 4) | STT_FUNC,	// Binding << 4 | Type.
						cx,								// Section number
						STV_DEFAULT						// Visibility
					);

				else
				
					addELFsym
					(
						(type tableNode_t [edx]).id,	// Name
						edi,							// Offset
						0,								// Size -- no known size
						(STB_LOCAL << 4) | STT_NOTYPE,	// Binding << 4 | Type.
						cx,								// Section number
						STV_DEFAULT						// Visibility
					);
					
				endif;
				
				// Save index to this ELF symbol table entry so
				// we can quickly find it when generating all the reloc data.
				
				mov( numELFsyms, eax );
				mov( eax, symEBX.symIndex );
				add( 1, numELFsyms );
				
			endif;
			
		endif; 
		
	endfor;
	
	// Symtab.Info must contain the number of local symbols (one greater than
	// the index of the last local symbol):
	
	mov( numELFsyms, eax );
	mov( eax, symtabSection.sh_info );	
		 
	// Emit the global symbols:
	
	foreach symbolTable.item() do
	
		mov( eax, edx );
		mov( (type tableNode_t [eax]).Value, ebx );
		
		// Map generic section number to ELF section numbers:
		
		movzx( symEBX.section, ecx );
		if( ecx = code_c ) then
		
			mov( shst_textIndex, ecx );
		
		elseif( ecx = data_c ) then
		
			mov( shst_dataIndex, ecx );
	
		elseif( ecx = bss_c ) then
		
			mov( shst_bssIndex, ecx );
	
		else	// Undefined section.
		
			xor( ecx, ecx );
			
		endif;
		
				
		
		// Get the offset value for this symbol:
		
		mov( symEBX.offset, edi );
		
		
		test( isExtern_c, symEBX.flags );
		if( @nz ) then
		
			// External symbols have storage class
			// STB_GLOBAL, a section number
			// of zero, and an offset of zero.
			
			if( symEBX.isFunc ) then
			
				mov( (STB_GLOBAL << 4) | STT_FUNC, al );
				
			else
			
				mov( (STB_GLOBAL << 4) | STT_NOTYPE, al );
				
			endif;
			xor( ecx, ecx );
			xor( edi, edi );
			
		else
		
			test( isPublic_c, symEBX.flags );
			if( @nz ) then
			
				// Public symbols have storage class
				// STB_GLOBAL and a section
				// number that is not zero.
				
				if( symEBX.isFunc ) then
				
					mov( (STB_GLOBAL << 4) | STT_FUNC, al );
					
				else
				
					mov( (STB_GLOBAL << 4) | STT_NOTYPE, al );
					
				endif;
								
				
			else	// Standard (local) symbol
			
				continue;	// Already emitted local symbols.
				
			endif;
			
		endif;
		addELFsym
		(
			(type tableNode_t [edx]).id,	// Name
			edi,							// Offset
			symEBX.size,					// Size
			al,								// Binding << 4 | Type.
			cx,								// Section number
			STV_DEFAULT						// Visibility
		);
		
		// Save index to this ELF symbol table entry so
		// we can quickly find it when generating all the reloc data.
		
		mov( numELFsyms, eax );
		mov( eax, symEBX.symIndex );
		add( 1, numELFsyms );
		
	endfor;	
		 
	// stringTable[0]..stringTable[strTblOffset] is the string table segment
	// ElfSyms[0]..ElfSyms[numELFsyms] is the symbol table data.
	
	
	
	
	// If there is a code segment, generate the raw data for that code
	// section and the corresponding code relocations:
	
	mov( codeSize, eax );
	if( eax <> 0 ) then
	
		// Allocate storage for the raw code:
	
		mem.alloc( eax );
		mov( eax, rawCode );
		
		// Allocate storage for the code relocations:
		
		intmul( @size(Elf32_Rel), numCodeRelocs, eax );
		add( @size(Elf32_Rel), eax );	// Just in case numCodeRelocs is 0.
		mem.alloc( eax );
		mov( eax, codeRelocations ); 


		// Build the raw code and code relocations data:
		
		buildRaw
		( 
			codeList,
			codeStart, 
			codeRelocations, 
			numCodeRelocs, 
			rawCode, 
			code_c, 
			brand 
		); 
		
	endif;
	
	// If there is a data section, allocate storage for it (and the data
	// relocations section, if there are any data relocations):
	
	mov( dataSize, eax );
	if( eax <> 0 ) then
	
		// Allocate storage for the data, if any:
	
		mem.alloc( eax );
		mov( eax, rawData );
	
		intmul( @size(Elf32_Rel), numDataRelocs, eax );
		mem.alloc( eax );
		mov( eax, dataRelocations ); 

		buildRaw
		( 
			dataList,
			dataStart, 
			dataRelocations, 
			numDataRelocs, 
			rawData, 
			data_c, 
			brand 
		);  
	
	endif;
	
	
	
	
	
	// Compute the offsets of the section header string table,
	// the string table and the symbol table:
	
	mov
	( 
		(@size( ElfFileHeader ) + 15) & $FFFF_FFF0, 
		eax 
	);
	mov( eax, shOffset  );
	add( shSize, eax );
	add( 15, eax );
	and( $FFFF_FFF0, eax );
	mov( eax, shstrTabOffset );
	 
	add( shstrtabSize, eax );
	add( 15, eax );
	and( $FFFF_FFF0, eax );
	mov( eax, symtabOffset );
	
	intmul( @size( Elf32_Sym ), numELFsyms, edx );
	add( edx, eax );
	add( 15, eax );
	and( $FFFF_FFF0, eax );
	mov( eax, strtabOffset );
	
	// Compute the offsets of the code, data, and bss sections:
	
	add( strTblOffset, eax );
	mov( eax, edx );
	add( 15, edx );
	and( $FFFF_FFF0, edx );
	
	// Compute the offset of the code section:
	 
	if( codeSize <> 0 ) then
	
		mov( edx, codeOffset );
		add( codeSize, edx );
		add( 15, edx );
		and( $FFFF_FFF0, edx );
		
	else	// No code, must point codeOffset at shstrtab
	
		mov( shstrTabOffset, eax );
		mov( eax, codeOffset );
		
	endif;
	
	// Compute the offset of the data section:
	 
	if( dataSize <> 0 ) then
	
		mov( edx, dataOffset );
		add( dataSize, edx );
		add( 15, edx );
		and( $FFFF_FFF0, edx );
		
	else	// No data, must set dataOffset to shstrTabOffset
	
		mov( shstrTabOffset, eax );
		mov( eax, dataOffset );
		
	endif;
	
	// Compute the offset of the optional code relocations section:
	 
	if( numCodeRelocs <> 0 ) then
	
		mov( edx, relCodeOffset );
		intmul( @size( Elf32_Rel ), numCodeRelocs, eax );
		add( eax, edx );
		add( 15, edx );
		and( $FFFF_FFF0, edx );
				
	endif;
	
	// Compute the offset of the optional data relocations section:
	 
	if( numDataRelocs <> 0 ) then
	
		mov( edx, relDataOffset );
		intmul( @size( Elf32_Rel ), numDataRelocs, eax );
		add( eax, edx );
				
	endif;
	
	// EDX now contains the ELF file size.
	
	mov( edx, ELFsize );
	mem.zalloc( edx );
	mov( eax, ElfFile );	
	
	
	// Set the bss section offset to shstrTabOffset (no associated section).
	 
	mov( shstrTabOffset, bssOffset );
	
	
	
	
	// Fill in the ELF file header info:
	
	cld();
	lea( edi, ElfFileHeader );
	mov( @size( ElfFileHeader ), ecx );
	mov( 0, al );
	rep.stosb();
	
	mov( ET_REL, ElfFileHeader.e_type );
	mov( EM_386, ElfFileHeader.e_machine );
	mov( EV_CURRENT, ElfFileHeader.e_version );
	mov( 0, ElfFileHeader.e_entry );		// Temporary assignment
	mov( 0, ElfFileHeader.e_phoff );		// Program header offset (none)
	
	// The section headers will immediately follow the file header
	// in the ELF file.  Put them at an offset that is a multiple of 16 bytes.
	
	mov( shOffset, eax );
	mov( eax, ElfFileHeader.e_shoff );
		
	mov( 0, ElfFileHeader.e_flags );
	mov( @size( ElfFileHeader ), ElfFileHeader.e_ehsize );
	mov( 0, ElfFileHeader.e_phentsize );	// No program header, so size=0
	mov( 0, ElfFileHeader.e_phnum );		// No program header, so cnt=0
	mov( @size( Elf32_Shdr ), ElfFileHeader.e_shentsize );
	mov( numSections, eax );
	mov( ax, ElfFileHeader.e_shnum );
	mov( 1,	 ElfFileHeader.e_shstrndx );
	
	// Fill in the magic data in the file header:
	
	lea( ebx, ElfFileHeader.e_ident );
	mov( ELFMAG0, (type byte [ebx+EI_MAG0]));
	mov( ELFMAG1, (type byte [ebx+EI_MAG1]));
	mov( ELFMAG2, (type byte [ebx+EI_MAG2]));
	mov( ELFMAG3, (type byte [ebx+EI_MAG3]));
	mov( ELFCLASS32, (type byte [ebx+EI_CLASS]));
	mov( ELFDATA2LSB, (type byte [ebx+EI_DATA]));
	mov( EV_CURRENT, (type byte [ebx+EI_VERSION]));
	
	if( brand = elfLinux_c ) then
	
		//mov( ELFOSABI_LINUX, (type byte [ebx+EI_OSABI]));
		
		// Linux puts zero in this byte, even though it should really be 3:
		
		mov( 0, (type byte [ebx+EI_OSABI]));
		
	elseif( brand = elfFreeBSD_c ) then
	
		mov( ELFOSABI_FREEBSD, (type byte [ebx+EI_OSABI]));
	
	else
	
		stderr.put( "Unknown ELF format specified!" nl );
		mov( 0, (type byte [ebx+EI_OSABI]));
		
	endif;
	
	// Now finish constructing all the data in the section headers:
	//
	// Finish the section header for the section header string table:
	
	mov( shstrTabOffset, eax );
	mov( eax, shstrtabSection.sh_offset );
	mov( shstrtabSize, eax );
	mov( eax, shstrtabSection.sh_size );	

	// Finish the section header for the symbol table:
	
	mov( symtabOffset, eax );
	mov( eax, symtabSection.sh_offset );
	intmul( @size( Elf32_Sym ), numELFsyms, eax );
	mov( eax, symtabSection.sh_size );
	mov( eax, symtabSize );

	// Finish the section header for the strings table:
	
	mov( strtabOffset, eax );
	mov( eax, strtabSection.sh_offset );
	mov( strTblOffset, eax );
	mov( eax, strtabSection.sh_size );

	// Finish the section header for the .text section:
	
	mov( codeOffset, eax );
	mov( eax, textSection.sh_offset );
	mov( codeSize, eax );
	mov( eax, textSection.sh_size );

	// Finish the section header for the .data section:
	
	mov( dataOffset, eax );
	mov( eax, dataSection.sh_offset );
	mov( dataSize, eax );
	mov( eax, dataSection.sh_size );

	// Finish the section header for the .bss section:
	
	mov( bssSize, eax );
	mov( eax, bssSection.sh_size );
	mov( bssOffset, eax );
	mov( eax, bssSection.sh_offset );

	// Finish the section header for the .rel.text section.
	// (Link and Info are fixed and don't need to be assigned here):
	
	if( numCodeRelocs <> 0 ) then
	
		mov( relCodeOffset, eax );
		mov( eax, relTextSection.sh_offset );
		intmul( @size( Elf32_Rel ), numCodeRelocs, eax );
		mov( eax, relTextSection.sh_size );
		mov( shst_textIndex, eax );
		mov( eax, relTextSection.sh_info );
		
	endif;
	
	// Finish the section header for the .rel.data section.
	
	if( numDataRelocs <> 0 ) then
	
		mov( relDataOffset, eax );
		mov( eax, relDataSection.sh_offset );
		intmul( @size( Elf32_Rel ), numDataRelocs, eax );
		mov( eax, relDataSection.sh_size );
		mov( shst_dataIndex, eax );
		mov( eax, relDataSection.sh_info );
		
	endif;
	


	////////////////////////////////////////////////////////////////////////////
	//
	// Copy all the data to the various sections.
	
	
	cld();
	mov( ElfFile, edi );
	lea( esi, ElfFileHeader );
	mov( @size( ElfFileHeader ), ecx );
	rep.movsb();
	
	// Align the sections on a 16-byte boundary in the ELF file:
	
	#macro align16( dummy[] );
	
		sub( ElfFile, edi );
		add( 15, edi );
		and( $FFFF_FFF0, edi );
		add( ElfFile, edi );
		
		
	#endmacro
	
	#macro cpySection( _section_ );
	
		lea( esi, _section_ );
		mov( @size( Elf32_Shdr ), ecx );
		rep.movsb();
		
	#endmacro
	
	
	// Copy the section headers to the ELF file:
	
	align16();
	cpySection( NULLsection );
	cpySection( shstrtabSection );
	cpySection( symtabSection );
	cpySection( strtabSection );
	cpySection( textSection );
	cpySection( dataSection );
	cpySection( bssSection );
	if( numCodeRelocs <> 0 ) then
	
		cpySection( relTextSection );
		
	endif;
	if( numDataRelocs <> 0 ) then
	
		cpySection( relDataSection );
		
	endif;
	
	// Copy the section header strings table to the ELF file:
	
	align16();
	mov( shstrtab, esi );
	mov( shstrtabSize, ecx );
	cld();
	rep.movsb();
	
	// Copy the symbol table to the ELF file:
	
	align16();
	mov( ELFsyms, esi );
	intmul( @size( Elf32_Sym ), numELFsyms, ecx );
	rep.movsb();
	
	// Copy the strings table to the ELF file:
	
	align16();
	mov( stringTable, esi );
	mov( strTblOffset, ecx );
	rep.movsb(); 	
	
	// Copy the code (if any) to the ELF file:
	
	if( codeSize <> 0 ) then
	
		align16();
		mov( rawCode, esi );
		mov( codeSize, ecx );
		rep.movsb();
		
	endif;
	
	// Copy the data (if any) to the ELF file:
	
	if( dataSize <> 0 ) then
	
		align16();
		mov( rawData, esi );
		mov( dataSize, ecx );
		rep.movsb();
		
	endif;
	
	// If there are any code relocations, copy them to the file:
	
	if( numCodeRelocs <> 0 ) then
	
		align16();
		mov( codeRelocations, esi );
		intmul( @size( Elf32_Rel ), numCodeRelocs, ecx );
		rep.movsb();
		
	endif;
		
	// If there are any data relocations, copy them to the file:
	
	if( numDataRelocs <> 0 ) then
	
		align16();
		mov( dataRelocations, esi );
		intmul( @size( Elf32_Rel ), numDataRelocs, ecx );
		rep.movsb();
		
	endif;
		
		
	

	// Okay, write the ELF file to disk:	
	
	fileio.openNew( outputFilename );
	mov( eax, fileHandle );
	fileio.write( fileHandle, val ElfFile, ELFsize );
	fileio.close( fileHandle );
	
		
	pop( edi );
	pop( esi );
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );
		
_end( generateELF );


	


	
///////////////////////////////////////////////////////////////////////////////
//
// generateMacho-
//
//	Generates a Mach-O file.
//
	


_proc( generateMacho )
(
	inputFilename	:string;
	outputFilename	:string; 
	codeList		:tokenList_t;
	dataList		:tokenList_t;
	bssList			:tokenList_t
);

		
var
	codeRelocations		:pRelocations;
	dataRelocations		:pRelocations;
	
	rawCode				:pByte;
	rawData				:pByte;
	
	numLocalSyms		:uns32;
	numPublicSyms		:uns32;
	numExternalSyms		:uns32;
	
	 
	MachoFile			:dword;
	MachoSize			:dword;
	
	filesize			:dword;
	fileHandle			:dword;
	
	mhSize				:dword;
	
	mh:
		record
		
			mh			:mach_header;
			textSeg		:segment_command;
			ts			:section;
			ds			:section;
			bss			:section;
			symtab		:symtab_command;
			dysymtab	:dysymtab_command;
			
		endrecord;
			
	
	
	
	#macro mov16( s, d ):_a_, _i_;

		?_a_:byte[16];
		#for( _i_ := 0 to 15 )
		
			?_a_[_i_] := 0;
			
		#endfor
		?_i_ := 0;
		#while( _i_ < @length(s) )
		
			?_a_[_i_] := char( @substr( s, _i_, 1 ) );
			?_i_ := _i_ + 1;
			
		#endwhile;
		mov
		( 
			_a_[0] + (_a_[1] << 8) + (_a_[2] << 16) + (_a_[3] <<24), 
			(type dword d[0])
		);
		mov
		( 
			_a_[4] + (_a_[5] << 8) + (_a_[6] << 16) + (_a_[7] <<24), 
			(type dword d[4])
		);
		mov
		( 
			_a_[8] + (_a_[9] << 8) + (_a_[10] << 16) + (_a_[11] <<24), 
			(type dword d[8])
		);
		mov
		( 
			_a_[12] + (_a_[13] << 8) + (_a_[14] << 16) + (_a_[15] <<24), 
			(type dword d[12])
		);
		
	#endmacro

				
			
	
		
_begin( generateMacho );

	push( eax );
	push( ebx );
	push( ecx );
	push( edx );
	push( esi ); 
	push( edi );
	
	if( verboseDebug ) then
	
		stdout.put
		(
			"generateMacho:" nl 
			"Input filename:  ", inputFilename, nl 
			"Output filename: ", outputFilename, nl 
		);
		
	endif;
		
	
	
	// Construct the Mach-o symbol table and the Mach-o strings table.
	//	 
	// Initial strings table size will be 256K
	
	mov( 256*1024, strTblSize );
	mem.zalloc( 256*1024 );
	mov( eax, stringTable );
	mov( 1, strTblOffset );
	
	// Initial symbol table size will be 65536 symbols
	
	mem.zalloc( 65536 * @size( nlist ));
	mov( eax, MachoSyms );
	mov( eax, ebx );
	mov( 65536 * @size( nlist ), MachoSymSize );
	mov( 0, numMachoSyms );	// Must have one dummy entry.
	
	
	
	
	
	// Copy all the symbols from the generic symbol table to
	// the Mach-o symbol table.  We have to emit the local
	// names first, the public symbols second, and then the 
	// external symbols last.
	
	// Emit the local symbols:
	
	mov( 0, numLocalSyms );
	foreach symbolTable.item() do
	
		mov( eax, edx );
		mov( (type tableNode_t [eax]).Value, ebx );
		
		// Map generic section number to Mach-o section numbers:
		
		movzx( symEBX.section, ecx );
		if( ecx = code_c ) then
		
			mov( 1, ecx );
		
		elseif( ecx = data_c ) then
		
			mov( 2, ecx );
	
		elseif( ecx = bss_c ) then
		
			mov( 3, ecx );
	
		else	// Undefined section.
		
			xor( ecx, ecx );
			
		endif;
		
				
		
		// Get the offset value for this symbol:
		
		mov( symEBX.offset, edi );
		
		// If it's a local symbol emit it to the Mach-O symbol table
		// and the Mach-O strings table:
		
 		test( isPublic_c | isExtern_c, symEBX.flags );
		if( @z ) then
		
			addMachoSym
			(
				(type tableNode_t [edx]).id,	// Name
				edi,							// Offset
				N_SECT,							// Type
				cl								// Section #
			);
			
			// Save index to this Mach-O symbol table entry so
			// we can quickly find it when generating all the reloc data.
			
			add( 1, numLocalSyms );
			mov( numMachoSyms, eax );
			mov( eax, symEBX.symIndex );
			add( 1, eax );
			mov( eax, numMachoSyms );
			
		endif;
		
	endfor;	
	
	
	
	// Emit the public symbols:
	
	mov( 0, numPublicSyms );
	foreach symbolTable.item() do
	
		mov( eax, edx );
		mov( (type tableNode_t [eax]).Value, ebx );
		
		// Map generic section number to Mach-o section numbers:
		
		movzx( symEBX.section, ecx );
		if( ecx = code_c ) then
		
			mov( 1, ecx );
		
		elseif( ecx = data_c ) then
		
			mov( 2, ecx );
	
		elseif( ecx = bss_c ) then
		
			mov( 3, ecx );
	
		else	// Undefined section.
		
			xor( ecx, ecx );
			
		endif;
		
				
		
		// Get the offset value for this symbol:
		
		mov( symEBX.offset, edi );
		
		// If it's a public symbol emit it to the Mach-O symbol table
		// and the Mach-O strings table:
		
		test( isPublic_c, symEBX.flags );
		if( @nz ) then
		
			addMachoSym
			(
				(type tableNode_t [edx]).id,	// Name
				edi,							// Offset
				N_SECT | N_EXT,					// Type
				cl								// Section #
			);
			
			// Save index to this Mach-O symbol table entry so
			// we can quickly find it when generating all the reloc data.
			
			add( 1, numPublicSyms );
			mov( numMachoSyms, eax );
			mov( eax, symEBX.symIndex );
			add( 1, eax );
			mov( eax, numMachoSyms );
			
		endif;
		
	endfor;	
	
	
	
	// Emit the external symbols:
	
	mov( 0, numExternalSyms );
	foreach symbolTable.item() do
	
		mov( eax, edx );
		mov( (type tableNode_t [eax]).Value, ebx );
		
		// Map generic section number to Mach-o section numbers:
		
		movzx( symEBX.section, ecx );
		if( ecx = code_c ) then
		
			mov( 1, ecx );
		
		elseif( ecx = data_c ) then
		
			mov( 2, ecx );
	
		elseif( ecx = bss_c ) then
		
			mov( 3, ecx );
	
		else	// Undefined section.
		
			xor( ecx, ecx );
			
		endif;
				
		
		// Get the offset value for this symbol:
		
		mov( symEBX.offset, edi );
		
		// If it's a public symbol emit it to the Mach-O symbol table
		// and the Mach-O strings table:
		
		test( isExtern_c, symEBX.flags );
		if( @nz ) then
		
			addMachoSym
			(
				(type tableNode_t [edx]).id,	// Name
				edi,							// Offset
				N_UNDF | N_EXT,					// Type
				cl								// Section #
			);
			
			// Save index to this Mach-O symbol table entry so
			// we can quickly find it when generating all the reloc data.
			
			add( 1, numExternalSyms );
			mov( numMachoSyms, eax );
			mov( eax, symEBX.symIndex );
			add( 1, eax );
			mov( eax, numMachoSyms );
			
		endif;
		
	endfor;	
		 
	
		 
	
	// If there is a code segment, generate the raw data for that code
	// section and the corresponding code relocations:
	
	mov( codeSize, eax );
	if( eax <> 0 ) then
	
		// Allocate storage for the raw code:
	
		add( 15, eax );			// Round out to a multiple of 16 bytes
		and( $FFFF_FFF0, eax );
		mov( eax, codeSize );
		mem.zalloc( eax );
		mov( eax, rawCode );
		
		// Allocate storage for the code relocations:
		
		intmul( @size(relocation_info), numCodeRelocs, eax );
		add( @size(relocation_info), eax );	// Just in case numCodeRelocs is 0.
		mem.alloc( eax );
		mov( eax, codeRelocations ); 


		// Build the raw code and code relocations data:
		
		buildRaw
		( 
			codeList,
			codeStart, 
			codeRelocations, 
			numCodeRelocs, 
			rawCode, 
			code_c, 
			macho_c 
		); 
		
	endif;
	
	// If there is a data section, allocate storage for it (and the data
	// relocations section, if there are any data relocations):
	
	mov( dataSize, eax );
	if( eax <> 0 ) then
	
		// Allocate storage for the data, if any:
	
		add( 15, eax );			// Round out to a multiple of 16 bytes
		and( $FFFF_FFF0, eax );
		mov( eax, dataSize );
		mem.zalloc( eax );
		mov( eax, rawData );
	
		intmul( @size(relocation_info), numDataRelocs, eax );
		mem.alloc( eax );
		mov( eax, dataRelocations ); 

		buildRaw
		( 
			dataList,
			dataStart, 
			dataRelocations, 
			numDataRelocs, 
			rawData, 
			data_c, 
			macho_c 
		);  
	
	endif;
	
	add( 15, bssSize );
	and( $FFFF_FFF0, bssSize );	

	
	
	
	// There are 3 segments:
	//
	//	1	:__TEXT,__text
	//	2	:LC_SYMTAB	
	//	3	:LC_DYSYMTAB	
	//
	//		
	//	
	// Fill in the Mach-o header:
	
	mov( MH_MAGIC, mh.mh.magic );
	mov( i386cpu, mh.mh.cputype );
	mov( i386sub, mh.mh.cpusubtype );
	mov( MH_OBJECT, mh.mh.filetype );
	mov( 3, mh.mh.ncmds );
	mov( @size( mh )-@size( mach_header ), mh.mh.sizeofcmds );
	mov( 0, mh.mh.flags );				// Always zero -- nothing special in file.
	
	

	// Fill in the __TEXT LC_SEGMENT load command:
	
	mov( LC_SEGMENT, mh.textSeg.cmd );
	mov
	( 
		@size( mh.textSeg ) + @size( mh.ts ) + @size( mh.ds ) + @size( mh.bss ),
		mh.textSeg.cmdsize
	);
	mov16( "", mh.textSeg.segname );
	mov( 0, mh.textSeg.vmaddr );
	
	// filesize and vmsize are the size of the code, data, and _bss sections:
	
	mov( codeSize, eax );
	add( dataSize, eax );
	mov( eax, mh.textSeg.filesize );
	add( bssSize, eax );
	mov( eax, mh.textSeg.vmsize );
	
	mov( @size( mh ), mh.textSeg.fileoff );
	mov( %111, mh.textSeg.maxprot );			// rwx
	mov( %111, mh.textSeg.initprot );			// rwx
	mov( 3, mh.textSeg.nsects );
	mov( 0, mh.textSeg.flags );
	
	// The text section header immediately follows the __TEXT Segment header:
	
	mov16( "__text", mh.ts.sectname );
	mov16( "__TEXT", mh.ts.segname );
	mov( 0, mh.ts.addr );
	mov( codeSize, eax );
	mov( eax, mh.ts.size );
	mov( @size( mh ), mh.ts.offset );
	mov( 4, mh.ts._align );			// 2^4 = 16-byte alignment
	mov( codeSize, eax );
	add( dataSize, eax );
	add( @size( mh ), eax );
	mov( eax, mh.ts.reloff );
	mov( numCodeRelocs, eax );
	mov( eax, mh.ts.nreloc );
	mov( S_ATTR_SOME_INSTRUCTIONS, mh.ts.flags );
	mov( 0, mh.ts.reserved1 );
	mov( 0, mh.ts.reserved2 );



	
	// The __data section header immediately follows the __text section header:
	
	mov16( "__data", mh.ds.sectname );
	mov16( "__DATA", mh.ds.segname );
	mov( dataStart, eax );
	mov( eax, mh.ds.addr );
	mov( dataSize, eax );
	mov( eax, mh.ds.size );
	
	// The data follows the code in the file:
	
	mov( mh.ts.offset, eax );
	add( codeSize, eax );
	mov( eax, mh.ds.offset );
	mov( 4, mh.ds._align );			// 2^4 = 16-byte alignment
	intmul( @size( relocation_info ), numCodeRelocs, eax );
	add( mh.ts.reloff, eax );
	mov( eax, mh.ds.reloff );
	mov( numDataRelocs, eax );
	mov( eax, mh.ds.nreloc );
	mov( 0, mh.ds.flags );
	mov( 0, mh.ds.reserved1 );
	mov( 0, mh.ds.reserved2 );
	
	
	// The __bss section header immediately follows the __data section header:
	
	mov16( "__bss", mh.bss.sectname );
	mov16( "__DATA", mh.bss.segname );
	mov( bssStart, eax );
	mov( eax, mh.bss.addr );
	mov( bssSize, eax );
	mov( eax, mh.bss.size );
	mov( 0,   mh.bss.offset );
	mov( 4,   mh.bss._align );			// 2^4 = 16-byte alignment
	mov( 0,   mh.bss.reloff );
	mov( 0,   mh.bss.nreloc );
	mov( S_ZEROFILL,   mh.bss.flags );
	mov( 0,   mh.bss.reserved1 );
	mov( 0,   mh.bss.reserved2 );
	
	
	// Now build the LC_SYMTAB segment:
	
	mov( LC_SYMTAB, mh.symtab.cmd );
	mov( @size( symtab_command ), mh.symtab.cmdsize );
	mov( 0, mh.symtab.symoff );	// Will fill this in later
	mov( numMachoSyms, eax );
	mov( eax, mh.symtab.nsyms );
	mov( 0, mh.symtab.stroff );	// Will fill this in later
	mov( strTblOffset, eax );
	mov( eax, mh.symtab.strsize );
		
	
	// Now build the LC_DYSYMTAB segment:
	
	mov( LC_DYSYMTAB, mh.dysymtab.cmd );
	mov( @size( dysymtab_command ), mh.dysymtab.cmdsize );
	
	
	mov( numLocalSyms, eax );
	mov( 0, mh.dysymtab.ilocalsym );
	mov( eax, mh.dysymtab.nlocalsym		 );
	
	
	if( numPublicSyms <> 0 ) then

		mov( numLocalSyms, eax );
		mov( eax, mh.dysymtab.iextdefsym );
		
	else
	
		mov( 0, mh.dysymtab.iextdefsym );
		
	endif;  
	mov( numPublicSyms, eax );
	mov( eax, mh.dysymtab.nextdefsym );
		
		
	if( numExternalSyms <> 0 ) then
	
		mov( numLocalSyms, eax );
		add( numPublicSyms, eax );
		mov( eax, mh.dysymtab.iundefsym );
		
	else
	
		mov( 0, mh.dysymtab.iundefsym );
		
	endif;	 
	mov( numExternalSyms, eax			 ); 
	mov( eax, mh.dysymtab.nundefsym		 );  
		
	xor( eax, eax 						 );					 
	mov( eax, mh.dysymtab.tocoff		 );	
	mov( eax, mh.dysymtab.ntoc			 );
	mov( eax, mh.dysymtab.modtaboff		 );
	mov( eax, mh.dysymtab.nmodtab		 );	
	mov( eax, mh.dysymtab.extrefsymoff	 );
	mov( eax, mh.dysymtab.nextrefsyms	 );	
	mov( eax, mh.dysymtab.indirectsymoff );	
	mov( eax, mh.dysymtab.nindirectsyms	 );
	mov( eax, mh.dysymtab.extreloff		 );
	mov( eax, mh.dysymtab.nextrel		 );	
	mov( eax, mh.dysymtab.locreloff		 );
	mov( eax, mh.dysymtab.nlocrel		 );	
	
	
	// Compute the size of the Mach-O file:
	//
	// Start with the size of the headers (this is a constant):	
	
	mov( @size( mh ), eax );
	
	// Add in the code and data which immediately follow the headers:
	
	add( codeSize, eax );
	add( dataSize, eax );
	
	// Next come the code and data relocations.
	//		
	// Add in the size of the code relocations:
	
	intmul( @size( relocation_info ), numCodeRelocs, edx );
	add( edx, eax );
	
	// Add in the size of the data relocations:
	
	intmul( @size( relocation_info ), numDataRelocs, edx );
	add( edx, eax );
	
	// Add in the size of the Mach-O Symbol table:
	
	mov( eax, mh.symtab.symoff );	// Fill in symbol table offset
	intmul( @size( nlist ), numMachoSyms, edx );
	add( edx, eax );
	
	// Add in the size of the strings table:
	
	mov( eax, mh.symtab.stroff );	// Fill in string table offset
	add( strTblOffset, eax );
	
	// Make the whole thing a multiple of 16 bytes:
	
	add( 15, eax );
	and( $FFFF_FFF0, eax );
	mov( eax, MachoSize );
	
	// Allocate the storage for the Mach-O file:
	
	mem.zalloc( eax );
	mov( eax, MachoFile );
	
	
	
	
	
	// Okay, copy the file header to the Mach-O file:
	
	cld();
	mov( eax, edi );
	lea( esi, mh );
	mov( @size( mh ), ecx );
	rep.movsb();
	
	// Copy the code to the Mach-O file:
	
	mov( rawCode, esi );
	mov( codeSize, ecx );
	rep.movsb();
	
	
	// Copy the data to the Mach-O file:
	
	mov( rawData, esi );
	mov( dataSize, ecx );
	rep.movsb();
	
	// Copy the code relocations to the Mach-O file:
	
	mov( codeRelocations, esi );
	intmul( @size( relocation_info ), numCodeRelocs, ecx );
	rep.movsb();
	
	// Copy the data relocations to the Mach-O file:
	
	mov( dataRelocations, esi );
	intmul( @size( relocation_info ), numDataRelocs, ecx );
	rep.movsb();
	
	// Copy the symbol table to the Mach-O file:
	
	mov( MachoSyms, esi );
	intmul( @size( nlist ), numMachoSyms, ecx );
	rep.movsb();
	
	// Copy the string table to the Mach-O file:
	
	mov( stringTable, esi );
	mov( strTblOffset, ecx );
	rep.movsb(); 
	
	

	// Okay, write the Mach-O file to disk:	
	
	fileio.openNew( outputFilename );
	mov( eax, fileHandle );
	fileio.write( fileHandle, val MachoFile, MachoSize );
	fileio.close( fileHandle );
	
		
	pop( edi );
	pop( esi );
	pop( edx );
	pop( ecx );
	pop( ebx );
	pop( eax );
		
_end( generateMacho );


	
///////////////////////////////////////////////////////////////////////////////
//
// compileCOFF-
//
//	Compiles and HLABE source file to a PE/COFF object file.

_proc( compileCOFF )
( 
		inputFilename	:string;
		outputFilename	:string; 
		start_source	:dword; 
		end_source		:dword;
		verbose			:boolean; 
	var	codeListPtr		:tokenList_t;
	var	dataListPtr		:tokenList_t;
	var	bssListPtr	    :tokenList_t
);
var
	codeList	:tokenList_t;
	dataList	:tokenList_t;
	bssList	    :tokenList_t;
	
	dummySymbol	:symbol_t;

_begin( compileCOFF );

	push( ebx );
	mov( codeListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, codeList );
	
	mov( dataListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, dataList );
	
	mov( bssListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, bssList );
	
	
	// Convert the ".asm" file to the internal representation that
	// the code generator uses:
	
	lexer( start_source, end_source, codeList, dataList, bssList );
	
	// Compute branch (and other) displacements and detect various
	// errors (like undefined symbols, branch out of range, and so on):
	
	optimizeDisps( codeList, dataList, bssList, verbose, pecoff_c );
	
	// Now generate the COFF file:
	
	generateCOFF( inputFilename, outputFilename, codeList, dataList, bssList );
	
	mov( codeListPtr, ebx );
	mov( codeList, eax );
	mov( eax, [ebx] );
	
	mov( dataListPtr, ebx );
	mov( dataList, eax );
	mov( eax, [ebx] );
	
	mov( bssListPtr, ebx );
	mov( bssList, eax );
	mov( eax, [ebx] );

	mov( true, eax );
	
_end( compileCOFF );


/////////////////////////////////////////////////////////////////////////////////
//
// compileELF-
//
//	Compiles an HLABE source file to an ELF object file.

procedure compileELF
( 
		inputFilename	:string;
		outputFilename	:string; 
		start_source	:dword; 
		end_source		:dword;
		brand			:obj_t;
		verbose			:boolean; 
	var	codeListPtr		:tokenList_t;
	var	dataListPtr		:tokenList_t;
	var	bssListPtr	    :tokenList_t
);
var
	codeList	:tokenList_t;
	dataList	:tokenList_t;
	bssList	    :tokenList_t;
	
	dummySymbol	:symbol_t;

_begin( compileELF );

	push( ebx );
	mov( codeListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, codeList );
	
	mov( dataListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, dataList );
	
	mov( bssListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, bssList );
	
	
	// Convert the ".asm" file to the internal representation that
	// the code generator uses:
	
	lexer( start_source, end_source, codeList, dataList, bssList );
	
	// Compute branch (and other) displacements and detect various
	// errors (like undefined symbols, branch out of range, and so on):
	
	optimizeDisps( codeList, dataList, bssList, verbose, brand );
	
	// Now generate the ELF file:
	
	generateELF
	( 
		inputFilename, 
		outputFilename, 
		codeList, 
		dataList, 
		bssList, 
		brand 
	);
	
	mov( codeListPtr, ebx );
	mov( codeList, eax );
	mov( eax, [ebx] );
	
	mov( dataListPtr, ebx );
	mov( dataList, eax );
	mov( eax, [ebx] );
	
	mov( bssListPtr, ebx );
	mov( bssList, eax );
	mov( eax, [ebx] );

	//mov( true, eax );
	xor( eax, eax );
	
_end( compileELF );



//////////////////////////////////////////////////////////////////////////////////
//
// compileMACHO-
//
//	Compiles an HLABE file to a Mac OSX Mach-O object file.

_proc( compileMACHO )
( 
		inputFilename	:string;
		outputFilename	:string; 
		start_source	:dword; 
		end_source		:dword;
		verbose			:boolean; 
	var	codeListPtr		:tokenList_t;
	var	dataListPtr		:tokenList_t;
	var	bssListPtr	    :tokenList_t
);
var
	codeList	:tokenList_t;
	dataList	:tokenList_t;
	bssList	    :tokenList_t;
	
	dummySymbol	:symbol_t;

_begin( compileMACHO );

	push( ebx );
	mov( codeListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, codeList );
	
	mov( dataListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, dataList );
	
	mov( bssListPtr, ebx );
	mov( [ebx], eax );
	mov( eax, bssList );
	
	
	// Convert the ".asm" file to the internal representation that
	// the code generator uses:
	
	lexer( start_source, end_source, codeList, dataList, bssList );
	
	// Compute branch (and other) displacements and detect various
	// errors (like undefined symbols, branch out of range, and so on):
	
	optimizeDisps( codeList, dataList, bssList, verbose, macho_c );
	
	// Now generate the Mach-o file:
	
	generateMacho( inputFilename, outputFilename, codeList, dataList, bssList );
	
	mov( codeListPtr, ebx );
	mov( codeList, eax );
	mov( eax, [ebx] );
	
	mov( dataListPtr, ebx );
	mov( dataList, eax );
	mov( eax, [ebx] );
	
	mov( bssListPtr, ebx );
	mov( bssList, eax );
	mov( eax, [ebx] );

	mov( true, eax );
	
_end( compileMACHO );


/////////////////////////////////////////////////////////////////////////////////
//
// compile sets up structured exception handling and then
// calls the compile function to do the real work.
		
procedure compile
(
		inputFilename	:dword;
		outputFilename	:dword; 
		start_source	:dword; 
		end_source		:dword;
		objType			:obj_t;
	var	codeListPtr		:tokenList_t;
	var	dataListPtr		:tokenList_t;
	var	bssListPtr	    :tokenList_t;
		verbose			:boolean
);

var
	codeList	:tokenList_t;
	dataList	:tokenList_t;
	bssList	    :tokenList_t;
	delims		:cset;

_begin( compile );

	push( ebx );
	push( ecx );
	push( edx );
	push( esi );
	push( edi );
	mov( esp, saveESP );
	
	#if( !runFromHLA )
	
		// Upon entry into any HLA code that needs exception support,
		// we have to set up the structured exception handling record
		// for HLA.
		//
		// Save away the current structured exception handling pointer:
		
		#if( @defined( WINDOWS ) )
		
			xor( ebx, ebx );
			fseg:mov( [ebx], eax );		// Get the exception pointer
			
		#else
		
			mov( ExceptionPtr, eax );	// Exception pointer in non-Windows OSes
			
		#endif
		mov( eax, SaveSEHPointer );
		call BuildExcepts;
		
	#endif
	
	// Add "(", ")", '+', and '-' to the legal delimiters for numeric values:
	
	conv.getDelimiters( delims );
	cs.setunion( { '(', ')', '+', '-' }, delims );
	conv.setDelimiters( delims );
	
	
	
	
	if( verbose ) then
	
		stdout.put
		(
			"------------" nl
			"HLA Back Engine Object code formatter" nl
			nl 
			"HLABE compiling '", 
			(type string inputFilename), 
			"' to '",
			(type string outputFilename),
			"'" nl
		);
		
	endif; 
	
	try
	
		// body goes here
		
		symbolTable.create( 65536 );
		equatesTable.create( 8192 );
		
		movzx( objType, eax );
		switch( eax );
		
			case( pecoff_c )
			
				compileCOFF
				(
					inputFilename,
					outputFilename, 
				    start_source, 
					end_source,
					verbose, 
					codeList, 
					dataList, 
					bssList 
				);
				
			case( elfLinux_c )
			
				compileELF
				( 
					inputFilename,
					outputFilename, 
				    start_source, 
					end_source,
					elfLinux_c,
					verbose, 
					codeList, 
					dataList, 
					bssList 
				);
				
			case( elfFreeBSD_c )
			
				compileELF
				( 
					inputFilename,
					outputFilename, 
				    start_source, 
					end_source,
					elfFreeBSD_c,
					verbose, 
					codeList, 
					dataList, 
					bssList 
				);
				
			case( macho_c )
			
				compileMACHO
				( 
					inputFilename,
					outputFilename, 
				    start_source, 
					end_source,
					verbose,
					codeList, 
					dataList, 
					bssList 
				);
				
			default
				stderr.put
				( 
					"Illegal object-code format specified -- compile failed" nl
				);
				mov( true, eax );
				
		endswitch;
				
	  anyexception
	  
	  	call ex.printExceptionError;
	  	mov( 0, eax );			// If there was an exception, return failure.
	  
	endtry;
	
	// Dump the hlabe symbol table if in verboseDebug mode:
	
	if( verboseDebug ) then
	
		stdout.put( nl, "Symbol table: " nl nl );
		foreach symbolTable.item() do
		
			mov( eax, edx );
			stdout.put
			( 
				(type tableNode_t [edx]).id:-24, ": " 
			);

			mov( (type tableNode_t [edx]).Value, edx );
			mov( (type symbol_t [edx]).flags, ah );
			test( isExtern_c, ah );
			mov( ' ', al );
			if( @nz ) then
			
				mov( 'X', al );
				
			endif;
			stdout.putc( al );
				
			test( isPublic_c, ah );
			mov( ' ', al );
			if( @nz ) then
			
				mov( 'P', al );
				
			endif;
			stdout.putc( al );
				
			test( isReferenced_c, ah );
			mov( ' ', al );
			if( @nz ) then
			
				mov( 'R', al );
				
			endif;
			stdout.putc( al );
				
			test( isDefined_c, ah );
			mov( ' ', al );
			if( @nz ) then
			
				mov( 'D', al );
				
			endif;
			stdout.put
			(
				(type char al), 
				"  $", 
				(type symbol_t [edx]).offset, 
				", sec:",
				(type uns8 (type symbol_t [edx]).section),
				", index:",
				(type uns8 (type symbol_t [edx]).symIndex),
				nl
			);
			
				
				
		endfor;
		stdout.newln();	
	
	endif;
	
	
	#if( !runFromHLA )
	
	
			jmp Exit_compile_hlabe;
			
			// HLA main programs provide a "QuitMain" external label that
			// exception handling code can call when the exception causes the
			// program to abort. This label immediately terminates program
			// execution. As we are not writing an HLA main program, the HLA
			// compiler does not provide this code for us, we have to supply
			// it manually. This particular exit code returns '1' in EAX to
			// denote a compilation error.

		QuitMain::
			mov( 1, eax );



			// Exit from the compile_PECOFF function.
			
		Exit_compile_hlabe:
		
	#endif
	 
	
	mov( saveESP, esp );
	push( eax );		// save compiler return code.
	#if( !runFromHLA )
	
		// Restore the Structured Exception Handler pointer we saved upon entry:
		
		mov( SaveSEHPointer, eax );
		#if( @defined( WINDOWS ) )
		
			xor( ebx, ebx );
			fseg:mov( eax, [ebx] );		// Restore the exception pointer
			
		#else
		
			mov( eax, ExceptionPtr );	// Exception pointer in non-Windows OSes
			
		#endif
		
	#endif
	
	// Return pointers to data:
	
	mov( codeListPtr, ecx );
	mov( codeList, edx );
	mov( edx, [ecx] );
	
	mov( dataListPtr, ecx );
	mov( dataList, edx );
	mov( edx, [ecx] );
	
	mov( bssListPtr, ecx );
	mov( bssList, edx );
	mov( edx, [ecx] );
	
	pop( eax );		// Retrieve compiler return code.
	pop( edi );
	pop( esi );
	pop( edx );
	pop( ecx );
	pop( ebx );
	
_end( compile );


// C-Callable version of the function above:


procedure _hlabe_compile
(
		inputFilename	:zstring;
		outputFilename	:zstring; 
		start_source	:dword; 
		end_source		:dword;
		objType			:obj_t;
		verbose			:boolean
);		@noframe; @nodisplay;
begin _hlabe_compile;

	// Create an alias that falls through to the
	// code below, in order to handle name mangling
	// across operating systems.
	
end _hlabe_compile;

procedure hlabe_compile
(
		inputFilename	:zstring;
		outputFilename	:zstring; 
		start_source	:dword; 
		end_source		:dword;
		objType			:obj_t;
		verbose			:boolean
);
var
	ebxSave		:dword;
	ecxSave		:dword;
	edxSave		:dword;
	esiSave		:dword;
	ediSave		:dword;
	inFile		:string;
	outFile		:string;
	codeList	:tokenList_t;
	dataList	:tokenList_t;
	bssList	    :tokenList_t;
	inBuf		:char[1024];
	outBuf		:char[1024];
	
_begin( hlabe_compile );

	mov( ebx, ebxSave );
	mov( ecx, ecxSave );
	mov( edx, edxSave );
	mov( esi, esiSave );
	mov( edi, ediSave );
	
	str.init( inBuf, 1024 );
	mov( eax, inFile );
	str.init( outBuf, 1024 );
	mov( eax, outFile );
	
	str.cpyz( inputFilename, inFile );
	str.cpyz( outputFilename, outFile );
	compile
	(
		inFile,
		outFile, 
	    start_source, 
		end_source, 
		objType, 
		codeList,
		dataList,
		bssList,
		verbose 
	);
	
	mov( ebxSave, ebx );
	mov( ecxSave, ecx );
	mov( edxSave, edx );
	mov( esiSave, esi );
	mov( ediSave, edi );
	
_end( hlabe_compile );
		
end hlabeUnit;