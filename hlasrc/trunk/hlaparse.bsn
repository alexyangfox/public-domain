%pure_parser													 
			   		   		   			 			 
				  		  						 
/*****************************/				  
/*                           */
/*                           */					 
/* Parser and compiler code. */
/* Randall Hyde              */
/* 12/24/97                  */
/*                           */
/*****************************/

/*					  									  
** debug.h must be first!
*/

%{				 

#define YYERROR_VERBOSE 1
#define YYDEBUG 0
#define YYINITDEPTH 16384
#define YYMAXDEPTH 65536
#define _STDLIB_H
#define YYMALLOC malloc2

#define MAX_PATH 1023


#define yystrlen strlen
static char *yystpcpy (char *yydest, const char *yysrc);

#include "debug.h"


#include <sys/types.h>
#include <sys/timeb.h>
#include <errno.h>
#include "common.h"

/* 
c** Override default RatC _name definition 
*/

#define _nameDefault "HLABison";

#include "ratc.h"


#include "symbol.h"
#include "version.h"
#include "output.h"
#include "asm.h"


// Here we determine the type of HLAPARSE we produce
// (based on -D command-line parameters)
//
// By default, we produce a version for Windows:
#define windows_c	3
#if defined(linux_c) || defined( freeBSD_c ) || defined( macOS_c )

 #undef  windows_c
 
#endif


#ifdef windows_c
	enum OSChoice targetOS = windows_os;
#elif defined( linux_c )
	enum OSChoice targetOS = linux_os;
#elif defined( freeBSD_c )
	enum OSChoice targetOS = freeBSD_os;
#elif defined( macOS_c )
	enum OSChoice targetOS = macOS_os;
#endif 


char *OSChoiceStrs[numOSChoices] =
	{
		"Windows",
		"Linux",
		"FreeBSD",
		"Mac OSX",
	};
	
char *ASMChoiceStrs[numAssemblers] =
	{
		"MASM",
		"FASM",
		"TASM",
		"GAS",
		"NASM",
		"HLA",
		"HLABE",
	};
	



enum    asmLevel langLevel;			// Language level we support.





/*
** Commonly used strings in program:
*/

char	*SizeMismatchStr = 
			"Operand size mismatch";

char	*NeedsInitializerMsg =	
			"Declaration must have initializer in readonly section";
		
char	*NullPointer = "0";



/*
** Assembly time variables.
** This are visible to the programmer via built-in functions and pragmas.
**
** CurLexLevel- 	Current lexical nesting level (read-only in HLA pgm).
** CurOffset-		Current offset in Activation Record (read-only).
** CurOffsetDir-	-1 or 1, determines if adding or subtracting offsets
**					 (read-only).
** AddOffset1st-	Determines whether to associate offset with symbol before
**					 or after adding in the size of an object (read-only).
**
** StartParmOffs-	Starting offset in activation record for parameters
**					 (read/write value).
**
** StartLclOffs-	Starting offset of local variables in activation record
**					 (r/w value).
**
** EnumSize-		Size of an enum variable, in bytes (r/w).
**
** UseVMT-			True if compiler emits a VMT for a class, false if method
**					 pointers are stored as part of the class record (r/w).
**
** CompileBound-	True if HLA compiles the BOUND instruction, false if
**					HLA ignores the bound instruction.
**
** CompileInto-		True if HLA compiles the INTO instruction, false if
**					HLA ignores the into instruction.
**
** AlwaysAlignStk-	Forces stack alignment to an address that is an even
**					multiple of four upon entry into a procedure (if true).
*/

int	 CurLexLevel 	= 0;
int	 CurOffset 		= 0;
int	 CurOffsetDir 	= -1;
int	 AddOffset1st	= 1;	
int	 StartParmOffs	= 8;
int	 StartLclOffs	= 0;
int  EnumSize		= 1;
int	 MinParmSize	= 4;
int	 CompileBound	= 1;
int	 CompileInto	= 1;
int	 AlwaysAlignStk	= 1;
int  TraceFlag		= 0;	/* True if we should emit code to trace instrs	*/
int	 FullExceptions = 0;	/* True if we link in the full exception code.  */
int	 threadSafe		= 0;	/* True if we're generating thread-safe code.	*/

char *CurBaseReg	= "ebp";	/* Base register used for auto vars.		*/

int  UseVMT			= 1;	/* Need to add a built-in function for this */

char *FileName;				/* Current filename we're processing.		*/



/*
** Internal variables
*/

int		yyerrCount	 = 0;	/* # errors in the program */
int		EnumVal 	 = 0;
int		LblCntr 	 = 1;	/* Zero is reserved for use by BreakLbl		    */
int		TrueLabel	 = -1;	/* -1 indicates "true" is not a legal label.    */
int		FalseLabel	 = -1;	/* Ditto.									    */
int		VarMacParms	 = 0;
int		StackSize	 = 16384;
int		HasAbstract	 = 0;	/* True if there is at least one abstract proc  */

int		BreakLbl	 = 0;	/* 0 if not currently in a loop.			    */
int		EndTryLabel	 = 0;	/* Used to hold # to build last lbl in try.     */
int		IgnoreErrors = 0;	/* True if the program is to ignore errors	    */
int		TempIgnoreErrors = 0;

int		RecFieldCnt	= 0;	/* Used to count fields in records & unions		*/
int		testMode 	= 0;	/* True if -test, but false if HLABE			*/
int		testMode2	= 0;	/* True if -test								*/


 /*
 ** Variables used to deal with variable alignment.
 **
 **	MinVarAlignment- If a VAR object's size is smaller than this, then
 **					 align the object on this boundary rather than the
 **					 object's size.
 **
 **	MaxVarAlignment- If a VAR object's size is greater than this, then
 **					 align the object on this boundary rather than the
 **					 object's size.
 **
 ** TempVarAlign-	 If non-zero, then align the next object on this
 **					 boundary rather than the object's size.
 **
 ** MinRecAlignment,
 **	MaxRecAlignment,
 ** TempRecAlign-	 As above, but for records rather than auto vars.
 */

int		MinVarAlignment = 1;
int		MaxVarAlignment = 1;
int		TempVarAlign = 1;
int		HoldOffset = 0; 

int		MinRecAlignment = 1; /* Used to control alignment in records.		*/
int		MaxRecAlignment = 1; /* Used to control alignment in records.		*/
int		TempRecAlign = 1;	 /* For ALIGN directive inside a record.		*/


 /*
 ** Variables used to keep track of where we are in the code.
 **
 **	Note: Section is where we assemble all these boolean values to return
 ** them when the program encounters the "@section" built-in function.
 */

unsigned Section= 0;	/*	 Bit #	(in 32-bit "Section" variable		*/
						/*   -----										*/
int inConst		= 0;	/*		 0										*/
int inVal		= 0;	/*		 1										*/
int	inType		= 0;	/*		 2										*/
int	inVar		= 0;	/*		 3										*/
int inStatic	= 0;	/*		 4										*/
int	inReadonly	= 0;	/*		 5										*/
int inStorage	= 0;	/*		 6										*/

int	inMain		= 0;	/*		12										*/
int	inProcedure	= 0;	/*		13										*/
int	inMethod	= 0;	/*		14										*/
int	inIterator	= 0;	/*		15										*/
int inMacro		= 0;	/*		16										*/
int inKeyword	= 0;	/*		17										*/
int	inTerminator= 0;	/*		18										*/
int inThunk		= 0;	/*		19										*/

int	inUnit		= 0;	/*		23										*/
int	inProgram	= 0;	/*		24										*/
int	inRecord	= 0;	/*		25										*/
int	inUnion		= 0;	/*		26										*/
int	inClass		= 0;	/*		27										*/
int inNamespace = 0;	/*		28										*/
int inRegex		= 0;	/*		29										*/
		 

int wasProgram = 0;		// Used to generate a .link file.
 /*
 ** Variable to denote that we're in an @string parameter list:
 */
 
int	InAtString	= 0;
		 
	
 /*
 ** Default Values for procedure options:
 */
 
int	AlignStackDefault = 1;
int	FrameDefault = 1; 	
int	DisplayDefault = 1;
int AlignDefault = 1;
int LeaveDefault = 1;	// "1" means "no leave, use manual"
int EnterDefault = 1;	// "1" means "no enter, use manual"
	 
		
 /*
 ** Access to the environment variables "hlainc" and "hlatmp"
 */
	
char	*hlainc  	= NULL;	/* Path to HLA include directory.				*/
char	*hlaauxinc  = NULL;	/* Path to app-specific include directory.		*/
char 	*outPath 	= NULL;	/* hlatmp:Path prefix used for output files.	*/
char	*objPath 	= NULL;	/* -obj:obj output path for object files.		*/
char	*binName 	= NULL;	/* -b:obj output name for object files.			*/

char	*hlaThreadSafe	= NULL;	/* '1' = thread-safe compilation.			*/


 /*
 ** _initialize_ points at the "_initialize_" constant's symbol
 ** table entry.  This is a string constant that HLA emits at
 ** the beginning of the main program.
 */
 
struct SymNode *_initialize_;
	

 /*
 ** _finalize_ points at the "_finalize_" constant's symbol
 ** table entry.  This is a string constant that HLA emits at
 ** the end of the main program.
 */
 
struct SymNode *_finalize_;


 /*
 ** InvisibleCode contains NULL if we are not processing
 ** the _initialize_ nor the _finalize_ strings.  It contains
 ** a pointer to either string if we are processing one of these.
 ** This is used by the yyerror function if an error occurs
 ** in the initialization or finalization code.
 */
 
char *InvisibleCode;
	

/*
** Internal variables used to process forward references.
*/

struct	StaticListType	*StaticList		= NULL;
struct	MethodListType	*MethodList		= NULL;
struct	PointerListType	*PointerList	= NULL;
struct	PatchListType	*PatchBaseList	= NULL;
struct	SymNode			*ClassPtr 		= NULL;
struct	SymNode			*ThisPtr		= NULL;
struct	FwdRefLabelType	*FwdLabelsList	= NULL;
struct	SymNode			**MainLocals	= NULL;



/*
** Data structures and variables used by the begin..end (context..endcontext)
** statement.
*/


struct contextListType	*contextList = NULL; 
	

/*
** NSGlobal- 	Points at global objects outside a namespace
**				while we are building a namespace.
**
**	currentNS-	Points at the hash table for the current namespace
**				we are processing.
*/

struct SymNode			*NSGlobal		= NULL;
struct SymNode			*currentNS		= NULL;


/*
** RecGlobal-	Points at global objects outside a record's field list.
**
** recNS-		Points at the hash table for the current namespace
**				outside a record, if the record is within a namespace.
*/

struct SymNode			*RecGlobal		= NULL;
struct SymNode			*RecNS			= NULL;


/*
** ParmGlobal-	Points at global objects outside a parameter list.
**
** parmNS-		Points at the hash table for the current namespace
**				outside a parameter list, if the proc is within a namespace.
*/

struct SymNode			*ProcGlobal		= NULL;
struct SymNode			*ProcNS			= NULL;

/*
** fastNamespace-
**	Determines whether certain symbol lookup operations
**	automatically return an undefined symbol (e.g., variable declarations)
**	versus doing a full lookup.
**
** fastLookup-
**	Set when we expect an undefined symbol.  Both fastNamespace and
**	fastLookup must be true to do the short-circuit lookup in the flex code.
*/

int	fastNamespace = 0;
int fastLookup	  = 0;

/*
** ParmLookup-
**	True if we're looking up symbols in a parameter list.
*/

int	parmLookup = 0;


/*
** Variables that track the need for calls to the push_exceptionptr,
** Set_exceptionptr, and _HLA_GET_EXCEPTIONPTREBP function calls and
** usage of the ExceptionPtr variable (for external emission).
*/

int	need_raise						= 0;
int	need_ExceptionPtr				= 0;
int	need_HLA_PUSH_EXCEPTIONPTR		= 0;
int	need_HLA_SET_EXCEPTIONPTR		= 0; 
int	need_HLA_GET_EXCEPTIONPTREBP	= 0; 



/*
** SegmentList- Points at a list of strings containing
** names of user-defined segments.  Must be output
** to a ".LINK" file for use during the linker phase.
*/

struct segmentList_t
{
	struct segmentList_t *next;
	char* name;
};

struct segmentList_t *SegmentList = NULL;


/*
** Special global to hold cset constants.
*/

char GlobalCset[ CSetSizeInBytes ];


/*
** Special global used to build record constants.
*/

union YYSTYPE *RecordValues;


/*
** Pointer to the start of the symbol table.
*/

struct  SymNode	*SymbolTable 	= &true_ste;
struct	SymNode	*CurrentContext = NULL;


/*
** Name of the main program in the assembly language output file:
*/

char	*mainName = "start";


/*
** Assembly Language Output File variables.
*/

FILE	*fOut;
int		StartOfStmt;	// Points into file at start of each stmt.

/*
** Memory buffers to hold intermediate data
*/

outputBuf *asmBuf;
outputBuf preambleBuf;
outputBuf codeBuf;
outputBuf dataBuf;
outputBuf bssBuf;
outputBuf roBuf;
outputBuf constBuf;
outputBuf extBuf;


/*
** Error device output file variable.
*/

FILE *MsgOut  = NULL;


/*
** Output file handle (for #openwrite, #write, #closewrite, #print, #error ):
*/

FILE *writeHandle = NULL;
FILE *readHandle = NULL;
FILE *PrintOut = NULL;


// The following is used by the #includelib statement:

includeLibList_t *includeLibList = NULL; 


/*
** Various prototypes this code uses.
*/

extern struct SymNode *LastRefdObject;

static void ExpectedOrdinalConst( void );


							   
static int shiftSize[5] = {0, 3, 4, 0, 5};
static char *divRETURNS[5] = { "", "al", "ax", "", "eax"}; 
static char *modRETURNS[5] = { "", "ah", "dx", "", "edx"}; 
static char *mulRETURNS[5] = { "", "ax", "dx:ax", "", "edx:eax"}; 
			
//static char *sizenames[16] = 
//		{
//			"byte", 
//			"word", 
//			"byte", 
//			"dword",
//			"byte", 
//			"byte", 
//			"byte", 
//			"qword",			 
//			"byte", 
//			"byte", 
//			"byte", 
//			"byte", 
//			"byte", 
//			"byte", 
//			"byte", 
//			"byte" 
//		};
			
static enum PrimType sizetypes[16] = 
		{
			tByte, 
			tWord, 
			tByte, 
			tDWord,
			tByte, 
			tByte, 
			tByte, 
			tQWord,			 
			tByte, 
			tByte, 
			tByte, 
			tByte, 
			tByte, 
			tByte, 
			tByte, 
			tByte 
		};
							   


static char *relop2Operators[] =
{
	"=",		// eq_astop
	"<>",		// ne_astop
	"<",		// b_astop
	"<=",		// be_astop
	">",		// a_astop
	">=",		// ae_astop
	"<",		// l_astop
	"<=",		// le_astop
	">",		// g_astop
	">=",		// ge_astop
	"=0",		// eq0_astop
	"<>0",		// ne0_astop
	"in", 		// in_astop
	"not in"	// notin_astop
};



static char *uToSTi[] =
{
	"st0",
	"st1",
	"st2",
	"st3",
	"st4",
	"st5",
	"st6",
	"st7"
};

static char *uToXmm[] =
{
	"xmm0",
	"xmm1",
	"xmm2",
	"xmm3",
	"xmm4",
	"xmm5",
	"xmm6",
	"xmm7"
};

static char *uToMmx[] =
{
	"mm0",
	"mm1",
	"mm2",
	"mm3",
	"mm4",
	"mm5",
	"mm6",
	"mm7"
};

static char *uToSeg[numSEGregs] =
{
	"eseg",
	"cseg",
	"sseg",
	"dseg",
	"fseg",
	"gseg"
	
};




// The following table converts an encoded register value
// into the corresponding string.

char *regStrs[] =
{
	"al",
	"cl",
	"dl",
	"bl",
	"ah",

	"ch",
	"dh",
	"bh",
	
	"ax",
	"cx",
	"dx",
	"bx",
	"sp",
	"bp",
	"si",
	"di",
	
	"eax",
	"ecx",
	"edx",
	"ebx",
	"esp",
	"ebp",
	"esi",
	"edi"
	
};

char *segStrs[]=
{
	"es",
	"cs",
	"ss",
	"ds",
	"fs",
	"gs"
};

char *ctrlStrs[]=
{
	"cr0",
	"cr1",
	"cr2",
	"cr3",
	"cr4",
	"cr5",
	"cr6",
	"cr7"
};

char *dbgStrs[]=
{
	"dr0",
	"dr1",
	"dr2",
	"dr3",
	"dr4",
	"dr5",
	"dr6",
	"dr7"
};







static char *uToCmppsd[] =
{
	"cmpeqps",
	"cmpltps",
	"cmpleps",
	"cmpordps",
	"cmpneps",
	"cmpnltps",
	"cmpnleps",
	"cmpunordps",
	"cmpeqpd",
	"cmpltpd",
	"cmplepd",
	"cmpordpd",
	"cmpneqpd",
	"cmpnlepd",
	"cmpnltpd",
	"cmpunordpd"
};


static char *uToCmp2[] =
{
	"cmppd",
	"cmpps",
	"cmpss"
};

static char *xshiftStrs[]=
{
	"psllw",
	"pslld",
	"psllq",
	"psraw",
	"psrad",
	"psrlw",
	"psrld",
	"psrlq"
};


// Table to translate fp_instrs to fpp_instrs values:

static enum fpp_instrs fp_fpp_xlat[num_fp_instrs] =
	{
		fadd_instr,
		fmul_instr,
		fcom_instr,
		fcomp_instr,
		fsub_instr,
		fsubr_instr,
		fdiv_instr,
		fdivr_instr,
	};



/*
** Variables used to process the command line.
*/

int		CurArg;

int		DumpSymbols = 0;	/* -d option (dump symbol table).		*/
int		Verbose = 0;		/* -v option (verbose compile).			*/
char	*SourceFile = NULL;	/* Filename provided on cmd line.		*/

int		Suffix;
char	AsmName[ 1024 ];
char	LinkName[ 1024 ];
char	csname[ 256 ];
char	dataname[ 256 ];
char	bssname[ 256 ];
char	roname[ 256 ];
char	constname[ 256 ];



// assembler determines which assembler we're writing source code for.

enum	AsmChoice	assembler = masm;
enum	gasChoice	gasSyntax = stdGas;

// useHLABE controls whether to use the internal HLA back engine for code
// generation.

int	useHLABE = 0;


// sourceOutput is zero for hexadecimal instruction encoding output,
// one for source code instruction output.

int sourceOutput = 0;	// Default is hex opcode output.


// If OptimizeStrings is true, then HLA merges (folds)
// identical string constants;  otherwise it emits separate
// data for each identical string in the program.

int			OptimizeStrings = 1;


// Moved here from hlautils.

static char*
getFileStr( int startPosn )
_begin( getFileStr )

	char	*t;
	int		CurPosn;
	int		size;
	
	_here;
	CurPosn = asmBuf->offset;
	size = CurPosn - startPosn + 1;
	t = malloc2( size+2 );
	strncpy( t, asmBuf->base + startPosn, size );
	t[ size ] = '\0';
	asmBuf->offset = startPosn;
	_return t;
				
_end( getFileStr )






																	 




/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/

#ifndef __STDC__

	#define __STDC__ 1

#endif

extern int yylex( union YYSTYPE *yylval );		


%}


/*
** Note: field "s" holds a pointer to a symbol's entry in the symbol table.
**		 field "v" holds an arbitrary value (not associated with a symbol).
*/

%union
{
	unsigned				u;
	int						i;
	char					*idStr;
	char					*returns;
	struct	SymNode			*s;
	struct	SymNode			v;
	struct	MacroType		m;
	struct	adrsYYS			adrs;
	struct	memYYS			mem;
	struct	adrsYYS			*adrsPtr;
	struct	regYYS			reg;
	struct	opnodeYYS		*opnode;
	struct	operandYYS		*operand;
	struct	PointerListType	*plist;
	
	struct
	{
				char	*idStr;		// Must be first!
		struct	SymNode	*s;
	} neID;  // For anyID ("n" "e" ID :-) )
	
	struct
	{
		int					parmCnt;
		struct	SymNode		**types;
		char				*parms;
		enum	ParmForm	*pForms;
	} collectedParms;
	
	struct
	{
		int l;
		int r;
	} rr;
	
	struct
	{
		struct adrsYYS m;
		int r;
	} mr;
	
	struct
	{
		int r;
		struct adrsYYS m;
	} rm;
	

	struct
	{
		struct	SymNode	*s;
		struct	SymNode	*cns;
	}en;
	
	struct
	{
		struct	SymNode	*type;
		char			*idStr;
	}nameAndType;
	
	struct
	{
		int				ints[4];
		unsigned		unss[4];
		struct	SymNode	*syms[4];
	}save;
	
		
		
	
	// Attributes for record and unions where we can save important data.
	
	struct
	{
		struct SymNode *endFields;
		struct SymNode *base;
		struct SymNode *saveCurNS;
		struct SymNode *saveRecNS;
		struct SymNode *saveRecGlobal;
		struct SymNode *saveProcNS;
		struct SymNode *saveProcGlobal;
		int MinRecAlignment;
		int MaxRecAlignment;
		int TempRecAlign;
		int RecFieldCnt;
		int CurOffset;
		int SaveOffset;
		int SaveDir;
		int SaveAdd1st;
		int SaveLex;
		char inSave;
		char newOffset;
		
	}ru;
	
	struct
	{
		short			SpecifiedOptions;
		short			UseFrame;
		short			UseDisplay;
		short			AlignStk;
		short			Alignment;
		short			NoStorage;
		short			NoEnter;
		short			NoLeave;
		short			IsVolatile;
		enum CallSeq	CallingSequence;
		char			*returns;
		char			*use;
	}options;


	struct
	{
				int			Disp;
		char				*FullName;
		struct	SymNode		*Sym;
		char				*StaticName;
	}dotName;

	struct
	{
		struct	SymNode		*sym;
		struct	SymNode		*type;
		unsigned			ObjectSize;
		unsigned			cls;
		unsigned			arity;
	}cls;


	struct
	{
		union
		{
			int				label1;
			int				trueTarget;
		}l1;
		union
		{
			int				label2;
			int				falseTarget;
		}l2;
		union
		{
			int				label3;
			int				exitTarget;
		}l3;
		int					label4;
		int					saveTrue;
		int					saveFalse;
		
	}labels;
	
	// The following is used when parsing #for loops.
	
	struct
	{
		struct	SymNode		*ControlVar;
		union	YYSTYPE		*inVal;
				int			endVal;
				int			byVal;
		enum	PrimType	pType;
	}forInfo;
	
	struct
	{
		int		cnt;
		int		size;
		char	bytes[8];
	}opcodes;
	
	struct
	{
		int		minRange;
		int		maxRange;
		int		lazy;
	}ranges;
	
	// The following is used to process switch/case/default/endswitch statements:
	
	struct
	{
		unsigned	cnt;
		int			minval;
		int			startOfCases;
		int			defaultLbl;
		int			exitLbl;
		int			*cases;
		int			*caseLbls;
	}cases;
	
	struct
	{
		unsigned	cnt;
		int			*cases;
	} caseVals;
	
}
  



%{
/*
** Variable that holds ConstExpr return values for the lexer.
*/

struct	SymNode	d1ceReturnVal;
union	YYSTYPE	d1dnReturnVal;
union	YYSTYPE	forReturnVal;
%}




%nonassoc dupTkn
%left '|' '^' orTkn lorTkn
%left '&' inTkn andTkn landTkn
%left '<' '>' leTkn geTkn '=' neTkn
%left '+' '-'
%left '*' '/' divTkn modTkn shlopTkn shropTkn
%right UMINUS notTkn

%token intconst
%token hexconst
%token binconst
%token fltconst
%token charconst
%token wcharconst
%token strconst
%token wstrconst
%token regexconst

%token assignTkn
%token addassignTkn
%token subassignTkn
%token modTkn
%token shlopTkn
%token shropTkn
%token DotDot
%token coloncolonTkn
%token matchTkn
%token match2Tkn
%token stmtsTkn
%token endstmtsTkn

%token UndefID

%token RegexID
%token atTkn
%token posTkn
%token tabTkn
%token arbTkn

%token LocalID
%token LocalConstID
%token LocalVarID
%token LocalStaticID
%token LocalProcID
%token LocalIterID
%token LocalMethodID
%token LocalLabelID

%token NonLocalID
%token NonLocalConstID
%token NonLocalVarID
%token NonLocalStaticID
%token NonLocalProcID
%token NonLocalIterID
%token NonLocalMethodID
%token NonLocalLabelID

%token OverloadedID
%token ovldClassTkn

%token ClassVarID
%token ClassStaticID
%token ClassProcID
%token ClassIterID
%token ClassMethodID




 /*
 ** Special recursive parser entry tokens
 */

%token	MacroParmTkn
%token	LastMacroParmTkn
%token	MacroID
%token	DoMacroDclTkn
%token	DoRegexDclTkn
%token  compileRegexTkn
%token	TextParameters
%token	DoOneValStmt
%token	DoOneConstExpr
%token	ctforTkn

%token	textblockTkn
%token	endtextTkn

%token	stringblockTkn
%token	endstringTkn

%token	matchblockTkn
%token	endmatchTkn




/* Function tokens */

%token beginTkn
%token endTkn
%token procTkn
%token endprocTkn
%token procedureTkn
%token iteratorTkn
%token methodTkn
%token programTkn
%token unitTkn

%token macroTkn
%token keywordTkn
%token terminatorTkn
%token endmacroTkn
%token endMacDefTkn

%token regexMacroTkn
%token endregexTkn
%token endRegexDefTkn
%token regexReturnTkn

/* Declaration tokens */

%token labelTkn
%token endlabelTkn
%token constTkn
%token endconstTkn
%token valTkn
%token endvalTkn
%token typeTkn
%token endtypeTkn
%token alignTkn
%token varTkn
%token endvarTkn
%token staticTkn
%token endstaticTkn
%token uninitializedTkn
%token endstorageTkn
%token readonlyTkn
%token endreadonlyTkn
%token recordTkn
%token endrecordTkn
%token unionTkn
%token endunionTkn
%token classTkn
%token vmtTkn
%token endclassTkn
%token enumTkn
%token inheritsTkn
%token pointerTkn
%token toTkn
%token downtoTkn
%token externalTkn
%token abstractTkn
%token overloadsTkn
%token overrideTkn
%token overridesTkn
%token forwardTkn
%token returnsTkn
%token atreturnsTkn
%token noframeTkn
%token frameTkn
%token nodisplayTkn
%token displayTkn
%token noalignstkTkn
%token alignstkTkn
%token alignprocTkn
%token useTkn
%token useenterTkn
%token noenterTkn
%token useleaveTkn
%token noleaveTkn
%token pascalTkn
%token cdeclTkn
%token stdcallTkn
%token nostorageTkn
%token volatileTkn
%token namespaceTkn
%token fastTkn
%token segmentTkn
%token hereTkn
%token atlabelTkn

%token	nameTkn
%token	valresTkn
%token	resultTkn
%token	lazyTkn
%token	thunkTkn

 /*
 ** HLL tokens
 */

%token jtTkn
%token jfTkn
%token ifTkn
%token thenTkn
%token elseifTkn
%token elseTkn
%token endifTkn

%token switchTkn
%token caseTkn
%token defaultTkn
%token endswitchTkn

%token whileTkn
%token doTkn
%token endwhileTkn
%token welseTkn

%token repeatTkn
%token untilTkn

%token forTkn
%token foreverTkn
%token foreachTkn
%token endforTkn
%token felseTkn

%token exitTkn
%token exitifTkn


%token breakTkn
%token breakifTkn

%token continueTkn
%token continueifTkn
					  
%token tryTkn
%token unprotectedTkn
%token exceptionTkn
%token anyexceptionTkn
%token endtryTkn
%token raiseTkn
						
 /*
 ** Data types
 */

%token booleanTkn
%token int8Tkn int16Tkn int32Tkn int64Tkn int128Tkn
%token charTkn wcharTkn
%token real32Tkn real64Tkn real80Tkn real128Tkn
%token uns8Tkn uns16Tkn uns32Tkn uns64Tkn uns128Tkn
%token stringTkn wstringTkn zstringTkn
%token csetTkn
%token regexTkn	
%token textTkn
%token byteTkn wordTkn dwordTkn qwordTkn tbyteTkn lwordTkn

%token atint8Tkn atint16Tkn atint32Tkn atint64Tkn atint128Tkn
%token atcharTkn atwcharTkn
%token atreal32Tkn atreal64Tkn atreal80Tkn
%token atuns8Tkn atuns16Tkn atuns32Tkn atuns64Tkn atuns128Tkn
%token atstringTkn atwstringTkn
%token atcsetTkn	
%token atbyteTkn atwordTkn atdwordTkn atqwordTkn attbyteTkn atlwordTkn
%token atpointerTkn


%token nullTkn

 /* 
 ** Constant functions 
 */

%token	absTkn
%token	ceilTkn cosTkn dateTkn envTkn
%token	expTkn extractTkn floorTkn
%token	isalphaTkn isalphanumTkn
%token	isdigitTkn islowerTkn isspaceTkn isupperTkn
%token	isxdigitTkn logTkn log10Tkn
%token	maxTkn minTkn oddTkn randomTkn
%token	randomizeTkn readTkn 
%token  sinTkn sortTkn sqrtTkn systemTkn
%token	tanTkn threadTkn timeTkn


 /*
 ** Pattern matching functions:
 */

%token peekcsetTkn			
%token onecsetTkn			
%token uptocsetTkn			
%token zerooronecsetTkn		
%token zeroormorecsetTkn	
%token oneormorecsetTkn		
%token exactlyncsetTkn		
%token firstncsetTkn		
%token norlesscsetTkn		
%token normorecsetTkn		
%token ntomcsetTkn			
%token exactlyntomcsetTkn	

%token peekcharTkn			
%token onecharTkn			
%token uptocharTkn			
%token zerooronecharTkn		
%token zeroormorecharTkn	
%token oneormorecharTkn		
%token exactlyncharTkn		
%token firstncharTkn		
%token norlesscharTkn		
%token normorecharTkn		
%token ntomcharTkn			
%token exactlyntomcharTkn	

%token peekicharTkn			
%token oneicharTkn			
%token uptoicharTkn			
%token zerooroneicharTkn	
%token zeroormoreicharTkn	
%token oneormoreicharTkn	
%token exactlynicharTkn		
%token firstnicharTkn		
%token norlessicharTkn		
%token normoreicharTkn		
%token ntomicharTkn			
%token exactlyntomicharTkn

%token matchstrTkn			
%token matchistrTkn			
%token uptostrTkn			
%token uptoistrTkn			
%token matchtostrTkn		
%token matchtoistrTkn		

%token zeroormorewsTkn		
%token oneormorewsTkn		
%token wsoreosTkn			
%token wstheneosTkn			
%token peekwsTkn			
%token eosTkn
%token wsTkn				

%token peekstrTkn
%token peekistrTkn
%token matchidTkn		
%token matchwordTkn		
%token matchiwordTkn		
%token matchintconstTkn	
%token matchrealconstTkn
%token matchnumericconstTkn
%token matchstrconstTkn	


%token matchregTkn	
%token matchreg8Tkn	
%token matchreg16Tkn
%token matchreg32Tkn
%token matchfpuregTkn
%token matchmmxregTkn
%token matchxmmregTkn


 /*
 ** String Functions:
 */

%token	deleteTkn
%token	indexTkn	  
%token	insertTkn	  
%token	lengthTkn	  
%token	lowercaseTkn
%token	rindexTkn	  
%token	strbrkTkn	  
%token	strsetTkn	  
%token	strspanTkn  
%token	substrTkn	  
%token	tokenizeTkn 
%token	trimTkn	  
%token	uppercaseTkn

 /*
 ** Symbol table functions
 */

%token symNameTkn
%token symTypeTkn sympTypeTkn symBasepTypeTkn symClassTkn symSizeTkn 
%token symOffsetTkn symLocalsymsTkn symParmsTkn
%token symLexTkn symArityTkn symDimTkn symNumelementsTkn symDefinedTkn
%token symTypeNameTkn symBaseTypeNameTkn sympClassTkn symStaticNameTkn 
%token symIsExternalTkn symIsConstTkn symIsClassTkn symElementSizeTkn
%token symIsRegTkn symIsReg8Tkn symIsReg16Tkn symIsReg32Tkn symIsfRegTkn
%token symIsMemTkn symIsTypeTkn

	
 /*	   
 ** Assembly-time constants and variables
 */

%token curLexTkn curOffsetTkn curDirTkn addOffset1stTkn lineNumberTkn
%token filenameTkn
%token startParmOfsTkn
%token startLclOfsTkn
%token enumSizeTkn
%token lastMacroObjectTkn
%token curObjectNameTkn
%token sectionTkn
%token boundvarTkn
%token intovarTkn
%token traceTkn
%token exceptsTkn
%token optstringsTkn
%token baseregTkn


 /*
 ** Machine register tokens
 */

%token st0Tkn
%token st1Tkn
%token st2Tkn
%token st3Tkn
%token st4Tkn
%token st5Tkn
%token st6Tkn
%token st7Tkn


%token alTkn
%token ahTkn
%token axTkn
%token eaxTkn

%token blTkn
%token bhTkn
%token bxTkn
%token ebxTkn

%token clTkn
%token chTkn
%token cxTkn
%token ecxTkn

%token dlTkn
%token dhTkn
%token dxTkn
%token edxTkn

%token siTkn
%token esiTkn

%token diTkn
%token ediTkn

%token bpTkn
%token ebpTkn

%token spTkn
%token espTkn


%token mm0Tkn
%token mm1Tkn
%token mm2Tkn
%token mm3Tkn
%token mm4Tkn
%token mm5Tkn
%token mm6Tkn
%token mm7Tkn

%token xmm0Tkn
%token xmm1Tkn
%token xmm2Tkn
%token xmm3Tkn
%token xmm4Tkn
%token xmm5Tkn
%token xmm6Tkn
%token xmm7Tkn

%token csTkn
%token dsTkn
%token esTkn
%token fsTkn
%token gsTkn
%token ssTkn

%token cr0Tkn
%token cr1Tkn
%token cr2Tkn
%token cr3Tkn
%token cr4Tkn
%token cr5Tkn
%token cr6Tkn
%token cr7Tkn

%token dr0Tkn
%token dr1Tkn
%token dr2Tkn
%token dr3Tkn
%token dr4Tkn
%token dr5Tkn
%token dr6Tkn
%token dr7Tkn


%token dxaxTkn
%token edxeaxTkn

/*
** the following is processed completely by the lexer:

%token thisTkn
*/

%token cTkn
%token ncTkn

%token oTkn
%token noTkn

%token sTkn
%token nsTkn

%token zTkn
%token nzTkn

%token aTkn
%token naTkn

%token aeTkn
%token naeTkn

%token bTkn
%token nbTkn

%token beTkn
%token nbeTkn

%token eTkn
%token neTkn

%token gTkn
%token ngTkn

%token geTkn
%token ngeTkn

%token lTkn
%token nlTkn

%token leTkn
%token nleTkn

%token peTkn
%token poTkn
%token npTkn
%token pTkn


 /*
 ** Machine instruction tokens
 */

%token aaaTkn
%token aadTkn
%token aamTkn
%token aasTkn
%token adcTkn
%token lockadcTkn
%token addTkn
%token lockaddTkn
%token andTkn
%token lockandTkn
%token arplTkn
%token boundTkn
%token bsfTkn
%token bsrTkn
%token bswapTkn
%token btTkn
%token btcTkn
%token lockbtcTkn
%token btrTkn
%token lockbtrTkn
%token btsTkn
%token lockbtsTkn
%token callTkn
%token cbwTkn
%token cdqTkn
%token clcTkn
%token cldTkn
%token cliTkn
%token cltsTkn
%token cmcTkn

%token cmovoTkn
%token cmovnoTkn
%token cmovbTkn
%token cmovnbTkn
%token cmoveTkn
%token cmovneTkn
%token cmovbeTkn
%token cmovnbeTkn
%token cmovsTkn
%token cmovnsTkn
%token cmovpTkn
%token cmovnpTkn
%token cmovlTkn
%token cmovnlTkn
%token cmovleTkn
%token cmovnleTkn

%token cmpTkn
%token cmpsbTkn
%token cmpsdTkn
%token cmpswTkn
%token cmpxchgTkn
%token lockcmpxchgTkn
%token cmpxchg8bTkn
%token cpuidTkn
%token cwdTkn
%token cwdeTkn
%token daaTkn
%token dasTkn
%token decTkn
%token lockdecTkn
%token divTkn
%token enterTkn
%token hltTkn
%token idivTkn
%token imodTkn
%token imulTkn
%token intmulTkn
%token inTkn
%token incTkn
%token lockincTkn
%token insbTkn
%token insdTkn
%token inswTkn
%token intTkn
%token intoTkn
%token invdTkn
%token invlpgTkn
%token iretTkn
%token iretdTkn

%token jaTkn  
%token jaeTkn 
%token jbTkn  
%token jbeTkn 
%token jcTkn  
%token jeTkn  
%token jgTkn  
%token jgeTkn 
%token jlTkn  
%token jleTkn 
%token jnaTkn 
%token jnaeTkn
%token jnbTkn 
%token jnbeTkn
%token jncTkn 
%token jneTkn 
%token jngTkn 
%token jngeTkn
%token jnlTkn 
%token jnleTkn
%token jnoTkn 
%token joTkn
%token jnpTkn 
%token jnsTkn 
%token jnzTkn 
%token jpTkn  
%token jpeTkn 
%token jpoTkn 
%token jsTkn  
%token jzTkn  

%token jcxzTkn
%token jecxzTkn

%token jmpTkn
%token lahfTkn
%token larTkn
%token leaTkn
%token ldsTkn
%token lesTkn
%token lfsTkn
%token lgsTkn
%token lssTkn
%token lslTkn
%token lgdtTkn
%token lidtTkn
%token lldtTkn
%token sgdtTkn
%token sidtTkn
%token sldtTkn
%token leaveTkn
%token lodsbTkn
%token lodsdTkn
%token lodswTkn
%token loopTkn
%token loopeTkn
%token loopzTkn
%token loopneTkn
%token loopnzTkn
%token lmswTkn
%token ltrTkn
%token strTkn
%token movTkn
%token movsbTkn
%token movsdTkn
%token movswTkn
%token movsxTkn
%token movzxTkn
%token mulTkn
%token negTkn
%token locknegTkn
%token nopTkn
%token notTkn
%token locknotTkn
%token orTkn
%token lockorTkn
%token outTkn
%token outsbTkn
%token outsdTkn
%token outswTkn
%token popTkn
%token popaTkn
%token popadTkn
%token popfTkn
%token popfdTkn
%token pushTkn
%token pushaTkn
%token pushadTkn
%token pushdTkn
%token pushfTkn
%token pushfdTkn
%token pushwTkn
%token rclTkn
%token rcrTkn
%token rdmsrTkn
%token rdpmcTkn
%token rdtscTkn
%token rsmTkn

%token repmovsbTkn	
%token repmovswTkn	
%token repmovsdTkn	
%token repinsbTkn
%token repinswTkn
%token repinsdTkn
%token repoutsbTkn	
%token repoutswTkn	
%token repoutsdTkn	
%token repstosbTkn	
%token repstoswTkn	
%token repstosdTkn	

%token repecmpsbTkn
%token repecmpswTkn
%token repecmpsdTkn

%token repzcmpsbTkn
%token repzcmpswTkn
%token repzcmpsdTkn

%token repnecmpsbTkn
%token repnecmpswTkn
%token repnecmpsdTkn

%token repnzcmpsbTkn
%token repnzcmpswTkn
%token repnzcmpsdTkn
 
%token repescasbTkn
%token repescaswTkn
%token repescasdTkn

%token repnescasbTkn
%token repnescaswTkn
%token repnescasdTkn
 
%token repzscasbTkn
%token repzscaswTkn
%token repzscasdTkn

%token repnzscasbTkn
%token repnzscaswTkn
%token repnzscasdTkn

%token retTkn
%token rolTkn
%token rorTkn
%token sahfTkn
%token salTkn
%token sarTkn
%token sbbTkn
%token locksbbTkn
%token scasbTkn
%token scasdTkn
%token scaswTkn

%token setbTkn
%token setnbTkn
%token setzTkn
%token setnzTkn
%token setbeTkn
%token setnbeTkn
%token setoTkn
%token setnoTkn
%token setsTkn
%token setnsTkn
%token setpTkn
%token setnpTkn
%token setlTkn
%token setleTkn
%token setnlTkn
%token setnleTkn

%token shlTkn
%token shldTkn
%token shrTkn
%token shrdTkn
%token smswTkn
%token stcTkn
%token stdTkn
%token stiTkn
%token stosbTkn
%token stosdTkn
%token stoswTkn
%token subTkn
%token sysenterTkn
%token sysexitTkn
%token locksubTkn
%token testTkn
%token ud2Tkn
%token verrTkn
%token verwTkn
%token waitTkn
%token wbinvdTkn
%token wrmsrTkn
%token xaddTkn
%token lockxaddTkn
%token xchgTkn
%token lockxchgTkn
%token xlatTkn
%token xorTkn
%token lockxorTkn




/*
** Floating point instructions
*/

%token fldTkn
%token fildTkn	
%token fbldTkn	
%token fstTkn	
%token fstpTkn	
%token fistTkn	
%token fistpTkn	
%token fisttpTkn	
%token fbstpTkn	
%token fxchTkn	
%token fxamTkn	

%token faddTkn	
%token faddpTkn	
%token fiaddTkn	

%token fmulTkn	
%token fmulpTkn	
%token fimulTkn	

%token fsubTkn	
%token fsubpTkn	
%token fsubrTkn	
%token fsubrpTkn
%token fisubTkn	
%token fisubrTkn

%token fdivTkn	
%token fdivpTkn	
%token fdivrTkn	
%token fdivrpTkn
%token fidivTkn	
%token fidivrTkn

%token fcomTkn	
%token fcompTkn	
%token fcomppTkn
%token ficomTkn	
%token ficompTkn

%token fucomTkn	
%token fucompTkn
%token fucomppTkn

%token fsqrtTkn	
%token fabsTkn	
%token fchsTkn	
%token ftstTkn	
%token fscaleTkn
%token fpremTkn	
%token fprem1Tkn
%token frndintTkn
%token fxtractTkn

%token fldzTkn	
%token fld1Tkn	
%token fldpiTkn	
%token fldl2tTkn
%token fldl2eTkn
%token fldlg2Tkn
%token fldln2Tkn

%token f2xm1Tkn	
%token fsinTkn	
%token fcosTkn	
%token fsincosTkn
%token fptanTkn	
%token fpatanTkn

%token fyl2xTkn	
%token fyl2xp1Tkn

%token finitTkn	
%token fninitTkn	
%token fwaitTkn	
%token fldcwTkn	
%token fstcwTkn	
%token fnstcwTkn	
%token fclexTkn	
%token fnclexTkn	
%token fldenvTkn
%token fstenvTkn
%token fnstenvTkn
%token fsaveTkn	
%token fnsaveTkn	
%token frstorTkn
%token fstswTkn	
%token fnstswTkn	
%token fincstpTkn
%token fdecstpTkn
%token fnopTkn	
%token ffreeTkn		


%token fcmovaTkn	
%token fcmovaeTkn	
%token fcmovbTkn	
%token fcmovbeTkn	
%token fcmoveTkn	
%token fcmovnaTkn	
%token fcmovnaeTkn
%token fcmovnbTkn	
%token fcmovnbeTkn
%token fcmovneTkn	
%token fcmovnuTkn	
%token fcmovuTkn	

%token fcomiTkn		
%token fcomipTkn	
%token fucomiTkn	
%token fucomipTkn



/*
** MMX Instructions
*/


%token paddbTkn
%token paddwTkn
%token padddTkn
%token paddqTkn
%token paddsbTkn
%token paddswTkn
%token paddusbTkn
%token padduswTkn

%token psubbTkn
%token psubwTkn
%token psubdTkn
%token psubqTkn
%token psubsbTkn
%token psubswTkn
%token psubusbTkn
%token psubuswTkn

%token pmullwTkn
%token pmulhwTkn
%token pmulhuwTkn
%token pmuludqTkn
%token pmaddwdTkn

%token pmaxswTkn
%token pmaxubTkn	

%token pminswTkn	
%token pminubTkn	

%token psadbwTkn	

%token pextrwTkn	
%token pinsrwTkn	
%token pmovmskbTkn
%token pshufwTkn
%token pshufdTkn

%token pavgbTkn
%token pavgwTkn

%token pcmpeqbTkn
%token pcmpeqwTkn
%token pcmpeqdTkn
%token pcmpgtbTkn
%token pcmpgtwTkn
%token pcmpgtdTkn

%token packsswbTkn
%token packuswbTkn
%token packssdwTkn

%token punpcklbwTkn
%token punpcklwdTkn
%token punpckldqTkn
%token punpcklqdqTkn
%token punpckhbwTkn
%token punpckhwdTkn
%token punpckhdqTkn
%token punpckhqdqTkn

%token pandTkn
%token pandnTkn
%token porTkn
%token pxorTkn

%token psllwTkn
%token pslldTkn
%token psllqTkn
%token psrlwTkn
%token psrldTkn
%token psrlqTkn
%token psrawTkn
%token psradTkn

%token movdTkn
%token movqTkn

%token emmsTkn

/*
** SSE Instructions:
*/

%token addpdTkn		
%token addsdTkn		
%token addpsTkn		
%token addssTkn
%token addsubpsTkn		
%token addsubpdTkn		
%token andnpdTkn	
%token andnpsTkn	
%token andpdTkn		
%token andpsTkn		
%token clflushTkn	
%token cmppdTkn		
%token cmppsTkn		
%token cmpssTkn		
%token cmpeqssTkn		
%token cmplessTkn		
%token cmpltssTkn		
%token cmpneqssTkn		
%token cmpnltssTkn		
%token cmpnlessTkn		
%token cmpordssTkn		
%token cmpunordssTkn	
%token cmpeqsdTkn		
%token cmplesdTkn		
%token cmpltsdTkn		
%token cmpneqsdTkn		
%token cmpnltsdTkn		
%token cmpnlesdTkn		
%token cmpordsdTkn		
%token cmpunordsdTkn

%token cmpeqpsTkn		
%token cmplepsTkn		
%token cmpltpsTkn		
%token cmpneqpsTkn		
%token cmpnltpsTkn		
%token cmpnlepsTkn		
%token cmpordpsTkn		
%token cmpunordpsTkn	

%token cmpeqpdTkn		
%token cmplepdTkn		
%token cmpltpdTkn		
%token cmpneqpdTkn		
%token cmpnltpdTkn		
%token cmpnlepdTkn		
%token cmpordpdTkn		
%token cmpunordpdTkn	

	
%token comisdTkn	
%token comissTkn	
%token cvtdq2pdTkn	
%token cvtdq2psTkn	
%token cvtpd2dqTkn	
%token cvtpd2piTkn	
%token cvtpd2psTkn	
%token cvtpi2pdTkn	
%token cvtpi2psTkn	
%token cvtps2dqTkn	
%token cvtps2pdTkn	
%token cvtps2piTkn	
%token cvtsd2siTkn	
%token cvtsi2sdTkn	
%token cvtsi2ssTkn	
%token cvtsd2ssTkn	
%token cvtss2sdTkn	
%token cvtss2siTkn	
%token cvttpd2piTkn
%token cvttpd2dqTkn
%token cvttps2dqTkn
%token cvttps2piTkn
%token cvttsd2siTkn
%token cvttss2siTkn
%token divpdTkn		
%token divpsTkn		
%token divssTkn		
%token divsdTkn		
%token fxsaveTkn	
%token fxrstorTkn	
%token haddpdTkn
%token haddpsTkn
%token hsubpdTkn
%token hsubpsTkn
%token lddquTkn
%token ldmxcsrTkn	
%token lfenceTkn	
%token maskmovdquTkn
%token maskmovqTkn	
%token maxpdTkn		
%token maxpsTkn		
%token maxsdTkn		
%token maxssTkn		
%token mfenceTkn	
%token minpdTkn		
%token minpsTkn		
%token minsdTkn		
%token minssTkn
%token monitorTkn		
%token movapdTkn	
%token movapsTkn
%token movddupTkn	
%token movdqaTkn	
%token movdquTkn	
%token movdq2qTkn	
%token movhlpsTkn	
%token movhpdTkn	
%token movhpsTkn	
%token movlpdTkn	
%token movlpsTkn	
%token movlhpsTkn	
%token movmskpdTkn	
%token movmskpsTkn	
%token movntpdTkn	
%token movntiTkn	
%token movntpsTkn	
%token movntdqTkn	
%token movntqTkn	
%token movq2dqTkn	
%token movshdupTkn
%token movsldupTkn	
%token movssTkn		
%token movupdTkn	
%token movupsTkn	
%token mulpdTkn		
%token mulpsTkn		
%token mulssTkn		
%token mulsdTkn
%token mwaitTkn		
%token orpdTkn		
%token orpsTkn	
%token pauseTkn	
%token prefetcht0Tkn	
%token prefetcht1Tkn	
%token prefetcht2Tkn	
%token prefetchntaTkn
%token pshufhwTkn
%token pshuflwTkn
%token psrldqTkn
%token pslldqTkn
%token rcppsTkn	
%token rcpssTkn	
%token rsqrtpsTkn	
%token rsqrtssTkn	
%token sfenceTkn	
%token shufpdTkn	
%token shufpsTkn	
%token sqrtpdTkn	
%token sqrtpsTkn	
%token sqrtsdTkn	
%token sqrtssTkn	
%token stmxcsrTkn	
%token subpsTkn		
%token subpdTkn		
%token subsdTkn	
%token subssTkn	
%token ucomisdTkn
%token ucomissTkn
%token unpckhpdTkn	
%token unpckhpsTkn	
%token unpcklpdTkn	
%token unpcklpsTkn	
%token xorpdTkn		
%token xorpsTkn		

/*
** Misc Tokens
*/

%token parsePrintTkn
%token parseHLAIDTkn
%token parseClassIDTkn



%%


 /*
 ** Here is the main production we work from.
 **
 **	If "PROGRAM" or "UNIT" is the first lexeme, then the
 ** "pgm" or "unit" productions take control.  The remaining
 ** productions handle recursive entries into the parser (which
 ** are generally made from the lexer).
 */


ParserEntry:

		pgm
	|	unit


		/*
		** Handle the parameter for the @TEXT function here.
		*/
		 
	|	doTextParameters

		/*
		** Handle the parameter list for a macro invocation here.
		*/

	|	doMacroParameters
	
		/*
		** Handle a macro declaration here
		*/
		
	|	doMacroDcl

		/*
		** Handle a regular expression declaration here
		*/
		
	|	doRegexDcl

		/*
		** Handle a statement beginning with "?" here.
		*/

	|	doOneValStmt

		/*
		** Various function calls handled directly by the lexer
		** need a constant expression surrounded by parentheses.
		** The following production handles this.
		*/

	|	doOneConstExpr
	

		/*
		** The following productions handle dotted object names
		** for the lexer.
		*/

	|	doParseObjID
	|	doParseClassID

		/*
		** The following production handles the parameter list
		** for the #print statement.
		*/

	|	doPrint

		/*
		** The following production collects all the text between
		** the #text and #endtext directives and places this text
		** in a string array.
		*/

	|	doTextBlock

		/*
		** The following production collects all the text between
		** the #string and #endstring directives and places this text
		** in a string.
		*/

	|	doStringBlock

		/*
		** The following production collects all the text between
		** the #match and #endmatch directives and process this
		** text accordingly.
		*/

	|	doMatchBlock
	
	
		/*
		** The following handles the #for loop:
		*/
	
	|	doCTForLoop
	
		/*
		** The following compiles Regex blocks:
		*/
		
	|	doCompileRegexTkn
	;





 /*
 ** This recursive entry to the parser handles the #for loop:
 */
 
doCTForLoop:
		ctforTkn		/* $1 */
		Lparen			/* $2 */
		ValID			/* $3 */
		assignTkn		/* $4 */
		ConstExpr		/* $5 */
		toTkn			/* $6 */
		ConstExpr		/* $7 */
		Rparen			/* $8 */
		{
			_here;
			doCTForLoop9
			( 
				$<s>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				1 
			);
			YYACCEPT;
		}
	;
	
 
	
doCTForLoop:
		ctforTkn		/* $1 */
		Lparen			/* $2 */
		ValID			/* $3 */
		assignTkn		/* $4 */
		ConstExpr		/* $5 */
		downtoTkn		/* $6 */
		ConstExpr		/* $7 */
		Rparen			/* $8 */
		{
			_here;
			doCTForLoop9( $<s>3, YYS &$<v>5, YYS &$<v>7, -1 );
			YYACCEPT;
				
		}
	;
	
	
doCTForLoop:
		ctforTkn		/* $1 */
		Lparen			/* $2 */
		ValID			/* $3 */
		inTkn			/* $4 */
		ConstExpr		/* $5 */
		Rparen			/* $6 */
		{
			union	YYSTYPE	v;

			_here;
			doCTForLoop7( $<s>3, YYS &$<v>5 );
			YYACCEPT;
				
		}
	;
	
lclUndefID:
		UndefID
		{
			_here;
			$<idStr>$ = $<idStr>1;
		}
	;
			
	
ValID:
		lclUndefID
		{
			union	YYSTYPE	dummy;
			
			_here;
			dummy.v.u.intval = 0;
			InsertSym
			( 
				$<idStr>1, 
				&int32_ste,		/* Default is int32 object.		*/
				tInt32,
				cValue, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				YYS &dummy,		/* Initially, no initialization	*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);
			$<s>$ = SymbolTable;
			_here;
		}
	
	|	DefinedID
		{
			_here;
			$<s>$ = $<s>1;
			
			
			_if( $<s>1->SymClass != cValue )
			
				yyerror
				( 
					"Expected a VALUE identifier as the #FOR "
					"loop control variable" 
				);
				$<s>$ = &forctrlvar_ste;
				
			_else
			
				FreeValue( YYS $<s>1 );
				$<s>1->pType = tInt32;
				$<s>1->Type = &int32_ste;
				
			_endif
		}
	; 
		


 /*
 ** Here is a recursive entry point to the parser.
 ** Whenever the lexer encounters @text it will immediately
 ** expand the following string parameter.  The following
 ** productions process that string parameter.
 */

doTextParameters: 

		TextParameters	/* $1 */
		'(' 			/* $2 */
		ConstOnlyExpr 	/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			
			_here;
			_if( doCollect )
			
				PushBackStr( "\xDD" );
				delayCollect = 1;
				
			_endif
			
			doTextParameters5( YYS &$<v>3 );
			YYACCEPT;
		}
	;


/**************************************************************************/


 /*
 ** Yet another recursive entry to the parser.
 ** This one evaluates a single VAL statement to handle the "?"
 ** operator.
 */

doOneValStmt: 
		SetValTrue
		DoOneValStmt 
		ValueRedef 
		{ 
			_here; 
			inVal = $<v.u.unsval>1;
			YYACCEPT; 
			_here; 
		}
	;

SetValTrue:
		{
			_here;
			$<v.u.unsval>$ = inVal;
			inVal = 1;
			_here;
		}
	;

/**************************************************************************/


 /*
 ** Yet another recursive entry to the parser.
 ** This one handles macro declarations.
 */
 
 doMacroDcl:
 		DoMacroDclTkn
	 	macros
		{
			YYACCEPT;
		}
	;
 	





/**************************************************************************/


 /*
 ** Yet another recursive entry to the parser.
 ** This one handles regex declarations.
 */
 
 doRegexDcl:
 		DoRegexDclTkn
	 	regexs
		{
			YYACCEPT;
		}
	;
 	
	
 	





/**************************************************************************/


 /*
 ** Yet another recursive entry to the parser.
 ** This one handles the compilation of regular expressions.
 */
 
doCompileRegexTkn:
 		compileRegexTkn		/* $1 */
 		compileRegex		/* $2 */
 		{
 			_here; 
 			memcpy( &d1ceReturnVal, &$<v>2, sizeofSymNode );
 			YYACCEPT; 
 		}
 	;





/**************************************************************************/

 /*
 ** Yet another recursive entry to the parser.
 ** This one evaluates a single constant expression surrounded by
 ** parentheses (used for conditional assembly, etc. )
 */

doOneConstExpr: 
		DoOneConstExpr 
		'('
		ConstOnlyExpr
		Rparen 
		{
			_here; 
			memcpy( &d1ceReturnVal, &$<v>3, sizeofSymNode );
			YYACCEPT; 
			_here;
		}
	;
	

	





/**************************************************************************/

 /*
 ** doTextBlock-
 **
 **	A recursive entry to the parse that handles the #text sequence:
 **
 **		#text( StrArrayID )
 **
 **			<< Aribitrary Text >>
 **
 **		#endtext
 **
 **	This production converts each line of text between the #text and the
 ** #endtext clauses to a string and stores each of these strings in the
 ** VAL string array specified by StrArrayID.
 */

doTextBlock:
		textblockTkn	/* $1 */
		Lparen			/* $2 */
		lclUndefID		/* $3 */
		Rparen			/* $4 */
		GetText			/* $5 */
		endtextTkn		/* $6 */
		{				/* $7 */

			_here;
			doTextBlock7( $<idStr>3, YYS &$<v>6 ); 
			YYACCEPT
		}


	|	textblockTkn	/* $1 */
		Lparen			/* $2 */
		DefinedID		/* $3 */
		Rparen			/* $4 */
		GetText			/* $5 */
		endtextTkn		/* $6 */
		{				/* $7 */

			_here;
			doTextBlock7a( $<s>3, YYS &$<v>6 );
			YYACCEPT
		}
	;

GetText:
		{
			_here;
			startGetTextBlock();
			_here;
		}
	;
	

	





/**************************************************************************/

 /*
 ** doStringBlock-
 **
 **	A recursive entry to the parse that handles the #string sequence:
 **
 **		#string( StrID )
 **
 **			<< Aribitrary Text >>
 **
 **		#endstring
 **
 **	This production converts the text between #string( StrID ) and #endstring
 ** into a single string (including newlines) and stores this string data
 ** into StrID.
 */

doStringBlock:
		stringblockTkn	/* $1 */
		Lparen			/* $2 */
		lclUndefID		/* $3 */
		Rparen			/* $4 */
		GetString		/* $5 */
		endstringTkn	/* $6 */
		{				/* $7 */

			_here;
			doStringBlock( $<idStr>3, YYS &$<v>6 ); 
			YYACCEPT
		}


	|	stringblockTkn	/* $1 */
		Lparen			/* $2 */
		DefinedID		/* $3 */
		Rparen			/* $4 */
		GetString		/* $5 */
		endstringTkn	/* $6 */
		{				/* $7 */

			_here;
			doStringBlocka( $<s>3, YYS &$<v>6 );
			YYACCEPT
		}
	;

GetString:
		{
			_here;
			startGetStringBlock();
			_here;
		}
	;



/**************************************************************************/

 /*
 ** doMatchBlock-
 **
 **	A recursive entry to the parse that handles the #match sequence:
 **
 **		#match( regexID )
 **
 **			<< Aribitrary Text >>
 **
 **		#endmatch
 **
 */

doMatchBlock:
		matchblockTkn	/* $1 */
		Lparen			/* $2 */
		DefinedID		/* $3 */
		Rparen			/* $4 */
		GetMatch		/* $5 */
		endmatchTkn		/* $6 */
		{				/* $7 */

			_here;
			doMatchBlock( $<s>3, YYS &$<v>6 );
			YYACCEPT
		}
	;

GetMatch:
		{
			_here;
			startGetMatchBlock();
			_here;
		}
	;



/**************************************************************************/
	
 /*
 ** A recursive entry into the parser
 ** that handles the "#print(----)" parameter list.
 */	

doPrint:
		parsePrintTkn		/* token = $F2 */
		Lparen
		PrintList
		Rparen
		{
			_here;
			_if( PrintOut != writeHandle )
			
				// Write a newline for #print, but not for #write
				
				fputs( "\n", PrintOut );
				
			_endif
			YYACCEPT 
		}
	;

 /*
 ** Handle the only, or the first, parameter in the #print
 ** parameter list here.
 */

PrintList:
		ConstOnlyExpr
		{
			_here;
			PrintList2( YYS &$<v>1 );
			
		}

		/*
		** Handle all but the first parameters in the #print parameter
		** list via this production.
		*/

	|	PrintList
		comma
		ConstOnlyExpr
		{
		
			_here;
			PrintList2( YYS &$<v>3 );
		}
	;

	
		

/**************************************************************************/


 /*
 ** Yet another recursive entry to the parser.
 ** This one parses an HLA identifier for use by
 ** the lexer when processing qualified object identifier names.
 **
 ** Examples:	objectName.FieldName
 **				className.FieldName.Fieldname
 **
 ** doParseObjID processes variable objects.
 ** doParseClassID processes class name sequences.
 **
 **	Note that the "parseHLAIDTkn" and "parseClassIDTkn" terminals have
 ** a $<s> attribute that points at the symbol table entry for the
 ** current object or class name.
 */

doParseObjID:
		parseHLAIDTkn		/* Token = $F5, yylval = CurObject */
		ObjFieldNames  
		{ 
			_here;
			memcpy( &d1dnReturnVal, &$<dotName>2, sizeof( union YYSTYPE ));
			_here; 
			YYACCEPT
		}
	;
	
doParseClassID:
		parseClassIDTkn		/* token = $F4, yylval = CurObject */
		ClassFieldName
		{
			_here;
			memcpy( &d1dnReturnVal, &$<dotName>2, sizeof( union YYSTYPE ));
			_here;
			YYACCEPT 
		}
	;
	
	/*
	** If this is a namespace, class, record, or union identifier with
	** appropriate "."/fieldlist, return a pointer to the
	** symbol table for the specified field.
	*/

GetObjectBaseName:
		{
			_here;
			$<s>$ = $<s>0;
			_here;
		}
	;
	
SaveObjBaseName:
		{
			_here;
			$<idStr>$ = hlastrdup2( $<s>0->TrueName );
			_here;
		}
	;
	  


	/*
	** The following production handles a base object name
	** followed by a sequence of dot-fieldnames.  This production
	** returns the following information:
	**
	**	dotname.StaticName-		A static ID for the object.
	**	dotname.FullName-		String containing full object name.
	**	dotname.Sym-			Pointer to symbol table entry of
	**							the last fieldname in the sequence.
	**	dotname.Disp-			Sum of all displacements from hlaFields NT.
	*/
	
ObjFieldNames:
		GetObjectBaseName	/* $1 Save ptr to object's sym tbl entry.	*/
		SaveObjBaseName		/* $2 Save copy of object's name as a str.	*/
		hlaSingleIDSVal		/* $3 */
		hlaFields			/* $4 */
		{					/* $5 */

			int	 nameLen;
			char *name;

			_here;

			/*
			** Note: 3/14/2000, rlh
			** Not sure if the following IF statement is ever
			** false (under reasonable conditions).  Added the
			** assert statement to let me know if this is ever
			** the case.  If the assert triggers for reasonable
			** code, perhaps we should remove the assert.  At some
			** point in the future, we may want to remove the IF
			** statement and ELSE body if the assert never triggers.
			**
			** $<s>1 should only be NULL if the class symbol is undefined.
			** However, that situation is handled elsewhere.
			*/

			assert( $<s>1 != NULL );
			_if( $<s>1 != NULL )

				/*
				** Generate the new FullName field.
				*/

				nameLen = 
						strlen( $<s>1->TrueName ) 
					+	strlen( $<dotName.FullName>4 )
					+	1;

				name = malloc2( nameLen );
				strcpy( name, $<s>1->TrueName );
				strcat( name, $<dotName.FullName>4 );
				$<dotName.FullName>$ = name;
				free2( vss $<dotName.FullName>4 );

				/*
				** Generate the StaticName field.
				**
				**	The new StaticName field is the value
				**	of the hlaFields StaticName field if it
				**	is non-null.  If it is null, then the
				**	hlaFields StaticName field is the StaticName
				**	value of the hlaSingleID field and the Disp
				**	field is the value of the hlaFields Disp value.
				*/

				_if( $<dotName.StaticName>4 != NULL )

					$<dotName.StaticName>$ = $<dotName.StaticName>4;

				_else

					$<dotName.StaticName>$ = $<s>1->StaticName;
				
				_endif
				$<dotName.Disp>$ = $<dotName.Disp>4;
				$<dotName.Sym>$ = $<dotName.Sym>4;


			_else	
			
				/* 
				** Class/object name is undefined. 
				** Not sure if this code is needed.
				*/

				nameLen = 
						strlen( $<idStr>2 ) 
					+	strlen( $<dotName.FullName>4 )
					+	1;

				name = malloc2( nameLen );
				strcpy( name, $<idStr>2 );
				strcat( name, $<dotName.FullName>4 );
				$<dotName.FullName>$ = name;
				$<dotName.Sym>$ = NULL;
				$<dotName.StaticName>$ = NULL;
				$<dotName.Disp>$ = 0;

			_endif
			free2( vss $<idStr>2 );
			_here;
		}
		
	
	/*
	** Go through this production if we have a class variable
	** name by itself without any fieldnames.
	*/
		
	|	GetObjectBaseName	/* $1 */
		SaveObjBaseName		/* $2 */
		hlaSingleIDSVal		/* $3 */
		Empty				/* $4 */
		{
			_here;
			$<dotName.FullName>$ = NULL;
			$<dotName.Sym>$ = NULL;
			$<dotName.StaticName>$ = NULL;
			free2( vss $<idStr>2 );
			_here;
		}
			
	;






 /*
 ** Identical to ObjFieldNames above, except
 ** this production only allows a single dot-name
 ** rather than a sequence of dot-names.  This is
 ** used to process a class name followed by a single
 ** field.  We don't have to worry about sequences
 ** longer than one dotted name because you can't
 ** have nested class definitions.
 */


ClassFieldName:
		GetObjectBaseName
		SaveObjBaseName
		hlaSingleIDSVal
		Empty
		{
			_here;
			$<dotName.FullName>$ = NULL;
			$<dotName.Sym>$ = NULL;
			$<dotName.StaticName>$ = NULL;
			free2( vss $<idStr>2 );
			_here;
		}
		
	|	GetObjectBaseName	/* $1 */
		SaveObjBaseName		/* $2 */
		hlaSingleIDSVal		/* $3 */
		SingleFieldName		/* $4 */
		{					/* $5 */

			int	 nameLen;
			char *name;

			_here;

			/*
			** Once again, it doesn't appear as though $<s>1 can
			** ever be NULL at this point.  The following assert
			** was added just to check this.  If it ever triggers
			** for reasonable code, just remove the assert.  Else,
			** (if it never triggers), we should remove the IF and
			** ELSE code at some point in the future.
			*/

			assert( $<s>1 != NULL );
			assert( $<dotName.FullName>4 != NULL );
			_if( $<s>1 != NULL )

				/*
				** Generate the new FullName field.
				*/
				nameLen = 
						strlen( $<s>1->TrueName ) 
					+	strlen( $<dotName.FullName>4 )
					+	2;

				name = malloc2( nameLen );

				strcpy( name, $<s>1->TrueName );
				
				// Kludge, because macro/text expansions don't
				// put a "." in front of the FullName identifier.
				
				_if( *$<dotName.FullName>4 != '.' )
				
					strcat( name, "." );
					
				_endif
				strcat( name, $<dotName.FullName>4 );
				$<dotName.FullName>$ = name;
				free2( vss $<dotName.FullName>4 );

				
				// Generate the StaticName field.
				//
				//	The new StaticName field is the value
				//	of the hlaFields StaticName field if it
				//	is non-null.  If it is null, then the
				//	hlaFields StaticName field is the StaticName
				//	value of the hlaSingleID field and the Disp
				//	field is the value of the hlaFields Disp value.
				

				_if( $<dotName.StaticName>4 != NULL )

					$<dotName.StaticName>$ = $<dotName.StaticName>4;

				_else

					$<dotName.StaticName>$ = $<s>1->StaticName;
				
				_endif
				$<dotName.Disp>$ = $<dotName.Disp>4;
				$<dotName.Sym>$ = $<dotName.Sym>4;

			_else

				nameLen = 
						strlen( $<idStr>2 ) 
					+	strlen( $<dotName.FullName>4 )
					+	1;

				name = malloc2( nameLen );
				strcpy( name, $<idStr>2 );
				strcat( name, $<dotName.FullName>4 );
				$<dotName.FullName>$ = name;
				$<dotName.Sym>$ = NULL;
				$<dotName.StaticName>$ = NULL;
				$<dotName.Disp>$ = 0;

			_endif
			free2( vss $<idStr>2 );
			_here;
		}
	;







/**************************************************************************/

 /*
 ** Here is a recursive entry point to the parser.
 ** Whenever the lexer encounters a macro ID it will invoke the
 ** following production in order to process the macro parameters
 ** for this call.
 */

doMacroParameters:
		MacroID
		'(' 
		doMacParm 
		{
			_here;
			assert( $<s>1 != NULL );
			$<s>$ = $<s>1->u.MacroData.Parameters;
			VarMacParms = 0;		/* Used for a variable parm list	*/
			_here; 
		} 
		OptMacroParms 
		Rparen
		{
			_here;
			(void) $<s>4;
			YYACCEPT;
		}
	;



 /*
 ** OptMacroParms-
 **
 **	Processes each actual macro parameter.
 ** Inherited attribute ($0) -	Pointer to the symbol table entry
 ** 							for this particular parameter (i.e.,
 **								the formal parameter).
 */

OptMacroParms:
	
		/*
		** Handle no parameters.
		*/

		EmptyParmList
		{
			_here;
			
			// Just in case there was a syntax error in the macro
			// parameter list.
			
			$<v.u.ArrayOfValues>$ = NULL;
			_here;
			
		}
	;  




 /*
 ** Handle the last (or only) macro parameter.
 **
 ** OptMacroParms #2:
 */

OptMacroParms:
		LastMacroParmTkn 
		{
			struct	SymNode	v;

			/*
			** Have we exhausted all the formal parameters already?
			*/

			_here;
			_if( $<s>0 == NULL )

				yyerror( "Excessive macro parameters" );


			/*
			** Okay, there's at least one formal parameter left.
			** Since this is the last actual parameter we're processing,
			** make sure that this is the last formal parameter, or if
			** there is at least one more formal parameter, make sure that
			** it is the last one and it's a VAR or STRING parameter 
			** (which accepts zero actual parameters).
			*/

			_elseif
			( 
					$<s>0->Next != NULL 
				&&	$<s>0->Next->pType != tArray 
				&&	$<s>0->Next->pType != tString 
			)

				struct SymNode *s;

				ErrorNear
				( 
					"Too few macro parameters", 
					$<v.u.strval>1, 
					__LINE__,
					__FILE__ 
				);

				/*
				** Okay, we don't have enough parameters, so let's
				** create some fake ones so the system won't crash on us.
				*/

				s = $<s>0;
				_while( s != NULL )

					v.u.strval = hlastrdup2( "" );
					SetSym
					( 
						s,
						&text_ste,			/* Type					*/
						tText, 				/* pType				*/
						0,					/* Arity				*/
						NULL,				/* Dimensions			*/
						0, 					/* NumElements			*/
						YYS &v,				/* Value				*/
						0,					/* Object Size			*/
						0,					/* Offset				*/
						NULL,				/* Static Name			*/
						NULL,				/* Record BASE address	*/
						NULL,				/* Fields				*/
						0,					/* FieldCnt				*/ 
						NULL,				/* CurField				*/
						0					/* CurIndex				*/ 
					);
					s = s->Next;

				_endwhile
					

			_else

				/*
				** Okay, this is the last actual parameter and there is
				** exactly one formal parameter left.  Process that
				** parameter here.
				**
				** First, check to see if this is a regular (non-VAR/STRING)
				** parameter.
				*/

				_if( $<s>0->pType == tText )

					v.u.strval = $<v.u.strval>1;
					SetSym
					( 
						$<s>0,
						&text_ste,			/* Type					*/
						tText, 				/* pType				*/
						0,					/* Arity				*/
						NULL,				/* Dimensions			*/
						0, 					/* NumElements			*/
						YYS &v,				/* Value				*/
						0,					/* Object Size			*/
						0,					/* Offset				*/
						NULL,				/* Static Name			*/
						NULL,				/* Record BASE address	*/
						NULL,				/* Fields				*/
						0,					/* FieldCnt				*/ 
						NULL,				/* CurField				*/
						0					/* CurIndex				*/ 
					);

				
				_elseif( $<s>0->pType == tString)

					v.u.strval = $<v.u.strval>1;
					SetSym
					( 
						$<s>0,
						&string_ste,		/* Type					*/
						tString, 			/* pType				*/
						0,					/* Arity				*/
						NULL,				/* Dimensions			*/
						0, 					/* NumElements			*/
						YYS &v,				/* Value				*/
						0,					/* Object Size			*/
						0,					/* Offset				*/
						NULL,				/* Static Name			*/
						NULL,				/* Record BASE address	*/
						NULL,				/* Fields				*/
						0,					/* FieldCnt				*/ 
						NULL,				/* CurField				*/
						0					/* CurIndex				*/ 
					);

				
				_elseif( $<s>0->pType == tArray )

					/*
					** Okay, we must be processing a VAR  parameter
					** at this point.  Since this is the last
					** actual parameter, we can now allocate storage
					** for the array of strings (for the VAR parm)
					** and store the current parameter into the *last*
					** element of that string array.
					*/


					int			   *Dims;
					struct SymNode *TheParms;

					++VarMacParms;			/* One last parameter	*/
					TheParms =	malloc2
								(
									VarMacParms * sizeof( struct SymNode )
								);

					/*
					** Initialize each element of the string array so
					** we can store data into these elements as we
					** unwind the recursive calls later.
					**
					** Note that the actual type and value is irrelevant
					** since it will all be overwritten later.
					*/

					_for( int i=0, i < VarMacParms, ++i )

						TheParms[i].Type = &uns8_ste;
						TheParms[i].pType = tUns8;
						TheParms[i].SymClass = cValue;
						TheParms[i].u.unsval = 0;


					_endfor

					/*
					** Store the text of the current parameter into
					** the last entry of the string array.
					*/

					SetSym
					( 
						&TheParms[ VarMacParms - 1 ],
						&string_ste,		/* Type					*/
						tString,			/* pType				*/
						0,					/* Arity				*/
						NULL,				/* Dimensions			*/
						0, 					/* NumElements			*/
						YYS &$<v>1,			/* Value				*/
						0,					/* Object Size			*/
						0,					/* Offset				*/
						NULL,				/* Static Name			*/
						NULL,				/* Record BASE address	*/
						NULL,				/* Fields				*/
						0,					/* FieldCnt				*/ 
						NULL,				/* CurField				*/
						0					/* CurIndex				*/ 
					);

					
					/*
					** Set up the symbol table entry for the array of
					** strings object.
					*/

					v.u.ArrayOfValues = TheParms;
					Dims = malloc2( sizeof( int ));
					*Dims = VarMacParms;
					SetSym
					( 
						$<s>0,
						&string_ste,		/* Type					*/
						tArray,				/* pType				*/
						1,					/* Arity				*/
						Dims,				/* Dimensions			*/
						VarMacParms,		/* NumElements			*/
						YYS &v,				/* Value				*/
						VarMacParms*4,		/* Object Size			*/
						0,					/* Offset				*/
						NULL,				/* Static Name			*/
						NULL,				/* Record BASE address	*/
						NULL,				/* Fields				*/
						0,					/* FieldCnt				*/ 
						NULL,				/* CurField				*/
						0					/* CurIndex				*/ 
					);

					/*
					** Must return a pointer to the array data so
					** we can store the previous entries as well.
					** Also, we just ate the last parameter, so subtract
					** it from the number we need to still process.
					*/

					$<v.u.ArrayOfValues>$ = TheParms;
					--VarMacParms;

				_else
				
					yyerror( "Internal HLA error -- unknown macro parm type" );

				_endif

				/*
				** Check to see if there was a VAR parameter at the
				** end of the formal parameter list.  Since there are
				** no more actual parameters, we need to create an array
				** with a single empty string in it if this is the case.
				**
				** Note that we only do this if the last actual parameter
				** was not associated with a VAR formal parameter.  That
				** is, there was an extra VAR parameter at the end of the
				** formal parameter list and the current set of actual
				** parameters only fulfilled the needs of the non-VAR
				** formal parameters.
				*/

				_if( $<s>0->Next != NULL )
				
					_if( $<s>0->Next->pType == tArray )

						int				*Dims;
						struct SymNode	*ps = $<s>0->Next;

						/*
						** Free any existing variable parameter value.
						*/

						FreeValue( YYS ps );

						/*
						** Must allocate dummy objects so they can
						** be freed later.
						*/

						ps->Type = &string_ste;
						ps->pType = tArray;
						ps->SymClass = cValue;
						ps->Arity = 1;

						Dims = malloc2( sizeof( int ));
						*Dims = 0;
						ps->Dimensions = Dims;

						ps->NumElements = 0;
						ps->u.ArrayOfValues = NULL;
						
					_elseif( $<s>0->Next->pType == tString )

							int				*Dims;
							struct SymNode	*ps = $<s>0->Next;

							
							// Free any existing variable parameter value.
							
							FreeValue( YYS ps );

							// Set this guy to the empty string.
							
							ps->Type = &string_ste;
							ps->pType = tString;
							ps->SymClass = cValue;
							ps->Arity = 0;

							ps->Dimensions = NULL;

							ps->NumElements = 0;
							ps->u.strval = hlastrdup2( "" );


					_endif
					
				_endif

			_endif
			_here;

		}
	;






 /*
 ** Handle the first through the next-to-last macro parameters here.
 **
 **	OptMacroParms #4:
 */

OptMacroParms:
		MacroParmTkn 
		comma 
		doMacParm 
		{ 
			/*
			** Have we exhausted all the formal parameters already?
			*/

			_here;
			_if( $<s>0 == NULL )

				yyerror( "Too many macro parameters" );


			_elseif( $<s>0->pType == tText )

				$<s>$ = $<s>0->Next;

			_else // tArray or tString

				$<s>$ = $<s>0;
				++VarMacParms;	/* One more variable parameter */

			_endif
			_here;
		} 
		OptMacroParms 
		{

			_here;
			_if( $<s>0 == NULL )

				/*
				** Already printed this error message above.
				**
				**	yyerror( "Too many macro parameters" );
				*/
				
			_elseif( $<v.u.ArrayOfValues>5 == NULL )
			
				yyerror( "Syntax error in macro parameter list" );

			_elseif( VarMacParms > 0 )
			
				_if( $<s>0->pType == tString )
				
					char *newStr;
					int	 prependLen = strlen( $<v.u.strval>1 );
					int  suffixLen  = strlen( $<s>0->u.strval );
					struct SymNode v;

				
					--VarMacParms;	/* One less parameter, now */

					newStr = malloc2( prependLen + suffixLen + 2 );
					strcpy( newStr, $<v.u.strval>1 );
					newStr[ prependLen ] = ',';
					strcpy( newStr + prependLen+1,  $<s>0->u.strval );
					v.u.strval = newStr;

					SetSym
					( 
						$<s>0,
						&string_ste,		/* Type					*/
						tString, 			/* pType				*/
						0,					/* Arity				*/
						NULL,				/* Dimensions			*/
						0, 					/* NumElements			*/
						YYS &v,				/* Value				*/
						0,					/* Object Size			*/
						0,					/* Offset				*/
						NULL,				/* Static Name			*/
						NULL,				/* Record BASE address	*/
						NULL,				/* Fields				*/
						0,					/* FieldCnt				*/ 
						NULL,				/* CurField				*/
						0					/* CurIndex				*/ 
					);
					
				
				_elseif( $<s>0->pType == tArray )

					
					// If VarMacParms is greater than zero, and we're
					// processing a VAR formal parameter then the current
					// actual parameter needs to be assigned to the
					// appropriate element of the VAR parm array of strings.
					

					--VarMacParms;	/* One less parameter, now */
					SetSym
					( 
						&$<v.u.ArrayOfValues>5[ VarMacParms ],
						&string_ste,		/* Type					*/
						tString,			/* pType				*/
						0,					/* Arity				*/
						NULL,				/* Dimensions			*/
						0, 					/* NumElements			*/
						YYS &$<v>1,			/* Value				*/
						0,					/* Object Size			*/
						0,					/* Offset				*/
						NULL,				/* Static Name			*/
						NULL,				/* Record BASE address	*/
						NULL,				/* Fields				*/
						0,					/* FieldCnt				*/ 
						NULL,				/* CurField				*/
						0					/* CurIndex				*/ 
					);
					$<v.u.ArrayOfValues>$ = $<v.u.ArrayOfValues>5;
					
				_else
				
					yyerror( "Internal HLA error processing macro parms" );
					
				_endif



			_else

				/*
				** Here we have a standard formal parameter.
				** Assign to it the value of the current actual parameter.
				*/

				struct SymNode v;

				v.u.strval = $<v.u.strval>1;
				SetSym
				( 
					$<s>0,
					&text_ste,			/* Type					*/
					tText, 				/* pType				*/
					0,					/* Arity				*/
					NULL,				/* Dimensions			*/
					0, 					/* NumElements			*/
					YYS &v,				/* Value				*/
					0,					/* Object Size			*/
					0,					/* Offset				*/
					NULL,				/* Static Name			*/
					NULL,				/* Record BASE address	*/
					NULL,				/* Fields				*/
					0,					/* FieldCnt				*/ 
					NULL,				/* CurField				*/
					0					/* CurIndex				*/ 
				);

			_endif
			(void) $<s>4;	// Shut up bison, we really use this.
			_here;
		}
	;




EmptyParmList:
			{
				struct SymNode v;

				_here;
				_if( $<s>0 != NULL )

					_if( $<s>0->pType != tArray )

						struct SymNode *s;

						yyerror( "Macro invocation needs parameters" );

						/*
						** Okay, we don't have enough parameters, so let's
						** create some fake ones so the system won't crash 
						** on us.
						*/

						s = $<s>0;
						_while( s != NULL )

							v.u.strval = hlastrdup2( "" );
							SetSym
							( 
								s,
								&text_ste,			/* Type					*/
								tText, 				/* pType				*/
								0,					/* Arity				*/
								NULL,				/* Dimensions			*/
								0, 					/* NumElements			*/
								YYS &v,				/* Value				*/
								0,					/* Object Size			*/
								0,					/* Offset				*/
								NULL,				/* Static Name			*/
								NULL,				/* Record BASE address	*/
								NULL,				/* Fields				*/
								0,					/* FieldCnt				*/ 
								NULL,				/* CurField				*/
								0					/* CurIndex				*/ 
							);
							s = s->Next;

						_endwhile
							

					_endif

					/*
					** Check to see if there was a VAR or string parameter at 
					** the end of the formal parameter list.  Since there are
					** no more actual parameters, we need to create an array
					** with a single empty string in it if this is the case.
					**
					** Note that we only do this if the last actual parameter
					** was not associated with a VAR/string formal parameter.
					** That is, there was an extra VAR parameter at the end of
					** the formal parameter list and the current set of actual
					** parameters only fulfilled the needs of the non-VAR/string
					** formal parameters.
					*/

					_if( $<s>0->Next != NULL )
					
						_if( $<s>0->Next->pType == tArray )

							int				*Dims;
							struct SymNode	*ps = $<s>0->Next;

							/*
							** Free any existing variable parameter value.
							*/

							FreeValue( YYS ps );

							/*
							** Must allocate dummy objects so they can
							** be freed later.
							*/

							ps->Type = &string_ste;
							ps->pType = tArray;
							ps->SymClass = cValue;
							ps->Arity = 1;

							Dims = malloc2( sizeof( int ));
							*Dims = 0;
							ps->Dimensions = Dims;

							ps->NumElements = 0;
							ps->u.ArrayOfValues = NULL;
							
						_elseif( $<s>0->Next->pType == tString )

							int				*Dims;
							struct SymNode	*ps = $<s>0->Next;

							/*
							** Free any existing string parameter value.
							*/

							FreeValue( YYS ps );

							/*
							** Must allocate dummy objects so they can
							** be freed later.
							*/

							ps->Type = &string_ste;
							ps->pType = tString;
							ps->SymClass = cValue;
							ps->Arity = 0;
							ps->NumElements = 0;							
							ps->u.strval = hlastrdup2( "" );

						_endif

					_endif

				_endif
				_here;
			}
		;

doMacParm:	{
				_here;
				doMacParm();
				_here;
			}
		;



/**************************************************************************/


 /*
 ** The following productions handle characters that the grammar
 ** expects to see at various points in the statement. If the character
 ** is not found, print an appropriate error message (this prevents
 ** many of the dreaded "syntax error" messages).
 */

Semicolon:
		';'

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected ';', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;




Colon:
		':'

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected ':', encountered '%s'\n"
				"(Possible undefined ID)",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;



Assign:
		assignTkn

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected ':=', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;




Lparen:
		'('

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected '(', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;




Rparen:
		')'

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected ')', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;




Rbrack:
		']'

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected ']', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;





Lbrack:
		'['

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected '[', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;







Rbrace:
		'}'

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected '}', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;









Lbrace:
		'{'

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected '{', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;







comma:
		','

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected ',', encountered '%s'",
				yytext
			);
			yyerror( msg );
			_here;
		}
	;



SetTempNoErrors:
		{
			TempIgnoreErrors = 1;
		}
	;





/**************************************************************************/


 /*
 ** Register definitions.
 */


Reg8a:	
		alTkn 
		{
			_here;
			$<u>$ = reg_al;
		}

	|	ahTkn 
		{
			_here;
			$<u>$ = reg_ah;
		}
	
	|	blTkn 
		{
			_here;
			$<u>$ = reg_bl;
		}
	
	|	bhTkn
		{
			_here;
			$<u>$ = reg_bh;
		}
	
	|	clTkn
		{
			_here;
			$<u>$ = reg_cl;
		}
	
	|	chTkn
		{
			_here;
			$<u>$ = reg_ch;
		}
	
	|	dlTkn
		{
			_here;
			$<u>$ = reg_dl;
		}
	
	|	dhTkn
		{
			_here;
			$<u>$ = reg_dh;
		}
	;
	
Reg16a:	
		axTkn 
		{
			_here;
			$<u>$ = reg_ax;
		}

	|	bxTkn 
		{
			_here;
			$<u>$ = reg_bx;
		}
	
	|	cxTkn 
		{
			_here;
			$<u>$ = reg_cx;
		}
	
	|	dxTkn
		{
			_here;
			$<u>$ = reg_dx;
		}
	
	|	spTkn
		{
			_here;
			$<u>$ = reg_sp;
		}
	
	|	bpTkn
		{
			_here;
			$<u>$ = reg_bp;
		}
	
	|	siTkn
		{
			_here;
			$<u>$ = reg_si;
		}
	
	|	diTkn
		{
			_here;
			$<u>$ = reg_di;
		}
	;

Reg32a:	
		eaxTkn 
		{
			_here;
			$<u>$ = reg_eax;
		}

	|	ebxTkn 
		{
			_here;
			$<u>$ = reg_ebx;
		}

	|	ecxTkn 
		{
			_here;
			$<u>$ = reg_ecx;
		}

	|	edxTkn 
		{
			_here;
			$<u>$ = reg_edx;
		}

	|	ebpTkn 
		{
			_here;
			$<u>$ = reg_ebp;
		}

	|	esiTkn 
		{
			_here;
			$<u>$ = reg_esi;
		}

	|	ediTkn 
		{
			_here;
			$<u>$ = reg_edi;
		}

	|	espTkn
		{
			_here;
			$<u>$ = reg_esp;
		}

	;
	

fReg8:
		Reg8a
		{
			$<reg.encoding>$ = $<u>1;
			$<reg.Size>$ = 1;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tByte;
			$<reg.Type>$ = &byte_ste;
				
		}
		
	|	fstmt
		Reg8a
		{
			$<reg.encoding>$ = $<u>2;
			$<reg.Size>$ = 1;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tByte;
			$<reg.Type>$ = &byte_ste;
				
		}
		
	|
		'('			/* $1 */
		typeTkn		/* $2 */
		TypeID		/* $3 */
		fReg8		/* $4 */
		Rparen		/* $5 */
		{			/* $6 */
		
			_if( $<s>3->ObjectSize != $<reg.Size>4 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>4 ],
					__LINE__,
					__FILE__
				);
				
			_endif
			$<reg.encoding>$ = $<reg.encoding>4;
			$<reg.Size>$ = $<reg.Size>4;
			$<reg.IsSigned>$ = IsInt( $<s>3->pType );
			$<reg.pType>$ = $<s>3->pType;
			$<reg.Type>$ = $<s>3;
		}
		
	|	fstmt		/* $1 */
		'('			/* $2 */
		typeTkn		/* $3 */
		TypeID		/* $4 */
		fReg8		/* $5 */
		Rparen		/* $6 */
		{			/* $7 */
		
			_if( $<s>4->ObjectSize != $<reg.Size>5 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>5 ],
					__LINE__,
					__FILE__
				);
				
			_endif
			$<reg.encoding>$ = $<reg.encoding>5;
			$<reg.Size>$ = $<reg.Size>5;
			$<reg.IsSigned>$ = IsInt( $<s>4->pType );
			$<reg.pType>$ = $<s>4->pType;
			$<reg.Type>$ = $<s>4;
		}
	;
	
	
	
Reg8:
		Reg8a
		{
			$<reg.encoding>$ = $<u>1;
			$<reg.Size>$ = 1;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tByte;
			$<reg.Type>$ = &byte_ste;
				
		}
		
	|
		'('			/* $1 */
		typeTkn		/* $2 */
		TypeID		/* $3 */
		fReg8		/* $4 */
		Rparen		/* $5 */
		{			/* $6 */
		
			_if( $<s>3->ObjectSize != $<reg.Size>4 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>4 ],
					__LINE__,
					__FILE__
				);
				
			_endif
			$<reg.encoding>$ = $<reg.encoding>4;
			$<reg.Size>$ = $<reg.Size>4;
			$<reg.IsSigned>$ = IsInt( $<s>3->pType );
			$<reg.pType>$ = $<s>3->pType;
			$<reg.Type>$ = $<s>3;
		}
	;
	
	

Reg16:
		Reg16a
		{
			$<reg.encoding>$ = $<u>1;
			$<reg.Size>$ = 2;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tWord;
			$<reg.Type>$ = &word_ste;
		}
		
	|
		'('			/* $1 */
		typeTkn		/* $2 */
		TypeID		/* $3 */
		fReg16		/* $4 */
		Rparen		/* $5 */
		{			/* $6 */
		
			_if( $<s>3->ObjectSize != $<reg.Size>4 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>4 ],
					__LINE__,
					__FILE__
				);
				
			_endif
			$<reg.encoding>$ = $<reg.encoding>4;
			$<reg.Size>$ = $<reg.Size>4;
			$<reg.IsSigned>$ = IsInt( $<s>3->pType );
			$<reg.pType>$ = $<s>3->pType;
			$<reg.Type>$ = $<s>3;
		}
	;
	
	

fReg16:
		Reg16a
		{
			$<reg.encoding>$ = $<u>1;
			$<reg.Size>$ = 2;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tWord;
			$<reg.Type>$ = &word_ste;
		}
		
	|	fstmt
		Reg16a
		{
			$<reg.encoding>$ = $<u>2;
			$<reg.Size>$ = 2;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tWord;
			$<reg.Type>$ = &word_ste;
		}
		
	|
		'('			/* $1 */
		typeTkn		/* $2 */
		TypeID		/* $3 */
		fReg16		/* $4 */
		Rparen		/* $5 */
		{			/* $6 */
		
			_if( $<s>3->ObjectSize != $<reg.Size>4 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>4 ],
					__LINE__,
					__FILE__
				);
				
			_endif
			$<reg.encoding>$ = $<reg.encoding>4;
			$<reg.Size>$ = $<reg.Size>4;
			$<reg.IsSigned>$ = IsInt( $<s>3->pType );
			$<reg.pType>$ = $<s>3->pType;
			$<reg.Type>$ = $<s>3;
		}
		
	|	fstmt		/* $1 */
		'('			/* $2 */
		typeTkn		/* $3 */
		TypeID		/* $4 */
		fReg16		/* $5 */
		Rparen		/* $6 */
		{			/* $7 */
		
			_if( $<s>4->ObjectSize != $<reg.Size>5 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>5 ],
					__LINE__,
					__FILE__
				);
				
			_endif
			$<reg.encoding>$ = $<reg.encoding>5;
			$<reg.Size>$ = $<reg.Size>5;
			$<reg.IsSigned>$ = IsInt( $<s>4->pType );
			$<reg.pType>$ = $<s>4->pType;
			$<reg.Type>$ = $<s>4;
		}
	;



Reg32:
		Reg32a
		{
			$<reg.encoding>$ = $<u>1;
			$<reg.Size>$ = 4;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tDWord;
			$<reg.Type>$ = &dword_ste;
		}
		
	|
		'('			/* $1 */
		typeTkn		/* $2 */
		TypeID		/* $3 */
		fReg32		/* $4 */
		Rparen		/* $5 */
		{			/* $6 */
		
			_if( $<s>3->ObjectSize != $<reg.Size>4 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>4 ],
					__LINE__,
					__FILE__
				);
			
			_endif
			$<reg.encoding>$ = $<reg.encoding>4;
			$<reg.Size>$ = $<reg.Size>4;
			$<reg.IsSigned>$ = IsInt( $<s>3->pType );
			$<reg.pType>$ = $<s>3->pType;
			$<reg.Type>$ = $<s>3;
		}
	;



fReg32:
		Reg32a
		{
			$<reg.encoding>$ = $<u>1;
			$<reg.Size>$ = 4;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tDWord;
			$<reg.Type>$ = &dword_ste;
		}
		
	|	fstmt
		Reg32a
		{
			$<reg.encoding>$ = $<u>2;
			$<reg.Size>$ = 4;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tDWord;
			$<reg.Type>$ = &dword_ste;
		}
		
	|	'('			/* $1 */			
		typeTkn		/* $2 */
		TypeID		/* $3 */
		fReg32		/* $4 */
		Rparen		/* $5 */
		{			/* $6 */
		
			_if( $<s>3->ObjectSize != $<reg.Size>4 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>4 ],
					__LINE__,
					__FILE__
				);
			
			_endif
			$<reg.encoding>$ = $<reg.encoding>4;
			$<reg.Size>$ = $<reg.Size>4;
			$<reg.IsSigned>$ = IsInt( $<s>3->pType );
			$<reg.pType>$ = $<s>3->pType;
			$<reg.Type>$ = $<s>3;
		}
		
	|	fstmt		/* $1 */
		'('			/* $2 */
		typeTkn		/* $3 */
		TypeID		/* $4 */
		fReg32		/* $5 */
		Rparen		/* $6 */
		{			/* $7 */
		
			_if( $<s>4->ObjectSize != $<reg.Size>5 )
			
				ErrorNear
				(
					"Illegal register size.",
					regStrs[ $<reg.encoding>5 ],
					__LINE__,
					__FILE__
				);
			
			_endif
			$<reg.encoding>$ = $<reg.encoding>5;
			$<reg.Size>$ = $<reg.Size>5;
			$<reg.IsSigned>$ = IsInt( $<s>4->pType );
			$<reg.pType>$ = $<s>4->pType;
			$<reg.Type>$ = $<s>4;
		}
	;


Register:	
		Reg8
		{
			$<reg>$ = $<reg>1;
		}
	;									 

Register:
		Reg16
		{
			$<reg>$ = $<reg>1;
		}
	;									 

Register:
		Reg32
		{
			$<reg>$ = $<reg>1;
		}
	;									 



fRegister:	
		fReg8
		{
			$<reg>$ = $<reg>1;
		}
	;									 

fRegister:
		fReg16
		{
			$<reg>$ = $<reg>1;
		}
	;									 

fRegister:
		fReg32
		{
			$<reg>$ = $<reg>1;
		}
	;									 





fReg16or32:
		fReg16
		{
			$<u>$ = $<reg.encoding>1;
		}
	
	|	fReg32
		{
			$<u>$ = $<reg.encoding>1;
		}
	;
	

fmmxReg:
		mmxReg_a
		{
			$<u>$ = $<u>1;
		}
		
	|	fstmt
		mmxReg_a
		{
			$<u>$ = $<u>1;
		}
	;		

mmxReg_a:
		mm0Tkn			/* $1 */
		{
			_here;
			$<u>$ = 0;
		}
	
	|	mm1Tkn			/* $1 */
		{
			_here;
			$<u>$ = 1;
		}
	
	|	mm2Tkn			/* $1 */
		{
			_here;
			$<u>$ = 2;
		}
	
	|	mm3Tkn			/* $1 */
		{
			_here;
			$<u>$ = 3;
		}
	
	|	mm4Tkn			/* $1 */
		{
			_here;
			$<u>$ = 4;
		}
	
	|	mm5Tkn			/* $1 */
		{
			_here;
			$<u>$ = 5;
		}
		
	|	mm6Tkn			/* $1 */
		{
			_here;
			$<u>$ = 6;
		}
	
	|	mm7Tkn			/* $1 */
		{
			_here;
			$<u>$ = 7;
		}
	;
	
		

			

segReg:
		esTkn
		{
			$<u>$ = reg_eseg;
			_here;
		}

	|	csTkn
		{
			$<u>$ = reg_cseg;
			_here;
		}
	
	|	ssTkn
		{
			$<u>$ = reg_sseg;
			_here;
		}
	|	dsTkn
		{
			$<u>$ = reg_dseg;
			_here;
		}

	|	fsTkn
		{
			$<u>$ = reg_fseg;
			_here;
		}

	|	gsTkn
		{
			$<u>$ = reg_gseg;
			_here;
		}
	;
	
fSegReg:
		segReg
		{
			$<u>$ = $<u>1;
		}
		
	|	fstmt
		segReg
		{
			$<u>$ = $<u>2;
		}
	;	


	


	
ctrlReg:
		cr0Tkn
		{
			$<u>$ = 0;
			_here;
		}

	|	cr2Tkn
		{
			$<u>$ = 2;
			_here;
		}

	|	cr3Tkn
		{
			$<u>$ = 3;
			_here;
		}

	|	cr4Tkn
		{
			$<u>$ = 4;
			_here;
		}
	;


fCtrlRegister:
		ctrlReg
		{
			$<u>$ = $<u>1;
		}

	|	fstmt
		ctrlReg
		{
			$<u>$ = $<u>2;
		}
	;




dbgReg:
		dr0Tkn
		{
			$<u>$ = 0;
			_here;
		}

	|	dr1Tkn
		{
			$<u>$ = 1;
			_here;
		}

	|	dr2Tkn
		{
			$<u>$ = 2;
			_here;
		}

	|	dr3Tkn
		{
			$<u>$ = 3;
			_here;
		}

	|	dr6Tkn
		{
			$<u>$ = 6;
			_here;
		}

	|	dr7Tkn
		{
			$<u>$ = 7;
			_here;
		}
	;
	
fDbgRegister:
		dbgReg
		{
			$<u>$ = $<u>1;
		}

	|	fstmt
		dbgReg
		{
			$<u>$ = $<u>2;
		}
	;




	

fXmmReg:
		xmmReg_a
		{
			$<u>$ = $<u>1;
		}
		
	|	fstmt
		xmmReg_a
		{
			$<u>$ = $<u>1;
		}
	;
	

xmmReg_a:
		xmm0Tkn			/* $2 */
		{
			_here;
			$<u>$ = 0;
		}
	
	|	xmm1Tkn			/* $1 */
		{
			_here;
			$<u>$ = 1;
		}
	
	|	xmm2Tkn			/* $1 */
		{
			_here;
			$<u>$ = 2;
		}
	
	|	xmm3Tkn			/* $1 */
		{
			_here;
			$<u>$ = 3;
		}
	
	|	xmm4Tkn			/* $1 */
		{
			_here;
			$<u>$ = 4;
		}
	
	|	xmm5Tkn			/* $1 */
		{
			_here;
			$<u>$ = 5;
		}
	
	|	xmm6Tkn			/* $1 */
		{
			_here;
			$<u>$ = 6;
		}
	
	|	xmm7Tkn			/* $1 */
		{
			_here;
			$<u>$ = 7;
		}
	;
	








/**************************************************************************/



 /*
 ** Compile a module (unit) here.
 */

unit: 
		unitTkn			/* $1 */ 
		UndefID			/* $2 */
		{				/* $3 */

			struct SymNode dummy;	/* Aribtrary value for Program object	*/


			inUnit = 1;

			/*
			** Emit the start of the program file (done here so that
			** any #asm..#endasm directives before "unit" will emit
			** their code before the initial output).
			*/

			SkeletalOutput();
		

			/*
			** Enter the unit name into the symbol table.
			*/

			CurLexLevel = 0;
			InsertSym
			(
				hlastrdup2( yytext ),
				&pgmID_ste,
				tProgram,
				cProgram,
				0,
				NULL,
				0,
				YYS &dummy,
				0,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			$<s>$ = SymbolTable;
			CurrentContext = SymbolTable;
			CurrentContext->u.proc.Locals =  SymbolTable->Next;
			MainLocals = &CurrentContext->u.proc.Locals;
			CurOffset = -4;		/* Make room for display */
			CurOffsetDir = -1;
			_here;

		} 
		Semicolon			/* $4 */
		UnitDeclarations 	/* $5 */
		endTkn 				/* $6 */
		AnyID 				/* $7 */
		Semicolon			/* $8 */
		{ 					/* $9 */

			char 					msg[ 256 ];
			struct	MethodListType	*temp;


			_if( _strne( $<idStr>2, $<neID.idStr>7 ) )
			
				yyerror( "Identifier must match unit name" );

			_endif
			
			// Reset the MainLocals (unit->u.proc.locals) to point
			// at the current local symbol table before we start
			// checking forward and static lists.
			
			*MainLocals = SymbolTable;

			/*
			** Check to ensure that all forward declared procedures
			** have be defined prior to code emission.
			*/

			CheckForwardDecls( $<s>3 );

			/*
			** Check to make sure all pointer forward references have
			** been resolved.
			*/

			CheckPtrs();

			/*
			** See if there are any outstanding undefined static
			** objects at lex level zero.  Although this isn't a main
			** program, the second parameter to CheckStatic must be
			** a one since we need to check for any undefined symbols
			** at this point.
			*/

			$<s>3->u.proc.Locals = SymbolTable;
			CurrentContext = SymbolTable;
			CheckStatic( StaticList, 1 );
			
			/*
			** See if there are any undefined methods or class procedures
			** at this point.
			*/

			_while( MethodList != NULL )

				assert( MethodList->ClassSym != NULL );
				assert( MethodList->MethodSym != NULL );
				assert( MethodList->ClassSym->TrueName != NULL );
				assert( MethodList->MethodSym->TrueName != NULL );

				/*
				** If the method was declared as external, it's
				** okay if it's undefined.
				*/

				_if( !MethodList->MethodSym->IsExternal )

					sprintf
					( 
						msg,
						"Undefined class procedure/method: %s.%s\n",
						MethodList->ClassSym->TrueName,
						MethodList->MethodSym->TrueName
					);
					yyerror( msg );

				_endif
				temp = MethodList;
				MethodList = MethodList->Next;
				free2( vss temp );

			_endwhile

			/*
			** See if there are any outstanding forward reference
			** labels.
			*/

			--CurLexLevel;
			CheckFwdRef();

			free2( vss $<neID.idStr>7 );
			endSourceFile();
			inUnit = 0;
			_here;

		}
	;



 /* 
 ** Handle HLA declarations here.
 */

UnitDeclarations:
		optionalSemicolon
		UnitDecls
	;
 
UnitDecls:	
		/* Empty */ 
		
	|	UnitDecls 
		saveCurNS 
		labelTkn 
		FwdLabels
		optionalEndLabel 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	UnitDecls 
		saveCurNS 
		constTkn 
		Constants
		optionalEndConst 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		} 
		
	|	UnitDecls 
		saveCurNS 
		valTkn 
		Values
		optionalEndVar 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		} 
		
	|	UnitDecls 
		saveCurNS 
		typeTkn 
		Types
		optionalEndType 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		} 
		
	|	UnitDecls 
		saveCurNS 
		staticTkn 
		StaticVars
		optionalEndStatic 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	UnitDecls 
		saveCurNS 
		uninitializedTkn 
		UninitVars
		optionalEndStorage 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	UnitDecls 
		saveCurNS 
		readonlyTkn 
		ReadOnlyVars
		optionalEndRO 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	UnitDecls 
		saveCurNS 
		procTkn 
		procDcls
		optionalEndProc
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	UnitDecls 
		saveCurNS 
		procs
		optionalSemicolon
		{ 
			currentNS = $<ru.saveCurNS>2; 
		} 

		
	|	UnitDecls 
		saveCurNS 
		NameSpace 
		optionalSemicolon
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
 	;


saveCurNS:
		{
			$<ru.saveCurNS>$ = currentNS;
			$<ru.saveProcNS>$ = ProcNS;
			$<ru.saveProcGlobal>$ = ProcGlobal;
			currentNS = NULL;
		}
	;
	
optionalEndLabel:

		/* Empty */
		
	|	endlabelTkn
		OneOrMoreSemicolons
	;

	
optionalEndVar:

		/* Empty */
		
	|	endvarTkn
		OneOrMoreSemicolons
	;

	
optionalEndConst:

		/* Empty */
		
	|	endconstTkn
		OneOrMoreSemicolons
	;

	
optionalEndVal:

		/* Empty */
		
	|	endvalTkn
		OneOrMoreSemicolons
	;

	
optionalEndType:

		/* Empty */
		
	|	endtypeTkn
		OneOrMoreSemicolons
	;

	
optionalEndStatic:

		/* Empty */
		
	|	endstaticTkn
		OneOrMoreSemicolons
	;

	
optionalEndStorage:

		/* Empty */
		
	|	endstorageTkn
		OneOrMoreSemicolons
	;

	
optionalEndRO:

		/* Empty */
		
	|	endreadonlyTkn
		OneOrMoreSemicolons
	;

	
optionalEndProc:

		/* Empty */
		
	|	endprocTkn
		OneOrMoreSemicolons
	;





/**************************************************************************/



 /*
 ** Handle a file containing a main program here.
 */

pgm: 
	programTkn		/* $1 */ 
	UndefID			/* $2 */
	{				/* $3 */

		struct SymNode			dummy;	/* Aribtrary val for Pgm object	*/
		struct contextListType	*p;
		int						*dims;

		_here;

		/*
		** Set the inProgram flag for use by the @section function.
		*/

		inProgram = 1;
		wasProgram = 1;
		
		/*
		** Emit the start of the program file (done here so that
		** any #asm..#endasm directives before "program" will emit
		** their code before the initial output).
		*/

		SkeletalOutput();
		

		/*
		** Enter the program name into the symbol table.
		*/

		CurLexLevel = 0;
		InsertSym
		(
			hlastrdup2( yytext ),
			&pgmID_ste,
			tProgram,
			cProgram,
			0,
			NULL,
			0,
			YYS &dummy,
			0,
			0,
			NULL,
			NULL,
			NULL,
			0
		);
		$<s>$ = SymbolTable;
		CurrentContext = SymbolTable;
		CurrentContext->u.proc.Locals =  SymbolTable->Next;
		MainLocals = &CurrentContext->u.proc.Locals;
		CurOffset = -4;		/* Make room for display */
		CurOffsetDir = -1;

		/*
		** Insert symbol table entry for "_display_" into
		** the main program's local symbols.
		*/

		dims = (int *) malloc( sizeof( int ));
		*dims = 1;
		InsertSym
		(
			"_display_",
			&dword_ste,
			tDWord,
			cVar,
			1,				// Arity
			dims,			// [1]
			1,				// # elements
			NULL,			// No value
			4,				// display is 4 bytes
			CurOffset,
			NULL,			// Static name
			NULL,			// Base
			NULL,			// Fields
			0				// FieldCnt
		);



		/*
		** Add the main program to the context list so we
		** can bail on this program via the EXIT and EXITIF
		** statements.
		*/
		
		p = malloc2( sizeof( struct contextListType ));
		p->Next = contextList;
		p->label = $<idStr>2;

		p->StaticName = hlastrdup2( "xHLAMain" sympost );
		p->LexLevel = CurLexLevel;
		p->IsProc = 2;
		p->HasDisplay = 1;
		p->SizeParms = 0;
		contextList = p;
		_here;

	}
	SetInitAndFinal	/* $4 */ 
	Semicolon		/* $5 */
	Declarations 	/* $6 */
	beginTkn 		/* $7 */
	AnyID			/* $8 */
	{				/* $9 */

		_here;
		_if( _strne( $<idStr>2, $<neID.idStr>8) )
		
			yyerror( "Identifier must match program name" );

		_endif

		/*
		** Set up the _initialize_ and _finalize_ variables
		** so that they point at the strings created in the
		** Declarations production.
		*/

		_initialize_ = $<s>4->Next;
		_finalize_ = $<s>4;

			
		// Reset the MainLocals (unit->u.proc.locals) to point
		// at the current local symbol table before we start
		// checking forward and static lists.
		
		*MainLocals = SymbolTable;

		/*
		** Check to ensure that all forward declared procedures
		** have be defined prior to code emission.
		*/

		CheckForwardDecls( $<s>3 );

		/*
		** Check to make sure all pointer forward references have
		** been resolved.
		*/

		CheckPtrs();

		inMain = 1;
		_here;
	} 
	Semicolon		/* $10 */
	{				/* $11 */

		/*
		** If this is a program compilation (vs. a unit compilation),
		** output some stuff that can only appear once in the entire
		** object module.  The stack and some important variables
		** are good examples of such items.
		*/

		struct SymNode 	*s;
		
		_here;

		/*
		** Support for coroutines.  Must define the MainPgmCoroutine
		** object as an external here (actual definition appears in
		** the stdlib code).
		*/

		_if( !threadSafe )
		
			startDseg();
			EmitImmExtern( "MainPgmCoroutine" sympost, tByte ); 
			endDseg();
			
		_endif

		/*
		** If the FullExceptions variable is true, then link in the
		** full exception handling package, otherwise, link in
		** a couple of short default handlers.
		**
		** Note that the user controls the FullExceptions value via
		** the compile time @exceptions variable.  Also note that
		** if the user has included the "excepts.hhf" include file
		** then FullExceptions has been set to true unless the user
		** has explicitly set it to false after the include.
		*/
		
		EmitExceptionCode( FullExceptions );		


		/*
		** For the main program, we need to output the assembly
		** language procedure declaration for the "?HLAMain"
		** procedure.  Note that this code always sets up a stack
		** frame and display (since it only executes once, the minor
		** inefficiency of always doing this is irrelevant).
		*/

		BeginMain( CurOffset );

		CurrentContext = $<s>3;



		/*
		** Emit the text associated with the _initialize_ string
		** at this point.
		**
		**	Note: the "InvisibleCode" variable is used by
		**	yyerror to determine if it should print the
		**	_initialize_ string as part of the error message.
		*/

		
		InvisibleCode = NULL;
		_if
		( 
				_initialize_->pType != tString 
			&&	_initialize_->pType != tZString 
		)

			WarnNear
			( 
				"_initialize_'s type is not string.  Initialization ignored.",
				"_initialize_" 
			);

		_elseif( strlen( _initialize_->u.strval ) != 0 )

			InvisibleCode = _initialize_->u.strval;
			PushBackStr( "\xF3" );
			PushBackStr( _initialize_->u.strval );

		_endif
		_here;


	}

	Stmts			/* $12 */
	endTkn 			/* $13 */
	AnyID 			/* $14 */
	Semicolon		/* $15 */
	{ 				/* $16 */

		char 					msg[ 256 ];
		struct	MethodListType	*temp;


		_here;
		_if( _strne( $<idStr>2, $<neID.idStr>14 ) )
		
			yyerror( "Identifier must match program name" );

		_endif

		/*
		** See if there are any outstanding undefined static
		** objects at lex level zero.
		*/

		$<s>3->u.proc.Locals = SymbolTable;

		CurrentContext = $<s>3;
		CheckStatic( StaticList, 1 );
		
		/*
		** See if there are any undefined methods or class procedures
		** at this point.
		*/

		_while( MethodList != NULL )

			assert( MethodList->ClassSym != NULL );
			assert( MethodList->MethodSym != NULL );
			assert( MethodList->ClassSym->TrueName != NULL );
			assert( MethodList->MethodSym->TrueName != NULL );

			/*
			** If the method was declared as external, it's
			** okay if it's undefined.
			*/

			_if( !MethodList->MethodSym->IsExternal )

				sprintf
				( 
					msg,
					"Undefined class procedure/iterator/method: %s.%s\n",
					MethodList->ClassSym->TrueName,
					MethodList->MethodSym->TrueName
				);
				yyerror( msg );

			_endif
			temp = MethodList;
			MethodList = MethodList->Next;
			free2( vss temp );

		_endwhile

		/*
		** See if there are any outstanding forward reference
		** labels.
		*/

		--CurLexLevel;
		CheckFwdRef();


		/*
		** Emit the text associated with the _finalize_ string
		** at this point.
		**
		**	Note: the "InvisibleCode" variable is used by
		**	yyerror to determine if it should print the
		**	_finalize_ string as part of the error message.
		*/


		PushBackStr( "end" );		
		InvisibleCode = NULL;
		_if
		( 
				_finalize_->pType != tString 
			&&	_finalize_->pType != tZString 
		)

			WarnNear
			(
				"_finalize_ must be a string constant.  Value ignored",
				"_finalize_"
			);

		_elseif( strlen( _finalize_->u.strval ) != 0 )

			InvisibleCode = _finalize_->u.strval;
			PushBackStr( "\xF3" );
			PushBackStr( _finalize_->u.strval );

		_endif
		_here;

	}
	Stmts	/* $17 */
	endTkn	/* $18    This was faked, above. */
	{		/* $19 */
		

		_here;

		/*
		** Output the end of the main program here.
		*/

		EndMain();
		endCseg();
		endSourceFile();

		inMain = 0;
		inProgram = 0;
		_here;

	}
	;


SetInitAndFinal:
		{
			union YYSTYPE dummy;

			/*
			** Create the "_initialize_" and "_finalize_" text symbols 
			** used to emit initialization code later on.  Set the 
			** $<s>$ attribute to point at the _finalize_ symbol table
			** entry (note that $<s>$->Next points at _initialize_'s
			** symbol table entry.
			*/

			_here;
			dummy.v.u.strval = hlastrdup2( "" );
			InsertSym
			( 
				"_initialize_", 
				&string_ste,	/* This is a STRING object.		*/
				tString,
				cValue, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				YYS &dummy,		/* Initially, no initialization	*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);

			dummy.v.u.strval = hlastrdup2( "" );
			InsertSym
			( 
				"_finalize_", 
				&string_ste,	/* This is a STRING object.		*/
				tString,
				cValue, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				YYS &dummy,		/* Initially, no initialization	*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);

			$<s>$ = SymbolTable;
			_here;
		}
	;






/**************************************************************************/


 /* 
 ** Handle HLA declarations here.
 */

Declarations:
		optionalSemicolon
		Decls
	;

 
Decls:	/* Empty */

	|	Decls 
		saveCurNS 
		labelTkn 
		FwdLabels
		optionalEndLabel 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	Decls 
		saveCurNS 
		constTkn 
		Constants
		optionalEndConst  
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	Decls 
		saveCurNS 
		valTkn 
		Values
		optionalEndVal  
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	Decls 
		saveCurNS 
		typeTkn 
		Types
		optionalEndType  
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	Decls 
		saveCurNS 
		varTkn 
		Variables
		optionalEndVar 
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	Decls 
		saveCurNS 
		staticTkn 
		StaticVars
		optionalEndStatic  
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	Decls 
		saveCurNS 
		uninitializedTkn 
		UninitVars
		optionalEndStorage 
		{
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	Decls 
		saveCurNS 
		readonlyTkn 
		ReadOnlyVars
		optionalEndRO 
		{
			currentNS = $<ru.saveCurNS>2; 
		}
		
	|	Decls 
		saveCurNS 
		procTkn 
		procDcls
		optionalEndProc
		{
			currentNS = $<ru.saveCurNS>2; 
		}
		
		
	|	Decls 
		saveCurNS 
		procs
		optionalSemicolon
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
	
	|	Decls 
		saveCurNS 
		NameSpace 
		optionalSemicolon
		{ 
			currentNS = $<ru.saveCurNS>2; 
		}
 	;

optionalSemicolon: 
		/*empty*/ 
	|	OneOrMoreSemicolons 
	;


OneOrMoreSemicolons:
		';'
	|	OneOrMoreSemicolons ';'
	;










/**************************************************************************/



/*
** NameSpace-                            
**                                       
** Process a name space declaration here.
*/


SavePointerList:	{ $<plist>$ = PointerList; PointerList = NULL; };

doFast:
		fastTkn
		{
			fastNamespace = 1;
		}
		Semicolon
	;
	

NameSpace:
		namespaceTkn			/* $1 */ 
		UndefinedID 			/* $2 */
		EnterNSName				/* $3 */
		Semicolon				/* $4 */ 
		SavePointerList			/* $5  */
		NameSpaceDCLs			/* $6  */
		endTkn					/* $7  */
		AnyID					/* $8  */
		Semicolon				/* $9  */
		{						/* $10 */

			struct SymNode *CurSym;

			assert( $<neID.idStr>8 != NULL );


			/*
			** Reset NSGlobal pointer (used by @global) since
			** we're no longer in a namespace.
			**
			** Ditto for currentNS (since we shouldn't be using
			** a hash table for a search while outside a namespace.  
			*/

			NSGlobal = NULL;
			currentNS = NULL;
			
			/*
			** Mark the end of the local symbols in this
			** Name Space with a NULL terminating link.
			*/

			_if( SymbolTable == $<s>3 )

				yyerror( "Namespaces must have at least one field" );

				/*
				** Create a dummy set of fields to
				** prevent any problems from occurring.
				*/

				$<s>3->Fields = &error_ste;

			_else

				$<s>3->Fields = SymbolTable;
				CurSym = SymbolTable;
				_while( CurSym->Next != $<s>3 )

					assert( CurSym->Next != NULL );
					CurSym = CurSym->Next;

				_endwhile
				CurSym->Next = NULL;

			_endif
			

			/*
			** Check to make sure all pointer forward references have
			** been resolved.
			*/

			CheckPtrs();
			
				
			/*
			** Restore linkage to the rest of the symbol table.
			*/

			$<s>3->Next = $<s>3->Base;
			$<s>3->Base = NULL;


			/*
			** Be sure the identifier after the END keyword
			** matches the name space name.
			*/

			_if( _strne( $<idStr>2, $<neID.idStr>8 ))

				char msg[ 256 ];

				sprintf
				(
					msg,
					"Identifier <<%s>> after END in name space\n"
					"declaration must match <<%s>>",
					$<neID.idStr>8,
					$<idStr>2
				);
				yyerror( msg );

			_endif

			/*
			** Remove the local symbols in this namespace
			** from the symbol table.
			*/

			SymbolTable = $<s>3;
			
			/*
			** Restore the previous PointerList value
			*/
			
			PointerList = $<plist>5;

			/*
			** Convert the symbol to a Namespace object.
			** We couldn't do this before this point because
			** we wouldn't be able to handle the "end <id>;"
			** syntax if "<id>" was a namespace object.
			*/

			$<s>3->pType = tNamespace;


			inNamespace = 0;
			free2( vss $<neID.idStr>8 );
		}
	;
	
	
NameSpace:
		namespaceTkn		/* $1 */ 
		UndefinedID 		/* $2 */
		EnterNSName			/* $3 */
		Semicolon			/* $4 */
		doFast				/* $5 */
		SavePointerList		/* $6  */
		NameSpaceDCLs		/* $7  */
		endTkn				/* $8  */
		AnyID				/* $9  */
		Semicolon			/* $10 */
		{					/* $11 */

			struct SymNode *CurSym;

			assert( $<neID.idStr>9 != NULL );


			/*
			** Reset NSGlobal pointer (used by @global) since

			** we're no longer in a namespace.
			**
			** Ditto for currentNS (since we shouldn't be using
			** a hash table for a search while outside a namespace.  
			*/

			NSGlobal = NULL;
			currentNS = NULL;
			
			/*
			** Mark the end of the local symbols in this
			** Name Space with a NULL terminating link.
			*/

			_if( SymbolTable == $<s>3 )

				yyerror( "Namespaces must have at least one field" );

				/*
				** Create a dummy set of fields to
				** prevent any problems from occurring.
				*/

				$<s>3->Fields = &error_ste;

			_else

				$<s>3->Fields = SymbolTable;
				CurSym = SymbolTable;
				_while( CurSym->Next != $<s>3 )

					assert( CurSym->Next != NULL );
					CurSym = CurSym->Next;

				_endwhile
				CurSym->Next = NULL;

			_endif
			

			/*
			** Check to make sure all pointer forward references have
			** been resolved.
			*/

			CheckPtrs();
			
				
			/*
			** Restore linkage to the rest of the symbol table.
			*/

			$<s>3->Next = $<s>3->Base;
			$<s>3->Base = NULL;


			/*
			** Be sure the identifier after the END keyword
			** matches the name space name.
			*/

			_if( _strne( $<idStr>2, $<neID.idStr>9 ))

				char msg[ 256 ];

				sprintf
				(
					msg,
					"Identifier <<%s>> after END in name space\n"
					"declaration must match <<%s>>",
					$<neID.idStr>9,
					$<idStr>2
				);
				yyerror( msg );

			_endif

			/*
			** Remove the local symbols in this namespace
			** from the symbol table.
			*/

			SymbolTable = $<s>3;
			
			/*
			** Restore the previous PointerList value
			*/
			
			PointerList = $<plist>6;

			/*
			** Convert the symbol to a Namespace object.
			** We couldn't do this before this point because
			** we wouldn't be able to handle the "end <id>;"
			** syntax if "<id>" was a namespace object.
			*/

			$<s>3->pType = tNamespace;


			inNamespace = 0;
			free2( vss $<neID.idStr>9 );
			
			/*
			** Turn off the Fast Namespace operation
			*/
			
			fastNamespace = 0;
		}
	;

	


NameSpace:
		namespaceTkn		/* $1  */ 
		LocalID 	    	/* $2  */
		SetNSName			/* $3  */
		Semicolon			/* $4  */
		SavePointerList		/* $5  */
		NameSpaceDCLs		/* $6  */
		endTkn				/* $7  */
		AnyID				/* $8  */
		Semicolon			/* $9  */
		{					/* $10 */

			assert( $<neID.idStr>8 != NULL );


			/*
			** Reset NSGlobal pointer (used by @global) since
			** we're no longer in a namespace.
			**
			** Ditto for currentNS.
			*/

			NSGlobal = NULL;
			currentNS = NULL;

			/*
			** Add the new identifiers to the name space:
			*/

			$<s>2->Fields = SymbolTable;
			$<s>2->Base = NULL;
				
			/*
			** Restore linkage to the rest of the symbol table.
			*/

			SymbolTable = $<s>3;
			
			/*
			** Restore PointerList:
			*/
			
			PointerList = $<plist>5;


			/*
			** Be sure the identifier after the END keyword
			** matches the name space name.
			*/

			_if( _strne( $<s>2->TrueName, $<neID.idStr>8 ))

				char msg[ 256 ];

				sprintf
				(
					msg,
					"Identifier <<%s>> after END in name space\n"
					"declaration must match <<%s>>",
					$<neID.idStr>8,
					$<s>2->TrueName
				);
				yyerror( msg );

			_endif



			inNamespace = 0;
			free2( vss $<neID.idStr>8 );
		}
	;



NameSpace:
		namespaceTkn		/* $1  */ 
		LocalID 	    	/* $2  */
		SetNSName			/* $3  */
		Semicolon			/* $4  */
		doFast				/* $5  */
		SavePointerList		/* $6  */
		NameSpaceDCLs		/* $7  */
		endTkn				/* $8  */
		AnyID				/* $9  */
		Semicolon			/* $10 */
		{					/* $11 */

			assert( $<neID.idStr>9 != NULL );


			/*
			** Reset NSGlobal pointer (used by @global) since
			** we're no longer in a namespace.
			**
			** Ditto for currentNS.
			*/

			NSGlobal = NULL;
			currentNS = NULL;

			/*
			** Add the new identifiers to the name space:
			*/

			$<s>2->Fields = SymbolTable;
			$<s>2->Base = NULL;
				
			/*
			** Restore linkage to the rest of the symbol table.
			*/

			SymbolTable = $<s>3;
			
			/*
			** Restore PointerList:
			*/
			

			PointerList = $<plist>6;


			/*
			** Be sure the identifier after the END keyword
			** matches the name space name.
			*/

			_if( _strne( $<s>2->TrueName, $<neID.idStr>9 ))

				char msg[ 256 ];

				sprintf
				(
					msg,
					"Identifier <<%s>> after END in name space\n"
					"declaration must match <<%s>>",
					$<neID.idStr>9,
					$<s>2->TrueName
				);
				yyerror( msg );

			_endif



			inNamespace = 0;
			free2( vss $<neID.idStr>9 );
			
			/*
			** Turn off the Fast Namespace operation
			*/
			
			fastNamespace = 0;
		}
	;


EnterNSName:
		{
			assert( $<idStr>0 != NULL );

			/*
			** Insert the name space identifier into the
			** symbol table.
			*/

			InsertSym
			( 
				$<idStr>0, 
				&namespace_ste,	/* Need a type for @typename.			*/
				tVariant,		/* It's a namespace, but not yet.		*/
				cNamespace, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				NULL,			/* No value						*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				SymbolTable,	/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);
			
			/*
			** Allocate storage for this namespace's hash table
			** (the hash table has 256 entries):
			*/
			
			SymbolTable->u.hashTable = 
				malloc2( sizeof( struct SymNode *) * 256 );
				
			currentNS = SymbolTable;
			
			/*
			** I'm paranoid and not counting on those entries all being
			** set to NULL.
			*/
			
			memset
			( 
				SymbolTable->u.hashTable, 
				0, 
				sizeof( struct SymNode *) * 256 
			);

			/*
			** Save a pointer to the namespace entry in the symbol
			** table so we can patch various fields later.  Also,
			** remove the rest of the symbol table from further
			** comparison until we're through processing the name
			** space.
			*/

			$<s>$ = SymbolTable;
			NSGlobal = SymbolTable->Next;	/* Used by @global	*/
			SymbolTable->Next = NULL;

			/*
			** Set the inNamespace flag for the @section function.
			*/

			inNamespace = 1;
			
			/*
			** "Prime" fastLookup for the first identifier we encounter:
			*/
			
			fastLookup = 1;
		}
	;

SetNSName:
		{
			/*
			** Preserve a pointer to the current symbol table
			** so we can restore this later.
			*/

			$<s>$ = SymbolTable;
			
			/*
			** If the ID is a locally defined namespace identifier,
			** then append all fields to the end of that namespace's
			** symbol table.  Otherwise we have an error.
			*/
			 
			_if( $<s>0->SymClass != cNamespace )

				yyerror( "Expected a NAMESPACE identifier" );

			_else

				/*
				** Save a pointer to the namespace entry in the symbol
				** table so we can patch various fields later.  Also,
				** remove the rest of the symbol table from further
				** comparison until we're through processing the name
				** space.
				*/

				NSGlobal = SymbolTable;		/* Used by @global */
				SymbolTable = $<s>0->Fields;
				
				/*
				** Set up the currentNS pointer so we can search
				** via a hash table.
				*/
				
				currentNS = $<s>0;

			_endif

			/*
			** Set the inNamespace flag for the @section function.
			*/

			inNamespace = 1;
		} 
	;


NameSpace:
		namespaceTkn		/* $1 */ 
		BadLocalID 	    	/* $2 */
		Semicolon			/* $3 */
		doFast				/* $4 */
		{
			yyerror( "Expected a NAMESPACE identifier" );
		}
		NameSpaceDCLs		/* $6 */
		endTkn				/* $7 */
		AnyID				/* $8 */
		Semicolon			/* $9 */
	|
		namespaceTkn		/* $1 */ 
		BadLocalID 	    	/* $2 */
		Semicolon			/* $3 */
		{
			yyerror( "Expected a NAMESPACE identifier" );
		}
		NameSpaceDCLs		/* $5 */
		endTkn				/* $6 */
		AnyID				/* $7 */
		Semicolon			/* $8 */
	;
	
BadLocalID:
		LocalConstID
	|	LocalVarID
	|	LocalStaticID
	|	LocalProcID
	|	LocalIterID
	|	LocalMethodID
	|	LocalLabelID
	;



NameSpaceDCLs:
		optionalSemicolon
		NSDcls
	;
	
NSDcls:
		Empty 
	|	NSDcls constTkn Constants optionalEndConst
	|	NSDcls valTkn Values optionalEndVal  
	|	NSDcls typeTkn Types optionalEndType  
	|	NSDcls NameSpaceVars optionalEndVar  
	|	NSDcls staticTkn StaticVars optionalEndStatic  
	|	NSDcls uninitializedTkn UninitVars optionalEndStorage  
	|	NSDcls readonlyTkn ReadOnlyVars optionalEndRO  
	|	NSDcls procTkn procDcls optionalEndProc
	|	NSDcls procs optionalSemicolon
 	;



NameSpaceVars:
		varTkn 		/* $1 */
		SeeIfInUnit	/* $2 */
		Variables	/* $3 */
	;

SeeIfInUnit:
		{
			_here;
			_if( inUnit )
			
				yyerror( "Variable section is not allowed in UNIT" );
				
			_endif
			_here;
		}
	; 


/**************************************************************************/






/*********************************************************************/
/*                                                                   */
/* TypeID-                                                           */
/*                                                                   */
/* The grammar uses this production to handle type identifiers       */
/* (that typically appear after a ":") in a declaration.             */
/* Examples:                                                         */
/* 			a: SomeType;                                             */
/* 			b: SomeType[8];                                          */
/* 			c: SomeType := 10;                                       */
/* 			etc.                                                     */
/*                                                                   */
/*                                                                   */
/* As attributes, the TypeID productions return:                     */
/*                                                                   */
/* Symbol-		points to the actual symbol table entry for the  	 */
/* 				type ID.                                             */
/*                                                                   */
/* Type-		Points at the base type for any object.  If      	 */
/* 				the symbol is a simple type isomorphism, then        */
/* 				type points at the base type for the type            */
/* 				object.  If the symbol is an array type, then        */
/* 				Type points at the base type of an element.          */
/* 				This is true even if the type is a multi-            */
/* 				dimensional array (that is, Type points at           */
/* 				the type symbol table entry for a single             */
/* 				element of the array).                               */
/*                                                                   */
/*                                                                   */
/* pType-			If Symbol  is an array type, then pType is       */
/* 				tArray. Otherwise, pType is equal to                 */
/* 				Type->pType (which should be the same as             */
/* 				Symbol->pType).                                      */
/*                                                                   */
/*                                                                   */
/* NumElements-	Zero if the type is a scalar type, some          	 */
/*  			non-zero value (holding the total number         	 */
/* 				of array elements) if this is an array               */
/* 				object.  Note that for multi-dimensional             */
/* 				arrays, this is the total number of objects          */
/* 				in all dimensions, not just the first.               */
/*                                                                   */
/* Arity-		Zero if this is a scalar object; n, where        	 */
/* 				n is the number of dimensions for an array           */
/* 				object.                                              */
/*                                                                   */
/* Dimensions-	NULL if this is a scalar object, a pointer       	 */
/* 				to an array of n integers, n being the               */
/* 				value of the Arity object above, where               */
/* 				each integer in the array represents the             */
/* 				maximum number of objects for a particular           */
/* 				dimension of the array.  For example,                */
/* 				a 4x5 array would have arity two and the             */
/* 				Dimensions value would point at an array             */
/* 				of two integers, the first being four and            */
/* 				the second being five.                               */
/*                                                                   */
/* Fields-		NULL if this is not a record object.             	 */
/* 				Otherwise, this field points at a local              */
/* 				symbol table listing the fields of the               */
/* 				record.                                              */
/*                                                                   */
/*********************************************************************/





/*
** TypeID: DefinedID
**
** This production doesn't use any inherited attributes
**
** This production uses the following synthesized attributes:
**
** $1 (from DefinedID)
**				A pointer to the symbol table entry for
**				the symbol identifier.
*/
	



 
TypeID:		DefinedTypeID
 			{
 				struct SymNode *SymPtr;
				
				_here;
				assert( $<s>1 != NULL );

				/*
				** Figure out the base class for this type name.
				*/

				SymPtr = $<s>1;
				_while
				(
						IsType( SymPtr->SymClass )
					&&	IsPrimitive( SymPtr->pType )
					&&	!EndOfTypeList( SymPtr )
				)
															 

					SymPtr = SymPtr->Type;

				_endwhile


				_if( IsType( SymPtr->SymClass ))
				
					/*
					** Pass the type information
					** back as the synthesized attribute.
					*/

					$<s>$ = SymPtr;


				_else

					/*
					** Pass back a dummy type to prevent
					** unexpected problems.
					*/

					$<s>$ = &uns32_ste;
					yyerror( "Expected type identifier" );

				_endif
				_here;

			}

		|	BuiltInType 
			{ 
				_here; 
				$<s>$ = $<s>1; 
			}

  		;


			/*
			** Since the built-in types are handled by reserved
			** words rather than symbols in the symbol table,
			** the following productions must handle each of
			** these reserved words individually.
			*/

BuiltInType:
			BuiltInTypeNotThunk
			{
				$<s>$ = $<s>1;
			}

		|	thunkTkn
			{
				$<s>$ = &thunk_ste;
			}
		;


BuiltInTypeNotThunk:
			booleanTkn
			{
				$<s>$ = &boolean_ste;
			}

		|	int8Tkn
			{
				$<s>$ = &int8_ste;
			}

		|	int16Tkn
			{
				$<s>$ = &int16_ste;
			}

		|	int32Tkn
			{
				$<s>$ = &int32_ste;
			}


		|	int64Tkn
			{
				$<s>$ = &int64_ste;
			}


		|	int128Tkn
			{
				$<s>$ = &int128_ste;
			}


		|	uns8Tkn
			{
				$<s>$ = &uns8_ste;
			}

		|	uns16Tkn
			{
				$<s>$ = &uns16_ste;
			}

		|	uns32Tkn
			{
				$<s>$ = &uns32_ste;
			}


		|	uns64Tkn
			{
				$<s>$ = &uns64_ste;
			}


		|	uns128Tkn
			{
				$<s>$ = &uns128_ste;
			}


		|	byteTkn
			{
				$<s>$ = &byte_ste;
			}

		|	wordTkn
			{
				$<s>$ = &word_ste;
			}

		|	dwordTkn
			{
				$<s>$ = &dword_ste;
			}


		|	qwordTkn
			{
				$<s>$ = &qword_ste;
			}


		|	tbyteTkn
			{
				$<s>$ = &tbyte_ste;
			}


		|	lwordTkn
			{
				$<s>$ = &lword_ste;
			}


		|	charTkn
			{
				$<s>$ = &char_ste;
			}

		|	wcharTkn
			{
				$<s>$ = &wchar_ste;
			}

		|	real32Tkn
			{
				$<s>$ = &real32_ste;
			}

		|	real64Tkn
			{
				$<s>$ = &real64_ste;
			}

		|	real80Tkn
			{
				$<s>$ = &real80_ste;
			}


		|	real128Tkn
			{
				$<s>$ = &real128_ste;
			}


		|	stringTkn
			{
				$<s>$ = &string_ste;
			}

		|	zstringTkn
			{
				$<s>$ = &zstring_ste;
			}

		|	wstringTkn
			{
				$<s>$ = &wstring_ste;
			}

		|	csetTkn
			{
				$<s>$ = &cset_ste;
			}

		|	textTkn
			{
				$<s>$ = &text_ste;
			}

		|	regexTkn
			{
				$<s>$ = &regex_ste;
			}
		;



DefinedTypeID:
			LocalID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}


		|	NonLocalID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		
			/*
			** The following exist so we can catch errors.
			*/


		|	LocalLabelID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalLabelID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		;

 /*
 ** The following production is used to match type names appearing as
 ** statements within the body of the code.  E.g.,
 **
 **		byte 0, 1, 2;
 */

TypeIDNotThunk:		
			DefinedTypeID
 			{
 				struct SymNode *SymPtr;
				
				_here;
				assert( $<s>1 != NULL );


				/*
				** Figure out the base class for this type name.
				*/

				SymPtr = $<s>1;
				_while
				(
						IsType( SymPtr->SymClass )
					&&	IsPrimitive( SymPtr->pType )
					&&	!EndOfTypeList( SymPtr )
				)
															 

					SymPtr = SymPtr->Type;

				_endwhile


				_if( IsType( SymPtr->SymClass ))
				
					/*
					** Pass the type information
					** back as the synthesized attribute.
					*/

					$<s>$ = SymPtr;


				_else

					/*
					**	This probably never executes since
					**	non-type identifiers are illegal

					**	at the beginning of a statement and
					**	the type processing logic doesn't prevent
					**	a type ID to point (ultimately) at a
					**	non-type ID.  Note that the assert
					**	statement always raises the assertion.
					*/

					/* $<s>$ = &uns32_ste; */
					assert( "Unxpected non-type identifier" );

				_endif

			}

		|	BuiltInTypeNotThunk { $<s>$ = $<s>1; }

  		;



/*****************************************************/


 /*
 ** DefinedID- Matches all predeclared symbols (at any lex level).
 **
 **	It returns the symbol attributes (see TypeID for details):
 **
 ** It expects these same attributes to be passed to it as
 ** synthesized attributes from LocalID and NonLocalID.
 **
 ** Warning: Note that these productions do *not* make a copy of the
 ** data.  It is up to the caller to make a copy of the data if it
 ** is possible for this data to be changed (e.g., an assignment to
 ** a "Value" object).
 */

AnyLocalID:
			LocalID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}


		|	LocalVarID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalStaticID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalProcID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalIterID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalMethodID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalLabelID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalConstID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		;

AnyNonLocalID:
			NonLocalID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalVarID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalStaticID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalProcID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalIterID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalMethodID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalLabelID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalConstID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		;


DefinedID:
			AnyLocalID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}


		|	AnyNonLocalID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		;




DefinedConstID:
			LocalConstID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalConstID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		;






AnyStaticID:

			LocalStaticID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalStaticID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		;


/**********************************************************************/
/*                                                                    */
/* UndefinedID- Matches any symbol that is not defined with the scope */
/* of the current program unit.                                       */
/*                                                                    */
/* This production returns the symbol synthesized attribute (i.e.,    */
/* a string with the identifier's name).                              */
/*                                                                    */
/* This production expects the "symbol" synthesized attribute to      */
/* be passed up from the UndefID non-terminal or the Symbol.TrueName  */
/* attribute from the NonLocalID non-terminal.                        */
/*                                                                    */
/**********************************************************************/

UndefinedID:
			AnyNonLocalID
			{
				_here;
				$<idStr>$ = hlastrdup2( $<s>1->TrueName );
				fastLookup = 0;
				_here;
			}

		|	lclUndefID
			{
				_here;
				$<idStr>$ = $<idStr>1;
				fastLookup = 0;
				_here;
			}
		;
		





/*************************************************************/
/*                                                           */
/* AnyID- Matches any type of identifier.			         */
/*                                                           */
/*************************************************************/

AnyID:
 		UndefID
		{
			_here;
			assert(	$<idStr>1 != NULL );
			$<neID.idStr>$ = $<idStr>1;
			$<neID.s>$ = NULL;
			_here;
		}

	|	AnyLocalID
		{
			_here;
			$<neID.idStr>$ = hlastrdup2( $<s>1->TrueName );
			$<neID.s>$ = $<s>1;
			_here;
		}

	|	AnyNonLocalID
		{
			_here;
			$<neID.idStr>$ = hlastrdup2( $<s>1->TrueName );
			$<neID.s>$ = $<s>1;
			_here;
		}
	;
	
	
AnyLabelID:
		NonLocalLabelID
		{
			_here;
			assert( $<s>1 != NULL );
			$<s>$ = $<s>1;
			_here;
		}
		
	|	LocalLabelID
		{
			_here;
			assert( $<s>1 != NULL );
			$<s>$ = $<s>1;
			_here;
		}
	;


SimpleID:
		DontLookUpID
 		UndefID
		{
			_here;
			assert(	$<idStr>2 != NULL );
			$<idStr>$ = $<idStr>2;
			SkipLookup = $<v.u.unsval>1;
			_here;
		}
	;
	
DontLookUpID:
		{
			$<v.u.unsval>$ = SkipLookup;
			SkipLookup = 1;
		}
	;


/************************************************************/
/*                                                          */
/* ArbID-                                                   */
/*                                                          */
/* Any type of identifier plus all the type reserved words. */
/*                                                          */
/************************************************************/

ArbID:	
		AnyID
		{
			_here;
			assert(	$<idStr>1 != NULL );
			$<idStr>$ = $<neID.idStr>1;
		}
	|	ReservedIDs
		{
			_here;
			$<idStr>$ = hlastrdup2( yytext );
		}
	;
		



ReservedIDs:
		booleanTkn	| int8Tkn	 | int16Tkn | int32Tkn | int64Tkn | int128Tkn
	|	charTkn 	| wcharTkn	 | real32Tkn| real64Tkn| real80Tkn | real128Tkn
	|	uns8Tkn	 	| uns16Tkn	 | uns32Tkn | uns64Tkn | uns128Tkn 
	|	stringTkn	| wstringTkn | zstringTkn          | regexTkn
	|	csetTkn		| textTkn	 | byteTkn	| wordTkn  
	|	dwordTkn	| qwordTkn	 | tbyteTkn	| lwordTkn | thunkTkn
	;





NonConstLocalID:
			LocalID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
//				SetReferenced( $<s>1 );
				_here;
			}


		|	LocalVarID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalStaticID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}


		|	LocalLabelID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalProcID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalIterID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalMethodID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		;




/*****************************************************/

/****************************************************************************/
/*                                                                          */
/* ArrayValues-> '[' ArrayList ']'  						                */
/* 		   | ConstExpr dup '[' ArrayList ']'    		                    */
/*                                                                          */
/* This production matches a constant array expression.                     */
/* This could be either a literal array (e.g., [1,2,3,4]) or                */
/* an array constant identifier.  It also handles the array                 */
/* duplication operation outside a pair of brackets.                        */
/*                                                                          */
/* ArrayValues returns the following attributes:                            */
/*                                                                          */
/* pType			tArray                                                  */
/* Type				Element type                                            */
/* Arity			1                                                       */
/* Locals			Locals associated with the ArrayList                    */
/* Dimensions		Single element array, that element contains NumElements */
/* NumElements		Number of elements in the array                         */
/* u.ArrayOfValues	Actual array data                                       */
/*                                                                          */
/****************************************************************************/




	/*
	** This production handles a list of constants inside
	** the brackets.  This could be scalar expressions,
	** array IDs, or dup operators.
	*/

ArrayValues:
		'[' 
		ArrayList 
		Rbrack 
		{
			_here;

			/*
			** Clear out unimportant fields.
			*/

			$<v.Name>$ = "";
			$<v.TrueName>$ = "";
			$<v.StaticName>$ = NULL;
			$<v.Offset>$ = 0;
			SetEndOfTypeList( &$<v>$ );
			$<v.Base>$ = NULL;			/* Note: array of records	*/
			$<v.Fields>$ = NULL;		/* field info is maintained	*/
			$<v.FieldCnt>$ = 0;			/* Type field.				*/

			/*
			** For an array constant, here are the important
			** assignments.
			*/

			$<v.pType>$ = tArray;
			$<v.SymClass>$ = cConstant;
			$<v.Type>$ = $<v.Type>2;
			$<v.Arity>$ = 1;
			$<v.Dimensions>$ = malloc2( sizeof( int ));
			*$<v.Dimensions>$ = $<v.NumElements>2;
			$<v.NumElements>$ = $<v.NumElements>2;

			$<v.u.ArrayOfValues>$ = $<v.u.ArrayOfValues>2;
			$<v.ObjectSize>$ = $<v.NumElements>2 * $<v.ObjectSize>2;

			_here;

		}
	
	|	DupArrayConst
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}
	;



	/*
	** Handle array constants created with the dup
	** operator here.  This particular production allows
	** the duplication operator outside a pair of brackets, e.g.,
	**
	**	AryConst :=  4 dup [0];
	*/

DupArrayConst:
			ConstExpr
			dupTkn			
			Lbrack 
			ArrayList 
			Rbrack 
			{
				struct	SymNode		*data;
						int			rowsize;

				/*
				** Range and type check the duplication constant.
				*/

				_here;
				_if( !checkSmallUns( YYS &$<v>1 ))

					yyerror
					( 
						"Array dup value must be an integer value "
						"greater than zero" 
					);
					Setval( YYS &$<v>1, 1 );
					
				_endif
				 
				/*
				** Set up the attributes for the return value.
				*/

				$<v.pType>$ = tArray;
				$<v.Type>$ = $<v.Type>4;
				$<v.Arity>$ = 1;
				$<v.Dimensions>$ = malloc2( sizeof( int ));
				*$<v.Dimensions>$ = $<v.u.unsval>1 * $<v.NumElements>4;
				$<v.NumElements>$ = *$<v.Dimensions>$;
				$<v.ObjectSize>$ = $<v.ObjectSize>4 * $<v.u.unsval>1;
				
				/*
				** Create the data to return by duplicating the ArrayList
				** values the number of times specified by ConstExpr.
				*/

				rowsize = $<v.NumElements>4 * sizeofSymNode;
				data =	malloc2( rowsize * $<v.u.unsval>1 );
				_for( unsigned i=0, i < $<v.u.unsval>1, ++ i )
					
					_for( int j=0, j < $<v.NumElements>4, ++j )

						DeepCopy
						(
							data + i*$<v.NumElements>4 + j,
							&$<v.u.ArrayOfValues>4[j]
							/*
							** rowsize
							*/
						);

					_endfor

				_endfor

				$<v.u.ArrayOfValues>$ = data;

				/*
				** Clear out unimportant fields.
				*/

				$<v.Name>$ = "";
				$<v.TrueName>$ = "";
				$<v.StaticName>$ = NULL;
				$<v.Offset>$ = 0;
				SetEndOfTypeList( &$<v>$ );
				$<v.Base>$ = NULL;			/* Note: array of records	*/
				$<v.Fields>$ = NULL;		/* field info is maintained	*/
				$<v.FieldCnt>$ = 0;			/* Type field.				*/
				_here;

			}
		;




/*****************************************************/

/********************************************************************/
/*                                                                  */
/*  ArrayList-                                                      */
/*                                                                  */
/*  Matches a comma separated list of values that should all have   */
/*  compatible types.  Returns the number of elements and a pointer */
/*  to the array of values.                                         */
/*                                                                  */
/********************************************************************/

/*
** Important note on algorithm:
**
** doArrayList recursively scans the entire list of constants
** in the array until it finds the last element.  While scanning
** the list it simply counts the number of elements.  When it
** reaches the last element of the array, it allocates a single
** block of storage for the entire array.  Then as the recursion
** unravels back to the ArrayList production, the DoArrayList
** calls store their respective values into the appropriate points
** of the array.  This took a little doing, and is somewhat complex,
** but it is far more efficient than the previous version that
** concatenated lots of little arrays together.
*/


ArrayList:	SetElementCnt DoArrayList
			{
				_here;

				/*
				** Clear out unimportant fields.
				*/

				$<v.Name>$ = "";
				$<v.TrueName>$ = "";
				$<v.StaticName>$ = NULL;
				$<v.Offset>$ = 0;
				SetEndOfTypeList( &$<v>$ );
				$<v.Base>$ = NULL;			/* Note: array of records	*/
				$<v.Fields>$ = NULL;		/* field info is maintained	*/
				$<v.FieldCnt>$ = 0;			/* Type field.				*/

				/*
				** Set up the array specific fields.
				*/

				$<v.pType>$ = $<v.pType>2;
				$<v.Type>$ = $<v.Type>2;
				$<v.Dimensions>$ = malloc2( sizeof( int ));
				*$<v.Dimensions>$ = $<v.NumElements>2;
				$<v.NumElements>$ = $<v.NumElements>2;
				$<v.Arity>$ = 1;
				$<v.u.ArrayOfValues>$ = $<v.u.ArrayOfValues>2;
				$<v.ObjectSize>$ = $<v.ObjectSize>2;

				_here;

			}
		;

SetElementCnt:	
		{ 
			_here;
			$<v.u.unsval>$ = 0;
		};

IncElementCnt:	
		{ 
			_here;
			_if( $<v.pType>-1 == tArray )
			
				$<v.u.unsval>$ = $<v.u.unsval>-2 + $<v.NumElements>-1;
				
			_else
			
				$<v.u.unsval>$ = $<v.u.unsval>-2 + 1;
				
			_endif 
		};




/*****************************************************************/
/*                                                               */
/* DoArrayList-> ConstExpr | DoArrayList ',' ConstExpr           */
/*                                                               */
/* This is where the real "ArrayList" work gets done.  ArrayList */
/* is simply a facade production that tacks on the Symbol and    */
/* Arity fields after DoArrayList actually constructs the array  */
/* constant.  There are two DoArrayList productions.  The first  */
/* production:													 */
/* 															     */
/* 		DoArrayList->ConstExpr								     */
/* 															     */
/* handles either the first constant in an array list or the 	 */
/* only constant in an array list.  The second production:       */
/* 															     */
/* 	DoArrayList->DoArrayList ',' ConstExpr                       */
/* 	                                                             */
/* Handles the 2nd through last constants in an array            */
/* list that has two or more items in it.                        */
/*                                                               */
/* Returned Attributes:                                          */
/*                                                               */
/* pType			(tArray)                                     */
/* Type				Element type                                 */
/* NumElements		Number of elements in the array              */
/* u.ArrayOfValues	Actual values in the array.                  */
/*                                                               */
/* Note: the program should only use this production to process	 */
/* array data, not an array dimension or index lists.  Array	 */
/* data lists can be all different types, whereas dimension and	 */
/* index lists must be unsigned integers only.					 */
/*																 */
/*****************************************************************/

optionalComma:
		Empty
		{
			_here;
		}
	|	','
		{
			_here;
		}
	;

 	
DoArrayList:

		/*
		** This production handles the last (or only)
		** object in the array list.
		**
		**	Inherited Attribute:
		**
		**		$0	contains the index in the array where we should
		**			store the current object.  This production uses
		**			$0 as an array index and IncElement count uses
		**			it (as $-2) to determine the new element count.
		*/

		ConstOnlyExpr 
		optionalComma 
		IncElementCnt
		{
			int	TotalElements;
			int	ThisIndex;
			
			_here;
			TotalElements = $<v.u.unsval>3;

			/*
			** The IncElementCnt production
			** has been nice enough to count up all the elements
			** in the array for us.  This being the last object
			** in the array, it is now possible to allocate the
			** storage for the array and begin assigning the
			** element values to the array.
			*/

			$<v.u.ArrayOfValues>$ = malloc2( TotalElements * sizeofSymNode );
			$<v.NumElements>$ = TotalElements;
			$<v.pType>$ = tArray;

			/*
			** Pass the result on back to the caller.
			*/

			ThisIndex = $<v.u.unsval>0;
			_if( $<v.pType>1 == tArray )

				_for( int i=0, i < $<v.NumElements>1, ++i )
								
					DeepCopy
					(
						&$<v.u.ArrayOfValues>$[ ThisIndex+i ],
						&$<v.u.ArrayOfValues>1[i]

						/*
						** $<v.NumElements>1 * sizeofSymNode
						*/
					);

				_endfor

				
			_elseif( $<v.pType>1 == tRecord )

				/*
				** Check to see if the record is bad:
				*/

				_if( $<v.Type>1 != NULL )

					DeepCopy
					(
						&$<v.u.ArrayOfValues>$[ ThisIndex ],
						&$<v>1
						/* sizeofSymNode */
					);
					

					$<v.u.ArrayOfValues>$[ ThisIndex ].TrueName = 
						$<v.Type>1->TrueName;
					$<v.u.ArrayOfValues>$[ ThisIndex ].Name = 
						$<v.Type>1->Name;

				_else

					// We had an error, so just return
					// the error element.

					memcpy
					( 
						&$<v.u.ArrayOfValues>$[ ThisIndex ],
						&error_ste,
						sizeofSymNode 

					);

				_endif

			_else /* object is scalar or string object */
			
				DeepCopy
				(
					&$<v.u.ArrayOfValues>$[ ThisIndex ],
					&$<v>1
				);

				/*
				** Kludge so the call to free value below
				** doesn't wipe out our string.
				*/

				_if
				( 
						$<v.pType>1 == tString 
					||	$<v.pType>1 == tZString 

					||	$<v.pType>1 == tPointer )

					$<v.pType>1 = tUns8;
					$<v.Type>1 = &uns8_ste;

				_endif

				
			_endif
			$<v.pType>$ = tArray;
			_if( $<v.Type>1 != &error_ste )

				$<v.Type>$  = $<v.u.ArrayOfValues>$[ThisIndex].Type;

			_else

				$<v.Type>$ = &error_ste;

			_endif
			FreeValue( YYS &$<v>1 );
			_here;
		}
		
		
		

		/*
		** This production handles the case where there
		** are two or more objects in an array list.
		**
		** Inherited Attribute:
		**
		**	$0	This production expects $0 to contain the index
		**		where it should store the ConstExpr value. The
		**		IncElementCnt production also uses this value to
		**		compute the next object's index (note that
		**		IncElementCnt supplies this inherited attribute
		**		to the "DoArrayList" call below).
		*/

	|	 
		ConstOnlyExpr 
		',' 
		IncElementCnt 
		DoArrayList
		{
			enum PrimType lp, rp;
			
			_here;
			$<v.u.ArrayOfValues>$ = $<v.u.ArrayOfValues>4;
			$<v.NumElements>$ = $<v.NumElements>4;
			$<v.pType>$ = tArray;

			/*
			** Okay, if the result is type compatible, concatenate
			** the two arrays.  
			*/

			_if
			( 
				CoerceArrays
				( 
					YYS &$<v>1, 
					YYS &$<v>4, 
					$<v.u.unsval>3, 
					$<v.NumElements>4 
				)
			)

				/*
				** Set the type to the newly coerced type value.
				*/

				$<v.Type>$ = $<v.Type>1;  /* Note: $1===$4 */

				_if( $<v.pType>1 == tArray )

					/*
					** Copy ConstExpr's values into their appropriate
					** places in the array.
					*/

					_for( int i=0, i < $<v.NumElements>1, ++i )
					
						DeepCopy
						(
							&$<v.u.ArrayOfValues>$[ $<v.u.unsval>0+i ],
							&$<v.u.ArrayOfValues>1[i]
							/* $<v.NumElements>1 * sizeofSymNode */
						);

					_endfor

				_elseif( $<v.pType>1 == tRecord )

					DeepCopy
					(
						&$<v.u.ArrayOfValues>$[ $<v.u.unsval>0 ],
						&$<v>1
						/* sizeofSymNode */
					);
					$<v.u.ArrayOfValues>$[ $<v.u.unsval>0 ].TrueName = 
						$<v.Type>1->TrueName;
					$<v.u.ArrayOfValues>$[ $<v.u.unsval>0 ].Name = 
						$<v.Type>1->Name;

				_else /* ConstExpr is a scalar or string object */

					DeepCopy
					(
						&$<v.u.ArrayOfValues>$[ $<v.u.unsval>0 ],
						&$<v>1
						/* sizeofSymNode */
					);

					/*
					** Kludge so the call to free value below
					** doesn't wipe out our string.
					*/

					_if
					( 
							$<v.pType>1 == tString 
						||	$<v.pType>1 == tZString 
					)

						$<v.pType>1 = tUns8;
						$<v.Type>1 = &uns8_ste;

					_endif

				_endif

			_else /* Arrays are incompatible */

				/*
				** If we can't coerce the arrays to be compatible,
				** print an error message and return the DoArrayList
				** data as the result.
				*/

				yyerror( "Type mismatch in operands" );
				$<v.Type>$ = $<v.Type>4;	/* Keep DoArrayList type */
				memcpy
				(
					&$<v.u.ArrayOfValues>$[ $<v.u.unsval>0 ],
					&$<v.u.ArrayOfValues>$[ $<v.u.unsval>0 + 1 ],
					sizeofSymNode
				);

			_endif
			FreeValue( YYS &$<v>1 );
			_here;
		}
	;
			 


/*****************************************************/


/*************************************************************************/
/*                                                                       */
/* DimList-> ConstExpr | DimList ',' ConstExpr                           */
/*                                                                       */
/* Parses a comma separated list of dimension values.                    */
/* Returns the arity (number of dimensions) and the                      */
/* list of elements required for each dimension.                         */
/*                                                                       */
/* These productions handle lists of array dimensions                    */
/* appearing in a declaration;  e.g.,                                    */
/*                                                                       */
/* 		x : byte[ 2, 3, 4]                                               */
/*                                                                       */
/* (DimList processes the "2, 3, 4" above).                              */
/*                                                                       */
/* Values in a dimension list must always be unsigned                    */
/* integers greater than zero.                                           */
/*                                                                       */
/* DimList returns the following attributes:                             */
/*                                                                       */
/* Arity			Equivalent to the number of elements in the list.    */
/* Dimensions		Array of unsigned values containing the values       */
/* 				in the list.                                             */
/* NumElements		Equals the product of all the elements in the list.  */
/* u.ArrayOfValues	Always NULL.                                         */
/*                                                                       */
/*************************************************************************/
 

  /*
  ** This code uses the lame "concatenate arrays" algorithm,
  ** but that's probably okay for Dimension lists because they rarely
  ** exceed one or two dimensions anyway.  Since the concatenation
  ** rarely occurs, there's little need to worry about its performance.
  */

DimList:

		/*
		** This production handles the special case where we
		** have a single dimension.  It also handles the last
		** dimension in two dimension (or higher) array.
		*/
			
		ConstOnlyExpr
		{
			/*
			** Range and type check this dimension's size.
			*/

			_here;
			_if( !checkSmallUns( YYS &$<v>1 ))

				yyerror
				( 
					"Array size must be an integer value "
					"greater than zero"
				);
				$<v.pType>1 = tUns32;
				Setval( YYS &$<v>1, 1 );

			_endif

			/*
			** Set up the return attributes for a single dimension
			** array.
			*/

			$<v.Arity>$ = 1;
			$<v.Dimensions>$ =
				malloc2
				( 
					sizeof( unsigned ) 
				);

			*$<v.Dimensions>$ = $<v.u.unsval>1;
			$<v.NumElements>$ = $<v.u.unsval>1;
			$<v.u.ArrayOfValues>$ = NULL;
			_here;
		}


		/*
		** This production handles the case where there are
		** two or more dimensions in an array.  It creates
		** the new dimension list by concatenating a new
		** dimension value to the end of the already created
		** dimension list.
		*/

	|	DimList comma ConstOnlyExpr
		{
			/*
			** Type and range check the new item to concatenate
			** to our dimension array.
			*/

			_here;
			_if
			( 
					!checkSmallUns( YYS &$<v>3 )
				||	$<v.u.unsval>3 == 0 
			)

				yyerror
				( 
					"Array size must be a 32-bit integer greater than zero" 
				);
				$<v.pType>3 = tUns32;
				$<v.u.unsval>3 = 1;
				$<v.u.lwordval>3[1] = 0;
				$<v.u.lwordval>3[2] = 0;
				$<v.u.lwordval>3[3] = 0;

			_endif

			/*
			** Create a new dimension list with enough room to hold
			** the old one plus one additional element.
			*/

			$<v.Arity>$ = $<v.Arity>1 + 1;
			$<v.Dimensions>$ =
				malloc2
				( 
					sizeof( unsigned ) * 
						( $<v.Arity>1 + 1 )
				);


			/*
			** Copy the old DimList data to the new array.
			*/

			assert( $<v.Dimensions>1 != NULL );
			memcpy
			( 
				$<v.Dimensions>$, 
				$<v.Dimensions>1,
				sizeof( int ) * $<v.Arity>1
			);

			/*
			** Append the latest dimension to the end of the new array.
			*/

			$<v.Dimensions>$[$<v.Arity>1] = 
				$<v.u.unsval>3;

			/*
			** Update the new NumElements and u.ArrayOfValues attributes.
			*/

			$<v.NumElements>$ = 
				$<v.NumElements>1 * $<v.u.unsval>3;

			$<v.u.ArrayOfValues>$ = NULL;

			/*
			** Free the old array, we won't be using it any more.
			*/

			free2( vss $<v.Dimensions>1 );
			_here; 

		}
	;










/*******************************************************************/
/*                                                                 */
/* IndexList-> ConstExpr | IndexList ',' ConstExpr                 */
/*                                                                 */
/* Virtually the same as DimList with two important exceptions:    */
/* (1) This code allows zeros in the list, and                     */
/* (2) This code prints slightly different error messages.         */
/*                                                                 */
/* The parser uses these productions to handle a list of indices   */
/* in an array access (as opposed to a definition).  E.g.,         */
/*                                                                 */
/* 		c := d[0,1,2,3];                                           */
/*                                                                 */
/* where "d" is some previously defined array and we're extracting */
/* element [0,1,2,3] from it.                                      */
/*                                                                 */
/* See the comments for DimList for additional details...          */
/*                                                                 */
/*******************************************************************/


/*
** Same lame algorithm as for DimList.  Same reason for not doing any better.
*/


IndexList:	
		ConstOnlyExpr
		{
			_here;
			_if( !checkSmallUns( YYS &$<v>1 ))

				yyerror
				( 
					"Index size must be an unsigned value "
					"greater than or equal to zero"
				);
				$<v.pType>1 = tUns32;
				$<v.Type>1 = &uns32_ste;
				Setval( YYS &$<v>1, 0 );

			_endif


			$<v.Arity>$ = 1;
			$<v.Dimensions>$ =
				malloc2
				( 
					sizeof( unsigned ) 
				);

			*$<v.Dimensions>$ = $<v.u.unsval>1;
			$<v.NumElements>$ = $<v.u.unsval>1;
			$<v.u.ArrayOfValues>$ = NULL;
			_here;
		}

	|	IndexList ',' ConstOnlyExpr
		{
			_here;
			_if( !checkSmallUns( YYS &$<v>1 ))

				yyerror
				( 
					"Index size must be an unsigned integer "
					"greater than or equal to zero" 
				);
				$<v.pType>3 = tUns32;
				$<v.Type>3 = &uns32_ste;
				Setval( YYS &$<v>1, 1 );

			_endif

			$<v.Arity>$ = $<v.Arity>1 + 1;
			$<v.Dimensions>$ =
				malloc2
				( 
					sizeof( unsigned ) * 
						( $<v.Arity>1 + 1 )
				);

			assert( $<v.Dimensions>1 != NULL );
			memcpy
			( 
				$<v.Dimensions>$, 
				$<v.Dimensions>1,
				sizeof( int ) * $<v.Arity>1
			);
			$<v.Dimensions>$[$<v.Arity>1] = $<v.u.unsval>3;
			$<v.NumElements>$ = $<v.NumElements>1 * $<v.u.unsval>3;
			$<v.u.ArrayOfValues>$ = NULL;
			free2( vss $<v.Dimensions>1 );
			_here; 

		}
	;



/*****************************************************/


/*****************************************************************/
/*                                                               */
/* AryRecID-                                                     */
/*                                                               */
/* Matches a fully qualified fieldname or array cell reference.  */
/* Recursive, so it also matches arrays of records, field names  */
/* with array indicies, etc.                                     */
/*                                                               */
/* Examples:                                                     */
/* 			A                                                    */
/* 			A.B                                                  */
/* 			A.B[5]                                               */
/* 			A.B[5].C                                             */
/* 			A.B[5].C.D                                           */
/* 			A.B[5].C.D[2]                                        */
/* 			etc.                                                 */
/*                                                               */
/* Returns as its attribute the particular field or array object */
/* specified by the complete name.                               */
/*                                                               */
/*****************************************************************/

AryRecVal:	DefinedConstID	{ _here; memcpy( &$<v>$, $<s>1, sizeofSymNode ); }
		|	RecordRef	{ _here; memcpy( &$<v>$, &$<v>1, sizeofSymNode );  }
		|	ArrayRef	{ _here; memcpy( &$<v>$, &$<v>1, sizeofSymNode );  }
		;




/*******************************************************************/
/*                                                                 */
/* ArrayRef-                                                       */
/*                                                                 */
/* Parses a list of record/array names followed by a list of array */
/* indices.  Returns as its attribute the value of the specified   */
/* array element.                                                  */
/*                                                                 */
/*******************************************************************/


ArrayRef:
		AryRecVal 
		'[' 
		IndexList 
		Rbrack 
		{
			/*
			** Be sure this is a constant or value.
			*/

			_here;
			_if( !IsConstant( $<v.SymClass>1 ))

				/*
				** 04/05/2000-
				**
				** Not sure this condition is possible here.
				** RLH.
				*/

				yyerror( "Expected an array constant" );

				/*
				** Return an arbitrary constant value (true)
				** just to ensure the integrity of this attribute
				** for the calling code.
				*/

				memcpy( &$<v>$, &dummy_ste, sizeofSymNode );


			/*
			** Be sure it's an array constant.
			*/

			_elseif( $<v.pType>1 != tArray )

				yyerror( "Object must be an array" );

				/*
				** Return an arbitrary constant value (true)
				** just to ensure the integrity of this attribute
				** for the calling code.
				*/

				memcpy( &$<v>$, &dummy_ste, sizeofSymNode );


			_else

				int Offset;
				int ResultSize;
				int NewArity;

				/*
				** Okay, we've got an array identifier that is either
				** a cConstant or cValue object.  Pass along the
				** appropriate information to the calling code.
				**
				** Begin by determining if IndexList provides a valid
				** set of indices into the array by calling ComputeOffset.
				*/

				_if
				( 
					ComputeOffset
					( 
						YYS &$<v>1, 
						YYS &$<v>3, 
						&Offset, 
						&ResultSize 
					)
				)

					/*
					** Okay, the indexes are fine.  Extract an element
					** or an array slice.
					*/

					$<v.Type>$ = $<v.Type>1;
					$<v.ObjectSize>$ = $<v.Type>1->ObjectSize;
					$<v.MaxObjectSize>$ = $<v.Type>1->MaxObjectSize;
					$<v.Base>$ = $<v.Type>1->Base;
					$<v.Fields>$ = $<v.Type>1->Fields;
					$<v.FieldCnt>$ = $<v.Type>1->FieldCnt;
					$<v.NumElements>$ = 
						_ifx( ResultSize == 1, 0, ResultSize );

					NewArity = $<v.Arity>1 - $<v.Arity>3;
					$<v.Arity>$  = NewArity;

					/*
					** If this object is not an array slice, 
					** just copy the data field.
					*/

					_if( $<v.Arity>$ == 0 )

						/*
						** ClipType( &$<v>$, $<v.Type>1 );
						*/

						$<v.pType>$ = $<v.Type>1->pType;
						$<v.NumElements>$ = 0;
						$<v.Dimensions>$ = NULL;
						memcpy
						( 
							&$<v.u.StartOfValues>$,
							&$<v.u.ArrayOfValues>1[ Offset ].u.StartOfValues,
							sizeof( union ValuesSize )
						);

					_else

						/*
						** At this point, the object must be an 
						** array slice.
						**
						** Begin by copying the dimension array
						** (the dope vector).
						** We have an array object, make
						** a copy of the Dimensions list and
						** make a copy of the array data.
						*/

						$<v.pType>$ = tArray;
						$<v.Dimensions>$ = 
							malloc2( NewArity * sizeof( int ));


						memcpy
						( 
							$<v.Dimensions>$, 
							&$<v.Dimensions>1[ $<v.Arity>3 ],
							NewArity * sizeof( int )
						);


						/*
						** Now make a copy of the array's data.
						*/

						$<v.u.ArrayOfValues>$ =
							malloc2
							( 
								ResultSize * sizeofSymNode 
							);

						memcpy
						(
							$<v.u.ArrayOfValues>$,
							&$<v.u.ArrayOfValues>1[ Offset ], 
							ResultSize * sizeofSymNode
						);
						FreeValue( YYS &$<v>3 );

					_endif

				_endif

			_endif
			_here;
		}
	;



/***************************************************************/
/*                                                             */
/* RecordRef-                                                  */
/*                                                             */
/* Parses a record name followed by a period and a field name. */
/* Returns as its attribute the value of the specified field.  */
/*                                                             */
/***************************************************************/


RecordRef:	
		AryRecVal 
		'.' 
		AnyID
		{
			char msg[ 256 ];
			
			_here;
			_if( !IsConstant( $<v.SymClass>1 ))

				/*
				** Not sure this condition is possible here.
				** 04/05/2000, RLH.
				*/

				yyerror( "Expected a record or union constant" );
				
				/*
				** Return a dummy value to prevent inconsistencies
				** in the program.
				*/

				memcpy( &$<v>$, &dummy_ste, sizeofSymNode );

			_elseif( $<v.pType>1 == tRecord )

				/*
				** Look up the field reference to see if
				** it is actually a field of the record object.
				*/

				struct	SymNode	*FieldList;
				int				ValueIndex;
				char			*lcID;
				
				lcID = hlastrdup2( $<neID.idStr>3 ); 
				lowercase( lcID );
				FieldList = $<v.Fields>1;
				ValueIndex = 0;
				_while
				( 
						FieldList != NULL 
					&&	_strne( lcID, FieldList->Name )
				)

					FieldList = FieldList->Next;
					++ValueIndex;

				_endwhile
				_if
				( 
						FieldList != NULL 
					&&	_streq( $<neID.idStr>3, FieldList->TrueName )
				)
				
					assert( $<v.u.FieldValues>1 != NULL );

					/*
					** Copy the data associated with this record entry.
					** (Does this really need to be a deep copy?)
					*/


					DeepCopy
					( 
						&$<v>$, 
						&$<v.u.FieldValues>1[ ValueIndex ] 
						/* sizeofSymNode  */
					);

					/*
					** Alas, the important type info wasn't part of
					** the field values, we must grab that info
					** from the FieldList object.
					*/

					memcpy
					(
						&$<v>$,
						FieldList,
						sizeofSymNode - sizeof( union ValuesSize )
					);
					$<v.SymClass>$ = $<v.SymClass>1;

				_else

					ErrorNear
					( 
						"Undefined symbol/field name", 
						$<neID.idStr>3, 
						__LINE__,
						__FILE__ 
					);

					/*
					** Return a dummy value to prevent inconsistencies
					** in the program.
					*/

					memcpy( &$<v>$, &dummy_ste, sizeofSymNode );

				_endif
				free2( vss lcID );
				
				

			_elseif( $<v.pType>1 == tUnion )
			
				assert( $<v.CurField>1 != NULL );
				assert( $<v.CurField>1->TrueName != NULL );
				
				_if( _strne( $<neID.idStr>3, $<v.CurField>1->TrueName ))

					sprintf
					(
						msg,
						"%s is the currently active "
						"field for union object %s (not %s)",
						$<v.CurField>1->TrueName,
						$<v.TrueName>1,
						$<neID.idStr>3
					);
					yyerror( msg );

					/*
					** Return a dummy value to prevent inconsistencies
					** in the program.
					*/

					memcpy( &$<v>$, &dummy_ste, sizeofSymNode );
					
				_else
				
					// Okay, they've specified the current field.
					// Return its value.

					/*
					** Copy the data associated with this record entry.
					** (Does this really need to be a deep copy?)
					*/

					DeepCopy
					( 
						&$<v>$, 
						&$<v.u.FieldValues>1[ $<v.CurIndex>1 ] 
					);

					/*
					** Alas, the important type info wasn't part of
					** the field CurField List object.
					*/

					memcpy
					(
						&$<v>$,
						$<v.CurField>1,
						sizeofSymNode - sizeof( union ValuesSize )
					);
					$<v.SymClass>$ = $<v.SymClass>1;
					

				_endif					

			_else /* not a record object */

				yyerror
				( 
					"Expected record or union object" 
				);

				/*
				** Return a dummy value to prevent inconsistencies
				** in the program.
				*/

				memcpy( &$<v>$, &dummy_ste, sizeofSymNode );

			_endif
			free2( vss $<neID.idStr>3 );
			_here;
		}
	;


/*****************************************************/


/*********************************************************************/
/*                                                                   */
/* AryRecObj-                                                        */
/*                                                                   */
/* Returns as its attribute the address of the value field associated*/
/* with the specified array/record object.                           */
/* 	                                                                 */
/*********************************************************************/



AryRecObj:	DefinedID	
			{ 

				_here;
				memcpy( &$<v>$, $<s>1, sizeofSymNode );
				$<v.u.PtrToValue>$ = $<s>1;
				
				/*
				** If this is an array object, we must make a copy of the
				** dimensions array since users of ArrayAdrs and RecordAdrs
				** will free this array when they are done.
				*/
				
				_if( $<v.Dimensions>$ != NULL )
				
					$<v.Dimensions>$ = malloc2( $<v.Arity>$ * sizeof( int ));
					memcpy
					( 
						$<v.Dimensions>$, 
						$<s>1->Dimensions,
						$<v.Arity>$ * sizeof( int )  
					);

				_endif
				_here;
			}

		|	RecordAdrs { _here; memcpy( &$<v>$, &$<v>1, sizeofSymNode ); }
		|	ArrayAdrs { _here; memcpy( &$<v>$, &$<v>1, sizeofSymNode ); }
		;






/***************************************************************************/
/*                                                                         */
/* RecordAdrs-                                                             */
/*                                                                         */
/* Processes an object of the form << `namestuff` . fieldID >>,            */
/* where `namestuff` represents a qualified record/array name string and   */
/* ".fieldID" represents a field name.  Returns normal                     */
/* type information plus a pointer to the data associated with the actual  */
/* record/union field.                                                     */
/*                                                                         */
/***************************************************************************/


RecordAdrs:	
		AryRecObj 
		'.' 
		AnyID
		{
			_here;
			_if( !IsConstant( $<v.SymClass>1 ))

				/*
				** 04/05/2000 RLH
				**
				**	This  condition doesn't seem possible.
				*/

				yyerror( "Expected a record or union constant" );
				
				/*
				** Return a dummy value to prevent inconsistencies
				** in the program.
				*/

				memcpy( &$<v>$, &dummy_ste, sizeofSymNode );
				$<v.u.PtrToValue>$ = NULL;


			_elseif( $<v.pType>1 == tRecord || $<v.pType>1 == tUnion )

				/*
				** Look up the field reference to see if
				** it is actually a field of the record object.
				*/

				struct	SymNode	*FieldList;
				int				ValueIndex;
				char			*lcID;
				
				lcID = hlastrdup2( $<neID.idStr>3 );
				lowercase( lcID );
				FieldList = $<v.Fields>1;
				ValueIndex = 0;
				_while
				( 
						FieldList != NULL 
					&&	_strne( lcID, FieldList->Name )
				)

					FieldList = FieldList->Next;
					++ValueIndex;

				_endwhile

				_if
				( 
						FieldList != NULL 
					&&	_streq( $<neID.idStr>3, FieldList->TrueName )
				)

					
					/*
					** Copy all the uninteresting fields.
					*/

					memcpy
					( 
						&$<v>$, 
						FieldList, 
						sizeofSymNode 
					);
					$<v>$.SymClass = $<v.SymClass>1;

					// If it's a union, we've got to set the current
					// field info:
					
					_if( $<v.pType>1 == tUnion )

						$<v.u.PtrToValue>1->CurIndex = ValueIndex;
						$<v.u.PtrToValue>1->CurField = FieldList;
						
					_endif
					
					/*
					** If this is a scalar (non-array) object, 
					** just get the address of the data field.
					*/

					_if( FieldList->Arity == 0 )

						$<v.u.PtrToValue>$ = 
							&$<v.u.PtrToValue>1->u.FieldValues[ ValueIndex ];

					_else


						/*
						** At this point, the object must be an 
						** array.
						**
						** Begin by copying the dimension array
						** (the dope vector).
						** We have an array object, make
						** a copy of the Dimensions list and
						** make a copy of the array data.
						*/

						$<v.pType>$ = tArray;
						$<v.Dimensions>$ = 
							malloc2
							( 
									FieldList->Arity
								* 	sizeof( int )
							);


						memcpy
						( 
							$<v.Dimensions>$, 
							FieldList->Dimensions,
							FieldList->Arity * sizeof( int )
						);

						/*
						** Now return the address of the fields's data.
						*/

						$<v.u.PtrToValue>$ = 
							&$<v.u.PtrToValue>1->u.FieldValues[ ValueIndex ];

					_endif


				_else

					ErrorNear
					( 
						"Undefined field name", 
						$<neID.idStr>3,
						__LINE__,
						__FILE__ 
					);

					/*
					** Return a dummy value to prevent inconsistencies
					** in the program.
					*/

					memcpy( &$<v>$, &dummy_ste, sizeofSymNode );
					$<v.u.PtrToValue>$ = NULL;

				_endif
				free2( vss lcID );


			_else /* not a record object */

				yyerror
				( 
					"Expected record or union object" 
				);

				/*
				** Return a dummy value to prevent inconsistencies
				** in the program.
				*/

				memcpy( &$<v>$, &dummy_ste, sizeofSymNode );
				$<v.u.PtrToValue>$ = NULL;

			_endif
			free2( vss $<neID.idStr>3 );
			_here;
		}
	;



/**************************************************************************/
/*                                                                        */
/* ArrayAdrs-                                                             */
/*                                                                        */
/* Processes an object of the form << `namestuff` [indexlist] >>,         */
/* where `namestuff` represents a qualified record/array name string and  */
/* [indexlist] represents a list of array indicies.  Returns normal       */
/* type information plus a pointer to the data associated with the actual */
/* array element.                                                         */
/*                                                                        */
/**************************************************************************/


ArrayAdrs:
			AryRecObj '[' IndexList Rbrack 
			{

				_here;
				
				/*
				** Be sure this is a constant or value.
				*/

				_if( !IsConstant( $<v.SymClass>1 ))

					/*
					** 04/05/2000 RLH
					**
					**	This  condition doesn't seem possible.
					*/

					yyerror( "Expected an array constant" );

					/*
					** Return an arbitrary constant value (true)
					** just to ensure the integrity of this attribute
					** for the calling code.
					*/

					memcpy( &$<v>$, &dummy_ste, sizeofSymNode );
					$<v.u.PtrToValue>$ = NULL;


				/*
				** Be sure it's an array constant.
				*/

				_elseif( $<v.pType>1 != tArray )

					yyerror( "Object must be an array" );

					/*
					** Return an arbitrary constant value (true)
					** just to ensure the integrity of this attribute
					** for the calling code.
					*/

					memcpy( &$<v>$, &dummy_ste, sizeofSymNode );
					$<v.u.PtrToValue>$ = NULL;


				_else

					int Offset;
					int ResultSize;
					int NewArity;

					/*
					** Okay, we've got an array identifier that is either
					** a cConstant or cValue object.  Pass along the
					** appropriate information to the calling code.
					**
					** Begin by determining if IndexList provides a valid
					** set of indices into the array by calling ComputeOffset.
					*/

					_if
					( 
						ComputeOffset
						( 
							YYS &$<v>1, 
							YYS &$<v>3, 
							&Offset, 
							&ResultSize 
						)
					)

						/*
						** Okay, the indexes are fine.  Extract an element
						** or an array slice.
						*/

						$<v.Type>$ = $<v.Type>1;
						$<v.Base>$ = $<v.Type>1->Base;
						$<v.Fields>$ = $<v.Type>1->Fields;
						$<v.FieldCnt>$ = $<v.Type>1->FieldCnt;
						$<v.NumElements>$ = 
							_ifx( ResultSize == 1, 0, ResultSize );

						NewArity = $<v.Arity>1 - $<v.Arity>3;
						$<v.Arity>$  = NewArity;

						/*
						** If this is a scalar object, 
						** just get the address of the data field.
						*/

						_if( $<v.Arity>$ == 0 )

							$<v.pType>$ = $<v.Type>1->pType;

							$<v.Dimensions>$ = NULL;
							$<v.u.PtrToValue>$ =
								&$<v.u.PtrToValue>1->u.ArrayOfValues[ Offset ];

						_else

							/*
							** At this point, the object must be an 
							** array slice.
							**
							** Begin by copying the dimension array
							** (the dope vector).
							** We have an array object, make
							** a copy of the Dimensions list and
							** make a copy of the array data.
							*/

							$<v.pType>$ = tArray;
							$<v.Dimensions>$ = 
								malloc2( NewArity * sizeof( int ));


							memcpy
							( 
								$<v.Dimensions>$, 
								&$<v.Dimensions>1[ $<v.Arity>3 ],
								NewArity * sizeof( int )
							);


							/*
							** Now the address of the array's data.
							*/

							$<v.u.PtrToValue>$ = 
								&$<v.u.PtrToValue>1->u.ArrayOfValues[ Offset ];

							FreeValue( YYS &$<v>3 );

						_endif

					_endif

				_endif
			    _here;
			}

	;








/*
** RecordList/RecList-
**
**	These productions process all the fields in the record.
**	Expected inherited attributes:
**
**		$0:	Pointer to chain in symbol table entry that specifies the
**			fields for this record.
**
**		RecordValues->FieldValues:	
**			Pointer to block of memory to hold record data.
*/


RecordList:
		RecList
		{
			
			struct	SymNode	*s;

			_here;
			s = $<s>1;

			// Begin by skipping over the VAL/CONST fields that might exist:
			
			_while( s != NULL && IsConstant( s->SymClass ) )
			
				s = s->Next;
				
			_endwhile;

			/*
			** RecList did the actual work, now just check to see
			** if there were enough fields in the record constant.
			*/

			_here;
			_if( s != NULL )

				yyerror( "Incorrect number of fields in record constant" );

				/*
				** Return a "safe" type to avoid problems.
				*/

				$<v.pType>$ = tUns32;

			_else

				$<v.pType>$ = tRecord;

			_endif
			_here;
		}
	;				   



RecList:
		/*
		** Process the last (or only) field in the record.
		*/

		ConstOnlyExpr
		{
			struct	SymNode	*s;
			struct	SymNode	*iter;
			struct	SymNode	*next;
			union	YYSTYPE	*v;
			union	YYSTYPE	*endAU;
			int				fIndex;
			int				cnt;
			
			_here;
			s = $<s>0;
			assert( s != NULL );

			// Begin by skipping over the VAL/CONST fields that might exist:
			
			_while( s != NULL && IsConstant( s->SymClass ) )
			
				s = s->Next;
				
			_endwhile;
			assert( s != NULL );


			// Default next field (the one that follows the current field)
			// is the very next field in the list.  
			//
			// "next" holds the pointer to the next field in the fields list
			// that this production will return.
			
			next = s->Next;
			
			
			// Check to see if the record is expecting an anonymous union
			// here.
			

			_if( s->pType == tAnonUnion )

				// We're expecting an anonymous union here.
				// Since they simply supplied a constant
				// (without the union.field[ --- ] syntax),
				// we'll just assume they want to use the
				// first field of the union.  This means
				// we use offset one (zero-based) into the
				// array of field values to select the
				// "slot" for the value, and we use the
				// next-to-last item in the fields list
				// as the type specification.
				//
				// Save a pointer (endAU) to this entry in the constant
				// as we have to back-patch some fields later on.
				
				endAU = 
					YYS &RecordValues->v.u.FieldValues[ RecordValues->v.Arity ];
					
				ClrConst
				(
					YYS endAU,
					tAnonUnion,
					&dummyType_ste		// No type, it's dynamically created.
				);
				s = s->Next;
				assert( s != NULL );
				
				// We have to count the number of fields in the anonymous
				// record so we can fill in the field values in the reverse
				// order.  Note that cnt doesn't include the bracketing fields,
				// so we'll have to add two to it later.
				
				cnt = 0;
				iter = s;	// Point iter at first data field.
				_while( iter->pType != tAnonUnion )
				
					++cnt;
					iter = iter->Next;
					assert( iter != NULL );
					
				_endwhile
				
				
				// Save the current index into the record's data array.
				// This corresponds to the first field of the anonymous
				// union which is where we will place the actual data
				// later on.
				
				fIndex = RecordValues->v.Arity + 1; // Skips 1st bracket entry.
				RecordValues->v.Arity += cnt+2;		// Skip beyond anon union.
				
				// Okay, now except for the first field (which is the
				// last field in the "s" list), let's clear all the
				// data fields.  
				
				_for( int i=cnt-1, i > 0, --i )
				
					v = YYS &RecordValues->v.u.FieldValues
							[ 
								fIndex + i 
							];
						
					ClrConst
					(
						YYS v,
						s->pType,
						s->Type
					);
					s = s->Next;
					assert( s->Next != NULL );
					
				_endfor
				
				
				
				// Okay, now s is pointing at the first field of
				// the union (which was the last item in the list).
				
				_if( FieldsAreCompatible( s, YYS &$<v>1 ))
				
					/*
					** Force the value's type to be the same as
					** the field if the types were compatible.
					** This undoes promotions like byte->uns8
					** when the field type really should be byte.
					** Treat pointers specially and pass them though
					** unchanged.
					*/
					
					_if( $<v.pType>1 != tPointer )

						$<v.pType>1 = s->pType;
						$<v.Type>1 = s->Type;

					_endif
										
					/*
					** Okay, the data types are compatible, copy the data 
					** from the constant into the record object we are 
					** constructing (in RecordValues).
					*/

					memcpy
					(
						&RecordValues->v.u.FieldValues[ fIndex ],
						&$<v>1,
						sizeofSymNode
					);

					
					
					// Okay, set up the last tAnonUnion field:

					v = YYS &RecordValues->v.u.FieldValues
							[ 
								RecordValues->v.Arity - 1 
							];
							
					ClrConst
					(
						YYS v,
						tAnonUnion,
						&dummyType_ste
					);
					
					// The ending Anon Union field overloads
					// the following symbol table fields:
					//
					//	CurField-	Pointer to the record's field list
					//				entry (so we can extract the type
					//				name later.
					//
					//	CurIndex-	Offset from the first tAnonUnion
					//				field where the actual data lies.
					//				This is always one since we're
					//				assuming the use of the first field
					//				in the union.
					//
					//	FieldCnt-	Total number of fields for this
					//				anonymous record (including the two
					//				tAnonUnion fields).
					
					v->v.CurField = s;
					v->v.CurIndex = 1;
					v->v.FieldCnt = cnt+2;

					endAU->v.CurField = s;
					endAU->v.CurIndex = 1;
					endAU->v.FieldCnt = cnt+2;

					// Skip the End Anon Union field:
					
					next = s->Next->Next;
					

				_else

					char msg[ 256 ];

					sprintf
					(
						msg, 
						"Type mismatch in field %s",
						s->TrueName
					);
					yyerror( msg );

				_endif
			
			
			_elseif( s->pType == tAnonRec )
			
				yyerror
				( 
					"Record/union constants may not contain anonymous records"
				);
				
			_else
			
				/*
				** Assume we correctly return a record type.
				** First, see if the type of the current constant in the
				** list of record fields (which looks like an array constant
				** to us) is the same type as the current field that
				** $<s>0 is pointing at.
				*/

				_if( FieldsAreCompatible( s, YYS &$<v>1 ))
				

					/*
					** Force the value's type to be the same as
					** the field if the types were compatible.
					** This undoes promotions like byte->uns8
					** when the field type really should be byte.
					*/
					
					_if( $<v.pType>1 != tPointer )
					
						$<v.pType>1 = s->pType;
						$<v.Type>1 = s->Type;
						
					_endif
					
					/*
					** Okay, the data types are compatible, if we haven't
					** exceeded the total number of fields allowed in the
					** specified record type, then copy the data from the
					** constant into the record object we are constructing
					** (in RecordValues).
					*/

					_if( RecordValues->v.Arity < RecordValues->v.FieldCnt )

						memcpy
						(
							&RecordValues->v.u.FieldValues
								[ RecordValues->v.Arity ],
							&$<v>1,
							sizeofSymNode
						);
						++RecordValues->v.Arity;

					_endif

				_else

					char msg[ 256 ];

					sprintf
					(
						msg, 
						"Type mismatch in field %s",
						s->TrueName
					);
					yyerror( msg );

				_endif
				
			_endif
			$<s>$ = next;
			_here;

		}
	;



	/*
	** Process the last (or only) field in the record when
	** it takes the form "union.field:[constexpr]".
	*/

RecList:

		unionTkn		/* $1 */
		'.'				/* $2 */
		AnyID			/* $3 */
		Colon			/* $4 */
		Lbrack			/* $5 */
		ConstOnlyExpr	/* $6 */
		Rbrack			/* $7 */
		{
			struct	SymNode	*s;
			struct	SymNode	*temp;
			struct	SymNode	*theField;
			struct	SymNode	*next;
			union	YYSTYPE	*v;
			union	YYSTYPE	*f;
			union	YYSTYPE	*endAU;
			int				rIndex;
			int				startIndex;
			int				upCntr;
			char			*lcName;
			int				cnt;
			char			msg[ 256 ];
			
			_here;
			s = $<s>0;
			assert( s != NULL );

			// Default next field is the very next field in the list.
			
			next = s->Next;
			_if( s->pType == tAnonUnion )
			
				// Because we have to reverse everything, the
				// first thing we need to do is count all the fields.
				
				cnt = 1;
				temp = s->Next;
				_while( temp->pType != tAnonUnion )
				
					++cnt;
					temp = temp->Next;
					assert( temp != NULL );
					
				_endwhile
				++cnt;		// Count the last field, too.
				
				// Now clear all the fields associated with
				// this anonymous union, and while we're doing that,
				// let's find the selected field.
				//
				// Begin by clearing the last bracketing field item:
				
				startIndex = RecordValues->v.Arity;
				endAU = YYS &RecordValues->v.u.FieldValues[ startIndex ]; 
				ClrConst
				(
					YYS endAU,
					tAnonUnion,
					&dummyType_ste
				);
				++RecordValues->v.Arity;
				s = s->Next;
				
				// The fields are actually in the list backwards.
				// Clear all the fields and save an index into
				// the array where we find the field we're interested in.
				
				
				lcName = lowercase( hlastrdup2( $<neID.idStr>3 ));
				f = NULL;
				upCntr = 1;
				_for( int i=cnt-2, i > 0, --i )

					v = YYS &RecordValues->v.u.FieldValues
							[ 
								RecordValues->v.Arity + i - 1 
							];
						
					_if( _streq( s->Name, lcName ))
					
						f = v;
						theField = s;
						rIndex = i;
						_if( _strne( $<neID.idStr>3, s->TrueName ))
						
							sprintf
							(
								msg,
								"Mispelled identifier, perhaps you meant %s",
								s->TrueName
							);
							yyerror( msg );
							
						_endif
						
					_endif

					ClrConst
					(
						YYS v,
						s->pType,
						s->Type
					);

					++upCntr;
					s = s->Next;
					
				_endfor
				RecordValues->v.Arity += cnt-2;
				free2( vss lcName );

				// Okay, set up the last tAnonUnion field:

				v = YYS &RecordValues->v.u.FieldValues
						[ 
							RecordValues->v.Arity 
						];
						
				ClrConst
				(
					YYS v,
					tAnonUnion,
					&dummyType_ste
				);
				
				// The ending Anon Union field overloads
				// the following symbol table fields:
				//
				//	CurField-	Pointer to the record's field list
				//				entry (so we can extract the type
				//				name later.
				//
				//	CurIndex-	Offset from the first tAnonUnion
				//				field where the actual data lies.
				//				This is always one since we're
				//				assuming the use of the first field
				//				in the union.
				//
				//	FieldCnt-	Total number of fields for this
				//				anonymous record (including the two
				//				tAnonUnion fields).
				
				v->v.CurField = _ifx( f == NULL, s, theField );
				v->v.CurIndex = rIndex;
				v->v.FieldCnt = cnt;

				endAU->v.CurField = _ifx( f == NULL, s, theField );
				endAU->v.CurIndex = rIndex;
				endAU->v.FieldCnt = cnt;


				// Skip the End Anon Union field:
				
				++RecordValues->v.Arity;
				next = s->Next;
				
				// Okay, now f is pointing at the appropriate field,
				
				_if( f == NULL )
				
					sprintf
					( 
						msg, 
						"Field %s was not found in anonymous union",
						$<neID.idStr>3
					);
					yyerror( msg );
					
				
				_elseif( FieldsAreCompatible( SSN f, YYS &$<v>6 ))
				

					/*
					** Force the value's type to be the same as
					** the field if the types were compatible.
					** This undoes promotions like byte->uns8
					** when the field type really should be byte.
					*/
					
					_if( $<v.pType>1 != tPointer )

						$<v.pType>1 = f->v.pType;
						$<v.Type>1 = f->v.Type;
						
					_endif
					
					/*
					** Okay, the data types are compatible, copy the data 
					** from the constant into the record object we are 
					** constructing (in RecordValues).
					*/

					memcpy
					(
						&RecordValues->v.u.FieldValues[ rIndex + startIndex ],
						&$<v>6,
						sizeofSymNode
					);					

				_else

					sprintf
					(
						msg, 
						"Type mismatch in field %s",
						$<neID.idStr>3
					);
					yyerror( msg );

				_endif
				next = s->Next;
				
			
			_elseif( s->pType == tAnonRec )
			
				yyerror
				( 
					"Record/union constants may not contain anonymous records"
				);
				
			_else
			
				sprintf
				(
					msg,
					"Expected an anonymous union with field %s",
					$<neID.idStr>3
				);
				yyerror( msg );
				
			_endif
			
			free2( vss $<neID.idStr>3 );
			$<s>$ = next;
			_here;
		}
	;


RecList:
		ConstOnlyExpr 
		',' 
		{
			/*
			** Set up inherited attribute for RecList
			*/

			_here;
			$<s>$ = $<s>0;
		} 
		RecList
		{

			struct	SymNode	*s;
			struct	SymNode	*iter;
			struct	SymNode	*next;
			union	YYSTYPE	*v;
			union	YYSTYPE	*endAU;
			int				fIndex;
			int				cnt;
			
			_here;
			
			// Begin by skipping over the VAL/CONST fields that might exist:
			
			s = $<s>4;
			_while( s != NULL && IsConstant( s->SymClass ) )
			
				s = s->Next;
				
			_endwhile;
			_if( s != NULL )

				// Default next field is the very next field in the list.
				
				next = s->Next;
				_if( s->pType == tAnonUnion )

					// We've got an anonymous union here.
					// Since they simply supplied a constant
					// (without the union.field[ --- ] syntax),
					// we'll just assume they want to use the
					// first field of the union.
					
					endAU = 
						YYS &RecordValues->v.u.FieldValues
							[ 

								RecordValues->v.Arity 
							];
						
					ClrConst
					(
						YYS endAU,
						tAnonUnion,
						&dummyType_ste
					);
					s = s->Next;
					assert( s != NULL );



					// We have to count the number of fields in the anonymous
					// record so we can fill in the field values in the reverse
					// order.  Note that cnt doesn't include the bracketing fields,
					// so we'll have to add two to it later.
					
					cnt = 0;
					iter = s;	// Point iter at first data field.
					_while( iter->pType != tAnonUnion )

					
						++cnt;
						iter = iter->Next;
						assert( iter != NULL );
						
					_endwhile
					fIndex = RecordValues->v.Arity + 1;	// Save index for later
					RecordValues->v.Arity += cnt+2;		// Skip beyond union.
				
					// Okay, let's clear all the data fields except
					// the first one (which is the last entry in the list).  
					
					_for( int i=cnt-1, i > 0, --i )
					
						v = YYS &RecordValues->v.u.FieldValues
								[ 
									fIndex + i 
								];
							
						ClrConst
						(
							YYS v,
							s->pType,
							s->Type
						);
						s = s->Next;
						assert( s->Next != NULL );
						
					_endfor
					
					
					
					// Okay, now s is pointing at the first field
					// (the last entry in the list).
					
					_if( FieldsAreCompatible( s, YYS &$<v>1 ))
					

						/*
						** Force the value's type to be the same as
						** the field if the types were compatible.
						** This undoes promotions like byte->uns8
						** when the field type really should be byte.
						*/
						
						_if( $<v.pType>1 != tPointer )

							$<v.pType>1 = s->pType;
							$<v.Type>1 = s->Type;
							
						_endif
							
						/*
						** Okay, the data types are compatible, copy the data 
						** from the constant into the record object we are 
						** constructing (in RecordValues).
						*/

						memcpy
						(
							&RecordValues->v.u.FieldValues[ fIndex ],
							&$<v>1,
							sizeofSymNode
						);

						
						
						// Okay, set up the last tAnonUnion field:

						v = YYS &RecordValues->v.u.FieldValues
								[ 
									RecordValues->v.Arity - 1 
								];
								
						ClrConst
						(
							YYS v,
							tAnonUnion,
							&dummyType_ste
						);
						
						// The ending Anon Union field overloads
						// the following symbol table fields:
						//
						//	Offset-		Index into the record constant array
						//				where the value for this field can
						//				be found (always one since this is
						//				the default index).
						//
						//	FieldCnt-	Total number of fields for this
						//				anonymous record (including the two
						//				tAnonUnion fields).
						//
						//	Base-		Pointer to the ending type bracket
						//				for the anon union (this is the
						//				"Anon Union" entry).
						//
						//	unsval-		Number of fields to skip in the
						//				backwards field list to get to
						//				the field description that corresponds
						//				to this field (Always FieldCnt-1 since
						//				the default field is always the first
						//				field of this Anon Union).

						v->v.CurField = s;
						v->v.CurIndex = 1;
						v->v.FieldCnt = cnt+2;

						endAU->v.CurField = s;
						endAU->v.CurIndex = 1;
						endAU->v.FieldCnt = cnt+2;
								 
						// Skip the End Anon Union field:
						
						next = s->Next->Next;
						

					_else

						char msg[ 256 ];

						sprintf
						(
							msg, 
							"Type mismatch in field %s",
							s->TrueName
						);
						yyerror( msg );

					_endif
				
				
			
				_elseif( s->pType == tAnonRec )
				
					yyerror
					( 
						"Record/union constants may not contain "
						"anonymous records"
					);
				
				_else


					_if( FieldsAreCompatible( s, YYS &$<v>1 ))


						/*
						** Force the value's type to be the same as
						** the field if the types were compatible.
						** This undoes promotions like byte->uns8
						** when the field type really should be byte.
						*/
						
						_if( $<v.pType>1 != tPointer )
						
							$<v.pType>1 = s->pType;
							$<v.Type>1 = s->Type;
							
						_endif
						
						
						_if
						( 
								RecordValues->v.Arity < 
									RecordValues->v.FieldCnt 
						)

							memcpy
							(
								&RecordValues->v.u.FieldValues
									[ RecordValues->v.Arity ],
								&$<v>1,
								sizeofSymNode
							);
							++RecordValues->v.Arity;

						_endif
			 
					_else

						char msg[ 256 ];

						sprintf
						(
							msg, 
							"Type mismatch in field %s",
							s->TrueName
						);
						yyerror( msg );

					_endif
					
				_endif
				$<s>$ = next;

			_else

				yyerror( "Too many fields in record constant" );
				
				$<s>$ = NULL; 

			_endif
			(void) $<s>3;	// Shut up Bison
			_here;
		}
	;



	/*
	** Process the the fields in the record when
	** they take the form "union.field:[constexpr]"
	** (all but the last or only).
	*/


RecList:
		unionTkn		/* $1 */
		'.'				/* $2 */
		AnyID			/* $3 */
		Colon			/* $4 */
		Lbrack			/* $5 */
		ConstOnlyExpr	/* $6 */
		Rbrack			/* $7 */
		','				/* $8 */
		{
			/*
			** Set up inherited attribute for RecList
			*/

			_here;
			$<s>$ = $<s>0;
		} 
		RecList			/* $10 */
		{
			struct	SymNode	*s;
			struct	SymNode	*temp;
			struct	SymNode	*next;
			struct	SymNode	*theField;
			union	YYSTYPE	*v;
			union	YYSTYPE	*f;
			union	YYSTYPE	*endAU;
			int				rIndex;
			int				startIndex;
			int				upCntr;
			int				cnt;
			char			*lcName;
			char			msg[ 256 ];
			
			_here;
			_if( $<s>10 != NULL )
				
				s = $<s>10;

				// Default next field is the very next field in the list.
				
				next = s->Next;
				_if( s->pType == tAnonUnion )

					// Because we have to reverse everything, the
					// first thing we need to do is count all the fields.
					
					cnt = 1;
					temp = s->Next;
					_while( temp->pType != tAnonUnion )
					
						++cnt;
						temp = temp->Next;
						assert( temp != NULL );
						
					_endwhile
					++cnt;		// Count the last field, too.
				

					// We've got an anonymous union here.  That's good
					// since the user is specifying a field of that union.
					
					startIndex = RecordValues->v.Arity;
					endAU = YYS &RecordValues->v.u.FieldValues[ startIndex ];
					ClrConst
					(
						YYS endAU,
						tAnonUnion,
						&dummyType_ste
					);
					++RecordValues->v.Arity;
					s = s->Next;
					
					// The fields are actually in the list backwards.
					// Clear all the fields and save an index into
					// the array where we find the field we're interested in.
					
					
					lcName = lowercase( hlastrdup2( $<neID.idStr>3 ));
					f = NULL;
					upCntr = 1;
					_for( int i=cnt-2, i > 0, --i )
					
						v = YYS &RecordValues->v.u.FieldValues
								[ 
									RecordValues->v.Arity + i - 1 
								];
							
						_if( _streq( s->Name, lcName ))
						
							f = v;
							theField = s;
							rIndex = i;
							_if( _strne( $<neID.idStr>3, s->TrueName ))
							
								sprintf
								(
									msg,
									"Mispelled identifier, "
									"perhaps you meant %s",
									s->TrueName
								);
								yyerror( msg );
								
							_endif
							
						_endif

						ClrConst
						(
							YYS v,
							s->pType,
							s->Type
						);
						++upCntr;

						s = s->Next;
						
					_endfor
					RecordValues->v.Arity += cnt-2;
					free2( vss lcName );

					// Initialize the last tAnonUnion field:
					
					v = YYS &RecordValues->v.u.FieldValues
							[ 
								RecordValues->v.Arity 
							];
							
					ClrConst
					(
						YYS v,
						tAnonUnion,
						&dummyType_ste
					);
					
				
					// The ending Anon Union field overloads
					// the following symbol table fields:
					//
					//	CurField-	Pointer to the record's field list
					//				entry (so we can extract the type
					//				name later.
					//
					//	CurIndex-	Offset from the first tAnonUnion
					//				field where the actual data lies.
					//				This is always one since we're
					//				assuming the use of the first field
					//				in the union.
					//
					//	FieldCnt-	Total number of fields for this
					//				anonymous record (including the two
					//				tAnonUnion fields).
					
					v->v.CurField = _ifx( f == NULL, s, theField );
					v->v.CurIndex = rIndex;
					v->v.FieldCnt = cnt;

					endAU->v.CurField = _ifx( f == NULL, s, theField );
					endAU->v.CurIndex = rIndex;
					endAU->v.FieldCnt = cnt;

					// Move on to the next field in the constant:
					
					++RecordValues->v.Arity;
					next = s->Next;
					
					// Okay, now f is pointing at the appropriate field,
					
					_if( f == NULL )
					
						sprintf
						( 
							msg, 
							"Field %s was not found in anonymous union",
							$<neID.idStr>3
						);
						yyerror( msg );
						
					
					_elseif( FieldsAreCompatible( SSN f, YYS &$<v>6 ))
					

						/*
						** Force the value's type to be the same as
						** the field if the types were compatible.
						** This undoes promotions like byte->uns8
						** when the field type really should be byte.
						*/
						
						_if( $<v.pType>1 != tPointer )

							$<v.pType>1 = f->v.pType;
							$<v.Type>1 = f->v.Type;
							
						_endif
						
						/*
						** Okay, the data types are compatible, copy the data 
						** from the constant into the record object we are 
						** constructing (in RecordValues).
						*/

						memcpy
						(
							&RecordValues->v.u.FieldValues[ rIndex + startIndex ],
							&$<v>6,
							sizeofSymNode
						);					

					_else

						sprintf
						(
							msg, 
							"Type mismatch in field %s",
							$<neID.idStr>3
						);
						yyerror( msg );

					_endif
					next = s->Next;
					
			
				_elseif( s->pType == tAnonRec )
				
					yyerror
					( 
						"Record/union constants may not contain "
						"anonymous records"
					);
					
				_else
				
					sprintf
					(
						msg,
						"Expected an anonymous union with field %s",
						$<neID.idStr>3
					);
					yyerror( msg );
					
				_endif
				free2( vss $<neID.idStr>3 );
				$<s>$ = next;

			_else

				yyerror( "Too many fields in record constant" );
				
				$<s>$ = NULL; 

			_endif
			(void) $<s>9;
			_here;
		}
	;

 


/*****************************************************/


/****************************************************************/
/*                                                              */
/* EnumList-                                                    */
/*                                                              */
/* Matches a list of symbolic named constants for an enumerated */
/* data type list.  Enters each name into the symbol table and  */
/* assigns a sequential ordinal value to that identifier.       */
/*                                                              */
/* Inherited Attribute:                                         */
/*                                                              */
/* 	$0 must be the address of the symbol table type entry for   */
/* 	each constant in the enumerated list.  It is the res-       */
/* 	sponsibility of the calling code to set up this inherited   */
/* 	attribute.                                                  */
/*                                                              */
/* Synthesized Attributes:                                      */
/*                                                              */
/* 	none.                                                       */
/*                                                              */
/****************************************************************/


EnumList:

		/*
		** Process a single identifier and add it to the symbol
		** table, assigning the next available enumeration value.
		**
		** This production handles the first symbol in an enumeration
		** list or the only symbol if there is only one.
		*/

		UndefinedID
		{
			struct SymNode TheValue;

			_here;
			assert( $<idStr>1 != NULL );

			Setval( YYS &TheValue, EnumVal );
			++EnumVal;

			InsertSym
			( 
				$<idStr>1, 
				$<v.Type>0,
				tEnum, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &TheValue,
				1,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			_here;
		}
	;

		 
		/*
		** Assign values to each symbol in the enumeration list.
		** This production handles the 2nd through nth symbols in
		** an enumeration list.
		*/

EnumList:
		UndefinedID 
		',' 
		{
			struct SymNode TheValue;

			_here;
			assert( $<idStr>1 != NULL );

			Setval( YYS &TheValue, EnumVal );
			++EnumVal;

			InsertSym
			( 
				$<idStr>1, 
				$<v.Type>0,
				tEnum, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &TheValue,
				1,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			$<v.Type>$ = $<v.Type>0;
			_here; 
		} 
		EnumList
		{
			_here;
			(void) $<v.Type>3;	// To shut up Bison
		}
	;


			/*
			** Handle some common errors found in enum lists.
			*/

EnumList:
		AnyLocalID
		{
			ErrorNear
			( 
				"Duplicate enumeration constant", 
				$<s>1->Name,
				__LINE__,
				__FILE__ 
			);
		} 

	|	AnyLocalID 
		',' 
		{
			ErrorNear
			( 
				"Duplicate enumeration constant", 
				$<s>1->Name,
				__LINE__,
				__FILE__ 
			);
		} 
		EnumList


	|	CopyLexeme error '}'
		{
			ErrorNear
			( 
				"Illegal enumeration list", 
				$<idStr>1,
				__LINE__,
				__FILE__
			);
			PushBackStr( "}" );
			free2( vss $<idStr>1 );
		}
			
	|	CopyLexeme error ';'
		{
			ErrorNear
			( 
				"Illegal enumeration list", 
				$<idStr>1,
				__LINE__,
				__FILE__ 
			);
			PushBackStr( "};" );
			free2( vss $<idStr>1 );
		}
			
	;

CopyLexeme:
			{
				/*
				** Set TempIgnoreErrors to true so yyerror
				** won't print a syntax error message along
				** with the error message we are providing.
				*/

				_here;
				TempIgnoreErrors = 1;
				$<idStr>$ = hlastrdup2(yytext);
			}
		;




/*****************************************************/

/*
** Auxilary productions to save compiler variables while
** the record and union productions play with their values.
*/	

Empty:	/* empty */ { _here; };


SaveOffset:
			{
				$<v.u.intval>$ = CurOffset;
				_here;
			}
		;

SaveDirection:
			{
				_here;
				$<v.u.intval>$ = CurOffsetDir;
			}
		;

SaveAdd1st:
			{
				_here;
				$<v.u.intval>$ = AddOffset1st;
			}
		;

SaveLex256:
			{
				_here;
				$<v.u.intval>$ = CurLexLevel;
				CurLexLevel = -256;
			}
		;

SaveLex3:
			{
				_here;
				$<v.u.intval>$ = CurLexLevel;
				CurLexLevel = CurLexLevel+1;  //was -3
			}
		;


/*****************************************************/

/*
** OptionalInherit-
**
**	This production processes the base class name following a
**	class definition, e.g.,
**
**	TypeName: class inherits(baseClassName)
**					 ^^^^^^^^^^^^^^^^^^^^^^^
**				<class stuff>
**
**			  endclass
**
**	Note that the base class item is optional.
**
**	This production returns, as its synthesized attribute,
**	a pointer to the symbol table entry for the base class.
**
*/



OptionalInherit:

			/*
			** This is optional, so allow an empty production.
			*/
				
			Empty
			{
				_here;
				$<s>$ = NULL
			}


			/*
			** If a base class name is actually present, make sure
			** it really is a class type.  If it is, return the
			** information that will allow the Class production
			** to properly allow for a base class.
			*/

		|	inheritsTkn Lparen TypeID Rparen
			{
				assert( $<s>3 != NULL );

				_here;
				_if( $<s>3->pType == tClass )

					$<s>$ = $<s>3;

				_else

					yyerror( "Base class type expected" );
					$<s>$ = NULL;

				_endif
			}


			/*
			** Handle a common error (unknown base type) here.
			*/

		|	inheritsTkn Lparen UndefID Rparen
			{
				ErrorNear
				( 
					"Undefined base type identifier",
					$<idStr>3,
					__LINE__,
					__FILE__ 
				);
				$<s>$ = NULL;

			}
		;



		
/*
** OptInherits-
**
**	This production processes the base record name following a
**	record definition, e.g.,
**
**	TypeName: record inherits(baseRecordName)
**					 ^^^^^^^^^^^^^^^^^^^^^^^
**				<record stuff>
**			  endrecord
**
**	Note that the base record item is optional.
**
**	This production assumes that there is a dorecordTkn non-terminal
**	at position $-1 and stores the base address of the base record
**	into the ru.base field of that NT's attribute.
**
*/



	
OptInherits:


			/*
			** This is optional, so allow an empty production.
			*/
				
			Empty
			{
				_here;
				$<ru.base>-1 = NULL				  
			}
			
			/*
			** If a base record name is actually present, make sure
			** it really is a record type.  If it is, return the
			** information that will allow the Record production
			** to properly allow for a base record.
			*/
			
		|	inheritsTkn		/* $1 */ 
			Lparen 			/* $2 */
			DefinedID 		/* $3 */
			Rparen			/* $4 */
			{
				assert( $<s>3 != NULL );
				_here;
				_if( $<ru.newOffset>-1 )
				
					yyerror
					( 
						"This record cannot both inherit fields and set a "
						"starting offset"
					);
					
				_endif
				_if
				( 
						$<ru.MinRecAlignment>-1 != 1 
					||	$<ru.MaxRecAlignment>-1 != 1 
				)
				
					yyerror
					(
						"This record cannot both inherit fields and specify "
						"alignment values"
					);
				
				_endif;
				_if( $<s>3->SymClass == cType )

					_if( $<s>3->pType == tRecord )
					
						struct SymNode *s;

						$<ru.base>-1 = $<s>3;

						// Copy the inherited fields to the new record:

						SymbolTable = CopyRecSymbols( $<s>3->Fields );

						
						// We've got to determine the starting
						// offset of the first field of the base
						// class so we can use that as our starting
						// field:
						
						s = $<s>3->Fields;
						assert( s != NULL );
						_while( s->Next != NULL )
						
							s = s->Next;
							
						_endwhile;
						
						$<ru.CurOffset>-1 = s->Offset;	// Starting offset.
						
						// Set the current offset to the base record's
						// starting offset plus it's size.  The next
						// record will pick up from there.
						
						CurOffset = s->Offset + $<s>3->ObjectSize;
						
						

					_else

						ErrorNear
						( 
							"Base record type expected",
							$<s>3->TrueName,
							__LINE__,
							__FILE__ 
						);
						$<ru.base>-1 = NULL;

					_endif

				_else

					ErrorNear
					( 
						"Expected a base type ID",
						$<s>3->TrueName,
						__LINE__,
						__FILE__ 
					);
					$<ru.base>-1 = NULL;

				_endif
				_here;
			}


			/*
			** Handle a common error (unknown base type) here.
			*/

		|	inheritsTkn 
			Lparen 
			UndefID 
			Rparen
			{
				ErrorNear
				( 
					"Undefined base type identifier",
					$<idStr>3,
					__LINE__,
					__FILE__ 
				);
				$<ru.base>-1 = NULL;
			}
		;
		
	
doUnionTkn:
		unionTkn
		{
			// Unions (generally) start with an offset of zero.
			// Save the current offset value away and set the
			// global CurOffset value to zero (note that anonymous
			// unions will have to reset the CurOffset back to
			// its original value, but that's another story...)
			
			_here;
			$<ru.SaveOffset>$ = CurOffset;
			$<ru.CurOffset>$ = CurOffset;
			CurOffset = 0;

			// Save the direction and add1st values.
			// Set them both to zero for unions.
			
			$<ru.SaveDir>$ = CurOffsetDir;
			CurOffsetDir = 0;	/* Forces all fields to the same offset */

			$<ru.SaveAdd1st>$ = AddOffset1st;
			AddOffset1st = 0;

			// Bump the current lex level (again, anonymous unions
			// will have to undo this).
			
			$<ru.SaveLex>$ = CurLexLevel;
			++CurLexLevel;
			

			// Save the alignment values.  Unions don't change them,
			// but it's not a bad idea to do this for consistency's
			// sake.
			
			$<ru.MinRecAlignment>$ = MinRecAlignment;
			$<ru.MaxRecAlignment>$ = MaxRecAlignment;
			$<ru.TempRecAlign>$ = TempRecAlign;
			TempRecAlign = 1;
			
			// Save the current record/union field count and then
			// set it to zero so we can count the fields in this record.
			
			$<ru.RecFieldCnt>$ = RecFieldCnt;
			RecFieldCnt = 0;

			// Misc initialization:
			
			$<ru.newOffset>$ = 0;
			$<ru.inSave>$ = (char)inUnion;
			inUnion = 1;
			
			// Preserve currentNS, etc.
			
			$<ru.saveCurNS>$ = currentNS;
			$<ru.saveRecNS>$ = RecNS;
			$<ru.saveRecGlobal>$ = RecGlobal;
			_if( RecNS == NULL )
			
				RecNS = currentNS;
				
			_endif
			_if( RecGlobal == NULL )
			
				RecGlobal = SymbolTable;
				
			_endif
			currentNS = NULL;
			
			// The current symbol table pointer is where the field list
			// will end.  Save a pointer to this spot so we can find
			// it later.
						
			$<ru.endFields>$ = SymbolTable;
			$<ru.base>$ = NULL;
			SymbolTable = &dummyField_ste;
			_here;
		}
	;



dorecordTkn:
		recordTkn	/* $1 */
		{
			/*
			** Initialize misc values:
			*/
			
			_here;
			$<ru.inSave>$ = (char)inRecord;
			inRecord = 1;

			$<ru.MinRecAlignment>$ = MinRecAlignment;
			$<ru.MaxRecAlignment>$ = MaxRecAlignment;
			MinRecAlignment = 1;
			MaxRecAlignment = 1;

			$<ru.RecFieldCnt>$ = RecFieldCnt;
			RecFieldCnt = 0;
			
			$<ru.SaveOffset>$ = CurOffset;
			$<ru.CurOffset>$ = 0;
			$<ru.newOffset>$ = 0;
			CurOffset = 0;
			
			$<ru.SaveLex>$ = CurLexLevel;
			++CurLexLevel;
			

			/*
			** In a record offsets are increasing and we increment
			** the offset *after* assigning to a field.
			*/

			$<ru.SaveDir>$ = CurOffsetDir;
			CurOffsetDir = 1;

			$<ru.SaveAdd1st>$ = AddOffset1st;
			AddOffset1st = 0;
			
			// Preserve currentNS:
			
			$<ru.saveCurNS>$ = currentNS;
			$<ru.saveRecNS>$ = RecNS;
			$<ru.saveRecGlobal>$ = RecGlobal;
			_if( RecNS == NULL )
			
				RecNS = currentNS;
				
			_endif
			_if( RecGlobal == NULL )
			
				RecGlobal = SymbolTable;
				
			_endif
			currentNS = NULL;

			/*
			** Mark the end of the fields for the record/union
			*/
			
			$<ru.endFields>$ = SymbolTable;
			$<ru.base>$ = NULL;
			SymbolTable = &dummyField_ste;
			_here;
		}
	;


  /*
  ** Note:	recordOpts always assumes that a dorecordTkn
  **		non-terminal immediately precedes the doRecordOpts
  **		non-terminal;  this code stores values into the
  **		attributes of $0!
  */
 
recordOpts:
		Empty
		{
			_here;
		}
	
	|	assignTkn	/* $1 */
		ConstExpr	/* $2 */
		Semicolon	/* $3 */
		{			

			_here;
			
			/*
			** If reasonable, set the starting offset to the
			** value of the constant expression above.
			*/
			
			_if( IsNumber( $<v.pType>2 ) && numBits( YYS &$<v>2 ) <= 32 )

				$<ru.CurOffset>0 = $<v.u.intval>2;
				CurOffset = $<v.u.intval>2;
				$<ru.newOffset>0 = 1;

			_else

				yyerror
				( 
					"Expected a 32-bit numeric constant" 
				);

			_endif
		}



	|	RecAlignment			/* $1 */
		{

			/*
			** In a record offsets are increasing and we increment
			** the offset *after* assigning to a field.
			*/

			_here;
			MinRecAlignment = $<ru.MinRecAlignment>1;
			MaxRecAlignment = $<ru.MaxRecAlignment>1;
		}

	|	RecAlignment			/* $1 */
		assignTkn				/* $2 */
		ConstExpr				/* $3 */
		Semicolon				/* $4 */
		{
			_here;
			MinRecAlignment = $<ru.MinRecAlignment>1;
			MaxRecAlignment = $<ru.MaxRecAlignment>1;
			_if( IsNumber( $<v.pType>3 ) && numBits( YYS &$<v>3 ) <= 32)

				$<ru.CurOffset>0 = $<v.u.intval>3;
				CurOffset = $<v.u.intval>3;
				$<ru.newOffset>0 = 1;

			_else

				yyerror
				( 
					"Expected a 32-bit numeric constant for starting offset" 
				);

			_endif
		}
	;
	

RecAlignment:
		'['			/* $1 */
		ConstExpr	/* $2 */
		Rbrack		/* $3 */
		{
			int align;

			_here;
			_if
			( 
					IsNumber( $<v.pType>2 )
				&&	checkSmallUns( YYS &$<v>2 ) 
				&&	$<v.u.unsval>2 >= 1
				&&	$<v.u.unsval>2 <= 4096
			)

				$<ru.MinRecAlignment>$ = $<v.u.unsval>2; // Min alignment
				$<ru.MaxRecAlignment>$ = $<v.u.unsval>2; // Max alignment

			_else

				yyerror( "Expected a constant in the range 1..4096" );
				$<ru.MinRecAlignment>$ = MinRecAlignment;
				$<ru.MaxRecAlignment>$ = MaxRecAlignment;

			_endif
			_here;
		}
	
	|	'['			/* $1 */
		ConstExpr	/* $2 */
		':'			/* $3 */
		ConstExpr	/* $4 */
		Rbrack		/* $5 */
		{
			int align;

			_here;
			_if
			( 
					IsNumber( $<v.pType>2 )
				&&	IsNumber( $<v.pType>4 ) 
				&&	checkSmallUns( YYS &$<v>2 ) 
				&&	checkSmallUns( YYS &$<v>4 ) 
				&&	$<v.u.unsval>2 <= 16
				&&	$<v.u.unsval>4 <= 16
			)
				_if( $<v.u.unsval>2 >= $<v.u.unsval>4 )
				
					$<ru.MaxRecAlignment>$ = $<v.u.unsval>2; // Max alignment
					$<ru.MinRecAlignment>$ = $<v.u.unsval>4; // Min alignment
					
				_else
				
					yyerror
					(
						"In record alignment, the first (max) value must be "
						"greater or equal to the second (min) value"
					);
					
					// Note that the following swaps the minimum and
					// maximum values:
					
					$<ru.MinRecAlignment>$ = $<v.u.unsval>2; // Max alignment
					$<ru.MaxRecAlignment>$ = $<v.u.unsval>4; // Min alignment

				_endif

			_else

				yyerror( "Expected a constant in the range 0..16" );
				$<ru.MinRecAlignment>$ = MinRecAlignment;
				$<ru.MaxRecAlignment>$ = MaxRecAlignment;

			_endif
			_here;
		}
	;
	
	
		
 /*
 ** Handle the "guts" of a record declaration.
 ** This is anything that is legal in a variable declaration
 ** plus an unnamed UNION.
 **
 */


RecordStuff:

		/*
		** Normal declarations look just like variable declarations.
		*/

		RecVars


		/*
		** The following production lets us sneak anonymous
		** unions in between variable declarations.
		*/

	|	RecordStuff		/* $1 */
		doUnionTkn		/* $2 */
		{				/* $3 */
			char	anonUnion[ 256 ];
			
			/*
			** Undo some of the effects of doUnionTkn that
			** we don't need for anonymous unions:
			*/
			
			_here;
			SymbolTable = $<ru.endFields>2;
			
			/*
			** doUnionTkn has bumped the lex level,
			** we really didn't want that to happen for
			** anonymous unions.
			*/
			
			CurLexLevel = $<ru.SaveLex>2;
			
			/*
			** It also set the offset to zero, we didn't really
			** want that to happen, either.
			*/
			
			CurOffset = $<ru.SaveOffset>2;
			
			// Create a dummy entry to mark the fact that
			// we have an anonymous union here.

			sprintf( anonUnion, "Anon Union %d", LblCntr++ );
			InsertSym
			( 
				hlastrdup2( anonUnion ),		// Name
				NULL,						// TYPE
				tAnonUnion,					// pType
				cVar,	 					// class
				0,							// Arity
				NULL,						// Dimensions
				0, 							// NumElements
				NULL,						// Value
				0,							// ObjectSize
				CurOffset,					// Offset
				NULL,						// StaticName
				NULL,						// Base
				NULL,						// Fields
				0							// FieldCnt
			);
			$<ru.endFields>$ = SymbolTable;
			$<ru.RecFieldCnt>$ = LblCntr - 1;
			
			_here;
			
		}
		UnionStuff		/* $4 */
		endunionTkn		/* $5 */
		Semicolon		/* $6 */
		{
			int					SizeOfUnion;
			int					ofsDiff;
			struct	SymNode		*CurSym;
			char				endAnonUnion[ 256 ];

			_here;
			inUnion = $<ru.inSave>2;

			/*
			** Note that we must add the number of fields in the
			** anonymous union to the field count for the record
			** (note that the "+2" component is to cover the two
			** anonymous union fields we added):
			*/
			
			RecFieldCnt = RecFieldCnt + $<ru.RecFieldCnt>2 + 2;
			
			/*
			** Restore other values to their pre-record form:
			*/
			
			MinRecAlignment = $<ru.MinRecAlignment>2;
			MaxRecAlignment = $<ru.MaxRecAlignment>2;

			/*
			** If there were no fields present in the anonymous
			** union, complain about this.  By happenstance, the
			** size of the union will wind up being zero, so this
			** has no deterimental effect on the record being
			** created.
			*/

			_if( RecFieldCnt == 0 )

				ErrorNear
				( 
					"Unions must have at least one field",
					"endunion",
					__LINE__,
					__FILE__ 
				);

			_endif

			/*
			** Determine the size of the union (this is the size
			** of the largest object in the union).
			*/

			CurSym = SymbolTable;
			SizeOfUnion = 0;
			_while( CurSym != $<ru.endFields>3 )

				SizeOfUnion = 
					max( SizeOfUnion, CurSym->ObjectSize);

				CurSym = CurSym->Next;

			_endwhile
			$<ru.endFields>3->ObjectSize = SizeOfUnion;

			/*
			** Now that we know the size of the largest field
			** of the union, set the alignment based on the
			** size of that largest object.
			*/
			
			CurOffset = $<ru.SaveOffset>2;	// Restore original curOffset.
			_if( $<ru.TempRecAlign>2 != 1 )

				AlignTo
				( 
					&CurOffset, 
					$<ru.TempRecAlign>2, 
					$<ru.TempRecAlign>2, 
					SizeOfUnion 
				);
				
			_else
			 
			 	// If there was no align directive prior to the
				// union, then align the union on the basis of
				// the largest object in the union.
				
				AlignTo
				( 
					&CurOffset, 

					MinRecAlignment, 
					MaxRecAlignment, 
					SizeOfUnion 
				);
				
			_endif
			ofsDiff = CurOffset - $<ru.SaveOffset>2;
			
			/*
			** Okay, now step through the fields of the anonymous
			** union again and set their offset fields to the
			** CurOffset value we just aligned.  Note that we actually
			** add the difference between the saved offset and the
			** current offset to the field offsets since there may
			** be anonymous records buried within this anonymous union.
			*/
			
			CurSym = SymbolTable;
			_while( CurSym->Next != $<ru.endFields>3 )

				CurSym->Offset += ofsDiff;
				CurSym = CurSym->Next;

			_endwhile
			CurSym->Offset += ofsDiff;
						
			// Create a dummy entry to mark the end of the
			// anonymous union in the symbol table dump.

			sprintf( endAnonUnion, "End Union %d", $<ru.RecFieldCnt>3 );
			InsertSym
			( 
				hlastrdup2( endAnonUnion ),	// Name
				NULL,						// TYPE
				tAnonUnion,					// pType
				cVar,	 					// class
				0,							// Arity
				NULL,						// Dimensions
				0, 							// NumElements
				NULL,						// Value
				0,							// ObjectSize
				0,							// Offset
				NULL,						// StaticName
				NULL,						// Base
				NULL,						// Fields
				0							// FieldCnt
			);

			
			
			/*
			** Reset the compiler variables to their RECORD defaults.
			** Note this code does not restore these values
			** since we know that previously we were processing a
			** record.  That being the case, we can directly set them
			** here.  Note that we must add the size of the largest
			** object in the anonymous union to our offset at this
			** point so that the next record field skips past the
			** union data.
			*/

			CurOffsetDir = 1;
			AddOffset1st = 0;
			CurOffset = CurOffset + SizeOfUnion;
			
			/*
			** restore currentNS:
			*/
			
			currentNS = $<ru.saveCurNS>2;
			RecNS = $<ru.saveRecNS>2;
			RecGlobal = $<ru.saveRecGlobal>2;
			_here;
		}

		/*
		** Back to processing normal fields after the anonymous
		** union.
		*/

		RecVars

	;




 /*
 ** Handle the "guts" of a union declaration.
 ** This is anything that is legal in a variable declaration
 ** plus an unnamed RECORD.  Since anonymous records define fields
 ** inside a union, we do not set CurLexLevel to -2 (it remains
 ** -3 for union field entries).
 **
 */


UnionStuff:

		/*
		** Normal declarations look just like variable declarations.
		*/

		RecVars


		/*
		** The following production lets us sneak anonymous
		** records into union declarations.
		*/

	|	UnionStuff		/* $1 */
		dorecordTkn		/* $2 */
		recordOpts		/* $3 */
		{				/* $4 */
		
			char anonRec[ 256 ];
			
			_here;
			
			/*
			** Undo some of the effects of dorecordTkn that
			** we don't need for anonymous unions:
			*/
			
			SymbolTable = $<ru.endFields>2;
			
			
			
			/*
			** Note: doRecordTkn has incremented the lex level.
			**		 We can't have this in nested records.  Correct
			**		 for that here.
			*/
			
			--CurLexLevel;
			
			/*
			** Assigning an offset to the start of the record
			** (e.g., "record :=8;") is illogical inside a
			** union, so we'll report an error if the user
			** has done this.
			*/
			
			_if( $<ru.newOffset>2 )
			
				yyerror( "Cannot assign an offset to an anonymous record" );
				
			_endif
			
			// Since this is an anonymous record, pick up with the offset
			// of the whole union object:
			
			CurOffset = $<ru.SaveOffset>2;
			CurOffsetDir = 1;	// Records have incrementing offsets.
			
			// Create a dummy entry to hold the size of the
			// record so we can compute the maximum size later.

			sprintf( anonRec, "Anon Record %d", LblCntr++ );
			InsertSym
			( 
				hlastrdup2( anonRec ),			// Name
				NULL,						// TYPE
				tAnonRec, 					// pType
				cVar,	 					// class
				0,							// Arity
				NULL,						// Dimensions
				0, 							// NumElements
				NULL,						// Value
				0,							// ObjectSize
				0,							// Offset
				NULL,						// StaticName
				NULL,						// Base
				NULL,						// Fields
				0							// FieldCnt
			);
			$<ru.endFields>$ = SymbolTable;
			$<ru.RecFieldCnt>$ = LblCntr - 1;
			_here;

		}
		RecordStuff
		endrecordTkn	
		Semicolon
		{
			int					SizeOfRecord;
			int					StartOffset;
			struct	SymNode		*CurSym;
			char				endAnonRec[ 256 ];

			_here;
			_if( RecFieldCnt == 0 )
			
				yyerror( "Anonymous records must have at least one field" );
				
			_endif

			/*
			** Note that we must add the number of fields in the
			** anonymous record to the field count for the union:
			** Note that the "+2" component adjusts for the two
			** anonymous record fields we added.
			*/
			
			RecFieldCnt = RecFieldCnt + $<ru.RecFieldCnt>2 + 2;
			MinRecAlignment = $<ru.MinRecAlignment>2;
			MaxRecAlignment = $<ru.MaxRecAlignment>2;
			
			/*
			** Restore other values to their pre-record form:
			*/
			
			inRecord = $<ru.inSave>2;

			
			
			/*
			** Original comment (which is not true):
			** We know that CurOffset started at zero for this
			** record (since it's buried in a union), therefore,
			** the current value of CurOffset is also the record's
			** size.  Record that value in the anon rec field we
			** created earlier.
			**
			** ---------------------
			**
			** if the anon record appears inside an anon union inside
			** another record, then the starting offset isn't zero.
			** so compute the size based on the starting and ending offsets.
			*/

			SizeOfRecord = CurOffset - $<ru.SaveOffset>2;
			$<ru.endFields>4->ObjectSize = SizeOfRecord; 
			
			/*
			** If there was an align at the end of the
			** record, then we need to extend the size
			** of the record so that it is aligned on
			** the specified boundary.
			*/

			_if( TempRecAlign != 1 )
			

				SizeOfRecord = 
						(
								(SizeOfRecord + TempRecAlign - 1)
							/	TempRecAlign
						) * TempRecAlign; 
						
				TempRecAlign = 1;

			_endif
			

			/*
			** If there were no fields present in the anonymous
			** record, complain about this.  By happenstance, the
			** size of the union will wind up being zero, so this
			** has no deterimental effect on the union being
			** created.
			*/

			_if( RecFieldCnt == 0 )

				ErrorNear
				( 
					"Records must have at least one field",
					"endrecord",
					__LINE__,
					__FILE__ 
				);

			_endif



			// Create a dummy entry to mark the end of the
			// anonymous record in the symbol table dump.

			sprintf( endAnonRec, "End Record %d", $<ru.RecFieldCnt>4 );
			InsertSym
			( 
				hlastrdup2( endAnonRec ),	// Name
				NULL,						// TYPE
				tAnonRec, 					// pType
				cVar,	 					// class
				0,							// Arity
				NULL,						// Dimensions
				0, 							// NumElements
				NULL,						// Value
				0,							// ObjectSize
				0,							// Offset
				NULL,						// StaticName
				NULL,						// Base
				NULL,						// Fields
				0							// FieldCnt
			);




			/*
			** Reset the compiler variables to their UNION defaults.
			** Note this code does not save and restore these values
			** since we know that previously we were processing a
			** union.  That being the case, we can directly set them
			** here.  Note that we must add the size of the largest
			** object in the anonymous union to our offset at this
			** point so that the next record field skips past the
			** union data.
			*/

			CurOffsetDir = 0;
			AddOffset1st = 0;
			CurOffset = $<ru.SaveOffset>2;
			CurOffsetDir = 0;
			
			/*
			** Restore currentNS, etc:
			*/
			
			currentNS = $<ru.saveCurNS>2;
			RecNS = $<ru.saveRecNS>2;
			RecGlobal = $<ru.saveRecGlobal>2;
			_here;
		}

		/*
		** Back to processing normal fields after the anonymous
		** record.
		*/

		RecVars

	;




RecVars:
			/* Empty */ 
			
		|	RecVars 
			RecDef
			{
				_here;
				++RecFieldCnt;
			} 
		;

  
  
 /*
 ** RecID:
 ** These productions handle the OVERRIDE option in
 ** record/union declarations.
 */
 
RecID:
		UndefinedID
		{
			_here;
			$<idStr>$ = $<idStr>1;
		}
		
	|	overridesTkn AnyLocalID
		{
			_here;
			$<idStr>$ = hlastrdup2( $<s>2->TrueName );
		}
		
	|	overridesTkn UndefinedID
		{
			_here;
			$<idStr>$ = $<idStr>2;
			HLAWarning
			( 
				"Attempted to override an undefined identifier", 
				$<idStr>2, 
				__LINE__, 
				__FILE__ 
			);
		}
	;
			
			
				

	



/*
** RecDef-
**
**	These productions handle local variable declarations.
*/


RecDef:

			/*
			** Allow empty declarations (just a semicolon) for
			** syntactical reasons (e.g., to put semicolons after
			** macros and such).
			*/

			';'
			{
				_here;
			}
	;



 /*
 ** Handle the "ID:FORWARD(ID);" declaration to support
 ** macro redeclarations of a symbol.
 */

RecDef: 
		RecID			/* $1 */
		Colon			/* $2 */
		forwardTkn		/* $3 */
		Lparen			/* $4 */
		UndefinedID		/* $5 */
		Rparen			/* $6 */
		Semicolon		/* $7 */
		{				/* $8 */

			union YYSTYPE v;
			_here;
			
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<idStr>5 != NULL );

			v.v.u.strval = $<idStr>1;
			InsertSym
			( 
				$<idStr>5, 
				&text_ste,
				tText, 
				cConstant, 
				0,				/* arity 			*/
				NULL,			/* NumDimensions	*/
				0, 				/* NumElements		*/
				YYS &v,
				4,				/* ObjectSize		*/
				0,
				NULL,
				NULL,			/* Base				*/
				NULL,			/* Fields			*/
				0				/* FieldCnt			*/ 
			);

			fastLookup = 1;

			_here;
		}
	;


RecDef:
		alignTkn	/* $1 */
		Lparen		/* $2 */
		ConstExpr	/* $3 */
		Rparen		/* $4 */
		Semicolon	/* $5 */
		{			/* $6 */
			_here;
			_if( IsNumber( $<v.pType>3 ) && checkSmallUns( YYS &$<v>3) )

				TempRecAlign = $<v.u.unsval>3;

			_else

				yyerror
				( 
					"Expected an integer constant here" 
				);

			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;


/*
** Handle procedure pointer variables here.
*/

RecDef:
			RecID			/* $1 */ 
			Colon 			/* $2 */
			procedureTkn 	/* $3 */
			
			/*
			** Before going any farther, save the current
			** (previous lex level) variable offset and offset 
			** direction so we can restore these values when
			** the compiler finishes this declaration.  Note that the
			** compiler saves these values in the attributes of the
			** following grammar symbols.
			*/
			
			SaveOffset		/* $4 */ 
			SaveDirection	/* $5 */

			/*
			** Also, set up the offset and direction values as appropriate
			** for processing parameters.  Then process the optional
			** parameter list.
			*/

			{				/* $6 */
			
				struct SymNode *saveSym;
				
				_here;
				assert( $<idStr>1 != NULL );

				
				AlignTo
				( 
					(int *) &$<v.u.intval>4, 
					MinRecAlignment, 
					MaxRecAlignment, 
					4 
				);
				InsertSym
				( 
					$<idStr>1,
					NULL,			/* Type - Filled in later.		*/
					tProcptr, 		/* pType						*/
					cVar, 			/* SymClass						*/
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					NULL,			/* Initially, no initialization	*/
					4,				/* Object size					*/
					$<v.u.intval>4,	/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);
				$<s>$ = SymbolTable;

				CurOffset = StartParmOffs;
				++CurLexLevel;

				/*
				** Reinsert the symbol into the local symbols
				** to keep the logic of this program happy.
				*/

				saveSym = currentNS;	// Don't enter this symbol into
				currentNS = NULL;		//  a hash table.
				InsertSym
				( 
					$<idStr>1,
					NULL, 
					tProcptr, 
					cVar, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
				currentNS = saveSym;

				/*
				** Temporary assignment so we can patch the local
				** entry later.
				*/

				$<s>$->u.proc.parms = SymbolTable;
				_here;

			}
			OptionalParms	/* $7  */ 
			Semicolon		/* $8  */
			Options			/* $9  */
			 
			/*
			** Initialize the pointer to the end of the parameters
			** for this procedure variable.
			** Set up the offset and direction variables to handle
			** local variable declarations.  
			*/
			 
			{				/* $10 */
				struct	SymNode *saveST;
				struct	SymNode *s;

				_here;
				--CurLexLevel;				
				CurOffset = $<v.u.intval>4;
				CurOffsetDir = $<v.u.unsval>5;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_returns
					|	specified_use
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_alignment 
					|	specified_nostorage 
				);
				
				saveST = SymbolTable;
				s =
					InsertSym
					( 
						" (ProcPtrType) ",
						NULL,			/* Primitive Type.				*/
						tProcptr, 		/* pType						*/
						cVar, 			/* SymClass						*/
						0,				/* Arity						*/
						NULL,			/* Dimensions					*/
						0, 				/* NumElements					*/
						NULL,			/* Initially, no initialization	*/
						4,				/* Object size					*/
						0,				/* Offset						*/
						NULL,			/* Static Name					*/
						NULL,			/* Base							*/
						NULL,			/* Fields						*/
						0				/* FieldCnt						*/
					);
					
				s->u.proc.parms = saveST;
				s->u.proc.Locals = NULL;
				s->u.proc.returns = $<options.returns>9;
				s->u.proc.use = $<options.use>9;
				s->u.proc.cs = $<options.CallingSequence>9;
				
				// Remove the dummy type we just created from the record:
				
				SymbolTable = saveST;
				
				// Fill in the original procptr fields:
				
				$<s>6->u.proc.parms->Type = s;
				$<s>6->u.proc.parms->u.proc.parms = saveST;
				$<s>6->u.proc.parms->u.proc.returns = hlastrdup2( "" );
				$<s>6->u.proc.parms->u.proc.use = NULL;
				$<s>6->u.proc.parms->u.proc.Locals = NULL;

				$<s>6->Type = s;
				$<s>6->u.proc.parms = saveST;
				$<s>6->u.proc.Locals = NULL;
				$<s>6->u.proc.returns = $<options.returns>9;
				$<s>6->u.proc.use = $<options.use>9;
				$<s>6->u.proc.cs = $<options.CallingSequence>9;
				SymbolTable = $<s>6;
				
				_if( !$<options.NoStorage>9 )
				
					CurOffset += 4 * CurOffsetDir;
					
				_endif
				
				_here;

				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
			}
	;




/*
** Handle "pointer to procedure xxxx" pointer fields here.
*/

RecDef:
		RecID			/* $1 */ 
		Colon 			/* $2 */
		pointerTkn		/* $3 */
		toTkn			/* $4 */
		procedureTkn 	/* $5 */
		DefinedID		/* $6 */
		{				/* $7 */
			
			_here;
			assert( $<idStr>1 != NULL );
			
			AlignTo
			( 
				&CurOffset, 
				MinRecAlignment, 
				MaxRecAlignment, 
				4 
			);
			
			CreatePtrToProc( $<idStr>1, $<s>6, NULL, cVar );
			_here;
				
		}
		Semicolon		/* $8 */
		Options			/* $9 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_nostorage
			);
			_if( !$<options.NoStorage>9 )
			
				CurOffset += 4 * CurOffsetDir;
				
			_endif

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;
		}
	;




/*
** Handle pointer declarations here.
*/

RecDef:
			RecID				/* $1 */
			Colon				/* $2 */
			pointerTkn			/* $3 */
			toTkn				/* $4 */
			AnyID				/* $5 */
			{					/* $6 */

				struct	SymNode			*BaseType;

			
				assert( $<idStr>1 != NULL );
				assert( $<neID.idStr>5 != NULL );

				_here;
				BaseType = $<neID.s>5;
				_if( BaseType != NULL )

					BaseType = GetBaseType( BaseType );
					_if( CantBeVar( BaseType->pType ))

						yyerror( "Fields cannot be this type" );
						BaseType = &uns32_ste;

					_endif

				_endif

				AlignTo
				( 
					&CurOffset, 
					MinRecAlignment, 
					MaxRecAlignment, 
					4 
				);
				InsertSym
				( 
					$<idStr>1,			/* Name			*/
					&pointer_ste,		/* Type			*/
					tPointer, 			/* pType		*/
					cVar,				/* SymClass		*/
					0,					/* Arity		*/
					NULL,				/* Dimensions	*/
					0, 					/* NumElements	*/
					NULL,				/* Value		*/
					4,					/* ObjectSize	*/
					CurOffset,			/* Offset		*/
					NULL,				/* StaticName	*/
					BaseType,			/* BaseType		*/
					NULL,				/* Fields		*/
					0					/* FieldCnt		*/
				);
				_if( BaseType == NULL )

					Add2PtrList( SymbolTable, $<neID.idStr>5 );

				_endif
				_here;

			}
			Semicolon			/* $7 */
			Options				/* $8 */
			{
				/*
				** If processing records, unions, parameters, etc.
				*/

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_nostorage 
				);
				_if( !$<options.NoStorage>8 )
				
					CurOffset += 4 * CurOffsetDir;
					
				_endif

				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;

			}
	;




RecDef:
			RecID				/* $1 */
			Colon				/* $2 */
			pointerTkn			/* $3 */
			toTkn				/* $4 */
			ReservedTypeIDs		/* $5 */
			{					/* $6 */

				_here;
				assert( $<idStr>1 != NULL );
				AlignTo
				( 
					&CurOffset, 
					MinRecAlignment, 
					MaxRecAlignment, 
					4 
				);
				InsertSym
				( 
					$<idStr>1,			/* Name			*/
					&pointer_ste,		/* Type			*/
					tPointer, 			/* pType		*/
					cVar,				/* SymClass		*/
					0,					/* Arity		*/
					NULL,				/* Dimensions	*/
					0, 					/* NumElements	*/
					NULL,				/* Value		*/
					4,					/* ObjectSize	*/
					CurOffset,			/* Offset		*/
					NULL,				/* StaticName	*/
					$<s>5,				/* BaseType		*/
					NULL,				/* Fields		*/
					0					/* FieldCnt		*/
				);
				_here;

			}
			Semicolon			/* $7 */
			Options				/* $8 */
			{
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_nostorage 
				);
				_if( !$<options.NoStorage>8 )

					CurOffset += 4 * CurOffsetDir;

				_endif
				
				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
	;


 /*
 ** Field declarations using a single type ID:
 ** e.g., i:integer;
 **
 */


RecDef:
			RecID				/* $1 */ 
			Colon				/* $2 */ 
			TypeID				/* $3 */ 
			{					/* $4 */
			
				_here;
				assert( $<idStr>1 != NULL );
				assert( $<s>3 != NULL );
				
				_if( CantBeVar($<s>3->pType ))

					yyerror( "Variables cannot be this type" );

				_else
				
					AlignTo
					( 
						&CurOffset, 
						MinRecAlignment, 
						MaxRecAlignment, 
						min( $<s>3->ObjectSize, 16 ) 
					);
					InsertSym
					( 
						$<idStr>1, 
										/* 3/7/00
										GetBaseType( $<s>3 ),
										*/
						$<s>3,
						$<s>3->pType, 
						cVar, 
						$<s>3->Arity,
						$<s>3->Dimensions,
						$<s>3->NumElements, 
						NULL,
						$<s>3->ObjectSize,
						CurOffset,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);
					SymbolTable->MaxObjectSize = $<s>3->MaxObjectSize;

					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					_if( $<s>3->pType == tClass )

						SymbolTable->Fields = 
							CopySymbols
							( 
								$<s>3->Fields,
								$<s>3->StaticName
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_elseif(  $<s>3->pType == tThunk )

						/*
						** Need some dummy local vars for a thunk.
						*/

						SymbolTable->u.proc.parms = &true_ste;


					_endif

					/*
					** If the type is a pointer type, we need to check
					** to see if there was a forward reference so we
					** can eventually patch the "Base" field.
					*/

					_if( $<s>3->pType == tPointer && $<s>3->Base == NULL )

						struct PatchListType *pbl;

						pbl = malloc2( sizeof( struct PatchListType ));
						
						pbl->Next = PatchBaseList;
						pbl->Symbol = SymbolTable;
						PatchBaseList = pbl;

						SymbolTable->Type = $<s>3;	/* so we can patch later */

					_endif

				_endif
				_here;

			}
			Semicolon			/* $5 */
			Options				/* $6 */
			{
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>6,
						specified_nostorage 
				);
				_if( !$<options.NoStorage>6 )
					
					CurOffset += $<s>3->ObjectSize * CurOffsetDir;
					
				_endif
				
				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
	;



 /*
 ** Array variable definitions:
 ** e.g., b:integer[4];
 **
 */

					
RecDef:
			RecID				/* $1 */ 
			Colon				/* $2 */
			TypeID				/* $3 */ 
			'['					/* $4 */ 
			DimList				/* $5 */ 
			Rbrack				/* $6 */  
			{					/* $7 */
			
				int	*DimensionArray;

				_here;
				assert( $<idStr>1 != NULL );
				assert( $<s>3 != NULL );
				assert( $<v.NumElements>5 > 0 );
				assert( $<v.Dimensions>5 != NULL );

				/*
				** Make sure this is a legal variable type
				** (e.g., no text variables).
				*/

				_if( CantBeVar( $<s>3->pType ))
				
					yyerror( "Illegal variable type" );
					
				_else 
				
					/*
					** Check to see if TypeID is an array type
					** (i.e., we're creating a multi-dimensional array).
					*/

					_if( $<s>3->pType != tArray )

						/*
						** TypeID is *not* an array type, so create
						** a single dimension array here.
						*/

						$<i>$ = $<s>3->ObjectSize * $<v.NumElements>5;

						AlignTo
						( 
							&CurOffset, 
							MinRecAlignment, 
							MaxRecAlignment, 
							min( $<s>3->ObjectSize, 16 ) 
						);
						InsertSym
						( 
							$<idStr>1, 
											/* 3/7/00
											GetBaseType( $<s>3 ),
											*/
							$<s>3,
							tArray, 
							cVar, 
							$<v.Arity>5,
							$<v.Dimensions>5,
							$<v.NumElements>5, 
							NULL,
							$<i>$,
							CurOffset,
							NULL,
							$<s>3->Base,
							$<s>3->Fields,
							$<s>3->FieldCnt
						);
						
						/*
						** For arrays, the MaxObjectSize (used for alignment)
						** value must be the MaxObjectSize of an element.
						*/
						
						SymbolTable->MaxObjectSize = $<s>3->MaxObjectSize;
						

						/*
						** If this is a class object, we need to duplicate
						** all the fields to all private constants, etc.
						*/

						_if( $<s>3->pType == tClass )

							SymbolTable->Fields = 
								CopySymbols
								( 
									$<s>3->Fields,
									$<s>3->StaticName
								);
							NullTerminate( SymbolTable->Fields, SymbolTable );

						_elseif(  $<s>3->pType == tThunk )

							/*
							** Need some dummy local vars for a thunk.
							*/

							SymbolTable->u.proc.parms = &true_ste;


						_endif

						/*
						** If the type is a pointer type, we need to check
						** to see if there was a forward reference so we
						** can eventually patch the "Base" field.
						*/

						_if( $<s>3->pType == tPointer && $<s>3->Base == NULL )

							struct PatchListType *pbl;

							pbl = malloc2( sizeof( struct PatchListType ));
							
							pbl->Next = PatchBaseList;
							pbl->Symbol = SymbolTable;
							PatchBaseList = pbl;

							/*
							** So we can patch later:
							*/

							SymbolTable->Type = $<s>3;	

						_endif



					/*
					** Okay, down here TypeID *is* an array type,
					** so we're creating a multi-dimensional array.
					*/

					_else

						assert( $<s>3->Dimensions != NULL );

						/*
						** Create the new dimension array by concatenating
						** the two existing dimension arrays.
						*/

						DimensionArray = 
							malloc2
							( 
								( $<s>3->Arity + $<v.NumElements>5 ) * 
									sizeof( int )
							);


						memcpy
						( 
							DimensionArray, 
							$<s>3->Dimensions, 
							$<s>3->Arity * sizeof( int )
						);
						memcpy
						(
							&DimensionArray[ $<s>3->Arity ],
							$<v.Dimensions>5,
							$<v.Arity>5 * sizeof( int )
						);
						$<i>$ = $<s>3->ObjectSize * $<v.NumElements>5;

						AlignTo
						( 
							&CurOffset, 
							MinRecAlignment, 
							MaxRecAlignment, 
							min( $<s>3->ObjectSize, 16 ) 
						);
						InsertSym
						( 
							$<idStr>1, 
											/* 3/7/00
											GetBaseType( $<s>3 ),
											*/
							$<s>3,
							tArray, 
							cVar, 
							$<s>3->Arity + $<v.Arity>5,
							DimensionArray,
							$<s>3->NumElements * $<v.NumElements>5, 
							NULL,
							$<i>$,
							CurOffset,
							NULL,
							$<s>3->Base,
							$<s>3->Fields,
							$<s>3->FieldCnt
						);

						/*
						** If this is a class object, we need to duplicate
						** all the fields to all private constants, etc.
						*/

						_if( $<s>3->pType == tClass )

							SymbolTable->Fields = 
								CopySymbols
								( 
									$<s>3->Fields,
									$<s>3->StaticName
								);
							NullTerminate( SymbolTable->Fields, SymbolTable );

						_elseif(  $<s>3->pType == tThunk )

							/*
							** Need some dummy local vars for a thunk.
							*/

							SymbolTable->u.proc.parms = &true_ste;

						_endif


						free2( vss $<v.Dimensions>5 );

					_endif

				_endif
				_here;
			}
			Semicolon			/* $8 */
			Options				/* $9 */
			{
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_nostorage 
				);
				_if( !$<options.NoStorage>9 )
				
					CurOffset += $<i>7 * CurOffsetDir;
					
				_endif
				
				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
	;






 /*
 ** Handle nested record declarations here.
 **
 */


RecDef:
			RecID			/* $1  */
			Colon			/* $2  */
			dorecordTkn		/* $3  */
			recordOpts		/* $4  */
			OptInherits		/* $5  */
			RecordStuff		/* $6  */
			endrecordTkn	/* $7  */
			Semicolon		/* $8  */
			{				/* $9  */
			
				struct	SymNode	*Fields;
				struct	SymNode	*CurSym;
				int				RecSize;
				int				FieldCnt;
				int				LargestField;

				_here;
				
				/*
				** Restore currentNS before we enter this record
				** type into the symbol table.
				*/
				
				currentNS = $<ru.saveCurNS>3;
				RecNS = $<ru.saveRecNS>3;
				RecGlobal = $<ru.saveRecGlobal>3;

				/*
				** If RecFieldCnt is zero at this point then there
				** weren't any fields in the record.  Records must
				** have at least one field.
				*/

				_if( RecFieldCnt != 0 )

					/*
					** If there is no base record, we need to mark
					** the end of the fields symbol list.  If there is
					** a base record, then that base record definition will
					** mark the end of our list.  In either case, we
					** need to count the number of fields in the record.
					**
					** While we're traversing the fields, also compute
					** the size of the largest field (for alignment
					** purposes).
					*/
					
					FieldCnt = 0;
					LargestField = 0;
					CurSym = SymbolTable;
					_while
					( 
							CurSym->Next != NULL 
						&&	CurSym->Next != &dummyField_ste 
					)

						++FieldCnt;
						
						LargestField = 
							max( LargestField, CurSym->MaxObjectSize);
						
						CurSym = CurSym->Next;

					_endwhile
					LargestField = 
						max( LargestField, CurSym->MaxObjectSize);
				
					CurSym->Next = NULL;

					/*
					** Okay, create the record symbol table entry
					** and attach the fields symbol table to that entry.
					*/

					CurLexLevel = $<ru.SaveLex>3;	
					Fields = SymbolTable;			
					SymbolTable = $<ru.endFields>3;		
					RecSize = CurOffset - $<ru.CurOffset>3;
					
					/*
					** If there was an align at the end of the
					** record, then we need to extend the size
					** of the record so that it is aligned on
					** the specified boundary.
					*/

					_if( TempRecAlign != 1 )
					

						RecSize = 
								(

										(RecSize + TempRecAlign - 1) 
									/ 	TempRecAlign 
								) * TempRecAlign;
								
						TempRecAlign = 1;

					_endif
					
					
					
					CurOffset = $<ru.SaveOffset>3;		
					CurOffsetDir = $<ru.SaveDir>3;	
					AddOffset1st = $<ru.SaveAdd1st>3;	

					/*
					** Okay, insert the record symbol into the symbol table
					*/

					MinRecAlignment = $<ru.MinRecAlignment>3;
					MaxRecAlignment = $<ru.MaxRecAlignment>3;
					AlignTo
					( 
						&CurOffset, 
						MinRecAlignment, 
						MaxRecAlignment, 
						min( LargestField, 16 ) 
					);
					InsertSym
					(
						$<idStr>1,
						NULL,
						tRecord,
						cVar,
						0,
						NULL,
						0,
						NULL,
						RecSize,
						CurOffset,
						NULL,
						$<ru.base>3,
						Fields,
						FieldCnt
					);
					SymbolTable->MaxObjectSize = LargestField;
					CurOffset += RecSize * CurOffsetDir;

				_else

					yyerror
					( 
						"Record variables must have at least one field" 
					);

				_endif
				MinRecAlignment = $<ru.MinRecAlignment>3;
				MaxRecAlignment = $<ru.MaxRecAlignment>3;
				inRecord = $<ru.inSave>3;

				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
	;

				












 /*
 ** Handle union variable declarations here.
 **
 */


RecDef:
			RecID			/* $1 */
			Colon			/* $2 */
			doUnionTkn		/* $3 */
			UnionStuff		/* $4 */
			endunionTkn		/* $5 */
			Semicolon		/* $6 */
			{
				int					SizeOfUnion;
				int					FieldCnt;
				struct	SymNode		*Fields;
				struct	SymNode		*CurSym;
				struct	SymNode		*LastSym;

				_here;
				
				/*
				** Restore currentNS before we enter this union
				** type into the symbol table.
				*/
				
				currentNS = $<ru.saveCurNS>3;
				RecNS = $<ru.saveRecNS>3;
				RecGlobal = $<ru.saveRecGlobal>3;

				/*
				** Determine if there were any fields in the union.
				** Error if not.
				*/

				_if( RecFieldCnt == 0 )

					ErrorNear
					( 
						"Unions must have at least one field",
						"endunion",
						__LINE__,
						__FILE__ 
					);

				_else

					/*
					** Null terminate the list of fields in the union.
					** Search for the saved symbol table entry which
					** marks the first entry that is not a field.  Upon
					** finding that entry, store a NULL in the previous
					** link field.
					*/

					CurSym = SymbolTable;
					SizeOfUnion = 0;
					FieldCnt = 0;
					_while
					( 
							CurSym->Next != NULL 
						&&	CurSym->Next != &dummyField_ste 
					)					

						SizeOfUnion = 
							max( SizeOfUnion, CurSym->ObjectSize);
						
						_if( CurSym->pType != tAnonRec )
						
							++FieldCnt;
							
						_endif
						CurSym = CurSym->Next;

					_endwhile
					CurSym->Next = NULL;
					_if( CurSym->pType != tAnonRec )
					
						++FieldCnt;
					
					_endif
					SizeOfUnion = 
						max( SizeOfUnion, CurSym->ObjectSize);
				


					/*
					** Restore all the compiler variables and set
					** up Fields so we can enter the union variable
					** into the symbol table.
					*/

					CurLexLevel = $<ru.SaveLex>3;
					Fields = SymbolTable;
					SymbolTable = $<ru.endFields>3;
					CurOffset = $<ru.SaveOffset>3;
					CurOffsetDir = $<ru.SaveDir>3;
					AddOffset1st = $<ru.SaveAdd1st>3;

					/*
					** Okay, create the union symbol table entry
					** and attach the fields symbol table to that entry.
					*/

					AlignTo
					( 
						&CurOffset, 
						MinRecAlignment, 
						MaxRecAlignment, 
						min( SizeOfUnion, 16 ) 
					);
					InsertSym
					(
						$<idStr>1,
						NULL,
						tUnion,
						cVar,
						0,
						NULL,
						0,
						NULL,
						SizeOfUnion,
						CurOffset,
						NULL,
						NULL,
						Fields,
						FieldCnt
					);
					CurOffset += SizeOfUnion * CurOffsetDir;

				_endif

				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
	;

	
	
 /*
 ** Handle some common errors here.
 */			

RecDef:		
		AnyLocalID
		Colon
		unionTkn
		UnionStuff
		endunionTkn
		Semicolon
		{
			ErrorNear
			( 
				"Duplicate symbol definition", 
				$<s>1->TrueName,
				__LINE__,
				__FILE__ 
			);

		}
	;

RecDef:		
		AnyLocalID
		Colon
		recordTkn
		recordOpts
		RecordStuff
		endrecordTkn
		Semicolon
		{
			ErrorNear
			( 
				"Duplicate symbol definition", 
				$<s>1->TrueName,
				__LINE__,
				__FILE__ 
			);
			inRecord = $<ru.inSave>3;
			MinRecAlignment = $<ru.MinRecAlignment>3;
			MaxRecAlignment = $<ru.MaxRecAlignment>3;
			TempRecAlign = 1;

		}
	;

RecDef:		
		AnyLocalID 
		':' 
		error 
		';'
		{
			ErrorNear
			( 
				"Duplicate symbol definition", 
				$<s>1->TrueName,
				__LINE__,
				__FILE__ 
			);
		}
	;

RecDef:		
		AnyLocalID 
		Colon 
		enumTkn 
		Lbrace 
		EnumList 
		Rbrace 
		Semicolon
		{
			ErrorNear
			( 
				"Duplicate symbol definition", 
				$<s>1->TrueName,
				__LINE__,
				__FILE__ 
			);

		}
	;

RecDef:		
		RecID 
		Colon 
		UndefID 
		'[' 
		DimList 
		Rbrack  
		Semicolon
		{
			ErrorNear
			( 
				"Undefined symbol", 
				$<idStr>3,
				__LINE__,
				__FILE__ 
			);

		}
	;

RecDef:		
		RecID 
		Colon 
		UndefID 
		Semicolon
		{
			ErrorNear
			( 
				"Undefined symbol", 
				$<idStr>3,
				__LINE__,
				__FILE__ 
			);

		}
	;

RecDef:		
		error ';'
		{
			_here;
		}
	;









/*****************************************************/




 /*
 ** OptionalExternal-
 **
 **	Processes an "@external" token.
 ** Used by variable declarations, not procedure declarations!
 **
 **	Returns in the $<returns>$ attribute one of the following values:
 **
 **		NULL	if no external token.
 **		""-		if 'external;'
 **		"str"-	if 'external("str");'
 */

OptionalExternal:
		Empty
		{
			_here;
			$<returns>$ = NULL;
		}

	|	RequiredExternal
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;

RequiredExternal:
		externalTkn		/* $1 */
		OptionalStr		/* $2 */
		Semicolon		/* $3 */
		{
			_here;
			$<returns>$ = $<returns>2;
		}
	;


OptionalStr:
			Empty
			{
				_here;
				$<returns>$ = hlastrdup2( "" );
				_here;
			}


		|	'('			/* $1 */
			ConstExpr	/* $2 */
			Rparen		/* $3 */
			{			/* $4 */
				_here;
				_if
				( 
						$<v.pType>2 != tString 
					&&	$<v.pType>2 != tZString 
				)

					yyerror( "Expected a string constant" );
					$<returns>$ = hlastrdup2( "" );

				_else

					$<returns>$ = $<v.u.strval>2;

				_endif
				_here;
			}
		;







	/*
	** InsertProcSym- Inserts a procedure pointer name into the
	** symbol table.
	*/

InsertProcSym:
		{
			char StaticName[ 256 ];
			char *sn;
			struct	SymNode	*saveNS;

			_here;
			assert( $<idStr>-4 != NULL );

			sprintf( StaticName, "%s" sympost "%d", $<idStr>-4, LblCntr++ );
			sn = hlastrdup2( StaticName );
			InsertSym
			( 
				$<idStr>-4,
				&proctype_ste,
				tProcptr, 
				cStatic, 
				0,
				NULL,
				0, 
				NULL,
				4,
				0,
				sn,
				NULL,
				NULL,
				0
			);

			$<s>$ = SymbolTable;
			CurOffset = StartParmOffs;
			++CurLexLevel;

			/*
			** Reinsert the symbol into the local symbols
			** to keep the logic of this program happy.
			** If in a namespace, don't insert this symbol
			** into the hash table.
			*/

			saveNS = currentNS;
			currentNS = NULL;
			InsertSym
			( 
				$<idStr>-4,
				&proctype_ste,
				tProcptr, 
				cStatic, 
				0,
				NULL,
				0, 
				NULL,
				4,
				0,
				sn,
				NULL,
				NULL,
				0
			);
			currentNS = saveNS;

			/*
			** Temporary assignment so we can patch the local
			** entry later.
			*/

			$<s>$->u.proc.parms = SymbolTable;
			_here;

		}
	;



	/*
	** InsertEnum- Inserts the name for a static enumeration
	** variable into the symbol table.
	*/

InsertEnum:
			{
				char StaticName[ 256 ];
				char *sn;

				_here;
				assert( $<idStr>-2 != NULL );

				sprintf( StaticName, "%s" sympost "%d", $<idStr>-2, LblCntr++ );
				sn = hlastrdup2( StaticName );
				InsertSym
				( 
					$<idStr>-2, 
					NULL,
					tEnum, 
					cStatic, 
					0,
					NULL,
					0, 
					NULL,
					EnumSize,
					0,
					sn,
					NULL,
					NULL,
					0
				);

				/*
				** Initialize EnumVal to zero so we can assign
				** successive values to the following named constants.
				*/

				EnumVal = 0;

				/*
				** Return pointer to symbol table entry as result.
				*/

				$<s>$ = SymbolTable;
				_here;

			}
	;



	/*
	** SaveEnumSym- Saves the pointer to the start of the
	** enumeration symbols in the symbol table for the current
	** static enum variable.
	*/

SaveEnumSym:
			{
				/*
				** Set up an inherited attribute for EnumList.
				** This must be the address of the variable symbol
				** table entry created above.
				*/

				$<v.Type>$ = SymbolTable;
				_here;
			}
	;









/*****************************************************/


/*****************************************************************************/
/*****************************************************************************/
/**********************                           ****************************/
/**********************                           ****************************/
/**********************       R E G E X S         ****************************/
/**********************                           ****************************/
/**********************                           ****************************/
/*****************************************************************************/
/*****************************************************************************/


/****************************************************************/
/*                                                              */
/* regexs -> 	#regex regexID optionalRegexParms  				*/
/* 				optionalLocalIDs ';' text                       */
/* 			    #endregex                                       */
/*                                                              */
/* This production handles regex declarations.                  */
/* Since the lexer must handle the recording of the regex data, */
/* this production has to pull some tricks to tell the flex     */
/* portion of the code to record each line up to the endregex   */
/* reserved word.                                               */
/*                                                              */
/****************************************************************/


regexs:
		regexMacroTkn		/*1*/
		UndefinedID 		/*2*/
		SaveSymTbl			/*3*/
		optionalMacParms 	/*4*/
		SaveSymTbl			/*5*/
		optionalLocalIDs 	/*6*/
		SaveSymTbl			/*7*/
		MatchSemicolon		/*8*/
		RecordTheRegex		/*9*/
		endRegexDefTkn		/*10*/
		endregexTkn 		/*11*/
		{
			struct SymNode v;
			struct SymNode *s;

			_here;
			
			// Restore currentNS before entering the symbol
			// into the symbol table.
			
			currentNS = $<s>4;

			#define ptr(p,prev) _ifx((p)!=(prev),p,NULL)

			/*
			** Initialize the regex data for the macro
			** symbol table entry.
			*/

			v.u.MacroData.Text = $<m.Text>10;
			v.u.MacroData.Parameters = ptr($<s>5,$<s>3);
			v.u.MacroData.Locals = ptr($<s>7,$<s>5);
			v.u.MacroData.Terminator = NULL;
			v.u.MacroData.NameSpace = NULL;
			v.u.MacroData.LineCnt = $<v.u.unsval>8;
			v.u.MacroData.Filename = 	hlastrdup2( FileName );

			/*
			** If there are parameters or local symbols, null
			** terminate the list of such symbols so they don't
			** point into the main symbol table.
			*/

			_if( $<s>7 != $<s>3 )

				s = $<s>7;
				_while( s->Next != NULL && s->Next != $<s>3 )

					s = s->Next;

				_endwhile
				s->Next = NULL;

			_endif
			SymbolTable = $<s>3;

			/*
			** Insert the text for the regex into
			** the symbol table.
			*/
			assert( $<idStr>2 != NULL );
			InsertSym
			( 
				$<idStr>2, 
				NULL,			/* No type associated with this symbol.	*/
				tRegexMac,		/* It's a regex.						*/
				cRegex, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				YYS &v,			/* Ptr to macro's text.			*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);

			inRegex = 0;
			_here;
		}
	
	;





/*
** RecordTheRegex calls doRecRegex in the FLEX file
** that sets the appropriate scanner state so that
** the scanner starts recording regular expression's text.
*/

RecordTheRegex:
		{ 
			_here;
			doRecRegex();
		}
	;


/*
** recordReturn calls lexer code that grabs everything
** from just beyond the #return item to the #endregex
** token and saves this as a string to process later.
*/

recordReturn:
		{
			// Tell the lexer to grab the #return
			// string and return it as a string constant.
			
			PushBackStr( "\xE1" );	
		}
	;

// Compile a regular expression here:

compileRegex:
		saveInRegex			/* $1 */
		initializeRegexList	/* $2 */
		regexExpr			/* $3 */
		endregexTkn			/* $4 */
		{
			_here;
			$<v>$ = $<v>2;
			$<v.u.rx>$->concat = $<v.u.rx>3;
			$<v.u.rx>$->returns = hlastrdup( "" );
			inRegex = $<u>1;
		}
	;


// Compile a regular expression with a #returns clause here:

compileRegex:
		saveInRegex			/* $1 */
		initializeRegexList	/* $2 */
		regexExpr			/* $3 */
		regexReturnTkn		/* $4 */
		recordReturn		/* $5 */
		ConstOnlyExpr		/* $6 */
		endregexTkn			/* $7 */
		{
			_here;
			$<v>$ = $<v>2;
			$<v.u.rx>$->concat = $<v.u.rx>3;

			_if( $<v.pType>6 != tString && $<v.pType>6 != tText )
			
				yyerror( "Expected a string expression after #return" );
				$<v.u.rx>$->returns = hlastrdup( "" );
				
			_else

				$<v.u.rx>$->returns = $<v.u.strval>6;
				
			_endif
			inRegex = $<u>1;
		}
	;




// Allow empty regular expressions (which will match anything).

compileRegex:
		saveInRegex				/* $1 */
		initializeRegexList		/* $2 */
		endregexTkn				/* $3 */
		{
			// Mark the end of the regular expression list.
			
			_here;
			$<v>$ = $<v>2;
			$<v.u.rx>$->returns = hlastrdup( "" );
			inRegex = $<u>1;
		}
	;



compileRegex:
		saveInRegex				/* $1 */
		initializeRegexList		/* $2 */
		regexReturnTkn			/* $3 */
		recordReturn			/* $4 */
		ConstOnlyExpr			/* $5 */
		endregexTkn				/* $6 */
		{
			// Mark the end of the regular expression list.
			
			_here;
			$<v>$ = $<v>2;
			$<v.u.rx>$->returns = $<v.u.strval>5;
			inRegex = $<u>1;
		}
	;


saveInRegex:
		{
			$<u>$ = inRegex;
		}
	;
	

initializeRegexList:
		allocateRegexNode
		{			
			_here;
			$<v>$ = $<v>1;
			inRegex = 1;
		}
	;
	
allocateRegexNode:
		{
			struct regexListType *rxl;
			
			_here;
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			rxl = malloc2( sizeof( struct regexListType ) );
			rxl->returns		= NULL;
			rxl->concat			= NULL;
			rxl->subexpr		= NULL;
			rxl->alt[0]			= NULL;
			rxl->alt[1]			= NULL;
			rxl->nodeType		= nt_StartOfRegex;
			rxl->minCnt			= 1;	// Default is one
			rxl->maxCnt			= 1;	//  copy of this item.
			rxl->id				= NULL;
			ClrConst( YYS &rxl->v, tRegex, &regex_ste );
			$<v.u.rx>$ = rxl;
			_here;
		}
	;


// Handle the components that make up a
// regular expression here.
//
// Handle R|S here:

regexExpr:
		regexItems			/* $1 */
		optionalAlternation	/* $2 */
		{
			struct regexListType *rxl;
		
			_if( $<v.u.rx>2 != NULL )
			
				// $<v>2 is the alternation node.
				// We need to attach $1 to the alt[0] leg
				// of the alternation.
				
				$<v>$ = $<v>2;	// This is the "alternation" node.
				$<v.u.rx>$->alt[0] = $<v.u.rx>1;
				
				
			_else // No alternation
			
				$<v>$ = $<v>1;
			
			_endif
			_here;
		}
	;
	



	
	
// Handle the alternation syntax for two regular expressions.

optionalAlternation:
		'|'						/* $1 */
		allocateRegexNode		/* $2 */
		regexExpr				/* $3 */
		{
			// $2 is an extra node that holds the alternation value.
			
			$<v>$ = $<v>2;
			$<v.u.rx>$->nodeType = nt_Alternative;
			
			// The $3 regex is the alt[1] leg of the alternation:
			
			$<v.u.rx>$->alt[1] = $<v.u.rx>3;
			_here;
		}
	;
	


optionalAlternation:
		Empty					/* $1 */
		{						/* $2 */
			_here;
			$<v.u.rx>$ = NULL;
		}
	;
	

	
	

	
	
// Handle the concatenation syntax for two regular expressions.

regexItems:
		regexElement			/* $1 */
		optionalConcat			/* $2 */
		{
			_if( $<v.u.rx>2 != NULL )
			
				// Must concatenate the expression of
				// "optionalConcat" to the end of #1:
				
				$<v>$ = $<v>1;
				$<v.u.rx>$->concat = $<v.u.rx>2;
			
			_else // no concatenation
			
				$<v>$ = $<v>1;
				
			_endif
			_here;
		}
	;
		
		
optionalConcat:
		','						/* $1 */
		regexItems				/* $2 */
		{
			$<v>$ = $<v>2;
			_here;
		}

	|	Empty					/* $1 */
		{						/* $2 */
			_here;
			$<v.u.rx>$ = NULL;
		}
	;
	
	


// Handle parentheses in regular expressions.

regexElement:
		Lparen				/* $1 */
		allocateRegexNode	/* $2 */
		regexExpr			/* $3 */
		Rparen				/* $4 */
		optionalRanges		/* $5 */
		{
			// $2 holds the subexpression node.
			
			$<v>$ = $<v>2;
			$<v.u.rx>$->nodeType = nt_Subexpr;
			$<v.u.rx>$->subexpr = $<v.u.rx>3;
			$<v.u.rx>$->minCnt = $<ranges.minRange>5;	
			$<v.u.rx>$->maxCnt = $<ranges.maxRange>5;
			$<v.u.rx>$->lazy = $<ranges.lazy>5;
			_here;
		}
	;
	
	


// Handle @match in regular expressions.

regexElement:
		matchTkn			/* $1 */
		Lparen				/* $2 */
		allocateRegexNode	/* $3 */
		regexExpr			/* $4 */
		Rparen				/* $5 */
		optionalRanges		/* $6 */
		{
			// $2 holds the subexpression node.
			
			$<v>$ = $<v>3;
			$<v.u.rx>$->nodeType = nt_match;
			$<v.u.rx>$->subexpr = $<v.u.rx>4;
			$<v.u.rx>$->minCnt = $<ranges.minRange>6;	
			$<v.u.rx>$->maxCnt = $<ranges.maxRange>6;
			$<v.u.rx>$->lazy = $<ranges.lazy>6;
			_here;
		}
	;
	
	


// Handle @match2 in regular expressions.

regexElement:
		match2Tkn			/* $1 */
		Lparen				/* $2 */
		allocateRegexNode	/* $3 */
		regexExpr			/* $4 */
		Rparen				/* $5 */
		optionalRanges		/* $6 */
		{
			// $2 holds the subexpression node.
			
			$<v>$ = $<v>3;
			$<v.u.rx>$->nodeType = nt_match2;
			$<v.u.rx>$->subexpr = $<v.u.rx>4;
			$<v.u.rx>$->minCnt = $<ranges.minRange>6;	
			$<v.u.rx>$->maxCnt = $<ranges.maxRange>6;
			$<v.u.rx>$->lazy = $<ranges.lazy>6;
			_here;
		}
	;
	

// Handle string lists in regular expressions.

regexElement:
		'['					/* $1 */
		ArrayList 			/* $2 */
		Rbrack 				/* $3 */
		allocateRegexNode	/* $4 */
		{
			_if( $<v.pType>2 != tArray )
			
				yyerror( "Expected an array inside '[]'" );
			
			_elseif( $<v.Type>2 == NULL || $<v.Type>2->pType != tString )
			
				yyerror( "Expected a string array inside '[]'" );
				
			_else
			
				// $4 holds the subexpression node.
				
				$<v>$ = $<v>4;
				$<v.u.rx>$->nodeType = nt_List;
				$<v.u.rx>$->v = $<v>2;
				
			_endif
			_here;
		}
	;
	

// Handle the extraction operation.

regexElement:
		'<'					/* $1 */
		allocateRegexNode	/* $2 */
		regexExpr			/* $3 */
		'>'					/* $4 */
		':'					/* $5 */
		AnyID				/* $6 */
		{
			struct SymNode *s;
			
			s = $<neID.s>6;
			_if( s != NULL )
			
				_if( s->SymClass != cValue )
				
					yyerror( "Expected a VAL object for string extraction ID" );
					
					// Create the symbol anyway, to prevent cascading errors:
					
					ClrNewSym
					(
						$<neID.idStr>6,		// Name,
						&string_ste,   		// TheType
						tString,	   		// pType
						cValue,		   		// TheClass
						0,			   		// Arity
						NULL,		   		// Dimensions
						0,			   		// NumElements
						4,			   		// ObjectSize
						0,			   		// CurOffset
						NULL,		   		// StaticName
						NULL,		   		// Base
						NULL,		   		// Fields
						0,			   		// FieldCnt
						NULL,		   		// CurField
						0			   		// CurIndex
					);
					s = SymbolTable;
					
				_endif
				
			_else // If the symbol is undefined, create a new one
			
				ClrNewSym
				(
					$<neID.idStr>6,		// Name,
					&string_ste,   		// TheType
					tString,	   		// pType
					cValue,		   		// TheClass
					0,			   		// Arity
					NULL,		   		// Dimensions
					0,			   		// NumElements
					4,			   		// ObjectSize
					0,			   		// CurOffset
					NULL,		   		// StaticName
					NULL,		   		// Base
					NULL,		   		// Fields
					0,			   		// FieldCnt
					NULL,		   		// CurField
					0			   		// CurIndex
				);
				s = SymbolTable;
			
			_endif
			
			// $2 holds the first half of the extraction node.
			// $7 holds the second half of the extraction node.
			
			$<v>$ = $<v>2;
			$<v.u.rx>$->nodeType = nt_ExtractStr;
			$<v.u.rx>$->id = s;
			$<v.u.rx>$->subexpr = $<v.u.rx>3;
			_here;
		}
	;
	

// Handle the case where we have a '.' item.

regexElement:
		'.'						/* $1 */
		optionalRanges			/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_AnyChar;
			rxl->minCnt = $<ranges.minRange>2;	
			rxl->maxCnt = $<ranges.maxRange>2;
			rxl->lazy = $<ranges.lazy>2;
			
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	



	

intExpression:
		Lparen					/* $1 */
		ConstOnlyExpr			/* $2 */
		Rparen					/* $3 */
		{
			_here;
			_if( !IsSmallNumber( $<v.pType>2 ) || ($<v.u.intval>2 < 0)  )
			
				yyerror( "Function expects a small unsigned integer argument" );
				FreeValue( YYS &$<v>2 );
				$<v.pType>2 = tUns32;
				$<v.Type>2 = &uns32_ste;
				$<v.u.lwordval>2[0] = 1;
				$<v.u.lwordval>2[1] = 0;
				$<v.u.lwordval>2[2] = 0;
				$<v.u.lwordval>2[3] = 0;
				
			_endif
			$<v>$ = $<v>2;			
			_here;
				
		}
	;
	


// Handle the @pos function.

regexElement:
		posTkn					/* $1 */
		intExpression			/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_pos;
			rxl->minCnt = $<v.u.unsval>2;	
			rxl->maxCnt = 0;
			rxl->lazy = 0;
			
			// Create a dummy pattern value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = 0;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	


// Handle the @pos function.

regexElement:
		tabTkn					/* $1 */
		intExpression			/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_tab;
			rxl->minCnt = $<v.u.unsval>2;	
			rxl->maxCnt = 0;
			rxl->lazy = 0;
			
			// Create a dummy pattern value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = 0;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;



	

charExpression:
		Lparen					/* $1 */
		ConstOnlyExpr			/* $2 */
		Rparen					/* $3 */
		{
			_here;
			_if( $<v.pType>2 != tChar )
			
				yyerror( "@matchChar/@oneChar expects a char argument" );
				FreeValue( YYS &$<v>2 );
				$<v.pType>2 = tChar;
				$<v.Type>2 = &char_ste;
				$<v.u.charval>2 = ' ';
				
			_endif
			$<v>$ = $<v>2;			
			_here;
				
		}
	;

// Handle the @matchchar (@oneChar) function.

regexElement:
		onecharTkn				/* $1 */
		charExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_Char;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>2;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	




// Handle the negated @matchchar (@oneChar) function.

regexElement:
		'-'						/* $1 */
		onecharTkn				/* $2 */
		charExpression			/* $3 */
		optionalRanges			/* $4 */
		allocateRegexNode		/* $5 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>5;
			rxl->nodeType = nt_notChar;
			rxl->minCnt = $<ranges.minRange>4;	
			rxl->maxCnt = $<ranges.maxRange>4;
			rxl->lazy = $<ranges.lazy>4;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>3;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	




// Handle the @matchichar (@oneiChar) function.

regexElement:
		oneicharTkn				/* $1 */
		charExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_iChar;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>2;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	




// Handle the negated @matchichar (@oneiChar) function.

regexElement:
		'-'						/* $1 */
		oneicharTkn				/* $2 */
		charExpression			/* $3 */
		optionalRanges			/* $4 */
		allocateRegexNode		/* $5 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>5;
			rxl->nodeType = nt_notiChar;
			rxl->minCnt = $<ranges.minRange>4;	
			rxl->maxCnt = $<ranges.maxRange>4;
			rxl->lazy = $<ranges.lazy>4;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>3;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	



// Handle the case where we have a single character constant.

regexElement:
		charconst				/* $1 */
		optionalRanges			/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_Char;
			rxl->minCnt = $<ranges.minRange>2;	
			rxl->maxCnt = $<ranges.maxRange>2;
			rxl->lazy = $<ranges.lazy>2;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>1;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	



// Handle the case where we have a negated character constant.

regexElement:
		'-'						/* $1 */
		charconst				/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_notChar;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>2;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	






// Handle the case where we have a case-insensitive character constant.

regexElement:
		'!'						/* $1 */
		charconst				/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_iChar;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>2;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	






// Handle the case where we have a case-insensitive negated character constant.

regexElement:
		'!'						/* $1 */
		'-'						/* $2 */
		charconst				/* $3 */
		optionalRanges			/* $4 */
		allocateRegexNode		/* $5 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>5;
			rxl->nodeType = nt_notiChar;
			rxl->minCnt = $<ranges.minRange>4;	
			rxl->maxCnt = $<ranges.maxRange>4;
			rxl->lazy = $<ranges.lazy>4;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>3;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}

	|	'-'						/* $1 */
		'!'						/* $2 */
		charconst				/* $3 */
		optionalRanges			/* $4 */
		allocateRegexNode		/* $5 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>5;
			rxl->nodeType = nt_notiChar;
			rxl->minCnt = $<ranges.minRange>4;	
			rxl->maxCnt = $<ranges.maxRange>4;
			rxl->lazy = $<ranges.lazy>4;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>3;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	
	
	
	
	

// Handle the @peekchar function.

regexElement:
		peekcharTkn				/* $1 */
		charExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_peekChar;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>2;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}

	|	'/'						/* $1 */
		charconst				/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_peekChar;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>2;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	
	
	
	
	

// Handle the @peekichar function.

regexElement:
		peekicharTkn			/* $1 */
		charExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_peekiChar;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>2;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}

	|	'/'						/* $1 */
		'!'						/* $2 */
		charconst				/* $3 */
		optionalRanges			/* $4 */
		allocateRegexNode		/* $5 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>5;
			rxl->nodeType = nt_peekiChar;
			rxl->minCnt = $<ranges.minRange>4;	
			rxl->maxCnt = $<ranges.maxRange>4;
			rxl->lazy = $<ranges.lazy>4;
			
			// Save away the character value.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
			rxl->v.u.charval = $<v.u.charval>3;
				
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	




	

strExpression:
		Lparen					/* $1 */
		ConstOnlyExpr			/* $2 */
		Rparen					/* $3 */
		{
			_here;
			_if( $<v.pType>2 != tString )
			
				yyerror( "Function expects a string argument" );
				FreeValue( YYS &$<v>2 );
				$<v.pType>2 = tString;
				$<v.Type>2 = &string_ste;
				$<v.u.strval>2 = hlastrdup( "" );
				
			_endif
			$<v>$ = $<v>2;			
			_here;
				
		}
	;



// Handle @matchword( expr ) here:
	
regexElement:
		matchwordTkn			/* $1 */
		strExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_matchWord;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;



// Handle @matchiword( expr ) here:
	
regexElement:
		matchiwordTkn			/* $1 */
		strExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_matchiWord;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;




// Handle @matchstr( expr ) here:
	
regexElement:
		matchstrTkn				/* $1 */
		strExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_String;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;


// Handle @matchistr( expr ) here:
	
regexElement:
		matchistrTkn			/* $1 */
		strExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_iString;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;




// Handle a literal string constant here:
	
regexElement:
		StringConst				/* $1 */
		optionalRanges			/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_String;
			rxl->minCnt = $<ranges.minRange>2;	
			rxl->maxCnt = $<ranges.maxRange>2;
			rxl->lazy = $<ranges.lazy>2;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>1;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;



// Handle a case-insenstive string comparison here.
	
regexElement:
		'!'						/* $1 */
		StringConst				/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_iString;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;



// Handle a negated literal string constant here.
// Note that an optional range does not make sense
// for this regular expression.
	
regexElement:
		'-'						/* $1 */
		StringConst				/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_notString;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	

// Handle a case-insenstive negated string comparison here.
	
regexElement:
		'!'						/* $1 */
		'-'						/* $2 */
		StringConst				/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_notiString;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>3;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}

	|	'-'						/* $1 */
		'!'						/* $2 */
		StringConst				/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_notiString;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>3;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;






// Handle @peekstr( expr ) here:
	
regexElement:
		peekstrTkn				/* $1 */
		strExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_peekStr;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
		
	|	'/'						/* $1 */
		StringConst				/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_peekStr;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;






// Handle @peekistr( expr ) here:
	
regexElement:
		peekistrTkn				/* $1 */
		strExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_peekiStr;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>2;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}

	|	'/'						/* $1 */
		'!'						/* $2 */
		StringConst				/* $3 */
		optionalRanges			/* $4 */
		allocateRegexNode		/* $5 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>5;
			rxl->nodeType = nt_peekiStr;
			rxl->minCnt = $<ranges.minRange>4;	
			rxl->maxCnt = $<ranges.maxRange>4;
			rxl->lazy = $<ranges.lazy>4;
			
			ClrConst( YYS &rxl->v, tString, &string_ste );
			rxl->v.u.strval = $<v.u.strval>3;	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;



csetExpression:
		Lparen					/* $1 */
		ConstOnlyExpr			/* $2 */
		Rparen					/* $3 */
		{
			_here;
			_if( $<v.pType>2 != tCset )
			
				yyerror( "@matchCset/@oneCset expects a cset argument" );
				FreeValue( YYS &$<v>2 );
				$<v.pType>2 = tCset;
				$<v.Type>2 = &cset_ste;
				$<v.u.lwordval>2[0] = 0;
				$<v.u.lwordval>2[1] = 0;
				$<v.u.lwordval>2[2] = 0;
				$<v.u.lwordval>2[3] = 0;
				
			_endif
			$<v>$ = $<v>2;			
			_here;
				
		}
	;


// Handle @matchcset( expr ) (synonym:@onecset) here:
	
regexElement:
		onecsetTkn				/* $1 */
		csetExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_Cset;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tCset, &cset_ste );
			rxl->v.u.lwordval[0] = $<v.u.lwordval>2[0];	  
			rxl->v.u.lwordval[1] = $<v.u.lwordval>2[1];	  
			rxl->v.u.lwordval[2] = $<v.u.lwordval>2[2];	  
			rxl->v.u.lwordval[3] = $<v.u.lwordval>2[3];	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;



// Handle a literal character set constant here:
	
regexElement:
		CSetLiteralConst		/* $1 */
		optionalRanges			/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this as a cset object:
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_Cset;
			rxl->minCnt = $<ranges.minRange>2;	
			rxl->maxCnt = $<ranges.maxRange>2;
			rxl->lazy = $<ranges.lazy>2;
			
			ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
			memcpy( &rxl->v.u.csetval, $<v.u.csetval>1, CSetSizeInBytes );			
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	



// Handle a negated literal character set constant here:
	
regexElement:
		'-'						/* $1 */
		CSetLiteralConst		/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this as a cset object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_notCset;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
			memcpy( &rxl->v.u.csetval, $<v.u.csetval>2, CSetSizeInBytes );			
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
	
// Handle @peekcset( expr ) here:
	
regexElement:
		peekcsetTkn				/* $1 */
		csetExpression			/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this guy as a string object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_peekCset;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tCset, &cset_ste );
			rxl->v.u.lwordval[0] = $<v.u.lwordval>2[0];	  
			rxl->v.u.lwordval[1] = $<v.u.lwordval>2[1];	  
			rxl->v.u.lwordval[2] = $<v.u.lwordval>2[2];	  
			rxl->v.u.lwordval[3] = $<v.u.lwordval>2[3];	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}

	|	'/'						/* $1 */
		CSetLiteralConst		/* $2 */
		optionalRanges			/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;

			// Store this as a cset object:
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_peekCset;
			rxl->minCnt = $<ranges.minRange>3;	
			rxl->maxCnt = $<ranges.maxRange>3;
			rxl->lazy = $<ranges.lazy>3;
			
			ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
			memcpy( &rxl->v.u.csetval, $<v.u.csetval>2, CSetSizeInBytes );			
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;



	


// Handle a simple CONST or VAL identifier here
// First case: no returns string or repetition values.	

regexElement:
		SomeConstID				/* $1 */
		allocateRegexNode		/* $2 */
		{
			struct regexListType *rxl;
		
			_here;
			
			// It's a char constant
			
			_if( $<s>1->pType == tChar )

				struct regexListType *rxl;
			
				_here;
				
				rxl = $<v.u.rx>2;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				// Although this is a character constant,
				// we're going to store it as a singleton
				// character set object.
				
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				
				// Set the single bit corresponding to the 
				// ASCII code for this character:
				
				rxl->v.u.charval = $<s>1->u.charval;
					
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				_here;

			
			// If it's a string constant ID, store it as a string:
			
			_elseif( $<s>1->pType == tString )

				struct regexListType *rxl;
			
				_here;

				rxl = $<v.u.rx>2;
				rxl->nodeType = nt_String;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tString, &string_ste );
				rxl->v.u.strval = $<s>1->u.strval;	  
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				_here;


			// If the identifier is a cset constant, deal with that here:
			
			_elseif( $<s>1->pType == tCset )

				rxl = $<v.u.rx>2;
				rxl->nodeType = nt_Cset;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
				memcpy( &rxl->v.u.csetval, $<s>1->u.csetval, CSetSizeInBytes );			
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			// If the identifier is a regex constant, deal with that here:
			
			_elseif( $<s>1->pType == tRegex )

				rxl = $<v.u.rx>2;
				rxl->nodeType = nt_Regex2;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tRegex, &regex_ste );	  
				memcpy( &rxl->v, $<s>1, sizeof( struct SymNode ));
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			_else
			
				yyerror( "Unexpected constant ID type in regular expression" );
				
				// Create a dummy entry to prevent cascading problems:
				
				rxl = $<v.u.rx>2;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				rxl->v.u.charval = ' ';
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				
			_endif				
			_here;
		}
	;
	

	
// Handle the case with the kleene star:

regexElement:
		SomeConstID				/* $1 */
		'*'						/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;
			
			// It's a char constant
			
			_if( $<s>1->pType == tChar )

				struct regexListType *rxl;
			
				_here;
				
				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 0;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 0;
				
				// Although this is a character constant,
				// we're going to store it as a singleton
				// character set object.
				
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				
				// Set the single bit corresponding to the 
				// ASCII code for this character:
				
				rxl->v.u.charval = $<s>1->u.charval;
					
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				_here;

			
			// If it's a string constant ID, store it as a string:
			
			_elseif( $<s>1->pType == tString )

				struct regexListType *rxl;
			
				_here;

				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_String;
				rxl->minCnt = 0;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tString, &string_ste );
				rxl->v.u.strval = $<s>1->u.strval;	  
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				_here;


			// If the identifier is a cset constant, deal with that here:
			
			_elseif( $<s>1->pType == tCset )

				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Cset;
				rxl->minCnt = 0;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
				memcpy( &rxl->v.u.csetval, $<s>1->u.csetval, CSetSizeInBytes );			
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			// If the identifier is a regex constant, deal with that here:
			
			_elseif( $<s>1->pType == tRegex )

				yyerror( "Regular expression IDs do not allow a '*' operator" );
				
			
			_else
			
				yyerror( "Unexpected constant ID type in regular expression" );
				
				// Create a dummy entry to prevent cascading problems:
				
				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				rxl->v.u.charval = ' ';
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				
			_endif				
			_here;
		}
	;
	


// Handle the case with the kleene star:

regexElement:
		SomeConstID				/* $1 */
		'+'						/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;
			
			// It's a char constant
			
			_if( $<s>1->pType == tChar )

				struct regexListType *rxl;
			
				_here;
				
				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 0;
				
				// Although this is a character constant,
				// we're going to store it as a singleton
				// character set object.
				
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				
				// Set the single bit corresponding to the 
				// ASCII code for this character:
				
				rxl->v.u.charval = $<s>1->u.charval;
					
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				_here;

			
			// If it's a string constant ID, store it as a string:
			
			_elseif( $<s>1->pType == tString )

				struct regexListType *rxl;
			
				_here;

				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_String;
				rxl->minCnt = 1;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tString, &string_ste );
				rxl->v.u.strval = $<s>1->u.strval;	  
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				_here;


			// If the identifier is a cset constant, deal with that here:
			
			_elseif( $<s>1->pType == tCset )

				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Cset;
				rxl->minCnt = 1;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
				memcpy( &rxl->v.u.csetval, $<s>1->u.csetval, CSetSizeInBytes );			
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			// If the identifier is a regex constant, deal with that here:
			
			_elseif( $<s>1->pType == tRegex )

				yyerror( "Regular expression IDs do not allow a '+' operator" );
				
			
			_else
			
				yyerror( "Unexpected constant ID type in regular expression" );
				
				// Create a dummy entry to prevent cascading problems:
				
				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				rxl->v.u.charval = ' ';
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				
			_endif				
			_here;
		}
	;
	

// Handle the cases with a numeric range:

regexElement:
		SomeConstID				/* $1 */
		':'						/* $2 */
		'['						/* $3 */
		oneRange				/* $4 */
		optionalSecondRange		/* $5 */
		Rbrack					/* $6 */
		allocateRegexNode		/* $7 */
		{
			struct regexListType *rxl;
		
			_here;
			
			// It's a char constant
			
			_if( $<s>1->pType == tChar )

				struct regexListType *rxl;
			
				_here;
				
				rxl = $<v.u.rx>7;
				rxl->nodeType = nt_Char;
				rxl->minCnt = $<ranges.minRange>4;	
				rxl->maxCnt = $<ranges.maxRange>5;
				rxl->lazy = 0;
				
				// Although this is a character constant,
				// we're going to store it as a singleton
				// character set object.
				
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				
				// Set the single bit corresponding to the 
				// ASCII code for this character:
				
				rxl->v.u.charval = $<s>1->u.charval;
					
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				_here;

			
			// If it's a string constant ID, store it as a string:
			
			_elseif( $<s>1->pType == tString )

				struct regexListType *rxl;
			
				_here;

				rxl = $<v.u.rx>7;
				rxl->nodeType = nt_String;
				rxl->minCnt = $<ranges.minRange>4;	
				rxl->maxCnt = $<ranges.maxRange>5;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tString, &string_ste );
				rxl->v.u.strval = $<s>1->u.strval;	  
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				_here;


			// If the identifier is a cset constant, deal with that here:
			
			_elseif( $<s>1->pType == tCset )

				rxl = $<v.u.rx>7;
				rxl->nodeType = nt_Cset;
				rxl->minCnt = $<ranges.minRange>4;	
				rxl->maxCnt = $<ranges.maxRange>5;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
				memcpy( &rxl->v.u.csetval, $<s>1->u.csetval, CSetSizeInBytes );			
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			// If the identifier is a regex constant, deal with that here:
			
			_elseif( $<s>1->pType == tRegex )

				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Regex2;
				_if( $<ranges.minRange>2 != 1 || $<ranges.maxRange>2 != 1 )
				
					yyerror( "Regex items do not allow repetition values" );
					
				_endif
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tRegex, &regex_ste );	  
				memcpy( &rxl->v, $<s>1, sizeof( struct SymNode ));
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			_else
			
				yyerror( "Unexpected constant ID type in regular expression" );
				
				// Create a dummy entry to prevent cascading problems:
				
				rxl = $<v.u.rx>7;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				rxl->v.u.charval = ' ';
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				
			_endif				
			_here;
		}
	;



// Handle the cases with lazy evaluation:

regexElement:
		SomeConstID				/* $1 */
		coloncolonTkn			/* $2 */
		'['						/* $3 */
		oneRange				/* $4 */
		optionalSecondRange		/* $5 */
		Rbrack					/* $6 */
		allocateRegexNode		/* $7 */
		{
			struct regexListType *rxl;
		
			_here;
			
			// It's a char constant
			
			_if( $<s>1->pType == tChar )

				struct regexListType *rxl;
			
				_here;
				
				rxl = $<v.u.rx>7;
				rxl->nodeType = nt_Char;
				rxl->minCnt = $<ranges.minRange>4;	
				rxl->maxCnt = $<ranges.maxRange>5;
				rxl->lazy = 1;
				
				// Although this is a character constant,
				// we're going to store it as a singleton
				// character set object.
				
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				
				// Set the single bit corresponding to the 
				// ASCII code for this character:
				
				rxl->v.u.charval = $<s>1->u.charval;
					
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				_here;

			
			// If it's a string constant ID, store it as a string:
			
			_elseif( $<s>1->pType == tString )

				struct regexListType *rxl;
			
				_here;

				rxl = $<v.u.rx>7;
				rxl->nodeType = nt_String;
				rxl->minCnt = $<ranges.minRange>4;	
				rxl->maxCnt = $<ranges.maxRange>5;
				rxl->lazy = 1;
				
				ClrConst( YYS &rxl->v, tString, &string_ste );
				rxl->v.u.strval = $<s>1->u.strval;	  
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				_here;


			// If the identifier is a cset constant, deal with that here:
			
			_elseif( $<s>1->pType == tCset )

				rxl = $<v.u.rx>7;
				rxl->nodeType = nt_Cset;
				rxl->minCnt = $<ranges.minRange>4;	
				rxl->maxCnt = $<ranges.maxRange>5;
				rxl->lazy = 1;
				
				ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
				memcpy( &rxl->v.u.csetval, $<s>1->u.csetval, CSetSizeInBytes );			
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			// If the identifier is a regex constant, deal with that here:
			
			_elseif( $<s>1->pType == tRegex )

				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Regex2;
				_if( $<ranges.minRange>2 != 1 || $<ranges.maxRange>2 != 1 )
				
					yyerror( "Regex items do not allow repetition values" );
					
				_endif
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tRegex, &regex_ste );	  
				memcpy( &rxl->v, $<s>1, sizeof( struct SymNode ));
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			_else
			
				yyerror( "Unexpected constant ID type in regular expression" );
				
				// Create a dummy entry to prevent cascading problems:
				
				rxl = $<v.u.rx>7;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				rxl->v.u.charval = ' ';
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				
			_endif				
			_here;
		}
		
		
	|	SomeConstID				/* $1 */
		coloncolonTkn			/* $2 */
		'*'						/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			// It's a char constant
			
			_if( $<s>1->pType == tChar )

				struct regexListType *rxl;
			
				_here;
				
				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 0;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 1;
				
				// Although this is a character constant,
				// we're going to store it as a singleton
				// character set object.
				
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				
				// Set the single bit corresponding to the 
				// ASCII code for this character:
				
				rxl->v.u.charval = $<s>1->u.charval;
					
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				_here;

			
			// If it's a string constant ID, store it as a string:
			
			_elseif( $<s>1->pType == tString )

				struct regexListType *rxl;
			
				_here;

				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_String;
				rxl->minCnt = 0;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 1;
				
				ClrConst( YYS &rxl->v, tString, &string_ste );
				rxl->v.u.strval = $<s>1->u.strval;	  
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				_here;


			// If the identifier is a cset constant, deal with that here:
			
			_elseif( $<s>1->pType == tCset )

				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Cset;
				rxl->minCnt = 0;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 1;
				
				ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
				memcpy( &rxl->v.u.csetval, $<s>1->u.csetval, CSetSizeInBytes );			
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			// If the identifier is a regex constant, deal with that here:
			
			_elseif( $<s>1->pType == tRegex )

				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Regex2;
				_if( $<ranges.minRange>2 != 1 || $<ranges.maxRange>2 != 1 )
				
					yyerror( "Regex items do not allow repetition values" );
					
				_endif
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tRegex, &regex_ste );	  
				memcpy( &rxl->v, $<s>1, sizeof( struct SymNode ));
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			_else
			
				yyerror( "Unexpected constant ID type in regular expression" );
				
				// Create a dummy entry to prevent cascading problems:
				
				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				rxl->v.u.charval = ' ';
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				
			_endif				
			_here;
		}
		
		
	|	SomeConstID				/* $1 */
		coloncolonTkn			/* $2 */
		'+'						/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			// It's a char constant
			
			_if( $<s>1->pType == tChar )

				struct regexListType *rxl;
			
				_here;
				
				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 1;
				
				// Although this is a character constant,
				// we're going to store it as a singleton
				// character set object.
				
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				
				// Set the single bit corresponding to the 
				// ASCII code for this character:
				
				rxl->v.u.charval = $<s>1->u.charval;
					
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				_here;

			
			// If it's a string constant ID, store it as a string:
			
			_elseif( $<s>1->pType == tString )

				struct regexListType *rxl;
			
				_here;

				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_String;
				rxl->minCnt = 1;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 1;
				
				ClrConst( YYS &rxl->v, tString, &string_ste );
				rxl->v.u.strval = $<s>1->u.strval;	  
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				_here;


			// If the identifier is a cset constant, deal with that here:
			
			_elseif( $<s>1->pType == tCset )

				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Cset;
				rxl->minCnt = 1;	
				rxl->maxCnt = 0x7fffffff;
				rxl->lazy = 1;
				
				ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
				memcpy( &rxl->v.u.csetval, $<s>1->u.csetval, CSetSizeInBytes );			
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			// If the identifier is a regex constant, deal with that here:
			
			_elseif( $<s>1->pType == tRegex )

				rxl = $<v.u.rx>3;
				rxl->nodeType = nt_Regex2;
				_if( $<ranges.minRange>2 != 1 || $<ranges.maxRange>2 != 1 )
				
					yyerror( "Regex items do not allow repetition values" );
					
				_endif
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tRegex, &regex_ste );	  
				memcpy( &rxl->v, $<s>1, sizeof( struct SymNode ));
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			_else
			
				yyerror( "Unexpected constant ID type in regular expression" );
				
				// Create a dummy entry to prevent cascading problems:
				
				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				rxl->v.u.charval = ' ';
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				
			_endif				
			_here;
		}
	;
	



// Special Case for Regular Expression Constants:

regexElement:
		SomeConstID				/* $1 */
		':'						/* $2 */
		AnyID					/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct regexListType *rxl;
		
			_here;
			
			// It's a char constant
			
			_if( $<s>1->pType == tChar )

				struct regexListType *rxl;
			
				_here;
				
				yyerror( "Illegal syntax for a char constant ID in a regex" );
				
				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 0;	
				rxl->maxCnt = 0;
				rxl->lazy = 1;
				
				// Although this is a character constant,
				// we're going to store it as a singleton
				// character set object.
				
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				
				// Set the single bit corresponding to the 
				// ASCII code for this character:
				
				rxl->v.u.charval = $<s>1->u.charval;
					
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				_here;

			
			// If it's a string constant ID, store it as a string:
			
			_elseif( $<s>1->pType == tString )

				struct regexListType *rxl;
			
				_here;

				yyerror( "Illegal syntax for a string constant ID in a regex" );

				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_String;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tString, &string_ste );
				rxl->v.u.strval = $<s>1->u.strval;	  
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				_here;


			// If the identifier is a cset constant, deal with that here:
			
			_elseif( $<s>1->pType == tCset )

				yyerror( "Illegal syntax for a cset constant ID in a regex" );

				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Cset;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				
				ClrConst( YYS &rxl->v, tCset, &cset_ste );	  
				memcpy( &rxl->v.u.csetval, $<s>1->u.csetval, CSetSizeInBytes );			
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			// If the identifier is a regex constant, deal with that here:
			
			_elseif( $<s>1->pType == tRegex )

				struct SymNode		 *s;
				
				s = $<neID.s>3;
				_if( s != NULL )
				
					_if( s->SymClass != cValue )
					
						yyerror( "Expected a VAL object for string extraction ID" );
						
						// Create the symbol anyway, to prevent cascading errors:
						
						ClrNewSym
						(
							$<neID.idStr>3,// Name,
							_ifx(s->pType == tText,&text_ste,&string_ste),// TheType
							_ifx(s->pType == tText,tText,tString),	// pType
							cValue,		   // TheClass
							0,			   // Arity
							NULL,		   // Dimensions
							0,			   // NumElements
							4,			   // ObjectSize
							0,			   // CurOffset
							NULL,		   // StaticName
							NULL,		   // Base
							NULL,		   // Fields
							0,			   // FieldCnt
							NULL,		   // CurField
							0			   // CurIndex
						);
						s = SymbolTable;
						
					_endif
					
				_else // If the symbol is undefined, create a new one
				
					ClrNewSym
					(
						$<neID.idStr>3,	// Name,
						&string_ste,   	// TheType
						tString,	   	// pType
						cValue,		   	// TheClass
						0,			   	// Arity
						NULL,		   	// Dimensions
						0,			   	// NumElements
						4,			   	// ObjectSize
						0,			   	// CurOffset
						NULL,		   	// StaticName
						NULL,		   	// Base
						NULL,		   	// Fields
						0,			   	// FieldCnt
						NULL,		   	// CurField
						0			   	// CurIndex
					);
					s = SymbolTable;
				
				_endif

				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Regex2;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				rxl->id = s;
				
				ClrConst( YYS &rxl->v, tRegex, &regex_ste );	  
				memcpy( &rxl->v, $<s>1, sizeof( struct SymNode ));
								
				// Return the new node we've created as this
				// production's attribute:
				
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;
				
			
			_else
			
				yyerror( "Unexpected constant ID type in regular expression" );
				
				// Create a dummy entry to prevent cascading problems:
				
				rxl = $<v.u.rx>4;
				rxl->nodeType = nt_Char;
				rxl->minCnt = 1;	
				rxl->maxCnt = 1;
				rxl->lazy = 0;
				ClrConst( YYS &rxl->v, tChar, &char_ste );	  
				rxl->v.u.charval = ' ';
				ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
				$<v.u.rx>$ = rxl;				
				
			_endif				
			_here;
		}
	;
	

// Handle the @EOS token here:
	
regexElement:
		eosTkn					/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_EOS;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
	

// Handle the @reg token here:

regexElement:
		matchregTkn				/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_reg;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
	

// Handle the @matchID token here:

regexElement:
		matchidTkn				/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_matchid;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
// Handle the @matchIntConst token here:

regexElement:
		matchintconstTkn		/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_matchInt;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
// Handle the @matchRealConst token here:

regexElement:
		matchrealconstTkn		/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_matchReal;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
// Handle the @matchstrConst token here:

regexElement:
		matchstrconstTkn		/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_matchStr;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
// Handle the @reg8 token here:

regexElement:
		matchreg8Tkn			/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_reg8;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
// Handle the @reg16 token here:

regexElement:
		matchreg16Tkn			/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_reg16;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
// Handle the @reg32 token here:

regexElement:
		matchreg32Tkn			/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_reg32;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;

	
// Handle the @regfpu token here:

regexElement:
		matchfpuregTkn			/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_regfpu;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;

	
// Handle the @regmmx token here:

regexElement:
		matchmmxregTkn			/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_regmmx;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;

	
// Handle the @regxmm token here:

regexElement:
		matchxmmregTkn			/* $1 */
		allocateRegexNode		/* $2 */
		{		
			struct regexListType *rxl;

			_here;

			// Store this as an EOS object:
			
			rxl = $<v.u.rx>2;
			rxl->nodeType = nt_regxmm;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	
	
	
	

// Handle the @WS token here:
	
regexElement:
		wsTkn					/* $1 */
		optionalRanges			/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_ws;
			rxl->minCnt = $<ranges.minRange>2;	
			rxl->maxCnt = $<ranges.maxRange>2;
			rxl->lazy = $<ranges.lazy>2;
			
			// Although this is a character constant,
			// we're going to store it as a singleton
			// character set object.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	
	
	
	

// Handle the @ARB token here:
	
regexElement:
		arbTkn					/* $1 */
		optionalRanges			/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct regexListType *rxl;
		
			_here;
			
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_AnyChar;
			rxl->minCnt = $<ranges.minRange>2;	
			rxl->maxCnt = $<ranges.maxRange>2;
			rxl->lazy = 1;
			
			// Although this is a character constant,
			// we're going to store it as a singleton
			// character set object.
			
			ClrConst( YYS &rxl->v, tChar, &char_ste );	  
							
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;
			_here;
		}
	;
	






// Handle a regular expression macro expansion here (save the
// name and parameter list for expansion later on).
	
processOptionalParms:
		{
			_here;
			_if( $<s>0->u.MacroData.Parameters != NULL )
			
				processMacroID( $<s>0 );
				
			_endif
		}
	;
			
			
regexElement:
		RegexID					/* $1 */
		processOptionalParms	/* $2 */
		allocateRegexNode		/* $3 */
		{
			struct SymNode		 *s;
			struct SymNode		 *t;
			struct SymNode		 **lastT;
			struct regexListType *rxl;
			
			_here;
			rxl = $<v.u.rx>3;
			rxl->nodeType = nt_Regex;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			
			// Does this need to be a deep copy of some sort?
			
			memcpy( &rxl->v,  $<s>1, sizeof( struct SymNode ));
			s = $<s>1->u.MacroData.Parameters;
			lastT = &rxl->v.u.MacroData.Parameters;
			_while( s != NULL )
			
				t = malloc2( sizeof( struct SymNode ));
				*lastT = t;
				lastT = &t->Next;
				DeepCopy( t, s );
				s = s->Next;
				
			_endwhile;
						

			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;

		}
	;


// Handle the case where we have "regexID:valStrID"
// that will save away the "returns" value when this
// RE is interpreted.

regexElement:
		RegexID					/* $1 */
		processOptionalParms	/* $2 */
		':'						/* $3 */
		AnyID					/* $4 */
		allocateRegexNode		/* $5 */
		{
			struct SymNode		 *sym;
			struct SymNode		 *t;
			struct SymNode		 **lastT;
			struct regexListType *rxl;
			struct SymNode		 *s;
			
			s = $<neID.s>4;
			_if( s != NULL )
			
				_if( s->SymClass != cValue )
				
					yyerror( "Expected a VAL object for string extraction ID" );
					
					// Create the symbol anyway, to prevent cascading errors:
					
					ClrNewSym
					(
						$<neID.idStr>4,	// Name,
						_ifx(s->pType == tText,&text_ste,&string_ste),// TheType
						_ifx(s->pType == tText,tText,tString),	// pType
						cValue,		   	// TheClass
						0,			   	// Arity
						NULL,		   	// Dimensions
						0,			   	// NumElements
						4,			   	// ObjectSize
						0,			   	// CurOffset
						NULL,		   	// StaticName
						NULL,		   	// Base
						NULL,		   	// Fields
						0,			   	// FieldCnt
						NULL,		   	// CurField
						0			   	// CurIndex
					);
					s = SymbolTable;
					
				_endif
				
			_else // If the symbol is undefined, create a new one
			
				ClrNewSym
				(
					$<neID.idStr>4,	// Name,
					&string_ste,   	// TheType
					tString,	   	// pType
					cValue,		   	// TheClass
					0,			   	// Arity
					NULL,		   	// Dimensions
					0,			   	// NumElements
					4,			   	// ObjectSize
					0,			   	// CurOffset
					NULL,		   	// StaticName
					NULL,		   	// Base
					NULL,		   	// Fields
					0,			   	// FieldCnt
					NULL,		   	// CurField
					0			   	// CurIndex
				);
				s = SymbolTable;
			
			_endif
			
			rxl = $<v.u.rx>5;
			rxl->nodeType = nt_Regex;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			rxl->id = s;
			
			// Does this need to be a deep copy of some sort?
			
			memcpy( &rxl->v,  $<s>1, sizeof( struct SymNode ));
			s = $<s>1->u.MacroData.Parameters;
			lastT = &rxl->v.u.MacroData.Parameters;
			_while( s != NULL )
			
				t = malloc2( sizeof( struct SymNode ));
				*lastT = t;
				lastT = &t->Next;
				DeepCopy( t, s );
				s = s->Next;
				
			_endwhile;
						

			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;
	


// Handle the @at:id token here

regexElement:
		atTkn					/* $1 */
		':'						/* $2 */
		AnyID					/* $3 */
		allocateRegexNode		/* $4 */
		{
			struct SymNode		 *sym;
			struct SymNode		 *t;
			struct regexListType *rxl;
			struct SymNode		 *s;
			
			s = $<neID.s>3;
			_if( s != NULL )
			
				_if( s->SymClass != cValue )
				
					yyerror( "Expected a VAL object for '@at:' identifier" );
					
					// Create the symbol anyway, to prevent cascading errors:
					
					ClrNewSym
					(
						$<neID.idStr>3,		// Name,
						&uns32_ste,			// TheType
						tUns32,				// pType
						cValue,				// TheClass
						0,	   				// Arity
						NULL,  				// Dimensions
						0,	   				// NumElements
						4,	   				// ObjectSize
						0,	   				// CurOffset
						NULL,  				// StaticName
						NULL,  				// Base
						NULL,  				// Fields
						0,	   				// FieldCnt
						NULL,  				// CurField
						0	   				// CurIndex
					);
					s = SymbolTable;
					
				_endif
				
			_else // If the symbol is undefined, create a new one
			
				ClrNewSym
				(
					$<neID.idStr>3, 	// Name,
					&uns32_ste,			// TheType
					tUns32,	   			// pType
					cValue,	   			// TheClass
					0,		   			// Arity
					NULL,	   			// Dimensions
					0,		   			// NumElements
					4,		   			// ObjectSize
					0,		   			// CurOffset
					NULL,	   			// StaticName
					NULL,	   			// Base
					NULL,	   			// Fields
					0,		   			// FieldCnt
					NULL,	   			// CurField
					0		   			// CurIndex
				);
				s = SymbolTable;
			
			_endif
			
			rxl = $<v.u.rx>4;
			rxl->nodeType = nt_at;
			rxl->minCnt = 1;	
			rxl->maxCnt = 1;
			rxl->id = s;
			
			// Return the new node we've created as this
			// production's attribute:
			
			ClrConst( YYS &$<v>$, tRegex, &regex_ste );			
			$<v.u.rx>$ = rxl;				
			_here;
		}
	;






	
SomeConstID:
		LocalConstID
		{
			$<s>$ = $<s>1;
		}
		
	|	NonLocalConstID
		{
			$<s>$ = $<s>1;
		}
	;	


// optionalRanges-
// Handles the optional ":[minrange,maxrange]" expression that
// may follow a regular expression.

optionalRanges:
		Empty
		{
			_here;
			$<ranges.minRange>$ = 1;
			$<ranges.maxRange>$ = 1;
			$<ranges.lazy>$ = 0;
		}
	
	|	':'					/* $1 */
		'['					/* $2 */
		oneRange			/* $3 */
		optionalSecondRange	/* $4 */
		Rbrack				/* $5 */
		{
			_here;
			$<ranges.minRange>$ = $<ranges.minRange>3;
			$<ranges.maxRange>$ = $<ranges.maxRange>4;
			$<ranges.lazy>$ = 0;
		}
		
	|	coloncolonTkn		/* $1 */
		'['					/* $2 */
		oneRange			/* $3 */
		optionalSecondRange	/* $4 */
		Rbrack				/* $5 */
		{
			_here;
			$<ranges.minRange>$ = $<ranges.minRange>3;
			$<ranges.maxRange>$ = $<ranges.maxRange>4;
			$<ranges.lazy>$ = 1;
		}
		
	|	'*'					/* $1 */
		{
			_here;
			$<ranges.minRange>$ = 0;
			$<ranges.maxRange>$ = 0x7fffffff;
			$<ranges.lazy>$ = 0;
		}
	
	|	'+'					/* $1 */
		{
			_here;
			$<ranges.minRange>$ = 1;
			$<ranges.maxRange>$ = 0x7fffffff;
			$<ranges.lazy>$ = 0;
		}
	
	;

		
oneRange:
		ConstExpr			/* $1 */
		{
			_here;
			_if( !IsSmallNumber( $<v.pType>1 ) )
			
				yyerror
				( 
					"Expected a constant integer expression	after ':'"
				);
				$<ranges.minRange>$ = 1;
				$<ranges.maxRange>$ = 1;
				FreeValue( YYS &$<v>1 );
				$<ranges.minRange>$ = 1;
				$<ranges.maxRange>$ = 1;
				
			_else

				$<ranges.minRange>$ = $<v.u.unsval>1;
				$<ranges.maxRange>$ = $<v.u.unsval>1;

			_endif
		}
	;
	
optionalSecondRange:
		Empty
		{
			_here;
			$<ranges.minRange>$ = $<v.u.unsval>0;
			$<ranges.maxRange>$ = $<v.u.unsval>0;
		}
	;
	
optionalSecondRange:
		','					/* $1 */
		oneRange			/* $2 */
		{
			_here;
			$<ranges.minRange>$ = $<v.u.unsval>2;
			$<ranges.maxRange>$ = $<v.u.unsval>2;
		}
	;
	
	
optionalSecondRange:
		','					/* $1 */
		'*'					/* $2 */
		{
			_here;
			$<ranges.minRange>$ = 0x7fffffff;
			$<ranges.maxRange>$ = 0x7fffffff;
		}
	;
	
	
			
	


	

/*****************************************************************************/
/*****************************************************************************/
/**********************                           ****************************/
/**********************                           ****************************/
/**********************       M A C R O S         ****************************/
/**********************                           ****************************/
/**********************                           ****************************/
/*****************************************************************************/
/*****************************************************************************/


/****************************************************************/
/*                                                              */
/* macros -> 	#macro macroID optionalMacParms  				*/
/* 				optionalLocalIDs ';' text                       */
/* 			    #endmacro                                       */
/*                                                              */
/* This production handles macro declarations.                  */
/* Since the lexer must handle the recording of the macro data, */
/* this production has to pull some tricks to tell the flex     */
/* portion of the code to record each line up to end endmacro   */
/* reserved word.                                               */
/*                                                              */
/****************************************************************/


macros:
		doMacroTkn			/*1*/
		UndefinedID 		/*2*/
		SaveSymTbl			/*3*/
		optionalMacParms 	/*4*/
		SaveSymTbl			/*5*/
		optionalLocalIDs 	/*6*/
		SaveSymTbl			/*7*/
		MatchSemicolon		/*8*/
		RecordTheMacro		/*9*/
		endMacDefTkn		/*10*/
		endmacroTkn 		/*11*/
		{
			struct SymNode v;
			struct SymNode *s;

			_here;
			
			// Restore currentNS before entering the symbol
			// into the symbol table.
			
			currentNS = $<s>4;

			#define ptr(p,prev) _ifx((p)!=(prev),p,NULL)

			/*
			** Initialize the macro data for the macro
			** symbol table entry.
			*/

			v.u.MacroData.Text = $<m.Text>10;
			v.u.MacroData.Parameters = ptr($<s>5,$<s>3);
			v.u.MacroData.Locals = ptr($<s>7,$<s>5);
			v.u.MacroData.Terminator = NULL;
			v.u.MacroData.NameSpace = NULL;
			v.u.MacroData.LineCnt = $<v.u.unsval>8;
			v.u.MacroData.Filename = 	hlastrdup2( FileName );

			/*
			** If there are parameters or local symbols, null
			** terminate the list of such symbols so they don't
			** point into the main symbol table.
			*/

			_if( $<s>7 != $<s>3 )

				s = $<s>7;
				_while( s->Next != NULL && s->Next != $<s>3 )

					s = s->Next;

				_endwhile
				s->Next = NULL;

			_endif
			SymbolTable = $<s>3;

			/*
			** Insert the text for the macro into
			** the symbol table.
			*/
			assert( $<idStr>2 != NULL );
			InsertSym
			( 
				$<idStr>2, 
				NULL,			/* No type associated with this symbol.	*/
				tMacro,			/* It's a macro.						*/
				cMacro, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				YYS &v,			/* Ptr to macro's text.			*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);

			inMacro = 0;
			_here;
		}
	
	;



/****************************************************************/
/*                                                              */
/* macros -> 	#macro macroID                                  */
/* 			optionalMacParms  				                    */
/* 			optionalLocalIDs                                    */
/* 			';'                                                 */
/* 			<<text>>                                            */
/* 			                                                    */
/* 			optionalKeywords                                    */
/*                                                              */
/* 			#terminator TerminatorID                            */
/* 			optionalMacParms  				                    */
/* 			optionalLocalIDs                                    */
/* 			';'                                                 */
/* 			<<text>>                                            */
/* 			                                                    */
/* 			#endmacro                                           */
/*                                                              */
/* This production handles macro declarations that have         */
/* a TERMINATOR clause (and optional KEYWORD clauses).          */
/* Since the lexer must handle the recording of the macro data, */
/* this production has to pull some tricks to tell the flex     */
/* portion of the code to record each line up to end endmacro   */
/* reserved word.                                               */
/*                                                              */
/****************************************************************/




macros:	
		doMacroTkn			/*1*/ 
		UndefinedID			/*2*/ 
		SaveSymTbl			/*3*/ 
		optionalMacParms	/*4*/
		SaveSymTbl			/*5*/ 
		optionalLocalIDs	/*6*/ 
		SaveSymTbl			/*7*/
		MatchSemicolon		/*8*/
		RecordTheMacro		/*9*/
		endMacDefTkn		/*10*/
		
		{					/*11*/ 
			_here;
			currentNS = $<s>4;
			$<s>$ = currentNS; 
		}
		optionalKeywords	/*12*/
		SaveSymTbl			/*13*/

		
		{					/*14*/ 
			_here;
			currentNS = $<s>4; 
		}
		doTerminatorTkn		/*15*/ 
		UndefinedID			/*16*/ 
		optionalMacParms	/*17*/ 
		SaveSymTbl			/*18*/
		optionalLocalIDs	/*19*/
		SaveSymTbl			/*20*/ 
		MatchSemicolon		/*21*/
		RecordTheMacro		/*22*/
		endMacDefTkn		/*23*/
		
		endmacroTkn 		/*24*/
		{
			struct SymNode v;
			struct SymNode *s;

			_here;

			// Restore currentNS before entering the symbols
			// into the symbol table.
			
			currentNS = $<s>4;

			/*
			** Set up the textual data for the terminator.
			*/

			v.u.MacroData.Text = $<m.Text>23;

			v.u.MacroData.Parameters = ptr( $<s>18, $<s>13 );
			v.u.MacroData.Locals = ptr( $<s>20, $<s>18 );
			v.u.MacroData.Terminator = NULL;
			v.u.MacroData.LineCnt = $<v.u.unsval>21;
			v.u.MacroData.NameSpace = currentNS;
			v.u.MacroData.Filename = 	hlastrdup2( FileName );

			/*
			** Null-terminate the list of parameters and
			** local symbols associated with the terminator.
			*/

			_if( $<s>20 != $<s>13 )

				s = $<s>20;
				_while( s->Next != NULL && s->Next != $<s>13 )

					s = s->Next;

				_endwhile
				s->Next = NULL;

			_endif
			SymbolTable = $<s>13;



			/*
			** Insert the text for the terminator macro into
			** the symbol table.
			*/

			assert( $<idStr>16 != NULL );
			InsertSym
			( 
				$<idStr>16, 
				NULL,			/* No type associated with this symbol.	*/
				tMacro,			/* It's a macro.						*/
				cTerminator, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				YYS &v,			/* Ptr to macro's text.			*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);
			_here;


			/*
			** Set up the textual macro data for the main macro.
			*/

			v.u.MacroData.Text = $<m.Text>10;
			v.u.MacroData.Parameters = ptr( $<s>5, $<s>3 );
			v.u.MacroData.Locals = ptr( $<s>7, $<s>5 );
			v.u.MacroData.Terminator = SymbolTable;
			v.u.MacroData.LineCnt = $<v.u.unsval>8;
			v.u.MacroData.Filename = 	hlastrdup2( FileName );


			/*
			** Null-terminate the list of keywords, parameters, and
			** local symbols associated with the main macro.
			*/

			s = SymbolTable;
			_while( s->Next != NULL && s->Next != $<s>3 )

				s = s->Next;

			_endwhile
			s->Next = NULL;
			SymbolTable = $<s>3;




			/*
			** Insert the text for the macro into
			** the symbol table.
			*/

			assert( $<idStr>2 != NULL );
			InsertSym
			( 
				$<idStr>2, 
				NULL,			/* No type associated with this symbol.	*/
				tMacro,			/* It's a macro.						*/
				cMacro, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				YYS &v,			/* Ptr to macro's text.			*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);

			inTerminator = 0;
			(void) $<s>11; // To shut up bison
			_here;
		}
	;





/*
** The following matches the "macro" keyword and
** sets the inMacro flag true for use by the @SECTION
** compile-time function.  It also preserves the currentNS
** variable (and sets it to NULL) so we don't use the
** hash table search when scanning for local macro symbols.
*/


doMacroTkn:
		macroTkn
		{
			_here;
			inMacro = 1;
		}
	;


/*
** The following matches the "terminator" keyword
** and sets up the appropriate @SECTION flags for
** a terminator section.
*/

doTerminatorTkn:
		terminatorTkn
		{
			_here;
			inMacro = 0;
			inKeyword = 0;
			inTerminator = 1;
		}
	;



/*
** The following matches the "keyword" keyword and
** sets the appropriate @SECTION flags.
*/

doKeywordTkn:
		keywordTkn
		{
			_here;
			inMacro = 0;
			inKeyword = 1;
		}
	;


/*
** The following matches a semicolon terminal symbol
** and saves the current line number in the source
** file as the object's attribute.  This is used to
** reset the source file line number when processing
** macros.
*/

MatchSemicolon:
		Semicolon
		{
			_here;
			$<v.u.unsval>$ = LineCnt;
			_here;
		}
	;



/*
** The following productions process the optional
** "keyword" sections in a macro definition.
*/


optionalKeywords:
			Empty	{ _here; $<s>$ = NULL; }

		|	optionalKeywords	/*1*/
			doKeywordTkn		/*2*/ 
			UndefinedID			/*3*/ 
			SaveSymTbl			/*4*/
			optionalMacParms	/*5*/
			SaveSymTbl			/*6*/
			optionalLocalIDs	/*7*/ 
			SaveSymTbl			/*8*/
			MatchSemicolon		/*9*/
			RecordTheMacro		/*10*/
			endMacDefTkn		/*11*/
			
			{
				struct SymNode v;
				struct SymNode *s;

				_here;

				/*
				** Process the macro text associated with
				** each keyword clause present in the macro.
				*/

				v.u.MacroData.Text = $<m.Text>11;
				v.u.MacroData.Parameters = ptr( $<s>6, $<s>4 );
				v.u.MacroData.Locals = ptr( $<s>8, $<s>6 );
				v.u.MacroData.NameSpace = $<s>0;
				v.u.MacroData.Terminator = NULL;
				v.u.MacroData.LineCnt = $<v.u.unsval>9;
				v.u.MacroData.Filename = 	hlastrdup2( FileName );

				/*
				** Null-terminate the list of parameter names and
				** local identifiers associated with this keyword macro.
				*/

				_if( $<s>8 != $<s>4 )

					s = $<s>8;
					_while( s->Next != NULL && s->Next != $<s>4 )

						s = s->Next;

					_endwhile
					s->Next = NULL;

				_endif
				SymbolTable = $<s>4;


				/*
				** Insert the text for the keyword macro into
				** the symbol table.
				*/

				assert( $<idStr>3 != NULL );
				InsertSym
				( 
					$<idStr>3, 
					NULL,			/* No type associated with this symbol.	*/
					tMacro,			/* It's a macro.						*/
					cKeyword, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					YYS &v,			/* Ptr to macro's text.			*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);
				$<s>$ = SymbolTable;
				_here;
			}

		;


/*
** SaveSymTbl saves the current pointer into the symbol table
** as a non-terminal attribute so we can determine if the
** macro has any parameters or local symbols.
*/

SaveSymTbl:	{ _here; $<s>$ = SymbolTable; };



/*
** RecordTheMacro calls doRecMac in the FLEX file
** that sets the appropriate scanner state so that
** the scanner starts recording macro text.
*/

RecordTheMacro:
			{ 
				_here;
				doRecMac();
			};




/*
** optionalMacParms:
**
**	The production processes optional macro parameters
** in a macro, keyword, or terminator macro definition.
*/

optionalMacParms:

		Empty
		{
			_here;
			$<s>$ = currentNS;
			currentNS = NULL;
		}

	|	'(' 
		{ 
			_here;
			$<s>$ = currentNS;
			currentNS = NULL;
		}
		MacroParmList 
		Rparen
		{
			_here;
			$<s>$ = $<s>2;
		}
	;


/*
** MacroParmList-
**
** This production processes a list of macro identifiers
** in a macro declaration.
**
**	MacroParmList returns a $<s> object so that optionalLocalIDs
** can check for a "[]" at the end of the declaration list.
*/

MacroParmList:
		AnyID
		{
			struct SymNode v;

			_here;
			v.u.strval = hlastrdup2( "" );
			v.pType = tString;
			v.Type = &string_ste;
			InsertSym
			( 
				$<neID.idStr>1, 
				&text_ste,
				tText, 
				cValue, 
				0,				/* Arity			*/
				NULL,			/* Dimensions		*/
				0, 				/* NumElements		*/
				YYS &v,			/* Value			*/
				0,				/* ObjectSize		*/
				0,				/* Offset			*/
				NULL,			/* Static Name		*/
				NULL,			/* Base				*/
				NULL,			/* Fields			*/
				0				/* FieldCnt			*/
			);
			$<s>$ = SymbolTable;
			_here;
		}
	;

/*
** Handle the last macro parameter (array/variable parameter list).
*/


MacroParmList:
			AnyID '[' Rbrack 
			{
				int				*Dims;
				struct SymNode	v;

				_here;
				
				/*
				** Must allocate dummy objects so they can
				** be freed later.
				*/

				Dims = malloc2( sizeof( int ));
				*Dims = 0;

				v.u.ArrayOfValues = NULL;
				InsertSym
				( 
					$<neID.idStr>1, 
					&string_ste,
					tArray, 
					cValue, 
					1,				/* Arity			*/
					Dims,			/* Dimensions		*/
					0, 				/* NumElements		*/
					YYS &v,			/* Value			*/
					0,				/* ObjectSize		*/
					0,				/* Offset			*/
					NULL,			/* Static Name		*/
					NULL,			/* Base				*/
					NULL,			/* Fields			*/
					0				/* FieldCnt			*/
				);
				$<s>$ = SymbolTable;
				_here;
			}

	;



// Handle the last macro parameter if it is of the form "string <id>"

MacroParmList:
			stringTkn AnyID 
			{
				int				*Dims;
				struct SymNode	v;

				_here;
				
				v.u.strval = hlastrdup2( "" );
				v.pType = tString;
				v.Type = &string_ste;
				InsertSym
				( 
					$<neID.idStr>2, 
					&string_ste,
					tString, 
					cValue, 
					0,				/* Arity			*/
					NULL,			/* Dimensions		*/
					0, 				/* NumElements		*/
					YYS &v,			/* Value			*/
					0,				/* ObjectSize		*/
					0,				/* Offset			*/
					NULL,			/* Static Name		*/
					NULL,			/* Base				*/
					NULL,			/* Fields			*/
					0				/* FieldCnt			*/
				);
				$<s>$ = SymbolTable;
				_here;
			}

	;



/*
** Handle all macro parameters but the last.
*/

MacroParmList:
		AnyID 			/* $1 */
		',' 			/* $2 */
		MacroParmList	/* $3 */
		{ 				/* $4 */

			struct SymNode v;

			_here;
			v.u.strval = hlastrdup2( "" );
			v.pType = tString;
			v.Type = &string_ste;
			InsertSym
			( 
				$<neID.idStr>1, 
				&text_ste,
				tText, 
				cValue, 
				0,				/* Arity			*/
				NULL,			/* Dimensions		*/
				0, 				/* NumElements		*/
				YYS &v,			/* Value			*/
				0,				/* ObjectSize		*/
				0,				/* Offset			*/
				NULL,			/* Static Name		*/
				NULL,			/* Base				*/
				NULL,			/* Fields			*/
				0				/* FieldCnt			*/
			);
			$<s>$ = $<s>3;
			_here;
		}
	;




 /*
 ** The following production handles a series of LOCAL statements
 ** appearing immediately after the beginning of the macro statement.
 */

optionalLocalIDs:

		Empty

	|	':' 
		MacroParmList
		{

			/*
			** Kludge!
			**
			**	Using MacroParmList to process the local names
			** means that the last local identifier could be
			** an array of strings (rather than a scalar text object).
			** This is legal for parameters (variable parms) but makes
			** no sense for local symbols.  The following code checks
			** the last declaration out to ensure it is not an attempt
			** to supply the "[]" suffix.  Note that $<s>2 points at
			** the last entry in the symbol table, which is the only
			** entry that may legally have the "[]" suffix from the
			** above productions.
			*/

			_here;
			_if( $<s>2->Dimensions != NULL )

				yyerror( "\"[]\" not allowed after local symbol" );

			_endif

		}
	;





/*****************************************************/


/*****************************************************************************/
/*****************************************************************************/
/**********************                           ****************************/
/**********************                           ****************************/
/**********************   P R O C E D U R E S     ****************************/
/**********************                           ****************************/
/**********************                           ****************************/
/*****************************************************************************/
/*****************************************************************************/


// Handle new-style procedure declarations here:

	
	
procDcls:
		Empty
		{
			_here;
		}
	;
	
procDcls:
		procDcls			/* $2 */
		newProcs			/* $1 */
		{
			_here;
		}
	;


newProcs:
		';'
		{
			_here;
		}
	;
	
	
	
// Handle procedure/iterator/method overloading here:

procID:
			LocalProcID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalIterID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	LocalMethodID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		
		|	NonLocalProcID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalIterID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	NonLocalMethodID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	ClassProcID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	ClassIterID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}

		|	ClassMethodID
			{
				_here;
				assert( $<s>1 != NULL );
				$<s>$ = $<s>1;
				_here;
			}
		;
		

newProcs:
		UndefinedID		/* $1 */
		':'				/* $2 */
		overloadsTkn	/* $3 */
		saveYYText		/* $4 */
		procID			/* $5 */
		OptionalStr		/* $6 */
		Semicolon		/* $7 */
		{
			struct SymNode	*s;
			struct SymNode	*parmPtr;
			int				parmCnt;
			
			_here;
			doCollect = 0;
			s = InsertSym
				(
					$<idStr>1,			//TrueName
					NULL,				//Type
					tOverloads,			//pType
					cOverloads,			//TheClass
					0,					//Arity
					NULL,				//Dimensions,
					0,					//NumElements,
					NULL,				//TheValue,
					0,					//ObjectSize,
					0,					//Offset,
					NULL,				//StaticName,
					NULL,				//Base,
					NULL,				//Fields,
					0					//FieldCnt
				);
				
			s->u.ovld.nextOvld	= NULL;
			parmPtr				= $<s>5->u.proc.parms;
			s->u.ovld.parms		= parmPtr;
			parmCnt = 0;
			_while( parmPtr->SymClass == cParm )
			
				parmPtr = parmPtr->Next;
				++parmCnt;
				
			_endwhile;
			s->u.ovld.numParms = parmCnt;
			_if( *$<returns>6 != '\0' )
			
				s->u.ovld.procName = $<returns>6;
			
			_else
			
				collectBuf[ collectIndex-1 ] = '\0'; // Trim ';'
				s->u.ovld.procName = hlastrdup2( collectBuf );
				
			_endif
			_here;
		} 
	;
	

newProcs:
		OverloadedID	/* $1 */
		':'				/* $2 */
		overloadsTkn	/* $3 */			
		saveYYText		/* $4 */
		procID			/* $5 */
		OptionalStr		/* $6 */
		Semicolon		/* $7 */
		{
			struct SymNode	*s;
			struct SymNode	*parmPtr;
			int				parmCnt;
			
			_here;
			doCollect = 0;
			s = InsertSym
				(
					strdup( $<s>1->TrueName ),	//TrueName
					NULL,						//Type
					tOverloads,					//pType
					cOverloads,					//TheClass
					0,							//Arity
					NULL,						//Dimensions,
					0,							//NumElements,
					NULL,						//TheValue,
					0,							//ObjectSize,
					0,							//Offset,
					NULL,						//StaticName,
					NULL,						//Base,
					NULL,						//Fields,
					0							//FieldCnt
				);
				
			s->u.ovld.nextOvld	= $<s>1;
			parmPtr				= $<s>5->u.proc.parms;
			s->u.ovld.parms		= parmPtr;
			parmCnt = 0;
			_while( parmPtr->SymClass == cParm )
			
				parmPtr = parmPtr->Next;
				++parmCnt;
				
			_endwhile;
			s->u.ovld.numParms = parmCnt;
			_if( *$<returns>6 != '\0' )
			
				s->u.ovld.procName = $<returns>6;
				
			_else
			
				collectBuf[ collectIndex-1 ] = '\0'; // Trim ';'
				s->u.ovld.procName = hlastrdup2( collectBuf );
				
			_endif
			_here;
		}
	;
	

	

/**********************************************************/
/*                                                        */
/* Procs-> procedure procID optionalParameters ';'        */
/* 		Declarations                                      */
/* 		begin procID                                      */
/* 		stmts                                             */
/* 		end prodID                                        */
/* 		                                                  */
/*                                                        */
/* This production handles procedure declarations.        */
/* Essentially identical to the production for a program. */
/* Note, however, that this code adjusts lex levels and   */
/* sets up other compiler variables needed by HLA.        */
/*                                                        */
/**********************************************************/


procs:
			procedureTkn	/* $1 */
			UndefinedID 	/* $2 */
			
			/*
			** Before going any farther, save the current
			** (previous lex level) variable offset and offset direction,
			** so we can restore all these values when
			** the compiler finishes this procedure.  Note that the
			** compiler saves these values in the attributes of the
			** following grammar symbols.
			*/
			
			SaveOffset		/* $3 */
			SaveDirection	/* $4 */
			SaveContext		/* $5 */

			/*
			** Insert the procedure name into the symbol table at the
			** old lex level.  This will provide access to the procedure's
			** name from outside this procedure. Also, enter the procedure's
			** name into the symbol table at the new lex level to prevent
			** the user from redefining this symbol inside the
			** procedure.
			**
			** Also, set up the offset and direction values as appropriate
			** for processing parameters.  The process the optional
			** parameter list.
			**
			** Also, bump the current lex level up by one.
			*/

			EnterName		/* $6 en.s = pointer to sym tbl entry		*/
							/* $6 en.cns = saved currentNS				*/


			/*
			** Process any formal parameters.
			*/

			OptionalParms 	/* $7 v.u.unsval= #bytes of parameters		*/
			Semicolon		/* $8 */

			/*
			** Process the optional returns, nonest, and noframe clauses.
			*/

			Options			/* $9 */

			
			/*
			** Initialize the pointer to the end of the parameters
			** for this procedure.
			** Set up the offset and direction variables to handle
			** local variable declarations.
			** Set up the procedure's "returns" value.  
			*/
			 
			{				/* $10 */

				int 					*dimension;
				struct SymNode 			value;
				struct contextListType	*p;
				char					exitname[ 256 ];
				union YYSTYPE			dummy;

				_here;


				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_returns
					|	specified_use
					|	specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_noenter 
					|	specified_noleave
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_alignment 
				);
				
				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.  This allows recursive calls
				** to gain access to the parameter list and "returns"
				** value for this procedure.
				*/

				$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.parms->u.proc.use = $<options.use>9;


				/*
				** Okay, now set up the pointers for the main
				** symbol table entry.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;
				CurOffsetDir = -1;
				$<en.s>6->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.use = $<options.use>9;
				
				CurOffset = StartLclOffs;
				_if( $<options.UseDisplay>9 )

					CurOffset -= 4;

					/*
					** Create a symbol table entry for the display.
					*/

					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);
					CurOffset -= CurLexLevel * 4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);



				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.  Do not add it if there is no
				** frame generation.
				*/
				
				_if( $<options.UseFrame>9 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<idStr>2;

					sprintf
					( 
						exitname, 
						"x%s" sympost, 
						$<en.s>6->StaticName 
					); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>9;
					p->SizeParms = $<v.u.unsval>7;
					contextList = p;

				_endif

				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:


				$<en.s>6->u.proc.cs = $<options.CallingSequence>9;
				_if
				(
						$<options.CallingSequence>9 == stdcall_cs
					||	$<options.CallingSequence>9 == cdecl_cs
				)

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<en.s>6->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>6 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile


				_endif
				_here;
			}

			/*
			** Process this procedure's declarations here.
			*/

			Declarations	/* $11 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 		/* $12 */
			AnyID 			/* $13 */
			Semicolon		/* $14 */

			{				/* $15 */

				int						HadPassByValRes;
				int 					RoundedOffset;
				struct SymNode			*s;
				struct SymNode			*bt;
				struct SymNode			*d;
				struct SymNode			value;

				_here;
				inProcedure = 1;

				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>9 )

					HadPassByValRes = 0;
					s = $<en.s>6->u.proc.parms;

					_while( s != NULL && s != $<en.s>6 )

						bt = GetBaseType( s );
						_if
						( 
								bt->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)


							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;

							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );

						_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(

								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif

				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** Don't count the size of the display as part
				** of the local variable count.
				*/

				_if( $<options.UseDisplay>9 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);



				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				startCseg();
				_if( $<options.Alignment>9 != 1 )

					EmitAlign( $<options.Alignment>9 );

				_endif
				StartProc( $<en.s>6->StaticName ); 
				_if( $<options.UseFrame>9 )
				
					_if( !$<options.UseDisplay>9 )


						/*
						** If we're not building a display, just use the
						** standard entry sequence.
						*/

						StdEntry( RoundedOffset, $<options.NoEnter>9 );

						/*
						** Align the stack on a dword boundary.
						*/

						_if( AlwaysAlignStk && $<options.AlignStk>9 )

							AlignStack();

						_endif

					_else //$<options.UseFrame>9

						/*
						** We've got to construct the display.
						*/

						ConstructDisplay
						( 
							CurLexLevel, 
							RoundedOffset,
							$<options.NoEnter>9 
						);

						/*
						** Align the stack on a dword boundary.
						*/

						_if( AlwaysAlignStk && $<options.AlignStk>9 )

							AlignStack();

						_endif
						
					_endif

					
					/*
					** _else
					**
					** 		Don't do anything special if we're not emiting
					**		code to construct the stack frame.  Note that
					**		"noframe" automatically assumes "nodisplay" as
					**		far as code emission is concerned.
					*/

				_endif


				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>9 && HadPassByValRes )

					CopyValResParms( $<en.s>6 );

				_endif


				assert( $<neID.idStr>13 != NULL );

				_if( _strne( $<idStr>2, $<neID.idStr>13 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"procedure name <<%s>>",
						$<neID.idStr>13,
						$<idStr>2
					);

					yyerror( msg );

				_endif

				/*
				** Check to ensure that all forward declared procedures
				** have been defined prior to code emission.
				*/

				CheckForwardDecls( $<en.s>6 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				CurrentContext = $<en.s>6;
				free2( vss $<neID.idStr>13 );


				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				_if( $<options.UseFrame>9 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
			    _here;
			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts			/* $16 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn 			/* $17 */
			AnyID 			/* $18 */
			Semicolon		/* $19 */
			{				/* $20 */


				_here;
				assert( $<neID.idStr>18 != NULL );

				_if( _strne( $<idStr>2, $<neID.idStr>18 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"procedure name <<%s>>",
						$<neID.idStr>18,
						$<idStr>2
					);

					yyerror( msg );

				_endif

				/*
				** Emit the exit label for this procedure.
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>9 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<en.s>6->StaticName );
					EmitStmtLbl( lbl );



					/*
					** Deal with the _finalize_ string here.
					*/

					_here;
					InvisibleCode = NULL;
					_if
					( 
							$<s>15->pType != tString 
						&&	$<s>15->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>15->u.strval ) != 0 )

						InvisibleCode = $<s>15->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>15->u.strval );

					_endif
					
				_endif
				_here;

			}
			Stmts		/* $21 */
			endTkn		/* $22 Faked by PushBackStr above	*/
			{			/* $22 */


				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;

				_here;
				
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>9 )

					StoreValResParms( $<en.s>6 );

				_endif

		

				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				



				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;
				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;

				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();

				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>9 )

					StdExit
					( 
						$<v.u.unsval>7, 
						$<en.s>6->u.proc.cs == cdecl_cs,
						$<options.NoLeave>9 
					);

				_endif
				EndProc( $<en.s>6->StaticName );
				endCseg();
				free2( vss $<neID.idStr>18 );
				
				currentNS = $<en.cns>6;

				inProcedure = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>9 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( cNode->label == $<idStr>2 );
					free2( vss cNode->StaticName );

				_endif
				_here;
			}
	;
	

	
	
newProcs:	
		UndefinedID		/* $1 */
		Colon			/* $2 */
		forwardTkn		/* $3 */
		Lparen			/* $4 */
		UndefinedID		/* $5 */
		Rparen			/* $6 */
		Semicolon		/* $7 */
		{				/* $8 */

			union YYSTYPE v;

			_here;
			assert( $<idStr>1 != NULL );
			assert( $<idStr>5 != NULL );

			v.v.u.strval = $<idStr>1;
			InsertSym
			( 
				$<idStr>5, 
				&text_ste,
				tText, 
				cConstant, 
				0,				/* arity 			*/
				NULL,			/* NumDimensions	*/
				0, 				/* NumElements		*/
				YYS &v,
				4,				/* ObjectSize		*/
				0,
				NULL,
				NULL,			/* Base				*/
				NULL,			/* Fields			*/
				0				/* FieldCnt			*/ 
			);

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;
		}
	;

			 

colonProcedure:
			':'
			procedureTkn
			{
				_here;
				$<idStr>$ = $<idStr>0;
			}
		;


newProcs:
			UndefinedID 	/* $1 */
			colonProcedure	/* $2 */
			
			/*
			** Before going any farther, save the current
			** (previous lex level) variable offset and offset direction,
			** so we can restore all these values when
			** the compiler finishes this procedure.  Note that the
			** compiler saves these values in the attributes of the
			** following grammar symbols.
			*/
			
			SaveOffset		/* $3 */
			SaveDirection	/* $4 */
			SaveContext		/* $5 */

			/*
			** Insert the procedure name into the symbol table at the
			** old lex level.  This will provide access to the procedure's
			** name from outside this procedure. Also, enter the procedure's
			** name into the symbol table at the new lex level to prevent
			** the user from redefining this symbol inside the
			** procedure.
			**
			** Also, set up the offset and direction values as appropriate
			** for processing parameters.  The process the optional
			** parameter list.
			**
			** Also, bump the current lex level up by one.
			*/

			EnterName		/* $6 en.s = pointer to sym tbl entry		*/
							/* $6 en.cns = saved currentNS				*/


			/*
			** Process any formal parameters.
			*/

			OptionalParms 	/* $7 v.u.unsval= #bytes of parameters		*/

			/*
			** Process the optional returns, noframe, etc., clauses.
			*/

			newProcOptionsSemicolon	/* $8 */

			
			/*
			** Initialize the pointer to the end of the parameters
			** for this procedure.
			** Set up the offset and direction variables to handle
			** local variable declarations.
			** Set up the procedure's "returns" value.  
			*/
			 
			{				/* $9 */

				int 					*dimension;
				struct SymNode 			value;
				struct contextListType	*p;
				char					exitname[ 256 ];
				union YYSTYPE			dummy;

				_here;

				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_returns
					|	specified_use
					|	specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_noenter 
					|	specified_noleave
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_alignment 
				);

				
				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.  This allows recursive calls
				** to gain access to the parameter list and "returns"
				** value for this procedure.
				*/

				$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>8;
				$<en.s>6->u.proc.parms->u.proc.use = $<options.use>8;


				/*
				** Okay, now set up the pointers for the main
				** symbol table entry.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;
				CurOffsetDir = -1;
				$<en.s>6->u.proc.returns = $<options.returns>8;
				$<en.s>6->u.proc.use = $<options.use>8;
				
				CurOffset = StartLclOffs;
				_if( $<options.UseDisplay>8 )

					CurOffset -= 4;

					/*
					** Create a symbol table entry for the display.
					*/

					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);
					CurOffset -= CurLexLevel * 4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);



				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.  Do not add it if there is no
				** frame generation.
				*/
				
				_if( $<options.UseFrame>8 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<idStr>2;

					sprintf
					( 
						exitname, 
						"x%s" sympost, 
						$<en.s>6->StaticName 
					); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>8;
					p->SizeParms = $<v.u.unsval>7;
					contextList = p;

				_endif

				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:


				$<en.s>6->u.proc.cs = $<options.CallingSequence>8;
				_if
				(
						$<options.CallingSequence>8 == stdcall_cs
					||	$<options.CallingSequence>8 == cdecl_cs
				)

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<en.s>6->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>6 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile


				_endif
				_here;
			}

			/*
			** Process this procedure's declarations here.
			*/

			Declarations	/* $10 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 		/* $11 */
			AnyID 			/* $12 */
			Semicolon		/* $13 */

			{				/* $14 */

				int						HadPassByValRes;
				int 					RoundedOffset;
				struct SymNode			*s;
				struct SymNode			*bt;
				struct SymNode			*d;
				struct SymNode			value;

				_here;
				inProcedure = 1;

				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>8 )

					HadPassByValRes = 0;
					s = $<en.s>6->u.proc.parms;

					_while( s != NULL && s != $<en.s>6 )

						bt = GetBaseType( s );
						_if
						( 
								bt->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)


							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;

							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );

						_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(

								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif

				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** Don't count the size of the display as part
				** of the local variable count.
				*/

				_if( $<options.UseDisplay>8 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);



				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				startCseg();
				_if( $<options.Alignment>8 != 1 )

					EmitAlign( $<options.Alignment>8 );

				_endif
				StartProc( $<en.s>6->StaticName ); 
				_if( $<options.UseFrame>8 && !$<options.UseDisplay>8 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>8 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>8 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>8 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>8 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>8 )

						AlignStack();

					_endif



				
				/*
				** _else
				**
				** 		Don't do anything special if we're not emiting
				**		code to construct the stack frame.  Note that
				**		"noframe" automatically assumes "nodisplay" as
				**		far as code emission is concerned.
				*/

				_endif


				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>8 && HadPassByValRes )

					CopyValResParms( $<en.s>6 );

				_endif


				assert( $<neID.idStr>12 != NULL );

				_if( _strne( $<idStr>2, $<neID.idStr>12 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"procedure name <<%s>>",
						$<neID.idStr>12,
						$<idStr>2
					);

					yyerror( msg );

				_endif

				/*
				** Check to ensure that all forward declared procedures
				** have been defined prior to code emission.
				*/

				CheckForwardDecls( $<en.s>6 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				CurrentContext = $<en.s>6;
				free2( vss $<neID.idStr>12 );


				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				_if( $<options.UseFrame>8 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;
			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts			/* $15 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn 			/* $16 */
			AnyID 			/* $17 */
			Semicolon		/* $18 */
			{				/* $19 */


				_here;
				assert( $<neID.idStr>17 != NULL );

				_if( _strne( $<idStr>2, $<neID.idStr>17 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"procedure name <<%s>>",
						$<neID.idStr>17,
						$<idStr>2
					);

					yyerror( msg );

				_endif

				/*
				** Emit the exit label for this procedure.
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>8 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<en.s>6->StaticName );
					EmitStmtLbl( lbl );



					/*
					** Deal with the _finalize_ string here.
					*/

					_here;
					InvisibleCode = NULL;
					_if
					( 
							$<s>14->pType != tString 
						&&	$<s>14->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>14->u.strval ) != 0 )

						InvisibleCode = $<s>14->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>14->u.strval );

					_endif
					
				_endif
				_here;

			}
			Stmts		/* $20 */
			endTkn		/* $21 Faked by PushBackStr above	*/
			{			/* $22 */


				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;

				_here;
				
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>8 )

					StoreValResParms( $<en.s>6 );

				_endif

		

				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				



				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;
				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;

				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();

				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>8 )

					StdExit
					( 
						$<v.u.unsval>7, 
						$<en.s>6->u.proc.cs == cdecl_cs,
						$<options.NoLeave>8 
					);

				_endif
				EndProc( $<en.s>6->StaticName );
				endCseg();
				free2( vss $<neID.idStr>17 );
				
				currentNS = $<en.cns>6;

				inProcedure = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>8 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( cNode->label == $<idStr>2 );
					free2( vss cNode->StaticName );

				_endif
				_here;
			}
	;
	

 			 

		
			


// Handle a procedure declaration that uses a user defined procedure type
// rather than "procedure" and a parameter list.	

saveUID:
		{
			_here;
			$<idStr>$ = $<idStr>-2;
		}
	;



newProcs:
			UndefinedID 	/* $1 */
			':'				/* $2 */
			TypeID			/* $3 */
			saveUID			/* $4 */
			
			/*
			** Before going any farther, save the current
			** (previous lex level) variable offset and offset direction,
			** so we can restore all these values when
			** the compiler finishes this procedure.  Note that the
			** compiler saves these values in the attributes of the
			** following grammar symbols.
			*/
			
			SaveOffset		/* $5 */
			SaveDirection	/* $6 */
			SaveContext		/* $7 */

			/*
			** Insert the procedure name into the symbol table at the
			** old lex level.  This will provide access to the procedure's
			** name from outside this procedure. Also, enter the procedure's
			** name into the symbol table at the new lex level to prevent
			** the user from redefining this symbol inside the
			** procedure.
			**
			** Also, set up the offset and direction values as appropriate
			** for processing parameters.  The process the optional
			** parameter list.
			**
			** Also, bump the current lex level up by one.
			*/

			EnterName		/* $8 en.s = pointer to sym tbl entry		*/
							/* $8 en.cns = saved currentNS				*/



			/*
			** Process the optional returns, nonest, and noframe clauses.
			*/

			newProcOptionsSemicolon	/* $9 */

			
			/*
			** Initialize the pointer to the end of the parameters
			** for this procedure.
			** Set up the offset and direction variables to handle
			** local variable declarations.
			** Set up the procedure's "returns" value.  
			*/
			 
			{				/* $10 */

				int 					*dimension;
				struct SymNode 			value;
				struct contextListType	*p;
				char					exitname[ 256 ];
				union YYSTYPE			dummy;
				
				short					CallingSequence;
				
				_here;
				_if( $<s>3->pType != tProcptr )
				
					char msg[256];
				
					sprintf
					( 
						msg,
						"Expected procedure type identifier after ':', "
						"found '%s'",
						$<s>3->TrueName
					);
					yyerror( msg );
				
				_endif
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_alignment 
					|	specified_noenter 
					|	specified_noleave
					|	specified_use
					|	specified_returns
					|	specified_stdcall
					|	specified_pascal
					|	specified_cdecl
				);
				
				_if( $<options.SpecifiedOptions>9 & specified_stdcall )
				
					CallingSequence = stdcall_cs;
					
				_elseif( $<options.SpecifiedOptions>9 & specified_cdecl )
				
					CallingSequence = cdecl_cs;
					
				_elseif( $<options.SpecifiedOptions>9 & specified_pascal )
				
					CallingSequence = pascal_cs;
					
				_else
				
					CallingSequence = $<s>3->u.proc.cs;
					_if( $<s>3->u.proc.cs == stdcall_cs )
					
						$<options.SpecifiedOptions>9 |= specified_stdcall;
						$<options.CallingSequence>9 = stdcall_cs;	
					
					_elseif( $<s>3->u.proc.cs == cdecl_cs )
					
						$<options.SpecifiedOptions>9 |= specified_cdecl;	
						$<options.CallingSequence>9 = cdecl_cs;
						
					_endif	
				
				_endif
				$<en.s>8->u.proc.parms->u.proc.cs = CallingSequence;
				
				

				
				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.  This allows recursive calls
				** to gain access to the parameter list and "returns"
				** value for this procedure.
				*/
				
				copyProcPtrParms( $<s>3 );

				$<en.s>8->u.proc.parms->u.proc.parms = SymbolTable;
				_if( $<options.SpecifiedOptions>9 & specified_returns )
				
					$<en.s>8->u.proc.parms->u.proc.returns = $<options.returns>9;
					$<en.s>8->u.proc.returns =	$<options.returns>9;

				_else
				
					$<en.s>8->u.proc.parms->u.proc.returns = 
												$<s>3->u.proc.returns;
					$<en.s>8->u.proc.returns =	$<s>3->u.proc.returns;
				
				_endif
				_if( $<options.SpecifiedOptions>9 & specified_use )
				
					$<en.s>8->u.proc.parms->u.proc.use = $<options.use>9;
					$<en.s>8->u.proc.use = $<options.use>9;

				_else
				
					$<en.s>8->u.proc.parms->u.proc.use = $<s>3->u.proc.use;
					$<en.s>8->u.proc.use = $<s>3->u.proc.use;
				
				_endif
				$<en.s>8->u.proc.ParmSize = $<s>3->u.proc.ParmSize;
				$<en.s>8->u.proc.parms->u.proc.ParmSize = $<s>3->u.proc.ParmSize;
				$<en.s>8->u.proc.parms = SymbolTable;
				CurOffsetDir = -1;
				
				CurOffset = StartLclOffs;
				_if( $<options.UseDisplay>9 )

					CurOffset -= 4;

					/*
					** Create a symbol table entry for the display.
					*/

					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);
					CurOffset -= CurLexLevel * 4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<s>3->u.proc.ParmSize;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);



				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.  Do not add it if there is no
				** frame generation.
				*/
				
				_if( $<options.UseFrame>9 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<idStr>1;

					sprintf
					( 
						exitname, 
						"x%s" sympost, 
						$<en.s>8->StaticName 
					); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>9;
					p->SizeParms = $<s>3->u.proc.ParmSize;
					contextList = p;

				_endif

				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:


				$<en.s>8->u.proc.cs = CallingSequence;
				_if( CallingSequence == stdcall_cs || CallingSequence == cdecl_cs )

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<en.s>8->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>8 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile


				_endif
				_here;
			}

			/*
			** Process this procedure's declarations here.
			*/

			Declarations	/* $11 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 		/* $12 */
			AnyID 			/* $13 */
			Semicolon		/* $14 */

			{				/* $15 */

				int						HadPassByValRes;
				int 					RoundedOffset;
				struct SymNode			*s;
				struct SymNode			*bt;
				struct SymNode			*d;
				struct SymNode			value;

				_here;
				inProcedure = 1;

				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>9 )

					HadPassByValRes = 0;
					s = $<en.s>8->u.proc.parms;

					_while( s != NULL && s != $<en.s>8 )

						bt = GetBaseType( s );
						_if
						( 
								bt->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)


							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;

							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );

						_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(

								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif

				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** Don't count the size of the display as part
				** of the local variable count.
				*/

				_if( $<options.UseDisplay>9 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);



				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				startCseg();
				_if( $<options.Alignment>9 != 1 )

					EmitAlign( $<options.Alignment>9 );

				_endif
				StartProc( $<en.s>8->StaticName ); 
				_if( $<options.UseFrame>9 && !$<options.UseDisplay>9 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>9 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>9 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>9 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>9 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>9 )

						AlignStack();

					_endif



				
				/*
				** _else
				**
				** 		Don't do anything special if we're not emiting
				**		code to construct the stack frame.  Note that
				**		"noframe" automatically assumes "nodisplay" as
				**		far as code emission is concerned.
				*/

				_endif


				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>9 && HadPassByValRes )

					CopyValResParms( $<en.s>8 );

				_endif


				assert( $<neID.idStr>13 != NULL );

				_if( _strne( $<idStr>1, $<neID.idStr>13 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"procedure name <<%s>>",
						$<neID.idStr>13,
						$<idStr>1
					);

					yyerror( msg );

				_endif

				/*
				** Check to ensure that all forward declared procedures
				** have been defined prior to code emission.
				*/

				CheckForwardDecls( $<en.s>8 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				CurrentContext = $<en.s>8;
				free2( vss $<neID.idStr>13 );


				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				_if( $<options.UseFrame>9 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif

			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts			/* $16 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn 			/* $17 */
			AnyID 			/* $18 */
			Semicolon		/* $19 */
			{				/* $20 */


				_here;
				assert( $<neID.idStr>18 != NULL );

				_if( _strne( $<idStr>1, $<neID.idStr>18 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"procedure name <<%s>>",
						$<neID.idStr>18,
						$<idStr>1
					);

					yyerror( msg );

				_endif

				/*
				** Emit the exit label for this procedure.
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>9 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<en.s>8->StaticName );
					EmitStmtLbl( lbl );



					/*
					** Deal with the _finalize_ string here.
					*/

					_here;
					InvisibleCode = NULL;
					_if
					( 
							$<s>15->pType != tString 
						&&	$<s>15->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>15->u.strval ) != 0 )

						InvisibleCode = $<s>15->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>15->u.strval );

					_endif
					
				_endif
				_here;

			}
			Stmts		/* $21 */
			endTkn		/* $22 Faked by PushBackStr above	*/
			{			/* $22 */


				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;

				_here;
				
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>9 )

					StoreValResParms( $<en.s>8 );

				_endif

		

				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>5;
				CurOffsetDir = $<v.u.unsval>6;
				



				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				$<en.s>8->u.proc.Locals = SymbolTable;
				SymbolTable = $<en.s>8;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>8;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>7;

				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();

				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>9 )
				

					StdExit
					( 
						$<s>3->u.proc.ParmSize, 
						$<en.s>8->u.proc.cs == cdecl_cs,
						$<options.NoLeave>9 
					);

				_endif
				EndProc( $<en.s>8->StaticName );
				endCseg();
			
				free2( vss $<neID.idStr>18 );
				
				currentNS = $<en.cns>8;

				inProcedure = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>9 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( cNode->label == $<idStr>1 );
					free2( vss cNode->StaticName );

				_endif
				_here;
			}
	;
	



 /*
 ** Handle an iterator declaration here.
 ** Virtually identical to a procedure declaration, except we
 ** need to declare the "YIELD" thunk and we need to handle
 ** the extra return address (fail address) pushed on the stack
 ** by the call.
 */



procs:
		iteratorTkn		/* $1 */
		UndefinedID 	/* $2 */
		
		/*
		** Before going any farther, save the current
		** (previous lex level) variable offset and offset direction,
		** so we can restore all these values when
		** the compiler finishes this iterator.  Note that the
		** compiler saves these values in the attributes of the
		** following grammar symbols.
		*/
		
		SaveOffset		/* $3 */
		SaveDirection	/* $4 */
		SaveContext		/* $5 */

		/*
		** Insert the iterator name into the symbol table at the
		** old lex level.  This will provide access to the procedure's
		** name from outside this procedure. Also, enter the iterator's
		** name into the symbol table at the new lex level to prevent
		** the user from redefining this symbol inside the
		** iterator.
		**
		** Also, set up the offset and direction values as appropriate
		** for processing parameters.  The process the optional
		** parameter list.
		**
		** Also, bump the current lex level up by one.
		*/

		EnterIterName	/* $6 en.s = pointer to sym tbl entry		*/
						/* $6 en.cns = saved currentNS value		*/


		/*
		** Process any formal parameters.
		*/

		OptionalParms 	/* $7 v.u.unsval= #bytes of parameters	*/
		Semicolon		/* $8 */

		/*
		** Process the optional returns, nonest, and noframe clauses.
		*/

		Options				/* $9  */

		
		/*
		** Initialize the pointer to the end of the parameters
		** for this procedure.
		** Set up the offset and direction variables to handle
		** local variable declarations.
		** Set up the procedure's "returns" value.  
		*/
		 
		{					/* $10 */

			int 			*dimension;
			struct SymNode 	value;
			struct contextListType	*p;
			char					exitname[ 256 ];
			union YYSTYPE			dummy;

			_here;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_noframe 
				|	specified_nodisplay 
				|	specified_noalignstk 
				|	specified_alignment 
				|	specified_noenter 
				|	specified_noleave 
				|	specified_use
			);


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.  This allows recursive calls
			** to gain access to the parameter list and "returns"
			** value for this procedure.
			*/


			$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>9;
			$<en.s>6->u.proc.parms->u.proc.use = $<options.use>9;

			/*
			** Okay, now set up the pointers for the main
			** symbol table entry.
			*/

			$<en.s>6->u.proc.parms = SymbolTable;
			CurOffsetDir = -1;
			$<en.s>6->u.proc.returns = $<options.returns>9;
			$<en.s>6->u.proc.use = $<options.use>9;
			CurOffset = StartLclOffs;

			// Iterators always use the pascal calling sequence:
			
			$<en.s>6->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>6->u.proc.cs = pascal_cs;

			/*
			** Create a symbol table entry for the "yield" thunk.
			*/

			InsertSym
			( 
				"yield", 
				&thunk_ste,	/* Type			*/
				tThunk, 	/* pType		*/
				cVar,		/* SymClass		*/ 
				0,			/* Arity		*/
				NULL,		/* dimensions	*/
				0, 			/* # elements	*/
				NULL,		/* Value		*/
				8,			/* ObjectSize	*/
				0,			/* Offset 		*/
				NULL,		/* StaticName	*/
				NULL,		/* Base			*/
				NULL,		/* Fields		*/
				0			/* FieldCnt		*/
			);

			/*
			** Thunks (yield) don't have any parameters,
			** but we can't leave proc.parms NULL (since other
			** code treats this as an error).  Just give each
			** Yield thunk a set of local constants which are
			** the lex level zero constants.
			*/
			
			SymbolTable->u.proc.parms = &true_ste;


			_if( $<options.UseDisplay>9 )

				CurOffset -= 4;

				/*
				** Create a symbol table entry for the display.
				*/

				dimension = malloc2( sizeof( int ));
				*dimension = CurLexLevel + 1;
				InsertSym
				( 
					"_display_", 
					&dword_ste,
					tDWord, 
					cVar, 
					1,
					dimension,
					*dimension, 
					NULL,
					*dimension*4,
					CurOffset,
					NULL,
					NULL,
					NULL,
					0
				);
				CurOffset -= CurLexLevel * 4;

			_endif

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);

			value.u.unsval = $<v.u.unsval>7;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);


			/*
			** Add this procedure to the context list so we
			** can bail on this procedure via the EXIT and EXITIF
			** statements.
			*/
			
			_if( $<options.UseFrame>9 )

				p = malloc2( sizeof( struct contextListType ));
				p->Next = contextList;
				p->label = $<idStr>2;

				sprintf( exitname, "x%s" sympost, $<en.s>6->StaticName ); 
				p->StaticName = hlastrdup2( exitname );
				p->LexLevel = CurLexLevel;
				p->IsProc = 1;
				p->HasDisplay = $<options.UseDisplay>9;
				p->SizeParms = $<v.u.unsval>7;
				contextList = p;

			_endif


			_here;
		}

		/*
		** Process this procedure's declarations here.
		*/

		Declarations	/* $11 */
		
		
		/*
		** Upon encountering the "begin" token, check the ID
		** to make sure it matches the procedure name.
		*/
		 
		beginTkn 		/* $12 */
		AnyID 			/* $13 */
		Semicolon		/* $14 */

		{				/* $15 */

			int 			RoundedOffset;
			struct	SymNode	value;
			struct	SymNode	*s;
			struct	SymNode	*bt;
			struct	SymNode	*d;
			int				HadPassByValRes;

			_here;
			inIterator = 1;




			/*
			** Check for pass by value/result or pass by result
			** parameters because we need to allocate local
			** storage for these.
			*/
			
			_if( $<options.UseFrame>9 )

				HadPassByValRes = 0;
				s = $<en.s>6->u.proc.parms;
				_while( s != NULL && s != $<en.s>6 )

					bt = GetBaseType( s );
					_if
					( 
							bt->pType == tProcptr 
						&&	(
									s->pClass == vrp_pc 
								||	s->pClass == result_pc
							)
					)

						CurOffset = CurOffset - 4;
						InsertSym
						(
							s->TrueName, 
							NULL,				/* Type			*/
							tProcptr,		 	/* pType		*/
							cVar,				/* SymClass		*/ 
							s->Arity,			/* Arity		*/
							s->Dimensions,		/* dimensions	*/
							s->NumElements,		/* # elements	*/
							NULL,				/* Value		*/
							4,					/* ObjectSize	*/
							CurOffset,			/* Offset 		*/
							s->StaticName,		/* StaticName	*/
							s->Base,			/* Base			*/
							s->Fields,			/* Fields		*/
							s->FieldCnt			/* FieldCnt		*/
						);
						d = SymbolTable;
						d->u.proc.returns = hlastrdup2( "" );
						d->u.proc.use = s->u.proc.use;
						d->u.proc.parms = s->u.proc.parms;
						d->u.proc.Locals = s->u.proc.Locals;
						d->u.proc.Forward = s->u.proc.Forward;
						d->u.proc.BaseClass = s->u.proc.BaseClass;
						d->u.proc.ParmSize = s->u.proc.ParmSize;
						d->u.proc.cs = s->u.proc.cs;

						// Insert a dummy type for the parameter list.
						
						InsertSym
						(
							" (procptr type) ", 
							NULL,				/* Type			*/
							tProcptr,		 	/* pType		*/
							cType,				/* SymClass		*/ 
							0,					/* Arity		*/
							NULL,				/* dimensions	*/
							0,					/* # elements	*/
							NULL,				/* Value		*/
							4,					/* ObjectSize	*/
							0,					/* Offset 		*/
							NULL,				/* StaticName	*/
							NULL,				/* Base			*/
							NULL,				/* Fields		*/
							0					/* FieldCnt		*/
						);
						SymbolTable->u.proc.parms = s->u.proc.parms;
						SymbolTable->u.proc.returns = d->u.proc.returns;
						SymbolTable->u.proc.use = s->u.proc.use;
						SymbolTable->u.proc.Locals = s->u.proc.Locals;
						SymbolTable->u.proc.Forward = s->u.proc.Forward;
						SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
						SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
						SymbolTable->u.proc.cs = s->u.proc.cs;
						d->Type = SymbolTable;
						SymbolTable = d;

						HadPassByValRes = 
							HadPassByValRes || (s->pClass == vrp_pc );


					_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

						assert( s->Type != NULL );
						CurOffset = CurOffset - s->Type->ObjectSize;
						InsertSym
						(
							s->TrueName, 
							s->Type,			/* Type			*/
							s->Type->pType, 	/* pType		*/
							cVar,				/* SymClass		*/ 
							s->Arity,			/* Arity		*/
							s->Dimensions,		/* dimensions	*/
							s->NumElements,		/* # elements	*/
							NULL,				/* Value		*/
							s->Type->ObjectSize,/* ObjectSize	*/
							CurOffset,			/* Offset 		*/
							s->StaticName,		/* StaticName	*/
							s->Base,			/* Base			*/
							s->Fields,			/* Fields		*/
							s->FieldCnt			/* FieldCnt		*/
						);

						HadPassByValRes = 
							HadPassByValRes | (s->pClass == vrp_pc );

					_endif
					s = s->Next;

				_endwhile

			_endif



			/*
			** Compute the number of bytes of local variables
			** and round this number to the larger multiple of
			** four bytes.
			*/

			RoundedOffset = -CurOffset;
			_if( RoundedOffset != ( RoundedOffset & ~3 ))

				RoundedOffset = ( RoundedOffset + 4 ) & ~3;

			_endif

			/*
			** Don't count the size of the display as part
			** of the local variable count.
			*/

			_if( $<options.UseDisplay>9 )

				RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

			_endif

			/*
			** Create a symbol table entry for the # of bytes
			** of local variables in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = RoundedOffset;
			InsertSym
			( 
				"_vars_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);



			/*
			** Output the assembly code for this procedure.
			**
			** For nested procedures (lex level 2 and above)
			** we need to emit the display
			*/


			startCseg();
			_if( $<options.Alignment>9 != 1 )

				EmitAlign( $<options.Alignment>9 ); 

			_endif
			StartProc( $<en.s>6->StaticName );
			_if( $<options.UseFrame>9 && !$<options.UseDisplay>9 )


				/*
				** If we're not building a display, just use the
				** standard entry sequence.
				*/

				StdEntry( RoundedOffset, $<options.NoEnter>9 );

				/*
				** Align the stack on a dword boundary.
				*/

				_if( AlwaysAlignStk  && $<options.AlignStk>9 )

					AlignStack();

				_endif

			_elseif( $<options.UseFrame>9 )

				/*
				** We've got to construct the display.
				*/

				ConstructDisplay
				( 
					CurLexLevel, 
					RoundedOffset,
					$<options.NoEnter>9 
				);

				/*
				** Align the stack on a dword boundary.
				*/

				_if( AlwaysAlignStk && $<options.AlignStk>9 )

					AlignStack();

				_endif


			/*
			** _else
			**
			** 		Don't do anything special if we're not emiting
			**		code to construct the stack frame.  Note that
			**		"noframe" automatically assumes "nodisplay" as
			**		far as code emission is concerned.
			*/

			_endif




			/*
			** If we have any pass by value/result parameters, emit
			** code to copy the data into the local storage allocated
			** to hold the parameter.  Note that we do not copy pass
			** by result parameters here because they are "out only"
			** variables.
			*/

			_if( $<options.UseFrame>9 && HadPassByValRes )

				CopyValResParms( $<en.s>6 );

			_endif






			assert( $<neID.idStr>13 != NULL );

			_if( _strne( $<idStr>2, $<neID.idStr>13 ))

				char msg[ 256 ];

				sprintf
				( 
					msg,
					"Identifier <<%s>> after 'begin' must match "
					"iterator name <<%s>>",
					$<neID.idStr>13,
					$<idStr>2
				);

				yyerror( msg );

			_endif

			/*
			** Check to ensure that all forward declared procedures
			** have been defined prior to code emission.
			*/

			CheckForwardDecls( $<en.s>6 );

			/*
			** Check to make sure all pointer forward references have
			** been resolved.
			*/

			CheckPtrs();

			CurrentContext = $<en.s>6;
			free2( vss $<neID.idStr>13 );

			/*
			** Emit the text associated with the _initialize_ string
			** at this point.
			**
			**	Note: the "InvisibleCode" variable is used by
			**	yyerror to determine if it should print the
			**	_initialize_ string as part of the error message.
			*/

			
			$<s>$ = lookup( "_finalize_", 1 );
			assert( $<s>$ != NULL );
			_if( $<options.UseFrame>9 )
			
				s=$<s>$->Next;
				InvisibleCode = NULL;
				_if
				( 
						s->pType != tString 
					&&	s->pType != tZString 
				)

					WarnNear
					( 
						"_initialize_'s type is not string.  "
						"Initialization ignored.",
						"_initialize_" 
					);

				_elseif( strlen( s->u.strval ) != 0 )

					InvisibleCode = s->u.strval;
					PushBackStr( "\xF3" );
					PushBackStr( s->u.strval );

				_endif
				
			_endif
			_here;

		}

		/*
		** Process the statements in the iterator.
		*/

		Stmts			/* $16 */


		/*
		** Upon encountering the "end" token, check the ID
		** to make sure it matches the iterator name.
		** Just before leaving, restore lex level, offset,
		** direction, and other values saved above.  The
		** other trick this code pulls on its way out is to
		** reset the SymbolTable pointer to point at the
		** original symbol table entry for this iterator
		** (the one entered into the previous lex level).
		** Doing this effectively "hides" all of the symbols
		** introduced in the declaration section from code
		** following this iterator.
		**
		*/
		 
		endTkn 			/* $17 */
		AnyID 			/* $18 */
		Semicolon		/* $19 */
		{				/* $20 */

			_here;
			assert( $<neID.idStr>18 != NULL );

			_if( _strne( $<idStr>2, $<neID.idStr>18 ))

				char msg[ 256 ];

				sprintf
				( 
					msg,
					"Identifier <<%s>> after 'end' must match "
					"iterator name <<%s>>",
					$<neID.idStr>18,
					$<idStr>2
				);

				yyerror( msg );

			_endif


			/*
			** Emit the label at the end of the procedure
			*/

			PushBackStr( "end" );
			_if( $<options.UseFrame>9 )

				char lbl[256];
				
				sprintf( lbl, "x%s" sympost, $<en.s>6->StaticName );
				EmitStmtLbl( lbl );

				/*
				** Deal with the _finalize_ string here.
				*/

				InvisibleCode = NULL;
				_if
				( 
						$<s>15->pType != tString 
					&&	$<s>15->pType != tZString 
				)

					WarnNear
					(
						"_finalize_ must be a string constant.  Value ignored",
						"_finalize_"
					);

				_elseif( strlen( $<s>15->u.strval ) != 0 )

					InvisibleCode = $<s>15->u.strval;
					PushBackStr( "\xF3" );
					PushBackStr( $<s>15->u.strval );

				_endif
				
			_endif
			_here;
		}
		Stmts		/* $21 */
		endTkn		/* $22 Faked by PushBackStr above	*/
		{			/* $22 */

			struct contextListType	*cNode;
			struct SymNode			*s;
			struct SymNode			*d;

			_here;
	
			/*
			** If we've got any pass by value/result or
			** pass by result parameters, we've got to
			** copy the data back to the caller at this point.
			*/

			_if( $<options.UseFrame>9 )

				StoreValResParms( $<en.s>6 );

			_endif




			
			--CurLexLevel;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			



			/*
			** Remove this iterator's local symbols from
			** further consideration in the symbol table.
			*/

			$<en.s>6->u.proc.Locals = SymbolTable;
			SymbolTable = $<en.s>6;


			/*
			** See if there are any outstanding undefined static
			** objects at lex level zero.
			*/

			CurrentContext = $<en.s>6;
			CheckStatic( StaticList, 0 );
			CurrentContext = $<s>5;

			/*
			** See if there are any outstanding forward reference
			** labels.
			*/

			CheckFwdRef();

			/*
			** Output the necessary data to the assembly language
			** file to complete this iterator.
			*/

			_if( $<options.UseFrame>9 )

				IteratorExit( $<v.u.unsval>7 ); 

			_endif
			EndProc( $<en.s>6->StaticName ); 
			endCseg();
			free2( vss $<neID.idStr>18 );


			/*
			** Restore currentNS and inIterator values:
			*/
			
			currentNS = $<en.cns>6;
			inIterator = 0;

			/*
			** Remove the current context from the context stack.
			*/
			
			_if( $<options.UseFrame>9 )

				assert( contextList != NULL );
				cNode = contextList;
				contextList = cNode->Next;

				assert( cNode->label == $<idStr>2 );
				free2( vss cNode->StaticName );

			_endif
			_here;
		}
	;
		 














			 

 /*
 ** Handle a new iterator declaration here.
 */



newProcs:
		UndefinedID 	/* $1 */
		colonIterator	/* $2 */
		
		/*
		** Before going any farther, save the current
		** (previous lex level) variable offset and offset direction,
		** so we can restore all these values when
		** the compiler finishes this iterator.  Note that the
		** compiler saves these values in the attributes of the
		** following grammar symbols.
		*/
		
		SaveOffset		/* $3 */
		SaveDirection	/* $4 */
		SaveContext		/* $5 */

		/*
		** Insert the iterator name into the symbol table at the
		** old lex level.  This will provide access to the procedure's
		** name from outside this procedure. Also, enter the iterator's
		** name into the symbol table at the new lex level to prevent
		** the user from redefining this symbol inside the
		** iterator.
		**
		** Also, set up the offset and direction values as appropriate
		** for processing parameters.  The process the optional
		** parameter list.
		**
		** Also, bump the current lex level up by one.
		*/

		EnterIterName	/* $6 en.s = pointer to sym tbl entry		*/
						/* $6 en.cns = saved currentNS value		*/


		/*
		** Process any formal parameters.
		*/

		OptionalParms 	/* $7 v.u.unsval= #bytes of parameters	*/

		/*
		** Process the optional returns, nonest, and noframe clauses.
		*/

		newProcOptionsSemicolon	/* $8  */

		
		/*
		** Initialize the pointer to the end of the parameters
		** for this procedure.
		** Set up the offset and direction variables to handle
		** local variable declarations.
		** Set up the procedure's "returns" value.  
		*/
		 
		{					/* $9 */

			int 			*dimension;
			struct SymNode 	value;
			struct contextListType	*p;
			char					exitname[ 256 ];
			union YYSTYPE			dummy;

			_here;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_noframe 
				|	specified_nodisplay 
				|	specified_noalignstk 
				|	specified_alignment 
				|	specified_noenter 
				|	specified_noleave 
				|	specified_use
			);


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.  This allows recursive calls
			** to gain access to the parameter list and "returns"
			** value for this procedure.
			*/


			$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>8;
			$<en.s>6->u.proc.parms->u.proc.use = $<options.use>8;

			/*
			** Okay, now set up the pointers for the main
			** symbol table entry.
			*/

			$<en.s>6->u.proc.parms = SymbolTable;
			CurOffsetDir = -1;
			$<en.s>6->u.proc.returns = $<options.returns>8;
			$<en.s>6->u.proc.use = $<options.use>8;
			CurOffset = StartLclOffs;

			// Iterators always use the pascal calling sequence:
			
			$<en.s>6->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>6->u.proc.cs = pascal_cs;

			/*
			** Create a symbol table entry for the "yield" thunk.
			*/

			InsertSym
			( 
				"yield", 
				&thunk_ste,	/* Type			*/
				tThunk, 	/* pType		*/
				cVar,		/* SymClass		*/ 
				0,			/* Arity		*/
				NULL,		/* dimensions	*/
				0, 			/* # elements	*/
				NULL,		/* Value		*/
				8,			/* ObjectSize	*/
				0,			/* Offset 		*/
				NULL,		/* StaticName	*/
				NULL,		/* Base			*/
				NULL,		/* Fields		*/
				0			/* FieldCnt		*/
			);

			/*
			** Thunks (yield) don't have any parameters,
			** but we can't leave proc.parms NULL (since other
			** code treats this as an error).  Just give each
			** Yield thunk a set of local constants which are
			** the lex level zero constants.
			*/
			
			SymbolTable->u.proc.parms = &true_ste;


			_if( $<options.UseDisplay>8 )

				CurOffset -= 4;

				/*
				** Create a symbol table entry for the display.
				*/

				dimension = malloc2( sizeof( int ));
				*dimension = CurLexLevel + 1;
				InsertSym
				( 
					"_display_", 
					&dword_ste,
					tDWord, 
					cVar, 
					1,
					dimension,
					*dimension, 
					NULL,
					*dimension*4,
					CurOffset,
					NULL,
					NULL,
					NULL,
					0
				);
				CurOffset -= CurLexLevel * 4;

			_endif

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);

			value.u.unsval = $<v.u.unsval>7;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);


			/*
			** Add this procedure to the context list so we
			** can bail on this procedure via the EXIT and EXITIF
			** statements.
			*/
			
			_if( $<options.UseFrame>8 )

				p = malloc2( sizeof( struct contextListType ));
				p->Next = contextList;
				p->label = $<idStr>2;

				sprintf( exitname, "x%s" sympost, $<en.s>6->StaticName ); 
				p->StaticName = hlastrdup2( exitname );
				p->LexLevel = CurLexLevel;
				p->IsProc = 1;
				p->HasDisplay = $<options.UseDisplay>8;
				p->SizeParms = $<v.u.unsval>7;
				contextList = p;

			_endif


			_here;
		}

		/*
		** Process this procedure's declarations here.
		*/

		Declarations	/* $10 */
		
		
		/*
		** Upon encountering the "begin" token, check the ID
		** to make sure it matches the procedure name.
		*/
		 
		beginTkn 		/* $11 */
		AnyID 			/* $12 */
		Semicolon		/* $13 */

		{				/* $14 */

			int 			RoundedOffset;
			struct	SymNode	value;
			struct	SymNode	*s;
			struct	SymNode	*bt;
			struct	SymNode	*d;
			int				HadPassByValRes;

			_here;
			inIterator = 1;




			/*
			** Check for pass by value/result or pass by result
			** parameters because we need to allocate local
			** storage for these.
			*/
			
			_if( $<options.UseFrame>8 )

				HadPassByValRes = 0;
				s = $<en.s>6->u.proc.parms;
				_while( s != NULL && s != $<en.s>6 )

					bt = GetBaseType( s );
					_if
					( 
							bt->pType == tProcptr 
						&&	(
									s->pClass == vrp_pc 
								||	s->pClass == result_pc
							)
					)

						CurOffset = CurOffset - 4;
						InsertSym
						(
							s->TrueName, 
							NULL,				/* Type			*/
							tProcptr,		 	/* pType		*/
							cVar,				/* SymClass		*/ 
							s->Arity,			/* Arity		*/
							s->Dimensions,		/* dimensions	*/
							s->NumElements,		/* # elements	*/
							NULL,				/* Value		*/
							4,					/* ObjectSize	*/
							CurOffset,			/* Offset 		*/
							s->StaticName,		/* StaticName	*/
							s->Base,			/* Base			*/
							s->Fields,			/* Fields		*/
							s->FieldCnt			/* FieldCnt		*/
						);
						d = SymbolTable;
						d->u.proc.returns = hlastrdup2( "" );
						d->u.proc.use = s->u.proc.use;
						d->u.proc.parms = s->u.proc.parms;
						d->u.proc.Locals = s->u.proc.Locals;
						d->u.proc.Forward = s->u.proc.Forward;
						d->u.proc.BaseClass = s->u.proc.BaseClass;
						d->u.proc.ParmSize = s->u.proc.ParmSize;
						d->u.proc.cs = s->u.proc.cs;

						// Insert a dummy type for the parameter list.
						
						InsertSym
						(
							" (procptr type) ", 
							NULL,				/* Type			*/
							tProcptr,		 	/* pType		*/
							cType,				/* SymClass		*/ 
							0,					/* Arity		*/
							NULL,				/* dimensions	*/
							0,					/* # elements	*/
							NULL,				/* Value		*/
							4,					/* ObjectSize	*/
							0,					/* Offset 		*/
							NULL,				/* StaticName	*/
							NULL,				/* Base			*/
							NULL,				/* Fields		*/
							0					/* FieldCnt		*/
						);
						SymbolTable->u.proc.parms = s->u.proc.parms;
						SymbolTable->u.proc.returns = d->u.proc.returns;
						SymbolTable->u.proc.use = s->u.proc.use;
						SymbolTable->u.proc.Locals = s->u.proc.Locals;
						SymbolTable->u.proc.Forward = s->u.proc.Forward;
						SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
						SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
						SymbolTable->u.proc.cs = s->u.proc.cs;
						d->Type = SymbolTable;
						SymbolTable = d;

						HadPassByValRes = 
							HadPassByValRes || (s->pClass == vrp_pc );


					_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

						assert( s->Type != NULL );
						CurOffset = CurOffset - s->Type->ObjectSize;
						InsertSym
						(
							s->TrueName, 
							s->Type,			/* Type			*/
							s->Type->pType, 	/* pType		*/
							cVar,				/* SymClass		*/ 
							s->Arity,			/* Arity		*/
							s->Dimensions,		/* dimensions	*/
							s->NumElements,		/* # elements	*/
							NULL,				/* Value		*/
							s->Type->ObjectSize,/* ObjectSize	*/
							CurOffset,			/* Offset 		*/
							s->StaticName,		/* StaticName	*/
							s->Base,			/* Base			*/
							s->Fields,			/* Fields		*/
							s->FieldCnt			/* FieldCnt		*/
						);

						HadPassByValRes = 
							HadPassByValRes | (s->pClass == vrp_pc );

					_endif
					s = s->Next;

				_endwhile

			_endif



			/*
			** Compute the number of bytes of local variables
			** and round this number to the larger multiple of
			** four bytes.
			*/

			RoundedOffset = -CurOffset;
			_if( RoundedOffset != ( RoundedOffset & ~3 ))

				RoundedOffset = ( RoundedOffset + 4 ) & ~3;

			_endif

			/*
			** Don't count the size of the display as part
			** of the local variable count.
			*/

			_if( $<options.UseDisplay>8 )

				RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

			_endif

			/*
			** Create a symbol table entry for the # of bytes
			** of local variables in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = RoundedOffset;
			InsertSym
			( 
				"_vars_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);



			/*
			** Output the assembly code for this procedure.
			**
			** For nested procedures (lex level 2 and above)
			** we need to emit the display
			*/


			startCseg();
			_if( $<options.Alignment>8 != 1 )

				EmitAlign( $<options.Alignment>8 ); 

			_endif
			StartProc( $<en.s>6->StaticName );
			_if( $<options.UseFrame>8 && !$<options.UseDisplay>8 )


				/*
				** If we're not building a display, just use the
				** standard entry sequence.
				*/

				StdEntry( RoundedOffset, $<options.NoEnter>8 );

				/*
				** Align the stack on a dword boundary.
				*/

				_if( AlwaysAlignStk  && $<options.AlignStk>8 )

					AlignStack();

				_endif

			_elseif( $<options.UseFrame>8 )

				/*
				** We've got to construct the display.
				*/

				ConstructDisplay
				( 
					CurLexLevel, 
					RoundedOffset,
					$<options.NoEnter>8 
				);

				/*
				** Align the stack on a dword boundary.
				*/

				_if( AlwaysAlignStk && $<options.AlignStk>8 )

					AlignStack();

				_endif


			/*
			** _else
			**
			** 		Don't do anything special if we're not emiting
			**		code to construct the stack frame.  Note that
			**		"noframe" automatically assumes "nodisplay" as
			**		far as code emission is concerned.
			*/

			_endif




			/*
			** If we have any pass by value/result parameters, emit
			** code to copy the data into the local storage allocated
			** to hold the parameter.  Note that we do not copy pass
			** by result parameters here because they are "out only"
			** variables.
			*/

			_if( $<options.UseFrame>8 && HadPassByValRes )

				CopyValResParms( $<en.s>6 );

			_endif






			assert( $<neID.idStr>12 != NULL );

			_if( _strne( $<idStr>2, $<neID.idStr>12 ))

				char msg[ 256 ];

				sprintf
				( 
					msg,
					"Identifier <<%s>> after 'begin' must match "
					"iterator name <<%s>>",
					$<neID.idStr>12,
					$<idStr>2
				);

				yyerror( msg );

			_endif

			/*
			** Check to ensure that all forward declared procedures
			** have been defined prior to code emission.
			*/

			CheckForwardDecls( $<en.s>6 );

			/*
			** Check to make sure all pointer forward references have
			** been resolved.
			*/

			CheckPtrs();

			CurrentContext = $<en.s>6;
			free2( vss $<neID.idStr>12 );

			/*
			** Emit the text associated with the _initialize_ string
			** at this point.
			**
			**	Note: the "InvisibleCode" variable is used by
			**	yyerror to determine if it should print the
			**	_initialize_ string as part of the error message.
			*/

			
			$<s>$ = lookup( "_finalize_", 1 );
			assert( $<s>$ != NULL );
			_if( $<options.UseFrame>8 )
			
				s=$<s>$->Next;
				InvisibleCode = NULL;
				_if
				( 
						s->pType != tString 
					&&	s->pType != tZString 
				)

					WarnNear
					( 
						"_initialize_'s type is not string.  "
						"Initialization ignored.",
						"_initialize_" 
					);

				_elseif( strlen( s->u.strval ) != 0 )

					InvisibleCode = s->u.strval;
					PushBackStr( "\xF3" );
					PushBackStr( s->u.strval );

				_endif
				
			_endif
			_here;

		}

		/*
		** Process the statements in the iterator.
		*/

		Stmts			/* $15 */


		/*
		** Upon encountering the "end" token, check the ID
		** to make sure it matches the iterator name.
		** Just before leaving, restore lex level, offset,
		** direction, and other values saved above.  The
		** other trick this code pulls on its way out is to
		** reset the SymbolTable pointer to point at the
		** original symbol table entry for this iterator
		** (the one entered into the previous lex level).
		** Doing this effectively "hides" all of the symbols
		** introduced in the declaration section from code
		** following this iterator.
		**
		*/
		 
		endTkn 			/* $16 */
		AnyID 			/* $17 */
		Semicolon		/* $18 */
		{				/* $19 */

			_here;
			assert( $<neID.idStr>17 != NULL );

			_if( _strne( $<idStr>2, $<neID.idStr>17 ))

				char msg[ 256 ];

				sprintf
				( 
					msg,
					"Identifier <<%s>> after 'end' must match "
					"iterator name <<%s>>",
					$<neID.idStr>17,
					$<idStr>2
				);

				yyerror( msg );

			_endif


			/*
			** Emit the label at the end of the procedure
			*/

			PushBackStr( "end" );
			_if( $<options.UseFrame>8 )

				char lbl[256];
				
				sprintf( lbl, "x%s" sympost, $<en.s>6->StaticName );
				EmitStmtLbl( lbl );

				/*
				** Deal with the _finalize_ string here.
				*/

				InvisibleCode = NULL;
				_if
				( 
						$<s>14->pType != tString 
					&&	$<s>14->pType != tZString 
				)

					WarnNear
					(
						"_finalize_ must be a string constant.  Value ignored",
						"_finalize_"
					);

				_elseif( strlen( $<s>14->u.strval ) != 0 )

					InvisibleCode = $<s>14->u.strval;
					PushBackStr( "\xF3" );
					PushBackStr( $<s>14->u.strval );

				_endif
				
			_endif
			_here;
		}
		Stmts		/* $20 */
		endTkn		/* $21 Faked by PushBackStr above	*/
		{			/* $22 */

			struct contextListType	*cNode;
			struct SymNode			*s;
			struct SymNode			*d;

			_here;
	
			/*
			** If we've got any pass by value/result or
			** pass by result parameters, we've got to
			** copy the data back to the caller at this point.
			*/

			_if( $<options.UseFrame>8 )

				StoreValResParms( $<en.s>6 );

			_endif




			
			--CurLexLevel;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			



			/*
			** Remove this iterator's local symbols from
			** further consideration in the symbol table.
			*/

			$<en.s>6->u.proc.Locals = SymbolTable;
			SymbolTable = $<en.s>6;


			/*
			** See if there are any outstanding undefined static
			** objects at lex level zero.
			*/

			CurrentContext = $<en.s>6;
			CheckStatic( StaticList, 0 );
			CurrentContext = $<s>5;

			/*
			** See if there are any outstanding forward reference
			** labels.
			*/

			CheckFwdRef();

			/*
			** Output the necessary data to the assembly language
			** file to complete this iterator.
			*/

			_if( $<options.UseFrame>8 )

				IteratorExit( $<v.u.unsval>7 ); 

			_endif
			EndProc( $<en.s>6->StaticName ); 
			endCseg();
			free2( vss $<neID.idStr>17 );


			/*
			** Restore currentNS and inIterator values:
			*/
			
			currentNS = $<en.cns>6;
			inIterator = 0;

			/*
			** Remove the current context from the context stack.
			*/
			
			_if( $<options.UseFrame>8 )

				assert( contextList != NULL );
				cNode = contextList;
				contextList = cNode->Next;

				assert( cNode->label == $<idStr>2 );
				free2( vss cNode->StaticName );

			_endif
			_here;
		}
	;
		 







 /*
 ** At this point, handle a procedure declaration that is
 ** a member of a class.
 */

procs:		procedureTkn		/* $1 */ 
			ClassProcID			/* $2 */
			SaveOffset 			/* $3 */
			SaveDirection 		/* $4 */
			SaveContext 		/* $5 */
			SaveThisPtr			/* $6 */
			{ $<s>$ = $<s>2; }	/* $7 */ 
			MatchParms			/* $8 */
			{					/* $9 */

				struct SymNode			*s;
				char					msg[ 256 ];
				struct MethodListType	*FindProc;
				struct MethodListType	**PrevPtr;


				_here;

				/*
				** Save the current SymbolTable pointer so we
				** can find the end of the declarations later.
				*/

				$<s>$ = SymbolTable;
				
				/*
				** Point ThisPtr at the current procedure ID
				** so we can access the class' fields (through
				** the proc.BaseClass field).
				*/
				
				ThisPtr = $<s>2->u.proc.BaseClass;

				/*
				** If the proc.Forward field contains NULL, then
				** we've already processed code corresponding to
				** this static procedure.  That means this is the
				** second occurrence of that procedure declaration
				** and we have a duplicate symbol definition.
				*/

				_if( $<s>2->u.proc.Forward == NULL )

					sprintf
					(
						msg,
						"Duplicate symbol <<%s>>",
						$<s>2->TrueName
					);
					yyerror( msg );
						

				_endif

				/*
				** Okay, this is the first declaration
				** of this procedure.  Point the SymbolTable
				** variable at this procedure's local vars
				** (that would just be the parameters, if any,
				** at this point) and mark the procedure as
				** processed.  Also, scan through the MethodList
				** and remove the reference to this procedure.
				*/

				SymbolTable = $<s>2->u.proc.Locals;
				$<s>2->u.proc.Forward = NULL;

				/*
				** Okay, remove the reference to this procedure
				** from the MethodList.
				*/

				FindProc = MethodList;
				PrevPtr = &MethodList;
				_while
				(
						FindProc != NULL 
					&&	FindProc->MethodSym != $<s>2 
				)

					PrevPtr = &FindProc->Next;
					FindProc = FindProc->Next;

				_endwhile

				_if( FindProc != NULL )

					*PrevPtr = FindProc->Next;
					free2( vss FindProc );

				_else

					yyerror
					( 
						"This class procedure has not been overridden" 
					);

				_endif


				/*
				** NULL terminate the local symbols for
				** use by FixSymbols
				*/

				s = SymbolTable;
				_while( s != NULL && s->Next != $<s>2 )

					s = s->Next;

				_endwhile
				_if( s != NULL )

					s->Next = NULL;

				_endif

				_if( CurLexLevel != $<s>2->u.proc.BaseClass->LexLevel )

					yyerror
					( 
						"Class procedure declared at different lex level" 
					);

				_endif
				++CurLexLevel;
				CurOffset = StartLclOffs;
				CurOffsetDir = -1;
				_here;
			}
			Semicolon			/* $10 */
			Options				/* $11 */
			{					/* $12 */

				char 					msg[ 256 ];
				int	 					*dimension;
				struct	SymNode			*s;
				struct contextListType	*p;
				char					exitname[ 256 ];

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>11,
						specified_returns
					|	specified_use
					|	specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_noenter 
					|	specified_noleave
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_alignment 
				);
				CurrentContext = $<s>2;
				_if( _strne( $<options.returns>11, "" ))

					yyerror( "\"returns\" clause not allowed here" );
					free2( vss $<options.returns>11 );

				_endif


				_if( $<options.UseDisplay>11 )

					CurOffset -= ( CurLexLevel + 1 ) * 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);

				_endif





				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>11 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>2->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>2->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>11;
					p->SizeParms = $<s>2->u.proc.ParmSize;
					contextList = p;

				_endif

				$<s>$ = $<s>9; /* Required by FixSymbols */
				_here;
			}

			/*
			** Reconnect the surrounding symbols with this class proc's
			** local symbols:
			*/

			FixSymbols		/* $13 */
			
			
			saveCurNS		/* $14 */

			 
			/*
			** Process this procedure's declarations here.
			*/

			Declarations	/* $15 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 		/* $16 */
 			AnyID			/* $17 */
  			Semicolon		/* $18 */
 			{				/* $19 */

				struct SymNode	*CurSym;
				int				RoundedOffset;
				struct SymNode	value;
				struct SymNode	*s;

				int				HadPassByValRes;
				struct SymNode	*d;

				_here;
				inProcedure = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>11 )

					HadPassByValRes = 0;
					s = $<s>2->u.proc.parms;
					_while( s != NULL && s != $<s>2 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = SymbolTable;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;


							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif


				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, don't factor its size into
				** the # of bytes of local variables.
				*/

				_if( $<options.UseDisplay>11 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>2->IsExternal )

					EmitPublic( $<s>2->StaticName ); 

				_endif

				startCseg();
				_if( $<options.Alignment>11 != 1 )

					EmitAlign( $<options.Alignment>11 );

				_endif
				StartProc( $<s>2->StaticName ); 
				_if( $<options.UseFrame>11 && !$<options.UseDisplay>11 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>11 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>11 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>11 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>11 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>11 )

						AlignStack();

					_endif

				_endif






				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>11 && HadPassByValRes )

					CopyValResParms( $<s>2 );

				_endif








				assert( $<neID.idStr>17 != NULL );

				_if( _strne( $<s>2->TrueName, $<neID.idStr>17 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"procedure name <<%s>>",
						$<neID.idStr>17,
						$<s>2->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Set up the Locals pointer to point at the
				** newly acquired local variables.
				*/

				$<s>2->u.proc.Locals = SymbolTable;


				/*
				** Check to ensure that all forward declared procedures
				** have been defined prior to code emission.
				*/

			
				CheckForwardDecls( $<s>9 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				/*
				** CurrentContext = $<s>2;
				*/

				free2( vss $<neID.idStr>17 );


				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/
				
				$<s>$ = lookup( "_finalize_", 1 );
				_if( $<options.UseFrame>11 )
				
					assert( $<s>$ != NULL );
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;

			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts	/* $20 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn		/* $21 */ 
			AnyID		/* $22 */
			Semicolon	/* $23 */
			{			/* $24 */

				_here;
				assert( $<neID.idStr>22 != NULL );

				_if( _strne( $<s>2->TrueName, $<neID.idStr>22 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"procedure name <<%s>>",
						$<neID.idStr>22,
						$<s>2->TrueName
					);

					yyerror( msg );

				_endif


				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>11 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>2->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					( 
							$<s>19->pType != tString 
						&&	$<s>19->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>19->u.strval ) != 0 )

						InvisibleCode = $<s>19->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>19->u.strval );

					_endif
					
				_endif
				_here;
			}
			Stmts		/* $25 */
			endTkn		/* $26 Faked by PushBackStr above	*/
			{			/* $27 */


				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;


				_here;

	
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>11 )

					StoreValResParms( $<s>2 );

				_endif




				--CurLexLevel;
				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				ThisPtr = $<s>6;


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				//$<s>2->u.proc.BaseClass->u.proc.Locals = SymbolTable;
				$<s>2->u.proc.Locals = SymbolTable;
				$<s>13->Next = NULL;
				SymbolTable = $<s>9;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/


				CurrentContext = $<s>2->u.proc.BaseClass;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;



				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>11 )

					StdExit
					( 
						$<s>2->u.proc.ParmSize, 
						$<s>2->u.proc.cs == cdecl_cs,
						$<options.NoLeave>11 
					); 

				_endif
				EndProc( $<s>2->StaticName ); 
				endCseg();


				
				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();

				free2( vss $<neID.idStr>22 );

				/*
				** Restore currentNS:
				*/
				
				currentNS = $<ru.saveCurNS>14;
				
				
				
				inProcedure = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>11 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>2->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				(void) $<s>7;	// To shut up bison
				(void) $<s>12;
				_here;
			}
	;




// Handle class procedure declarations using the new procedure syntax:

			
newProcs:	ClassProcID			/* $1  */
			':'					/* $2  */ 
			procedureTkn		/* $3  */
			SaveOffset 			/* $4  */
			SaveDirection 		/* $5  */
			SaveContext 		/* $6  */
			SaveThisPtr			/* $7  */
			{ $<s>$ = $<s>1; }	/* $8  */ 
			MatchParms			/* $9  */
			{					/* $10 */

				struct SymNode			*s;
				char					msg[ 256 ];
				struct MethodListType	*FindProc;
				struct MethodListType	**PrevPtr;


				_here;

				/*
				** Save the current SymbolTable pointer so we
				** can find the end of the declarations later.
				*/

				$<s>$ = SymbolTable;
				
				/*
				** Point ThisPtr at the current procedure ID
				** so we can access the class' fields (through
				** the proc.BaseClass field).
				*/
				
				ThisPtr = $<s>1->u.proc.BaseClass; 

				/*
				** If the proc.Forward field contains NULL, then
				** we've already processed code corresponding to
				** this static procedure.  That means this is the
				** second occurrence of that procedure declaration
				** and we have a duplicate symbol definition.
				*/

				_if( $<s>1->u.proc.Forward == NULL )

					sprintf
					(
						msg,
						"Duplicate symbol <<%s>>",
						$<s>1->TrueName
					);
					yyerror( msg );
						

				_endif

				/*
				** Okay, this is the first declaration
				** of this procedure.  Point the SymbolTable
				** variable at this procedure's local vars
				** (that would just be the parameters, if any,
				** at this point) and mark the procedure as
				** processed.  Also, scan through the MethodList
				** and remove the reference to this procedure.
				*/

				SymbolTable = $<s>1->u.proc.Locals;
				$<s>1->u.proc.Forward = NULL;

				/*
				** Okay, remove the reference to this procedure
				** from the MethodList.
				*/

				FindProc = MethodList;
				PrevPtr = &MethodList;
				_while
				(
						FindProc != NULL 
					&&	FindProc->MethodSym != $<s>1 
				)

					PrevPtr = &FindProc->Next;
					FindProc = FindProc->Next;

				_endwhile

				_if( FindProc != NULL )

					*PrevPtr = FindProc->Next;
					free2( vss FindProc );

				_else

					yyerror
					( 
						"This class procedure has not been overridden" 
					);

				_endif


				/*
				** NULL terminate the local symbols for
				** use by FixSymbols
				*/

				s = SymbolTable;
				_while( s != NULL && s->Next != $<s>1 )

					s = s->Next;

				_endwhile
				_if( s != NULL )

					s->Next = NULL;

				_endif

				_if( CurLexLevel != $<s>1->u.proc.BaseClass->LexLevel )

					yyerror
					( 
						"Class procedure declared at different lex level" 
					);

				_endif
				++CurLexLevel;
				CurOffset = StartLclOffs;
				CurOffsetDir = -1;
				_here;
			}
			newProcOptionsSemicolon		/* $11 */
			{							/* $12 */

				char 					msg[ 256 ];
				int	 					*dimension;
				struct	SymNode			*s;
				struct contextListType	*p;
				char					exitname[ 256 ];

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>11,
						specified_returns
					|	specified_use
					|	specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_noenter 
					|	specified_noleave
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_alignment 
				);
				CurrentContext = $<s>1;
				_if( _strne( $<options.returns>11, "" ))

					yyerror( "\"returns\" clause not allowed here" );
					free2( vss $<options.returns>11 );

				_endif


				_if( $<options.UseDisplay>11 )

					CurOffset -= ( CurLexLevel + 1 ) * 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);

				_endif





				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>11 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>1->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>1->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>11;
					p->SizeParms = $<s>1->u.proc.ParmSize;
					contextList = p;

				_endif

				$<s>$ = $<s>10; /* Required by FixSymbols */
				_here;
			}

			/*
			** Reconnect the surrounding symbols with this class proc's
			** local symbols:
			*/

			FixSymbols		/* $13 */
			
			
			saveCurNS		/* $14 */

			 
			/*
			** Process this procedure's declarations here.
			*/

			Declarations	/* $15 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 		/* $16 */
 			AnyID			/* $17 */
  			Semicolon		/* $18 */
 			{				/* $19 */

				struct SymNode	*CurSym;
				int				RoundedOffset;
				struct SymNode	value;
				struct SymNode	*s;

				int				HadPassByValRes;
				struct SymNode	*d;

				_here;
				inProcedure = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>11 )

					HadPassByValRes = 0;
					s = $<s>1->u.proc.parms;
					_while( s != NULL && s != $<s>1 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = SymbolTable;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;


							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif


				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, don't factor its size into
				** the # of bytes of local variables.
				*/

				_if( $<options.UseDisplay>11 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>1->IsExternal )

					EmitPublic( $<s>1->StaticName ); 

				_endif

				startCseg();
				_if( $<options.Alignment>11 != 1 )

					EmitAlign( $<options.Alignment>11 );

				_endif
				StartProc( $<s>1->StaticName ); 
				_if( $<options.UseFrame>11 && !$<options.UseDisplay>11 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>11 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>11 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>11 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>11 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>11 )

						AlignStack();

					_endif

				_endif






				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>11 && HadPassByValRes )

					CopyValResParms( $<s>1 );

				_endif








				assert( $<neID.idStr>17 != NULL );

				_if( _strne( $<s>1->TrueName, $<neID.idStr>17 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"procedure name <<%s>>",
						$<neID.idStr>17,
						$<s>1->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Set up the Locals pointer to point at the
				** newly acquired local variables.
				*/

				$<s>1->u.proc.Locals = SymbolTable;


				/*
				** Check to ensure that all forward declared procedures
				** have been defined prior to code emission.
				*/

			
				CheckForwardDecls( $<s>10 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				/*
				** CurrentContext = $<s>2;
				*/

				free2( vss $<neID.idStr>17 );


				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/
				
				$<s>$ = lookup( "_finalize_", 1 );
				_if( $<options.UseFrame>11 )
				
					assert( $<s>$ != NULL );
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;

			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts	/* $20 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn		/* $21 */ 
			AnyID		/* $22 */
			Semicolon	/* $23 */
			{			/* $24 */

				_here;
				assert( $<neID.idStr>22 != NULL );

				_if( _strne( $<s>1->TrueName, $<neID.idStr>22 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"procedure name <<%s>>",
						$<neID.idStr>22,
						$<s>1->TrueName
					);

					yyerror( msg );

				_endif


				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>11 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>2->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					( 
							$<s>19->pType != tString 
						&&	$<s>19->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>19->u.strval ) != 0 )

						InvisibleCode = $<s>19->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>19->u.strval );

					_endif
					
				_endif
				_here;
			}
			Stmts		/* $25 */
			endTkn		/* $26 Faked by PushBackStr above	*/
			{			/* $27 */


				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;


				_here;

	
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>11 )

					StoreValResParms( $<s>1 );

				_endif




				--CurLexLevel;
				CurOffset = $<v.u.unsval>4;
				CurOffsetDir = $<v.u.unsval>5;
				ThisPtr = $<s>7;


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				//$<s>2->u.proc.BaseClass->u.proc.Locals = SymbolTable;
				$<s>1->u.proc.Locals = SymbolTable;
				$<s>13->Next = NULL;
				SymbolTable = $<s>10;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/


				CurrentContext = $<s>1->u.proc.BaseClass;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>6;



				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>11 )

					StdExit
					( 
						$<s>1->u.proc.ParmSize, 
						$<s>1->u.proc.cs == cdecl_cs,
						$<options.NoLeave>11 
					); 

				_endif
				EndProc( $<s>1->StaticName ); 
				endCseg();


				
				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();

				free2( vss $<neID.idStr>22 );

				/*
				** Restore currentNS:
				*/
				
				currentNS = $<ru.saveCurNS>14;
				
				
				
				inProcedure = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>11 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>1->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				(void) $<s>8;	// To shut up bison
				(void) $<s>12;
				_here;
			}
	;


			

 /*
 ** At this point, handle a method declaration that is
 ** a member of a class.
 */

procs:		methodTkn			/* $1 */
			ClassMethodID	    /* $2 */
			SaveOffset 			/* $3 */
			SaveDirection 		/* $4 */
			SaveContext 		/* $5 */
			SaveThisPtr			/* $6 */
			{ $<s>$ = $<s>2; }	/* $7 */
			MatchParms			/* $8 */
			{					/* $9 */

				char msg[ 256 ];

				_here;
				
				/*
				** Save the current SymbolTable pointer so we
				** can find the end of the declarations later.
				*/

				$<s>$ = SymbolTable;
				
				_if( $<s>2->IsReferenced != NULL )
				
					$<s>2->IsReferenced->IsPublic = 1;
					
				_endif
								
				/*
				** Point ThisPtr at the current procedure ID
				** so we can access the class' fields (through
				** the proc.BaseClass field).
				*/
				
				ThisPtr = $<s>2->u.proc.BaseClass; 
				

				_if( $<s>2->u.proc.Forward == NULL )

					sprintf
					(
						msg,
						"Duplicate symbol <<%s>>",
						$<s>2->TrueName
					);
					yyerror( msg );
					SymbolTable = $<s>2->u.proc.Locals;
						

				_else

					struct MethodListType	*FindProc;
					struct MethodListType	**PrevPtr;
					struct SymNode			*s;

					/*
					** Okay, this is the first declaration
					** of this method.  Point the SymbolTable
					** variable at this method's local vars
					** (that would just be the parameters, if any,
					** at this point) and mark the method as
					** processed.  Also, scan through the MethodList
					** and remove the reference to this method.
					*/

					SymbolTable = $<s>2->u.proc.Locals;
					$<s>2->u.proc.Forward = NULL;

					/*
					** Okay, remove the reference to this procedure
					** from the MethodList.
					*/

					FindProc = MethodList;
					PrevPtr = &MethodList;
					_while
					(
							FindProc != NULL 
						&&	FindProc->MethodSym != $<s>2 
					)

						PrevPtr = &FindProc->Next;
						FindProc = FindProc->Next;

					_endwhile
					_if( FindProc != NULL )

						*PrevPtr = FindProc->Next;
						free2( vss FindProc );

					_else

						yyerror
						( 
							"This class method has not been overridden" 
						);

					_endif


					/*
					** NULL terminate the local symbols for
					** use by FixSymbols
					*/

					s = SymbolTable;
					_while( s != NULL && s->Next != $<s>2 )

						s = s->Next;

					_endwhile
					_if( s != NULL )

						s->Next = NULL;

					_endif


				_endif
				_if( CurLexLevel != $<s>2->u.proc.BaseClass->LexLevel )

					yyerror
					( 
						"Class method declared at different lex level" 
					);

				_endif
				++CurLexLevel;
				CurOffset = StartLclOffs;
				CurOffsetDir = -1;
				_here;

			}
			Semicolon			/* $10 */
			Options				/* $11 */
			{					/* $12 */

				int	 *dimension;
				struct contextListType	*p;
				char					exitname[ 256 ];

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>11,
						specified_returns
					|	specified_use
					|	specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_noenter 
					|	specified_noleave
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_alignment 
				);
				CurrentContext = $<s>2;

				$<s>$ = $<s>9; /* Required by FixSymbols */



				_if( _strne( $<options.returns>11, "" ))

					yyerror( "\"returns\" clause not allowed here" );
					free2( vss $<options.returns>11 );

				_endif


				_if( $<options.UseDisplay>11 )

					CurOffset -= ( CurLexLevel + 1 ) * 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);

				_endif



				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>11 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>2->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>2->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>11;
					p->SizeParms = $<s>2->u.proc.ParmSize;
					contextList = p;

				_endif
				_here;
			}

			/*
			** Reconnect local symbols to the main symbol
			** table chain.  Return a pointer to the last
			** item in the local symbols list in the attribute.
			*/

			FixSymbols			/* $13 */
			
			/*
			** Save currentNS
			*/
			
			saveCurNS			/* $14 */
			 
			 
			/*
			** Process this method's declarations here.
			*/

			Declarations		/* $15 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the method name.
			*/
			 
			beginTkn 			/* $16 */
 			AnyID				/* $17 */
  			Semicolon			/* $18 */
 			{					/* $19 */

				struct SymNode  *CurSym;
				int				RoundedOffset;
				struct SymNode	value;
				struct SymNode	*s;


				int				HadPassByValRes;
				struct SymNode	*d;

				_here;
				inMethod = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>11 )

					HadPassByValRes = 0;
					s = $<s>2->u.proc.parms;
					_while( s != NULL && s != $<s>2 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
	
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;

							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif
						( 
								s->pClass == vrp_pc 
							||	s->pClass == result_pc  
						)

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif



				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, don't factor its size into
				** the # of bytes of local variables.
				*/

				_if( $<options.UseDisplay>11 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/
				
				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);

				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>2->IsExternal )

					EmitPublic( $<s>2->StaticName );

				_endif
				startCseg();
				_if( $<options.Alignment>11 != 1 )

					EmitAlign( $<options.Alignment>11 );

				_endif
				StartProc( $<s>2->StaticName ); 
				_if( $<options.UseFrame>11 && !$<options.UseDisplay>11 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>11 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>11 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>11 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>11
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>11 )

						AlignStack();

					_endif

				_endif




				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>11 && HadPassByValRes )

					CopyValResParms( $<s>2 );

				_endif




				assert( $<neID.idStr>17 != NULL );

				_if( _strne( $<s>2->TrueName, $<neID.idStr>17 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"method name <<%s>>",
						$<neID.idStr>17,
						$<s>2->TrueName
					);

					yyerror( msg );

				_endif


				/*
				** Set up the Locals pointer to point at the
				** newly acquired local variables.
				*/

				$<s>2->u.proc.Locals = SymbolTable;


				/*
				** Check to ensure that all forward declared methods
				** have been defined prior to code emission.
				*/

			
				CheckForwardDecls( $<s>12 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				free2( vss $<neID.idStr>17 );

				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				assert( $<s>$ != NULL );
				_if( $<options.UseFrame>11 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;


			}

			/*
			** Process the statements in the method.
			*/

			Stmts			/* $20 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the method name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this method
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this method.
			**
			*/
			 
			endTkn 			/* $21 */
			AnyID			/* $22 */
			Semicolon		/* $23 */
			{				/* $24 */

				_here;
				assert( $<neID.idStr>22 != NULL );

				_if( _strne( $<s>2->TrueName, $<neID.idStr>22 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"method name <<%s>>",
						$<neID.idStr>22,
						$<s>2->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>11 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>2->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					( 
							$<s>19->pType != tString 
						&&	$<s>19->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>19->u.strval ) != 0 )

						InvisibleCode = $<s>19->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>19->u.strval );

					_endif
					
				_endif
				_here;
			}
			Stmts		/* $24 */
			endTkn		/* $25 Faked by PushBackStr above	*/
			{			/* $26 */

				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;


				_here;

	
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>11 )

					StoreValResParms( $<s>2 );

				_endif

		

				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				ThisPtr = $<s>6;

				/*
				** Remove this method's local symbols from
				** further consideration in the symbol table.
				*/

				$<s>2->u.proc.Locals = SymbolTable;
				$<s>13->Next = NULL;
				SymbolTable = $<s>12;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<s>2->u.proc.BaseClass;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;

				/*
				** Output the necessary data to the assembly language
				** file to complete this method.
				*/

				_if( $<options.UseFrame>11 )

					StdExit
					( 
						$<s>2->u.proc.ParmSize, 
						$<s>2->u.proc.cs == cdecl_cs,
						$<options.NoLeave>11 
					);

				_endif
				EndProc( $<s>2->StaticName );
				endCseg();


				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();

				free2( vss $<neID.idStr>22 );


				/*
				** Restore currentNS value:
				*/
				
				currentNS = $<ru.saveCurNS>14;
				
				inMethod = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>11 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>2->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				(void) $<s>7;	// Shut up bison
				_here;
			}
	;





// Handle the new syntax for class method declarations:


newProcs:	ClassMethodID	    /* $1  */
			Colon				/* $2  */
			methodTkn			/* $3  */
			SaveOffset 			/* $4  */
			SaveDirection 		/* $5  */
			SaveContext 		/* $6  */
			SaveThisPtr			/* $7  */
			{ $<s>$ = $<s>2; }	/* $8  */
			MatchParms			/* $9  */
			{					/* $10 */

				char msg[ 256 ];

				/*
				** Save the current SymbolTable pointer so we
				** can find the end of the declarations later.
				*/

				_here;
				$<s>$ = SymbolTable;
				
				_if( $<s>1->IsReferenced != NULL )
				
					$<s>1->IsReferenced->IsPublic = 1;
					
				_endif
								
				/*
				** Point ThisPtr at the current procedure ID
				** so we can access the class' fields (through
				** the proc.BaseClass field).
				*/
				
				ThisPtr = $<s>1->u.proc.BaseClass; 
				

				_if( $<s>1->u.proc.Forward == NULL )

					sprintf
					(
						msg,
						"Duplicate symbol <<%s>>",
						$<s>1->TrueName
					);
					yyerror( msg );
					SymbolTable = $<s>1->u.proc.Locals;
						

				_else

					struct MethodListType	*FindProc;
					struct MethodListType	**PrevPtr;
					struct SymNode			*s;

					/*
					** Okay, this is the first declaration
					** of this method.  Point the SymbolTable
					** variable at this method's local vars
					** (that would just be the parameters, if any,
					** at this point) and mark the method as
					** processed.  Also, scan through the MethodList
					** and remove the reference to this method.
					*/

					SymbolTable = $<s>1->u.proc.Locals;
					$<s>1->u.proc.Forward = NULL;

					/*
					** Okay, remove the reference to this procedure
					** from the MethodList.
					*/

					FindProc = MethodList;
					PrevPtr = &MethodList;
					_while
					(
							FindProc != NULL 
						&&	FindProc->MethodSym != $<s>1 
					)

						PrevPtr = &FindProc->Next;
						FindProc = FindProc->Next;

					_endwhile
					_if( FindProc != NULL )

						*PrevPtr = FindProc->Next;
						free2( vss FindProc );

					_else

						yyerror
						( 
							"This class method has not been overridden" 
						);

					_endif


					/*
					** NULL terminate the local symbols for
					** use by FixSymbols
					*/

					s = SymbolTable;
					_while( s != NULL && s->Next != $<s>1 )

						s = s->Next;

					_endwhile
					_if( s != NULL )

						s->Next = NULL;

					_endif


				_endif
				_if( CurLexLevel != $<s>1->u.proc.BaseClass->LexLevel )

					yyerror
					( 
						"Class method declared at different lex level" 
					);

				_endif
				++CurLexLevel;
				CurOffset = StartLclOffs;
				CurOffsetDir = -1;
				_here;

			}
			newProcOptionsSemicolon	/* $11 */
			{						/* $12 */

				int	 *dimension;
				struct contextListType	*p;
				char					exitname[ 256 ];

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>11,
						specified_returns
					|	specified_use
					|	specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_noenter 
					|	specified_noleave
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_alignment 
				);
				CurrentContext = $<s>1;

				$<s>$ = $<s>10; /* Required by FixSymbols */



				_if( _strne( $<options.returns>11, "" ))

					yyerror( "\"returns\" clause not allowed here" );
					free2( vss $<options.returns>11 );

				_endif


				_if( $<options.UseDisplay>11 )

					CurOffset -= ( CurLexLevel + 1 ) * 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);

				_endif



				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>11 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>1->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>1->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>11;
					p->SizeParms = $<s>1->u.proc.ParmSize;
					contextList = p;

				_endif
				_here;
			}

			/*
			** Reconnect local symbols to the main symbol
			** table chain.  Return a pointer to the last
			** item in the local symbols list in the attribute.
			*/

			FixSymbols			/* $13 */
			
			/*
			** Save currentNS
			*/
			
			saveCurNS			/* $14 */
			 
			 
			/*
			** Process this method's declarations here.
			*/

			Declarations		/* $15 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the method name.
			*/
			 
			beginTkn 			/* $16 */
 			AnyID				/* $17 */
  			Semicolon			/* $18 */
 			{					/* $19 */

				struct SymNode  *CurSym;
				int				RoundedOffset;
				struct SymNode	value;
				struct SymNode	*s;


				int				HadPassByValRes;
				struct SymNode	*d;

				_here;
				inMethod = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>11 )

					HadPassByValRes = 0;
					s = $<s>1->u.proc.parms;
					_while( s != NULL && s != $<s>1 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
	
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;

							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif
						( 
								s->pClass == vrp_pc 
							||	s->pClass == result_pc  
						)

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif



				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, don't factor its size into
				** the # of bytes of local variables.
				*/

				_if( $<options.UseDisplay>11 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/
				
				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);

				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>1->IsExternal )

					EmitPublic( $<s>1->StaticName );

				_endif
				startCseg();
				_if( $<options.Alignment>11 != 1 )

					EmitAlign( $<options.Alignment>11 );

				_endif
				StartProc( $<s>1->StaticName ); 
				_if( $<options.UseFrame>11 && !$<options.UseDisplay>11 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>11 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>11 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>11 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>11
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>11 )

						AlignStack();

					_endif

				_endif




				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>11 && HadPassByValRes )

					CopyValResParms( $<s>1 );

				_endif




				assert( $<neID.idStr>17 != NULL );

				_if( _strne( $<s>1->TrueName, $<neID.idStr>17 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"method name <<%s>>",
						$<neID.idStr>17,
						$<s>1->TrueName
					);

					yyerror( msg );

				_endif


				/*
				** Set up the Locals pointer to point at the
				** newly acquired local variables.
				*/

				$<s>1->u.proc.Locals = SymbolTable;


				/*
				** Check to ensure that all forward declared methods
				** have been defined prior to code emission.
				*/

			
				CheckForwardDecls( $<s>12 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				free2( vss $<neID.idStr>17 );

				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				assert( $<s>$ != NULL );
				_if( $<options.UseFrame>11 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;


			}

			/*
			** Process the statements in the method.
			*/

			Stmts			/* $20 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the method name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this method
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this method.
			**
			*/
			 
			endTkn 			/* $21 */
			AnyID			/* $22 */
			Semicolon		/* $23 */
			{				/* $24 */

				_here;
				assert( $<neID.idStr>22 != NULL );

				_if( _strne( $<s>1->TrueName, $<neID.idStr>22 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"method name <<%s>>",
						$<neID.idStr>22,
						$<s>1->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>11 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>1->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					( 
							$<s>19->pType != tString 
						&&	$<s>19->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>19->u.strval ) != 0 )

						InvisibleCode = $<s>19->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>19->u.strval );

					_endif
					
				_endif
				_here;
			}
			Stmts		/* $24 */
			endTkn		/* $25 Faked by PushBackStr above	*/
			{			/* $26 */

				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;


				_here;

	
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>11 )

					StoreValResParms( $<s>1 );

				_endif

		

				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>4;
				CurOffsetDir = $<v.u.unsval>5;
				ThisPtr = $<s>7;

				/*
				** Remove this method's local symbols from
				** further consideration in the symbol table.
				*/

				$<s>1->u.proc.Locals = SymbolTable;
				$<s>13->Next = NULL;
				SymbolTable = $<s>12;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<s>1->u.proc.BaseClass;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>6;

				/*
				** Output the necessary data to the assembly language
				** file to complete this method.
				*/

				_if( $<options.UseFrame>11 )

					StdExit
					( 
						$<s>1->u.proc.ParmSize, 
						$<s>1->u.proc.cs == cdecl_cs,
						$<options.NoLeave>11 
					);

				_endif
				EndProc( $<s>1->StaticName );
				endCseg();


				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();

				free2( vss $<neID.idStr>22 );


				/*
				** Restore currentNS value:
				*/
				
				currentNS = $<ru.saveCurNS>14;
				
				inMethod = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>11 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>1->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				(void) $<s>8;	// Shut up bison
				_here;
			}
	;





 /*
 ** Handle a class iterator declaration here.
 ** Similar to a method declaration, except we need to
 ** define the YIELD thunk.
 */


procs:
		iteratorTkn			/* $1  */
		ClassIterID		    /* $2  */
		SaveOffset 			/* $3  */
		SaveDirection 		/* $4  */
		SaveContext 		/* $5  */
		SaveThisPtr			/* $6  */
		{ $<s>$ = $<s>2; }	/* $7  */
		MatchParms			/* $8  */
		{					/* $9  */

			char msg[ 256 ];

			/*
			** Save the current SymbolTable pointer so we
			** can find the end of the declarations later.
			*/

			_here;
			$<s>$ = SymbolTable;

			/*
			** Save the current SymbolTable pointer so we
			** can find the end of the declarations later.
			*/

			$<s>$ = SymbolTable;
			
			_if( $<s>2->IsReferenced != NULL )
			
				$<s>2->IsReferenced->IsPublic = 1;
				
			_endif
			
			
			/*
			** Point ThisPtr at the current procedure ID
			** so we can access the class' fields (through
			** the proc.BaseClass field).
			*/
			
			ThisPtr = $<s>2->u.proc.BaseClass; 
			
			
			
			 

			_if( $<s>2->u.proc.Forward == NULL )

				sprintf
				(
					msg,
					"Duplicate symbol <<%s>>",
					$<s>2->TrueName
				);
				yyerror( msg );
				SymbolTable = $<s>2->u.proc.Locals;
					

			_else

				struct MethodListType	*FindProc;
				struct MethodListType	**PrevPtr;
				struct SymNode			*s;

				/*
				** Okay, this is the first declaration
				** of this iterator.  Point the SymbolTable
				** variable at this method's local vars
				** (that would just be the parameters, if any,
				** at this point) and mark the iterator as
				** processed.  Also, scan through the MethodList
				** and remove the reference to this iterator.
				*/

				SymbolTable = $<s>2->u.proc.Locals;
				$<s>2->u.proc.Forward = NULL;

				/*
				** Okay, remove the reference to this procedure
				** from the MethodList.
				*/

				FindProc = MethodList;
				PrevPtr = &MethodList;
				_while( FindProc->MethodSym != $<s>2 )

					PrevPtr = &FindProc->Next;
					FindProc = FindProc->Next;
					assert( FindProc != NULL );

				_endwhile
				*PrevPtr = FindProc->Next;
				free2( vss FindProc );


				/*
				** NULL terminate the local symbols for
				** use by FixSymbols
				*/

				s = SymbolTable;
				_while( s != NULL && s->Next != $<s>2 )

					s = s->Next;

				_endwhile
				_if( s != NULL )

					s->Next = NULL;

				_endif


			_endif
			_if( CurLexLevel != $<s>2->u.proc.BaseClass->LexLevel )

				yyerror
				( 
					"Class iterator declared at different lex level" 
				);

			_endif
			CurOffset = StartLclOffs;
			CurOffsetDir = -1;
			++CurLexLevel;

			/*
			** Create a symbol table entry for the "yield" thunk.
			*/

			InsertSym
			( 
				"yield", 
				&thunk_ste,	/* Type			*/
				tThunk, 	/* pType		*/
				cVar,		/* SymClass		*/ 
				0,			/* Arity		*/
				NULL,		/* dimensions	*/
				0, 			/* # elements	*/
				NULL,		/* Value		*/
				8,			/* ObjectSize	*/
				0,			/* Offset 		*/
				NULL,		/* StaticName	*/
				NULL,		/* Base			*/
				NULL,		/* Fields		*/
				0			/* FieldCnt		*/
			);

			/*
			** Thunks (yield) don't have any parameters,
			** but we can't leave proc.parms NULL (since other
			** code treats this as an error).  Just give each
			** Yield thunk a set of local constants which are
			** the lex level zero constants.
			*/
			
			SymbolTable->u.proc.parms = &true_ste;


			_here;
		}
		Semicolon			/* $10 */
		Options				/* $11 */
		{					/* $12 */

			int	 *dimension;
			struct contextListType	*p;
			char					exitname[ 256 ];

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>11,
					specified_returns
				|	specified_use
				|	specified_noframe 
				|	specified_nodisplay 
				|	specified_noalignstk 
				|	specified_noenter 
				|	specified_noleave
				|	specified_pascal
				|	specified_stdcall
				|	specified_cdecl
				|	specified_alignment 
			);
			CurrentContext = $<s>2;

			$<s>$ = $<s>9;  /* Required by FixSymbols and other code */


			_if( _strne( $<options.returns>11, "" ))

				yyerror( "\"returns\" clause not allowed here" );
				free2( vss $<options.returns>11 );

			_endif

			/*
			** Insert an entry for the display, if necessary.
			*/

			_if( $<options.UseDisplay>11 )

				CurOffset -= ( CurLexLevel + 1 ) * 4;
				dimension = malloc2( sizeof( int ));
				*dimension = CurLexLevel + 1;
				InsertSym
				( 
					"_display_", 
					&dword_ste,
					tDWord, 
					cVar, 
					1,
					dimension,
					*dimension, 
					NULL,
					*dimension*4,
					CurOffset,
					NULL,
					NULL,
					NULL,
					0
				);

			_endif



			/*
			** Add this procedure to the context list so we
			** can bail on this procedure via the EXIT and EXITIF
			** statements.
			*/
			
			_if( $<options.UseFrame>11 )

				p = malloc2( sizeof( struct contextListType ));
				p->Next = contextList;
				p->label = $<s>2->TrueName;

				sprintf( exitname, "x%s" sympost, $<s>2->StaticName ); 
				p->StaticName = hlastrdup2( exitname );
				p->LexLevel = CurLexLevel;
				p->IsProc = 1;
				p->HasDisplay = $<options.UseDisplay>11;
				p->SizeParms = $<s>2->u.proc.ParmSize;
				contextList = p;

			_endif
			_here;

		}

		/*
		** Reconnect local symbols to the main symbol
		** table chain.  Return a pointer to the last
		** item in the local symbols list in the attribute.
		*/

		FixSymbols			/* $13 */
		
		saveCurNS			/* $14 */
		 
		 
		/*
		** Process this method's declarations here.
		*/

		Declarations		/* $15 */
		
		
		/*
		** Upon encountering the "begin" token, check the ID
		** to make sure it matches the method name.
		*/
		 
		beginTkn 			/* $16 */
		AnyID				/* $17 */
		Semicolon			/* $18 */
		{					/* $19 */

			struct SymNode *CurSym;
			int				RoundedOffset;
			struct SymNode	value;
			int				HadPassByValRes;
			struct SymNode	*s;
			struct SymNode	*d;

			_here;
			inIterator = 1;


			/*
			** Check for pass by value/result or pass by result
			** parameters because we need to allocate local
			** storage for these.
			*/

			_if( $<options.UseFrame>11 )

				HadPassByValRes = 0;
				s = $<s>2->u.proc.parms;
				_while( s != NULL && s != $<s>2 )

					_if
					( 
							s->pType == tProcptr 
						&&	(
									s->pClass == vrp_pc 
								||	s->pClass == result_pc
							)
					)

						CurOffset = CurOffset - 4;
						InsertSym
						(
							s->TrueName, 
							NULL,				/* Type			*/
							tProcptr,		 	/* pType		*/
							cVar,				/* SymClass		*/ 
							s->Arity,			/* Arity		*/
							s->Dimensions,		/* dimensions	*/
							s->NumElements,		/* # elements	*/
							NULL,				/* Value		*/
							4,					/* ObjectSize	*/
							CurOffset,			/* Offset 		*/
							s->StaticName,		/* StaticName	*/
							s->Base,			/* Base			*/
							s->Fields,			/* Fields		*/
							s->FieldCnt			/* FieldCnt		*/
						);
						d = SymbolTable;
						d->u.proc.returns = hlastrdup2( "" );
						d->u.proc.use = s->u.proc.use;
						d->u.proc.parms = s->u.proc.parms;
						d->u.proc.Locals = s->u.proc.Locals;
						d->u.proc.Forward = s->u.proc.Forward;
						d->u.proc.BaseClass = s->u.proc.BaseClass;
						d->u.proc.ParmSize = s->u.proc.ParmSize;
						d->u.proc.cs = s->u.proc.cs;


						InsertSym
						(
							" (procptr type) ", 
							NULL,				/* Type			*/
							tProcptr,		 	/* pType		*/
							cType,				/* SymClass		*/ 
							0,					/* Arity		*/
							NULL,				/* dimensions	*/
							0,					/* # elements	*/
							NULL,				/* Value		*/
							4,					/* ObjectSize	*/
							0,					/* Offset 		*/
							NULL,				/* StaticName	*/
							NULL,				/* Base			*/
							NULL,				/* Fields		*/
							0					/* FieldCnt		*/
						);
						SymbolTable->u.proc.parms = s->u.proc.parms;
						SymbolTable->u.proc.returns = d->u.proc.returns;
						SymbolTable->u.proc.use = s->u.proc.use;
						SymbolTable->u.proc.Locals = s->u.proc.Locals;
						SymbolTable->u.proc.Forward = s->u.proc.Forward;
						SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
						SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
						SymbolTable->u.proc.cs = s->u.proc.cs;
						d->Type = SymbolTable;
						SymbolTable = d;

						HadPassByValRes = 
							HadPassByValRes || (s->pClass == vrp_pc );


					_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

						assert( s->Type != NULL );
						CurOffset = CurOffset - s->Type->ObjectSize;
						InsertSym
						(
							s->TrueName, 
							s->Type,			/* Type			*/
							s->Type->pType, 	/* pType		*/
							cVar,				/* SymClass		*/ 
							s->Arity,			/* Arity		*/
							s->Dimensions,		/* dimensions	*/
							s->NumElements,		/* # elements	*/
							NULL,				/* Value		*/
							s->Type->ObjectSize,/* ObjectSize	*/
							CurOffset,			/* Offset 		*/
							s->StaticName,		/* StaticName	*/
							s->Base,			/* Base			*/
							s->Fields,			/* Fields		*/
							s->FieldCnt			/* FieldCnt		*/
						);

						HadPassByValRes = 
							HadPassByValRes | (s->pClass == vrp_pc );

					_endif
					s = s->Next;

				_endwhile

			_endif



			/*
			** Compute the number of bytes of local variables
			** and round this number to the larger multiple of
			** four bytes.
			*/

			RoundedOffset = -CurOffset;
			_if( RoundedOffset != ( RoundedOffset & ~3 ))

				RoundedOffset = ( RoundedOffset + 4 ) & ~3;

			_endif

			/*
			** If we have a display, don't factor its size into
			** the # of bytes of local variables.
			*/

			_if( $<options.UseDisplay>11 )

				RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

			_endif

			/*
			** Create a symbol table entry for the # of bytes
			** of local variables in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = RoundedOffset;
			InsertSym
			( 
				"_vars_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);




			/*
			** Output the assembly code for this procedure.
			**
			** For nested procedures (lex level 2 and above)
			** we need to emit the display
			*/

			_if( $<s>2->IsExternal )

				EmitPublic( $<s>2->StaticName );

			_endif
			startCseg();
			_if( $<options.Alignment>11 != 1 )

				EmitAlign( $<options.Alignment>11 );

			_endif
			StartProc( $<s>2->StaticName );
			_if( $<options.UseFrame>11 && !$<options.UseDisplay>11 )


				/*
				** If we're not building a display, just use the
				** standard entry sequence.
				*/

				StdEntry( RoundedOffset, $<options.NoEnter>11 );

				/*
				** Align the stack on a dword boundary.
				*/

				_if( AlwaysAlignStk && $<options.AlignStk>11 )

					AlignStack();

				_endif

			_elseif( $<options.UseFrame>11 )

				/*
				** We've got to construct the display.
				*/

				ConstructDisplay
				( 
					CurLexLevel, 
					RoundedOffset,
					$<options.NoEnter>11 
				);

				/*
				** Align the stack on a dword boundary.
				*/

				_if( AlwaysAlignStk && $<options.AlignStk>11 )

					AlignStack();

				_endif

			_endif





			/*
			** If we have any pass by value/result parameters, emit
			** code to copy the data into the local storage allocated
			** to hold the parameter.  Note that we do not copy pass
			** by result parameters here because they are "out only"
			** variables.
			*/

			_if( $<options.UseFrame>11 && HadPassByValRes )

				CopyValResParms( $<s>2 );

			_endif





			assert( $<neID.idStr>17 != NULL );

			_if( _strne( $<s>2->TrueName, $<neID.idStr>17 ))

				char msg[ 256 ];

				sprintf
				( 
					msg,
					"Identifier <<%s>> after 'begin' must match "
					"iterator name <<%s>>",
					$<neID.idStr>17,
					$<s>2->TrueName
				);

				yyerror( msg );

			_endif


			/*
			** Set up the Locals pointer to point at the
			** newly acquired local variables.
			*/

			$<s>2->u.proc.Locals = SymbolTable;


			/*
			** Check to ensure that all forward declared symbols
			** have been defined prior to code emission.
			*/

		
			CheckForwardDecls( $<s>12 );

			/*
			** Check to make sure all pointer forward references have
			** been resolved.
			*/

			CheckPtrs();

			free2( vss $<neID.idStr>17 );

			/*
			** Emit the text associated with the _initialize_ string
			** at this point.
			**
			**	Note: the "InvisibleCode" variable is used by
			**	yyerror to determine if it should print the
			**	_initialize_ string as part of the error message.
			*/

			
			$<s>$ = lookup( "_finalize_", 1 );
			assert( $<s>$ != NULL );
			_if( $<options.UseFrame>11 )
			
				s=$<s>$->Next;
				InvisibleCode = NULL;
				_if
				( 
						s->pType != tString 
					&&	s->pType != tZString 
				)

					WarnNear
					( 
						"_initialize_'s type is not string.  "
						"Initialization ignored.",
						"_initialize_" 
					);

				_elseif( strlen( s->u.strval ) != 0 )

					InvisibleCode = s->u.strval;
					PushBackStr( "\xF3" );
					PushBackStr( s->u.strval );

				_endif
				
			_endif
			_here;

		}

		/*
		** Process the statements in the iterator.
		*/

		Stmts			/* $20 */


		/*
		** Upon encountering the "end" token, check the ID
		** to make sure it matches the iterator name.
		** Just before leaving, restore lex level, offset,
		** direction, and other values saved above.  The
		** other trick this code pulls on its way out is to
		** reset the SymbolTable pointer to point at the
		** original symbol table entry for this iterator
		** (the one entered into the previous lex level).
		** Doing this effectively "hides" all of the symbols
		** introduced in the declaration section from code
		** following this iterator.
		**
		*/
		 
		endTkn 			/* $21 */
		AnyID			/* $22 */
		Semicolon		/* $23 */
		{				/* $24 */

			_here;
			assert( $<neID.idStr>22 != NULL );

			_if( _strne( $<s>2->TrueName, $<neID.idStr>22 ))

				char msg[ 256 ];

				sprintf
				( 
					msg,
					"Identifier <<%s>> after 'end' must match "
					"iterator name <<%s>>",
					$<neID.idStr>22,
					$<s>2->TrueName
				);

				yyerror( msg );

			_endif


			/*
			** Emit the label at the end of the procedure
			*/

			PushBackStr( "end" );
			_if( $<options.UseFrame>11 )

				char lbl[256];
				
				sprintf( lbl, "x%s" sympost, $<s>2->StaticName );
				EmitStmtLbl( lbl );

	
				/*
				** Deal with the _finalize_ string here.
				*/

				InvisibleCode = NULL;
				_if
				( 
						$<s>19->pType != tString 
					&&	$<s>19->pType != tZString 
				)

					WarnNear
					(
						"_finalize_ must be a string constant.  Value ignored",
						"_finalize_"
					);

				_elseif( strlen( $<s>19->u.strval ) != 0 )

					InvisibleCode = $<s>19->u.strval;
					PushBackStr( "\xF3" );
					PushBackStr( $<s>19->u.strval );

				_endif
			
			_endif

		}
		Stmts		/* $25 */
		endTkn		/* $26 Faked by PushBackStr above	*/
		{			/* $27 */

			struct contextListType	*cNode;
			struct SymNode			*s;
			struct SymNode			*d;


			_here;

	
			/*
			** If we've got any pass by value/result or
			** pass by result parameters, we've got to
			** copy the data back to the caller at this point.
			*/

			_if( $<options.UseFrame>11 )

					StoreValResParms( $<s>2 );

			_endif


			
			--CurLexLevel;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			ThisPtr = $<s>6;

			/*
			** Remove this iterator's local symbols from
			** further consideration in the symbol table.
			*/

			$<s>2->u.proc.Locals = SymbolTable;
			$<s>13->Next = NULL;
			SymbolTable = $<s>12;

			/*
			** See if there are any outstanding undefined static
			** objects at lex level zero.
			*/

			CurrentContext = $<s>2->u.proc.BaseClass;
			CheckStatic( StaticList, 0 );
			CurrentContext = $<s>5;

			/*
			** Output the necessary data to the assembly language
			** file to complete this method.
			*/

			_if( $<options.UseFrame>11 )

				IteratorExit( $<s>2->u.proc.ParmSize ); 

			_endif
			EndProc( $<s>2->StaticName );
			endCseg();


			/*
			** See if there are any outstanding forward reference
			** labels.
			*/

			CheckFwdRef();

			free2( vss $<neID.idStr>22 );


			/*
			** Restore currentNS value:
			*/
			
			currentNS = $<ru.saveCurNS>14;
			
			
			
			inIterator = 0;

			/*
			** Remove the current context from the context stack.
			*/
			
			_if( $<options.UseFrame>11 )

				assert( contextList != NULL );
				cNode = contextList;
				contextList = cNode->Next;

				assert( _streq( cNode->label, $<s>2->TrueName) );
				free2( vss cNode->StaticName );


			_endif
			(void) $<s>7;	// Shut up bison
			_here;
		}
	;
		 



// New syntax version of the class iterator:


colonIterator:	// Sneaky trick to avoid having to change all the $n values
		':'
		iteratorTkn
		{
			_here;
			$<s>$ = $<s>0;
		}
	;

newProcs:
		ClassIterID		    /* $1  */
		colonIterator		/* $2  */
		SaveOffset 			/* $3  */
		SaveDirection 		/* $4  */
		SaveContext 		/* $5  */
		SaveThisPtr			/* $6  */
		{ $<s>$ = $<s>2; }	/* $7  */
		MatchParms			/* $8  */
		{					/* $9  */

			char msg[ 256 ];

			/*
			** Save the current SymbolTable pointer so we
			** can find the end of the declarations later.
			*/

			_here;
			$<s>$ = SymbolTable;

			/*
			** Save the current SymbolTable pointer so we
			** can find the end of the declarations later.
			*/

			$<s>$ = SymbolTable;
			
			_if( $<s>2->IsReferenced != NULL )
			
				$<s>2->IsReferenced->IsPublic = 1;
				
			_endif
			
			
			/*
			** Point ThisPtr at the current procedure ID
			** so we can access the class' fields (through
			** the proc.BaseClass field).
			*/
			
			ThisPtr = $<s>2->u.proc.BaseClass; 
			
			
			
			 

			_if( $<s>2->u.proc.Forward == NULL )

				sprintf
				(
					msg,
					"Duplicate symbol <<%s>>",
					$<s>2->TrueName
				);
				yyerror( msg );
				SymbolTable = $<s>2->u.proc.Locals;
					

			_else

				struct MethodListType	*FindProc;
				struct MethodListType	**PrevPtr;
				struct SymNode			*s;

				/*
				** Okay, this is the first declaration
				** of this iterator.  Point the SymbolTable
				** variable at this method's local vars
				** (that would just be the parameters, if any,
				** at this point) and mark the iterator as
				** processed.  Also, scan through the MethodList
				** and remove the reference to this iterator.
				*/

				SymbolTable = $<s>2->u.proc.Locals;
				$<s>2->u.proc.Forward = NULL;

				/*
				** Okay, remove the reference to this procedure
				** from the MethodList.
				*/

				FindProc = MethodList;
				PrevPtr = &MethodList;
				_while( FindProc->MethodSym != $<s>2 )

					PrevPtr = &FindProc->Next;
					FindProc = FindProc->Next;
					assert( FindProc != NULL );

				_endwhile
				*PrevPtr = FindProc->Next;
				free2( vss FindProc );


				/*
				** NULL terminate the local symbols for
				** use by FixSymbols
				*/

				s = SymbolTable;
				_while( s != NULL && s->Next != $<s>2 )

					s = s->Next;

				_endwhile
				_if( s != NULL )

					s->Next = NULL;

				_endif


			_endif
			_if( CurLexLevel != $<s>2->u.proc.BaseClass->LexLevel )

				yyerror
				( 
					"Class iterator declared at different lex level" 
				);

			_endif
			CurOffset = StartLclOffs;
			CurOffsetDir = -1;
			++CurLexLevel;

			/*
			** Create a symbol table entry for the "yield" thunk.
			*/

			InsertSym
			( 
				"yield", 
				&thunk_ste,	/* Type			*/
				tThunk, 	/* pType		*/
				cVar,		/* SymClass		*/ 
				0,			/* Arity		*/
				NULL,		/* dimensions	*/
				0, 			/* # elements	*/
				NULL,		/* Value		*/
				8,			/* ObjectSize	*/
				0,			/* Offset 		*/
				NULL,		/* StaticName	*/
				NULL,		/* Base			*/
				NULL,		/* Fields		*/
				0			/* FieldCnt		*/
			);

			/*
			** Thunks (yield) don't have any parameters,
			** but we can't leave proc.parms NULL (since other
			** code treats this as an error).  Just give each
			** Yield thunk a set of local constants which are
			** the lex level zero constants.
			*/
			
			SymbolTable->u.proc.parms = &true_ste;


			_here;
		}
		newProcOptionsSemicolon	/* $10 */
		{						/* $11 */

			int	 *dimension;
			struct contextListType	*p;
			char					exitname[ 256 ];

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_returns
				|	specified_use
				|	specified_noframe 
				|	specified_nodisplay 
				|	specified_noalignstk 
				|	specified_noenter 
				|	specified_noleave
				|	specified_pascal
				|	specified_stdcall
				|	specified_cdecl
				|	specified_alignment 
			);
			CurrentContext = $<s>2;

			$<s>$ = $<s>9;  /* Required by FixSymbols and other code */


			_if( _strne( $<options.returns>10, "" ))

				yyerror( "\"returns\" clause not allowed here" );
				free2( vss $<options.returns>10 );

			_endif

			/*
			** Insert an entry for the display, if necessary.
			*/

			_if( $<options.UseDisplay>10 )

				CurOffset -= ( CurLexLevel + 1 ) * 4;
				dimension = malloc2( sizeof( int ));
				*dimension = CurLexLevel + 1;
				InsertSym
				( 
					"_display_", 
					&dword_ste,
					tDWord, 
					cVar, 
					1,
					dimension,
					*dimension, 
					NULL,
					*dimension*4,
					CurOffset,
					NULL,
					NULL,
					NULL,
					0
				);

			_endif



			/*
			** Add this procedure to the context list so we
			** can bail on this procedure via the EXIT and EXITIF
			** statements.
			*/
			
			_if( $<options.UseFrame>10 )

				p = malloc2( sizeof( struct contextListType ));
				p->Next = contextList;
				p->label = $<s>2->TrueName;

				sprintf( exitname, "x%s" sympost, $<s>2->StaticName ); 
				p->StaticName = hlastrdup2( exitname );
				p->LexLevel = CurLexLevel;
				p->IsProc = 1;
				p->HasDisplay = $<options.UseDisplay>10;
				p->SizeParms = $<s>2->u.proc.ParmSize;
				contextList = p;

			_endif
			_here;

		}

		/*
		** Reconnect local symbols to the main symbol
		** table chain.  Return a pointer to the last
		** item in the local symbols list in the attribute.
		*/

		FixSymbols			/* $12 */
		
		saveCurNS			/* $13 */
		 
		 
		/*
		** Process this method's declarations here.
		*/

		Declarations		/* $14 */
		
		
		/*
		** Upon encountering the "begin" token, check the ID
		** to make sure it matches the method name.
		*/
		 
		beginTkn 			/* $15 */
		AnyID				/* $16 */
		Semicolon			/* $17 */
		{					/* $18 */

			struct SymNode *CurSym;
			int				RoundedOffset;
			struct SymNode	value;
			int				HadPassByValRes;
			struct SymNode	*s;
			struct SymNode	*d;

			_here;
			inIterator = 1;


			/*
			** Check for pass by value/result or pass by result
			** parameters because we need to allocate local
			** storage for these.
			*/

			_if( $<options.UseFrame>10 )

				HadPassByValRes = 0;
				s = $<s>2->u.proc.parms;
				_while( s != NULL && s != $<s>2 )

					_if
					( 
							s->pType == tProcptr 
						&&	(
									s->pClass == vrp_pc 
								||	s->pClass == result_pc
							)
					)

						CurOffset = CurOffset - 4;
						InsertSym
						(
							s->TrueName, 
							NULL,				/* Type			*/
							tProcptr,		 	/* pType		*/
							cVar,				/* SymClass		*/ 
							s->Arity,			/* Arity		*/
							s->Dimensions,		/* dimensions	*/
							s->NumElements,		/* # elements	*/
							NULL,				/* Value		*/
							4,					/* ObjectSize	*/
							CurOffset,			/* Offset 		*/
							s->StaticName,		/* StaticName	*/
							s->Base,			/* Base			*/
							s->Fields,			/* Fields		*/
							s->FieldCnt			/* FieldCnt		*/
						);
						d = SymbolTable;
						d->u.proc.returns = hlastrdup2( "" );
						d->u.proc.use = s->u.proc.use;
						d->u.proc.parms = s->u.proc.parms;
						d->u.proc.Locals = s->u.proc.Locals;
						d->u.proc.Forward = s->u.proc.Forward;
						d->u.proc.BaseClass = s->u.proc.BaseClass;
						d->u.proc.ParmSize = s->u.proc.ParmSize;
						d->u.proc.cs = s->u.proc.cs;


						InsertSym
						(
							" (procptr type) ", 
							NULL,				/* Type			*/
							tProcptr,		 	/* pType		*/
							cType,				/* SymClass		*/ 
							0,					/* Arity		*/
							NULL,				/* dimensions	*/
							0,					/* # elements	*/
							NULL,				/* Value		*/
							4,					/* ObjectSize	*/
							0,					/* Offset 		*/
							NULL,				/* StaticName	*/
							NULL,				/* Base			*/
							NULL,				/* Fields		*/
							0					/* FieldCnt		*/
						);
						SymbolTable->u.proc.parms = s->u.proc.parms;
						SymbolTable->u.proc.returns = d->u.proc.returns;
						SymbolTable->u.proc.use = s->u.proc.use;
						SymbolTable->u.proc.Locals = s->u.proc.Locals;
						SymbolTable->u.proc.Forward = s->u.proc.Forward;
						SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
						SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
						SymbolTable->u.proc.cs = s->u.proc.cs;
						d->Type = SymbolTable;
						SymbolTable = d;

						HadPassByValRes = 
							HadPassByValRes || (s->pClass == vrp_pc );


					_elseif( s->pClass == vrp_pc || s->pClass == result_pc  )

						assert( s->Type != NULL );
						CurOffset = CurOffset - s->Type->ObjectSize;
						InsertSym
						(
							s->TrueName, 
							s->Type,			/* Type			*/
							s->Type->pType, 	/* pType		*/
							cVar,				/* SymClass		*/ 
							s->Arity,			/* Arity		*/
							s->Dimensions,		/* dimensions	*/
							s->NumElements,		/* # elements	*/
							NULL,				/* Value		*/
							s->Type->ObjectSize,/* ObjectSize	*/
							CurOffset,			/* Offset 		*/
							s->StaticName,		/* StaticName	*/
							s->Base,			/* Base			*/
							s->Fields,			/* Fields		*/
							s->FieldCnt			/* FieldCnt		*/
						);

						HadPassByValRes = 
							HadPassByValRes | (s->pClass == vrp_pc );

					_endif
					s = s->Next;

				_endwhile

			_endif



			/*
			** Compute the number of bytes of local variables
			** and round this number to the larger multiple of
			** four bytes.
			*/

			RoundedOffset = -CurOffset;
			_if( RoundedOffset != ( RoundedOffset & ~3 ))

				RoundedOffset = ( RoundedOffset + 4 ) & ~3;

			_endif

			/*
			** If we have a display, don't factor its size into
			** the # of bytes of local variables.
			*/

			_if( $<options.UseDisplay>10 )

				RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

			_endif

			/*
			** Create a symbol table entry for the # of bytes
			** of local variables in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = RoundedOffset;
			InsertSym
			( 
				"_vars_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);




			/*
			** Output the assembly code for this procedure.
			**
			** For nested procedures (lex level 2 and above)
			** we need to emit the display
			*/

			_if( $<s>2->IsExternal )

				EmitPublic( $<s>2->StaticName );

			_endif
			startCseg();
			_if( $<options.Alignment>10 != 1 )

				EmitAlign( $<options.Alignment>10 );

			_endif
			StartProc( $<s>2->StaticName );
			_if( $<options.UseFrame>10 && !$<options.UseDisplay>10 )


				/*
				** If we're not building a display, just use the
				** standard entry sequence.
				*/

				StdEntry( RoundedOffset, $<options.NoEnter>10 );

				/*
				** Align the stack on a dword boundary.
				*/

				_if( AlwaysAlignStk && $<options.AlignStk>10 )

					AlignStack();

				_endif

			_elseif( $<options.UseFrame>10 )

				/*
				** We've got to construct the display.
				*/

				ConstructDisplay
				( 
					CurLexLevel, 
					RoundedOffset,
					$<options.NoEnter>10 
				);

				/*
				** Align the stack on a dword boundary.
				*/

				_if( AlwaysAlignStk && $<options.AlignStk>10 )

					AlignStack();

				_endif

			_endif





			/*
			** If we have any pass by value/result parameters, emit
			** code to copy the data into the local storage allocated
			** to hold the parameter.  Note that we do not copy pass
			** by result parameters here because they are "out only"
			** variables.
			*/

			_if( $<options.UseFrame>10 && HadPassByValRes )

				CopyValResParms( $<s>2 );

			_endif





			assert( $<neID.idStr>16 != NULL );

			_if( _strne( $<s>2->TrueName, $<neID.idStr>16 ))

				char msg[ 256 ];

				sprintf
				( 
					msg,
					"Identifier <<%s>> after 'begin' must match "
					"iterator name <<%s>>",
					$<idStr>16,
					$<s>2->TrueName
				);

				yyerror( msg );

			_endif


			/*
			** Set up the Locals pointer to point at the
			** newly acquired local variables.
			*/

			$<s>2->u.proc.Locals = SymbolTable;


			/*
			** Check to ensure that all forward declared symbols
			** have been defined prior to code emission.
			*/

		
			CheckForwardDecls( $<s>11 );

			/*
			** Check to make sure all pointer forward references have
			** been resolved.
			*/

			CheckPtrs();

			free2( vss $<neID.idStr>16 );

			/*
			** Emit the text associated with the _initialize_ string
			** at this point.
			**
			**	Note: the "InvisibleCode" variable is used by
			**	yyerror to determine if it should print the
			**	_initialize_ string as part of the error message.
			*/

			
			$<s>$ = lookup( "_finalize_", 1 );
			assert( $<s>$ != NULL );
			_if( $<options.UseFrame>11 )
			
				s=$<s>$->Next;
				InvisibleCode = NULL;
				_if
				( 
						s->pType != tString 
					&&	s->pType != tZString 
				)

					WarnNear
					( 
						"_initialize_'s type is not string.  "
						"Initialization ignored.",
						"_initialize_" 
					);

				_elseif( strlen( s->u.strval ) != 0 )

					InvisibleCode = s->u.strval;
					PushBackStr( "\xF3" );
					PushBackStr( s->u.strval );

				_endif
				
			_endif
			_here;

		}

		/*
		** Process the statements in the iterator.
		*/

		Stmts			/* $19 */


		/*
		** Upon encountering the "end" token, check the ID
		** to make sure it matches the iterator name.
		** Just before leaving, restore lex level, offset,
		** direction, and other values saved above.  The
		** other trick this code pulls on its way out is to
		** reset the SymbolTable pointer to point at the
		** original symbol table entry for this iterator
		** (the one entered into the previous lex level).
		** Doing this effectively "hides" all of the symbols
		** introduced in the declaration section from code
		** following this iterator.
		**
		*/
		 
		endTkn 			/* $20 */
		AnyID			/* $21 */
		Semicolon		/* $22 */
		{				/* $23 */

			_here;
			assert( $<neID.idStr>21 != NULL );

			_if( _strne( $<s>2->TrueName, $<neID.idStr>21 ))

				char msg[ 256 ];

				sprintf
				( 
					msg,
					"Identifier <<%s>> after 'end' must match "
					"iterator name <<%s>>",
					$<neID.idStr>21,
					$<s>2->TrueName
				);

				yyerror( msg );

			_endif


			/*
			** Emit the label at the end of the procedure
			*/

			PushBackStr( "end" );
			_if( $<options.UseFrame>10 )

				char lbl[256];
				
				sprintf( lbl, "x%s" sympost, $<s>2->StaticName );
				EmitStmtLbl( lbl );

	
				/*
				** Deal with the _finalize_ string here.
				*/

				InvisibleCode = NULL;
				_if
				( 
						$<s>18->pType != tString 
					&&	$<s>18->pType != tZString 
				)

					WarnNear
					(
						"_finalize_ must be a string constant.  Value ignored",
						"_finalize_"
					);

				_elseif( strlen( $<s>18->u.strval ) != 0 )

					InvisibleCode = $<s>18->u.strval;
					PushBackStr( "\xF3" );
					PushBackStr( $<s>18->u.strval );

				_endif
			
			_endif
			_here;
		}
		Stmts		/* $24 */
		endTkn		/* $25 Faked by PushBackStr above	*/
		{			/* $26 */

			struct contextListType	*cNode;
			struct SymNode			*s;
			struct SymNode			*d;


			_here;

	
			/*
			** If we've got any pass by value/result or
			** pass by result parameters, we've got to
			** copy the data back to the caller at this point.
			*/

			_if( $<options.UseFrame>10 )

					StoreValResParms( $<s>2 );

			_endif


			
			--CurLexLevel;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			ThisPtr = $<s>6;

			/*
			** Remove this iterator's local symbols from
			** further consideration in the symbol table.
			*/

			$<s>2->u.proc.Locals = SymbolTable;
			$<s>12->Next = NULL;
			SymbolTable = $<s>11;

			/*
			** See if there are any outstanding undefined static
			** objects at lex level zero.
			*/

			CurrentContext = $<s>2->u.proc.BaseClass;
			CheckStatic( StaticList, 0 );
			CurrentContext = $<s>5;

			/*
			** Output the necessary data to the assembly language
			** file to complete this method.
			*/

			_if( $<options.UseFrame>10 )

				IteratorExit( $<s>2->u.proc.ParmSize ); 

			_endif
			EndProc( $<s>2->StaticName );
			endCseg();


			/*
			** See if there are any outstanding forward reference
			** labels.
			*/

			CheckFwdRef();

			free2( vss $<neID.idStr>21 );


			/*
			** Restore currentNS value:
			*/
			
			currentNS = $<ru.saveCurNS>13;
			
			
			
			inIterator = 0;

			/*
			** Remove the current context from the context stack.
			*/
			
			_if( $<options.UseFrame>10 )

				assert( contextList != NULL );
				cNode = contextList;
				contextList = cNode->Next;

				assert( _streq( cNode->label, $<s>2->TrueName) );
				free2( vss cNode->StaticName );


			_endif
			(void) $<s>7;	// Shut up bison
			_here;
		}
	;
		 












	/*
	** Handle external procedure declarations here.
	*/

procs:		procedureTkn		/* $1  */ 
			UndefinedID 		/* $2  */
			SaveOffset 			/* $3  */
			SaveDirection		/* $4  */
			SaveContext 		/* $5  */
			EnterName			/* $6  */
			OptionalParms 		/* $7  */
			Semicolon			/* $8  */
			Options				/* $9  */
			externalTkn 		/* $10 */
			{ 					/* $11 */
				_here;
				$<idStr>$ = hlastrdup2( $<idStr>2 ); 
			} 
			OptionalExtName 	/* $12 */
			Semicolon			/* $13 */
			{
				struct SymNode	*ParmList;
				struct SymNode	*localProcDcl;
				char			*CurrentType;
				struct SymNode	value;

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_returns 
					|	specified_pascal 
					|	specified_stdcall 
					|	specified_cdecl 
					|	specified_use
				);

				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				--CurLexLevel;

				_if( CurLexLevel != 0 )

					yyerror
					( 
						"External procedures may only be declared "
						"at lex level zero"
					);

				_endif


				// On return. u.proc.parms points at the local
				// declaration for this procedure. Save it so
				// we can use that data later.
				
				localProcDcl = $<en.s>6->u.proc.parms;

				/*
				** Change the static name to correspond to the
				** external name of this procedure.  Note that
				** we need to update the name in two places.
				*/

				free2( vss localProcDcl->StaticName );
				localProcDcl->StaticName = hlastrdup2( $<idStr>12 );

				free2( vss $<en.s>6->StaticName );
				$<en.s>6->StaticName = $<idStr>12;

			
				/*
				** Since this is an external declaration, mark it
				** as such.
				*/

				$<en.s>6->IsExternal = 1;

				/*
				** Update this procedure's "returns" and "use" fields.
				*/

				$<en.s>6->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.use = $<options.use>9;


				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.
				*/


				localProcDcl->u.proc.parms = SymbolTable;
				localProcDcl->u.proc.returns = $<options.returns>9;
				localProcDcl->u.proc.use = $<options.use>9;




				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;


				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a external procedure, so mark it as a forward
				** procedure in the event this external declaration appears
				** within a header file included by the file containing
				** the actual declaration.
				*/

				$<en.s>6->u.proc.Forward = SymbolTable;

				/*
				** Store up the external definition for later emission:
				*/

				EmitTypedExtern( $<en.s>6, $<idStr>12, tLabel );

				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;

				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				localProcDcl->IsExternal = 1;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;
				$<en.s>6->IsReferenced = localProcDcl->IsReferenced;
				



				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:

				$<en.s>6->u.proc.cs = $<options.CallingSequence>9;
				_if
				(
						$<options.CallingSequence>9 == stdcall_cs
					||	$<options.CallingSequence>9 == cdecl_cs
				)

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<en.s>6->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>6 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile


				_endif
				
				
				/*
				** Restore the currentNS value saved in EnterName:
				*/
				
				currentNS = $<en.cns>6;
				(void) $<idStr>11;	// Shut Up Bison				
				_here;
			}
	;




	
			 




	/*
	** Handle external procedure declarations here.
	*/



newProcs:	UndefinedID 			/* $1  */
			colonProcedure			/* $2  */
			SaveOffset 				/* $3  */
			SaveDirection			/* $4  */
			SaveContext 			/* $5  */
			EnterName				/* $6  */
			OptionalParms 			/* $7  */
			newProcOptionsSemicolon	/* $8  */
			externalTkn 			/* $9 */
			{ 						/* $10 */
				_here;
				$<idStr>$ = hlastrdup2( $<idStr>1 ); 
			} 
			OptionalExtName 	/* $11 */
			Semicolon			/* $12 */
			{
				struct SymNode	*ParmList;
				struct SymNode	*localProcDcl;
				char			*CurrentType;
				struct SymNode	value;

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_returns 
					|	specified_pascal 
					|	specified_stdcall 
					|	specified_cdecl 
					|	specified_use
				);

				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				--CurLexLevel;

				_if( CurLexLevel != 0 )

					yyerror
					( 
						"External procedures may only be declared "
						"at lex level zero"
					);

				_endif


				// On return. u.proc.parms points at the local
				// declaration for this procedure. Save it so
				// we can use that data later.
				
				localProcDcl = $<en.s>6->u.proc.parms;

				/*
				** Change the static name to correspond to the
				** external name of this procedure.  Note that
				** we need to update the name in two places.
				*/

				free2( vss localProcDcl->StaticName );
				localProcDcl->StaticName = hlastrdup2( $<idStr>11 );

				free2( vss $<en.s>6->StaticName );
				$<en.s>6->StaticName = $<idStr>11;

			
				/*
				** Since this is an external declaration, mark it
				** as such.
				*/

				$<en.s>6->IsExternal = 1;

				/*
				** Update this procedure's "returns" and "use" fields.
				*/

				$<en.s>6->u.proc.returns 		= $<options.returns>8;
				$<en.s>6->u.proc.use 			= $<options.use>8;


				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.
				*/


				localProcDcl->u.proc.parms = SymbolTable;
				localProcDcl->u.proc.returns = $<options.returns>8;
				localProcDcl->u.proc.use = $<options.use>8;




				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;


				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a external procedure, so mark it as a forward
				** procedure in the event this external declaration appears
				** within a header file included by the file containing
				** the actual declaration.
				*/

				$<en.s>6->u.proc.Forward = SymbolTable;

				/*
				** Store up the external definition for later emission:
				*/

				EmitTypedExtern( $<en.s>6, $<idStr>11, tLabel );

				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;

				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				localProcDcl->IsExternal = 1;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;
				$<en.s>6->IsReferenced = localProcDcl->IsReferenced;
				



				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:

				$<en.s>6->u.proc.cs = $<options.CallingSequence>8;
				localProcDcl->u.proc.cs = $<options.CallingSequence>8;
				_if
				(
						$<options.CallingSequence>9 == stdcall_cs
					||	$<options.CallingSequence>9 == cdecl_cs
				)

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<en.s>6->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>6 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile


				_endif
				
				
				/*
				** Restore the currentNS value saved in EnterName:
				*/
				
				currentNS = $<en.cns>6;
				(void) $<idStr>10;	// Shut Up Bison				
				_here;
			}
	;

	
			 




	/*
	** Handle external procedure declarations here.
	*/

newProcs:	UndefinedID 			/* $1  */
			':'						/* $2  */
			TypeID					/* $3  */
			saveUID					/* $4  */
			SaveOffset 				/* $5  */
			SaveDirection			/* $6  */
			SaveContext 			/* $7  */
			EnterName				/* $8  */
			newProcOptionsSemicolon	/* $9  */
			externalTkn 			/* $10 */
			{ 						/* $11 */
				_here;
				$<idStr>$ = hlastrdup2( $<idStr>1 ); 
			} 
			OptionalExtName 	/* $12 */
			Semicolon			/* $13 */
			{					/* $14 */
				struct SymNode	*ParmList;
				struct SymNode	*localProcDcl;
				char			*CurrentType;
				struct SymNode	value;
				short			CallingSequence;
				char			*use;
				char			*returns;

				_here;


				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_returns 
					|	specified_use
					|	specified_pascal 
					|	specified_stdcall 
					|	specified_cdecl 
				);
				_if( $<options.SpecifiedOptions>9 & specified_use )
				
					use = $<options.use>9;
					
				_else
				
					use = $<s>3->u.proc.use;
					
				_endif
				_if( $<options.SpecifiedOptions>9 & specified_returns )
				
					returns = $<options.returns>9;
					
				_else
				
					returns = $<s>3->u.proc.returns;
					
				_endif
				_if( $<options.SpecifiedOptions>9 & specified_stdcall )
				
					CallingSequence = stdcall_cs;
					
				_elseif( $<options.SpecifiedOptions>9 & specified_cdecl )
				
					CallingSequence = cdecl_cs;
					
				_elseif( $<options.SpecifiedOptions>9 & specified_pascal )
				
					CallingSequence = pascal_cs;
					
				_else
				
					CallingSequence = $<s>3->u.proc.cs;
					_if( $<s>3->u.proc.cs == stdcall_cs )
					
						$<options.SpecifiedOptions>9 |= specified_stdcall;
						$<options.CallingSequence>9 = stdcall_cs;	
					
					_elseif( $<s>3->u.proc.cs == cdecl_cs )
					
						$<options.SpecifiedOptions>9 |= specified_cdecl;	
						$<options.CallingSequence>9 = cdecl_cs;
						
					_endif	
				
				_endif
				$<en.s>8->u.proc.parms->u.proc.cs = CallingSequence;
				

				CurOffset = $<v.u.unsval>5;
				CurOffsetDir = $<v.u.unsval>6;
				--CurLexLevel;

				_if( CurLexLevel != 0 )

					yyerror
					( 
						"External procedures may only be declared "
						"at lex level zero"
					);

				_endif


				// Save a pointer to the local declaration of this
				// procedure because we're about to wipe out the value
				// in u.proc.parms.
				
				localProcDcl = $<en.s>8->u.proc.parms;
				

				// On return. u.proc.parms points at the local
				// declaration for this procedure. Save it so
				// we can use that data later.
				
				copyProcPtrParms( $<s>3 );
				$<en.s>8->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>8->u.proc.parms->u.proc.returns = returns;
				$<en.s>8->u.proc.parms->u.proc.use = use;
				$<en.s>8->u.proc.parms->u.proc.ParmSize = $<s>3->u.proc.ParmSize;
				$<en.s>8->u.proc.ParmSize = $<s>3->u.proc.ParmSize;
				$<en.s>8->u.proc.parms = SymbolTable;
				$<en.s>8->u.proc.returns = returns;
				$<en.s>8->u.proc.use = use;
				

				/*
				** Change the static name to correspond to the
				** external name of this procedure.  Note that
				** we need to update the name in two places.
				*/

				free2( vss localProcDcl->StaticName );
				localProcDcl->StaticName = hlastrdup2( $<idStr>12 );

				free2( vss $<en.s>8->StaticName );
				$<en.s>8->StaticName = $<idStr>12;

			
				/*
				** Since this is an external declaration, mark it
				** as such.
				*/

				$<en.s>8->IsExternal = 1;

				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<s>3->u.proc.ParmSize;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a external procedure, so mark it as a forward
				** procedure in the event this external declaration appears
				** within a header file included by the file containing
				** the actual declaration.
				*/

				$<en.s>8->u.proc.Forward = SymbolTable;

				/*
				** Store up the external definition for later emission:
				*/

				EmitTypedExtern( $<en.s>8, $<idStr>12, tLabel );

				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				*/

				$<en.s>8->u.proc.Locals = SymbolTable;

				SymbolTable = $<en.s>8;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>8;
				localProcDcl->IsExternal = 1;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>7;
				$<en.s>8->IsReferenced = localProcDcl->IsReferenced;
				



				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:

				$<en.s>8->u.proc.cs = CallingSequence;
				_if
				(
						CallingSequence == stdcall_cs
					||	CallingSequence == cdecl_cs
				)

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<en.s>8->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>8 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile


				_endif
				
				
				/*
				** Restore the currentNS value saved in EnterName:
				*/
				
				currentNS = $<en.cns>8;
				(void) $<idStr>11;	// Shut Up Bison				
				_here;
			}
	;

			

	
			 




 /*
 ** Handle external iterator definitions here.
 */

procs:		iteratorTkn 		/* $1  */
			UndefinedID 		/* $2  */
			SaveOffset 			/* $3  */
			SaveDirection		/* $4  */
			SaveContext 		/* $5  */
			EnterIterName		/* $6  */
			OptionalParms 		/* $7  */
			Semicolon			/* $8  */
			Options				/* $9  */
			externalTkn 		/* $10 */
			{ 					/* $11 */
				_here;
				$<idStr>$ = hlastrdup2( $<idStr>2 ); 
			} 
			OptionalExtName 	/* $12 */
			Semicolon			/* $13 */
			{					/* $14 */

				struct SymNode	*ParmList;
				char			*CurrentType;
				struct SymNode	value;


				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
					specified_use
				);

				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				--CurLexLevel;

				_if( CurLexLevel != 0 )

					yyerror
					( 
						"External iterators may only be declared "
						"at lex level zero"
					);

				_endif

				/*
				** Change the static name to correspond to the
				** external name of this procedure.  Note that
				** we need to update the name in two places.
				*/

				free2( vss $<en.s>6->u.proc.parms->StaticName );
				$<en.s>6->u.proc.parms->StaticName = hlastrdup2( $<idStr>12 );

				free2( vss $<en.s>6->StaticName );
				$<en.s>6->StaticName = $<idStr>12;

				/*
				** Since this is an external declaration, mark it
				** as such.
				*/

				$<en.s>6->IsExternal = 1;

				/*
				** Update this procedure's "returns" and "use" fields.
				*/


				$<en.s>6->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.use = $<options.use>9;


				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.
				*/


				$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.parms->u.proc.use = $<options.use>9;

				// Iterators always use the pascal calling sequence:
				
				$<en.s>6->u.proc.cs = pascal_cs;
				$<en.s>6->u.proc.parms->u.proc.cs = pascal_cs;
				



				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;


				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a external procedure, so mark it as a forward
				** procedure in the event this external declaration appears
				** within a header file included by the file containing
				** the actual declaration.
				*/

				$<en.s>6->u.proc.Forward = SymbolTable;


				/*
				** Queue up the external declaration for later emission.
				*/

				EmitTypedExtern( $<en.s>6, $<idStr>12, tLabel );


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;

				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;


				/*
				** Restore currentNS.
				*/
				
				currentNS = $<en.cns>6;
				(void) $<idStr>11;	// Shut up bison				
				_here;
			}
	;






 /*
 ** Handle new external iterator definitions here.
 */

newProcs:	UndefinedID 			/* $1  */
			colonIterator			/* $2  */
			SaveOffset 				/* $3  */
			SaveDirection			/* $4  */
			SaveContext 			/* $5  */
			EnterIterName			/* $6  */
			OptionalParms 			/* $7  */
			newProcOptionsSemicolon	/* $8  */
			externalTkn 			/* $9  */
			{ 						/* $10 */
				_here;
				$<idStr>$ = hlastrdup2( $<idStr>2 ); 
			} 
			OptionalExtName 	/* $11 */
			Semicolon			/* $12 */
			{					/* $13 */

				struct SymNode	*ParmList;
				char			*CurrentType;
				struct SymNode	value;
				char			*use;


				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
					specified_use
				);

				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				--CurLexLevel;

				_if( CurLexLevel != 0 )

					yyerror
					( 
						"External iterators may only be declared "
						"at lex level zero"
					);

				_endif

				/*
				** Change the static name to correspond to the
				** external name of this procedure.  Note that
				** we need to update the name in two places.
				*/

				free2( vss $<en.s>6->u.proc.parms->StaticName );
				$<en.s>6->u.proc.parms->StaticName = hlastrdup2( $<idStr>11 );

				free2( vss $<en.s>6->StaticName );
				$<en.s>6->StaticName = $<idStr>11;

				/*
				** Since this is an external declaration, mark it
				** as such.
				*/

				$<en.s>6->IsExternal = 1;

				/*
				** Update this procedure's "returns" and "use" fields.
				*/


				$<en.s>6->u.proc.returns = $<options.returns>8;
				$<en.s>6->u.proc.use = $<options.use>8;


				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.
				*/


				$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>8;
				$<en.s>6->u.proc.parms->u.proc.use = $<options.use>8;

				// Iterators always use the pascal calling sequence:
				
				$<en.s>6->u.proc.cs = pascal_cs;
				$<en.s>6->u.proc.parms->u.proc.cs = pascal_cs;
				



				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;


				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a external procedure, so mark it as a forward
				** procedure in the event this external declaration appears
				** within a header file included by the file containing
				** the actual declaration.
				*/

				$<en.s>6->u.proc.Forward = SymbolTable;


				/*
				** Queue up the external declaration for later emission.
				*/

				EmitTypedExtern( $<en.s>6, $<idStr>11, tLabel );


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;

				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;


				/*
				** Restore currentNS.
				*/
				
				currentNS = $<en.cns>6;
				(void) $<idStr>10;	// Shut up bison				
				_here;
			}
	;





			/*
			** Handle forward procedure declarations here.
			*/

procs:		procedureTkn		/* $1 */ 
			UndefinedID 		/* $2 */
			SaveOffset 			/* $3 */
			SaveDirection		/* $4 */
			SaveContext 		/* $5 */
			EnterName			/* $6 */
			OptionalParms 		/* $7 */
			Semicolon			/* $8 */
			Options				/* $9 */
			forwardTkn 			/* $10 */
			Semicolon			/* $11 */
			{					/* $12 */

				struct SymNode	*ParmList;
				char			*CurrentType;
				int				*dimension;
				struct SymNode	value;

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_returns 
					|	specified_pascal 
					|	specified_stdcall 
					|	specified_cdecl 
					|	specified_use
				);

				$<en.s>6->u.proc.cs = $<options.CallingSequence>9;

				/*
				** Set up the "returns" field for this procedure.
				*/

				$<en.s>6->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.use = $<options.use>9;

				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.  Note that $<6>->u.proc.parms
				** points at the local symbol table entry that has
				** the same name as the current procedure (to prevent
				** reusing the name in the procedure).
				*/

				$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.parms->u.proc.use = $<options.use>9;


				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;

				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a forward procedure, so mark it as such
				** in the symbol table.
				*/

				$<en.s>6->u.proc.Forward = SymbolTable;


				

				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				** (of course, there are no local symbols for
				** forward declarations, but we still have to
				** point proc.Locals at the parameters, if any).
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;




				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				--CurLexLevel;

				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;

				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:

				_if
				(
						$<en.s>6->u.proc.cs == stdcall_cs
					||	$<en.s>6->u.proc.cs == cdecl_cs
				)

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<en.s>6->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>6 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile

				_endif
				
				/*
				** Restore currentNS
				*/
				
				currentNS = $<en.cns>6;
				_here;
			}

	;
















			/*
			** Handle new forward procedure declarations here.
			*/

newProcs:	UndefinedID 			/* $1 */
			colonProcedure			/* $2 */
			SaveOffset 				/* $3 */
			SaveDirection			/* $4 */
			SaveContext 			/* $5 */
			EnterName				/* $6 */
			OptionalParms 			/* $7 */
			newProcOptionsSemicolon	/* $8 */
			forwardTkn 				/* $9  */
			Semicolon				/* $10 */
			{						/* $11 */

				struct SymNode	*ParmList;
				char			*CurrentType;
				int				*dimension;
				struct SymNode	value;

				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_returns 
					|	specified_pascal 
					|	specified_stdcall 
					|	specified_cdecl 
					|	specified_use
				);

				$<en.s>6->u.proc.cs = $<options.CallingSequence>8;

				/*
				** Set up the "returns" field for this procedure.
				*/

				$<en.s>6->u.proc.returns = $<options.returns>8;
				$<en.s>6->u.proc.use = $<options.use>8;

				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.  Note that $<6>->u.proc.parms
				** points at the local symbol table entry that has
				** the same name as the current procedure (to prevent
				** reusing the name in the procedure).
				*/

				$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>8;
				$<en.s>6->u.proc.parms->u.proc.use = $<options.use>8;


				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;

				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a forward procedure, so mark it as such
				** in the symbol table.
				*/

				$<en.s>6->u.proc.Forward = SymbolTable;


				

				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				** (of course, there are no local symbols for
				** forward declarations, but we still have to
				** point proc.Locals at the parameters, if any).
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;




				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				--CurLexLevel;

				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;

				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:

				_if
				(
						$<en.s>6->u.proc.cs == stdcall_cs
					||	$<en.s>6->u.proc.cs == cdecl_cs
				)

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<en.s>6->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>6 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile

				_endif
				
				/*
				** Restore currentNS
				*/
				
				currentNS = $<en.cns>6;
				_here;
			}

	;





			/*
			** Handle new forward procedure declarations here.
			*/

newProcs:	UndefinedID 			/* $1  */
			':'						/* $2  */
			TypeID					/* $3  */
			saveUID					/* $4  */
			SaveOffset 				/* $5  */
			SaveDirection			/* $6  */
			SaveContext 			/* $7  */
			EnterName				/* $8  */
			newProcOptionsSemicolon	/* $9  */
			forwardTkn 				/* $10 */
			Semicolon				/* $11 */
			{						/* $12 */

				struct SymNode	*ParmList;
				char			*CurrentType;
				int				*dimension;
				struct SymNode	value;

				_here;
				
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_use
					|	specified_returns
					|	specified_stdcall
					|	specified_pascal
					|	specified_cdecl
				);
				_if
				( 
						$<options.SpecifiedOptions>9 
					&	(
								specified_stdcall
							|	specified_pascal
							|	specified_cdecl
						)
				)
				
					$<en.s>8->u.proc.cs = $<options.CallingSequence>9;

				_else

					$<en.s>8->u.proc.cs = $<s>3->u.proc.cs;
					
				_endif
				_if( $<options.SpecifiedOptions>9 & specified_use )
				
					$<en.s>8->u.proc.use = $<options.use>9;
				
				_else
				
					$<en.s>8->u.proc.use = $<s>3->u.proc.use;
					
				_endif
				_if( $<options.SpecifiedOptions>9 & specified_returns )
				
					$<en.s>8->u.proc.returns = $<options.returns>9;
				
				_else 
				
					$<en.s>8->u.proc.returns = $<s>3->u.proc.returns;
					
				_endif
				

				/*
				** Copy the parameters from the type ID:
				*/

				copyProcPtrParms( $<s>3 );
				$<en.s>8->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>8->u.proc.parms->u.proc.returns = $<en.s>8->u.proc.returns;
				$<en.s>8->u.proc.parms->u.proc.use = $<en.s>8->u.proc.use;


				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>8->u.proc.parms = SymbolTable;

				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<s>3->u.proc.ParmSize;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a forward procedure, so mark it as such
				** in the symbol table.
				*/

				$<en.s>8->u.proc.Forward = SymbolTable;


				

				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				** (of course, there are no local symbols for
				** forward declarations, but we still have to
				** point proc.Locals at the parameters, if any).
				*/

				$<en.s>8->u.proc.Locals = SymbolTable;




				CurOffset = $<v.u.unsval>5;
				CurOffsetDir = $<v.u.unsval>6;
				--CurLexLevel;

				SymbolTable = $<en.s>8;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>8;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>7;

				// If the calling sequence reverses the parameters,
				// go in and swap all the offsets on the parameters:

				_if
				(
						$<en.s>8->u.proc.cs == stdcall_cs
					||	$<en.s>8->u.proc.cs == cdecl_cs
				)

					struct	SymNode	*fixParms;
					int			  	offset;

					fixParms = $<s>3->u.proc.parms;

					offset = 8;
					_while( fixParms != NULL && fixParms != $<en.s>8 )

						_if( fixParms->SymClass == cParm )

							fixParms->Offset = offset;
							
							// Round up to the next multiple of four:
							
							offset += ((( fixParms->ObjectSize + 3) >> 2) << 2);

						_endif
						fixParms = fixParms->Next;

					_endwhile

				_endif
				
				/*
				** Restore currentNS
				*/
				
				currentNS = $<en.cns>8;
				_here;
			}

	;




 /*
 ** Handle forward iterator declarations here.
 */

procs:		iteratorTkn			/* $1 */ 
			UndefinedID 		/* $2 */
			SaveOffset 			/* $3 */
			SaveDirection		/* $4 */
			SaveContext 		/* $5 */
			EnterIterName		/* $6 */
			OptionalParms 		/* $7 */
			Semicolon			/* $8 */
			Options				/* $9 */
			forwardTkn 			/* $10 */
			Semicolon			/* $11 */
			{					/* $12 */

				struct SymNode	*ParmList;
				char			*CurrentType;
				int				*dimension;
				struct SymNode	value;

				_here;

				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
					specified_use
				);
				
				// Iterators always use the pascal calling sequence:
				
				$<en.s>6->u.proc.cs = pascal_cs;
				$<en.s>6->u.proc.parms->u.proc.cs = pascal_cs;


				/*
				** Set up the "returns" field for this procedure.
				*/

				$<en.s>6->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.use = $<options.use>9;

				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.
				*/


				$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>9;
				$<en.s>6->u.proc.parms->u.proc.use = $<options.use>9;



				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;


				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a forward procedure, so mark it as such
				** in the symbol table.
				*/

				$<en.s>6->u.proc.Forward = SymbolTable;


				

				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				** (of course, there are no local symbols for
				** forward declarations, but we still have to
				** point proc.Locals at the parameters, if any).
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;




				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				--CurLexLevel;

				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;

				_here;

				
				/*
				** Restore currentNS:
				*/
				
				currentNS = $<en.cns>6;
				_here;
			}
	;



 /*
 ** Handle new forward iterator declarations here.
 */

newProcs:	UndefinedID 			/* $1 */
			colonIterator			/* $2 */
			SaveOffset 				/* $3 */
			SaveDirection			/* $4 */
			SaveContext 			/* $5 */
			EnterIterName			/* $6 */
			OptionalParms 			/* $7 */
			newProcOptionsSemicolon	/* $8 */
			forwardTkn 				/* $9  */
			Semicolon				/* $10 */
			{						/* $11 */

				struct SymNode	*ParmList;
				char			*CurrentType;
				int				*dimension;
				struct SymNode	value;

				_here;

				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
					specified_use
				);
				
				// Iterators always use the pascal calling sequence:
				
				$<en.s>6->u.proc.cs = pascal_cs;
				$<en.s>6->u.proc.parms->u.proc.cs = pascal_cs;


				/*
				** Set up the "returns" field for this procedure.
				*/

				$<en.s>6->u.proc.returns = $<options.returns>8;
				$<en.s>6->u.proc.use = $<options.use>8;

				/*
				** Patch the local symbol table entry's proc.parms
				** field first, then store the address of the start
				** of parameters into the main symbol table entry
				** for this procedure.
				*/


				$<en.s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<en.s>6->u.proc.parms->u.proc.returns = $<options.returns>8;
				$<en.s>6->u.proc.parms->u.proc.use = $<options.use>8;



				/*
				** Mark the end of the parameter list, and then
				** insert the _parms_ constant into the symbol table.
				*/

				$<en.s>6->u.proc.parms = SymbolTable;


				/*
				** Create a symbol table entry for the # of bytes
				** of parameters in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);


				/*
				** This is a forward procedure, so mark it as such
				** in the symbol table.
				*/

				$<en.s>6->u.proc.Forward = SymbolTable;


				

				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table
				** (of course, there are no local symbols for
				** forward declarations, but we still have to
				** point proc.Locals at the parameters, if any).
				*/

				$<en.s>6->u.proc.Locals = SymbolTable;




				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				--CurLexLevel;

				SymbolTable = $<en.s>6;

				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<en.s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>5;

				_here;

				
				/*
				** Restore currentNS:
				*/
				
				currentNS = $<en.cns>6;
				_here;
			}
	;



  /*
  ** A quick check to see if "external" is being used on
  ** a procedure that is already defined.
  */
  
procs:	procedureTkn		/* $1  */ 
		SaveOffset 			/* $2  */
		SaveDirection 		/* $3  */
		SaveContext 		/* $4  */
		LocalProcID			/* $5  */
		MatchParms			/* $6  */
		PatchLocals			/* $7  */
		Semicolon			/* $8  */
		Options				/* $9  */
		externalTkn			/* $10 */
		{					/* $11 */
			_here;
			$<idStr>$ = hlastrdup2( "" );
		}
		OptionalExtName		/* $12 */
		Semicolon			/* $13 */
		{
			char msg[ 256 ];
			
			_here;
			sprintf
			(
				msg,
				"Procedure <%s> is already defined,\n"
				"external definition is illegal here",
				$<s>5->TrueName
			);
				
			yyerror( msg );
			free2( vss $<idStr>12 );

			/*
			** Undo the stuff done by PatchLocals.
			** (PatchLocals isn't really used by this
			** production, it appears simply to eliminate
			** shift/reduce conflicts).
			*/

			SymbolTable = $<s>7;
			--CurLexLevel;
			
			/*
			** Restore currentNS
			*/
			
			currentNS = $<s>1;
			(void)$<idStr>11; // Shut up bison
			_here;
		}
	;


  /*
  ** A quick check to see if "external" is being used on
  ** a procedure that is already defined.
  */
  
colonProcedure2:
			':'
			procedureTkn
			{
				$<idStr>$ = $<idStr>-3;
			}
		;


  
newProcs:	
		LocalProcID				/* $1  */ 
		SaveOffset 				/* $2  */
		SaveDirection 			/* $3  */
		SaveContext 			/* $4  */
		colonProcedure2			/* $5  */
		MatchParms				/* $6  */
		PatchLocals				/* $7  */
		newProcOptionsSemicolon	/* $8  */
		externalTkn				/* $9  */
		{						/* $10 */
			_here;
			$<idStr>$ = hlastrdup2( "" );
		}
		OptionalExtName		/* $11 */
		Semicolon			/* $12 */
		{
			char msg[ 256 ];
			
			sprintf
			(
				msg,
				"Procedure <%s> is already defined,\n"
				"external definition is illegal here",
				$<s>5->TrueName
			);
				
			yyerror( msg );
			free2( vss $<idStr>11 );

			/*
			** Undo the stuff done by PatchLocals.
			** (PatchLocals isn't really used by this
			** production, it appears simply to eliminate
			** shift/reduce conflicts).
			*/

			SymbolTable = $<s>7;
			--CurLexLevel;
			
			/*
			** Restore currentNS
			*/
			
			currentNS = $<s>1;
			(void)$<idStr>10; // Shut up bison
			_here;
		}
	;


 /*
 ** PatchLocals-
 **
 **	Returns a pointer to the current symbol table entry as the
 ** attribute and sets SymbolTable to point at the previously
 ** defined locals for the subroutine whose symtab ptr is at $-1
 */

PatchLocals:
		{

			struct SymNode	*s;
			char 			msg[ 256 ];

			_here;
			++CurLexLevel;

			/*
			** Return the current (nonlocal) symbol in the symbol
			** table as this action's attribute:
			*/


			$<s>$ = SymbolTable;

			/*
			** If the symbol's .Forward field is non-NULL, then
			** a definition for this procedure already exists.
			** If it's not a tProc, then they are defining a
			** procedure when the forward or external declaration
			** appearing previously was not a procedure.
			*/
			 
			_if( $<s>-1->pType != tProc )

				/*
				** This condition may not be possible
				** RLH 4/20/2000
				*/

				sprintf
				(
					msg,
					"Symbol <<%s>> previously declared, but not as procedure",
					$<s>-1->TrueName
				);
				yyerror( msg );

			_else
			
				_if( $<s>-1->u.proc.Forward == NULL )

					sprintf
					(
						msg,
						"Duplicate procedure symbol <<%s>>",
						$<s>-1->TrueName
					);
					yyerror( msg );

					assert( $<s>-1->u.proc.Locals != NULL );
					SymbolTable = $<s>-1->u.proc.Locals;

				_else


					SymbolTable = $<s>-1->u.proc.Forward;
					$<s>-1->u.proc.Forward = NULL;

				_endif

				/*
				** NULL terminate the local symbols for
				** use by FixSymbols
				*/


				s = SymbolTable;
				_while( s != NULL && s->Next != $<s>-1 )

					s = s->Next;

				_endwhile
				_if( s != NULL )

					s->Next = NULL;

				_endif

			_endif
			_here;
		}
	;


 /*
 ** At this point, handle a procedure declaration that has
 ** had a previous forward declaration at this lex level
 ** (Note: "forward" means either forward or external).
 */

procs:		procedureTkn		/* $1  */ 
			SaveOffset			/* $2  */
			SaveDirection 		/* $3  */
			SaveContext 		/* $4  */
			LocalProcID			/* $5  */
			MatchParms			/* $6  */
			PatchLocals			/* $7  */
			Semicolon			/* $8  */
			Options				/* $9  */
			{					/* $10 */

				int						*dimension;
				struct	SymNode			*s;
				struct contextListType	*p;
				char					exitname[ 256 ];
				
				_here;
				CurrentContext = $<s>5;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_alignment 
					|	specified_noenter 
					|	specified_noleave
				);

				// Note: FixSymbols will patch this procedure's local symbol
				// table chain to point at $<s>$.  So set $<s>$ to point
				// back at the current local symbol table.

				$<s>$ = $<s>7;


				/*
				** If we need a display, allocate storage for it and
				** create a symbol table entry for it.
				*/

				CurOffset = StartLclOffs;
				_if( $<options.UseDisplay>9 )

					CurOffset -= 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);
					CurOffset -= CurLexLevel * 4;

				_endif


				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>9 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>5->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>5->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>9;
					p->SizeParms = $<s>5->u.proc.ParmSize;
					contextList = p;
				
				_endif
				_here;
			}

			/*
			** Reconnect local symbols to the main symbol
			** table chain.  Return a pointer to the last
			** item in the local symbols list in the attribute.
			*/

			FixSymbols			/* $11 */

			saveCurNS			/* $12 */
			 
			/*
			** Process this procedure's declarations here.
			*/

			Declarations		/* $13 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 			/* $14 */
 			AnyID				/* $15 */
  			Semicolon			/* $16 */
 			{					/* $17 */


				int				RoundedOffset;
				struct SymNode	value;

				int				HadPassByValRes;
				struct SymNode	*s;
				struct SymNode	*d;

				_here;
				inProcedure = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>9 )

					HadPassByValRes = 0;
					s = $<s>5->u.proc.parms;
					_while( s != NULL && s != $<s>5 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;


							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif
						( 
								s->pClass == vrp_pc 
							||	s->pClass == result_pc  
						)

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif




				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, remove the size of the
				** display from the number of local variables.
				*/

				_if( $<options.UseDisplay>9 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>5->IsExternal )

					EmitPublic( $<s>5->StaticName );

				_endif
				startCseg();
				_if( $<options.Alignment>9 != 1 )

					EmitAlign( $<options.Alignment>9 );

				_endif
				StartProc( $<s>5->StaticName );
				_if( $<options.UseFrame>9 && !$<options.UseDisplay>9 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>9 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>9 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>9 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>9 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>9 )

						AlignStack();

					_endif

				_endif




				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>9 && HadPassByValRes )

					CopyValResParms( $<s>5 );

				_endif





				assert( $<neID.idStr>15 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>15 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"procedure name <<%s>>",

						$<neID.idStr>15,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Check to ensure that all forward declared procedures
				** have be defined prior to code emission.
				*/

				CheckForwardDecls( $<s>10 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				/*
				** CurrentContext = $<s>5;
				*/

				free2( vss $<neID.idStr>15 );


				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				assert( $<s>$ != NULL );
				_if( $<options.UseFrame>9 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;

			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts			/* $18 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn 			/* $19 */
			AnyID			/* $20 */
			Semicolon		/* $21 */
			{				/* $22 */

				struct SymNode			*s;
				struct SymNode			*d;


				_here;
				assert( $<neID.idStr>20 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>20 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"procedure name <<%s>>",
						$<neID.idStr>20,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif


				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>9 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>5->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					( 
							$<s>17->pType != tString 
						&&	$<s>17->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>17->u.strval ) != 0 )

						InvisibleCode = $<s>17->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>17->u.strval );

					_endif
					
				_endif

			}
			Stmts		/* $23 */
			endTkn		/* $24 Faked by PushBackStr above	*/
			{			/* $25 */
		
				struct contextListType	*cNode;
				struct SymNode			*s;
				int						HadPassByValRes;
				struct SymNode			*d;
	
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_here;
				_if( $<options.UseFrame>9 )

					StoreValResParms( $<s>5 );

				_endif


				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>2;
				CurOffsetDir = $<v.u.unsval>3;


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				$<s>5->u.proc.Locals = SymbolTable;
				$<s>11->Next = NULL;
				SymbolTable = $<s>7;

				/*
				** Since this can no longer be an external reference,
				** set the external flag to false.
				*/

				$<s>5->IsExternal = 0;


				/*
				** See if there are any outstanding undefined static
				** objects at this lex level.
				*/

				CurrentContext = $<s>5;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>4;

				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();


				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>9 )

					StdExit
					( 
						$<s>5->u.proc.ParmSize, 
						$<s>5->u.proc.cs == cdecl_cs,
						$<options.NoLeave>9
					);

				_endif
				EndProc( $<s>5->StaticName );
				endCseg();
				free2( vss $<neID.idStr>20 );

				inProcedure = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>9 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>5->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				
				
				/*
				** Restore currentNS
				*/
				
				currentNS = $<ru.saveCurNS>12;
				_here;
			}
	;



// Handle a procedure with a forward/external declaration using new syntax:


newProcs:	LocalProcID				/* $1  */ 
			SaveOffset				/* $2  */
			SaveDirection 			/* $3  */
			SaveContext 			/* $4  */
			colonProcedure2			/* $5  */
			MatchParms				/* $6  */
			PatchLocals				/* $7  */
			newProcOptionsSemicolon	/* $8  */
			{						/* $9 */

				int						*dimension;
				struct	SymNode			*s;
				struct contextListType	*p;
				char					exitname[ 256 ];
				
				_here;
				CurrentContext = $<s>5;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_alignment 
					|	specified_noenter 
					|	specified_noleave
				);

				// Note: FixSymbols will patch this procedure's local symbol
				// table chain to point at $<s>$.  So set $<s>$ to point
				// back at the current local symbol table.

				$<s>$ = $<s>7;


				/*
				** If we need a display, allocate storage for it and
				** create a symbol table entry for it.
				*/

				CurOffset = StartLclOffs;
				_if( $<options.UseDisplay>8 )

					CurOffset -= 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);
					CurOffset -= CurLexLevel * 4;

				_endif


				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>8 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>5->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>5->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>8;
					p->SizeParms = $<s>5->u.proc.ParmSize;
					contextList = p;
				
				_endif
				_here;
			}

			/*
			** Reconnect local symbols to the main symbol
			** table chain.  Return a pointer to the last
			** item in the local symbols list in the attribute.
			*/

			FixSymbols			/* $10 */

			saveCurNS			/* $11 */
			 
			/*
			** Process this procedure's declarations here.
			*/

			Declarations		/* $12 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 			/* $13 */
 			AnyID				/* $14 */
  			Semicolon			/* $15 */
 			{					/* $16 */


				int				RoundedOffset;
				struct SymNode	value;

				int				HadPassByValRes;
				struct SymNode	*s;
				struct SymNode	*d;

				_here;
				inProcedure = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>9 )

					HadPassByValRes = 0;
					s = $<s>5->u.proc.parms;
					_while( s != NULL && s != $<s>5 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;


							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif
						( 
								s->pClass == vrp_pc 
							||	s->pClass == result_pc  
						)

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif




				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, remove the size of the
				** display from the number of local variables.
				*/

				_if( $<options.UseDisplay>8 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>5->IsExternal )

					EmitPublic( $<s>5->StaticName );

				_endif
				startCseg();
				_if( $<options.Alignment>8 != 1 )

					EmitAlign( $<options.Alignment>8 );

				_endif
				StartProc( $<s>5->StaticName );
				_if( $<options.UseFrame>8 && !$<options.UseDisplay>8 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>8 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>8 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>8 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>8 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>8 )

						AlignStack();

					_endif

				_endif




				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>8 && HadPassByValRes )

					CopyValResParms( $<s>5 );

				_endif





				assert( $<neID.idStr>14 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>14 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"procedure name <<%s>>",

						$<neID.idStr>14,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Check to ensure that all forward declared procedures
				** have be defined prior to code emission.
				*/

				CheckForwardDecls( $<s>9 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				/*
				** CurrentContext = $<s>5;
				*/

				free2( vss $<neID.idStr>14 );


				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				assert( $<s>$ != NULL );
				_if( $<options.UseFrame>8 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;

			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts			/* $17 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn 			/* $18 */
			AnyID			/* $19 */
			Semicolon		/* $20 */
			{				/* $21 */

				struct SymNode			*s;
				struct SymNode			*d;


				_here;
				assert( $<neID.idStr>19 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>19 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"procedure name <<%s>>",
						$<neID.idStr>19,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif


				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>8 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>5->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					( 
							$<s>16->pType != tString 
						&&	$<s>16->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>16->u.strval ) != 0 )

						InvisibleCode = $<s>16->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>16->u.strval );

					_endif
					
				_endif
				_here;
			}
			Stmts		/* $22 */
			endTkn		/* $23 Faked by PushBackStr above	*/
			{			/* $24 */
		
				struct contextListType	*cNode;
				struct SymNode			*s;
				int						HadPassByValRes;
				struct SymNode			*d;
	
				_here;
				
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>8 )

					StoreValResParms( $<s>5 );

				_endif


				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>2;
				CurOffsetDir = $<v.u.unsval>3;


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				$<s>5->u.proc.Locals = SymbolTable;
				$<s>10->Next = NULL;
				SymbolTable = $<s>7;

				/*
				** Since this can no longer be an external reference,
				** set the external flag to false.
				*/

				$<s>5->IsExternal = 0;


				/*
				** See if there are any outstanding undefined static
				** objects at this lex level.
				*/

				CurrentContext = $<s>5;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>4;

				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();


				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>8 )

					StdExit
					( 
						$<s>5->u.proc.ParmSize, 
						$<s>5->u.proc.cs == cdecl_cs,
						$<options.NoLeave>8
					);

				_endif
				EndProc( $<s>5->StaticName );
				endCseg();
				free2( vss $<neID.idStr>19 );

				inProcedure = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>8 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>5->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				
				
				/*
				** Restore currentNS
				*/
				
				currentNS = $<ru.saveCurNS>11;
				_here;
			}
	;
	


// MatchProcTypeID-
//
//	Parameters are specified by a TypeID. Make sure that TypeID is a procedure
// type and that its parameter list matches the current set.
//
//	Assumes the procedure ID being check is at $0. 


MatchProcTypeID:
			TypeID				/* $1 */
			{
				struct	SymNode	*p;
				struct	SymNode	*t;
				char	msg[256];
				
				_here;
				_if( $<s>1->pType != tProcptr )
				
					sprintf
					(
						msg, 
						"Expected a procedure type ID after ':', found '%s'",
						$<s>1->TrueName
					);
					yyerror( msg );
					
				_else
					
					t = $<s>1->u.proc.parms;
					p = $<s>0->u.proc.parms;
					_while( t->Next != $<s>1 && p->Next != $<s>0 )
					
						/*
						** Be sure the forward definition wasn't a procedural
						** parameter.
						*/

						_if(  p->Type == NULL )

							/*
							** This occurs if the declared parameter is
							** a procedure parameter but the forward parameter was not.
							*/
							
							sprintf
							(
								msg,
								"Parameter \"%s\" was not a procedure parameter in "
								"the original\n"
								"definition (may have been a type symbol"
								"that is indirectly a\n"
								"procedure type, though)",
								t->TrueName
							);
							yyerror( msg );

						
						
							/*
							** Next, make sure the object is an actual parameter
							** in the original declaration.
							*/

						_elseif( p->SymClass != cParm )

							sprintf
							(
								msg,
								"Parameter \"%s\" is not present in original definition",
								t->TrueName
							);
							yyerror
							(
								msg
							);

						_else /* This is a parameter */
						

							/*
							** Make sure the two parameters were passed the same
							** way (e.g., pass by reference).
							*/

							_if( t->pClass != p->pClass )

								yyerror
								(
									"Parameter classes must agree "
									"(e.g., pass by value,\n"
									"pass by reference, etc.) with "
									"original declaration"
								);


							/*
							** Be sure the names are identical.
							*/

							_elseif( _strne( p->TrueName, t->TrueName ))

							 	sprintf
								(
									msg,
									"Identifier \"%s\" must be identical to "
									" declaration \"%s\"",
									t->TrueName,
									p->TrueName
								);
								yyerror( msg );

							/*
							** Be sure their types are identical
							*/

							_elseif( p->Type != t->Type )

								sprintf
								(
									msg,
									"Type (%s:%s) must match original "
									"declaration (%s:%s)",
									p->TrueName,
									p->Type->TrueName,
									t->TrueName,
									t->Type->TrueName
								);
								yyerror( msg );



							/*
							** If the StaticName field is non-NULL, then we
							** have a register parameter (e.g., "in <reg>" was
							** used).
							*/

							_elseif( p->StaticName != NULL )

								/*
								** Make sure the current declaration also
								** specifies a register parameter.
								*/

								_if( t->StaticName == NULL )

									sprintf
									(
										msg,
										"Original parameter declaration was in register %s",
										p->StaticName
									);
									yyerror( msg );


								/*
								** Make sure the current declaration specifies
								** the same register.
								*/

								_elseif( _strne( t->StaticName, p->StaticName ))

									sprintf
									(
										msg,
										"IN <reg> declarations must be the same "
										"(%s vs. %s [fwd])",
										t->StaticName,
										p->StaticName
									);
									yyerror( msg );

								_endif


							/*
							** If the current declaration is a register parameter
							** but the original (forward) definition wasn't, print
							** the appropriate message.
							*/

							_elseif( p->StaticName != NULL )

								sprintf
								(
									msg,
									"Original parameter declaration wasn't specified "
									"in a register (%s)",
									p->TrueName
								);
								yyerror( msg );

							_endif

						_endif

						t = t->Next;
						p = p->Next;
					
					_endwhile
					
					_if( t->Next != $<s>1 || _strne( p->TrueName, "_finalize_") )
					
						yyerror
						( 
							"Number of declared parameters does not match "
							"original declaration"
						);
						
					_endif
					
				_endif
				_here;  
			}
	;
			

// Handle a procedure with a forward/external declaration using new syntax:



newProcs:	LocalProcID				/* $1  */ 
			SaveOffset				/* $2  */
			SaveDirection 			/* $3  */
			SaveContext 			/* $4  */
			':'						/* $5  */
			{ $<s>$ = $<s>1; }		/* $6  */
			MatchProcTypeID			/* $7  */
			PatchLocals				/* $8  */
			newProcOptionsSemicolon	/* $9  */
			{						/* $10 */

				int						*dimension;
				struct	SymNode			*s;
				struct contextListType	*p;
				char					exitname[ 256 ];
				
				_here;
				CurrentContext = $<s>4;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_alignment 
					|	specified_noenter 
					|	specified_noleave
				);

				// Note: FixSymbols will patch this procedure's local symbol
				// table chain to point at $<s>$.  So set $<s>$ to point
				// back at the current local symbol table.

				$<s>$ = $<s>8;


				/*
				** If we need a display, allocate storage for it and
				** create a symbol table entry for it.
				*/

				CurOffsetDir = -1;
				CurOffset = StartLclOffs;
				_if( $<options.UseDisplay>9 )

					CurOffset -= 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);
					CurOffset -= CurLexLevel * 4;

				_endif


				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>9 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>5->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>5->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>9;
					p->SizeParms = $<s>5->u.proc.ParmSize;
					contextList = p;
				
				_endif
				_here;
			}

			/*
			** Reconnect local symbols to the main symbol
			** table chain.  Return a pointer to the last
			** item in the local symbols list in the attribute.
			*/

			FixSymbols			/* $11 */

			saveCurNS			/* $12 */
			 
			/*
			** Process this procedure's declarations here.
			*/

			Declarations		/* $13 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 			/* $14 */
 			AnyID				/* $15 */
  			Semicolon			/* $16 */
 			{					/* $17 */


				int				RoundedOffset;
				struct SymNode	value;

				int				HadPassByValRes;
				struct SymNode	*s;
				struct SymNode	*d;

				_here;
				inProcedure = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>9 )

					HadPassByValRes = 0;
					s = $<s>6->u.proc.parms;
					_while( s != NULL && s != $<s>6 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;


							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif
						( 
								s->pClass == vrp_pc 
							||	s->pClass == result_pc  
						)

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif




				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, remove the size of the
				** display from the number of local variables.
				*/

				_if( $<options.UseDisplay>9 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>6->IsExternal )

					EmitPublic( $<s>6->StaticName );

				_endif
				startCseg();
				_if( $<options.Alignment>9 != 1 )

					EmitAlign( $<options.Alignment>9 );

				_endif
				StartProc( $<s>5->StaticName );
				_if( $<options.UseFrame>9 && !$<options.UseDisplay>9 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>9 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>9 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>9 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>9 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>9 )

						AlignStack();

					_endif

				_endif




				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>9 && HadPassByValRes )

					CopyValResParms( $<s>6 );

				_endif





				assert( $<neID.idStr>15 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>15 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"procedure name <<%s>>",

						$<neID.idStr>15,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Check to ensure that all forward declared procedures
				** have be defined prior to code emission.
				*/

				CheckForwardDecls( $<s>10 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				/*
				** CurrentContext = $<s>5;
				*/

				free2( vss $<neID.idStr>15 );


				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				assert( $<s>$ != NULL );
				_if( $<options.UseFrame>9 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;

			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts			/* $18 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn 			/* $19 */
			AnyID			/* $20 */
			Semicolon		/* $21 */
			{				/* $22 */

				struct SymNode			*s;
				struct SymNode			*d;


				_here;
				assert( $<neID.idStr>20 != NULL );

				_if( _strne( $<s>6->TrueName, $<neID.idStr>20 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"procedure name <<%s>>",
						$<neID.idStr>20,
						$<s>6->TrueName
					);

					yyerror( msg );

				_endif


				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>9 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>6->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					( 
							$<s>17->pType != tString 
						&&	$<s>17->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>17->u.strval ) != 0 )

						InvisibleCode = $<s>17->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>17->u.strval );

					_endif
					
				_endif

			}
			Stmts		/* $23 */
			endTkn		/* $24 Faked by PushBackStr above	*/
			{			/* $25 */
		
				struct contextListType	*cNode;
				struct SymNode			*s;
				int						HadPassByValRes;
				struct SymNode			*d;
	
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_here;
				_if( $<options.UseFrame>9 )

					StoreValResParms( $<s>6 );

				_endif


				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>2;
				CurOffsetDir = $<v.u.unsval>3;


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				$<s>6->u.proc.Locals = SymbolTable;
				$<s>11->Next = NULL;
				SymbolTable = $<s>8;

				/*
				** Since this can no longer be an external reference,
				** set the external flag to false.
				*/

				$<s>6->IsExternal = 0;


				/*
				** See if there are any outstanding undefined static
				** objects at this lex level.
				*/

				CurrentContext = $<s>6;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>4;

				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();


				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>9 )

					StdExit
					( 
						$<s>6->u.proc.ParmSize, 
						$<s>6->u.proc.cs == cdecl_cs,
						$<options.NoLeave>9
					);

				_endif
				EndProc( $<s>6->StaticName );
				endCseg();
				free2( vss $<neID.idStr>20 );

				inProcedure = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>9 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>6->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				
				
				/*
				** Restore currentNS
				*/
				
				currentNS = $<ru.saveCurNS>12;
				_here;
			}
	;






 
 
 
 
  /*
  ** A quick check to see if "external" is being used on
  ** an iterator that is already defined.
  */
  		 
procs:	iteratorTkn			/* $1  */ 
		SaveOffset 			/* $2  */
		SaveDirection 		/* $3  */
		SaveContext 		/* $4  */
		LocalIterID 		/* $5  */
		MatchParms			/* $6  */
		PatchLclIter		/* $7  */
		Semicolon			/* $8  */
		Options				/* $9  */
		externalTkn			/* $10 */
		{					/* $11 */
			_here;
			$<idStr>$ = hlastrdup2( "" );
		}
		OptionalExtName		/* $12 */
		Semicolon			/* $13 */
		{
			char msg[ 256 ];
			
			sprintf
			(
				msg,
				"Iterator <%s> is already defined,\n"
				"external definition is illegal here",
				$<s>5->TrueName
			);
				
			yyerror( msg );
			free2( vss $<idStr>12 );

			/*
			** Undo the stuff done by PatchLclIter.
			** (PatchLocals isn't really used by this
			** production, it appears simply to eliminate
			** shift/reduce conflicts).
			*/

			SymbolTable = $<s>7;
			--CurLexLevel;
			(void) $<idStr>11;	// shut up bison
			_here;
		}
	;



  /*
  ** A quick check to see if "external" is being used on
  ** a new iterator that is already defined.
  */
  
colonIterator2:
		':'
		iteratorTkn
		{
			_here;
			$<idStr>$ = $<idStr>-3;
		}
	;
  		 
newProcs:	
		LocalIterID				/* $1  */ 
		SaveOffset 				/* $2  */
		SaveDirection 			/* $3  */
		SaveContext 			/* $4  */
		colonIterator2 			/* $5  */
		MatchParms				/* $6  */
		PatchLclIter			/* $7  */
		newProcOptionsSemicolon	/* $8  */
		externalTkn				/* $9  */
		{						/* $10 */
			_here;
			$<idStr>$ = hlastrdup2( "" );
		}
		OptionalExtName		/* $11 */
		Semicolon			/* $12 */
		{
			char msg[ 256 ];
			
			sprintf
			(
				msg,
				"Iterator <%s> is already defined,\n"
				"external definition is illegal here",
				$<s>5->TrueName
			);
				
			yyerror( msg );
			free2( vss $<idStr>11 );

			/*
			** Undo the stuff done by PatchLclIter.
			** (PatchLocals isn't really used by this
			** production, it appears simply to eliminate
			** shift/reduce conflicts).
			*/

			SymbolTable = $<s>7;
			--CurLexLevel;
			(void) $<idStr>10;	// shut up bison
			_here;
		}
	;



PatchLclIter:
		{

			struct SymNode	*s;
			char 			msg[ 256 ];

			_here;
			++CurLexLevel;

			/*
			** Return the current (nonlocal) symbol in the symbol
			** table as this action's attribute:
			*/


			$<s>$ = SymbolTable;

			/*
			** If the symbol's .Forward field is non-NULL, then
			** a definition for this procedure already exists.
			** If it's not a tProc, then they are defining a
			** procedure when the forward or external declaration
			** appearing previously was not a procedure.
			*/
			 
			_if( $<s>-1->pType != tIterator )

				sprintf
				(
					msg,
					"Symbol <<%s>> previously declared, but not as iterator",
					$<s>-1->TrueName
				);
				yyerror( msg );

			_else
			
				_if( $<s>-1->u.proc.Forward == NULL )

					sprintf
					(
						msg,
						"Duplicate iterator symbol <<%s>>",
						$<s>-1->TrueName
					);
					yyerror( msg );

					assert( $<s>-1->u.proc.Locals != NULL );
					SymbolTable = $<s>-1->u.proc.Locals;

				_else


					SymbolTable = $<s>-1->u.proc.Forward;
					$<s>-1->u.proc.Forward = NULL;

				_endif

				/*
				** NULL terminate the local symbols for
				** use by FixSymbols
				*/


				s = SymbolTable;
				_while( s != NULL && s->Next != $<s>-1 )

					s = s->Next;

				_endwhile
				_if( s != NULL )

					s->Next = NULL;

				_endif

			_endif
			_here;
		}
	;




 /*
 ** At this point, handle an iterator that has had a previous
 ** forward or external declaration.
 */


procs:		iteratorTkn			/* $1  */ 
			SaveOffset 			/* $2  */
			SaveDirection 		/* $3  */
			SaveContext 		/* $4  */
			LocalIterID 		/* $5  */
			MatchParms			/* $6  */
			PatchLclIter		/* $7  */
			Semicolon			/* $8  */
			Options				/* $9  */
			{					/* $10 */

				char 					msg[ 256 ];
				int						*dimension;
				struct	SymNode			*s;
				struct contextListType	*p;
				char					exitname[ 256 ];

				_here;
				CurrentContext = $<s>5;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_alignment 
					|	specified_noenter 
					|	specified_noleave
				);


				/*
				** Required by FixSymbols.
				*/

				$<s>$ = $<s>7;


				/*
				** Create a symbol table entry for the "yield" thunk.
				*/

				InsertSym
				( 
					"yield", 
					&thunk_ste,	/* Type			*/
					tThunk, 	/* pType		*/
					cVar,		/* SymClass		*/ 
					0,			/* Arity		*/
					NULL,		/* dimensions	*/
					0, 			/* # elements	*/
					NULL,		/* Value		*/
					8,			/* ObjectSize	*/
					0,			/* Offset 		*/
					NULL,		/* StaticName	*/
					NULL,		/* Base			*/
					NULL,		/* Fields		*/
					0			/* FieldCnt		*/
				);

				/*
				** Thunks (yield) don't have any parameters,
				** but we can't leave proc.parms NULL (since other
				** code treats this as an error).  Just give each
				** Yield thunk a set of local constants which are
				** the lex level zero constants.
				*/
				
				SymbolTable->u.proc.parms = &true_ste;



				/*
				** If we need a display, allocate storage for it and
				** create a symbol table entry for it.
				*/

				CurOffset = StartLclOffs;
				_if( $<options.UseDisplay>9 )

					CurOffset -= 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);
					CurOffset -= CurLexLevel * 4;

				_endif



				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>9 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>5->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>5->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>9;
					p->SizeParms = $<s>5->u.proc.ParmSize;
					contextList = p;

				_endif


				_here;
			}

			/*
			** Reconnect local symbols to the main symbol
			** table chain.  Return a pointer to the last
			** item in the local symbols list in the attribute.
			*/

			FixSymbols			/* $11 */
			 
			saveCurNS			/* $12 */
			
			/*
			** Process this procedure's declarations here.
			*/

			Declarations		/* $13 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 			/* $14 */
 			AnyID				/* $15 */
  			Semicolon			/* $16 */
 			{					/* $17 */


				int				RoundedOffset;
				struct SymNode	value;

				int				HadPassByValRes;
				struct SymNode	*s;
				struct SymNode	*d;

				_here;
				inIterator = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>9 )

					HadPassByValRes = 0;
					s = $<s>5->u.proc.parms;
					_while( s != NULL && s != $<s>5 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;


							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif
						( 
								s->pClass == vrp_pc 
							||	s->pClass == result_pc  
						)

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif


				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, remove the size of the
				** display from the number of local variables.
				*/

				_if( $<options.UseDisplay>9 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>5->IsExternal )

					EmitPublic( $<s>5->StaticName );

				_endif
				startCseg();
				_if( $<options.Alignment>9 != 1 )

					EmitAlign( $<options.Alignment>9 );

				_endif
				StartProc( $<s>5->StaticName );
				_if( $<options.UseFrame>9 && !$<options.UseDisplay>9 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>9 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>9 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>9 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>9 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>9 )

						AlignStack();

					_endif

				_endif


				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>9 && HadPassByValRes )

					CopyValResParms( $<s>5 );

				_endif



				assert( $<neID.idStr>15 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>15 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"iterator name <<%s>>",
						$<neID.idStr>15,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Check to ensure that all forward declared procedures
				** have be defined prior to code emission.
				*/

				CheckForwardDecls( $<s>10 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				free2( vss $<neID.idStr>15 );




				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				assert( $<s>$ != NULL );
				_if( $<options.UseFrame>9 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;

			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts			/* $18 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn 			/* $19 */
			AnyID			/* $20 */
			Semicolon		/* $21 */
			{				/* $22 */


				_here;
				assert( $<neID.idStr>20 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>20 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"iteator name <<%s>>",
						$<neID.idStr>20,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif



				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>9 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>5->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					(
							$<s>17->pType != tString 
						&&	$<s>17->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>17->u.strval ) != 0 )

						InvisibleCode = $<s>17->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>17->u.strval );

					_endif
					
				_endif
				_here;
			}
			Stmts		/* $23 */
			endTkn		/* $24 Faked by PushBackStr above	*/
			{			/* $25 */
							 
				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;

				_here;
	
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>9 )

					StoreValResParms( $<s>5 );

				_endif



				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>2;
				CurOffsetDir = $<v.u.unsval>3;


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				$<s>5->u.proc.Locals = SymbolTable;
				$<s>11->Next = NULL;
				SymbolTable = $<s>7;

				/*
				** Since this can no longer be an external reference,
				** set the external flag to false.
				*/

				$<s>5->IsExternal = 0;


				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<s>5;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>4;

				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();


				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>9 )

					IteratorExit( $<s>5->u.proc.ParmSize ); 

				_endif
				EndProc( $<s>5->StaticName );
				endCseg();
				free2( vss $<neID.idStr>20 );

				inIterator = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>9 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>5->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				
				/*
				** Restore currentNS
				*/
				
				currentNS = $<ru.saveCurNS>12;
				
				_here;
			}
	;






 /*
 ** At this point, handle an iterator that has had a previous
 ** forward or external declaration using the new syntax.
 */


newProcs:	LocalIterID				/* $1  */ 
			SaveOffset 				/* $2  */
			SaveDirection 			/* $3  */
			SaveContext 			/* $4  */
			colonIterator2 			/* $5  */
			MatchParms				/* $6  */
			PatchLclIter			/* $7  */
			newProcOptionsSemicolon	/* $8  */
			{						/* $9  */

				char 					msg[ 256 ];
				int						*dimension;
				struct	SymNode			*s;
				struct contextListType	*p;
				char					exitname[ 256 ];

				_here;
				CurrentContext = $<s>5;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_noframe 
					|	specified_nodisplay 
					|	specified_noalignstk 
					|	specified_alignment 
					|	specified_noenter 
					|	specified_noleave
				);


				/*
				** Required by FixSymbols.
				*/

				$<s>$ = $<s>7;


				/*
				** Create a symbol table entry for the "yield" thunk.
				*/

				InsertSym
				( 
					"yield", 
					&thunk_ste,	/* Type			*/
					tThunk, 	/* pType		*/
					cVar,		/* SymClass		*/ 
					0,			/* Arity		*/
					NULL,		/* dimensions	*/
					0, 			/* # elements	*/
					NULL,		/* Value		*/
					8,			/* ObjectSize	*/
					0,			/* Offset 		*/
					NULL,		/* StaticName	*/
					NULL,		/* Base			*/
					NULL,		/* Fields		*/
					0			/* FieldCnt		*/
				);

				/*
				** Thunks (yield) don't have any parameters,
				** but we can't leave proc.parms NULL (since other
				** code treats this as an error).  Just give each
				** Yield thunk a set of local constants which are
				** the lex level zero constants.
				*/
				
				SymbolTable->u.proc.parms = &true_ste;



				/*
				** If we need a display, allocate storage for it and
				** create a symbol table entry for it.
				*/

				CurOffset = StartLclOffs;
				_if( $<options.UseDisplay>8 )

					CurOffset -= 4;
					dimension = malloc2( sizeof( int ));
					*dimension = CurLexLevel + 1;
					InsertSym
					( 
						"_display_", 
						&dword_ste,
						tDWord, 
						cVar, 
						1,
						dimension,
						*dimension, 
						NULL,
						*dimension*4,
						CurOffset,
						NULL,
						NULL,
						NULL,
						0
					);
					CurOffset -= CurLexLevel * 4;

				_endif



				/*
				** Add this procedure to the context list so we
				** can bail on this procedure via the EXIT and EXITIF
				** statements.
				*/
				
				_if( $<options.UseFrame>8 )

					p = malloc2( sizeof( struct contextListType ));
					p->Next = contextList;
					p->label = $<s>5->TrueName;

					sprintf( exitname, "x%s" sympost, $<s>5->StaticName ); 
					p->StaticName = hlastrdup2( exitname );
					p->LexLevel = CurLexLevel;
					p->IsProc = 1;
					p->HasDisplay = $<options.UseDisplay>8;
					p->SizeParms = $<s>5->u.proc.ParmSize;
					contextList = p;

				_endif


				_here;
			}

			/*
			** Reconnect local symbols to the main symbol
			** table chain.  Return a pointer to the last
			** item in the local symbols list in the attribute.
			*/

			FixSymbols			/* $10 */
			 
			saveCurNS			/* $11 */
			
			/*
			** Process this procedure's declarations here.
			*/

			Declarations		/* $12 */
			
			
			/*
			** Upon encountering the "begin" token, check the ID
			** to make sure it matches the procedure name.
			*/
			 
			beginTkn 			/* $13 */
 			AnyID				/* $14 */
  			Semicolon			/* $15 */
 			{					/* $16 */


				int				RoundedOffset;
				struct SymNode	value;

				int				HadPassByValRes;
				struct SymNode	*s;
				struct SymNode	*d;

				_here;
				inIterator = 1;


				/*
				** Check for pass by value/result or pass by result
				** parameters because we need to allocate local
				** storage for these.
				*/

				_if( $<options.UseFrame>8 )

					HadPassByValRes = 0;
					s = $<s>5->u.proc.parms;
					_while( s != NULL && s != $<s>5 )

						_if
						( 
								s->pType == tProcptr 
							&&	(
										s->pClass == vrp_pc 
									||	s->pClass == result_pc
								)
						)

							CurOffset = CurOffset - 4;
							InsertSym
							(
								s->TrueName, 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);
							d = SymbolTable;
							d->u.proc.returns = hlastrdup2( "" );
							d->u.proc.use = s->u.proc.use;
							d->u.proc.parms = s->u.proc.parms;
							d->u.proc.Locals = s->u.proc.Locals;
							d->u.proc.Forward = s->u.proc.Forward;
							d->u.proc.BaseClass = s->u.proc.BaseClass;
							d->u.proc.ParmSize = s->u.proc.ParmSize;
							d->u.proc.cs = s->u.proc.cs;


							InsertSym
							(
								" (procptr type) ", 
								NULL,				/* Type			*/
								tProcptr,		 	/* pType		*/
								cType,				/* SymClass		*/ 
								0,					/* Arity		*/
								NULL,				/* dimensions	*/
								0,					/* # elements	*/
								NULL,				/* Value		*/
								4,					/* ObjectSize	*/
								0,					/* Offset 		*/
								NULL,				/* StaticName	*/
								NULL,				/* Base			*/
								NULL,				/* Fields		*/
								0					/* FieldCnt		*/
							);
							SymbolTable->u.proc.parms = s->u.proc.parms;
							SymbolTable->u.proc.returns = d->u.proc.returns;
							SymbolTable->u.proc.use = s->u.proc.use;
							SymbolTable->u.proc.Locals = s->u.proc.Locals;
							SymbolTable->u.proc.Forward = s->u.proc.Forward;
							SymbolTable->u.proc.BaseClass = s->u.proc.BaseClass;
							SymbolTable->u.proc.ParmSize = s->u.proc.ParmSize;
							SymbolTable->u.proc.cs = s->u.proc.cs;
							d->Type = SymbolTable;
							SymbolTable = d;

							HadPassByValRes = 
								HadPassByValRes || (s->pClass == vrp_pc );


						_elseif
						( 
								s->pClass == vrp_pc 
							||	s->pClass == result_pc  
						)

							assert( s->Type != NULL );
							CurOffset = CurOffset - s->Type->ObjectSize;
							InsertSym
							(
								s->TrueName, 
								s->Type,			/* Type			*/
								s->Type->pType, 	/* pType		*/
								cVar,				/* SymClass		*/ 
								s->Arity,			/* Arity		*/
								s->Dimensions,		/* dimensions	*/
								s->NumElements,		/* # elements	*/
								NULL,				/* Value		*/
								s->Type->ObjectSize,/* ObjectSize	*/
								CurOffset,			/* Offset 		*/
								s->StaticName,		/* StaticName	*/
								s->Base,			/* Base			*/
								s->Fields,			/* Fields		*/
								s->FieldCnt			/* FieldCnt		*/
							);

							HadPassByValRes = 
								HadPassByValRes | (s->pClass == vrp_pc );

						_endif
						s = s->Next;

					_endwhile

				_endif


				/*
				** Compute the number of bytes of local variables
				** and round this number to the larger multiple of
				** four bytes.
				*/

				RoundedOffset = -CurOffset;
				_if( RoundedOffset != ( RoundedOffset & ~3 ))

					RoundedOffset = ( RoundedOffset + 4 ) & ~3;

				_endif

				/*
				** If we have a display, remove the size of the
				** display from the number of local variables.
				*/

				_if( $<options.UseDisplay>8 )

					RoundedOffset = RoundedOffset - ( CurLexLevel + 1 )*4;

				_endif

				/*
				** Create a symbol table entry for the # of bytes
				** of local variables in this procedure.
				*/

				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.u.unsval = RoundedOffset;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);




				/*
				** Output the assembly code for this procedure.
				**
				** For nested procedures (lex level 2 and above)
				** we need to emit the display
				*/

				_if( $<s>5->IsExternal )

					EmitPublic( $<s>5->StaticName );

				_endif
				startCseg();
				_if( $<options.Alignment>8 != 1 )

					EmitAlign( $<options.Alignment>8 );

				_endif
				StartProc( $<s>5->StaticName );
				_if( $<options.UseFrame>8 && !$<options.UseDisplay>8 )


					/*
					** If we're not building a display, just use the
					** standard entry sequence.
					*/

					StdEntry( RoundedOffset, $<options.NoEnter>8 );

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>8 )

						AlignStack();

					_endif

				_elseif( $<options.UseFrame>8 )

					/*
					** We've got to construct the display.
					*/

					ConstructDisplay
					( 
						CurLexLevel, 
						RoundedOffset,
						$<options.NoEnter>8 
					);

					/*
					** Align the stack on a dword boundary.
					*/

					_if( AlwaysAlignStk && $<options.AlignStk>8 )

						AlignStack();

					_endif

				_endif


				/*
				** If we have any pass by value/result parameters, emit
				** code to copy the data into the local storage allocated
				** to hold the parameter.  Note that we do not copy pass
				** by result parameters here because they are "out only"
				** variables.
				*/

				_if( $<options.UseFrame>8 && HadPassByValRes )

					CopyValResParms( $<s>5 );

				_endif



				assert( $<neID.idStr>14 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>14 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'begin' must match "
						"iterator name <<%s>>",
						$<neID.idStr>14,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif

				/*
				** Check to ensure that all forward declared procedures
				** have be defined prior to code emission.
				*/

				CheckForwardDecls( $<s>9 );

				/*
				** Check to make sure all pointer forward references have
				** been resolved.
				*/

				CheckPtrs();

				free2( vss $<neID.idStr>14 );




				/*
				** Emit the text associated with the _initialize_ string
				** at this point.
				**
				**	Note: the "InvisibleCode" variable is used by
				**	yyerror to determine if it should print the
				**	_initialize_ string as part of the error message.
				*/

				
				$<s>$ = lookup( "_finalize_", 1 );
				assert( $<s>$ != NULL );
				_if( $<options.UseFrame>8 )
				
					s=$<s>$->Next;
					InvisibleCode = NULL;
					_if
					( 
							s->pType != tString 
						&&	s->pType != tZString 
					)

						WarnNear
						( 
							"_initialize_'s type is not string.  "
							"Initialization ignored.",
							"_initialize_" 
						);

					_elseif( strlen( s->u.strval ) != 0 )

						InvisibleCode = s->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( s->u.strval );

					_endif
					
				_endif
				_here;

			}

			/*
			** Process the statements in the procedure.
			*/

			Stmts			/* $17 */


			/*
			** Upon encountering the "end" token, check the ID
			** to make sure it matches the procedure name.
			** Just before leaving, restore lex level, offset,
			** direction, and other values saved above.  The
			** other trick this code pulls on its way out is to
			** reset the SymbolTable pointer to point at the
			** original symbol table entry for this procedure
			** (the one entered into the previous lex level).
			** Doing this effectively "hides" all of the symbols
			** introduced in the declaration section from code
			** following this procedure.
			**
			*/
			 
			endTkn 			/* $18 */
			AnyID			/* $19 */
			Semicolon		/* $20 */
			{				/* $21 */


				_here;
				assert( $<neID.idStr>19 != NULL );

				_if( _strne( $<s>5->TrueName, $<neID.idStr>19 ))

					char msg[ 256 ];

					sprintf
					( 
						msg,
						"Identifier <<%s>> after 'end' must match "
						"iteator name <<%s>>",
						$<neID.idStr>19,
						$<s>5->TrueName
					);

					yyerror( msg );

				_endif



				/*
				** Emit the label at the end of the procedure
				*/

				PushBackStr( "end" );
				_if( $<options.UseFrame>8 )

					char lbl[256];
					
					sprintf( lbl, "x%s" sympost, $<s>5->StaticName );
					EmitStmtLbl( lbl );


					/*
					** Deal with the _finalize_ string here.
					*/

					InvisibleCode = NULL;
					_if
					(
							$<s>16->pType != tString 
						&&	$<s>16->pType != tZString 
					)

						WarnNear
						(
							"_finalize_ must be a string constant.  Value ignored",
							"_finalize_"
						);

					_elseif( strlen( $<s>16->u.strval ) != 0 )

						InvisibleCode = $<s>16->u.strval;
						PushBackStr( "\xF3" );
						PushBackStr( $<s>16->u.strval );

					_endif
					
				_endif
				_here;
			}
			Stmts		/* $22 */
			endTkn		/* $23 Faked by PushBackStr above	*/
			{			/* $24 */
							 
				struct contextListType	*cNode;
				struct SymNode			*s;
				struct SymNode			*d;

				_here;
	
				/*
				** If we've got any pass by value/result or
				** pass by result parameters, we've got to
				** copy the data back to the caller at this point.
				*/

				_if( $<options.UseFrame>8 )

					StoreValResParms( $<s>5 );

				_endif



				
				--CurLexLevel;
				CurOffset = $<v.u.unsval>2;
				CurOffsetDir = $<v.u.unsval>3;


				/*
				** Remove this procedure's local symbols from
				** further consideration in the symbol table.
				*/

				$<s>5->u.proc.Locals = SymbolTable;
				$<s>10->Next = NULL;
				SymbolTable = $<s>7;

				/*
				** Since this can no longer be an external reference,
				** set the external flag to false.
				*/

				$<s>5->IsExternal = 0;


				/*
				** See if there are any outstanding undefined static
				** objects at lex level zero.
				*/

				CurrentContext = $<s>5;
				CheckStatic( StaticList, 0 );
				CurrentContext = $<s>4;

				/*
				** See if there are any outstanding forward reference
				** labels.
				*/

				CheckFwdRef();


				/*
				** Output the necessary data to the assembly language
				** file to complete this procedure.
				*/

				_if( $<options.UseFrame>8 )

					IteratorExit( $<s>5->u.proc.ParmSize ); 

				_endif
				EndProc( $<s>5->StaticName );
				endCseg();
				free2( vss $<neID.idStr>19 );

				inIterator = 0;

				/*
				** Remove the current context from the context stack.
				*/
				
				_if( $<options.UseFrame>8 )

					assert( contextList != NULL );
					cNode = contextList;
					contextList = cNode->Next;

					assert( _streq( cNode->label, $<s>5->TrueName) );
					free2( vss cNode->StaticName );

				_endif
				
				/*
				** Restore currentNS
				*/
				
				currentNS = $<ru.saveCurNS>11;
				
				_here;
			}
	;






	/*
	** If the user defines a method at an incorrect lex
	** level, slap their wrists here.
	*/

	/*
	** Not sure it's possible to use this production.
	** 4/20/2000 RLH.
	*/

procs:		methodTkn			/* $1 */
			NonLocalMethodID	/* $2 */
			SaveOffset 			/* $3 */
			SaveDirection 		/* $4 */
			SaveContext 		/* $5 */
			SaveThisPtr			/* $6 */
			Semicolon			/* $7 */
			Options				/* $8 */
			{					/* $9 */
				_here;
				yyerror( "Cannot define this method at this lex level" );
				$<s>$ = SymbolTable;
			}
			Declarations		/* $10 */
			beginTkn 			/* $11 */
 			AnyID				/* $12 */
  			Semicolon			/* $13 */
 			{					/* $14 */
				_here;
				free2( vss $<neID.idStr>12 );
			}
			Stmts				/* $15 */
			endTkn 				/* $16 */
			AnyID				/* $17 */
			Semicolon			/* $18 */
			{					/* $19 */

				_here;
				--CurLexLevel;
				CurOffset = $<v.u.unsval>3;
				CurOffsetDir = $<v.u.unsval>4;
				ThisPtr = $<s>6;
				$<s>2->u.proc.Locals = SymbolTable;
				SymbolTable = $<s>9;
				free2( vss $<neID.idStr>17 );
				_here;
			}
		;






/*****************************************************/








 /*
 ** ClassStuff-
 **
 ** Handle the "guts" of a class declaration.
 **
 */



ClassStuff:
			/* Empty */

	|		GetLexLvl 
			constTkn 	
			Constants			
			optionalEndConst
			{
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>5;	//Shut up bison
			}


	|		GetLexLvl 
			valTkn 	
			Values			
			optionalEndVal
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>5;	//Shut up bison
			}


	|		GetLexLvl 
			varTkn 	
			RecVars			
			optionalEndVar
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>5;	//Shut up bison
			}


	|		GetLexLvl 
			staticTkn 	
			StaticVars			
			optionalEndStatic
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>5;	//Shut up bison
			}

	|		GetLexLvl
			uninitializedTkn
			UninitVars			
			optionalEndStorage
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>5;	//Shut up bison
			}


	|		GetLexLvl 
			readonlyTkn 	
			ReadOnlyVars
			optionalEndRO			
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>5;	//Shut up bison
			}


	|		GetLexLvl 
			procTkn
			{
				$<v>$ = $<v>1;
			} 	
			newClassProcDCLs
			optionalEndProc
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>3;	//Shut up bison
				(void) $<v.u.intval>6;	//Shut up bison
			}


	|		GetLexLvl
			overrideTkn 
			procTkn
			{
				_here;
				$<v>$ = $<v>1;
			} 	
			newClassOverrideDCLs
			optionalEndProc 
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>4;	//Shut up bison
				(void) $<v.u.intval>7;	//Shut up bison
			}


	|		GetLexLvl 
			ClassProc 	
			optionalSemicolon			
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>4;	//Shut up bison
			}

	|		GetLexLvl 
			FwdMethod 	
			optionalSemicolon			
			{ 
				_here; 
				$<v.u.intval>$ = $<v.u.intval>1; 
			}
			ClassStuff
			{
				_here;
				(void) $<v.u.intval>4;	//Shut up bison
			}
	;


GetLexLvl:	
		{ 
			_here; 
			$<v.u.intval>$ = $<v.u.intval>0; 
		}
	;


// Handle new-style class procedure/method/iterator declarations here:
//
// newClassProcs -> "proc" newClassProcDCLs

newClassProcDCLs:
		Empty
		{
			_here;
		}
	;
	
newClassProcDCLs:
		{ _here;$<v>$ = $<v>0; }	/* $1 Pass the lex level to newClassProc */
		newClassProc				/* $2 */
		{ _here;$<v>$ = $<v>1; }	/* $3 */
		newClassProcDCLs			/* $4 */
		{ _here;(void) $<v>3;  }	/* $5 */
	;





newClassOverrideDCLs:
		Empty
		{
			_here;
		}
	;
	
newClassOverrideDCLs:
		{ _here;$<v>$ = $<v>0; }		/* $1 Pass the lex level to newClassProc */
		newClassOverride				/* $2 */
		{ _here;$<v>$ = $<v>1; }		/* $3 */
		newClassOverrideDCLs			/* $4 */
		{ _here;(void) $<v>3;  }		/* $5 */
	;







 /*
 ** Handle a standard method declaration that appears within a class.
 */

FwdMethod:	
		methodTkn		/* $1 */
		UndefinedID 	/* $2 */
		SaveOffset 		/* $3 */
		SaveDirection	/* $4 */
		SaveContext 	/* $5 */
		FMSaveLexLvl	/* $6 	Saves CurLexLevel here and sets it to $0 */
		EnterName4		/* $7 */
		OptionalParms 	/* $8 */
		Semicolon		/* $9 */
		Options			/* $10 */
		{				/* $11 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** EnterName entered this code into the symbol
			** table as a procedure rather than as a method.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cMethod;
			$<en.s>7->pType = tMethod;

			// Methods always use the pascal calling sequence
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;

			/*
			** Enter the "returns" value into the symbol table.
			*/
			
			$<en.s>7->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.use = $<options.use>10;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_returns 
				|	specified_use
			);



			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>10;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;

			/*
			** This guy isn't external, so ensure that:
			*/
			
			$<en.s>7->IsExternal = 0;
				

			/*
			** Remove this methods's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class method declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;

			_endwhile
		
			ParmList->Next = NULL;
			
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (method parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			
			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;
			
			/*
			** Restore currentNS
			*/

			currentNS = $<en.cns>7;
			_here;
		}
	;
	


colonMethod:
			':'
			methodTkn
			{
				_here;
				$<idStr>$ = $<idStr>0;
			}
		;




 /*
 ** Handle a standard method declaration that appears within a class.
 */

newClassProc:	
		UndefinedID 			/* $1  */
		colonMethod				/* $2  */
		SaveOffset 				/* $3  */
		SaveDirection			/* $4  */
		SaveContext 			/* $5  */
		FMSaveLexLvl			/* $6 	Saves CurLexLevel here and sets it to $0 */
		EnterName4				/* $7  */
		OptionalParms 			/* $8  */
		newProcOptionsSemicolon	/* $9  */
		{						/* $10 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** EnterName entered this code into the symbol
			** table as a procedure rather than as a method.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cMethod;
			$<en.s>7->pType = tMethod;

			// Methods always use the pascal calling sequence
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;

			/*
			** Enter the "returns" value into the symbol table.
			*/
			
			$<en.s>7->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.use = $<options.use>9;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
				specified_returns |
				specified_use
			);



			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>9;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;

			/*
			** This guy isn't external, so ensure that:
			*/
			
			$<en.s>7->IsExternal = 0;
				

			/*
			** Remove this methods's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class method declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;

			_endwhile
		
			ParmList->Next = NULL;
			
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (method parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			
			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;
			
			/*
			** Restore currentNS
			*/

			currentNS = $<en.cns>7;
			_here;
		}
	;
	



 /*
 ** Handle an abstract method declaration that appears within a class.
 */

FwdMethod:	
		methodTkn					/* $1 */
		UndefinedID 				/* $2 */
		SaveOffset 					/* $3 */
		SaveDirection				/* $4 */
		SaveContext 				/* $5 */
		FMSaveLexLvl				/* $6 	Save CurLexLevel, set it to $0 */
		EnterName4					/* $7 */
		OptionalParms 				/* $8 */
		Semicolon					/* $9 */
		Options						/* $10 */
		abstractTkn					/* $11 */ 
		Semicolon					/* $12 */
		{							/* $13 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			

			/*
			** EnterName entered this code into the symbol
			** table as a procedure rather than as a method.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cMethod;
			$<en.s>7->pType = tMethod;


			/*
			** Enter the "returns" value into the symbol table.
			*/
			
			$<en.s>7->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.use = $<options.use>10;

			// Methods always use the pascal calling sequence
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_returns 
				|	specified_use
			);

			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>10;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;

			/*
			** It is abstract, so we don't need to have a definition
			** for it later in the code.  We can specify this by claiming
			** that the method is external.
			*/

			$<en.s>7->IsExternal = 1;

			/*
			** The static name assigned earlier is incorrect,
			** substitute the name of the ?abstract procedure
			** to generate a run-time error if the program accidentally
			** calls this abstract procedure.  Also set "HasAbstract" to
			** true so the compiler will emit code for the ?abstract
			** procedure.
			*/

			free2( vss $<en.s>7->StaticName );
			$<en.s>7->StaticName = hlastrdup2( "abstract" sympost );
			HasAbstract = 1;
			need_raise = 1;

			/*
			** Remove this methods's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class method declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (method parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been defined (in the event this
			** external declaration just turns out to be
			** a forward declaration).
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;
			
			/*
			** Restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			_here;
		}
	;




 /*
 ** Handle an abstract method declaration that appears within a class.
 */

newClassProc:	
		UndefinedID 				/* $2  */
		colonMethod					/* $1  */
		SaveOffset 					/* $3  */
		SaveDirection				/* $4  */
		SaveContext 				/* $5  */
		FMSaveLexLvl				/* $6  	Save CurLexLevel, set it to $0 */
		EnterName4					/* $7  */
		OptionalParms 				/* $8  */
		newProcOptionsSemicolon		/* $9  */
		abstractTkn					/* $10 */ 
		Semicolon					/* $11 */
		{							/* $12 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			

			/*
			** EnterName entered this code into the symbol
			** table as a procedure rather than as a method.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cMethod;
			$<en.s>7->pType = tMethod;


			/*
			** Enter the "returns" value into the symbol table.
			*/
			
			$<en.s>7->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.use = $<options.use>9;

			// Methods always use the pascal calling sequence
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_returns 
				|	specified_use
			);

			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>9;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;

			/*
			** It is abstract, so we don't need to have a definition
			** for it later in the code.  We can specify this by claiming
			** that the method is external.
			*/

			$<en.s>7->IsExternal = 1;

			/*
			** The static name assigned earlier is incorrect,
			** substitute the name of the ?abstract procedure
			** to generate a run-time error if the program accidentally
			** calls this abstract procedure.  Also set "HasAbstract" to
			** true so the compiler will emit code for the ?abstract
			** procedure.
			*/

			free2( vss $<en.s>7->StaticName );
			$<en.s>7->StaticName = hlastrdup2( "abstract" sympost );
			HasAbstract = 1;
			need_raise = 1;

			/*
			** Remove this methods's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class method declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (method parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been defined (in the event this
			** external declaration just turns out to be
			** a forward declaration).
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;
			
			/*
			** Restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			_here;
		}
	;


newClassProc:
		UndefinedID		/* $1 */
		':'				/* $2 */
		overloadsTkn	/* $3 */
		saveYYText		/* $4 */
		procID			/* $5 */
		OptionalStr		/* $6 */
		Semicolon		/* $7 */
		{
			struct SymNode	*s;
			struct SymNode	*parmPtr;
			int				parmCnt;
			
		    _here;
		   	doCollect = 0;
			s = InsertSym
				(
					$<idStr>1,			//TrueName
					NULL,				//Type
					tOverloads,			//pType
					cOverloads,			//TheClass
					0,					//Arity
					NULL,				//Dimensions,
					0,					//NumElements,
					NULL,				//TheValue,
					0,					//ObjectSize,
					0,					//Offset,
					NULL,				//StaticName,
					NULL,				//Base,
					NULL,				//Fields,
					0					//FieldCnt
				);
				
			s->u.ovld.nextOvld	= NULL;
			parmPtr				= $<s>5->u.proc.parms;
			s->u.ovld.parms		= parmPtr;
			parmCnt = 0;
			_while( parmPtr->SymClass == cParm )
			
				parmPtr = parmPtr->Next;
				++parmCnt;
				
			_endwhile;
			s->u.ovld.numParms = parmCnt;
			_if( *$<returns>6 != '\0' )
			
				s->u.ovld.procName = $<returns>6;
			
			_else
			
				collectBuf[ collectIndex-1 ] = '\0'; // Trim ';'
				s->u.ovld.procName = hlastrdup2( collectBuf );
				
			_endif
			_here;
		} 
	;
	

newClassProc:
		OverloadedID	/* $1 */
		':'				/* $2 */
		overloadsTkn	/* $3 */			
		saveYYText		/* $4 */
		procID			/* $5 */
		OptionalStr		/* $6 */
		Semicolon		/* $7 */
		{
			struct SymNode	*s;
			struct SymNode	*parmPtr;
			int				parmCnt;
			
			_here;
			doCollect = 0;
			s = InsertSym
				(
					strdup( $<s>1->TrueName ),	//TrueName
					NULL,						//Type
					tOverloads,					//pType
					cOverloads,					//TheClass
					0,							//Arity
					NULL,						//Dimensions,
					0,							//NumElements,
					NULL,						//TheValue,
					0,							//ObjectSize,
					0,							//Offset,
					NULL,						//StaticName,
					NULL,						//Base,
					NULL,						//Fields,
					0							//FieldCnt
				);
				
			s->u.ovld.nextOvld	= $<s>1;
			parmPtr				= $<s>5->u.proc.parms;
			s->u.ovld.parms		= parmPtr;
			parmCnt = 0;
			_while( parmPtr->SymClass == cParm )
			
				parmPtr = parmPtr->Next;
				++parmCnt;
				
			_endwhile;
			s->u.ovld.numParms = parmCnt;
			_if( *$<returns>6 != '\0' )
			
				s->u.ovld.procName = $<returns>6;
				
			_else
			
				s->u.ovld.procName = hlastrdup( collectBuf );
				
			_endif
			_here;
		}
	;
	

	



 /*
 ** Handle an overridden method declaration that appears within a class.
 */

omID:
		overrideTkn			/* $1 */
		methodTkn			/* $2 */
		LocalMethodID		/* $3 */
		{ 
			_here;
			$<s>$ = $<s>3; 
		}

	|	overrideTkn
		methodTkn
		NonLocalMethodID /* Need this because lex level is probably -256 */
		{ 
			_here;
			$<s>$ = $<s>3; 
		}
	;


FwdMethod:	
		omID		 		/* $1 */
		Semicolon			/* $2 */
		{					/* $3 */

			char   StaticName[ 256 ];
			struct MethodListType	*ml;
			struct SymNode *sym;


			_here;

			/*
			** Verify that the lex level of the original method
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden method does not match\n"
					"the lex level of the original method"
				);

			_endif

			/*
			** Change the symbol's static ID at this point.
			*/

			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			
			sprintf( StaticName, "%s" sympost "%d", $<s>1->TrueName, LblCntr++ );
			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = hlastrdup2( StaticName );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); // Not a unique ptr!
				sym->StaticName = hlastrdup2( StaticName );

			_endif

			/*
			** Ensure that this is not an external ID.
			*/

			$<s>1->IsExternal = 0;
			SetReferenced( $<s>1 );


			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;



			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			_here;
		}
	;






omID2:
		LocalMethodID		/* $1 */
		':'					/* $2 */
		methodTkn			/* $3 */
		{ 
			_here;
			$<s>$ = $<s>1; 
		}

	|	NonLocalMethodID /* Need this because lex level is probably -256 */
		':'
		methodTkn
		{ 
			_here;
			$<s>$ = $<s>1; 
		}
	;


newClassOverride:	
		omID2				/* $1 */
		Semicolon			/* $2 */
		{					/* $3 */

			char   StaticName[ 256 ];
			struct MethodListType	*ml;
			struct SymNode *sym;


			_here;

			/*
			** Verify that the lex level of the original method
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden method does not match\n"
					"the lex level of the original method"
				);

			_endif

			/*
			** Change the symbol's static ID at this point.
			*/

			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			
			sprintf( StaticName, "%s" sympost "%d", $<s>1->TrueName, LblCntr++ );
			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = hlastrdup2( StaticName );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); // Not a unique ptr!
				sym->StaticName = hlastrdup2( StaticName );

			_endif

			/*
			** Ensure that this is not an external ID.
			*/

			$<s>1->IsExternal = 0;
			SetReferenced( $<s>1 );


			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;



			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			_here;
		}
	;




	/*
	** Handle an overridden external method here.
	*/

FwdMethod:	
		omID		 	/* $1 */
		Semicolon		/* $2 */
		externalTkn		/* $3 */
		{				/* $4 */ 

			char DefaultName[ 256 ];

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <procname>
			*/
			
			_here;
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<s>1->TrueName );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName	/* $5 */ 
		{				/* $6 */

			char   StaticName[ 256 ];
			struct MethodListType	*ml;
			struct SymNode	*sym;


			_here;

			/*
			** Verify that the lex level of the original method
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden method does not match\n"
					"the lex level of the original method"
				);

			_endif

			/*
			** Change the symbol's static ID at this point.
			*/

			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = $<idStr>5;
			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>5 );

			_endif

			/*
			** Ensure that this is an external ID.
			*/

			$<s>1->IsExternal = 1;

			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;



			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<s>1, $<s>1->StaticName, tLabel );
			(void) $<idStr>4;	// shut up bison
			_here;
		}
	;








newClassOverride:	
		omID2		 	/* $1 */
		Semicolon		/* $2 */
		externalTkn		/* $3 */
		{				/* $4 */ 

			char DefaultName[ 256 ];

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <procname>
			*/
			
			_here;
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<s>1->TrueName );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName	/* $5 */ 
		{				/* $6 */

			char   StaticName[ 256 ];
			struct MethodListType	*ml;
			struct SymNode	*sym;


			_here;

			/*
			** Verify that the lex level of the original method
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden method does not match\n"
					"the lex level of the original method"
				);

			_endif

			/*
			** Change the symbol's static ID at this point.
			*/

			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = $<idStr>5;
			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>5 );

			_endif

			/*
			** Ensure that this is an external ID.
			*/

			$<s>1->IsExternal = 1;

			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;



			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<s>1, $<s>1->StaticName, tLabel );
			(void) $<idStr>4;	// shut up bison
			_here;
		}
	;








FwdMethod:	
		methodTkn					/* $1 */
		UndefinedID 				/* $2 */
		SaveOffset 					/* $3 */
		SaveDirection				/* $4 */
		SaveContext 				/* $5 */
		FMSaveLexLvl				/* $6 	Save CurLexLevel, set it to $0 */
		EnterName4					/* $7 */
		OptionalParms 				/* $8 */
		Semicolon					/* $9 */
		Options						/* $10 */
		externalTkn					/* $11 */ 
		{							/* $12 */ 

			char DefaultName[ 256 ];

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <methodname>
			*/
			
			_here;
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<idStr>2 );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName				/* $13 */ 
		{							/* $14 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;
			struct SymNode			*sym;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** EnterName entered this code into the symbol
			** table as a procedure rather than as a method.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cMethod;
			$<en.s>7->pType = tMethod;


			/*
			** Enter the "returns" value into the symbol table.
			*/
			
			$<en.s>7->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.use = $<options.use>10;

			// Methods always use the pascal calling sequence
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_returns 
				|	specified_use
			);

			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>10;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;

			/*
			** It is also external, deal with that here.
			*/

			$<en.s>7->IsExternal = 1;

			free2( vss $<en.s>7->StaticName );
			$<en.s>7->StaticName = $<idStr>13;
			sym = lookupin( $<en.s>7->TrueName, $<en.s>7->u.proc.parms );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>13 );

			_endif


			/*
			** Remove this methods's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class method declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (method parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been defined (in the event this
			** external declaration just turns out to be
			** a forward declaration).
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<en.s>7, $<en.s>7->StaticName, tLabel );
			
			/*
			** restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			(void) $<idStr>12;	// shut up bison
			_here;
		}
	;





newClassProc:	
		UndefinedID 				/* $1  */
		colonMethod					/* $2  */
		SaveOffset 					/* $3  */
		SaveDirection				/* $4  */
		SaveContext 				/* $5  */
		FMSaveLexLvl				/* $6  	Save CurLexLevel, set it to $0 */
		EnterName4					/* $7  */
		OptionalParms 				/* $8  */
		newProcOptionsSemicolon		/* $9  */
		externalTkn					/* $10 */ 
		{							/* $11 */ 

			char DefaultName[ 256 ];

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <methodname>
			*/
			
			_here;
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<idStr>2 );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName				/* $12 */
		Semicolon					/* $13 */ 
		{							/* $14 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;
			struct SymNode			*sym;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** EnterName entered this code into the symbol
			** table as a procedure rather than as a method.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cMethod;
			$<en.s>7->pType = tMethod;


			/*
			** Enter the "returns" value into the symbol table.
			*/
			
			$<en.s>7->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.use = $<options.use>9;

			// Methods always use the pascal calling sequence
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_returns 
				|	specified_use
			);

			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>9;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;

			/*
			** It is also external, deal with that here.
			*/

			$<en.s>7->IsExternal = 1;

			free2( vss $<en.s>7->StaticName );
			$<en.s>7->StaticName = $<idStr>12;
			sym = lookupin( $<en.s>7->TrueName, $<en.s>7->u.proc.parms );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>12 );

			_endif


			/*
			** Remove this methods's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class method declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (method parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been defined (in the event this
			** external declaration just turns out to be
			** a forward declaration).
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<en.s>7, $<en.s>7->StaticName, tLabel );
			
			/*
			** restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			(void) $<idStr>11;	// shut up bison
			_here;
		}
	;





	/*
	** Save the current lex level in the attribute and
	** set the lex level to the value specified by the
	** attribute immediately before the FwdMethod token.
	*/

FMSaveLexLvl:
		{

			$<v.u.intval>$ = CurLexLevel;
			CurLexLevel = $<v.u.intval>-5;
			_here;
		}
	;










 /*
 ** Handle a class iterator declaration that appears within a class.
 */

FwdMethod:	
		iteratorTkn		/* $1 */
		UndefinedID 	/* $2 */
		SaveOffset 		/* $3 */
		SaveDirection	/* $4 */
		SaveContext 	/* $5 */
		FMSaveLexLvl	/* $6 	Saves CurLexLevel here and sets it to $0 */
		EnterIterName4	/* $7 */
		OptionalParms 	/* $8 */
		Semicolon		/* $9 */
		{				/* $10 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;

			
			/*
			** EnterIterName entered this code into the symbol
			** table as an iterator rather than as a class iterator.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cClassIter;
			$<en.s>7->pType = tClassIter;
			$<en.s>7->Type = &classiterID_ste;


			/*
			** Enter the "returns" value into the symbol table.
			** (Iterators can't appear in an expression, so return
			** the empty string.)
			*/
			
			$<en.s>7->u.proc.returns = hlastrdup2( "" );
			$<en.s>7->u.proc.use = NULL;

			// Iterators always use the pascal calling sequence
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;


			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = hlastrdup2( "" );
			$<en.s>7->u.proc.parms->u.proc.use = NULL;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this iterator.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward iterator, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;

			/*
			** Remove this iterator's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class iterator declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (classiter parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this iterator to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;
			
			/*
			** restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			
			_here;
		}
	;






		
		
 /*
 ** Handle a class iterator declaration that appears within a class.
 */

newClassProc:	
		UndefinedID 	/* $2 */
		colonIterator	/* $1 */
		SaveOffset 		/* $3 */
		SaveDirection	/* $4 */
		SaveContext 	/* $5 */
		FMSaveLexLvl	/* $6 	Saves CurLexLevel here and sets it to $0 */
		EnterIterName4	/* $7 */
		OptionalParms 	/* $8 */
		Semicolon		/* $9 */
		{				/* $10 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;

			
			/*
			** EnterIterName entered this code into the symbol
			** table as an iterator rather than as a class iterator.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cClassIter;
			$<en.s>7->pType = tClassIter;
			$<en.s>7->Type = &classiterID_ste;


			/*
			** Enter the "returns" value into the symbol table.
			** (Iterators can't appear in an expression, so return
			** the empty string.)
			*/
			
			$<en.s>7->u.proc.returns = hlastrdup2( "" );
			$<en.s>7->u.proc.use = NULL;

			// Iterators always use the pascal calling sequence
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;


			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = hlastrdup2( "" );
			$<en.s>7->u.proc.parms->u.proc.use = NULL;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this iterator.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward iterator, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;

			/*
			** Remove this iterator's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class iterator declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (classiter parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this iterator to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;
			
			/*
			** restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			
			_here;
		}
	;






		
		
 /*
 ** Handle an overridden iterator declaration that appears within a class.
 */

oiID:
		overrideTkn			/* $1 */
		iteratorTkn			/* $2 */
		LocalIterID			/* $3 */
		{
			_here;
			$<s>$ = $<s>3; 
		}

	|	overrideTkn
		iteratorTkn
		NonLocalIterID /* Need this because lex level is probably -256 */
		{ 
			_here;
			$<s>$ = $<s>3; 
		}

	|	overrideTkn
		iteratorTkn
		ClassIterID /* Need this because lex level is probably -256 */
		{ 
			_here;
			$<s>$ = $<s>3; 
		}
	;




FwdMethod:	
		oiID		 		/* $1 */
		Semicolon			/* $2 */
		{					/* $3 */

			char   StaticName[ 256 ];
			struct MethodListType	*ml;
			struct SymNode *sym;


			_here;

			/*
			** Verify that the lex level of the original iterator
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden iterator does not match\n"
					"the lex level of the original iterator"
				);

			_endif

			/*
			** Change the symbol's static ID at this point.
			*/

			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			
			sprintf( StaticName, "%s" sympost "%d", $<s>1->TrueName, LblCntr++ );
			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = hlastrdup2( StaticName );
			_if( sym != NULL )

				sym->StaticName = hlastrdup2( StaticName );

			_endif

			/*
			** Ensure that this is not an external ID.
			*/

			$<s>1->IsExternal = 0;
			SetReferenced( $<s>1 );


			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;



			/*
			** This is a forward iterator, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			_here;
		}
	;






oiID2:
		LocalIterID			/* $1 */
		iteratorTkn			/* $2 */
		{
			_here;
			$<s>$ = $<s>1; 
		}

	|	NonLocalIterID 		/* Need this because lex level is probably -256 */
		':'					/* $2 */
		iteratorTkn
		{ 
			_here;
			$<s>$ = $<s>1; 
		}

	|	ClassIterID /* Need this because lex level is probably -256 */
		':'
		iteratorTkn
		{ 
			_here;
			$<s>$ = $<s>1; 
		}
	;




newClassOverride:	
		oiID2		 		/* $1 */
		Semicolon			/* $2 */
		{					/* $3 */

			char   StaticName[ 256 ];
			struct MethodListType	*ml;
			struct SymNode *sym;


			_here;

			/*
			** Verify that the lex level of the original iterator
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden iterator does not match\n"
					"the lex level of the original iterator"
				);

			_endif

			/*
			** Change the symbol's static ID at this point.
			*/

			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			
			sprintf( StaticName, "%s" sympost "%d", $<s>1->TrueName, LblCntr++ );
			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = hlastrdup2( StaticName );
			_if( sym != NULL )

				sym->StaticName = hlastrdup2( StaticName );

			_endif

			/*
			** Ensure that this is not an external ID.
			*/

			$<s>1->IsExternal = 0;
			SetReferenced( $<s>1 );


			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;



			/*
			** This is a forward iterator, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			_here;
		}
	;






	/*
	** Handle an overridden external method here.
	*/

FwdMethod:	
		oiID		 	/* $1 */
		Semicolon		/* $2 */
		externalTkn		/* $3 */
		{				/* $4 */ 

			char DefaultName[ 256 ];

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <itername>
			*/
			
			_here;
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<s>1->TrueName );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName	/* $5 */ 
		{				/* $6 */

			char   StaticName[ 256 ];
			struct MethodListType	*ml;
			struct SymNode	*sym;


			_here;

			/*
			** Verify that the lex level of the original iterator
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden iterator does not match\n"
					"the lex level of the original iterator"
				);

			_endif

			/*
			** Change the symbol's static ID at this point.
			*/

			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = $<idStr>5;
			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			_if( sym != NULL )

				sym->StaticName = hlastrdup2( $<idStr>5 );

			_endif

			/*
			** Ensure that this is an external ID.
			*/

			$<s>1->IsExternal = 1;

			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;



			/*
			** This is a forward iterator, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<s>1, $<s>1->StaticName, tLabel );
			(void) $<idStr>4;	// shut up bison
			_here;
		}
	;











	/*
	** Handle an overridden external method here.
	*/

newClassOverride:	
		oiID2		 	/* $1 */
		Semicolon		/* $2 */
		externalTkn		/* $3 */
		{				/* $4 */ 

			char DefaultName[ 256 ];

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <itername>
			*/
			
			_here;
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<s>1->TrueName );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName	/* $5 */ 
		{				/* $6 */

			char   StaticName[ 256 ];
			struct MethodListType	*ml;
			struct SymNode	*sym;


			_here;

			/*
			** Verify that the lex level of the original iterator
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden iterator does not match\n"
					"the lex level of the original iterator"
				);

			_endif

			/*
			** Change the symbol's static ID at this point.
			*/

			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = $<idStr>5;
			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			_if( sym != NULL )

				sym->StaticName = hlastrdup2( $<idStr>5 );

			_endif

			/*
			** Ensure that this is an external ID.
			*/

			$<s>1->IsExternal = 1;

			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;



			/*
			** This is a forward iterator, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this method to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<s>1, $<s>1->StaticName, tLabel );
			(void) $<idStr>4;	// shut up bison
			_here;
		}
	;











 /*
 ** Handle an external class iterator declaration 
 ** that appears within a class.
 */

FwdMethod:	
		iteratorTkn		/* $1  */
		UndefinedID 	/* $2  */
		SaveOffset 		/* $3  */
		SaveDirection	/* $4  */
		SaveContext 	/* $5  */
		FMSaveLexLvl	/* $6 	Saves CurLexLevel here and sets it to $0 */
		EnterIterName4	/* $7  */
		OptionalParms 	/* $8  */
		Semicolon		/* $9  */
		Empty			/* $10 */
		externalTkn		/* $11 */ 
		{				/* $12 */ 

			char DefaultName[ 256 ];

			_here;

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <methodname>
			*/
			
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<idStr>2 );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName		/* $13 */ 
		{					/* $14 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct SymNode			*sym;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** EnterIterName entered this code into the symbol
			** table as an iterator rather than as a class iterator.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cClassIter;
			$<en.s>7->pType = tClassIter;
			$<en.s>7->Type = &classiterID_ste;


			/*
			** Enter the "returns" value into the symbol table.
			** (Iterators can't appear in an expression, so return
			** the empty string.)
			*/
			
			$<en.s>7->u.proc.returns = hlastrdup2( "" );
			$<en.s>7->u.proc.use = NULL;

			// Iterators always use pascal calling sequence:
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;


			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = hlastrdup2( "" );
			$<en.s>7->u.proc.parms->u.proc.use = NULL;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this iterator.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward iterator, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;


			/*
			** This symbol is external, deal with that here.
			*/

			$<en.s>7->IsExternal = 1;

			free2( vss $<en.s>7->StaticName );
			$<en.s>7->StaticName = $<idStr>13;
			sym = lookupin( $<en.s>7->TrueName, $<en.s>7->u.proc.parms );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>13 );

			_endif

			/*
			** Remove this iterator's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class iterator declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (classiter parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this iterator to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;


			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;

			/*
			** Output an externdef directive to keep
			** MASM happy.
			*/

			EmitTypedExtern( $<en.s>7, $<en.s>7->StaticName, tLabel );
			
			/*
			** Restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			(void) $<idStr>12;	// shut up bison
			_here;
		}
	;






		
		

 /*
 ** Handle an external class iterator declaration 
 ** that appears within a class.
 */

newClassProc:	
		UndefinedID 			/* $1  */
		colonIterator			/* $2  */
		SaveOffset 				/* $3  */
		SaveDirection			/* $4  */
		SaveContext 			/* $5  */
		FMSaveLexLvl			/* $6 	Saves CurLexLevel here and sets it to $0 */
		EnterIterName4			/* $7  */
		OptionalParms 			/* $8  */
		newProcOptionsSemicolon	/* $9  */
		Empty					/* $10 */
		externalTkn				/* $11 */ 
		{						/* $12 */ 

			char DefaultName[ 256 ];

			_here;

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <methodname>
			*/
			
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<idStr>2 );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName		/* $13 */
		Semicolon			/* $14 */ 
		{					/* $15 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct SymNode			*sym;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
				specified_use
			);

			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** EnterIterName entered this code into the symbol
			** table as an iterator rather than as a class iterator.
			** We need to fix that here.
			*/

			$<en.s>7->SymClass = cClassIter;
			$<en.s>7->pType = tClassIter;
			$<en.s>7->Type = &classiterID_ste;


			/*
			** Enter the "returns" value into the symbol table.
			** (Iterators can't appear in an expression, so return
			** the empty string.)
			*/
			
			$<en.s>7->u.proc.returns = hlastrdup2( "" );
			$<en.s>7->u.proc.use = $<options.use>9;

			// Iterators always use pascal calling sequence:
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;


			/*
			** Set the BaseClass field to point at the base
			** class for this symbol.
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = hlastrdup2( "" );
			$<en.s>7->u.proc.parms->u.proc.use = NULL;

			/*
			** Mark the end of the parameters in the symbol table.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this iterator.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward iterator, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;


			/*
			** This symbol is external, deal with that here.
			*/

			$<en.s>7->IsExternal = 1;

			free2( vss $<en.s>7->StaticName );
			$<en.s>7->StaticName = $<idStr>13;
			sym = lookupin( $<en.s>7->TrueName, $<en.s>7->u.proc.parms );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>13 );

			_endif

			/*
			** Remove this iterator's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class iterator declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (classiter parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this iterator to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;


			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;

			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;

			/*
			** Output an externdef directive to keep
			** MASM happy.
			*/

			EmitTypedExtern( $<en.s>7, $<en.s>7->StaticName, tLabel );
			
			/*
			** Restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			(void) $<idStr>12;	// shut up bison
			_here;
		}
	;






		
		

/*
** SaveClassPtr, SaveThisPtr-
**
** Stacks up the ClassPtr and ThisPtr variables so they can be restored later.
*/

SaveClassPtr:	{ _here; $<s>$ = ClassPtr; _here; };
SaveThisPtr:	{ _here; $<s>$ = ThisPtr; _here;  };









/*
** Handle (static) procedure declarations appearing within
** a class declaration.
*/

ClassProc:	
		procedureTkn		/* $1  */ 
		UndefinedID 		/* $2  */
		SaveOffset 			/* $3  */
		SaveDirection		/* $4  */
		SaveContext 		/* $5  */
		FMSaveLexLvl		/* $6  */
		EnterName4			/* $7  */
		OptionalParms 		/* $8  */
		Semicolon			/* $9  */
		Options				/* $10 */
		{					/* $11 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;

			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** Enter the optional "returns" value into the symbol table.
			*/
			

			$<en.s>7->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.use = $<options.use>10;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_returns 
				|	specified_use
			);

			/*
			** Save a pointer to this procedure's class' symbol
			** table entry for later reference:
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;

			/*
			** EnterName entered this symbol as a "cProc" object.
			** It really needs to be a "cClassProc" and "tClassProc"
			** object since it is a static procedure in a class.
			** Handle that change here.
			*/

			$<en.s>7->SymClass = cClassProc;
			$<en.s>7->pType = tClassProc;
			$<en.s>7->Type = &classprocID_ste;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>10;
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;

			/*
			** Mark the end of the parameter list.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;


			/*
			** Remove this procedure's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class procedure declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;
			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (classproc parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this (static) class procedure to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;
			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;
			
			/*
			** Restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			
			_here;
		}
	;


/*
** Handle (static) procedure declarations appearing within
** a class declaration (new syntax).
*/

newClassProc:	
		UndefinedID 			/* $1  */
		colonProcedure			/* $2  */
		SaveOffset 				/* $3  */
		SaveDirection			/* $4  */
		SaveContext 			/* $5  */
		FMSaveLexLvl			/* $6  */
		EnterName4				/* $7  */
		OptionalParms 			/* $8  */
		newProcOptionsSemicolon	/* $9  */
		{						/* $10 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;

			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** Enter the optional "returns" value into the symbol table.
			*/
			

			$<en.s>7->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.use = $<options.use>9;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_returns 
				|	specified_use
			);

			/*
			** Save a pointer to this procedure's class' symbol
			** table entry for later reference:
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;

			/*
			** EnterName entered this symbol as a "cProc" object.
			** It really needs to be a "cClassProc" and "tClassProc"
			** object since it is a static procedure in a class.
			** Handle that change here.
			*/

			$<en.s>7->SymClass = cClassProc;
			$<en.s>7->pType = tClassProc;
			$<en.s>7->Type = &classprocID_ste;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>9;
			
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.cs = pascal_cs;

			/*
			** Mark the end of the parameter list.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;


			/*
			** Remove this procedure's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class procedure declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;
			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (classproc parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this (static) class procedure to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;
			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;
			
			/*
			** Restore currentNS
			*/
			
			currentNS = $<en.cns>7;
			
			_here;
		}
	;


	/*
	** Handle an external class procedure here.
	*/

ClassProc:	
		procedureTkn				/* $1  */ 
		UndefinedID 				/* $2  */
		SaveOffset 					/* $3  */
		SaveDirection				/* $4  */
		SaveContext 				/* $5  */
		FMSaveLexLvl				/* $6  */
		EnterName4					/* $7  */
		OptionalParms 				/* $8  */
		Semicolon					/* $9  */
		Options						/* $10 */
		externalTkn					/* $11 */ 
		{							/* $12 */ 

			char DefaultName[ 256 ];

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <procname>
			*/
			
			_here;
			
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<idStr>2 );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName				/* $13 */ 
		{							/* $14 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct SymNode			*sym;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** Enter the optional "returns" value into the symbol table.
			*/

			$<en.s>7->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.use = $<options.use>10;
			
			
			// Always use pascal calling sequence for class stuff:
			
			$<en.s>7->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
				specified_returns
			);

			/*
			** Save a pointer to this procedure's class' symbol
			** table entry for later reference:
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;

			/*
			** EnterName entered this symbol as a "cProc" object.
			** It really needs to be a "cClassProc" and "tClassProc"
			** object since it is a static procedure in a class.
			** Handle that change here.
			*/

			$<en.s>7->SymClass = cClassProc;
			$<en.s>7->pType = tClassProc;
			$<en.s>7->Type = &classprocID_ste;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>10;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>10;
			

			/*
			** Mark the end of the parameter list.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;


			/*
			** It is also external, deal with that here.
			*/

			$<en.s>7->IsExternal = 1;

			free2( vss $<en.s>7->StaticName );
			$<en.s>7->StaticName = $<idStr>13;
			sym = lookupin( $<en.s>7->TrueName, $<en.s>7->u.proc.parms );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>13 );

			_endif


			/*
			** Remove this procedure's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class procedure declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (classproc parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this (static) class procedure to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;
			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<en.s>7, $<en.s>7->StaticName, tLabel );
			
			/*
			** Restore currentNS:
			*/
			
			currentNS = $<en.cns>7;
			(void) $<idStr>12;	//shut up bison
			_here;
		}
	;





	/*
	** Handle a new-syntax external class procedure here.
	*/

newClassProc:	
		UndefinedID 				/* $1  */
		colonProcedure				/* $2  */
		SaveOffset 					/* $3  */
		SaveDirection				/* $4  */
		SaveContext 				/* $5  */
		FMSaveLexLvl				/* $6  */
		EnterName4					/* $7  */
		OptionalParms 				/* $8  */
		newProcOptionsSemicolon		/* $9  */
		externalTkn					/* $10 */ 
		{							/* $11 */ 

			char DefaultName[ 256 ];

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <procname>
			*/
			
			_here;
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<idStr>2 );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName				/* $12 */
		Semicolon					/* $13 */ 
		{							/* $14 */

			struct SymNode			*ParmList;
			struct SymNode			*s;
			struct SymNode			*sym;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			CurOffset = $<v.u.unsval>3;
			CurOffsetDir = $<v.u.unsval>4;
			
			/*
			** Enter the optional "returns" value into the symbol table.
			*/

			$<en.s>7->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.use = $<options.use>9;
			
			
			// Always use pascal calling sequence for class stuff:
			
			$<en.s>7->u.proc.cs = pascal_cs;
			$<en.s>7->u.proc.parms->u.proc.cs = pascal_cs;

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_returns
				|	specified_use
			);

			/*
			** Save a pointer to this procedure's class' symbol
			** table entry for later reference:
			*/

			$<en.s>7->u.proc.BaseClass = ClassPtr;

			/*
			** EnterName entered this symbol as a "cProc" object.
			** It really needs to be a "cClassProc" and "tClassProc"
			** object since it is a static procedure in a class.
			** Handle that change here.
			*/

			$<en.s>7->SymClass = cClassProc;
			$<en.s>7->pType = tClassProc;
			$<en.s>7->Type = &classprocID_ste;


			/*
			** Patch the local symbol table entry's proc.parms
			** field first, then store the address of the start
			** of parameters into the main symbol table entry
			** for this procedure.
			*/


			$<en.s>7->u.proc.parms->u.proc.parms = SymbolTable;
			$<en.s>7->u.proc.parms->u.proc.returns = $<options.returns>9;
			$<en.s>7->u.proc.parms->u.proc.use = $<options.use>9;
			

			/*
			** Mark the end of the parameter list.
			*/

			$<en.s>7->u.proc.parms = SymbolTable;

			/*
			** Create a symbol table entry for the # of bytes
			** of parameters in this procedure.
			*/

			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.u.unsval = $<v.u.unsval>8;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<en.s>7->u.proc.Forward = SymbolTable;


			/*
			** It is also external, deal with that here.
			*/

			$<en.s>7->IsExternal = 1;

			free2( vss $<en.s>7->StaticName );
			$<en.s>7->StaticName = $<idStr>12;
			sym = lookupin( $<en.s>7->TrueName, $<en.s>7->u.proc.parms );
			_if( sym != NULL )

				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>12 );

			_endif


			/*
			** Remove this procedure's parameters from
			** further consideration in the symbol table
			** (of course, there are no local symbols for
			** class procedure declarations, but we still have to
			** point proc.Locals at the parameters, if any).
			**
			** NULL terminate the local symbols.
			*/

			$<en.s>7->u.proc.Locals = SymbolTable;

			ParmList = SymbolTable;
			_while( ParmList->Next != $<en.s>7 && ParmList->Next != NULL )

				ParmList = ParmList->Next;
				//assert( ParmList != NULL );

			_endwhile
			ParmList->Next = NULL;
			
			// Create a type for the parameter list.
			
			s =
				InsertSym
				( 
					" (classproc parms) ", 
					NULL,
					tMethod, 
					cMethod, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
			
			s->u.proc.parms = $<en.s>7->u.proc.parms;
			s->u.proc.returns = $<en.s>7->u.proc.returns;
			s->u.proc.use = $<en.s>7->u.proc.use;
			s->u.proc.cs = $<en.s>7->u.proc.cs;
			$<en.s>7->Type = s;
			SymbolTable = $<en.s>7;
			

			/*
			** Add this (static) class procedure to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = SymbolTable;
			ml->LexLevel = CurLexLevel;
			CurrentContext = $<s>5;
			CurLexLevel = $<v.u.intval>6;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<en.s>7, $<en.s>7->StaticName, tLabel );
			
			/*
			** Restore currentNS:
			*/
			
			currentNS = $<en.cns>7;
			(void) $<idStr>11;	//shut up bison
			_here;
		}
	;






	







 /*
 ** Handle overriding a class procedure here.
 */

ClassProc:	
		overrideTkn			/* $1  */ 
		procedureTkn 		/* $2  */
		ClassProcID			/* $3  */
		Semicolon			/* $4  */
		{					/* $5 */

			struct	MethodListType	*ml;
			char					StaticName[ 256 ];


			_here;
			
			/*
			** Verify that the lex level of the original procedure
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>3->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden procedure does not match\n"
					"the lex level of the original procedure"
				);

			_endif


			/*
			** Change the symbol's static ID at this point.
			*/

			sprintf( StaticName, "%s" sympost "%d", $<s>3->TrueName, LblCntr++ );
			$<s>3->StaticName = hlastrdup2( StaticName );

			/*
			** Make sure this isn't treated as an external declaration.
			*/

			$<s>3->IsExternal = 0;


			/*
			** Save a pointer to this procedure's class' symbol
			** table entry for later reference:
			*/

			$<s>3->u.proc.BaseClass = ClassPtr;

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<s>3->u.proc.Forward = $<s>3; /* Any non-NULL value works */


			/*
			** Add this (static) class procedure to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>3;
			ml->LexLevel = CurLexLevel;

			_here;
		}
	;

 /*
 ** Handle overriding a class procedure here.
 */

newClassOverride:	
		ClassProcID			/* $1  */
		colonProcedure		/* $2  */
		Semicolon			/* $3  */
		{					/* $4  */

			struct	MethodListType	*ml;
			char					StaticName[ 256 ];


			_here;
			
			/*
			** Verify that the lex level of the original procedure
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )
			
				char msg[256];

				sprintf
				( 
					msg,
					"Lex level of overriden procedure (%d) does not match\n"
					"the lex level of the original procedure (%d)",
					$<s>1->LexLevel,
					$<v.u.intval>0
				);
				yyerror( msg );

			_endif


			/*
			** Change the symbol's static ID at this point.
			*/

			sprintf( StaticName, "%s" sympost "%d", $<s>1->TrueName, LblCntr++ );
			$<s>1->StaticName = hlastrdup2( StaticName );

			/*
			** Make sure this isn't treated as an external declaration.
			*/

			$<s>1->IsExternal = 0;


			/*
			** Save a pointer to this procedure's class' symbol
			** table entry for later reference:
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;

			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-NULL value works */


			/*
			** Add this (static) class procedure to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			_here;
		}
	;





	/*
	** Handle an overridden external class procedure declaration here.
	*/

ClassProc:
		overrideTkn					/* $1 */	
		procedureTkn				/* $2 */ 
		ClassProcID 				/* $3 */
		Semicolon					/* $4 */
		externalTkn					/* $5 */ 
		{							/* $6 */ 

			char DefaultName[ 256 ];

			_here;
			
			/*
			** Verify that the lex level of the original procedure
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>3->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden procedure does not match\n"
					"the lex level of the original procedure"
				);

			_endif

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <procname>
			*/
			
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<s>3->TrueName );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName				/* $7 */ 
		{							/* $8 */

			struct SymNode			*ParmList;
			struct SymNode			*sym;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			
			/*
			** Save a pointer to this procedure's class' symbol
			** table entry for later reference:
			*/

			$<s>3->u.proc.BaseClass = ClassPtr;


					 
			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<s>3->u.proc.Forward = $<s>3; /* Any non-null item works here */


			/*
			** It is also external, deal with that here.
			*/

			$<s>3->IsExternal = 1;

			free2( vss $<s>3->StaticName );
			$<s>3->StaticName = $<idStr>7;
			sym = lookupin( $<s>3->TrueName, $<s>3->u.proc.parms );
			_if( sym != NULL )


				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>7 );

			_endif



			/*
			** Add this (static) class procedure to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>3;
			ml->LexLevel = CurLexLevel;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<s>3, $<s>3->StaticName, tLabel );
			(void) $<idStr>6; // shut up bison
			_here;
		}
	;





	/*
	** Handle an overridden external class procedure declaration here.
	*/

newClassOverride:
		ClassProcID 				/* $1 */
		colonProcedure				/* $2 */ 
		Semicolon					/* $3 */
		externalTkn					/* $4 */ 
		{							/* $5 */ 

			char DefaultName[ 256 ];

			_here;
			
			/*
			** Verify that the lex level of the original procedure
			** is the same as the current lex level (provided by $0).
			*/

			_if( $<s>1->LexLevel != $<v.u.intval>0 )

				yyerror
				( 
					"Lex level of overriden procedure does not match\n"
					"the lex level of the original procedure"
				);

			_endif

			/*
			** We need to pass the default external name to the
			** OptionalExtName production to use if there is no
			** external name explicitly supplied.  The default
			** name is:
			**
			**	<classname> + "_" + <procname>
			*/
			
			strcpy( DefaultName, ClassPtr->TrueName );
			strcat( DefaultName, "_" );
			strcat( DefaultName, $<s>1->TrueName );
			$<idStr>$ = hlastrdup2( DefaultName ); 
		} 
		OptionalExtName				/* $6 */
		Semicolon					/* $7 */ 
		{							/* $8 */

			struct SymNode			*ParmList;
			struct SymNode			*sym;
			struct MethodListType	*ml;
			char					*CurrentType;
			struct SymNode			value;


			_here;
			
			/*
			** Save a pointer to this procedure's class' symbol
			** table entry for later reference:
			*/

			$<s>1->u.proc.BaseClass = ClassPtr;


					 
			/*
			** This is a forward procedure, so mark it as such
			** in the symbol table.
			*/

			$<s>1->u.proc.Forward = $<s>1; /* Any non-null item works here */


			/*
			** It is also external, deal with that here.
			*/

			$<s>1->IsExternal = 1;

			free2( vss $<s>1->StaticName );
			$<s>1->StaticName = $<idStr>6;
			sym = lookupin( $<s>1->TrueName, $<s>1->u.proc.parms );
			_if( sym != NULL )


				//free2( vss sym->StaticName ); not a unique ptr!
				sym->StaticName = hlastrdup2( $<idStr>6 );

			_endif



			/*
			** Add this (static) class procedure to the
			** Method List so we can check later to see
			** if it has been properly defined.
			*/

			ml = malloc2( sizeof( struct MethodListType ));
			ml->Next = MethodList;
			MethodList = ml;

			ml->ClassSym = ClassPtr;
			ml->MethodSym = $<s>1;
			ml->LexLevel = CurLexLevel;

			/*
			** Output an externdef directive to keep MASM happy.
			*/

			EmitTypedExtern( $<s>1, $<s>1->StaticName, tLabel );
			(void) $<idStr>5; // shut up bison
			_here;
		}
	;



		
		


		










 /*
 ** FixSymbols:
 **
 **	SymbolTable points at the start of the local symbols,
 ** $<s>0 points at the non-local symbols.
 ** Append the non-local symbols to the end of the local
 ** symbols and return a pointer to the last entry in the
 ** local symbol table as the attribute for this production.
 */		 

FixSymbols:
		{
			struct SymNode *s;

			/*
			** Symbol table points at the local symbols,
			** locate the last item in that list and point
			** it's NEXT field at $<s>0.
			*/

			_here;
			s = SymbolTable;
			assert( s != NULL );
			_while( s->Next != NULL )

				s = s->Next;

			_endwhile

			$<s>$ = s;
			s->Next = $<s>0;
		}
	;





/*****************************************************/


 /*
 ** MatchParms-
 **
 ** Assumes grammar symbol immediately to the left of the MatchParms
 ** non-terminal is a LocalSymbol token so $<s>0->u.proc.parms
 ** points at the symbol table entry of the procedure we're processing.
 */

MatchParms:

		Empty
		{
			char msg[ 256 ];

			_here;
			$<v.u.intval>$ = 0;
			assert( $<s>0 != NULL );


			_if( $<s>0->u.proc.parms == NULL )

				/*
				** 5/3/2000- Not sure what triggers this case. RLH.
				*/

				yyerror( "Parameters do not match original declaration" );


			/*
			** Check to see if there should have been a parameter here.
			*/

			_elseif( $<s>0->u.proc.ParmSize != 0 )

				sprintf
				(
					msg,
					"Missing parameter \"%s\" found in fwd/extern definition",
					$<s>0->u.proc.parms->TrueName
				);
				yyerror( msg );

			_endif
		}
	
		/*
		** If there is a parameter list, compare the parameter list
		** we're encountering in this actual declaration against the
		** parameter list ($<s>0) put in the symbol table by the
		** forward or external declaration.
		*/

	|	'('
		{	
			/*
			** Pass a pointer to the parameter symbols to the
			** MatchOneOrMoreParms code.
			*/

			_here;
			$<s>$ = $<s>0->u.proc.parms;
			++CurLexLevel;
			parmLookup = 1;
			fastLookup = 1;	
		}
		MatchOneOrMoreParms 
		Rparen
		{
			char msg[ 256 ];

			/*
			** Okay, the very last entry in the procedure's local
			** symbol table is a duplicate entry for the procedure
			** itself.  This entry will not be of class "cParm".
			** If the current entry is of class cParm, then there
			** are an insufficient number of parameters in the
			** current declaration.
			*/

			_here;
			_if( $<s>3->SymClass == cParm )

				sprintf
				(
					msg,
					"Parameter list is missing \"%s\" found in fwd/extern " 
					"definition",
					$<s>3->TrueName
				);
				yyerror
				( 
					msg
				);

			_endif
			--CurLexLevel;
			parmLookup = 0;
			fastLookup = 0;
			(void) $<s>2;	//shut up bison
			_here;	
		}
	;


 /*
 ** ProcessParameter:
 **
 **	$-5		Pointer to the forward declared type
 ** $-4		PassBy value for the current declaration.
 **	$-3		idStr for the current parameter declaration
 ** $-1		TypeID for the current parameter declaration.
 */

ProcessParameter:
		{ 
			char msg[ 256 ];

			_here;
			assert( $<neID.idStr>-3 != NULL );
			assert( $<s>-5 != NULL );


			$<s>$ = $<s>-5;	/* Just in case there is an error */

			/*
			** Be sure the forward definition wasn't a procedural
			** paramter.
			*/

			_if(  $<s>-5->Type == NULL )

				/*
				** This occurs if the declared parameter is
				** a procedure parameter but the forward parameter was not.
				*/
				
				sprintf
				(
					msg,
					"Parameter \"%s\" was not a procedure parameter in "
					"the original\n"
					"definition (may have been a type symbol"
					"that is indirectly a\n"
					"procedure type, though)",
					$<neID.idStr>-3
				);
				yyerror( msg );

			
			
				/*
				** Next, make sure the object is an actual parameter
				** in the original declaration.
				*/

			_elseif( $<s>-5->SymClass != cParm )

				sprintf
				(
					msg,
					"Parameter \"%s\" is not present in original definition",
					$<neID.idStr>-3
				);
				yyerror
				(
					msg
				);

			_else /* This is a parameter */
			

				/*
				** Make sure the two parameters were passed the same
				** way (e.g., pass by reference).
				*/

				_if( $<v.pClass>-4 != $<s>-5->pClass )

					yyerror
					(
						"Parameter classes must agree (e.g., pass by value,\n"
						"pass by reference, etc.) with original declaration"
					);


				/*
				** Be sure the names are identical.
				*/

				_elseif( _strne( $<neID.idStr>-3, $<s>-5->TrueName ))

				 	sprintf
					(
						msg,
						"Identifier \"%s\" must be identical to "
						" declaration \"%s\"",
						$<neID.idStr>-3,
						$<s>-5->TrueName
					);
					yyerror( msg );

				/*
				** Be sure their types are identical
				*/

				_elseif( $<s>-5->Type != $<s>-1 )

					sprintf
					(
						msg,
						"Type (%s:%s) must match original "
						"declaration (%s:%s)",
						$<neID.idStr>-3,
						$<s>-1->TrueName,
						$<s>-5->TrueName,
						$<s>-5->Type->TrueName
					);
					yyerror( msg );



				/*
				** If the StaticName field is non-NULL, then we
				** have a register parameter (e.g., "in <reg>" was
				** used).
				*/

				_elseif( $<s>-5->StaticName != NULL )

					/*
					** Make sure the current declaration also
					** specifies a register parameter.
					*/

					_if( $<idStr>0 == NULL )

						sprintf
						(
							msg,
							"Original parameter declaration was in register %s",
							$<s>-5->StaticName
						);
						yyerror( msg );


					/*
					** Make sure the current declaration specifies
					** the same register.
					*/

					_elseif( _strne( $<idStr>0, $<s>-5->StaticName ))

						sprintf
						(
							msg,
							"IN <reg> declarations must be the same "
							"(%s vs. %s [fwd])",
							$<idStr>0,
							$<s>-5->StaticName
						);
						yyerror( msg );

					_endif


				/*
				** If the current declaration is a register parameter
				** but the original (forward) definition wasn't, print
				** the appropriate message.
				*/

				_elseif( $<idStr>0 != NULL )

					sprintf
					(
						msg,
						"Original parameter declaration wasn't specified "
						"in a register (%s)",
						$<idStr>0
					);
					yyerror( msg );

				_endif
				$<s>$ = $<s>-5->Next;

			_endif
		}
	;


/*
** Process the optional "in <reg>" sequence here.
*/

OptionalInReg:
		Empty
		{
			_here;
			$<idStr>$ = NULL;
		}
	
	|	inTkn
		fRegister
		{
			_here;
			$<idStr>$ = regStrs[ $<reg.encoding>2 ];
		}
	;



/*
** MatchOneOrMoreParms-
**
**	This is the workhorse production that matches the
**	current procedure declaration parameter list against
**	a forward declaration.
*/


	/*
	** Compare the very last parameter, if it is not a procedural parameter,
	** against the original declaration.
	*/

MatchOneOrMoreParms:
		PassBy				/* $1 */ 
		AnyID 				/* $2 */
		Colon 				/* $3 */
		TypeID				/* $4 */
		OptionalInReg		/* $5 */
		ProcessParameter	/* $6 */
		{
			_here;
			$<s>$ = $<s>6;
		}
	;




	/*
	** Compare all but the last non-procedural parameters against
	** the original declaration here.
	*/



MatchOneOrMoreParms:
		PassBy					/* $1 */ 
		AnyID		 			/* $2 */
		Colon 					/* $3 */
		TypeID					/* $4 */
		OptionalInReg			/* $5 */
		ProcessParameter		/* $6 */
		';'						/* $7 */
		{						/* $8 */ 

			/*
			** Pass a pointer to the next symbol table entry
			** (appearing in the original declaration) to the
			** MatchOneOrMoreParms production.
			*/

			_here;
			$<s>$ = $<s>6;	
		}
		MatchOneOrMoreParms		/* $9  */
		{						/* $10 */

			/*
			** Return the pointer to the last symbol appearing the
			** the parameter list of the original definition.
			*/

			_here;
			(void) $<s>8;	//shut up bison
			$<s>$ = $<s>9;
		}
	;



variantTkn:
		varTkn
		{
			_here;
			$<s>$ = &variant_ste;
		}
	;



MatchOneOrMoreParms:
		PassBy				/* $1 */ 
		AnyID 				/* $2 */
		Colon 				/* $3 */
		variantTkn			/* $4 */
		OptionalInReg		/* $5 */
		ProcessParameter	/* $6 */
		{
			_here;
			$<s>$ = $<s>6;
		}
	;


MatchOneOrMoreParms:
		PassBy					/* $1 */ 
		AnyID		 			/* $2 */
		Colon 					/* $3 */
		variantTkn				/* $4 */
		OptionalInReg			/* $5 */
		ProcessParameter		/* $6 */
		';'						/* $7 */
		{						/* $8 */ 

			/*
			** Pass a pointer to the next symbol table entry
			** (appearing in the original declaration) to the
			** MatchOneOrMoreParms production.
			*/

			_here;
			$<s>$ = $<s>6;	
		}
		MatchOneOrMoreParms		/* $9  */
		{						/* $10 */

			/*
			** Return the pointer to the last symbol appearing the
			** the parameter list of the original definition.
			*/

			_here;
			(void) $<s>8;	//shut up bison
			$<s>$ = $<s>9;
		}
	;




	/*
	** This code will handle the last parameter in the parameter list if
	** it is a procedural parameter.
	*/

ProcessProcParm:
		{								/* $7 */
			char msg[ 256 ];

			_here;
			assert( $<neID.idStr>-4 != NULL );
			assert( $<s>-6 != NULL );

			$<s>$ = $<s>-6;	/* Just in case there is an error */

			/*
			** Be sure this parameter is actually present in the
			** original declaration.
			*/

			_if( $<s>-6->SymClass != cParm )

				sprintf
				(
					msg,
					"\"%s\" appears to be an extra parameter",
					$<neID.idStr>-4
				);
				yyerror
				(
					msg
				);

			_else /* This is a parameter */
			
				/*
				** Be sure this parameter was passed the same way
				** as in the original declaration.
				*/

				_if( $<v.pClass>-5 != $<s>-6->pClass )

					yyerror
					(
						"Parameter classes must agree (e.g., pass by value,\n"
						"pass by reference, etc.) with original declaration"
					);

				/*
				** Be sure this parameter has the same name as in the
				** original declaration.
				*/

				_elseif( _strne( $<neID.idStr>-4, $<s>-6->TrueName ))

				 	sprintf
					(
						msg,
						"Identifier (%s) must match original declaration (%s)",
						$<neID.idStr>-4,
						$<s>-6->TrueName
					);
					yyerror( msg );

				
				// Be sure the original parameter was a procedural parameter.
				

				_elseif( $<s>-6->pType != tProcptr )

					sprintf
					(
						msg,
						"\"%s\" cannot be a procedure parameter",
						$<neID.idStr>-4
					);
					yyerror( msg );

				_endif
				$<s>$ = $<s>-6->Next;

			_endif
			_here;
		}
	;


MatchOneOrMoreParms:
		PassBy							/* $1 */
		AnyID							/* $2 */ 
		Colon 							/* $3 */
		procedureTkn					/* $4 */

		/*
		** Handle the parameters for
		** this procedural parameter
		** here.
		*/

		SetSM4							/* $5 */
		MatchParms						/* $6 */
		ProcessProcParm					/* $7 */
		{
			_here;
			$<s>$ = $<s>7;
		}
	;





	/*
	** This production handles procedural parameters that are not the
	** last parameter in the parameter list.
	**
	**	Please see the comments in the previous production.
	*/

MatchOneOrMoreParms:
		PassBy				   	/* $1 */
		AnyID				   	/* $2 */ 
		Colon 				   	/* $3 */
		procedureTkn		   	/* $4 */
		SetSM4				   	/* $5 */
		MatchParms				/* $6 */
		ProcessProcParm		   	/* $7 */
		';'						/* $8 */
		{						/* $9 */
			/*
			** Pass the address of the entry for the
			** next (original) parameter on to the
			** MatchOneOrMoreParms production.
			*/

			_here;
			$<s>$ = $<s>7;	
		}
		MatchOneOrMoreParms		/* $10 */
		{						/* $11 */
			/*
			** Return the address of the last parameter
			** to the MatchParms production.
			*/

 			_here;
			(void) $<s>9;	//shut up bison
			$<s>$ = $<s>10;
		}
	;
		 


SetSM4:	
		{ 
			_here;
			_if( $<s>-4->pType == tProcptr )
			
				// If the parameter is a procedure pointer,
				// return a pointer to the parameter list
				// (Note that we must skip the dummy procedure
				// entry at the start of the list).
				
				_if( $<s>-4->Type != NULL )
				
					// If the type field is non-NULL, then
					// this is a procedure parameter that was
					// specified by some type name.  So grab
					// the parameter list from the type's proc.parms
					// pointer.
					
					assert( $<s>-4->Type->u.proc.parms != NULL );
					$<s>$ = $<s>-4->Type->u.proc.parms->Next;
					
				_else
				
					// If the type field is NULL, then this is
					// a procedure parameter declared directly as
					// a procedure object in the parameter list.
					// Extract the parameter pointer directly from
					// the current object.
					
					$<s>$ = $<s>-4->u.proc.parms->Next;
					
				_endif
				
			_else
			
				// If the parameter is not a procedure pointer,
				// just return a pointer to its type.
				
				$<s>$ = $<s>-4;
				
			_endif
			assert( $<s>$ != NULL );
		};






/*****************************************************/


OptionalExtName:
			Empty
			{ _here; $<idStr>$ = $<idStr>0; }
	
	|		'(' ConstOnlyExpr Rparen
			{
				_here;
				_if
				( 
						$<v.pType>2 != tString 
					&&	$<v.pType>2 != tZString 
				)

					yyerror( "Expected string type for external name" );
					$<idStr>$ = $<idStr>0;

				_else

					$<idStr>$ = hlastrdup2( $<v.u.strval>2 );
					free2( vss $<idStr>0 );
					FreeValue( YYS &$<v>2 );

				_endif
			}
	;


reg32use:
		eaxTkn
		{
			_here;
			$<idStr>$ = "eax";
		}
		
	|	ebxTkn
		{
			_here;
			$<idStr>$ = "ebx";
		}
		
	|	ecxTkn
		{
			_here;
			$<idStr>$ = "ecx";
		}
		
	|	edxTkn
		{
			_here;
			$<idStr>$ = "edx";
		}
		
	|	esiTkn
		{
			_here;
			$<idStr>$ = "esi";
		}
		
	|	ediTkn
		{
			_here;
			$<idStr>$ = "edi";
		}
	;		
	
	

 /*
 ** Handle options that are legal after a procedure
 ** variable (pointer) declaration.
 */
 






 /*
 ** Handle the options that are legal for a procedure declaration.
 */

Options:
		Empty
		{
			_here;
			$<options.returns>$ = hlastrdup2( "" );
			$<options.use>$ = NULL;
			$<options.SpecifiedOptions>$ = 0;
			$<options.UseFrame>$ = FrameDefault;
			$<options.UseDisplay>$ = DisplayDefault;
			$<options.AlignStk>$ = AlignStackDefault;
			$<options.Alignment>$ = AlignDefault;
			$<options.NoEnter>$ = EnterDefault;
			$<options.NoLeave>$ = LeaveDefault;
			$<options.CallingSequence>$ = pascal_cs;
			$<options.NoStorage>$ = 0;
			$<options.IsVolatile>$ = 0;
		}
	;

Options:
		Options 
		atreturnsTkn 
		Lparen 
		ConstOnlyExpr 
		Rparen 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			free2( vss $<options.returns>1 );
			_if
			( 
					$<v.pType>4 != tString 
				&&	$<v.pType>4 != tZString 
			)

				yyerror( "Expected string type for 'returns' value" );
				$<options.returns>$ = hlastrdup2( "" );

			_else

				$<options.returns>$ = hlastrdup2( $<v.u.strval>4 );

			_endif
			FreeValue( YYS &$<v>4 );

			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_returns;

		}
	;

Options:
		Options 
		useTkn 
		reg32use 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_use;
			$<options.use>$ = $<idStr>3;
		}	
	;

Options:
		Options 
		noframeTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noframe;
			$<options.UseFrame>$ = 0;
		}
	;

Options:
		Options 
		frameTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noframe;
			$<options.UseFrame>$ = 1;
		}
	;

Options:
		Options 
		nodisplayTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_nodisplay;
			$<options.UseDisplay>$ = 0;
		}
	;

Options:
		Options 
		displayTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_nodisplay;
			$<options.UseDisplay>$ = 1;
		}
	;

Options:
		Options 
		noalignstkTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noalignstk;
			$<options.AlignStk>$ = 0;
		}
	;

Options:
		Options 
		alignstkTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noalignstk;
			$<options.AlignStk>$ = 1;
		}
	;

Options:
		Options 
		noenterTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noenter;
			$<options.NoEnter>$ = 1;
		}
	;

Options:
		Options 
		useenterTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noenter;

			$<options.NoEnter>$ = 0;
		}
	;

Options:
		Options 
		noleaveTkn 
			Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noleave;

			$<options.NoLeave>$ = 1;
		}
	;

Options:
		Options 
		useleaveTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noleave;
			$<options.NoLeave>$ = 0;
		}
	;

Options:
		Options 
		pascalTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.CallingSequence>$ = pascal_cs;

			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_pascal;

		}
	;

Options:
		Options 
		stdcallTkn 
		Semicolon
		{
			_here;
			$<options>$ = $<options>1;
			$<options.CallingSequence>$ = stdcall_cs;

			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_stdcall;

		}
	;

Options:
		Options 
		cdeclTkn 
		Semicolon
		{

			_here;
			$<options>$ = $<options>1;
			$<options.CallingSequence>$ = cdecl_cs;

			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_cdecl;

		}
	;

Options:
		Options			/* $1 */
		alignprocTkn	/* $2 */
		Lparen			/* $3 */
		ConstExpr		/* $4 */
		Rparen			/* $5 */
		Semicolon		/* $6 */
		{				/* $7 */

			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ = 
				$<options.SpecifiedOptions>$ | specified_alignment;

			_if( IsNumber( $<v.pType>4 ) && numBits( YYS &$<v>4) <= 32 )

				_if
				(
						assembler == fasm
					&&	$<v.u.unsval>4 != 1
					&&	$<v.u.unsval>4 != 2
					&&	$<v.u.unsval>4 != 4
					&&	$<v.u.unsval>4 != 8
					&&	$<v.u.unsval>4 != 16
				)
				
					yyerror
					( 
						"FASM output supports only 1, 2, 4, 8, and 16 "
						"as alignment values" 
					);
				
					
				_endif
				$<options.Alignment>$ = $<v.u.unsval>4;

			_else

				yyerror
				( 
					"Expected an integer constant here" 
				);
				$<options.Alignment>$ = 1;

			_endif
			FreeValue( YYS &$<v>4 );
			_here;
		}
	;

Options:
		Options 
		nostorageTkn
		{
			_here;
			$<options>$ = $<options>1;
			$<options.NoStorage>$ = 1;
		}
	;
	
Options:
		Options 
		volatileTkn
		{
			_here;
			$<options>$ = $<options>1;
			$<options.IsVolatile>$ = 1;
		}







newProcOptionsSemicolon:
		';'		/* $1 */
		{
			_here;
			$<options.returns>$ = hlastrdup2( "" );
			$<options.use>$ = NULL;
			$<options.SpecifiedOptions>$ = 0;
			$<options.UseFrame>$ = FrameDefault;
			$<options.UseDisplay>$ = DisplayDefault;
			$<options.AlignStk>$ = AlignStackDefault;
			$<options.Alignment>$ = AlignDefault;
			$<options.NoEnter>$ = EnterDefault;
			$<options.NoLeave>$ = LeaveDefault;
			$<options.CallingSequence>$ = pascal_cs;
			$<options.NoStorage>$ = $<options.NoStorage>1;
			$<options.IsVolatile>$ = $<options.IsVolatile>1;
		}
	;
		
newProcOptionsSemicolon:
			Lbrace			/* $1 */
			newOptions		/* $2 */
			Rbrace			/* $3 */
			Semicolon		/* $4 */
			{
				_here;
				$<options>$ = $<options>2;
			}
		;





newProcOptions:
			Lbrace			/* $1 */
			newOptions		/* $2 */
			Rbrace			/* $3 */
			{
				_here;
				$<options>$ = $<options>2;
			}
		;





newOptions:
		Empty
		{
			_here;
			$<options.returns>$ = hlastrdup2( "" );
			$<options.use>$ = NULL;
			$<options.SpecifiedOptions>$ = 0;
			$<options.UseFrame>$ = FrameDefault;
			$<options.UseDisplay>$ = DisplayDefault;
			$<options.AlignStk>$ = AlignStackDefault;
			$<options.Alignment>$ = AlignDefault;
			$<options.NoEnter>$ = EnterDefault;
			$<options.NoLeave>$ = LeaveDefault;
			$<options.CallingSequence>$ = pascal_cs;
			$<options.NoStorage>$ = 0;
			$<options.IsVolatile>$ = 0;
		}
		
	|	newOptions
		','
		{
			_here;
			$<options>$ = $<options>1;
		}
		
	|	newOptions 
		atreturnsTkn 
		Lparen 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			$<options>$ = $<options>1;
			free2( vss $<options.returns>1 );
			_if
			( 
					$<v.pType>4 != tString 
				&&	$<v.pType>4 != tZString 
			)

				yyerror( "Expected string type for 'returns' value" );
				$<options.returns>$ = hlastrdup2( "" );

			_else

				$<options.returns>$ = hlastrdup2( $<v.u.strval>4 );

			_endif
			FreeValue( YYS &$<v>4 );

			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_returns;
			_here;
		}
		
	|	newOptions		/* $1 */ 
		useTkn 			/* $2 */
		reg32use		/* $3 */
		{
			_here;
			$<options>$ = $<options>1;
			$<options.use>$ = $<idStr>3;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_use;
		}
	

	

	|	newOptions noframeTkn
		{
			_here;
			$<options>$ = $<options>1;
			$<options.UseFrame>$ = 0;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noframe;
		}

	|	newOptions frameTkn
		{
			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noframe;
			$<options.UseFrame>$ = 1;
		}

	|	newOptions nodisplayTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.UseDisplay>$ = 0;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_nodisplay;

		}

	|	newOptions displayTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.UseDisplay>$ = 1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_nodisplay;

		}

	|	newOptions noalignstkTkn
		{
			_here;
			$<options>$ = $<options>1;
			$<options.AlignStk>$ = 0;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noalignstk;

		}

	|	newOptions alignstkTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.AlignStk>$ = 1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noalignstk;

		}

	|	newOptions noenterTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.NoEnter>$ = 1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noenter;

		}

	|	newOptions useenterTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.NoEnter>$ = 0;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noenter;

		}

	|	newOptions noleaveTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.NoLeave>$ = 1;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noleave;

		}

	|	newOptions useleaveTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.NoLeave>$ = 0;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_noleave;

		}

	|	newOptions pascalTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.CallingSequence>$ = pascal_cs;

			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_pascal;

		}

	|	newOptions stdcallTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.CallingSequence>$ = stdcall_cs;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_stdcall;

		}

	|	newOptions cdeclTkn
		{

			_here;
			$<options>$ = $<options>1;
			$<options.CallingSequence>$ = cdecl_cs;
			$<options.SpecifiedOptions>$ =
				$<options.SpecifiedOptions>1 | specified_cdecl;

		}

	|	newOptions		/* $1 */
		alignprocTkn	/* $2 */
		Lparen			/* $3 */
		ConstExpr		/* $4 */
		Rparen			/* $5 */
		{				/* $6 */

			_here;
			$<options>$ = $<options>1;
			$<options.SpecifiedOptions>$ = 
				$<options.SpecifiedOptions>$ | specified_alignment;

			_if( IsNumber( $<v.pType>4 ) )

				_if
				(
					$<v.u.unsval>4 != 1
					&&	$<v.u.unsval>4 != 2
					&&	$<v.u.unsval>4 != 4
					&&	$<v.u.unsval>4 != 8
					&&	$<v.u.unsval>4 != 16
				)
				
					yyerror
					( 
						"HLA supports only 1, 2, 4, 8, and 16 "
						"as alignment values" 
					);
				
					
				_endif
				$<options.Alignment>$ = $<v.u.unsval>4;

			_else

				yyerror
				( 
					"Expected an integer constant here" 
				);
				$<options.Alignment>$ = 1;

			_endif
			FreeValue( YYS &$<v>4 );
			_here;
		}

	|	newOptions 
		nostorageTkn
		{
			_here;
			$<options>$ = $<options>1;
			$<options.NoStorage>$ = 1;
			$<options.SpecifiedOptions>$ = 
				$<options.SpecifiedOptions>$ | specified_nostorage;
		}

	|	newOptions volatileTkn
		{
			_here;
			$<options>$ = $<options>1;
			$<options.IsVolatile>$ = 1;
			$<options.SpecifiedOptions>$ = 
				$<options.SpecifiedOptions>$ | specified_volatile;
		}
	;









/*****************************************************/


 /*
 ** OptionalParms-
 **
 ** Assumes production immediately to the left of the OptionalParms
 ** non-terminal is an EnterSymbol call (so $<s>0 points at the
 ** symbol table entry for this procedure).
 */
 
OptionalParms:
		saveCurNS
		{ 
			_here;
			$<s>$ = $<s>0;
			parmLookup = 1;
			fastLookup = 1; 
			ProcNS = currentNS;
			//ProcGlobal = SymbolTable; // Removed, messed up parms
		}
		doOptionalParms
		{ 
			_here;
			currentNS = $<ru.saveCurNS>1;
			//ProcGlobal = $<ru.saveProcGlobal>1; // see above
			ProcNS = $<ru.saveProcNS>1;
			$<v.u.intval>$ = $<v.u.intval>3;
			parmLookup = 0;
			fastLookup = 0;
			(void) $<s>2;	//shut up bison 
		}
	;
	
doOptionalParms:

		Empty
		{
			_here;
			$<v.u.intval>$ = 0;
			assert( $<s>0 != NULL );
			$<s>0->u.proc.ParmSize = 0;
		}
	
	|	'(' 
		{ 
			_here;
			$<v.u.intval>$ = CurOffset;
		} 
		OneOrMoreParms 
		Rparen
		{
			_here;
			$<v.u.intval>$ = $<v.u.intval>3 - CurOffset;
			assert( $<s>0 != NULL );
			(void) $<v.u.intval>2;	//shut up bison
			$<s>0->u.proc.ParmSize = $<v.u.intval>$;
		}
	;

ParmTypeID:
		TypeID
		{
			_here;
			$<s>$ = $<s>1;
		}

	|	UndefID
		{
			yyerror( "Undefined type identifier" );
			$<s>$ = &dword_ste;
			_here;
		}
	;
	
ColonSavePG:
		Colon
		{
			_here;
			$<s>$ = ProcGlobal;
			ProcGlobal = SymbolTable;
		}
	;

OneOrMoreParms:
		PassBy			/* $1 */ 
		UndefinedID 	/* $2 */ 
		ColonSavePG		/* $3 */
		ParmTypeID		/* $4 */
		{
			int CurParmSize;
			
			_here;
			assert( $<idStr>2 != NULL );
			assert( $<s>4 != NULL );
			
			// Restore ProcGlobal:
			
			ProcGlobal = $<s>3;

			CurParmSize = 0;
			_if( CantBeParm( $<s>4->pType ))

				yyerror( "Parameters cannot be this type" );

			_else
			
				CurParmSize =
					_ifx
					( 
						$<v.pClass>1 == valp_pc, 
						$<s>4->ObjectSize,	/* Pass by Value */
						_ifx
						( 
								$<v.pClass>1 >= refp_pc 
							&&	$<v.pClass>1 <= result_pc, 
							4,				/* Pass by ref, valres, result	*/
							8				/* Pass by name or lazy.		*/
						)
					);

				_if( $<v.pClass>1 == valp_pc  )


					/*
					** If we're passing this by value, specify the
					** base type of this object as the parameter type.
					*/

					InsertSym
					( 
						$<idStr>2,
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						CurParmSize,
						$<v.u.intval>0,
						NULL,
						$<s>4->Base,
						$<s>4->Fields,
						$<s>4->FieldCnt
					);


				_else

					/*

					** If we're passing this parameter by address
					** (reference, value/result, or result), or
					** by thunk (name, lazy evaluation), then
					** specify the actual type of the parameter.
					*/

					InsertSym
					( 
						$<idStr>2, 
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						CurParmSize,
						$<v.u.intval>0,
						NULL,
						$<s>4,
						NULL,
						0
					);

				_endif
				SymbolTable->u.proc.returns = $<v.u.proc.returns>1;
				SymbolTable->u.proc.use = $<v.u.proc.use>1;
				_if( $<s>4->pType == tProcptr )
				
					SymbolTable->u.proc.parms = $<s>4->u.proc.parms;
					SymbolTable->u.proc.ParmSize = $<s>4->u.proc.ParmSize;
					SymbolTable->u.proc.parms->u.proc.ParmSize = 
						$<s>4->u.proc.ParmSize;

				_else
				
					// Put a bogus entry here, for consistency,
					// if it's not a proc pointer.
					
					SymbolTable->u.proc.parms = &true_ste;
					
				_endif

				/*
				** For parameters, the pClass field contains the passing
				** mechanism.
				*/

				SymbolTable->pClass = $<v.pClass>1;
				
			_endif
			$<v.u.intval>$ = $<v.u.intval>0 + max( CurParmSize, MinParmSize);
			_if( max( CurParmSize, MinParmSize) % 4 != 0 )

				$<v.u.intval>$ = $<v.u.intval>$ + 
									4 - (max( CurParmSize, MinParmSize) % 4);

			_endif
			_here;
		}
	;
			 
		

 /*
 ** Special production that specifies passing the
 ** parameter in a register.
 */
 			
OneOrMoreParms:
		PassBy			/* $1 */ 
		UndefinedID 	/* $2 */
		ColonSavePG		/* $3 */
		ParmTypeID		/* $4 */
		inTkn			/* $5 */
		fRegister		/* $6 */
		{
			int CurParmSize;

			assert( $<idStr>2 != NULL );
			assert( $<s>4 != NULL );
			_here;
			
			// Restore ProcGlobal
			
			ProcGlobal = $<s>3;

			CurParmSize = 0;
			_if( CantBeParm( $<s>4->pType ))

				yyerror( "Parameters cannot be this type" );

			_elseif
			(
					$<v.pClass>1 != valp_pc
				&&	$<v.pClass>1 != refp_pc
			)

				yyerror
				( 
					"Can only pass value and reference parameters in registers"
				);

			_else
			
				CurParmSize =
					_ifx
					( 
						$<v.pClass>1 == valp_pc, 
						$<s>4->ObjectSize,	/* Pass by Value */
						4					/* Pass by ref	 */
					);

				_if( CurParmSize != $<reg.Size>6 )


					ErrorNear
					( 
						"Type size and register size are not the same", 
						$<s>4->TrueName,
						__LINE__,
						__FILE__ 
					);
					
				_elseif( $<v.pClass>1 == valp_pc  )


					/*
					** If we're passing this by value, specify the
					** base type of this object as the parameter type.
					*/

					InsertSym
					( 
						$<idStr>2,
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						CurParmSize,
						$<v.u.intval>0,
						regDup( $<reg.encoding>6 ),
						$<s>4->Base,
						$<s>4->Fields,
						$<s>4->FieldCnt
					);
					SymbolTable->regnum = $<reg.encoding>6;
					_if( $<s>4->pType == tProcptr )
					
						// Copy parameter info if a proc ptr.
						
						memcpy
						( 
							&SymbolTable->u, 
							&$<s>4->u, 
							sizeof( union ValuesSize )
						);
						
					_endif



				_else

					/*
					** If we're passing this parameter by reference then
					** specify the actual type of the parameter.
					*/

					InsertSym
					( 
						$<idStr>2, 
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						CurParmSize,
						$<v.u.intval>0,
						regDup( $<reg.encoding>6 ),
						$<s>4,
						NULL,
						0
					);
					SymbolTable->regnum = $<reg.encoding>6;
					

				_endif
				SymbolTable->u.proc.returns = $<v.u.proc.returns>1;
				SymbolTable->u.proc.use = $<v.u.proc.use>1;
				_if( $<s>4->pType == tProcptr )
				
					SymbolTable->u.proc.parms = $<s>4->u.proc.parms;

				_else
				
					// Put a bogus entry here, for consistency,
					// if it's not a proc pointer.
					
					SymbolTable->u.proc.parms = &true_ste;
					
				_endif



				/*
				** For parameters, the pClass field contains the passing
				** mechanism.
				*/

				SymbolTable->pClass = $<v.pClass>1;

			_endif

			/*
			** Register variables don't consume any space on the stack,
			** so just return the previous offset.
			*/

			$<v.u.intval>$ = $<v.u.intval>0;
			_here;
		}
	;
			 		
			
OneOrMoreParms:
		PassBy				/* $1 */ 
		UndefinedID			/* $2 */
		ColonSavePG			/* $3 */
		ParmTypeID 			/* $4 */
		{
			_here;
			ProcGlobal = $<s>3;
			fastLookup = 1;
		}
		';' 				/* $6 */
		{
			$<v.u.unsval>$ = $<v.u.unsval>0;
		} 
		OneOrMoreParms		/* $8 */ 
		{
			int CurParmSize;

			_here;
			assert( $<idStr>2 != NULL );
			assert( $<s>4 != NULL );

			CurParmSize = 0;
			_if( CantBeParm($<s>4->pType ))

				yyerror( "Parameters cannot be this type" );

			_else
			
				_if( $<v.pClass>1 == valp_pc )

					CurParmSize = $<s>4->ObjectSize;
					InsertSym
					( 
						$<idStr>2, 
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						CurParmSize,
						$<v.u.unsval>8,
						NULL,
						$<s>4->Base,
						$<s>4->Fields,
						$<s>4->FieldCnt
					);
					SymbolTable->u.proc.returns = $<v.u.proc.returns>1;
					SymbolTable->u.proc.use = $<v.u.proc.use>1;
					_if( $<s>4->pType == tProcptr )
					
						SymbolTable->u.proc.parms = $<s>4->u.proc.parms;

					_else
					
						// Put a bogus entry here, for consistency,
						// if it's not a proc pointer.
						
						SymbolTable->u.proc.parms = &true_ste;
						
					_endif

				_elseif
				(
						$<v.pClass>1 >= refp_pc 
					&&	$<v.pClass>1 <= result_pc
				)
				 
					InsertSym
					( 
						$<idStr>2, 
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						4,
						$<v.u.unsval>8,
						NULL,
						$<s>4,
						NULL,
						0
					);
					CurParmSize = 4;
					SymbolTable->u.proc.returns = $<v.u.proc.returns>1;
					SymbolTable->u.proc.use = $<v.u.proc.use>1;
					_if( $<s>4->pType == tProcptr )
					
						SymbolTable->u.proc.parms = $<s>4->u.proc.parms;

					_else
					
						// Put a bogus entry here, for consistency,
						// if it's not a proc pointer.
						
						SymbolTable->u.proc.parms = &true_ste;
						
					_endif

				_else
				 
					InsertSym
					( 
						$<idStr>2, 
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						8,
						$<v.u.unsval>8,
						NULL,
						NULL,
						NULL,
						0
					);
					SymbolTable->u.proc.returns = $<v.u.proc.returns>1;
					SymbolTable->u.proc.use = $<v.u.proc.use>1;
					CurParmSize = 8;

				_endif

				/*
				** For parameters, the pClass field contains the passing
				** mechanism.
				*/

				SymbolTable->pClass = $<v.pClass>1;


			_endif
			$<v.u.intval>$ = $<v.u.intval>8 + max( CurParmSize, MinParmSize);
			_if( max( CurParmSize, MinParmSize) % 4 != 0 )

				$<v.u.intval>$ = $<v.u.intval>$ + 
								4 - (max( CurParmSize, MinParmSize) % 4);

			_endif
			
			(void) $<v.u.unsval>7; // shut up bison
			_here;
		}
	;
		
			


		
			
			 
		
 /*
 ** Handle an untyped VAR parameter:
 */
 			
OneOrMoreParms:
		PassBy			/* $1 */ 
		UndefinedID		/* $2 */
		ColonSavePG		/* $3 */
		varTkn			/* $4 */
		{
			_here;
			ProcGlobal = $<s>3;
			fastLookup = 1
		}
		';' 			/* $6 */
		{				/* $7 */

			$<v.u.unsval>$ = $<v.u.unsval>0;
		} 
		OneOrMoreParms	/* $8 */ 
		{				/* $9 */

			_here;
			assert( $<idStr>2 != NULL );

			
			_if( $<v.pClass>1 != refp_pc )

				yyerror( "Variant parameters must be pass by reference" );

			_endif
				 
			InsertSym
			( 
				$<idStr>2,		/* ID			*/ 
				&variant_ste,	/* Type			*/
				tDWord, 		/* pType		*/
				cParm, 			/* Class		*/
				0,				/* arity		*/
				NULL,			/* Dimensions	*/
				0, 				/* NumElements	*/
				NULL,			/* Value		*/
				4,				/* Size			*/
				$<v.u.unsval>8,	/* Offset		*/
				NULL,			/* StaticName	*/
				&dword_ste,		/* Base			*/
				NULL,			/* Fields		*/
				0				/* FieldCnt		*/
			);

			/* Register parameters don't consume any space, so just */
			/* return the previous offset.							*/

			$<v.u.intval>$ = $<v.u.intval>8;

			/*
			** For parameters, the pClass field contains the passing
			** mechanism.
			*/

			SymbolTable->pClass = refp_pc;

			// Return new offset here

			$<v.u.intval>$ = $<v.u.intval>8 + 4;
			(void) $<v.u.unsval>7; // shut up bison
			_here;			

		}
	;
		
			


		
			
			 
OneOrMoreParms:
		PassBy			/* $1 */ 
		UndefinedID		/* $2 */
		ColonSavePG		/* $3 */
		varTkn			/* $4 */
		{				/* $5 */

			assert( $<idStr>2 != NULL );
			_here;	 
			ProcGlobal = $<s>3;
			
			_if( $<v.pClass>1 != refp_pc )

				yyerror( "Variant parameters must be pass by reference" );

			_endif
			InsertSym
			( 
				$<idStr>2,		/* ID			*/ 
				&variant_ste,	/* Type			*/
				tDWord, 		/* pType		*/
				cParm, 			/* Class		*/
				0,				/* arity		*/
				NULL,			/* Dimensions	*/
				0, 				/* NumElements	*/
				NULL,			/* Value		*/
				4,				/* Size			*/
				$<v.u.intval>0,	/* Offset		*/
				NULL,			/* StaticName	*/
				NULL,			/* Base			*/
				NULL,			/* Fields		*/
				0				/* FieldCnt		*/
			);

			// Put the PassBy parameters into this symbol
			// (returns is always NULL for VAR objects,
			// parms is always ref_pc.)

			SymbolTable->u.proc.returns = $<v.u.proc.returns>1;
			SymbolTable->u.proc.use = $<v.u.proc.use>1;
			SymbolTable->u.proc.parms = &true_ste;

			/*
			** For parameters, the pClass field contains the passing
			** mechanism.
			*/

			SymbolTable->pClass = refp_pc;

			// Return new offset here

			$<v.u.intval>$ = $<v.u.intval>0 + 4;

			_here;			

		}
	;
	
	
OneOrMoreParms:
		PassBy			/* $1 */ 
		UndefinedID 	/* $2 */
		ColonSavePG		/* $3 */
		varTkn 			/* $4 */
		inTkn			/* $5 */
		fRegister		/* $6 */
		{
			_here;
			ProcGlobal = $<s>3;
			fastLookup = 1;
		}
		';' 			/* $8 */
		{				/* $9 */
			_here;
			$<v.u.unsval>$ = $<v.u.unsval>0;
		} 
		OneOrMoreParms 	/* $10  */
		{				/* $11 */

			assert( $<idStr>2 != NULL );
			_here;
			_if( $<reg.Size>6 != 4 )

				yyerror
				( 
					"Can only pass reference parameters in 32-bit registers" 
				);
				
			_else
				
				_if( $<v.pClass>1 != refp_pc )

					yyerror
					( 
						"Variant parameters must be pass by reference" 
					);

				_endif /* must be pass by reference */
			 
			 
				InsertSym
				( 
					$<idStr>2,		/* ID			*/ 
					&variant_ste,	/* Type			*/
					tDWord, 		/* pType		*/
					cParm, 			/* Class		*/
					0,				/* arity		*/
					NULL,			/* Dimensions	*/
					0, 				/* NumElements	*/
					NULL,			/* Value		*/
					4,				/* Size			*/
					$<v.u.unsval>8,	/* Offset		*/
					regDup( $<reg.encoding>6 ),		/* StaticName	*/
					&dword_ste,		/* Base			*/
					NULL,			/* Fields		*/
					0				/* FieldCnt		*/
				);
				SymbolTable->regnum = $<reg.encoding>6;
				

			_endif

			/*
			** For parameters, the pClass field contains the passing
			** mechanism.
			*/

			SymbolTable->pClass = $<v.pClass>1;


			/* 
			** Register parameters don't consume any space
			** in the activation record, so just return
			** the previous offset.
			*/
			
			$<v.u.intval>$ = $<v.u.intval>10; 
			(void) $<v.u.unsval>9; // shut up bison
			_here;
		}
	;
		

	
OneOrMoreParms:
		PassBy			/* $1 */ 
		UndefinedID 	/* $2 */
		ColonSavePG		/* $3 */
		varTkn 			/* $4 */
		inTkn			/* $5 */
		fRegister		/* $6 */
		{				/* $7 */

			assert( $<idStr>2 != NULL );
			_here;
			ProcGlobal = $<s>3;
			
			_if( $<reg.Size>6 != 4 )

				yyerror
				( 
					"Can only pass reference parameters in 32-bit registers" 
				);
				
			_else
				
				_if( $<v.pClass>1 != refp_pc )

					yyerror
					( 
						"Variant parameters must be pass by reference" 
					);

				_endif /* must be pass by reference */
			 
			 
				InsertSym
				( 
					$<idStr>2,		/* ID			*/ 
					&variant_ste,	/* Type			*/
					tDWord, 		/* pType		*/
					cParm, 			/* Class		*/
					0,				/* arity		*/
					NULL,			/* Dimensions	*/
					0, 				/* NumElements	*/
					NULL,			/* Value		*/
					4,				/* Size			*/
					$<v.u.unsval>0,	/* Offset		*/
					regDup( $<reg.encoding>6 ),		/* StaticName	*/
					&dword_ste,		/* Base			*/
					NULL,			/* Fields		*/
					0				/* FieldCnt		*/
				);
				SymbolTable->regnum = $<reg.encoding>6;
				

			_endif

			/*
			** For parameters, the pClass field contains the passing
			** mechanism.
			*/

			SymbolTable->pClass = $<v.pClass>1;


			/*
			** Register parameters don't consume any space in
			** the activation record, so just return the
			** previous offset.
			*/

			$<v.u.intval>$ = $<v.u.intval>0; 
			_here;
		}
	;
		
			
			
		
			


			
	
	
 /*
 ** Handle memory parameters passed in a register.
 */		 
		
			
OneOrMoreParms:
		PassBy			/* $1 */ 
		UndefinedID 	/* $2 */
		ColonSavePG		/* $3 */
		ParmTypeID		/* $4 */
		inTkn			/* $5 */
		fRegister		/* $6 */
		{
			_here;
			ProcGlobal = $<s>3;
			fastLookup = 1;
		}
		';' 			/* $8 */
		{				/* $9 */

			$<v.u.unsval>$ = $<v.u.unsval>0;
		} 
		OneOrMoreParms 	/* $10 */
		{				/* $11 */

			int CurParmSize;

			assert( $<idStr>2 != NULL );
			assert( $<s>4 != NULL );
			_here;
			CurParmSize = 0;
			_if( CantBeParm($<s>4->pType ))

				yyerror( "Parameters cannot be this type" );

			_elseif
			(
					$<v.pClass>1 != valp_pc
				&&	$<v.pClass>1 != refp_pc
			)

				yyerror
				( 
					"Can only pass value and reference parameters in registers"
				);

			_else
			
				CurParmSize =
					_ifx
					( 
						$<v.pClass>1 == valp_pc, 
						$<s>4->ObjectSize,	/* Pass by Value */
						4					/* Pass by ref   */
					);

				_if( CurParmSize != $<reg.Size>6 )

					ErrorNear
					( 
						"Type size and register size are not the same", 
						$<s>4->TrueName,
						__LINE__,
						__FILE__ 
					);
					
				_elseif( $<v.pClass>1 == valp_pc )

					InsertSym
					( 
						$<idStr>2, 
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						CurParmSize,
						$<v.u.unsval>10,
						regDup( $<reg.encoding>6 ),
						$<s>4->Base,
						$<s>4->Fields,
						$<s>4->FieldCnt
					);
					SymbolTable->regnum = $<reg.encoding>6;

				_else /* must be pass by reference */
				 
					InsertSym
					( 
						$<idStr>2, 
						$<s>4,
						$<s>4->pType, 
						cParm, 
						$<s>4->Arity,
						$<s>4->Dimensions,
						$<s>4->NumElements, 
						NULL,
						4,
						$<v.u.unsval>10,
						regDup( $<reg.encoding>6 ),
						$<s>4,
						NULL,
						0
					);
					CurParmSize = 4;
					SymbolTable->regnum = $<reg.encoding>6;

				_endif
				SymbolTable->u.proc.returns = $<v.u.proc.returns>1;
				SymbolTable->u.proc.use = $<v.u.proc.use>1;
				_if( $<s>4->pType == tProcptr )
				
					SymbolTable->u.proc.parms = $<s>4->u.proc.parms;

				_else
				
					// Put a bogus entry here, for consistency,
					// if it's not a proc pointer.
					
					SymbolTable->u.proc.parms = &true_ste;
					
				_endif

				/*
				** For parameters, the pClass field contains the passing
				** mechanism.
				*/

				SymbolTable->pClass = $<v.pClass>1;


			_endif

			$<v.u.intval>$ = $<v.u.intval>10;
			(void) $<v.u.unsval>9; // shut up bison
			_here;
		}
	;

		
// Handle parameters of the form:
//
//	symbol:procedure( optional args );			
			
OneOrMoreParms:
		PassBy			/* $1 */
		UndefinedID		/* $2 */ 
		ColonSavePG		/* $3 */
		procedureTkn	/* $4 */
			
		/*
		** Before going any farther, save the current
		** (previous lex level) variable offset and offset 
		** direction so we can restore these values when
		** the compiler finishes this declaration.  Note that the
		** compiler saves these values in the attributes of the
		** following grammar symbols.
		*/
		
		SaveOffset		/* $5 */ 
		SaveDirection	/* $6 */
		EnterProcName	/* $7 */
		OptionalParms	/* $8 */
		{				/* $9 */

			struct	SymNode	*s;
			struct	SymNode	*t;
			
			_here;
			ProcGlobal = $<s>3;

			_if( $<v.pClass>1 != valp_pc )

				yyerror
				( 
					"Procedure parameters can only be passed by value"
				);
				$<v.pClass>1 = valp_pc;

			_endif

			/*
			** We have to fix the procedure pointer's offset
			** because EnterProcName just set this to zero.
			*/

			$<s>7->Offset = $<v.u.intval>0;


			// Create a dummy type to hold the parameter list:
			
			s = SymbolTable;
			InsertSym
			( 
				" (parameter Proc Ptr Type) ", 
				NULL,			/* Default is int32 object.		*/
				tProcptr,
				cType, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				NULL,			/* No initialization			*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);
			SymbolTable->u.proc.parms = s;
			SymbolTable->u.proc.returns = $<v.u.proc.returns>1;
			SymbolTable->u.proc.use = $<v.u.proc.use>1;
			$<s>7->Type = SymbolTable;

			/*
			** Initialize the pointer to the end of the parameters
			** for this procedure variable.
			** Set up the offset and direction variables to handle
			** local variable declarations.  
			*/

			$<s>7->u.proc.parms->u.proc.parms = s;
			$<s>7->u.proc.parms->u.proc.returns = $<v.u.proc.returns>1;
			$<s>7->u.proc.parms->u.proc.use = $<v.u.proc.use>1;
			$<s>7->u.proc.parms->u.proc.Locals = NULL;

			$<s>7->u.proc.parms = s;
			$<s>7->u.proc.Locals = NULL;
			$<s>7->u.proc.returns = $<v.u.proc.returns>1;
			$<s>7->u.proc.use = $<v.u.proc.use>1;
			--CurLexLevel;
			CurOffset = $<v.u.unsval>5;
			CurOffsetDir = $<v.u.unsval>6;
			
			// Remove the parameter list for this procedure pointer argument
			// from the symbol table we're building:
			
			SymbolTable = $<s>7;

			/*
			** Update the offset into the activation record for
			** the next parameter.
			*/

			$<v.u.intval>$ = $<v.u.intval>0 + max( 4, MinParmSize);
			_here;
		}
	;




OneOrMoreParms:
		PassBy			/* $1 */
		UndefinedID		/* $2 */ 
		ColonSavePG		/* $3 */
		procedureTkn	/* $4 */
			
		/*
		** Before going any farther, save the current
		** (previous lex level) variable offset and offset 
		** direction so we can restore these values when
		** the compiler finishes this declaration.  Note that the
		** compiler saves these values in the attributes of the
		** following grammar symbols.
		*/
		
		SaveOffset		/* $5  */ 
		SaveDirection	/* $6  */
		EnterProcName	/* $7  */
		OptionalParms	/* $8  */
		{
			_here;
			ProcGlobal = $<s>3;
			fastLookup = 1;
		}
		';'				/* $10 */
		{				/* $11 */ 
		
			struct	SymNode *s;
			
			_here;
			_if( $<v.pClass>1 != valp_pc )

				yyerror
				( 
					"Procedure parameters can only be passed by value"
				);
				$<v.pClass>1 = valp_pc;

			_endif



			// Create a dummy type to hold the parameter list:
			
			s = SymbolTable;
			InsertSym
			( 
				" (parameter Proc Ptr Type) ", 
				NULL,			/* Primitive type.		*/
				tProcptr,
				cType, 
				0,				/* Arity				*/
				NULL,			/* Dimensions			*/
				0, 				/* NumElements			*/
				NULL,			/* No initialization	*/
				0,				/* Object size			*/
				0,				/* Offset				*/
				NULL,			/* Static Name			*/
				NULL,			/* Base					*/
				NULL,			/* Fields				*/
				0				/* FieldCnt				*/
			);
			SymbolTable->u.proc.parms = s;
			SymbolTable->u.proc.returns = hlastrdup2( "" );
			SymbolTable->u.proc.use = $<v.u.proc.use>1;
			$<s>7->Type = SymbolTable;

			/*
			** Initialize the pointer to the end of the parameters
			** for this procedure variable.
			** Set up the offset and direction variables to handle
			** local variable declarations.  
			*/

			$<s>7->u.proc.parms->u.proc.parms = s;
			$<s>7->u.proc.parms->u.proc.returns = $<v.u.proc.returns>1;
			$<s>7->u.proc.parms->u.proc.use = $<v.u.proc.use>1;
			$<s>7->u.proc.parms->u.proc.Locals = NULL;

			$<s>7->u.proc.parms = s;
			$<s>7->u.proc.Locals = NULL;
			$<s>7->u.proc.returns = $<v.u.proc.returns>1;
			$<s>7->u.proc.use = $<v.u.proc.use>1;
			--CurLexLevel;
			CurOffset = $<v.u.intval>5;
			CurOffsetDir = $<v.u.intval>6;

			/*
			** Temporarily remove this symbol from the Symbol Table
			** so we can insert the parameters following the
			** procedure parameter first.
			*/

			SymbolTable = $<s>7->Next;

			_here;

			/*
			** Since this isn't the last parameter, pass the starting
			** offset value on to the next parameter in the list (because
			** the last parameter has the smallest offset value in the
			** parameter list).
			*/

			$<v.u.intval>$ = $<v.u.intval>0;
			_here;
		} 
		OneOrMoreParms	/* $12 */ 
		{				/* $13 */

			_here;

			/*
			** We have to fix the procedure pointer's offset
			** because EnterProcName just set this to zero.
			*/

			$<s>7->Offset = $<v.u.intval>12;

			/*
			** Update the offset into the activation record for
			** the previous parameter.
			*/

			$<v.u.intval>$ = $<v.u.intval>12 + max( 4, MinParmSize);

			/*
			** Insert the procedure pointer parameter back into
			** the symbol table since we've already processed all
			** the parameters after the procedure parm.
			*/

			$<s>7->Next = SymbolTable;
			SymbolTable = $<s>7;
			(void) $<v.u.intval>11; // shut up bison
			_here;
		}
	;



/*****************************************************/


 /*
 ** EnterProcName-
 **
 ** Enters a procedure name, passed as a parameter, into the
 ** symbol table.
 **
 **	Parameters to this production:
 **
 **	$<idStr>-4:			procedure variable's name.
 ** $<v.pClass>-5:		PassBy value
 */

EnterProcName:
		{
			_here;
			assert( $<idStr>-4 != NULL );
			InsertSym
			( 
				$<idStr>-4,
				&proctype_ste,
				tProcptr, 
				cParm, 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				CurOffset,			/* Offset		*/
				NULL,				/* StaticName	*/
				NULL,				/* Base			*/
				NULL,			  	/* Fields		*/
				0					/* FieldCnt		*/
			);


			/*
			** For parameters, the pClass field contains the passing
			** mechanism.
			*/

			SymbolTable->pClass = $<v.pClass>-5;
			SymbolTable->u.proc.returns = $<v.u.proc.returns>-5;
			SymbolTable->u.proc.use = $<v.u.proc.use>-5;


			/*
			** Set up globals so we can process the parameter
			** list of this procedure pointer.
			*/

			$<s>$ = SymbolTable;
			CurOffset = StartParmOffs;
			++CurLexLevel;

			/*
			** Reinsert the symbol into the local symbols
			** to keep the logic of this program happy.
			*/

			InsertSym
			( 
				$<idStr>-4,
				&proctype_ste,
				tProcptr, 
				cVar, 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0,					/* NumElements	*/ 
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* Offset		*/
				NULL,				/* StaticName	*/
				NULL,				/* Base			*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);

			/*
			** Temporary assignment so we can patch the local
			** entry later.
			*/

			$<s>$->u.proc.parms = SymbolTable;
			$<s>$->u.proc.returns = hlastrdup2( "" );
			$<s>$->u.proc.use = NULL;
			_here;

		}
	;


PassBy:
		PassByValDefault	
		{
			_here; 
			$<v.pClass>$ = valp_pc; 
			$<v.u.proc.returns>$ = hlastrdup2( "" );
			$<v.u.proc.use>$ = NULL;
			_here; 
		}
	|	valTkn				
		{ 
			_here; 
			$<v.pClass>$ = valp_pc; 
			$<v.u.proc.returns>$ = hlastrdup2( "" );
			$<v.u.proc.use>$ = NULL;
			_here; 
		}
	|	varTkn
		{ 
			_here; 
			$<v.pClass>$ = refp_pc; 
			$<v.u.proc.returns>$ = hlastrdup2( "" );
			$<v.u.proc.use>$ = NULL;
			_here; 
		}
	|	valresTkn
		{ 
			_here; 
			$<v.pClass>$ = vrp_pc; 
			$<v.u.proc.returns>$ = hlastrdup2( "" );
			$<v.u.proc.use>$ = NULL;
			_here; 
		}
	|	resultTkn
		{ 
			_here; 
			$<v.pClass>$ = result_pc; 
			$<v.u.proc.returns>$ = hlastrdup2( "" );
			$<v.u.proc.use>$ = NULL;
			_here; 
		}
	|	nameTkn OptionalReturns
		{ 
			_here; 
			$<v.pClass>$ = name_pc; 
			$<v.u.proc.returns>$ = $<returns>2;
			$<v.u.proc.use>$ = NULL;
			assert( $<v.u.proc.returns>$ != NULL );
			_here; 
		}
	|	lazyTkn OptionalReturns
		{ 
			_here; 
			$<v.pClass>$ = lazy_pc; 
			$<v.u.proc.returns>$ = $<returns>2;
			$<v.u.proc.use>$ = NULL;
			assert( $<v.u.proc.returns>$ != NULL );
			_here; 
		}
;


PassByValDefault: /* Empty */ ;

OptionalReturns:
		Empty
		{
			_here;
			$<returns>$ = hlastrdup2( "" );
		}

	|	'(' strconst Rparen
		{
			_here;
			$<returns>$ = $<v.u.strval>2;
		}
	;



 /*
 ** Enter a procedure's name into the symbol table.
 ** Returns a pointer to the main symbol table entry for the procedure's
 ** name.  The procedure name must be stored in the $<idStr>$ field of
 ** the grammar symbol exactly four symbols before EnterName.
 */

EnterName:
			{
				char StaticName[ 256 ];
				char *sn;
				union YYSTYPE dummy;

				_here;
				assert( $<neID.idStr>-3 != NULL );
				sprintf( StaticName, "%s" sympost "%d", $<neID.idStr>-3, LblCntr++ );
				sn = hlastrdup2( StaticName ); 
				InsertProc
				(
					$<neID.idStr>-3,
					sn
				);

				$<en.s>$ = SymbolTable;
				SymbolTable->u.proc.Forward = NULL;
				CurrentContext = SymbolTable;

				/*
				** If we're processing a namespace section,
				** turn off the use of the Hash Table while
				** handling local symbols for the procedure.
				*/
				
				$<en.cns>$ = currentNS;
				currentNS = NULL;
				

				/*
				** Enter second copy of procedure name at the next
				** lower lex level in order to prevent an immediately
				** local procedure from having the same name.
				*/

				++CurLexLevel;
				sn = hlastrdup2( StaticName );
				InsertProc
				(
					hlastrdup2( $<neID.idStr>-3 ),
					hlastrdup2( sn )
				);
				SymbolTable->u.proc.Forward = NULL;
				CurOffset = StartParmOffs;

				/*
				** For the moment, return the pointer to the local
				** entry of this procedure in the proc.parms pointer
				** so the caller can fill in appropriate fields in
				** the local entry as well as the main entry for this
				** procedure.
				*/

				$<en.s>$->u.proc.parms = SymbolTable;

				/*
				** Create the "_initialize_" and "_finalize_" text symbols 
				** used to emit initialization code later on.
				*/

				dummy.v.u.strval = hlastrdup2( "" );
				InsertSym
				( 
					hlastrdup2( "_initialize_" ), 
					&string_ste,	/* This is a STRING object.		*/
					tString,
					cValue, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					&dummy,			/* Initially, no initialization	*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);

				dummy.v.u.strval = hlastrdup2( "" );
				InsertSym
				( 
					hlastrdup2( "_finalize_" ), 
					&string_ste,	/* This is a STRING object.		*/
					tString,
					cValue, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					YYS &dummy,		/* Initially, no initialization	*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);

				_here;

			}

	;


EnterName4:
			{
				char StaticName[ 256 ];
				char *sn;
				union YYSTYPE dummy;

				_here;
				assert( $<idStr>-4 != NULL );
				sprintf( StaticName, "%s" sympost "%d", $<idStr>-4, LblCntr++ );
				sn = hlastrdup2( StaticName ); 
				InsertProc
				(
					$<idStr>-4,
					sn
				);

				$<en.s>$ = SymbolTable;
				SymbolTable->u.proc.Forward = NULL;
				CurrentContext = SymbolTable;

				/*
				** If we're processing a namespace section,
				** turn off the use of the Hash Table while
				** handling local symbols for the procedure.
				*/
				
				$<en.cns>$ = currentNS;
				currentNS = NULL;
				

				/*
				** Enter second copy of procedure name at the next
				** lower lex level in order to prevent an immediately
				** local procedure from having the same name.
				*/

				++CurLexLevel;
				sn = hlastrdup2( StaticName );
				InsertProc
				(
					hlastrdup2( $<idStr>-4 ),
					hlastrdup2( sn )
				);
				SymbolTable->u.proc.Forward = NULL;
				CurOffset = StartParmOffs;

				/*
				** For the moment, return the pointer to the local
				** entry of this procedure in the proc.parms pointer
				** so the caller can fill in appropriate fields in
				** the local entry as well as the main entry for this
				** procedure.
				*/

				$<en.s>$->u.proc.parms = SymbolTable;

				/*
				** Create the "_initialize_" and "_finalize_" text symbols 
				** used to emit initialization code later on.
				*/

				dummy.v.u.strval = hlastrdup2( "" );
				InsertSym
				( 
					hlastrdup2( "_initialize_" ), 
					&string_ste,	/* This is a STRING object.		*/
					tString,
					cValue, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					&dummy,			/* Initially, no initialization	*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);

				dummy.v.u.strval = hlastrdup2( "" );
				InsertSym
				( 
					hlastrdup2( "_finalize_" ), 
					&string_ste,	/* This is a STRING object.		*/
					tString,
					cValue, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					YYS &dummy,		/* Initially, no initialization	*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);

				_here;

			}

	;

	/*
	** As above, except this routine is used to insert iterators
	** into the symbol table.
	*/

EnterIterName:
			{
				char StaticName[ 256 ];
				char *sn;
				union YYSTYPE dummy;

				_here;
				assert( $<neID.idStr>-3 != NULL );
				sprintf( StaticName, "%s" sympost "%d", $<neID.idStr>-3, LblCntr++ );
				sn = hlastrdup2( StaticName ); 
				InsertProc
				(
					$<neID.idStr>-3,
					sn
				);

				$<en.s>$ = SymbolTable;
				SymbolTable->u.proc.Forward = NULL;
				SymbolTable->pType = tIterator;
				SymbolTable->Type = &iterID_ste;
				SymbolTable->SymClass = cIterator;
				CurrentContext = SymbolTable;

				/*
				** Save currentNS and then set it to NULL
				** so that local IDs don't wind up in the
				** namespace hash table.
				*/
				
				$<en.cns>$ = currentNS;
				currentNS = NULL;

				/*
				** Enter second copy of procedure name at the next
				** lower lex level in order to prevent an immediately
				** local procedure from having the same name.
				*/

				++CurLexLevel;
				sn = hlastrdup2( StaticName );
				InsertProc
				(
					$<neID.idStr>-3,
					sn
				);
				SymbolTable->u.proc.Forward = NULL;
				SymbolTable->pType = tIterator;
				SymbolTable->Type = &iterID_ste;
				SymbolTable->SymClass = cIterator;
				CurOffset = StartParmOffs + 4;

				/*
				** For the moment, return the pointer to the local
				** entry of this procedure in the proc.parms pointer
				** so the caller can fill in appropriate fields in
				** the local entry as well as the main entry for this
				** procedure.
				*/

				$<en.s>$->u.proc.parms = SymbolTable;

				/*
				** Create the "_initialize_" and "_finalize_" text symbols 
				** used to emit initialization code later on.
				*/

				dummy.v.u.strval = hlastrdup2( "" );
				InsertSym
				( 
					"_initialize_", 
					&string_ste,	/* This is a STRING object.		*/
					tString,
					cValue, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					YYS &dummy,		/* Initially, no initialization	*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);

				dummy.v.u.strval = hlastrdup2( "" );
				InsertSym
				( 
					"_finalize_", 
					&string_ste,	/* This is a STRING object.		*/
					tString,
					cValue, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					YYS &dummy,		/* Initially, no initialization	*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);
				_here;
			}

	;



EnterIterName4:
			{
				char StaticName[ 256 ];
				char *sn;
				union YYSTYPE dummy;

				_here;
				assert( $<idStr>-4 != NULL );
				sprintf( StaticName, "%s" sympost "%d", $<idStr>-4, LblCntr++ );
				sn = hlastrdup2( StaticName ); 
				InsertProc
				(
					$<idStr>-4,
					sn
				);

				$<en.s>$ = SymbolTable;
				SymbolTable->u.proc.Forward = NULL;
				SymbolTable->pType = tIterator;
				SymbolTable->Type = &iterID_ste;
				SymbolTable->SymClass = cIterator;
				CurrentContext = SymbolTable;

				/*
				** Save currentNS and then set it to NULL
				** so that local IDs don't wind up in the
				** namespace hash table.
				*/
				
				$<en.cns>$ = currentNS;
				currentNS = NULL;

				/*
				** Enter second copy of procedure name at the next
				** lower lex level in order to prevent an immediately
				** local procedure from having the same name.
				*/

				++CurLexLevel;
				sn = hlastrdup2( StaticName );
				InsertProc
				(
					$<idStr>-4,
					sn
				);
				SymbolTable->u.proc.Forward = NULL;
				SymbolTable->pType = tIterator;
				SymbolTable->Type = &iterID_ste;
				SymbolTable->SymClass = cIterator;
				CurOffset = StartParmOffs + 4;

				/*
				** For the moment, return the pointer to the local
				** entry of this procedure in the proc.parms pointer
				** so the caller can fill in appropriate fields in
				** the local entry as well as the main entry for this
				** procedure.
				*/

				$<en.s>$->u.proc.parms = SymbolTable;

				/*
				** Create the "_initialize_" and "_finalize_" text symbols 
				** used to emit initialization code later on.
				*/

				dummy.v.u.strval = hlastrdup2( "" );
				InsertSym
				( 
					"_initialize_", 
					&string_ste,	/* This is a STRING object.		*/
					tString,
					cValue, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					YYS &dummy,		/* Initially, no initialization	*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);

				dummy.v.u.strval = hlastrdup2( "" );
				InsertSym
				( 
					"_finalize_", 
					&string_ste,	/* This is a STRING object.		*/
					tString,
					cValue, 
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					YYS &dummy,		/* Initially, no initialization	*/
					0,				/* Object size					*/
					0,				/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);
				_here;
			}

	;



SaveContext:
			{
				$<s>$ = CurrentContext;
				_here;
			}
	;






/*****************************************************/
















/*****************************************************************************/
/*****************************************************************************/
/**********************                           ****************************/
/**********************                           ****************************/
/**********************         T Y P E S         ****************************/
/**********************                           ****************************/
/**********************                           ****************************/
/*****************************************************************************/
/*****************************************************************************/



/******************************************************/
/*                                                    */
/* The following productions handle type definitions. */
/*                                                    */
/******************************************************/

Types:	SetInType
		doTypes
		{
			_here;
			inType = 0;
			_here;
		}
	;

SetInType:
		{
			_here;
			inType = 1;

			/*
			** "Prime" fastLookup for the first identifier we encounter:
			*/
			
			fastLookup = 1;
			
		}
	;




	/*
	** The following productions allow for zero or more type
	** declarations within a type section.
	*/

doTypes:

		Empty
		{
			_here;
		}
		 
	|	doTypes TypeDef
		{
			_here;
		} 
	;



/*
** TypeDef handles a single type definition.
**
**	Possible productions:
**
*/

TypeDef:

			/*
			** Allow empty declarations (just a semicolon) for
			** syntactical reasons (e.g., to put semicolons after
			** macros and such).
			*/

			';'
			{
				_here;
			}
	;
	

TypeDef:	
		UndefinedID		/* $1 */
		Colon			/* $2 */
		forwardTkn		/* $3 */
		Lparen			/* $4 */
		UndefinedID		/* $5 */
		Rparen			/* $6 */
		Semicolon		/* $7 */
		{				/* $8 */

			union YYSTYPE v;

			_here;
			assert( $<idStr>1 != NULL );
			assert( $<idStr>5 != NULL );

			v.v.u.strval = $<idStr>1;
			InsertSym
			( 
				$<idStr>5, 
				&text_ste,
				tText, 
				cConstant, 
				0,				/* arity 			*/
				NULL,			/* NumDimensions	*/
				0, 				/* NumElements		*/
				YYS &v,
				4,				/* ObjectSize		*/
				0,
				NULL,
				NULL,			/* Base				*/
				NULL,			/* Fields			*/
				0				/* FieldCnt			*/ 
			);

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;
		}
	;



			/*
			** Enumerated type declarations:
			** e.g., colors: enum={red, green, blue};
			**
			*/

TypeDef:	UndefinedID		/* $1 */ 
			Colon 			/* $2 */
			enumTkn			/* $3 */ 
			{				/* $4 */
				_here;
				assert( $<idStr>1 != NULL );

				/*
				** Insert the type name into the symbol table.
				*/

				InsertSym
				( 
					$<idStr>1, 
					NULL,		/* Treat like a primitive type (NULL type) */
					tEnum, 
					cType, 
					0,
					NULL,
					0, 
					NULL,
					EnumSize,
					0,
					NULL,
					NULL,
					NULL,
					0
				);

				/*
				** Initialize EnumVal to zero so we can assign
				** successive values to the following named constants.
				*/

				EnumVal = 0;
				$<s>$ = SymbolTable;

			}
			Lbrace 
			{
				/*
				** Set up an inherited attribute (parameter) for the
				** EnumList non-terminal.  This must be the address
				** of the symbol table entry created above.  Note that
				** the global SymbolTable pointer is currently pointing
				** at the symbol table entry for the type name we just
				** entered into the symbol table.
				*/

				$<v.Type>$ = SymbolTable;
				_here;
			}

			/*
			** Process all the names in the enumerated list.
			*/

			EnumList 
			Rbrace
			Semicolon
			{
				// Patch a pointer to the list of enumerated constant names
				// into the symbol table entry for the enumerated type:
				
				$<s>4->Fields = SymbolTable;
				$<s>4->FieldCnt = EnumVal;

				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				(void) $<v.Type>6; // shut up bison
				_here;
			}
	;





			/*
			** Handle pointer declarations here.
			*/

TypeDef:	UndefinedID			/* $1 */
			Colon				/* $2 */
			pointerTkn			/* $3 */
			toTkn				/* $4 */
			AnyID				/* $5 */
			Semicolon			/* $6 */
			{					/* $7 */

				struct	SymNode			*BaseType;

				char	*UndefinedID = $<idStr>1;
			
				assert( UndefinedID != NULL );
				assert( $<neID.idStr>5 != NULL );


				_here;
				BaseType = $<neID.s>5;
				_if( BaseType != NULL )

					BaseType = GetBaseType( BaseType );

				_endif
				InsertSym
				( 
					UndefinedID,		/* Name			*/
					&pointer_ste,		/* Type			*/
					tPointer, 			/* pType		*/
					cType,				/* SymClass		*/
					0,					/* Arity		*/
					NULL,				/* Dimensions	*/
					0, 					/* NumElements	*/
					NULL,				/* Value		*/
					4,					/* ObjectSize	*/
					0,					/* Offset		*/
					NULL,				/* StaticName	*/
					BaseType,			/* BaseType		*/
					NULL,				/* Fields		*/
					0					/* FieldCnt		*/
				);
				_if( BaseType == NULL )
				
					Add2PtrList( SymbolTable, $<neID.idStr>5 );

				_endif

				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
	;
   



TypeDef:	UndefinedID			/* $1 */
			Colon				/* $2 */
			pointerTkn			/* $3 */
			toTkn				/* $4 */
			ReservedTypeIDs		/* $5 */
			Semicolon			/* $6 */
			{					/* $7 */

			
				assert( $<idStr>1 != NULL );
				_here;
				InsertSym
				( 
					$<idStr>1,			/* Name			*/
					&pointer_ste,		/* Type			*/
					tPointer, 			/* pType		*/
					cType,				/* SymClass		*/
					0,					/* Arity		*/
					NULL,				/* Dimensions	*/
					0, 					/* NumElements	*/
					NULL,				/* Value		*/
					4,					/* ObjectSize	*/
					0,					/* Offset		*/
					NULL,				/* StaticName	*/
					$<s>5,				/* BaseType		*/
					NULL,				/* Fields		*/
					0					/* FieldCnt		*/
				);

				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
	;



ReservedTypeIDs:
		booleanTkn	
		{
			_here;
			$<s>$ = &boolean_ste;
		}

	|	int8Tkn	 
		{
			_here;
			$<s>$ = &int8_ste;
		}

	|	int16Tkn 
		{
			$<s>$ = &int16_ste;
		}

	|	int32Tkn
		{
			_here;
			$<s>$ = &int32_ste;
		}

	|	int64Tkn
		{
			$<s>$ = &int64_ste;
		}

	|	int128Tkn
		{
			_here;
			$<s>$ = &int128_ste;
		}

	|	charTkn 	
		{
			_here;
			$<s>$ = &char_ste;
		}

	|	wcharTkn 	
		{
			_here;
			$<s>$ = &wchar_ste;
		}

	|	real32Tkn	 
		{
			_here;
			$<s>$ = &real32_ste;
		}

	|	real64Tkn
		{
			_here;
			$<s>$ = &real64_ste;
		}

	|	real80Tkn
		{
			_here;
			$<s>$ = &real80_ste;
		}

	|	real128Tkn
		{
			_here;
			$<s>$ = &real128_ste;
		}

	|	uns8Tkn	 	
		{
			_here;
			$<s>$ = &uns8_ste;
		}

	|	uns16Tkn	 
		{
			_here;
			$<s>$ = &uns16_ste;
		}

	|	uns32Tkn 
		{
			_here;
			$<s>$ = &uns32_ste;
		}

	|	uns64Tkn 
		{
			_here;
			$<s>$ = &uns64_ste;
		}

	|	uns128Tkn 
		{
			_here;
			$<s>$ = &uns128_ste;
		}

	|	stringTkn
		{
			_here;
			$<s>$ = &string_ste;
		}

	|	zstringTkn
		{
			_here;
			$<s>$ = &zstring_ste;
		}

	|	wstringTkn
		{
			_here;
			$<s>$ = &wstring_ste;
		}

	|	csetTkn		
		{
			_here;
			$<s>$ = &cset_ste;
		}

	|	byteTkn	
		{
			_here;
			$<s>$ = &byte_ste;
		}

	|	wordTkn  
		{
			_here;
			$<s>$ = &word_ste;
		}

	|	dwordTkn
		{
			_here;
			$<s>$ = &dword_ste;
		}

	|	qwordTkn
		{
			_here;
			$<s>$ = &qword_ste;
		}

	|	tbyteTkn
		{
			_here;
			$<s>$ = &tbyte_ste;
		}

	|	lwordTkn
		{
			_here;
			$<s>$ = &lword_ste;
		}

	|	thunkTkn
		{
			_here;
			$<s>$ = &thunk_ste;
		}
	;



	/*
	** Handle procedure type definitions here
	*/


typeDefNamem4:
		{

			struct SymNode *saveSym;
			
			_here;
			assert( $<idStr>-4 != NULL );
			InsertSym
			( 

				$<idStr>-4,
				&proctype_ste,
				tProcptr, 
				cType, 
				0,
				NULL,
				0, 
				NULL,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			$<s>$ = SymbolTable;
			CurOffset = StartParmOffs;
			++CurLexLevel;

			/*
			** Reinsert the symbol into the local symbols
			** to keep the logic of this program happy.
			*/

			saveSym = currentNS;	// Do not enter this second
			currentNS = NULL;		//  symbol into the hash table!
			InsertSym
			( 
				$<idStr>-4,
				&proctype_ste,
				tProcptr, 
				cType, 
				0,
				NULL,
				0, 
				NULL,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			currentNS = saveSym;

			/*
			** Temporary assignment so we can patch the local
			** entry later.
			*/

			$<s>$->u.proc.parms = SymbolTable;
			$<s>$->u.proc.returns = hlastrdup2( "" );
			$<s>$->u.proc.use = NULL;
			_here;
		}
	;
	


TypeDef:	
		UndefinedID		/* $1 */ 
		Colon 			/* $2 */
		procedureTkn 	/* $3 */
		
		/*
		** Before going any farther, save the current
		** (previous lex level) variable offset and offset 
		** direction so we can restore these values when
		** the compiler finishes this declaration.  Note that the
		** compiler saves these values in the attributes of the
		** following grammar symbols.
		*/
		
		SaveOffset		/* $4 */ 
		SaveDirection	/* $5 */

		/*
		** Also, set up the offset and direction values as appropriate
		** for processing parameters.  Then process the optional
		** parameter list.
		*/

		typeDefNamem4		/* $6 */
		OptionalParms	 	/* $7 */
		';'					/* $8 */
		Options				/* $9 */
		 
		/*
		** Initialize the pointer to the end of the parameters
		** for this procedure variable.
		** Set up the offset and direction variables to handle
		** local variable declarations.  
		*/
		 
		{				/* $10 */

			union YYSTYPE value;
			
			_here;
			--CurLexLevel;
			CurOffset = $<v.u.unsval>4;
			CurOffsetDir = $<v.u.unsval>5;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_returns
				|	specified_use
				|	specified_pascal
				|	specified_stdcall
				|	specified_cdecl
				|	specified_alignment 
			);
			$<s>6->u.proc.parms->u.proc.parms = SymbolTable;
			$<s>6->u.proc.parms->u.proc.returns = $<options.returns>9;
			$<s>6->u.proc.parms->u.proc.use = $<options.use>9;
			$<s>6->u.proc.parms->u.proc.ParmSize = $<v.u.unsval>7;

			$<s>6->u.proc.parms = SymbolTable;
			$<s>6->u.proc.returns = $<options.returns>9;
			$<s>6->u.proc.use = $<options.use>9;
			$<s>6->u.proc.cs = $<options.CallingSequence>9;
			$<s>6->u.proc.ParmSize = $<v.u.unsval>7;

			/*
			** Just to be on the safe side, let's create
			** a "parms" and "vars" entry for this object.
			*/
			
			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.v.u.unsval = $<v.u.unsval>7;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			value.v.u.unsval = 0;
			InsertSym
			( 
				"_vars_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			$<s>6->u.proc.parms->u.proc.Locals = SymbolTable;
			$<s>6->u.proc.Locals = SymbolTable;
			
			SymbolTable = $<s>6;

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;
		}
	;






TypeDef:	
		UndefinedID		/* $1 */ 
		Colon 			/* $2 */
		procedureTkn 	/* $3 */
		
		/*
		** Before going any farther, save the current
		** (previous lex level) variable offset and offset 
		** direction so we can restore these values when
		** the compiler finishes this declaration.  Note that the
		** compiler saves these values in the attributes of the
		** following grammar symbols.
		*/
		
		SaveOffset		/* $4 */ 
		SaveDirection	/* $5 */

		/*
		** Also, set up the offset and direction values as appropriate
		** for processing parameters.  Then process the optional
		** parameter list.
		*/

		typeDefNamem4				/* $6  */
		OptionalParms 				/* $7  */
		newProcOptions				/* $8  */
		';'							/* $9  */
		 
		/*
		** Initialize the pointer to the end of the parameters
		** for this procedure variable.
		** Set up the offset and direction variables to handle
		** local variable declarations.  
		*/
		 
		{							/* $10 */

			union YYSTYPE value;
			
			_here;
			--CurLexLevel;
			CurOffset = $<v.u.unsval>4;
			CurOffsetDir = $<v.u.unsval>5;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_returns
				|	specified_use
				|	specified_pascal
				|	specified_stdcall
				|	specified_cdecl
				|	specified_alignment 
			);
			$<s>6->u.proc.parms->u.proc.parms = SymbolTable;
			$<s>6->u.proc.parms->u.proc.returns = $<options.returns>8;
			$<s>6->u.proc.parms->u.proc.use = $<options.use>8;

			$<s>6->u.proc.parms = SymbolTable;
			$<s>6->u.proc.returns = $<options.returns>8;
			$<s>6->u.proc.use = $<options.use>8;
			$<s>6->u.proc.cs = $<options.CallingSequence>8;
			
			/*
			** Just to be on the safe side, let's create
			** a "parms" and "vars" entry for this object.
			*/
			
			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.v.u.unsval = $<v.u.unsval>7;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			value.v.u.unsval = 0;
			InsertSym
			( 
				"_vars_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			$<s>6->u.proc.parms->u.proc.Locals = SymbolTable;
			$<s>6->u.proc.Locals = SymbolTable;
			
			SymbolTable = $<s>6;

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;
		}
	;
















 /*
 ** Handle type declarations of the form:
 **
 **		procptrtype : pointer to procedure yyyy;
 */

TypeDef:
		UndefinedID		/* $1 */ 
		Colon 			/* $2 */
		pointerTkn		/* $3 */
		toTkn			/* $4 */
		procedureTkn 	/* $5 */
		DefinedID		/* $6 */
		Semicolon		/* $7 */
		{				/* $8 */
			
			_here;
			assert( $<idStr>1 != NULL );
			CreatePtrToProc( $<idStr>1, $<s>6, NULL, cType );

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;
		}
	;




/*
** Handle type isomorphisms (renaming) here.
** This consists of defining one identifier to be the
** same as some other type identifier.
**
*/



TypeDef:	UndefinedID 
			Colon 
			TypeID 
			Semicolon
			{
				struct	SymNode	*BaseType;
				struct	SymNode	*next;
						char	*name;
						char	*trueName;
			
				_here;
				assert( $<idStr>1 != NULL );

				/*
				** If TypeID is an isomorphism for some other type,
				** then its type field will point at the most
				** primitive type representing the complete transitive
				** closure of its type (i.e., following the type
				** chain down to the root as long as there are type
				** isomorphisms).  Once a non-primitive type enters
				** the equation, the TypeID field will contain NULL
				** (e.g., for a record object).
				**
				** Note, since all type IDs are maintained this
				** way, there is never more than one level we
				** have to seek (at most) only one link down
				** from TypeID.
				**
				** Hence, if TypeID's Type field is NULL, then
				** using TypeID's address as the type of this new
				** symbol  If TypeID's Type field is non-Null,
				** then use TypeID's Type field as the type of the
				** new object.
				*/

				BaseType = GetBaseType( $<s>3 );
				InsertSym
				( 
					$<idStr>1,
					BaseType, 
					$<s>3->pType, 
					cType, 
					$<s>3->Arity,
					$<s>3->Dimensions,
					$<s>3->NumElements, 
					NULL,
					$<s>3->ObjectSize,
					0,
					NULL,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt
				);
				SymbolTable->MaxObjectSize = $<s>3->MaxObjectSize;
				_if( $<s>3->pType == tProcptr )
				
					// Copy parameter info if a proc ptr.
					
					memcpy
					( 
						&SymbolTable->u, 
						&$<s>3->u, 
						sizeof( union ValuesSize )
					);
					
				_endif

				/*
				** Copy any data (e.g., procedure "returns" value) to
				** the new type.
				*/

				memcpy
				(
					&SymbolTable->u.StartOfValues,
					&BaseType->u.StartOfValues,
					sizeof( union ValuesSize )
				);


				/*
				** If it's a class object, copy the fields.
				*/

				_if( BaseType->pType == tClass )

					SymbolTable->Fields = 
						CopySymbols
						( 
							BaseType->Fields,
							BaseType->StaticName
						);
					SymbolTable->StaticName = hlastrdup2( BaseType->StaticName );
					NullTerminate( SymbolTable->Fields, SymbolTable );

				_elseif(  BaseType->pType == tThunk )

					/*
					** Need some dummy local vars for a thunk.
					*/

					SymbolTable->u.proc.parms = &true_ste;

				_endif


				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
	;








	/*
	** Allow the definition of an array type here.
	** Typical definition:
	**
	**		UndefinedID : TypeID [ dimension list ] ;
	**
	**
	*/


TypeDef:	UndefinedID 
			Colon 
			TypeID
			'[' 
			DimList 
			Rbrack 
			Semicolon
			{
				int	Size = 1;

				_here;
				assert( $<s>3 != NULL );
				assert( $<idStr>1 != NULL );

				/*
				** Text arrays are illegal.  Deal with that here.
				*/

				_if( $<s>3->pType == tText )

					assert( $<v.Dimensions>5 != NULL );
					yyerror( "Text arrays are illegal" );
					free2( vss $<v.Dimensions>5 );
				

				/*
				** If TypeID is not an array type, then we've got an
				** array of some scalar type.
				*/

				_elseif( $<s>3->pType != tArray )

					struct SymNode *TheType;

					/*
					** Compute the total size (in bytes) of the array.
					*/

					Size = 	$<s>3->ObjectSize * $<v.NumElements>5;

					/*
					** Compute the type of an array element.
					** (If Type field is NULL, it's a base type, else it's
					** a some derived type).
					*/

					TheType = GetBaseType( $<s>3 );

					
					// Insert the new type definition into the symbol table.
					
					InsertSym
					( 
						$<idStr>1, 
						TheType,
						tArray, 
						cType, 
						$<v.Arity>5,
						$<v.Dimensions>5,
						$<v.NumElements>5, 
						NULL,
						Size,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);
					_if( $<s>3->pType == tProcptr )
					
						// Copy parameter info if a proc ptr.
						
						memcpy
						( 
							&SymbolTable->u, 
							&$<s>3->u, 
							sizeof( union ValuesSize )
						);
						
					_endif
					
					/*
					** For arrays, the MaxObjectSize field must
					** be the MaxObjectSize of an element
					*/
					
					SymbolTable->MaxObjectSize = $<s>3->MaxObjectSize; 

					/*
					** Copy any data (e.g., procedure "returns" value) to
					** the new type.
					*/

					memcpy
					(
						&SymbolTable->u.StartOfValues,
						&TheType->u.StartOfValues,
						sizeof( union ValuesSize )
					);

					/*
					** Handle the case where the base type is a class.
					*/

					_if( TheType->pType == tClass )

						SymbolTable->Fields = 
							CopySymbols
							( 
								TheType->Fields,
								TheType->StaticName
							);
							
						SymbolTable->StaticName = 
							hlastrdup2( TheType->StaticName );
							
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_elseif(  TheType->pType == tThunk )

						/*
						** Need some dummy local vars for a thunk.
						*/

						SymbolTable->u.proc.parms = &true_ste;


					_endif



				/*
				** If TypeID is an array type, then we're creating
				** an array of arrays (i.e., a multidimensional array).
				** The following code handles this case.
				*/

				_else

					int *DimensionArray;
					struct	SymNode *TheType;

					/*
					** Create a dimension array big enough to hold
					** the indexes from TypeID plus the indexes the
					** current production is adding.
					*/

					DimensionArray = 
						malloc2
						( 
							( $<s>3->Arity + $<v.NumElements>5 ) * 
								sizeof( int )
						);


					/*
					** Copy TypeID's dimension list to the new
					** dimension list.
					*/

					assert( $<s>3->Dimensions != NULL );
					memcpy
					( 
						DimensionArray, 
						$<s>3->Dimensions, 
						$<s>3->Arity * sizeof( int )
					);

					/*
					** Append the new dimension list to the end of TypeID's.
					*/			   

					assert( $<v.Dimensions>5 != NULL );
					memcpy
					(
						&DimensionArray[ $<s>3->Arity ],
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);

					/*
					** Compute and save the base type of an array element.
					*/

					TheType =	GetBaseType( $<s>3 );

					/*
					** Insert this new array type into the symbol table.
					*/

					InsertSym
					( 
						$<idStr>1, 
						TheType,
						tArray, 
						cType, 
						$<s>3->Arity + $<v.Arity>5,
						DimensionArray,
						$<s>3->NumElements * $<v.NumElements>5, 
						NULL,
						$<s>3->ObjectSize * $<v.NumElements>5,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);
					_if( $<s>3->pType == tProcptr )
					
						// Copy parameter info if a proc ptr.
						
						memcpy
						( 
							&SymbolTable->u, 
							&$<s>3->u, 
							sizeof( union ValuesSize )
						);
						
					_endif

					/*
					** Copy any data (e.g., procedure "returns" value) to
					** the new type.
					*/

					memcpy
					(
						&SymbolTable->u.StartOfValues,
						&TheType->u.StartOfValues,
						sizeof( union ValuesSize )
					);

					/*
					** Handle the case where the base type is a class.
					*/

					_if( TheType->pType == tClass )

						SymbolTable->Fields = 
							CopySymbols
							( 
								TheType->Fields,
								TheType->StaticName
							);
						SymbolTable->StaticName = 
							hlastrdup2( TheType->StaticName );
							
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_elseif(  TheType->pType == tThunk )

						/*
						** Need some dummy local vars for a thunk.
						*/

						SymbolTable->u.proc.parms = &true_ste;


					_endif


					/*
					** Free the dimension list array because we're
					** not going to use it.  Note that we don't
					** free TypeID's dimension list because TypeID
					** is still using it.
					*/

					free2( vss $<v.Dimensions>5 );

				_endif


				/*
				** "Prime" fastLookup for the next identifier we encounter:
				*/
				
				fastLookup = 1;
				_here;
			}
		;



			/*
			** Handle record declarations here.
			**
			** Such declarations use the following production:
			**
			**	UndefID : record  variable_declarations endrecord
			**
			**	variable_declarations is all the stuff that can
			**	appear in a VAR section plus an anonymous union.
			**
			** Note that while processing record declarations this code
			** must adjust the offset, direction, lex level, and offset
			** addition position;  this requires saving and restoring
			** the current values.
			**
			** While processing record fields:
			**
			**	The offset starts at zero if there is no ancestor (base)
			**	record. It starts at the size of the base record if one
			**	exists.
			**
			**	The offset direction is positive (new fields are given
			**	high offsets in the record).
			**
			**	The current offset is assigned to a field *before* adding
			**	in the size of the object.
			**
			**	The lex level is set to -2 for records.
			**
			**
			*/


TypeDef:	
		UndefinedID		/* $1 */
		Colon			/* $2 */
		dorecordTkn		/* $3 */
		recordOpts		/* $4 */
		OptInherits		/* $5 */
		RecordStuff		/* $6 */
		endrecordTkn	/* $7 */
		Semicolon		/* $8 */
		{
			struct	SymNode		*Fields;
			struct	SymNode		TheValue;
			int					FieldCnt;
			int					LargestField;
			int					RecSize;
			int					fieldCntr;

			/*
			** Restore currentNS before we enter this record
			** type into the symbol table.
			*/
			
			_here;
			currentNS = $<ru.saveCurNS>3;
			RecNS = $<ru.saveRecNS>3;
			RecGlobal = $<ru.saveRecGlobal>3;

			/*
			** Make sure there was at least one field in the record.
			*/

			_if( RecFieldCnt != 0 )


				struct SymNode	*CurSym;


				
				/*
				** We need to mark the end of the fields symbol list.  
				** This is all the entries in the symbol table from
				** SymbolTable through the pointer to the record
				** sym tbl entry saved above.
				**
				** While traversing the fields, we'll also compute
				** the size of the largest field (for alignment
				** purposes).
				*/

				FieldCnt = 1;

				CurSym = SymbolTable;
				LargestField = 0;
				_while
				( 
						CurSym->Next != NULL 
					&&	CurSym->Next != &dummyField_ste 
				)

					LargestField = max( LargestField, CurSym->MaxObjectSize );
					CurSym = CurSym->Next;
					++FieldCnt;

				_endwhile
				LargestField = max( LargestField, CurSym->MaxObjectSize );
				CurSym->Next = NULL;


				/*
				** Okay, create the record symbol table entry
				** and attach the fields symbol table to that entry.
				*/


				CurLexLevel = $<ru.SaveLex>3;
				Fields = SymbolTable;
				SymbolTable = $<ru.endFields>3;
				RecSize = CurOffset - $<ru.CurOffset>3;
				
				/*
				** If there was an align at the end of the
				** record, then we need to extend the size
				** of the record so that it is aligned on
				** the specified boundary.
				*/

				_if( TempRecAlign != 1 )
				

					RecSize = 
							(
									(RecSize + TempRecAlign - 1) 
								/ 	TempRecAlign 
							) * TempRecAlign;
							
					TempRecAlign = 1;

				_endif
					
					

				TheValue.u.intval = RecSize;
				InsertSym
				(
					$<idStr>1,

					NULL,
					tRecord,
					cType,
					0,
					NULL,
					FieldCnt,
					YYS &TheValue,
					RecSize,
					0,
					NULL,
					$<ru.base>3,
					Fields,
					FieldCnt
				);
				SymbolTable->MaxObjectSize = LargestField;
				
				// Now we need to go through all the fields and
				// patch the "Parent" field to point at this
				// symbol table entry.
				
				_for( int fieldCntr = 0, fieldCntr < FieldCnt, ++fieldCntr )
				
					Fields->Parent = SymbolTable;
					Fields = Fields->Next;
					
				_endfor
				 

			_else	/* There were no fields in this record */

				CurLexLevel = $<ru.SaveLex>3;
				yyerror
				( 
					"Records must contain at least one field" 
				);

			_endif

			/*
			** Patch any forward referenced pointers that
			** may reference the newly created record
			*/
			
			PatchPtrs();

			/*
			** Restore the following to their previous values
			** (prior to processing the fields in the record).
			*/

			CurOffset = $<ru.SaveOffset>3;
			CurOffsetDir = $<ru.SaveDir>3;
			AddOffset1st = $<ru.SaveAdd1st>3;
			inRecord = $<ru.inSave>3;
			MinRecAlignment = $<ru.MinRecAlignment>3;
			MaxRecAlignment = $<ru.MaxRecAlignment>3;
			RecFieldCnt = $<ru.RecFieldCnt>3;
			_here;
		}
	;

				



	/*
	** Handle union declarations here.
	** The code is nearly identical to that for records except
	** that we don't increment the offset for each field encountered
	** in the union (the CurOffsetDir variable provides a tricky
	** way to force this).  Also note that unions never have a base
	** record.
	**
	*/


TypeDef:
		UndefinedID		/* $1 */
		Colon			/* $2 */
		doUnionTkn		/* $3 */
		UnionStuff		/* $4 */
		endunionTkn		/* $5 */
		Semicolon		/* $6 */
		{
			int					SizeOfUnion;
			int					FieldCnt;
			struct	SymNode		*Fields;
			struct	SymNode		TheValue;
			struct	SymNode		*CurSym;
			  
			_here;
			
			/*
			** Restore currentNS before we enter this union
			** type into the symbol table.
			*/
			
			currentNS = $<ru.saveCurNS>3;
			RecNS = $<ru.saveRecNS>3;
			RecGlobal = $<ru.saveRecGlobal>3;

			/*
			** Determine if there were any fields present in
			** the union.
			*/

			_if( RecFieldCnt == 0 )

				yyerror( "Unions must have at least one field" );
				CurLexLevel = $<ru.SaveOffset>3;

			_else

				/*
				** Null terminate the list of fields in the union.
				** Since inheritence is not possible, just search
				** for the Union ID's symbol table entry to determine
				** the end of the union field list.
				*/

				CurSym = SymbolTable;
				SizeOfUnion = 0;
				FieldCnt = 0;
				_while
				( 
						CurSym->Next != NULL 
					&&	CurSym->Next != &dummyField_ste 
				)					
				

					SizeOfUnion = 
						max( SizeOfUnion, CurSym->ObjectSize);
					
					_if( CurSym->pType != tAnonRec )
					
						++FieldCnt;
					
					_endif
					CurSym = CurSym->Next;

				_endwhile
				CurSym->Next = NULL;
				_if( CurSym->pType != tAnonRec )
				
					++FieldCnt;
				
				_endif
				SizeOfUnion = 
					max( SizeOfUnion, CurSym->ObjectSize);

				/*
				** Okay, create the union symbol table entry
				** and attach the fields symbol table to that entry.
				*/

				CurLexLevel = $<ru.SaveLex>3;
				Fields = SymbolTable;
				SymbolTable = $<ru.endFields>3;
				TheValue.u.intval = SizeOfUnion;
				InsertSym
				(
					$<idStr>1,
					NULL,
					tUnion,
					cType,
					0,
					NULL,
					0,
					YYS &TheValue,
					SizeOfUnion,
					0,
					NULL,
					NULL,
					Fields,
					FieldCnt
				);

			_endif

			/*
			** Restore remaining compiler variable not already
			** restored above.
			*/

			CurOffset = $<ru.SaveOffset>3;
			CurOffsetDir = $<ru.SaveDir>3;
			AddOffset1st = $<ru.SaveAdd1st>3;
			inUnion = $<ru.inSave>3;
			RecFieldCnt = $<ru.RecFieldCnt>3;
			MinRecAlignment = $<ru.MinRecAlignment>3;
			MaxRecAlignment = $<ru.MaxRecAlignment>3;
			inUnion = $<ru.inSave>3;

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;
		}
	;

	/*
	** Handle class declarations here.
	**
	** Such declarations use the following production:
	**
	**	UndefID : class optional_base  variable_declarations endclass
	**
	**	variable_declarations includes CONST, VALUE, VAR, STATIC,
	**	MACRO, and PROCEDURE declarations (notably absent are
	**	TYPE and DATA declaration sections).
	**
	** Note that while processing class declarations this code
	** must adjust the offset, direction, lex level, and offset
	** addition position;  this requires saving and restoring
	** the current values.
	**
	** While processing class fields:
	**
	**	The offset starts at zero if there is no ancestor (base)
	**	record. It starts at the size of the base record if one
	**	exists.
	**
	**	The offset direction is positive (new fields are given
	**	high offsets in the class).
	**
	**	The current offset is assigned to a field *before* adding
	**	in the size of the object.
	**
	**	The lex level is set to -256 for classes.
	*/

TypeDef:
		UndefinedID		/* $1 */
		Colon			/* $2 */
		SaveOffset 		/* $3 */
		SaveDirection	/* $4 */
		SaveAdd1st		/* $5 */
		SaveLex256		/* $6 */
		SaveClassPtr	/* $7 */
		doClassTkn		/* $8 */
		OptionalInherit	/* $9 */
		{				/* $10 */

			struct SymNode	*theClass;
			struct SymNode	TheValue;
			char			StaticName[ 256 ];
			char			*sn;

			_here;
			
			/*
			** Put the name of the virtual method table (VMT)
			** in the StaticName field of this symbol.
			*/

			sprintf( StaticName, "_VMT_%s_" sympost, $<idStr>1 );
			sn = hlastrdup2( StaticName );

			/*
			** Save the address of the class' symbol table entry
			** as the Symbol attribute for this semantic action.
			** We'll use this address later to determine which
			** symbol table entries are fields in the class.
			*/

			TheValue.u.intval = CurOffset;
			InsertSym
			(
				$<idStr>1,
				NULL,
				tClass,
				cType,
				0,
				NULL,
				0,
				YYS &TheValue,
				CurOffset,
				0,
				sn,
				$<s>9,
				NULL,
				0
			);
			$<s>$ = SymbolTable;	// So we can find the end of the list later.
			ClassPtr = SymbolTable;
			
			
			// Patch any pointers to this class:
			
			PatchPtrs();


			/*
			** If this class is inheriting fields from a base class,
			** adjust the CurOffset value to the size of the base
			** class; otherwise set the CurOffset value to four and
			** add a VMT (virtual method table) pointer to the class.
			*/

			_if( $<s>9 == NULL )


				/*
				** No fields to inherit, so create an entry for
				** the VMT.
				*/

				struct SymNode v;
						 
				TheValue.u.strval = hlastrdup2( StaticName );
				InsertSym
				(
					"_VMT_",			/* Name,		 */
					&dword_ste,			/* TheType,		 */
					tDWord,				/* pType,		 */
					cStatic,			/* TheClass,	 */
					0,					/* Arity,		 */
					NULL,				/* Dimensions,	 */
					0,					/* NumElements,	 */
					YYS &TheValue,		/* TheValue,	 */
					4,					/* ObjectSize,	 */
					0,					/* Offset,		 */
					hlastrdup2(StaticName),/* StaticName,	 */
					NULL,				/* Base,		 */
					NULL,				/* Fields,		 */
					0					/* FieldCnt		 */
				);
				EmitVMTExtern( SymbolTable, sn );


				v.u.strval = hlastrdup2( "_pVMT_" );
				CurOffset = 4;
				InsertSym
				(
					"_pVMT_",
					&pointer_ste,
					tPointer,
					cVar,
					0,
					NULL,
					0,
					YYS &v,
					4,
					0,
					hlastrdup2( StaticName ),
					&dword_ste,
					NULL,
					0
				);


			_else


				/*
				** Okay, we're inheriting fields.  Copy the fields
				** from the base type to this class (we have to do
				** this because someone might change the values
				** of the VAL objects and we don't want those changes
				** to be global).
				*/

				SymbolTable = CopySymbols( $<s>9->Fields, sn );
				CurOffset = $<s>9->ObjectSize;
				EmitVMTExtern( SymbolTable, sn );

				$<s>$->NumElements = $<s>9->NumElements;
				$<s>$->Base = $<s>9;
				$<s>$->Fields = SymbolTable;
				$<s>$->FieldCnt = $<s>9->FieldCnt;
				$<s>$->LexLevel = $<v.u.intval>6;
				$<s>$->u.intval = CurOffset;
				$<s>$->ObjectSize = CurOffset;



			_endif



			/*
			** Class fields have increasing offset values,
			** the first field is at offset four (to make room
			** for the VMT pointer), and fields don't
			** exist at the current program unit's lex level.
			*/

			CurOffsetDir = 1;
			AddOffset1st = 0;
			
			
			_here;

		}
		optionalSemicolon	/* $11 */
		{					/* $12 */

			/*
			** Get the surrounding lex level for use by ClassStuff
			*/

			$<v.u.intval>$ = $<v.u.intval>6;
			_here;
		}
		ClassStuff		/* $13 */
		endclassTkn		/* $14 */
		Semicolon		/* $15 */
		{				/* $16 */

			struct	SymNode		*classSym;
			struct	SymNode		*CurSym;
			int					FieldCnt;
			char				StaticName[ 256 ];

			_here;
			
			/*
			** We need to mark the end of the fields symbol list.  
			** This is all the entries in the symbol table from
			** SymbolTable through the pointer to the record
			** sym tbl entry saved above.
			*/

			FieldCnt = 1;
			CurSym = SymbolTable;
			_while( CurSym->Next != NULL && CurSym->Next != $<s>10 )

				CurSym = CurSym->Next;
				++FieldCnt;

			_endwhile
			CurSym->Next = NULL;
			classSym = $<s>10;		// Ptr to original class entry.


			/*
			** Okay, create the class symbol table entry
			** and attach the field's symbol table to that entry.
			*/


			CurLexLevel = $<v.u.intval>6;
			classSym->NumElements = FieldCnt;
			classSym->u.intval = CurOffset;
			classSym->ObjectSize = CurOffset;
			classSym->Base = $<s>9;
			classSym->Fields = SymbolTable;
			classSym->FieldCnt = FieldCnt;
			classSym->LexLevel = $<v.u.intval>6;
			SymbolTable = classSym;


			/*
			** Update the offset values in the class' method and iterator
			** fields.
			*/

			UpdateVMTOffsets( classSym );


			/*
			** Clean up any forward pointer declarations
			** that were handled within the class:
			*/
			
			PatchPtrs();
			
			/*
			** Restore the following to their previous values
			** (prior to processing the fields in the class).
			*/

			CurOffset = $<v.u.intval>3;
			CurOffsetDir = $<v.u.intval>4;
			AddOffset1st = $<v.u.unsval>5;
			ClassPtr = $<s>6;
			inClass = $<v.u.unsval>8;

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			(void) $<v.u.intval>12; // shut up bison
			_here;

		}
	;


doClassTkn:
		classTkn
		{
			_here;
			$<v.u.unsval>$ = inClass;
			inClass = 1;
		}
	;

				











			/*
			** Handle some common errors
			**
			*/


TypeDef:	AnyLocalID
			Colon
			unionTkn
			UnionStuff
			endunionTkn
			Semicolon
			{
				ErrorNear
				( 
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);

			}

		|	AnyLocalID
			Colon
			dorecordTkn
			recordOpts
			OptInherits
			RecordStuff
			endrecordTkn
			Semicolon
			{
				ErrorNear
				( 
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);
				inRecord =	$<ru.inSave>5;
				MinRecAlignment =	$<ru.MinRecAlignment>5;
				MaxRecAlignment =	$<ru.MaxRecAlignment>5;
				currentNS = $<ru.saveCurNS>3;
				RecNS = $<ru.saveRecNS>3;
				RecGlobal = $<ru.saveRecGlobal>3;

			}

		|	AnyLocalID 
			Colon 
			ArbID 
			'[' 
			DimList 
			Rbrack  
			Semicolon
			{
				ErrorNear
				( 
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);
				free2( vss $<idStr>3 );
			}

		|	AnyLocalID 
			Colon 
			ArbID 
			Semicolon
			{
				ErrorNear
				( 
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);
				free2( vss $<idStr>3 );
			}

	
		|	AnyLocalID 
			Colon 
			enumTkn 
			Lbrace 
			EnumList 
			Rbrace 
			Semicolon
			{
				ErrorNear
				( 			  
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);

			}


		|	UndefinedID 
			Colon 
			UndefID 
			'[' 
			DimList 
			Rbrack  
			Semicolon
			{
				ErrorNear
				( 
					"Undefined symbol", 
					$<idStr>3,
					__LINE__,
					__FILE__ 
				);

			}

		|	UndefinedID 
			Colon 
			UndefID 
			Semicolon
			{
				ErrorNear
				( 
					"Undefined symbol", 
					$<idStr>3,
					__LINE__,
					__FILE__ 
				);

			}


		|	error ';'
	
		;




/*****************************************************/




/************************************************************/
/*                                                          */
/* Handle label (forward) declarations in these productions */
/*                                                          */
/************************************************************/

				
FwdLabels:

		/* Empty */
		
	|	FwdLabels			/* $1 */ 
		UndefinedID 		/* $2 */
		Semicolon  			/* $3 */
		OptionalExternal	/* $4 */
		{
			/*
			** The program is declaring a forward-referenced statement
			** label.  Enter the label into the forward reference list.
			*/

			struct FwdRefLabelType *flist;
			struct FwdRefLabelType *temp;
			char sn[ 256 ];

			_here;
			
			/*
			** First, let's see if there is already a reference
			** to this particular identifier so we can use the
			** existing StaticName.
			*/

			flist = FwdLabelsList;
			_while( flist != NULL )

				_breakif( _streq( $<idStr>2, flist->label ));
				flist = flist->Next;

			_endwhile

			_if( flist == NULL && $<returns>4 == NULL )

				/*
				** We didn't find the symbol in the forward reference
				** list and it's not an external label, so add it to the list.
				*/

				temp = malloc2( sizeof( struct FwdRefLabelType ));
				temp->Next = FwdLabelsList;
				temp->label = hlastrdup2( $<idStr>2 );
				temp->lexLevel = CurLexLevel;
				sprintf( sn, "%s" sympost "%d", $<idStr>2, LblCntr++ );
				temp->StaticName = hlastrdup2( sn );
				temp->isExternal = 0;
				temp->referenced = 0;
				FwdLabelsList = temp;
				
			_else
			
				_if( $<returns>4 != NULL )
				
					// They've specified the @external option:
					
					_if( *$<returns>4 == '\0' ) // No optional string.
					
						strcpy( sn, $<idStr>2 );
						
					_else // Has optional string.
					
						strcpy( sn, $<returns>4 );
						
					_endif
					
				_else
				
					// The symbol has been previously referenced but
					// is not yet defined.  Create a static name for it.
					
					sprintf( sn, "%s" sympost "%d", $<idStr>2, LblCntr++ );
				
				_endif
			
				/*
				** Okay, it's an external label.  First check to
				** see if it appears in the forward reference
				** list.  If so, we've got to adjust the
				** static name for the label.
				*/
				
				_if( flist != NULL )
				
					EmitBackPatchss( flist->StaticName, sn, tLabel );
					free2( vss flist->StaticName );
					flist->StaticName = hlastrdup2( sn );
					
				_endif 
				InsertSym
				( 
					$<idStr>2, 
					NULL,
					tLabel, 
					cLabel, 
					0,					/* Arity 		*/
					NULL,				/* Dimensions	*/
					0, 					/* NumElements	*/
					NULL,				/* Value		*/
					0,					/* ObjectSize	*/
					0,					/* Offset		*/
					hlastrdup2( sn ),	/* Static Name	*/
					NULL,				/* Base			*/
					NULL,				/* Fields		*/
					0					/* FieldCnt		*/
				);
				
				EmitTypedExtern( SymbolTable, sn, tLabel );				
				_if( $<returns>4 != NULL )

					SymbolTable->IsExternal = 1;
					
				_endif
				
				// Set the type to NULL to indicate that
				// it's not been defined yet.
				
				SymbolTable->Type = NULL;
			
			_endif
			free2( vss $<returns>4 );
			_here;
		}
	;
	







/*****************************************************************************/
/*****************************************************************************/
/**********************                           ****************************/
/**********************                           ****************************/
/**********************    C O N S T A N T S      ****************************/
/**********************                           ****************************/
/**********************                           ****************************/
/*****************************************************************************/
/*****************************************************************************/





 /**********************************************************/
 /*                                                        */
 /* The following productions handle constant expressions. */
 /* Constant expressions are computable at assembly time.  */
 /*                                                        */
 /**********************************************************/

Constants:
		SetInConst
		doConstants
		{
			_here;
			inConst = 0;
		}
	;

SetInConst:
		{
			_here;
			inConst = 1;

			/*
			** "Prime" fastLookup for the first identifier we encounter:
			*/
			
			fastLookup = 1;
		}
	;

			/*
			** Allow zero or more constant definitions in the
			** constant declaration section.
			*/

doConstants:
		Empty
		{
			_here;
		}

	|	doConstants ConstDef
		{
			_here;
		}
	;



/*
** ConstDef
**
** These productions handle the individual forms of constant
** declarations that are possible.
**
** Productions:
**
**	ConstDef->	UndefinedID ':=' ConstOnlyExpr ';'
**
**			|	UndefinedID ':' TypeID ':=' ConstOnlyExpr ';'
**
**			|	UndefinedID ':' TypeID '[' DimList ']' ':=' ConstOnlyExpr ';'
**
*/

ConstDef:	

		/*
		** Allow empty declarations (just a semicolon) for
		** syntactical reasons.
		*/

		';'
		{
			_here;
		}
	;
	


 /*
 ** Handle the "ID:FORWARD(ID);" declaration to support
 ** macro redeclarations of a symbol.
 */

ConstDef: UndefinedForward { _here; };





			/*
			** Quick scalar constant declarations:
			**
			**	Syntax  <id> := <expression>;
			**
			** e.g., u:=1234;
			**		 x:=u;
			**
			** Generally used to create scalar constants,
			** However, if the expression on the right
			** hand side of the assignment operator is
			** an array identifier or an array constant,
			** then this operation creates an array constant.
			** Likewise, if the expression is a record constant,
			** then this operation creates a record constant.
			**
			**
			*/


ConstDef: 
		UndefinedID 
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<v.Type>3 != NULL );

			InsertSym
			( 
				$<idStr>1, 
				$<v.Type>3,
				$<v.pType>3, 
				cConstant, 
				$<v.Arity>3,
				$<v.Dimensions>3,
				$<v.NumElements>3, 
				YYS &$<v>3,
				_ifx
				( 
					$<v.pType>3 == tArray,
					$<v.Type>3->ObjectSize * $<v.NumElements>3,
					$<v.Type>3->ObjectSize
				),
				0,
				NULL,
				$<v.Base>3,
				$<v.Fields>3,
				$<v.FieldCnt>3 
			);

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;

		}
	;



			/*
			** Full scalar const declarations:
			** e.g., i:integer := -2;
			**
			*/


ConstDef: 
		UndefinedID	/* $1 */
		Colon 			/* $2 */
		TypeID 			/* $3 */
		assignTkn 		/* $4 */
		ConstOnlyExpr 	/* $5 */
		Semicolon 		/* $6 */
		{
			_here;
			assert( $<s>3 != NULL );
			
			/*
			** Check to see if the TypeID and the ConstOnlyExpr (which
			** is an ID) are both arrays and if they are compatible.
			*/
				 
			_if( $<s>3->pType == tArray && $<v.pType>5 == tArray )

				_if
				( 
					ArraysAreCompatible
					( 
						YYS $<s>3, 
						YYS &$<v>5 
					)
				)

					InsertSym
					( 
						$<idStr>1, 
						GetBaseType( $<s>3 ),
						tArray, 
						cConstant, 
						$<s>3->Arity,
						$<s>3->Dimensions,
						$<s>3->NumElements, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_else

					yyerror
					( 
						"Type mismatch of operands or "
						"value out of range in declaration" 
					);
					FreeValue( YYS &$<v>5 );


				_endif


			/*
			** If it's not an array, check to see if it is
			** a record.
			*/

			_elseif( $<s>3->pType == tRecord && $<v.pType>5 == tRecord )

				_if
				( 
					RecordsAreCompatible
					( 
						$<s>3, 
						YYS &$<v>5 
					)
				)

					InsertSym
					( 
						$<idStr>1, 
						GetBaseType( $<s>3 ),
						tRecord, 
						cConstant, 
						$<s>3->Arity,
						$<s>3->Dimensions,
						$<s>3->NumElements, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_else

					yyerror
					( 
						"Type mismatch of operands. Expected "
						"compatible record types" 
					);
					FreeValue( YYS &$<v>5 );

				_endif


			/*
			** If it's not an array or record, check to see if it
			** is a primitive type (error if it's not).
			*/

			_elseif( IsNotPrimType( $<s>3->pType ))

				yyerror( "Constants can only have primitive types" );
				FreeValue( YYS &$<v>5 );

			/*
			** Okay, we've got a primitive (scalar) type.  See if the
			** constant is compatible with the TypeID.  If so, enter
			** the symbol into the symbol table.
			*/

			_elseif( IsCompatible( $<s>3, YYS &$<v>5 ))

				InsertSym
				( 
					$<idStr>1, 
					GetBaseType( $<s>3 ),
					$<s>3->pType, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &$<v>5,
					$<s>3->ObjectSize,
					0,
					NULL,
					NULL,
					NULL,
					0
				);

			_else

				yyerror
				( 
					"Type mismatch of operands or "
					"value out of range in declaration" 
				);
				FreeValue( YYS &$<v>5 );

			_endif

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;
		}
	;



	/*
	** Array const definitions:
	**
	** e.g., b:integer[4] := ConstOnlyExpr;
	**
	*/

					
ConstDef: 
		UndefinedID	/* $1 */
		Colon		/* $2 */
		TypeID 		/* $3 */
		'[' 		/* $4 */
		DimList 	/* $5 */
		Rbrack 		/* $6 */
		{			/* $7 */
		
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			/*
			** Set up some common synthesized attribute return values.
			*/

			$<v.pType>$ = tArray;
			$<v.Arity>$ = $<s>3->Arity + $<v.Arity>5;
			$<v.Base>$ = $<s>3->Base;
			$<v.Fields>$ = $<s>3->Fields;
			$<v.FieldCnt>$ = $<s>3->FieldCnt;
			$<v.Type>$ =GetBaseType( $<s>3 );

			/*
			** Scream if the user is trying to define a text array.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;

			_endif

			/*
			** If it's not a primitive scalar type, complain about
			** that and then fake a usable type.
			*/

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Constants can only have primitive types" );
				$<s>3 = &uns32_ste;

			_endif

			/*
			** If the TypeID isn't an array object, this is easy;
			** Just return the size of the array constant list.
			*/

			_if( $<s>3->pType != tArray )
			
				$<v.NumElements>$ = $<v.NumElements>5;
				$<v.Dimensions>$ = $<v.Dimensions>5;

			/*
			** On the other hand, if TypeID is an array object,
			** then we've got to add a new list of dimensions onto
			** the end of the TypeID list.
			*/

			_else

				/*
				** Compute the number of dimensions and elements in
				** the new type.
				*/

				$<v.NumElements>$ = 
						$<s>3->NumElements * $<v.NumElements>5;

				$<v.Dimensions>$ =
					malloc2( $<v.Arity>$ * sizeof( int ));


				/*
				** Copy TypeID's dimensions to our Dimensions array.
				*/
				
				assert( $<s>3->Dimensions != NULL );
				memcpy
				( 
					$<v.Dimensions>$, 
					$<s>3->Dimensions,
					$<s>3->Arity * sizeof( int )
				);

				/*
				** Concatenate the explict dimensions list to the end
				** of our Dimensions array.
				*/
				 
				assert( $<v.Dimensions>5 != NULL );
				memcpy
				(
					$<v.Dimensions>$ +	$<s>3->Arity,
					$<v.Dimensions>5,
					$<v.Arity>5 * sizeof( int )
				);

				/*
				** We're done with the explict list, so free it.
				*/

				free2( vss $<v.Dimensions>5 );

			_endif
			$<v.u.ArrayOfValues>$ = NULL;
			_here;
		}
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			_if( $<v.pType>9 == tArray )

				/*
				** Check to see if the list of array values specified
				** by the user is type and count compatible with the
				** array type specified by the TypeID and the explicit
				** dimensions list.	If so, insert the constant into
				** the symbol table.
				*/

				_if
				( 
					ArraysAreCompatible
					( 
						YYS &$<v>7, 
						YYS &$<v>9 
					)
				)

					InsertSym
					( 
						$<idStr>1, 
						$<v.Type>7,
						tArray, 
						cConstant, 
						$<v.Arity>7,
						$<v.Dimensions>7,
						$<v.NumElements>7,
						YYS &$<v>9,
						$<s>3->ObjectSize * $<v.NumElements>5,
						0,
						NULL,
						$<v.Base>7,
						$<v.Fields>7,
						$<v.FieldCnt>7
					);


				_else

					/*
					** At this point either the types of the elements do
					** not agree or the number of elements do not agree.
					** Figure out which and print the appropriate error 
					** msg.
					*/

					_if
					( 
							$<v.NumElements>7 == $<v.NumElements>9
						||	$<s>3->pType == tText 
					)

						yyerror( "Type mismatch in operands" );

					_else
					
						char msg[80];
						
						sprintf
						(
							msg,
							"The number of array elements do not match "
							"(expects %d, has %d)",
							$<v.NumElements>7,
							$<v.NumElements>9
						);
						yyerror( msg );
						
					_endif
					_if( $<v.pType>9 == tArray )
					
						FreeValue( YYS &$<v>9 );

					_endif
					free2( vss $<v.Dimensions>7 );

				_endif

			_else

				yyerror( "Expected array expression" );
				_if( $<v.pType>9 == tArray )
				
					FreeValue( YYS &$<v>9 );

				_endif
				free2( vss $<v.Dimensions>7 );

			_endif

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;		
		}
	;
												





	/*
	** Open array const definitions:
	**
	** e.g., b:integer[] := ConstOnlyExpr;
	**
	*/

					
ConstDef: 
		UndefinedID	/* $1 */
		Colon		/* $2 */
		TypeID 		/* $3 */
		'[' 		/* $4 */
		Rbrack 		/* $5 */
		{			/* $6 */
		
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );
			/*
			** Scream if the user is trying to define a text array.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;

			_endif

			/*
			** If it's not a primitive scalar type, complain about
			** that and then fake a usable type.
			*/

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Constants can only have primitive types" );
				$<s>3 = &uns32_ste;

			_endif
			_here;
		}
		assignTkn		/* $7  */ 
		ConstOnlyExpr 	/* $8  */
		Semicolon		/* $9  */
		{				/* $10 */

			int		i;
			char	IsValid;

			_here;
			_if( $<v.pType>8 != tArray )
			
				yyerror( "Expected array expression" );
				FreeValue( YYS &$<v>8 );
			
			_else				
			
				/*
				** There are two cases we need to consider here:
				**
				**	1.	The base type of the constant is a scalar
				**		type.  For this case, we simply give the
				**		constant type the same number of elements
				**		as the array constant.
				**
				**	2.	The base type of the constant is an array type.
				**		In this case we have to make sure that the
				**		number of elements in the array constant is
				**		an even multiple of the number of elements in
				**		the array type.
				*/
				
				_if( $<s>3->pType != tArray )
				
					/*
					** Okay, we've got the simple case where we
					** just copy the data from the expression into
					** the new constant object. But first, let's make sure 
					** that the elements of this array are compatible with
					** the base type of the array constant object:
					*/
					
					
					IsValid = 1;
					i = 0;
					_do
					
						/*
						** Verify that each element of the array expression
						** is compatible with our destination type:
						*/
						
						IsValid = 
								IsValid 
							&&	IsCompatible
								(
									GetBaseType( $<s>3 ),
									YYS &$<v.u.ArrayOfValues>8[i] 
								);
								
						++i;
						
					_until( i >= $<v.NumElements>8 || !IsValid )

					_if( IsValid )
					
						InsertSym
						( 
							$<idStr>1, 
							GetBaseType( $<s>3 ),
							tArray, 
							cConstant, 
							1,							/* Arity		*/
							malloc2( sizeof( int )),	/* Dimensions	*/
							$<v.NumElements>8,			/* NumElements	*/
							NULL,						/* Value		*/
							0,							/* ObjectSize	*/
							0,							/* Offset		*/
							NULL,						/* Static Name	*/
							$<v.Base>8,					/* Base Type	*/
							$<v.Fields>8,				/* Field list	*/
							$<v.FieldCnt>8				/* Num Fields	*/
						);
						
						/*
						** Allocate storage to hold the data:
						*/
						
						SymbolTable->u.ArrayOfValues = 
							malloc2
							( 
								$<v.NumElements>8 * sizeof( struct SymNode )
							);
							
						/*
						** Copy the data from the array constant expression
						** to the array object we've just created:
						*/
						
						_for( i=0, i < $<v.NumElements>8, ++i )
						
							DeepCopy
							( 
								&SymbolTable->u.ArrayOfValues[i], 
								&$<v.u.ArrayOfValues>8[i]
							);
							
						_endfor
						
						/*
						** Set up the size information for this constant array:
						*/
						
						SymbolTable->Dimensions[0] = $<v.NumElements>8;
						SymbolTable->ObjectSize = 
							$<s>3->ObjectSize * $<v.NumElements>8;
							
						
						
					_else
					
						yyerror( "Type mismatch in operands" );
					
					_endif


				_else
				
					/*
					** Okay, the base type of the constant object is
					** an array type.  This means that the number
					** of elements in the constant expression must
					** be an even multiple of the number of elements
					** in the base type.
					*/
					
					_if
					(
							$<s>3->NumElements >= $<v.NumElements>8
						||	( $<v.NumElements>8 % $<s>3->NumElements ) != 0
					)
					
						yyerror
						( 
							"Array constant has bad number of elements"
						);
						
					_else

						IsValid = 1;
						i = 0;
						_do
						
							/*
							** Verify that each element of the array expression
							** is compatible with our destination type:
							*/
							
							IsValid = 
									IsValid 
								&&	IsCompatible
									(
										GetBaseType( $<s>3 ),
										YYS &$<v.u.ArrayOfValues>8[i] 
									);
									
							++i;
							
						_until( i >= $<v.NumElements>8 || !IsValid )
						
						_if( IsValid )
						
							InsertSym
							( 
								$<idStr>1, 
								GetBaseType( $<s>3 ),
								tArray, 
								cConstant, 
								$<s>3->Arity + 1,			
								malloc2( sizeof( int ) * ($<s>3->Arity + 1)),
								$<v.NumElements>8,			
								NULL,						
								0,							
								0,							
								NULL,						
								$<v.Base>8,					
								$<v.Fields>8,				
								$<v.FieldCnt>8				
							);
							
							/*
							** Allocate storage to hold the data:
							*/
							
							SymbolTable->u.ArrayOfValues = 
								malloc2
								( 
									$<v.NumElements>8 * sizeof( struct SymNode )
								);
								
							/*
							** Copy the data from the array constant expression
							** to the array object we've just created:
							*/
							
							_for( i=0, i < $<v.NumElements>8, ++i )
							
								DeepCopy
								( 
									&SymbolTable->u.ArrayOfValues[i], 
									&$<v.u.ArrayOfValues>8[i]
								);
								
							_endfor
							
							/*
							** Set up the size information for this 
							** constant array:
							*/
							
							_for( i = 0, i < SymbolTable->Arity - 1, ++i )
							
								SymbolTable->Dimensions[i] = 
									$<s>3->Dimensions[i];
									
							_endfor
							SymbolTable->Dimensions[ SymbolTable->Arity - 1 ] =
								$<v.NumElements>8 / $<s>3->NumElements;
								
							SymbolTable->ObjectSize = 
								$<s>3->Type->ObjectSize * $<v.NumElements>8;
								
							
							
						_else
						
							yyerror( "Type mismatch in operands" );
						
						_endif

					
					_endif


				_endif

			_endif
			FreeValue( YYS &$<v>8 );

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;		
		}
	;
												





	/*
	** Various error productions.
	*/


	/*
	** Handle duplicate symbol errors here.
	*/

ConstDef: 
		AnyLocalID
		{
			char msg[ 256 ];

			sprintf
			( 
				msg,
				"Symbol <<%s>> is already defined", 
				$<s>1->TrueName 
			);
			yyerror( msg );
		}

		/*
		** Handle some bizzarre error cases that the parser
		** doesn't deal with too well.
		*/

	|	UndefID ';'
		{
			yyerror( "Syntax error, expected declaration" );
		}


	|	error ';' {_here; }

	;



















/*****************************************************************************/
/*****************************************************************************/
/**********************                           ****************************/
/**********************                           ****************************/
/**********************       V A L U E S         ****************************/
/**********************                           ****************************/
/**********************                           ****************************/
/*****************************************************************************/
/*****************************************************************************/










 /**********************************************************/
 /*                                                        */
 /* The following productions handle constant expressions. */
 /* Constant expressions are computable at assembly time.  */
 /*                                                        */
 /**********************************************************/

Values:
		SetInValue
		doValues
		{
			_here;
			inVal = 0;
			fastLookup = 0; /* force lookup */
			
		}
	;


SetInValue:
		{
			_here;
			inVal = 1;
		}
	;


doValues:	Empty	{ _here; }

		|	doValues ValueDef { _here; } 
		;


/*
** ValueDef
**
** These productions handle the individual forms of value
** declarations that are possible.
**
** Productions:
**
**	ValueDef->	UndefinedID ':=' ConstOnlyExpr ';'
**
**			|	UndefinedID ':' TypeID ':=' ConstOnlyExpr ';'
**
**			|	UndefinedID ':' TypeID ';'
**
**			|	UndefinedID ':' TypeID '[' DimList ']' ':=' ConstOnlyExpr ';'
**
**			|	UndefinedID ':' TypeID '[' DimList ']' ';' 
**
**			|	UndefinedID ':' TypeID '[' ']' ':=' ConstOnlyExpr ';'
**
**
**			|	LocalID ':=' ConstOnlyExpr ';'
**
**			|	LocalID ':' TypeID ':=' ConstOnlyExpr ';'
**
**			|	LocalID ':' TypeID ';'
**
**			|	LocalID ':' TypeID '[' DimList ']' := ConstOnlyExpr ';'
**
**			|	LocalID ':' TypeID '[' DimList ']' ';'
**
**			|	LocalID ':' TypeID '[' ']' ':=' ConstOnlyExpr ';'
**
**			|	ArrayRef := ConstOnlyExpr;
**
**			|	RecordRef := ConstOnlyExpr;
**
**			|	UndefinedID := regexConst;
**			|	UndefinedID :regex := regexConst;
**			|	LocalID := regexConst;
**			|	LocalID :regex := regexConst; 
**
**	plus some error productions.
**
**	These productions are nearly identical to those for ConstDef
**	(although there are twice as many since there are productions for
**	LocalIDs as well as UndefinedIDs).  Therefore, you might want to
**	take a look at the comments for ConstDef for additional insight into
**	this code.
**
*/

ValueDef:	

			/*
			** Allow empty declarations (just a semicolon) for
			** syntactical reasons (e.g., to put semicolons after
			** macros and such).
			*/


			';' { _here; }
		;
	
 /*
 ** Handle the "ID:FORWARD(ID);" declaration to support
 ** macro redeclarations of a symbol.
 */

ValueDef:  UndefinedForward { _here; };

			/*
			** Built-in VAL objects
			*/

ValueDef:		startParmOfsTkn assignTkn ConstOnlyExpr Semicolon
			{
				_here;
				_if( !checkSmallInt( YYS &$<v>3 ) )

					yyerror( "Parameter offset value must be a small integer" );

				_else


					StartParmOffs = $<v.u.intval>3;

				_endif
				_here;
					
			}
		;



ValueDef:
		startLclOfsTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( !checkSmallInt( YYS &$<v>3 ) )

				yyerror( "Locals offset value must be a small integer" );

			_else

				StartLclOffs = $<v.u.intval>3;

			_endif
			_here;
				
		}
	;



ValueDef:
			enumSizeTkn assignTkn ConstOnlyExpr Semicolon
			{
				_here;
				_if( !checkSmallUns( YYS &$<v>3 ) )

					yyerror( "Enum size must be a small non-negative integer" );

				_else

					EnumSize = $<v.u.intval>3;

				_endif
				_here;
					
			}
		;



ValueDef:
		atlabelTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( !checkSmallUns( YYS &$<v>3 ) || $<v.u.intval>3 < 1 )

				yyerror( "@label must be assigned an integer > 1" );

			_else

				LblCntr = $<v.u.intval>3;

			_endif
			_here;
		}
	;

		 
		 

		 
ValueDef:
		boundvarTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@bound expects a boolean expression" );

			_else

				CompileBound = $<v.u.boolval>3;
				
			_endif
		}
	;




ValueDef:
		baseregTkn assignTkn ebpTkn Semicolon
		{
			_here;
			CurBaseReg = "ebp";
		}
	;



ValueDef:
		baseregTkn assignTkn espTkn Semicolon
		{
			_here;
			CurBaseReg = "esp";
		}
	;

		 
ValueDef:
		baseregTkn assignTkn error Semicolon
		{
			yyerror( "'@basereg := reg' only allows ESP or EBP" );
		}
	;

		 
ValueDef:
		intovarTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@into expects a boolean expression" );

			_else

				CompileInto = $<v.u.boolval>3;

			_endif

				
		}
	;

		 
ValueDef:
		traceTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@trace expects a boolean expression" );

			_else

				TraceFlag = $<v.u.boolval>3;

			_endif

				
		}
	;

		 
ValueDef:
		exceptsTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@exceptions expects a boolean expression" );

			_else

				FullExceptions = $<v.u.boolval>3;

			_endif

				
		}
	;

		 
		 
ValueDef:
		displayTkn 
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@display expects a boolean expression" );

			_else

				DisplayDefault = $<v.u.boolval>3;

			_endif

				
		}
	;

		 
		 
ValueDef:
		nodisplayTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@nodisplay expects a boolean expression" );

			_else

				DisplayDefault = !$<v.u.boolval>3;

			_endif
				
		}
	;

		 
		 
ValueDef:
		frameTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@frame expects a boolean expression" );

			_else

				FrameDefault = $<v.u.boolval>3;
				_if( langLevel <= low_level && $<v.u.boolval>3 )
				
					yyerror
					( 
						"@frame can only be assigned false except in \n"
						"high-level and medium-level language modes."
					);
					
				_endif


			_endif

				
		}
	;

		 
		 
ValueDef:
		noframeTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@nodisplay expects a boolean expression" );

			_else

				FrameDefault = !$<v.u.boolval>3;
				_if( langLevel <= low_level && !$<v.u.boolval>3 )
				
					yyerror
					( 
						"@noframe can only be assigned true except in \n"
						"high-level and medium-level language modes."
					);
					
				_endif
				

			_endif

				
		}
	;

		 
		 
ValueDef:
		alignstkTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@alignstack expects a boolean expression" );

			_else

				AlignStackDefault = $<v.u.boolval>3;
				_if( langLevel <= low_level && $<v.u.boolval>3 )
				
					yyerror
					( 
						"@alignstack can only be assigned false except in \n"
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}
	;

		 
		 
ValueDef:
		noalignstkTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@noalignstack expects a boolean expression" );

			_else

				AlignStackDefault = !$<v.u.boolval>3;
				_if( langLevel <= low_level && !$<v.u.boolval>3 )
				
					yyerror
					( 
						"@noalignstack can only be assigned false except in \n"
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}
	;

		 
		 
ValueDef:
		useenterTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@enter expects a boolean expression" );

			_else

				EnterDefault = $<v.u.boolval>3;
				_if( langLevel <= low_level )
				
					yyerror
					( 
						"@enter is illegal except in "
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}
	;

		 
		 
ValueDef:
		noenterTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@noenter expects a boolean expression" );

			_else

				EnterDefault = !$<v.u.boolval>3;
				_if( langLevel <= low_level )
				
					yyerror
					( 
						"@noenter is illegal except in "
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}
	;

		 
		 
ValueDef:
		useleaveTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@leave expects a boolean expression" );

			_else

				LeaveDefault = $<v.u.boolval>3;
				_if( langLevel <= low_level )
				
					yyerror
					( 
						"@leave is illegal except in "
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}
	;

		 
		 
ValueDef:
		noleaveTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@noalignstack expects a boolean expression" );

			_else

				LeaveDefault = !$<v.u.boolval>3;
				_if( langLevel <= low_level )
				
					yyerror
					( 
						"@noleave is illegal except in "
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}
	;
		


ValueDef:
			alignprocTkn assignTkn ConstOnlyExpr Semicolon
			{
				_here;
				_if( !checkSmallUns( YYS &$<v>3 ) )

					yyerror
					( 
						"@align value must be a small non-negative integer" 
					);

				_else

					int bits;
					int value;
					
					bits = 0;
					value = $<v.u.intval>3;
					_while( value != 0 )
					
						bits = bits + (value & 1);
						value = value >> 1;
						
					_endwhile;
					_if( bits != 1 )
					
						yyerror
						( 
							"@align requires an operand that is a power of two" 
						);
						
					_else
					
						AlignDefault = $<v.u.intval>3;
						
					_endif;

				_endif
				_here;
			}
		;

		 

		

		 
		// Deal with the @optstrings pseudo-variable here.

ValueDef:
		optstringsTkn	/* $1 */
		assignTkn		/* $2 */
		ConstOnlyExpr	/* $3 */
		Semicolon		/* $4 */
		{				/* $5 */
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@optstrings expects a boolean expression" );

			_else

				OptimizeStrings = $<v.u.boolval>3;

			_endif

				
		}
	;

		 
		/*
		** The following production lets the user treat the
		** @offset(name) function as a pseudo-variable allowing
		** the user to change the offset field of a VAR object.
		*/
		
ValueDef:
		symOffsetTkn	/* $1 */ 
		Lparen 			/* $2 */
		Empty			/* $3 */
		Classify		/* $4 */
		Rparen			/* $5 */
		assignTkn		/* $6 */
		ConstOnlyExpr	/* $7 */
		Semicolon		/* $8 */
		{
			_here;
			_if(( $<cls.cls>4 & cfy_SingleID ) == 0 )

				yyerror( "@offset requires a single ID parameter" );

			_elseif(( $<cls.cls>4 & cfy_Undefined) || $<cls.sym>4 == NULL )

				yyerror( "@offset requires a defined identifier" );

			_else

				_if( checkSmallInt( YYS &$<v>7 ))

					$<cls.sym>4->Offset = $<v.u.intval>7;
					
				_else
				
					yyerror( "Expected a 32-bit numeric offset value" );
					
				_endif
				
			_endif
			FreeValue( YYS &$<v>7 );
			_here;
		}
	;
		
	


			/*
			** Quick scalar value declarations:
			**
			**	Syntax  <id> := <expression>;
			**
			** e.g., u:=1234;
			**		 x:=u;
			**
			** Generally used to create scalar constants,
			** However, if the expression on the right
			** hand side of the assignment operator is
			** an array identifier, then this
			** operation creates an array constant.
			*/


ValueDef: 
		UndefinedID	/* $1 */
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<v.Type>3 != NULL );

			InsertSym
			( 
				$<idStr>1, 
				$<v.Type>3,
				$<v.pType>3, 
				cValue, 
				$<v.Arity>3,
				$<v.Dimensions>3,	/* ConstOnlyExpr mallocs this if array */
				$<v.NumElements>3, 
				YYS &$<v>3,
				_ifx
				( 
					$<v.pType>3 == tArray,
					$<v.Type>3->ObjectSize * $<v.NumElements>3,
					$<v.Type>3->ObjectSize
				),
				0,
				NULL,
				$<v.Base>3,
				$<v.Fields>3,
				$<v.FieldCnt>3 
			);
			
			// Must handle the union field manually:
			
			SymbolTable->CurField = $<v.CurField>3;
			SymbolTable->CurIndex = $<v.CurIndex>3;
			_here;

		}
	;


// Handle the special case of a regular expression constant:

ValueDef: 
		UndefinedID	/* $1 */
		assignTkn	/* $2 */ 
		regexconst	/* $3 */
		Semicolon	/* $4 */
		{
			_here;
			assert( $<idStr>1 != NULL );

			InsertSym
			( 
				$<idStr>1, 
				&regex_ste,
				tRegex, 
				cValue, 
				0,
				NULL,
				0, 
				YYS &$<v>3,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0 
			);
			_here;

		}
	;




			
	/*
	** Quick scalar value redeclarations:
	** e.g., u:=1234; (assuming u is already defined.)
	**
	**
	** Note, if the object on the right side of the assignment
	** statement is an array object, ConstOnlyExpr mallocs all the
	** array data.
	*/


ValueDef:
		AnyLocalID 
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			assert( $<s>1 != NULL );

			SetSym
			( 
				$<s>1, 
				$<v.Type>3,
				$<v.pType>3, 
				$<v.Arity>3,
				$<v.Dimensions>3,	/* ConstOnlyExpr mallocs this if array */
				$<v.NumElements>3, 
				YYS &$<v>3,
				_ifx
				( 
					$<v.pType>3 == tArray,
					$<v.Type>3->ObjectSize * $<v.NumElements>3,
					$<v.Type>3->ObjectSize
				),
				0,
				NULL,
				$<v.Base>3,
				$<v.Fields>3,
				$<v.FieldCnt>3,
				$<v.CurField>3,
				$<v.CurIndex>3 
			);
			_here;
		}
	;


// Special case for regular expressions			
			
ValueDef:
		AnyLocalID 
		assignTkn 
		regexconst 
		Semicolon
		{
			_here;
			assert( $<s>1 != NULL );

			SetSym
			( 
				$<s>1, 
				&regex_ste,
				tRegex, 
				0,
				NULL,
				0, 
				YYS &$<v>3,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0,
				NULL,
				0 
			);
			_here;
		}
	;

			
			
	/*
	** Partial scalar value declarations:
	** e.g., i:integer;
	**
	**	Note:	These values are initialized with zero or an
	**			empty string.
	**
	*/


ValueDef: 
		UndefinedID	/* $1 */
		Colon 
		TypeID 
		Semicolon
		{
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );

			_elseif( $<s>3->pType != tArray )

				ClrNewSym
				( 
					$<idStr>1, 
					$<s>3,
					$<s>3->pType, 
					cValue, 
					0,
					NULL,
					0, 
					$<s>3->ObjectSize,
					0,
					NULL,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt,
					$<s>3->CurField,
					$<s>3->CurIndex 
				);

			_else /* We have an array */


				ClrNewSym
				( 
					$<idStr>1, 
					$<s>3->Type,
					tArray, 
					cValue, 
					$<s>3->Arity,
					DupDims( $<s>3 ),
					$<s>3->NumElements, 
					$<s>3->ObjectSize,
					0,
					NULL,
					$<s>3->Base, 
					$<s>3->Fields,
					$<s>3->FieldCnt,
					$<s>3->CurField,
					$<s>3->CurIndex
				);

			_endif


		}
	;






	/*
	** Partial scalar const redeclarations:
	** e.g., i:integer;  (assuming i is already defined.)
	**
	**	This production lets the programmer change the type
	**	of a value without assigning a value to it.  Of course,
	**	the code will initialize the value with zero or an
	**	empty string. 
	**
	*/


ValueDef:	
		AnyLocalID 
		Colon 
		TypeID 
		Semicolon
		{
			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );

			_elseif( $<s>3->pType != tArray )

				ClrSym
				( 
					$<s>1, 
					$<s>3,
					$<s>3->pType, 
					0,
					NULL,
					0, 
					$<s>3->ObjectSize,
					0,
					NULL,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt,
					$<s>3->CurField,
					$<s>3->CurIndex 
				);

			_else /* We have an array */


				ClrSym
				( 
					$<s>1, 
					$<s>3->Type,
					tArray, 
					$<s>3->Arity,
					DupDims( $<s>3 ),
					$<s>3->NumElements, 
					$<s>3->ObjectSize,
					0,
					NULL,
					$<s>3->Base, 
					$<s>3->Fields,
					$<s>3->FieldCnt,
					$<s>3->CurField,
					$<s>3->CurIndex
				);

			_endif


		}
	;



	/*
	** Full scalar value declarations:
	** e.g., i:integer := -2;
	**
	*/


ValueDef: 
		UndefinedID		/* $1 */
		Colon 			/* $2 */
		TypeID 			/* $3 */
		assignTkn 		/* $4 */
		ConstOnlyExpr 	/* $5 */
		Semicolon		/* $6 */
		{
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			/*
			** If the TypeID is an array, the ConstOnlyExpr must also
			** be an array (ID).  That being the case, make sure
			** they are compatible with one another.
			*/
				 
			_if( $<s>3->pType == tArray && $<v.pType>5 == tArray )

				_if
				( 
					ArraysAreCompatible
					( 
						YYS $<s>3, 
						YYS &$<v>5 
					)
				)

					InsertSym
					( 
						$<idStr>1,
						GetBaseType( $<s>3 ), 
						tArray, 
						cValue, 
						$<s>3->Arity,
						DupDims( $<s>3 ),
						$<s>3->NumElements, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_else

					yyerror
					( 
						"Type mismatch of array operands or "
						"element value out of range" 
					);
					FreeValue( YYS &$<v>5 );


				_endif

			/*
			** If it's not an array, check to see if it is
			** a record.
			*/

			_elseif( $<s>3->pType == tRecord && $<v.pType>5 == tRecord )

				_if
				( 
					RecordsAreCompatible
					( 
						$<s>3, 
						YYS &$<v>5 
					)
				)

					InsertSym
					( 
						$<idStr>1, 
						GetBaseType( $<s>3 ),
						tRecord, 
						cValue, 
						$<s>3->Arity,
						$<s>3->Dimensions,
						$<s>3->NumElements, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_else

					yyerror
					( 
						"Type mismatch of operands. Expected "
						"compatible record types" 
					);

					FreeValue( YYS &$<v>5 );

				_endif


			/*
			** If it's not an array or record, check to see if it is
			** a union.
			*/

			_elseif
			( 
					$<s>3->pType == tUnion 
				&&	$<v.pType>5 == tUnion
				&&	GetBaseType( $<s>3 ) == GetBaseType( $<v.Type>5 )
			)

				InsertSym
				( 
					$<idStr>1, 
					GetBaseType( $<s>3 ),
					tUnion, 
					cValue, 
					0,					// Arity
					NULL,				// Dimensions
					0,					// NumElements
					YYS &$<v>5,			// FieldValues points at data.
					$<s>3->ObjectSize,
					$<v.Offset>5,		// Offset holds field #
					NULL,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt
				);
				
				// Must manually set up the two fields associated with
				// union constants:
				
				SymbolTable->CurField = $<v.CurField>5;
				SymbolTable->CurIndex = $<v.CurIndex>5;


			/*
			** If TypeID is not an array, make sure that it's a
			** primitive type.
			*/

			_elseif( IsNotPrimType( $<s>3->pType ))

				yyerror( "Constants can only have primitive types" );
				FreeValue( YYS &$<v>5 );

			/*
			** If TypeID is a primitive type, then check to see if
			** it is type compatible with the ConstOnlyExpr value.
			** Insert the object into the symbol table if they
			** are compatible.
			*/

			_elseif( IsCompatible( $<s>3, YYS &$<v>5 ))

				InsertSym
				( 
					$<idStr>1,
					GetBaseType( $<s>3 ), 
					$<s>3->pType, 
					cValue, 
					0,
					NULL,
					0, 
					YYS &$<v>5,
					$<s>3->ObjectSize,
					0,
					NULL,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt
				);

			_else

				yyerror
				( 
					"Type mismatch of operands or "
					"value out of range in declaration" 
				);
				FreeValue( YYS &$<v>5 );

			_endif

		}
	;



// Special case for regular expressions

ValueDef: 
		UndefinedID		/* $1 */
		Colon 			/* $2 */
		TypeID 			/* $3 */
		assignTkn 		/* $4 */
		regexconst	 	/* $5 */
		Semicolon		/* $6 */
		{
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			_if( $<s>3->pType != tRegex )
			
				yyerror( "Type mismatch, expected REGEX object" );
				
			_else
			
				InsertSym
				( 
					$<idStr>1, 
					&regex_ste,
					tRegex, 
					cValue, 
					0,
					NULL,
					0, 
					YYS &$<v>5,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0 
				);
			
			_endif
		}
	;




	/*
	** Full scalar value redeclarations:
	** e.g., i:integer := -2; (Assumes i already exists.)
	**
	*/

ValueDef:
		AnyLocalID		/* $1 */ 
		Colon 			/* $2 */
		TypeID 			/* $3 */
		assignTkn 		/* $4 */
		ConstOnlyExpr 	/* $5 */
		Semicolon		/* $6 */
		{
			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );
			
			/*
			** Check to see if TypeID is an array type and if
			** ConstOnlyExpr is also an array value (array ID).
			*/
				 
			_if( $<s>3->pType == tArray && $<v.pType>5 == tArray )

				/*
				** If they are compatible arrays, then assign
				** ConstOnlyExpr's value to the Local ID, else
				** print an appropriate error message.
				*/

				_if
				( 
					ArraysAreCompatible
					( 
						YYS $<s>3, 
						YYS &$<v>5 
					)
				)

					SetSym
					( 
						$<s>1,
						GetBaseType( $<s>3 ), 
						tArray, 
						$<s>3->Arity,
						DupDims( $<s>3 ),
						$<s>3->NumElements, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt,
						$<s>3->CurField,
						$<s>3->CurIndex
					);
					
				_else

					yyerror
					( 
						"Type mismatch of operands or "
						"value out of range in declaration" 
					);
					FreeValue( YYS &$<v>5 );


				_endif

			/*
			** If it's not an array, check to see if it is
			** a record.
			*/

			_elseif( $<s>3->pType == tRecord && $<v.pType>5 == tRecord )

				_if
				( 
					RecordsAreCompatible
					( 
						$<s>3, 
						YYS &$<v>5 
					)
				)

					SetSym
					( 
						$<s>1, 
						GetBaseType( $<s>3 ),
						tRecord, 
						$<s>3->Arity,
						$<s>3->Dimensions,
						$<s>3->NumElements, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt,
						$<s>3->CurField,
						$<s>3->CurIndex
					);

				_else

					yyerror
					( 
						"Type mismatch of operands. Expected "
						"compatible record types" 
					);
					FreeValue( YYS &$<v>5 );

				_endif




			/*
			** If it's not an array or record, check to see if it is
			** a union.
			*/

			_elseif
			( 
					$<s>3->pType == tUnion 
				&&	$<v.pType>5 == tUnion
				&&	GetBaseType( $<s>3 ) == GetBaseType( $<v.Type>5 )
			)

				SetSym
				( 
					$<s>1, 
					GetBaseType( $<s>3 ),
					tUnion, 
					0,					// Arity
					NULL,				// Dimensions
					0,					// NumElements
					YYS &$<v>5,			// Value
					$<s>3->ObjectSize,
					0,					// Offset
					NULL,
					$<v.Base>5,
					$<v.Fields>5,
					$<v.FieldCnt>5,
					$<v.CurField>5,
					$<v.CurIndex>5
				);




			/*
			** If TypeID and/or ConstOnlyExpr are not arrays, see if
			** they are primitive types.
			*/

			_elseif( IsNotPrimType( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				FreeValue( YYS &$<v>5 );

			/*
			** If they are primitive types, see if they are type
			** compatible.  Set the value of the LocalID if they
			** are compatible.
			*/

			_elseif( IsCompatible( $<s>3, YYS &$<v>5 ))

				SetSym
				( 
					$<s>1,
					GetBaseType( $<s>3 ), 
					$<s>3->pType, 
					0,
					NULL,
					0, 
					YYS &$<v>5,
					$<s>3->ObjectSize,
					0,
					NULL,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt,
					$<s>3->CurField,
					$<s>3->CurIndex
				);

			_else

				yyerror
				( 
					"Type mismatch of operands or "
					"value out of range in declaration" 
				);
				FreeValue( YYS &$<v>5 );

			_endif

		}
	;



// Special case for regular expressions.

ValueDef:
		AnyLocalID		/* $1 */ 
		Colon 			/* $2 */
		TypeID 			/* $3 */
		assignTkn 		/* $4 */
		regexconst	 	/* $5 */
		Semicolon		/* $6 */
		{
			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );
			
			_if( $<s>3->pType != tRegex )
			
				yyerror( "Type mismatch, expected REGEX object" );
				
			_else
			
				SetSym
				( 
					$<s>1, 
					&regex_ste,
					tRegex, 
					0,
					NULL,
					0, 
					YYS &$<v>5,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0,
					NULL,
					0 
				);
			
			_endif
		}
	;




	/*
	** Array value defintions:
	** e.g., b:integer[4] := [1,2,3,4];
	**
	*/

ValueDef: 
		UndefinedID	/* $1 */
		Colon			/* $2 */
		TypeID 			/* $3 */
		'[' 			/* $4 */
		DimList 		/* $5 */
		Rbrack 			/* $6 */
		{				/* $7 */
		
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			/*
			** Set up some common synthesized attribute return values.
			*/

			$<v.pType>$ = tArray;
			$<v.Arity>$ = $<s>3->Arity + $<v.Arity>5;
			$<v.Base>$ = $<s>3->Base;
			$<v.Fields>$ = $<s>3->Fields;
			$<v.FieldCnt>$ = $<s>3->FieldCnt;
			$<v.Type>$ =GetBaseType( $<s>3 );

			/*
			** Scream if the user is trying to define a text array.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;

			_endif

			/*
			** If it's not a primitive scalar type, complain about
			** that and then fake a usable type.
			*/

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				$<s>3 = &uns32_ste;

			_endif

			/*
			** If the TypeID isn't an array object, this is easy;
			** Just return the size of the array constant list.
			*/

			_if( $<s>3->pType != tArray )
			
				$<v.NumElements>$ = $<v.NumElements>5;
				$<v.Dimensions>$ = $<v.Dimensions>5;

			/*
			** On the other hand, if TypeID is an array object,
			** then we've got to add a new list of dimensions onto
			** the end of the TypeID list.
			*/

			_else

				/*
				** Compute the number of dimensions and elements in
				** the new type.
				*/

				$<v.NumElements>$ = 
						$<s>3->NumElements * $<v.NumElements>5;

				$<v.Dimensions>$ =
					malloc2( $<v.Arity>$ * sizeof( int ));


				/*
				** Copy TypeID's dimensions to our Dimensions array.
				*/
				
				assert( $<s>3->Dimensions != NULL );
				memcpy
				( 
					$<v.Dimensions>$, 
					$<s>3->Dimensions,
					$<s>3->Arity * sizeof( int )
				);

				/*
				** Concatenate the explict dimensions list to the end
				** of our Dimensions array.
				*/
				 
				assert( $<v.Dimensions>5 != NULL );
				memcpy
				(
					$<v.Dimensions>$ +	$<s>3->Arity,
					$<v.Dimensions>5,
					$<v.Arity>5 * sizeof( int )
				);

				/*
				** We're done with the explict list, so free it.
				*/

				free2( vss $<v.Dimensions>5 );

			_endif
			$<v.u.ArrayOfValues>$ = NULL;
		}
		assignTkn		/* $8  */ 
		ConstOnlyExpr 	/* $9  */
		Semicolon		/* $10 */
		{
			_here;
			_if( $<v.pType>9 == tArray )

				/*
				** Check to see if the list of array values specified
				** by the user is type and count compatible with the
				** array type specified by the TypeID and the explicit
				** dimensions list.	If so, insert the constant into
				** the symbol table.
				*/

				_if
				( 
					ArraysAreCompatible
					( 
						YYS &$<v>7, 
						YYS &$<v>9 
					)
				)

					InsertSym
					( 
						$<idStr>1, 
						$<v.Type>7,
						tArray, 
						cValue, 
						$<v.Arity>7,
						$<v.Dimensions>7,
						$<v.NumElements>7,
						YYS &$<v>9,
						$<s>3->ObjectSize * $<v.NumElements>5,
						0,
						NULL,
						$<v.Base>7,
						$<v.Fields>7,
						$<v.FieldCnt>7
					);


				_else

					/*
					** At this point either the types of the elements do
					** not agree or the number of elements do not agree.
					** Figure out which and print the appropriate error 
					** msg.
					*/

					_if
					( 
							$<v.NumElements>7 == $<v.NumElements>9
						||	$<s>3->pType == tText 
					)

						yyerror( "Type mismatch in operands" );

					_else

						yyerror
						( 
							"The number of array elements do not match" 
						);

					_endif
					_if( $<v.pType>9 == tArray )
					
						FreeValue( YYS &$<v>9 );

					_endif
					free2( vss $<v.Dimensions>7 );

				_endif

			_else

				yyerror( "Expected array expression" );
				_if( $<v.pType>9 == tArray )
				
					FreeValue( YYS &$<v>9 );

				_endif
				free2( vss $<v.Dimensions>7 );

			_endif

		
		}
	;
	
	/*
	** Array value redefintions:
	** e.g., b:integer[4] := [1,2,3,4]; (assumes b already exists.)
	**
	**
	** Note: See the preceding production for comments on this code.
	*/

ValueDef:					
		AnyLocalID 
		Colon
		TypeID '[' DimList Rbrack 
		{
			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );

			/*
			** Set up some common synthesized attribute return values.
			*/

			$<v.pType>$ = tArray;
			$<v.Arity>$ = $<s>3->Arity + $<v.Arity>5;
			$<v.Base>$ = $<s>3->Base;
			$<v.Fields>$ = $<s>3->Fields;
			$<v.FieldCnt>$ = $<s>3->FieldCnt;
			$<v.Type>$ =GetBaseType( $<s>3 );

			/*
			** Scream if the user is trying to define a text array.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;

			_endif

			/*
			** If it's not a primitive scalar type, complain about
			** that and then fake a usable type.
			*/

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				$<s>3 = &uns32_ste;

			_endif

			/*
			** If the TypeID isn't an array object, this is easy;
			** Just return the size of the array constant list.
			*/

			_if( $<s>3->pType != tArray )
			
				$<v.NumElements>$ = $<v.NumElements>5;
				$<v.Dimensions>$ = $<v.Dimensions>5;

			/*
			** On the other hand, if TypeID is an array object,
			** then we've got to add a new list of dimensions onto
			** the end of the TypeID list.
			*/

			_else

				/*
				** Compute the number of dimensions and elements in
				** the new type.
				*/

				$<v.NumElements>$ = 
						$<s>3->NumElements * $<v.NumElements>5;

				$<v.Dimensions>$ =
					malloc2( $<v.Arity>$ * sizeof( int ));


				/*
				** Copy TypeID's dimensions to our Dimensions array.
				*/
				
				assert( $<s>3->Dimensions != NULL );
				memcpy
				( 
					$<v.Dimensions>$, 
					$<s>3->Dimensions,
					$<s>3->Arity * sizeof( int )
				);

				/*
				** Concatenate the explict dimensions list to the end
				** of our Dimensions array.
				*/
				 
				assert( $<v.Dimensions>5 != NULL );
				memcpy
				(
					$<v.Dimensions>$ +	$<s>3->Arity,
					$<v.Dimensions>5,
					$<v.Arity>5 * sizeof( int )
				);

				/*
				** We're done with the explict list, so free it.
				*/

				free2( vss $<v.Dimensions>5 );

			_endif
			$<v.u.ArrayOfValues>$ = NULL;
		}
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			_if( $<v.pType>9 == tArray )

				/*
				** Check to see if the list of array values specified
				** by the user is type and count compatible with the
				** array type specified by the TypeID and the explicit
				** dimensions list.	If so, insert the constant into
				** the symbol table.
				*/

				_if
				( 
					ArraysAreCompatible
					( 
						YYS &$<v>7, 
						YYS &$<v>9 
					)
				)

					SetSym
					( 
						$<s>1, 
						$<v.Type>7,
						tArray, 
						$<v.Arity>7,
						$<v.Dimensions>7,
						$<v.NumElements>7,
						YYS &$<v>9,
						$<s>3->ObjectSize * $<v.NumElements>5,
						0,
						NULL,
						$<v.Base>7,
						$<v.Fields>7,
						$<v.FieldCnt>7,
						$<v.CurField>7,
						$<v.CurIndex>7
					);


				_else

					/*
					** At this point either the types of the elements do
					** not agree or the number of elements do not agree.
					** Figure out which and print the appropriate error 
					** msg.
					*/

					_if
					( 
							$<v.NumElements>7 == $<v.NumElements>9
						||	$<s>3->pType == tText 
					)

						yyerror( "Type mismatch in operands" );

					_else

						yyerror
						( 
							"The number of array elements do not match" 
						);

					_endif
					_if( $<v.pType>9 == tArray )
					
						FreeValue( YYS &$<v>9 );

					_endif
					free2( vss $<v.Dimensions>7 );

				_endif

			_else

				yyerror( "Expected array expression" );
				_if( $<v.pType>9 == tArray )
				
					FreeValue( YYS &$<v>9 );

				_endif
				free2( vss $<v.Dimensions>7 );

			_endif
			_here;
		
		}
	;


	
	/*
	** Open array value definitions:
	**
	** e.g., b:integer[] := [1,2,3,4];
	**
	*/
	
ValueDef: 
		UndefinedID	/* $1 */
		Colon		/* $2 */
		TypeID 		/* $3 */
		'[' 		/* $4 */
		Rbrack 		/* $5 */
		{			/* $6 */
		
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );
			/*
			** Scream if the user is trying to define a text array.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;

			_endif

			/*
			** If it's not a primitive scalar type, complain about
			** that and then fake a usable type.
			*/

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				$<s>3 = &uns32_ste;

			_endif
			_here;
		}
		assignTkn		/* $7  */ 
		ConstOnlyExpr 	/* $8  */
		Semicolon		/* $9  */
		{				/* $10 */

			int		i;
			char	IsValid;

			_here;
			_if( $<v.pType>8 != tArray )
			
				yyerror( "Expected array expression" );
				FreeValue( YYS &$<v>8 );
			
			_else				
			
				/*
				** There are two cases we need to consider here:
				**
				**	1.	The base type of the constant is a scalar
				**		type.  For this case, we simply give the
				**		constant type the same number of elements
				**		as the array constant.
				**
				**	2.	The base type of the constant is an array type.
				**		In this case we have to make sure that the
				**		number of elements in the array constant is
				**		an even multiple of the number of elements in
				**		the array type.
				*/
				
				_if( $<s>3->pType != tArray )
				
					/*
					** Okay, we've got the simple case where we
					** just copy the data from the expression into
					** the new constant object. But first, let's make sure 
					** that the elements of this array are compatible with
					** the base type of the array constant object:
					*/
					
					
					IsValid = 1;
					i = 0;
					_do
					
						/*
						** Verify that each element of the array expression
						** is compatible with our destination type:
						*/
						
						IsValid = 
								IsValid 
							&&	IsCompatible
								(
									GetBaseType( $<s>3 ),
									YYS &$<v.u.ArrayOfValues>8[i] 
								);
								
						++i;
						
					_until( i >= $<v.NumElements>8 || !IsValid )
					
					_if( IsValid )
					
						InsertSym
						( 
							$<idStr>1, 
							GetBaseType( $<s>3 ),
							tArray, 
							cValue, 
							1,							/* Arity		*/
							malloc2( sizeof( int )),	/* Dimensions	*/
							$<v.NumElements>8,			/* NumElements	*/
							NULL,						/* Value		*/
							0,							/* ObjectSize	*/
							0,							/* Offset		*/
							NULL,						/* Static Name	*/
							$<v.Base>8,					/* Base Type	*/
							$<v.Fields>8,				/* Field list	*/
							$<v.FieldCnt>8				/* Num Fields	*/
						);
						
						/*
						** Allocate storage to hold the data:
						*/
						
						SymbolTable->u.ArrayOfValues = 
							malloc2
							( 
								$<v.NumElements>8 * sizeof( struct SymNode )
							);
							
						/*
						** Copy the data from the array constant expression
						** to the array object we've just created:
						*/
						
						_for( i=0, i < $<v.NumElements>8, ++i )
						
							DeepCopy
							( 
								&SymbolTable->u.ArrayOfValues[i], 
								&$<v.u.ArrayOfValues>8[i]
							);
							
						_endfor
						
						/*
						** Set up the size information for this constant array:
						*/
						
						SymbolTable->Dimensions[0] = $<v.NumElements>8;
						SymbolTable->ObjectSize = 
							$<s>3->ObjectSize * $<v.NumElements>8;
							
						
						
					_else
					
						yyerror( "Type mismatch in operands" );
					
					_endif


				_else
				
					/*
					** Okay, the base type of the constant object is
					** an array type.  This means that the number
					** of elements in the constant expression must
					** be an even multiple of the number of elements
					** in the base type.
					*/
					
					_if
					(
							$<s>3->NumElements >= $<v.NumElements>8
						||	( $<v.NumElements>8 % $<s>3->NumElements ) != 0
					)
					
						yyerror
						( 
							"Array constant has bad number of elements"
						);
						
					_else

						IsValid = 1;
						i = 0;
						_do
						
							/*
							** Verify that each element of the array expression
							** is compatible with our destination type:
							*/
							
							IsValid = 
									IsValid 
								&&	IsCompatible
									(
										GetBaseType( $<s>3 ),
										YYS &$<v.u.ArrayOfValues>8[i] 
									);
									
							++i;
							
						_until( i >= $<v.NumElements>8 || !IsValid )
						
						_if( IsValid )
						
							InsertSym
							( 
								$<idStr>1, 
								GetBaseType( $<s>3 ),
								tArray, 
								cValue, 
								$<s>3->Arity + 1,			
								malloc2( sizeof( int ) * ($<s>3->Arity + 1)),
								$<v.NumElements>8,			
								NULL,						
								0,							
								0,							
								NULL,						
								$<v.Base>8,					
								$<v.Fields>8,				
								$<v.FieldCnt>8				
							);
							
							/*
							** Allocate storage to hold the data:
							*/
							
							SymbolTable->u.ArrayOfValues = 
								malloc2
								( 
									$<v.NumElements>8 * sizeof( struct SymNode )
								);
								
							/*
							** Copy the data from the array constant expression
							** to the array object we've just created:
							*/
							
							_for( i=0, i < $<v.NumElements>8, ++i )
							
								DeepCopy
								( 
									&SymbolTable->u.ArrayOfValues[i], 
									&$<v.u.ArrayOfValues>8[i]
								);
								
							_endfor
							
							/*
							** Set up the size information for this 
							** constant array:
							*/
												
							_for( i = 0, i < SymbolTable->Arity - 1, ++i )
							
								SymbolTable->Dimensions[i] = 
									$<s>3->Dimensions[i];
									
							_endfor
							SymbolTable->Dimensions[ SymbolTable->Arity - 1 ] =
								$<v.NumElements>8 / $<s>3->NumElements;
								
							SymbolTable->ObjectSize = 
								$<s>3->Type->ObjectSize * $<v.NumElements>8;
								
							
							
						_else
						
							yyerror( "Type mismatch in operands" );
						
						_endif

					
					_endif


				_endif

			_endif
			FreeValue( YYS &$<v>8 );

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;	
			_here;	
		}
	;
												






												


	
	/*
	** Open array value redefinitions:
	**
	** e.g., b:integer[] := [1,2,3,4];
	**
	*/
	
ValueDef: 
		AnyLocalID 	/* $1 */
		Colon		/* $2 */
		TypeID 		/* $3 */

		'[' 		/* $4 */
		Rbrack 		/* $5 */
		{			/* $6 */
		
			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );
			/*
			** Scream if the user is trying to define a text array.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;

			_endif

			/*
			** If it's not a primitive scalar type, complain about
			** that and then fake a usable type.
			*/

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				$<s>3 = &uns32_ste;

			_endif
			_here;
		}
		assignTkn		/* $7  */ 
		ConstOnlyExpr 	/* $8  */
		Semicolon		/* $9  */
		{				/* $10 */

			int		i;
			char	IsValid;

			_here;
			_if( $<v.pType>8 != tArray )
			
				yyerror( "Expected array expression" );
				FreeValue( YYS &$<v>8 );
			
			_else				
			
				/*
				** There are two cases we need to consider here:
				**
				**	1.	The base type of the constant is a scalar
				**		type.  For this case, we simply give the
				**		constant type the same number of elements
				**		as the array constant.
				**
				**	2.	The base type of the constant is an array type.
				**		In this case we have to make sure that the
				**		number of elements in the array constant is
				**		an even multiple of the number of elements in
				**		the array type.
				*/
				
				_if( $<s>3->pType != tArray )
				
					/*
					** Okay, we've got the simple case where we
					** just copy the data from the expression into
					** the new constant object. But first, let's make sure 
					** that the elements of this array are compatible with
					** the base type of the array constant object:
					*/
					
					
					IsValid = 1;
					i = 0;
					_do
					
						/*
						** Verify that each element of the array expression
						** is compatible with our destination type:
						*/
						
						IsValid = 
								IsValid 
							&&	IsCompatible
								(
									GetBaseType( $<s>3 ),
									YYS &$<v.u.ArrayOfValues>8[i] 
								);
								
						++i;
						
					_until( i >= $<v.NumElements>8 || !IsValid )
					
					_if( IsValid )
					
						SetSym
						( 
							$<s>1, 
							GetBaseType( $<s>3 ),
							tArray, 
							1,							/* Arity		*/
							malloc2( sizeof( int )),	/* Dimensions	*/
							$<v.NumElements>8,			/* NumElements	*/
							NULL,						/* Value		*/
							0,							/* ObjectSize	*/
							0,							/* Offset		*/
							NULL,						/* Static Name	*/
							$<v.Base>8,					/* Base Type	*/
							$<v.Fields>8,				/* Field list	*/
							$<v.FieldCnt>8,				/* Num Fields	*/
							$<v.Fields>8,				/* Current Field*/
							0							/* CurfieldIndx */
						);
						
						/*
						** Allocate storage to hold the data:
						*/
						
						SymbolTable->u.ArrayOfValues = 
							malloc2
							( 
								$<v.NumElements>8 * sizeof( struct SymNode )
							);
							
						/*
						** Copy the data from the array constant expression
						** to the array object we've just created:
						*/
						
						_for( i=0, i < $<v.NumElements>8, ++i )
						
							DeepCopy
							( 
								&SymbolTable->u.ArrayOfValues[i], 
								&$<v.u.ArrayOfValues>8[i]
							);
							
						_endfor
						
						/*
						** Set up the size information for this constant array:
						*/
						
						SymbolTable->Dimensions[0] = $<v.NumElements>8;
						SymbolTable->ObjectSize = 
							$<s>3->ObjectSize * $<v.NumElements>8;
							
						
						
					_else
					
						yyerror( "Type mismatch in operands" );
					
					_endif


				_else
				
					/*
					** Okay, the base type of the constant object is
					** an array type.  This means that the number
					** of elements in the constant expression must
					** be an even multiple of the number of elements
					** in the base type.
					*/
					
					_if
					(
							$<s>3->NumElements >= $<v.NumElements>8
						||	( $<v.NumElements>8 % $<s>3->NumElements ) != 0
					)
					
						yyerror
						( 
							"Array constant has bad number of elements"
						);
						
					_else

						IsValid = 1;
						i = 0;
						_do
						
							/*
							** Verify that each element of the array expression
							** is compatible with our destination type:
							*/
							
							IsValid = 
									IsValid 
								&&	IsCompatible
									(
										GetBaseType( $<s>3 ),
										YYS &$<v.u.ArrayOfValues>8[i] 
									);
									
							++i;
							
						_until( i >= $<v.NumElements>8 || !IsValid )
						
						_if( IsValid )
						
							SetSym
							( 
								$<s>1, 
								GetBaseType( $<s>3 ),
								tArray, 
								$<s>3->Arity + 1,			
								malloc2( sizeof( int ) * ($<s>3->Arity + 1)),	
								$<v.NumElements>8,			
								NULL,						
								0,							
								0,							
								NULL,						
								$<v.Base>8,					
								$<v.Fields>8,				
								$<v.FieldCnt>8,				
								$<v.Fields>8,  
								0
							);
							
							/*
							** Allocate storage to hold the data:
							*/
							
							SymbolTable->u.ArrayOfValues = 
								malloc2
								( 
									$<v.NumElements>8 * sizeof( struct SymNode )
								);
								
							/*
							** Copy the data from the array constant expression
							** to the array object we've just created:
							*/
							
							_for( i=0, i < $<v.NumElements>8, ++i )
							
								DeepCopy
								( 
									&SymbolTable->u.ArrayOfValues[i], 
									&$<v.u.ArrayOfValues>8[i]
								);
								
							_endfor
							
							/*
							** Set up the size information for this 
							** constant array:
							*/
												
							_for( i = 0, i < SymbolTable->Arity - 1, ++i )
							
								SymbolTable->Dimensions[i] = 
									$<s>3->Dimensions[i];
									
							_endfor
							SymbolTable->Dimensions[ SymbolTable->Arity - 1 ] =
								$<v.NumElements>8 / $<s>3->NumElements;
								
							SymbolTable->ObjectSize = 
								$<s>3->Type->ObjectSize * $<v.NumElements>8;
								
							
							
						_else
						
							yyerror( "Type mismatch in operands" );
						
						_endif

					
					_endif


				_endif

			_endif
			FreeValue( YYS &$<v>8 );

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;		
		}
	;
												






												





	/*
	** Array value definitions:
	** e.g., b:integer[4];
	**
	*/

ValueDef: 
		UndefinedID	/* $1 */
		Colon
		TypeID 
		'[' 
		DimList 
		Rbrack  
		Semicolon
		{
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			/*
			** Initialize some common synthesized attributes.
			*/

			$<v.pType>$ 	= tArray;
			$<v.Arity>$ 	= $<s>3->Arity + $<v.Arity>5;
			$<v.Type>$  	= GetBaseType( $<s>3 );
			$<v.Base>$		= $<s>3->Base;
			$<v.Fields>$	= $<s>3->Fields;
			$<v.FieldCnt>$	= $<s>3->FieldCnt;


			/*
			** Text arrays are illegal.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;


			/*								
			** Make sure this is a legal constant type.
			*/

			_elseif( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				$<s>3 = &string_ste;

			_else

				/*
				** If TypeID is a scalar type, just use the
				** DimList attributes.
				*/

				_if( $<s>3->pType != tArray )
				
					$<v.NumElements>$ = $<v.NumElements>5;
					$<v.Dimensions>$ = $<v.Dimensions>5;

				/*
				** If TypeID is an array type, we need to
				** combine TypeID with DimList to produce
				** a larger array.
				*/

				_else


					$<v.NumElements>$ = 
							$<s>3->NumElements * $<v.NumElements>5;

					$<v.Dimensions>$ =
						malloc2( $<v.Arity>$ * sizeof( int ));
 
					assert( $<s>3->Dimensions != NULL );
					memcpy
					( 
						$<v.Dimensions>$, 
						$<s>3->Dimensions,
						$<s>3->Arity * sizeof( int )
					);

					assert( $<v.Dimensions>5 != NULL );
					memcpy
					(
						$<v.Dimensions>$ +	$<s>3->Arity,
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);
					free2( vss $<v.Dimensions>5 );

				_endif

				ClrNewSym
				( 
					$<idStr>1, 
					$<v.Type>$,
					tArray, 
					cValue, 
					$<v.Arity>$,
					$<v.Dimensions>$,
					$<v.NumElements>$,
					$<s>3->ObjectSize * $<v.NumElements>5,
					0,
					NULL,
					$<v.Base>$,
					$<v.Fields>$,
					$<v.FieldCnt>$,
					$<v.CurField>$,
					$<v.CurIndex>$
				);

			_endif
			_here;
		}
	;

	/*
	** Array const redefintions:
	** e.g., b:integer[4]; (assumes b already exists.)
	**
	** Similar to the previous section.  See that production
	** for comments.
	**
	*/
			
ValueDef:					
		AnyLocalID 
		Colon
		TypeID '[' DimList Rbrack  Semicolon
		{
			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );

			/*
			** Initialize some common synthesized attributes.
			*/

			$<v.pType>$ 	= tArray;
			$<v.Arity>$ 	= $<s>3->Arity + $<v.Arity>5;
			$<v.Type>$  	= GetBaseType( $<s>3 );
			$<v.Base>$		= $<s>3->Base;
			$<v.Fields>$	= $<s>3->Fields;
			$<v.FieldCnt>$	= $<s>3->FieldCnt;


			/*
			** Text arrays are illegal.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;


			/*
			** Make sure this is a legal constant type.
			*/

			_elseif( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				$<s>3 = &string_ste;

			_else

				/*
				** If TypeID is a scalar type, just use the
				** DimList attributes.
				*/

				_if( $<s>3->pType != tArray )
				
					$<v.NumElements>$ = $<v.NumElements>5;
					$<v.Dimensions>$ = $<v.Dimensions>5;

				/*
				** If TypeID is an array type, we need to
				** combine TypeID with DimList to produce
				** a larger array.
				*/

				_else


					$<v.NumElements>$ = 
							$<s>3->NumElements * $<v.NumElements>5;

					$<v.Dimensions>$ =
						malloc2( $<v.Arity>$ * sizeof( int ));
 
					assert( $<s>3->Dimensions != NULL );
					memcpy
					( 
						$<v.Dimensions>$, 
						$<s>3->Dimensions,
						$<s>3->Arity * sizeof( int )
					);

					assert( $<v.Dimensions>5 != NULL );
					memcpy
					(
						$<v.Dimensions>$ +	$<s>3->Arity,
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);
					free2( vss $<v.Dimensions>5 );

				_endif

				ClrSym
				( 
					$<s>1, 
					$<v.Type>$,
					tArray, 
					$<v.Arity>$,
					$<v.Dimensions>$,
					$<v.NumElements>$,
					$<s>3->ObjectSize * $<v.NumElements>5,
					0,
					NULL,
					$<v.Base>$,
					$<v.Fields>$,
					$<v.FieldCnt>$,
					$<v.CurField>$,
					$<v.CurIndex>$
				);

			_endif
			_here;
		}
	;


	/*
	** Handle statements of the form "array[ConstOnlyExpr] := ConstOnlyExpr"
	*/

ValueDef:
		ArrayAdrs 
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			_if( $<v.u.PtrToValue>1 != NULL )

				_if( $<v.pType>1 == tArray )

					_if
					( 
						ArraysAreCompatible
						( 
							YYS &$<v>1, 
							YYS &$<v>3 
						)
					)


						_for( int i=0, i < $<v.NumElements>1, ++i )
						
							DeepCopy
							(
									&$<v.u.PtrToValue>1[i],
									&$<v.u.ArrayOfValues>3[i]
							);

						_endfor

					_elseif( $<v.NumElements>1 == $<v.NumElements>3 )

						yyerror( "Type mismatch in operands" );

					_else

						yyerror
						( 
							"The number of array elements do not match"
						);

					_endif
					FreeValue( YYS &$<v>3 );


				_elseif( $<v.pType>1 == tRecord )

					_if
					( 
						RecordsAreCompatible
						( 
							&$<v>1, 
							YYS &$<v>3 
						)
					)
			
						_for( int i=0, i < $<v.FieldCnt>3, ++i )

							// Note: A deep copy was already done on
							// the constant, no need to repeat that here.
												
							FreeValue( YYS &$<v.u.PtrToValue>1->u.FieldValues[i] );
							$<v.u.PtrToValue>1->u.FieldValues[i] =
								$<v.u.FieldValues>3[i];

						_endfor

					_else

						yyerror
						( 
							"The records are incompatible"
						);
						FreeValue( YYS &$<v>3 );

					_endif



				_elseif
				( 
						$<v.pType>1 == tUnion
					&&	$<v.pType>3 == tUnion
					&&	GetBaseType( $<v.Type>1 ) == 
							GetBaseType( $<v.Type>3 ) 
				)

					_for( int i=0, i < $<v.FieldCnt>3, ++i )

						// Note: A deep copy was already done on
						// the constant, no need to repeat that here.
											
						FreeValue( YYS &$<v.u.PtrToValue>1->u.FieldValues[i] );
						$<v.u.PtrToValue>1->u.FieldValues[i] =
							$<v.u.FieldValues>3[i];

					_endfor
					$<v.u.PtrToValue>1->CurField = $<v.CurField>3;
					$<v.u.PtrToValue>1->CurIndex = $<v.CurIndex>3;


				_else /* Must be a scalar value */

					memcpy
					( 
						&$<v.u.PtrToValue>1->u.StartOfValues, 
						&$<v.u.StartOfValues>3, 
						sizeof( union ValuesSize )
					);

				_endif

			_endif
			_here;
		}
	;

	/*
	** Handle statements of the form "record.field := ConstOnlyExpr"
	*/

ValueDef:
		RecordAdrs 
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			_if( $<v.u.PtrToValue>1 != NULL )

				_if( $<v.pType>1 == tArray )

					_if
					( 
						ArraysAreCompatible
						( 
							YYS &$<v>1, 
							YYS &$<v>3 
						)
					)


						_for( int i=0, i < $<v.NumElements>1, ++i )

							DeepCopy
							(
								&$<v.u.PtrToValue>1->u.ArrayOfValues[i],
								&$<v.u.ArrayOfValues>3[i]
							);

						_endfor

					_elseif( $<v.NumElements>1 == $<v.NumElements>3 )

						yyerror( "Type mismatch in operands" );

					_else

						yyerror
						( 
							"The number of array elements do not match"
						);

					_endif
					FreeValue( YYS &$<v>3 );


				_elseif( $<v.pType>1 == tRecord )

					_if
					( 
						RecordsAreCompatible
						( 
							&$<v>1, 
							YYS &$<v>3 
						)
					)
			
						_for( int i=0, i < $<v.FieldCnt>3, ++i )

							DeepCopy
							(
									&$<v.u.PtrToValue>1->u.FieldValues[i],
									&$<v.u.FieldValues>3[i]
							);

						_endfor

					_else

						yyerror
						( 
							"The fields are incompatible"
						);

					_endif
					FreeValue( YYS &$<v>3 );

				_elseif( $<v.pType>1 == tUnion )

					_if( $<v.Type>1 == $<v.Type>3 )
					
			
						_for( int i=0, i < $<v.FieldCnt>3, ++i )

							DeepCopy
							(
									&$<v.u.PtrToValue>1->u.FieldValues[i],
									&$<v.u.FieldValues>3[i]
							);

						_endfor

						
					_else
					
						yyerror
						( 
							"The union field and constant are incompatible"
						);
						
						// Need to set up a dummy value to prevent problems:
						
						memcpy
						( 
							$<v.u.PtrToValue>1->u.FieldValues,
							&dummy_ste,
							sizeofSymNode
						);
						$<v.u.PtrToValue>1->u.FieldValues->StaticName = 
							$<v.u.PtrToValue>1->StaticName;
							
						$<v.u.PtrToValue>1->StaticName = NULL;
						$<v.u.PtrToValue>1->u.FieldValues->Offset = $<v.Offset>1;
							
					_endif



				_else /* Must be a scalar value */

					memcpy
					( 
						&$<v.u.PtrToValue>1->u.StartOfValues, 
						&$<v.u.StartOfValues>3, 
						sizeof( union ValuesSize )
					);

				_endif

			_endif
			_here;
		}
	;

ValueDef:
		error ';' { _here; }

		;







/*****************************************************************************/
/*****************************************************************************/
/**********************                           ****************************/
/**********************                           ****************************/
/**********************    V A L U E S  4 "?"     ****************************/
/**********************                           ****************************/
/**********************                           ****************************/
/*****************************************************************************/
/*****************************************************************************/




/*
** ValueReDef
**
** These productions handle the individual forms of value
** declarations that are possible after the "?" token.
**
** Productions:
**
**	ValueReDef->
**				UndefinedID ':=' ConstOnlyExpr ';'
**
**			|	UndefinedID ':' TypeID ':=' ConstOnlyExpr ';'
**
**			|	UndefinedID ':' TypeID ';'
**
**			|	UndefinedID ':' TypeID '[' DimList ']' ':=' ConstOnlyExpr ';'
**
**			|	UndefinedID ':' TypeID '[' DimList ']' ';'
**
**			|	UndefinedID ':' TypeID '[' ']' ':=' ConstOnlyExpr ';' 
**
**
**			|	LocalID ':=' ConstOnlyExpr ';'
**
**			|	LocalID ':' TypeID ':=' ConstOnlyExpr ';'
**
**			|	LocalID ':' TypeID ';'
**
**			|	LocalID ':' TypeID '[' DimList ']' := ConstOnlyExpr ';'
**
**			|	LocalID ':' TypeID '[' ']' ':=' ConstOnlyExpr ';'
**
**			|	LocalID ':' TypeID '[' DimList ']' ';'
**
**			|	ArrayRef := ConstOnlyExpr;
**
**			|	RecordRef := ConstOnlyExpr; 
**
**
**			|	UndefinedID := regexConst;
**			|	UndefinedID :regex := regexConst;
**			|	LocalID := regexConst;
**			|	LocalID :regex := regexConst; 
**
**	plus some error productions.
**
**	These productions are nearly identical to those for ValueDef.
**
*/

ValueRedef:	

			/*
			** Allow empty declarations (just a semicolon) for
			** syntactical reasons (e.g., to put semicolons after
			** macros and such).
			*/


			';' { _here; }
	

			/*
			** Built-in VAL objects
			*/

	|		startParmOfsTkn assignTkn ConstOnlyExpr Semicolon
			{
				_here;
				_if( !checkSmallInt( YYS &$<v>3 ) )

					yyerror
					( 
						"Parameter offset value must be a 32-bit integer" 
					);

				_else

					StartParmOffs = $<v.u.intval>3;

				_endif

					
			}



	|		startLclOfsTkn assignTkn ConstOnlyExpr Semicolon
			{
				_here;
				_if( !checkSmallInt( YYS &$<v>3 ) )

					yyerror( "Locals offset value must be a 32-bit integer" );

				_else

					StartLclOffs = $<v.u.intval>3;

				_endif

					
			}



	|		enumSizeTkn assignTkn ConstOnlyExpr Semicolon
			{
				_here;
				_if( !checkSmallInt( YYS &$<v>3 ) )

					yyerror( "Enum size must be an integer" );

				_else

					EnumSize = $<v.u.intval>3;

				_endif

					
			}




	|		atlabelTkn assignTkn ConstOnlyExpr Semicolon
			{
				_here;
				_if( !checkSmallInt( YYS &$<v>3 ) || $<v.u.intval>3 < 1 )

					yyerror( "@label must be assigned an integer > 1" );

				_else

					LblCntr = $<v.u.intval>3;

				_endif
				_here;
			}




	|		baseregTkn assignTkn ebpTkn Semicolon
			{
				_here;
				CurBaseReg = "ebp";
			}



	|		baseregTkn assignTkn espTkn Semicolon
			{
				_here;
				CurBaseReg = "esp";
			}

		 
	|		baseregTkn assignTkn error Semicolon
			{
				yyerror( "'@basereg := reg' only allows ESP or EBP" );
			}



		 
	|	boundvarTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@bound expects a boolean expression" );

			_else

				CompileBound = $<v.u.boolval>3;

			_endif

				
		}

		 
	|	intovarTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@into expects a boolean expression" );

			_else

				CompileInto = $<v.u.boolval>3;

			_endif

				
		}

	|	traceTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@trace expects a boolean expression" );

			_else

				TraceFlag = $<v.u.boolval>3;

			_endif

				
		}

		 
		 
	|	exceptsTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@exceptions expects a boolean expression" );

			_else

				FullExceptions = $<v.u.boolval>3;

			_endif

				
		}


		 
		 
	|	displayTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@display expects a boolean expression" );

			_else

				DisplayDefault = $<v.u.boolval>3;

			_endif

				
		}

		 
		 
	|	nodisplayTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@nodisplay expects a boolean expression" );

			_else

				DisplayDefault = !$<v.u.boolval>3;

			_endif
				
		}

		 
		 
	|	frameTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@frame expects a boolean expression" );

			_else

				FrameDefault = $<v.u.boolval>3;
				_if( langLevel <= low_level && $<v.u.boolval>3 )
				
					yyerror
					( 
						"@frame can only be assigned false except in \n"
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}

		 
		 
	|	noframeTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@nodisplay expects a boolean expression" );

			_else

				FrameDefault = !$<v.u.boolval>3;
				_if( langLevel <= low_level && !$<v.u.boolval>3 )
				
					yyerror
					( 
						"@noframe can only be assigned true except in \n"
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}

		 
		 
	|	alignstkTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@alignstack expects a boolean expression" );

			_else

				AlignStackDefault = $<v.u.boolval>3;
				_if( langLevel <= low_level && $<v.u.boolval>3 )
				
					yyerror
					( 
						"@alignstack can only be assigned false except in \n"
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}

		 
		 
	|	noalignstkTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@noalignstack expects a boolean expression" );

			_else

				AlignStackDefault = !$<v.u.boolval>3;
				_if( langLevel <= low_level && !$<v.u.boolval>3 )
				
					yyerror
					( 
						"@noalignstack can only be assigned true except in \n"
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}

		 
		 
	|	useenterTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@enter expects a boolean expression" );

			_else

				EnterDefault = $<v.u.boolval>3;
				_if( langLevel <= low_level  )
				
					yyerror
					( 
						"@enter is illegal except in "
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}

		 
		 
	|	noenterTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@noenter expects a boolean expression" );

			_else

				EnterDefault = !$<v.u.boolval>3;
				_if( langLevel <= low_level  )
				
					yyerror
					( 
						"@noenter is illegal except in "
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}

		 
		 
	|	useleaveTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@leave expects a boolean expression" );

			_else

				LeaveDefault = $<v.u.boolval>3;
				_if( langLevel <= low_level  )
				
					yyerror
					( 
						"@leave is illegal except in "
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}

		 
		 
	|	noleaveTkn assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@noleave expects a boolean expression" );

			_else

				LeaveDefault = !$<v.u.boolval>3;
				_if( langLevel <= low_level  )
				
					yyerror
					( 
						"@noleave is illegal except in "
						"high-level and medium-level language modes."
					);
					
				_endif

			_endif

				
		}
		



	|		alignprocTkn assignTkn ConstOnlyExpr Semicolon
			{
				_here;
				_if( !checkSmallInt( YYS &$<v>3 ) )

					yyerror( "@align value must be a 32-bit integer" );

				_else

					int bits;
					int value;
					
					bits = 0;
					value = $<v.u.intval>3;
					_while( value != 0 )
					
						bits = bits + (value & 1);
						value = value >> 1;
						
					_endwhile;
					_if( bits != 1 )
					
						yyerror
						( 
							"@align requires an operand that is a power of two" 
						);
						
					_elseif
					(
							assembler == fasm
						&&	$<v.u.intval>3 > 16
					)
					
						yyerror
						( 
							"FASM output supports only 1, 2, 4, 8, and 16 "
							"as alignment values" 
						);
					
						
					_else
					
						AlignDefault = $<v.u.intval>3;
						
					_endif;

				_endif
			}

		 

		 
		// Deal with the @optstrings pseudo-variable here.

	|	optstringsTkn	/* $1 */
		assignTkn		/* $2 */
		ConstOnlyExpr	/* $3 */
		Semicolon		/* $4 */
		{				/* $5 */
			_here;
			_if( $<v.pType>3 != tBoolean )

				yyerror( "@optstrings expects a boolean expression" );

			_else

				OptimizeStrings = $<v.u.boolval>3;

			_endif

				
		}

		 
		 
		/*
		** The following production lets the user treat the
		** @offset(name) function as a pseudo-variable allowing
		** the user to change the offset field of a VAR object.
		*/
		
	|	symOffsetTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		assignTkn		/* $5 */
		ConstOnlyExpr	/* $6 */
		Semicolon		/* $7 */
		{
			_here;
			_if(( $<cls.cls>3 & cfy_SingleID ) == 0 )

				yyerror( "@offset requires a single ID parameter" );

			_elseif(( $<cls.cls>3 & cfy_Undefined) || $<cls.sym>3 == NULL )

				yyerror( "@offset requires a defined identifier" );

			_else

				_if( checkSmallInt( YYS &$<v>6 ))

					$<cls.sym>3->Offset = $<v.u.intval>6;
					
				_else
				
					yyerror( "Expected a 32-bit numeric offset value" );
					
				_endif
				
			_endif
			FreeValue( YYS &$<v>6 );
			_here;
		}

	;

	


 /*
 ** Quick scalar value declarations:
 **
 **	Syntax  <id> := <expression>;
 **
 ** e.g., u:=1234;
 **		 x:=u;
 **
 ** Generally used to create scalar constants,
 ** However, if the expression on the right
 ** hand side of the assignment operator is
 ** an array identifier, then this
 ** operation creates an array constant.
 **
 ** Note, however, that assignments of the form
 **			id := [array_list]
 ** are handled elsewhere.
 **
 */


ValueRedef:	
		lclUndefID 
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{

			_here;
			assert( $<idStr>1 != NULL );
			assert( $<v.Type>3 != NULL );

			InsertSym
			( 
				$<idStr>1, 
				$<v.Type>3,
				$<v.pType>3, 
				cValue, 
				$<v.Arity>3,
				$<v.Dimensions>3,	/* ConstOnlyExpr mallocs this if array */
				$<v.NumElements>3, 
				YYS &$<v>3,
				_ifx
				( 
					$<v.pType>3 == tArray,
					$<v.Type>3->ObjectSize * $<v.NumElements>3,
					$<v.Type>3->ObjectSize
				),
				0,
				NULL,
				$<v.Base>3,
				$<v.Fields>3,
				$<v.FieldCnt>3 
			);
			_here;

		}
	;






// Special case for regular expressions

ValueRedef:	
		lclUndefID 
		assignTkn 
		regexconst 
		Semicolon
		{
			_here;
			assert( $<idStr>1 != NULL );

			InsertSym
			( 
				$<idStr>1, 
				&regex_ste,
				tRegex, 
				cValue, 
				0,
				NULL,
				0, 
				YYS &$<v>3,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0 
			);
			_here;

		}
	;




		
		/*
		** Quick scalar value redeclarations:
		** e.g., u:=1234; (assuming u is already defined.)
		**
		**
		** Note, if the object on the right side of the assignment
		** statement is an array object, ConstOnlyExpr mallocs all the
		** array data.
		*/

ValueRedef:	
		DefinedConstID assignTkn ConstOnlyExpr Semicolon
		{
			_here;
			assert( $<s>1 != NULL );

			SetSym
			( 
				$<s>1, 
				$<v.Type>3,
				$<v.pType>3, 
				$<v.Arity>3,
				$<v.Dimensions>3,	/* ConstOnlyExpr mallocs this if array */
				$<v.NumElements>3, 
				YYS &$<v>3,
				_ifx
				( 
					$<v.pType>3 == tArray,
					$<v.Type>3->ObjectSize * $<v.NumElements>3,
					$<v.Type>3->ObjectSize
				),
				0,
				NULL,
				$<v.Base>3,
				$<v.Fields>3,
				$<v.FieldCnt>3,
				$<v.CurField>3,
				$<v.CurIndex>3 
			);
			_here;
		}
	;


// Special case for regular expressions			

ValueRedef:	
		DefinedConstID	/* $1 */ 
		assignTkn 		/* $2 */
		regexconst 		/* $3 */
		Semicolon		/* $4 */
		{
			_here;
			assert( $<s>1 != NULL );

			SetSym
			( 
				$<s>1, 
				&regex_ste,
				tRegex, 
				0,
				NULL,
				0, 
				YYS &$<v>3,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0,
				NULL,
				0 
			);
			_here;
		}
	;


	/*
	** For the += and -= operators we'll just cheat and
	** push back a normal expression that computes these values:
	*/

ValueRedef:	
		DefinedConstID addassignTkn 
		{
			_here;
			assert( $<s>1 != NULL );
			PushBackStr( "+" );
			PushBackStr( $<s>1->TrueName );
			PushBackStr( ":=" );
			PushBackStr( $<s>1->TrueName );
			PushBackStr( "?" );				
			_here;
		}

	|	DefinedConstID subassignTkn 
		{
			_here;
			assert( $<s>1 != NULL );
			PushBackStr( "-" );
			PushBackStr( $<s>1->TrueName );
			PushBackStr( ":=" );
			PushBackStr( $<s>1->TrueName );
			PushBackStr( "?" );				
			_here;
		}
	;


// Some errors:

ValueRedef:	
		UndefID 
		addassignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			yyerror( "+= operator is not legal with undefined left hand side" );
		}
	;
			

ValueRedef:	
		UndefID 
		subassignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			yyerror( "-= operator is not legal with undefined left hand side" );
		}
	;
			
			
   /*
   ** Partial scalar value declarations:
   ** e.g., i:integer;
   **
   **	Note:	These values are initialized with zero or an
   **			empty string.
   **
   */


ValueRedef: lclUndefID Colon TypeID Semicolon
			{

				_here;
				assert( $<idStr>1 != NULL );
				assert( $<s>3 != NULL );

				_if( !CanBeVal( $<s>3->pType ))

					yyerror( "Values can only have primitive types" );

				_elseif( $<s>3->pType != tArray )

					ClrNewSym
					( 
						$<idStr>1, 
						$<s>3,
						$<s>3->pType, 
						cValue, 
						0,
						NULL,
						0, 
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt,
						$<s>3->CurField,
						$<s>3->CurIndex 
					);

				_else /* We have an array */


					ClrNewSym
					( 
						$<idStr>1, 
						$<s>3->Type,
						tArray, 
						cValue, 
						$<s>3->Arity,
						DupDims( $<s>3 ),
						$<s>3->NumElements, 
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base, 
						$<s>3->Fields,
						$<s>3->FieldCnt,
						$<s>3->CurField,
						$<s>3->CurIndex
					);

				_endif
				_here;

			}



			/*
			** Partial scalar const redeclarations:
			** e.g., i:integer;  (assuming i is already defined.)
			**
			**	This production lets the programmer change the type
			**	of a value without assigning a value to it.  Of course,
			**	the code will initialize the value with zero or an
			**	empty string. 
			**
			*/


		|	DefinedConstID Colon TypeID Semicolon
			{
				assert( $<s>1 != NULL );
				assert( $<s>3 != NULL );
				_here;
				_if( !CanBeVal( $<s>3->pType ))

					yyerror( "Values can only have primitive types" );

				_elseif( $<s>3->pType != tArray )

					ClrSym
					( 
						$<s>1, 
						$<s>3,
						$<s>3->pType, 
						0,
						NULL,
						0, 
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt,
						$<s>3->CurField,
						$<s>3->CurIndex 
					);

				_else /* We have an array */


					ClrSym
					( 
						$<s>1, 
						$<s>3->Type,
						tArray, 
						$<s>3->Arity,
						DupDims( $<s>3 ),
						$<s>3->NumElements, 
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base, 
						$<s>3->Fields,
						$<s>3->FieldCnt,
						$<s>3->CurField,
						$<s>3->CurIndex
					);

				_endif

				_here;
			}
	;


			/*
			** Full scalar value declarations:
			** e.g., i:integer := -2;
			**
			*/


ValueRedef:	
		lclUndefID		/* $1 */ 
		Colon 			/* $2 */
		TypeID 			/* $3 */
		assignTkn 		/* $4 */
		ConstOnlyExpr 	/* $5 */
		Semicolon		/* $6 */
		{
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );
			
			/*
			** If the TypeID is an array, the ConstOnlyExpr must also
			** be an array (ID).  That being the case, make sure
			** they are compatible with one another.
			*/
				 
			_if( $<s>3->pType == tArray && $<v.pType>5 == tArray )

				_if
				( 
					ArraysAreCompatible
					( 
						YYS $<s>3, 
						YYS &$<v>5 
					)
				)

					InsertSym
					( 
						$<idStr>1,
						GetBaseType( $<s>3 ), 
						tArray, 
						cValue, 
						$<s>3->Arity,
						DupDims( $<s>3 ),
						$<s>3->NumElements, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_else

					yyerror
					( 
						"Type mismatch of array operands or "
						"element value out of range" 
					);
					FreeValue( YYS &$<v>5 );


				_endif

			/*
			** If it's not an array, check to see if it is
			** a record.
			*/

			_elseif( $<s>3->pType == tRecord && $<v.pType>5 == tRecord )

				_if
				( 
					RecordsAreCompatible
					( 
						$<s>3, 
						YYS &$<v>5 
					)
				)

					InsertSym
					( 
						$<idStr>1, 
						GetBaseType( $<s>3 ),
						tRecord, 
						cValue, 
						$<s>3->Arity,
						$<s>3->Dimensions,
						$<s>3->NumElements, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_else

					yyerror
					( 
						"Type mismatch of operands. Expected "
						"compatible record types" 
					);

					FreeValue( YYS &$<v>5 );

				_endif


				/*
				** If it's not an array or record, check to see if it is
				** a union.
				*/

				_elseif
				( 
						$<s>3->pType == tUnion 
					&&	$<v.pType>5 == tUnion
					&&	GetBaseType( $<s>3 ) == GetBaseType( $<v.Type>5 )
				)

					InsertSym
					( 
						$<idStr>1, 
						GetBaseType( $<s>3 ),
						tUnion, 
						cValue, 
						0,					// Arity
						NULL,				// Dimensions
						0,					// NumElements
						YYS &$<v>5,
						$<s>3->ObjectSize,
						$<s>3->Offset,		// Index of selected field.
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

					// Must manually set up the two fields associated with
					// union constants:
					
					SymbolTable->CurField = $<v.CurField>5;
					SymbolTable->CurIndex = $<v.CurIndex>5;


			/*
			** If TypeID is not an array, make sure that it's a
			** primitive type.
			*/

			_elseif( IsNotPrimType( $<s>3->pType ))

				yyerror( "Constants can only have primitive types" );
				FreeValue( YYS &$<v>5 );

			/*
			** If TypeID is a primitive type, then check to see if
			** it is type compatible with the ConstOnlyExpr value.
			** Insert the object into the symbol table if they
			** are compatible.
			*/

			_elseif( IsCompatible( $<s>3, YYS &$<v>5 ))

				InsertSym
				( 
					$<idStr>1,
					GetBaseType( $<s>3 ), 
					$<s>3->pType, 
					cValue, 
					0,
					NULL,
					0, 
					YYS &$<v>5,
					$<s>3->ObjectSize,
					0,
					NULL,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt
				);

			_else

				yyerror
				( 
					"Type mismatch of operands or "
					"value out of range in declaration" 
				);
				FreeValue( YYS &$<v>5 );

			_endif
			_here;
		}
	;


// Special case for regular expressions.

ValueRedef:	
		lclUndefID		/* $1 */ 
		Colon 			/* $2 */
		TypeID 			/* $3 */
		assignTkn 		/* $4 */
		regexconst 	/* $5 */
		Semicolon		/* $6 */
		{
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			_if( $<s>3->pType != tRegex )
			
				yyerror( "Type mismatch, expected REGEX object" );
				
			_else
			
				InsertSym
				( 
					$<idStr>1, 
					&regex_ste,
					tRegex, 
					cValue, 
					0,
					NULL,
					0, 
					YYS &$<v>5,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0 
				);
			
			_endif
		}
	;



			/*
			** Full scalar value redeclarations:
			** e.g., i:integer := -2; (Assumes i already exists.)
			**
			*/
ValueRedef:	
			DefinedConstID 
			Colon 
			TypeID 
			assignTkn 
			ConstOnlyExpr 
			Semicolon
			{
				_here;
				assert( $<s>1 != NULL );
				assert( $<s>3 != NULL );
				
				/*
				** Check to see if TypeID is an array type and if
				** ConstOnlyExpr is also an array value (array ID).
				*/
					 
				_if( $<s>3->pType == tArray && $<v.pType>5 == tArray )

					/*
					** If they are compatible arrays, then assign
					** ConstOnlyExpr's value to the Local ID, else
					** print an appropriate error message.
					*/

					_if
					( 
						ArraysAreCompatible
						( 
							YYS $<s>3, 
							YYS &$<v>5 
						)
					)

						SetSym
						( 
							$<s>1,
							GetBaseType( $<s>3 ), 
							tArray, 
							$<s>3->Arity,
							DupDims( $<s>3 ),
							$<s>3->NumElements, 
							YYS &$<v>5,
							$<s>3->ObjectSize,
							0,
							NULL,
							$<s>3->Base,
							$<s>3->Fields,
							$<s>3->FieldCnt,
							$<s>3->CurField,
							$<s>3->CurIndex
						);
						
					_else

						yyerror
						( 
							"Type mismatch of operands or "
							"value out of range in declaration" 
						);
						FreeValue( YYS &$<v>5 );


					_endif

				/*
				** If it's not an array, check to see if it is
				** a record.
				*/

				_elseif( $<s>3->pType == tRecord && $<v.pType>5 == tRecord )

					_if
					( 
						RecordsAreCompatible
						( 
							$<s>3, 
							YYS &$<v>5 
						)
					)

						SetSym
						( 
							$<s>1, 
							GetBaseType( $<s>3 ),
							tRecord, 
							$<s>3->Arity,
							$<s>3->Dimensions,
							$<s>3->NumElements, 
							YYS &$<v>5,
							$<s>3->ObjectSize,
							0,
							NULL,
							$<s>3->Base,
							$<s>3->Fields,
							$<s>3->FieldCnt,
							$<s>3->CurField,
							$<s>3->CurIndex
						);

					_else

						yyerror
						( 
							"Type mismatch of operands. Expected "
							"compatible record types" 
						);
						FreeValue( YYS &$<v>5 );

					_endif





				/*
				** If it's not an array or record, check to see if it is
				** a union.
				*/

				_elseif
				( 
						$<s>3->pType == tUnion 
					&&	$<v.pType>5 == tUnion
					&&	GetBaseType( $<s>3 ) == GetBaseType( $<v.Type>5 )
				)

					SetSym
					( 
						$<s>1, 
						GetBaseType( $<s>3 ),
						tRecord, 
						0,					// Arity
						NULL,				// Dimensions
						0,					// NumElements
						YYS &$<v>5,
						$<s>3->ObjectSize,
						$<v.Offset>5,		// Index of selected field.
						NULL,
						$<v.Base>5,
						$<v.Fields>5,
						$<v.FieldCnt>5,
						$<v.CurField>5,
						$<v.CurIndex>5
					);







				/*
				** If TypeID and/or ConstOnlyExpr are not arrays, see if
				** they are primitive types.
				*/

				_elseif( IsNotPrimType( $<s>3->pType ))

					yyerror( "Values can only have primitive types" );
					FreeValue( YYS &$<v>5 );

				/*
				** If they are primitive types, see if they are type
				** compatible.  Set the value of the LocalID if they
				** are compatible.
				*/

				_elseif( IsCompatible( $<s>3, YYS &$<v>5 ))

					SetSym
					( 
						$<s>1,
						GetBaseType( $<s>3 ), 
						$<s>3->pType, 
						0,
						NULL,
						0, 
						YYS &$<v>5,
						$<s>3->ObjectSize,
						0,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt,
						$<s>3->CurField,
						$<s>3->CurIndex
					);

				_else

					yyerror
					( 
						"Type mismatch of operands or "
						"value out of range in declaration" 
					);
					FreeValue( YYS &$<v>5 );

				_endif
				_here;
			}
		;



// Special case for regular expressions

ValueRedef:	
		DefinedConstID	/* $1 */ 
		Colon 			/* $2 */
		TypeID 			/* $3 */
		assignTkn 		/* $4 */
		regexconst 		/* $5 */
		Semicolon		/* $6 */
		{
			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );
			
			_if( $<s>3->pType != tRegex )
			
				yyerror( "Type mismatch, expected REGEX object" );
				
			_else
			
				SetSym
				( 
					$<s>1, 
					&regex_ste,
					tRegex, 
					0,
					NULL,
					0, 
					YYS &$<v>5,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0,
					NULL,
					0 
				);
			
			_endif
			}
		;




			/*
			** Array value defintions:
			** e.g., b:integer[4] := ConstOnlyExpr;
			**
			*/

ValueRedef:	lclUndefID 
			Colon
			TypeID 
			'[' 
			DimList 
			Rbrack 
			{
				_here;
				assert( $<idStr>1 != NULL );
				assert( $<s>3 != NULL );

				/*
				** Set up some common synthesized attribute return values.
				*/

				$<v.pType>$ = tArray;
				$<v.Arity>$ = $<s>3->Arity + $<v.Arity>5;
				$<v.Base>$ = $<s>3->Base;
				$<v.Fields>$ = $<s>3->Fields;
				$<v.FieldCnt>$ = $<s>3->FieldCnt;
				$<v.Type>$ =GetBaseType( $<s>3 );

				/*
				** Scream if the user is trying to define a text array.
				*/

				_if( $<s>3->pType == tText )

					yyerror( "Cannot have TEXT arrays" );
					$<s>3 = &string_ste;

				_endif

				/*
				** If it's not a primitive scalar type, complain about
				** that and then fake a usable type.
				*/

				_if( !CanBeVal( $<s>3->pType ))

					yyerror( "Values can only have primitive types" );
					$<s>3 = &uns32_ste;

				_endif

				/*
				** If the TypeID isn't an array object, this is easy;
				** Just return the size of the array constant list.
				*/

				_if( $<s>3->pType != tArray )
				
					$<v.NumElements>$ = $<v.NumElements>5;
					$<v.Dimensions>$ = $<v.Dimensions>5;
 
				/*
				** On the other hand, if TypeID is an array object,
				** then we've got to add a new list of dimensions onto
				** the end of the TypeID list.
				*/

				_else

					/*
					** Compute the number of dimensions and elements in
					** the new type.
					*/

					$<v.NumElements>$ = 
							$<s>3->NumElements * $<v.NumElements>5;

					$<v.Dimensions>$ =
						malloc2( $<v.Arity>$ * sizeof( int ));
 

					/*
					** Copy TypeID's dimensions to our Dimensions array.
					*/
					
					assert( $<s>3->Dimensions != NULL );
					memcpy
					( 
						$<v.Dimensions>$, 
						$<s>3->Dimensions,
						$<s>3->Arity * sizeof( int )
					);

					/*
					** Concatenate the explict dimensions list to the end
					** of our Dimensions array.
					*/
					 
					assert( $<v.Dimensions>5 != NULL );
					memcpy
					(
						$<v.Dimensions>$ +	$<s>3->Arity,
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);

					/*
					** We're done with the explict list, so free it.
					*/

					free2( vss $<v.Dimensions>5 );

				_endif
				$<v.u.ArrayOfValues>$ = NULL;
				_here;
			}
			assignTkn 
			ConstOnlyExpr 
			Semicolon
			{
 				_here;
				_if( $<v.pType>9 == tArray )

					/*
					** Check to see if the list of array values specified
					** by the user is type and count compatible with the
					** array type specified by the TypeID and the explicit
					** dimensions list.	If so, insert the constant into
					** the symbol table.
					*/

					_if
					( 
						ArraysAreCompatible
						( 
							YYS &$<v>7, 
							YYS &$<v>9 
						)
					)

						InsertSym
						( 
							$<idStr>1, 
							$<v.Type>7,
							tArray, 
							cValue, 
							$<v.Arity>7,
							$<v.Dimensions>7,
							$<v.NumElements>7,
							YYS &$<v>9,
							$<s>3->ObjectSize * $<v.NumElements>5,
							0,
							NULL,
							$<v.Base>7,
							$<v.Fields>7,
							$<v.FieldCnt>7
						);


					_else

						/*
						** At this point either the types of the elements do
						** not agree or the number of elements do not agree.
						** Figure out which and print the appropriate error 
						** msg.
						*/

						_if
						( 
								$<v.NumElements>7 == $<v.NumElements>9
							||	$<s>3->pType == tText 
						)

							yyerror( "Type mismatch in operands" );

						_else

							yyerror
							( 
								"The number of array elements do not match" 
							);

						_endif
						_if( $<v.pType>9 == tArray )
						
							FreeValue( YYS &$<v>9 );

						_endif
						free2( vss $<v.Dimensions>7 );

					_endif

				_else

					yyerror( "Expected array expression" );
					_if( $<v.pType>9 == tArray )
					
						FreeValue( YYS &$<v>9 );

					_endif
					free2( vss $<v.Dimensions>7 );

				_endif
				_here;
			}
												


			/*
			** Array value redefintions:
			** e.g., b:integer[4] := [1,2,3,4]; (assumes b already exists.)
			**
			**
			** Note: See the preceding production for comments on this code.
			*/

		|	DefinedConstID 
			Colon
			TypeID 
			'[' 
			DimList 
			Rbrack 
			{
				_here;
				assert( $<s>1 != NULL );
				assert( $<s>3 != NULL );

				/*
				** Set up some common synthesized attribute return values.
				*/

				$<v.pType>$ = tArray;
				$<v.Arity>$ = $<s>3->Arity + $<v.Arity>5;
				$<v.Base>$ = $<s>3->Base;
				$<v.Fields>$ = $<s>3->Fields;
				$<v.FieldCnt>$ = $<s>3->FieldCnt;
				$<v.Type>$ =GetBaseType( $<s>3 );

				/*
				** Scream if the user is trying to define a text array.
				*/

				_if( $<s>3->pType == tText )

					yyerror( "Cannot have TEXT arrays" );
					$<s>3 = &string_ste;

				_endif

				/*
				** If it's not a primitive scalar type, complain about
				** that and then fake a usable type.
				*/

				_if( !CanBeVal( $<s>3->pType ))

					yyerror( "Values can only have primitive types" );
					$<s>3 = &uns32_ste;

				_endif

				/*
				** If the TypeID isn't an array object, this is easy;
				** Just return the size of the array constant list.
				*/

				_if( $<s>3->pType != tArray )
				
					$<v.NumElements>$ = $<v.NumElements>5;
					$<v.Dimensions>$ = $<v.Dimensions>5;
 
				/*
				** On the other hand, if TypeID is an array object,
				** then we've got to add a new list of dimensions onto
				** the end of the TypeID list.
				*/

				_else

					/*
					** Compute the number of dimensions and elements in
					** the new type.
					*/

					$<v.NumElements>$ = 
							$<s>3->NumElements * $<v.NumElements>5;

					$<v.Dimensions>$ =
						malloc2( $<v.Arity>$ * sizeof( int ));
 

					/*
					** Copy TypeID's dimensions to our Dimensions array.
					*/
					
					assert( $<s>3->Dimensions != NULL );
					memcpy
					( 
						$<v.Dimensions>$, 
						$<s>3->Dimensions,
						$<s>3->Arity * sizeof( int )
					);

					/*
					** Concatenate the explict dimensions list to the end
					** of our Dimensions array.
					*/
					 
					assert( $<v.Dimensions>5 != NULL );
					memcpy
					(
						$<v.Dimensions>$ +	$<s>3->Arity,
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);

					/*
					** We're done with the explict list, so free it.
					*/

					free2( vss $<v.Dimensions>5 );

				_endif
				$<v.u.ArrayOfValues>$ = NULL;
				_here;
			}
			assignTkn 
			ConstOnlyExpr 
			Semicolon
			{
 				_here;
				_if( $<v.pType>9 == tArray )

					/*
					** Check to see if the list of array values specified
					** by the user is type and count compatible with the
					** array type specified by the TypeID and the explicit
					** dimensions list.	If so, insert the constant into
					** the symbol table.
					*/

					_if
					( 
						ArraysAreCompatible
						( 
							YYS &$<v>7, 
							YYS &$<v>9 
						)
					)

						SetSym
						( 
							$<s>1, 
							$<v.Type>7,
							tArray, 
							$<v.Arity>7,
							$<v.Dimensions>7,
							$<v.NumElements>7,
							YYS &$<v>9,
							$<s>3->ObjectSize * $<v.NumElements>5,
							0,
							NULL,
							$<v.Base>7,
							$<v.Fields>7,
							$<v.FieldCnt>7,
							$<v.CurField>7,
							$<v.CurIndex>7
						);


					_else

						/*
						** At this point either the types of the elements do
						** not agree or the number of elements do not agree.
						** Figure out which and print the appropriate error 
						** msg.
						*/

						_if
						( 
								$<v.NumElements>7 == $<v.NumElements>9
							||	$<s>3->pType == tText 
						)

							yyerror( "Type mismatch in operands" );

						_else

							yyerror
							( 
								"The number of array elements do not match" 
							);

						_endif
						_if( $<v.pType>9 == tArray )
						
							FreeValue( YYS &$<v>9 );

						_endif
						free2( vss $<v.Dimensions>7 );

					_endif

				_else

					yyerror( "Expected array expression" );
					_if( $<v.pType>9 == tArray )
					
						FreeValue( YYS &$<v>9 );

					_endif
					free2( vss $<v.Dimensions>7 );

				_endif
				_here;
			
			}
		;



	
	/*
	** Open array value definitions:
	**
	** e.g., b:integer[] := [1,2,3,4];
	**
	*/
	
ValueRedef: 
		lclUndefID	/* $1 */
		Colon		/* $2 */
		TypeID 		/* $3 */
		'[' 		/* $4 */
		Rbrack 		/* $5 */
		{			/* $6 */
		
			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );
			/*
			** Scream if the user is trying to define a text array.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;

			_endif

			/*
			** If it's not a primitive scalar type, complain about
			** that and then fake a usable type.
			*/

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				$<s>3 = &uns32_ste;

			_endif
			_here;
		}
		assignTkn		/* $7  */ 
		ConstOnlyExpr 	/* $8  */
		Semicolon		/* $9  */
		{				/* $10 */

			int		i;
			char	IsValid;

			_here;
			_if( $<v.pType>8 != tArray )
			
				yyerror( "Expected array expression" );
				FreeValue( YYS &$<v>8 );
			
			_else				
			
				/*
				** There are two cases we need to consider here:
				**
				**	1.	The base type of the constant is a scalar
				**		type.  For this case, we simply give the
				**		constant type the same number of elements
				**		as the array constant.
				**
				**	2.	The base type of the constant is an array type.
				**		In this case we have to make sure that the
				**		number of elements in the array constant is
				**		an even multiple of the number of elements in
				**		the array type.
				*/
				
				_if( $<s>3->pType != tArray )
				
					/*
					** Okay, we've got the simple case where we
					** just copy the data from the expression into
					** the new constant object. But first, let's make sure 
					** that the elements of this array are compatible with
					** the base type of the array constant object:
					*/
					
					
					IsValid = 1;
					i = 0;
					_do
					
						/*
						** Verify that each element of the array expression
						** is compatible with our destination type:
						*/
						
						IsValid = 
								IsValid 
							&&	IsCompatible
								(
									GetBaseType( $<s>3 ),
									YYS &$<v.u.ArrayOfValues>8[i] 
								);
								
						++i;
						
					_until( i >= $<v.NumElements>8 || !IsValid )
					
					_if( IsValid )
					
						InsertSym
						( 
							$<idStr>1, 
							GetBaseType( $<s>3 ),
							tArray, 
							cValue, 
							1,							/* Arity		*/
							malloc2( sizeof( int )),	/* Dimensions	*/
							$<v.NumElements>8,			/* NumElements	*/
							NULL,						/* Value		*/
							0,							/* ObjectSize	*/
							0,							/* Offset		*/
							NULL,						/* Static Name	*/
							$<v.Base>8,					/* Base Type	*/
							$<v.Fields>8,				/* Field list	*/
							$<v.FieldCnt>8				/* Num Fields	*/
						);
						
						/*
						** Allocate storage to hold the data:
						*/
						
						SymbolTable->u.ArrayOfValues = 
							malloc2
							( 
								$<v.NumElements>8 * sizeof( struct SymNode )
							);
							
						/*
						** Copy the data from the array constant expression
						** to the array object we've just created:
						*/
						
						_for( i=0, i < $<v.NumElements>8, ++i )
						
							DeepCopy
							( 
								&SymbolTable->u.ArrayOfValues[i], 
								&$<v.u.ArrayOfValues>8[i]
							);
							
						_endfor
						
						/*
						** Set up the size information for this constant array:
						*/
						
						SymbolTable->Dimensions[0] = $<v.NumElements>8;
						SymbolTable->ObjectSize = 
							$<s>3->ObjectSize * $<v.NumElements>8;
							
						
						
					_else
					
						yyerror( "Type mismatch in operands" );
					
					_endif


				_else
				
					/*
					** Okay, the base type of the constant object is
					** an array type.  This means that the number
					** of elements in the constant expression must
					** be an even multiple of the number of elements
					** in the base type.
					*/
					
					_if
					(
							$<s>3->NumElements >= $<v.NumElements>8
						||	( $<v.NumElements>8 % $<s>3->NumElements ) != 0
					)
					
						yyerror
						( 
							"Array constant has bad number of elements"
						);
						
					_else

						IsValid = 1;
						i = 0;
						_do
						
							/*
							** Verify that each element of the array expression
							** is compatible with our destination type:
							*/
							
							IsValid = 
									IsValid 
								&&	IsCompatible
									(
										GetBaseType( $<s>3 ),
										YYS &$<v.u.ArrayOfValues>8[i] 
									);
									
							++i;
							
						_until( i >= $<v.NumElements>8 || !IsValid )
						
						_if( IsValid )
						
							InsertSym
							( 
								$<idStr>1, 
								GetBaseType( $<s>3 ),
								tArray, 
								cValue, 
								$<s>3->Arity + 1,			
								malloc2( sizeof( int ) * ($<s>3->Arity + 1)),
								$<v.NumElements>8,			
								NULL,						
								0,							
								0,							
								NULL,						
								$<v.Base>8,					
								$<v.Fields>8,				
								$<v.FieldCnt>8				
							);
							
							/*
							** Allocate storage to hold the data:
							*/
							
							SymbolTable->u.ArrayOfValues = 
								malloc2
								( 
									$<v.NumElements>8 * sizeof( struct SymNode )
								);
								
							/*
							** Copy the data from the array constant expression
							** to the array object we've just created:
							*/
							
							_for( i=0, i < $<v.NumElements>8, ++i )
							
								DeepCopy
								( 
									&SymbolTable->u.ArrayOfValues[i], 
									&$<v.u.ArrayOfValues>8[i]
								);
								
							_endfor
							
							/*
							** Set up the size information for this 
							** constant array:
							*/
												
							_for( i = 0, i < SymbolTable->Arity - 1, ++i )
							
								SymbolTable->Dimensions[i] = 
									$<s>3->Dimensions[i];
									
							_endfor
							SymbolTable->Dimensions[ SymbolTable->Arity - 1 ] =
								$<v.NumElements>8 / $<s>3->NumElements;
								
							SymbolTable->ObjectSize = 
								$<s>3->Type->ObjectSize * $<v.NumElements>8;
								
							
							
						_else
						
							yyerror( "Type mismatch in operands" );
						
						_endif

					
					_endif


				_endif

			_endif
			FreeValue( YYS &$<v>8 );

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;		
		}
	;
												






												


	
	/*
	** Open array value redefinitions:
	**
	** e.g., b:integer[] := [1,2,3,4];
	**
	*/
	
ValueRedef: 
		DefinedConstID 	/* $1 */
		Colon			/* $2 */
		TypeID 			/* $3 */
		'[' 			/* $4 */
		Rbrack 			/* $5 */
		{				/* $6 */
		
			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );
			/*
			** Scream if the user is trying to define a text array.
			*/

			_if( $<s>3->pType == tText )

				yyerror( "Cannot have TEXT arrays" );
				$<s>3 = &string_ste;

			_endif

			/*
			** If it's not a primitive scalar type, complain about
			** that and then fake a usable type.
			*/

			_if( !CanBeVal( $<s>3->pType ))

				yyerror( "Values can only have primitive types" );
				$<s>3 = &uns32_ste;

			_endif
			_here;
		}
		assignTkn		/* $7  */ 
		ConstOnlyExpr 	/* $8  */
		Semicolon		/* $9  */
		{				/* $10 */

			int		i;
			char	IsValid;

			_here;
			_if( $<v.pType>8 != tArray )
			
				yyerror( "Expected array expression" );
				FreeValue( YYS &$<v>8 );
			
			_else				
			
				/*
				** There are two cases we need to consider here:
				**
				**	1.	The base type of the constant is a scalar
				**		type.  For this case, we simply give the
				**		constant type the same number of elements
				**		as the array constant.
				**
				**	2.	The base type of the constant is an array type.
				**		In this case we have to make sure that the
				**		number of elements in the array constant is
				**		an even multiple of the number of elements in
				**		the array type.
				*/
				
				_if( $<s>3->pType != tArray )
				
					/*
					** Okay, we've got the simple case where we
					** just copy the data from the expression into
					** the new constant object. But first, let's make sure 
					** that the elements of this array are compatible with
					** the base type of the array constant object:
					*/
					
					
					IsValid = 1;
					i = 0;
					_do
					
						/*
						** Verify that each element of the array expression
						** is compatible with our destination type:
						*/
						
						IsValid = 
								IsValid 
							&&	IsCompatible
								(
									GetBaseType( $<s>3 ),
									YYS &$<v.u.ArrayOfValues>8[i] 
								);
								
						++i;
						
					_until( i >= $<v.NumElements>8 || !IsValid )
					
					_if( IsValid )
					
						int *dimensions = malloc2( sizeof(int));
					
						SetSym
						( 
							$<s>1, 
							GetBaseType( $<s>3 ),
							tArray, 
							1,							/* Arity		*/
							dimensions,					/* Dimensions	*/
							$<v.NumElements>8,			/* NumElements	*/
							NULL,						/* Value		*/
							0,							/* ObjectSize	*/
							0,							/* Offset		*/
							NULL,						/* Static Name	*/
							$<v.Base>8,					/* Base Type	*/
							$<v.Fields>8,				/* Field list	*/
							$<v.FieldCnt>8,				/* Num Fields	*/
							$<v.Fields>8,				/* Current Field*/
							0							/* CurfieldIndx */
						);
						
						/*
						** Allocate storage to hold the data:
						*/
						
						$<s>1->u.ArrayOfValues = 
							malloc2
							( 
								$<v.NumElements>8 * sizeof( struct SymNode )
							);
							
						/*
						** Copy the data from the array constant expression
						** to the array object we've just created:
						*/
						

						_for( i=0, i < $<v.NumElements>8, ++i )
						
							DeepCopy
							( 
								&$<s>1->u.ArrayOfValues[i], 
								&$<v.u.ArrayOfValues>8[i]
							);
							
						_endfor
						
						/*
						** Set up the size information for this constant array:
						*/
						
						$<s>1->Dimensions[0] = $<v.NumElements>8;
						$<s>1->ObjectSize = 
							$<s>3->ObjectSize * $<v.NumElements>8;
							
						
						
					_else
					
						yyerror( "Type mismatch in operands" );
					
					_endif


				_else
				
					/*
					** Okay, the base type of the constant object is
					** an array type.  This means that the number
					** of elements in the constant expression must
					** be an even multiple of the number of elements
					** in the base type.
					*/
					
					_if
					(
							$<s>3->NumElements >= $<v.NumElements>8
						||	( $<v.NumElements>8 % $<s>3->NumElements ) != 0
					)
					
						yyerror
						( 
							"Array constant has bad number of elements"
						);
						
					_else

						IsValid = 1;
						i = 0;
						_do
						
							/*
							** Verify that each element of the array expression
							** is compatible with our destination type:
							*/
							
							IsValid = 
									IsValid 
								&&	IsCompatible
									(
										GetBaseType( $<s>3 ),
										YYS &$<v.u.ArrayOfValues>8[i] 
									);
									
							++i;
							
						_until( i >= $<v.NumElements>8 || !IsValid )
						
						_if( IsValid )
						
							SetSym
							( 
								$<s>1, 
								GetBaseType( $<s>3 ),
								tArray, 
								$<s>3->Arity + 1,			
								malloc2( sizeof( int ) * ($<s>3->Arity + 1)),	
								$<v.NumElements>8,			
								NULL,						
								0,							
								0,							
								NULL,						
								$<v.Base>8,					
								$<v.Fields>8,				
								$<v.FieldCnt>8,				
								$<v.Fields>8,  
								0
							);
							
							/*
							** Allocate storage to hold the data:
							*/
							
							$<s>1->u.ArrayOfValues = 
								malloc2
								( 
									$<v.NumElements>8 * sizeof( struct SymNode )
								);
								
							/*
							** Copy the data from the array constant expression
							** to the array object we've just created:
							*/
							
							_for( i=0, i < $<v.NumElements>8, ++i )
							
								DeepCopy
								( 
									&$<s>1->u.ArrayOfValues[i], 
									&$<v.u.ArrayOfValues>8[i]
								);
								
							_endfor
							
							/*
							** Set up the size information for this 
							** constant array:
							*/
												
							_for( i = 0, i < $<s>1->Arity - 1, ++i )
							
								$<s>1->Dimensions[i] = 
									$<s>3->Dimensions[i];
									
							_endfor
							$<s>1->Dimensions[ $<s>1->Arity - 1 ] =
								$<v.NumElements>8 / $<s>3->NumElements;
								
							$<s>1->ObjectSize = 
								$<s>3->Type->ObjectSize * $<v.NumElements>8;
								
							
							
						_else
						
							yyerror( "Type mismatch in operands" );
						
						_endif

					
					_endif


				_endif

			_endif
			FreeValue( YYS &$<v>8 );

			/*
			** "Prime" fastLookup for the next identifier we encounter:
			*/
			
			fastLookup = 1;
			_here;		
		}
	;
												






												





			/*
			** Array value definitions:
			** e.g., b:integer[4];
			**
			*/

					
ValueRedef:	lclUndefID 
			Colon
			TypeID 
			'[' 
			DimList 
			Rbrack  
			Semicolon
			{
				_here;
				assert( $<idStr>1 != NULL );
				assert( $<s>3 != NULL );

				/*
				** Initialize some common synthesized attributes.
				*/

				$<v.pType>$ 	= tArray;
				$<v.Arity>$ 	= $<s>3->Arity + $<v.Arity>5;
				$<v.Type>$  	= GetBaseType( $<s>3 );
				$<v.Base>$		= $<s>3->Base;
				$<v.Fields>$	= $<s>3->Fields;
				$<v.FieldCnt>$	= $<s>3->FieldCnt;


				/*
				** Text arrays are illegal.
				*/

				_if( $<s>3->pType == tText )

					yyerror( "Cannot have TEXT arrays" );
					$<s>3 = &string_ste;


				/*
				** Make sure this is a legal constant type.
				*/

				_elseif( !CanBeVal( $<s>3->pType ))

					yyerror( "Values can only have primitive types" );
					$<s>3 = &string_ste;

				_else

					/*
					** If TypeID is a scalar type, just use the
					** DimList attributes.
					*/

					_if( $<s>3->pType != tArray )
					
						$<v.NumElements>$ = $<v.NumElements>5;
						$<v.Dimensions>$ = $<v.Dimensions>5;

					/*
					** If TypeID is an array type, we need to
					** combine TypeID with DimList to produce
					** a larger array.
					*/

					_else


						$<v.NumElements>$ = 
								$<s>3->NumElements * $<v.NumElements>5;

						$<v.Dimensions>$ =
							malloc2( $<v.Arity>$ * sizeof( int ));
	 
						assert( $<s>3->Dimensions != NULL );
						memcpy
						( 
							$<v.Dimensions>$, 
							$<s>3->Dimensions,
							$<s>3->Arity * sizeof( int )
						);

						assert( $<v.Dimensions>5 != NULL );
						memcpy
						(
							$<v.Dimensions>$ +	$<s>3->Arity,
							$<v.Dimensions>5,
							$<v.Arity>5 * sizeof( int )
						);
						free2( vss $<v.Dimensions>5 );

					_endif

					ClrNewSym
					( 
						$<idStr>1, 
						$<v.Type>$,
						tArray, 
						cValue, 
						$<v.Arity>$,
						$<v.Dimensions>$,
						$<v.NumElements>$,
						$<s>3->ObjectSize * $<v.NumElements>5,
						0,
						NULL,
						$<v.Base>$,
						$<v.Fields>$,
						$<v.FieldCnt>$,
						$<v.CurField>$,
						$<v.CurIndex>$
					);

				_endif
				_here;
			}

			/*
			** Array const redefintions:
			** e.g., b:integer[4]; (assumes b already exists.)
			**
			** Similar to the previous section.  See that production
			** for comments.
			**
			*/
			
					
		|	DefinedConstID 
			Colon
			TypeID 
			'[' 
			DimList 
			Rbrack  
			Semicolon
			{
				_here;
				assert( $<s>1 != NULL );
				assert( $<s>3 != NULL );

				/*
				** Initialize some common synthesized attributes.
				*/

				$<v.pType>$ 	= tArray;
				$<v.Arity>$ 	= $<s>3->Arity + $<v.Arity>5;
				$<v.Type>$  	= GetBaseType( $<s>3 );
				$<v.Base>$		= $<s>3->Base;
				$<v.Fields>$	= $<s>3->Fields;
				$<v.FieldCnt>$	= $<s>3->FieldCnt;


				/*
				** Text arrays are illegal.
				*/

				_if( $<s>3->pType == tText )

					yyerror( "Cannot have TEXT arrays" );
					$<s>3 = &string_ste;


				/*
				** Make sure this is a legal constant type.
				*/

				_elseif( !CanBeVal( $<s>3->pType ))

					yyerror( "Values can only have primitive types" );
					$<s>3 = &string_ste;

				_else

					/*
					** If TypeID is a scalar type, just use the
					** DimList attributes.
					*/

					_if( $<s>3->pType != tArray )
					
						$<v.NumElements>$ = $<v.NumElements>5;
						$<v.Dimensions>$ = $<v.Dimensions>5;

					/*
					** If TypeID is an array type, we need to
					** combine TypeID with DimList to produce
					** a larger array.
					*/

					_else


						$<v.NumElements>$ = 
								$<s>3->NumElements * $<v.NumElements>5;

						$<v.Dimensions>$ =
							malloc2( $<v.Arity>$ * sizeof( int ));
	 
						assert( $<s>3->Dimensions != NULL );
						memcpy
						( 
							$<v.Dimensions>$, 
							$<s>3->Dimensions,
							$<s>3->Arity * sizeof( int )
						);

						assert( $<v.Dimensions>5 != NULL );
						memcpy
						(
							$<v.Dimensions>$ +	$<s>3->Arity,
							$<v.Dimensions>5,
							$<v.Arity>5 * sizeof( int )
						);
						free2( vss $<v.Dimensions>5 );

					_endif

					ClrSym
					( 
						$<s>1, 
						$<v.Type>$,
						tArray, 
						$<v.Arity>$,
						$<v.Dimensions>$,
						$<v.NumElements>$,
						$<s>3->ObjectSize * $<v.NumElements>5,
						0,
						NULL,
						$<v.Base>$,
						$<v.Fields>$,
						$<v.FieldCnt>$,
						$<v.CurField>$,
						$<v.CurIndex>$
					);

				_endif
				_here;
			}
		;


 /*
 ** Handle statements of the form "array[ConstOnlyExpr] := ConstOnlyExpr"
 */

ValueRedef:	
		ArrayAdrs 
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			_if( $<v.u.PtrToValue>1 != NULL )

				_if( $<v.pType>1 == tArray )

					_if
					( 
						ArraysAreCompatible
						( 
							YYS &$<v>1, 
							YYS &$<v>3 
						)
					)


						_for( int i=0, i < $<v.NumElements>1, ++i )
						
							DeepCopy
							(
									&$<v.u.PtrToValue>1[i],
									&$<v.u.ArrayOfValues>3[i]
							);

						_endfor

					_elseif( $<v.NumElements>1 == $<v.NumElements>3 )

							yyerror( "Type mismatch in operands" );

					_else

						yyerror
						( 
							"The number of array elements do not match"
						);

					_endif
					FreeValue( YYS &$<v>3 );


				_elseif( $<v.pType>1 == tRecord )

					_if
					( 
						RecordsAreCompatible
						( 
							&$<v>1, 
							YYS &$<v>3 
						)
					)
			
						_for( int i=0, i < $<v.FieldCnt>3, ++i )

							DeepCopy
							(
									&$<v.u.PtrToValue>1->u.FieldValues[i],
									&$<v.u.FieldValues>3[i]
							);

						_endfor

					_else

						yyerror
						( 
							"The records/unions are incompatible"
						);

					_endif
					FreeValue( YYS &$<v>3 );



				_elseif
				( 
						$<v.pType>1 == tUnion
					&&	$<v.pType>3 == tUnion
					&&	GetBaseType( $<v.Type>1 ) == 
							GetBaseType( $<v.Type>3 ) 
				)

					_for( int i=0, i < $<v.FieldCnt>3, ++i )

						// Note: A deep copy was already done on
						// the constant, no need to repeat that here.
											
						FreeValue( YYS &$<v.u.PtrToValue>1->u.FieldValues[i] );
						$<v.u.PtrToValue>1->u.FieldValues[i] =
							$<v.u.FieldValues>3[i];

					_endfor
					$<v.u.PtrToValue>1->CurField = $<v.CurField>3;
					$<v.u.PtrToValue>1->CurIndex = $<v.CurIndex>3;


				_else /* Must be a scalar value */

					memcpy
					( 
						&$<v.u.PtrToValue>1->u.StartOfValues, 
						&$<v.u.StartOfValues>3, 
						sizeof( union ValuesSize )
					);

				_endif

			_endif
			_here;
		}
	;





			/*
			** Handle statements of the form "record.field := ConstOnlyExpr"
			**
			*/

ValueRedef:	
		RecordAdrs 
		assignTkn 
		ConstOnlyExpr 
		Semicolon
		{
			_here;
			_if( $<v.u.PtrToValue>1 != NULL )

				_if( $<v.pType>1 == tArray )

					_if
					( 
						ArraysAreCompatible
						( 
							YYS &$<v>1, 
							YYS &$<v>3 
						)
					)


						_for( int i=0, i < $<v.NumElements>1, ++i )

							DeepCopy
							(
								&$<v.u.PtrToValue>1->u.ArrayOfValues[i],
								&$<v.u.ArrayOfValues>3[i]
							);

						_endfor

					_elseif( $<v.NumElements>1 == $<v.NumElements>3 )

						yyerror( "Type mismatch in operands" );

					_else

						yyerror
						( 
							"The number of array elements do not match"
						);

					_endif
					FreeValue( YYS &$<v>3 );


				_elseif( $<v.pType>1 == tRecord )



					_if
					( 
						RecordsAreCompatible
						( 
							&$<v>1, YYS &$<v>3 
						)
					)
			
						_for( int i=0, i < $<v.FieldCnt>3, ++i )

							DeepCopy
							(
									&$<v.u.PtrToValue>1->u.FieldValues[i],
									&$<v.u.FieldValues>3[i]
							);

						_endfor

					_else

						yyerror
						( 
							"The fields are incompatible"
						);

					_endif
					FreeValue( YYS &$<v>3 );


				_elseif
				( 
						$<v.pType>1 == tUnion
					&&	$<v.pType>3 == tUnion
					&&	GetBaseType( $<v.Type>1 ) == 
							GetBaseType( $<v.Type>3 ) 
				)

					_if( $<v.Type>1 == $<v.Type>3 )
					
			
						_for( int i=0, i < $<v.FieldCnt>3, ++i )

							DeepCopy
							(
									&$<v.u.PtrToValue>1->u.FieldValues[i],
									&$<v.u.FieldValues>3[i]
							);

						_endfor

						
					_else
					
						yyerror
						( 
							"The union field and constant are incompatible"
						);
						
						// Need to set up a dummy value to prevent problems:
						
						memcpy
						( 
							$<v.u.PtrToValue>1->u.FieldValues,
							&dummy_ste,
							sizeofSymNode
						);
						$<v.u.PtrToValue>1->u.FieldValues->StaticName = 
							$<v.u.PtrToValue>1->StaticName;
							
						$<v.u.PtrToValue>1->StaticName = NULL;
						$<v.u.PtrToValue>1->u.FieldValues->Offset = $<v.Offset>1;
							
					_endif



				_else /* Must be a scalar value */

					memcpy
					( 
						&$<v.u.PtrToValue>1->u.StartOfValues, 
						&$<v.u.StartOfValues>3, 
						sizeof( union ValuesSize )
					);

				_endif

			_endif
			_here;
		}


		|	error ';' { _here; }

		;

















		
	










/*****************************************************************************/
/*****************************************************************************/
/**********************                           ****************************/
/**********************                           ****************************/
/**********************    V A R I A B L E S      ****************************/
/**********************                           ****************************/
/**********************                           ****************************/
/*****************************************************************************/
/*****************************************************************************/







/***********************************************************/
/*                                                         */
/* The following productions handle variable declarations. */
/*                                                         */
/***********************************************************/

Variables:
			SetInVar
			OptionalVarAlign
			doVariables
			{
				_here;
				inVar = $<v.u.unsval>1;
			}
		;


SetInVar:
		{
			/*
			**	Note: "Variables" productions get used by
			**	records and unions, even when we're not
			**	declaring variables.  Deal with that here.
			**	Also note that Variables is also used by
			**	classes, but we treat those as var dcls.
			*/

			_here;
			$<v.u.unsval>$ = inVar;
			inVar = !(( inRecord || inUnion ) && !inVar );
		}
	;



OptionalVarAlign:

		Empty
		{
			_here;
			MinVarAlignment = 1;
			MaxVarAlignment = 1;
			TempVarAlign = 0;
			HoldOffset = 0;
		}
			
		
	|	assignTkn	/* $1 */
		ConstExpr	/* $2 */
		Semicolon	/* $3 */
		{
			_here;
			_if
			( 
					IsNumber( $<v.pType>2 )
				&&	checkSmallInt( YYS &$<v>2 ) 
			)

				CurOffset = $<v.u.intval>2; 
				HoldOffset = 1;

			_else

				yyerror( "Expected a constant in the range 1..64" );
				HoldOffset = 0;

			_endif
			MinVarAlignment = 1;	// Min alignment
			MaxVarAlignment = 1;	// Max alignment
			TempVarAlign = 0;
			FreeValue( YYS &$<v>2 );
			_here;
		}
			
		
	|	'['			/* $1 */
		ConstExpr	/* $2 */
		Rbrack		/* $3 */
		{
			_here;
			_if
			( 
					IsNumber( $<v.pType>2 )
				&&	checkSmallUns( YYS &$<v>2 ) 
				&&	$<v.u.unsval>2 >= 1
				&&	$<v.u.unsval>2 <= 64
			)

				MinVarAlignment = $<v.u.unsval>2; // Min alignment
				MaxVarAlignment = $<v.u.unsval>2; // Max alignment

			_else

				yyerror( "Expected a constant in the range 1..64" );
				MinVarAlignment = 1;
				MaxVarAlignment = 1;

			_endif
			TempVarAlign = 0;
			HoldOffset = 0;
			FreeValue( YYS &$<v>2 );
			_here;
		}
			
		
	|	'['			/* $1 */
		ConstExpr	/* $2 */
		Rbrack		/* $3 */
		assignTkn	/* $4 */
		ConstExpr	/* $5 */
		Semicolon	/* $6 */
		{
			_here;
			_if
			( 
					IsNumber( $<v.pType>2 )
				&&	checkSmallUns( YYS &$<v>2 ) 
				&&	$<v.u.unsval>2 >= 1
				&&	$<v.u.unsval>2 <= 64
			)

				MinVarAlignment = $<v.u.unsval>2; // Min alignment
				MaxVarAlignment = $<v.u.unsval>2; // Max alignment

			_else

				yyerror( "Expected an alignment constant in the range 1..64" );
				MinVarAlignment = 1;
				MaxVarAlignment = 1;

			_endif
			HoldOffset = 0;
			_if
			( 
					IsNumber( $<v.pType>5 )
				&&	checkSmallInt( YYS &$<v>5 ) 
			)

				CurOffset = $<v.u.intval>5; 
				HoldOffset = 1;

			_else

				yyerror( "Expected an integer constant as starting offset" );

			_endif
			TempVarAlign = 0;
			FreeValue( YYS &$<v>2 );
			FreeValue( YYS &$<v>5 );
			_here;
		}
	
	|	'['			/* $1 */
		ConstExpr	/* $2 */
		':'			/* $3 */
		ConstExpr	/* $4 */
		Rbrack		/* $5 */
		{
			_here;
			_if
			( 
					IsNumber( $<v.pType>2 )
				&&	IsNumber( $<v.pType>4 ) 
				&&	checkSmallUns( YYS &$<v>2 ) 
				&&	checkSmallUns( YYS &$<v>4 ) 
				&&	$<v.u.unsval>2 >= 1
				&&	$<v.u.unsval>2 <= 64
				&&	$<v.u.unsval>4 >= 1
				&&	$<v.u.unsval>4 <= 64
			)
				_if( $<v.u.unsval>2 >= $<v.u.unsval>4 )
				
					MaxVarAlignment = $<v.u.unsval>2; // Max alignment
					MinVarAlignment = $<v.u.unsval>4; // Min alignment
					
				_else
				
					yyerror
					(
						"In VAR alignment, the first (max) value must be "
						"greater or equal to the second (min) value"
					);
					
					// Note that the following swaps the minimum and
					// maximum values:
					
					MinVarAlignment = $<v.u.unsval>2; // Max alignment
					MaxVarAlignment = $<v.u.unsval>4; // Min alignment

				_endif

			_else

				yyerror( "Expected a constant in the range 1..64" );
				MinVarAlignment = 1;
				MaxVarAlignment = 1;

			_endif
			TempVarAlign = 0;
			HoldOffset = 0;
			FreeValue( YYS &$<v>2 );
			FreeValue( YYS &$<v>4 );
			_here;
		}
	
	|	'['			/* $1 */
		ConstExpr	/* $2 */
		':'			/* $3 */
		ConstExpr	/* $4 */
		Rbrack		/* $5 */
		assignTkn	/* $6 */
		ConstExpr	/* $7 */
		Semicolon	/* $8 */
		{
			int align;

			_here;
			_if
			( 
					IsNumber( $<v.pType>2 )
				&&	IsNumber( $<v.pType>4 ) 
				&&	checkSmallUns( YYS &$<v>2 ) 
				&&	checkSmallUns( YYS &$<v>4 ) 
				&&	$<v.u.unsval>2 >= 1
				&&	$<v.u.unsval>2 <= 64
				&&	$<v.u.unsval>4 >= 1
				&&	$<v.u.unsval>4 <= 64
			)
				_if( $<v.u.unsval>2 >= $<v.u.unsval>4 )
				
					MaxVarAlignment = $<v.u.unsval>2; // Max alignment
					MinVarAlignment = $<v.u.unsval>4; // Min alignment
					
				_else
				
					yyerror
					(
						"In VAR alignment, the first (max) value must be "
						"greater or equal to the second (min) value"
					);
					
					// Note that the following swaps the minimum and
					// maximum values:
					
					MinVarAlignment = $<v.u.unsval>2; // Max alignment
					MaxVarAlignment = $<v.u.unsval>4; // Min alignment

				_endif

			_else

				yyerror( "Expected a constant in the range 1..64 for align" );
				MinVarAlignment = 1;
				MaxVarAlignment = 1;

			_endif
			HoldOffset = 0;
			_if
			( 
					IsNumber( $<v.pType>7 )
				&&	checkSmallInt( YYS &$<v>7 ) 
			)

				CurOffset = $<v.u.intval>7; 
				HoldOffset = 1;

			_else

				yyerror( "Expected an integer constant as starting offset" );

			_endif
			TempVarAlign = 0;
			FreeValue( YYS &$<v>2 );
			FreeValue( YYS &$<v>4 );
			FreeValue( YYS &$<v>7 );
			_here;
		}
	;



doVariables:

			Empty
			{
				_here;
			}
			 
		|	 doVariables VariableDef { _here; } 
		;


/*
** VariableDef-
**
**	These productions handle local variable declarations.
*/


VariableDef:

			/*
			** Allow empty declarations (just a semicolon) for
			** syntactical reasons (e.g., to put semicolons after
			** macros and such).
			*/

			';' { _here; }
	;



 /*
 ** Handle the "ID:FORWARD(ID);" declaration to support
 ** macro redeclarations of a symbol.
 */

VariableDef: UndefinedForward;


VariableDef:
		alignTkn	/* $1 */
		Lparen		/* $2 */
		ConstExpr	/* $3 */
		Rparen		/* $4 */
		Semicolon	/* $5 */
		{			/* $6 */

			_here;
			_if( IsNumber( $<v.pType>3 ) && numBits( YYS &$<v>3 ) <= 32 )

				TempVarAlign = $<v.u.unsval>3;

			_else

				yyerror
				( 
					"Expected an integer constant here" 
				);

			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;

			

	

/*
** Handle procedure pointer variables here.
*/

VariableDef:
			UndefinedID		/* $1 */ 
			Colon 			/* $2 */
			procedureTkn 	/* $3 */
			
			/*
			** Before going any farther, save the current
			** (previous lex level) variable offset and offset 
			** direction so we can restore these values when
			** the compiler finishes this declaration.  Note that the
			** compiler saves these values in the attributes of the
			** following grammar symbols.
			*/
			
			SaveOffset		/* $4 */ 
			SaveDirection	/* $5 */

			/*
			** Also, set up the offset and direction values as appropriate
			** for processing parameters.  Then process the optional
			** parameter list.
			*/

			{				/* $6 */
			
				_here;
				assert( $<idStr>1 != NULL );

				/*
				** If a local variable, bump the offset prior to
				** assigning it to the symbol.
				*/
				
				$<v.u.intval>$ = CurOffset;
				_if( AddOffset1st && !HoldOffset )
				
					$<v.u.intval>4 += 4 * CurOffsetDir;

				_endif

				$<v.u.intval>4 = AlignVarOffset( $<v.u.intval>4, 4, CurOffsetDir );
				InsertSym
				( 
					$<idStr>1,
					NULL,			/* Type							*/
					tProcptr, 		/* pType						*/
					cVar, 			/* SymClass						*/
					0,				/* Arity						*/
					NULL,			/* Dimensions					*/
					0, 				/* NumElements					*/
					NULL,			/* Initially, no initialization	*/
					4,				/* Object size					*/
					$<v.u.intval>4,	/* Offset						*/
					NULL,			/* Static Name					*/
					NULL,			/* Base							*/
					NULL,			/* Fields						*/
					0				/* FieldCnt						*/
				);
				$<s>$ = SymbolTable;

				/*
				** If a parameter, bump up the offset after assigning
				** the offset to the symbol.
				*/
				
				_if( !AddOffset1st )
				
					$<v.u.intval>4 += 4 * CurOffsetDir;

				_endif

				CurOffset = StartParmOffs;
				++CurLexLevel;
				
				/*
				** Reinsert the symbol into the local symbols
				** to keep the logic of this program happy.
				*/

				InsertSym
				( 
					$<idStr>1,
					NULL,
					tProcptr, 
					cVar, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);

				/*
				** Temporary assignment so we can patch the local
				** entry later.
				*/

				$<s>$->u.proc.parms = SymbolTable;
				_here;
			}
			OptionalParms	/* $7 	*/ 
			Semicolon		/* $8 	*/
			Options			/* $9   */
			{				/* $10 	*/

				struct	SymNode	*s;
				union	YYSTYPE	value;
				
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>9,
						specified_returns
					|	specified_use
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_alignment 
					|	specified_nostorage
					|	specified_volatile 
				);

				--CurLexLevel;
				_if( $<options.NoStorage>9 )
				
					CurOffset = $<v.u.intval>6;
					
				_else
				
					CurOffset = $<v.u.intval>4;
					
				_endif
				CurOffsetDir = $<v.u.unsval>5;
			 
				/*
				** Initialize the pointer to the end of the parameters
				** for this procedure variable.
				** Set up the offset and direction variables to handle
				** local variable declarations.  
				*/
			 

			
				// Need to create a dummy type to hold the procedure pointer parameters.
				
				s = SymbolTable;
				InsertSym
				( 
					" (procptr parms) ", 
					NULL,
					tProcptr, 
					cType, 
					0,
					NULL,
					0, 
					NULL,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
				SymbolTable->u.proc.parms = s;
				SymbolTable->u.proc.returns = hlastrdup2( "" );
				SymbolTable->u.proc.use = NULL;
				SymbolTable->u.proc.cs = $<options.CallingSequence>9;
				$<s>6->Type = SymbolTable;
				$<s>6->u.proc.parms->Type = SymbolTable;
				
				// Remove the dummy entry from the symbol table:
			
				SymbolTable = s;
				
				// Patch the original symbol table entries:

				$<s>6->u.proc.parms->u.proc.parms = SymbolTable;
				$<s>6->u.proc.parms->u.proc.returns = $<options.returns>9;
				$<s>6->u.proc.parms->u.proc.use = $<options.use>9;

				$<s>6->u.proc.parms = SymbolTable;
				$<s>6->u.proc.returns = $<options.returns>9;
				$<s>6->u.proc.use = $<options.use>9;
				$<s>6->u.proc.cs = $<options.CallingSequence>9;
				
			
				/*
				** Just to be on the safe side, let's create
				** a "parms" and "vars" entry for this object.
				*/
				
				ClrConst
				(
					YYS &value,
					tUns32,
					&uns32_ste
				);
				value.v.u.unsval = $<v.u.unsval>7;
				InsertSym
				( 
					"_parms_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
				value.v.u.unsval = 0;
				InsertSym
				( 
					"_vars_", 
					&uns32_ste,
					tUns32, 
					cConstant, 
					0,
					NULL,
					0, 
					YYS &value,
					4,
					0,
					NULL,
					NULL,
					NULL,
					0
				);
				$<s>6->u.proc.parms->u.proc.Locals = SymbolTable;
				$<s>6->u.proc.Locals = SymbolTable;
							
				SymbolTable = $<s>6;
				_here;
			}
	;


VariableDef:
		UndefinedID		/* $1 */ 
		Colon 			/* $2 */
		pointerTkn		/* $3 */
		toTkn			/* $4 */
		procedureTkn 	/* $5 */
		DefinedID		/* $6 */
		{				/* $7 */
			
			
			_here;
			assert( $<idStr>1 != NULL );

			$<i>$ = CurOffset;
			_if( AddOffset1st && !HoldOffset )
			
				CurOffset += 4 * CurOffsetDir;

			_endif

			CurOffset = AlignVarOffset( CurOffset, 4, CurOffsetDir );
			CreatePtrToProc( $<idStr>1, $<s>6, NULL, cVar );
			_if( !AddOffset1st )
			
				CurOffset += 4 * CurOffsetDir;

			_endif
			_here;
		}
		Semicolon		/* $8 */
		Options			/* $9 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>9 )
			
				CurOffset = $<i>7;
				
			_endif
			_here;
		}
	;





			/*
			** Variable with an enumerated type declaration:
			** e.g., colorVar: enum={red, green, blue};
			**
			** See the corresponding code in the TypeDef
			** productions for comments on how enums work.
			**
			*/

VariableDef:
			UndefinedID 
			Colon 
			enumTkn
			{
				_here;
				assert( $<idStr>1 != NULL );
				 
				/*
				** For local variables, we need to add the object's
				** size the the current offset before saving the
				** offset in the symbol table.  The following code
				** handles that case.
				*/

				_if( AddOffset1st && !HoldOffset )
				
					CurOffset = 
							CurOffset 
						+ 	EnumSize * CurOffsetDir;

				_endif

				CurOffset = 
					AlignVarOffset( CurOffset, EnumSize, CurOffsetDir );

				InsertSym
				( 
					$<idStr>1, 
					NULL,
					tEnum, 
					cVar, 
					0,
					NULL,
					0, 
					NULL,
					EnumSize,
					CurOffset,
					NULL,
					NULL,
					NULL,
					0
				);

				/*
				** For records, unions, parameters, and other such
				** stuff, we need to add the object's size to the
				** CurOffset variable *after* entering the symbol
				** into the symbol table.  This code segment
				** handles that case.
				*/

				_if( !AddOffset1st )
				
					CurOffset = 
							CurOffset 
						+ 	EnumSize * CurOffsetDir;

				_endif

				/*
				** Initialize EnumVal to zero so we can assign
				** successive values to the following named constants.
				*/

				EnumVal = 0;
				_here;
			}
			Lbrace 
			{
				/*
				** Set up an inherited attribute for EnumList.
				** This must be the address of the variable symbol
				** table entry created above.
				*/

				$<v.Type>$ = SymbolTable;
				_here;
			}
			EnumList 
			Rbrace
			Semicolon
			{
				_here;
				(void) $<v.Type>6; // shut up bison
			}
	;





			
// Handle pointer declarations here.
			
VariableDef:
			UndefinedID			/* $1 */
			Colon				/* $2 */
			pointerTkn			/* $3 */
			toTkn				/* $4 */
			AnyID				/* $5 */
			{					/* $6 */

				struct	SymNode		*BaseType;

				_here;
				assert( $<idStr>1 != NULL );
				assert( $<neID.idStr>5 != NULL );

				$<i>$ = CurOffset;
				
				// If processing local vars...
				
				_if( AddOffset1st && !HoldOffset )
				
					CurOffset += 4 * CurOffsetDir;

				_endif

				CurOffset = AlignVarOffset( CurOffset, 4, CurOffsetDir );
				BaseType = $<neID.s>5;
				_if( BaseType != NULL )

					BaseType = GetBaseType( BaseType );
					_if( CantBeVar( BaseType->pType ))

						yyerror( "Variables cannot be this type" );
						BaseType = &uns32_ste;

					_endif

				_endif

				InsertSym
				( 
					$<idStr>1,			/* Name			*/
					&pointer_ste,		/* Type			*/
					tPointer, 			/* pType		*/
					cVar,				/* SymClass		*/
					0,					/* Arity		*/
					NULL,				/* Dimensions	*/
					0, 					/* NumElements	*/
					NULL,				/* Value		*/
					4,					/* ObjectSize	*/
					CurOffset,			/* Offset		*/
					NULL,				/* StaticName	*/
					BaseType,			/* BaseType		*/
					NULL,				/* Fields		*/
					0					/* FieldCnt		*/
				);
				_if( BaseType == NULL )

					Add2PtrList( SymbolTable, $<neID.idStr>5 );

				_endif

				
				// If processing records, unions, parameters, etc.
				
				_if( !AddOffset1st )
				
					CurOffset += 4 * CurOffsetDir;

				_endif
				_here;
			}
			Semicolon			/* $7 */
			Options				/* $8 */
			{
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_nostorage
					|	specified_volatile 
				);
				_if( $<options.NoStorage>8 )
				
					CurOffset = $<i>6;
					
				_endif
				_here;
			}
	;




VariableDef:
			UndefinedID			/* $1 */
			Colon				/* $2 */
			pointerTkn			/* $3 */
			toTkn				/* $4 */
			ReservedTypeIDs		/* $5 */
			{					/* $6 */
				_here;
				assert( $<idStr>1 != NULL );

				$<i>$ = CurOffset;
				
				/*
				** If processing local vars...
				*/

				_if( AddOffset1st && !HoldOffset )
				
					CurOffset += 4 * CurOffsetDir;

				_endif
				CurOffset = AlignVarOffset( CurOffset, 4, CurOffsetDir );
				InsertSym
				( 
					$<idStr>1,			/* Name			*/
					&pointer_ste,		/* Type			*/
					tPointer, 			/* pType		*/
					cVar,				/* SymClass		*/
					0,					/* Arity		*/
					NULL,				/* Dimensions	*/
					0, 					/* NumElements	*/
					NULL,				/* Value		*/
					4,					/* ObjectSize	*/
					CurOffset,			/* Offset		*/
					NULL,				/* StaticName	*/
					$<s>5,				/* BaseType		*/
					NULL,				/* Fields		*/
					0					/* FieldCnt		*/
				);

				/*
				** If processing records, unions, parameters, etc.
				*/

				_if( !AddOffset1st )
				
					CurOffset += 4 * CurOffsetDir;

				_endif
				_here;
			}
			Semicolon			/* $7 */
			Options				/* $8 */
			{
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>8,
						specified_nostorage
					|	specified_volatile 
				);
				_if( $<options.NoStorage>8 )
				
					CurOffset = $<i>6;
					
				_endif
				_here;
			}
	;


			
// Variable declarations using a single type ID:
// e.g., i:int32;

VariableDef:
			UndefinedID			/* $1 */ 
			Colon				/* $2 */ 
			TypeID				/* $3 */ 
			{					/* $4 */

				_here;
				assert( $<idStr>1 != NULL );
				assert( $<s>3 != NULL );
				
				$<i>$ = CurOffset;

				_if( CantBeVar($<s>3->pType ))

					yyerror( "Variables cannot be this type" );

				_else
				
					/*
					** If processing local vars...
					*/

					_if( AddOffset1st && !HoldOffset )
					
						CurOffset += $<s>3->ObjectSize * CurOffsetDir;

					_endif
					CurOffset = 
						AlignVarOffset
						( 
							CurOffset, 
							$<s>3->ObjectSize, 
							CurOffsetDir 
						);
					
					InsertSym
					( 
						$<idStr>1, 
						$<s>3,
						$<s>3->pType, 
						cVar, 
						$<s>3->Arity,
						$<s>3->Dimensions,
						$<s>3->NumElements, 
						NULL,
						$<s>3->ObjectSize,
						CurOffset,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);
					_if( $<s>3->pType == tProcptr )
					
						// Copy parameter info if a proc ptr.
						
						memcpy
						( 
							&SymbolTable->u, 
							&$<s>3->u, 
							sizeof( union ValuesSize )
						);
						
					_endif

					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					_if( $<s>3->pType == tClass )

						SymbolTable->Fields = 
							CopySymbols
							( 
								$<s>3->Fields,
								$<s>3->StaticName
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_elseif(  $<s>3->pType == tThunk )

						/*
						** Need some dummy local vars for a thunk.
						*/

						SymbolTable->u.proc.parms = &true_ste;


					_endif

					/*
					** If the type is a pointer type, we need to check
					** to see if there was a forward reference so we
					** can eventually patch the "Base" field.
					*/

					_if( $<s>3->pType == tPointer && $<s>3->Base == NULL )

						struct PatchListType *pbl;

						pbl = malloc2( sizeof( struct PatchListType ));
						
						pbl->Next = PatchBaseList;
						pbl->Symbol = SymbolTable;
						PatchBaseList = pbl;

						SymbolTable->Type = $<s>3;	/* so we can patch later */

					_endif


					/*
					** If processing records, unions, parameters, etc.
					*/

					_if( !AddOffset1st )
					
						CurOffset += $<s>3->ObjectSize * CurOffsetDir;

					_endif

				_endif
				_here;

			}
			Semicolon			/* $5 */
			Options				/* $6 */
			{
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>6,
						specified_nostorage
					|	specified_volatile 
				);
				_if( $<options.NoStorage>6 )
				
					CurOffset = $<i>4;
					
				_endif
				_here;
			}
	;




	
// Array variable definitions:
// e.g., b:integer[4];
						
VariableDef:
		UndefinedID			/* $1 */ 
		Colon				/* $2 */
		TypeID				/* $3 */ 
		'['					/* $4 */ 
		DimList				/* $5 */ 
		Rbrack				/* $6 */  
		{					/* $7 */

			int	*DimensionArray;
			int	ArraySize;

			_here;
			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );
			assert( $<v.NumElements>5 > 0 );
			assert( $<v.Dimensions>5 != NULL );

			$<i>$ = CurOffset;
			
			/*
			** Make sure this is a legal variable type
			** (e.g., no text variables).
			*/

			_if( CantBeVar( $<s>3->pType ))
			
				yyerror( "Illegal variable type" );
				
			_else 
			
				/*
				** Check to see if TypeID is an array type
				** (i.e., we're creating a multi-dimensional array).
				*/

				_if( $<s>3->pType != tArray )

					/*
					** TypeID is *not* an array type, so create
					** a single dimension array here.
					*/

					ArraySize = $<s>3->ObjectSize * $<v.NumElements>5;

					/*
					** If local variable.
					*/

					_if( AddOffset1st && !HoldOffset )

						CurOffset += ArraySize * CurOffsetDir;

					_endif

					CurOffset = 
						AlignVarOffset
						( 
							CurOffset, 
							ArraySize, 
							CurOffsetDir 
						);
						
					InsertSym
					( 
						$<idStr>1, 
						$<s>3,
						tArray, 
						cVar, 
						$<v.Arity>5,
						$<v.Dimensions>5,
						$<v.NumElements>5, 
						NULL,
						ArraySize,
						CurOffset,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					_if( $<s>3->pType == tClass )

						SymbolTable->Fields = 
							CopySymbols
							( 
								$<s>3->Fields,
								$<s>3->StaticName
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_elseif(  $<s>3->pType == tThunk )

						/*
						** Need some dummy local vars for a thunk.
						*/

						SymbolTable->u.proc.parms = &true_ste;


					_endif

					/*
					** If the type is a pointer type, we need to check
					** to see if there was a forward reference so we
					** can eventually patch the "Base" field.
					*/

					_if( $<s>3->pType == tPointer && $<s>3->Base == NULL )

						struct PatchListType *pbl;

						pbl = malloc2( sizeof( struct PatchListType ));
						
						pbl->Next = PatchBaseList;
						pbl->Symbol = SymbolTable;
						PatchBaseList = pbl;

						/*
						** So we can patch later:
						*/

						SymbolTable->Type = $<s>3;	

					_endif


					/*
					** If not a local variable
					*/

					_if( !AddOffset1st )

						CurOffset += ArraySize * CurOffsetDir;

					_endif


				/*
				** Okay, down here TypeID *is* an array type,
				** so we're creating a multi-dimensional array.
				*/

				_else

					assert( $<s>3->Dimensions != NULL );

					/*
					** Create the new dimension array by concatenating
					** the two existing dimension arrays.
					*/

					DimensionArray = 
						malloc2
						( 
							( $<s>3->Arity + $<v.NumElements>5 ) * 
								sizeof( int )
						);

					memcpy
					( 
						DimensionArray, 
						$<s>3->Dimensions, 
						$<s>3->Arity * sizeof( int )
					);
					memcpy
					(
						&DimensionArray[ $<s>3->Arity ],
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);
					ArraySize = $<s>3->ObjectSize * $<v.NumElements>5;

					/*
					** Add the new array to the symbol table.
					*/

					_if( AddOffset1st && !HoldOffset ) /* If local variable */

						CurOffset += ArraySize * CurOffsetDir;

					_endif

					CurOffset = 
						AlignVarOffset
						( 
							CurOffset, 
							ArraySize,
							CurOffsetDir 
						);
						
					InsertSym
					( 
						$<idStr>1, 
						$<s>3,
						tArray, 
						cVar, 
						$<s>3->Arity + $<v.Arity>5,
						DimensionArray,
						$<s>3->NumElements * $<v.NumElements>5, 
						NULL,
						ArraySize,
						CurOffset,
						NULL,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					_if( $<s>3->pType == tClass )


						SymbolTable->Fields = 
							CopySymbols
							( 
								$<s>3->Fields,
								$<s>3->StaticName
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_elseif(  $<s>3->pType == tThunk )

						/*
						** Need some dummy local vars for a thunk.
						*/

						SymbolTable->u.proc.parms = &true_ste;

					_endif


					_if( !AddOffset1st )	/* If not a local variable */

						CurOffset += ArraySize * CurOffsetDir;

					_endif
					free2( vss $<v.Dimensions>5 );

				_endif

			_endif
			_here;
		}
		Semicolon			/* $8 */
		Options				/* $9 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>9 )
			
				CurOffset = $<i>7;
				
			_endif
		}
	;






			
// Handle record variable declarations here.

VariableDef:
			UndefinedID		/* $1 */
			Colon			/* $2 */
			dorecordTkn		/* $3 */
			recordOpts		/* $4 */
			OptInherits		/* $5 */
			RecordStuff		/* $6 */
			endrecordTkn	/* $7 */
			Semicolon		/* $8 */
			{
				struct	SymNode	*Fields;
				struct	SymNode	*CurSym;
				int				RecSize;
				int				FieldCnt;
				int				LargestField;

				_here;
				
				/*
				** Restore currentNS before we enter this record
				** type into the symbol table.
				*/
				
				currentNS = $<ru.saveCurNS>3;
				RecNS = $<ru.saveRecNS>3;
				RecGlobal = $<ru.saveRecGlobal>3;


				/*
				** Make sure there was at least one field.
				*/

				_if( RecFieldCnt != 0 )


					
					/*
					** If there is no base record, we need to mark
					** the end of the fields symbol list.  If there is
					** a base record, then that base record definition will
					** mark the end of our list.  In either case, we
					** need to count the number of fields in the record.
					**
					** Also compute the size of the largest field
					** (for alignment purposes).
					*/
					
					FieldCnt = 0;
					LargestField = 0;
					CurSym = SymbolTable;
					_while
					( 
							CurSym->Next != NULL 
						&&	CurSym->Next != &dummyField_ste 
					)

						LargestField = 
							max( LargestField, CurSym->MaxObjectSize );
							
						++FieldCnt;
						CurSym = CurSym->Next;

					_endwhile
					LargestField = 
						max( LargestField, CurSym->MaxObjectSize );

					CurSym->Next = NULL;
					
					/*
					** Okay, create the record symbol table entry
					** and attach the fields symbol table to that entry.
					*/

					CurLexLevel = $<ru.SaveLex>3;	
					Fields = SymbolTable;			
					SymbolTable = $<ru.endFields>3;		
					RecSize = CurOffset - $<ru.CurOffset>3;			
				
					/*
					** If there was an align at the end of the
					** record, then we need to extend the size
					** of the record so that it is aligned on
					** the specified boundary.
					*/

					_if( TempRecAlign != 1 )
					

						RecSize = 
								(
										(RecSize + TempRecAlign - 1) 
									/ 	TempRecAlign 
								) * TempRecAlign;
								
						TempRecAlign = 1;

					_endif
					
					


					CurOffset = $<ru.SaveOffset>3;		
					CurOffsetDir = $<ru.SaveDir>3;	
					AddOffset1st = $<ru.SaveAdd1st>3;	

					/*
					** Okay, insert the record symbol into the symbol table
					*/

					_if( AddOffset1st && !HoldOffset )	/* If a local variable */

						CurOffset += RecSize * CurOffsetDir;

					_endif
					CurOffset = 
						AlignVarOffset
						( 
							CurOffset,
							RecSize, 
							CurOffsetDir 
						);

					InsertSym
					(
						$<idStr>1,
						NULL,
						tRecord,
						cVar,
						0,
						NULL,
						0,
						NULL,
						RecSize,
						CurOffset,
						NULL,
						$<ru.base>3,
						Fields,
						FieldCnt
					);
					SymbolTable->MaxObjectSize = LargestField;

					_if( !AddOffset1st )	/* If not a local variable */

						CurOffset += RecSize * CurOffsetDir;

					_endif
					
					// Now we need to go through all the fields and
					// patch the "Parent" field to point at this
					// symbol table entry.
					
					_for( int fieldCntr = 0, fieldCntr < FieldCnt, ++fieldCntr )
					
						Fields->Parent = SymbolTable;
						Fields = Fields->Next;
						
					_endfor
					

				_else

					yyerror
					( 
						"Record variables must have at least one field" 
					);

				_endif
				inRecord = $<ru.inSave>3;
				MinRecAlignment = $<ru.MinRecAlignment>3;
				MaxRecAlignment = $<ru.MaxRecAlignment>3;
				RecFieldCnt = $<ru.RecFieldCnt>3;
				_here;
			}
	;

				



			
// Handle union variable declarations here.
			
VariableDef:
			UndefinedID
			Colon
			SaveOffset 
			SaveDirection
			SaveAdd1st
			SaveLex3
			unionTkn
			{
				_here;
				assert( $<idStr>1 != NULL );

				$<s>$ = SymbolTable;
				CurOffset = 0;
				CurOffsetDir = 0;	/* Forces all fields to the same offset */
				AddOffset1st = 0;

			}
			UnionStuff
			endunionTkn
			Semicolon
			{
				int					SizeOfUnion;
				int					FieldCnt;
				struct	SymNode		*Fields;
				struct	SymNode		*CurSym;
				struct	SymNode		*LastSym;

				/*
				** Determine if there were any fields in the union.
				** Error if not.
				*/

				_here;
				_if( SymbolTable == $<s>8 )

					ErrorNear
					( 
						"Unions must have at least one field",
						"endunion",
						__LINE__,
						__FILE__ 
					);

				_else

					/*
					** Null terminate the list of fields in the union.
					** Search for the saved symbol table entry which
					** marks the first entry that is not a field.  Upon
					** finding that entry, store a NULL in the previous
					** link field.
					*/

					CurSym = SymbolTable;
					SizeOfUnion = 0;
					FieldCnt = 0;
					_while( CurSym != $<s>8 )

						SizeOfUnion = 
							max( SizeOfUnion, CurSym->ObjectSize);
						
						LastSym =  CurSym;
						CurSym = CurSym->Next;
						++FieldCnt;

					_endwhile
					LastSym->Next = NULL;


					/*
					** Restore all the compiler variables and set
					** up Fields so we can enter the union variable
					** into the symbol table.
					*/

					CurLexLevel = $<v.u.intval>6;
					Fields = SymbolTable;
					SymbolTable = $<s>8;
					CurOffset = $<v.u.intval>3;
					CurOffsetDir = $<v.u.intval>4;
					AddOffset1st = $<v.u.unsval>5;

					/*
					** Okay, create the union symbol table entry
					** and attach the fields symbol table to that entry.
					*/

					_if( AddOffset1st && !HoldOffset )	/* If a local variable */

						CurOffset += SizeOfUnion * CurOffsetDir;

					_endif
					CurOffset = 
						AlignVarOffset
						( 
							CurOffset,
							SizeOfUnion, 
							CurOffsetDir 
						);
						
					InsertSym
					(
						$<idStr>1,
						NULL,
						tUnion,
						cVar,
						0,
						NULL,
						0,
						NULL,
						SizeOfUnion,
						CurOffset,
						NULL,
						NULL,
						Fields,
						FieldCnt
					);
					_if( !AddOffset1st )	/* If not a local variable */

						CurOffset += SizeOfUnion * CurOffsetDir;

					_endif
					
					// Now we need to go through all the fields and
					// patch the "Parent" field to point at this
					// symbol table entry.
					
					_for( int fieldCntr = 0, fieldCntr < FieldCnt, ++fieldCntr )
					
						Fields->Parent = SymbolTable;
						Fields = Fields->Next;
						
					_endfor

				_endif
				_here;
			}
	;

				

VariableDef: VarErrors;


		/*
		** Handle some common errors down here.
		**
		*/



VarErrors:	AnyLocalID
			Colon
			unionTkn
			UnionStuff
			endunionTkn
			Semicolon
			{
				ErrorNear
				( 
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);

			}

		|	AnyLocalID
			Colon
			dorecordTkn
			recordOpts
			OptInherits
			RecordStuff
			endrecordTkn
			Semicolon
			{
				ErrorNear
				( 
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);
				inRecord = $<ru.inSave>3;
				MinRecAlignment = $<ru.MinRecAlignment>3;
				MaxRecAlignment = $<ru.MaxRecAlignment>3;
				currentNS = $<ru.saveCurNS>3;
				RecNS = $<ru.saveRecNS>3;
				RecGlobal = $<ru.saveRecGlobal>3;

			}

		|	AnyLocalID ':' error ';'
			{
				ErrorNear
				( 
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);
			}

		|	AnyLocalID Colon enumTkn Lbrace EnumList Rbrace Semicolon
			{
				ErrorNear
				( 
					"Duplicate symbol definition", 
					$<s>1->TrueName,
					__LINE__,

					__FILE__ 
				);

			}


		|	UndefinedID Colon UndefID '[' DimList Rbrack  Semicolon
			{
				ErrorNear
				( 
					"Undefined symbol", 
					$<idStr>3,
					__LINE__,
					__FILE__ 
				);

			}

		|	UndefinedID Colon UndefID Semicolon
			{
				ErrorNear
				( 
					"Undefined symbol", 
					$<idStr>3,
					__LINE__,
					__FILE__ 
				);

			}


		|	error ';'
	
		;


















/************************************************************/
/*                                                          */
/* Utility Productions for the static declaration sections: */
/*                                                          */
/************************************************************/


UndefinedForward:
		UndefinedID		/* $1 */
		Colon			/* $2 */
		forwardTkn		/* $3 */
		Lparen			/* $4 */
		UndefinedID		/* $5 */
		Rparen			/* $6 */
		{				/* $7 */

			union YYSTYPE v;

			_here;
			assert( $<idStr>1 != NULL );
			assert( $<idStr>5 != NULL );

			v.v.u.strval = $<idStr>1;
			InsertSym
			( 
				$<idStr>5, 
				&text_ste,
				tText, 
				cConstant, 
				0,				/* arity 			*/
				NULL,			/* NumDimensions	*/
				0, 				/* NumElements		*/
				YYS &v,
				4,				/* ObjectSize		*/
				0,
				NULL,
				NULL,			/* Base				*/
				NULL,			/* Fields			*/
				0				/* FieldCnt			*/ 
			);

			_here;
		}
		
		Semicolon		/* $8 */
		{				/* $9 */
			_here;
		}
	;




StaticAlign:
		alignTkn	/* $1 */
		Lparen		/* $2 */
		ConstExpr	/* $3 */
		Rparen		/* $4 */
		Semicolon	/* $5 */
		{			/* $6 */

			_here;
			_if
			( 
					IsNumber( $<v.pType>3 ) 
				&&	numBits32( YYS &$<v>3 ) <= 32
				&&	$<v.u.intval>3 > 0 
			)
			
				EmitAlign( $<v.u.unsval>3 );
				
			_else
			
				yyerror( "Expected a 32-bit positive constant" );
				
			_endif
			FreeValue( YYS &$<v.u.unsval>3 );
			_here;
		}
	;




StaticPtrToProcUninit:
		UndefinedID			/* $1  */ 
		Colon 				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		procedureTkn 		/* $5  */
		DefinedID			/* $6  */
		{					/* $7  */
			
			char StaticName[ 256 ];
			char *sn;

			_here;
			assert( $<idStr>1 != NULL );

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
			sn = hlastrdup2( StaticName );

			CreatePtrToProc( $<idStr>1, $<s>6, sn, cStatic );
			_here;
		}
		Semicolon			/* $8  */
		Options				/* $9 */
		OptionalExternal	/* $10 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_use
				|	specified_pascal
				|	specified_stdcall
				|	specified_cdecl
				|	specified_alignment 
				|	specified_nostorage 
				|	specified_volatile 
			);
			_if( $<returns>10 == NULL )

				EmitTypedLabel( SymbolTable->StaticName, tDWord );
				_if( !$<options.NoStorage>9 )

					EmitDword();

				_endif

			_else
			 
				SymbolTable->IsExternal = 1;
				_if( *$<returns>10 == '\0' )

				 	free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( SymbolTable->TrueName );
					free2( vss $<returns>10 );

				_else

					SymbolTable->StaticName = $<returns>10;

				_endif
				EmitTypedExtern
				( 
					SymbolTable, 
					SymbolTable->StaticName, 
					tDWord 
				);

			_endif
			_here;
		}
	;


StaticProcUninit:
		UndefinedID			/* $1 */ 
		Colon 				/* $2 */
		procedureTkn 		/* $3 */
		
		/*
		** Before going any farther, save the current
		** (previous lex level) variable offset and offset 
		** direction so we can restore these values when
		** the compiler finishes this declaration.  Note that the
		** compiler saves these values in the attributes of the
		** following grammar symbols.
		*/
		
		SaveOffset 			/* $4 */
		SaveDirection		/* $5 */

		/*
		** Insert the name into the symbol table.
		*/
					
		InsertProcSym 		/* $6  */
		

		OptionalParms 		/* $7  */
		Semicolon			/* $8  */
		Options				/* $9  */
		OptionalExternal	/* $10 */
		 
		/*
		** Initialize the pointer to the end of the parameters
		** for this procedure variable.
		** Set up the offset and direction variables to handle
		** local variable declarations.  
		*/
		 
		{					/* $11 */

			struct	SymNode	*s;
			union	YYSTYPE	value;

			_here;
			--CurLexLevel;
			CurOffset = $<v.u.intval>4;
			CurOffsetDir = $<v.u.unsval>5;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_returns
				|	specified_use
				|	specified_pascal
				|	specified_stdcall
				|	specified_cdecl
				|	specified_nostorage
				|	specified_volatile 
			);
			_if( $<returns>10 != NULL && $<options.NoStorage>9 )

				yyerror
				(
					"Can't specify both 'NOSTORAGE' and 'EXTERNAL' options"
				);

			_endif
			
			// Need to create a dummy type to hold the procedure pointer parameters.
			
			s = SymbolTable;
			InsertSym
			( 
				" (procptr parms) ", 
				NULL,
				tProcptr, 
				cType, 
				0,
				NULL,
				0, 
				NULL,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			SymbolTable->u.proc.parms = s;
			SymbolTable->u.proc.returns = $<options.returns>9;
			SymbolTable->u.proc.use = $<options.use>9;
			SymbolTable->u.proc.cs = $<options.CallingSequence>9;
			$<s>6->Type = SymbolTable;
			$<s>6->u.proc.parms->Type = SymbolTable;
			
			// Remove the dummy entry from the symbol table:
			
			SymbolTable = s;
			
			// Patch the original symbol table entries:

			$<s>6->u.proc.parms->u.proc.parms = SymbolTable;
			$<s>6->u.proc.parms->u.proc.returns = hlastrdup2( "" );
			$<s>6->u.proc.parms->u.proc.use = NULL;

			$<s>6->u.proc.parms = SymbolTable;
			$<s>6->u.proc.returns = $<options.returns>9;
			$<s>6->u.proc.use = $<options.use>9;
			$<s>6->u.proc.cs = $<options.CallingSequence>9;
			
			/*
			** Just to be on the safe side, let's create
			** a "parms" and "vars" entry for this object.
			*/
			
			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.v.u.unsval = $<v.u.unsval>7;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			value.v.u.unsval = 0;
			InsertSym
			( 
				"_vars_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			$<s>6->u.proc.parms->u.proc.Locals = SymbolTable;
			$<s>6->u.proc.Locals = SymbolTable;
			
			SymbolTable = $<s>6;


			_if( $<returns>10 == NULL )

				EmitTypedLabel( $<s>6->StaticName, tDWord );
				_if( !$<options.NoStorage>9 )

					EmitDword();

				_endif

			_else

				$<s>6->IsExternal = 1;
				_if( *$<returns>10 == '\0' )

				 	free2( vss $<s>6->StaticName );
					$<s>6->StaticName = hlastrdup2( $<s>6->TrueName );
					free2( vss $<returns>10 );

				_else

					$<s>6->StaticName = $<returns>10;

				_endif
				EmitTypedExtern( $<s>6, $<s>6->StaticName, tDWord );

			_endif
			_here;
		}
	;

 /*
 ** Handle a static procedure variable declaration that occurs
 ** after an external declaration (or a duplicate symbol definition).
 */

StaticProcRedef:
		AnyLocalID		/* $1 */ 
		Colon 			/* $2 */
		procedureTkn	/* $3 */
		SaveLocalIDPtr	/* $4 */
		MatchParms 		/* $5 */
		Semicolon		/* $6 */
		Options			/* $7 */
		{				/* $8 */
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>7,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				$<s>1->IsExternal = 0;
				_if( $<s>1->pType == tProcptr )

					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitTypedLabel( $<s>1->StaticName, tDWord );
					_if( !$<options.NoStorage>7 )

						EmitDword();

					_endif

				_else

					ErrorNear
					(
						"External base type must be a procedure pointer",
						$<s>1->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			_here;
		}
	;
	
StaticPtrToProcRedef:
		AnyLocalID			/* $1  */ 
		Colon 				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		procedureTkn 		/* $5  */
		DefinedID			/* $6  */
		Semicolon			/* $7  */
		Options				/* $8  */
		{					/* $9  */
			
			char msg[ 256 ];
			
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			assert( $<idStr>1 != NULL );

			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				$<s>1->IsExternal = 0;
				_if( $<s>1->pType == tProcptr )

					assert( $<s>1->u.proc.Forward != NULL );
					_if( $<s>1->u.proc.Forward != $<s>6 )
						
						sprintf
						( 
							msg,
							"Base procedure does not agree with original "
							"declaration\n('%s' should be '%s')",
							$<s>6->TrueName,
							$<s>1->u.proc.Forward->TrueName
						);
						yyerror( msg );
						
					_endif

					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitTypedLabel( $<s>1->StaticName, tDWord );
					_if( !$<options.NoStorage>8 )

						EmitDword();

					_endif

				_else

					ErrorNear
					(
						"External base type must be a procedure pointer",
						$<s>1->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			_here;
		}
	;


				



			 
SaveLocalIDPtr: 
		{ 
			_here;
			$<s>$ = $<s>-2; 
			_if( $<s>$->pType != tProcptr )

				yyerror( "External declaration is a pointer to a procedure" );

			_endif
		}
	;




 /*
 ** Handle procedure pointer variables with initializers here.
 */


StaticProcInit:
			UndefinedID		/* $1  */ 
			Colon 			/* $2  */
			procedureTkn 	/* $3  */
			SaveOffset 		/* $4  */
			SaveDirection	/* $5  */
			InsertProcSym 	/* $6  */
			OptionalParms 	/* $7  */
			assignTkn		/* $8  */
			{				/* $9  */

				/*
				** Must fix restore these here because they
				** might affect the constant expression.
				*/

				_here;
				--CurLexLevel;
				CurOffset = $<v.u.unsval>4;
				CurOffsetDir = $<v.u.unsval>5;
			}
			ConstOnlyExpr	/* $10 */
			Semicolon		/* $11 */
			Options			/* $12 */
			 
			/*
			** Initialize the pointer to the end of the parameters
			** for this procedure variable.
			** Set up the offset and direction variables to handle
			** local variable declarations.  
			*/
			 
			{
				struct	SymNode	*s;
				union	YYSTYPE	value;
				
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>12,
						specified_returns
					|	specified_use
					|	specified_pascal
					|	specified_stdcall
					|	specified_cdecl
					|	specified_nostorage
					|	specified_volatile 
				);
				_if( $<options.NoStorage>12 )

					yyerror( "'nostorage' option is illegal here" );

				_endif

				_if( $<v.pType>10 != tPointer )

					yyerror
					( 
						"Operand must be the address of a static object" 
					);

				_else

			
					// Need to create a dummy type to hold the procedure pointer parameters.
					
					s = SymbolTable;
					InsertSym
					( 
						" (procptr parms) ", 
						NULL,
						tProcptr, 
						cType, 
						0,
						NULL,
						0, 
						NULL,
						4,
						0,
						NULL,
						NULL,
						NULL,
						0
					);
					SymbolTable->u.proc.parms = s;
					SymbolTable->u.proc.returns = $<options.returns>12;
					SymbolTable->u.proc.use = $<options.use>12;
					SymbolTable->u.proc.cs = $<options.CallingSequence>12;
					$<s>6->Type = SymbolTable;
					$<s>6->u.proc.parms->Type = SymbolTable;
					$<s>6->u.proc.returns = hlastrdup2( "" );
					$<s>6->u.proc.use = NULL;
					
					// Remove the dummy entry from the symbol table:
					
					SymbolTable = s;
			
					// Patch the original symbol table entries:

					$<s>6->u.proc.parms->u.proc.parms = SymbolTable;
					$<s>6->u.proc.parms->u.proc.returns = hlastrdup2( "" );
					$<s>6->u.proc.parms->u.proc.use = NULL;
					$<s>6->u.proc.parms->u.proc.Locals = NULL;

					$<s>6->u.proc.parms = SymbolTable;
					$<s>6->u.proc.Locals = NULL;
					$<s>6->u.proc.returns = $<options.returns>12;
					$<s>6->u.proc.use = $<options.use>12;
					$<s>6->u.proc.cs = $<options.CallingSequence>12;
			
					/*
					** Just to be on the safe side, let's create
					** a "parms" and "vars" entry for this object.
					*/
					
					ClrConst
					(
						YYS &value,
						tUns32,
						&uns32_ste
					);
					value.v.u.unsval = $<v.u.unsval>7;
					InsertSym
					( 
						"_parms_", 
						&uns32_ste,
						tUns32, 
						cConstant, 
						0,
						NULL,
						0, 
						YYS &value,
						4,
						0,
						NULL,
						NULL,
						NULL,
						0
					);
					value.v.u.unsval = 0;
					InsertSym
					( 
						"_vars_", 
						&uns32_ste,
						tUns32, 
						cConstant, 
						0,
						NULL,
						0, 
						YYS &value,
						4,
						0,
						NULL,
						NULL,
						NULL,
						0
					);
					$<s>6->u.proc.parms->u.proc.Locals = SymbolTable;
					$<s>6->u.proc.Locals = SymbolTable;
					
					SymbolTable = $<s>6;
					EmitTypedLabel( $<s>6->StaticName, tDWord );
					EmitAdrs( $<v.u.strval>10 ); 

				_endif
				_here;
			}
	;


StaticPtrToProcInit:
		UndefinedID			/* $1  */ 
		Colon 				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		procedureTkn 		/* $5  */
		DefinedID			/* $6  */
		assignTkn			/* $7  */
		ConstOnlyExpr		/* $8  */
		{					/* $9  */					
			
			char StaticName[ 256 ];
			char *sn;

			_here;
			assert( $<idStr>1 != NULL );

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
			sn = hlastrdup2( StaticName );

			CreatePtrToProc( $<idStr>1, $<s>6, sn, cStatic );

			_here;
		}
		Semicolon			/* $10 */
		Options				/* $11 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>11,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>11 )

				yyerror( "'nostorage' option is illegal here" );

			_elseif( $<v.pType>8 != tPointer )

				yyerror
				( 
					"Operand must be the address of a static object" 
				);

			_else

				EmitTypedLabel( SymbolTable->StaticName, tDWord );
				EmitAdrs( $<v.u.strval>8 ); 

			_endif
		}
	;





 /*
 ** Handle a static procedure variable declaration with an initializer
 ** that occurs after an external declaration (or a duplicate symbol 
 ** definition).
 */

StaticRedefInit:
		AnyLocalID				/* $1 */ 
		Colon 					/* $2 */
		procedureTkn			/* $3 */
		SaveLocalIDPtr	 		/* $4 */
		MatchParms 				/* $5 */
		assignTkn				/* $6 */
		ConstOnlyExpr			/* $7  */
		Semicolon				/* $8  */
		{						/* $9  */
			_here;
			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				$<s>1->IsExternal = 0;
				_if( $<v.pType>7 != tPointer )

					yyerror
					( 
						"Operand must be the address of a static object" 
					);

				_else


					_if( $<s>1->pType == tProcptr )

						EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
						EmitTypedLabel( $<s>1->StaticName, tDWord );
						EmitAdrs( $<v.u.strval>7 );

					_else

						ErrorNear
						(
							"External base type must be a procedure pointer",
							$<s>1->TrueName,
							__LINE__,
							__FILE__
						);

					_endif


				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			FreeValue( YYS &$<v>7 );
			_here;
		}
	;




StaticPtrToProcRedefInit:
		AnyLocalID			/* $1  */ 
		Colon 				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		procedureTkn 		/* $5  */
		DefinedID			/* $6  */
		assignTkn			/* $7  */
		ConstOnlyExpr		/* $8  */
		Semicolon			/* $9 */
		{		
			char msg[ 256 ];
						
			_here;
			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				$<s>1->IsExternal = 0;
				_if( $<v.pType>8 != tPointer )

					yyerror
					( 
						"Operand must be the address of a static object" 
					);

				_else


					_if( $<s>1->pType == tProcptr )

						_if( $<s>1->u.proc.Forward != $<s>6 )
							
							sprintf
							( 
								msg,
								"Base procedure does not agree with original "
								"declaration\n('%s' should be '%s')",
								$<s>6->TrueName,
								$<s>1->u.proc.Forward->TrueName
							);
							yyerror( msg );
							
						_endif

						EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
						EmitTypedLabel( $<s>1->StaticName, tDWord );
						EmitAdrs( $<v.u.strval>8 );

					_else

						ErrorNear
						(
							"External base type must be a procedure pointer",
							$<s>1->TrueName,
							__LINE__,
							__FILE__
						);

					_endif


				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			FreeValue( YYS &$<v>8 );
			_here;
		}
	;





 /*
 ** The following production reserves storage for an ENUM object
 ** in a static section.
 */

StaticEnum:
		UndefinedID		/* $1  */ 
		Colon 			/* $2  */
		enumTkn			/* $3  */
		InsertEnum		/* $4  */
		Lbrace			/* $5  */
		SaveEnumSym		/* $6  */
		EnumList 		/* $7  */
		Rbrace			/* $8  */
		Semicolon		/* $9  */
		Options			/* $10 */
		{				/* $11 */
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_nostorage
				|	specified_volatile 
			);
			// Fix up the generated enum type to include a pointer to
			// the enum symbols and the count of enum symbols:
			
			$<s>4->Fields = SymbolTable;
			$<s>4->FieldCnt = EnumVal;
			

			_if( EnumSize == 1 )

				EmitTypedLabel( $<s>4->StaticName, tByte );
				_if( !$<options.NoStorage>10 )

					EmitByte();

				_endif

			_elseif( EnumSize == 2 )

				EmitTypedLabel( $<s>4->StaticName, tWord );
				_if( !$<options.NoStorage>10 )

					EmitWord();

				_endif

			_else

				EmitTypedLabel( $<s>4->StaticName, tDWord );
				_if( !$<options.NoStorage>10 )

					EmitDword();

				_endif

			_endif
		 }
	;







StaticEnumInit:
		UndefinedID		/* $1 */ 
		Colon 			/* $2 */
		enumTkn			/* $3 */
		InsertEnum		/* $4 */
		Lbrace			/* $5 */
		SaveEnumSym		/* $6 */ 
		EnumList		/* $7 */ 
		Rbrace			/* $8 */
		{				/* $9 */

			// Fix up the generated enum type to include a pointer to
			// the enum symbols and the count of enum symbols:
			
			_here;
			$<s>4->Fields = SymbolTable;
			$<s>4->FieldCnt = EnumVal;

		}
		assignTkn		/* $10 */
		ConstOnlyExpr	/* $11 */
		Semicolon		/* $12 */
		{
			char	valStr[32];
			
			_here;
			sprintf( valStr, "%d", $<v.u.unsval>11 );
			
			_if( $<v.Type>11 != $<v.Type>6 )

				yyerror( "Type mismatch in enum constant" );

			_else
			
				_switch( EnumSize )
				
					_case( 4 )
					
						EmitData( $<s>4->StaticName, tDWord, valStr );
						
					_endcase
				
					_case( 2 )
					
						EmitData( $<s>4->StaticName, tWord, valStr );
						
					_endcase
				
					_default
					
						EmitData( $<s>4->StaticName, tByte, valStr );
						
				_endswitch
				

			_endif
			_here;
		}
	;




 /*
 ** Handle pointer declarations to user-defined types with
 ** an initializer here (for Readonly and Static sections).
 */


StaticPtrToUser:
		UndefinedID			/* $1  */
		Colon				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		AnyID				/* $5  */
		assignTkn			/* $6  */
		ConstExpr			/* $7  */
		{					/* $10 */

			struct	SymNode			*BaseType;
			char	*sn;
			char	StaticName[ 256 ];

			_here;
			assert( $<idStr>1 != NULL );
			assert( $<neID.idStr>5 != NULL );

			BaseType = $<neID.s>5;
			_if( BaseType != NULL )

				BaseType = GetBaseType( BaseType );
				_if( CantBeVar( BaseType->pType ))

					yyerror( "Static/Readonly variables cannot be this type" );
					BaseType = &uns32_ste;

				_endif

			_endif

			_if
			( 
					$<v.pType>7 != tPointer 

			)

				yyerror( "Expression must be a pointer constant" );
				FreeValue( YYS &$<v>7 );
				$<v.u.strval>7 = hlastrdup2( "0" );
				$<v.pType>7 = tString;
				$<v.Type>7 = &string_ste;

			_endif

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
			sn = hlastrdup2( StaticName );
			InsertSym
			( 
				$<idStr>1,			/* Name			*/
				&pointer_ste,		/* Type			*/
				tPointer, 			/* pType		*/
				cStatic,			/* SymClass		*/ 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* CurOffset	*/
				sn,					/* StaticName	*/
				BaseType,			/* BaseType		*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);


			EmitTypedLabel( sn, tDWord );
			EmitAdrs( $<v.u.strval>7 );


			_if( BaseType == NULL )

				Add2PtrList( SymbolTable, $<neID.idStr>5 );

			_endif
			FreeValue( YYS &$<v>7 );
			_here;
		}
		Semicolon			/* $9  */
		Options				/* $10 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>10 )

				yyerror( "'nostorage' option is illegal here" );

			_endif

		}
	;



 /*
 ** Handle a pointer to a user defined type with an intializer,
 ** assuming a previous external declaration.
 */

StaticPtrToExtUser:
		AnyLocalID			/* $1  */
		Colon				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		AnyID				/* $5  */
		assignTkn			/* $6  */
		ConstExpr			/* $7  */
		{					/* $8  */


			struct	SymNode			*BaseType;
			char	*sn;
			char	StaticName[ 256 ];

			_here;
			assert( $<idStr>1 != NULL );
			assert( $<neID.idStr>5 != NULL );

			BaseType = $<neID.s>5;
			_if( BaseType != NULL )

				BaseType = GetBaseType( BaseType );
				_if( CantBeVar( BaseType->pType ))

					yyerror( "Static/Readonly variables cannot be this type" );
					BaseType = &uns32_ste;

				_endif

			_endif

			_if
			( 
					$<v.pType>7 != tPointer 

			)

				yyerror( "Expression must be a pointer constant" );
				FreeValue( YYS &$<v>7 );
				$<v.u.strval>7 = hlastrdup2( "0" );
				$<v.pType>7 = tString;
				$<v.Type>7 = &string_ste;

			_endif



			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				$<s>1->IsExternal = 0;
				_if( $<s>1->Type == &pointer_ste && $<s>1->Base == BaseType ) 

					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitTypedLabel( $<s>1->StaticName, tDWord );
					EmitAdrs( $<v.u.strval>7 );

				_else

					ErrorNear
					(
						"External base type must match declared base type",
						$<neID.idStr>5,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif


			_if( BaseType == NULL )

				Add2PtrList( $<s>1, $<neID.idStr>5 );

			_endif
			FreeValue( YYS &$<v>7 );
			_here;
		}
		Semicolon			/* $9  */
		Options				/* $10 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>10 )

				yyerror( "'nostorage' option is illegal here" );

			_endif

		}
	;
		
		
 /*
 ** Handle pointer declarations to the built-in types 
 ** with initializers here.
 */
		
StaticPtrToBuiltIn:
		UndefinedID			/* $1  */
		Colon				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		ReservedTypeIDs		/* $5  */
		assignTkn			/* $6  */
		ConstExpr			/* $7  */
		{					/* $8  */

			struct	SymNode	*BaseType;
			char			*sn;
			char			StaticName[ 256 ];

			_here;
			assert( $<idStr>1 != NULL );


			BaseType = $<s>5;
			_if( CantBeVar( BaseType->pType ))

				yyerror( "Static/Readonly variables cannot be this type" );
				BaseType = &uns32_ste;

			_endif

			/*
			** It better be a pointer constant.
			*/

			_if
			( 
					$<v.pType>7 != tPointer 

			)

				yyerror( "Expression must be a pointer constant" );
				FreeValue( YYS &$<v>7 );
				$<v.u.strval>7 = hlastrdup2( "0" );
				$<v.pType>7 = tString;
				$<v.Type>7 = &string_ste;

			_endif

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
			sn = hlastrdup2( StaticName );
			InsertSym
			( 
				$<idStr>1,			/* Name			*/
				&pointer_ste,		/* Type			*/
				tPointer, 			/* pType		*/
				cStatic,			/* SymClass		*/ 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* CurOffset	*/
				sn,					/* StaticName	*/
				BaseType,			/* BaseType		*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);
			EmitTypedLabel( sn, tDWord );
			EmitAdrs( $<v.u.strval>7 );
			FreeValue( YYS &$<v>7 );
			_here;
		}
		Semicolon			/* $9  */
		Options				/* $10 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>10 )

				yyerror( "'nostorage' option is illegal here" );

			_endif
		}
	;


 /*
 ** Handle pointer declarations to the built-in types with an initializer
 ** that have a previous external declaration.
 */


StaticPtrToBuiltInExt:
		AnyLocalID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		ReservedTypeIDs		/* $5 */
		assignTkn			/* $6 */
		ConstExpr			/* $7 */
		{					/* $8 */					
			
			_here;


			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				$<s>1->IsExternal = 0;
				_if( $<s>1->Type == &pointer_ste && $<s>1->Base == $<s>5 )

					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitTypedLabel( $<s>1->StaticName, tDWord );
					EmitAdrs( $<v.u.strval>7 );

				_else

					ErrorNear
					(
						"Pointer constant is illegal here",
						$<s>5->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			FreeValue( YYS &$<v>7 );
			_here;
		}
		Semicolon			/* $9  */
		Options				/* $10 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>10 )

				yyerror( "'nostorage' option is illegal here" );

			_endif
		}
	;



 /*
 ** Handle a pointer to a built-in type of an external symbol
 ** using the nostorage option.
 */

StaticPtrToBuiltInNS:
		AnyLocalID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		ReservedTypeIDs		/* $5 */
		Semicolon			/* $6 */
		Options				/* $7 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>7,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				$<s>1->IsExternal = 0;
				_if( $<s>1->Type == &pointer_ste && $<s>1->Base == $<s>5 ) 

					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitTypedLabel( $<s>1->StaticName, tDWord );
					_if( !$<options.NoStorage>7 )

						EmitDwordConst( 0, "" );

					_endif

				_else

					ErrorNear
					(
						"External base type must match declared base type",
						$<s>5->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			_here;
		}
	;
	
	
 /*
 ** Static variable declarations using a single type ID with
 ** an initializer.  e.g., i:int8 := 5;
 ** Note: external is not allowed here.
 */
	
StaticSingleTypeInit:
		UndefinedID			/* $1 */ 
		Colon 				/* $2 */
		TypeID 				/* $3 */
		assignTkn 			/* $4 */
		ConstOnlyExpr 		/* $5 */
		{					/* $6 */

			char StaticName[ 256 ];
			char *sn;

			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			_here;

			_if( CantBeVar($<s>3->pType ))

				yyerror( "Object cannot be this type" );

			_else
			
				sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
				sn = hlastrdup2( StaticName );

				InsertSym
				( 
					$<idStr>1, 
					$<s>3,			/* GetBaseType( $<s>3 ), */
					$<s>3->pType, 
					cStatic, 
					$<s>3->Arity,
					$<s>3->Dimensions,
					$<s>3->NumElements, 
					NULL,
					$<s>3->ObjectSize,
					0,
					sn,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt
				);
				_if( $<s>3->pType == tProcptr )
				
					// Copy parameter info if a proc ptr.
					
					memcpy
					( 
						&SymbolTable->u, 
						&$<s>3->u, 
						sizeof( union ValuesSize )
					);
					
				_endif

				/*
				** Check to see if the TypeID and the ConstOnlyExpr
				** are both arrays and if they are compatible.
				*/

				_if( $<s>3->pType == tArray && $<v.pType>5 == tArray )

					_if
					( 
						ArraysAreCompatible
						( 
							YYS $<s>3, 
							YYS &$<v>5 
						)
					)

						OutValue( sn, $<s>3, YYS &$<v>5 );

					_else

						yyerror
						( 
							"Array type mismatch or value out of range" 
						);

					_endif


				/*
				** Check to see if the TypeID and the ConstOnlyExpr are
				** compatible record objects. 
				*/

				_elseif
				( 
						$<s>3->pType == tRecord 
					&&	$<v.pType>5 == tRecord 
				)

					_if
					( 
						RecordsAreCompatible
						( 
							$<s>3, 
							YYS &$<v>5 
						)
					)

						OutValue( sn, $<s>3, YYS &$<v>5 );

					_else

						yyerror
						( 
							"Type mismatch, expected compatible "
							"record types"
						);

					_endif




				/*
				** Check to see if the TypeID and the ConstOnlyExpr are
				** compatible union objects. 
				*/

				_elseif
				( 
						$<s>3->pType == tUnion 
					&&	GetBaseType( $<s>3 ) == GetBaseType( $<v.Type>5 ) 
				)

					OutValue( sn, $<s>3, YYS &$<v>5 );


				_elseif
				( 
						( 
								$<s>3->pType == tPointer 
							||	$<s>3->pType == tProcptr
							||	$<s>3->pType == tDWord
						)
					&&	$<v.pType>5 == tPointer
				)

					OutValue( sn, $<s>3, YYS &$<v>5 );



				/*
				** Check to see if the TypeID and the ConstOnlyExpr are
				** compatible pointer objects here.
				*/

				_elseif( IsNotPrimType( $<s>3->pType ))

					yyerror( "This static type requires a constant" );


				/*
				** Special case: since strings are really pointer
				** objects, we'll allow a pointer constant as the
				** initial value of a string.  Can't really check
				** the type (since the pointer constant might
				** not be defined yet), but this is assembly language,
				** the programmer has to take responsibility for
				** some things!
				*/

				_elseif
				( 
						( IsStr( $<s>3->pType ))
					&&	$<v.pType>5 == tPointer
				)

					assert( $<v.u.strval>5 != NULL );
					EmitTypedLabel( StaticName, tDWord );
					EmitAdrs( $<v.u.strval>5 );
				
				/*
				** We've got a scalar object, output the constant here.
				*/

				_elseif( IsCompatible( $<s>3, YYS &$<v>5 ))

					OutStaticConst( sn, $<s>3, YYS &$<v>5 );

				_else

					yyerror( "Static type mismatch or range error" );

				_endif

			_endif
			FreeValue( YYS &$<v>5 );
			_here;
		}
		Semicolon			/* $7 */
		Options				/* $8 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>8 )

				yyerror( "'nostorage' option is illegal here" );

			_endif
		}
	;
	


 /*
 ** Static variable declarations using a single type ID with
 ** an initializer.  e.g., i:int8 := 5;
 ** Note: This production handles the case where this symbol
 ** was previously declared.
 */

StaticSingleTypeWasExt:
		AnyLocalID			/* $1 */ 
		Colon 				/* $2 */
		TypeID 				/* $3 */
		assignTkn 			/* $4 */
		ConstOnlyExpr 		/* $5 */
		{					/* $6 */

			char StaticName[ 256 ];
			char *sn;

			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );

			_here;

			_if( CantBeVar($<s>3->pType ))

				yyerror( "Variables cannot be this type" );

			_else
			

				_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

					/*
					** The type of the previously declared symbol must
					** be identical to the current declared type.
					*/

					$<s>1->IsExternal = 0;
					_if( $<s>1->Type == $<s>3 ) 

						EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );

						/*
						** Check to see if the TypeID and the ConstOnlyExpr
						** are both arrays and if they are compatible.
						*/

						_if( $<s>3->pType == tArray && $<v.pType>5 == tArray )

							_if
							( 
								ArraysAreCompatible
								( 
									YYS $<s>3, 
									YYS &$<v>5 
								)
							)

								OutValue
								( 
									$<s>1->StaticName, 
									$<s>3, 
									YYS &$<v>5 
								);

							_else

								yyerror
								( 
									"Array type mismatch or value out of range" 
								);

							_endif


						/*
						** Check to see if the TypeID and the ConstOnlyExpr are
						** compatible record objects. 
						*/

						_elseif
						( 
								$<s>3->pType == tRecord 
							&&	$<v.pType>5 == tRecord 
						)

							_if
							( 
								RecordsAreCompatible
								( 
									$<s>3, 
									YYS &$<v>5 
								)
							)

								OutValue
								( 
									$<s>1->StaticName, 
									$<s>3, YYS &$<v>5 
								);

							_else

								yyerror
								( 
									"Type mismatch, expected compatible "
									"record types"
								);

							_endif






						/*
						** Check to see if the TypeID and the ConstOnlyExpr are
						** compatible union objects. 
						*/

						_elseif
						( 
								$<s>3->pType == tUnion 
							&&	GetBaseType( $<s>3 ) == 
									GetBaseType( $<v.Type>5 ) 
						)

							OutValue( $<s>1->StaticName, $<s>3, YYS &$<v>5 );




						_elseif
						( 
								( 
										$<s>3->pType == tPointer 
									||	$<s>3->pType == tProcptr
									||	$<s>3->pType == tDWord
								)
							&&	$<v.pType>5 == tPointer
						)

							OutValue
							( 
								$<s>1->StaticName, 
								$<s>3, 
								YYS &$<v>5 
							);



						/*
						** Check to see if the TypeID and the ConstOnlyExpr are
						** compatible pointer objects here.
						*/

						_elseif( IsNotPrimType( $<s>3->pType ))

							yyerror( "This static type requires a constant" );

						
						/*
						** We've got a scalar object, output the constant here.
						*/

						_elseif
						( 
							IsCompatible( $<s>3, YYS &$<v>5 )
						)

							OutStaticConst( $<s>1->StaticName, $<s>3, YYS &$<v>5 );

						_else

							yyerror( "Static type mismatch or range error" );

						_endif

					_else

						ErrorNear
						(
							"External type must match "
							"declared type",
							$<s>1->TrueName,
							__LINE__,
							__FILE__
						);

					_endif

				_else

					ErrorNear
					( 
						"Duplicate symbol definition",
						$<s>1->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_endif
			FreeValue( YYS &$<v>5 );
			_here;
		}
		Semicolon			/* $7 */
		Options				/* $8 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>8 )

				yyerror( "'nostorage' option is illegal here" );

			_endif
		}
	;




 /*
 ** Array static variable definitions with initializers
 ** e.g., b:int8[4] := [1,2,3,4];
 **
 */

StaticArrayInit:
		UndefinedID		/* $1  */ 
		Colon			/* $2  */
		TypeID 			/* $3  */
		'[' 			/* $4  */
		DimList 		/* $5  */
		Rbrack  		/* $6  */
		assignTkn 		/* $7  */
		ConstOnlyExpr 	/* $8  */
		{				/* $9 */
		
			int		*DimensionArray;
			int		ArraySize;
			char	StaticName[ 256 ];
			char	*sn;

			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );
			assert( $<v.NumElements>5 > 0 );
			assert( $<v.Dimensions>5 != NULL );

			_here;

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
			sn = hlastrdup2( StaticName );

			/*
			** Make sure this is a legal variable type
			** (e.g., no text variables).
			*/

			_if( CantBeVar( $<s>3->pType ))
			
				yyerror( "Bad static/readonly variable type" );
				
			_else 
			
				/*
				** Check to see if TypeID is an array type
				** (i.e., we're creating a multi-dimensional array).
				*/

				_if( $<s>3->pType != tArray )

					/*
					** TypeID is *not* an array type, so create
					** a single dimension array here.
					*/

					ArraySize = $<s>3->ObjectSize * $<v.NumElements>5;
					InsertSym
					( 
						$<idStr>1, 
						$<s>3,
						tArray, 
						cStatic, 
						$<v.Arity>5,
						$<v.Dimensions>5,
						$<v.NumElements>5, 
						NULL,
						ArraySize,
						0,
						sn,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);
					DimensionArray = $<v.Dimensions>5;


				/*
				** Okay, down here TypeID *is* an array type,
				** so we're creating a multi-dimensional array.
				*/

				_else

					assert( $<s>3->Dimensions != NULL );

					/*
					** Create the new dimension array by concatenating
					** the two existing dimension arrays.
					*/

					DimensionArray = 
						malloc2
						( 
							( $<s>3->Arity + $<v.NumElements>5 ) * 
								sizeof( int )
						);

					memcpy
					( 
						DimensionArray, 
						$<s>3->Dimensions, 
						$<s>3->Arity * sizeof( int )
					);
					memcpy
					(
						&DimensionArray[ $<s>3->Arity ],
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);
					ArraySize = $<s>3->ObjectSize * $<v.NumElements>5;
					free2( vss $<v.Dimensions>5 );

					/*
					** Add the new array to the symbol table.
					*/

					InsertSym
					( 
						$<idStr>1, 
						$<s>3->Type,
						tArray, 
						cStatic, 
						$<s>3->Arity + $<v.Arity>5,
						DimensionArray,
						$<s>3->NumElements * $<v.NumElements>5, 
						NULL,
						ArraySize,
						0,
						sn,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_endif
				
				
				/*
				** Check to see if the TypeID and the ConstOnlyExpr
				** are both arrays and if they are compatible.
				*/

				_if( $<v.pType>8 != tArray )

					yyerror( "Expected an array constant as initializer" );

				_else
				
					_if
					( 
						ArraysAreCompatible
						( 
							YYS SymbolTable, 
							YYS &$<v>8 
						)
					)
					
						OutValue( sn, SymbolTable, YYS &$<v>8 );

					_else

						yyerror
						( 
							"Array type mismatch or value out of range" 
						);

					_endif


				_endif
				FreeValue( YYS &$<v>8 );

			_endif
			_here;
		}
		Semicolon		/* $10 */
		Options			/* $11 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>11,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>11 )

				yyerror( "'nostorage' option is illegal here" );

			_endif
		}
	;








 /*
 ** Open ended array static variable definitions with initializers
 ** e.g., b:int8[] := [1,2,3,4];
 **
 */

StaticArrayInit:
		UndefinedID		/* $1 */ 
		Colon			/* $2 */
		TypeID 			/* $3 */
		'[' 			/* $4 */
		Rbrack  		/* $5 */
		assignTkn 		/* $6 */
		ConstOnlyExpr 	/* $7 */
		{				/* $8 */
		
			int		*DimensionArray;
			int		ArraySize;
			char	StaticName[ 256 ];
			char	*sn;

			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );


			_here;

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
			sn = hlastrdup2( StaticName );

			/*
			** Make sure this is a legal variable type
			** (e.g., no text variables).
			*/

			_if( CantBeVar( $<s>3->pType ))
			
				yyerror( "Bad static/readonly variable type" );
				
			_else 
			
				/*
				** Check to see if TypeID is an array type
				** (i.e., we're creating a multi-dimensional array).
				*/

				_if( $<s>3->pType != tArray )

					/*
					** TypeID is *not* an array type, so create
					** a single dimension array here.
					*/

					ArraySize = $<s>3->ObjectSize * $<v.NumElements>7;
					InsertSym
					( 
						$<idStr>1, 
						$<s>3,
						tArray, 
						cStatic, 
						1,							/* arity       */
						malloc2( sizeof( int )),	/* dimensions  */
						$<v.NumElements>7,			/* numelements */
						NULL,						/* value       */
						ArraySize,					/* object size */
						0,
						sn,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);
					SymbolTable->Dimensions[0] = $<v.NumElements>7;


				/*
				** Okay, down here TypeID *is* an array type,
				** so we're creating a multi-dimensional array.
				*/

				_elseif
				( 
						$<v.NumElements>7 <= $<s>3->NumElements
					||	($<v.NumElements>7 % $<s>3->NumElements) != 0
				)
				
					/*
					** The array constant must have an even multiple
					** of the number of elements of $<s>3's type, or
					** this is an error.
					*/
					
					yyerror( "Illegal number of array elements in constant" );
					
				_else

					assert( $<s>3->Dimensions != NULL );
					assert( $<s>3->NumElements != 0 );

					/*
					** Create the new dimension array by concatenating
					** the two existing dimension arrays.
					*/

					DimensionArray = 
						malloc2
						( 
							( $<s>3->Arity + 1 ) * sizeof( int )
						);

					memcpy
					( 
						DimensionArray, 
						$<s>3->Dimensions, 
						$<s>3->Arity * sizeof( int )
					);
					DimensionArray[ $<s>3->Arity ] =
						$<v.NumElements>7 / $<s>3->NumElements;
						
					/*
					** Add the new array to the symbol table.
					*/

					InsertSym
					( 
						$<idStr>1, 
						$<s>3->Type,
						tArray, 
						cStatic, 
						$<s>3->Arity + 1,
						DimensionArray,
						$<v.NumElements>7, 
						NULL,
						GetBaseType( $<s>3 )->ObjectSize * $<v.NumElements>7,
						0,
						sn,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_endif
				
				
				/*
				** Check to see if the TypeID and the ConstOnlyExpr
				** are both arrays and if they are compatible.
				*/

				_if( $<v.pType>7 != tArray )

					yyerror( "Expected an array constant as initializer" );

				_else
				
					_if
					( 
						ArraysAreCompatible
						( 
							YYS SymbolTable, 
							YYS &$<v>7 
						)
					)
					
						OutValue( sn, SymbolTable, YYS &$<v>7 );

					_else

						yyerror
						( 
							"Array type mismatch or value out of range" 
						);

					_endif


				_endif
				FreeValue( YYS &$<v>7 );

			_endif
			_here;
		}
		Semicolon		/* $9  */
		Options			/* $10 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>10,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>10 )

				yyerror( "'nostorage' option is illegal here" );

			_endif
			_here;
		}
	;




 /*
 ** Handle an array declaration in the readonly or static section that
 ** has a previous external declaration.
 */

StaticArrayInitExt:

			AnyLocalID		/* $1  */ 
			Colon			/* $2  */
			TypeID 			/* $3  */
			'[' 			/* $4  */
			DimList 		/* $5  */
			Rbrack  		/* $6  */
			assignTkn 		/* $7  */
			ConstOnlyExpr 	/* $8  */
			{				/* $9  */

				int		*DimensionArray;
				int		ArraySize;
				int		Arity;


				assert( $<s>1 != NULL );
				assert( $<s>3 != NULL );
				assert( $<v.NumElements>5 > 0 );
				assert( $<v.Dimensions>5 != NULL );

				_here;
				
				/*
				** Set DimensionArray so that it contains all the
				** dimensions for the declared type (including
				** the dimensions from TypeID if it is an array type).
				*/
				
				_if( $<s>3->pType == tArray )
				
					DimensionArray =
						malloc2
						( 
							($<v.Arity>5 + $<s>3->Arity ) * sizeof(int)
						);
						
					memcpy
					( 
						DimensionArray, 
						$<s>3->Dimensions, 
						$<s>3->Arity * sizeof( int )
					);
					memcpy
					(
						&DimensionArray[ $<s>3->Arity ],
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);
					ArraySize = $<s>3->NumElements * $<v.NumElements>5;
					Arity = $<s>3->Arity + $<v.Arity>5;
						
				_else
				
					DimensionArray = malloc2( $<v.NumElements>5 * sizeof(int));
					memcpy
					(
						DimensionArray,
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);
					ArraySize = $<v.NumElements>5;
					Arity = $<v.Arity>5;
					
				_endif
				
				/*
				** Make sure this is a legal variable type
				** (e.g., no text variables).
				*/

				_if( CantBeVar( $<s>3->pType ))
				
					yyerror( "Bad static variable type" );
				
				
				/*
				** Make sure the number of elements in the new
				** declared size matches the original.
				*/
				
				_elseif
				( 
						$<s>1->pType != tArray 
					||	$<s>1->NumElements != ArraySize
					||	$<s>1->Arity != Arity 
				)
				
					yyerror
					( 
						"Number of elements does not match original" 
					);
				
				_else
				
				
					_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

						$<s>1->IsExternal = 0;
						EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
						_if
						( 
							ArraysAreCompatible
							( 
								YYS $<s>1, 
								YYS &$<v>8 
							)
						)
						
							OutValue( $<s>1->StaticName, $<s>1, YYS &$<v>8 );

						_else

							yyerror
							( 
								"Array type mismatch or value out of range" 
							);

						_endif


					_else

						ErrorNear
						( 
							"Duplicate symbol definition",
							$<s>1->TrueName,
							__LINE__,
							__FILE__
						);

					_endif

					/*
					** If it's a multidimensional array,
					** free the dimensions array of the constant.
					*/

					FreeValue( YYS &$<v>5 );
					free2( vss $<v.Dimensions>5 );
					FreeValue( YYS &$<v>8 );

				_endif
				_here;
			}
			Semicolon		/* $10 */
			Options			/* $11 */
			{
				_here;
				CheckLegalOptions
				( 
					$<options.SpecifiedOptions>11,
						specified_nostorage
					|	specified_volatile 
				);
				_if( $<options.NoStorage>11 )

					yyerror( "'nostorage' option is illegal here" );

				_endif
				_here;
			}
	;



 /*
 ** Handle pointer declarations to user-defined types here.
 */

StaticPtrToUserNoInit:
		UndefinedID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		AnyID				/* $5 */
		{					/* $6 */

			struct	SymNode			*BaseType;
			char	*sn;
			char	StaticName[ 256 ];

			assert( $<idStr>1 != NULL );
			assert( $<neID.idStr>5 != NULL );

			_here;
			BaseType = $<neID.s>5;
			_if( BaseType != NULL )

				BaseType = GetBaseType( BaseType );
				_if( CantBeVar( BaseType->pType ))

					yyerror( "Static/Storage variables cannot be this type" );
					BaseType = &uns32_ste;

				_endif

			_endif

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
			sn = hlastrdup2( StaticName );
			InsertSym
			( 
				$<idStr>1,			/* Name			*/
				&pointer_ste,		/* Type			*/
				tPointer, 			/* pType		*/
				cStatic,			/* SymClass		*/ 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* CurOffset	*/
				sn,					/* StaticName	*/
				BaseType,			/* BaseType		*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);
			$<s>$ = SymbolTable;
			_here;
		}
		Semicolon			/* $7 */
		Options				/* $8 */
		OptionalExternal	/* $9 */
		{

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<returns>9 != NULL && $<options.NoStorage>8 )

				yyerror
				(
					"Can't specify both 'NOSTORAGE' and 'EXTERNAL' options"
				);

			_endif
			_if( $<returns>9 == NULL )
			 
				EmitTypedLabel( $<s>6->StaticName, tDWord );
				_if( !$<options.NoStorage>8 )

					EmitDword( );

				_endif

			_else

				SymbolTable->IsExternal = 1;
				_if( *$<returns>9 == '\0' )

					free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( $<idStr>1 );

				_else

					free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( $<returns>9 );

				_endif
				EmitTypedExtern
				( 
					SymbolTable, 
					SymbolTable->StaticName, 
					tDWord 
				);

			_endif
			free2( vss $<returns>9 );


			_if( SymbolTable->Base == NULL )

				Add2PtrList( SymbolTable, $<neID.idStr>5 );

			_endif
			_here;
		}
	;


 /*
 ** Deal with a declaration of a pointer to a user-defined type
 ** that has had a previous external declaration.
 */

StaticPtrToUserExt:
		AnyLocalID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		AnyID				/* $5 */
		Semicolon			/* $6 */
		Options				/* $7 */
		{					/* $8 */

			struct	SymNode *BaseType;
	
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>7,
					specified_nostorage
				|	specified_volatile 
			);
			BaseType = $<neID.s>5;
			_if( BaseType != NULL )

				BaseType = GetBaseType( BaseType );
				_if( CantBeVar( BaseType->pType ))

					yyerror( "Static/Storage variables cannot be this type" );
					BaseType = &uns32_ste;

				_endif

			_endif
			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				_if( $<s>1->Type == &pointer_ste && $<s>1->Base == BaseType ) 

					$<s>1->IsExternal = 0;
					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitTypedLabel( $<s>1->StaticName, tDWord );
					_if( !$<options.NoStorage>7 )

						EmitDword( );

					_endif

				_else

					ErrorNear
					(
						"External base type must match declared base type",
						$<neID.idStr>5,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif


			_if( BaseType == NULL )

				Add2PtrList( $<s>1, $<neID.idStr>5 );

			_endif

			free2( vss $<neID.idStr>5 );
			_here;
		}
	;



 /*
 ** Handle pointer declarations to the built-in types here.
 */

StaticPtrBuiltInNoInit:
		UndefinedID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		ReservedTypeIDs		/* $5 */
		{					/* $6 */

			struct	SymNode	*BaseType;
			char			*sn;
			char			StaticName[ 256 ];

			assert( $<idStr>1 != NULL );

			_here;
			BaseType = $<s>5;
			_if( CantBeVar( BaseType->pType ))

				yyerror( "Static/Storage variables cannot be this type" );
				BaseType = &uns32_ste;

			_endif

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
			sn = hlastrdup2( StaticName );
			InsertSym
			( 
				$<idStr>1,			/* Name			*/
				&pointer_ste,		/* Type			*/
				tPointer, 			/* pType		*/
				cStatic,			/* SymClass		*/ 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* CurOffset	*/
				sn,					/* StaticName	*/
				BaseType,			/* BaseType		*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);
			$<s>$ = SymbolTable;
			_here;

		}
		Semicolon			/* $7 */
		Options				/* $8 */
		OptionalExternal	/* $9 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<returns>9 != NULL && $<options.NoStorage>8 )

				yyerror
				(
					"Can't specify both 'NOSTORAGE' and 'EXTERNAL' options"
				);

			_endif
			_if( $<returns>9 == NULL )
			 
				EmitTypedLabel( $<s>6->StaticName, tDWord );
				_if( !$<options.NoStorage>8 )

					EmitDword( );

				_endif

			_else

				SymbolTable->IsExternal = 1;
				_if( *$<returns>9 == '\0' )

					free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( $<idStr>1 );

				_else

					free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( $<returns>9 );

				_endif
				EmitTypedExtern
				( 
					SymbolTable,
					SymbolTable->StaticName, 
					tDWord 
				);

			_endif
			free2( vss $<returns>9 );
			_here;
		}
	;






 /*
 ** Static variable declarations using a single type ID:
 ** e.g., i:integer;
 */



StaticSingleType:
 		UndefinedID			/* $1 */ 
		Colon 				/* $2 */
		TypeID 				/* $3 */
		{					/* $4 */

			char			StaticName[ 1024 ];
			char 			*sn;
			/* struct	SymNode	*bt;*/


			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );

			_here;

			/*bt = GetBaseType( $<s>3 );*/

			_if( CantBeVar( $<s>3->pType ))

				yyerror( "Static/Storage variables cannot be this type" );

			_else
			
				sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
				sn = hlastrdup2( StaticName );
				InsertSym
				( 
					$<idStr>1, 
					$<s>3,
					$<s>3->pType, 
					cStatic, 
					$<s>3->Arity,
					$<s>3->Dimensions,
					$<s>3->NumElements, 
					NULL,
					$<s>3->ObjectSize,
					0,
					sn,
					$<s>3->Base,
					$<s>3->Fields,
					$<s>3->FieldCnt
				);
				$<idStr>$ = sn;
				
			_endif
			_here;
		}
		Semicolon			/* $5 */
		Options				/* $6 */
		OptionalExternal	/* $7 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>6,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<returns>7 != NULL && $<options.NoStorage>6 )

				yyerror
				(
					"Can't specify both 'NOSTORAGE' and 'EXTERNAL' options"
				);

			_endif
			_if( !CantBeVar( $<s>3->pType ))
			
				_if( $<s>3->pType == tProcptr )
				
					// Copy parameter info if a proc ptr.
					
					memcpy( &SymbolTable->u, &$<s>3->u, sizeof( union ValuesSize ));
					
				_endif


				// If this is an external declaration,
				// output an externdef statement to the ASM file.

				_if( $<returns>7 != NULL )
				 
					SymbolTable->IsExternal = 1;
					_if( *$<returns>7 == '\0' )

						free2( vss SymbolTable->StaticName );
						SymbolTable->StaticName = hlastrdup2( $<idStr>1 );

					_else

						free2( vss SymbolTable->StaticName );
						SymbolTable->StaticName = hlastrdup2( $<returns>7 );

					_endif
					EmitExtern( SymbolTable, $<s>3->ObjectSize );


				_else


					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					
					_if( $<s>3->pType == tClass )

						SymbolTable->Fields = 
							CopySymbols
							( 
								$<s>3->Fields,
								$<idStr>4
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_elseif(  $<s>3->pType == tThunk )

						/*
						** Need some dummy local vars for a thunk.
						*/

						SymbolTable->u.proc.parms = &true_ste;

					_endif


					_if( !$<options.NoStorage>6 )

						_if( IsPrimitive( $<s>3->pType ) )
						
							ReserveTypedStorage( $<idStr>4, $<s>3, 1 );

						_elseif
						( 
								$<s>3->pType == tPointer
							||	$<s>3->pType == tProcptr
						)
						
							ReserveTypedStorage( $<idStr>4, &dword_ste, 1 );
						
						_else
  
							ReserveUntypedStorage( $<idStr>4, $<s>3->ObjectSize );

						_endif

					_else // Nostorage active

						_if
						( 
								$<s>3->pType == tPointer
							||	$<s>3->pType == tProcptr
						)
						
							EmitTypedLabel( $<idStr>4, tDWord );
							
						
						_elseif( IsPrimitive( $<s>3->pType ))

							EmitTypedLabel( $<idStr>4, $<s>3->pType );

						_elseif
						( 
								$<s>3->pType == tPointer
							||	$<s>3->pType == tProcptr
						)
						
							EmitTypedLabel( $<idStr>4, tDWord );
							
						_else

							EmitTypedLabel( $<idStr>4, tByte );

						_endif

					_endif

				_endif

			_endif
			free2( vss $<returns>7 );
			_here;
		}
	;
	
	
	
	
 /*
 ** Static variable declarations using a single type ID (external declaration)
 ** e.g., i:integer;
 **
 */


StaticSingleExt:
		AnyLocalID			/* $1 */ 
		Colon 				/* $2 */
		TypeID				/* $3 */
		Semicolon			/* $4 */
		Options				/* $5 */
		{					/* $6 */

			struct	SymNode	*BaseType;

			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>5,
					specified_nostorage
				|	specified_volatile 
			);
			BaseType = GetBaseType( $<s>3 );

			_if( CantBeVar( BaseType->pType ))

				yyerror( "Static/Storage variables cannot be this type" );
				BaseType = &uns32_ste;

			_elseif( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				$<s>1->IsExternal = 0;
				EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
				_if( !$<options.NoStorage>5 )
				
					_if( IsPrimitive( $<s>3->pType ))
					
						ReserveTypedStorage( $<s>1->StaticName, $<s>3, 1 );
						
					_else
					
						ReserveUntypedStorage
						( 
							$<s>1->StaticName,
							_ifx
							( 
								$<s>1->NumElements == 0, 
								$<s>3->ObjectSize, 
								$<s>1->NumElements * $<s>3->ObjectSize 
							)
						);
						
					_endif

				_else
				
					EmitTypedLabel
					( 
						$<s>1->StaticName, 
						_ifx( $<s>1->StaticName ,$<s>3->pType, tByte )
					);
				
				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			_here;
		}
	;



 /*
 ** Array static variable definitions:
 ** e.g., b:integer[4];
 */


StaticArray:
		UndefinedID			/* $1 */
		Colon		   		/* $2 */
		TypeID 				/* $3 */
		'[' 				/* $4 */
		DimList 			/* $5 */
		Rbrack  			/* $6 */
		{					/* $7 */					

			int		*DimensionArray;
			int		ArraySize;
			char	*sn;
			char	StaticName[ 1024 ];


			assert( $<idStr>1 != NULL );
			assert( $<s>3 != NULL );
			assert( $<v.NumElements>5 > 0 );
			assert( $<v.Dimensions>5 != NULL );

			_here;

			sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );

			/*
			** Make sure this is a legal variable type
			** (e.g., no text variables).
			*/

			$<s>$ = NULL;
			
			_if( CantBeVar( $<s>3->pType ))
			
				yyerror( "Illegal static/storage variable type" );
				
			_else 
			
				/*
				** Check to see if this is an external declaration.
				*/


				/*
				** Check to see if TypeID is an array type
				** (i.e., we're creating a multi-dimensional array).
				*/

				_if( $<s>3->pType != tArray )

					/*
					** TypeID is *not* an array type, so create
					** a single dimension array here.
					*/

					ArraySize = $<s>3->ObjectSize * $<v.NumElements>5;
					sn = hlastrdup2( StaticName );
					InsertSym
					( 
						$<idStr>1, 
						$<s>3,
						tArray, 
						cStatic, 
						$<v.Arity>5,
						$<v.Dimensions>5,
						$<v.NumElements>5, 
						NULL,
						ArraySize,
						0,
						sn,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);




				/*
				** Okay, down here TypeID *is* an array type,
				** so we're creating a multi-dimensional array.
				*/

				_else

					struct SymNode *BaseType;

					assert( $<s>3->Dimensions != NULL );

					/*
					** Create the new dimension array by concatenating
					** the two existing dimension arrays.
					*/

					DimensionArray = 
						malloc2
						( 
							( $<s>3->Arity + $<v.NumElements>5 ) * 
								sizeof( int )
						);

					memcpy
					( 
						DimensionArray, 
						$<s>3->Dimensions, 
						$<s>3->Arity * sizeof( int )
					);
					memcpy
					(
						&DimensionArray[ $<s>3->Arity ],
						$<v.Dimensions>5,
						$<v.Arity>5 * sizeof( int )
					);
					ArraySize = $<s>3->ObjectSize * $<v.NumElements>5;

					/*
					** Add the new array to the symbol table.
					*/

					sn = hlastrdup2( StaticName );
					InsertSym
					( 
						$<idStr>1, 
						$<s>3,
						tArray, 
						cStatic, 
						$<s>3->Arity + $<v.Arity>5,
						DimensionArray,
						$<s>3->NumElements * $<v.NumElements>5, 
						NULL,
						ArraySize,
						0,
						sn,
						$<s>3->Base,
						$<s>3->Fields,
						$<s>3->FieldCnt
					);

				_endif
				$<s>$ = SymbolTable;

			_endif
			_here;
		}
		Semicolon			/* $8  */
		Options				/* $9  */
		OptionalExternal	/* $10 */
		{
		
			struct	SymNode *bt;

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<returns>10 != NULL && $<options.NoStorage>9 )

				yyerror
				(
					"Can't specify both 'NOSTORAGE' and 'EXTERNAL' options"
				);

			_endif
			_if( !CantBeVar( $<s>3->pType ))
			
				bt = GetBaseType( $<s>3 );
			
				/*
				** Check to see if TypeID is an array type
				** (i.e., we're creating a multi-dimensional array).
				*/

				_if( $<s>3->pType != tArray )

					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					_if( $<s>3->pType == tClass )

						SymbolTable->Fields = 
							CopySymbols
							( 
								$<s>3->Fields,
								$<s>3->StaticName
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

						/*
						** Check to see if this class object is external.
						*/

						_if( $<returns>10 != NULL )
						 
							SymbolTable->IsExternal = 1;
							_if( *$<returns>10 == '\0' )

								free2( vss SymbolTable->StaticName );
								SymbolTable->StaticName = 
									hlastrdup2( $<idStr>1 );

							_else

								free2( vss SymbolTable->StaticName );
								SymbolTable->StaticName = 
									hlastrdup2( $<returns>10 );

							_endif
							EmitExtern
							( 
								SymbolTable,
								bt->ObjectSize 
							);  


						_else /* No External Clause */
						
							_if( $<options.NoStorage>9 )
							
								EmitTypedLabel
								( 
									$<s>7->StaticName, 
									_ifx
									(
										IsPrimitive( $<s>3->pType ),
										$<s>3->pType,
										tByte
									) 
								);
								
							_else

								_if( IsPrimitive( $<s>3->pType ) )
								
									ReserveTypedStorage
									(
										$<s>7->StaticName,
										$<s>3,
										$<v.NumElements>5
									);
										
								_else
								
									ReserveUntypedStorage
									(
										$<s>7->StaticName, 
										$<s>3->ObjectSize*$<v.NumElements>5 
									);

								_endif

							_endif
							
						_endif
							
					_else
					
						_if(  $<s>3->pType == tThunk )

							/*
							** Need some dummy local vars for a thunk.
							*/

							SymbolTable->u.proc.parms = &true_ste;

						_endif

						/*
						** Check to see if this array object
						** is external.
						*/

						_if( $<returns>10 != NULL )
						 
							SymbolTable->IsExternal = 1;
							_if( *$<returns>10 != '\0' )

								free2( vss SymbolTable->StaticName );
								SymbolTable->StaticName = 
									hlastrdup2( $<returns>10 );

							_else

								free2( vss SymbolTable->StaticName );
								SymbolTable->StaticName =
									hlastrdup2( SymbolTable->TrueName );

							_endif
							EmitExtern
							( 
								SymbolTable,
								bt->ObjectSize 
							);  


						_else /* No External Clause */

							_if( $<options.NoStorage>9 )
									
								EmitTypedLabel
								( 
									$<s>7->StaticName, 
									_ifx
									( 
										IsPrimitive( $<s>3->pType ), 
										$<s>3->pType, 
										tByte
									) 
								);
								
							_else

								_if( IsPrimitive( $<s>3->pType ) )
								
									ReserveTypedStorage
									(
										$<s>7->StaticName,
										$<s>3, 
										$<v.NumElements>5 
									);
								
								_elseif
								( 
										$<s>3->pType == tPointer 	
									||	$<s>3->pType == tProcptr
								) 	
								
									ReserveTypedStorage
									(
										$<s>7->StaticName,
										&dword_ste, 
										$<v.NumElements>5 
									);
								
								_else
								
									ReserveUntypedStorage
									(
										$<s>7->StaticName,
										$<v.NumElements>5 * $<s>3->ObjectSize
									);
									
								_endif

							_endif
							
						_endif  

					_endif



				/*
				** Okay, down here TypeID *is* an array type,
				** so we're creating a multi-dimensional array.
				*/

				_else


					assert( $<s>3->Dimensions != NULL );


					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					
					_if( SymbolTable->Type->pType == tClass )

						int ThisObjSize;

						SymbolTable->Fields = 
							CopySymbols
							( 
								bt->Fields,
								bt->StaticName
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

						/*
						** See if it's an external array of classes
						** declaration.
						*/

						_if( $<returns>10 != NULL )
						 
							SymbolTable->IsExternal = 1;
							_if( *$<returns>10 == '\0' )

								free2( vss SymbolTable->StaticName );
								SymbolTable->StaticName = 
									hlastrdup2( $<idStr>1 );

							_else

								free2( vss SymbolTable->StaticName );
								SymbolTable->StaticName = 
									hlastrdup2( $<returns>10 );

							_endif

							EmitTypedExtern
							( 
								SymbolTable,
								SymbolTable->StaticName, 
								tDWord 
							);


						_else /* No External Clause */

							ThisObjSize = $<s>3->ObjectSize;
							EmitTypedLabel
							( 
								$<s>7->StaticName, 
								_ifx
								( 
									IsPrimitive( $<s>3->pType ), 
									$<s>3->pType, 
									tByte
								) 
							);
							_if( !$<options.NoStorage>9 )

								ReserveStorage
								( 
									ThisObjSize 
								);

							_endif

						_endif

					_else
					
						_if(  SymbolTable->Type->pType == tThunk )

							/*
							** Need some dummy local vars for a thunk.
							*/

							SymbolTable->u.proc.parms = &true_ste;

						_endif

						
						/*
						** Deal with other array types here.
						** First, see if this is an external declaration.
						*/

						_if( $<returns>10 != NULL )
						 
							SymbolTable->IsExternal = 1;
							_if( *$<returns>10 == '\0' )

								free2( vss SymbolTable->StaticName );
								SymbolTable->StaticName = 
									hlastrdup2( $<idStr>1 );

							_else

								free2( vss SymbolTable->StaticName );
								SymbolTable->StaticName = 
									hlastrdup2( $<returns>10 );

							_endif
							EmitExtern( SymbolTable, bt->ObjectSize );


						_else /* No External Clause */

							EmitTypedLabel
							( 
								$<s>7->StaticName, 
								_ifx
								( 
									IsPrimitive( $<s>3->pType ), 
									$<s>3->pType, 
									tByte
								) 
							);
							_if( !$<options.NoStorage>9 )

								ReserveStorage
								( 
									$<s>7->ObjectSize 
								);

							_endif
							
						_endif 

					_endif
					free2( vss $<v.Dimensions>5 );

				_endif

			_endif
			free2( vss $<returns>10 );
			_here;
		}
	;




 /*
 ** This production handles array declarations when
 ** there has been a previous forward declaration.
 */

StaticArrayExt:
		AnyLocalID		/* $1 */ 
		Colon			/* $2 */
		TypeID 			/* $3 */
		'[' 			/* $4 */
		DimList 		/* $5 */
		Rbrack  		/* $6 */
		Semicolon		/* $7 */
		Options			/* $8 */
		{				/* $9 */

			int				*DimensionArray;
			int				ArraySize;
			struct	SymNode	*bt;

			_here;
			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );
			assert( $<v.NumElements>5 > 0 );
			assert( $<v.Dimensions>5 != NULL );

			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			bt = GetBaseType( $<s>3 );

			/*
			** Make sure this is a legal variable type
			** (e.g., no text variables).
			*/

			_if( CantBeVar( $<s>3->pType ))
			
				yyerror( "Illegal static variable type" );
				
			_else 
			
				_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

					char *theType;

					$<s>1->IsExternal = 0;
					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitTypedLabel
					( 
						$<s>1->StaticName, 
						_ifx
						(
							IsPrimitive( bt->pType ),
							bt->pType,
							tByte
						)
					);
					_if( !$<options.NoStorage>8 )

						ReserveStorage
						( 
							$<s>1->ObjectSize 
						);

					_endif
						
					_if
					(
							$<s>1->ObjectSize
						!=	$<s>3->ObjectSize * $<v.NumElements>5
					)

						WarnNear
						( 
							"Declared size does not match external size",
							$<s>1->TrueName 
						);

					_endif

				_else

					ErrorNear
					( 
						"Duplicate symbol definition",
						$<s>1->TrueName,
						__LINE__,
						__FILE__
					);

				_endif


			_endif
			free2( vss $<v.Dimensions>5 );
			_here;
		}
	;




 /*
 ** Handle record static variable declarations here.
 */


StaticRecord:
			UndefinedID		/* $1 */
			Colon			/* $2 */ 
			dorecordTkn		/* $3 */
			recordOpts		/* $4 */
			OptInherits		/* $5 */
			RecordStuff		/* $6 */
			endrecordTkn	/* $7 */
			Semicolon		/* $8 */
			{
				struct	SymNode	*Fields;
				struct	SymNode	*CurSym;
				int				RecSize;
				int				FieldCnt;
				int				LargestField;
				char			StaticName[ 256 ];


				/*
				** Restore currentNS before we enter this record
				** type into the symbol table.
				*/
				
				_here;
				currentNS = $<ru.saveCurNS>3;
				RecNS = $<ru.saveRecNS>3;
				RecGlobal = $<ru.saveRecGlobal>3;

				/*
				** If CurOffset is zero at this point then there
				** weren't any fields in the record.  Records must
				** have at least one field.
				*/

				_if( RecFieldCnt != 0 )


					/*
					** If there is no base record, we need to mark
					** the end of the fields symbol list.  If there is
					** a base record, then that base record definition will
					** mark the end of our list.  In either case, we
					** need to count the number of fields in the record.
					*/
					
					FieldCnt = 0;
					CurSym = SymbolTable;
					LargestField = 0;
					_while
					( 
							CurSym->Next != NULL 
						&&	CurSym->Next != &dummyField_ste 
					)

						LargestField = 
							max( LargestField, CurSym->MaxObjectSize );
							
						++FieldCnt;
						CurSym = CurSym->Next;

					_endwhile
					LargestField = 
						max( LargestField, CurSym->MaxObjectSize );

					CurSym->Next = NULL;

					/*
					** Okay, create the record symbol table entry
					** and attach the fields symbol table to that entry.
					*/

					CurLexLevel = $<ru.SaveLex>3;	
					Fields = SymbolTable;			
					SymbolTable = $<ru.endFields>3;		
					CurOffset = AlignVarOffset( CurOffset, 1, 1 );
					RecSize = CurOffset - $<ru.CurOffset>3;			

					/*
					** If there was an align at the end of the
					** record, then we need to extend the size
					** of the record so that it is aligned on
					** the specified boundary.
					*/

					_if( TempRecAlign != 1 )
					

						RecSize = 
								(
										(RecSize + TempRecAlign - 1) 
									/ 	TempRecAlign 
								) * TempRecAlign;
								
						TempRecAlign = 1;

					_endif
					
					
					CurOffset = $<ru.SaveOffset>3;		
					CurOffsetDir = $<ru.SaveDir>3;	
					AddOffset1st = $<ru.SaveAdd1st>3;	

					sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
					InsertSym
					(
						$<idStr>1,
						$<ru.base>3,
						tRecord,
						cStatic,
						0,
						NULL,
						0,
						NULL,
						RecSize,
						0,
						hlastrdup2( StaticName ),
						$<ru.base>3,
						Fields,
						FieldCnt
					);
					SymbolTable->MaxObjectSize = LargestField;
					
					// Now we need to go through all the fields and
					// patch the "Parent" field to point at this
					// symbol table entry.
					
					_for( int fieldCntr = 0, fieldCntr < FieldCnt, ++fieldCntr )
					
						Fields->Parent = SymbolTable;
						Fields = Fields->Next;
						
					_endfor
					
					// Okay, reserve storage for this static object.
					
					ReserveUntypedStorage( StaticName, RecSize );
					

				_else

					yyerror
					( 
						"Record variables must have at least one field" 
					);

				_endif
				inRecord = $<ru.inSave>3;
				MinRecAlignment = $<ru.MinRecAlignment>3;
				MaxRecAlignment = $<ru.MaxRecAlignment>3;
				RecFieldCnt = $<ru.RecFieldCnt>3;
				_here;
			}
	;

				



 /*
 ** Handle union variable declarations here.
 **
 */

StaticUnion:
			UndefinedID
			Colon
			SaveOffset 
			SaveDirection
			SaveAdd1st
			SaveLex3
			unionTkn
			{
				_here;
				assert( $<idStr>1 != NULL );

				$<s>$ = SymbolTable;
				CurOffset = 0;
				CurOffsetDir = 0;	/* Forces all fields to the same offset */
				AddOffset1st = 0;

			}
			UnionStuff
			endunionTkn
			Semicolon
			{
				int					SizeOfUnion;
				int					FieldCnt;
				struct	SymNode		*Fields;
				struct	SymNode		*CurSym;
				struct	SymNode		*LastSym;

				/*
				** Determine if there were any fields in the union.
				** Error if not.
				*/

				_if( SymbolTable == $<s>8 )

					ErrorNear
					( 
						"Unions must have at least one field",
						"endunion",
						__LINE__,
						__FILE__ 
					);

				_else

					char	StaticName[ 256 ];

					/*
					** Null terminate the list of fields in the union.
					** Search for the saved symbol table entry which
					** marks the first entry that is not a field.  Upon
					** finding that entry, store a NULL in the previous
					** link field.
					*/

					CurSym = SymbolTable;
					SizeOfUnion = 0;
					FieldCnt = 0;
					_while( CurSym != $<s>8 )

						SizeOfUnion = 
							max( SizeOfUnion, CurSym->ObjectSize);
						
						LastSym =  CurSym;
						CurSym = CurSym->Next;
						++FieldCnt;

					_endwhile
					LastSym->Next = NULL;


					/*
					** Restore all the compiler variables and set
					** up Fields so we can enter the union variable
					** into the symbol table.
					*/

					CurLexLevel = $<v.u.intval>6;
					Fields = SymbolTable;
					SymbolTable = $<s>8;
					CurOffset = $<v.u.intval>3;
					CurOffsetDir = $<v.u.intval>4;
					AddOffset1st = $<v.u.unsval>5;

					sprintf( StaticName, "%s" sympost "%d", $<idStr>1, LblCntr++ );
					InsertSym
					(
						$<idStr>1,
						NULL,
						tUnion,
						cStatic,
						0,
						NULL,
						0,
						NULL,
						SizeOfUnion,
						0,
						hlastrdup2( StaticName ),
						NULL,
						Fields,
						FieldCnt
					);
					ReserveUntypedStorage( StaticName, SizeOfUnion );

				_endif
				_here;
			}
	;


/********************************************************************/
/*                                                         			*/
/* The following productions handle static variable declarations.	*/
/*                                                         			*/
/********************************************************************/



StaticVars:	
		SetInStatic
		OutputDSEG
		OptionalAlignment
		doStaticVars
		OutputEndDSEG
		{
			_here;
			inStatic = 0;
		}
	;
	


SetInStatic:
		{
			_here;
			inStatic = 1;
		}
	;

OutputDSEG:	
		{
			_here;
			startDseg();
		}
	;

OutputEndDSEG: 
		{
			_here;
			endDseg();
			_here;
		}
	;

OptionalAlignment:
		Empty { _here; }

	|	'('
		ConstExpr
		Rparen
		{
			_here;
			_if
			( 
					IsNumber( $<v.pType>2 )
				&&	numBits32( YYS &$<v>2 ) <= 32 
				&&	(
							$<v.u.unsval>2 == 1
						||	$<v.u.unsval>2 == 2
						||	$<v.u.unsval>2 == 4
						||	$<v.u.unsval>2 == 8
						||	$<v.u.unsval>2 == 16
					)
			)

				EmitAlign( $<v.u.unsval>2 );

			_else

				yyerror
				( 
					"Expected the constant 1, 2, 4, 8, or 16 here" 
				);

			_endif
			FreeValue( YYS &$<v.u.unsval>2 );
			_here;
		}
	;



doStaticVars:

		/* Empty */ 
	|	 doStaticVars StaticDef 
	;

//oneOrMoreStaticVars:
//		StaticDef 
//	|	oneOrMoreStaticVars StaticDef 
//	;



			/*
			** Allow emission of the VMT here.
			*/

StaticDef:
		vmtTkn				/* $1 */
		Lparen				/* $2 */
		TypeID				/* $3 */
		Rparen				/* $4 */
		Semicolon			/* $5 */
		OptionalExternal	/* $6 */
		{
			_here;
			_if( $<s>3->pType == tClass )

				/*
				** Okay, build the Virtual Method Table for
				** this class and adjust the offsets for each
				** of the methods to reflect the index into the
				** VMT.
				*/

				_if( $<returns>6 == NULL )  // No "@external" on VMT.
				
					BuildVMT( $<s>3, $<s>3->StaticName );
					extLookup
					( 
						$<s>3, 				  // sym,
						$<s>3->StaticName, 	  // theLabel, 
						tDWord, 			  // theType, 
						1, 					  // IsPublic,
						1, 					  // ForceRef,
						1 					  // isVMT 
					);
					
				_elseif( *$<returns>6 == '\0' ) // @external;
				
					extLookup
					( 
						$<s>3, 				  // sym,
						$<s>3->StaticName, 	  // theLabel, 
						tDWord, 			  // theType, 
						0, 					  // IsPublic,
						0, 					  // ForceRef,
						1 					  // isVMT 
					);
				
				_else		// @external( "some_name" );

					extLookup
					( 
						$<s>3, 				  // sym,
						$<returns>6,	 	  // theLabel, 
						tDWord, 			  // theType, 
						0, 					  // IsPublic,
						0, 					  // ForceRef,
						1 					  // isVMT 
					);
				
				_endif

			_else

				yyerror( "Expected a class type identifier" );

			_endif
			_here;
		}

	|	UndefinedID			/* $1 */ 
		Colon 				/* $2 */
		vmtTkn				/* $3 */
		Lparen				/* $4 */
		TypeID				/* $5 */
		Rparen				/* $6 */
		Semicolon			/* $7 */
		OptionalExternal	/* $8 */
		{
			char *sn;

			/*
			** Okay, the user wants to attach a label to this VMT.
			** Automatically make it public.
			*/

			_here;
			sn = hlastrdup2( $<idStr>1 );
			InsertSym
			( 
				$<idStr>1,			/* Name			*/
				&dword_ste,			/* Type			*/
				tDWord, 			/* pType		*/
				cStatic,			/* SymClass		*/ 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* CurOffset	*/
				sn,					/* StaticName	*/
				NULL,				/* BaseType		*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);
			EmitTypedPublic( sn, tDWord );
			EmitTypedLabel( sn, tDWord );

			_if( $<s>5->pType == tClass )

				/*
				** Okay, build the Virtual Method Table for
				** this class and adjust the offsets for each
				** of the methods to reflect the index into the
				** VMT.
				*/

				_if( $<returns>8 == NULL )
				
					BuildVMT( $<s>5, $<s>5->StaticName );
					extLookup
					( 
						$<s>5, 				  // sym,
						$<s>5->StaticName, 	  // theLabel, 
						tDWord, 			  // theType, 
						1, 					  // IsPublic,
						1, 					  // ForceRef,
						1 					  // isVMT 
					);
					
				_elseif( *$<returns>8 == '\0' ) // @external;
				
					extLookup
					( 
						$<s>5, 				  // sym,
						$<s>5->StaticName, 	  // theLabel, 
						tDWord, 			  // theType, 
						0, 					  // IsPublic,
						0, 					  // ForceRef,
						1 					  // isVMT 
					);
				
				_else

					extLookup
					( 
						$<s>3, 				  // sym,
						$<returns>8,	 	  // theLabel, 
						tDWord, 			  // theType, 
						0, 					  // IsPublic,
						0, 					  // ForceRef,
						1 					  // isVMT 
					);
				
				_endif

			_else

				yyerror( "Expected a class type identifier" );

			_endif
			_here;
		}
	;
	
StaticDef:
		vmtTkn				/* $1 */
		Lparen				/* $2 */
		UndefID				/* $3 */
		Rparen				/* $4 */
		Semicolon			/* $5 */
		OptionalExternal	/* $6 */
		{
			char msg[1024];
			
			sprintf
			( 
				msg, 
				"Undefined type ID in VMT statement: '%s'\n", 
				$<idStr>3 
			);
			yyerror( msg );			
		}
	;
	




StaticDef:

			/*
			** Allow empty declarations (just a semicolon) for
			** syntactical reasons (e.g., to put semicolons after
			** macros and such).
			*/

			';'
	;



 /*
 ** Handle the "ID:FORWARD(ID);" declaration to support
 ** macro redeclarations of a symbol.
 */

StaticDef: UndefinedForward;	

 /*
 ** Handle ALIGN Directive
 */

StaticDef: StaticAlign;
	

 /*
 ** Handle procedure pointer variables here.
 */

StaticDef: StaticPtrToProcUninit;
StaticDef: StaticProcUninit;


 /*
 ** Handle a static procedure variable declaration that occurs
 ** after an external declaration (or a duplicate symbol definition).
 */

StaticDef: StaticPtrToProcRedef;
StaticDef: StaticProcRedef;

 /*
 ** Handle procedure pointer variables with initializers here.
 */


StaticDef: StaticPtrToProcInit;
StaticDef: StaticProcInit;


 /*
 ** Handle a static procedure variable declaration with an initializer
 ** that occurs after an external declaration (or a duplicate symbol 
 ** definition).
 */

StaticDef: StaticPtrToProcRedefInit;
StaticDef: StaticRedefInit;


 /*
 ** Static variable with an enumerated type declaration:
 ** e.g., colorVar: enum={red, green, blue};
 **
 ** See the corresponding code in the TypeDef
 ** productions for comments on how enums work.
 **
 */

StaticDef: StaticEnum;


/*
** Static enum variable with the no storage option.
*/






/*
** Static enum variable with an initializer.
*/

StaticDef: StaticEnumInit;




 /*
 ** Handle pointer declarations to user-defined types here.
 */

StaticDef: StaticPtrToUserNoInit;

 /*
 ** Deal with a declaration of a pointer to a user-defined type
 ** that has had a previous external declaration.
 */

StaticDef: StaticPtrToUserExt;


 /*
 ** Handle pointer declarations to user-defined types with
 ** an initializer here.
 */

StaticDef:	StaticPtrToUser;

 /*
 ** Handle a pointer to a user defined type with an intializer,
 ** assuming a previous external declaration.
 */

StaticDef: StaticPtrToExtUser;




 /*
 ** Handle pointer declarations to the built-in types here.
 */

StaticDef: StaticPtrBuiltInNoInit;


 /*
 ** Handle pointer declarations to the built-in types
 ** that have a previous external declaration.
 */

StaticDef: StaticPtrToBuiltInNS;

 /*
 ** Handle pointer declarations to the built-in types 
 ** with initializers here.
 */

StaticDef: StaticPtrToBuiltIn;




 /*
 ** Handle pointer declarations to the built-in types with an initializer
 ** that have a previous external declaration.
 */

StaticDef: StaticPtrToBuiltInExt;






 /*
 ** Static variable declarations using a single type ID:
 ** e.g., i:integer;
 */



StaticDef: StaticSingleType;


 /*
 ** Static variable declarations using a single type ID (external declaration)
 ** e.g., i:integer;
 **
 */


StaticDef: StaticSingleExt;




 /*
 ** Static variable declarations using a single type ID with
 ** an initializer.  e.g., i:int8 := 5;
 ** Note: external is not allowed here.
 */


StaticDef: StaticSingleTypeInit;




 /*
 ** Static variable declarations using a single type ID with
 ** an initializer.  e.g., i:int8 := 5;
 ** Note: This production handles the case where this symbol
 ** was previously declared.
 */

StaticDef: StaticSingleTypeWasExt;


 /*
 ** Array static variable definitions:
 ** e.g., b:integer[4];
 */


StaticDef: StaticArray;



 /*
 ** This production handles array declarations when
 ** there has been a previous forward declaration.
 */

StaticDef: StaticArrayExt;



 /*
 ** Array static variable definitions with initializers
 ** e.g., b:int8[4] := [1,2,3,4];
 **
 */

StaticDef: StaticArrayInit;





StaticDef: StaticArrayInitExt;




 /*
 ** Handle record static variable declarations here.
 */


StaticDef: StaticRecord;
				



 /*
 ** Handle union variable declarations here.
 **
 */

StaticDef: StaticUnion;



		/*
		** Handle the output of arbitrary constants in
		** the static section down here.
		*/

StaticDef:
			TypeID 
			{ $<s>$ = $<s>1; } 
			ConstantList 
			Semicolon
			{
				(void) $<s>2;	// shut up bison
			}
	;
				


		/*
		** Handle some common errors down here.
		**
		*/

StaticDef: VarErrors;
		




























/********************************************************************/
/*                                                         			*/
/* The following productions handle READONLY variable declarations. */
/*                                                         			*/
/********************************************************************/


ReadOnlyVars:	
			SetInReadOnly
			OutputReadOnly
			OptionalROAlignment
			doReadOnlyVars
			OutputEndReadOnly
			{
				_here;
				inReadonly = 0;
			}
		;
	


SetInReadOnly:
		{
			_here;
			inReadonly = 1;
		}
	;

OutputReadOnly:	
		{
			_here;
			startROseg();
		}
		;

OutputEndReadOnly: 
		{
			_here;
			endROseg();
		}
		;

OptionalROAlignment:
			Empty
			

		|	'('
			ConstExpr
			Rparen
			{
				_here;
				_if
				( 
						IsNumber( $<v.pType>2 )
					&&	numBits32( YYS &$<v>2 ) <= 32  
					&&	(
								$<v.u.unsval>2 == 1
							||	$<v.u.unsval>2 == 2
							||	$<v.u.unsval>2 == 4
							||	$<v.u.unsval>2 == 8
							||	$<v.u.unsval>2 == 16
						)
				)

					EmitAlign( $<v.u.unsval>2 );

				_else

					yyerror( "Expected the constant 1, 2, 4, 8, or 16 here" );

				_endif
			}
		;



doReadOnlyVars:

			/* Empty */ 
		|	 doReadOnlyVars ReadOnlyDef 
		;
	 



ReadOnlyDef:

			/*
			** Allow empty declarations (just a semicolon) for
			** syntactical reasons (e.g., to put semicolons after
			** macros and such).
			*/

			';'
	;


 /*
 ** Handle the "ID:FORWARD(ID);" declaration to support
 ** macro redeclarations of a symbol.
 */

ReadOnlyDef: UndefinedForward;


 /*
 ** Handle emission of the VMT to the READONLY segment.
 */



ReadOnlyDef:
		vmtTkn				/* $1 */
		Lparen				/* $2 */
		TypeID				/* $3 */
		Rparen				/* $4 */
		Semicolon			/* $5 */
		OptionalExternal	/* $6 */
		{
			_here;
			_if( $<s>3->pType == tClass )

				/*
				** Okay, build the Virtual Method Table for
				** this class and adjust the offsets for each
				** of the methods to reflect the index into the
				** VMT.
				*/

				_if( $<returns>6 == NULL )
				
					BuildVMT( $<s>3, $<s>3->StaticName );
					extLookup
					( 
						$<s>3, 				  // sym,
						$<s>3->StaticName, 	  // theLabel, 
						tDWord, 			  // theType, 
						1, 					  // IsPublic,
						1, 					  // ForceRef,
						1 					  // isVMT 
					);
					
				_else // @external;
				
					extLookup
					( 
						$<s>3, 				  // sym,
						$<s>3->StaticName, 	  // theLabel, 
						tDWord, 			  // theType, 
						0, 					  // IsPublic,
						0, 					  // ForceRef,
						1 					  // isVMT 
					);
					_if( *$<returns>6 != '\0' )
					
						HLAWarning
						( 
							"Ignoring VMT external string", 
							$<returns>6, 
							__LINE__, 
							__FILE__ 
						);
						
					_endif
								
				_endif

			_else

				yyerror( "Expected a class type identifier" );

			_endif
			_here;
		}
	;
	
	

// readonly undefID : vmt( type ); {@external}

ReadOnlyDef:
		UndefinedID			/* $1 */ 
		Colon 				/* $2 */
		vmtTkn				/* $3 */
		Lparen				/* $4 */
		TypeID				/* $5 */
		Rparen				/* $6 */
		Semicolon			/* $7 */
		OptionalExternal	/* $8 */
		{
			char *sn;

			/*
			** Okay, the user wants to attach a label to this VMT.
			** Automatically make it public.
			*/

			_here;
			sn = hlastrdup2( $<idStr>1 );
			InsertSym
			( 
				$<idStr>1,			/* Name			*/
				&dword_ste,			/* Type			*/
				tDWord, 			/* pType		*/
				cStatic,			/* SymClass		*/ 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* CurOffset	*/
				sn,					/* StaticName	*/
				NULL,				/* BaseType		*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);
			EmitTypedPublic( sn, tDWord );
			EmitTypedLabel( sn, tDWord );

			_if( $<s>5->pType == tClass )

				/*
				** Okay, build the Virtual Method Table for
				** this class and adjust the offsets for each
				** of the methods to reflect the index into the
				** VMT.
				*/

				_if( $<returns>8 == NULL )
				
					BuildVMT( $<s>5, $<s>5->StaticName );
					extLookup
					( 
						$<s>5, 				  // sym,
						$<s>5->StaticName, 	  // theLabel, 
						tDWord, 			  // theType, 
						1, 					  // IsPublic,
						1, 					  // ForceRef,
						1 					  // isVMT 
					);
					
				_else // @external;
				
					extLookup
					( 
						$<s>5, 				  // sym,
						$<s>5->StaticName, 	  // theLabel, 
						tDWord, 			  // theType, 
						0, 					  // IsPublic,
						0, 					  // ForceRef,
						1 					  // isVMT 
					);
					_if( *$<returns>8 != '\0' )
					
						HLAWarning
						( 
							"Ignoring VMT external string", 
							$<returns>8, 
							__LINE__, 
							__FILE__ 
						);
						
					_endif
								
				_endif

			_else

				yyerror( "Expected a class type identifier" );

			_endif
			_here;
		}
	;









/*
** Handle the "align" directive here.
*/

ReadOnlyDef: StaticAlign;

 /*
 ** Handle procedure pointer variables with initializers here.
 */

ReadOnlyDef: StaticPtrToProcInit;
ReadOnlyDef: StaticProcInit;



// Handle a procedure pointer declaration
//
// undefID:procedure{ (parms) }; {options}


ReadOnlyDef:
		UndefinedID			/* $1  */ 
		Colon 				/* $2  */
		procedureTkn 		/* $3  */
		SaveOffset 			/* $4  */
		SaveDirection		/* $5  */
		InsertProcSym 		/* $6  */
		OptionalParms 		/* $7  */
		Semicolon			/* $8  */
		Options				/* $9  */
		OptionalExternal	/* $10 */
		{
			struct	SymNode	*s;
			union YYSTYPE value;

			_here;
			--CurLexLevel;
			CurOffset = $<v.u.intval>4;
			CurOffsetDir = $<v.u.unsval>5;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_returns
				|	specified_use
				|	specified_pascal
				|	specified_stdcall
				|	specified_cdecl
				|	specified_alignment 
			);
			_if( $<options.NoStorage>9 && $<returns>10 != NULL )

				yyerror( "'nostorage' option is illegal here" );

			_endif
			
			// Need to create a dummy type to hold the procedure pointer parameters.
			
			s = SymbolTable;
			InsertSym
			( 
				" (procptr parms) ", 
				NULL,
				tProcptr, 
				cType, 
				0,
				NULL,
				0, 
				NULL,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			SymbolTable->u.proc.parms = s;
			SymbolTable->u.proc.returns = hlastrdup2( "" );
			SymbolTable->u.proc.use = NULL;
			SymbolTable->u.proc.cs = $<options.CallingSequence>9;
			$<s>6->Type = SymbolTable;
			$<s>6->u.proc.parms->Type = SymbolTable;
			
			// Remove the dummy entry from the symbol table:
			
			SymbolTable = s;
			
			// Patch the original symbol table entries:

			$<s>6->u.proc.parms->u.proc.parms = SymbolTable;
			$<s>6->u.proc.parms->u.proc.returns = hlastrdup2( "" );
			$<s>6->u.proc.parms->u.proc.use = NULL;
			$<s>6->u.proc.parms->u.proc.Locals = NULL;

			$<s>6->u.proc.parms = SymbolTable;
			$<s>6->u.proc.returns = $<options.returns>9;
			$<s>6->u.proc.use = $<options.use>9;
			$<s>6->u.proc.cs = $<options.CallingSequence>9;
			
			/*
			** Just to be on the safe side, let's create
			** a "parms" and "vars" entry for this object.
			*/
			
			ClrConst
			(
				YYS &value,
				tUns32,
				&uns32_ste
			);
			value.v.u.unsval = $<v.u.unsval>7;
			InsertSym
			( 
				"_parms_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,
				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			value.v.u.unsval = 0;
			InsertSym
			( 
				"_vars_", 
				&uns32_ste,
				tUns32, 
				cConstant, 
				0,

				NULL,
				0, 
				YYS &value,
				4,
				0,
				NULL,
				NULL,
				NULL,
				0
			);
			$<s>6->u.proc.parms->u.proc.Locals = SymbolTable;
			$<s>6->u.proc.Locals = SymbolTable;
			
			SymbolTable = $<s>6;

			// Deal with the @external option here:
			
			_if( $<returns>10 != NULL )
			
				$<s>6->IsExternal = 1;
			 	free2( vss $<s>6->StaticName );
				_if( *$<returns>10 == '\0' )

					$<s>6->StaticName = hlastrdup2( $<s>6->TrueName );
					free2( vss $<returns>10 );

				_else
					
					$<s>6->StaticName = $<returns>10;

				_endif
				EmitTypedExtern( $<s>6, $<s>6->StaticName, tDWord );
				
			_elseif( $<options.NoStorage>9 )

				// @nostorage option was present.
				
				EmitTypedLabel( $<s>6->StaticName, tDWord );

			_else

				yyerror
				( 
					NeedsInitializerMsg 
				);

			_endif 
			_here;
		}
	;


EnterReadOnlyDef:
		{
			
			char StaticName[ 256 ];
			char *sn;

			_here;
			assert( $<idStr>-6 != NULL );

			sprintf( StaticName, "%s" sympost "%d", $<idStr>-6, LblCntr++ );
			sn = hlastrdup2( StaticName );

			CreatePtrToProc( $<idStr>-6, $<s>-1, sn, cStatic );
			 
			_here;
		}
	;
	

// undefID:pointer to procedure ID; {options} @external;
ReadOnlyDef:
		UndefinedID			/* $1  */ 
		Colon 				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		procedureTkn 		/* $5  */
		DefinedID			/* $6  */
		Semicolon			/* $7  */
		EnterReadOnlyDef	/* $8  */
		Options				/* $9 */
		RequiredExternal	/* $10 */
		{
			_here;
			assert( $<returns>10 != NULL );
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_returns
				|	specified_use
				|	specified_pascal
				|	specified_stdcall
				|	specified_cdecl
				|	specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>9 )

				yyerror( "'@nostorage' option is illegal here" );

			_endif

			SymbolTable->IsExternal = 1;
			_if( *$<returns>10 == '\0' )

			 	free2( vss SymbolTable->StaticName );
				SymbolTable->StaticName = hlastrdup2( SymbolTable->TrueName );
				free2( vss $<returns>10 );

			_else

				SymbolTable->StaticName = $<returns>10;

			_endif
			EmitTypedExtern( SymbolTable, SymbolTable->StaticName, tDWord );
			_here;
		}
	;



// undefID:pointer to procedure ID; {options}

ReadOnlyDef:
		UndefinedID			/* $1  */ 
		Colon 				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		procedureTkn 		/* $5  */
		DefinedID			/* $6  */
		Semicolon			/* $7  */
		EnterReadOnlyDef	/* $8  */
		Options				/* $9  */
		{
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>9 )

				EmitTypedLabel( SymbolTable->StaticName, tDWord );

			_else

				yyerror
				( 
					NeedsInitializerMsg 
				);

			_endif
			_here;
		}
	;







 /*
 ** Handle a readonly procedure variable declaration with an initializer
 ** that occurs after an external declaration (or a duplicate symbol 
 ** definition).
 */

ReadOnlyDef: StaticPtrToProcRedefInit;
ReadOnlyDef: StaticRedefInit;


// localID:procedure {(parms)}; {options}

ReadOnlyDef:
		AnyLocalID				/* $1 */ 
		Colon 					/* $2 */
		procedureTkn			/* $3 */
		SaveLocalIDPtr	 		/* $4 */
		MatchParms 				/* $5 */
		Semicolon				/* $6 */
		Options					/* $7 */
		{						/* $8 */

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>7,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>7 )

				_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

					EmitTypedLabel( $<s>1->StaticName, tDWord );
					
				_else

					ErrorNear
					( 
						"Duplicate symbol definition",
						$<s>1->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				yyerror( NeedsInitializerMsg );

			_endif
			_here;
		}
	;


// localID:pointer to procedure ID; {options}

ReadOnlyDef:
		AnyLocalID			/* $1  */ 
		Colon 				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		procedureTkn 		/* $5  */
		DefinedID			/* $6  */
		Semicolon			/* $7  */
		Options				/* $8  */
		{
			
			char msg[256];
			char StaticName[ 256 ];
			char *sn;

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			assert( $<idStr>1 != NULL );

			assert( $<s>1->u.proc.Forward != NULL );
			_if( $<s>1->u.proc.Forward != $<s>6 )
				
				sprintf
				( 
					msg,
					"Base procedure does not agree with original "
					"declaration\n('%s' should be '%s')",
					$<s>6->TrueName,
					$<s>1->u.proc.Forward->TrueName
				);
				yyerror( msg );
				
			_endif

			_if( $<options.NoStorage>8 )

				_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

					EmitTypedLabel( $<s>1->StaticName, tDWord );

				_else

					ErrorNear
					( 
						"Duplicate symbol definition",
						$<s>1->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				yyerror( NeedsInitializerMsg );

			_endif
			_here;
		}
	;







	/*
	** Static enum variable with an initializer.
	*/

ReadOnlyDef: StaticEnumInit;


// undefID:enum{ idlist }; {options}

ReadOnlyDef:
		UndefinedID		/* $1  */  
		Colon 			/* $2  */
		enumTkn			/* $3  */
		InsertEnum		/* $4  */
		Lbrace			/* $5  */
		SaveEnumSym 	/* $6  */
		EnumList 		/* $7  */
		Rbrace			/* $8  */
		{				/* $9  */

			// Fix up the generated enum type to include a pointer to
			// the enum symbols and the count of enum symbols:
			
			_here;
			$<s>4->Fields = SymbolTable;
			$<s>4->FieldCnt = EnumVal;

		}
		Semicolon		/* $10 */
		Options			/* $11 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>11,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<options.NoStorage>11 )

				EmitLabel( $<s>4->StaticName, EnumSize ); 

			_else

				yyerror( NeedsInitializerMsg );

			_endif
			_here;
		}
	;




 /*
 ** Handle pointer declarations to user-defined types with
 ** an initializer here.
 */

ReadOnlyDef: StaticPtrToUser;


 /*
 ** Handle a pointer declaration with the NOSTORAGE option
 */

EnterROPDef:
		{

			struct	SymNode			*BaseType;
			char	*sn;
			char	StaticName[ 256 ];

			assert( $<idStr>-4 != NULL );
			assert( $<neID.idStr>0 != NULL );

			_here;
			BaseType = $<neID.s>0;
			_if( BaseType != NULL )

				BaseType = GetBaseType( BaseType );
				_if( CantBeVar( BaseType->pType ))

					yyerror( "Readonly variables cannot be this type" );
					BaseType = &uns32_ste;

				_endif

			_endif

			sprintf( StaticName, "%s" sympost "%d", $<idStr>-4, LblCntr++ );
			sn = hlastrdup2( StaticName );
			InsertSym
			( 
				$<idStr>-4,			/* Name			*/
				&pointer_ste,		/* Type			*/
				tPointer, 			/* pType		*/
				cStatic,			/* SymClass		*/ 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* CurOffset	*/
				sn,					/* StaticName	*/
				BaseType,			/* BaseType		*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);
			$<s>$ = SymbolTable;
			_here;
		}
	;
	

// undefID:pointer to typeID; {options}

ReadOnlyDef:
		UndefinedID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		AnyID				/* $5 */
		EnterROPDef			/* $6 */
		Semicolon			/* $7 */
		Options				/* $8 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			_if( !$<options.NoStorage>8 )

				yyerror
				( 
					"Readonly object requires an initializer\n"
					"or the 'NOSTORAGE' option."
				);

			_endif
			EmitTypedLabel( $<s>6->StaticName, tDWord );


			_if( $<s>6->Base == NULL )

				Add2PtrList( $<s>6, $<neID.idStr>5 );

			_endif
			_here;
		}
	;


 /*
 ** Handle a readonly declaration of an external pointer to a user
 ** defined object.
 */
 
 // undefID:pointer to type; {options} @external;
 
ReadOnlyDef:
		UndefinedID			/* $1  */ 
		Colon 				/* $2  */
		pointerTkn			/* $3  */
		toTkn				/* $4  */
		AnyID				/* $5  */
		EnterROPDef			/* $6  */
		Semicolon			/* $7  */
		Options				/* $8  */
		RequiredExternal	/* $9  */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_volatile 
			);
			_if( $<returns>9 == NULL )
			 
				EmitTypedLabel( $<s>6->StaticName, tDWord );
				EmitDwordConst( 0, "" );

			_else

				$<s>6->IsExternal = 1;
				_if( *$<returns>9 == '\0' )

					free2( vss $<s>6->StaticName );
					$<s>6->StaticName = hlastrdup2( $<idStr>1 );

				_else

					free2( vss $<s>6->StaticName );
					$<s>6->StaticName = hlastrdup2( $<returns>9 );

				_endif
				EmitTypedExtern
				( 
					$<s>6, 
					SymbolTable->StaticName, 
					tDWord 
				);

			_endif
			free2( vss $<returns>9 );


			_if( $<s>6 == NULL )
			
				Add2PtrList( SymbolTable, $<neID.idStr>5 );

			_endif
			_here;
		}
	;



 /*
 ** Handle a pointer to a user defined type with an intializer,
 ** assuming a previous external declaration.
 */


ReadOnlyDef: StaticPtrToExtUser;

 /*
 ** Handle a pointer to a user defined type using the nostorage
 ** option assuming the presence of a previous external declaration.
 */
 

// localID:pointer to type; {options}
 
ReadOnlyDef:
		AnyLocalID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		AnyID				/* $5 */
		Semicolon			/* $6 */
		Options				/* $7 */
		{					/* $8 */

			struct	SymNode *BaseType;
	
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>7,
					specified_nostorage
				|	specified_volatile 
			);
			_if( !$<options.NoStorage>7 )

				yyerror
				( 
					"Readonly object requires an initializer\n"
					"or the 'NOSTORAGE' option."
				);

			_endif
			BaseType = $<neID.s>5;
			_if( BaseType != NULL )

				BaseType = GetBaseType( BaseType );
				_if( CantBeVar( BaseType->pType ))

					yyerror( "Readonly variables cannot be this type" );
					BaseType = &uns32_ste;

				_endif

			_endif

			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				_if( $<s>1->Type == &pointer_ste && $<s>1->Base == BaseType ) 

					$<s>1->IsExternal = 0;
					EmitTypedPublic( $<s>1->StaticName, tDWord );
					EmitTypedLabel( $<s>1->StaticName, tDWord ); 

				_else

					ErrorNear
					(
						"External base type must match declared base type",
						$<neID.idStr>5,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif


			_if( BaseType == NULL )

				Add2PtrList( $<s>1, $<neID.idStr>5 );
				
			_endif

			free2( vss $<neID.idStr>5 );
			_here;
		}
	;


 /*
 ** Handle pointer declarations to the built-in types 
 ** with initializers here.
 */


ReadOnlyDef: StaticPtrToBuiltIn;


 /*
 ** Handle a pointer to a built-in types with the NOSTORAGE option.
 */

EnterRODef2:
		{

			struct	SymNode *BaseType;
			char			*sn;
			char			StaticName[ 256 ];

			assert( $<idStr>-4 != NULL );

			_here;
			BaseType = $<s>0;
			_if( CantBeVar( BaseType->pType ))

				yyerror( "Readonly variables cannot be this type" );
				BaseType = &uns32_ste;

			_endif

			sprintf( StaticName, "%s" sympost "%d", $<idStr>-4, LblCntr++ );
			sn = hlastrdup2( StaticName );
			InsertSym
			( 
				$<idStr>-4,			/* Name			*/
				&pointer_ste,		/* Type			*/
				tPointer, 			/* pType		*/
				cStatic,			/* SymClass		*/ 
				0,					/* Arity		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				4,					/* ObjectSize	*/
				0,					/* CurOffset	*/
				sn,					/* StaticName	*/
				BaseType,			/* BaseType		*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);

			 
			EmitTypedLabel( sn, tDWord );
			_here;
		}
	;


// undefID:pointer to type; {options}

ReadOnlyDef:
		UndefinedID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		ReservedTypeIDs		/* $5 */
		EnterRODef2			/* $6 */
		Semicolon			/* $7 */
		Options				/* $8 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			_if( !$<options.NoStorage>8 )

				yyerror
				( 
					"Readonly object requires an initializer\n"
					"or the 'NOSTORAGE' option."
				);

			_endif
		}
	;






 /*
 ** Handle an external definition of a pointer to a built-in type.
 */
 
// undefID:pointer to type; {options} @external;

ReadOnlyDef:
		UndefinedID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		ReservedTypeIDs		/* $5 */
		EnterRODef2			/* $6 */
		Semicolon			/* $7 */
		Options				/* $8 */
		RequiredExternal	/* $9 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_volatile 
			);
 
			_if( $<returns>9 == NULL )
			 
				EmitTypedLabel( SymbolTable->StaticName, tDWord );
				EmitDwordConst( 0, "" );

			_else

				SymbolTable->IsExternal = 1;
				_if( *$<returns>9 == '\0' )

					free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( $<idStr>1 );

				_else

					free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( $<returns>9 );

				_endif
				EmitTypedExtern
				( 
					SymbolTable,
					SymbolTable->StaticName, 
					tDWord 
				);

			_endif
			free2( vss $<returns>9 );
			_here;
		}
	;



 /*
 ** Handle pointer declarations to the built-in types with an initializer
 ** that have a previous external declaration.
 */
 

ReadOnlyDef: StaticPtrToBuiltInExt;

 /*
 ** Handle a pointer to a built-in type of an external symbol
 ** using the nostorage option.
 */
 
ReadOnlyDef: StaticPtrToBuiltInNS;


 /*
 ** ReadOnly variable declarations using a single type ID with
 ** an initializer.  e.g., i:int8 := 5;
 ** Note: external is not allowed here.
 */


ReadOnlyDef: StaticSingleTypeInit;


 /*
 ** Single type id declarations with nostorage option.
 */

EnterRODef3:
		{

			char			StaticName[ 256 ];
			char 			*sn;
			int				size;


			assert( $<idStr>-2 != NULL );
			assert( $<s>0 != NULL );

			_here;

			size = $<s>0->ObjectSize;

			_if( CantBeVar( $<s>0->pType ))

				yyerror( "Readonly variables cannot be this type" );

			_else
			
				sprintf( StaticName, "%s" sympost "%d", $<idStr>-2, LblCntr++ );
				sn = hlastrdup2( StaticName );
				InsertSym
				( 
					$<idStr>-2, 
					$<s>0, 			/*GetBaseType( $<s>3 ),*/
					$<s>0->pType, 
					cStatic, 
					$<s>0->Arity,
					$<s>0->Dimensions,
					$<s>0->NumElements, 
					NULL,
					size,
					0,
					sn,
					$<s>0->Base,
					$<s>0->Fields,
					$<s>0->FieldCnt
				);
				_if( $<s>0->pType == tProcptr )
				
					// Copy parameter info if a proc ptr.
					
					memcpy
					( 
						&SymbolTable->u, 
						&$<s>0->u, 
						sizeof( union ValuesSize )
					);
					
				_endif



				/*
				** If this is a class object, we need to duplicate
				** all the fields to all private constants, etc.
				*/

				
				_if( $<s>0->pType == tClass )

					SymbolTable->Fields = 
						CopySymbols
						( 
							$<s>0->Fields,
							StaticName
						);
					NullTerminate( SymbolTable->Fields, SymbolTable );

				_elseif(  $<s>0->pType == tThunk )

					/*
					** Need some dummy local vars for a thunk.
					*/

					SymbolTable->u.proc.parms = &true_ste;

				_endif

			_endif
			_here;
		}
	;
	

// undefID:type; {options}
	
ReadOnlyDef:
		UndefinedID			/* $1 */ 
		Colon 				/* $2 */
		TypeID 				/* $3 */
		EnterRODef3			/* $4 */
		Semicolon			/* $5 */
		Options				/* $6 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>6,
					specified_nostorage
				|	specified_volatile 
			);
			_if( !$<options.NoStorage>6 )

				yyerror
				( 
					"Readonly object requires an initializer\n"
					"or the 'NOSTORAGE' option."
				);

			_endif
			_if( !CantBeVar( $<s>3->pType ))

				_if
				( 
						$<s>3->pType == tPointer
					||	$<s>3->pType == tProcptr
				)
				
					EmitTypedLabel( SymbolTable->StaticName, tDWord );
					
				
				_else

					EmitTypedLabel( SymbolTable->StaticName, tByte );

				_endif

			_endif
		}
	;


 /*
 ** Handle an external declaration with a simple type ID:
 */
 
// undefID:type; {options} @external;

ReadOnlyDef:
		UndefinedID			/* $1  */ 
		Colon 				/* $2  */
		TypeID		 		/* $3  */
		EnterRODef3			/* $4  */
		Semicolon			/* $5  */
		Options				/* $6  */
		RequiredExternal	/* $7  */
		{
			struct	SymNode	*bt;
			
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>6,
					specified_volatile 
			);
			
			_if( CantBeVar( $<s>3->pType ))

				free2( vss $<returns>7 );
				
			_else
			
				SymbolTable->IsExternal = 1;
				_if( *$<returns>7 == '\0' )

				 	free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( SymbolTable->TrueName );
					free2( vss $<returns>7 );

				_else

					SymbolTable->StaticName = $<returns>7;

				_endif
				bt = GetBaseType( $<s>3 );
				EmitExtern( SymbolTable, bt->ObjectSize );
				
			_endif

		}
	;









 /*
 ** Readonly variable declarations using a single type ID with
 ** an initializer.  e.g., i:int8 := 5;
 ** Note: This production handles the case where this symbol
 ** was previously declared.
 */

ReadOnlyDef: StaticSingleTypeWasExt;


 /*
 ** Handle the case where we've got the definition of a 
 ** previously declared external symbol with a simple type ID
 ** and the nostorage option.
 */


ReadOnlyDef:
		AnyLocalID			/* $1 */ 
		Colon 				/* $2 */
		TypeID 				/* $3 */
		Semicolon			/* $4 */
		Options				/* $5 */
		{					/* $6 */

			char StaticName[ 256 ];
			char *sn;
			struct	SymNode	*bt;

			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>5,
					specified_nostorage
				|	specified_volatile 
			);
			_if( !$<options.NoStorage>5 )

				yyerror
				( 
					"Readonly object requires an initializer\n"
					"or the 'NOSTORAGE' option."
				);

			_endif

			bt = GetBaseType( $<s>3 );
			_if( CantBeVar($<s>3->pType ))

				yyerror( "Readonly variables cannot be this type" );

			_else
			

				_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

					_if
					(
							$<s>1->Type == $<s>3
						||	$<s>1->Type == GetBaseType( $<s>3 )
					)

						$<s>1->IsExternal = 0;
						EmitTypedPublic ( $<s>1->StaticName, $<s>1->pType );
						EmitLabel( $<s>1->StaticName, bt->ObjectSize );  

					_else

						ErrorNear
						(
							"External type must match "
							"declared type",
							$<s>1->TrueName,
							__LINE__,
							__FILE__
						);

					_endif

				_else

					ErrorNear
					( 
						"Duplicate symbol definition",
						$<s>1->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_endif
			_here;
		}
	;

 /*
 ** Array readonly variable definitions with initializers
 ** e.g., b:int8[4] := [1,2,3,4];
 **
 */


ReadOnlyDef: StaticArrayInit;

 /*
 ** Handle array declarations with the nostorage option:
 */

EnterRODef4:
		{

			int		*DimensionArray;
			int		ArraySize;
			char	StaticName[ 256 ];
			char	*sn;


			assert( $<idStr>-5 != NULL );
			assert( $<s>-3 != NULL );
			assert( $<v.NumElements>-1 > 0 );
			assert( $<v.Dimensions>-1 != NULL );

			_here;

			sprintf( StaticName, "%s" sympost "%d", $<idStr>-5, LblCntr++ );

			/*
			** Make sure this is a legal variable type
			** (e.g., no text variables).
			*/

			_if( CantBeVar( $<s>-3->pType ))
			
				yyerror( "Illegal Readonly variable type" );
				
			_else 
			
				/*
				** Check to see if TypeID is an array type
				** (i.e., we're creating a multi-dimensional array).
				*/

				_if( $<s>-3->pType != tArray )

					/*
					** TypeID is *not* an array type, so create
					** a single dimension array here.
					*/

					ArraySize = $<s>-3->ObjectSize * $<v.NumElements>-1;
					sn = hlastrdup2( StaticName );
					InsertSym
					( 
						$<idStr>-5, 
						$<s>-3,
						tArray, 
						cStatic, 
						$<v.Arity>-1,
						$<v.Dimensions>-1,
						$<v.NumElements>-1, 
						NULL,
						ArraySize,
						0,
						sn,
						$<s>-3->Base,
						$<s>-3->Fields,
						$<s>-3->FieldCnt
					);

					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					_if( $<s>-3->pType == tClass )

						SymbolTable->Fields = 
							CopySymbols
							( 
								$<s>-3->Fields,
								$<s>-3->StaticName
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_else
					
						_if(  $<s>-3->pType == tThunk )

							/*
							** Need some dummy local vars for a thunk.
							*/

							SymbolTable->u.proc.parms = &true_ste;

						_endif

					_endif


				/*
				** Okay, down here TypeID *is* an array type,
				** so we're creating a multi-dimensional array.
				*/

				_else

					struct SymNode *BaseType;

					assert( $<s>-3->Dimensions != NULL );

					/*
					** Create the new dimension array by concatenating
					** the two existing dimension arrays.
					*/

					DimensionArray = 
						malloc2
						( 
							( $<s>-3->Arity + $<v.NumElements>-1 ) * 
								sizeof( int )
						);

					memcpy
					( 
						DimensionArray, 
						$<s>-3->Dimensions, 
						$<s>-3->Arity * sizeof( int )
					);
					memcpy
					(
						&DimensionArray[ $<s>-3->Arity ],
						$<v.Dimensions>-1,
						$<v.Arity>-1 * sizeof( int )
					);
					ArraySize = $<s>-3->ObjectSize * $<v.NumElements>-1;

					/*
					** Add the new array to the symbol table.
					*/

					sn = hlastrdup2( StaticName );
					BaseType = GetBaseType( $<s>-3 );
					InsertSym
					( 
						$<idStr>-5, 
						$<s>-3,
						tArray, 
						cStatic, 
						$<s>-3->Arity + $<v.Arity>-1,
						DimensionArray,
						$<s>-3->NumElements * $<v.NumElements>-1, 
						NULL,
						ArraySize,
						0,
						sn,
						$<s>-3->Base,
						$<s>-3->Fields,
						$<s>-3->FieldCnt
					);

					/*
					** If this is a class object, we need to duplicate
					** all the fields to all private constants, etc.
					*/

					
					_if( SymbolTable->Type->pType == tClass )

						int ThisObjSize;

						SymbolTable->Fields = 
							CopySymbols
							( 
								BaseType->Fields,
								BaseType->StaticName
							);
						NullTerminate( SymbolTable->Fields, SymbolTable );

					_else
					
						_if(  SymbolTable->Type->pType == tThunk )

							/*
							** Need some dummy local vars for a thunk.
							*/

							SymbolTable->u.proc.parms = &true_ste;

						_endif

					_endif
					free2( vss $<v.Dimensions>-1 );

				_endif

			_endif
			_here;
		}
	; 

ReadOnlyDef:
		UndefinedID			/* $1 */
		Colon		   		/* $2 */
		TypeID 				/* $3 */
		'[' 				/* $4 */
		DimList 			/* $5 */
		Rbrack  			/* $6 */
		EnterRODef4			/* $7 */
		Semicolon			/* $8 */
		Options				/* $9 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_nostorage
				|	specified_volatile 
			);
			_if( !$<options.NoStorage>9 )

				yyerror
				( 
					"Readonly object requires an initializer\n"
					"or the 'NOSTORAGE' option."
				);

			_endif
			_if( !CantBeVar( $<s>3->pType ))
			
				EmitTypedLabel( SymbolTable->StaticName, tByte );
					
			_endif  
			
		}
	;



 /*
 ** Handle external array declarations in the readonly section:
 */
 

ReadOnlyDef:
		UndefinedID			/* $1  */ 
		Colon				/* $2  */
		TypeID 				/* $3  */
		'[' 				/* $4  */
		DimList 			/* $5  */
		Rbrack  			/* $6  */
		EnterRODef4			/* $7  */
		Semicolon			/* $8  */
		Options				/* $9  */
		RequiredExternal	/* $10 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>9,
					specified_volatile 
			);
			_if( !CantBeVar( $<s>3->pType ))
			
				SymbolTable->IsExternal = 1;
				_if( *$<returns>10 == '\0' )

				 	free2( vss SymbolTable->StaticName );
					SymbolTable->StaticName = hlastrdup2( SymbolTable->TrueName );
					free2( vss $<returns>10 );

				_else

					SymbolTable->StaticName = $<returns>10;

				_endif
				EmitExtern( SymbolTable, GetBaseType( $<s>3 )->ObjectSize );
				
			_endif
		}
	;




 /*
 ** Handle an array declaration in the readonly section that
 ** has a previous external declaration.
 */


ReadOnlyDef: StaticArrayInitExt;

 /*
 ** Handle an array declaration in the readonly section that
 ** has a previous external declaration and has the nostorage option.
 */


ReadOnlyDef:
		AnyLocalID		/* $1 */ 
		Colon			/* $2 */
		TypeID 			/* $3 */
		'[' 			/* $4 */
		DimList 		/* $5 */
		Rbrack  		/* $6 */
		Semicolon		/* $7 */
		Options			/* $8 */
		{				/* $9 */

			int				*DimensionArray;
			int				ArraySize;
			struct	SymNode	*bt;


			assert( $<s>1 != NULL );
			assert( $<s>3 != NULL );
			assert( $<v.NumElements>5 > 0 );
			assert( $<v.Dimensions>5 != NULL );

			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>8,
					specified_nostorage
				|	specified_volatile 
			);
			_if( !$<options.NoStorage>8 )

				yyerror
				( 
					"Readonly object requires an initializer\n"
					"or the 'NOSTORAGE' option."
				);

			_endif


			bt = GetBaseType( $<s>3 );

			/*
			** Make sure this is a legal variable type
			** (e.g., no text variables).
			*/

			_if( CantBeVar( $<s>3->pType ))
			
				yyerror( "Illegal Readonly variable type" );
				
			_else 
			
				_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

					$<s>1->IsExternal = 0;
					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitLabel( $<s>1->StaticName, bt->ObjectSize );
					
					_if
					(
							$<s>1->ObjectSize
						!=	$<s>3->ObjectSize * $<v.NumElements>5
					)

						WarnNear
						( 
							"Declared size does not match external size",
							$<s>1->TrueName 
						);

					_endif

				_else

					ErrorNear
					( 
						"Duplicate symbol definition",
						$<s>1->TrueName,
						__LINE__,
						__FILE__
					);

				_endif


			_endif
			free2( vss $<v.Dimensions>5 );
			_here;
		}
	;


		/*
		** Handle the output of arbitrary constants in
		** the readonly section down here.
		*/


ReadOnlyDef:
			TypeID 
			{ _here; $<s>$ = $<s>1; } 
			ConstantList 
			Semicolon
			{
				_here;
				(void) $<s>2;	// shut up bison
			}
	;


		/*
		** Handle some common errors down here.
		**
		*/

ReadOnlyDef: VarErrors;
		













/********************************************************************/
/*                                                         			*/
/* The following productions handle uninitialized var declarations.	*/
/*                                                         			*/
/********************************************************************/



UninitVars:	SetInStorage
			OutputBSSSEG
			OptionalAlignment
			doUninitVars
			OutputEndBSSSEG
			{
				_here;
				inStorage = 0;
			}
		;
	

SetInStorage:
		{
			_here;
			inStorage = 1;
		}
	;

OutputBSSSEG:	
		{
			_here;
			startBssSeg();
		}
		;

OutputEndBSSSEG: {
					_here;
					endBssSeg();
					_here;
			   }
		;



doUninitVars:

			/* Empty */ 
		|	 doUninitVars UninitDef 
		;




UninitDef:

			/*
			** Allow empty declarations (just a semicolon) for
			** syntactical reasons (e.g., to put semicolons after
			** macros and such).
			*/

			';'
	;
	


 /*
 ** Handle the "ID:FORWARD(ID);" declaration to support
 ** macro redeclarations of a symbol.
 */

UninitDef:
		UndefinedForward
	;	


		/*
		** Handle the "align" directive here.
		*/


UninitDef: StaticAlign;

	/*
	** Handle procedure pointer variables here.
	*/


UninitDef: StaticPtrToProcUninit;
UninitDef: StaticProcUninit;




 /*
 ** Handle a storage procedure variable declaration that occurs
 ** after an external declaration (or a duplicate symbol definition).
 */


UninitDef: StaticPtrToProcRedef;
UninitDef: StaticProcRedef;

			 


 /*
 ** Storage variable with an enumerated type declaration:
 ** e.g., colorVar: enum={red, green, blue};
 **
 ** See the corresponding code in the TypeDef
 ** productions for comments on how enums work.
 **
 */


UninitDef: StaticEnum;



 /*
 ** Handle pointer declarations to user-defined types here.
 */


UninitDef: StaticPtrToUserNoInit;



UninitDef: StaticPtrToUserExt;


 /*
 ** Handle pointer declarations to the built-in types here.
 */
 

UninitDef: StaticPtrBuiltInNoInit;


 /*
 ** Handle pointer declarations to the built-in types
 ** that have a previous external declaration.
 */
 

UninitDef: 
		AnyLocalID			/* $1 */
		Colon				/* $2 */
		pointerTkn			/* $3 */
		toTkn				/* $4 */
		ReservedTypeIDs		/* $5 */
		Semicolon			/* $6 */
		Options				/* $7 */
		{
			_here;
			CheckLegalOptions
			( 
				$<options.SpecifiedOptions>7,
					specified_nostorage
				|	specified_volatile 
			);
			_if( $<s>1->IsExternal && $<s>1->SymClass == cStatic )

				_if( $<s>1->Type == &pointer_ste && $<s>1->Base == $<s>5 ) 

					$<s>1->IsExternal = 0;
					EmitTypedPublic( $<s>1->StaticName, $<s>1->pType );
					EmitTypedLabel( $<s>1->StaticName, tDWord );
					_if( !$<options.NoStorage>7 )

						EmitDword();

					_endif

				_else

					ErrorNear
					(
						"External base type must match declared base type",
						$<s>5->TrueName,
						__LINE__,
						__FILE__
					);

				_endif

			_else

				ErrorNear
				( 
					"Duplicate symbol definition",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			_here;
		}
	;


 /*
 ** Storage variable declarations using a single type ID:
 ** e.g., i:integer;
 **
 */



UninitDef: StaticSingleType;


 /*
 ** Storage variable declarations using a single type ID
 ** that have been previously declared:
 ** e.g., i:integer;
 **
 */


UninitDef: StaticSingleExt;


 /*
 ** Array storage variable definitions:
 ** e.g., b:integer[4];
 */


UninitDef: StaticArray;


 /*
 ** This production handles array declarations when
 ** there has been a previous forward declaration.
 */


UninitDef: StaticArrayExt;



 /*
 ** Handle record storage variable declarations here.
 */


UninitDef: StaticRecord;
				



/*
** Handle union variable declarations here.
**
*/

UninitDef: StaticUnion;

				


		/*
		** Handle some common errors down here.
		**
		*/

UninitDef: VarErrors;
		









			

/*
** The following productions deal with lists of constants
** appearing after a type name in a declaration section,
** e.g.,
**
**	byte 0, 1, 2, 3;
**
*/

ConstantList:
			DoConstant

		|	DoConstant 
			',' 
			{ _here; $<s>$ = $<s>0; }
			ConstantList
			{
				_here;
				(void) $<s>3;	// shut up bison
			}
		;


DoConstant:
			ConstOnlyExpr
			{	

				/*
				** Check to see if the TypeID and the ConstOnlyExpr
				** are both arrays and if they are compatible.
				*/

				_here;
				_if( $<s>0->pType == tArray && $<v.pType>1 == tArray )

					_if
					( 
						ArraysAreCompatible
						( 
							YYS $<s>0, 
							YYS &$<v>1 
						)
					)

						OutValue( NULL, $<s>0, YYS &$<v>1 );

					_else

						yyerror
						( 
							"Array type mismatch or value out of range" 
						);

					_endif


				/*
				** Check to see if the TypeID and the ConstOnlyExpr are
				** compatible record objects. 
				*/

				_elseif
				( 
						$<s>0->pType == tRecord 
					&&	$<v.pType>1 == tRecord 
				)

					_if
					( 
						RecordsAreCompatible
						( 
							$<s>0, 
							YYS &$<v>1 
						)
					)

						OutValue( NULL, $<s>0, YYS &$<v>1 );

					_else

						yyerror
						( 
							"Type mismatch, expected compatible "
							"record types"
						);

					_endif


				/*
				** Check for a pointer object with the dword directive.
				*/

				_elseif
				( 
						( 
								$<s>0->pType == tDWord 
							||	$<s>0->pType == tPointer
							||	$<s>0->pType == tProcptr
						)
					&&	$<v.pType>1 == tPointer
				)

					OutValue( NULL, &pointer_ste, YYS &$<v>1 );


				/*
				** Check to see if the TypeID and the ConstOnlyExpr are
				** compatible pointer objects here.
				*/

				_elseif( IsNotPrimType( $<s>0->pType ))

					yyerror( "This data/static type requires a constant" );

				
				/*
				** We've got a scalar object, output the constant here.
				*/

				_elseif( IsCompatible( $<s>0, YYS &$<v>1 ))

					OutValue( NULL, $<s>0, YYS &$<v>1 );


				_elseif
				( 
						$<s>0 == &byte_ste 
					&&	( $<v.pType>1 == tString || $<v.pType>1 == tZString )
				)

					EmitByteString( $<v.u.strval>1, 0 );

				_elseif( $<s>0 == &byte_ste && $<v.pType>1 == tWString )

					EmitWordString( $<v.u.strval>1 );

				_else

					yyerror( "Static type mismatch or range error" );

				_endif
				FreeValue( YYS &$<v>1 );
				_here;
			}
		;
			 














/***********************************************************************/
/* ******************************************************************* */
/* ******************************************************************* */
/* ******************************************************************* */
/* *****************						 ************************* */
/* *****************						 ************************* */
/* *****************   S T A T I C E X P R	 ************************* */
/* *****************						 ************************* */
/* *****************						 ************************* */
/* ******************************************************************* */
/* ******************************************************************* */
/* ******************************************************************* */
/***********************************************************************/

/********************************************************************/
/*                                                                  */
/* StaticExpr-                                                      */
/*                                                                  */
/* These are address expressions that take the following form:      */
/*                                                                  */
/* staticSymbol                                                     */
/* staticSymbol + ConstOnlyExpr                                     */
/* staticSymbol - ConstOnlyExpr                                     */
/*																	*/
/*                                                                  */
/* staticSymbol must be an object declared in the static section, a */
/* procedure, or a statement level that is visible (or will soon be */
/* declared) at the current lex level or a lower lex level.         */
/*                                                                  */
/********************************************************************/





StaticExpr:
		'&'
		UndefID
		{
			struct FwdRefLabelType	*flist;
			struct StaticListType	*StaticListEntry;
			struct StaticListType	*sList;
			static char				StaticName[ 256 ];

			/*
			** Check to see if this symbol is in the
			** forward labels list (because it appeared
			** in a LABEL declaration).
			*/

			_here;
			flist = FwdLabelsList;
			_while( flist != NULL )

				_breakif( _streq( $<idStr>2, flist->label ));
				flist = flist->Next;

			_endwhile

			_if( flist != NULL && *flist->StaticName != '\0' )
			
				// Okay, it's in the forward list, just use the
				// static name we find there:
				
				$<idStr>$ = hlastrdup2( flist->StaticName );
				flist->referenced = 1;			

			_else
			
				// See if this symbol is in the StaticList. Use the
				// existing static name if it is:
				
				sList = searchStatic( $<idStr>2 );
				_if( sList == NULL )
				
					/*
					** Add a node to the StaticList so we can check
					** this definition once we've compiled the current
					** code to make sure that the type is ultimately
					** defined.
					*/

					sprintf
					( 
						StaticName, 
						"%s" sympost "%d", 
						$<idStr>2, 
						LblCntr++ 
					);
					StaticListEntry = malloc2( sizeof( struct StaticListType ));
					StaticListEntry->Next = StaticList;
					StaticListEntry->DefinedSym = NULL;
					StaticListEntry->Context = CurrentContext;
					StaticListEntry->Name = hlastrdup2( $<idStr>2 );
					StaticListEntry->StaticName = hlastrdup2( StaticName );
					StaticListEntry->LineNumber = LineCnt;
					StaticListEntry->Fixed = 0;
					StaticList = StaticListEntry;
					$<idStr>$ = hlastrdup2( StaticListEntry->StaticName );
					
				_else

					$<idStr>$ = hlastrdup2( sList->StaticName );
					
				_endif
				
			_endif
			free2( vss $<idStr>2 );
			_here;
		}
	;





StaticExpr:
		'&'			/* $1 */
		UndefID		/* $2 */
		'['			/* $3 */
		ConstExpr	/* $4 */
		Rbrack		/* $5 */
		{
			struct FwdRefLabelType	*flist;
			struct StaticListType	*StaticListEntry;
			struct StaticListType	*sList;
			static char				StaticName[ 256 ];

			_here;
			_if( !IsOrdinal( $<v.pType>4 ) || numBits32( YYS &$<v>4 ) > 32 )

				yyerror( "Expected 32-bit ordinal type in index expression" );
			
			_endif



			/*
			** Check to see if this symbol is in the
			** forward labels list (because it appeared
			** in a LABEL declaration).
			*/

			flist = FwdLabelsList;
			_while( flist != NULL )

				_breakif( _streq( $<idStr>2, flist->label ));
				flist = flist->Next;

			_endwhile

			_if( flist != NULL && *flist->StaticName != '\0' )
			
				// Okay, it's in the forward list, just use the
				// static name we find there:
				
				sprintf
				( 
					StaticName, 
					"(%s%s%d)", 
					flist->StaticName,
					_ifx( $<v.u.intval>4 < 0, "", "+" ), 
					$<v.u.intval>4 
				);
				$<idStr>$ = hlastrdup2( StaticName );
				flist->referenced = 1;

			_else

				// See if this symbol is in the StaticList. Use the
				// existing static name if it is:
				
				sList = searchStatic( $<idStr>2 );
				_if( sList == NULL )
				
					sprintf( StaticName, "%s" sympost "%d", $<idStr>2, LblCntr );

					/*
					** Add a node to the StaticList so we can check
					** this definition once we've compiled the current
					** code to make sure that the type is ultimately
					** defined.
					*/

					StaticListEntry = malloc2( sizeof( struct StaticListType ));
					StaticListEntry->Next = StaticList;
					StaticListEntry->DefinedSym = NULL;
					StaticListEntry->Context = CurrentContext;
					StaticListEntry->Name = hlastrdup2( $<idStr>2 );
					StaticListEntry->StaticName = hlastrdup2( StaticName );
					StaticListEntry->LineNumber = LineCnt;
					StaticListEntry->Fixed = 0;
					StaticList = StaticListEntry;

					sprintf
					( 
						StaticName, 
						"(%s" sympost "%d%s%d)", 
						$<idStr>2, 
						LblCntr++, 
						_ifx( $<v.u.intval>4 < 0, "", "+" ), 
						$<v.u.intval>4 
					);
					$<idStr>$ = hlastrdup2( StaticName );
					
				_else
				
					$<idStr>$ = hlastrdup2( sList->StaticName );
					
				_endif
				
			_endif
			free2( vss $<idStr>2 );
			FreeValue( YYS &$<v>4 );
			_here;
		}
	;




StaticExpr:
		'&'
		StaticLabelIDs
		{
			_here;
			$<idStr>$ = hlastrdup2( $<s>2->StaticName );
			_here;
		}
	;



StaticExpr:
		'&'					/* $1 */
		StaticLabelIDs		/* $2 */
		'['					/* $3 */
		ConstExpr			/* $4 */
		Rbrack				/* $5 */
		
		{
			char	StaticName[256];
			
			_here;
			_if( !IsOrdinal( $<v.pType>4 ) || numBits32( YYS &$<v>4 ) > 32 )

				yyerror( "Expected 32-bit ordinal type in index expression" );
			
			_endif
			sprintf
			( 
				StaticName, 
				"(%s%s%d)", 
				$<s>2->StaticName, 
				_ifx( $<v.u.intval>4 < 0, "", "+" ), 
				$<v.u.intval>4 
			);
			$<idStr>$ = hlastrdup2( StaticName );
			_here;
		}
	;





StaticExpr:

		'&'					/* $1 */
		StaticExprIDs		/* $2 */
		SetUp4hlaFields		/* $3 */
		hlaFields			/* $4 */
		{					/* $5 */

			char msg[ 256 ];
			char adrs[ 256 ];

			_here;
			_if( $<s>2->Fields == NULL );

				ErrorNear
				( 
					"Object is not class/record/union/namespace",
					$<s>2->TrueName,
						__LINE__,
						__FILE__
				);													   
				$<idStr>$ = hlastrdup2( "" );

			_elseif( $<dotName.Sym>4 == NULL )

				sprintf
				( 
					msg,
					"Symbol is not defined or is not a field of '%s'",
					$<s>2->TrueName
				);
				yyerror( msg );
				$<idStr>$ = hlastrdup2( "" );

			_else

				_if
				( 
						$<dotName.StaticName>4 != NULL
					||	$<dotName.Sym>4->SymClass == cProc
				)
				
					sprintf
					(
						adrs,
						"(%s%s%d)",
						$<dotName.StaticName>4,
						_ifx( $<dotName.Disp>4 < 0, "", "+" ), 
						$<dotName.Disp>4

					);
					$<idStr>$ = hlastrdup2( adrs );

				_elseif( $<s>2->SymClass == cStatic )

					assert( $<s>2->StaticName != NULL );
					sprintf
					(
						adrs,
						"(%s%s%d)",
						$<s>2->StaticName,
						_ifx( $<dotName.Disp>4 < 0, "", "+" ), 
						$<dotName.Disp>4
					);

					$<idStr>$ = hlastrdup2( adrs );
												  
				_else

					yyerror( "Illegal static symbol" );
					$<idStr>$ = hlastrdup2( "" );

				_endif

			_endif
			free2( vss $<dotName.FullName>4 );
			_here;
		}
	;


StaticExpr:

		'&'					/* $1 */
		StaticExprIDs		/* $2 */
		SetUp4hlaFields		/* $3 */
		hlaFields			/* $4 */
		'['					/* $5 */
		ConstExpr			/* $6 */
		Rbrack				/* $7 */
		{					/* $8 */

			char msg[ 256 ];
			char adrs[ 256 ];
			
			_here;
			_if( !IsOrdinal( $<v.pType>6 ) || numBits32( YYS &$<v>6 ) > 32 )

				yyerror( "Expected 32-bit ordinal type in index expression" );
			
			_endif
			_if( $<s>2->Fields == NULL );

				ErrorNear
				( 
					"Object is not class/record/union/namespace",
					$<s>2->TrueName,
						__LINE__,
						__FILE__
				);
				$<idStr>$ = hlastrdup2( "" );

			_elseif( $<dotName.Sym>4 == NULL )

				sprintf
				( 
					msg,
					"Symbol is not defined or is not a field of '%s'",
					$<s>2->TrueName
				);
				yyerror( msg );
				$<idStr>$ = hlastrdup2( "" );

			_else

				_if
				( 
						$<dotName.StaticName>4 != NULL
					||	$<dotName.Sym>4->SymClass == cProc
				)
				
					sprintf
					(
						adrs,
						"(%s%s%d)",
						$<dotName.StaticName>4,
						_ifx( $<dotName.Disp>4 < 0, "", "+" ), 
						$<dotName.Disp>4 + $<v.u.unsval>6
					);
					$<idStr>$ = hlastrdup2( adrs );

				_elseif( $<s>2->SymClass == cStatic )

					assert( $<s>2->StaticName != NULL );
					sprintf
					(
						adrs,
						"(%s%s%d)",
						$<s>2->StaticName,
						_ifx( $<dotName.Disp>4 < 0, "", "+" ), 
						$<dotName.Disp>4 + $<v.u.unsval>6
					);
					$<idStr>$ = hlastrdup2( adrs );
												  
				_else

					yyerror( "Illegal static symbol" );
					$<idStr>$ = hlastrdup2( "" );

				_endif

			_endif
			free2( vss $<dotName.FullName>4 );
			FreeValue( YYS &$<v>6 );
			_here;
		}
	;
	




	
StaticLabelIDs:
		ClassIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}
	
	|	ClassMethodID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}
	
	|	ClassProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}
		
	|	ClassStaticID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}
	
	|	LocalStaticID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	|	LocalProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	|	LocalIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	|	LocalMethodID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	|	LocalLabelID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}
		
	|	NonLocalStaticID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	|	NonLocalProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	|	NonLocalIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	|	NonLocalMethodID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	|	NonLocalLabelID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}

	;
	
StaticExprIDs:
		LocalStaticID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}


	|	NonLocalStaticID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
			_here;
		}
	;


SetUp4hlaFields:
		{
			_here;
			$<dotName.Sym>$ = $<s>0;
			$<dotName.Disp>$ = 0;
			_if( $<s>0 != NULL )

				$<dotName.StaticName>$ = $<s>0->StaticName;

			_else

				$<dotName.StaticName>$ = NULL;

			_endif
			_here;
		}
	;


















/***********************************************************************/
/* ******************************************************************* */
/* ******************************************************************* */
/* ******************************************************************* */
/* *****************						 ************************* */
/* *****************						 ************************* */
/* *****************    C O N S T E X P R	 ************************* */
/* *****************						 ************************* */
/* *****************						 ************************* */
/* ******************************************************************* */
/* ******************************************************************* */
/* ******************************************************************* */
/***********************************************************************/



ConstOnlyExpr:	
		ConstExpr
		{

			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}
		
	|	NonConstLocalID
		{
			char msg[ 256 ];
			
			   
			sprintf
			(
				msg,
				"<<%s>> must be a const or val identifier",
				$<s>1->TrueName
			);
			yyerror( msg );

			/*
			** Return an arbitrary constant value (error)
			** just to ensure the integrity of this attribute
			** for the calling code.
			*/

			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);
			_here;
		}
	;
	
fConstOnlyExpr:
		ConstOnlyExpr
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}

	|	fstmt
		ConstOnlyExpr
		{
			_here;
			memcpy( &$<v>$, &$<v>2, sizeofSymNode );
			_here;
		}
	;







/*****************************************************************************/
/*                                                                           */
/* ConstExpr:                                                                */     
/*                                                                           */     
/* This set of productions processes *constant* expressions.   HLA uses      */
/* constant   expressions in the "const" and "val" sections as well as  in   */
/* a few other spots.                                                        */
/*                                                                           */
/*****************************************************************************/


 /*
 ** Handle parenthesized constant expressions here.
 */



ConstExpr:
		'(' ConstOnlyExpr Rparen
		{
			_here;
			memcpy( &$<v>$, &$<v>2, sizeofSymNode );
			_here;

		}
	;


ConstExpr:
		LiteralConst
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;

		}
	;
		




 /*
 ** Allow static address expressions for use in the STATIC declaration
 ** section of a program/procedure.  These aren't real constants, but
 ** it is convenient to treat them as such for purposes of parsing.
 */

LiteralConst:
		StaticExpr
		{
			struct SymNode *sym;
			
			_here;
			$<v.u.strval>$ = $<idStr>1;
			assert( $<v.u.strval>$ != NULL );
			
			sym = lookup( $<idStr>1, 1 );
			_if( sym != NULL )
			
				SetReferenced( sym );
				
			_endif
			$<v.SymClass>$ = cConstant;
			$<v.pType>$ = tPointer;
			$<v.Type>$ = &pointer_ste;
			$<v.Base>$ = &byte_ste;
			_here;
		}
	;



LiteralConst:
		nullTkn
		{
			_here;
			$<v.u.strval>$ = NullPointer;
			$<v.SymClass>$ = cConstant;
			$<v.pType>$ = tPointer;
			$<v.Type>$ = &pointer_ste;
			$<v.Base>$ = NULL;
			_here;
		}
	;







 /*
 ** Handle numeric and character constants here.
 */


LiteralConst:
		intconst
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}

	|	binconst
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}

	|	hexconst
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}

	|	fltconst
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}
		
	|	charconst
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}
		
	|	wcharconst
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			_here;
		}
	;



			
 /***************************************/
 /*                                     */
 /* Handle (constant) identifiers here. */
 /*                                     */
 /***************************************/





ConstExpr:
		DefinedConstID
		{
			_here;

			/*
			** Okay, we've got an identifier that is either
			** a cConstant or cValue object.  Pass along the
			** appropriate information to the calling code.
			*/

			_if
			( 
					$<s>1->pType == tString 
				||	$<s>1->pType == tZString 
				||	$<s>1->pType == tText 
			)
			
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste, 
					YYS &true_ste
				);
				$<v.u.strval>$ = hlastrdup2( $<s>1->u.strval );

			_else

				DeepCopy( &$<v>$, $<s>1 );

			_endif
			_here;
		}


		/*
		** If the parser encounters an undefined symbol, print an
		** error message and fake a symbol.
		*/

	|	UndefID
		{

			yyerror( "Undefined symbol" );

			/*
			** Since we're in ConstExpr, the caller might expect
			** us to return an actual defined object at this point.
			** Let's create a dummy one to avoid program errors.
			** Note that this may cause some cascading errors if
			** the user actually defines this symbol later in this
			** current declaration section.
			*/

			memcpy( &$<v>$, &true_ste, sizeofSymNode );
			_here;

		}

	;





/*
** Handle Array references here.
**
** If the number of indexes in the IndexList is less than the
** number of dimensions in DefinedID, then this production
** returns an array slice.  If the number of indexes matches
** the number of dimensions in DefinedID, then this production
** returns the value of a single element of the constant array.
*/


ConstExpr:	
		ArrayRef
		{
			_here;
			DeepCopy( &$<v>$, &$<v>1 );
			_here;
		}
	;




/*
** Handle Record references here.
*/


ConstExpr:	
		RecordRef
		{
			_here;
			DeepCopy( &$<v>$, &$<v>1 );
			_here;
		}
	;




/*
** Handle array constants here.
**
** This is a list of values inside square brackets.  Each element
** must be type compatible with the others.
*/



ConstExpr:
		ArrayValues 
		{

			_here;

			/*
			** Begin by creating the dimension array
			** (the dope vector).  This will be a
			** single element array whose sole element
			** contains NumElements.
			*/

			$<v.Dimensions>$ = $<v.Dimensions>1;

			/*
			** Now pass the array's data on.
			*/

			$<v.u.ArrayOfValues>$ = $<v.u.ArrayOfValues>1;

			/*
			** Set up the other important attribute fields.
			*/

			$<v.pType>$ = tArray;
			$<v.SymClass>$ = cConstant;

			$<v.Type>$ = $<v.Type>1;
			$<v.Base>$ = $<v.Base>1;
			$<v.Fields>$ = $<v.Fields>1;
			$<v.FieldCnt>$ = $<v.FieldCnt>1;
			$<v.Arity>$ = $<v.Arity>1;
			$<v.NumElements>$ = $<v.NumElements>1;
			_here;
		}
	;


/*
** Handle record constants here.
**										
** The number of fields in the constant must match the preceding
** type, the types of the fields must be compatible, and each field
** must contain a constant value.
*/


ConstExpr:	
		TypeID 
		':' 
		Lbrack
		SaveRecArray
		{
			_here;

			assert( $<s>1 != NULL );

			/*
			** Initialize the global RecordValues object so the
			** recursive invocations of RecordList have unfettered access.
			** Note that the Arity field (normally unused for record
			** objects) is used as a "temporary" variable by this code.
			** Arity holds an integer specifying the current field
			** we're processing.
			**
			**	Note: the following malloc allocates one extra entry
			**	just in case the TypeID object is not a record object
			**	(meaning FieldCnt will be zero).  The error will be
			**	caught later, but we don't want malloc to return NULL
			**	just because we didn't allocate any storage. 
			*/

			RecordValues->v.u.FieldValues = 
				malloc2( ( $<s>1->FieldCnt + 1 ) * sizeofSymNode );
			RecordValues->v.FieldCnt = $<s>1->FieldCnt;
			RecordValues->v.Arity = 0;


			/*
			** If TypeID is a valid record type identifier, then
			** pass a pointer to the symbol table entry of the
			** last field in the record as an inherited attribute
			** to the RecordList non-terminal.
			**
			** If TypeID is not a valid record type, pass any old
			** junk (just to cause a failure) as the inherited attribute.
			*/


			_if( $<s>1->pType == tRecord || $<s>1->pType == tUnion )

				$<s>$ = $<s>1->Fields;

			_else

				$<s>$ = &UndefinedType;

			_endif
			_here;
		}  
		RecordList 
		Rbrack 
		{
			
			_here;
			_if( $<s>1->pType == tUnion || $<v.pType>6 == tUnion )

				ErrorNear
				( 
					"Union constants do not take this form", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);

			_elseif( $<s>1->pType != tRecord || $<v.pType>6 != tRecord )

				ErrorNear
				(  
					"Illegal record type", 
					$<s>1->TrueName,
					__LINE__,
					__FILE__ 
				);

				/*
				** Generate some quasi-safe record constant:
				*/

				memcpy( &$<v>$, &error_ste, sizeofSymNode );


			_else

				memcpy( &$<v>$, $<s>1, sizeofSymNode );
				$<v.pType>$ = tRecord;
				$<v.Type>$ = GetBaseType( $<s>1 );
				$<v.SymClass>$	= cConstant;
				$<v.u.FieldValues>$ = RecordValues->v.u.FieldValues;

			_endif

			/*
			** Restore the global RecordValues object.
			*/

			memcpy
			(
				RecordValues,
				&$<v>4,
				sizeofSymNode
			);
			(void) $<s>5;	// shut up bison
			_here;

		}
	;


/*
** Handle union constants here.
**										
** Only a single field is allowed and the user must
** explicitly specify that field.
*/


ConstExpr:	
		TypeID			/* $1 */
		'.'				/* $2 */
		AnyID 			/* $3 */
		':' 			/* $4 */
		Lbrack			/* $5 */
		ConstOnlyExpr	/* $6 */
		Rbrack			/* $7 */
		{
			int				i;
			int				fieldIndex;
			struct	SymNode	*field;
			struct	SymNode	*theField;
			struct	SymNode	*s;
			char			lcName[256];
			char			msg[ 256 ];
				
			_here;
			assert( $<s>1 != NULL );
			assert( $<neID.idStr>3 != NULL );
			
			_if( $<s>1->pType == tUnion )

				strcpy( lcName, $<neID.idStr>3 );
				lowercase( lcName );
				
				// We've got a union constant.
				// Allocate storage for all the fields
				// even though we only use one at a time
				// (this is done to keep things general).
				// Note that, unlike records, HLA stores
				// the value entries in the FieldValues
				// array in reverse order so that their
				// indexes match the entries in the field
				// list (this is called "live and learn"
				// since I learned from the kludge that
				// the record stuff became).
				
				s = $<s>1->Type;
				_if( s == NULL )
				
					$<s>1->Type = $<s>1;
					
				_endif
				ClrConst
				(
					YYS &$<v>$,
					tUnion,
					$<s>1
				);
				$<s>1->Type = s;
				
				// Allocate storage to hold all the fields:
				
				$<v.u.FieldValues>$ = 
					malloc2( $<s>1->FieldCnt * sizeofSymNode );
					
				// Initialize the field we just allocated and
				// give it a default type in case we have an error.
				
				field = $<s>1->Fields;
				assert( field != NULL );
				fieldIndex = -1;
				_for( i=0, i < $<s>1->FieldCnt, ++i )
				
					// Initialize this guy, in case we're not using it:
					
					ClrConst
					(
						YYS &$<v.u.FieldValues>$[i],
						field->pType,
						field->Type
					);
					
					// See if the current field is the field
					// we're searching for.
					
					_if( _streq( lcName, field->Name ))
					
						fieldIndex = i;		// Save field index.
						theField = field;	// Save ptr to field.
						
						// Handle case neutrality check:
						
						_if( _strne( $<neID.idStr>3, field->TrueName ))
						
							sprintf
							(
								msg,
								"Mispelled identifier %s, perhaps "
								"you meant %s",
								$<neID.idStr>3,
								field->TrueName
							);
							yyerror( msg );
							
						_endif
						
					_endif
					
					_if( field->pType == tAnonRec )
					
						yyerror
						( 
							"Union constants are illegal if an "
							"anonymous record is present in the union"
						);
						
					_endif;
					
					field = field->Next;
					
				_endfor
				
				_if( fieldIndex == -1 )
				
					sprintf
					(
						msg,
						"Field %s is not a member of union %s",
						$<neID.idStr>3,
						$<s>1->TrueName
					);
					
				_else
					
					assert( theField->Type != NULL );
					_if( FieldsAreCompatible( theField, YYS &$<v>6 ))
				
						// Okay, initialize the union constant:

						memcpy
						( 
							&$<v.u.FieldValues>$[fieldIndex], 
							&$<v>6, 
							sizeofSymNode 
						);
						
						// Entry zero contains all the information for
						// the actual field we're initializing:
						
						$<v.u.FieldValues>$->pType = theField->pType;
						$<v.u.FieldValues>$->ObjectSize = 
							theField->ObjectSize;
						
						$<v.u.FieldValues>$->MaxObjectSize = 
							theField->MaxObjectSize;
							
						$<v.u.FieldValues>$->Type = theField->Type;
						$<v.u.FieldValues>$->Arity = theField->Arity;

						_if( theField->Dimensions == NULL )
						
						
							$<v.u.FieldValues>$->Dimensions = NULL;
							
						_else
						
							$<v.u.FieldValues>$->Dimensions =
								malloc2( theField->NumElements * sizeof( int ));
							
							memcpy
							(
								$<v.u.FieldValues>$->Dimensions,  
								theField->Dimensions,
								theField->NumElements * sizeof( int )
							);
							
						_endif

						$<v.u.FieldValues>$->NumElements = 
							theField->NumElements; 
							
						$<v.u.FieldValues>$->Fields = theField->Fields;
						$<v.u.FieldValues>$->Base = theField->Base;
						$<v.u.FieldValues>$->FieldCnt = theField->FieldCnt;
						
						// The CurField and CurIndex fields provide the
						// link to the actual data field of this union
						// constant where the current data can be found.
						
						$<v.u.FieldValues>$->CurField = theField;
						$<v.u.FieldValues>$->CurIndex = fieldIndex; 
						
						
						// Initialize the the main value's fields:
						
						$<v.pType>$ = tUnion;
						$<v.Type>$ = $<s>1;
						$<v.SymClass>$	= cConstant;
						$<v.Fields>$ = $<s>1->Fields;
						$<v.Base>$ = $<s>1->Base;
						$<v.FieldCnt>$ = $<s>1->FieldCnt;
						$<v.CurField>$ = theField;
						$<v.CurIndex>$ = fieldIndex; 
						
						
					_else
					
						assert( $<v.Type>6 != NULL );
						sprintf
						(
							msg,
							"Type mismatch in field %s of union "
							"constant %s (expected %s, found %s)",
							theField->TrueName,
							$<s>1->TrueName,
							theField->Type->TrueName,
							$<v.Type>6->TrueName
						);
						yyerror( msg );
						
					_endif
					
				_endif					
					
			_else
			
				sprintf
				(
					msg,
					"Expected a union type rather than '%s'",
					$<s>1->TrueName
				);
				yyerror( msg );

			_endif
			free2( vss $<neID.idStr>3 );
			_here;
		}
	;



/*
** SaveRecArray-
**
**	Saves the global variable RecordValues for reentrancy reasons.
*/

SaveRecArray:
			{
				_here;
				memcpy
				(
					&$<v>$,
					RecordValues,
					sizeofSymNode
				);
				_here;
			}
		;




 /***************************************************************************/
 /*                                                                         */
 /* Handle string constants here.                                           */
 /*                                                                         */
 /* Note that the parser must assemble string constants that are possibly   */
 /* broken into several pieces.  If the parser detects two adjacent strings */
 /* or an adjacent character and string constant, the following code        */
 /* combines them into a single string.                                     */
 /*                                                                         */
 /***************************************************************************/


LiteralConst:
		StringConst
		{
			_here;
			$<v.Type>$ = &string_ste;
			$<v.pType>$ = tString;
			ClrArray( YYS &$<v>$ );
			$<v.u.strval>$ = $<v.u.strval>1;
			_here;
		}

	|	WStringConst
		{
			_here;
			$<v.Type>$ = &wstring_ste;
			$<v.pType>$ = tWString;
			ClrArray( YYS &$<v>$ );
			$<v.u.strval>$ = $<v.u.strval>1;
			_here;
		}

	;



StringConst:
			strconst
			{
				_here;
				$<v.Type>$ = &string_ste;
				$<v.pType>$ = tString;
				$<v.u.strval>$ = $<v.u.strval>1;
				_here;
			}
			
			/*
			** Combine two adjacent character constants into
			** a single string constant.
			*/

		|	charconst charconst  
			{
				_here;
				$<v.Type>$ = &string_ste;
				$<v.pType>$ = tString;
				$<v.u.strval>$ = malloc2( 3 );
				$<v.u.strval>$[ 0 ] = $<v.u.charval>1;
				$<v.u.strval>$[ 1 ] = $<v.u.charval>2;
				$<v.u.strval>$[ 2 ] = '\0';
				_here;
			}

			/*
			** Concatenate a string constant followed by a character
			** constant to form a single string constant.
			*/

		|	strconst charconst 
			{
				int len = strlen( $<v.u.strval>1 );

				_here;
				$<v.Type>$ = &string_ste;
				$<v.pType>$ = tString;
				$<v.u.strval>$ = malloc2( len + 2 );
				strcpy( $<v.u.strval>$, $<v.u.strval>1 );
				$<v.u.strval>$[ len ] =  $<v.u.charval>2;
				$<v.u.strval>$[ len + 1 ] =  '\0';
				free2( vss $<v.u.strval>1 );
				_here;
			}

			/*
			** Concatenate a single character constant followed by
			** a string constant to form a single string.
			*/

		|	charconst StringConst
			{
				_here;
				$<v.Type>$ = &string_ste;
				$<v.pType>$ = tString;
				$<v.u.strval>$ = malloc2( strlen( $<v.u.strval>2 ) + 2 );

				$<v.u.strval>$[ 0 ] = $<v.u.charval>1;
				strcpy( $<v.u.strval>$ + 1, $<v.u.strval>2 );

				free2( vss $<v.u.strval>2 );
				_here;
			}

			/*
			** Concatenate multiple string constants into a single
			** string constant.
			*/

		|	strconst StringConst 
			{
				_here;
				$<v.Type>$ = &string_ste;
				$<v.pType>$ = tString;
				$<v.u.strval>$ = 
					malloc2
					( 
							strlen( $<v.u.strval>1 )
						+	strlen( $<v.u.strval>2 )
						+	1
					);

				assert( $<v.u.strval>$ != NULL );
				strcpy( $<v.u.strval>$, $<v.u.strval>1 );
				strcat( $<v.u.strval>$, $<v.u.strval>2 );
				free2( vss $<v.u.strval>1 );
				free2( vss $<v.u.strval>2 );
				_here;
			}

		;





WStringConst:
			wstrconst
			{
				_here;
				$<v.Type>$ = &wstring_ste;
				$<v.pType>$ = tWString;
				$<v.u.strval>$ = $<v.u.strval>1;
				_here;
			}
			
			/*
			** Combine two adjacent character constants into
			** a single string constant.
			*/

		|	wcharconst wcharconst  
			{
				_here;
				$<v.Type>$ = &wstring_ste;
				$<v.pType>$ = tWString;
				$<v.u.strval>$ = malloc2( 6 );
				$<v.u.strval>$[ 0 ] = $<v.u.bytes>1[0];
				$<v.u.strval>$[ 1 ] = $<v.u.bytes>1[1];
				$<v.u.strval>$[ 2 ] = $<v.u.bytes>2[0];
				$<v.u.strval>$[ 3 ] = $<v.u.bytes>2[1];
				$<v.u.strval>$[ 4 ] = '\0';
				$<v.u.strval>$[ 5 ] = '\0';
				_here;
			}

			/*
			** Concatenate a string constant followed by a character
			** constant to form a single string constant.
			*/

		|	wstrconst wcharconst 
			{
				int len = wstrlen( $<v.u.strval>1 );

				_here;
				$<v.Type>$ = &wstring_ste;
				$<v.pType>$ = tWString;
				$<v.u.strval>$ = malloc2( len + 2 );
				memcpy( $<v.u.strval>$, $<v.u.strval>1, len + 2 );
				$<v.u.strval>$[ len ] =  $<v.u.bytes>2[0];
				$<v.u.strval>$[ len + 1 ] =  $<v.u.bytes>2[1];
				$<v.u.strval>$[ len + 2 ] =  '\0';
				$<v.u.strval>$[ len + 3 ] =  '\0';
				free2( vss $<v.u.strval>1 );
				_here;
			}

			/*
			** Concatenate a single character constant followed by
			** a string constant to form a single string.
			*/

		|	wcharconst WStringConst
			{
				int len;
				
				_here;
				len = wstrlen( $<v.u.strval>2 );
				
				$<v.Type>$ = &wstring_ste;
				$<v.pType>$ = tWString;
				$<v.u.strval>$ = malloc2( len );

				$<v.u.strval>$[ 0 ] = $<v.u.bytes>1[0];
				$<v.u.strval>$[ 1 ] = $<v.u.bytes>1[1];
				memcpy( $<v.u.strval>$ + 2, $<v.u.strval>2, len );

				free2( vss $<v.u.strval>2 );
				_here;
			}

			/*
			** Concatenate multiple string constants into a single
			** string constant.
			*/

		|	wstrconst WStringConst 
			{
				int len1;
				int len2;
				
				_here;
				len1 = wstrlen( $<v.u.strval>1 );
				len2 = wstrlen( $<v.u.strval>2 );
				$<v.Type>$ = &wstring_ste;
				$<v.pType>$ = tWString;
				$<v.u.strval>$ = malloc2( len1 + len2 );

				memcpy( $<v.u.strval>$, $<v.u.strval>1, len1 );
				memcpy( $<v.u.strval>$+len1-2, $<v.u.strval>2, len2 );
				free2( vss $<v.u.strval>1 );
				free2( vss $<v.u.strval>2 );
				_here;
			}

		;


 /*
 ** Handle literal constants of the form:
 **
 **	@{ numeric_set }
 **
 ** here (this is a set of integers in the range 0..31 forming
 ** a dword value).
 */

LiteralConst:
		'@'			/* $1 */
		'{'			/* $2 */
		intSet		/* $3 */
		Rbrace		/* $4 */
		{
			_here;
			ClrConst
			(
				YYS &$<v>$,
				tDWord,
				&dword_ste
			);
			$<v.u.unsval>$ = $<v.u.unsval>3;
		}
	;
	
intSet:
		EmptyIntSet	
		{
			_here;
			$<v.u.unsval>$ = 0;
		}
		
	|	intSetItems
		{
		 	_here;
		 	$<v.u.unsval>$ = $<v.u.unsval>1;
		}
	;
	
intSetItems:
		intSetItem
		{
			_here;
			$<v.u.unsval>$ = $<v.u.unsval>1;
		}
		
	|	intSet		/* $1 */
		','			/* $2 */
		intSetItem	/* $3 */
		{
			_here;
			$<v.u.unsval>$ = $<v.u.unsval>1 | $<v.u.unsval>3;
		}
	;

EmptyIntSet:
	;
	
intSetItem:	
		ConstOnlyExpr 
		{
			_here;
			_if
			( 
					( !IsUns( $<v.pType>1 ) && !IsBytes( $<v.pType>1 ) )
				||	numBits32( YYS &$<v>1 ) > 32
				||	$<v.u.unsval>1 >= 32
			)
			
				yyerror( "Expected an integer value between 0 and 31" );
				$<v.u.unsval>$ = 0;
				
			_else
			
				$<v.u.unsval>$ = 1 << $<v.u.unsval>1;

			_endif
			$<v.pType>$ = tDWord;
		}
	;
			


 /*****************************************/
 /*                                       */
 /*  Handle character set constants here. */
 /*                                       */
 /*****************************************/


LiteralConst:
		CSetLiteralConst
		{
			_here;
			$<v>$ = $<v>1;
		}
	;
	
CSetLiteralConst:
			'{' 
			PreserveGlobal	/* Save a copy of the GlobalCSet object	*/ 
			ClearSet  		/* GlobalCSet <- empty_set				*/
			SetItems 		/* Union set items into GlobalCSet.		*/
			Rbrace 
			{
				_here;
				$<v.Type>$ = &cset_ste;
				$<v.pType>$ = tCset;
				ClrArray( YYS &$<v>$ );

				/*
				** Return the set constant prepared by the
				** SetItems productions.
				*/

				memcpy( &$<v.u.csetval>$, &GlobalCset, CSetSizeInBytes );


				/*
				** PreserveGlobal pushed a copy of GlobalCset
				** onto the parser stack.  The following for
				** loop restores GlobalCset from that copy made.
				** The allows the use of the global value GlobalCset
				** in a reentrant fashion.
				*/

				memcpy( &GlobalCset, &$<v.u.csetval>2, CSetSizeInBytes );
				_here;
			};

/*
** SetItems- 	Valid set items are character constants or character
**				ranges ( char..char )) separated by commas.
*/

SetItems:	
			/* empty */ 
		|	SetItem 
		|	SetItems ',' SetItem 
		;

SetItem:	ConstOnlyExpr UnionChar;
SetItem:	ConstOnlyExpr DotDot ConstOnlyExpr UnionRange;


 /*
 ** UnionChar-
 **
 **	Adds a single character (singleton) to the current character set.
 ** The character to add to the set is passed in as an inherited attribute.
 ** The calling code must set up this attribute.
 **
 ** Modified 2/6/2007 to allow string objects as well (unions in each of
 ** the characters in the string).
 */

UnionChar:	{
				_here;
				_if( $<v.pType>0 == tString )
				
					char *str =$<v.u.strval>0;
					_while( *str != '\0' )
					
						AddGlobalCset( *str );
						++str;
						
					_endwhile
					
				_elseif( $<v.pType>0 == tChar )

					AddGlobalCset( $<v.u.charval>0 );

				_else

					yyerror( "Only character constants allowed here" );

				_endif
				_here;
			};

 /*
 ** UnionRange-
 **
 **	We've got an expression of the form 'x'..'y'.
 ** Union in all the characters in this range.
 **
 ** The starting and ending character values for the range are passed
 ** in as inherited attributes $-2 and $0, respectively.  The calling
 ** code must set these up.
 */

UnionRange:	{
				_here;
				_if( $<v.pType>0 != tChar || $<v.pType>-2 != tChar )
				
					yyerror( "Character set constructor requires char constants" );
					
				_endif
				_if( $<v.u.charval>-2 > $<v.u.charval>0 )

					yyerror( "Bad range for character set constant" );

				_endif
				_for
				( 
					unsigned char ch=$<v.u.charval>-2, 
					ch <= $<v.u.charval>0, 
					++ch 
				)
			
					_if( ch <= 127 )

						AddGlobalCset( ch );

					_else

						yyerror( "Charset range must be 0..127" );
						break;

					_endif
				
				_endfor
				_here;

				
			}; 

 /*
 ** ClearSet-
 **
 ** Initializes the global character set to the empty set.
 */

ClearSet:	{	
				_here;
				memset( &GlobalCset, 0, CSetSizeInBytes );
				_here;

			};


 /*
 ** PreserveGlobal-
 **
 **	Saves a copy of GlobalCset on the parser stack so we can
 ** restore it later.  This is to allow recursive calls to the
 ** cset routines.  For example, someone might try something
 ** like this:
 **
 **	c:cset := { 'a'..'z', cset( string( {'0'..'9'} ) ), 'A'..'Z' };
 **
 ** This properly produces the set {'a'..'z', '0'..'9', 'A'..'Z'}
 **
 ** It we did not preserve the GlobalCset variable, the set would
 ** probably get messed up.
 */

PreserveGlobal:	
			{
				_here;
				memcpy( &$<v.u.csetval>$, &GlobalCset, CSetSizeInBytes );
				_here;

			};










 /***************************/
 /*                         */
 /*  Handle Unary "-" here. */
 /*                         */
 /***************************/

 
ConstExpr:	
		'-' 
		ConstExpr %prec UMINUS
		{
			struct SymNode v;

			_here;
			memcpy( &$<v>$, &$<v>2, sizeofSymNode );
			negval
			( 
				&$<v.u.lwordval>$[0], 
				&$<v.u.lwordval>2[0], 
				$<v.pType>2, 
				&$<v.pType>$, 
				&$<v.Type>$ 
			);
			ClrArray( YYS &$<v>$ );
			_here;
		};
			
			


 /******************************/
 /*                            */
 /*  Handle Unary 'not' here.  */
 /*                            */
 /******************************/

ConstExpr:	
		'!' 
		ConstExpr %prec UMINUS
		{
			_here;
			memcpy( &$<v>$, &$<v>2, sizeofSymNode );
			notval
			( 
				&$<v.u.lwordval>$[0], 
				&$<v.u.lwordval>2[0], 
				$<v.pType>2, 
				&$<v.pType>$, 
				&$<v.Type>$ 
			);
			ClrArray( YYS &$<v>$ );
			_here;
		};
				   	
	








/*********************************************/
/*                                           */
/* Handle Addition of constants here         */
/* (Also includes union of character sets	 */
/*  and string concatenation).				 */
/*                                           */
/*********************************************/
	

ConstExpr:	
		ConstExpr 
		'+' 
		ConstExpr
		{


			struct SymNode v;

			/*
			** Handle the special case where the left operand
			** is of the form "&ID" which can only be used as
			** an address in a static operand.
			*/

			_here;
			_if( $<v.pType>1 == tPointer )

				_if
				( 
						IsOrdinal( $<v.pType>3 )
					&&	numBits32( YYS &$<v>3 ) <= 32
				)

					char temp[ 256 ];
					
					sprintf( temp, "%s+%u", $<v.u.strval>1, $<v.u.unsval>3 );
					$<v.pType>$ = tPointer;
					$<v.Type>$ = &pointer_ste;
					$<v.SymClass>$ = cConstant;
					$<v.u.strval>$ = hlastrdup2( temp );


				_else

					yyerror( "Illegal static address constant" );

				_endif
				free2( vss $<v.u.strval>1 );


			/*
			** Next, see if the two operands are compatible
			** with one another or if we can make them compatible
			** with one another.
			*/

			_elseif( MakeCompatible( &$<v>1, &$<v>3 ))				
				
				/*
				** At this point, the objects are compatible with
				** one another, so we can use the type of either
				** operand to determine how to perform the "+"
				** operation.  
				*/

				_switch( $<v.pType>1 )

					/* For numeric values, just do an addition.
					*/

					_case( tUns8 )
					_case( tUns16 )
					_case( tUns32 )
					_case( tUns64 )
					_case( tUns128 )
					_case( tByte )
					_case( tWord )
					_case( tDWord )
					_case( tQWord )
					_case( tTByte )
					_case( tLWord )
					_case( tInt8 )
					_case( tInt16 )
					_case( tInt32 )
					_case( tInt64 )
					_case( tInt128 )
					_case( tReal32 )
					_case( tReal64 )
					_case( tReal80 )
					_case( tCset )

						memcpy( &$<v>$, &$<v>1, sizeofSymNode );
						addval
						( 
							&$<v.u.lwordval>$[0], 
							&$<v.u.lwordval>3[0], 
							&$<v.pType>$,
							&$<v.Type>$ 
						);
						
					_endcase


					/*
					** For string operands, do string concat.
					*/

			    	_case( tString )
					{
						char *newstr;

						ClrConst
						( 
							YYS &$<v>$, 
							tString, 
							&string_ste
						);
						newstr = 
							malloc2
							( 
									strlen( $<v.u.strval>1 ) 
								+	strlen( $<v.u.strval>3 )
								+	1
							);

						strcpy( newstr, $<v.u.strval>1 );
						strcat( newstr, $<v.u.strval>3 );
						$<v.u.strval>$ = newstr;
						free2( vss $<v.u.strval>1 );
						free2( vss $<v.u.strval>3 );
					}
			    	_endcase
			    		
			    	_case( tZString )
					{
						char *newstr;

						ClrConst
						( 
							YYS &$<v>$, 
							tZString, 
							&zstring_ste
						);
						newstr = 
							malloc2
							( 
									strlen( $<v.u.strval>1 ) 
								+	strlen( $<v.u.strval>3 )
								+	1
							);

						strcpy( newstr, $<v.u.strval>1 );
						strcat( newstr, $<v.u.strval>3 );
						$<v.u.strval>$ = newstr;
						free2( vss $<v.u.strval>1 );
						free2( vss $<v.u.strval>3 );
					}
			    	_endcase
			    		
					/*
					** For character operands, do string concatenation.
					*/


			    	_case( tChar )
					{
						char *newstr;

						newstr = malloc2( 3 );


						/*
						** Alas, above we set the type of the
						** return value to tChar.  It really needs to
						** be of type string.  Correct that here.
						*/

						SetConst
						( 
							YYS &$<v>$, 
							tString, 
							&string_ste,
							YYS &v
						);

						newstr[ 0 ] = $<v.u.charval>1;
						newstr[ 1 ] = $<v.u.charval>3;
						newstr[ 2 ] = '\0';
						$<v.u.strval>$ = newstr;

					}
			    	_endcase
			    		

					_default

						yyerror( "Illegal operand types" );
						SetConst
						( 
							YYS &$<v>$, 
							tBoolean, 
							&boolean_ste,
							YYS &v
						);
				

				_endswitch

			_else

				yyerror( "Type mismatch in operands" );
				SetConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste,
					YYS &v
				);
				
			_endif
			_here;

		}
	;
	  


	  
	  
	  
	  
	  
	  




		

/*********************************************/
/*                                           */
/* Handle Subtraction of constants here      */
/* (Also includes difference of character 	 */
/*  sets).									 */
/*                                           */
/*********************************************/
			   
/*
** See Addition for better comments
*/

ConstExpr:	ConstExpr '-' ConstExpr
			{
				struct SymNode v;

				_here;
				
				/*
				** Handle the special case where the left operand
				** is of the form "@ID" which can only be used as
				** an address in a static operand.
				*/

				_if( $<v.pType>1 == tPointer )

					_if( IsOrdinal( $<v.pType>3 ) && numBits( YYS &$<v>3 ) <= 32 )

						char temp[ 256 ];
						
						sprintf( temp, "%s-%u", $<v.u.strval>1, $<v.u.unsval>3 );
						$<v.pType>$ = tPointer;
						$<v.Type>$ = &pointer_ste;
						$<v.SymClass>$ = cConstant;
						$<v.u.strval>$ = hlastrdup2( temp );


					_else

						yyerror( "Illegal static address constant" );

					_endif
					free2( vss $<v.u.strval>1 );

				_elseif( MakeCompatible( &$<v>1, &$<v>3 ))

					_here;
					SetConst
					( 
						YYS &$<v>$, 
						$<v.pType>1, 
						$<v.Type>1,
						YYS &v				/* Dummy value */
					);

					_switch( $<v.pType>1 )

						/*
						** For the numeric types, do subtraction.
						*/

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )
						_case( tQWord )
						_case( tTByte )
						_case( tLWord )
						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )
						_case( tReal32 )
						_case( tReal64 )
						_case( tReal80 )
  			    		_case( tCset )

							_here;
							memcpy( &$<v>$, &$<v>1, sizeofSymNode );
							subval
							( 
								&$<v.u.lwordval>$[0], 
								&$<v.u.lwordval>3[0], 
								&$<v.pType>$,
								&$<v.Type>$ 
							);
							_here;
						

						_endcase

						_default

							yyerror( "Illegal operand types" );
							ClrConst
							(
								YYS &$<v>$,
								tUns32,
								&uns32_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					(
						YYS &$<v>$,
						tUns32,
						&uns32_ste
					);


				_endif
				_here;

			};
	  
	  
	  
	  
	  
	  
	  




/*********************************************/
/*                                           */
/* Handle Multiplication of constants here   */
/* (Also includes intersection of character	 */
/*  sets).									 */
/*                                           */
/*********************************************/
			
/*
** See Addition for detailed comments
*/



ConstExpr:	
		ConstExpr 
		'*' 
		ConstExpr
		{

			struct SymNode v;

			_here;
			_if( MakeCompatible( &$<v>1, &$<v>3 ))

				_switch( $<v.pType>1 )

					/*
					** For numeric operands, compute the product.
					*/

					_case( tUns8 )
					_case( tUns16 )
					_case( tUns32 )
					_case( tUns64 )
					_case( tUns128 )
					_case( tByte )
					_case( tWord )
					_case( tDWord )
					_case( tQWord )
					_case( tTByte )
					_case( tLWord )
					_case( tInt8 )
					_case( tInt16 )
					_case( tInt32 )
					_case( tInt64 )
					_case( tInt128 )
					_case( tReal32 )
					_case( tReal64 )
					_case( tReal80 )
			    	_case( tCset )
					
						memcpy( &$<v>$, &$<v>1, sizeofSymNode );
						mulval
						( 
							&$<v.u.lwordval>$[0], 
							&$<v.u.lwordval>3[0], 
							&$<v.pType>$,
							&$<v.Type>$ 
						);
					

					_endcase

					_default

						yyerror( "Illegal operand types" );
						ClrConst
						(
							YYS &$<v>$,
							tUns32,
							&uns32_ste
						);

				_endswitch

			_else

				yyerror( "Type mismatch in operands" );
				ClrConst
				(
					YYS &$<v>$,
					tUns32,
					&uns32_ste
				);

			_endif
			_here;
		}
	;
	  
	  
	  
	  
	  
	  




		
		
/*********************************************/
/*                                           */
/* Handle Division of constants here.		 */
/* Performs a real division that always		 */
/* returns a real result.					 */
/*                                           */
/*********************************************/

			
ConstExpr:	
		ConstExpr 
		'/' 
		ConstExpr
		{

			// If the left operand is not real80, convert it
			// to real80 (if possible, print an error if not).
			
			_here;
			_if( !IsCompatible( &real80_ste, YYS &$<v>1 ) )
				
				yyerror
				( 
					"Left operand to '/' is incompatible with REAL80 type"
				);
				$<v.u.lwordval>1[0] = 1;
				$<v.u.lwordval>1[1] = 0;
				$<v.u.lwordval>1[2] = 0;
				$<v.u.lwordval>1[3] = 0;
				$<v.pType>1 = tUns8;
				$<v.Type>1 = &uns8_ste;
				
				// Force '1' to real:
				
				IsCompatible( &real80_ste, YYS &$<v>1 );
				
			_endif;

			// If the right operand is not real80, convert it
			// to real80 (if possible, print an error if not).
			
			_if( !IsCompatible( &real80_ste, YYS &$<v>3 ) )
				
				yyerror
				( 
					"Right operand to '/' is incompatible with REAL80 type"
				);
				$<v.u.lwordval>3[0] = 1;
				$<v.u.lwordval>3[1] = 0;
				$<v.u.lwordval>3[2] = 0;
				$<v.u.lwordval>3[3] = 0;
				$<v.pType>1 = tUns8;
				$<v.Type>1 = &uns8_ste;
				
				// Force '1' to real:
				
				IsCompatible( &real80_ste, YYS &$<v>1 );
				
			_endif;

			_if( MakeCompatible( &$<v>1, &$<v>3 ))

				// At this point, both operands are
				// real80, so do the division:
				
				memcpy( &$<v>$, &$<v>1, sizeofSymNode );
				divval
				( 
					&$<v.u.lwordval>$[0], 
					&$<v.u.lwordval>3[0], 
					&$<v.pType>$,
					&$<v.Type>$ 
				);
				


			_else

				yyerror( "Type mismatch in operands" );
				ClrConst
				(
					YYS &$<v>$, 
					tUns32, 
					&uns32_ste
				);

			_endif
			_here;
		}
	;
	  
	  
	  
	  
	  
	  




		
		
/*********************************************/
/*                                           */
/* Handle Division of constants here.		 */
/* Performs an integer division that always	 */
/* returns an integer result.				 */
/*                                           */
/*********************************************/
			
ConstExpr:	ConstExpr divTkn ConstExpr
			{
				struct SymNode v;

				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					_switch( $<v.pType>1 )

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )
						_case( tQWord )
						_case( tTByte )
						_case( tLWord )
						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )

							memcpy( &$<v>$, &$<v>1, sizeofSymNode );
							divval
							( 
								&$<v.u.lwordval>$[0], 
								&$<v.u.lwordval>3[0], 
								&$<v.pType>$,
								&$<v.Type>$ 
							);

						_endcase
						
						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							(
								YYS &$<v>$,
								tUns32,
								&uns32_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					(
						YYS &$<v>$, 
						tUns32, 
						&uns32_ste
					);

				_endif
				_here;

			};
	  
	  
	  
	  
	  
	  




		
		
		
		
/*********************************************/
/*                                           */
/* Handle Modulo (remainder) of constants	 */
/* here.  Performs an integer division that  */
/* always returns an integer result.		 */
/*                                           */
/*********************************************/
	
			
ConstExpr:	ConstExpr modTkn ConstExpr
			{
				struct SymNode v;
				
				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					_switch( $<v.pType>1 )

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )
						_case( tQWord )
						_case( tTByte )
						_case( tLWord )
						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )


							memcpy( &$<v>$, &$<v>1, sizeofSymNode );
							modval
							( 
								&$<v.u.lwordval>$[0], 
								&$<v.u.lwordval>3[0], 
								&$<v.pType>$,
								&$<v.Type>$ 
							);

						_endcase

						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							(
								YYS &$<v>$,
								tUns32,
								&uns32_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					(
						YYS &$<v>$, 
						tUns32, 
						&uns32_ste
					);

				_endif
				_here;
			};
	  
	  
	  
	  
	  
	  




/**************************************************/
/* 		                                          */
/* Handle logical AND, OR, and XOR of boolean and */
/* logical constants here.                        */
/*                                                */
/**************************************************/


ConstExpr:	ConstExpr '&' ConstExpr
			{
				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					ClrConst
					( 
						YYS &$<v>$, 
						$<v.pType>1, 
						$<v.Type>1			/* Dummy value */
					);

					_switch( $<v.pType>1 )

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )
						_case( tQWord )
						_case( tTByte )
						_case( tLWord )

							$<v.u.lwordval>$[0] = 
								$<v.u.lwordval>1[0] & $<v.u.lwordval>3[0];

							$<v.u.lwordval>$[1] = 
								$<v.u.lwordval>1[1] & $<v.u.lwordval>3[1];

							$<v.u.lwordval>$[2] = 
								$<v.u.lwordval>1[2] & $<v.u.lwordval>3[2];

							$<v.u.lwordval>$[3] = 
								$<v.u.lwordval>1[3] & $<v.u.lwordval>3[3];
								
							compactType
							( 
								&$<v.u.lwordval>$, 
								&$<v.pType>$, 
								&$<v.Type>$ 
							);
							$<v.ObjectSize>$ = $<v.Type>$->ObjectSize;


						_endcase

						_case( tBoolean )

							$<v.u.boolval>$ = $<v.u.boolval>1 && $<v.u.boolval>3;

						_endcase

						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							(
								YYS &$<v>$,
								tUns32,
								&uns32_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					(
						YYS &$<v>$, 
						tUns32, 
						&uns32_ste
					);

				_endif
				_here;
			};
	  
	  
	  
	  
ConstExpr:	ConstExpr '|' ConstExpr
			{

				struct SymNode v;

				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					SetConst
					( 
						YYS &$<v>$, 
						$<v.pType>1, 
						$<v.Type>1,
						YYS &v	/* Dummy value */
					);

					_switch( $<v.pType>1 )

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )
						_case( tQWord )
						_case( tTByte )
						_case( tLWord )

							$<v.u.lwordval>$[0] = 
								$<v.u.lwordval>1[0] | $<v.u.lwordval>3[0];

							$<v.u.lwordval>$[1] = 
								$<v.u.lwordval>1[1] | $<v.u.lwordval>3[1];

							$<v.u.lwordval>$[2] = 
								$<v.u.lwordval>1[2] | $<v.u.lwordval>3[2];

							$<v.u.lwordval>$[3] = 
								$<v.u.lwordval>1[3] | $<v.u.lwordval>3[3];

							compactType
							( 
								&$<v.u.lwordval>$, 
								&$<v.pType>$, 
								&$<v.Type>$ 
							);
							$<v.ObjectSize>$ = $<v.Type>$->ObjectSize;

						_endcase

						_case( tBoolean )

							$<v.u.boolval>$ = 
								$<v.u.boolval>1 || $<v.u.boolval>3;

						_endcase

						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							(
								YYS &$<v>$,
								tUns32,
								&uns32_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					(
						YYS &$<v>$, 
						tUns32, 
						&uns32_ste
					);

				_endif
				_here;
			};
	  
	  
	  
	  
ConstExpr:	ConstExpr '^' ConstExpr
			{

				struct SymNode v;

				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					ClrConst
					( 
						YYS &$<v>$, 
						$<v.pType>1, 
						$<v.Type>1
					);

					_switch( $<v.pType>1 )

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )
						_case( tQWord )
						_case( tTByte )
						_case( tLWord )

							$<v.u.lwordval>$[0] = 
								$<v.u.lwordval>1[0] ^ $<v.u.lwordval>3[0];

							$<v.u.lwordval>$[1] = 
								$<v.u.lwordval>1[1] ^ $<v.u.lwordval>3[1];

							$<v.u.lwordval>$[2] = 
								$<v.u.lwordval>1[2] ^ $<v.u.lwordval>3[2];

							$<v.u.lwordval>$[3] = 
								$<v.u.lwordval>1[3] ^ $<v.u.lwordval>3[3];

							compactType
							( 
								&$<v.u.lwordval>$, 
								&$<v.pType>$, 
								&$<v.Type>$ 
							);
							$<v.ObjectSize>$ = $<v.Type>$->ObjectSize;

						_endcase

						_case( tBoolean )

							$<v.u.boolval>$ = 
									( $<v.u.boolval>1 != 0 )
								^	( $<v.u.boolval>3 != 0 );

						_endcase

						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							(
								YYS &$<v>$,
								tUns32,
								&uns32_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					(
						YYS &$<v>$, 
						tUns32, 
						&uns32_ste
					);

				_endif
				_here;
			};
	  
	  
	  



/****************************************************/
/*                                                  */
/* Handle the left and right shift operations here. */
/* shl, shr                                         */
/*                                                  */
/****************************************************/



ConstExpr:	
		ConstExpr	/* $1 */ 
		shlopTkn 	/* $2 */
		ConstExpr	/* $3 */
		{

			struct SymNode v;
			
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			
			_if
			( 
					IsNumber( $<v.pType>3 )
				&&	$<v.u.lwordval>3[0] <= 128
				&&	$<v.u.lwordval>3[1] == 0 
				&&	$<v.u.lwordval>3[1] == 0 
				&&	$<v.u.lwordval>3[1] == 0
			)
			
				_if( IsNumber( $<v.pType>1 ))
				
					shlval
					( 
						&$<v.u.lwordval>$[0],
						&$<v.u.lwordval>3[0], 
						&$<v.pType>$, 
						&$<v.Type>$ 
					);
									
				_else
				
					yyerror( "Shift operands must be integers" );
					
				_endif
			
			
			_else
			
				yyerror
				( 
					"Shift count must be an integer in the range 0..128"
				);
				
			_endif
			_here;
		}
	;
	  
	  
	  



	  
	  
ConstExpr:
		ConstExpr	/* $1 */ 
		shropTkn 	/* $2 */
		ConstExpr	/* $3 */
		{

			struct SymNode v;

			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			
			_if
			( 
					IsNumber( $<v.pType>3 )
				&&	$<v.u.lwordval>3[0] <= 128
				&&	$<v.u.lwordval>3[1] == 0 
				&&	$<v.u.lwordval>3[1] == 0 
				&&	$<v.u.lwordval>3[1] == 0
			)
			
				_if( IsNumber( $<v.pType>1 ))
				
					shrval
					( 
						&$<v.u.lwordval>$[0],
						&$<v.u.lwordval>3[0], 
						&$<v.pType>$, 
						&$<v.Type>$ 
					);
									
				_else
				
					yyerror( "Shift operands must be integers" );
					
				_endif
			
			
			_else
			
				yyerror
				( 
					"Shift count must be an integer in the range 0..128"
				);
				
			_endif
			_here;
		}
	;
	  
	  
	  
	  

/***********************************************/
/*                                             */
/* Handle the comparison operations down here. */
/* =, <>, <, >, <=, >=, in                     */
/*                                             */
/***********************************************/
	  

ConstExpr:	ConstExpr '=' ConstExpr
			{

				/*
				** If the operand types are different, see if we
				** can coerce them to be the same.
				*/

				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					/*
					** Initialize the fields of the return result.
					** Type is always boolean, default to true...
					*/

					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

					_switch( $<v.pType>1 )

						/*
						** Compare ordinal types here.
						*/

						_case( tEnum )						

							$<v.u.boolval>$ = $<v.u.unsval>1 == $<v.u.unsval>3;
							
						_endcase


						_case( tBoolean )
						_case( tChar )

							$<v.u.boolval>$ = $<v.u.charval>1 == $<v.u.charval>3;
							
						_endcase

						/*
						** Compare numeric types here.
						*/

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )
						_case( tQWord )
						_case( tTByte )
						_case( tLWord )
						_case( tCset )

							$<v.u.boolval>$ = 
									$<v.u.lwordval>1[0] == $<v.u.lwordval>3[0]
								&&	$<v.u.lwordval>1[1] == $<v.u.lwordval>3[1]
								&&	$<v.u.lwordval>1[2] == $<v.u.lwordval>3[2]
								&&	$<v.u.lwordval>1[3] == $<v.u.lwordval>3[3];
								
						_endcase

						_case( tReal32 )
							
							// Floats are equal only if all 32 bits are equal:
							
							$<v.u.boolval>$ = 
									$<v.u.lwordval>1[0] == $<v.u.lwordval>3[0];
							


						_case( tReal64 )
							
							// Doubles are equal only if all 64 bits are equal:

							$<v.u.boolval>$ = 
									$<v.u.lwordval>1[0] == $<v.u.lwordval>3[0]
								&&	$<v.u.lwordval>1[1] == $<v.u.lwordval>3[1];
							

						_case( tReal80 )

							$<v.u.boolval>$ = 
								feq80( $<v.u.fltval>1, $<v.u.fltval>3 );

						_endcase



						/*
						** Compare strings and pointer constants (which
						** are string objects) here.
						*/
																 
						_case( tPointer )
						{
							char *l = $<v.u.strval>1;
							char *r	= $<v.u.strval>3;

							/*
							** skip over the "?nnnn_" preceding
							** the static name.
							*/

							_do _until( *l++ == '_' );
							_do _until( *r++ == '_' );

							$<v.u.boolval>$ = 
								_streq( l, r );
						}
						_endcase


						_case( tString )
						_case( tZString )

							$<v.u.boolval>$ = 
								_streq( $<v.u.strval>1, $<v.u.strval>3 );

						_endcase



						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							(
								YYS &$<v>$,
								tBoolean,
								&boolean_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

				_endif
				_here;
			};
	  
	  
	  
	  
	  

/*
** Not Equal operator - See "=" operator for detailed comments.
*/


ConstExpr:	ConstExpr neTkn ConstExpr
			{

				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

					_switch( $<v.pType>1 )

						_case( tEnum )						

							$<v.u.boolval>$ = $<v.u.unsval>1 != $<v.u.unsval>3;
							
						_endcase


						_case( tBoolean )
						_case( tChar )

							$<v.u.boolval>$ = $<v.u.charval>1 != $<v.u.charval>3;
							
						_endcase

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )						
						_case( tQWord )						
						_case( tTByte )
						_case( tLWord )
						_case( tCset )						

							$<v.u.boolval>$ = 
									$<v.u.lwordval>1[0] != $<v.u.lwordval>3[0]
								||	$<v.u.lwordval>1[1] != $<v.u.lwordval>3[1]
								||	$<v.u.lwordval>1[2] != $<v.u.lwordval>3[2]
								||	$<v.u.lwordval>1[3] != $<v.u.lwordval>3[3];
								

						_endcase



						_case( tReal32 )
							
							// Floats are equal only if all 32 bits are equal:
							
							$<v.u.boolval>$ = 
									$<v.u.lwordval>1[0] != $<v.u.lwordval>3[0];
							


						_case( tReal64 )
							
							// Doubles are equal only if all 64 bits are equal:

							$<v.u.boolval>$ = 
									$<v.u.lwordval>1[0] != $<v.u.lwordval>3[0]
								&&	$<v.u.lwordval>1[1] != $<v.u.lwordval>3[1];
							

						_case( tReal80 )

							$<v.u.boolval>$ = 
								fne80( $<v.u.fltval>1, $<v.u.fltval>3 );

						_endcase




						_case( tPointer )
						{
							char *l = $<v.u.strval>1;
							char *r	= $<v.u.strval>3;

							/*
							** skip over the "?nnnn_" preceding
							** the static name.
							*/

							_do _until( *l++ == '_' );
							_do _until( *r++ == '_' );

							$<v.u.boolval>$ = 
								_strne( l, r );
						}
						_endcase



						_case( tString )
						_case( tZString )

							$<v.u.boolval>$ = 
								_strne( $<v.u.strval>1, $<v.u.strval>3 );

						_endcase


						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							( 
								YYS &$<v>$, 
								tBoolean, 
								&boolean_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

				_endif
				_here;
			};
	  
	  


	  
/*
** Less Than operator - See "=" operator for detailed comments.
*/
	  
ConstExpr:	ConstExpr '<' ConstExpr
			{
				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

					_switch( $<v.pType>1 )


						_case( tEnum )						

							$<v.u.boolval>$ = $<v.u.unsval>1 < $<v.u.unsval>3;
							
						_endcase


						_case( tBoolean )
						_case( tChar )

							$<v.u.boolval>$ = $<v.u.charval>1 < $<v.u.charval>3;
							
						_endcase

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )						
						_case( tQWord )						
						_case( tTByte )
						_case( tLWord )

							$<v.u.boolval>$ = 
								UnsLT( &$<v.u.lwordval>1[0], &$<v.u.lwordval>3[0] );

						_endcase


						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )

							$<v.u.boolval>$ = 
								IntLT( &$<v.u.lwordval>1[0], &$<v.u.lwordval>3[0] );

						_endcase




						_case( tReal32 )
							
							$<v.u.boolval>$ = 
									$<v.u.fltval.f.f>1 < $<v.u.fltval.f.f>3; 
							


						_case( tReal64 )
							
							// Doubles are equal only if all 64 bits are equal:

							$<v.u.boolval>$ = 
									$<v.u.fltval.f.d>1 < $<v.u.fltval.f.d>3; 
							

						_case( tReal80 )

							$<v.u.boolval>$ = 
								flt80( $<v.u.fltval>1, $<v.u.fltval>3 );

						_endcase


						_case( tString )
						_case( tZString )

							$<v.u.boolval>$ = 
								_strlt( $<v.u.strval>1, $<v.u.strval>3 );

						_endcase


						/*
						** One character set is less than another if
						** the first CSet is a proper subset of the other.
						** This occurs if their intersection equals
						** the first operand but not the seconv.
						*/

						_case( tCset )
						{
							int IsEql = 1;
							int IsLE = 1;

							_for( int i=0, i < CSetSizeInBytes, ++i )

								IsEql &=
										$<v.u.csetval>1[i] 
									== 	$<v.u.csetval>3[i];

								IsLE &=
									( 
											$<v.u.csetval>1[i] 
										&	$<v.u.csetval>3[i] 
									)
									== $<v.u.csetval>1[i];

							_endfor
							$<v.u.boolval>$ =	IsLE && !IsEql;
						}
						_endcase



						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							( 
								YYS &$<v>$, 
								tBoolean, 
								&boolean_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

				_endif
				_here;
			};
	  
	  
	  
	  
	  
/*
** Less Than or Equal operator - See "=" operator for detailed comments.
*/

ConstExpr:	ConstExpr leTkn ConstExpr
			{
				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

					_switch( $<v.pType>1 )

						_case( tEnum )						

							$<v.u.boolval>$ = $<v.u.unsval>1 <= $<v.u.unsval>3;
							
						_endcase


						_case( tBoolean )
						_case( tChar )

							$<v.u.boolval>$ = $<v.u.charval>1 <= $<v.u.charval>3;
							
						_endcase

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )						
						_case( tQWord )						
						_case( tTByte )
						_case( tLWord )

							$<v.u.boolval>$ = 
								UnsLE( &$<v.u.lwordval>1[0], &$<v.u.lwordval>3[0] );

						_endcase


						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )

							$<v.u.boolval>$ = 
								IntLE( &$<v.u.lwordval>1[0], &$<v.u.lwordval>3[0] );

						_endcase




						_case( tReal32 )
							
							// Floats are equal only if all 32 bits are equal:
							
							$<v.u.boolval>$ = 
									$<v.u.fltval.f.f>1 <= $<v.u.fltval.f.f>3; 
							


						_case( tReal64 )
							
							// Doubles are equal only if all 64 bits are equal:

							$<v.u.boolval>$ = 
									$<v.u.fltval.f.d>1 <= $<v.u.fltval.f.d>3; 
							

						_case( tReal80 )

							$<v.u.boolval>$ = 
								fle80( $<v.u.fltval>1, $<v.u.fltval>3 );

						_endcase


						_case( tString )
						_case( tZString )

							$<v.u.boolval>$ = 
								_strle( $<v.u.strval>1, $<v.u.strval>3 );

						_endcase


						
						/*
						** One Cset is less than or equal to another if
						** the first cset is a subset of the other.
						** This occurs when their intersection is equal
						** to the first cset.
						*/

						_case( tCset )
						{
							int IsLE = 1;

							_for( int i=0, i < CSetSizeInBytes, ++i )

								IsLE &=
									( 
											$<v.u.csetval>1[i] 
										&	$<v.u.csetval>3[i] 
									)
									== $<v.u.csetval>1[i];

							_endfor
							$<v.u.boolval>$ =	IsLE;
						}
						_endcase



						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							( 
								YYS &$<v>$, 
								tBoolean, 
								&boolean_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

				_endif
				_here;
			};
	  
	  
	  
	  
	  


	  
/*
** Greater Than operator - See "=" operator for detailed comments.
*/

ConstExpr:	ConstExpr '>' ConstExpr
			{
				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

					_switch( $<v.pType>1 )

						_case( tEnum )						

							$<v.u.boolval>$ = $<v.u.unsval>1 > $<v.u.unsval>3;
							
						_endcase


						_case( tBoolean )
						_case( tChar )

							$<v.u.boolval>$ = $<v.u.charval>1 > $<v.u.charval>3;
							
						_endcase

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )						
						_case( tQWord )						
						_case( tTByte )
						_case( tLWord )

							$<v.u.boolval>$ = 
								UnsGT( &$<v.u.lwordval>1[0], &$<v.u.lwordval>3[0] );

						_endcase


						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )

							$<v.u.boolval>$ = 
								IntGT( &$<v.u.lwordval>1[0], &$<v.u.lwordval>3[0] );

						_endcase




						_case( tReal32 )
							
							// Floats are equal only if all 32 bits are equal:
							
							$<v.u.boolval>$ = 
									$<v.u.fltval.f.f>1 > $<v.u.fltval.f.f>3; 
							


						_case( tReal64 )
							
							// Doubles are equal only if all 64 bits are equal:

							$<v.u.boolval>$ = 
									$<v.u.fltval.f.d>1 > $<v.u.fltval.f.d>3; 
							

						_case( tReal80 )

							$<v.u.boolval>$ = 
								fgt80( $<v.u.fltval>1, $<v.u.fltval>3 );

						_endcase


						_case( tString )
						_case( tZString )

							$<v.u.boolval>$ = 
								_strgt( $<v.u.strval>1, $<v.u.strval>3 );

						_endcase


						/*
						** One cset is greater than another if it is
						** a proper superset of the other.  This means
						** that their intersection will be equal to the
						** second operand but not the first.
						*/

						_case( tCset )
						{
							int IsEql = 1;
							int IsGE = 1;

							_for( int i=0, i < CSetSizeInBytes, ++i )

								IsEql &=
										$<v.u.csetval>1[i] 
									== 	$<v.u.csetval>3[i];

								IsGE &=
									( 
											$<v.u.csetval>1[i] 
										&	$<v.u.csetval>3[i] 
									)
									== $<v.u.csetval>3[i];

							_endfor
							$<v.u.boolval>$ =	IsGE && !IsEql;
						}
						_endcase






						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							( 
								YYS &$<v>$, 
								tBoolean, 
								&boolean_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

				_endif
				_here;
			};
	  
	  
	  
	  
	  


	  
/*
** Greater Than or Equal operator - See "=" operator for detailed comments.
*/

ConstExpr:	ConstExpr geTkn ConstExpr
			{
				_here;
				_if( MakeCompatible( &$<v>1, &$<v>3 ))

					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

					_switch( $<v.pType>1 )


						_case( tEnum )						

							$<v.u.boolval>$ = $<v.u.unsval>1 >= $<v.u.unsval>3;
							
						_endcase


						_case( tBoolean )
						_case( tChar )

							$<v.u.boolval>$ = $<v.u.charval>1 >= $<v.u.charval>3;
							
						_endcase

						_case( tUns8 )
						_case( tUns16 )
						_case( tUns32 )
						_case( tUns64 )
						_case( tUns128 )
						_case( tByte )
						_case( tWord )
						_case( tDWord )						
						_case( tQWord )						
						_case( tTByte )
						_case( tLWord )

							$<v.u.boolval>$ = 
								UnsGE( &$<v.u.lwordval>1[0], &$<v.u.lwordval>3[0] );

						_endcase


						_case( tInt8 )
						_case( tInt16 )
						_case( tInt32 )
						_case( tInt64 )
						_case( tInt128 )

							$<v.u.boolval>$ = 
								IntGE( &$<v.u.lwordval>1[0], &$<v.u.lwordval>3[0] );

						_endcase




						_case( tReal32 )
							
							// Floats are equal only if all 32 bits are equal:
							
							$<v.u.boolval>$ = 
									$<v.u.fltval.f.f>1 >= $<v.u.fltval.f.f>3; 
							


						_case( tReal64 )
							
							// Doubles are equal only if all 64 bits are equal:

							$<v.u.boolval>$ = 
									$<v.u.fltval.f.d>1 >= $<v.u.fltval.f.d>3; 
							

						_case( tReal80 )

							$<v.u.boolval>$ = 
								fge80( $<v.u.fltval>1, $<v.u.fltval>3 );

						_endcase


						_case( tString )
						_case( tZString )

							$<v.u.boolval>$ = 
								_strge( $<v.u.strval>1, $<v.u.strval>3 );

						_endcase


						/*
						** One cset is greater than or equal to another
						** if it is a superset of the other.  This occurs
						** when their intersection is equal to the second
						** set or both sets.
						*/

						_case( tCset )
						{
							int IsGE = 1;

							_for( int i=0, i < CSetSizeInBytes, ++i )

								IsGE &=
									( 
											$<v.u.csetval>1[i] 
										&	$<v.u.csetval>3[i] 
									)
									== $<v.u.csetval>3[i];

							_endfor
							$<v.u.boolval>$ =	IsGE;
						}
						_endcase



						_default
							
							yyerror( "Illegal operand types" );
							ClrConst
							( 
								YYS &$<v>$, 
								tBoolean, 
								&boolean_ste
							);

					_endswitch

				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

				_endif
				_here;
			};
	  
	  
	  


/*
** IN operator - Determines if a character is a member of a character set.
*/

	  
ConstExpr:	ConstExpr inTkn ConstExpr
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				_if( $<v.pType>1 == tChar && $<v.pType>3 == tCset )

					$<v.u.boolval>$ =
						( 
								$<v.u.csetval>3[ $<v.u.charval>1 / 8 ]
							&	( 1 << $<v.u.charval>1 % 8 )
						) != 0;
				_else

					yyerror( "Type mismatch in operands" );
					ClrConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste
					);

				_endif
				_here;

			};
		




	  
 /***************************************************************/
 /*                                                             */
 /* Handle the type converions functions here.                  */
 /* These functions include:                                    */
 /* boolean(), unsigned(), integer(), real(), char(), string(), */
 /* text(), and cset().                                         */
 /*                                                             */
 /*	See the FUNCS.C file for explanations of these functions.	*/
 /*																*/
 /***************************************************************/


 /*
 ** Handle the @byte..@lword, @uns8..@uns128, etc., tokens here
 */
	
	

ConstExpr:
		atToken		/* $1 */
		Lparen		/* $2 */
		ConstExpr	/* $3 */
		Rparen		/* $4 */
		{
			_here;
			memcpy( &$<v>$, &$<v>3, sizeofSymNode );
			$<v.pType>$ = $<v.pType>1;
			$<v.Type>$ = $<v.Type>1;
			
			// Zero fill to 128 bytes from the actual type unless
			// it's an INTxx type, in which case we need to sign extend
			// the value.
			
			_if( $<v.pType>1 >= tInt8 && $<v.pType>1 <= tInt128 )
			
				_if( $<v.pType>1 == tInt8 )
				
					_if( $<v.u.csetval>3[0] >= 0x80 )
					
						$<v.u.csetval>$[0] = $<v.u.csetval>3[0];
						$<v.u.csetval>$[1] = 0xff;
						$<v.u.csetval>$[2] = 0xff;
						$<v.u.csetval>$[3] = 0xff;
						$<v.u.lwordval>$[1] = 0xffffffff;
						$<v.u.lwordval>$[2] = 0xffffffff;
						$<v.u.lwordval>$[3] = 0xffffffff;
						
					_else
					
						$<v.u.csetval>$[0] = $<v.u.csetval>3[0];
						$<v.u.csetval>$[1] = 0;
						$<v.u.csetval>$[2] = 0;
						$<v.u.csetval>$[3] = 0;
						$<v.u.lwordval>$[1] = 0;
						$<v.u.lwordval>$[2] = 0;
						$<v.u.lwordval>$[3] = 0;
						
					_endif
				
				_elseif( $<v.pType>1 == tInt16 )
				
					_if( $<v.u.csetval>3[1] >= 0x80 )
					
						$<v.u.csetval>$[0] = $<v.u.csetval>3[0];
						$<v.u.csetval>$[1] = $<v.u.csetval>3[1];
						$<v.u.csetval>$[2] = 0xff;
						$<v.u.csetval>$[3] = 0xff;
						$<v.u.lwordval>$[1] = 0xffffffff;
						$<v.u.lwordval>$[2] = 0xffffffff;
						$<v.u.lwordval>$[3] = 0xffffffff;
						
					_else
					
						$<v.u.csetval>$[0] = $<v.u.csetval>3[0];
						$<v.u.csetval>$[1] = $<v.u.csetval>3[1];
						$<v.u.csetval>$[2] = 0;
						$<v.u.csetval>$[3] = 0;
						$<v.u.lwordval>$[1] = 0;
						$<v.u.lwordval>$[2] = 0;
						$<v.u.lwordval>$[3] = 0;
						
					_endif
				

				_elseif( $<v.pType>1 == tInt32 )
				
					_if( $<v.u.csetval>3[3] >= 0x80 )
					
						$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
						$<v.u.lwordval>$[1] = 0xffffffff;
						$<v.u.lwordval>$[2] = 0xffffffff;
						$<v.u.lwordval>$[3] = 0xffffffff;
						
					_else
					
						$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
						$<v.u.lwordval>$[1] = 0;
						$<v.u.lwordval>$[2] = 0;
						$<v.u.lwordval>$[3] = 0;
						
					_endif
				

				_elseif( $<v.pType>1 == tInt64 )
				
					_if( $<v.u.csetval>3[3] >= 0x80 )
					
						$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
						$<v.u.lwordval>$[1] = $<v.u.lwordval>3[1];
						$<v.u.lwordval>$[2] = 0xffffffff;
						$<v.u.lwordval>$[3] = 0xffffffff;
						
					_else
					
						$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
						$<v.u.lwordval>$[1] = $<v.u.lwordval>3[1];
						$<v.u.lwordval>$[2] = 0;
						$<v.u.lwordval>$[3] = 0;
						
					_endif
					
					
				_else

					$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
					$<v.u.lwordval>$[1] = $<v.u.lwordval>3[1];
					$<v.u.lwordval>$[2] = $<v.u.lwordval>3[2];
					$<v.u.lwordval>$[3] = $<v.u.lwordval>3[3];
						
				_endif
				

			_elseif( $<v.pType>1 == tPointer )
		
				char adrs[16];
				
				sprintf( adrs, "%u", $<v.u.lwordval>3[0] );
				$<v.u.strval>$ = hlastrdup2( adrs );
				$<v.u.lwordval>$[1] = 0;
				$<v.u.lwordval>$[2] = 0;
				$<v.u.lwordval>$[3] = 0;
					

			_else  // Not an Int object
			
				_switch( $<v.u.intval>1 )
				
					// Note: cases 1..4 fall through to case 8.
					
					_case( 1 )
					
						$<v.u.csetval>$[1] = 0;
						
					_case( 2 )
					
						$<v.u.csetval>$[2] = 0;
						$<v.u.csetval>$[3] = 0;
						
					_case( 4 )
					
						$<v.u.lwordval>$[1] = 0;
						
					_case( 8 )
					
						$<v.u.lwordval>$[2] = 0;
						$<v.u.lwordval>$[3] = 0;
						
					_endcase
					
					_case( 10 )
					
						$<v.u.csetval>$[8] = 0;
						$<v.u.csetval>$[9] = 0;
						$<v.u.lwordval>$[3] = 0;
						
				_endswitch
				
			_endif
			_here;		
		}
	;
	
ConstExpr:
		'('			/* $1 */
		typeTkn		/* $2 */
		TypeID		/* $3 */
		ConstExpr	/* $4 */
		Rparen		/* $5 */
		{
			enum PrimType pType;
			struct SymNode *s;
			
			_here;
			_if
			(
					(
							IsPrimitive( $<s>3->pType )
						&&	IsPrimitive( $<v.pType>4 )
						&&	$<s>3->ObjectSize == $<v.ObjectSize>4
						&&	$<v.ObjectSize>4 <= 16
					)
				
				||	IsCompatible( $<s>3, YYS &$<v>4 )
			)
			
				pType = $<s>3->pType;
				s = $<s>3;
				
				memcpy( &$<v>$, &$<v>4, sizeofSymNode );
				$<v.pType>$ = pType;
				$<v.Type>$ = s;
				
				// Zero fill to 128 bytes from the actual type unless
				// it's an INTxx type, in which case we need to sign extend
				// the value.
				
				_if( pType >= tInt8 && pType <= tInt128 )
				
					_if( pType == tInt8 )
					
						_if( $<v.u.csetval>3[0] >= 0x80 )
						
							$<v.u.csetval>$[0] = $<v.u.csetval>3[0];
							$<v.u.csetval>$[1] = 0xff;
							$<v.u.csetval>$[2] = 0xff;
							$<v.u.csetval>$[3] = 0xff;
							$<v.u.lwordval>$[1] = 0xffffffff;
							$<v.u.lwordval>$[2] = 0xffffffff;
							$<v.u.lwordval>$[3] = 0xffffffff;
							
						_else
						
							$<v.u.csetval>$[0] = $<v.u.csetval>3[0];
							$<v.u.csetval>$[1] = 0;
							$<v.u.csetval>$[2] = 0;
							$<v.u.csetval>$[3] = 0;
							$<v.u.lwordval>$[1] = 0;
							$<v.u.lwordval>$[2] = 0;
							$<v.u.lwordval>$[3] = 0;
							
						_endif
					
					_elseif( pType == tInt16 )
					
						_if( $<v.u.csetval>3[1] >= 0x80 )
						
							$<v.u.csetval>$[0] = $<v.u.csetval>3[0];
							$<v.u.csetval>$[1] = $<v.u.csetval>3[1];
							$<v.u.csetval>$[2] = 0xff;
							$<v.u.csetval>$[3] = 0xff;
							$<v.u.lwordval>$[1] = 0xffffffff;
							$<v.u.lwordval>$[2] = 0xffffffff;
							$<v.u.lwordval>$[3] = 0xffffffff;
							
						_else
						
							$<v.u.csetval>$[0] = $<v.u.csetval>3[0];
							$<v.u.csetval>$[1] = $<v.u.csetval>3[1];
							$<v.u.csetval>$[2] = 0;
							$<v.u.csetval>$[3] = 0;
							$<v.u.lwordval>$[1] = 0;
							$<v.u.lwordval>$[2] = 0;
							$<v.u.lwordval>$[3] = 0;
							
						_endif
					

					_elseif( pType == tInt32 )
					
						_if( $<v.u.csetval>3[3] >= 0x80 )
						
							$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
							$<v.u.lwordval>$[1] = 0xffffffff;
							$<v.u.lwordval>$[2] = 0xffffffff;
							$<v.u.lwordval>$[3] = 0xffffffff;
							
						_else
						
							$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
							$<v.u.lwordval>$[1] = 0;
							$<v.u.lwordval>$[2] = 0;
							$<v.u.lwordval>$[3] = 0;
							
						_endif
					

					_elseif( pType == tInt64 )
					
						_if( $<v.u.csetval>3[3] >= 0x80 )
						
							$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
							$<v.u.lwordval>$[1] = $<v.u.lwordval>3[1];
							$<v.u.lwordval>$[2] = 0xffffffff;
							$<v.u.lwordval>$[3] = 0xffffffff;
							
						_else
						
							$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
							$<v.u.lwordval>$[1] = $<v.u.lwordval>3[1];
							$<v.u.lwordval>$[2] = 0;
							$<v.u.lwordval>$[3] = 0;
							
						_endif
						
						
					_else

						$<v.u.lwordval>$[0] = $<v.u.lwordval>3[0];
						$<v.u.lwordval>$[1] = $<v.u.lwordval>3[1];
						$<v.u.lwordval>$[2] = $<v.u.lwordval>3[2];
						$<v.u.lwordval>$[3] = $<v.u.lwordval>3[3];
							
					_endif
					

				_elseif( pType == tPointer )
			
					char adrs[16];
					
					sprintf( adrs, "%u", $<v.u.lwordval>3[0] );
					$<v.u.strval>$ = hlastrdup2( adrs );
					$<v.u.lwordval>$[1] = 0;
					$<v.u.lwordval>$[2] = 0;
					$<v.u.lwordval>$[3] = 0;
						

				_else  // Not an Int object
				
					_switch( s->ObjectSize )
					
						// Note: cases 1..4 fall through to case 8.
						
						_case( 1 )
						
							$<v.u.csetval>$[1] = 0;
							
						_case( 2 )
						
							$<v.u.csetval>$[2] = 0;
							$<v.u.csetval>$[3] = 0;
							
						_case( 4 )
						
							$<v.u.lwordval>$[1] = 0;
							
						_case( 8 )
						
							$<v.u.lwordval>$[2] = 0;
							$<v.u.lwordval>$[3] = 0;
							
						_endcase
						
						_case( 10 )
						
							$<v.u.csetval>$[8] = 0;
							$<v.u.csetval>$[9] = 0;
							$<v.u.lwordval>$[3] = 0;
							
					_endswitch
					
				_endif
				
			_else
			
				yyerror( "Type conflict in type coercion operator" );
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				
			_endif
			_here;		
		}
	;

	

// Special case for @string because it needs to process TEXT constants
// and it needs to convert whatever bits appear in the variant data
// to a string of characters:
	
ConstExpr:
		atstringTkn	/* $1 */
		{			/* $2 */
		
			// Save the InAtString flag and then set it to one
			// so that the lexer won't expand text constants.
			
			_here;
			$<v.u.intval>$ = InAtString;
			InAtString = 1;
		}
		Lparen		/* $3 */
		ConstExpr	/* $4 */
		Rparen		/* $5 */
		{
			// ConstExpr better be a string value (note that TEXT
			// constants were already converted to string objects).
			
			_here;
			_if( $<v.pType>4 == tString || $<v.pType>4 == tZString )
			
				memcpy( &$<v>$, &$<v>4, sizeofSymNode );
				
			_elseif( $<v.pType>4 == tPointer || $<v.pType>4 == tProcptr )
			
				ClrConst( YYS &$<v>$, tString, &string_ste );
				$<v.u.strval>$ = $<v.u.strval>4;		
			

			_else
			
				// For all other types, create a string that
				// is the length of the data type and just copy
				// the bits to the string as though they were characters.
				// Note that the string might actually be smaller
				// than the data type's size since there may be
				// zero bits on the interior.
				
				char *theStr = malloc2( 17 ); // Max 16 chars!
				
				ClrConst( YYS &$<v>$, tString, &string_ste );
				$<v.u.strval>$ = theStr;
				memcpy( theStr, &$<v.u.lwordval>4[0], 16 );
				theStr[ 17 ] = '\0';  // Make sure it's zero terminated.
				
				
			_endif
			
	
			// Restore InAtString value:
			
			InAtString = $<v.u.intval>2;
			_here;	
		}
	;
		
		
ConstExpr:
		atwstringTkn
		Lparen		/* $3 */
		ConstExpr	/* $4 */
		Rparen		/* $5 */
		{
			yyerror( "HLA doesn't currently support the @wstring function" );
		}
	;
	
	
	
 /*
 ** Must handle @byte specially because it's overloaded:
 */
 
ConstFunc:	
		atbyteTkn		/* $1 */ 
		Lparen 			/* $2 */
		ConstOnlyExpr 	/* $3 */
		',' 			/* $4 */
		ConstOnlyExpr 	/* $5 */
		Rparen			/* $6 */
		{
			_here;
			SelByteFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5 
			);
		}
		
	|	atbyteTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		Rparen			/* $4 */
		{	
			_here;
			memcpy( &$<v>$, &$<v>3, sizeofSymNode );
			$<v.pType>$ = tByte;
			$<v.Type>$ = &byte_ste;
			$<v.u.bytes>$[0] = $<v.u.bytes>4[0];
			$<v.u.bytes>$[1] = 0;
			$<v.u.words>$[1] = 0;
			$<v.u.dwords>$[1] = 0;
			$<v.u.dwords>$[2] = 0;
			$<v.u.dwords>$[3] = 0;
			
		}
	;




	
	
	
atToken:
		atint8Tkn
		{
			_here;
			$<v.u.intval>$ = 1;
			$<v.pType>$ = tInt8;
			$<v.Type>$ = &int8_ste;
		}
		
	|	atint16Tkn
		{
			_here;
			$<v.u.intval>$ = 2;
			$<v.pType>$ = tInt16;
			$<v.Type>$ = &int16_ste;
		}
		
	|	atint32Tkn
		{
			_here;
			$<v.u.intval>$ = 4;
			$<v.pType>$ = tInt32;
			$<v.Type>$ = &int32_ste;
		}
		
	|	atint64Tkn
		{
			_here;
			$<v.u.intval>$ = 8;
			$<v.pType>$ = tInt64;
			$<v.Type>$ = &int64_ste;
		}
		
	|	atint128Tkn
		{
			_here;
			$<v.u.intval>$ = 16;
			$<v.pType>$ = tInt128;
			$<v.Type>$ = &int128_ste;
		}
		
	|	atcharTkn
		{
			_here;
			$<v.u.intval>$ = 1;
			$<v.pType>$ = tChar;
			$<v.Type>$ = &char_ste;
		}
		
	|	atwcharTkn
		{
			_here;
			$<v.u.intval>$ = 2;
			$<v.pType>$ = tWChar;
			$<v.Type>$ = &wchar_ste;
		}
		
	|	atreal32Tkn
		{
			_here;
			$<v.u.intval>$ = 4;
			$<v.pType>$ = tReal32;
			$<v.Type>$ = &real32_ste;
		}
		
	|	atreal64Tkn
		{
			_here;
			$<v.u.intval>$ = 8;
			$<v.pType>$ = tReal64;
			$<v.Type>$ = &real64_ste;
		}
		
	|	atreal80Tkn
		{
			_here;
			$<v.u.intval>$ = 10;
			$<v.pType>$ = tReal80;
			$<v.Type>$ = &real80_ste;
		}
		
	|	atuns8Tkn
		{
			_here;
			$<v.u.intval>$ = 1;
			$<v.pType>$ = tUns8;
			$<v.Type>$ = &uns8_ste;
		}
		
	|	atuns16Tkn
		{
			_here;
			$<v.u.intval>$ = 2;
			$<v.pType>$ = tUns16;
			$<v.Type>$ = &uns16_ste;
		}
		
	|	atuns32Tkn
		{
			_here;
			$<v.u.intval>$ = 4;
			$<v.pType>$ = tUns32;
			$<v.Type>$ = &uns32_ste;
		}
		
	|	atuns64Tkn
		{
			_here;
			$<v.u.intval>$ = 8;
			$<v.pType>$ = tUns64;
			$<v.Type>$ = &uns64_ste;
		}
		
	|	atuns128Tkn
		{
			_here;
			$<v.u.intval>$ = 16;
			$<v.pType>$ = tUns128;
			$<v.Type>$ = &uns128_ste;
		}
		
		
	|	atcsetTkn	
		{
			_here;
			$<v.u.intval>$ = 16;
			$<v.pType>$ = tCset;
			$<v.Type>$ = &cset_ste;
		}
		
	|	atwordTkn
		{
			_here;
			$<v.u.intval>$ = 2;
			$<v.pType>$ = tWord;
			$<v.Type>$ = &word_ste;
		}
		
	|	atdwordTkn
		{
			_here;
			$<v.u.intval>$ = 4;
			$<v.pType>$ = tDWord;
			$<v.Type>$ = &dword_ste;
		}
		
	|	atqwordTkn
		{
			_here;
			$<v.u.intval>$ = 8;
			$<v.pType>$ = tQWord;
			$<v.Type>$ = &qword_ste;
		}
		
	|	attbyteTkn
		{
			_here;
			$<v.u.intval>$ = 8;
			$<v.pType>$ = tTByte;
			$<v.Type>$ = &tbyte_ste;
		}
		
	|	atlwordTkn
		{
			_here;
			$<v.u.intval>$ = 16;
			$<v.pType>$ = tLWord;
			$<v.Type>$ = &lword_ste;
		}
		
	|	atpointerTkn
		{
			_here;
			$<v.u.intval>$ = 4;
			$<v.pType>$ = tPointer;
			$<v.Type>$ = &pointer_ste;  
		}
	;		
	
	

 /* 
 ** Handle the boolean(x) constant function here. 
 */


ConstExpr:	booleanTkn Lparen ConstOnlyExpr Rparen
			{	
				_here;
				BooleanFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			};


  /* 
  ** Handle the integer(x) constant function here. 
  */                
 
ConstExpr:	int8Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tInt8,
				&int8_ste 
			);
			_here;
		};                                                         
                                                                     
ConstExpr:	int16Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tInt16,
				&int16_ste 
			);
			_here;
		};                                                         
                                                                     
ConstExpr:	int32Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tInt32,
				&int32_ste 
			);
			_here;
		};                                                         
                                                                     
                                                                     
ConstExpr:	int64Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tInt64,
				&int64_ste 
			);
			_here;
		};                                                         
                                                                     
                                                                     
ConstExpr:	int128Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tInt128,
				&int128_ste 
			);
			_here;
		};                                                         
                                                                     
                                                                     
  /* 
  ** Handle the unsigned(x) constant function here. 
  */                
  
             
                                                    
ConstExpr:	uns8Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tUns8,
				&uns8_ste 
			);
			_here;
 		}
 	;
 			                                                         
ConstExpr:	uns16Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tUns16,
				&uns16_ste 
			);
			_here;
 		}
 	;
 			                                                         
ConstExpr:	uns32Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tUns32,
				&uns32_ste 
			);
			_here;
 		}
 	;
 			                                                         
ConstExpr:	uns64Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tUns64,
				&uns64_ste 
			);
			_here;
 		}
 	;
 			                                                         
ConstExpr:	uns128Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tUns128,
				&uns128_ste 
			);
			_here;
 		}
 	;
 			                                                         
                                                                     
 			                                                         
                                                                     
ConstExpr: byteTkn Lparen ConstOnlyExpr Rparen
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tByte,
				&byte_ste 
			);
			_here;
		}
	;

ConstExpr: wordTkn Lparen ConstOnlyExpr Rparen
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tWord,
				&word_ste 
			);
			_here;
		}
	;

ConstExpr: dwordTkn Lparen ConstOnlyExpr Rparen
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tDWord,
				&dword_ste 
			);
			_here;
		}
	;

ConstExpr: qwordTkn Lparen ConstOnlyExpr Rparen
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tQWord,
				&qword_ste 
			);
			_here;
		}
	;

ConstExpr: tbyteTkn Lparen ConstOnlyExpr Rparen
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tTByte,
				&tbyte_ste 
			);
			_here;
		}
	;

ConstExpr: lwordTkn Lparen ConstOnlyExpr Rparen
		{
			_here;
			IntegerFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tLWord,
				&lword_ste 
			);
			_here;
		}
	;



  /* 
  ** Handle the real(x) constant function here. 
  */                
          
                                                            
ConstExpr:	real32Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			RealFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tReal32,
				&real32_ste 
			);
			_here;
		};                                                         
                                                                 
                                                                     
ConstExpr:	real64Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			RealFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tReal64,
				&real64_ste 
			);
			_here;
		}
	;                                                         
                                                                     
                                                                     
ConstExpr:	real80Tkn Lparen ConstOnlyExpr Rparen                          
		{
			_here;
			RealFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3,
				tReal80,
				&real80_ste 
			);
			_here;
		}
	;                                                         
                                                                    
                                                                     
                                                                     
  /* Handle the char(x) constant function here. */                
                                                                     
 ConstExpr:	charTkn Lparen ConstOnlyExpr Rparen                          
 			{
				_here;
				CharFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
 			};                                                         
                                                                     
                                                                     
  /* 
  ** Handle the string(x) constant function here. 
  */                
                                                                     
 ConstExpr:	stringTkn 
 			Lparen 
			ConstOnlyExpr
			Rparen
 			{
				_here;
				StrFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
 			};                                                         
                                                                     
                                                                     
  /* 
  ** Handle the zstring(x) constant function here. 
  */                
                                                                     
 ConstExpr:	zstringTkn 
 			Lparen 
			ConstOnlyExpr
			Rparen
 			{
				_here;
				StrFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
 			};                                                         
                                                                     
                                                                     
  /* 
  ** Handle the cset(x) constant function here. 
  */                
                                                                     
 ConstExpr:	csetTkn Lparen ConstOnlyExpr Rparen                          
 			{
				_here;
				CsetFunc
				( 
					&$<v>$, 
					&$<v>3 
				);
				_here;
 			};                                                         
                                                                     


  /* 
  ** Handle the text(x) constant function here.
  **
  ** This code is sneaky.  It evaluates the string expression and
  ** insert the specified text into the input stream.  Then this
  ** production has a second ConstExpr non-terminal that will eat
  ** the text inserted by the text() function.
  **
  ** This production seems to want to match "text(somestring))" rather
  ** than the standard "text(somestring)" form.  The last parenthesis
  ** is synthesized by this code (via the call to PushBackStr) in
  ** order to separate the two ConstExpr non-terminals and a possible
  ** operator that could follow the second ConstExpr below.  This
  ** is a sneaky way to avoid about 15 shift/reduce conflicts.
  */ 
       
                                                                     
 ConstExpr:	textTkn Lparen ConstOnlyExpr Rparen  
 			{
 				_here;
				
 				/*
 				** Okay, push a ")" character back on the input so
 				** we can match it when we're done with the text
 				** expansion.
 				*/
 				            
 				PushBackStr( ")" );
 				
 				/*
 				** There had better be only a string expression
 				** present.  If there is, push it back onto the
 				** input stream (in reverse order) so the ConstExpr
 				** non-terminal following this semantic action can
 				** pick up the text data.  Note that the size of the
 				** input string is limited to the maximum number of
 				** push-back characters that Flex allows (set to
 				** 32kbytes for this compile).
 				*/
 				                                                 
 				_if( $<v.pType>3 == tString || $<v.pType>3 == tZString )
 				
					/*
					** Note that "InsertText" will free the
					** data passed to it.
					*/

 					PushBackStr( $<v.u.strval>3 );
                                                                     
 				_else                                                  
 				                                                       
 					yyerror                                            
 					(                                                  
 						"'text' only allows string operands"                           
 					);
					PushBackStr( "0" );
                                                                     
 				_endif
				_here;

			/*
			** Okay, process the text we just pushed back onto the
			** input stream and then match that ")" we pushed
			** earlier.
			*/
                                                                     
 			}
 			ConstExpr Rparen 
 			{
				/*
				** Return the value of the computed ConstExpr above
				** as the value of the text(string) function.
				*/

				_here;
				memcpy( &$<v>$, &$<v>6, sizeofSymNode );

 			};
 			                                                         
                                                                     
                                                                  
 /*
 ** Handle the @read function here
 */															  
     
	 
ConstFunc:	readTkn 	/* $1 */
			Lparen 		/* $2 */
			DefinedID	/* $3 */
			Rparen		/* $4 */
			{
				_here;
				_if( readHandle == NULL )
				
					// If the read file is not open,
					// just return EOF (false):
					
					SetConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste, 
						YYS &false_ste
					);
					
				_elseif( $<s>3->SymClass != cValue )
				
					/*
					** If it's not a value object, print an error
					** and return EOF.
					*/
					
					yyerror( "@read function requires a VAL operand" );
					SetConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste, 
						YYS &false_ste
					);
					
				
				_else
				
					// Okay, read a string from the
					// input file and store in the value object.
					
					char inputline[4096];
					char *result;
					int	 len;
					
					result = fgets( inputline, 4095, readHandle );
					_if( result == NULL )
					
						// We've hit EOF, so just return false:
						
						SetConst
						( 
							YYS &$<v>$, 
							tBoolean, 
							&boolean_ste, 
							YYS &false_ste
						);
						
					_else
					
						union YYSTYPE v;
						int len;
					
						// We're not at EOF, so return true and
						// copy the string data to the variable:
						
						SetConst
						( 
							YYS &$<v>$, 
							tBoolean, 
							&boolean_ste, 
							YYS &true_ste
						);
						
						len = strlen( inputline );
						_while( len > 0 )
						
							--len;
							_if( inputline[ len ] == 0xa )
							
								inputline [ len ] = 0;
								
							_elseif( inputline[ len ] == 0xd )
							
								inputline [ len ] = 0;
								
							_else
							
								break;
								
							_endif
							
						_endwhile

						v.v.u.strval = hlastrdup2( inputline );
						SetSym
						( 
							$<s>3, 
							&string_ste,
							tString, 
							0,
							NULL,
							0, 
							YYS &v,
							4,
							0,
							NULL,
							NULL,
							NULL,
							0,
							NULL,
							0 
						);
						
					_endif
				
				_endif
				_here;
			}
		;


ConstFunc:	readTkn 	/* $1 */
			Lparen 		/* $2 */
			UndefID		/* $3 */
			Rparen		/* $4 */
			{
				_here;
				_if( readHandle == NULL )
				
					// If the read file is not open,
					// just return EOF (false):
					
					SetConst
					( 
						YYS &$<v>$, 
						tBoolean, 
						&boolean_ste, 
						YYS &false_ste
					);
					
				_else
				
					// Okay, read a string from the
					// input file and store in the value object.
					
					char inputline[4096];
					char *result;
					
					result = fgets( inputline, 4095, readHandle );
					_if( result == NULL )
					
						// We've hit EOF, so just return false:
						
						SetConst
						( 
							YYS &$<v>$, 
							tBoolean, 
							&boolean_ste, 
							YYS &false_ste
						);
						
					_else
					
						union YYSTYPE v;
						int len;
					
						// We're not at EOF, so return true and
						// copy the string data to the variable:
						
						SetConst
						( 
							YYS &$<v>$, 
							tBoolean, 
							&boolean_ste, 
							YYS &true_ste
						);

						len = strlen( inputline );
						_while( len > 0 )
						
							--len;
							_if( inputline[ len ] == 0xa )
							
								inputline [ len ] = 0;
								
							_elseif( inputline[ len ] == 0xd )
							
								inputline [ len ] = 0;
								
							_else
							
								break;
								
							_endif
							
						_endwhile
						
						v.v.u.strval = hlastrdup2( inputline );
						InsertSym
						( 
							$<idStr>3, 
							&string_ste,
							tString, 
							cValue, 
							0,
							NULL,
							0, 
							YYS &v,
							4,
							0,
							NULL,
							NULL,
							NULL,
							0 
						);
						
						
					_endif
				
				_endif
				_here;
			}
		;






	                                                                 




 /*************************************************/
 /*                                               */
 /* Handle the built-in assembler functions here. */
 /*                                               */
 /*************************************************/


/*
**	@abs(x), @byte(u,u), @ceil(x), @cos(x), @date, @exp(x),
**	@extract(cs), @floor(x), @isalpha(ch),
**	@isalphanum(ch), @isdigit(ch), @islower(ch), @isspace(ch),
**	@isupper(ch), @isxdigit(ch), @log(x), @log10(x),
**	@max(x,y,...), @min(x,y,...),
**	@odd(u), @random(x), @randomize(x), @sin(x), @sqrt(x),
**	@tan(x), @time 
*/

ConstExpr:
		ConstFunc
		{
			_here;
			memcpy( &$<v>$, &$<v>1, sizeofSymNode );
		}
	;



ConstFunc:	absTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				AbsFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	absTkn Lparen error Rparen
			{

				yyerror( "Error in @ABS function [abs(number)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
			}
		;





ConstFunc:	ceilTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				CeilFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	ceilTkn Lparen error Rparen
			{

				yyerror( "Error in @ceil function [@ceil(f)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
			}
		;




				
ConstFunc:	cosTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				CosFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	cosTkn Lparen error Rparen
			{

				yyerror( "Error in @cos function [@cos(f)]" );
				ClrConst
				( 
					YYS &$<v>$, 
					tReal80, 
					&real80_ste
				);

			}
		;





ConstFunc:	dateTkn
			{
				_here;
				DateFunc( YYS &$<v>$ );
				_here;
			}
		;



ConstFunc:	envTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				EnvFunc( YYS &$<v>$, YYS &$<v>3 );
				_here;
			}
		;


ConstFunc:	expTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				ExpFunc( YYS &$<v>$, YYS &$<v>3 );
				_here;
			}
		;

ConstFunc:	expTkn Lparen error Rparen
			{
				yyerror( "Error in @exp function [@exp(f)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tReal80, 
					&real80_ste
				);

			}
		;





ConstFunc:	extractTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				ExtractFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	extractTkn Lparen error Rparen
			{
				yyerror( "Error in @extract function [@extract(cs)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tChar, 
					&char_ste
				);

			}
		;





ConstFunc:	floorTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				FloorFunc( YYS &$<v>$, YYS &$<v>3 );
				_here;
			}
		;

ConstFunc:	floorTkn Lparen error Rparen
			{

				yyerror( "Error in @floor function [@floor(f)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);

			}
		;







ConstFunc:	isalphaTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				IsAlphaFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	isalphaTkn Lparen error Rparen
			{
				yyerror( "Error in @isalpha function [@isalpha(i)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);

			}
		;





ConstFunc:	isalphanumTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				IsAlnumFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	isalphanumTkn Lparen error Rparen
			{
				yyerror( "Error in @isalphanum function [@isalphanum(i)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);

			}
		;





ConstFunc:	isdigitTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				IsDigitFunc
				(
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	isdigitTkn Lparen error Rparen
			{
				yyerror( "Error in @isdigit function [@isdigit(i)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);

			}
		;





ConstFunc:	islowerTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				IsLowerFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	islowerTkn Lparen error Rparen
			{
				yyerror( "Error in @islower function [@islower(i)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);

			}
		;
								



ConstFunc:	isspaceTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				IsSpaceFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	isspaceTkn Lparen error Rparen
			{
				yyerror( "Error in @isspace function [@isspace(i)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);

			}
		;





ConstFunc:	isupperTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				IsUpperFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	isupperTkn Lparen error Rparen
			{
				yyerror( "Error in @isupper function [@isupper(i)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);

			}
		;






ConstFunc:	isxdigitTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				IsXdigitFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	isxdigitTkn Lparen error Rparen
			{
				yyerror( "Error in @isxdigit function [@isxdigit(i)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);

			}
		;





					 

ConstFunc:	logTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				LogFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	logTkn Lparen error Rparen
			{
				yyerror( "Error in @log function [@log(f)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tReal80, 
					&real80_ste
				);

			}
		;







ConstFunc:	log10Tkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				Log10Func
				( 
					YYS &$<v>$, 
					YYS &$<v>3 

				);
				_here;
			}
		;

ConstFunc:	log10Tkn Lparen error Rparen
			{
				yyerror( "Error in @log10 function [@log10(f)]" );

				ClrConst

				( 
					YYS &$<v>$, 
					tReal80, 
					&real80_ste
				);

			}
		;





ConstFunc:	maxTkn Lparen MaxConstList Rparen
			{
				_here;
				SetConst
				( 
					YYS &$<v>$, 
					$<v.pType>3, 
					$<v.Type>3,
					YYS &$<v>3
				);
				_here;
			}
		;

ConstFunc:	maxTkn Lparen error Rparen
			{
				yyerror( "Error in @max function [@max(list)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tReal80, 
					&real80_ste
				);

			}
		;




MaxConstList:	ConstOnlyExpr
				{
					_here;
					SetConst
					( 
						YYS &$<v>$, 
						$<v.pType>1, 
						$<v.Type>1,
						YYS &$<v>1
					);
					_here;
				}


		|		MaxConstList ',' ConstOnlyExpr
				{

					_here;
					_if
					( 
						MakeCompatible
						( 
							&$<v>1, 
							&$<v>3 
						)
					)


						SetConst
						( 
							YYS &$<v>$, 
							$<v.pType>3, 
							$<v.Type>3,
							YYS &$<v>3
						);
						_switch( $<v.pType>1 )

							_case( tBoolean )
							_case( tEnum  )
							_case( tByte  )
							_case( tWord  )
							_case( tDWord )
							_case( tUns8  )
							_case( tUns16 )
							_case( tUns32 )
							_case( tUns64 )
							_case( tUns128 )
							_case( tQWord )
							_case( tTByte )
							_case( tLWord )
							
								bigmaxUns
								(
									&$<v.u.lwordval>$[0], 
									&$<v.u.lwordval>1[0], 
									&$<v.u.lwordval>3[0] 
								);
								
							_endcase


							_case( tInt8  )
							_case( tInt16 )
							_case( tInt32 )
							_case( tInt64 )
							_case( tInt128 )

								bigmaxInt
								(
									&$<v.u.lwordval>$[0], 
									&$<v.u.lwordval>1[0], 
									&$<v.u.lwordval>3[0] 
								);
								
							_endcase


							_case( tChar )

								$<v.u.charval>$ = 
									max
									( 
										$<v.u.charval>1, 
										$<v.u.charval>3 
									);

							_endcase


							_case( tReal32 )
							
								_if
								( 
									$<v.u.fltval.f.f>1 > $<v.u.fltval.f.f>3 
								)
								
									$<v.u.fltval>$ = $<v.u.fltval>1;
								
								_else
								
									$<v.u.fltval>$ = $<v.u.fltval>3;
								
								_endif
								
							_endcase
								
								 
							_case( tReal64 )
							
								_if
								( 
									$<v.u.fltval.f.d>1 > $<v.u.fltval.f.d>3 
								)
								
									$<v.u.fltval>$ = $<v.u.fltval>1;
								
								_else
								
									$<v.u.fltval>$ = $<v.u.fltval>3;
								
								_endif
								
							_endcase
								
								 
							_case( tReal80 )

								fmax80
								( 
									&$<v.u.fltval>$,
									$<v.u.fltval>1, 
									$<v.u.fltval>3 
								);

							_endcase

							_case( tString )
							_case( tZString )

								_if
								( 
									_strge
									( 
										$<v.u.strval>1, 
										$<v.u.strval>3 
									)
								) 

									$<v.u.strval>$ = $<v.u.strval>1;
									free2( vss $<v.u.strval>3 );

								_else

									$<v.u.strval>$ = $<v.u.strval>3;
									free2( vss $<v.u.strval>1 );

								_endif

							_endcase

							_default

								yyerror
								( 
									"Max doesn't allow that operand type"
								);
								ClrConst
								( 
									YYS &$<v>$, 
									tUns32, 
									&uns32_ste
								);


						_endswitch

					_else

						yyerror( "Type mismatch in operands" );
						ClrConst
						( 
							YYS &$<v>$, 
							tUns32, 
							&uns32_ste
						);


					_endif
					_here;
				}
		;






ConstFunc:	minTkn Lparen MinConstList Rparen
			{
				_here;
				SetConst
				( 
					YYS &$<v>$, 
					$<v.pType>3, 
					$<v.Type>3,
					YYS &$<v>3
				);
				_here;
			}
		;

ConstFunc:	minTkn Lparen error Rparen
			{

				yyerror( "Error in @min function [@min(list)]" );

				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tUns32, 
					&uns32_ste
				);
				_here;

			}
		;






MinConstList:	ConstOnlyExpr
				{
					_here;
					SetConst
					( 
						YYS &$<v>$, 
						$<v.pType>1, 
						$<v.Type>1,
						YYS &$<v>1
					);
					_here;
				}

		|		MinConstList ',' ConstOnlyExpr
				{
					_here;
					_if( MakeCompatible( &$<v>1, &$<v>3 ))


						SetConst
						( 
							YYS &$<v>$, 
							$<v.pType>3, 
							$<v.Type>3,
							YYS &$<v>3
						);
						_switch( $<v.pType>1 )

							_case( tBoolean )
							_case( tEnum  )
							_case( tChar  )
							_case( tWChar )
							_case( tByte  )
							_case( tWord  )
							_case( tDWord )
							_case( tQWord )
							_case( tTByte )
							_case( tLWord )
							_case( tUns8  )
							_case( tUns16 )
							_case( tUns32 )
							_case( tUns64 )
							_case( tUns128 )

								bigminUns
								( 
									&$<v.u.lwordval>$[0],
									&$<v.u.lwordval>1[0],
									&$<v.u.lwordval>3[0]
								);

							_endcase


							_case( tInt8  )
							_case( tInt16 )
							_case( tInt32 )
							_case( tInt64 )
							_case( tInt128 )

								bigminInt
								( 
									&$<v.u.lwordval>$[0],
									&$<v.u.lwordval>1[0],
									&$<v.u.lwordval>3[0]
								);

							_endcase


							_case( tReal32 )  
							
								_if
								( 
									$<v.u.fltval.f.f>1 < $<v.u.fltval.f.f>3 
								)
								
									$<v.u.fltval>$ = $<v.u.fltval>1;
								
								_else
								
									$<v.u.fltval>$ = $<v.u.fltval>3;
								
								_endif
								
							_endcase


							_case( tReal64 )
							
								_if
								( 
									$<v.u.fltval.f.d>1 < $<v.u.fltval.f.d>3 
								)
								
									$<v.u.fltval>$ = $<v.u.fltval>1;
								
								_else
								
									$<v.u.fltval>$ = $<v.u.fltval>3;
								
								_endif
								
							_endcase


							_case( tReal80 )

								fmin80
								(
									&$<v.u.fltval>$,
									$<v.u.fltval>1,
									$<v.u.fltval>3
								);
								

							_endcase

							_case( tString )
							_case( tZString )

								_if
								( 
									_strle
									( 
										$<v.u.strval>1, 
										$<v.u.strval>3 
									)
								) 

									$<v.u.strval>$ = $<v.u.strval>1;
									free2( vss $<v.u.strval>3 );

								_else

									$<v.u.strval>$ = $<v.u.strval>3;
									free2( vss $<v.u.strval>1 );

								_endif

							_endcase

							_default

								yyerror
								( 
									"Min doesn't allow that operand type"
								);
								ClrConst
								( 
									YYS &$<v>$, 
									tUns32, 
									&uns32_ste
								);


						_endswitch

					_else

						yyerror( "Type mismatch in operands" );
						ClrConst
						( 
							YYS &$<v>$, 
							tUns32, 
							&uns32_ste
						);

					_endif
					_here;
				}
		;






ConstFunc:	oddTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				OddFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	oddTkn Lparen error Rparen
			{

				yyerror( "Error in @odd function [@odd(i)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);

			}
		;




                                                                     

ConstFunc:	
		randomTkn 
		Lparen 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			RandFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3 
			);
			_here;

		}
	;

ConstFunc:	
		randomTkn 
		Lparen 
		error 
		Rparen
		{
			yyerror( "Error in @random function [@random(i)]" );

			ClrConst
			( 
				YYS &$<v>$, 
				tInt32, 
				&int32_ste
			);
		}
	;





ConstFunc:	
		randomizeTkn 
		Lparen 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			RandomizeFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3 
			);
			_here;
		}
	;

ConstFunc:	
		randomizeTkn 
		Lparen 
		error 
		Rparen
		{
			yyerror( "Error in @randomize function [@randomize(i)]" );

			ClrConst
			( 
				YYS &$<v>$, 
				tInt32, 
				&int32_ste
			);

		}
	;





ConstFunc:	
		sinTkn 
		Lparen 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			SinFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3 
			);
			_here;
		}
	;



ConstFunc:	
		sinTkn 
		Lparen 
		error 
		Rparen
		{
			yyerror( "Error in @sin function [@sin(f)]" );

			ClrConst
			( 
				YYS &$<v>$, 
				tReal80, 
				&real80_ste
			);
		}
	;




// Handle the @sort function here:

ConstFunc:	
		sortTkn				/* $1 */ 
		Lparen 				/* $2 */
		ConstOnlyExpr		/* $3 -- Array to sort							*/
		comma				/* $4 */
		ConstOnlyExpr		/* $5 -- # of elements to sort 					*/
		comma				/* $6 */
		Classify			/* $7 -- Val object for left compare operand	*/
		comma				/* $8 */
		Classify			/* $9 -- Val object for right compare operand	*/
		comma				/* $10 */
		ConstOnlyExpr		/* $11 -- macro name (as string)				*/
		Rparen
		{
			_here;
			_if( $<v.pType>3 != tArray )
				
				yyerror( "Expected an array as the first @sort parameter\n" );
				
			_elseif( !IsSmallNumber( $<v.pType>5 ))
			
				yyerror
				( 
					"Expected a small array element count value as the second\n"
					"@sort parameter.\n"
				);
				
			_elseif( $<v.u.unsval>5 > $<v.NumElements>3 )
			
				yyerror
				(
					"Second parameter of @sort is greater than the number of\n"
					"elements in the array specified by parameter #1 (or the\n"
					"value is negative).\n"
				);
				
			_elseif( $<cls.sym>7 == NULL || $<cls.sym>9 == NULL )
			
				yyerror
				(
					"The third and fourth parameters of @sort must be the\n"
					"names of VAL objects declared in your source file.\n"
				);
				
			_elseif
			( 
					$<cls.sym>7->SymClass != cValue 
				||	$<cls.sym>9->SymClass != cValue 
			)
			
				yyerror
				(
					"The third and fourth parameters of @sort must be the\n"
					"names of VAL objects declared in your source file.\n"
				);
				
			_elseif( $<v.pType>11 != tString && $<v.pType>11 != tZString )
			
				yyerror
				(
					"The fifth parameter of @sort must be a string holding\n"
					"the name of a macro that will compare the values in the\n"
					"VAL objects specified by the third and fourth \n"
					"parameters.\n"
				);
				
			_else
				
				SortArray
				( 
					YYS &$<v>3,
					0, 
					$<v.u.unsval>5-1, 
					$<cls.sym>7, 
					$<cls.sym>9,
					$<v.u.strval>11
				);
			
			_endif
			$<v>$ = $<v>3;				// Return result array (hopefully sorted)
			FreeValue( YYS &$<v>5 );	// In case there was an error.
			FreeValue( YYS &$<v>11 );	// Free up macro name string.
			_here;
		}
	;

				
					 

ConstFunc:	
		sqrtTkn 
		Lparen 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			SqrtFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3 
			);
			_here;
		}
	;

ConstFunc:	
		sqrtTkn 
		Lparen 
		error 
		Rparen
		{
			yyerror( "Error in @sqrt function [@sqrt(f)]" );

			ClrConst
			( 
				YYS &$<v>$, 
				tReal80, 
				&real80_ste
			);

		}
	;






// Handle @system( "pgm", "cmdline") here:

ConstFunc:	systemTkn Lparen ConstOnlyExpr Rparen
			{
				_here;
				SystemFunc( YYS &$<v>$, YYS &$<v>3 );
				_here;
			}
		;



					 

ConstFunc:	
		tanTkn 
		Lparen 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			TanFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3 
			);
			_here;
		}
	;

ConstFunc:	
		tanTkn 
		Lparen 
		error 
		Rparen
		{
			yyerror( "Error in @tan function [@tan(f)]" );

			ClrConst
			( 
				YYS &$<v>$, 
				tReal80, 
				&real80_ste
			);
		}
	;





				
ConstFunc:	
		timeTkn
		{
			_here;
			TimeFunc( YYS &$<v>$ );
			_here;
		}
	;



ConstFunc:	
		threadTkn
		{
			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			v.v.u.unsval = threadSafe;
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v
			);
			_here;
		}
	;







/****************************************************/
/*                                                  */
/* String Functions:                                */
/*                                                  */
/* string:		@delete( str, StartPos, Length )    */
/* int32:		@index( srcStr, startPos, subStr )  */
/* string:		@insert( str, StartPos, subStr )    */
/* int32:		@length( str )                      */
/* string: 		@lowercase( str, startPos )         */
/* int32:		@rindex( srcStr, subStr, startPos ) */
/* int32:		@strbrk( srcStr, startPos, cset )   */
/* string:		@strset( char, len );               */
/* int32:		@strspan( string, startPos, cset )  */
/* string:		@substr( string, startPos, length ) */
/* string[n]:	@tokenize( string, startPos, cset ) */
/* string:		@trim( string, startPos )           */
/* string:		@uppercase( string, startPos );     */
/* 	                                                */
/****************************************************/




ConstFunc:	deleteTkn 		/* $1 */
			Lparen 			/* $2 */
			ConstOnlyExpr 	/* $3 */
			comma 			/* $4 */
			ConstOnlyExpr 	/* $5 */
			comma 			/* $6 */
			ConstOnlyExpr 	/* $7 */
			Rparen			/* $8 */
			{				/* $9 */

				_here;
				DeleteFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3, 
					YYS &$<v>5, 
					YYS &$<v>7 
				);
				_here;
			}
		;

ConstFunc:	deleteTkn Lparen error Rparen
			{
				union	YYSTYPE value;

				yyerror( "Error in DELETE function [delete(s,i,i)]" );

				value.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &value
				);
			}
		;







ConstFunc:	
		indexTkn 
		Lparen 
		ConstOnlyExpr 
		comma 
		ConstOnlyExpr 
		comma 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			IndexFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>7, 
				YYS &$<v>5 
			);
			_here;
		}
	;

ConstFunc:	indexTkn Lparen error Rparen
			{
				yyerror( "Error in INDEX function [index(s,i,s)]" );

				/*
				** Return -1 to indicate that we did not find the string
				*/

				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);

			}
		;




ConstFunc:	insertTkn		/* $1 */
			Lparen			/* $2 */
			ConstOnlyExpr	/* $3 */
			comma			/* $4 */
			ConstOnlyExpr	/* $5 */
			comma			/* $6 */
			ConstOnlyExpr	/* $7 */
			Rparen			/* $8 */
			{
				_here;
				InsertFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3, 
					YYS &$<v>5, 
					YYS &$<v>7 
				);
				_here;
			}
		;


ConstFunc:	insertTkn Lparen error Rparen
			{
				union	YYSTYPE value;

				yyerror( "Error in INSERT function [insert(s,i,s)]" );

				value.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &value
				);
			}
		;






ConstFunc:	lengthTkn Lparen ConstOnlyExpr  Rparen
			{
				_here;
				LengthFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3 
				);
				_here;
			}
		;

ConstFunc:	lengthTkn Lparen error Rparen
			{

				yyerror( "Error in LENGTH function [length(s)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);

			}
		;




ConstFunc:	lowercaseTkn Lparen ConstOnlyExpr comma ConstOnlyExpr Rparen
			{
				_here;
				LowerFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3, 
					YYS &$<v>5 
				);
				_here;
			}
		;



ConstFunc:	lowercaseTkn Lparen error Rparen
			{
				union	YYSTYPE value;

				yyerror( "Error in LOWERCASE function [lowercase(s,i)]" );

				value.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &value
				);
			}
		;







ConstFunc:	
		rindexTkn 
		Lparen 
		ConstOnlyExpr 
		comma 
		ConstOnlyExpr 
		comma 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			RIndexFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>7, 
				YYS &$<v>5 
			);
			_here;
		}
	;

ConstFunc:	rindexTkn Lparen error Rparen
			{

				yyerror( "Error in RINDEX function [rindex(s,i,s)]" );

				/*
				** Return -1 to indicate that we did not find the string
				*/

				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);

			}
		;





ConstFunc:	strbrkTkn 		/* $1 								*/
			Lparen 			/* $2 								*/
			ConstOnlyExpr 	/* $3 = string to scan 				*/
			comma 			/* $4 								*/
			ConstOnlyExpr 	/* $5 = starting position for scan	*/
			comma 			/* $6 								*/
			ConstOnlyExpr 	/* $7 = char set to find			*/
			Rparen			/* $8								*/
			{				/* $9								*/

				_here;
				strbrkFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3, 
					YYS &$<v>5, 
					YYS &$<v>7 
				);
				_here;
			}
	;

ConstFunc:	strbrkTkn Lparen error Rparen
			{
				yyerror( "Error in STRBRK function [strbrk(s,i,cs)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);

			}
		;












ConstFunc:	strsetTkn 		/* $1 								*/
			Lparen 			/* $2 								*/
			ConstOnlyExpr 	/* $3 = character to replicate		*/
			comma 			/* $4 								*/
			ConstOnlyExpr 	/* $5 = # of characters in string	*/
			Rparen			/* $6								*/
			{				/* $7								*/
				_here;
				strsetFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3, 
					YYS &$<v>5 
				);
				_here;
			}
	;

ConstFunc:	strsetTkn Lparen error Rparen
			{
				union	YYSTYPE	value;

				yyerror( "Error in STRSET function [strset(c,i)]" );

				value.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &value
				);

			}
		;










ConstFunc:	strspanTkn 		/* $1 								*/
			Lparen 			/* $2 								*/
			ConstOnlyExpr 	/* $3 = string to scan 				*/
			comma 			/* $4 								*/
			ConstOnlyExpr 	/* $5 = starting position for scan	*/
			',' 			/* $6 								*/
			ConstOnlyExpr 	/* $7 = char set to find			*/
			Rparen			/* $8								*/
			{				/* $9								*/

				_here;
				strspanFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3, 
					YYS &$<v>5, 
					YYS &$<v>7 
				);
				_here;
			}
	;

ConstFunc:	strspanTkn Lparen error Rparen
			{
				yyerror( "Error in STRSPAN function [strspan(s,i,cs)]" );

				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);

			}
		;










ConstFunc:	
		substrTkn 
		Lparen 
		ConstOnlyExpr 
		comma 
		ConstOnlyExpr 
		comma 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			SubstrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7 
			);
			_here;
		}
	;


ConstFunc:	substrTkn Lparen error Rparen
			{
				union	YYSTYPE value;

				yyerror( "Error in SUBSTR function [substr(s,i,i)]" );

				value.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &value
				);
			}
		;






ConstFunc:	tokenizeTkn 	/* $1 							*/
			Lparen 			/* $2 							*/
			ConstOnlyExpr 	/* $3	- string to tokenize	*/
			comma 			/* $4							*/
			ConstOnlyExpr 	/* $5	- Starting posn in str.	*/
			comma			/* $6							*/
			ConstOnlyExpr	/* $7	- Delimiters.			*/
			comma			/* $8							*/
			ConstOnlyExpr	/* $9	- Active Quote chars.	*/
			Rparen			/* $10							*/
			{				/* $11							*/

				_here;
				TokenizeFunc
				( 
					YYS &$<v>$, 
					YYS &$<v>3, 
					YYS &$<v>5, 
					YYS &$<v>7, 
					YYS &$<v>9 
				);
				_here;
			}
		;


ConstFunc:	tokenizeTkn Lparen error Rparen
			{
				union	YYSTYPE value;

				yyerror
				( 
					"Error in @TOKENIZE function [tokenize(s,i,cs,cs)]" 
				);

				/*
				** Create a dummy array of strings with a single
				** element containing an empty string.
				*/

				$<v.pType>$ = tArray;
				$<v.Type>$ = &string_ste;
				$<v.SymClass>$ = cConstant;
				$<v.ObjectSize>$ = 4;
				$<v.StaticName>$ = NULL;
				$<v.LexLevel>$ = 1;
				$<v.IsExternal>$ = 0;
				$<v.IsReferenced>$ = NULL;
				$<v.Arity>$ = 1;
				$<v.NumElements>$ = 1;
				$<v.Dimensions>$ = malloc2( sizeof( int ));
				*$<v.Dimensions>$ = 1;
				$<v.Fields>$ = NULL;
				$<v.Base>$ = NULL;
				$<v.FieldCnt>$ = 0;
				$<v.u.ArrayOfValues>$ = malloc2( sizeof( struct SymNode ));
				
				value.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS $<v.u.ArrayOfValues>$, 
					tString, 
					&string_ste,
					YYS &value
				);


			}
		;








ConstFunc:	
		trimTkn 
		Lparen 
		ConstOnlyExpr 
		comma 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			TrimFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5 
			);
			_here;
		}
	;


ConstFunc:	trimTkn Lparen error Rparen
			{
				union	YYSTYPE value;

				yyerror( "Error in @TRIM function [trim(s,i)]" );

				value.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &value
				);
			}
		;









ConstFunc:	
		uppercaseTkn 
		Lparen 
		ConstOnlyExpr 
		comma 
		ConstOnlyExpr 
		Rparen
		{
			_here;
			UpperFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5 
			);
			_here;
		}
	;


ConstFunc:	uppercaseTkn Lparen error Rparen
			{
				union	YYSTYPE value;

				yyerror( "Error in @UPPERCASE function [uppercase(s,i)]" );

				value.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &value
				);
			}
		;





 /***************************************************/
 /*                                                 */
 /* Pattern matching functions are dealt with here. */
 /*                                                 */
 /***************************************************/


 /*
 ** peekCset-
 **
 **	This function checks to see if the first character
 ** of a string is a member of the specified character set.
 ** It does not remove the character from the string it
 ** passes through to the $7 parameter.
 **
 ** Note that without the destination (DefinedID) parameter,
 ** this function is identical to oneCset.
 */


ConstFunc:	
		peekcsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			peekCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	peekcsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			peekCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	peekcsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = Extraction str		*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			peekCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** oneCset-
 **
 **	This function checks to see if the first character of
 ** the string is a member of the specified character set.
 ** If the $7 parameter is present, this code copies the
 ** string, minus the first character, into the strvar
 ** specified by the $7 parameter.
 **
 ** The matched characters are copied into the $9 parameter,
 ** if present.
 */

ConstFunc:	
		onecsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			oneCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	onecsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			oneCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	onecsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = place to store str 	*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			oneCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** uptoCset-
 **
 **	This function scans through the characters in the string
 ** passed as the second parameter until it finds a character
 ** that is a member of the cset passed as the third parameter.
 ** This function returns false if no such character exists
 ** in the string; it returns true if it finds the string.
 ** If the $7 parameter is present, this code copies the
 ** string, minus the matched characters, into the strvar
 ** specified by the $7 parameter.  Note that the characters
 ** deleted includes the one character found in the cset.
 ** If this routine returns false, it copies the whole string
 ** into the $7 parameter.
 **
 ** If the $9 parameter is specified, this code copies the
 ** matched string into that variable.
 */

ConstFunc:	
		uptocsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			uptoCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	uptocsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			uptoCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	uptocsetTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = cset to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = place to store rslt	*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			uptoCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;



 /*
 ** zeroOrOneCset-
 **
 **	This function attempts to match zero or more characters
 ** in a string from a character set.  It always returns true.
 ** If the $7 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $7 parameter.
 **
 ** If the $9 parameter is present, store the matched string
 ** into the specified variable.
 */

ConstFunc:	
		zerooronecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			zeroOrOneCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	zerooronecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			zeroOrOneCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	zerooronecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			zeroOrOneCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** zeroOrMoreCset-
 **
 **	This function attempts to match zero or more characters
 ** in a string from a character set.  It returns true.
 ** If the $7 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $7 parameter.
 **
 ** If the $9 parameter is present, this code copies
 ** the matched string to the $9 variable.
 */

ConstFunc:	
		zeroormorecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			zeroOrMoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	zeroormorecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			zeroOrMoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	zeroormorecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store rslt	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			zeroOrMoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** oneOrMoreCset-
 **
 **	This function attempts to match one or more characters
 ** in a string from a character set.  It returns true if it matches
 ** at least one character from the set.
 ** If the $7 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $7 parameter.
 **
 ** If the $9 parameter is present, this code copies
 ** the matched string to the $9 variable.
 */

ConstFunc:	
		oneormorecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			oneOrMoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	oneormorecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			oneOrMoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	oneormorecsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			oneOrMoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;





 /*
 ** exactlynCset-
 **
 **	This function attempts to match exactly n characters
 ** in a string from a character set.  It returns true if it matches
 ** n characters from the set and the n+1th char is not in the set.
 **
 ** If the $9 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $9 parameter.
 **
 ** If the $11 parameter is present, this code copies
 ** the matched string to the $9 variable.
 */

ConstFunc:	
		exactlyncsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			exactlynCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	exactlyncsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			exactlynCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	exactlyncsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store rslt	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			exactlynCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;




 /*
 ** firstnCset-
 **
 **	This function attempts to match n characters
 ** in a string from a character set.  It returns true if it matches
 ** n characters from the set, even if the n+1th char is not in the set.
 **
 ** If the $9 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $9 parameter.
 **
 ** If the $11 parameter is present, this code copies
 ** the matched string to the $9 variable.
 */

ConstFunc:	
		firstncsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			firstnCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	firstncsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			firstnCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	firstncsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store rslt	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			firstnCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;




 /*
 ** norlessCset-
 **
 **	This function attempts to match 0..n characters
 ** in a string from a character set.  It returns true if it matches
 ** less than or equal to n characters from the set.
 ** If it matches n characters, the n+1th character must
 ** not be in the character set.
 **
 ** If the $9 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $9 parameter.
 **
 ** If the $11 parameter is present, this code copies
 ** the matched string to the $9 variable.
 */

ConstFunc:	
		norlesscsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			norlessCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	norlesscsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			norlessCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	norlesscsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store rslt	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			norlessCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;




 /*
 ** normoreCset-
 **
 **	This function attempts to match n+ characters
 ** in a string from a character set.  It returns true if it matches
 ** greater than or equal to n characters from the set.
 **
 ** If the $9 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $9 parameter.
 **
 ** If the $11 parameter is present, this code copies
 ** the matched string to the $11 variable.
 */

ConstFunc:	
		normorecsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			normoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	normorecsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			normoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	normorecsetTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store rslt	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			normoreCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;




 /*
 ** ntomCset-
 **
 **	This function attempts to match between n & m characters
 ** in a string from a character set.  It returns true if it matches
 ** greater than or equal to n characters from the set.  It will
 ** match all the way to the mth character if characters n..m
 ** are all in the set.  The m+1th character may or may not be in
 ** the set.
 **
 ** If the $11 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $11 parameter.
 **
 ** If the $13 parameter is present, this code copies
 ** the matched string to the $13 variable.
 */

ConstFunc:	
		ntomcsetTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			ntomCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	ntomcsetTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			ntomCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11, 
				NULL 
			);
			_here;
		}

	|	ntomcsetTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		','					/* $12						*/
		DefinedID			/* $13= place to store rslt	*/
		Rparen				/* $14						*/
		{					/* $15						*/
			_here;
			ntomCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11, 
				$<s>13 
			);
			_here;
		}
	;




 /*
 ** exactlyntomCset-
 **
 **	This function attempts to match between n & m characters
 ** in a string from a character set.  It returns true if it matches
 ** greater than or equal to n characters from the set.  It will
 ** match all the way to the mth character if characters n..m
 ** are all in the set.  The m+1th character may or may not be in
 ** the set.
 **
 ** If the $11 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $11 parameter.
 **
 ** If the $13 parameter is present, this code copies
 ** the matched string to the $13 variable.
 */

ConstFunc:	
		exactlyntomcsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			exactlyntomCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				NULL,
				NULL 
			);
			_here;
		}


	|	exactlyntomcsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			exactlyntomCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				NULL 
			);
			_here;
		}

	|	exactlyntomcsetTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		','					/* $12						*/
		DefinedID			/* $13= place to store str 	*/
		Rparen				/* $14						*/
		{					/* $15						*/
			_here;
			exactlyntomCsetFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				$<s>13 
			);
			_here;
		}
	;





 /************* character matching functions ****************/


 /*
 ** peekChar-
 **
 **	This function checks to see if the first character
 ** of a string is a member of the specified character set.
 ** It does not remove the character from the string it
 ** passes through to the $7 parameter.
 **
 ** If the $9 parameter is present, this code stores the
 ** matched string into that parameter.
 **
 ** Note that without the destination (DefinedID) parameter,
 ** this function is identical to oneChar.
 */

ConstFunc:	
		peekcharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			peekCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	peekcharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			peekCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	peekcharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = place to store rslt	*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			peekCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** peekiChar-
 **
 **	Case insensitive version of the above.
 */

ConstFunc:	
		peekicharTkn	/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			peekiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	peekicharTkn	/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			peekiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	peekicharTkn	/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = place to store rslt	*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			peekiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;







 /*
 ** oneChar-
 **
 **	This function checks to see if the first character
 ** of a string is a member of the specified character set.
 ** It does not remove the character from the string it
 ** passes through to the $5 parameter.
 **
 ** If the $7 parameter is present, this code stores the
 ** matched string into that parameter.
 **
 ** Note that without the destination (DefinedID) parameter,
 ** this function is identical to peekChar.
 */

ConstFunc:	
		onecharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			oneCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5,
				NULL, 
				NULL 
			);
			_here;
		}

	|	onecharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			oneCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	onecharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = place to store rslt	*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			oneCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** oneiChar-
 **
 **	Case insensitive version of the above.
 */

ConstFunc:	
		oneicharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			oneiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	oneicharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			oneiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	oneicharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = place to store rslt	*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			oneiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;





 /*
 ** uptoChar-
 **
 **	This function scans through the string searching for
 ** the character specified by the $5 parameter. If it finds
 ** the character, it matches everything up to that point.
 ** If the $5 character is not in the string, this routine
 ** returns false.
 **
 ** If the $7 parameter is present, this code returns all
 ** characters following the matched string (including
 ** the matched char) in the string.
 **
 ** If the $9 parameter is present, this code returns the
 ** matched string in that string (the matched string does
 ** not include the matched char).
 **
 */

ConstFunc:	
		uptocharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			uptoCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	uptocharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			uptoCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	uptocharTkn		/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = place to store rslt	*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			uptoCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** uptoiChar-
 **
 **	Case insensitive version of the above.
 */

ConstFunc:	
		uptoicharTkn	/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		Rparen			/* $6						*/
		{				/* $7						*/
			_here;
			uptoiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	uptoicharTkn	/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		Rparen			/* $8						*/
		{				/* $9						*/
			_here;
			uptoiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	uptoicharTkn	/* $1 						*/
		Lparen 			/* $2 						*/
		ConstOnlyExpr 	/* $3 = string to scan 		*/
		comma 			/* $4 						*/
		ConstOnlyExpr 	/* $5 = char to match		*/
		','				/* $6						*/
		DefinedID		/* $7 = place to store str 	*/
		','				/* $8						*/
		DefinedID		/* $9 = place to store rslt	*/
		Rparen			/* $10						*/
		{				/* $11						*/
			_here;
			uptoiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;





 /*
 ** zerooroneChar-
 **
 **	This function optionally matches a character at the beginning of
 ** the string.  If the character is not the first character of
 ** the string, this function still returns true.  If the DefinedID
 ** string parameter is present, this returns the remaining characters
 ** in the string minus the matched character (if any).
 **
 ** If the $9 parameter is present, the matched char (or empty string
 ** if no match) is returned in that parameter.
 **
 */

ConstFunc:	
		zerooronecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			zerooroneCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	zerooronecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			zerooroneCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	zerooronecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store rslt	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			zerooroneCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** zerooroneiChar-
 **
 **	Case insensitive version of the above.
 */

ConstFunc:	
		zerooroneicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			zerooroneiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	zerooroneicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			zerooroneiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	zerooroneicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/

			_here;
			zerooroneiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;





 /*
 ** zeroormoreChar-
 **
 **	This function optionally matches zero or more copies of
 ** a single character at the beginning of the string.
 ** If the character is not the first character of the string,
 ** this function still returns true.  If the DefinedID
 ** string parameter is present, this returns the remaining 
 ** characters in the string minus the matched characters (if any).
 **
 */

ConstFunc:	
		zeroormorecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			zeroormoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	zeroormorecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			zeroormoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	zeroormorecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store rslt	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			zeroormoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** zeroormoreiChar-
 **
 **	Case insensitive version of the above.
 */

ConstFunc:	
		zeroormoreicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			zeroormoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	zeroormoreicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			zeroormoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	zeroormoreicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store rslt	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			zeroormoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;





 /*
 ** oneormoreChar-
 **
 **	This function optionally matches zero or more copies of
 ** a single character at the beginning of the string.
 ** If the character is not the first character of the string,
 ** this function still returns true.  If the DefinedID
 ** string parameter is present, this returns the remaining 
 ** characters in the string minus the matched characters (if any).
 **
 ** If the $9 parameter is present, return the matched string
 ** in this parameter.
 */

ConstFunc:	
		oneormorecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			oneormoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	oneormorecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			oneormoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	oneormorecharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			oneormoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;


 /*
 ** oneormoreiChar-
 **
 **	Case insensitive version of the above.
 */

ConstFunc:	
		oneormoreicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			oneormoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	oneormoreicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			oneormoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				NULL 
			);
			_here;
		}

	|	oneormoreicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = char to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store rslt	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			oneormoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7, 
				$<s>9 
			);
			_here;
		}
	;




 /*
 ** exactlynChar-
 **
 **	This function attempts to match exactly n characters
 ** in a string against a single character.  It returns true if 
 ** it matches n characters and the n+1th char is not in the set.
 **
 ** If the $9 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $9 parameter.
 **
 ** If the $11 parameter is present, this code copies the matched
 ** string to that object.
 */

ConstFunc:	
		exactlyncharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			exactlynCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	exactlyncharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			exactlynCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	exactlyncharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			exactlynCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
		}
	;


 /*
 ** exactlynichar- Case insensitive version of the above.
 */

ConstFunc:	
		exactlynicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			exactlyniCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	exactlynicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $6						*/
		DefinedID			/* $8 = place to store str 	*/
		Rparen				/* $9						*/
		{					/* $10						*/
			_here;
			exactlyniCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	exactlynicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			exactlyniCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;




 /*
 ** firstnChar-
 **
 **	This function attempts to match exactly n characters
 ** in a string against a single character.  It returns true if 
 ** it matches n characters, even if the n+1th char is in the set.
 **
 ** If the $9 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $9 parameter.
 **
 ** If the $11 parameter is present, this code copies the matched
 ** string to that object.
 */

ConstFunc:	
		firstncharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			firstnCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	firstncharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			firstnCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	firstncharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			firstnCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;


 /*
 ** firstnichar- Case insensitive version of the above.
 */

ConstFunc:	
		firstnicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			firstniCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	firstnicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			firstniCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	firstnicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			firstniCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;




 /*
 ** norlessnChar-
 **
 **	This function attempts to match between zero and n characters
 ** in a string against a single character.  It returns true if 
 ** it matches up to n characters, even if the n+1th char is in the set.
 **
 ** If the $9 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $9 parameter.
 **
 ** If the $11 parameter is present, this code copies the matched
 ** text to the specified string variable.
 */

ConstFunc:	
		norlesscharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			norlessCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	norlesscharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			norlessCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	norlesscharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		','					/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store rslt	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			norlessCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;


 /*
 ** norlessnichar- Case insensitive version of the above.
 */

ConstFunc:	
		norlessicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			norlessiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	norlessicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			norlessiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	norlessicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store rslt */
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			norlessiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;




 /*
 ** normoreChar-
 **
 **	This function attempts to match exactly n characters
 ** in a string against a single character.  It returns true if 
 ** it matches n characters, even if the n+1th char is in the set.
 **
 ** If the $9 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $9 parameter.
 **
 ** If the $11 parameter is present, this code stores the matched
 ** string into that object.
 */

ConstFunc:	
		normorecharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			normoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	normorecharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			normoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	normorecharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			normoreCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;


 /*
 ** nomoreichar- Case insensitive version of the above.
 */

ConstFunc:	
		normoreicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			normoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	normoreicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			normoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				NULL 
			);
			_here;
		}

	|	normoreicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			normoreiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				$<s>9, 
				$<s>11 
			);
			_here;
		}
	;



 /*
 ** ntomChar-
 **
 **	This function attempts to match between n & m characters
 ** in a string against a given character.  It returns true if 
 ** it matches greater than or equal to n characters.  It will
 ** match all the way to the mth character if characters n..m
 ** are all equal to the character.  The m+1th character may or 
 ** may not be equal to the character compared against.
 **
 ** If the $11 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $11 parameter.
 **
 ** If the $13 parameter is present, this code copies the
 ** matched string to that object.
 */

ConstFunc:	
		ntomcharTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			ntomCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	ntomcharTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			ntomCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
			    YYS &$<v>9, 
				$<s>11,
				NULL
			);
			_here;
		}

	|	ntomcharTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		','					/* $12						*/
		DefinedID			/* $13= place to store rslt	*/
		Rparen				/* $14						*/
		{					/* $15						*/
			_here;
			ntomCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				$<s>13
			);
			_here;
		}
	;


 /*
 ** ntomiChar- Case insensitive version of the above.
 */

ConstFunc:	
		ntomicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			ntomiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				NULL, 
				NULL 
			);
			_here;
		}

	|	ntomicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			ntomiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				NULL
			);
			_here;
		}

	|	ntomicharTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		','					/* $12						*/
		DefinedID			/* $13= place to store rslt	*/
		Rparen				/* $14						*/
		{					/* $15						*/
			_here;
			ntomiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				$<s>13
			);
			_here;
		}
	;



 /*
 ** exactlyntomChar-
 **
 **	This function attempts to match between n & m characters
 ** in a string against a given character.  It returns true if 
 ** it matches greater than or equal to n characters.  It will
 ** match all the way to the mth character if characters n..m
 ** are all equal to the character.  The m+1th character must 
 ** not be equal to the character compared against.
 **
 ** If the $11 parameter is present, this code copies the
 ** string, minus any matched characters, into the strvar
 ** specified by the $11 parameter.
 **
 ** If the $13 parameter is present, this code copies the
 ** matched string to that object.
 */

ConstFunc:	
		exactlyntomcharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = m					*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			exactlyntomCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				NULL,
				NULL 
			);
			_here;
		}

	|	exactlyntomcharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = n					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			exactlyntomCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				NULL 
			);
			_here;
		}

	|	exactlyntomcharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = m					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		','					/* $12						*/
		DefinedID			/* $13= place to store rslt	*/
		Rparen				/* $14						*/
		{					/* $15						*/
			_here;
			exactlyntomCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				$<s>13 
			);
			_here;
		}
	;


 /*
 ** exactlyntomiChar- Case insensitive version of the above.
 */

ConstFunc:	
		exactlyntomicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = m					*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			exactlyntomiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				NULL,
				NULL 
			);
			_here;
		}

	|	exactlyntomicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = m					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
			_here;
			exactlyntomiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				NULL 
			);
			_here;
		}

	|	exactlyntomicharTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma				/* $4 						*/
		ConstOnlyExpr 		/* $5 = cset to match		*/
		comma				/* $6						*/
		ConstOnlyExpr		/* $7 = n					*/
		comma				/* $8						*/
		ConstOnlyExpr		/* $9 = m					*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		','					/* $12						*/
		DefinedID			/* $13= place to store str 	*/
		Rparen				/* $14						*/
		{					/* $15						*/
			_here;
			exactlyntomiCharFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				YYS &$<v>7, 
				YYS &$<v>9, 
				$<s>11,
				$<s>13 
			);
			_here;
		}
	;


/*******************************************************/
/* 	                                                   */
/* Handle the regular expression match operations here.*/
/* @match( str, regex )                                */
/* @match2( str, regex )                               */
/*                                                     */
/*******************************************************/

ConstFunc:	
		matchTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		regexconst	 		/* $5 = regular expression	*/
		Rparen				/* $6						*/
		{					/* $8						*/

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/
			
			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// Only allow a string operand:
			
			_if( $<v.pType>3 != tString )
			
				yyerror
				( 
					"Type mismatch, @match requires a string operand "
					"as the first operand"
				);
				
			_else
			
				$<v.u.boolval>$ = 
					matchRegex
					( 
						$<v.u.strval>3, 
						$<v.u.rx>5,
						NULL,
						NULL,
						NULL 
					) != NULL;
			
			_endif
			FreeValue( YYS &$<v>3 );
			//FreeValue( YYS &$<v>5 );
			_here;
		}
	
	
	|	matchTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		regexconst	 		/* $5 = regular expression	*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
		
			int 			result = 0;
			union	YYSTYPE	value;
			
			// Note: DefinedID, for better or for worse, returns
			// a pointer to the "true" symbol table entry if there
			// was an undefined symbol error. This creates some problems
			// in the following code, which the following macro fixes
			
			#define dID(x) (_ifx( (x)==&true_ste, NULL, (x)))

			_here;
			// Only allow a string operand:
			
			_if( $<v.pType>3 != tString )
			
				yyerror
				( 
					"Type mismatch, @match requires a string operand "
					"as the first operand"
				);
				
			_else
			
				result = 
					matchRegex
					( 
						$<v.u.strval>3, 
						$<v.u.rx>5,
						NULL,
						NULL,
						dID( $<s>7 ) 
					) != NULL;
			
			_endif
			_if( result )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			
			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);
			$<v.u.boolval>$ = result;
			FreeValue( YYS &$<v>3 );
			//FreeValue( YYS &$<v>5 );
			_here;
		}
	
	
	|	matchTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		regexconst	 		/* $5 = regular expression	*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9= place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
		
			int 			result = 0;
			union	YYSTYPE	value;

			_here;
			
			// Only allow a string operand:
			
			_if( $<v.pType>3 != tString )
			
				yyerror
				( 
					"Type mismatch, @match requires a string operand "
					"as the first operand"
				);
				
			_else
			
				result = 
					matchRegex
					( 
						$<v.u.strval>3, 
						$<v.u.rx>5,
						dID( $<s>9 ),
						NULL,
						dID( $<s>7 ) 
					) != NULL;
			
			_endif
			_if( result )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			
			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);
			$<v.u.boolval>$ = result;
			FreeValue( YYS &$<v>3 );
			//FreeValue( YYS &$<v>5 );
			_here;
		}
	
	
	|	matchTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		regexconst	 		/* $5 = regular expression	*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9= place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
		
			int 			result = 0;
			union	YYSTYPE	value;			
				
			_here;
			
			// Only allow a string operand:
			
			_if( $<v.pType>3 != tString )
			
				yyerror
				( 
					"Type mismatch, @match requires a string operand "
					"as the first operand"
				);
				
			_else
			
				result = 
					matchRegex
					( 
						$<v.u.strval>3, 
						$<v.u.rx>5,
						dID( $<s>9 ),
						dID( $<s>11 ),
						dID( $<s>7 ) 
					) != NULL;
			
			_endif
			_if( result )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						//FreeValue( &value );
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			
			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);
			$<v.u.boolval>$ = result;
			FreeValue( YYS &$<v>3 );
			//FreeValue( YYS &$<v>5 );
			_here;
		}	
	;






ConstFunc:	
		match2Tkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		regexconst	 		/* $5 = regular expression	*/
		Rparen				/* $6						*/
		{					/* $8						*/

			_here;
			
			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// Only allow a string operand:
			
			_if( $<v.pType>3 != tString )
			
				yyerror
				( 
					"Type mismatch, @match requires a string operand "
					"as the first operand"
				);
				
			_else
			
				$<v.u.boolval>$ = 
					matchRegex2
					( 
						$<v.u.strval>3, 
						$<v.u.rx>5,
						NULL,
						NULL,
						NULL 
					) != NULL;
			
			_endif
			FreeValue( YYS &$<v>3 );
			//FreeValue( YYS &$<v>5 );
			_here;
		}
	
	
	|	match2Tkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		regexconst	 		/* $5 = regular expression	*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
		
			int 			result = 0;
			union	YYSTYPE	value;

			_here;
			
			// Only allow a string operand:
			
			_if( $<v.pType>3 != tString )
			
				yyerror
				( 
					"Type mismatch, @match requires a string operand "
					"as the first operand"
				);
				
			_else
			
				result = 
					matchRegex2
					( 
						$<v.u.strval>3, 
						$<v.u.rx>5,
						NULL,
						NULL,
						dID( $<s>7 ) 
					) != NULL;
			
			_endif
			_if( result )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			
			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);
			$<v.u.boolval>$ = result;
			FreeValue( YYS &$<v>3 );
			//FreeValue( YYS &$<v>5 );
			_here;
		}
	
	
	|	match2Tkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		regexconst	 		/* $5 = regular expression	*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9= place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
		
			int 			result = 0;
			union	YYSTYPE	value;

			_here;
			
			// Only allow a string operand:
			
			_if( $<v.pType>3 != tString )
			
				yyerror
				( 
					"Type mismatch, @match requires a string operand "
					"as the first operand"
				);
				
			_else
			
				result = 
					matchRegex2
					( 
						$<v.u.strval>3, 
						$<v.u.rx>5,
						dID( $<s>9 ),
						NULL,
						dID( $<s>7 ) 
					) != NULL;
			
			_endif
			_if( result )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			
			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);
			$<v.u.boolval>$ = result;
			FreeValue( YYS &$<v>3 );
			//FreeValue( YYS &$<v>5 );
			_here;
		}
	
	
	|	match2Tkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		regexconst	 		/* $5 = regular expression	*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9= place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/
		
			int 			result = 0;
			union	YYSTYPE	value;

			_here;
			
			// Only allow a string operand:
			
			_if( $<v.pType>3 != tString )
			
				yyerror
				( 
					"Type mismatch, @match requires a string operand "
					"as the first operand"
				);
				
			_else
			
				result = 
					matchRegex2
					( 
						$<v.u.strval>3, 
						$<v.u.rx>5,
						dID( $<s>9 ),
						dID( $<s>11 ),
						dID( $<s>7 ) 
					) != NULL;
			
			_endif
			_if( result )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			
			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);
			$<v.u.boolval>$ = result;
			FreeValue( YYS &$<v>3 );
			//FreeValue( YYS &$<v>5 );
			
			_here;
		}	
	;







	


LocalOrNonLocalID:
		LocalConstID
		{
			_here;
			$<s>$ = $<s>1;
		}
		
	|	NonLocalConstID
		{
			_here;
			$<s>$ = $<s>1;
		}
	;	


// Handle a compiled regular expression here:

ConstFunc:	
		matchTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		LocalOrNonLocalID	/* $5 = RE Identifier		*/
		Rparen				/* $6						*/
		{					/* $8						*/

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// The LocalOrNonLocalID above had better be a regular expression
			// identifier or this is an error.
			
			_if( $<s>5->pType != tRegex )
			
				yyerror
				( 
					"@match requires a regular expression as the second operand" 
				);
				
			_else
				

				// Only allow a string operand:
				
				_if( $<v.pType>3 != tString )
				
					yyerror
					( 
						"Type mismatch, @match requires a string operand "
						"as the first operand"
					);
					
				_else
				
					$<v.u.boolval>$ = 
						matchRegex
						( 
							$<v.u.strval>3, 
							$<s>5->u.rx,
							NULL,
							NULL,
							NULL 
						) != NULL;
				
				_endif
				
			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}

	|	matchTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		LocalOrNonLocalID	/* $5 = RE Identifier		*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		Rparen				/* $8						*/
		{					/* $10						*/

			union	YYSTYPE	value;

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// The LocalOrNonLocalID above had better be a regular expression
			// identifier or this is an error.
			
			_if( $<s>5->pType != tRegex )
			
				yyerror
				( 
					"@match requires a regular expression as the second operand" 
				);
				
			_else
				

				// Only allow a string operand:
				
				_if( $<v.pType>3 != tString )
				
					yyerror
					( 
						"Type mismatch, @match requires a string operand "
						"as the first operand"
					);
					
				_else
				
					$<v.u.boolval>$ = 
						matchRegex
						( 
							$<v.u.strval>3, 
							$<s>5->u.rx,
							NULL,
							NULL, 
							dID( $<s>7 )
						) != NULL;
				
				_endif
				
			_endif
			_if( $<v.u.boolval>$ )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}

	|	matchTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		LocalOrNonLocalID	/* $5 = RE Identifier		*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9= place to store str 	*/
		Rparen				/* $10						*/
		{					/* $12						*/

			union	YYSTYPE	value;

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// The LocalOrNonLocalID above had better be a regular expression
			// identifier or this is an error.
			
			_if( $<s>5->pType != tRegex )
			
				yyerror
				( 
					"@match requires a regular expression as the second operand" 
				);
				
			_else
				

				// Only allow a string operand:
				
				_if( $<v.pType>3 != tString )
				
					yyerror
					( 
						"Type mismatch, @match requires a string operand "
						"as the first operand"
					);
					
				_else
				
					$<v.u.boolval>$ = 
						matchRegex
						( 
							$<v.u.strval>3, 
							$<s>5->u.rx,
							dID( $<s>9 ),
							NULL,
							dID( $<s>7 ) 
						) != NULL;
				
				_endif
				
			_endif
			_if( $<v.u.boolval>$ )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}

	|	matchTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		LocalOrNonLocalID	/* $5 = RE Identifier		*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9= place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/

			union	YYSTYPE	value;

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// The LocalOrNonLocalID above had better be a regular expression
			// identifier or this is an error.
			
			_if( $<s>5->pType != tRegex )
			
				yyerror
				( 
					"@match requires a regular expression as the second operand" 
				);
				
			_else
				

				// Only allow a string operand:
				
				_if( $<v.pType>3 != tString )
				
					yyerror
					( 
						"Type mismatch, @match requires a string operand "
						"as the first operand"
					);
					
				_else
				
					$<v.u.boolval>$ = 
						matchRegex
						( 
							$<v.u.strval>3, 
							$<s>5->u.rx,
							dID( $<s>9 ),
							dID( $<s>11 ),
							dID( $<s>7 ) 
						) != NULL;
				
				_endif
				
			_endif
			_if( $<v.u.boolval>$ )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;




ConstFunc:	
		match2Tkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		LocalOrNonLocalID	/* $5 = RE Identifier		*/
		Rparen				/* $6						*/
		{					/* $8						*/

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// The LocalOrNonLocalID above had better be a regular expression
			// identifier or this is an error.
			
			_if( $<s>5->pType != tRegex )
			
				yyerror
				( 
					"@match requires a regular expression as the second operand" 
				);
				
			_else
				

				// Only allow a string operand:
				
				_if( $<v.pType>3 != tString )
				
					yyerror
					( 
						"Type mismatch, @match requires a string operand "
						"as the first operand"
					);
					
				_else
				
					$<v.u.boolval>$ = 
						matchRegex2
						( 
							$<v.u.strval>3, 
							$<s>5->u.rx,
							NULL,
							NULL,
							NULL 
						) != NULL;
				
				_endif
				
			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}

	|	match2Tkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		LocalOrNonLocalID	/* $5 = RE Identifier		*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		Rparen				/* $8						*/
		{					/* $10						*/

			union	YYSTYPE	value;

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// The LocalOrNonLocalID above had better be a regular expression
			// identifier or this is an error.
			
			_if( $<s>5->pType != tRegex )
			
				yyerror
				( 
					"@match requires a regular expression as the second operand" 
				);
				
			_else
				

				// Only allow a string operand:
				
				_if( $<v.pType>3 != tString )
				
					yyerror
					( 
						"Type mismatch, @match requires a string operand "
						"as the first operand"
					);
					
				_else
				
					$<v.u.boolval>$ = 
						matchRegex2
						( 
							$<v.u.strval>3, 
							$<s>5->u.rx,
							NULL,
							NULL, 
							dID( $<s>7 )
						) != NULL;
				
				_endif
				
			_endif
			_if( $<v.u.boolval>$ )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}

	|	match2Tkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		LocalOrNonLocalID	/* $5 = RE Identifier		*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9= place to store str 	*/
		Rparen				/* $10						*/
		{					/* $12						*/

			union	YYSTYPE	value;

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// The LocalOrNonLocalID above had better be a regular expression
			// identifier or this is an error.
			
			_if( $<s>5->pType != tRegex )
			
				yyerror
				( 
					"@match requires a regular expression as the second operand" 
				);
				
			_else
				

				// Only allow a string operand:
				
				_if( $<v.pType>3 != tString )
				
					yyerror
					( 
						"Type mismatch, @match requires a string operand "
						"as the first operand"
					);
					
				_else
				
					$<v.u.boolval>$ = 
						matchRegex2
						( 
							$<v.u.strval>3, 
							$<s>5->u.rx,
							dID( $<s>9 ),
							NULL,
							dID( $<s>7 ) 
						) != NULL;
				
				_endif
				
			_endif
			_if( $<v.u.boolval>$ )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}

	|	match2Tkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		LocalOrNonLocalID	/* $5 = RE Identifier		*/
		','					/* $6						*/
		DefinedID			/* $7= place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9= place to store str 	*/
		','					/* $10						*/
		DefinedID			/* $11= place to store str 	*/
		Rparen				/* $12						*/
		{					/* $13						*/

			union	YYSTYPE	value;

			/*
			** Initialize the fields of the return result.
			** Type is always boolean, default to false...
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);

			// The LocalOrNonLocalID above had better be a regular expression
			// identifier or this is an error.
			
			_if( $<s>5->pType != tRegex )
			
				yyerror
				( 
					"@match requires a regular expression as the second operand" 
				);
				
			_else
				

				// Only allow a string operand:
				
				_if( $<v.pType>3 != tString )
				
					yyerror
					( 
						"Type mismatch, @match requires a string operand "
						"as the first operand"
					);
					
				_else
				
					$<v.u.boolval>$ = 
						matchRegex2
						( 
							$<v.u.strval>3, 
							$<s>5->u.rx,
							dID( $<s>9 ),
							dID( $<s>11 ),
							dID( $<s>7 ) 
						) != NULL;
				
				_endif
				
			_endif
			_if( $<v.u.boolval>$ )
			
				_if
				(		
						(
								$<s>7->pType == tString 
							||	$<s>7->pType == tText
						)
					&&	$<s>7->u.strval != NULL 
				)
				
					
					parseExpression( $<s>7->u.strval, &value );
					_if( value.v.pType != tString )
					
						yyerror
						( 
							"Expected a string result for 'returns' operand" 
						);
						FreeValue( &value );
						value.v.pType =tString;
						value.v.Type = &string_ste;
						value.v.u.strval = hlastrdup( "" );
						
					_endif
								
					
				_endif

				_if( $<s>7->u.strval != NULL )
				
					free2( vss $<s>7->u.strval );
					
				_endif
				$<s>7->u.strval = value.v.u.strval;
				
			_endif
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



 /*****************************************************************************/
 
 
 
 /*
 ** matchstr-  Matches the first group of characters in
 ** the $3 parameter against the string in the $5 parameter.
 **
 ** On match, returns chars after matched string in $7 and returns
 ** matched chars in $9.
 */


ConstFunc:	
		matchstrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchstrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				NULL 
			);
			_here;
		}

	|	matchstrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store rslt	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			matchStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				$<s>9 
			);
			_here;
		}
	;






 /*
 ** matchistr-  Matches the first group of characters in
 ** the $3 parameter against the string in the $5 parameter.
 **
 ** On match, returns chars after matched string in $7 and returns
 ** matched chars in $9.
 */


ConstFunc:	
		matchistrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchistrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				NULL 
			);
			_here;
		}

	|	matchistrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			matchiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				$<s>9 
			);
			_here;
		}
	;






 /*
 ** uptoStr-  Matches all the characters in the $3 parameter
 **			  up to, and but not including, the string specified by
 ** 		  the $5 parameter.
 */


ConstFunc:	
		uptostrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			uptoStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL,
				NULL 
			);
			_here;
		}

	|	uptostrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			uptoStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				NULL 
			);
			_here;
		}

	|	uptostrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store rslt	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			uptoStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				$<s>9 
			);
			_here;
		}
	;




 /*
 ** uptoiStr- Case insensitive version of the above.
 */


ConstFunc:	
		uptoistrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			uptoiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL,
				NULL 
			);
			_here;
		}

	|	uptoistrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			uptoiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				NULL 
			);
			_here;
		}

	|	uptoistrTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store rslt	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			uptoiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				$<s>9 
			);
			_here;
		}
	;







 /*
 ** matchtoStr-  Matches all the characters in the $3 parameter
 **				 up to, and including, the string specified by
 **				 the $5 parameter.
 */


ConstFunc:	
		matchtostrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchtoStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchtostrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchtoStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				NULL 
			);
			_here;
		}

	|	matchtostrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			matchtoStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				$<s>9 
			);
			_here;
		}
	;




 /*
 ** matchtoiStr- Case insensitive version of the above.
 */


ConstFunc:	
		matchtoistrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchtoiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchtoistrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchtoiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				NULL 
			);
			_here;
		}

	|	matchtoistrTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		comma 				/* $4 						*/
		ConstOnlyExpr 		/* $5 = string to match		*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store str 	*/
		','					/* $8						*/
		DefinedID			/* $9 = place to store str 	*/
		Rparen				/* $10						*/
		{					/* $11						*/
			_here;
			matchtoiStrFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				YYS &$<v>5, 
				$<s>7,
				$<s>9 
			);
			_here;
		}
	;










 /*
 ** zeroOrMoreWS-	Skips any whitespace characters in the string.
 **					Always succeeds.
 */


ConstFunc:	
		zeroormorewsTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $4						*/
		{					/* $5						*/
			_here;
			zeroOrMoreWSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL 
			);
			_here;
		}

	|	zeroormorewsTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		','					/* $4						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			zeroOrMoreWSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5 
			);
			_here;
		}
	;







 /*
 ** oneOrMoreWS-	Skips any whitespace characters in the string.
 **					Succeeds if there is at least one WS char.
 */


ConstFunc:	
		oneormorewsTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $4						*/
		{					/* $5						*/
			_here;
			oneOrMoreWSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL 
			);
			_here;
		}

	|	oneormorewsTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		','					/* $4						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			oneOrMoreWSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5 
			);
			_here;
		}
	;







 /*
 ** WSorEOS-	Matches a WS item or EOS.  Eats the WS value
 **				if found, but does not eat EOS (though it
 **				will succeed on EOS).
 */


ConstFunc:	
		wsoreosTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $4						*/
		{					/* $5						*/
			_here;
			WSorEOSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL 
			);
			_here;
		}

	|	wsoreosTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		','					/* $4						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			WSorEOSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5 
			);
			_here;
		}
	;






 /*
 ** WSthenEOS-	Matches zero or more WS items followed
 **				by the end of the string.
 */


ConstFunc:	
		wstheneosTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $4						*/
		{					/* $5						*/
			_here;
			WSthenEOSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL 
			);
			_here;
		}

	|	wstheneosTkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		','					/* $4						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			WSthenEOSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5 
			);
			_here;
		}
	;






 /*
 ** peekWS-	Looks ahead to the next character to see
 **			if it is a WS item.  Does not eat the WS char.
 */


ConstFunc:	
		peekwsTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $4						*/
		{					/* $5						*/
			_here;
			peekWSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL 
			);
			_here;
		}

	|	peekwsTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		','					/* $4						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			peekWSFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5 
			);
			_here;
		}
	;





 /*
 ** EOS-	Returns true if at the end of the string.
 */


ConstFunc:	
		eosTkn				/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $4						*/
		{					/* $5						*/
			_here;
			eosFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL 
			);
			_here;
		}

	|	eosTkn				/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		','					/* $4						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			eosFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5 
			);
			_here;
		}
	;






 /*
 ** matchID-  Matches a string that corresponds to an HLA identifier.
 **
 **		RE:  {'a'..'z', 'A'..'Z', '_'}{'a'..'z', 'A'..'Z', '0'..'9', '_'}* 
 **
 ** On match, the identifier in $7 and the rest of the string
 ** in $5.
 */


ConstFunc:	
		matchidTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchIDFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchidTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchIDFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchidTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store ID	*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchIDFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;









 /*
 ** matchIntConst-  Matches a string that corresponds to an integer constant.
 **
 **		RE: 	{'0'..'9'}
 **			|	{'0'..'9'} {'0'..'9', '_'}* {'0'..'9'} 
 **
 ** On match, the constant goes into $7 and the rest of the string
 ** winds up in $5.
 */


ConstFunc:	
		matchintconstTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchIntConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchintconstTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchIntConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchintconstTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store const*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchIntConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;









 /*
 ** matchRealConst-  Matches a string that corresponds to an FP constant.
 **
 ** On match, the constant goes into $7 and the rest of the string
 ** winds up in $5.
 */


ConstFunc:	
		matchrealconstTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchRealConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchrealconstTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchRealConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchrealconstTkn	/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store const*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchRealConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;











 /*
 ** matchNumericConst-  Matches a string that corresponds to an integer
 **						or a real literal constant.
 **
 ** On match, the constant goes into $7 and the rest of the string
 ** winds up in $5.
 */


ConstFunc:	
		matchnumericconstTkn	/* $1 						*/
		Lparen 					/* $2 						*/
		ConstOnlyExpr 			/* $3 = string to scan 		*/
		Rparen					/* $6						*/
		{						/* $7						*/
			_here;
			matchNumericConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchnumericconstTkn	/* $1 						*/
		Lparen 					/* $2 						*/
		ConstOnlyExpr 			/* $3 = string to scan 		*/
		',' 					/* $4 						*/
		DefinedID				/* $5 = place to store str 	*/
		Rparen					/* $6						*/
		{						/* $7						*/
			_here;
			matchNumericConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchnumericconstTkn	/* $1 						*/
		Lparen 					/* $2 						*/
		ConstOnlyExpr 			/* $3 = string to scan 		*/
		',' 					/* $4 						*/
		DefinedID				/* $5 = place to store str 	*/
		','						/* $6						*/
		DefinedID				/* $7 = place to store const*/
		Rparen					/* $8						*/
		{						/* $9						*/
			_here;
			matchNumericConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;













 /*
 ** matchStrConst-  Matches a string that corresponds to an HLA compatible
 **					string constant.
 **
 ** On match, the constant goes into $7 and the rest of the string
 ** winds up in $5.
 */


ConstFunc:	
		matchstrconstTkn		/* $1 						*/
		Lparen 					/* $2 						*/
		ConstOnlyExpr 			/* $3 = string to scan 		*/
		Rparen					/* $6						*/
		{						/* $7						*/
			_here;
			matchStrConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchstrconstTkn		/* $1 						*/
		Lparen 					/* $2 						*/
		ConstOnlyExpr 			/* $3 = string to scan 		*/
		',' 					/* $4 						*/
		DefinedID				/* $5 = place to store str 	*/
		Rparen					/* $6						*/
		{						/* $7						*/
			_here;
			matchStrConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchstrconstTkn		/* $1 						*/
		Lparen 					/* $2 						*/
		ConstOnlyExpr 			/* $3 = string to scan 		*/
		',' 					/* $4 						*/
		DefinedID				/* $5 = place to store str 	*/
		','						/* $6						*/
		DefinedID				/* $7 = place to store const*/
		Rparen					/* $8						*/
		{						/* $9						*/
			_here;
			matchStrConstFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;





 /*
 ** matchReg-	Matches a string that corresponds to an 80x86 general
 **				purpose register.
 **
 ** On match, the constant goes into $7 and the rest of the string
 ** winds up in $5.
 */


ConstFunc:	
		matchregTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchRegFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchregTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchRegFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchregTkn			/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store const*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchRegFunc
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;





 /*
 ** matchReg8-	Matches a string that corresponds to an 80x86 general
 **				purpose 8-bit register.
 **
 ** On match, the constant goes into $7 and the rest of the string
 ** winds up in $5.
 */


ConstFunc:	
		matchreg8Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchReg8Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchreg8Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchReg8Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchreg8Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store const*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchReg8Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;







 /*
 ** matchReg16-	Matches a string that corresponds to an 80x86 general
 **				purpose 16-bit register.
 **
 ** On match, the constant goes into $7 and the rest of the string
 ** winds up in $5.
 */


ConstFunc:	
		matchreg16Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchReg16Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchreg16Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchReg16Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchreg16Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store const*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchReg16Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;






 /*
 ** matchReg32-	Matches a string that corresponds to an 80x86 general
 **				purpose 32-bit register.
 **
 ** On match, the constant goes into $7 and the rest of the string
 ** winds up in $5.
 */


ConstFunc:	
		matchreg32Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchReg32Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				NULL,
				NULL 
			);
			_here;
		}

	|	matchreg32Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		Rparen				/* $6						*/
		{					/* $7						*/
			_here;
			matchReg32Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5, 
				NULL 
			);
			_here;
		}

	|	matchreg32Tkn		/* $1 						*/
		Lparen 				/* $2 						*/
		ConstOnlyExpr 		/* $3 = string to scan 		*/
		',' 				/* $4 						*/
		DefinedID			/* $5 = place to store str 	*/
		','					/* $6						*/
		DefinedID			/* $7 = place to store const*/
		Rparen				/* $8						*/
		{					/* $9						*/
			_here;
			matchReg32Func
			( 
				YYS &$<v>$, 
				YYS &$<v>3, 
				$<s>5,
				$<s>7 
			);
			_here;
		}
	;













/**********************************************************/
/*                                                        */
/* Handle the assembly-time constants and variables here. */
/*                                                        */
/**********************************************************/

ConstFunc:	lineNumberTkn
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tUns32, 
					&uns32_ste
				);
				$<v.u.unsval>$ = LineCnt;
			}
		;



ConstFunc:	filenameTkn
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste
				);
				$<v.u.strval>$ = hlastrdup2( FileName );
			}
		;


			
ConstFunc:	curLexTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
				$<v.u.intval>$ = CurLexLevel;
			}
		;

ConstFunc:	curOffsetTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
				$<v.u.intval>$ = CurOffset;
			}
		;


ConstFunc:	curDirTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
				$<v.u.intval>$ = CurOffsetDir;
			}
		;


ConstFunc:	addOffset1stTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = AddOffset1st;
			}
		;



ConstFunc:	startParmOfsTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
				$<v.u.intval>$ = StartParmOffs;
			}
		;


ConstFunc:	startLclOfsTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
				$<v.u.intval>$ = StartLclOffs;
			}
		;


ConstFunc:	enumSizeTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
				$<v.u.intval>$ = EnumSize;
			}
		;


ConstFunc:	atlabelTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tInt32, 
					&int32_ste
				);
				$<v.u.intval>$ = LblCntr;
			}
		;


ConstFunc:	traceTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = TraceFlag;
			}
		;


ConstFunc:	exceptsTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = FullExceptions;
			}
		;


ConstFunc:	optstringsTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = OptimizeStrings;
			}
		;


ConstFunc:	boundvarTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = CompileBound;
			}
		;




ConstFunc:	intovarTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = CompileInto;
			}
		;




ConstFunc:	noframeTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = !FrameDefault;
			}
		;




ConstFunc:	frameTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = FrameDefault;
			}
		;





ConstFunc:	nodisplayTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = !DisplayDefault;
			}
		;




ConstFunc:	displayTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = DisplayDefault;
			}
		;






ConstFunc:	noalignstkTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = !AlignStackDefault;
			}
		;




ConstFunc:	alignstkTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = AlignStackDefault;
			}
		;






ConstFunc:	noenterTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = !EnterDefault;
			}
		;




ConstFunc:	useenterTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = EnterDefault;
			}
		;





ConstFunc:	noleaveTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = !LeaveDefault;
			}
		;




ConstFunc:	useleaveTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tBoolean, 
					&boolean_ste
				);
				$<v.u.boolval>$ = LeaveDefault;
			}
		;




ConstFunc:	alignprocTkn 
			{
				_here;
				ClrConst
				( 
					YYS &$<v>$, 
					tUns32, 
					&uns32_ste
				);
				$<v.u.unsval>$ = !AlignDefault;
			}
		;




ConstFunc:	lastMacroObjectTkn 
			{
				union YYSTYPE v;

				_here;
				_if
				( 
						LastMacroObject != NULL 
					&&	LastMacroObject->TrueName != NULL 
				)
				
					v.v.u.strval = hlastrdup2( LastMacroObject->TrueName );
					
				_else
				
					v.v.u.strval = hlastrdup2( "" );
					
				_endif
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &v
				);
				_here;
			}
		;


ConstFunc:	baseregTkn 
			{
				union YYSTYPE v;

				_here;
				v.v.u.strval = hlastrdup2( CurBaseReg );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &v
				);
			}
		;





 /*
 ** Replace @curobject by the current object name
 ** if we're currently processing an object.
 */
 

ConstFunc:	curObjectNameTkn 
			{
				union YYSTYPE v;

				_here;
				_if
				( 
						LastRefdObject != NULL 
					&&	LastRefdObject->TrueName != NULL 
				)
				
					v.v.u.strval = hlastrdup2( LastRefdObject->TrueName );
					
				_else
				
					v.v.u.strval = hlastrdup2( "" );
					
				_endif
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &v
				);
				_here;
			}
		;





 
	/*
	** @section( id )
	**
	**	Merges the following boolean varibles into a 32-bit
	**	array of booleans and returns this 32-bit value as
	**	an unsigned 32-bit integer.  The bits are arranged as
	**	follows:
	**
	*/

	/*   					 Bit #	(in 32-bit "Section" variable	*/
	/*  			   		 -----								 	*/
	/*  inConst					 0								 	*/
	/*  inVal					 1								 	*/
	/*  inType					 2								 	*/
	/*  inVar					 3								 	*/
	/*  inStatic				 4								 	*/
	/*  inReadonly				 5								 	*/
	/*  inStorage				 6								 	*/
	/*															 	*/
	/*  inMain					12								 	*/
	/*  inProcedure				13								 	*/
	/*  inMethod				14								 	*/
	/*  inIterator				15								 	*/
	/*  inMacro					16								 	*/
	/*  inKeyword				17								 	*/
	/*  inTerminator			18								 	*/
	/*  inThunk					19								 	*/
	/*															 	*/
	/*  inUnit					23								 	*/
	/*  inProgram				24								 	*/
	/*  inRecord				25								 	*/
	/*  inUnion					26								 	*/
	/*  inClass					27								 	*/
	/*  inNamespace 			28								 	*/
	/*  inRegex		 			29								 	*/


ConstFunc: 
		sectionTkn		/* $1 */ 
		{				/* $2 */


			union YYSTYPE v;
			#define b(val,ofs) ((val & 1) << ofs )

			_here;
			v.v.u.unsval =
					b( inRegex, 29 )
				+	b( inNamespace, 28 )
				+	b( inClass, 27 )
				+	b( inUnion, 26 )
				+	b( inRecord, 25 )
				+	b( inProgram, 24 )
				+	b( inUnit, 23 )
				
				+	b( inThunk, 19 )
				+	b( inTerminator, 18 )
				+	b( inKeyword, 17 )
				+	b( inMacro, 16 )
				+	b( inIterator, 15 )
				+	b( inMethod, 14 )
				+	b( inProcedure, 13 )
				+	b( inMain, 12 )

				+	b( inStorage, 6 )
				+	b( inReadonly, 5 )
				+	b( inStatic, 4 )
				+	b( inVar, 3 )
				+	b( inType, 2 )
				+	b( inVal, 1 )
				+	( inConst & 1 );

			SetConst
			( 
				YYS &$<v>$, 
				tDWord, 
				&dword_ste,
				YYS &v
			);
			$<v.u.lwordval>$[1] = 0;
			$<v.u.lwordval>$[2] = 0;
			$<v.u.lwordval>$[3] = 0;
			_here;
		}
	;
			

 



/*******************************************/
/*                                         */
/* Handle the symbol table functions here. */
/*                                         */
/*******************************************/


/*
** @name, @type, @TypeName, @pType, @class, @pClass, @size, @offset,
** @StaticName, @lex, @IsExternal, @arity, @dim, @elements,
*/

ConstExpr:	SymTblFunc
			{
				_here;
				memcpy( &$<v>$, &$<v>1, sizeofSymNode );
			}
	;



	/*
	** @defined( id )
	**
	** This function returns true if the ID
	** specified by the symbol above is defined.
	** It returns false if the symbol is undefined.
	*/

SymTblFunc: 
		symDefinedTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */


			union YYSTYPE v;

			_here;
			_if( $<cls.cls>3 & cfy_SingleID )

				v.v.u.unsval = ( $<cls.cls>3 & cfy_Undefined ) == 0;

			_else

				yyerror( "Expected a single identifier" );
				v.v.u.unsval = 0;

			_endif
			ClrConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste
			);
			$<v.u.unsval>$ = v.v.u.unsval;
			_here;
		}
	;
			

 
	/*
	** @name( id )
	**
	** This function returns a string containing the
	** name of the specified identifier.
	*/

SymTblFunc: 
		symNameTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */


			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tString, 
				&string_ste
			);

			_if( $<cls.sym>3 != NULL )

				v.v.u.strval = hlastrdup2( $<cls.sym>3->TrueName );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &v
				);

			_else

				v.v.u.strval = hlastrdup2( "" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &v
				);


			_endif
			_here;
		}
	;
			

 
 /*
 ** @locals( symbol )-
 ** Returns an array of strings specify the local symbols
 ** associated with the argument.  The argument must be
 ** a record, union, procedure, iterator, or method.
 ** Sorry, namespaces and classes aren't allowed.
 */
			
SymTblFunc: 
		symLocalsymsTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			int		i;
			int		j;
			int		localCnt;
			int		fieldCnt;
			union	YYSTYPE	v;
			struct	SymNode	*s;
			struct	SymNode	*curField;
			struct	SymNode	*curLcl;			
			

			_here;
			s = $<cls.sym>3;
			ClrConst
			( 
				YYS &v, 
				tString, 
				&string_ste
			);
			_if( s != NULL )
			
				// Handle enums, classes, records, and unions here:
				
				_if
				( 
						s->pType == tRecord
					||	s->pType == tUnion
					||	s->pType == tClass
					||	s->pType == tEnum
				)
				
					/*
					** Construct the $<v>$ object for the parser.
					** Begin by clearing out unimportant fields.
					*/

					SetConst
					( 
						YYS &$<v>$, 
						tString, 
						&string_ste,
						YYS &v
					);


					$<v.TrueName>$ = hlastrdup2( "" );
					$<v.StaticName>$ = NULL;
					$<v.Offset>$ = 0;
					$<v.Base>$ = NULL;
					$<v.Fields>$ = NULL;
					$<v.FieldCnt>$ = 0; 
					
					
					/*
					** Count the number of actual fields
					** in the structure (we don't count
					** Anon Record entries).
					*/
					
					fieldCnt = 0;
					curField = s->Fields;
					_for( i=s->FieldCnt-1, i >= 0 , --i )
					
						assert( curField != NULL );
						_if( curField->pType != tAnonRec )
						
							++fieldCnt;
							
						_endif
						curField = curField->Next;
					
					_endfor
					
					/*
					** Here are the important assignments.
					*/

					$<v.pType>$ = tArray;
					$<v.SymClass>$ = cConstant;
					$<v.Type>$ = &string_ste;
					$<v.Arity>$ = 1;
					$<v.Dimensions>$ = malloc2( sizeof( int ));
					$<v.Dimensions>$[0] = fieldCnt;
					$<v.NumElements>$ = fieldCnt;

					$<v.u.ArrayOfValues>$ = 
						malloc2( fieldCnt * sizeofSymNode );
						
					$<v.ObjectSize>$ = fieldCnt * sizeof( char* );

					/*
					** Okay, fill in the array elements here:
					*/
					
					curField = s->Fields;
					i = fieldCnt-1;
					_for( j=s->FieldCnt-1, j >= 0 , --j )

						assert( curField != NULL );
						_if( curField->pType != tAnonRec )
						
							$<v.u.ArrayOfValues>$[i].Name = hlastrdup2( "" );
							$<v.u.ArrayOfValues>$[i].TrueName = hlastrdup2( "" );
							$<v.u.ArrayOfValues>$[i].SymClass = cConstant;
							$<v.u.ArrayOfValues>$[i].StaticName = NULL;
							$<v.u.ArrayOfValues>$[i].Base = NULL;
							$<v.u.ArrayOfValues>$[i].Fields = NULL;
							$<v.u.ArrayOfValues>$[i].FieldCnt = 0;
							$<v.u.ArrayOfValues>$[i].pType = tString;
							$<v.u.ArrayOfValues>$[i].Type = &string_ste;
							$<v.u.ArrayOfValues>$[i].Arity = 0;
							$<v.u.ArrayOfValues>$[i].Dimensions = NULL;
							$<v.u.ArrayOfValues>$[i].NumElements = 0;

							$<v.u.ArrayOfValues>$[i].u.strval = curField->TrueName;
							--i;
							
						_endif
						curField = curField->Next;

					_endfor
					
				
				
				
				// Handle classes here:
				
				_elseif( s->pType == tNamespace )
				
					/*
					** Construct the $<v>$ object for the parser.
					** Begin by clearing out unimportant fields.
					*/

					SetConst
					( 
						YYS &$<v>$, 
						tString, 
						&string_ste,
						YYS &v
					);


					$<v.TrueName>$ = hlastrdup2( "" );
					$<v.StaticName>$ = NULL;
					$<v.Offset>$ = 0;
					$<v.Base>$ = NULL;
					$<v.Fields>$ = NULL;
					$<v.FieldCnt>$ = 0; 
					
					
					/*
					** Count the number of actual fields
					** in the structure (we don't count
					** Anon Record entries).
					*/
					
					fieldCnt = 0;
					curField = s->Fields;
					_while( curField != NULL )
					
						_if( curField->pType != tAnonRec )
						
							++fieldCnt;
							
						_endif
						curField = curField->Next;
					
					_endwhile
					
					/*
					** Here are the important assignments.
					*/

					$<v.pType>$ = tArray;
					$<v.SymClass>$ = cConstant;
					$<v.Type>$ = &string_ste;
					$<v.Arity>$ = 1;
					$<v.Dimensions>$ = malloc2( sizeof( int ));
					$<v.Dimensions>$[0] = fieldCnt;
					$<v.NumElements>$ = fieldCnt;

					$<v.u.ArrayOfValues>$ = 
						malloc2( fieldCnt * sizeofSymNode );
						
					$<v.ObjectSize>$ = fieldCnt * sizeof( char* );

					/*
					** Okay, fill in the array elements here:
					*/
					
					curField = s->Fields;
					i = fieldCnt-1;
					_while( curField != NULL )

						_if( curField->pType != tAnonRec )
						
							$<v.u.ArrayOfValues>$[i].Name = hlastrdup2( "" );
							$<v.u.ArrayOfValues>$[i].TrueName = hlastrdup2( "" );
							$<v.u.ArrayOfValues>$[i].SymClass = cConstant;
							$<v.u.ArrayOfValues>$[i].StaticName = NULL;
							$<v.u.ArrayOfValues>$[i].Base = NULL;
							$<v.u.ArrayOfValues>$[i].Fields = NULL;
							$<v.u.ArrayOfValues>$[i].FieldCnt = 0;
							$<v.u.ArrayOfValues>$[i].pType = tString;
							$<v.u.ArrayOfValues>$[i].Type = &string_ste;
							$<v.u.ArrayOfValues>$[i].Arity = 0;
							$<v.u.ArrayOfValues>$[i].Dimensions = NULL;
							$<v.u.ArrayOfValues>$[i].NumElements = 0;

							$<v.u.ArrayOfValues>$[i].u.strval = curField->TrueName;
							--i;
							
						_endif
						curField = curField->Next;

					_endwhile
					
				
				
				
				// Handle procedures, methods, and iterators here:
				
				_elseif
				( 
						s->pType == tProc 
					||	s->pType == tMethod
					||	s->pType == tClassProc 
					||	s->pType == tClassIter 
					||	s->pType == tIterator
				)
				
					/*
					** Construct the $<v>$ object for the parser.
					** Begin by clearing out unimportant fields.
					*/

					SetConst
					( 
						YYS &$<v>$, 
						tString, 
						&string_ste,
						YYS &v
					);


					$<v.TrueName>$ = hlastrdup2( "" );
					$<v.StaticName>$ = NULL;
					$<v.Offset>$ = 0;
					$<v.Base>$ = NULL;
					$<v.Fields>$ = NULL;
					$<v.FieldCnt>$ = 0; 
					
					
					/*
					** We need to count the number of local symbols
					** here:
					*/
					
					curLcl = s->u.proc.Locals;
					localCnt = 0;
					_while( curLcl != s && curLcl != NULL )
						
						++localCnt;
						curLcl = curLcl->Next;
						
					_endwhile;
					
					/*
					** Here are the important assignments.
					*/

					$<v.pType>$ = tArray;
					$<v.SymClass>$ = cConstant;
					$<v.Type>$ = &string_ste;
					$<v.Arity>$ = 1;
					$<v.Dimensions>$ = malloc2( sizeof( int ));
					$<v.Dimensions>$[0] = localCnt;
					$<v.NumElements>$ = localCnt;
					
					$<v.u.ArrayOfValues>$ = 
						malloc2( localCnt * sizeofSymNode );
						
					$<v.ObjectSize>$ = localCnt * sizeof( char* );

					/*
					** Okay, fill in the array elements here:
					*/
					
					curLcl = s->u.proc.Locals;
					_for( i=0, i < localCnt, ++i )

						$<v.u.ArrayOfValues>$[i].Name = hlastrdup2( "" );
						$<v.u.ArrayOfValues>$[i].TrueName = hlastrdup2( "" );
						$<v.u.ArrayOfValues>$[i].SymClass = cConstant;
						$<v.u.ArrayOfValues>$[i].StaticName = NULL;
						$<v.u.ArrayOfValues>$[i].Base = NULL;
						$<v.u.ArrayOfValues>$[i].Fields = NULL;
						$<v.u.ArrayOfValues>$[i].FieldCnt = 0;
						$<v.u.ArrayOfValues>$[i].pType = tString;
						$<v.u.ArrayOfValues>$[i].Type = &string_ste;
						$<v.u.ArrayOfValues>$[i].Arity = 0;
						$<v.u.ArrayOfValues>$[i].Dimensions = NULL;
						$<v.u.ArrayOfValues>$[i].NumElements = 0;

						assert( curLcl != NULL );
						$<v.u.ArrayOfValues>$[i].u.strval = curLcl->TrueName;
						curLcl = curLcl->Next;

					_endfor
					
				
				_elseif( s->pType == tProgram )
				
					yyerror
					(
						"@localsyms argument cannot be a program/unit ID!"
					);
					
					// Dummy string to keep the rest of the system happy.
					
					v.v.u.strval = hlastrdup2( "@localsyms" );
					SetConst
					( 
						YYS &$<v>$, 
						tString, 
						&string_ste,
						YYS &v
					);
					
					
				_else
				
					yyerror
					( 
						"@localsyms argument doesn't have any local symbols" 
					);
					v.v.u.strval = hlastrdup2( "@localsyms" );
					SetConst
					( 
						YYS &$<v>$, 
						tString, 
						&string_ste,
						YYS &v
					);
					
				_endif				

			_else

				yyerror( "Expected an identifier as @localsyms parameter" );
				v.v.u.strval = hlastrdup2( "@localsyms" );
				SetConst
				( 
					YYS &$<v>$, 
					tString, 
					&string_ste,
					YYS &v
				);


			_endif
			_here;
		}
	;
			

 
			
 
 /*
 ** @parms( symbol )-
 ** Returns an array of strings specify the local symbols
 ** associated with the argument.  The argument must be
 ** a record, union, procedure, iterator, or method.
 ** Sorry, namespaces and classes aren't allowed.
 */
			
SymTblFunc: 
		symParmsTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			int		i;
			int		j;
			int		localCnt;
			int		fieldCnt;
			union	YYSTYPE	v;
			struct	SymNode	*s;
			struct	SymNode	*curField;
			struct	SymNode	*curLcl;			
			
			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);
			s = $<cls.sym>3;
			_if( s != NULL )
			
				// Handle records and unions here:
				
				
				// Handle procedures, methods, and iterators here:
				
				_if
				( 
						s->pType == tProc 
					||	s->pType == tMethod
					||	s->pType == tClassProc 
					||	s->pType == tClassIter 
					||	s->pType == tIterator
					||	s->pType == tProcptr
				)
				


					/*
					** Construct the $<v>$ object for the parser.
					** Begin by clearing out unimportant fields.
					*/

					v.v.u.unsval = s->u.proc.ParmSize;
					SetConst
					( 
						YYS &$<v>$, 
						tUns32, 
						&uns32_ste,
						YYS &v
					);


					$<v.TrueName>$ = hlastrdup2( "" );
					$<v.StaticName>$ = NULL;
					$<v.Offset>$ = 0;
					$<v.Base>$ = NULL;
					$<v.Fields>$ = NULL;
					$<v.FieldCnt>$ = 0;
				
				_else
				
					yyerror
					( 
						"@parms: argument must be a procedure, method, "
						"or iterator" 
					);
					ClrConst
					( 
						YYS &$<v>$, 
						tUns32, 
						&uns32_ste
					);
					
				_endif				

			_else

				yyerror( "Expected an identifier as @parms argument" );
				ClrConst
				( 
					YYS &$<v>$, 
					tUns32, 
					&uns32_ste
				);


			_endif
			_here;
		}
	;
			

 
			
 /*
 ** @type( id )
 **
 **	This function returns a (probably) unique integer for each type
 ** in the current program.  This is accomplished by running a HASH
 ** function on the type id's name.
 */

SymTblFunc:
		symTypeTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */


			union	YYSTYPE	v;
					char	*TypeName;
					int		HashVal;

			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);

			/*
			** This is truly digusting code.  It hashes the
			** type name to try to produce a unique ID (that
			** is consistent across compiles).  No guarantee
			** that the values are truly unique, but there
			** is a pretty good chance it will happen.
			*/

			_if( ( $<cls.cls>3 & cfy_Reg8 ) != 0 )

				$<cls.type>3 = &byte_ste;

			_elseif( ( $<cls.cls>3 & cfy_Reg16 ) != 0 )

				$<cls.type>3 = &word_ste;

			_elseif( ( $<cls.cls>3 & cfy_Reg32 ) != 0 )

				$<cls.type>3 = &dword_ste;

			_elseif( ( $<cls.cls>3 & cfy_fpReg ) != 0 )

				$<cls.type>3 = &real80_ste;

			_endif

			_if( $<cls.type>3 == NULL )

				/*
				** Unknown expression type. Just return zero.
				*/

				v.v.u.unsval = 0;

			_else

				_if( $<cls.sym>3 != NULL && $<cls.sym>3->SymClass == cType )
				
					/*
					** If this is a type name, just return
					** the address of the symbol.
					*/
					
					TypeName = $<cls.sym>3->TrueName;
					
				_else
				
					assert( $<cls.type>3 != NULL );
					TypeName = $<cls.type>3->TrueName;
					
				_endif
				HashVal = 0;
				TypeName = _ifx( TypeName == NULL, "", TypeName );
				_while( *TypeName != '\0' )
				
					/*
					** Hash function is effectively a ROL xor new char
					** plus a summing of the H.O. two bits.
					*/
					
					HashVal = (( HashVal << 2 ) ^ *TypeName ) +
								( HashVal >> 30 );
					++TypeName;
					
				_endwhile
				v.v.u.unsval = HashVal;

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tDWord, 
				&dword_ste,
				YYS &v
			);
			_here;
		}

	;	


 /*
 ** @TypeName( id )
 **
 ** This function returns a string corresponding to the
 ** name of the type of the identifier passed as a parameter.
 */

SymTblFunc:
		symTypeNameTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */


			union YYSTYPE	v;
			char			*TypeName;
			char			ptrName[256];

			/*
			** If we've got a register, return "byte", "word",
			** or "dword" as appropriate.
			*/

			_here;
			_if( ( $<cls.cls>3 & cfy_Reg8 ) != 0 )

				TypeName = "byte";

			_elseif( ( $<cls.cls>3 & cfy_Reg16 ) != 0 )

				TypeName = "word";

			_elseif( ( $<cls.cls>3 & cfy_Reg32 ) != 0 )

				TypeName = "dword";

			_elseif( ( $<cls.cls>3 & cfy_fpReg ) != 0 )

				TypeName = "real80";


			// Note: for cls objects, sym==type if you have a type dcl.

			_elseif( $<cls.type>3 != NULL && $<cls.sym>3 != $<cls.type>3 )
 
				_if( $<cls.cls>3 & cfy_IsPointer )
				
					_if( $<cls.sym>3->Base != NULL )
					
						
						strcpy( ptrName, "pointer to " );
						strncpy
						( 
							&ptrName[11],
							$<cls.sym>3->Base->TrueName,
							244
						);
						ptrName[255] = '\0';  
						TypeName = ptrName;
											
					_else
					
						// Pointer to ????
						
						TypeName = $<cls.type>3->TrueName;
						
					_endif
						
				
				_else
				
					TypeName = $<cls.type>3->TrueName;
					
				_endif


			_elseif( $<cls.sym>3 != NULL && $<cls.sym>3->SymClass == cType )
				
				/*
				** If this is a type name and it's base type is NULL,
				** just return the address of the symbol.  If the base
				** type is not NULL, then return the base type.
				*/
				
				_if( $<cls.sym>3->Type == NULL )

					TypeName = $<cls.sym>3->TrueName;

				_else

					// If it's a pointer, emit "pointer to <type>"
					
					_if( $<cls.cls>3 & cfy_IsPointer )
					
						_if( $<cls.sym>3->Base != NULL )
						
							strcpy( ptrName, "pointer to " );
							strncpy
							( 
								&ptrName[11],
								$<cls.sym>3->Base->TrueName,
								244
							);
							ptrName[255] = '\0';  
							TypeName = ptrName;

						
						_else
						
							// Pointer to ????
							
							TypeName = $<cls.sym>3->Type->TrueName;
							
						_endif
							
					
					_else
					
						TypeName = $<cls.sym>3->Type->TrueName;
						
					_endif

				_endif
							
			_else

				/*
				** Unknown expression type. Just return the empty string.
				*/

				TypeName = "";

			_endif
			v.v.u.strval = hlastrdup2( TypeName );
			SetConst
			( 
				YYS &$<v>$, 
				tString, 
				&string_ste,
				YYS &v
			);
			_here;
		}
	;




 /*
 ** @BaseType( id )
 **
 ** This function returns a string corresponding to the
 ** name of the base type of the identifier passed as a parameter.
 */

SymTblFunc:
		symBaseTypeNameTkn	/* $1 */ 
		Lparen 				/* $2 */
		Classify			/* $3 */
		Rparen				/* $4 */
		{					/* $5 */


			union YYSTYPE	v;
			char			*TypeName;
			char			ptrName[256];

			/*
			** If we've got a register, return "byte", "word",
			** or "dword" as appropriate.
			*/

			_here;
			_if( ( $<cls.cls>3 & cfy_Reg8 ) != 0 )

				TypeName = "byte";

			_elseif( ( $<cls.cls>3 & cfy_Reg16 ) != 0 )

				TypeName = "word";

			_elseif( ( $<cls.cls>3 & cfy_Reg32 ) != 0 )

				TypeName = "dword";

			_elseif( ( $<cls.cls>3 & cfy_fpReg ) != 0 )

				TypeName = "real80";


			_else
			
				_if( $<cls.type>3 != NULL )

					_if( $<cls.type>3->Base != NULL )

						TypeName = $<cls.type>3->Base->TrueName;

					_elseif( $<cls.type>3->Type != NULL )

						TypeName = $<cls.type>3->Type->TrueName;

					_else

						TypeName = $<cls.type>3->TrueName;

					_endif

				_elseif( $<cls.sym>3->Base != NULL )

					TypeName = $<cls.sym>3->Base->TrueName;

				_elseif( $<cls.sym>3->Type != NULL )

					_if( $<cls.sym>3->Type->Base != NULL )

						TypeName = $<cls.sym>3->Type->Base->TrueName;

					_elseif( $<cls.sym>3->Type->Type != NULL )

						TypeName = $<cls.sym>3->Type->Type->TrueName;

					_else

						TypeName = $<cls.sym>3->Type->TrueName;

					_endif

				_else

					TypeName = $<cls.sym>3->TrueName;

				_endif;
				assert( TypeName != NULL );
							
			_endif
			v.v.u.strval = hlastrdup2( TypeName );
			SetConst
			( 
				YYS &$<v>$, 
				tString, 
				&string_ste,
				YYS &v
			);
			_here;
		}
	;


 /*
 ** @ptype( id )
 **
 **	This function returns the pType (primitive type) of a symbol.
 ** Actually, it returns that value plus one, so zero can be returned
 ** for undefined symbols or symbols that don't have a pType.
 */

SymTblFunc:
		sympTypeTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);

			/*
			** Because we have to allow for undefined IDs,
			** the following code bumps the actual pType value
			** up by one (undefined IDs have a pType of zero).
			*/
			
			_here;
			_if( ( $<cls.cls>3 & cfy_Reg8 ) != 0 )

				_if( $<cls.type>3 != NULL )

					v.v.u.unsval = $<cls.type>3->pType + 1;

				_else

					v.v.u.unsval = tByte + 1;

				_endif

			_elseif( ( $<cls.cls>3 & cfy_Reg16 ) != 0 )

				_if( $<cls.type>3 != NULL )

					v.v.u.unsval = $<cls.type>3->pType + 1;

				_else

					v.v.u.unsval = tWord + 1;

				_endif

			_elseif( ( $<cls.cls>3 & cfy_Reg32 ) != 0 )

				_if( $<cls.type>3 != NULL )

					v.v.u.unsval = $<cls.type>3->pType + 1;

				_else

					v.v.u.unsval = tDWord + 1;

				_endif

			_elseif( ( $<cls.cls>3 & cfy_fpReg ) != 0 )

				v.v.u.unsval = tReal80 + 1;


			_elseif( $<cls.sym>3 != NULL )

				_if( $<cls.sym>3->Type == NULL )
				
					v.v.u.unsval = $<cls.sym>3->pType + 1;
					
				_else
				
					v.v.u.unsval = $<cls.sym>3->Type->pType + 1;
					
				_endif

			_elseif( $<cls.type>3 != NULL )

				v.v.u.unsval = $<cls.type>3->pType + 1;

			_else

				v.v.u.unsval = 0;

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tUns32, 
				&uns32_ste,
				YYS &v 
			);
			_here;
		}
	;



 
 /*
 ** @baseptype( id )
 **
 **	This function returns the pType (primitive type) of a symbol.
 ** Actually, it returns that value plus one, so zero can be returned
 ** for undefined symbols or symbols that don't have a pType.
 */

SymTblFunc:
		symBasepTypeTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE	v;
			struct SymNode	*t;

			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);

			// $<cls.type>3 should be the type of the expression.
			// But if it is invalid, then use the base symbol's type.

			t = $<cls.type>3;
			_if( t == NULL )

				t = _ifx( $<cls.sym>3 != NULL, $<cls.sym>3->Type, NULL );

			_endif
				

			/*
			** Because we have to allow for undefined IDs,
			** the following code bumps the actual pType value
			** up by one (undefined IDs have a pType of zero).
			*/
			
			_here;
			_if( ( $<cls.cls>3 & cfy_Reg8 ) != 0 )

				v.v.u.unsval = _ifx( t != NULL, t->pType + 1, tByte + 1 );

			_elseif( ( $<cls.cls>3 & cfy_Reg16 ) != 0 )

				v.v.u.unsval = _ifx( t != NULL, t->pType + 1, tWord + 1 );

			_elseif( ( $<cls.cls>3 & cfy_Reg32 ) != 0 )

				v.v.u.unsval = _ifx( t != NULL, t->pType + 1, tDWord + 1 );

			_elseif( ( $<cls.cls>3 & cfy_fpReg ) != 0 )
					   
				v.v.u.unsval = tReal80 + 1;


			_elseif( t != NULL )
			
				_if( t->pType == tArray )

					unArray( YYS &$<cls>3 );
					v.v.u.unsval = $<cls.sym>3->pType+1;

				_elseif( t->pType == tPointer )

					_if( t->Base != NULL )

						v.v.u.unsval = t->Base->pType+1;

					_elseif( t->Type != NULL )

						_if( t->Type->Base != NULL )

							v.v.u.unsval = t->Type->Base->pType+1;

						_else

							v.v.u.unsval = t->Type->pType+1;

						_endif

					_else

						v.v.u.unsval = tPointer+1;

					_endif

				_else

					v.v.u.unsval = t->pType+1;
					
				_endif
					
			_else
			
				v.v.u.unsval = 0;

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tUns32, 
				&uns32_ste,
				YYS &v 
			);
			_here;
		}
	;
 


 /*
 ** @class( id )
 **
 **	This function returns the SymClass value (plus one) of
 ** a symbol.
 */


SymTblFunc:
		symClassTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);

			/*
			** Because we have to allow for undefined IDs,
			** the following code bumps the actual pType value
			** up by one (undefined IDs have a pType of zero).
			*/
			
			_here;
			_if( $<cls.sym>3 == NULL )

				v.v.u.unsval = 0;

			_else

				v.v.u.unsval = $<cls.sym>3->SymClass + 1;

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tUns32, 
				&uns32_ste,
				YYS &v 
			);
			_here;
		}
	;


 /*
 ** pClass( id )
 **
 **	If ID is a parameter, this function returns the passing
 ** mechanism (e.g., pass by value) for that parameter.
 */


SymTblFunc:
		sympClassTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			/*
			** Because we have to allow for undefined
			** IDs (which will have a default pClass of zero),
			** the following code bumps the true pClass up by
			** one when returning the value to the user.
			*/

			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);
			_if
			( 
					(( $<cls.cls>3 & cfy_SingleID ) == 0 )
				||	$<cls.sym>3 == NULL 
			)

				v.v.u.unsval = 0;

			_else

				v.v.u.unsval = $<cls.sym>3->pClass + 1;

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tUns32, 
				&uns32_ste,
				YYS &v 
			);
			_here;
		}
	;




 /*
 ** @size( id )
 **
 **	This function returns the object size of the identifier.
 */

SymTblFunc:
		symSizeTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			/*
			** Return the size of the operand.  If we cannot
			** determine the size of the operand, force an
			** error and return one.
			*/
			
			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);
			_if( $<cls.cls>3 & cfy_Undefined )
			
				yyerror( "Undefined symbol in @SIZE function" );
				
			_else
			
				v.v.u.unsval = $<cls.ObjectSize>3;
				SetConst
				( 
					YYS &$<v>$, 
					tUns32, 
					&uns32_ste,
					YYS &v 
				);
				
			_endif
			_here;
		}
	;


 /*
 ** @ElementSize( id )
 **
 **	This function returns the size of an element of the identifier.
 */

SymTblFunc:
		symElementSizeTkn	/* $1 */ 
		Lparen 				/* $2 */
		Classify			/* $3 */
		Rparen				/* $4 */
		{					/* $5 */

			union YYSTYPE v;

			/*
			** Because we have to allow for undefined IDs,
			** the following code bumps the actual pType value
			** up by one (undefined IDs have a pType of zero).
			*/
			
			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);
			_if( $<cls.arity>3 == 0 || $<cls.type>3 == NULL )

				yyerror( "Expected an array identifier/expression" );
				v.v.u.unsval =  0;

			_else

				v.v.u.unsval = $<cls.type>3->ObjectSize;

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tUns32, 
				&uns32_ste,
				YYS &v 
			);
			_here;
		}
	;


 /*
 ** @offset( id )
 **
 **	This function returns the offset associated with a parameter
 ** or VAR object.
 */

SymTblFunc:
		symOffsetTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			/*
			** Undefined symbols will have an offset of zero.
			*/

			_here;
			ClrConst
			( 
				YYS &v, 
				tInt32, 
				&int32_ste
			);
			_if(( $<cls.cls>3 & cfy_SingleID ) == 0 )

				yyerror( "@offset requires a single ID as a parameter" );
				v.v.u.unsval = 0;
				
				 
			_elseif( ( $<cls.cls>3 & cfy_Undefined) || $<cls.sym>3 == NULL )
			
				yyerror
				(
					"The symbol supplied as @offset argument is undefined"
				);
				v.v.u.unsval = 0;

			_else
			
				v.v.u.unsval = $<cls.sym>3->Offset;
				_if
				(
						$<cls.sym>3->SymClass != cVar
					&&	$<cls.sym>3->SymClass != cParm
					&&	$<cls.sym>3->SymClass != cClassIter
					&&	$<cls.sym>3->SymClass != cMethod
				)

					yyerror( "Expected VAR, Parm, class iterator, or method" );
					v.v.u.unsval = 0;

				_endif

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tInt32, 
				&int32_ste,
				YYS &v
			);
			_here;
		}
	;



 /*
 ** @StaticName( id )
 **
 ** This function returns a string corresponding to the
 ** static name of the identifier.
 */

SymTblFunc:
		symStaticNameTkn/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;


			/*
			** If the symbol is undefined, or if there is no
			** static name for this object, return an empty string,
			** otherwise return the static name.
			*/

			_here;
			_if(( $<cls.cls>3 & cfy_SingleID ) == 0 )

				yyerror( "@StaticName requires a single ID as a parameter" );

			_elseif( $<cls.sym>3 == NULL || $<cls.sym>3->StaticName == NULL )

				v.v.u.strval = hlastrdup2( "" );

			_else

				v.v.u.strval = hlastrdup2( $<cls.sym>3->StaticName );

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tString, 
				&string_ste,
				YYS &v
			);
			_here;
		}
	;




 /*
 ** @lex( id )
 **
 **	Returns the lex level of the specified identifier.
 */

SymTblFunc:	
		symLexTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;


			/*
			** @lex requires a single, defined, identifier as
			** a parameter.
			*/

			_here;
			ClrConst
			( 
				YYS &v, 
				tInt32, 
				&int32_ste
			);
			_if(( $<cls.cls>3 & cfy_SingleID ) == 0 )

				yyerror( "@lex requires a single ID as a parameter" );

			_elseif
			( 
					$<cls.sym>3 == NULL 
				||	($<cls.cls>3 & cfy_Undefined) != 0
			)

				yyerror( "@lex requires a single (defined) ID parameter" );
				v.v.u.unsval = 0;

			_else

				v.v.u.unsval = $<cls.sym>3->LexLevel;

			_endif

			SetConst
			( 
				YYS &$<v>$, 
				tInt32, 
				&int32_ste,
				YYS &v
			);
			_here;
		}
	;



 /*
 ** @IsExternal( id )
 **
 **	Returns the IsExternal flag for the specified identifier.
 */

SymTblFunc:	
		symIsExternalTkn	/* $1 */ 
		Lparen 				/* $2 */
		Classify			/* $3 */
		Rparen				/* $4 */
		{					/* $6 */

			union YYSTYPE v;


			/*
			** @IsExternal requires a single, defined, identifier as
			** a parameter.
			*/

			_here;
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			_if(( $<cls.cls>3 & cfy_SingleID ) == 0 )

				yyerror( "@IsExternal requires a single ID as a parameter" );

			_elseif
			( 
					$<cls.sym>3 == NULL 
				||	($<cls.cls>3 & cfy_Undefined) != 0
			)

				yyerror
				( 
					"@IsExternal requires a single (defined) ID parameter" 
				);
				v.v.u.unsval = 0;

			_else

				v.v.u.unsval = $<cls.sym>3->IsExternal;

			_endif

			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v
			);
			_here;
		}
	;



 /*
 ** @arity( id )
 **
 **	Returns the arity (number of dimensions) for the specified symbol.
 ** Non-array and undefined symbols have arity zero.
 */
    
SymTblFunc:	
		symArityTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;


			/*
			** Undefined objects have arity zero.
			*/

			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);
			_if
			( 
					$<cls.sym>3 != NULL 
				&&	($<cls.cls>3 & cfy_Undefined) == 0
			)

				v.v.u.unsval = $<cls.sym>3->Arity;

			_elseif( $<cls.type>3 != NULL )

				v.v.u.unsval = $<cls.type>3->Arity;

			_else

				v.v.u.unsval = 0;

			_endif

			SetConst
			( 
				YYS &$<v>$, 
				tUns32, 
				&uns32_ste,
				YYS &v
			);
			_here;
		}
	;


 /*
 ** @dim( ArrayID )
 **
 **	Returns a single dimension array whose elements contain the bounds
 ** of each of the array dimensions of the specified symbol.
 */

SymTblFunc:	
		symDimTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);

			/*
			** Set up some common synthesized attribute return values.
			*/


			/*
			** Undefined symbols will have a dimension array
			** containing a single zero element.
			*/

			_if
			( 
					$<cls.sym>3 != NULL 
				&&	( $<cls.cls>3 & cfy_Undefined ) == 0 
				&&	$<cls.sym>3->pType == tArray 
			)
									 
				$<v.Name>$ = "";
				$<v.TrueName>$ = "";
				$<v.SymClass>$ = cConstant;
				$<v.pType>$ = tArray;
				$<v.Type>$ = &uns32_ste;
				$<v.ObjectSize>$ = 0;
				$<v.Offset>$ = 0;
				$<v.StaticName>$ = NULL;
				$<v.LexLevel>$ = CurLexLevel;
				$<v.Arity>$ = 1;
				$<v.Dimensions>$ = malloc2( sizeof( int ));
				*$<v.Dimensions>$ = $<cls.sym>3->Arity;
				$<v.NumElements>$ = $<cls.sym>3->Arity;
				$<v.Base>$ = NULL;
				$<v.Fields>$ = NULL;
				$<v.FieldCnt>$ = 0;

				$<v.u.ArrayOfValues>$ = 
					malloc2
					( 
						$<cls.sym>3->Arity * sizeof( struct SymNode )
					);
				
				_for( int i=0, i < $<cls.sym>3->Arity, ++i )

					v.v.u.unsval = $<cls.sym>3->Dimensions[i];
					SetConst
					( 
						YYS &$<v.u.ArrayOfValues>$[i], 
						tUns32, 
						&uns32_ste,
						YYS &v
					);

				_endfor

			_elseif
			( 
					$<cls.type>3 != NULL 
				&&	$<cls.type>3->pType == tArray 
			)
									 
				$<v.Name>$ = "";
				$<v.TrueName>$ = "";
				$<v.SymClass>$ = cConstant;
				$<v.pType>$ = tArray;
				$<v.Type>$ = &uns32_ste;
				$<v.ObjectSize>$ = 0;
				$<v.Offset>$ = 0;
				$<v.StaticName>$ = NULL;
				$<v.LexLevel>$ = CurLexLevel;
				$<v.Arity>$ = 1;
				$<v.Dimensions>$ = malloc2( sizeof( int ));
				*$<v.Dimensions>$ = $<cls.type>3->Arity;
				$<v.NumElements>$ = $<cls.type>3->Arity;
				$<v.Base>$ = NULL;
				$<v.Fields>$ = NULL;
				$<v.FieldCnt>$ = 0;

				$<v.u.ArrayOfValues>$ = 
					malloc2
					( 
						$<cls.type>3->Arity * sizeof( struct SymNode )
					);
				
				assert( $<v.u.ArrayOfValues>$ != NULL );
				_for( int i=0, i < $<cls.type>3->Arity, ++i )

					v.v.u.unsval = $<cls.type>3->Dimensions[i];
					SetConst
					( 
						YYS &$<v.u.ArrayOfValues>$[i], 
						tUns32, 
						&uns32_ste,
						YYS &v
					);

				_endfor


			_else
									 
				$<v.Name>$ = "";
				$<v.TrueName>$ = "";
				$<v.SymClass>$ = cConstant;
				$<v.pType>$ = tArray;
				$<v.Type>$ = &uns32_ste;
				$<v.ObjectSize>$ = 0;
				$<v.Offset>$ = 0;
				$<v.StaticName>$ = NULL;
				$<v.LexLevel>$ = CurLexLevel;
				$<v.Arity>$ = 1;
				$<v.Dimensions>$ = malloc2( sizeof( int ));
				*$<v.Dimensions>$ = 1;
				$<v.NumElements>$ = 1;
				$<v.Base>$ = NULL;
				$<v.Fields>$ = NULL;
				$<v.FieldCnt>$ = 0;

				$<v.u.ArrayOfValues>$ = malloc2( sizeof( struct SymNode ));

				$<v.u.ArrayOfValues>$->SymClass = cConstant;
				$<v.u.ArrayOfValues>$->pType = tUns32;
				$<v.u.ArrayOfValues>$->Type = &uns32_ste;
				$<v.u.ArrayOfValues>$->ObjectSize = 4;
				$<v.u.ArrayOfValues>$->Arity = 0;
				$<v.u.ArrayOfValues>$->Dimensions = NULL;
				$<v.u.ArrayOfValues>$->NumElements = 0;
				$<v.u.ArrayOfValues>$->Base = NULL;
				$<v.u.ArrayOfValues>$->Fields = NULL;
				$<v.u.ArrayOfValues>$->FieldCnt = 0;
				$<v.u.ArrayOfValues>$->u.unsval = 0;

			_endif
			_here;
		}
	;


 /*
 ** @dim( ArrayID)[ ConstExpr ]
 **
 ** Returns the specified dimension value.
 */

SymTblFunc:	
		symDimTkn			/* $1 */ 
		Lparen 				/* $2 */
		Classify			/* $3 */
		Rparen 				/* $4 */
		'[' 				/* $5 */
		ConstOnlyExpr 		/* $6 */
		Rbrack				/* $7 */
		{					/* $8 */

			struct SymNode *s;

			/*
			** Set up some common synthesized attribute return values.
			*/


			/*
			** Undefined symbols will return zero.
			*/

			_here;
			ClrConst
			( 
				YYS &$<v>$, 
				tUns32, 
				&uns32_ste
			);
			_if
			( 
					( $<cls.cls>3 & cfy_Undefined ) == 0
				&&	$<cls.sym>3 != NULL 
				&&	$<cls.sym>3->pType == tArray 
			)

				s = $<cls.sym>3;

			_elseif
			( 
					$<cls.type>3 != NULL 
				&&	$<cls.type>3->pType == tArray 
			)
				s = $<cls.type>3;

			_else

				s = NULL;
			
			_endif


			_if( !IsNumber( $<v.pType>6  ) || numBits( YYS &$<v>6 ) > 32 )

				yyerror( "Type mismatch in array index expression" );

			_else


				_if( s == NULL )
										 
					$<v.Name>$ = "";
					$<v.TrueName>$ = "";
					$<v.SymClass>$ = cConstant;
					$<v.pType>$ = tUns32;
					$<v.Type>$ = &uns32_ste;
					$<v.ObjectSize>$ = 0;
					$<v.Offset>$ = 0;
					$<v.StaticName>$ = NULL;
					$<v.LexLevel>$ = CurLexLevel;
					$<v.Arity>$ = 0;
					$<v.Dimensions>$ = NULL;
					$<v.NumElements>$ = 0;
					$<v.Base>$ = NULL;
					$<v.Fields>$ = NULL;
					$<v.FieldCnt>$ = 0;

					$<v.u.unsval>$ = 0;

				_elseif( $<v.u.unsval>6 > s->Arity )

					yyerror( "Array index value is out of range" );

					$<v.Name>$ = "";
					$<v.TrueName>$ = "";
					$<v.SymClass>$ = cConstant;
					$<v.pType>$ = tUns32;
					$<v.Type>$ = &uns32_ste;
					$<v.ObjectSize>$ = 0;
					$<v.Offset>$ = 0;
					$<v.StaticName>$ = NULL;
					$<v.LexLevel>$ = CurLexLevel;
					$<v.Arity>$ = 0;
					$<v.Dimensions>$ = NULL;
					$<v.NumElements>$ = 0;
					$<v.Base>$ = NULL;
					$<v.Fields>$ = NULL;
					$<v.FieldCnt>$ = 0;

					$<v.u.unsval>$ = 0;

				_else

					$<v.Name>$ = "";
					$<v.TrueName>$ = "";
					$<v.SymClass>$ = cConstant;
					$<v.pType>$ = tUns32;
					$<v.Type>$ = &uns32_ste;
					$<v.ObjectSize>$ = 0;
					$<v.Offset>$ = 0;
					$<v.StaticName>$ = NULL;
					$<v.LexLevel>$ = CurLexLevel;
					$<v.Arity>$ = 0;
					$<v.Dimensions>$ = NULL;
					$<v.NumElements>$ = 0;
					$<v.Base>$ = NULL;
					$<v.Fields>$ = NULL;
					$<v.FieldCnt>$ = 0;

					$<v.u.unsval>$ = s->Dimensions[ $<v.u.unsval>6 ];
					
				_endif

			_endif
			_here;
		}
	;



/*
** @NumElements( ID )
**
**	This function returns the total number of elements in
**	the array specified.
*/

SymTblFunc:	
		symNumelementsTkn	/* $1 */ 
		Lparen 				/* $2 */
		Classify			/* $3 */
		Rparen				/* $4 */
		{					/* $5 */

			union	YYSTYPE	v;
			struct	SymNode	*s;

			/*
			** Because we have to allow for undefined IDs,
			** the following code bumps the actual pType value
			** up by one (undefined IDs have a pType of zero).
			*/
			
			_here;
			ClrConst
			( 
				YYS &v, 
				tUns32, 
				&uns32_ste
			);
			_if
			( 
					( $<cls.cls>3 & cfy_Undefined ) == 0
				&&	$<cls.sym>3 != NULL 
				&&	$<cls.sym>3->pType == tArray 
			)

				s = $<cls.sym>3;

			_elseif
			( 
					$<cls.type>3 != NULL 
				&&	$<cls.type>3->pType == tArray 
			)
				s = $<cls.type>3;

			_else

				s = NULL;
			
			_endif


			_if
			( 
					$<cls.arity>3 == 0 
				||	s == NULL
			)

				yyerror( "Expected an array expression" );
				v.v.u.unsval =  0;

			_else

				v.v.u.unsval = s->NumElements;

			_endif
			SetConst
			( 

				YYS &$<v>$, 
				tUns32, 
				&uns32_ste,
				YYS &v 
			);
			_here;
		}
	;
	
	
	
	
 /*
 ** @IsConst( expr )
 **
 **	This function returns the pType (primitive type) of a symbol.
 ** Actually, it returns that value plus one, so zero can be returned
 ** for undefined symbols or symbols that don't have a pType.
 */

SymTblFunc:
   		symIsConstTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify 		/* $3 */
		Rparen			/* $4 */ 
		{				/* $5 */

			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			v.v.u.unsval = ( $<cls.cls>3 & cfy_ConstExpr ) != 0;
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;


	

	


	

	
 /*
 ** @IsReg( reg )
 **
 **	This function returns true if the parameter is a register.
 **
 **	@IsReg8( reg ), @IsReg16( reg ), @IsReg32( reg ):
 **
 **	These return true if the register is of the appropriate size.
 */

SymTblFunc:
	 	symIsRegTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify 		/* $3 */
		Rparen			/* $4 */ 
		{				/* $5 */

			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			v.v.u.unsval = ( $<cls.cls>3 & cfy_Reg) != 0;
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;





SymTblFunc:
	 	symIsReg8Tkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify 		/* $3 */
		Rparen			/* $4 */ 
		{				/* $5 */


			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			v.v.u.unsval = ( $<cls.cls>3 & cfy_Reg8) != 0;
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;





SymTblFunc:
	 	symIsReg16Tkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify 		/* $3 */
		Rparen			/* $4 */ 
		{				/* $5 */


			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			v.v.u.unsval = ( $<cls.cls>3 & cfy_Reg16) != 0;
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;





SymTblFunc:
	 	symIsReg32Tkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify 		/* $3 */
		Rparen			/* $4 */ 
		{				/* $5 */


			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			v.v.u.unsval = ( $<cls.cls>3 & cfy_Reg32) != 0;
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;




SymTblFunc:
	 	symIsfRegTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify 		/* $3 */
		Rparen			/* $4 */ 
		{				/* $5 */


			union YYSTYPE v;

			_here;
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			v.v.u.unsval = ( $<cls.cls>3 & cfy_fpReg) != 0;
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;





	
 /*
 ** @IsClass( expr )
 **
 **	This function returns true if the expression has SymClass "cClass".
 */

SymTblFunc:
	 	symIsClassTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			/*
			** If it's undefined or not a class, return false.
			** If its not an identifier, print an error.
			*/
				
			_here;		
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			_if( ( $<cls.cls>3 & cfy_SingleID ) != 0 )

				v.v.u.unsval = 
						( $<cls.cls>3 & cfy_Undefined ) == 0
					&&	( $<cls.cls>3 & cfy_SingleID ) != 0
					&&	$<cls.sym>3 != NULL
					&&	$<cls.sym>3->pType == tClass;
				
			_else
			
				v.v.u.unsval = 0;
					
			_endif

			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;



	






	
 /*
 ** @IsMem( expr )
 **
 **	This function returns true if the parameter is a memory operand.
 */

SymTblFunc:
	 	symIsMemTkn		/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			/*
			** If it's a memory operand, return true.
			*/

			_here;			
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			v.v.u.unsval = ( $<cls.cls>3 & cfy_MemoryExpr ) != 0;
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;



	

SymTblFunc:
	 	symIsTypeTkn	/* $1 */ 
		Lparen 			/* $2 */
		Classify		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			union YYSTYPE v;

			/*
			** If it's a Type ID, return true.
			*/
			
			_here;				
			ClrConst
			( 
				YYS &v, 
				tBoolean, 
				&boolean_ste
			);
			_if(( $<cls.cls>3 & cfy_SingleID ) == 0 )		

				yyerror( "@IsType requires a single ID parameter" );

			_else

				v.v.u.unsval =
						$<cls.sym>3 != NULL
					&&	$<cls.sym>3->SymClass == cType;

			_endif
			SetConst
			( 
				YYS &$<v>$, 
				tBoolean, 
				&boolean_ste,
				YYS &v 
			);
			_here;
		}
	;



	






hlaSingleIDSVal:
		{
			_here;
			$<dotName.Sym>$ = $<s>-1;
			$<dotName.Disp>$ = 0;
			$<dotName.StaticName>$ =
				_ifx( $<s>-1 == NULL, NULL, $<s>-1->StaticName );
		}
	;


	


/*
** Process the fields of a namespace, union, record, or class here.
*/


hlaFields:

		SingleFieldName
		{
			_here;
			memcpy( &$<dotName>$, &$<dotName>1, sizeof( union YYSTYPE ));
			_here;
		}
	;

/*
** Handle a chain of dot-fieldnames here.  This code
** handles all but the last identifier in the chain of names.
*/

hlaFields:
		PtAtHLAFields		/* $1 */
		'.'					/* $2 */
		SimpleID			/* $3 */
		hlaLookup			/* $4 */
		hlaFields			/* $5 */
		{					/* $6 */
			char *name;

			_here;

			assert( $<dotName.FullName>5 != NULL );
			assert( $<s>3 != NULL );
			_if( $<s>1 == NULL || $<dotName.Sym>5 == NULL )

				/*
				** If the symbol to the left of ArbID
				** is undefined, then the whole thing
				** is undefined.  Likewise, if any symbols appearing
				** to the right of ArbID are undefined, then
				** the whole thing is undefined.  Handle that here.
				*/


				name =	malloc2
						( 
								strlen( $<idStr>3 ) 
							+	strlen( $<dotName.FullName>5 )
							+	2 
						);

				name[0] = '.';
				strcpy( name+1, $<idStr>3 );
				strcat( name+1, $<dotName.FullName>5 );

				$<dotName.Sym>$ = NULL;
				$<dotName.Disp>$ = 0;
				$<dotName.StaticName>$ = NULL;

			_else /* Names to the left and right of ArbID are defined */

				_if( $<dotName.Sym>4 != NULL )

					/*
					** Now we know that the name in the middle is defined.
					** This is somewhat of a bogus test since the stuff
					** to the right of ArbID cannot be defined if ArbID
					** is not defined.
					*/

					$<dotName.Sym>$ = $<dotName.Sym>5;
					$<dotName.FullName>$ = 
						malloc2
						( 
								strlen( $<dotName.FullName>5 )
							+	strlen( $<idStr>3 ) 
							+	2 
						);

					$<dotName.FullName>$[0] = '.';
					strcpy(	$<dotName.FullName>$+1, $<idStr>3 );
					strcat( $<dotName.FullName>$+1, $<dotName.FullName>5 );

					/*
					** If the stuff to the right of ArbID has a static
					** name, then this becomes the static name and we
					** also inherit the Disp field from the right hand stuff.  
					**
					** If the stuff to the right of ArbID does not have
					** a static name and ArbID does, then ArbID's StaticName
					** is returned along with the right hand side's Disp
					** field.
					**
					** If neither the stuff to the right nor ArbID has a
					** valid StaticName field, return NULL for StaticName
					** and return the sum of their displacements.
					*/

					_if
					( 
							$<dotName.StaticName>5 != NULL 
					)

						$<dotName.StaticName>$ = $<dotName.StaticName>5;
						$<dotName.Disp>$ = $<dotName.Disp>5;

					_elseif
					( 
							$<dotName.StaticName>4 != NULL 
					)

						$<dotName.StaticName>$ = $<dotName.StaticName>4;
						$<dotName.Disp>$ = $<dotName.Disp>5;

					_else

						$<dotName.StaticName>$ = NULL;
						$<dotName.Disp>$ = 
							$<dotName.Disp>4 + $<dotName.Disp>5;

					_endif

				_else	/* Never happens, but just in case of weirdness */

					assert( 0 );

				_endif

			_endif

			free2( vss $<idStr>3 );
			free2( vss $<dotName.FullName>5 );
			_here;
		}
	;
	
	
		/*
		** Handle the only or the last fieldname in a chain
		** of field names.
		*/

SingleFieldName:
		PtAtHLAFields
		'.'
		SimpleID
		{
			_here;
			_if( $<s>1 == NULL )

				/*
				** If the symbol to the left of the "."
				** is undefined, then the whole thing
				** is undefined.  Handle that here.
				*/

				$<dotName.Sym>$ = NULL;
				$<dotName.FullName>$ = hlastrdup2( $<idStr>3 );

				$<dotName.StaticName>$ = NULL;
				$<dotName.Disp>$ = 0;

			_else

				$<dotName.Sym>$ = lookupin( $<idStr>3, $<s>1 );
				_if( $<dotName.Sym>$ != NULL )

					/*
					** So far, so good.  The symbols on either side of
					** the "." are both defined.  Set the return
					** value as the union of these two items.
					*/									   

					$<dotName.FullName>$ = malloc2( strlen( $<idStr>3 ) + 2 );
					$<dotName.FullName>$[0] = '.';
					strcpy(	&$<dotName.FullName>$[1], $<idStr>3 );

					/*
					** If the ArbID has a static name, that's the
					** static name we return.  Otherwise, we just 
					** return ArbID's displacement.
					*/

					_if( IsStaticClass( $<dotName.Sym>$->SymClass ))

						$<dotName.Disp>$ = 0;
						$<dotName.StaticName>$ = $<dotName.Sym>$->StaticName;

					_else
					
						$<dotName.Disp>$ = $<dotName.Sym>$->Offset;
						$<dotName.StaticName>$ = NULL;

					_endif

				_else

					/*
					** If the symbol on the right of the "." is undefined,
					** then the whole symbol is undefined.  Handle that here.
					*/

					$<dotName.Sym>$ = NULL;
					$<dotName.FullName>$ = hlastrdup2( $<idStr>3 );
					$<dotName.StaticName>$ = NULL;
					$<dotName.Disp>$ = 0;

				_endif

			_endif
			free2( vss $<idStr>3 );
			_here;
		}
	;
	
	
	
	


	/*
	** This production points $<dotName.Sym>$ at the fields of the
	** symbol specified by $<dotName.Sym>0.
	*/

PtAtHLAFields:
		{
			_here;
			_if( $<dotName.Sym>0 == NULL )

				$<s>$ = NULL;

			_elseif( $<dotName.Sym>0->pType == tPointer )

				assert( $<dotName.Sym>0->Base != NULL );
				$<s>$ = $<dotName.Sym>0->Base->Fields;
				
			_else

				$<s>$ = 
					_ifx
					(
						$<dotName.Sym>0->Type != NULL,
						$<dotName.Sym>0->Type->Fields, 
						$<dotName.Sym>0->Fields
					);

			_endif
			_here;
		}
	;


 	/*
	** hlaLookup-
	**
	**	This production looks up the $<idStr>0 symbol using
	**	the symbol table pointed at by $<s>-2.
	**
	**	This is used to lookup identifiers in the middle of
	**	a dot-name list.
	*/

hlaLookup:
		{
			_here;
			$<dotName.Sym>$ = 
				lookupin
				( 
					$<idStr>0, 
					$<s>-2 
				);


			_if( $<dotName.Sym>$ != NULL )

				$<dotName.StaticName>$ = $<dotName.Sym>$->StaticName;
				_if( $<dotName.StaticName>$ == NULL )

					$<dotName.Disp>$ = $<dotName.Sym>$->Offset;

				_else

					$<dotName.Disp>$ = 0;

				_endif

			_else

				$<dotName.StaticName>$ = NULL;
				$<dotName.Disp>$ = 0;

			_endif
			$<dotName.FullName>$ = $<idStr>0;
			_here;
		}
	;








/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/***********************                            **************************/
/***********************                            **************************/
/***********************                            **************************/
/***********************        S t m t s           **************************/
/***********************                            **************************/
/***********************                            **************************/
/***********************                            **************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

/****************************************************
/*													*/
/* Stmts-											*/
/*													*/
/* Handle the statements down here.					*/
/*													*/
/****************************************************/



Stmts: /* Empty */
	|	Stmts		/* $1 */ 
		TraceIt		/* $2 */ 
		OneStmt		/* $3 */ 
		{ 
			_here;
			_if( $<returns>3 != NULL )
			 
				free2( vss $<returns>3 ); 

			_endif
			_here; 
		}
	;


OneStmt:
	
		/*
		** Handle data declarations in the middle of the code here.
		*/

		SavePosn			/* $1 */
		TypeIDNotThunk 		/* $2 */
		{ 					/* $3 */
			_here;
			$<s>$ = $<s>2; 
			_here;
		} 
		ConstantList		/* $4 */ 
		Semicolon			/* $5 */
		{					/* $6 */
			_here;
			$<returns>$ = NULL;
			(void) $<s>3;	// shut up bison
			_here;
		}
	;
	
	

Colon2:
		':'
		

	|	SetTempNoErrors
		error
		{
			char msg[256];

			_here;
			sprintf
			( 
				msg,
				"Expected ':', encountered '%s'\n"
				"(Possible undefined ID '%s')",
				yytext,
				$<idStr>0
			);
			yyerror( msg );
			_here;
		}
	;


		


  /*
  ** Handle a label without a FORWARD attachment.
  */

OneStmt:
		SavePosn			/* $1 */ 
		UndefinedID 		/* $2 */
		Colon2				/* $3 */
		{
			char 					*StaticName;
			char 					*sn;
			struct FwdRefLabelType	*flist;
			struct FwdRefLabelType	**ptr;
			struct StaticListType	*sList;

			assert( $<idStr>2 != NULL );

			/*
			** First, let's see if there is already a reference
			** to this particular identifier so we can use the
			** existing StaticName.  Don't use predefined labels
			** at a lower lex level in this check!
			*/

			_here;
			flist = FwdLabelsList;
			ptr = &FwdLabelsList;
			_while( flist != NULL && flist->lexLevel >= CurLexLevel )

				_breakif( _streq( $<idStr>2, flist->label ));
				ptr = &flist->Next;
				flist = flist->Next;

			_endwhile

			_if( flist != NULL )

				/*
				** It's defined here, so may as well set the
				** referenced flag
				*/
				
				flist->referenced = 1;
				
				/*
				** Okay, we've found a forward referenced
				** label, so use its StaticName entry.
				*/

				sn = flist->StaticName;

				/*
				** If the label was declared external, emit
				** a public declaration for the label.
				*/
				
				_if( flist->isExternal )
				
					EmitPublic( sn );
					
				_endif
				

				/*
				** Remove the label from the forward
				** reference list.
				*/

				*ptr = flist->Next;
				free2( vss flist->label );
				free2( vss flist );

			_else
			
				// See if this symbol is in the static list:
				
				sList = searchStatic( $<idStr>2 );
				_if( sList != NULL )
			
					sn = hlastrdup( sList->StaticName );
					
					// As we are emitting the label at this point,
					// "fix" this symbol.
					
					sList->Fixed = 1;
			
				_else
					
					// This is the first occurrence of this label,
					// so create a new StaticName for it.
					
					StaticName = malloc2( strlen( $<idStr>2 ) + 16);
					sprintf( StaticName, "%s" sympost "%d", $<idStr>2, LblCntr++ );
					sn = hlastrdup2( StaticName );

				_endif

			_endif
			InsertSym
			( 
				$<idStr>2, 
				NULL,
				tLabel, 
				cLabel, 
				0,					/* Arity 		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				0,					/* ObjectSize	*/
				0,					/* Offset		*/
				sn,					/* Static Name	*/
				NULL,				/* Base			*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);

			/*
			** Set the Type field to non-NULL to indicate
			** that it's already defined.
			*/

			SymbolTable->Type = SymbolTable;
			NewLn();
			EmitStmtLbl( sn );
				
			$<returns>$ = NULL;
			_here;
		}
	;








OneStmt:
		SavePosn			/* $1 */ 
		UndefID		 		/* $2 */
		coloncolonTkn		/* $3 */
		{
			char 					*StaticName;
			char 					*sn;
			struct FwdRefLabelType	*flist;
			struct FwdRefLabelType	**ptr;
			struct StaticListType	*sList;
			struct SymNode			*saveST;
			struct SymNode			*link;

			assert( $<idStr>2 != NULL );

			/*
			** First, let's see if there is already a reference
			** to this particular identifier so we can use the
			** existing StaticName.
			*/

			_here;
			flist = FwdLabelsList;
			ptr = &FwdLabelsList;
			_while( flist != NULL )

				_breakif( _streq( $<idStr>2, flist->label ));
				ptr = &flist->Next;
				flist = flist->Next;

			_endwhile

			_if( flist != NULL )

				flist->referenced = 1;	// Defined here, so set referenced.
				
				/*
				** Okay, we've found a forward referenced
				** label, so use its StaticName entry.
				*/

				sn = flist->StaticName;
				
				/*
				** If the label was declared external, emit
				** a public declaration for the label.
				*/
				
				_if( flist->isExternal )
				
					EmitPublic( sn );
					
				_endif
				

				/*
				** Remove the label from the forward
				** reference list.
				*/

				*ptr = flist->Next;
				free2( vss flist->label );
				free2( vss flist );

			_else
			
				// See if this symbol is in the static list:
				
				sList = searchStatic( $<idStr>2 );
				_if( sList != NULL )
			
					sn = hlastrdup( sList->StaticName );
					sList->Fixed = 1;	// Because we're defining the symbol.
			
				_else
					
					// This is the first occurrence of this label,
					// so create a new StaticName for it.
					
					StaticName = malloc2( strlen( $<idStr>2 ) + 16);
					sprintf( StaticName, "%s" sympost "%d", $<idStr>2, LblCntr++ );
					sn = hlastrdup2( StaticName );
					
				_endif

			_endif
			
			// We need to insert this symbol at lex level zero because it's
			// a global symbol. The easiest way to do this is to link it into
			// the symbol table at the point where "true" and "false" are
			// defined.
			
			saveST = SymbolTable;
			SymbolTable = false_ste.Next;
			
			InsertSym
			( 
				$<idStr>2, 
				NULL,
				tLabel, 
				cLabel, 
				0,					/* Arity 		*/
				NULL,				/* Dimensions	*/
				0, 					/* NumElements	*/
				NULL,				/* Value		*/
				0,					/* ObjectSize	*/
				0,					/* Offset		*/
				sn,					/* Static Name	*/
				NULL,				/* Base			*/
				NULL,				/* Fields		*/
				0					/* FieldCnt		*/
			);
			
			false_ste.Next = SymbolTable;

			/*
			** Set the Type field to non-NULL to indicate
			** that it's already defined..
			*/

			SymbolTable->Type = SymbolTable;
			NewLn();
			EmitGlobalStmtLbl( sn );
			

			SymbolTable = saveST;
			
			$<returns>$ = NULL;
			_here;
		}
	;






   /*
   ** Handle duplicate label definitions and global public defs here.
   */

OneStmt:
		SavePosn		/* $1 */ 
		AnyLabelID 		/* $2 */
		coloncolonTkn	/* $3 */
		{
			_here;
			_if( $<s>2->Type != NULL )

				char msg[256];

				sprintf
				( 
					msg,
					"Duplicate Label Definition (%s)", 
					$<s>2->TrueName 
				);
				yyerror( msg );

			_else

				/*
				** If we just defined it, set the Type field
				** to a non-NULL value to indicate this.
				*/

				$<s>2->Type = $<s>2;
				_if( $<s>2->IsExternal )
				
					EmitPublic( $<s>2->StaticName );
					NewLn();
					EmitGlobalStmtLbl( $<s>2->StaticName );
					
				_endif
				$<s>2->IsExternal = 0;

			_endif
			$<returns>$ = NULL;
			_here;
			
		}
	;

		
		
		/*
		** Handle duplicate label definitions and public defs here.
		*/

OneStmt:
		SavePosn		/* $1 */ 
		LocalLabelID 	/* $2 */
		Colon			/* $3 */
		{
			_here;
			_if( $<s>2->Type != NULL )

				char msg[256];

				sprintf
				( 
					msg,
					"Duplicate Label Definition (%s)", 
					$<s>2->TrueName 
				);
				yyerror( msg );

			_else

				/*
				** If we just defined it, set the Type field
				** to a non-NULL value to indicate this.
				*/

				$<s>2->Type = $<s>2;
				_if( $<s>2->IsExternal )
				
					EmitPublic( $<s>2->StaticName );
					NewLn();
					EmitStmtLbl( $<s>2->StaticName );
					
				_endif
				$<s>2->IsExternal = 0;

			_endif
			$<returns>$ = NULL;
			_here;
			
		}
	; 
	
	
	/*
	** Handle segment overrides here
	*/
	
OneStmt:
		csTkn					/* $1 */
		':'						/* $2 */
		{						/* $3 */
			_here;
			cseg_prefix();
			$<returns>$ = NULL;
			_here;
		}
	;
	
OneStmt:
		dsTkn					/* $1 */
		':'						/* $2 */
		{						/* $3 */
			_here;
			dseg_prefix();
			$<returns>$ = NULL;
			_here;
		}
	;
	
OneStmt:
		esTkn					/* $1 */
		':'						/* $2 */
		{						/* $3 */
			_here;
			eseg_prefix();
			$<returns>$ = NULL;
			_here;
		}
	;
	
OneStmt:
		fsTkn					/* $1 */
		':'						/* $2 */
		{						/* $3 */
			_here;
			fseg_prefix();
			$<returns>$ = NULL;
			_here;
		}
	;
	
OneStmt:
		gsTkn					/* $1 */
		':'						/* $2 */
		{						/* $3 */
			_here;
			gseg_prefix();
			$<returns>$ = NULL;
			_here;
		}
	;
	
OneStmt:
		ssTkn					/* $1 */
		':'						/* $2 */
		{						/* $3 */
			_here;
			sseg_prefix();
			$<returns>$ = NULL;
			_here;
		}
	;
	
	
	
	
		
		/*
		** Handle the empty statement here.
		*/

OneStmt:
		';'
		{
			_here;
			$<returns>$ = NULL;
		}
	;

OneStmt:
		SavePosn	/* $1 */
		SingleStmt 	/* $2 */
		Semicolon	/* $3 */
		{ 			/* $4 */
			_here;
			$<returns>$ = $<returns>2; 
			_here;
		}
	;


SavePosn:
		{
			_here;
			StartOfStmt = asmBuf->offset;
		}
	;



 /*
 ** TraceStmt-  If the TraceFlag variable is true, then
 ** emit some code to provide a trace of this statement at
 ** run time.
 */
 
		
TraceIt:
		{
			int		fnLength;
			int		fIndex;
			char	sn[ 256 ];
			char	*fName;
			static struct _fileList
			{
				struct _fileList *next;
				char *filename;
			}
				*fileList = NULL,
				*cursor;
			
			extern char *IncFileNameStack[];
			extern int IncSP;
			
				
			_here;
			_if( TraceFlag )
			
				static unsigned char EmittedTrace = 0;
			
				
				_if( BufSP >= 0 )
				
					fName = BufferStack[ BufSP ].FileName;
					
				_else
				
					fName = FileName;
					
				_endif
				
				cursor = fileList; 
				fIndex = 0;
				_while( cursor != NULL )
				
					_breakif( _streq( fName, cursor->filename ));
					cursor = cursor->next;
					++fIndex;
					
				_endwhile
				sprintf( sn, "filename_%d" sympost, fIndex );
				_if( cursor == NULL )
				
					cursor = malloc2( sizeof( struct _fileList ));
					cursor->next = fileList;
					cursor->filename = hlastrdup2( fName );
					fileList = cursor;
					EmitLabelledString( fName, sn );
					
				_endif
				PushStaticAdrs( sn );
				Pushd( LineCnt );
				_if( !EmittedTrace )
				
					EmitImmExtern( "_traceLine_", tLabel ); 
					
				_endif
				EmitCallLabel( "_traceLine_" );
//				Emit1L( "call", "_traceLine_" );
					
								
			_endif
			_here;
		}
	;
	
	
	


 /*
 ** The following allows the user to arbitrarily group a sequence
 ** of statements together for use as a parameter.
 */


StmtSequence:
		OneStmt
		{
			_here;
			$<returns>$ = $<returns>1;
		}

	|	StmtSequence	/* $1 */
		TraceIt			/* $2 */
		OneStmt			/* $3 */
		{
			_here;
			_if( $<returns>1 != NULL )

				free2( vss $<returns>1 );

			_endif
			$<returns>$ = $<returns>3;
			_here;
		}
	;



 /*
 ** Special production that allows us to nest statements inside
 ** other statements (e.g., ADD( MOV( 0, EAX ), EBX ); ).
 **
 **	This code processes the statement and then feeds the statement's
 ** return string back to the lexer so it can reuse the return value
 ** in place of that statement.
 */


fstmt:
		SingleStmt
		{
			_here;
			_if( $<returns>1 != NULL )
			
				_if( *$<returns>1 != '\0' )
			
					delayCollect = 1;
					PushBackStr( "\xDD" );	// Don't capture this text!
					PushBackStr( $<returns>1 );
				
				_endif
				free2( vss $<returns>1 );

			_endif
			_here;
		}
	;




 /*
 ** Here are some productions to merge the fstmt object
 ** with a ton of things that fstmt normally precedes.
 ** This dramatically reduces the number of productions
 ** in the grammar.
 */


 /*
 ** fRegister-  Register with an optional fstmt.
 */


fedxeax:
		edxeaxTkn
		{
			_here;
			$<reg.encoding>$ = 0; // Default to EAX
			$<reg.Size>$ = 8;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tQWord;
			$<reg.Type>$ = &qword_ste;
		}

	|	fstmt
		edxeaxTkn
		{
			_here;
			$<reg.encoding>$ = 0; // Default to EAX
			$<reg.Size>$ = 8;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tQWord;
			$<reg.Type>$ = &qword_ste;
		}
	;

fdxax:
		dxaxTkn
		{
			_here;
			$<reg.encoding>$ = 0; // Default to EAX
			$<reg.Size>$ = 4;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tDWord;
			$<reg.Type>$ = &dword_ste;
		}

	|	fstmt
		dxaxTkn
		{
			_here;
			$<reg.encoding>$ = 0; // Default to EAX
			$<reg.Size>$ = 4;
			$<reg.IsSigned>$ = 0;
			$<reg.pType>$ = tDWord;
			$<reg.Type>$ = &dword_ste;
		}
	;


fMemory:
		Memory
		{
			_here;
			$<adrs>$ = $<adrs>1;
		}

	|	fstmt
		Memory
		{
			_here;
			$<adrs>$ = $<adrs>2;
		}
	;


fMemoryDest:
		MemoryDest
		{
			_here;
			$<adrs>$ = $<adrs>1;
		}

	|	fstmt
		MemoryDest
		{
			_here;
			$<adrs>$ = $<adrs>2;
		}
	;

fAnonMem:
		AnonMem
		{
			$<adrs>$ = $<adrs>1;
		}

	|	fstmt
		AnonMem
		{
			_here;
			$<adrs>$ = $<adrs>2;
		}
	;
 
fEitherMemDest:
		fMemoryDest
		{
			_here;
			$<adrs>$ = $<adrs>1;
		}

	|	fAnonMem
		{
			_here;
			$<adrs>$ = $<adrs>1;
			$<adrs.Size>$ = 0;
			$<adrs.Type>$ = &byte_ste;
			$<adrs.pType>$ = tByte;
			$<adrs.Sym>$->Type = &byte_ste;
			$<adrs.Sym>$->pType = tByte;
		}
	;
 
fEitherMem:
		fMemory
		{
			_here;
			$<adrs>$ = $<adrs>1;
		}

	|	fAnonMem
		{
			_here;
			$<adrs>$ = $<adrs>1;
			$<adrs.Size>$ = 0;
			$<adrs.Type>$ = &byte_ste;
			$<adrs.pType>$ = tByte;
			$<adrs.Sym>$->Type = &byte_ste;
			$<adrs.Sym>$->pType = tByte;
		}
	;

	


fEitherMem16Dest:
		fMemoryDest
		{
			_here;
			_if( $<adrs.Size>1 != 2 )
			
				yyerror( "Expected a word memory operand" );
				$<adrs.Size>$ = 2;
				
			_endif
			$<adrs>$ = $<adrs>1;
		}
	|	fAnonMem
		{
			_here;
			$<adrs>$ = $<adrs>1;
			$<adrs.Size>$ = 2;
			$<adrs.pType>$ = tWord;
			$<adrs.Type>$ = &word_ste;
			$<adrs.Sym>$->Type = &word_ste;
			$<adrs.Sym>$->pType = tWord;
		}
	;

fEitherMem32Dest:
		fMemoryDest
		{
			_here;
			_if( $<adrs.Size>1 != 4 )
			
				yyerror( "Expected a dword memory operand" );
				$<adrs.Size>$ = 4;
				
			_endif
			$<adrs>$ = $<adrs>1;
		}
	|	fAnonMem
		{
			_here;
			$<adrs>$ = $<adrs>1;
			$<adrs.Size>$ = 4;
			$<adrs.pType>$ = tDWord;
			$<adrs.Type>$ = &dword_ste;
			$<adrs.Sym>$->Type = &dword_ste;
			$<adrs.Sym>$->pType = tDWord;
		}
	;


fEitherMem64Dest:
		fMemoryDest
		{
			_here;
			_if( $<adrs.Size>1 != 8 )
			
				yyerror( "Expected a qword memory operand" );
				$<adrs.Size>$ = 8;
				
			_endif
			$<adrs>$ = $<adrs>1;
		}
	|	fAnonMem
		{
			_here;
			$<adrs>$ = $<adrs>1;
			$<adrs.Size>$ = 8;
			$<adrs.pType>$ = tQWord;
			$<adrs.Type>$ = &qword_ste;
			$<adrs.Sym>$->Type = &qword_ste;
			$<adrs.Sym>$->pType = tQWord;
		}
	;




fEitherMem128Dest:
		fMemoryDest
		{
			_here;
			_if( $<adrs.Size>1 != 16 )
			
				yyerror( "Expected an lword memory operand" );
				$<adrs.Size>$ = 16;
				
			_endif
			$<adrs>$ = $<adrs>1;
		}
	|	fAnonMem
		{
			_here;
			$<adrs>$ = $<adrs>1;
			$<adrs.Size>$ = 16;
			$<adrs.pType>$ = tLWord;
			$<adrs.Type>$ = &lword_ste;
			$<adrs.Sym>$->Type = &lword_ste;
			$<adrs.Sym>$->pType = tLWord;
		}
	;

fEitherMem128or64Dest:
		fMemoryDest
		{
			_here;
			_if( $<adrs.Size>1 != 16 && $<adrs.Size>1 != 8  )
			
				yyerror( "Expected an lword or qword memory operand" );
				$<adrs.Size>$ = 16;
				
			_endif
			$<adrs>$ = $<adrs>1;
		}
	|	fAnonMem
		{
			_here;
			$<adrs>$ = $<adrs>1;
			$<adrs.Size>$ = 16;
			$<adrs.pType>$ = tLWord;
			$<adrs.Type>$ = &lword_ste;
			$<adrs.Sym>$->Type = &lword_ste;
			$<adrs.Sym>$->pType = tLWord;
		}
	;


	
	
	
	








fConstExpr:
		ConstExpr
		{
			_here;
			$<v>$ = $<v>1;
		}

	|	fstmt
		ConstExpr
		{
			_here;
			$<v>$ = $<v>2;
		}
	;


fUndefID:
		UndefID
		{
			_here;
			$<idStr>$ = $<idStr>1;
		}

	|	fstmt
		UndefID
		{
			_here;
			$<idStr>$ = $<idStr>2;
		}
	;



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Command operands for various instructions

ppp:
		Lparen		/* $1 */
		fmmxReg		/* $2 */
		comma		/* $3 */
		fmmxReg		/* $4 */
		Rparen		/* $5 */
		{
			_here;
			$<rr.l>$ = $<u>2;
			$<rr.r>$ = $<u>4;
		}
	;
	

xx:
		fXmmReg		/* $1 */
		comma		/* $2 */
		fXmmReg		/* $3 */
		{
			_here;
			$<rr.l>$ = $<u>1;
			$<rr.r>$ = $<u>3;
		}
	;

pxx:
		Lparen		/* $1 */
		fXmmReg		/* $2 */
		comma		/* $3 */
		fXmmReg		/* $4 */
		Rparen		/* $3 */
		{
			_here;
			$<rr.l>$ = $<u>2;
			$<rr.r>$ = $<u>4;
		}
	;
	
pmx:
		Lparen				/* $1 */
		fEitherMem128Dest	/* $2 */
		comma				/* $3 */
		fXmmReg				/* $4 */
		Rparen				/* $5 */
		{
			_here;
			$<mr.r>$ = $<u>4;
			$<mr.m>$ = $<adrs>2;
			$<mr.m.forcedSize>$ = 0;
		}
	;
	
pxm:
		Lparen				/* $1 */
		fXmmReg				/* $2 */
		comma				/* $3 */
		fEitherMem128Dest	/* $4 */
		Rparen				/* $5 */
		{
			_here;
			$<rm.r>$ = $<u>2;
			$<rm.m>$ = $<adrs>4;
			$<rm.m.forcedSize>$ = 0;
		}
	;


/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

/*
** The following production allows the programmer to group
** a sequence of statements together and specify a RETURNS string
** for the entire sequence.  This is mainly useful inside macros
** and boolean expressions.
*/

SingleStmt:
		returnsTkn			/* $1 */
		Lparen				/* $2 */
		Lbrace				/* $3 */
		Stmts				/* $4 */
		Rbrace				/* $5 */
		comma				/* $6 */
		ConstOnlyExpr		/* $7 */
		Rparen				/* $8 */
		{
			_here;
			_if( $<v.pType>7 != tString && $<v.pType>7 != tZString )

				yyerror
				( 
					"RETURNS expected a string constant for the RETURNS value"
				);
				FreeValue( YYS &$<v>7 );
				$<returns>$ = NULL;

			_else

				$<returns>$ = $<v.u.strval>7;
			
			_endif
		}
	;
	
	



/*
** Allow the user to embed static variable declarations in the
** middle of the code.  This is primarily for supporting data
** emission from macros.
*/


SingleStmt:
		staticTkn
		StaticVars
		endstaticTkn
		{
			_here;
			$<returns>$ = NULL;
		}
	;



SingleStmt:
		readonlyTkn
		ReadOnlyVars
		endreadonlyTkn
		{
			_here;
			$<returns>$ = NULL;
		}
	;



SingleStmt:
		uninitializedTkn
		UninitVars
		endstorageTkn
		{
			_here;
			$<returns>$ = NULL;
		}
	;



SingleStmt:
		procs
		endprocTkn
		{
			_here;
			$<returns>$ = NULL;
		}
	;





 /*
 ** Allow the insertion of the align directive here.
 */

SingleStmt:
		alignTkn	/* $1 */
		Lparen		/* $2 */
		ConstExpr	/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			_if( checkSmallUns( YYS &$<v>3 ) )
			
				EmitAlign( $<v.u.unsval>3 );
				
			_else
			
				yyerror
				( 
					"Align directive requires a 32-bit positive constant" 
				);
				
			_endif
			FreeValue( YYS &$<v>3 );
			$<returns>$ = NULL;
		}
	;
	




	

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// Handle overloaded procedure calls here:

SingleStmt:
		OverloadedID		/* $1 */
		'('					/* $2 */
		saveYYText			/* $3 */
		CollectParameters	/* $4 */
		')'					/* $5 */
		{					/* $6 */
			char			*pbStmt;
			struct	SymNode	*sig;
			
			_here;
			LastRefdObject = $<s>3;
			$<returns>$ = NULL;
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level procedure calls are illegal in low and machine\n"
					"level language mode."
				);
				
			_endif
			
			// Search for the matching signature:
			
			sig =	matchSignature
					( 
						$<s>1, 
						$<collectedParms.parmCnt>4, 
						$<collectedParms.types>4, 
						$<collectedParms.pForms>4 
					);
					
			_if( sig == NULL )
			
				yyerror
				( 
					"No matching signature/parameter list for overloaded call."
				);
				
			_else	// We matched a signature
			
				// Emit the code to call the associated function:
				
				pbStmt = 	malloc2
							( 
								strlen( sig->u.ovld.procName ) +
								strlen( $<collectedParms.parms>4 )
								+256
							);
							
				sprintf
				(
					pbStmt,
					"%s( %s )",
					sig->u.ovld.procName,
					$<collectedParms.parms>4
				);
				PushBackStr( pbStmt );
				$<returns>$ = pbStmt;
				
			_endif
			_if( $<collectedParms.parms>4 != NULL )
			
				free( $<collectedParms.parms>4 );
				
			_endif
			_if( $<collectedParms.types>4 != NULL )
			
				free( $<collectedParms.types>4 );
				
			_endif
			_here; 
		}
		
		// Must reinvoke SingleStmt to process the
		// string we just pushed back on the lexer input:
		
		callFunction	/* $7 */
		{
			_here;
			$<returns>$ = $<returns>7;
			_if( $<returns>6 != NULL )
			
				free( $<returns>6 ); 
				
			_endif
		}
	;



saveYYText:
		{
			_here;
			doCollect = 1;
			collectIndex = 0;
			delayCollect = 0;
			collectBuf[0] = '\0';
			$<s>$ = LastRefdObject;
		}
	;
	
CollectParameters:
		OptionalCollectParameters	/* $1 */
		{
			char	*parms;
			int		i;
			int		j;
			
			_here;
			
			// Note: Lookahead has grabbed an extra token,
			// so subtract the size of that lexeme in order
			// to remove the lookahead symbol.
			
			collectIndex -= yyleng;
			collectBuf[ collectIndex ] = '\0';
			doCollect = 0;
			i = collectBuf[0] == '(';
			_while( isspace( collectBuf[i] ) )
			
				++i;
				
			_endwhile
			j = collectIndex - 1;
			_while( j > 0 &&  isspace(collectBuf[j])  )
			
				--j;
				
			_endwhile
			collectBuf[ j+1 ] = '\0';	
			parms = hlastrdup2( &collectBuf[i] );
			$<collectedParms>$ = $<collectedParms>1;
			$<collectedParms.parms>$ = parms;
			_here;
		}
	;

OptionalCollectParameters:
		Empty
		{
			_here;
			$<collectedParms.parmCnt>$ 	= 0;
			$<collectedParms.types>$ 	= NULL;
			$<collectedParms.pForms>$ 	= NULL;
			$<collectedParms.parms>$ 	= NULL;	// Filled in later
		}
		
	|	OneOrMoreCollectParameters
		{
			_here;
			$<collectedParms>$ = $<collectedParms>1;
		}
	;
	
	
OneOrMoreCollectParameters:
		OneCollectParameter
		{
			_here;
			$<collectedParms>$ = $<collectedParms>1;
		}

	|	OneCollectParameter 		/* $1 */
		','							/* $2 */
		OneOrMoreCollectParameters	/* $3 */
		{
			_here;
			$<collectedParms.parmCnt>$ = 
				$<collectedParms.parmCnt>1 + $<collectedParms.parmCnt>3;
				
			$<collectedParms.types>$ = 
				malloc2
				( 
					$<collectedParms.parmCnt>$ * sizeof( struct SymNode*)
				);
				
			$<collectedParms.types>$[0] = $<collectedParms.types>1[0];	
			memcpy
			( 
				&$<collectedParms.types>$[1],
				$<collectedParms.types>3,
				$<collectedParms.parmCnt>3 * sizeof( struct SymNode*)
			);
			free( $<collectedParms.types>3 );
				
			$<collectedParms.pForms>$ = 
				malloc2
				( 
					$<collectedParms.parmCnt>$ * sizeof( enum ParmForm )
				);
				
			$<collectedParms.pForms>$[0] = $<collectedParms.pForms>1[0];	
			memcpy
			( 
				&$<collectedParms.pForms>$[1],
				$<collectedParms.pForms>3,
				$<collectedParms.parmCnt>3 * sizeof( enum ParmForm )
			);
			free( $<collectedParms.pForms>3 );
			$<collectedParms.parms>$ = NULL;	// Filled in later
			_here; 
		}
	;


	
OneCollectParameter:
		fConstExpr
		{
			_here;
			$<collectedParms.pForms>$ = malloc2( sizeof( enum ParmForm ));
			$<collectedParms.pForms>$[0] = parm_constant;
			$<collectedParms.parmCnt>$ = 1;
			$<collectedParms.types>$ = malloc2( sizeof( struct SymNode* ));
			$<collectedParms.types>$[0] = $<v.Type>1;
			_here; 
		}
	;

	

	




	/*
	** Register parameters are easy to deal with.
	** All we've got to do is verify the size is correct.
	** For eight-bit registers, we also need to zero extend
	** the value we push on the stack.  For 16-bit register,
	** we need to zero extend the value if the minimum parm
	** size is four bytes.
	*/

OneCollectParameter:
		fRegister 
		{
			_here;
			$<collectedParms.pForms>$ = malloc2( sizeof( enum ParmForm ));
			$<collectedParms.pForms>$[0] = parm_register;
			$<collectedParms.parmCnt>$ = 1;
			$<collectedParms.types>$ = malloc2( sizeof( struct SymNode*));
			$<collectedParms.types>$[0] = $<reg.Type>1;
			$<collectedParms.parms>$ = NULL;	// Filled in later
			_here; 
		}
	;

	
OneCollectParameter:
		edxeaxTkn 
		{
			_here;
			$<collectedParms.pForms>$ = malloc2( sizeof( enum ParmForm ));
			$<collectedParms.pForms>$[0] = parm_register;
			$<collectedParms.parmCnt>$ = 1;
			$<collectedParms.types>$ = malloc2( sizeof( struct SymNode*));
			$<collectedParms.types>$[0] = &qword_ste;
			_here;
		}
	;

	
	

OneCollectParameter:
		dxaxTkn 
		{
			_here;
			$<collectedParms.pForms>$ = malloc2( sizeof( enum ParmForm ));
			$<collectedParms.pForms>$[0] = parm_register;
			$<collectedParms.parmCnt>$ = 1;
			$<collectedParms.types>$ = malloc2( sizeof( struct SymNode*));
			$<collectedParms.types>$[0] = &dword_ste;
			_here;
		}
	;

	
	



OneCollectParameter:
		valTkn
		fRegister
		{
			_here;
			$<collectedParms.pForms>$ = malloc2( sizeof( enum ParmForm ));
			$<collectedParms.pForms>$[0] = parm_register;
			$<collectedParms.parmCnt>$ = 1;
			$<collectedParms.types>$ = malloc2( sizeof( struct SymNode*));
			$<collectedParms.types>$[0] = $<reg.Type>2;
			$<collectedParms.parms>$ = NULL;	// Filled in later
			_here; 
		}
	;

	
	

	/*
	** Okay, memory is really miserable.  Not only do we have to
	** deal with all the possible memory types, but we've also
	** got to deal with the fact that parameters can be passed by
	** value, by reference, by value/result, by result, by name,
	** and by lazy evaluation.
	*/	
	
OneCollectParameter:
		fMemory
		{
			_here;
			$<collectedParms.pForms>$ = malloc2( sizeof( enum ParmForm ));
			$<collectedParms.pForms>$[0] = parm_memory;
			$<collectedParms.parmCnt>$ = 1;
			$<collectedParms.types>$ = malloc2( sizeof( struct SymNode*));
			$<collectedParms.types>$[0] = $<adrs.Type>1;
			FreeAdrs( &$<adrs>1 );
			_here;
		}
	;





	
OneCollectParameter:
		valTkn
		fMemory
		{
			_here;
			$<collectedParms.pForms>$ = malloc2( sizeof( enum ParmForm ));
			$<collectedParms.pForms>$[0] = parm_memory;
			$<collectedParms.parmCnt>$ = 1;
			$<collectedParms.types>$ = malloc2( sizeof( struct SymNode*));
			$<collectedParms.types>$[0] = $<adrs.Type>2;
			FreeAdrs( &$<adrs>2 );
			_here;
		}
	;












//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

callFunction:
		callLocalProc
		{
			_here;
			$<returns>$ = $<returns>1;
		}
		
	|	callNonLocalProc	
		{
			_here;
			$<returns>$ = $<returns>1;
		}
		
	|	callClassProc	
		{
			_here;
			$<returns>$ = $<returns>1;
		}
		
	|	IndirectCall1	
		{
			_here;
			$<returns>$ = $<returns>1;
		}
		
	|	IndirectCall2	
		{
			_here;
			$<returns>$ = $<returns>1;
		}
		
	|	IndirectCall3	
		{
			_here;
			$<returns>$ = $<returns>1;
		}
		
	|	IndirectCall4	
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;



callLocalProc:

		/*
		** Handle procedure calls via procname here.
		*/

		LocalProcID
		CallParameters
		{
			_here;
			call_proc( $<s>1 );
			SetReferenced( $<s>1 );
			$<returns>$ = hlastrdup2( $<s>1->u.proc.returns );
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level procedure calls are illegal in low and machine\n"
					"level language mode."
				);
				
			_endif
		}
	;
	
		/*
		** Handle procedure calls via procname here.
		*/


callNonLocalProc:
		NonLocalProcID
		CallParameters
		{
			_here;
			call_proc( $<s>1 );
			SetReferenced( $<s>1 );
			$<returns>$ = hlastrdup2( $<s>1->u.proc.returns );
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level procedure calls are illegal in low- and\n"
					"machine-level language mode."
				);
				
			_endif
		}
	;


		/*
		** Handle class procedure calls via classname.u.procname here.
		*/

callClassProc:
		ClassProcID
		CallParameters
		{

			/*
			** This invocation uses a class name (rather than
			** an object name), so load esi (this) zero (NULL)
			** before making the call.
			*/

			_here;
			SetReferenced( $<s>1 );
			
			// Must initialize ESI with NULL before class proc call:
			
			EmitGeneric_r_r( xor_instr, reg_esi, reg_esi );
			
			call_proc( $<s>1 );
			$<returns>$ = hlastrdup2( $<s>1->u.proc.returns );
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level class procedure calls are illegal in low- and\n"
					"machine-level language mode."
				);
				
			_endif
		}
	;
	

SingleStmt:
		callLocalProc
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;

SingleStmt:
		callNonLocalProc
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;


SingleStmt:
		callClassProc
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;


SingleStmt:
		IndirectCall1
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;


SingleStmt:
		IndirectCall2
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;


SingleStmt:
		IndirectCall3
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;


SingleStmt:
		IndirectCall4
		{
			_here;
			$<returns>$ = $<returns>1;
		}
	;





 /*
 ** Handle calls via pointer and variable objects here.
 **
 **	Syntaxes allowed by the following productions:
 **
 **	name()				pointers, procptrs, and thunks.
 **	name[index]()		arrays of pointers, procptrs, and thunks.
 **	name.field()		class fields that are procptrs and thunks; note
 **						 that methods and class procedures are handled
 **						 elsewhere.
 **	name.field[index]()	arrays of class objects, arrays of pointers to
 **						class objects, arrays of class object fields, etc. 	
 **		
 */
 

IndirectCall1:
		SimpleMemoryVar			/* $1 */
		SMV0					/* $<s>2 contains $<adrs.Sym>1	*/
		IndirectCallParameters	/* $3 */
		{
			char returns[ 256 ];

			_here;
			returns[0] = '\0';
			_if( $<adrs.SymClass>1 == cParm )

				_if
				(
						$<adrs.pClass>1 == name_pc
					||	$<adrs.pClass>1 == lazy_pc
				)

					call_thunk( &$<adrs>1 );

					/*
					** Note: the user can specify a return value
					** as a pseudo-parameter to the "name" or
					** "lazy" keyword.  If such a parameter has
					** been specified, return the associated string
					** as the "returns" value.
					*/

					_if( $<adrs.Sym>1->u.proc.returns != NULL )
					
						strcpy( returns, $<adrs.Sym>1->u.proc.returns );
						
					_endif


				_elseif( $<adrs.pClass>1 == valp_pc )

					_if
					(
							$<adrs.pType>1 == tThunk
						||	(
									$<adrs.pType>1 == tArray
								&&	GetBaseType( $<adrs.Type>1 )->pType 
												== tThunk
							)
					)

						call_thunk( &$<adrs>1 );

					_elseif
					( 
							$<adrs.pType>1 == tProcptr 
						||	(
									$<adrs.pType>1 == tArray
								&&	GetBaseType( $<adrs.Type>1 )->pType 
												== tProcptr
							)
					)

						EmitCall_m( &$<adrs>1 );

						/*
						** Look up the "returns" value for this
						** procedure parameter.  Note: a "returns"
						** value can only exist if this procedure
						** pointer is of some user-defined type.
						*/

						_if
						( 
								$<adrs.Sym>1->Type != NULL
							&&	$<adrs.Sym>1->Type->u.proc.returns != NULL 
						)

							strcpy
							(
								returns,
								$<adrs.Sym>1->Type->u.proc.returns
							);

						_endif

							

					_else

						yyerror
						( 
							"Illegal use of value parameter\n"
							"(Expected thunk or procedure parameter)"
						);

					_endif


				_else

					yyerror
					(
						"Cannot call code except via pass by name,\n"
						"pass by lazy evaluation, or pass by value"
					);

				_endif

			/*
			** If it's not a parameter, see if it's a thunk here.
			*/

			_elseif
			(
					$<adrs.pType>1 == tThunk
				||	(
							$<adrs.pType>1 == tArray
						&&	GetBaseType( $<adrs.Type>1 )->pType == tThunk
					)

			)

				call_thunk( &$<adrs>1 );


			/*
			** If it's not a thunk or a parameter, see if it's a
			** procedure variable.
			*/

			_elseif
			( 
					$<adrs.pType>1 == tProcptr 
				||	(
							$<adrs.pType>1 == tArray
						&&	GetBaseType( $<adrs.Type>1 )->pType == tProcptr
					)
			)


				EmitCall_m( &$<adrs>1 );
						
				/*
				** Look up the "returns" value for this
				** procedure parameter.
				*/

				_if( $<adrs.Sym>1 != NULL )

					_if
					( 
							$<adrs.Sym>1->Type != NULL 
						&&	$<adrs.Sym>1->Type->u.proc.returns != NULL 
					)

						strcpy
						(
							returns,
							$<adrs.Sym>1->Type->u.proc.returns
						);

					_elseif( $<adrs.Sym>1->u.proc.returns != NULL ) 
 
						strcpy
						(
							returns,
							$<adrs.Sym>1->u.proc.returns
						);

					_endif

				_endif

			_else

				yyerror( "Variable must point at a procedure or method" );

			_endif
			FreeAdrs( &$<adrs>1 );
			$<returns>$ = hlastrdup2( returns );
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level indirect procedure calls are illegal in low- and\n"
					"machine-level language mode."
				);
				
			_endif
			_here;
 		}
	;

IndirectCall2:
		SimpleMemoryVar			/* $1 */
		IndexAdrsMode			/* $2 */
		SMVm1					/* $3 $<s>3 contains $<adrs.Sym>1 */
		IndirectCallParameters	/* $4 */
		{
			char returns[ 256 ];

			_here;
			returns[ 0 ] = '\0';

			/*
			** Merge the base name with the index to get the
			** name plus the adjusted offsets.
			*/

			CombineAddresses( &$<adrs>1, &$<adrs>2 );

			_if( $<adrs.SymClass>1 == cParm )

				_if
				(
						$<adrs.pClass>1 == name_pc
					||	$<adrs.pClass>1 == lazy_pc
				)

					call_thunk( &$<adrs>1 );
					_if( $<adrs.Sym>1->u.proc.returns != NULL )
					
						strcpy( returns, $<adrs.Sym>1->u.proc.returns );
						
					_endif


				_elseif( $<adrs.pClass>1 == valp_pc )

					_if
					(
							$<adrs.pType>1 == tThunk
						||	(
									$<adrs.pType>1 == tArray
								&&	GetBaseType( $<adrs.Type>1 )->pType 
												== tThunk
							)
					)

						call_thunk( &$<adrs>1 );

					_elseif
					( 
							$<adrs.pType>1 == tProcptr 
						||	(
									$<adrs.pType>1 == tArray
								&&	GetBaseType( $<adrs.Type>1 )->pType 
												== tProcptr
							)
					)

						EmitCall_m( &$<adrs>1 );

						/*
						** Look up the "returns" value for this
						** procedure parameter.  Note: a "returns"
						** value can only exist if this procedure
						** pointer is of some user-defined type.
						*/

						_if( $<adrs.Sym>1 != NULL )

							_if
							( 
									$<adrs.Sym>1->Type != NULL 
								&&	$<adrs.Sym>1->Type->u.proc.returns != NULL 
							)

								strcpy
								(
									returns,
									$<adrs.Sym>1->Type->u.proc.returns
								);

							_endif

						_endif

					_else

						yyerror
						( 
							"Illegal use of value parameter\n"
							"(Expected thunk or procedure parameter)"
						);

					_endif


				_else

					yyerror
					(
						"Cannot call code except via pass by name,\n"
						"pass by lazy evaluation, or pass by value"
					);

				_endif

			/*
			** If it's not a parameter, see if it's a thunk here.
			*/

			_elseif
			(
					$<adrs.pType>1 == tThunk
				||	(
							$<adrs.pType>1 == tArray
						&&	GetBaseType( $<adrs.Type>1 )->pType == tThunk
					)

			)

				call_thunk( &$<adrs>1 );


			/*
			** If it's not a thunk or a parameter, see if it's a
			** procedure variable.
			*/

			_elseif
			( 
					$<adrs.pType>1 == tProcptr 
				||	(
							$<adrs.pType>1 == tArray
						&&	GetBaseType( $<adrs.Type>1 )->pType == tProcptr
					)
			)

				EmitCall_m( &$<adrs>1 );

				/*
				** Look up the "returns" value for this
				** procedure parameter.  Note: a "returns"
				** value can only exist if this procedure
				** pointer is of some user-defined type.
				*/

				_if( $<adrs.Sym>1 != NULL )

					_if
					( 
							$<adrs.Sym>1->Type != NULL 
						&&	$<adrs.Sym>1->Type->u.proc.returns != NULL 
					)

						strcpy
						(
							returns,
							$<adrs.Sym>1->Type->u.proc.returns
						);

					_endif

				_endif

			_else

				yyerror( "Variable must point at a procedure or method" );

			_endif
			SetReferenced( $<adrs.Sym>1 );
			FreeAdrs( &$<adrs>2 );
			FreeAdrs( &$<adrs>1 );
			$<returns>$ = hlastrdup2( returns );
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level indirect procedure calls are illegal in low- and\n"
					"machine-level language mode."
				);
				
			_endif
			_here;
 		}
	;





// Handle procedure pointers that are members of a record or union
// here.  Also handle calls to procedures and methods in a pointer
// to a class.
//
// Giant kludge here. We might have an overloaded symbol in an object
// reference sequence. If so, we have to push a special token to switch
// the grammar to handle the overloaded ID pushback.

parenPushBack:
		'('
		{

			// Next, check to see if we have an overridden
			// class symbol here:
			
			_here;
			_if( $<adrs.Sym>0->pType == tOverloads )
			
				// This only happens from IndirectCall3:
				//
				// Bison's lookahead has already consumed the
				// next symbol, push it back:
				
				PushBackStr( "\xde" );
				
			_else
			
				PushBackStr( "(" );
				
			_endif
		}
	;
	
	
IndirectCall3:
		SimpleMemoryVar			/* $1 */
		FieldStuff				/* $2 */
		parenPushBack			/* $3 */
		ovldClassTkn			/* $4 */
		saveYYText				/* $5 */
		CollectParameters		/* $6 */
		')'						/* $7 */
		{						/* $8 */
			char			*pbStmt;
			struct	SymNode	*sig;
			
			_here;
			LastRefdObject = $<s>5;
			$<returns>$ = NULL;
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level procedure calls are illegal in low and machine\n"
					"level language mode."
				);
				
			_endif
			
			// Search for the matching signature:
			
			sig =	matchSignature
					( 
						$<adrs.Sym>2, 
						$<collectedParms.parmCnt>6, 
						$<collectedParms.types>6, 
						$<collectedParms.pForms>6 
					);
					
			_if( sig == NULL )
			
				yyerror
				( 
					"No matching signature/parameter list for overloaded call."
				);
				
			_else	// We matched a signature
			
				// Emit the code to call the associated function:
				
				pbStmt = 	malloc2
							( 
								strlen( sig->u.ovld.procName ) +
								strlen( $<collectedParms.parms>6 )
								+256
							);
							
				sprintf
				(
					pbStmt,
					"%s( %s )",
					sig->u.ovld.procName,
					$<collectedParms.parms>6
				);
				PushBackStr( pbStmt );
				$<returns>$ = pbStmt;
				
			_endif
			_if( $<collectedParms.parms>6 != NULL )
			
				free( $<collectedParms.parms>6 );
				
			_endif
			_if( $<collectedParms.types>6 != NULL )
			
				free( $<collectedParms.types>6 );
				
			_endif
			_here; 
		}
		
		// Must reinvoke SingleStmt to process the
		// string we just pushed back on the lexer input:
		
		callFunction	/* $9 */
		{
			$<returns>$ = $<returns>9;
			_if( $<returns>8 != NULL )
			
				free( $<returns>8 ); 
				
			_endif
		}
	;


IndirectCall3:
		SimpleMemoryVar			/* $1 */
		FieldStuff				/* $2 */
		parenPushBack			/* $3 */
		SMVm1					/* $4 = FieldStuff's adrs.sym field */
		IndirectCallParameters	/* $5 */
		{						/* $6 */

			int  			useLEA    = 1;
			int  			useOffset = 1;
			int  			isPointer = 0;
			enum ClassType	SymClass;
			struct SymNode	*classPtr;
			struct SymNode	*typ;
			struct SymNode	*s;
			char			name[ 256 ];
			char 			returns[ 256 ];

			_here;
			returns[ 0 ] = '\0';

			// Handle classes specially because we get to use the
			// ESI and EDI registers for class invocations.
			//
			// Note: $<adrs.Sym>1->Type is usually equal to $<adrs.Type>1
			// They are different for parameters passed by address. In that
			// case, $<adrs.Type>1 will be a tPointer type and $<adrs.Sym>1->Type
			// is the base type.  Note that $<adrs.pType>1 will contain tPointer
			// for a parameter passed by address. In such a case, this code has
			// to use the (base) type of $<adrs.Sym>1->Type as the object pointed at.
			//
			// It shouldn't possible for $<adrs.Sym>1->Type to be NULL. This used
			// to denote a procedure pointer object that was directly declared (rather
			// than creating a user-defined procedure type and using that to declare
			// the object). This should have been corrected everywhere by now (dummy
			// types should be created), but just in case some old code is laying around,
			// the assert below was added to catch these.
			//
			// In no case should $<adrs.Sym>1 be NULL.  Even for anonymous
			// memory objects, the Sym field is set to something legitimate.
			
			typ = 
				GetCallType
				( 
					$<adrs.Sym>1, 
					$<adrs.Type>1, 
					$<adrs.pType>1, 
					&isPointer 
				);			
			
			classPtr = NULL;
			_if( typ->pType == tClass )
			
				classPtr = typ;
				
				/*
				** If we've referenced a class object, we need to set
				** the IsReferenced field of the _VMT_ field for this class.
				*/
				
				s = lookupin( "_VMT_", classPtr->Fields );
				assert( s != NULL );
				_if( s->IsReferenced != NULL )
				
					SetReferenced( s );
					
				_endif

				/*
				** The assumption to this point is that we have
				** a class variable.  Check to see if what we've
				** really got is a pointer to a class object.  The
				** only difference in the code generation is "lea"
				** (for class vars) vs. "mov" (for class pointers).
				*/

				_if( isPointer )

					useLEA = 0;
					useOffset = 0;
					_if
					( 
							$<adrs.SymClass>1 == cParm 
						&&	$<adrs.pClass>1 == refp_pc 
					)
						yyerror
						( 
							"Cannot pass a pointer by reference here"
						);

					_endif

				_elseif
				(
						IsStaticClass( $<adrs.SymClass>1 ) 
					&&	$<adrs.StaticName>1 != NULL 
					&&	*$<adrs.StaticName>1 != '\0'
					&&	$<adrs.BaseReg>2 == NULL
					&&	$<adrs.IndexReg>2 == NULL
				)

					useLEA = 0;
					useOffset = 1;

				_endif

				/*
				** Emit the code that moves the address of the
				** object into the ESI register (this).
				** Note that the address of the object is
				** the SimpleMemoryVar, not the FieldStuff value.
				*/

				_if
				( 
						$<adrs.SymClass>1 == cVar
					|| 	$<adrs.SymClass>1 == cStatic
				)

					_if( useLEA )
					
						$<adrs.forcedSize>1 = 0;
						EmitLea_m_r2( &$<adrs>1, reg_esi );
						
					_elseif( useOffset ) 
					
						EmitMov_o_r
						( 
							$<adrs.StaticName>1, 
							$<adrs.Disp>1, 
							reg_esi 
						);
						
					_else
					
						EmitMov_m_r( &$<adrs>1, reg_esi, 4 ); 
						
					_endif

				_elseif( $<adrs.SymClass>1 == cParm )

					/*
					** Handle pass by value of the object here.
					*/
					_if( $<adrs.pClass>1 == valp_pc )

						_if( useLEA )
						
							$<adrs.forcedSize>1 = 0;
							EmitLea_m_r2( &$<adrs>1, reg_esi );
							
						_elseif( useOffset ) 
						
							EmitMov_o_r
							( 
								$<adrs.StaticName>1, 
								$<adrs.Disp>1, 
								reg_esi 
							);
							
						_else
						
							$<adrs.forcedSize>1 = 0;
							EmitMov_m_r( &$<adrs>1, reg_esi, 4 ); 
							
						_endif

					/*
					** Handle pass by reference of the object
					** here.
					*/

					_elseif( $<adrs.pClass>1 == refp_pc )

						struct adrsYYS adrs;
						
						$<adrs.forcedSize>1 = 0;
						EmitMov_m_r( &$<adrs>1, reg_esi, 4 );
						initAdrs1( &adrs, reg_esi, 0 ); 
						EmitMov_m_r( &adrs, reg_esi, 4 );

					/*
					** Don't allow the other parameter passing methods.
					*/

					_else

						yyerror
						(
							"Object pointer must be passed by "
							"value or reference"
						);

					_endif

				_else

					yyerror( "Expected class object" );

				_endif


				/*
				** If the field is a class procedure, issue the
				** call here.
				*/

				_if( $<adrs.SymClass>2 == cClassProc )

					/*
					** Since this is a procedure, the following
					** should always have some sort of value
					** (besides NULL).
					*/
					
					assert( $<adrs.Sym>2->StaticName != NULL );

					/*
					** This is just a class procedure.
					** Call it directly.
					*/

					call_proc( $<adrs.Sym>2 );
					_if( $<adrs.Sym>2->u.proc.returns != NULL )
					
						strcpy( returns, $<adrs.Sym>2->u.proc.returns );
						
					_endif

				
				
				/*
				** If the field is a class method, issue the
				** call here.
				*/

				_elseif( $<adrs.SymClass>2 == cMethod )

					struct adrsYYS adrs;

					/*
					** First, get the address of the virtual
					** method table into EDI (VMT is always at
					** offset zero within the object and ESI is
					** currently pointing at the object).
					*/

					initAdrs1( &adrs, reg_esi, 0 );
					EmitMov_m_r( &adrs, reg_edi, 4 );

					initAdrs1( &adrs, reg_edi, $<adrs.Sym>2->Offset );
					EmitCall_m( &adrs );
					_if( $<adrs.Sym>2->u.proc.returns != NULL )
					
						strcpy( returns, $<adrs.Sym>2->u.proc.returns );
						
					_endif

				/*
				** If the field is a pointer to a procedure, issue
				** the indirect call here.
				*/
				
				_elseif
				( 
						$<adrs.pType>2 == tProcptr 
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tProcptr
						)
				)

					struct adrsYYS adrs;
					
					_if( $<adrs.SymClass>2 == cStatic )
					
						EmitCall_m( &$<adrs>2 );
						
					_else

						BuildAdrs
						( 
							&adrs, 
							4, 			// Size
							4, 			// ObjectSize
							NULL, 		// StaticName
							"esi", 		// BaseReg
							NULL, 		// IndexReg
							0, 			// Scale
							$<adrs.Sym>2->Offset, 	// Disp
							NULL,		// Sym
							&dword_ste,	// Type
							tDWord,		// pType
							cNone,		// SymClass
							none_pc,	// pClass
							NULL		// BaseType
						);
						EmitCall_m( &adrs );
						
					_endif

				/*
				** If the field is a thunk, invoke the thunk here.
				*/

				_elseif 
				( 
						$<adrs.pType>2 == tThunk 
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tThunk
						)
				)

					struct adrsYYS adrs;

					BuildAdrs
					( 
						&adrs, 
						4, 			// Size
						4, 			// ObjectSize
						NULL, 		// StaticName
						"esi", 		// BaseReg
						NULL, 		// IndexReg
						0, 			// Scale
						$<adrs.Sym>2->Offset, 	// Disp
						NULL,		// Sym
						&dword_ste,	// Type
						tDWord,		// pType
						cNone,		// SymClass
						none_pc,	// pClass
						NULL		// BaseType
					);

					push_mem( &adrs, 4 );
					adrs.Disp += 4;
					EmitCall_m( &adrs );
				
				
				/*
				** If the field is neither a method nor a procedure,
				** then this is an illegal call.
				*/

				_else

					yyerror( "Object member is not method or procedure" );

				_endif


			/*
			** If it wasn't a class variable, see if it is a procedure
			** pointer variable or a thunk.
			*/

			_elseif( $<adrs.pType>1 != tPointer )
			
				/*
				** If this is a parameter, be sure it's a value, name,
				** or lazy parameter (the only parameter types that allow
				** indirect calls).
				*/

				_if( $<adrs.SymClass>2 == cParm )

					_if( $<adrs.pClass>2 == valp_pc )

						_if
						(
								$<adrs.pType>2 == tThunk
							||	(
										$<adrs.pType>2 == tArray
									&&	GetBaseType( $<adrs.Type>2 )->pType
													== tThunk
								)
						)

							setForcedSize( $<adrs>2, 4 );
							call_thunk( &$<adrs>2 );

						_elseif
						( 
								$<adrs.pType>2 == tProcptr 
							||	(
										$<adrs.pType>2 == tArray
									&&	GetBaseType( $<adrs.Type>2 )->pType 
													== tProcptr
								)
						)

							setForcedSize( $<adrs>2, 4 );
							EmitCall_m( &$<adrs>2 );

							/*
							** Look up the "returns" value for this
							** procedure parameter.  Note: a "returns"
							** value can only exist if this procedure
							** pointer is of some user-defined type.
							*/

							_if( $<adrs.Sym>2 != NULL )

								_if
								( 
										$<adrs.Sym>2->Type != NULL 
									&&	$<adrs.Sym>2->Type->u.proc.returns 
											!= NULL 
								)

									strcpy
									(
										returns,
										$<adrs.Sym>2->Type->u.proc.returns
									);

								_endif

							_endif

						_else

							yyerror
							( 
								"Illegal use of value parameter\n"
								"(Expected thunk or procedure parameter)"
							);

						_endif


					_else

						yyerror
						(
							"Cannot call code except via pass by value"
						);

					_endif

				/*
				** If it's not a parameter, see if it's a thunk here.
				*/

				_elseif
				(
						$<adrs.pType>2 == tThunk
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tThunk
						)

				)

					setForcedSize( $<adrs>2, 4 );
					call_thunk( &$<adrs>2 );


				/*
				** If it's not a thunk or a parameter, see if it's a
				** procedure variable.
				*/

				_elseif
				( 
						$<adrs.pType>2 == tProcptr 
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tProcptr
						)
				)

					setForcedSize( $<adrs>2, 4 );
					EmitCall_m( &$<adrs>2 );
						
					/*
					** Look up the "returns" value for this
					** procedure parameter.  Note: a "returns"
					** value can only exist if this procedure
					** pointer is of some user-defined type.
					*/

					_if( $<adrs.Sym>2 != NULL )

						_if
						( 
								$<adrs.Sym>2->Type != NULL 
							&&	$<adrs.Sym>2->Type->u.proc.returns != NULL 
						)

							strcpy
							(
								returns,
								$<adrs.Sym>2->Type->u.proc.returns
							);

						_endif

					_endif


				_else

					yyerror( "Variable must point at a procedure or method" );

				_endif
				
			_else

				yyerror( "Illegal use of pointer variable (must dereference)" );

			_endif

			SetReferenced( $<adrs.Sym>2 );
			FreeAdrs( &$<adrs>1 );
			FreeAdrs( &$<adrs>2 );
			$<returns>$ = hlastrdup2( returns );

			_here;
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level indirect procedure calls are illegal in low- and\n"
					"machine-level language mode."
				);
				
			_endif
		}
	;



	/*
	** Same as above, except with an index into an array of pointers.
	*/

		
IndirectCall4:
		SimpleMemoryVar			/* $1 */
		FieldStuff				/* $2 */
		IndexAdrsMode			/* $3 */
		SMVm1					/* $4 */
		IndirectCallParameters	/* $5 */
		{						/* $6 */

			int	 useLEA = 1;
			int	 useOffset = 1;
			int	 hasBase;
			char returns[ 256 ];

			_here;
			returns[ 0 ] = '\0';

			/*
			** Note whether or not there was an index register in the
			** IndexAdrsMode.
			*/
			
			hasBase =
				(
						$<adrs>3.BaseReg != NULL 
					||	$<adrs>3.IndexReg != NULL
				);

			/*
			** Combine the index information with the base information
			** so we can use the code from the previous production.
			*/

			CombineAddresses( &$<adrs>1, &$<adrs>3 );

			/*
			** Handle classes specially because we get to use the
			** ESI and EDI registers for class invocations.
			*/

			_if
			( 
					$<adrs.pType>1 == tClass

				||	(
							$<adrs.pType>1 == tArray
						&&	GetBaseType( $<adrs.Type>1 )->pType == tClass
					)

				||	(
							(
									$<adrs.pType>1 == tPointer
								||	(
											$<adrs.pType>1 == tArray
										&&	GetBaseType( $<adrs.Sym>1 )->pType
														== tPointer
									)
							)
						&&	$<adrs.Sym>1->Base->pType == tClass
					)
			)

				/*
				** The assumption to this point is that we have
				** a class variable.  Check to see if what we've
				** really got is a pointer to a class object.  The
				** only difference in the code generation is "lea"
				** (for class vars) vs. "mov" (for class pointers).
				*/

				_if
				( 
						$<adrs.pType>1 == tPointer
					||	(
								$<adrs.pType>1 == tArray
							&&	GetBaseType( $<adrs.Type>1 )->pType == tPointer
						)
				)

					useLEA = 0;
					useOffset = 0;
					_if
					( 
							$<adrs.SymClass>1 == cParm 
						&&	$<adrs.pClass>1 == refp_pc 
					)
						yyerror
						( 
							"Cannot pass a pointer by reference here"
						);

					_endif

				_elseif
				( 
						IsStaticClass( $<adrs.SymClass>1 )
					&&	$<adrs.StaticName>1 != NULL 
					&&	*$<adrs.StaticName>1 != '\0'
					&&	$<adrs.BaseReg>2 == NULL
					&&	$<adrs.IndexReg>2 == NULL
				)

					useLEA = 0;

				_endif
				
				/*
				** At this point, we may incorrectly think that we
				** can use "mov offset...".  If the index includes
				** a register, we must use LEA, not MOV offset.
				*/

				_if( hasBase &&	useOffset == 1 )
				
					useLEA = 1;
					useOffset = 0;
					
				_endif
				

				/*
				** Emit the code that moves the address of the
				** object into the ESI register (this).
				*/

				_if
				(
						$<adrs.SymClass>1 == cVar 
					||	$<adrs.SymClass>1 == cStatic
				)

					_if( useLEA )
					
						$<adrs.forcedSize>1 = 0;
						EmitLea_m_r2( &$<adrs>1, reg_esi );
						
					_elseif( useOffset ) 
					
						EmitMov_o_r
						( 
							$<adrs.StaticName>1, 
							$<adrs.Disp>1, 
							reg_esi 
						);
						
					_else
					
						$<adrs.forcedSize>1 = 0;
						EmitMov_m_r( &$<adrs>1, reg_esi, 4 ); 
						
					_endif

				_elseif( $<adrs.SymClass>1 == cParm )

					/*
					** Handle pass by value of the object here.
					*/

					_if( $<adrs.pClass>1 == valp_pc  )

						_if( useLEA )
						
							$<adrs.forcedSize>1 = 0;
							EmitLea_m_r2( &$<adrs>1, reg_esi );
							
						_elseif( useOffset ) 
						
							EmitMov_o_r
							( 
								$<adrs.StaticName>1, 
								$<adrs.Disp>1, 
								reg_esi 
							);
							
						_else
						
							$<adrs.forcedSize>1 = 0;
							EmitMov_m_r( &$<adrs>1, reg_esi, 4 ); 
							
						_endif

					/*
					** Handle pass by reference of the object
					** here.
					*/

					_elseif( $<adrs.pClass>1 == refp_pc )

						struct adrsYYS adrs;

						EmitMov_m_r( &$<adrs>1, reg_esi, 4 );
						initAdrs1( &adrs, reg_esi, 0 );
						EmitMov_m_r( &adrs, reg_esi, 4 );  


					/*
					** Don't allow the other parameter passing methods.
					*/

					_else

						yyerror
						(
							"Object pointer must be passed by "
							"value or reference"
						);

					_endif

				_else

					yyerror( "Expected class object" );

				_endif
				
				


				/*
				** If the field is a class procedure, issue the
				** call here.
				*/

				_if( $<adrs.SymClass>2 == cClassProc )


					/*
					** Since this is a procedure, the following
					** should always have some sort of value
					** (besides NULL).
					*/
					
					assert( $<adrs.Sym>2->StaticName != NULL );

					/*
					** This is just a class procedure.
					** Call it directly.
					*/

					call_proc( $<adrs.Sym>2 );
					_if( $<adrs.Sym>2->u.proc.returns != NULL )
					
						strcpy( returns, $<adrs.Sym>2->u.proc.returns );
						
					_endif
				
				/*
				** If the field is a class method, issue the
				** call here.
				*/

				_elseif( $<adrs.SymClass>2 == cMethod )

					struct adrsYYS adrs;

					/*
					** First, get the address of the virtual
					** method table into EDI (VMT is always at
					** offset zero within the object and ESI is
					** currently pointing at the object).
					*/

					initAdrs1( &adrs, reg_esi, 0 );
				   	EmitMov_m_r( &adrs, reg_edi, 4 ); 

					initAdrs1( &adrs, reg_edi, $<adrs.Sym>2->Offset );
					EmitCall_m( &adrs );
					_if( $<adrs.Sym>2->u.proc.returns != NULL )
					
						strcpy( returns, $<adrs.Sym>2->u.proc.returns );
						
					_endif


				/*
				** If the field is a pointer to a procedure, issue
				** the indirect call here.
				*/
				
				_elseif
				( 
						$<adrs.pType>2 == tProcptr 
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tProcptr

						)
				)

					struct adrsYYS adrs;
					
					_if( $<adrs.SymClass>2 == cStatic )
					
						EmitCall_m( &$<adrs>2 );
						
					_else

						BuildAdrs
						( 
							&adrs, 
							4, 			// Size
							4, 			// ObjectSize
							NULL, 		// StaticName
							"esi", 		// BaseReg
							NULL, 		// IndexReg
							0, 			// Scale
							$<adrs.Sym>2->Offset, 	// Disp
							NULL,		// Sym
							&dword_ste,	// Type
							tDWord,		// pType
							cNone,		// SymClass
							none_pc,	// pClass
							NULL		// BaseType
						);
						EmitCall_m( &adrs );
						
					_endif


				/*
				** If the field is a thunk, invoke the thunk here.
				*/

				_elseif 
				( 
						$<adrs.pType>2 == tThunk 
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tThunk
						)
				)
					struct adrsYYS adrs;

					
					_if( $<adrs.SymClass>2 == cStatic )
					
						call_thunk( &$<adrs>2 );
						
					_else

						BuildAdrs
						( 
							&adrs, 
							4, 			// Size
							4, 			// ObjectSize
							NULL, 		// StaticName
							"esi", 		// BaseReg
							NULL, 		// IndexReg
							0, 			// Scale
							$<adrs.Sym>2->Offset, 	// Disp
							NULL,		// Sym
							&dword_ste,	// Type
							tDWord,		// pType
							cNone,		// SymClass
							none_pc,	// pClass
							NULL		// BaseType
						);

						push_mem( &adrs, 4 );
						adrs.Disp += 4;
						EmitCall_m( &adrs );
						
					_endif
				
				
				/*
				** If the field is neither a method nor a procedure,
				** then this is an illegal call.
				*/

				_else

					yyerror( "Object member is not method or procedure" );

				_endif


			/*
			** If it wasn't a class variable, see if it is a procedure
			** pointer variable or a thunk.
			*/

			_elseif( $<adrs.pType>1 != tPointer )

				/*
				** Merge the base name with the fields to get the
				** full name plus the adjusted offsets, base, and
				** index registers.
				*/
				

				CombineAddresses( &$<adrs>2, &$<adrs>1 );

				/*
				** If this is a parameter, be sure it's a value, name,
				** or lazy parameter (the only parameter types that allow
				** indirect calls).
				*/

				_if( $<adrs.SymClass>1 == cParm )

					_if( $<adrs.pClass>1 == valp_pc )

						_if
						(
								$<adrs.pType>2 == tThunk
							||	(
										$<adrs.pType>2 == tArray
									&&	GetBaseType( $<adrs.Type>2 )->pType 
													== tThunk
								)
						)

							call_thunk( &$<adrs>2 );

						_elseif
						( 
								$<adrs.pType>2 == tProcptr 
							||	(
										$<adrs.pType>2 == tArray
									&&	GetBaseType( $<adrs.Type>2 )->pType 
													== tProcptr
								)
						)

							EmitCall_m( &$<adrs>2 );

							/*
							** Look up the "returns" value for this
							** procedure parameter.  Note: a "returns"
							** value can only exist if this procedure
							** pointer is of some user-defined type.
							*/

							_if( $<adrs.Sym>2 != NULL )
							
								_if
								( 
										$<adrs.Sym>2->Type != NULL 
									&&	$<adrs.Sym>2->Type->u.proc.returns 
											!= NULL
								)

									strcpy
									(
										returns,
										$<adrs.Sym>2->Type->u.proc.returns
									);

								_endif
							
							_endif

						_else

							yyerror
							( 
								"Illegal use of value parameter\n"
								"(Expected thunk or procedure parameter)"
							);

						_endif


					_else

						yyerror
						(
							"Cannot call code except via pass by value"
						);

					_endif

				/*
				** If it's not a parameter, see if it's a thunk here.
				*/

				_elseif
				(
						$<adrs.pType>2 == tThunk
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tThunk
						)

				)

					call_thunk( &$<adrs>2 );


				/*
				** If it's not a thunk or a parameter, see if it's a
				** procedure variable.
				*/

				_elseif
				( 
						$<adrs.pType>2 == tProcptr 
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tProcptr
						)
				)

					EmitCall_m( &$<adrs>2 );
						
					/*
					** Look up the "returns" value for this
					** procedure parameter.  Note: a "returns"
					** value can only exist if this procedure
					** pointer is of some user-defined type.
					*/

					_if( $<adrs.Sym>2 != NULL )

						_if
						( 
								$<adrs.Sym>2->Type != NULL 
							&&	$<adrs.Sym>2->Type->u.proc.returns != NULL 
						)

							strcpy
							(
								returns,
								$<adrs.Sym>2->Type->u.proc.returns
							);

						_endif

					_endif

				_else

					yyerror( "Variable must point at a procedure or method" );

				_endif

			_else
			
				yyerror( "Must dereference pointer variable for call" );

			_endif


			SetReferenced( $<adrs.Sym>2 );
			SetReferenced( $<adrs.Sym>3 );
			FreeAdrs( &$<adrs>1 );
			FreeAdrs( &$<adrs>2 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( returns );
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level indirect procedure calls are illegal in low- and\n"
					"machine-level language mode."
				);
				
			_endif
			_here;
		}
	;




  /* Get the attribute of a SimpleMemoryVar object at $-1 */

SMVm1:	
		{ 
			_here;
			_if( $<adrs.Sym>-1 == NULL )
			
				$<s>$ = $<adrs.Type>-1; 

			_else
			
				$<s>$ = $<adrs.Sym>-1; 

			_endif
		};

  /* Get the attribute of a SimpleMemoryVar object at $0 */

SMV0:
		{
			_here;
			_if( $<adrs.Sym>0 == NULL )
			
				$<s>$ = $<adrs.Type>0; 

			_else
			
				$<s>$ = $<adrs.Sym>0; 

			_endif
		};


/*
** CallParameters-
**
**	Processes the actual parameter list for a procedure call.
**
**	On entry, $<s>0 points at the procedure's symbol table entry.
*/

CallParameters:
		'('
		SavePosn
		{
			_here;
			$<s>$ =	$<s>0;
			_if( $<s>$ == NULL )
			
				yyerror( "Undefined symbol or illegal parameter" );
				$<s>$ = &error_ste;
				
			_endif
			_here;
		}
		OptionalCallParameters
		Rparen
		{
			_here;
			(void) $<s>3;	// shut up bison
		}
	;


 
//  IndirectCallParameters-
// 
// 	Similar to CallParameters, but used by procedure
//  invocations made by a procedure pointer variable.
//
//	$<s>0 - Points at the variable containing the address of the
//			function we're trying to call.
//
//	On Return:
//
//	$<s>$ -	Points at the (type) entry that contains the
//			parameter list pointer in the u.proc.parms field.	
 

IndirectCallParameters:
		'('
		SavePosn
		{
			enum	PrimType	pType;
			struct	SymNode		*s;
			struct	SymNode		*typ;
			char				msg[256];
			char				name[32];

			_here;
			
			assert( $<s>0 != NULL );			// Must have some symbol

			_if( $<s>0->pType == tOverloads  )
			
				pType = tOverloads;
				$<s>$ = &dword_ste;

			_elseif( $<s>0->Type == NULL )
			
				// It must be some primitive type that is not
				// a function address.
				
				strncpy( name, $<s>0->TrueName, 31 );
				name[31] = 0;
				sprintf( msg, "Object cannot be called: '%s'", name );
				yyerror( msg );
				$<s>$ = &dummyProc_ste;

			_else
			
			
				// Get the base type of the (proc) pointer object:

				typ = GetBaseType( $<s>0->Type );
				pType =	typ->pType;
				_if
				(
						pType == tProcptr	// Var is a procedure pointer
					||	pType == tThunk		//  ... a thunk
					||	pType == tProc		//  Could be a method
					||	pType == tMethod	//  ... pointer to a class?
					||	pType == tClassProc	//  ... pointer to a class?
					||	pType == tClassIter	//  ... pointer to a class?
					||	(
								$<s>0->SymClass == cParm	// name or lazy parm
							&&	(
										$<s>0->pClass == name_pc
									||	$<s>0->pClass == lazy_pc
								)
						)
				)
				
					$<s>$ = typ;
				
				_else
				
					// It must be some primitive type that is not
					// a function address.
					
					strncpy( name, $<s>0->TrueName, 31 );
					name[31] = 0;
					sprintf( msg, "Object cannot be called: '%s'", name );
					yyerror( msg );
					$<s>$ = &dummyProc_ste;

				_endif
				
			_endif	
			_here;
		}
		OptionalCallParameters
		Rparen
		{
			_here;
			(void) $<s>3;	// shut up bison
		}
	;



OptionalCallParameters:

		Empty
		{
			_here;
			_if
			( 
					$<s>0->u.proc.parms != NULL 
				&&	$<s>0->u.proc.parms->SymClass == cParm 
			)

				yyerror( "Too few actual parameters" );

			_endif
		}

	|	CopyProc
		CopyParms
		OneorMoreCallParameters
		{
			_here;
		}
	;

CopyProc:
		{
			_here;
			$<s>$ = $<s>0;
		}
	;

CopyProc2:
		{
			_here;
			$<s>$ = $<s>-6;
		}
	;

CopyParms:
		{
			_here;
			_if( $<s>0->pType == tArray )
			
				$<s>$ = GetBaseType($<s>0->Type)->u.proc.parms;
				_if( $<s>$ == NULL )
				
					$<s>$ = $<s>0->Type->u.proc.parms;
					
				_endif
				
			_else
			
				$<s>$ = $<s>0->u.proc.parms;
				
			_endif
			assert( $<s>$ != NULL );
		}
	;


SaveFilePosn:
		{
			_here;
			$<v.u.unsval>$ = asmBuf->offset;
		}
	;
			

SaveParameter:
		{
			_here;
			_if
			( 
					$<s>-5->u.proc.cs == cdecl_cs 
				||	$<s>-5->u.proc.cs == stdcall_cs
			)
			
				$<v.u.strval>$ = getFileStr( $<v.u.unsval>0 );

			_else

				$<v.u.strval>$ = hlastrdup2( "" );

			_endif
			_here;
		}
	;


OneorMoreCallParameters:

		SaveFilePosn
		OneCallParameter
		{
			_here;
			_if( $<s>0 != NULL && $<s>0->SymClass != cParm )

				yyerror( "Too many actual parameters" );

			_elseif( $<s>0 == NULL || $<s>0->Next->SymClass == cParm )

				yyerror( "Too few actual parameters" );

			_endif
		}


	|	SaveFilePosn		/* $1 */
		OneCallParameter 	/* $2 */
		','					/* $3 */
		{					/* $4 */
			_here;
			$<v.u.unsval>$ = $<v.u.unsval>1;
		}
		SaveParameter		/* $5 */
		CopyProc2			/* $6 */
		{ 					/* $7 */

			assert( $<s>0 != NULL );

			_here;
			_if( $<s>0 == NULL || $<s>0->Next == NULL )

				yyerror( "Parameter error" );
				$<s>$ = &true_ste;

			_elseif( $<s>0->Next->SymClass != cParm )

				yyerror( "Too many actual parameters" );
				$<s>$ = $<s>0;

			_else

				$<s>$ = $<s>0->Next; 

			_endif
			assert( $<s>$ != NULL );
			_here;
		} 
		OneorMoreCallParameters	/* $8 */
		{
			_here;
			assert( $<s>-1 != NULL );
			_if
			( 
					$<s>-1->u.proc.cs == cdecl_cs 
				||	$<s>-1->u.proc.cs == stdcall_cs
			)

				asmPuts( $<v.u.strval>5 );
				asmPuts( "\n" );

			_endif
			(void) $<v.u.unsval>4;	// shut up bison
			(void) $<s>7;	// shut up bison
			free2( vss $<v.u.strval>5 );
			_here;
		}
	;






 /*
 ** OneCallParameter-
 **
 **	Processes a single actual parameter.
 **
 **	$<s>-1 points at the symbol table entry for the current parameter.
 */

OneCallParameter:
		fConstExpr
		{

			/*
			** If the actual parameter is a constant, the parameter
			** class *must* be a value parameter unless it's a tPointer
			** constant.
			*/

			_here;
			assert( $<s>-1 != NULL );

			_if( $<s>-1->pClass == valp_pc )

				PassValpConst( $<s>-1, YYS &$<v>1 );

			/*
			** If the parameter was passed by reference, by value/result,
			** or by result, only pointer constants are legal.
			*/

			_elseif 
			( 
					ByAddress( $<s>-1->pClass )
				&&	$<v.pType>1 == tPointer 
				
			)

				/*
				** Determine if we're passing this parameter
				** on the stack or in a register ($<s>1->StaticName
				** contains a pointer to a register name if we're
				** passing the parameter in a register).
				*/


				_if( $<s>-1->StaticName == NULL )

					_if( isdigit( *$<v.u.strval>1) )
					
						// Kludge!  NULL is treated like a
						// static name (whose static name is "0").
						// Let's undo that kludge here by creating
						// a numeric constant for zero and emitting that.
						
						int value = parsePtrExpr( $<v.u.strval>1 ); 
						Pushd( value );
					
					_else
					
						push_offset( YYS &$<v>1 );
						
					_endif
					
				_else // output is to register specified by $<s>-1->StaticName

					enum regnums rnum;
					struct adrsYYS adrs;
					
					rnum = RegStrToReg( $<s>-1->StaticName );
					_if( isdigit( *$<v.u.strval>1 ) )
					
						// Kludge!  NULL is treated like a
						// static name (whose static name is "0").
						// Let's undo that kludge here by creating
						// a numeric constant for zero and emitting that.
						
						int value = parsePtrExpr($<v.u.strval>1); 
						EmitMov_c_r( value, rnum );
					
					_else
					
						EmitMov_o_r
						( 
							$<v.u.strval>1, 
							0, 
							rnum 
						);
						
					_endif

				_endif


			/*
			** Currently, we will not allow constants to be passed
			** by name or by lazy evaluation.
			*/

			_else

				yyerror( "Constant is not allowed as parameter here" );

			_endif
			_here;
		}
	;
	




OneCallParameter:
		valTkn
		fConstExpr
		{

			_here;
			assert( $<s>-1 != NULL );

			_if
			( 
					!ByAddress( $<s>-1->pClass ) 
				&&	!($<s>-1->pClass == valp_pc && $<s>-1->pType == tString)
			)
			
				yyerror
				( 
					"VAL operator requires a VAR/VARRES/RESULT "
					"or STRING parameter"
				);
				
			/*
			** If the parameter was passed by reference, by value/result,
			** or by result, only pointer constants are legal.
			*/

			_elseif 
			( 
					$<v.pType>2 == tPointer
				||	(
							IsNumber( $<v.pType>2 )
						&&	numBits32( YYS &$<v>2 ) <= 32
					)
				||	( 
							$<s>-1->pClass == valp_pc 
						&&	$<s>-1->pType == tString 
						&&	IsNumber( $<v.pType>2 )
						&&	numBits32( YYS &$<v>2 ) <= 32
					)
			)

				/*
				** Determine if we're passing this parameter
				** on the stack or in a register.
				*/
				
				_if( $<s>-1->StaticName == NULL )
				
					// Okay, we're passing it on the stack
					// If the parameter is just a number, then
					// push that immediate constant on the stack.
					// Otherwise, push the value of the memory object.
					

					_if( IsNumber( $<v.pType>2 ))

						Pushd( $<v.u.unsval>2 );
						
					_else
					
						push_offset( YYS &$<v>2 );
						
					_endif
					
				_else // output is to register specified by $<s>-1->StaticName

					enum regnums rnum;
					struct adrsYYS adrs;
					
					rnum = RegStrToReg( $<s>-1->StaticName );
					_if( IsNumber( $<v.pType>2 ))

						EmitMov_c_r( $<v.u.unsval>2, rnum );
						
					_else
					
						EmitMov_o_r
						( 
							$<v.u.strval>2, 
							0, 
							rnum 
						);
						
					_endif
					
				_endif


			/*
			** Currently, we will not allow constants to be passed
			** by name or by lazy evaluation.
			*/

			_else

				yyerror( "Constant is not allowed as parameter here" );

			_endif
			_here;

		}
	;
	




	/*
	** Register parameters are easy to deal with.
	** All we've got to do is verify the size is correct.
	** For eight-bit registers, we also need to zero extend
	** the value we push on the stack.  For 16-bit register,
	** we need to zero extend the value if the minimum parm
	** size is four bytes.
	*/

OneCallParameter:
		fRegister 
		{

			enum regnums srcreg;
			enum regnums destreg;
			struct adrsYYS adrs;
			
			_here;
			assert( $<s>-1 != NULL );

			srcreg = $<reg.encoding>1;

			_if( $<s>-1->ObjectSize != $<reg.Size>1 )

				yyerror( "Register size does not match parameter size" );

			_endif
			_if( $<s>-1->pClass != valp_pc )

				yyerror( "Can only pass registers by value" );

			_endif

			/*
			** If the parameter is passed in a register, and
			** we're passing in a register, some quick checks
			** to see if we need to generate any code at all.
			*/

			_if( $<s>-1->StaticName != NULL )
			
				destreg = RegStrToReg( $<s>-1->StaticName );

				_if( srcreg != destreg )

					EmitMov_r_r( srcreg, destreg );

				/* _else // we're passing data in the same register */

				_endif

			_elseif( $<reg.Size>1 == 1 )

				/*
				** If minimum parm size is four bytes, we need to
				** push three extra bytes before the data byte.
				** The following code accomplishes this using the
				** eax register, while preserving eax's original value.
				*/


				_if( srcreg == reg_al )

					push_r( reg_eax );

				_elseif( srcreg == reg_bl )

					push_r( reg_ebx );

				_elseif( srcreg == reg_cl )

					push_r( reg_ecx );

				_elseif( srcreg == reg_dl )

					push_r( reg_edx );

				_else

					// "xH" registers have to be moved onto the stack:
					
					EmitGeneric_c_r( sub_instr, 4, reg_esp );
					initAdrs1( &adrs, reg_esp, 0 );
					EmitMov_r_m( srcreg, &adrs, 1 );

				_endif

				
			_elseif( $<reg.Size>1 == 2 )


				_if( srcreg == reg_ax )

					push_r( reg_eax );

				_elseif( srcreg == reg_bx )

					push_r( reg_ebx );

				_elseif( srcreg == reg_cx )

					push_r( reg_ecx );

				_elseif( srcreg == reg_dx )

					push_r( reg_edx );

				_elseif( srcreg == reg_si )

					push_r( reg_esi );

				_elseif( srcreg == reg_di )

					push_r( reg_edi );

				_elseif( srcreg == reg_bp )

					push_r( reg_ebp );

				_elseif( srcreg == reg_sp )

					push_r( reg_esp );

				_endif
			
			_else // Must be a 32-bit register.
			
				push_r( srcreg );
			
			_endif 
			_here;
		}
	;

	
OneCallParameter:
		edxeaxTkn 
		{

			
			_here;
			assert( $<s>-1 != NULL );
			_if( $<s>-1->ObjectSize != 8 )

				yyerror( "Register size does not match parameter size" );

			_endif
			_if( $<s>-1->pClass != valp_pc )

				yyerror( "Can only pass registers by value" );

			_endif

			
			push_r( reg_edx );
			push_r( reg_eax );
			_here;
		}
	;

	
	

OneCallParameter:
		dxaxTkn 
		{

			
			_here;
			assert( $<s>-1 != NULL );
			_if( $<s>-1->ObjectSize != 4 )

				yyerror( "Register size does not match parameter size" );

			_endif
			_if( $<s>-1->pClass != valp_pc )

				yyerror( "Can only pass registers by value" );

			_endif

			
			push_r( reg_dx );
			push_r( reg_ax );
			_here;
		}
	;

	
	



OneCallParameter:
		valTkn
		fRegister
		{
			enum regnums srcreg;
			enum regnums destreg;

			_here;
			assert( $<s>-1 != NULL );

			srcreg = $<reg.encoding>2;
			
			_if( $<reg.Size>2 != 4 )

				yyerror( "Must be a 32-bit register with VAL prefix" );

			_elseif
			( 
					!ByAddress( $<s>-1->pClass ) 
				&&	!($<s>-1->pClass == valp_pc && $<s>-1->pType == tString)
			)

				yyerror
				( 
					"VAL prefix is only legal with "
					"VAR/RESULT/VARRES/STRING parameters" 
				);

			_else

				/*
				** If the parameter is passed in a register, and
				** we're passing in a register, some quick checks
				** to see if we need to generate any code at all.
				*/

				_if( $<s>-1->StaticName != NULL )

					_if
					( 
						_strne
						( 
							$<s>-1->StaticName, 
							regStrs[ $<reg.encoding>2]
						)
					)

						destreg = RegStrToReg( $<s>-1->StaticName );
						EmitMov_r_r( srcreg, destreg );

					/* _else // we're passing data in the same register */

					_endif

				_else // Must be a 32-bit register.
				
					push_r( srcreg );
				
				_endif 
				
			_endif
			_here;
		}
	;

	
	

	/*
	** Okay, memory is really miserable.  Not only do we have to
	** deal with all the possible memory types, but we've also
	** got to deal with the fact that parameters can be passed by
	** value, by reference, by value/result, by result, by name,
	** and by lazy evaluation.
	*/	
	
OneCallParameter:
		fMemory
		{
			_here;
			
			_if( $<s>-1 != NULL && $<s>-2 != NULL )
			
				OutputMemParm( $<s>-2, $<s>-1, &$<adrs>1, 0 );
				
			_else
			
				yyerror( "Illegal parameter value" );
				
			_endif
			FreeAdrs( &$<adrs>1 );
			_here;
		}
	;





	
OneCallParameter:
		valTkn
		fMemory
		{
			_here;
			assert( $<s>-1 != NULL );
			OutputMemParm( $<s>-2, $<s>-1, &$<adrs>2, 1 );
			FreeAdrs( &$<adrs>2 );
			_here;
		}
	;





OneCallParameter:
		fAnonMem
		{
			int ASize0;

			_here;
			assert( $<s>-1 != NULL );

			$<adrs.Size>1 = 
				_ifx
				( 
					$<s>-1->Arity == 0, 
					$<s>-1->ObjectSize, 
					$<s>-1->Type->ObjectSize 
				);
			$<adrs.ObjectSize>1 = $<s>-1->ObjectSize;
			$<adrs.Type>1 = $<s>-1->Type;
			$<adrs.pType>1 = $<s>-1->pType;
			$<adrs.SymClass>1 = $<s>-1->SymClass;
			$<adrs.forcedSize>1 = $<adrs.Size>1;
			OutputMemParm( $<s>-2, $<s>-1, &$<adrs>1, 0 );
			FreeAdrs( &$<adrs>1 );
			_here;
		}
	;




OneCallParameter:
		valTkn
		fAnonMem
		{
			int ASize0;

			_here;
			assert( $<s>-1 != NULL );

			$<adrs.Size>2 = 
				_ifx
				( 
					$<s>-1->Arity == 0, 
					$<s>-1->ObjectSize, 
					$<s>-1->Type->ObjectSize 
				);
			$<adrs.ObjectSize>2 = $<s>-1->ObjectSize;
			$<adrs.Type>2 = $<s>-1->Type;
			$<adrs.pType>2 = $<s>-1->pType;
			$<adrs.SymClass>2 = $<s>-1->SymClass;
			$<adrs.forcedSize>2 = $<adrs.Size>2;
			OutputMemParm( $<s>-2, $<s>-1, &$<adrs>2, 1 );
			FreeAdrs( &$<adrs>2 );
			_here;
		}
	;


 /*
 ** Handle thunk declarations here for pass by name and
 ** pass by lazy evaluation parameters.
 */

OneCallParameter:
		doThunkTkn
		PreThunk
		stmtsTkn
		Stmts
		endstmtsTkn
		{
			char thunkname[ 256 ];

			_here;
			assert( $<s>-1 != NULL );

			sprintf( thunkname, "thunk_%u" sympost, $<v.u.unsval>2 );
			pop_r( reg_ebp );
			ret_instr( 4 );
			EndProc( thunkname );
			{
				char lbl[ 256 ];
				
				sprintf( lbl, "endthunk_%u" sympost, $<v.u.unsval>2 );
				EmitStmtLbl( lbl );
			}

			/*
			** Okay, now that we've processed this thunk, let's
			** make sure it's legal to have a thunk here.
			*/

			_if
			( 
					$<s>-1->pClass != name_pc 
				&&	$<s>-1->pClass != lazy_pc 
				&&  !(
							$<s>-1->pClass == valp_pc
						&&	$<s>-1->pType == tThunk
					)

			)

				yyerror
				( 
					"Thunks are only allowed for pass by name\n"
					"and pass by lazy evaluation parameters"
				);

			_endif

			inThunk = $<v.u.unsval>1;
			_here;
		}
	;


doThunkTkn:
		thunkTkn
		{
			_here;
			$<v.u.unsval>$ = inThunk;
			inThunk = 1;
		}
	;


PreThunk:
		{
			int ThunkNum;
			char tempProc[ 256 ];
			char procname[ 256 ];
			struct adrsYYS adrs;

			_here;
			ThunkNum = LblCntr++;
			
			sprintf( procname, "thunk_%d" sympost, ThunkNum );
			PushStaticAdrs( procname );
			push_r( reg_ebp );

			sprintf( procname, "endthunk_%d" sympost, ThunkNum );
			EmitJmpLabel( procname );
			  
			NewLn();
			sprintf( procname, "thunk_%d" sympost, ThunkNum );
			EmitComment( "thunk begins here" );
			StartProc( procname );
			push_r( reg_ebp );
			initAdrs( &adrs, reg_esp, -1, 0, 8 ); 
			EmitMov_m_r( &adrs, reg_ebp, 4 );
			$<v.u.intval>$ = ThunkNum;
			_here;
		}
	;
	  



/*

** If the "stmts" token appears as a parameter, just process
** the statements and leave it up to the user to push the
** appropriate parameter (with these statements) onto the stack.
*/

OneCallParameter:
		stmtsTkn		/* $1 */
		{				/* $2 */
			_here;
			$<v.u.unsval>$ = StartOfStmt;
		}
		StmtSequence	/* $3 */
		endstmtsTkn		/* $4 */
		{				/* $5 */
			_here;
			_if( $<returns>3 != NULL )

				free2( vss $<returns>3 );

			_endif
			StartOfStmt = $<v.u.unsval>2;
			_here;
		}
	;

/*****************************************************************/







 /*
 ** Handle the call instruction here.
 **
 **	Allowable syntax:
 **
 **	call LocalProcID;
 ** call( LocalProcID )		-- Returns "returns" value via fstmt.
 ** call NonLocalProcID;
 **	call( NonLocalProcID )	-- Returns "returns" value via fstmt.
 ** call( dwordvar );
 ** call( [anonmem] );
 ** call( Reg32 );
 **
 */


 /*
 ** Handle calling a procedure with a local procedure ID here.
 */


callParms:
		LocalProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	fstmt
		LocalProcID
		{
			_here;
			$<s>$ = $<s>2;
			SetReferenced( $<s>2 );
		}

	|	NonLocalProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	fstmt
		NonLocalProcID
		{
			_here;
			$<s>$ = $<s>2;
			SetReferenced( $<s>2 );
		}


	|	LocalIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	fstmt
		LocalIterID
		{
			_here;
			$<s>$ = $<s>2;
			SetReferenced( $<s>2 );
		}

	|	NonLocalIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );

		}

	|	fstmt
		NonLocalIterID
		{
			_here;
			$<s>$ = $<s>2;
			SetReferenced( $<s>2 );
		}


	|	ClassProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	fstmt
		ClassProcID
		{
			_here;
			$<s>$ = $<s>2;
			SetReferenced( $<s>2 );
		}
	;

CallTargetID:
		LocalLabelID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}
	
	|	NonLocalLabelID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}
	
	|	LocalProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	LocalIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	NonLocalProcID

		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	NonLocalIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	ClassProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}
	;
	
	
UndefProc:
		NonLocalID
		{			  
			_here;
			$<idStr>$ = hlastrdup2( $<s>1->TrueName );
		}

	|	NonLocalVarID
		{
			_here;
			$<idStr>$ =  hlastrdup2( $<s>1->TrueName );
		}

	|	NonLocalStaticID
		{
			_here;
			$<idStr>$ =  hlastrdup2( $<s>1->TrueName );
		}

	|	UndefID
		{
			_here;
			$<idStr>$ = $<idStr>1;
		}
		
	|	NonLocalConstID
		{
			_here;
			$<idStr>$ =  hlastrdup2( $<s>1->TrueName );
		}
	;

	




CallTarget:
		UndefProc
		{
			_here;
			callUndefSym( $<idStr>1 );
			free2( vss $<idStr>1 );
		}
	;








SingleStmt:
		callTkn
		CallTarget
		{
			_here;
			$<returns>$ = NULL;
			_here;
		}
	;



SingleStmt:
		callTkn
		CallTargetID
		{
			_here;
			EmitCallLabel( $<s>2->StaticName );
			SetReferenced( $<s>2 );
			$<returns>$ = NULL;
			_here;
		}



	|	callTkn
		Lparen
		callParms
		Rparen
		{
			_here;
			EmitCallLabel( $<s>3->StaticName );
			SetReferenced( $<s>3 );
			$<returns>$ = hlastrdup2( $<s>3->u.proc.returns );
		}
	;



SingleStmt:
		callTkn
		hereTkn
		';'
		{
			char label[64];
			
			_here;
			sprintf( label, "here" sympost "%d", LblCntr++ );
			EmitStmtLbl( label );
			EmitCallLabel( label );
			PushBackStr( ";" );
			$<returns>$ = NULL;
		}
	;
		
		
SingleStmt:
		callTkn
		hereTkn
		'['
		fConstOnlyExpr
		Rbrack
		{
			int  disp;
			char label[64];
			
			_here;
			disp = CheckOrdinalSize( YYS &$<v>4, 32 );
			sprintf( label, "here" sympost "%d", LblCntr );
			EmitStmtLbl( label );
			sprintf
			( 
				label, 
				"(here" sympost "%d%s%d)" , 
				LblCntr++, 
				_ifx( disp < 0, "", "+"),
				disp 
			);
			EmitCallLabel( label );
			$<returns>$ = NULL;
		}
	;



 /*
 ** Process indirect calls through dword memory locations here.
 */

SingleStmt:
		callTkn
		Lparen
		fEitherMemDest
		Rparen
		{
			_here;
			_if( $<adrs.Size>3 != 4 && $<adrs.Size>3 != 0 )

				yyerror( "Procedure pointer must be four bytes long" );

			_else

				EmitCall_m( &$<adrs>3 );

			_endif
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;

		}
	;

	

 /*
 ** Handle indirect calls through registers here.
 */

SingleStmt:
		callTkn
		Lparen
		fReg32
		Rparen
		{
			_here;
			EmitCall_r( $<reg.encoding>3 );
			$<returns>$ = NULL;
		}
	;









//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////


 /*
 ** EmptyParens-
 **
 **	This production handles the "()" that follow
 ** implied addressing mode instructions.  If the
 ** empty parentheses are not present, this production
 ** sneaks a peek at the next symbol.  If it is a ';'
 ** (meaning no parentheses are present), this production
 ** pushes the ';' back and succeeds.  This makes the
 ** parentheses optional for stand-alone statements
 ** (they are not optional for composed statements).
 */

EmptyParens:
		'('
		')'

	|	';'
		{
			/*
			** Note: productions following this one will expect
			** the semicolon, so put it back.
			*/

			_here;
			PushBackStr( ";" );
		}
	;



 /*													   
 ** Handle implied address mode (no operand) instructions here.
 */

SingleStmt:
		aaaTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ax" );
			implied_instr( aaa_instr );
		}

	|	aadTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ax" );
			implied_instr( aad_instr );
		}

	|	aamTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ax" );
			implied_instr( aam_instr );
		}

	|	aasTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ax" );
			implied_instr( aas_instr );
		}


	|	cbwTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ax" );
			implied_instr( cbw_instr );
		}


	|	cdqTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "eax" );
			implied_instr( cdq_instr );
		}


	|	clcTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( clc_instr );
		}


	|	cldTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( cld_instr );
		}


	|	cliTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( cli_instr );
		}


	|	cltsTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( clts_instr );
		}


	|	cmcTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( cmc_instr );
		}


	|	cpuidTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ax" );
			implied_instr( cpuid_instr );
		}


	|	cwdTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ax" );
			implied_instr( cwd_instr );
		}


	|	cwdeTkn
		EmptyParens
		{ 
			_here; 	
			$<returns>$ = hlastrdup2( "eax" );
			implied_instr( cwde_instr );
		}


	|	daaTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "al" );
			implied_instr( daa_instr );
		}

	|	dasTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "al" );
			implied_instr( das_instr );
		}

	|	hltTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( hlt_instr );
		}

	|	intoTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			_if( CompileInto )

				implied_instr( into_instr );

			_endif
		}

	|	invdTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( invd_instr );
		}

	|	iretTkn 
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( iret_instr );
		}

	|	iretdTkn 
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( iretd_instr );
		}

	|	lahfTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "al" );
			implied_instr( lahf_instr );
		}

	|	leaveTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( leave_instr );
		}

	|	nopTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( nop_instr );
		}

	|	popadTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			popad();
		}

	|	popaTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			popaw();
		}

	|	popfTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			popf();
		}

	|	popfdTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			popfd();
		}

	|	pushaTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( pusha_instr );
		}

	|	pushadTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( pushad_instr );
		}

	|	pushfTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			pushf();
		}

	|	pushfdTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			pushfd();
		}

	|	rdtscTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "edx:eax" );
			implied_instr( rdtsc_instr );
		}
		
	|	sysenterTkn
		EmptyParens
		{
			_here;
			$<returns>$ = NULL;
			implied_instr( sysenter_instr );
		}
		
	|	sysexitTkn
		EmptyParens
		{
			_here;
			$<returns>$ = NULL;
			implied_instr( sysexit_instr );
		}
		

	|	ud2Tkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( ud2_instr );
		}
		

	|	wbinvdTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( wbinvd_instr );
		}
		

	|	wrmsrTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( wrmsr_instr );
		}
		

	|	rdmsrTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "edx:eax" );
			implied_instr( rdmsr_instr );
		}

	|	rdpmcTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "edx:eax" );
			implied_instr( rdpmc_instr );
		}

	|	rsmTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( rsm_instr );
		}

	|	sahfTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ah" );
			implied_instr( sahf_instr );
		}

	|	stcTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( stc_instr );
		}

	|	stdTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( std_instr );
		}

	|	stiTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( sti_instr );
		}

	|	waitTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( wait_instr );
		}

	|	xlatTkn
		EmptyParens
		{
			_here; 
			$<returns>$ = NULL;
			implied_instr( xlat_instr );
		}
	;




		













/***********************************************************************/

 /*
 ** Handle the POP instruction here.
 */
 
 SingleStmt:
 		popTkn
		Lparen
		fRegister
		Rparen
		{
			_here;
			_if( $<reg.Size>3 == 1 )

				yyerror( "Eight-bit register is illegal here" );

			_endif
			pop_r( $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
		}


 	|	popTkn		/* $1 */
		Lparen		/* $2 */
		fSegReg		/* $3 */
		Rparen		/* $4 */
		{
			_here;
			_if( $<u>3 == reg_cseg )

				yyerror( "Cannot pop CS register" );

			_endif
			pop_sr( $<u>3 );
			$<returns>$ = hlastrdup2( segStrs[ $<u>3 ]);
		}


 	|	popTkn
		Lparen
		fMemoryDest
		Rparen
		{
			_here;
			_if( $<adrs.Size>3 == 2 || $<adrs.Size>3 == 4 )

				pop_mem( &$<adrs>3, $<adrs.Size>3 );

			_else

				yyerror( SizeMismatchStr );

			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
		}
	;










 /*
 ** Handle the PUSH, PUSHW, and PUSHD instructions here.
 **
 ** Syntax:
 **
 **		push( Reg16 )
 **		push( Reg32 )
 **		push( memory )
 **
 **		pushw( Reg16 )
 **		pushw( memory )
 **		pushw( AnonMem )
 **		pushw( Const )
 **
 **		pushd( Reg32 )
 **		pushd( memory )
 **		pushd( AnonMem )
 **		pushd( Const )
 */


SingleStmt:
		pushwTkn
		Lparen
		fRegister
		Rparen
		{
			_here;
			_if( $<reg.Size>3 != 2 )

				yyerror( "Illegal register size" );

			_endif
			push_r( $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
		}
	;


SingleStmt:
 		pushwTkn
		Lparen
		fMemory
		Rparen
		{
			char adrs[ 256 ];

			_here;
			_if( $<adrs.Size>3 == 2 )

				push_mem( &$<adrs>3, 2 );

			_else

				yyerror( SizeMismatchStr );

			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
		}
	;




SingleStmt:
		pushwTkn
		Lparen
		fConstExpr
		Rparen
		{
			char *Result;

			_here;
			Result = CheckOrdinal( YYS &$<v>3, 16 );
			Pushw( $<v.u.unsval>3 );
			$<returns>$ = Result;
		}
	;





SingleStmt:
		pushwTkn
		Lparen
		fAnonMem
		Rparen
		{
			char adrs[ 256 ];
			char mem[ 256 ];

			_here;
			push_mem( &$<adrs>3, 2 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;











SingleStmt:
		pushdTkn
		Lparen
		fRegister
		Rparen
		{
			_here;
			_if( $<reg.Size>3 != 4 )

				yyerror( "Illegal register size" );

			_endif
			push_r( $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
		}
	;


SingleStmt:
 		pushdTkn
		Lparen
		fMemory
		Rparen
		{
			char as[ 256 ];
			char mem[ 256 ];

			_here;
			_if( $<adrs.Size>3 == 4 )

				push_mem( &$<adrs>3, 4 );

			_else

				yyerror( SizeMismatchStr );

			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
		}
	;






SingleStmt:
		pushdTkn
		Lparen
		fConstExpr
		Rparen
		{
			char *Result;

			_here;
			_if( $<v.pType>3 == tPointer )

				_if( isdigit( *$<v.u.strval>3 ))
				
					int value = parsePtrExpr( $<v.u.strval>3 );
					
					Result = hlastrdup2( $<v.u.strval>3 );
					Pushd( value );
					
				_else
				
					push_offset( YYS &$<v>3 );
					Result = hlastrdup2( "" );		// This is bogus
													// and needs to be fixed.
													
				_endif

			_else

				Result = CheckOrdinal( YYS &$<v>3, 32 );
				Pushd( $<v.u.unsval>3 );

			_endif
			$<returns>$ = Result;
		}
	;






SingleStmt:
		pushdTkn
		Lparen
		fAnonMem
		Rparen
		{
			char adrs[ 256 ];
			char mem[ 256 ];

			_here;
			push_mem( &$<adrs>3, 4 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;
















SingleStmt:
		pushTkn
		Lparen
		fRegister
		Rparen
		{
			_here;
			_if( $<reg.Size>3 == 1 )

				yyerror( "Illegal register size" );

			_endif
			push_r( $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
		}
	;





SingleStmt:
		pushTkn
		Lparen
		edxeaxTkn
		Rparen
		{
			_here;
			push_r( reg_edx );
			push_r( reg_eax );
			$<returns>$ = hlastrdup2( "edx:eax" );
		}
	;



SingleStmt:
		pushTkn
		Lparen
		fstmt
		edxeaxTkn
		Rparen
		{
			_here;
			push_r( reg_edx );
			push_r( reg_eax );
			$<returns>$ = hlastrdup2( "edx:eax" );
		}
	;




SingleStmt:
		pushTkn
		Lparen
		dxaxTkn
		Rparen
		{
			_here;
			push_r( reg_dx );
			push_r( reg_ax );
			$<returns>$ = hlastrdup2( "dx:ax" );
		}
	;



SingleStmt:
		pushTkn
		Lparen
		fstmt
		dxaxTkn
		Rparen
		{
			_here;
			push_r( reg_dx );
			push_r( reg_ax );
			$<returns>$ = hlastrdup2( "dx:ax" );
		}
	;





SingleStmt:
		pushTkn		/* $1 */
		Lparen		/* $2 */
		fSegReg		/* $3 */
		Rparen		/* $4 */
		{
			_here;
			push_sr( $<u>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<u>3 ]);
		}
	;





SingleStmt:
 		pushTkn
		Lparen
		fMemory
		Rparen
		{
			char adrs[ 256 ];

			_here;
			_if( $<adrs.Size>3 == 2 || $<adrs.Size>3 == 4 )

				push_mem( &$<adrs>3, $<adrs.Size>3 );

			_else

				yyerror( SizeMismatchStr );

			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
		}
	;












	/*
	** Handle some common errors here.
	*/



SingleStmt:
	 	pushTkn
		Lparen
		fUndefID
		Rparen
		{
			char msg[256];

			sprintf( msg, "Undefined ID: %s", $<idStr>3 );
			yyerror( msg );
			$<returns>$ = hlastrdup2( $<idStr>3 );
		}

	|	pushTkn
		Lparen
		fAnonMem
		Rparen
		{
			yyerror( "Must specify memory size" );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
		}
	;


















// Floating-point register definitions:

fp_reg:
		fp_reg_st0
		{
			_here;
			$<u>$ = $<u>1;
		}
		
	|	fp_reg_not0		/* $1 */
		{
			_here;
			$<u>$ = $<u>1;
		}
	;
	
fp_reg_st0:
		st0Tkn	/* $1 */
		{
			_here;
			$<u>$ = reg_st0;
		}
		
	|	fstmt	/* $1 */
		st0Tkn	/* $2 */
		{
			_here;
			$<u>$ = reg_st0;
		}
	;
	
fp_reg_not0:
		st1Tkn
		{
			_here;
			$<u>$ = reg_st1;
		}
	
	|	st2Tkn
		{
			_here;
			$<u>$ = reg_st2;
		}
	
	|	st3Tkn
		{
			_here;
			$<u>$ = reg_st3;
		}
	
	|	st4Tkn
		{
			_here;
			$<u>$ = reg_st4;
		}
	
	|	st5Tkn
		{
			_here;
			$<u>$ = reg_st5;
		}
	
	|	st6Tkn
		{
			_here;
			$<u>$ = reg_st6;
		}
	
	|	st7Tkn
		{
			_here;
			$<u>$ = reg_st7;
		}
		
	|	fstmt
		st1Tkn
		{
			_here;
			$<u>$ = reg_st1;
		}
	
	|	fstmt
		st2Tkn
		{
			_here;
			$<u>$ = reg_st2;
		}
	
	|	fstmt
		st3Tkn
		{
			_here;
			$<u>$ = reg_st3;
		}
	
	|	fstmt
		st4Tkn
		{
			_here;
			$<u>$ = reg_st4;
		}
	
	|	fstmt
		st5Tkn
		{
			_here;
			$<u>$ = reg_st5;
		}
	
	|	fstmt
		st6Tkn
		{
			_here;
			$<u>$ = reg_st6;
		}
	
	|	fstmt
		st7Tkn
		{
			_here;
			$<u>$ = reg_st7;
		}
	;
	

	



/*
** Arithmetic Instructions:
**
**	FADD, FADDP, FSUB, FSUBP, FSUBR, FSUBRP, FCOM, FCOMP, FCOMPP, 
**  FMUL, FMULP, FDIV, FDIVP, FDIVR, FDIVRP
*/

FP_arith_instr:
		faddTkn		/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fadd_instr;
			_here;
		}

	|	fmulTkn		/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fmul_instr;
			_here;
		}

	|	fcomTkn		/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fcom_instr;
			_here;
		}

	|	fcompTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fcomp_instr;
			_here;
		}

	|	fsubrTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fsubr_instr;
			_here;
		}

	|	fsubTkn		/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fsub_instr;
			_here;
		}

	|	fdivrTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fdivr_instr;
			_here;
		}

	|	fdivTkn		/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fdiv_instr;
			_here;
		}
	;
	
	

FPP_arith_instr:
		faddpTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = faddp_instr;
			_here;
		}

	|	fmulpTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fmulp_instr;
			_here;
		}
		
	|	fcomppTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fcompp_instr;
			_here;
		}

	|	fsubrpTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fsubrp_instr;
			_here;
		}

	|	fsubpTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fsubp_instr;
			_here;
		}

	|	fdivrpTkn	/* $1 */
		{			/* $4 */

			_here;
			$<u>$ = fdivrp_instr;
			_here;
		}
		
	|	fdivpTkn	/* $1 */
		{			/* $4 */

			_here;
			$<u>$ = fdivp_instr;
			_here;
		}
	;
	

	
	

// Handle FP instructions with no operands:

SingleStmt:
		FP_arith_instr		/* $1 */
		EmptyParens			/* $2 */
		{					/* $3 */

			_here;
			fp_arith_noOp_instr( $<u>1 );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;
	
	
	
		
SingleStmt:
		FPP_arith_instr		/* $1 */
		EmptyParens			/* $2 */
		{					/* $3 */

			_here;

			// Must translate fXXX instruction to fXXXp instruction!
			
			fpp_arith_noOp_instr( $<u>1 );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;
	
	
	
// Handle FP arithmetic instructions that have an ST(i), ST0 operand
// pair (i <> 0).


SingleStmt:
		FP_arith_instr		/* $1 */
		Lparen				/* $2 */
		fp_reg_not0			/* $3 */
		comma				/* $4 */
		fp_reg_st0			/* $5 */
		Rparen				/* $6 */
		{					/* $7 */

			_here;
			
			// fcom and fcomp have reversed operand ordering.
			// The CPU doesn't support xxx( st0, sti ) instructions,
			// so don't allow that here.
			
			_if( $<u>1 == fcom_instr || $<u>1 == fcomp_instr )
			
				yyerror( "fcom and fcomp do not allow 'ST0, STi' operands" );
				
			_endif
			
			fp_arith_sti_st0_instr( $<u>1, $<u>3 );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;
	
	
	
// Handle FP arithmetic instructions that have an ST0, ST(i) operand


SingleStmt:
		FP_arith_instr		/* $1 */
		Lparen				/* $2 */
		fp_reg_st0			/* $3 */
		comma				/* $4 */
		fp_reg				/* $5 */
		Rparen				/* $6 */
		{					/* $7 */

			char stirtn[4] = "st0";
			_here;
			
			fp_arith_st0_sti_instr( $<u>1, $<u>5 );

			stirtn[2] |= ($<u>5 & 0x7);
			$<returns>$ = hlastrdup2( stirtn );
			_here;
		}
	;
		
SingleStmt:
		FPP_arith_instr		/* $1 */
		Lparen				/* $2 */
		fp_reg_st0			/* $3 */
		comma				/* $4 */
		fp_reg				/* $5 */
		')'					/* $6 */
		{					/* $7 */

			char stirtn[4] = "st0";
			_here;
			
			_if( $<u>1 == fcompp_instr && $<u>5 != reg_st1 )
			
				yyerror( "fcompp only allows '( st0, st1') operands" );
				$<u>5 = reg_st1;
				
			_endif
			fpp_arith_st0_sti_instr( $<u>1, $<u>5 );
			stirtn[2] |= ($<u>5 & 0x7);
			$<returns>$ = hlastrdup2( stirtn );
			_here;
		}
	;
		
// fXXXX( STi ) variant of the above (st0 implied).
		
SingleStmt:
		FP_arith_instr		/* $1 */
		Lparen				/* $2 */
		fp_reg				/* $3 */
		')'					/* $4 */
		{					/* $5 */

			char stirtn[4] = "st0";
			_here;
			
			fp_arith_st0_sti_instr( $<u>1, $<u>3 );
			stirtn[2] |= ($<u>3 & 0x7);
			$<returns>$ = hlastrdup2( stirtn );
			_here;
		}
	;
		
// fXXXXp STi variant of the above (st0 implied).

SingleStmt:
		FPP_arith_instr		/* $1 */
		Lparen				/* $2 */
		fp_reg				/* $3 */
		')'					/* $4 */
		{					/* $5 */

			char stirtn[4] = "st0";
			_here;
			
			// Convert from fXXX instr to fXXXp instr!
			
			fpp_arith_st0_sti_instr( fp_fpp_xlat[$<u>1], $<u>3 );
			stirtn[2] |= ($<u>3 & 0x7);
			$<returns>$ = hlastrdup2( stirtn );
			_here;
		}
	;
	

	
	
// Handle FP arithmetic instructions that have a single memory operand


SingleStmt:
		FP_arith_instr		/* $1 */
		Lparen				/* $2 */
		fMemory				/* $3 */
		Rparen				/* $4 */
		{					/* $5 */

			_here;
			
			fp_arith_mem_instr( $<u>1, &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;
	

	
	
// Handle FP arithmetic instructions that have a constant operand


SingleStmt:
		FP_arith_instr		/* $1 */
		Lparen				/* $2 */
		fConstExpr			/* $3 */
		Rparen				/* $4 */
		{					/* $5 */

			struct adrsYYS adrs;
			char name [ 256 ];

			_here;
			_if( IsReal( $<v.pType>3 ))
				
				// Extend real32 and real64 constants to real80
				// (always compatible, so just ignore return result):
				
				IsCompatible( &real80_ste, YYS &$<v>3 );

				sprintf( name, "fpconst" sympost "%d", LblCntr++ );
				startStrSeg();
				OutValue( name, &real64_ste, YYS &$<v>3 );
				endStrSeg();
				
				initAdrs( &adrs, -1, -1, 0, 0 );
				adrs.StaticName = hlastrdup( name );
				adrs.Size = 8;
				fp_arith_mem_instr( $<u>1, &adrs );
				FreeValue( YYS &$<v>3 );
				
			_else
			
				yyerror( "FP instructions require real constant operands" );
				
			_endif
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;
	

	
	
// Handle FP/Integer arithmetic instructions that have a single memory operand


SingleStmt:
		FPI_arith_instr		/* $1 */
		Lparen				/* $2 */
		fMemory				/* $3 */
		Rparen				/* $4 */
		{					/* $5 */

			_here;
			
			fpi_arith_mem_instr( $<u>1, &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;	


// Fake a memory operand for the FP/integer instructions.

SingleStmt:
		FPI_arith_instr		/* $1 */
		Lparen				/* $2 */
		fConstExpr			/* $3 */
		Rparen				/* $4 */
		{					/* $5 */

			char			*operand;
			struct	adrsYYS adrs;
			char			label[64];
			
			_here;
			
			operand = CheckOrdinal( YYS &$<v>3, 64 );
			sprintf( label, "fp_int_const" sympost "%d", LblCntr++ );
			startStrSeg();
			EmitData
			( 
				label,
				tQWord, 
				operand 
			);
			endStrSeg();
			initLbl( &adrs, label, 0 );
			adrs.Size = 8;
			fpi_arith_mem_instr( $<u>1, &adrs );
			FreeValue( YYS &$<v>3 );
			free2( vss operand );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;	

		
			

FPI_arith_instr:
		fiaddTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fiadd_instr;
			_here;
		}

	|	fimulTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fimul_instr;
			_here;
		}

	|	ficomTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = ficom_instr;
			_here;
		}

	|	ficompTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = ficomp_instr;
			_here;
		}

	|	fisubrTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fisubr_instr;
			_here;
		}

	|	fisubTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fisub_instr;
			_here;
		}

	|	fidivrTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fidivr_instr;
			_here;
		}

	|	fidivTkn	/* $1 */
		{			/* $2 */

			_here;
			$<u>$ = fidiv_instr;
			_here;
		}
	;
	
	

/*
** fsqrt instruction
*/

SingleStmt:
		fsqrtTkn
		EmptyParens
		{
			_here;
			implied_instr( fsqrt_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fscale instruction
*/

SingleStmt:
		fscaleTkn
		EmptyParens
		{
			_here;
			implied_instr( fscale_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fprem instruction
*/

SingleStmt:
		fpremTkn
		EmptyParens
		{
			_here;
			implied_instr( fprem_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fprem1 instruction
*/

SingleStmt:
		fprem1Tkn
		EmptyParens
		{
			_here;
			implied_instr( fprem1_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** frndint instruction
*/

SingleStmt:
		frndintTkn
		EmptyParens
		{
			_here;
			implied_instr( frndint_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fxtract instruction
*/

SingleStmt:
		fxtractTkn
		EmptyParens
		{
			_here;
			implied_instr( fxtract_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fabs instruction
*/

SingleStmt:
		fabsTkn
		EmptyParens
		{
			_here;
			implied_instr( fabs_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fchs instruction
*/

SingleStmt:
		fchsTkn
		EmptyParens
		{
			_here;
			implied_instr( fchs_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** ftst instruction
*/

SingleStmt:
		ftstTkn
		EmptyParens
		{
			_here;
			implied_instr( ftst_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fxam instruction
*/

SingleStmt:
		fxamTkn
		EmptyParens
		{
			_here;
			implied_instr( fxam_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fldz instruction
*/

SingleStmt:
		fldzTkn
		EmptyParens
		{
			_here;
			implied_instr( fldz_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fld1 instruction
*/

SingleStmt:
		fld1Tkn
		EmptyParens
		{
			_here;
			implied_instr( fld1_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fldpi instruction
*/

SingleStmt:
		fldpiTkn
		EmptyParens
		{
			_here;
			implied_instr( fldpi_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fldl2t instruction
*/

SingleStmt:
		fldl2tTkn
		EmptyParens
		{
			_here;
			implied_instr( fldl2t_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fldl2e instruction
*/

SingleStmt:
		fldl2eTkn
		EmptyParens
		{
			_here;
			implied_instr( fldl2e_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fldlg2 instruction
*/

SingleStmt:
		fldlg2Tkn
		EmptyParens
		{
			_here;
			implied_instr( fldlg2_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fldln2 instruction
*/

SingleStmt:
		fldln2Tkn
		EmptyParens
		{
			_here;
			implied_instr( fldln2_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** f2xm1 instruction
*/

SingleStmt:
		f2xm1Tkn
		EmptyParens
		{
			_here;
			implied_instr( f2xm1_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fsin instruction
*/

SingleStmt:
		fsinTkn
		EmptyParens
		{
			_here;
			implied_instr( fsin_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fcos instruction
*/

SingleStmt:
		fcosTkn
		EmptyParens
		{
			_here;
			implied_instr( fcos_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fsincos instruction
*/

SingleStmt:
		fsincosTkn
		EmptyParens
		{
			_here;
			implied_instr( fsincos_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fptan instruction
*/

SingleStmt:
		fptanTkn
		EmptyParens
		{
			_here;
			implied_instr( fptan_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fpatan instruction
*/

SingleStmt:
		fpatanTkn
		EmptyParens
		{
			_here;
			implied_instr( fpatan_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fyl2x instruction
*/

SingleStmt:
		fyl2xTkn
		EmptyParens
		{
			_here;
			implied_instr( fyl2x_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** fyl2xp1 instruction
*/

SingleStmt:
		fyl2xp1Tkn
		EmptyParens
		{
			_here;
			implied_instr( fyl2xp1_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;


/*
** finit instruction
*/

SingleStmt:
		finitTkn
		EmptyParens
		{
			_here;
			implied_instr( finit_instr );
			$<returns>$ = NULL;
			_here;
		}
	;


SingleStmt:
		fninitTkn
		EmptyParens
		{
			_here;
			implied_instr( fninit_instr );
			$<returns>$ = NULL;
			_here;
		}
	;


/*
** fwait instruction
*/

SingleStmt:
		fwaitTkn
		EmptyParens
		{
			_here;
			implied_instr( fwait_instr );
			$<returns>$ = NULL;
			_here;
		}
	;


/*
** fclex instruction
*/

SingleStmt:
		fclexTkn
		EmptyParens
		{
			_here;
			implied_instr( fclex_instr );
			$<returns>$ = NULL;
			_here;
		}
	;

SingleStmt:
		fnclexTkn
		EmptyParens
		{
			_here;
			implied_instr( fnclex_instr );
			$<returns>$ = NULL;
			_here;
		}
	;

/*
** fincstp instruction
*/

SingleStmt:
		fincstpTkn
		EmptyParens
		{
			_here;
			implied_instr( fincstp_instr );
			$<returns>$ = NULL;
			_here;
		}
	;

/*
** fdecstp instruction
*/

SingleStmt:
		fdecstpTkn
		EmptyParens
		{
			_here;
			implied_instr( fdecstp_instr );
			$<returns>$ = NULL;
			_here;
		}
	;

/*
** fnop instruction
*/

SingleStmt:
		fnopTkn
		EmptyParens
		{
			_here;
			implied_instr( fnop_instr );
			$<returns>$ = NULL;
			_here;
		}
	;

SingleStmt:
		fucomppTkn	/* $1 */
		EmptyParens	/* $2 */
		{			/* $3 */
			_here;
			implied_instr( _fucompp_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;



// fld instruction:

SingleStmt:
		fldTkn			/* $1 */
		Lparen			/* $2 */
		fp_reg			/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fld_sti( $<u>3 );
			$<returns>$ = hlastrdup( uToSTi[ $<u>3 ] );
			_here;
		}
	;
		
SingleStmt:
		fldTkn			/* $1 */
		Lparen			/* $2 */
		fMemory			/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fld_mem( &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup( "st0" );
			_here;
		}
	;
		
SingleStmt:
		fldTkn			/* $1 */
		Lparen			/* $2 */
		fConstExpr		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
		
			struct adrsYYS adrs;
			char name [ 256 ];

			_here;
			_if( IsReal( $<v.pType>3 ))
			
				// Extend real32 and real64 constants to real80
				// (always compatible, so just ignore return result):
				
				IsCompatible( &real80_ste, YYS &$<v>3 );

				sprintf( name, "fpconst" sympost "%d", LblCntr++ );
				startStrSeg();
				OutValue( name, &real80_ste, YYS &$<v>3 );
				endStrSeg();
				
				initAdrs( &adrs, -1, -1, 0, 0 );
				adrs.StaticName = hlastrdup( name );
				adrs.Size = 10;
				fld_mem( &adrs );

			_else

				yyerror( "Expected a floating point constant" );

			_endif
			$<returns>$ = hlastrdup2( name );
			FreeAdrs( &adrs );
		}
	;



// fst instruction:

SingleStmt:
		fstTkn			/* $1 */
		Lparen			/* $2 */
		fp_reg			/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fst_sti( $<u>3 );
			$<returns>$ = hlastrdup( uToSTi[ $<u>3 ] );
			_here;
		}
	;
		
SingleStmt:
		fstTkn			/* $1 */
		Lparen			/* $2 */
		fMemoryDest		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fst_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;


// fstp instruction:

SingleStmt:
		fstpTkn			/* $1 */
		Lparen			/* $2 */
		fp_reg			/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fstp_sti( $<u>3 );
			$<returns>$ = hlastrdup( uToSTi[ $<u>3 ] );
			_here;
		}
	;
		
SingleStmt:
		fstpTkn			/* $1 */
		Lparen			/* $2 */
		fMemoryDest		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fstp_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;





// fxch instruction:

SingleStmt:
		fxchTkn		/* $1 */
		EmptyParens /* $2 */
		{			/* $3 */

			_here;
			implied_instr( fxch_instr );
			$<returns>$ = hlastrdup2( "st0" );
			_here;
		}
	;

SingleStmt:
		fxchTkn			/* $1 */
		Lparen			/* $2 */
		fp_reg			/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fxch_sti( $<u>3 );
			$<returns>$ = hlastrdup( "st0" );
			_here;
		}
	;




// fist instruction:

SingleStmt:
		fistTkn			/* $1 */
		Lparen			/* $2 */
		fMemoryDest		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fist_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;


// fistp instruction:

SingleStmt:
		fistpTkn		/* $1 */
		Lparen			/* $2 */
		fMemoryDest		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fistp_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;





// fild instruction:

SingleStmt:
		fildTkn			/* $1 */
		Lparen			/* $2 */
		fMemory			/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fild_mem( &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup( "st0" );
			_here;
		}
	;





 // FISTTP

SingleStmt:
		fisttpTkn		/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			// MASM6 doesn't support this instruction, so we must
			// manually encode it.

			_here;
			fisttp_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
		}
	;





// fbstp instruction:

SingleStmt:
		fbstpTkn		/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fbstp_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;





// fbld instruction:

SingleStmt:
		fbldTkn			/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here;
			fbld_mem( &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup( "st0" );
			_here;
		}
	;


SingleStmt:
		ffreeTkn		/* $1 */
		Lparen			/* $2 */
		fp_reg			/* $3 */
		Rparen			/* $4 */
		{
			_here;
			ffree_sti( $<u>3 );
			$<returns>$ = NULL;
			_here;
		}
	;
	
	
	
fp_op1Or2:
		fcmovbTkn
		{
			_here;
			$<u>$ = fcmovb_instr;
		}
	
	|	fcmovnaeTkn
		{
			_here;
			$<u>$ = fcmovb_instr;
		}
	
	|	fcmoveTkn
		{
			_here;
			$<u>$ = fcmove_instr;
		}
		
	|	fcmovbeTkn
		{
			_here;
			$<u>$ = fcmovbe_instr;
		}
		
	|	fcmovnaTkn
		{
			_here;
			$<u>$ = fcmovbe_instr;
		}
		
	|	fcmovuTkn
		{
			_here;
			$<u>$ = fcmovu_instr;
		}
	
	|	fcmovnbTkn
		{
			_here;
			$<u>$ = fcmovnb_instr;
		}
	
	|	fcmovaeTkn
		{
			_here;
			$<u>$ = fcmovnb_instr;
		}
	
	|	fcmovneTkn
		{
			_here;
			$<u>$ = fcmovne_instr;
		}
		
	|	fcmovnbeTkn
		{
			_here;
			$<u>$ = fcmovnbe_instr;
		}
		
	|	fcmovaTkn
		{
			_here;
			$<u>$ = fcmovnbe_instr;
		}
		
	|	fcmovnuTkn
		{
			_here;
			$<u>$ = fcmovnu_instr;
		}
	;
	
SingleStmt:
		fp_op1Or2	/* $1 */
		Lparen		/* $2 */
		fp_reg		/* $3 */
		Rparen		/* $4 */
		{			/* $5 */
			_here;
			fp_op1Or2_instr( $<u>1, $<u>3 ); 
			_here;
		}
	;
		
SingleStmt:
		fp_op1Or2		/* $1 */
		Lparen			/* $2 */
		fp_reg			/* $3 */
		','				/* $4 */
		fp_reg_st0		/* $5 */
		Rparen			/* $6 */
		{
			_here;
			fp_op1Or2_instr( $<u>1, $<u>3 );
			$<returns>$ = hlastrdup( "st0" ); 
			_here;
		}
	;
	
	

fp_com1Or2:
		fucomiTkn
		{
			_here;
			$<u>$ = fucomi_instr;
		}
		
	|	fcomiTkn
		{
			_here;
			$<u>$ = fcomi_instr;
		}
		
	|	fucomipTkn
		{
			_here;
			$<u>$ = fucomip_instr;
		}
		
	|	fcomipTkn
		{
			_here;
			$<u>$ = fcomip_instr;
		}
	;
	
SingleStmt:
		fp_com1Or2	/* $1 */
		Lparen		/* $2 */
		fp_reg		/* $3 */
		Rparen		/* $4 */
		{			/* $5 */
			_here;
			fp_op1Or2_instr( $<u>1, $<u>3 ); 
			_here;
		}
		
	|	fp_com1Or2		/* $1 */
		Lparen			/* $2 */
		fp_reg_st0		/* $3 */
		','				/* $4 */
		fp_reg			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			fp_op1Or2_instr( $<u>1, $<u>5 );
			$<returns>$ = hlastrdup( "st0" ); 
			_here;
		}
	;
	
	


	
SingleStmt:
		fucompTkn
		EmptyParens
		{
			_here;
			fp_op1Or2_instr( fucomp_instr, reg_st1 ); 
			$<returns>$ = hlastrdup( "st0" ); 
			_here;
		}
	;
		
SingleStmt:
		fucompTkn	/* $1 */
		Lparen		/* $2 */
		fp_reg		/* $3 */
		Rparen		/* $4 */
		{
			_here;
			fp_op1Or2_instr( fucomp_instr, $<u>3 ); 
			$<returns>$ = hlastrdup( "st0" ); 
			_here;
		}
	;
		
SingleStmt:
		fucompTkn	/* $1 */
		Lparen		/* $2 */
		fp_reg_st0	/* $3 */
		','			/* $4 */
		fp_reg		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			fp_op1Or2_instr( fucomp_instr, $<u>5 ); 
			$<returns>$ = hlastrdup( "st0" ); 
			_here;
		}
	;
	
SingleStmt:
		fucomTkn
		EmptyParens
		{
			_here;
			fp_op1Or2_instr( fucom_instr, reg_st1 ); 
			$<returns>$ = hlastrdup( "st0" ); 
			_here;
		}
	;
		
SingleStmt:
		fucomTkn	/* $1 */
		Lparen		/* $2 */
		fp_reg		/* $3 */
		Rparen		/* $4 */
		{
			_here;
			fp_op1Or2_instr( fucom_instr, $<u>3 ); 
			$<returns>$ = hlastrdup( "st0" ); 
			_here;
		}
	;
		
SingleStmt:
		fucomTkn	/* $1 */
		Lparen		/* $2 */
		fp_reg_st0	/* $3 */
		','			/* $4 */
		fp_reg		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			fp_op1Or2_instr( fucom_instr, $<u>5 ); 
			$<returns>$ = hlastrdup( "st0" ); 
			_here;
		}
	;
		
	
	
				



/*
** fldenv/fstenv instructions
*/


SingleStmt:
		fldenvTkn		/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			_here;
			fldenv_mem( &$<adrs>3 );
			_here;
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
		}
	;


SingleStmt:
		fstenvTkn		/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			_here;
			fstenv_mem( &$<adrs>3, 1 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;


SingleStmt:
		fnstenvTkn		/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			_here;
			fstenv_mem( &$<adrs>3, 0 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;


SingleStmt:
		fsaveTkn
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			_here;
			fsave_mem( &$<adrs>3, 1 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;

SingleStmt:
		fnsaveTkn
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			_here;
			fsave_mem( &$<adrs>3, 0 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;


SingleStmt:
		frstorTkn
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			_here;
			frstor_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;






SingleStmt:
		fxrstorTkn
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			_here;
			fxrstor_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;



SingleStmt:
		fxsaveTkn
		Lparen				/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			_here;
			fxsave_mem( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;






/*
** fldcw & fstcw instructions
*/

SingleStmt:
		fldcwTkn	/* $1 */
		Lparen		/* $2 */
		fMemoryDest	/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			_if( $<adrs.Size>3 != 2 )

				yyerror
				( 
					"Expected a word sized operand" 
				);

			_endif
			fldcw_mem( &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}
	;


SingleStmt:
		fldcwTkn	/* $1 */
		Lparen		/* $2 */
		fAnonMem	/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			fldcw_mem( &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}
	;




SingleStmt:
		fstcwTkn	/* $1 */
		Lparen		/* $2 */
		fMemoryDest	/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			_if( $<adrs.Size>3 != 2 )

				yyerror
				( 
					"Expected a word sized operand" 
				);

			_endif
			fstcw_mem( &$<adrs>3, 1 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}

	|	fstcwTkn	/* $1 */
		Lparen		/* $2 */
		fAnonMem	/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			$<adrs.Size>3 = 2;
			fstcw_mem( &$<adrs>3, 1 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}
	;





SingleStmt:
		fnstcwTkn	/* $1 */
		Lparen		/* $2 */
		fMemoryDest	/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			_if( $<adrs.Size>3 != 2 )

				yyerror
				( 
					"Expected a word sized operand" 
				);

			_endif
			fstcw_mem( &$<adrs>3, 0 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}
	;

SingleStmt:
		fnstcwTkn	/* $1 */
		Lparen		/* $2 */
		fAnonMem	/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			$<adrs.Size>3 = 2;
			fstcw_mem( &$<adrs>3, 0 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}
	;







/*
** fstsw instruction
*/

SingleStmt:
		fstswTkn		/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			char address[ 256 ];

			_here;
			_if( $<adrs.Size>3 != 2 && $<adrs.Size>3 != 0 )

				yyerror
				( 
					"Expected a word sized operand" 
				);

			_endif
			fstsw_mem( &$<adrs>3, 1 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;

SingleStmt:
		fstswTkn	/* $1 */
		Lparen		/* $2 */
		axTkn		/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			fstsw_ax( 1 );
			$<returns>$ = hlastrdup2( "ax" );
			_here;
		}
	;

SingleStmt:
		fstswTkn	/* $1 */
		Lparen		/* $2 */
		fstmt		/* $3 */
		axTkn		/* $4 */
		Rparen		/* $5 */
		{			/* $6 */

			_here;
			fstsw_ax( 1 );
			$<returns>$ = hlastrdup2( "ax" );
			_here;
		}
	;




/*
** fnstsw instruction
*/

SingleStmt:
		fnstswTkn		/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			_here;
			_if( $<adrs.Size>3 != 2 && $<adrs.Size>3 != 0 )

				yyerror
				( 
					"Expected a word sized operand" 
				);

			_endif
			fstsw_mem( &$<adrs>3, 0 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;

SingleStmt:
		fnstswTkn	/* $1 */
		Lparen		/* $2 */
		axTkn		/* $3 */
		Rparen		/* $4 */
		{			/* $5 */

			_here;
			fstsw_ax( 0 );
			$<returns>$ = hlastrdup2( "ax" );
			_here;
		}
	;

SingleStmt:
		fnstswTkn	/* $1 */
		Lparen		/* $2 */
		fstmt		/* $3 */
		axTkn		/* $4 */
		Rparen		/* $5 */
		{			/* $6 */

			_here;
			fstsw_ax( 0 );
			$<returns>$ = hlastrdup2( "ax" );
			_here;
		}
	;






/*****************************************************************************/

	
	
	
	
	/**********************/
	/* 	                  */
	/*  MMX Instructions! */
	/*                    */
	/**********************/
	
 /*
 ** EMMS instruction:
 */
 
SingleStmt:
		emmsTkn				/* $1 */
		EmptyParens
		{
				_here; 
				implied_instr( emms_instr );                                          		
				$<returns>$ = NULL;
				_here;                                               			
		}
	;			
	
	
	
	
SingleStmt:
		movdTkn				/* $1 */
		Lparen				/* $2 */
		fEitherMem32Dest	/* $3 */
		comma				/* $4 */
		fmmxReg				/* $5 */
		Rparen				/* $6 */
		{					/* $7 */
		
			enum mmxregnums mmx;
			
			_here;
			movd_m_r( &$<adrs>3, $<u>5, 0 );
			FreeAdrs( &$<adrs>3 );                           			
			$<returns>$ = hlastrdup2( uToMmx[$<u>5] );
		}
	;
		
SingleStmt:
		movdTkn				/* $1 */
		Lparen				/* $2 */
		fmmxReg				/* $3 */
		comma				/* $4 */
		fEitherMem32Dest	/* $5 */
		Rparen				/* $6 */
		{					/* $7 */
		
			enum mmxregnums mmx;
			
			_here;
			movd_r_m( $<u>3, &$<adrs>5, 0 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
		}
	;

SingleStmt:
		movdTkn				/* $1 */
		Lparen				/* $2 */
		fEitherMem32Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{					/* $7 */
			_here;
			movd_m_r( &$<adrs>3, $<u>5, 1 );
			FreeAdrs( &$<adrs>3 );                           			
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
		}
	;
		
SingleStmt:
		movdTkn				/* $1 */
		Lparen				/* $2 */
		fXmmReg				/* $3 */
		comma				/* $4 */
		fEitherMem32Dest	/* $5 */
		Rparen				/* $6 */
		{					/* $7 */
			_here;
			movd_r_m( $<u>3, &$<adrs>5, 1 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
		}
	;
		
SingleStmt:
		movdTkn			/* $1 */
		Lparen			/* $2 */
		fReg32			/* $3 */
		comma			/* $4 */
		fmmxReg			/* $5 */
		Rparen			/* $6 */
		{				/* $7 */
		
			_here;
			movd_r32_r( $<reg.encoding>3, $<u>5, 0 );
			$<returns>$ = hlastrdup2( uToMmx[$<u>5] );
		}
	;
		
SingleStmt:
		movdTkn			/* $1 */
		Lparen			/* $2 */
		fmmxReg			/* $3 */
		comma			/* $4 */
		fReg32			/* $5 */
		Rparen			/* $6 */
		{				/* $7 */
		
			_here;
			movd_r_r32( $<u>3, $<reg.encoding>5, 0 );
			$<returns>$ = hlastrdup2( regStrs[$<reg.encoding>5] );
		}
	;
		
SingleStmt:
		movdTkn			/* $1 */
		Lparen			/* $2 */
		fReg32			/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		Rparen			/* $6 */
		{				/* $7 */
			_here;
			movd_r32_r( $<reg.encoding>3, $<u>5, 1 );
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
		}
	;
		
SingleStmt:
		movdTkn			/* $1 */
		Lparen			/* $2 */
		fXmmReg			/* $3 */
		comma			/* $4 */
		fReg32			/* $5 */
		Rparen			/* $6 */
		{				/* $7 */
			_here;
			movd_r_r32( $<u>3, $<reg.encoding>5, 1 );
			$<returns>$ = hlastrdup2( regStrs[$<reg.encoding>5] );
		}
	;
		


SingleStmt:
		movqTkn				/* $1 */
		Lparen				/* $2 */
		fEitherMem64Dest	/* $3 */
		comma				/* $4 */
		fmmxReg				/* $5 */
		Rparen				/* $6 */
		{					/* $7 */
		
			movq_m_regmmx( &$<adrs>3, $<u>5 );                                          			
			FreeAdrs( &$<adrs>3 );                           			
			$<returns>$ = hlastrdup2( uToMmx[$<u>5] );
		}
	;
		
SingleStmt:
		movqTkn				/* $1 */
		Lparen				/* $2 */
		fEitherMem64Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{					/* $7 */
		
			movq_m_regxmm( &$<adrs>3, $<u>5 );                                          			
			FreeAdrs( &$<adrs>3 );                           			
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
		}
	;
		
		
SingleStmt:
		movqTkn				/* $1 */
		Lparen				/* $2 */
		fmmxReg				/* $3 */
		comma				/* $4 */
		fEitherMem64Dest	/* $5 */
		Rparen				/* $6 */
		{					/* $7 */
		
			_here;
			movq_regmmx_m( $<u>3, &$<adrs>5 );                                          			
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
		}
	;
		
SingleStmt:
		movqTkn					/* $1 */
		Lparen					/* $2 */
		fXmmReg					/* $3 */
		comma					/* $4 */
		fEitherMem64Dest		/* $5 */
		Rparen					/* $6 */
		{						/* $7 */
		
			movq_regxmm_m( $<u>3, &$<adrs>5 );                                          			
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
		}
	;
		
SingleStmt:
		movqTkn			/* $1 */
		pxx				/* $2 */
		{				/* $3 */
		
			_here;
			movq_r_r( $<rr>2.l, $<rr>2.r, 1 );
			$<returns>$ = hlastrdup2( uToXmm[$<rr>2.r] );
		}
	;
		
SingleStmt:
		movqTkn			/* $1 */
		ppp				/* $2 */
		{				/* $3 */
		
			_here;
			movq_r_r( $<rr.l>2, $<rr.r>2, 0 );
			$<returns>$ = hlastrdup2( uToMmx[ $<rr.r>2 ] );
		}
	;
	
	

// Handle various SSE instructions (operands: (xmm, xmm) or (mem128,xmm)) here:
					  
sseTkns:
		addpsTkn		/* $1 */
		{
			_here;
			$<u>$ = addps_instr;
		}
		
	|	andnpsTkn		/* $1 */
		{
			_here;
			$<u>$ = andnps_instr;
		}
		
	|	andpsTkn		/* $1 */
		{
			_here;
			$<u>$ = andps_instr;
		}
		
	|	divpsTkn		/* $1 */
		{
			_here;
			$<u>$ = divps_instr;
		}
		
	|	maxpsTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = maxps_instr;
		}
		
	|	minpsTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = minps_instr;
		}
		
	|	mulpsTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = mulps_instr;
		}
		
	|	orpsTkn			/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = orps_instr;
		}
	
	|	rcppsTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = rcpps_instr;
		}
		
	|	rsqrtpsTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = rsqrtps_instr;
		}

	|	sqrtpsTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = sqrtps_instr;
		}
		
	|	subpsTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = subps_instr;
		}

	|	xorpsTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = xorps_instr;
		}
		
	|	addssTkn		/* $1 */
		{
			_here;
			$<u>$ = addss_instr;
		}
		
	|	divssTkn		/* $1 */
		{
			_here;
			$<u>$ = divss_instr;
		}
		
	|	maxssTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = maxss_instr;
		}
		
	|	minssTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = minss_instr;
		}
		
	|	mulssTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = mulss_instr;
		}
		
	|	rcpssTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = rcpss_instr;
		}
		
	|	rsqrtssTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = rsqrtss_instr;
		}

	|	sqrtssTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = sqrtss_instr;
		}
		
	|	subssTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = subss_instr;
		}
		
	|	addpdTkn		/* $1 */
		{
			_here;
			$<u>$ = addpd_instr;
		}
		
	|	andnpdTkn		/* $1 */
		{
			_here;
			$<u>$ = andnpd_instr;
		}
		
	|	andpdTkn		/* $1 */
		{
			_here;
			$<u>$ = andpd_instr;
		}
		
	|	divpdTkn		/* $1 */
		{
			_here;
			$<u>$ = divpd_instr;
		}
		
	|	maxpdTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = maxpd_instr;
		}
		
	|	minpdTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = minpd_instr;
		}
		
	|	mulpdTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = mulpd_instr;
		}
		
	|	orpdTkn			/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = orpd_instr;
		}
	
	|	sqrtpdTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = sqrtpd_instr;
		}
		
	|	subpdTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = subpd_instr;
		}

	|	xorpdTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = xorpd_instr;
		}
		
	|	addsdTkn		/* $1 */
		{
			_here;
			$<u>$ = addsd_instr;
		}
		
	|	divsdTkn		/* $1 */
		{
			_here;
			$<u>$ = divsd_instr;
		}
		
	|	maxsdTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = maxsd_instr;
		}
		
	|	minsdTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = minsd_instr;
		}
		
	|	mulsdTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = mulsd_instr;
		}
		
	|	sqrtsdTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = sqrtsd_instr;
		}
		
	|	subsdTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = subsd_instr;
		}
		
	|	addsubpdTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = addsubpd_instr;
		}
		
	|	addsubpsTkn		/* $1 */
		{				/* $2 */
			_here;
			$<u>$ = addsubps_instr;
		}
		
	|	cvtdq2psTkn
		{
			_here;
			$<u>$ = cvtdq2ps_instr;
		}
	
	|	cvtpd2dqTkn
		{
			_here;
			$<u>$ = cvtpd2dq_instr;
		}
		
	|	cvtpd2psTkn
		{
			_here;
			$<u>$ = cvtpd2ps_instr;
		}
		
	|	cvtps2dqTkn
		{
			_here;
			$<u>$ = cvtps2dq_instr;
		}
		
	|	cvttpd2dqTkn
		{
			_here;
			$<u>$ = cvttpd2dq_instr;
		}
		
	|	cvttps2dqTkn
		{
			_here;
			$<u>$ = cvttps2dq_instr;
		}
		
	|	haddpsTkn
		{
			_here;
			$<u>$ = haddps_instr;
		}
		
	|	haddpdTkn
		{
			_here;
			$<u>$ = haddpd_instr;
		}
		
	|	hsubpsTkn
		{
			_here;
			$<u>$ = hsubps_instr;
		}
		
	|	hsubpdTkn
		{
			_here;
			$<u>$ = hsubpd_instr;
		}
		
	|	movshdupTkn
		{
			_here;
			$<u>$ = movshdup_instr;
		}
		
	|	movsldupTkn
		{
			_here;
			$<u>$ = movsldup_instr;
		}
	;
	
SingleStmt:
		sseTkns		/* $1 */
		pxx			/* $2 */
		{
			_here;
			sse_instr_r_r( $<u>1, $<rr>2.l, $<rr>2.r );	
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
		}
	;
	
SingleStmt:
		sseTkns				/* $1 */
		Lparen				/* $2 */
		fEitherMemDest		/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			sse_instr_m_r( $<u>1, &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );	
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
		}
	;

// Handle the movaps and movups instructions, which allow
// a destination memory operand:
	
sse_mov_tkns:
		movapsTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = movaps_instr;
		}
		
	|	movupsTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = movups_instr;
		}
		
	|	movapdTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = movapd_instr;
		}
		
	|	movupdTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = movupd_instr;
		}
		
	|	movdqaTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = movdqa_instr;
		}
		
	|	movdquTkn		/* $1 */
		{				/* $2 */
		
			_here;
			$<u>$ = movdqu_instr;
		}
	;
		

	
SingleStmt:
		sse_mov_tkns	/* $1 */
		pxx				/* $2 */
		{
			_here;
			sse_mov_instr_r_r( $<u>1, $<rr>2.l, $<rr>2.r );	
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
		}
	;
	
SingleStmt:
		sse_mov_tkns		/* $1 */
		pmx					/* $2 */
		{
			_here;
			sse_mov_instr_m_r( $<u>1, &$<mr.m>2, $<mr.r>2 );
			FreeAdrs( &$<mr.m>2 );	
			$<returns>$ = hlastrdup2( uToXmm[ $<mr.r>2 ] );
		}
	;
	
SingleStmt:
		sse_mov_tkns		/* $1 */
		pxm					/* $2 */
		{
			_here;
			sse_mov_instr_r_m( $<u>1, $<rm.r>2, &$<rm.m>2 );	
			$<returns>$ = FreeAdrs2( &$<rm.m>2 );
		}
	;
	
SingleStmt:
		movntpdTkn		/* $1 */
		pxm				/* $2 */
		{
			_here;
			EmitMovntp( movntpd_instr, $<rm.r>2, &$<rm.m>2 );	
			$<returns>$ = FreeAdrs2( &$<rm.m>2 );
		}
	;
	
SingleStmt:
		movntpsTkn		/* $1 */
		pxm				/* $2 */
		{
			_here;
			EmitMovntp( movntps_instr, $<rm.r>2, &$<rm.m>2 );	
			$<returns>$ = FreeAdrs2( &$<rm.m>2 );
		}
	;
	


	


	
	

// Handle the movsd and movss instructions, which allow
// a destination memory operand:

	
SingleStmt:
		movsdTkn		/* $1 */
		Lparen			/* $2 */
		fXmmReg			/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			EmitMovsds_r_r( _movsd_instr, $<u>3, $<u>5 );	
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
		}
	;
	
SingleStmt:
		movsdTkn			/* $1 */
		Lparen				/* $2 */
		fEitherMem64Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitMovsds_m_r( _movsd_instr, &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );	
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
		}
	;
	
SingleStmt:
		movsdTkn			/* $1 */
		Lparen				/* $2 */
		fXmmReg				/* $3 */
		comma				/* $4 */
		fEitherMem64Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitMovsds_r_m( _movsd_instr, $<u>3, &$<adrs>5 );	
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
		}
	;
	
SingleStmt:
		movssTkn		/* $1 */
		Lparen			/* $2 */
		fXmmReg			/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			EmitMovsds_r_r( movss_instr, $<u>3, $<u>5 );	
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
		}
	;
	
SingleStmt:
		movssTkn			/* $1 */
		Lparen				/* $2 */
		fEitherMem32Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitMovsds_m_r( movss_instr, &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );	
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
		}
	;
	
SingleStmt:
		movssTkn			/* $1 */
		Lparen				/* $2 */
		fXmmReg				/* $3 */
		comma				/* $4 */
		fEitherMem32Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitMovsds_r_m( movss_instr, $<u>3, &$<adrs>5 );	
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
		}
	;
	



// Instructions with Mw/Rv operands (Rv=16 or 32-bit GPR, but always
// forced to 32 bits):
//
//	sldt, smsw, streg

mw_rv_tkns:
		sldtTkn
		{
			_here;
			$<u>$ = sldt_instr;
		}
	
	|	smswTkn 
		{
			_here;
			$<u>$ = smsw_instr;
		}
	
	|	strTkn 
		{
			_here;
			$<u>$ = streg_instr;
		}
	;


SingleStmt:
		mw_rv_tkns			/* $1 */
		Lparen				/* $2 */
		fEitherMem16Dest	/* $3 */
		Rparen				/* $6 */
		{
			_here;
			$<adrs.forcedSize>3 = 2;
			Emit_mw_rv_m( $<u>1, &$<adrs>3 ); 
			$<returns>$ = NULL;	
			_here;
		}
	;
		
SingleStmt:
		mw_rv_tkns	/* $1 */
		Lparen		/* $2 */
		fReg16or32	/* $3 */
		Rparen		/* $6 */
		{
			_here;
			Emit_mw_rv_r( $<u>1, $<u>3 ); 
			$<returns>$ = NULL;	
			_here;
		}
	;
	



// Instructions with Ew operands:
//
//	lldt, ltreg, verr, verw, lmsw

Ew_tkns:
		lldtTkn
		{
			_here;
			$<u>$ = lldt_instr;
		}
	
	|	lmswTkn 
		{
			_here;
			$<u>$ = lmsw_instr;
		}
	
	|	ltrTkn 
		{
			_here;
			$<u>$ = ltreg_instr;
		}
	
	|	verrTkn 
		{
			_here;
			$<u>$ = verr_instr;
		}
	
	|	verwTkn 
		{
			_here;
			$<u>$ = verw_instr;
		}
	;


SingleStmt:
		Ew_tkns				/* $1 */
		Lparen				/* $2 */
		fEitherMemDest		/* $3 */
		Rparen				/* $4 */
		{
			_here;
			Emit_ew_m( $<u>1, &$<adrs>3 ); 
			$<returns>$ = NULL;	
			_here;
		}
	;


SingleStmt:
		Ew_tkns				/* $1 */
		Lparen				/* $2 */
		fReg16				/* $3 */
		Rparen				/* $4 */
		{
			_here;
			Emit_ew_r( $<u>1, $<reg.encoding>3 ); 
			$<returns>$ = NULL;	
			_here;
		}
	;
	



// Instructions with Ms operands:
//
//	sgdt, sidt, lgdt, lidt

Ms_tkns:
		sgdtTkn
		{
			_here;
			$<u>$ = sgdt_instr;
		}
	
	|	lidtTkn 
		{
			_here;
			$<u>$ = lidt_instr;
		}
	
	|	lgdtTkn 
		{
			_here;
			$<u>$ = lgdt_instr;
		}
	
	|	sidtTkn 
		{
			_here;
			$<u>$ = sidt_instr;
		}
	
	;


SingleStmt:
		Ms_tkns				/* $1 */
		Lparen				/* $2 */
		fEitherMemDest		/* $3 */
		Rparen				/* $4 */
		{
			_here;
			Emit_ms_m( $<u>1, &$<adrs>3 ); 
			$<returns>$ = NULL;	
			_here;
		}
	;
	
	
SingleStmt:
		invlpgTkn		/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			Emit_invlpg( &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here; 
		}
	;	

Gv_Ew_tkns:
		larTkn
		{
			_here;
			$<u>$ = lar_instr;
		}
		
	|	lslTkn
		{
			_here;
			$<u>$ = lsl_instr;
		}
	;
	
SingleStmt:
		Gv_Ew_tkns		/* $1 */
		Lparen			/* $2 */
		fReg16			/* $3 */
		comma			/* $4 */
		fReg16			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			Emit_Gv_Ew_r( $<u>1, $<reg.encoding>5, $<reg.encoding>3 );
			$<returns>$ = hlastrdup( regStrs[ $<reg.encoding>3 ] ); 
		}
	;
		
SingleStmt:
		Gv_Ew_tkns			/* $1 */
		Lparen				/* $2 */
		fReg16				/* $3 */
		comma				/* $4 */
		fEitherMem16Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Gv_Ew_m( $<u>1, &$<adrs>5, $<reg.encoding>3 );
			FreeAdrs( &$<adrs>5 );
			$<returns>$ = hlastrdup( regStrs[ $<reg.encoding>3 ] ); 
		}
	;
		
SingleStmt:
		Gv_Ew_tkns		/* $1 */
		Lparen			/* $2 */
		fReg32			/* $3 */
		comma			/* $4 */
		fReg32			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			Emit_Gv_Ew_r( $<u>1, $<reg.encoding>5, $<reg.encoding>3 );
			$<returns>$ = hlastrdup( regStrs[ $<reg.encoding>3 ] ); 
		}
	;
		
SingleStmt:
		Gv_Ew_tkns			/* $1 */
		Lparen				/* $2 */
		fReg32				/* $3 */
		comma				/* $4 */
		fEitherMem32Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Gv_Ew_m( $<u>1, &$<adrs>5, $<reg.encoding>3 );
			FreeAdrs( &$<adrs>5 );
			$<returns>$ = hlastrdup( regStrs[ $<reg.encoding>3 ] ); 
		}
	;
	


vps_mq_tkns:
		movlpsTkn
		{
			_here;
			$<u>$ = movlps_instr;
		}
	
	|	movhpsTkn
		{
			_here;
			$<u>$ = movhps_instr;
		}
	;
		
vps_vrqTkns:
		movhlpsTkn
		{
			_here;
			$<u>$ = movhlps_instr;
		}
		
	|	movlhpsTkn
		{
			_here;
			$<u>$ = movlhps_instr;
		}
	;
	
SingleStmt:
		vps_mq_tkns			/* $1 */
		Lparen				/* $2 */
		fEitherMem64Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Mq_Vps( $<u>1, &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
			_here;
		}
	;
	
SingleStmt:
		vps_mq_tkns			/* $1 */
		Lparen				/* $2 */
		fXmmReg				/* $3 */
		comma				/* $4 */
		fEitherMem64Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Vps_Mq( $<u>1, $<u>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;
		}
	;
		
		
SingleStmt:
		vps_vrqTkns		/* $1 */		
		pxx				/* $2 */
		{
			_here;
			Emit_Vps_VRq( $<u>1, $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
	
SingleStmt:
		movddupTkn			/* $1 */
		Lparen				/* $2 */
		fXmmReg				/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Movddup_r_r( $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
			_here;
		}
	;
		
	
	
SingleStmt:
		movddupTkn			/* $1 */
		Lparen				/* $2 */
		fEitherMem64Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Movddup( &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
			_here;
		}
	;
		
	
	
Vps_Wq_tkns:
		unpcklpsTkn
		{
			_here;
			$<u>$ = unpcklps_instr;
		}
	
	|	unpckhpsTkn
		{
			_here;
			$<u>$ = unpckhps_instr;
		}
	;
	
SingleStmt:
		Vps_Wq_tkns		/* $1 */
		pxx				/* $2 */
		{
			_here;
			Emit_Vps_Wq_r( $<u>1, $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
SingleStmt:
		Vps_Wq_tkns			/* $1 */
		Lparen				/* $2 */
		fEitherMem128Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Vps_Wq_m( $<u>1, &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
			_here;
		}
	;
		
	
	
Vsd_Mq_tkns:
		movlpdTkn
		{
			_here;
			$<u>$ = movlpd_instr;
		}
	
	|	movhpdTkn
		{
			_here;
			$<u>$ = movhpd_instr;
		}
	;
	
SingleStmt:
		Vsd_Mq_tkns			/* $1 */
		Lparen				/* $2 */
		fEitherMem64Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Mq_Vsd_m( $<u>1, &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
			_here;
		}
	;
	
SingleStmt:
		Vsd_Mq_tkns			/* $1 */
		Lparen				/* $2 */
		fXmmReg				/* $3 */
		comma				/* $4 */
		fEitherMem64Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			Emit_Vsd_Mq_m( $<u>1, $<u>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;
		}
	;
		
	
	
Vpd_Wq_tkns:
		unpcklpdTkn
		{
			_here;
			$<u>$ = unpcklpd_instr;
		}
	
	|	unpckhpdTkn
		{
			_here;
			$<u>$ = unpckhpd_instr;
		}
		
	|	cvtdq2pdTkn
		{
			_here;
			$<u>$ = cvtdq2pd_instr;
		}
	;
	
SingleStmt:
		Vpd_Wq_tkns		/* $1 */
		pxx				/* $2 */
		{
			_here;
			Emit_Vpd_Wq_r( $<u>1, $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
SingleStmt:
		Vpd_Wq_tkns				/* $1 */
		Lparen					/* $2 */
		fEitherMem128or64Dest	/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emit_Vpd_Wq_m( $<u>1, &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
			_here;
		}
	;
		


	
	
Gv_Ev_tkns:
		cmovoTkn
		{
			_here;
			$<u>$ = cmovo_instr;
		}
	
	|	cmovnoTkn
		{
			_here;
			$<u>$ = cmovno_instr;
		}
		
	|	cmovbTkn
		{
			_here;
			$<u>$ = cmovb_instr;
		}
	
	|	cmovnbTkn
		{
			_here;
			$<u>$ = cmovnb_instr;
		}
		
	|	cmoveTkn
		{
			_here;
			$<u>$ = cmovz_instr;
		}
	
	|	cmovneTkn
		{
			_here;
			$<u>$ = cmovnz_instr;
		}
		
	|	cmovbeTkn
		{
			_here;
			$<u>$ = cmovbe_instr;
		}
	
	|	cmovnbeTkn
		{
			_here;
			$<u>$ = cmovnbe_instr;
		}
		
	|	cmovsTkn
		{
			_here;
			$<u>$ = cmovs_instr;
		}
	
	|	cmovnsTkn
		{
			_here;
			$<u>$ = cmovns_instr;
		}
		
	|	cmovlTkn
		{
			_here;
			$<u>$ = cmovl_instr;
		}
	
	|	cmovnlTkn
		{
			_here;
			$<u>$ = cmovnl_instr;
		}
		
	|	cmovleTkn
		{
			_here;
			$<u>$ = cmovle_instr;
		}
	
	|	cmovnleTkn
		{
			_here;
			$<u>$ = cmovnle_instr;
		}
	
	|	cmovpTkn
		{
			_here;
			$<u>$ = cmovp_instr;
		}
	
	|	cmovnpTkn
		{
			_here;
			$<u>$ = cmovnp_instr;
		}
		
	|	bsfTkn
		{
			_here;
			$<u>$ = bsf_instr;
		}
	
	|	bsrTkn
		{
			_here;
			$<u>$ = bsr_instr;
		}
	;
	
SingleStmt:
		Gv_Ev_tkns		/* $1 */
		Lparen			/* $2 */
		fReg16			/* $3 */
		comma			/* $4 */
		fReg16			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			Emit_Gv_Ev_r( $<u>1, $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[$<reg.encoding>5] );
			_here;
		}
	;
	
SingleStmt:
		Gv_Ev_tkns		/* $1 */
		Lparen			/* $2 */
		fReg32			/* $3 */
		comma			/* $4 */
		fReg32			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			Emit_Gv_Ev_r( $<u>1, $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[$<reg.encoding>5] );
			_here;
		}
	;
	
SingleStmt:
		Gv_Ev_tkns				/* $1 */
		Lparen					/* $2 */
		fEitherMemDest			/* $3 */
		comma					/* $4 */
		fReg16or32				/* $5 */
		Rparen					/* $6 */
		{
			_here;
			_if
			( 
					($<adrs.Size>3 == 2 && ($<u>5 >= reg_eax ))
				||	($<adrs.Size>3 == 4 && ($<u>5 < reg_eax ))
			)
				yyerror( "Operand size mismatch" );
				
			_endif;
			Emit_Gv_Ev_m( $<u>1, &$<adrs>3, $<u>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( regStrs[$<u>5] );
			_here;
		}
	;
	

Gd_VRp_tkns:
		movmskpsTkn
		{
			_here;
			$<u>$ = movmskps_instr;
		}
	
	|	movmskpdTkn
		{
			_here;
			$<u>$ = movmskpd_instr;
		}
	;
		

SingleStmt:
		Gd_VRp_tkns		/* $1 */
		Lparen			/* $2 */
		fXmmReg			/* $3 */
		comma			/* $4 */
		fReg32			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			Emit_Gd_VRp_r( $<u>1, $<u>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[$<reg.encoding>5] );
			_here;
		}
	;
	
				

	
		

Pq_Qq_Tkns:
		packsswbTkn
		{
			_here;
			$<u>$ = packsswb_instr;
		}
		
	|	pcmpgtbTkn
		{
			_here;
			$<u>$ = pcmpgtb_instr;
		}
	
	|	pcmpgtwTkn
		{
			_here;
			$<u>$ = pcmpgtw_instr;
		}
	
	|	pcmpgtdTkn
		{
			_here;
			$<u>$ = pcmpgtd_instr;
		}
	
	|	packuswbTkn
		{
			_here;
			$<u>$ = packuswb_instr;
		}
	
	|	pcmpeqbTkn
		{
			_here;
			$<u>$ = pcmpeqb_instr;
		}
	
	|	pcmpeqwTkn
		{
			_here;
			$<u>$ = pcmpeqw_instr;
		}
	
	|	pcmpeqdTkn
		{
			_here;
			$<u>$ = pcmpeqd_instr;
		}
	
	|	paddqTkn
		{
			_here;
			$<u>$ = paddq_instr;
		}
	
	|	pmullwTkn
		{
			_here;
			$<u>$ = pmullw_instr;
		}
	
	|	pavgbTkn
		{
			_here;
			$<u>$ = pavgb_instr;
		}
	
	|	pavgwTkn
		{
			_here;
			$<u>$ = pavgw_instr;
		}
	
	|	pmulhuwTkn
		{
			_here;
			$<u>$ = pmulhuw_instr;
		}
	
	|	pmulhwTkn
		{
			_here;
			$<u>$ = pmulhw_instr;
		}
	
	|	pmuludqTkn
		{
			_here;
			$<u>$ = pmuludq_instr;
		}
	
	|	pmaddwdTkn
		{
			_here;
			$<u>$ = pmaddwd_instr;
		}
	
	|	psadbwTkn
		{
			_here;
			$<u>$ = psadbw_instr;
		}
	
	|	packssdwTkn
		{
			_here;
			$<u>$ = packssdw_instr;
		}
	
	|	psubusbTkn
		{
			_here;
			$<u>$ = psubusb_instr;
		}
	
	|	psubuswTkn
		{
			_here;
			$<u>$ = psubusw_instr;
		}
	
	|	pminubTkn
		{
			_here;
			$<u>$ = pminub_instr;
		}
	
	|	pandTkn
		{
			_here;
			$<u>$ = pand_instr;
		}
	
	|	paddusbTkn
		{
			_here;
			$<u>$ = paddusb_instr;
		}
	
	|	padduswTkn
		{
			_here;
			$<u>$ = paddusw_instr;
		}
	
	|	pmaxubTkn
		{
			_here;
			$<u>$ = pmaxub_instr;
		}
	
	|	pandnTkn
		{
			_here;
			$<u>$ = pandn_instr;
		}
	
	|	psubsbTkn
		{
			_here;
			$<u>$ = psubsb_instr;
		}
	
	|	psubswTkn
		{
			_here;
			$<u>$ = psubsw_instr;
		}
	
	|	pminswTkn
		{
			_here;
			$<u>$ = pminsw_instr;
		}
	
	|	porTkn
		{
			_here;
			$<u>$ = por_instr;
		}
	
	|	paddsbTkn
		{
			_here;
			$<u>$ = paddsb_instr;
		}
	
	|	paddswTkn
		{
			_here;
			$<u>$ = paddsw_instr;
		}
	
	|	pmaxswTkn
		{
			_here;
			$<u>$ = pmaxsw_instr;
		}
	
	|	pxorTkn
		{
			_here;
			$<u>$ = pxor_instr;
		}
	
	|	psubbTkn
		{
			_here;
			$<u>$ = psubb_instr;
		}
	
	|	psubwTkn
		{
			_here;
			$<u>$ = psubw_instr;
		}
	
	|	psubdTkn
		{
			_here;
			$<u>$ = psubd_instr;
		}
	
	|	psubqTkn
		{
			_here;
			$<u>$ = psubq_instr;
		}
	
	|	paddbTkn
		{
			_here;
			$<u>$ = paddb_instr;
		}
	
	|	paddwTkn
		{
			_here;
			$<u>$ = paddw_instr;
		}
	
	|	padddTkn
		{
			_here;
			$<u>$ = paddd_instr;
		}
	;
	
SingleStmt:
		Pq_Qq_Tkns		/* $1 */
		ppp				/* $2 */
		{
			_here;
			Emit_Pq_Qq_r( $<u>1, $<rr>2.l, $<rr>2.r, 0 );
			$<returns>$ = hlastrdup2( uToMmx[ $<rr>2.r ] );
			_here;
		}
	;
	
SingleStmt:
		Pq_Qq_Tkns				/* $1 */
		Lparen					/* $2 */
		fEitherMemDest			/* $3 */
		comma					/* $4 */
		fmmxReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			_if( $<adrs.Size>3 == 0 )
			
				$<adrs.Size>3 = 8;
				
			_endif
			_if( $<adrs.Size>3 != 8 )
			
				yyerror( "Instruction expects a qword operand" );
				
			_endif
			Emit_Pq_Qq_m( $<u>1, &$<adrs>3, $<u>5, 0 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToMmx[$<u>5] );
			_here;
		}
	;
	

	
SingleStmt:
		Pq_Qq_Tkns		/* $1 */
		pxx				/* $2 */
		{
			_here;
			Emit_Pq_Qq_r( $<u>1, $<rr>2.l, $<rr>2.r, 1 );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
SingleStmt:
		Pq_Qq_Tkns				/* $1 */
		Lparen					/* $2 */
		fEitherMemDest			/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			_if( $<adrs.Size>3 == 0 )
			
				$<adrs.Size>3 = 16;
				
			_endif
			_if( $<adrs.Size>3 != 16 )
			
				yyerror( "Instruction expects an lword operand" );
				
			_endif
			Emit_Pq_Qq_m( $<u>1, &$<adrs>3, $<u>5, 1 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;
	


 

Vdq_Wd_Tkns:
		punpcklbwTkn
		{
			_here;
			$<u>$ = punpcklbw_instr;
		}
	|	punpcklwdTkn
		{
			_here;
			$<u>$ = punpcklwd_instr;
		}
	|	punpckldqTkn
		{
			_here;
			$<u>$ = punpckldq_instr;
		}
	;
	
Vdq_Wq_Tkns:
		punpckhbwTkn
		{
			_here;
			$<u>$ = punpckhbw_instr;
		}
	|	punpckhwdTkn
		{
			_here;
			$<u>$ = punpckhwd_instr;
		}
	|	punpckhdqTkn
		{
			_here;
			$<u>$ = punpckhdq_instr;
		}
	;
	
	
SingleStmt:
		Vdq_Wq_Tkns		/* $1 */
		ppp				/* $2 */
		{
			_here;
			Emit_Vdq_Wq_r( $<u>1, $<rr>2.l, $<rr>2.r, 0 );
			$<returns>$ = hlastrdup2( uToMmx[ $<rr>2.r ] );
			_here;
		}
	;
	
	
SingleStmt:
		Vdq_Wq_Tkns		/* $1 */
		pxx				/* $2 */
		{
			_here;
			Emit_Vdq_Wq_r( $<u>1, $<rr>2.l, $<rr>2.r, 1 );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
	
	
	
SingleStmt:
		Vdq_Wd_Tkns		/* $1 */
		ppp				/* $2 */
		{
			_here;
			Emit_Vdq_Wd_r( $<u>1, $<rr>2.l, $<rr>2.r, 0 );
			$<returns>$ = hlastrdup2( uToMmx[ $<rr>2.r ] );
			_here;
		}
	;
	
	
SingleStmt:
		Vdq_Wd_Tkns		/* $1 */
		pxx				/* $2 */
		{
			_here;
			Emit_Vdq_Wd_r( $<u>1, $<rr>2.l, $<rr>2.r, 1 );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
	
SingleStmt:
		punpcklqdqTkn	/* $1 */
		pxx				/* $2 */
		{
			_here;
			Emit_Vdq_Wq_r( punpcklqdq_instr, $<rr>2.l, $<rr>2.r, 1 );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
	
SingleStmt:
		punpckhqdqTkn	/* $1 */
		pxx				/* $2 */
		{
			_here;
			Emit_Vdq_Wq_r( punpckhqdq_instr, $<rr>2.l, $<rr>2.r, 1 );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
SingleStmt:
		Vdq_Wq_Tkns				/* $1 */
		Lparen					/* $2 */
		fEitherMemDest			/* $3 */
		comma					/* $4 */
		fmmxReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			
			_if( $<adrs.Size>3 == 0 )
				
				$<adrs.Size>3 = 8;
				
			_endif
			_if( $<adrs.Size>3 != 8 )
			
				yyerror( "Instruction expects a qword operand" );
				
			_endif
			Emit_Vdq_Wq_m( $<u>1, &$<adrs>3, $<u>5, 0 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToMmx[$<u>5] );
			_here;
		}
	;
	
SingleStmt:
		Vdq_Wd_Tkns				/* $1 */
		Lparen					/* $2 */
		fEitherMemDest			/* $3 */
		comma					/* $4 */
		fmmxReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			
			// Note: Intel claims the size should be dword.
			
			_if( $<adrs.Size>3 == 0 )
				
				$<adrs.Size>3 = 4;
				
			_endif
			_if( $<adrs.Size>3 != 4 )
			
				yyerror( "Instruction expects a dword operand" );
				
			_endif
			Emit_Vdq_Wd_m( $<u>1, &$<adrs>3, $<u>5, 0 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToMmx[$<u>5] );
			_here;
		}
	;
	
SingleStmt:
		Vdq_Wq_Tkns				/* $1 */
		Lparen					/* $2 */
		fEitherMemDest			/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emit_Vdq_Wq_m( $<u>1, &$<adrs>3, $<u>5, 1 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;
	
SingleStmt:
		Vdq_Wd_Tkns				/* $1 */
		Lparen					/* $2 */
		fEitherMemDest			/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emit_Vdq_Wd_m( $<u>1, &$<adrs>3, $<u>5, 1 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;
	
SingleStmt:
		lddquTkn				/* $1 */
		pxm						/* $2 */
		{
			_here;
			Emit_Vdq_Wq_m( lddqu_instr, &$<rm.m>2, $<rm.r>2, 1 );
			FreeAdrs( &$<rm.m>2 );
			$<returns>$ = hlastrdup2( uToXmm[ $<rm.r>2 ] );
			_here;
		}
	;
	
SingleStmt:
		punpcklqdqTkn			/* $1 */
		pmx						/* $2 */
		{
			_here;
			Emit_Vdq_Wq_m( punpcklqdq_instr, &$<mr.m>2, $<mr.r>2, 1 );
			FreeAdrs( &$<mr.m>2 );
			$<returns>$ = hlastrdup2( uToXmm[ $<mr.r>2 ] );
			_here;
		}
	;
	
SingleStmt:
		punpckhqdqTkn			/* $1 */
		pmx						/* $2 */
		{
			_here;
			Emit_Vdq_Wq_m( punpckhqdq_instr, &$<mr.m>2, $<mr.r>2, 1 );
			FreeAdrs( &$<mr.m>2 );
			$<returns>$ = hlastrdup2( uToXmm[ $<mr.r>2] );
			_here;
		}
	;
	

uns8ConstExpr:
		ConstExpr
		{
			_if
			( 
					IsNumber( $<v.pType>1 )
				&&	checkSmallUns( YYS &$<v>1 ) 
				&&	$<v.u.unsval>1 <= 255
			)
			
				$<u>$ = $<v.u.unsval>1;
				
			_else
			
				yyerror( "Constant value is too large" );
				$<u>$ = 0;
				
			_endif
		}
	;
	
	
pshufTkns:
		pshufhwTkn
		{
			_here;
			$<u>$ = pshufhw_instr;
		}
		
	|	pshufdTkn
		{
			_here;
			$<u>$ = pshufd_instr;
		}
	
	|	pshuflwTkn
		{
			_here;
			$<u>$ = pshuflw_instr;
		}
	;


SingleStmt:
		pshufwTkn		/* $1 */
		Lparen			/* $2 */
		uns8ConstExpr	/* $3 */
		comma			/* $4 */
		fmmxReg			/* $5 */
		comma			/* $6 */
		fmmxReg			/* $7 */
		Rparen			/* $8 */
		{
			_here;
			Emit_pshuf_r( pshufw_instr, $<u>3, $<u>5, $<u>7 );
			$<returns>$ = hlastrdup2( uToMmx[$<u>7] );
			_here;
		}
	;
	

SingleStmt:
		pshufwTkn			/* $1 */
		Lparen				/* $2 */
		uns8ConstExpr		/* $3 */
		comma				/* $4 */
		fEitherMem64Dest	/* $5 */
		comma				/* $6 */
		fmmxReg				/* $7 */
		Rparen				/* $8 */
		{
			_here;
			Emit_pshuf_m( pshufw_instr, $<u>3, &$<adrs>5, $<u>7 );
			FreeAdrs( &$<adrs>5 );
			$<returns>$ = hlastrdup2( uToMmx[$<u>7] );
			_here;
		}
	;


SingleStmt:
		pshufTkns		/* $1 */
		Lparen			/* $2 */
		uns8ConstExpr	/* $3 */
		comma			/* $4 */
		xx				/* $5 */
		Rparen			/* $6 */
		{
			_here;
			Emit_pshuf_r( $<u>1, $<u>3, $<rr>5.l, $<rr>5.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>5.r ] );
			_here;
		}
	;
	

SingleStmt:
		pshufTkns			/* $1 */
		Lparen				/* $2 */
		uns8ConstExpr		/* $3 */
		comma				/* $4 */
		fEitherMem128Dest	/* $5 */
		comma				/* $6 */
		fXmmReg				/* $7 */
		Rparen				/* $8 */
		{
			_here;
			Emit_pshuf_m( $<u>1, $<u>3, &$<adrs>5, $<u>7 );
			FreeAdrs( &$<adrs>5 );
			$<returns>$ = hlastrdup2( uToXmm[$<u>7] );
			_here;
		}
	;
				



psr_psl_tkns:
		psrlwTkn
		{
			_here;		
			$<u>$ = psrlw_instr;
		}
	
	|	psrawTkn
		{
			_here;
			$<u>$ = psraw_instr;
		}
	
	|	psllwTkn
		{
			_here;
			$<u>$ = psllw_instr;
		}
	
	|	psrldTkn
		{
			_here;
			$<u>$ = psrld_instr;
		}
	
	|	psradTkn
		{
			_here;
			$<u>$ = psrad_instr;
		}
	
	|	pslldTkn
		{
			_here;
			$<u>$ = pslld_instr;
		}
	
	|	psrlqTkn
		{
			_here;
			$<u>$ = psrlq_instr;
		}

	|	psllqTkn
		{
			_here;
			$<u>$ = psllq_instr;
		}

	|	pslldqTkn
		{
			_here;
			$<u>$ = pslldq_instr;
		}

	|	psrldqTkn
		{
			_here;
			$<u>$ = psrldq_instr;
		}
	;


SingleStmt:
		psr_psl_tkns	/* $1 */
		Lparen			/* $2 */
		uns8ConstExpr	/* $3 */
		comma			/* $4 */
		fmmxReg			/* $5 */
		Rparen			/* $8 */
		{
			_here;
			_if( $<u>1 == pslldq_instr || $<u>1 == psrldq_instr )
			
				yyerror( "Instruction requires XMM register operand" );
				$<u>1 = psrlw_instr;
				
			_endif
			Emit_psl_psr_imm( $<u>1, $<u>3, $<u>5, 0 );	
			$<returns>$ = hlastrdup2( uToMmx[$<u>5] );
			_here;
		}
	;

SingleStmt:
		psr_psl_tkns	/* $1 */
		Lparen			/* $2 */
		uns8ConstExpr	/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		Rparen			/* $8 */
		{
			_here;
			Emit_psl_psr_imm( $<u>1, $<u>3, $<u>5, 1 );	
			$<returns>$ = hlastrdup2( uToXmm[$<u>5] );
			_here;
		}
	;
	
	
SingleStmt:
		psr_psl_tkns	/* $1 */
		ppp				/* $2 */
		{
			_here;
			_if( $<u>1 == pslldq_instr || $<u>1 == psrldq_instr )
			
				yyerror( "Instruction requires XMM register and constant operands" );
				$<u>1 = psrlw_instr;
				
			_endif
			Emit_psl_psr_r( $<u>1, $<rr>2.l, $<rr>2.r, 0 );
			$<returns>$ = hlastrdup2( uToMmx[ $<rr>2.r ] );
			_here;
		}
	;
	
SingleStmt:
		psr_psl_tkns			/* $1 */
		Lparen					/* $2 */
		fEitherMem				/* $3 */
		comma					/* $4 */
		fmmxReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			_if( $<adrs.Size>3 != 8 )
			
				yyerror( "Instruction expects a qword operand" );
				
			_endif
			Emit_psl_psr_m( $<u>1, &$<adrs>3, $<u>5, 0 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToMmx[$<u>5] );
			_here;
		}
	;
	

	
SingleStmt:
		psr_psl_tkns	/* $1 */
		pxx				/* $2 */
		{
			_here;
			_if( $<u>1 == pslldq_instr || $<u>1 == psrldq_instr )
			
				yyerror( "Instruction requires a constant operand" );
				$<u>1 = psrlw_instr;
				
			_endif
			Emit_psl_psr_r( $<u>1, $<rr>2.l, $<rr>2.r, 1 );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
SingleStmt:
		psr_psl_tkns			/* $1 */
		Lparen					/* $2 */
		fEitherMem				/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emit_psl_psr_m( $<u>1, &$<adrs>3, $<u>5, 1 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;
	
	
setccTkns:
		setoTkn
		{
			_here;
			$<u>$ = seto_instr;
		}
		
	|	setnoTkn
		{
			_here;
			$<u>$ = setno_instr;
		}
		
	|	setbTkn
		{
			_here;
			$<u>$ = setb_instr;
		}
		
	|	setnbTkn
		{
			_here;
			$<u>$ = setnb_instr;
		}
		
	|	setzTkn
		{
			_here;
			$<u>$ = setz_instr;
		}
		
	|	setnzTkn
		{
			_here;
			$<u>$ = setnz_instr;
		}
		
	|	setbeTkn
		{
			_here;
			$<u>$ = setbe_instr;
		}
		
	|	setnbeTkn
		{
			_here;
			$<u>$ = setnbe_instr;
		}
		
	|	setsTkn
		{
			_here;
			$<u>$ = sets_instr;
		}
		
	|	setnsTkn
		{
			_here;
			$<u>$ = setns_instr;
		}
		
	|	setpTkn
		{
			_here;
			$<u>$ = setp_instr;
		}
		
	|	setnpTkn
		{
			_here;
			$<u>$ = setnp_instr;
		}
		
	|	setlTkn
		{
			_here;
			$<u>$ = setl_instr;
		}
		
	|	setnlTkn
		{
			_here;
			$<u>$ = setnl_instr;
		}
		
	|	setleTkn
		{
			_here;
			$<u>$ = setle_instr;
		}
		
	|	setnleTkn
		{
			_here;
			$<u>$ = setnle_instr;
		}
	;
	
	
SingleStmt:
		setccTkns		/* $1 */
		Lparen			/* $2 */
		fReg8			/* $3 */
		Rparen			/* $4 */
		{
			_here;
			Emit_set_Eb_r( $<u>1, $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[$<reg.encoding>3] );
			_here;
		}
	;
	
SingleStmt:
		setccTkns				/* $1 */
		Lparen					/* $2 */
		fEitherMem				/* $3 */
		Rparen					/* $6 */
		{
			_here;
			_if( $<adrs.Size>3 != 1 )
			
				yyerror( "Instruction expects a byte operand" );
				
			_endif
			Emit_set_Eb_m( $<u>1, &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;
	
	
btTkns:
		btTkn
		{
			_here;
			$<u>$ = bt_instr;
		}
	
	|	btcTkn
		{
			_here;
			$<u>$ = btc_instr;
		}			
	
	|	btrTkn
		{
			_here;
			$<u>$ = btr_instr;
		}			
	
	|	btsTkn
		{
			_here;
			$<u>$ = bts_instr;
		}
		
	|	lockbtcTkn
		{
			_here;
			$<u>$ = lockbtc_instr;
		}			
	
	|	lockbtrTkn
		{
			_here;
			$<u>$ = lockbtr_instr;
		}			
	
	|	lockbtsTkn
		{
			_here;
			$<u>$ = lockbts_instr;
		}
	;
	
	
SingleStmt:
		btTkns		/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fReg16or32	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<u>1 >= lockbts_instr )
			
				yyerror( "LOCK prefix requires a memory operand" );
				
			_endif
			_if( IsOrdinal( $<v.pType>3 ) && numBits32( YYS &$<v>3 ) <= 32 )
			
				_if( $<u>5 >= reg_ax && $<u>5 <= reg_di )
				
					_if( $<v.u.unsval>3 < 16 )
				
						Emit_bt_c_r( $<u>1, $<v.u.unsval>3, $<u>5 );
						
					_else
					
						yyerror( "Bit number must be between 0 and 15" );
					
					_endif
					
				_elseif( $<u>5 >= reg_eax && $<u>5 <= reg_edi )
					
				
					_if( $<v.u.unsval>3 < 32 )
				
						Emit_bt_c_r( $<u>1, $<v.u.unsval>3, $<u>5 );
						
					_else
					
						yyerror( "Bit number must be between 0 and 31" );
					
					_endif
					
				_else
					
					yyerror( "Instruction requires a 16 or 32 bit register" );
					
				_endif
				
			_else
		
				yyerror( "Expected ordinal value for bit number" );
			
			_endif
			
			$<returns>$ = hlastrdup2( regStrs[ $<u>5 ]);
			FreeValue( YYS &$<v>3 );
			_here;		
		}
	;
	
SingleStmt:
		btTkns			/* $1 */
		Lparen			/* $2 */
		fConstExpr		/* $3 */
		comma			/* $4 */
		fEitherMem		/* $5 */
		Rparen			/* $6 */
		{
			int size;
			
			_here;
			_if( IsOrdinal( $<v.pType>3 ) && numBits32( YYS &$<v>3 ) <= 32 )
			
				_if( $<v.u.unsval>3 >= 256 )
				
					yyerror( "Bit number must be between 0 and 255" );
					
				_else
				
					// This is kind of lame.
					// If the address size isn't word or dword, we
					// default to dword. Technically, we should give
					// a warning or something, but lots of code
					// checks bits in >dword objects (e.g., csets),
					// so it's best to do this quietly.
					
					size = $<adrs.Size>5;
					_if( size != 2 && size != 4 )
					
						_if( size == 0 || size == 8 || size == 16 )
						
							$<adrs.Size>5 = 4;
							$<adrs.pType>5 = tDWord;
							$<adrs.Type>5 = &dword_ste;
							$<adrs.forcedSize>5 = 4;
							
						_else
					
							yyerror( "Size mismatch in operands" );
							
						_endif
						
					_endif
					Emit_bt_c_m( $<u>1, $<v.u.unsval>3, &$<adrs>5 );
					
				_endif
				
			_else
		
				yyerror( "Expected ordinal value for bit number" );
			
			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;
	
SingleStmt:
		btTkns		/* $1 */
		Lparen		/* $2 */
		fReg16or32	/* $3 */
		comma		/* $4 */
		fReg16or32	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<u>1 >= lockbts_instr )
			
				yyerror( "LOCK prefix requires a memory operand" );
				
			_endif
			_if( isReg16( $<u>3 ) && !isReg16( $<u>5 ))
			
				yyerror( "Both registers must be the same size" );
				
			_else
			
				Emit_bt_r_r( $<u>1, $<u>3, $<u>5 );
				
			_endif
 			$<returns>$ = hlastrdup2( regStrs[ $<u>5 ] );
			_here;
		}
	;
		
	
SingleStmt:
		btTkns			/* $1 */
		Lparen			/* $2 */
		fReg16or32		/* $3 */
		comma			/* $4 */
		fEitherMem		/* $5 */
		Rparen			/* $6 */
		{
			int size;
			
			_here;
			size = $<adrs.Size>5;
			_if( size != 2 && size != 4 )
			
				_if( size == 0 || size == 8 || size == 16 )
				
					$<adrs.Size>5 = 4;
					$<adrs.pType>5 = tDWord;
					$<adrs.Type>5 = &dword_ste;
					$<adrs.forcedSize>5 = 4;
					
				_else
			
					yyerror( "Size mismatch in operands" );
					
				_endif
				
			_endif
			Emit_bt_r_m( $<u>1, $<u>3, &$<adrs>5 );
 			$<returns>$ = FreeAdrs2( &$<adrs>5 );
		}
	;
	
	
SingleStmt:
		btTkns			/* $1 */
		Lparen			/* $2 */
		fReg16or32		/* $3 */
		comma			/* $4 */
		fConstExpr		/* $5 */
		Rparen			/* $6 */
		{
			char sn[ 256 ];
			struct adrsYYS adrs;
		
			_here;
			_if( $<u>1 >= lockbts_instr )
			
				yyerror( "LOCK prefix requires a memory operand" );
				
			_endif
			_if( $<v.pType>5 != tCset )

				yyerror( "Constant must be a character set constant" );

			_endif
			
			// Create the character set constant in memory:
			
			sprintf( sn, "cset" sympost "%d", LblCntr++ );
			startStrSeg();
			OutValue( sn, &cset_ste, YYS &$<v>5 );
			endStrSeg();
			initAdrs( &adrs, -1, -1, 0, 0 );
			adrs.StaticName = sn;
			Emit_bt_r_m( $<u>1, $<u>3, &adrs );
			$<returns>$ = hlastrdup2( regStrs[ $<u>3 ] );
			FreeValue( YYS &$<v>5 );
			_here;
		}
	;
		
	

shxdTkns:
		shldTkn
		{
			_here;
			$<u>$ = shld_instr;
		}
	
	|	shrdTkn
		{
			_here;
			$<u>$ = shrd_instr;
		}
	;
	
	
SingleStmt:
		shxdTkns		/* $1 */
		Lparen			/* $2 */
		fConstExpr		/* $3 */
		comma			/* $4 */
		fReg16or32		/* $5 */
		comma			/* $6 */
		fReg16or32		/* $7 */
		Rparen			/* $8 */
		{
			_here;
			_if( IsOrdinal( $<v.pType>3 ) && numBits32( YYS &$<v>3 ) <= 32 )
			
				_if( isReg16( $<u>5 ))
				
					_if( $<v.u.unsval>3 < 16 )
				
						Emit_shxd_c_r_r( $<u>1, $<v.u.unsval>3, $<u>5, $<u>7 );
						
					_else
					
						yyerror( "Bit number must be between 0 and 15" );
					
					_endif
					
				_else
					
				
					_if( $<v.u.unsval>3 < 32 )
				
						Emit_shxd_c_r_r( $<u>1, $<v.u.unsval>3, $<u>5, $<u>7 );
						
					_else
					
						yyerror( "Bit number must be between 0 and 31" );
					
					_endif
					
				_endif
				
			_else
		
				yyerror( "Expected ordinal value for bit number" );
			
			_endif
			$<returns>$ = hlastrdup2( regStrs[ $<u>7 ] );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;
	
	
SingleStmt:
		shxdTkns		/* $1 */
		Lparen			/* $2 */
		fcl				/* $3 */
		comma			/* $4 */
		fReg16or32		/* $5 */
		comma			/* $6 */
		fReg16or32		/* $7 */
		Rparen			/* $8 */
		{
			_here;
			Emit_shxd_cl_r_r( $<u>1, $<u>5, $<u>7 );
			$<returns>$ = hlastrdup2( regStrs[ $<u>7 ] );
			_here;
		}
	;
	


SingleStmt:
		shxdTkns		/* $1 */
		Lparen			/* $2 */
		fConstExpr		/* $3 */
		comma			/* $4 */
		fReg16or32		/* $5 */
		comma			/* $6 */
		fEitherMemDest	/* $7 */
		Rparen			/* $8 */
		{
			int regSize;
			
			_here;
			regSize = _ifx( isReg16( $<u>5 ), 2, 4 );
			_if( $<adrs.Size>7 == 0 )
			
				$<adrs.Size>7 = regSize;
			
			_endif
			_if( IsOrdinal( $<v.pType>3 ) && numBits32( YYS &$<v>3 ) <= 32 )
			
				_if( regSize != $<adrs.Size>7 )
				
					yyerror( "Memory operand size must match register size" );
					
				_endif
				_if( regSize == 2 && $<v.u.unsval>3 >= 16 )
				
					yyerror( "Bit number must be between 0 and 15" );
					
				_elseif( regSize == 4 && $<v.u.unsval>3 >= 32 ) 	
				
					yyerror( "Bit number must be between 0 and 31" );
						
				_endif
				Emit_shxd_c_r_m
				( 
					$<u>1, 
					$<v.u.unsval>3, 
					$<u>5, 
					&$<adrs>7 
				);
				
			_else
		
				yyerror( "Expected ordinal value for bit number" );
			
			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>7 );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;
		
		

	


SingleStmt:
		shxdTkns		/* $1 */
		Lparen			/* $2 */
		fcl				/* $3 */
		comma			/* $4 */
		fReg16or32		/* $5 */
		comma			/* $6 */
		fEitherMemDest	/* $7 */
		Rparen			/* $8 */
		{
			int regSize;
			
			_here;
			regSize = _ifx( isReg16( $<u>5 ), 2, 4 );
			_if( $<adrs.Size>7 == 0 )
			
				$<adrs.Size>7 = regSize;
			
			_endif
			_if( $<adrs.Size>7 != regSize )
			
				yyerror( "Memory operand size must match register size" );
				
			_endif
			Emit_shxd_cl_r_m
			( 
				$<u>1, 
				$<u>5, 
				&$<adrs>7 
			);
			$<returns>$ = FreeAdrs2( &$<adrs>7 );
			_here;
		}
	;
	
	
	
	
 /*
 ** Handle the LEA instruction here.
 **
 **	Syntax:
 **
 **		lea( Reg32, memory )
 **		lea( Reg32, AnonMem )
 **		lea( Reg32, LocalProcID )
 **		lea( Reg32, NonLocalProcID )
 **		lea( Reg32, LocalLabelID )
 **		lea( Reg32, StringConstant )
 **		lea( Reg32, const ConstExpr )
 **
 **		lea( memory, Reg32 )
 **		lea( AnonMem, Reg32 )
 **		lea( LocalProcID, Reg32 )
 **		lea( NonLocalProcID, Reg32 )
 **		lea( LocalLabelID, Reg32 )
 **		lea( StringConstant, Reg32 )
 **		lea( const ConstExpr, Reg32 )
 */


SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		fReg32		/* $3 */
		comma		/* $4 */
		fEitherMem	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitLea_m_r( &$<adrs>5, $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ] );  
			FreeAdrs( &$<adrs>5 );
			_here;
		}
	;



SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		fEitherMem	/* $3 */
		comma		/* $4 */
		fReg32		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitLea_m_r( &$<adrs>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );  
			FreeAdrs( &$<adrs>3 );
			_here;
		}			
	;



leaProc:
		LocalProcID
		{
			_here;
			$<s>$ = $<s>1;
		}

	|	NonLocalProcID
		{
			_here;
			$<s>$ = $<s>1;
		}

	|	LocalIterID
		{
			_here;
			$<s>$ = $<s>1;
		}

	|	NonLocalIterID
		{
			_here;
			$<s>$ = $<s>1;
		}

	|	LocalLabelID
		{
			_here;
			$<s>$ = $<s>1;
		}
	;


SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		fReg32		/* $3 */
		comma		/* $4 */
		leaProc		/* $5 */
		Rparen		/* $6 */
		{
			struct adrsYYS adrs;
			
			_here;
			initAdrs2( &adrs, $<s>5->StaticName, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ] );  
			_here;
		}
	;		 

SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		leaProc		/* $3 */
		comma		/* $4 */
		fReg32		/* $5 */
		Rparen		/* $6 */
		{
			struct adrsYYS adrs;
			
			_here;
			initAdrs2( &adrs, $<s>3->StaticName, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );  
			_here;
		}
	;		 

SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		fstmt		/* $3 */
		leaProc		/* $4 */
		comma		/* $5 */
		fReg32		/* $6 */
		Rparen		/* $7 */
		{
			struct adrsYYS adrs;
			
			_here;
			initAdrs2( &adrs, $<s>4->StaticName, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>6 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>6 ] );  
			_here;
		}
	;		 

SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		fReg32		/* $3 */
		comma		/* $4 */
		fstmt		/* $5 */
		leaProc		/* $6 */
		Rparen		/* $7 */
		{
			struct adrsYYS adrs;
			
			_here;
			initAdrs2( &adrs, $<s>6->StaticName, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ] );  
			_here;
		}
	;



SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		fReg32		/* $3 */
		comma		/* $4 */
		fUndefID	/* $5 */
		Rparen		/* $6 */
		{			
			struct SymNode 			*sym;
			struct StaticListType	*sList;
			struct FwdRefLabelType	*temp;
			char					sn[ 256 ];
			struct adrsYYS			adrs;
			struct FwdRefLabelType *flist;

			/*
			** We're taking the address of a label that has yet to be defined
			** in this procedure (note that the label could be defined
			** outside the current procedure as anything, but we'll
			** defer judgement on this until we finish processing the
			** current procedure).
			*/

			_here;

			/*
			** First, let's see if there is already a reference
			** to this particular identifier so we can use the
			** existing StaticName.
			*/

			flist = FwdLabelsList;
			_while( flist != NULL )

				_breakif( _streq( $<idStr>5, flist->label ));
				flist = flist->Next;

			_endwhile

			_if( flist != NULL )

				flist->referenced = 1;
				
				/*
				** We found the symbol in the forward reference
				** list.  So just use the StaticName field of the
				** symbol we located as the target label.
				*/
			
				initAdrs2( &adrs, flist->StaticName, -1, -1, 0, 0 );
				EmitLea_m_r( &adrs, $<reg.encoding>3 );
				

			_else
			
				// See if this symbol is in the static list:
				
				sList = searchStatic( $<idStr>5 );
				_if( sList != NULL )
			
					initAdrs2( &adrs, sList->Name, -1, -1, 0, 0 );
					EmitLea_m_r( &adrs, $<reg.encoding>3 );
			
				_else			

					/*
					** We didn't find the symbol in the forward reference
					** list, so add it to that list.
					*/


					temp = malloc2( sizeof( struct FwdRefLabelType ));
					temp->Next = FwdLabelsList;
					temp->label = hlastrdup2( $<idStr>5 );
					temp->lexLevel = CurLexLevel;
					temp->isExternal = 0;
					temp->referenced = 1;
					sprintf( sn, "%s" sympost "%d", $<idStr>5, LblCntr++ );
					temp->StaticName = hlastrdup2( sn );
					FwdLabelsList = temp;
					initAdrs2( &adrs, sn, -1, -1, 0, 0 );
					EmitLea_m_r( &adrs, $<reg.encoding>3 );
					
				_endif

			_endif
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ] );
			_here;  

		}
	;		 

SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		fUndefID	/* $3 */
		comma		/* $4 */
		fReg32		/* $5 */
		Rparen		/* $6 */
		{
			struct SymNode 			*sym;
			struct adrsYYS 			adrs;
			struct StaticListType	*sList;
			struct FwdRefLabelType	*temp;
			char 					sn[ 256 ];


			/*
			** We're taking the address of a label that has yet to be defined
			** in this procedure (note that the label could be defined
			** outside the current procedure as anything, but we'll
			** defer judgement on this until we finish processing the
			** current procedure).
			*/

			struct FwdRefLabelType *flist;

			_here;
			
			/*
			** First, let's see if there is already a reference
			** to this particular identifier so we can use the
			** existing StaticName.
			*/

			flist = FwdLabelsList;
			_while( flist != NULL )

				_breakif( _streq( $<idStr>3, flist->label ));
				flist = flist->Next;

			_endwhile

			_if( flist != NULL )

				flist->referenced = 1;
				
				/*
				** We found the symbol in the forward reference
				** list.  So just use the StaticName field of the
				** symbol we located as the target label.
				*/

				initAdrs2( &adrs, flist->StaticName, -1, -1, 0, 0 );
				EmitLea_m_r( &adrs, $<reg.encoding>5 );

			_else

				// See if this symbol is in the static list:
				
				sList = searchStatic( $<idStr>3 );
				_if( sList != NULL )
			
					initAdrs2( &adrs, sList->Name, -1, -1, 0, 0 );
					EmitLea_m_r( &adrs, $<reg.encoding>5 );
			
				_else			

					/*
					** We didn't find the symbol in the forward reference
					** list, so add it to that list.
					*/


					temp = malloc2( sizeof( struct FwdRefLabelType ));
					temp->Next = FwdLabelsList;
					temp->label = hlastrdup2( $<idStr>3 );
					temp->lexLevel = CurLexLevel;
					temp->isExternal = 0;
					temp->referenced = 1;
					sprintf( sn, "%s" sympost "%d", $<idStr>3, LblCntr++ );
					temp->StaticName = hlastrdup2( sn );
					FwdLabelsList = temp;
					initAdrs2( &adrs, sn, -1, -1, 0, 0 );
					EmitLea_m_r( &adrs, $<reg.encoding>5 );
					
				_endif

			_endif
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;  
		}
	;








SingleStmt:
		leaTkn			/* $1 */
		Lparen			/* $2 */
		fReg32			/* $3 */
		comma			/* $4 */
		StringConst		/* $5 */
		Rparen			/* $6 */
		{
			struct adrsYYS	adrs;
			int				lbl;
			char 			label[256];

			_here;
			lbl = EmitString( $<v.u.strval>5 );
			sprintf( label, "str" sympost "%d", lbl );
			initAdrs2( &adrs, label, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>3 );
				
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
			_if( langLevel <= medium_level )
			
				yyerror
				( 
					"LEA with a string operand is illegal except in \n"
					"high-level language mode."
				);
				
			_endif
		}
	;		 

SingleStmt:
		leaTkn			/* $1 */
		Lparen			/* $2 */
		StringConst		/* $3 */
		comma			/* $4 */
		fReg32			/* $5 */
		Rparen			/* $6 */
		{
			struct adrsYYS	adrs;
			int				lbl;
			char 			label[256];

			_here;
			lbl = EmitString( $<v.u.strval>3 );
			sprintf( label, "str" sympost "%d", lbl );
			initAdrs2( &adrs, label, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>5 );
				
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
			_if( langLevel <= medium_level )
			
				yyerror
				( 
					"LEA with a string operand is illegal except in \n"
					"high-level language mode."
				);
				
			_endif
		}
	;		 

SingleStmt:
		leaTkn			/* $1 */
		Lparen			/* $2 */
		fstmt			/* $3 */
		StringConst		/* $4 */
		comma			/* $5 */
		fReg32			/* $6 */
		Rparen			/* $7 */
		{
			struct adrsYYS	adrs;
			int				lbl;
			char			label[256];

			_here;
			lbl = EmitString( $<v.u.strval>4 );
			sprintf( label, "str" sympost "%d", lbl );
			initAdrs2( &adrs, label, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>6 );
				
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>6 ]);
			_if( langLevel <= medium_level )
			
				yyerror
				( 
					"LEA with a string operand is illegal except in \n"
					"high-level language mode."
				);
				
			_endif
		}
	;		 

SingleStmt:
		leaTkn			/* $1 */
		Lparen			/* $2 */
		fReg32			/* $3 */
		comma			/* $4 */
		fstmt			/* $5 */
		StringConst		/* $6 */
		Rparen			/* $7 */
		{
			struct adrsYYS	adrs;
			int				lbl;
			char 			label[256];

			_here;
			lbl = EmitString( $<v.u.strval>6 );
			sprintf( label, "str" sympost "%d", lbl );
			initAdrs2( &adrs, label, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>3 );
				
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
			_if( langLevel <= medium_level )
			
				yyerror
				( 
					"LEA with a string operand is illegal except in \n"
					"high-level language mode."
				);
				
			_endif
		}
	;



SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		fReg32		/* $3 */
		comma		/* $4 */
		constTkn	/* $5 */
		fConstExpr	/* $6 */
		Rparen		/* $7 */
		{
			int 			lbl;
			struct SymNode	*Type;
			struct adrsYYS	adrs;
			char			label[256];

			_here;
			Type = _ifx( $<v.Type>6 == NULL, &$<v>6, $<v.Type>6 );
			startStrSeg();
			lbl = LblCntr++;
			sprintf
			( 
				label, 
				"leaData" sympost "%d", 
				lbl
			);
			
			// Reserve at least four bytes for the constant in memory:
			
			_if( Type->ObjectSize < 4 )
			
				Type = &dword_ste;
				
			_endif
			OutValue( label, Type, YYS &$<v>6 );
			endStrSeg();
			
			initAdrs2( &adrs, label, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>3 );
			FreeValue( YYS &$<v>6 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
			_if( langLevel <= medium_level )
			
				yyerror
				( 
					"LEA with a CONST operand is illegal except in \n"
					"high-level language mode."
				);
				
			_endif
			_here;
		}
	;		 

SingleStmt:
		leaTkn		/* $1 */
		Lparen		/* $2 */
		constTkn	/* $3 */
		fConstExpr	/* $4 */
		comma		/* $5 */
		fReg32		/* $6 */
		Rparen		/* $7 */
		{
			int 			lbl;
			struct SymNode	*Type;
			struct adrsYYS	adrs;
			char			label[256];

			_here;
			Type = _ifx( $<v.Type>4 == NULL, &$<v>4, $<v.Type>4 );
			startStrSeg();
			lbl = LblCntr++;
			sprintf
			( 
				label, 
				"leaData" sympost "%d", 
				lbl
			);
			
			// Reserve at least four bytes for the constant in memory:
			
			_if( Type->ObjectSize < 4 )
			
				Type = &dword_ste;
				
			_endif
			OutValue( label, Type, YYS &$<v>4 );
			endStrSeg();
			initAdrs2( &adrs, label, -1, -1, 0, 0 );
			EmitLea_m_r( &adrs, $<reg.encoding>6 );
			FreeValue( YYS &$<v>4 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>6 ]);
			_if( langLevel <= medium_level )
			
				yyerror
				( 
					"LEA with a CONST operand is illegal except in \n"
					"high-level language mode."
				);
				
			_endif
			_here;
		}
	;



 /*
 ** Handle the MOVSX and MOVZX instructions here.
 **
 ** Syntax:
 **
 ** movsx( Reg8, Reg16 )
 ** movsx( Reg8, Reg32 )
 **
 ** movsx( Reg16, Reg32 )
 **
 ** movsx( mem, Reg16 )
 ** movsx( mem, Reg32 )
 **
 ** Ditto for movzx.
 */			



MovSorX: 
		movsxTkn
		{
			_here;
			$<u>$ = movsx_instr;
		}
		 
	|	movzxTkn
		{
			_here;
			$<u>$ = movzx_instr;
		}
	;

SingleStmt:
		MovSorX		/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if
			( 
					$<reg.Size>5 != $<reg.Size>3*2
				&&	$<reg.Size>5 != $<reg.Size>3*4
			)

				yyerror( "Dest operand must be larger than source operand" );

			_endif
			EmitMovxx_r_r( $<u>1, $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
			_here;
		}
	;

SingleStmt:
		MovSorX		/* $1 */
		Lparen		/* $2 */
		fMemoryDest	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if
			( 
					$<reg.Size>5 != $<adrs.Size>3*2
				&&	$<reg.Size>5 != $<adrs.Size>3*4
			)

				yyerror( "Dest operand must be larger than source operand" );

			_endif
			EmitMovxx_m_r( $<u>1, &$<adrs>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;



	/*
	** Deal with some common errors here.
	*/

SingleStmt:
		MovSorX		/* $1 */
		Lparen		/* $2 */
		fAnonMem	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			/*
			** We could actually handle this one (must be byte),
			** but just to be safe and consistent, give an error.
			*/

			yyerror( "Must specify memory size" );
			yyerror( SizeMismatchStr );
			FreeAdrs( &$<adrs>2 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
		}
	;



 /*
 ** Handle the XADD instruction here.
 **
 ** Syntax:
 **
 **		xadd( Reg8, Reg8 )
 **		xadd( mem, Reg8 )
 **
 **		xadd( Reg16, Reg16 )
 **		xadd( mem, Reg16 )
 **
 **		xadd( Reg32, Reg32 )
 **		xadd( mem, Reg32 )
 */

SingleStmt:
		xaddTkn
		Lparen
		fRegister
		comma
		fRegister
		Rparen
		{
			_here;
			_if( $<reg.Size>3 != $<reg.Size>5 )

				yyerror( "Register size mismatch" );

			_endif
			EmitXadd_r_r( $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
		}
	;



SingleStmt:
		xaddTkn
		Lparen
		fRegister
		comma
		fEitherMemDest
		Rparen
		{
			_here;
			_if( $<reg.Size>3 != $<adrs.Size>5 && $<adrs.Size>5 != 0 )

				yyerror( "Operand size mismatch" );

			_endif
			EmitXadd_r_m( $<reg.encoding>3, &$<adrs>5, 0 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 ); 
			_here;
		}
	;
		
SingleStmt:
		lockxaddTkn
		Lparen
		fRegister
		comma
		fEitherMemDest
		Rparen
		{
			_here;
			_if( $<reg.Size>3 != $<adrs.Size>5 && $<adrs.Size>5 != 0 )

				yyerror( "Operand size mismatch" );

			_endif
			EmitXadd_r_m( $<reg.encoding>3, &$<adrs>5, 0xf0 );	// Lock prefix
			$<returns>$ = FreeAdrs2( &$<adrs>5 ); 
			_here;
		}
	;


SingleStmt:
		lockxaddTkn
		Lparen
		fRegister
		comma
		fRegister
		Rparen
		{
			_here;
			yyerror( "Destination operand must be a memory location" );
			$<returns>$ = NULL; 
			_here;
		}
	;
		








// Handle the CMPSS instructions

cmpssTkns:
		cmpeqssTkn
		{
			_here;
			$<u>$ = cmpeqss_instr;
		}
	|	cmpneqssTkn
		{
			_here;
			$<u>$ = cmpness_instr;
		}
	|	cmpltssTkn
		{
			_here;
			$<u>$ = cmpltss_instr;
		}
	|	cmpnltssTkn
		{
			_here;
			$<u>$ = cmpnltss_instr;
		}
	|	cmplessTkn
		{
			_here;
			$<u>$ = cmpless_instr;
		}
	|	cmpnlessTkn
		{
			_here;
			$<u>$ = cmpnless_instr;
		}
	|	cmpordssTkn
		{
			_here;
			$<u>$ = cmpordss_instr;
		}
	|	cmpunordssTkn
		{
			_here;
			$<u>$ = cmpunordss_instr;
		}
	;
	
	
SingleStmt:
		cmpssTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		xx				/* $5 */
		Rparen			/* $6 */
		{
			int subop = $<v.u.unsval>3;
			
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || subop > 7 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..7" 
				);
				subop = 0;
				
			_endif
			EmitCmpss_r_r( subop, $<rr>5.l, $<rr>5.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>5.r ] );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



SingleStmt:
		cmpssTkns		/* $1 */
		pxx				/* $2 */
		{
			_here;
			EmitCmpss_r_r( $<u>1, $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;



SingleStmt:
		cmpssTkn			/* $1 */
		Lparen				/* $2 */
		ConstOnlyExpr		/* $3 */
		comma				/* $4 */
		fEitherMem32Dest	/* $5 */
		comma				/* $6 */
		fXmmReg				/* $7 */
		Rparen				/* $8 */
		{
			int subop = $<v.u.unsval>3;
			
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || subop > 7 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..7" 
				);
				subop = 0;
				
			_endif
			EmitCmpss_m_r( subop, &$<adrs>5, $<u>7 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>7 ] );
			FreeAdrs( &$<adrs>5 );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



SingleStmt:
		cmpssTkns			/* $1 */
		Lparen				/* $2 */
		fEitherMem32Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitCmpss_m_r( $<u>1, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;









// Handle the CMPSD instructions


cmpsdTkns:
		cmpeqsdTkn
		{
			_here;
			$<u>$ = cmpeqsd_instr;
		}
	|	cmpneqsdTkn
		{
			_here;
			$<u>$ = cmpnesd_instr;
		}
	|	cmpltsdTkn
		{
			_here;
			$<u>$ = cmpltsd_instr;
		}
	|	cmpnltsdTkn
		{
			_here;
			$<u>$ = cmpnltsd_instr;
		}
	|	cmplesdTkn
		{
			_here;
			$<u>$ = cmplesd_instr;
		}
	|	cmpnlesdTkn
		{
			_here;
			$<u>$ = cmpnlesd_instr;
		}
	|	cmpordsdTkn
		{
			$<u>$ = cmpordsd_instr;
		}
	|	cmpunordsdTkn
		{
			_here;
			$<u>$ = cmpunordsd_instr;
		}
	;
	
	
SingleStmt:
		cmpsdTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		comma			/* $6 */
		fXmmReg			/* $7 */
		Rparen			/* $8 */
		{
			int subop = $<v.u.unsval>3;
			
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || subop > 7 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..7" 
				);
				subop = 0;
				
			_endif
			EmitCmpsd_r_r( subop, $<u>5, $<u>7 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>7 ] );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



SingleStmt:
		cmpsdTkns		/* $1 */
		Lparen			/* $2 */
		fXmmReg			/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			EmitCmpsd_r_r( $<u>1, $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;



SingleStmt:
		cmpsdTkn			/* $1 */
		Lparen				/* $2 */
		ConstOnlyExpr		/* $3 */
		comma				/* $4 */
		fEitherMem64Dest	/* $5 */
		comma				/* $6 */
		fXmmReg				/* $7 */
		Rparen				/* $8 */
		{
			int subop = $<v.u.unsval>3;
			
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || subop > 7 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..7" 
				);
				subop = 0;
				
			_endif
			EmitCmpsd_m_r( subop, &$<adrs>5, $<u>7 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>7 ] );
			FreeAdrs( &$<adrs>5 );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



SingleStmt:
		cmpsdTkns			/* $1 */
		Lparen				/* $2 */
		fEitherMem64Dest	/* $3 */
		comma				/* $4 */
		fXmmReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitCmpsd_m_r( $<u>1, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;




// Handle the CMPPS instructions


cmppsTkns:
		cmpeqpsTkn
		{
			_here;
			$<u>$ = cmpeqps_instr;
		}
	|	cmpneqpsTkn
		{
			_here;
			$<u>$ = cmpneps_instr;
		}
	|	cmpltpsTkn
		{
			_here;
			$<u>$ = cmpltps_instr;
		}
	|	cmpnltpsTkn
		{
			_here;
			$<u>$ = cmpnltps_instr;
		}
	|	cmplepsTkn
		{
			_here;
			$<u>$ = cmpleps_instr;
		}
	|	cmpnlepsTkn
		{
			_here;
			$<u>$ = cmpnleps_instr;
		}
	|	cmpordpsTkn
		{
			_here;
			$<u>$ = cmpordps_instr;
		}
	|	cmpunordpsTkn
		{
			_here;
			$<u>$ = cmpunordps_instr;
		}
	;

SingleStmt:
		cmppsTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		xx				/* $5 */
		Rparen			/* $6 */
		{
			int subop = $<v.u.unsval>3;
			
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || subop > 7 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..7" 
				);
				subop = 0;
				
			_endif
			EmitCmpps_r_r( subop, $<rr>5.l, $<rr>5.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>5.r ] );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



SingleStmt:
		cmppsTkns		/* $1 */
		pxx				/* $2 */
		{
			_here;
			EmitCmpps_r_r( $<u>1, $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;



SingleStmt:
		cmppsTkn			/* $1 */
		Lparen				/* $2 */
		ConstOnlyExpr		/* $3 */
		comma				/* $4 */
		fEitherMem128Dest	/* $5 */
		comma				/* $6 */
		fXmmReg				/* $7 */
		Rparen				/* $8 */
		{
			int subop = $<v.u.unsval>3;
			
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || subop > 7 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..7" 
				);
				subop = 0;
				
			_endif
			EmitCmpps_m_r( subop, &$<adrs>5, $<u>7 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>7 ] );
			FreeAdrs( &$<adrs>5 );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



SingleStmt:
		cmppsTkns			/* $1 */
		pmx					/* $2 */
		{
			_here;
			EmitCmpps_m_r( $<u>1, &$<mr.m>2, $<mr.r>2 );
			$<returns>$ = hlastrdup2( uToXmm[ $<mr.r>2 ] );
			FreeAdrs( &$<mr.m>2 );
			_here;
		}
	;




// Handle the CMPPD instructions


cmppdTkns:
		cmpeqpdTkn
		{
			_here;
			$<u>$ = cmpeqpd_instr;
		}
	|	cmpneqpdTkn
		{
			_here;
			$<u>$ = cmpnepd_instr;
		}
	|	cmpltpdTkn
		{
			_here;
			$<u>$ = cmpltpd_instr;
		}
	|	cmpnltpdTkn
		{
			_here;
			$<u>$ = cmpnltpd_instr;
		}
	|	cmplepdTkn
		{
			_here;
			$<u>$ = cmplepd_instr;
		}
	|	cmpnlepdTkn
		{
			_here;
			$<u>$ = cmpnlepd_instr;
		}
	|	cmpordpdTkn
		{
			_here;
			$<u>$ = cmpordpd_instr;
		}
	|	cmpunordpdTkn
		{
			_here;
			$<u>$ = cmpunordpd_instr;
		}
	;

SingleStmt:
		cmppdTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		xx				/* $5 */
		Rparen			/* $6 */
		{
			int subop = $<v.u.unsval>3;
			
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || subop > 7 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..7" 
				);
				subop = 0;
				
			_endif
			EmitCmppd_r_r( subop, $<rr>5.l, $<rr>5.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>5.r ] );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



SingleStmt:
		cmppdTkns		/* $1 */
		pxx				/* $2 */
		{
			_here;
			EmitCmppd_r_r( $<u>1, $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;



SingleStmt:
		cmppdTkn			/* $1 */
		Lparen				/* $2 */
		ConstOnlyExpr		/* $3 */
		comma				/* $4 */
		fEitherMem128Dest	/* $5 */
		comma				/* $6 */
		fXmmReg				/* $7 */
		Rparen				/* $8 */
		{
			int subop = $<v.u.unsval>3;
			
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || subop > 7 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..7" 
				);
				subop = 0;
				
			_endif
			EmitCmppd_m_r( subop, &$<adrs>5, $<u>7 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>7 ] );
			FreeAdrs( &$<adrs>5 );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;



SingleStmt:
		cmppdTkns			/* $1 */
		pmx					/* $2 */
		{
			_here;
			EmitCmppd_m_r( $<u>1, &$<mr.m>2, $<mr.r>2 );
			$<returns>$ = hlastrdup2( uToXmm[ $<mr.r>2 ] );
			FreeAdrs( &$<mr.m>2 );
			_here;
		}
	;

	

// Handle the movnti instruction

SingleStmt:
		movntiTkn			/* $1 */
		Lparen				/* $2 */
		fReg32				/* $3 */
		comma				/* $4 */
		fEitherMem32Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitMovnti_r_m( $<reg.encoding>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;
		}
	;
	

// Handle the pinsrw instruction:

SingleStmt:
		pinsrwTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		fReg16or32		/* $5 */
		comma			/* $6 */
		fmmxReg			/* $7 */
		Rparen			/* $8 */
		{
		
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || $<v.u.unsval>3 > 255 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..255" 
				);
				
			_endif
			EmitPinsrw_r_r( $<v.u.unsval>3, $<u>5, $<u>7, 0 );
			$<returns>$ = hlastrdup2( uToMmx[ $<u>7 ] );
			_here;
			
		}
	;

SingleStmt:
		pinsrwTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		fReg16or32		/* $5 */
		comma			/* $6 */
		fXmmReg			/* $7 */
		Rparen			/* $8 */
		{
		
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || $<v.u.unsval>3 > 255 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..255" 
				);
				
			_endif
			EmitPinsrw_r_r( $<v.u.unsval>3, $<u>5, $<u>7, 0x66 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>7 ] );
			_here;
			
		}
	;



SingleStmt:
		pinsrwTkn			/* $1 */
		Lparen				/* $2 */
		ConstOnlyExpr		/* $3 */
		comma				/* $4 */
		fEitherMem16Dest	/* $5 */
		comma				/* $6 */
		fmmxReg				/* $7 */
		Rparen				/* $8 */
		{
		
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || $<v.u.unsval>3 > 255 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..255" 
				);
				
			_endif
			EmitPinsrw_m_r( $<v.u.unsval>3, &$<adrs>5, $<u>7, 0 );
			$<returns>$ = hlastrdup2( uToMmx[ $<u>7 ] );
			FreeAdrs( &$<adrs>5 );
			_here;
			
		}
	;

SingleStmt:
		pinsrwTkn			/* $1 */
		Lparen				/* $2 */
		ConstOnlyExpr		/* $3 */
		comma				/* $4 */
		fEitherMem16Dest	/* $5 */
		comma				/* $6 */
		fXmmReg				/* $7 */
		Rparen				/* $8 */
		{
		
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || $<v.u.unsval>3 > 255 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..255" 
				);
				
			_endif
			EmitPinsrw_m_r( $<v.u.unsval>3, &$<adrs>5, $<u>7, 0x66 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>7 ] );
			FreeAdrs( &$<adrs>5 );
			_here;
			
		}
	;
	

// Handle the pextrw instruction:

SingleStmt:
		pextrwTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		fmmxReg			/* $5 */
		comma			/* $6 */
		fReg32			/* $7 */
		Rparen			/* $8 */
		{
		
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || $<v.u.unsval>3 > 255 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..255" 
				);
				
			_endif
			EmitPextrw_r_r( $<v.u.unsval>3, $<u>5, $<reg.encoding>7, 0 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>7 ] );
			_here;
			
		}
	;

SingleStmt:
		pextrwTkn		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		comma			/* $6 */
		fReg32			/* $7 */
		Rparen			/* $8 */
		{
		
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || $<v.u.unsval>3 > 255 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..255" 
				);
				
			_endif
			EmitPextrw_r_r( $<v.u.unsval>3, $<u>5, $<reg.encoding>7, 0x66 );
			$<returns>$ = hlastrdup2( uToXmm[ $<reg.encoding>7 ] );
			_here;
			
		}
	;




// Handle the shufps and shufpd instructions here

shufTkns:
		shufpsTkn
		{
			_here;
			$<u>$ = 0;
		}
	
	|	shufpdTkn
		{
			_here;
			$<u>$ = 0x66;
		}
	;
	
SingleStmt:
		shufTkns		/* $1 */
		Lparen			/* $2 */
		ConstOnlyExpr	/* $3 */
		comma			/* $4 */
		xx				/* $5 */
		Rparen			/* $6 */
		{
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || $<v.u.unsval>3 > 255 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..255" 
				);
				
			_endif
			EmitShufxx_r_r( $<u>1, $<v.u.unsval>3, $<rr>5.l, $<rr>5.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>5.r ] );
			_here;
		}
	;


	
SingleStmt:
		shufTkns			/* $1 */
		Lparen				/* $2 */
		ConstOnlyExpr		/* $3 */
		comma				/* $4 */
		fEitherMem128Dest	/* $5 */
		comma				/* $6 */
		fXmmReg				/* $7 */
		Rparen				/* $8 */
		{
			_here;
			_if( !IsSmallNumber( $<v.pType>3 ) || $<v.u.unsval>3 > 255 )
			
				yyerror
				( 
					"First operand must be an integer constant in the range 0..255" 
				);
				
			_endif
			EmitShufxx_m_r( $<u>1, $<v.u.unsval>3, &$<adrs>5, $<u>7 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>7] );
			FreeAdrs( &$<adrs>5 );
			_here;
		}
	;
	
	


SingleStmt:
		cmpxchg8bTkn	/* $1 */
		Lparen			/* $2 */
		fEitherMemDest	/* $3 */
		Rparen			/* $4 */
		{
			char adrs[ 256 ];

			_here;
			_if( $<adrs.Size>3 == 8 || $<adrs.Size>3 == 0 )

				EmitCmpXchg8b( &$<adrs>3 );

			_else

				yyerror( SizeMismatchStr );

			_endif
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}
	;
		
SingleStmt:
		cmpxchg8bTkn	/* $1 */
		Lparen			/* $2 */
		error			/* $3 */
		Rparen			/* $4 */
		{
			yyerror( "Syntax: 'cmpxchg8b( m64 )'" );
			$<returns>$ = NULL;
		}
	;





// Handle movq2dq here

SingleStmt:
		movq2dqTkn	/* $1 */
		Lparen		/* $2 */
		fmmxReg		/* $3 */
		comma		/* $4 */
		fXmmReg		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitMovq2dq_r_r( $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;





// Handle movdq2q here

SingleStmt:
		movdq2qTkn	/* $1 */
		Lparen		/* $2 */
		fXmmReg		/* $3 */
		comma		/* $4 */
		fmmxReg		/* $5 */
		Rparen		/* $2 */
		{
			_here;
			EmitMovdq2q_r_r( $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToMmx[ $<u>5 ] );
			_here;
		}
	;



// Handle pmovmskb here

SingleStmt:
		pmovmskbTkn	/* $1 */
		Lparen		/* $2 */
		fmmxReg		/* $3 */
		comma		/* $4 */
		fReg32		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitPmovmskb_r_r( $<u>3, $<reg.encoding>5, 0 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
		}
	;
	

SingleStmt:
		pmovmskbTkn	/* $1 */
		Lparen		/* $2 */
		fXmmReg		/* $3 */
		comma		/* $4 */
		fReg32		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitPmovmskb_r_r( $<u>3, $<reg.encoding>5, 0x66 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
		}
	;
	
	
	
// Handle MOVNTQ and MOVNTDQ here:

SingleStmt:
		movntqTkn			/* $1 */
		Lparen				/* $2 */
		fmmxReg				/* $3 */
		comma				/* $4 */
		fEitherMem64Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitMovntq_r_m( $<u>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 ); 
			_here;
		}
	;



SingleStmt:
		movntdqTkn			/* $1 */
		Lparen				/* $2 */
		fXmmReg				/* $3 */
		comma				/* $4 */
		fEitherMem128Dest	/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitMovntdq_r_m( $<u>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 ); 
			_here;
		}
	;



// Handle maskmovq and maskmovdq here

SingleStmt:
		maskmovqTkn
		ppp
		{
			_here;
			EmitMaskMovq_r_r( $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToMmx[ $<rr>2.r ] );
			_here;
		}
	;
		


SingleStmt:
		maskmovdquTkn
		pxx
		{
			_here;
			EmitMaskMovdqu_r_r( $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
	
	
	
// Handle ucomiss, ucomisd, comiss, and comisd here:

comTkns:
		ucomissTkn
		{
			_here;
			$<u>$ = ucomiss_instr;
		}
	
	|	ucomisdTkn
		{
			_here;
			$<u>$ = ucomisd_instr;
		}
		
	|	comissTkn
		{
			_here;
			$<u>$ = comiss_instr;
		}
		
	|	comisdTkn
		{
			_here;
			$<u>$ = comisd_instr;
		}
	;
	
	
SingleStmt:
		comTkns
		pxx
		{
			_here;
			EmitCom_r_r( $<u>1, $<rr>2.l, $<rr>2.r );
			$<returns>$ = hlastrdup2( uToXmm[ $<rr>2.r ] );
			_here;
		}
	;
	
SingleStmt:
		comTkns		/* $1 */
		Lparen		/* $2 */
		fEitherMem	/* $3 */
		comma		/* $4 */
		fXmmReg		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<u>1 == ucomiss_instr || $<u>1 == comiss_instr )
			
				_if( $<adrs.Size>3 != 4 && $<adrs.Size>3 != 0 )
				
					yyerror( "Expected a dword/real32 memory operand" );
					
				_endif
				
			_elseif( $<u>1 == ucomisd_instr || $<u>1 == comisd_instr )
			
				_if( $<adrs.Size>3 != 8 && $<adrs.Size>3 != 0  )
				
					yyerror( "Expected a qword/real64 memory operand" );
					
				_endif
				
			_endif
			EmitCom_m_r( $<u>1, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;
		

	



// Handle cvtpd2pi and cvttpd2pi here:
	
pd2piTkns:
		cvtpd2piTkn
		{
			_here;
			$<u>$ = cvtpd2pi_instr;
		}
		
	|	cvttpd2piTkn
		{
			_here;
			$<u>$ = cvttpd2pi_instr;
		}
	;
	
SingleStmt:
		pd2piTkns	/* $1 */
		Lparen		/* $2 */
		fXmmReg		/* $3 */
		comma		/* $4 */
		fmmxReg		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitPd2pi_r_r( $<u>1, $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToMmx[ $<u>5 ] );
			_here;
		}
	;	
			
	
SingleStmt:
		pd2piTkns			/* $1 */
		Lparen				/* $2 */
		fEitherMem128Dest	/* $3 */
		comma				/* $4 */
		fmmxReg				/* $5 */
		Rparen				/* $6 */
		{
			_here;
			EmitPd2pi_m_r( $<u>1, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToMmx[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;	
			

// Handle cvtps2pd and cvtsd2ss here:

SingleStmt:
		cvtps2pdTkn		/* $1 */
		Lparen			/* $2 */
		fXmmReg			/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			EmitPssd2pdss_r_r( cvtps2pd_instr, $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;	
			
	
SingleStmt:
		cvtsd2ssTkn		/* $1 */
		Lparen			/* $2 */
		fXmmReg			/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			EmitPssd2pdss_r_r( cvtsd2ss_instr, $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;	
			
	
SingleStmt:
		cvtps2pdTkn				/* $1 */
		Lparen					/* $2 */
		fEitherMem64Dest		/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			EmitPssd2pdss_m_r( cvtps2pd_instr, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;	
			
	
SingleStmt:
		cvtsd2ssTkn				/* $1 */
		Lparen					/* $2 */
		fEitherMem64Dest		/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			EmitPssd2pdss_m_r( cvtsd2ss_instr, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;	
			

				
			

// Handle cvtpi2pd and cvtpi2ps here:

pi2pdpsTkns:
		cvtpi2pdTkn
		{
			_here;
			$<u>$ = cvtpi2pd_instr;
		}
		
	|	cvtpi2psTkn
		{
			_here;
			$<u>$ = cvtpi2ps_instr;
		}
	;
	
	
SingleStmt:
		pi2pdpsTkns		/* $1 */
		Lparen			/* $2 */
		fmmxReg			/* $3 */
		comma			/* $4 */
		fXmmReg			/* $5 */
		Rparen			/* $6 */
		{
			_here;
			Emitpi2pdps_r_r( $<u>1, $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
		}
	;	
			
	
SingleStmt:
		pi2pdpsTkns				/* $1 */
		Lparen					/* $2 */
		fEitherMem64Dest		/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emitpi2pdps_m_r( $<u>1, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;	
			


// Handle cvtps2pi and cvttps2pi here:

ps2piTkns:
		cvtps2piTkn
		{
			_here;
			$<u>$ = cvtps2pi_instr;
		}
		
	|	cvttps2piTkn
		{
			_here;
			$<u>$ = cvttps2pi_instr;
		}
	;
	
SingleStmt:
		ps2piTkns	/* $1 */
		Lparen		/* $2 */
		fXmmReg		/* $3 */
		comma		/* $4 */
		fmmxReg		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			Emitps2pi_r_r( $<u>1, $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToMmx[ $<u>5 ] );
			_here;
		}
	;
			
	
SingleStmt:
		ps2piTkns				/* $1 */
		Lparen					/* $2 */
		fEitherMem64Dest		/* $3 */
		comma					/* $4 */
		fmmxReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emitps2pi_m_r( $<u>1, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToMmx[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;
	

// Handle cvtsd2si and cvttsd2si here:
	
sd2siTkns:
		cvtsd2siTkn
		{
			_here;
			$<u>$ = cvtsd2si_instr;
		}
		
	|	cvttsd2siTkn
		{
			_here;
			$<u>$ = cvttsd2si_instr;
		}
	;
	
SingleStmt:
		sd2siTkns	/* $1 */
		Lparen		/* $2 */
		fXmmReg		/* $3 */
		comma		/* $4 */
		fReg32		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			Emitsd2si_r_r( $<u>1, $<u>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
			
		}
	;
	

			
	
SingleStmt:
		sd2siTkns				/* $1 */
		Lparen					/* $2 */
		fEitherMem64Dest		/* $3 */
		comma					/* $4 */
		fReg32					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emitsd2si_m_r( $<u>1, &$<adrs>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;
				

	

// Handle cvtsd2si and cvttsd2si here:
	
ss2siTkns:
		cvtss2siTkn
		{
			_here;
			$<u>$ = cvtss2si_instr;
		}
		
	|	cvttss2siTkn
		{
			_here;
			$<u>$ = cvttss2si_instr;
		}
	;
	
SingleStmt:
		ss2siTkns	/* $1 */
		Lparen		/* $2 */
		fXmmReg		/* $3 */
		comma		/* $4 */
		fReg32		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			Emitss2si_r_r( $<u>1, $<u>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
			
		}
	;
	

			
	
SingleStmt:
		ss2siTkns				/* $1 */
		Lparen					/* $2 */
		fEitherMem32Dest		/* $3 */
		comma					/* $4 */
		fReg32					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emitss2si_m_r( $<u>1, &$<adrs>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;
				

				

	

// Handle cvtsd2si and cvttsd2si here:
	
si2sdsTkns:
		cvtsi2sdTkn
		{
			_here;
			$<u>$ = cvtsi2sd_instr;
		}
		
	|	cvtsi2ssTkn
		{
			_here;
			$<u>$ = cvtsi2ss_instr;
		}
	;
	
SingleStmt:
		si2sdsTkns	/* $1 */
		Lparen		/* $2 */
		fReg32		/* $3 */
		comma		/* $4 */
		fXmmReg		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			Emitsi2sds_r_r( $<u>1, $<reg.encoding>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
			
		}
	;
	

			
	
SingleStmt:
		si2sdsTkns				/* $1 */
		Lparen					/* $2 */
		fEitherMem32Dest		/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emitsi2sds_m_r( $<u>1, &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;
				


				

	

// Handle cvtss2sd here:
	
SingleStmt:
		cvtss2sdTkn	/* $1 */
		Lparen		/* $2 */
		fXmmReg		/* $3 */
		comma		/* $4 */
		fXmmReg		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			Emitss2sd_r_r( $<u>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			_here;
			
		}
	;
	

			
	
SingleStmt:
		cvtss2sdTkn				/* $1 */
		Lparen					/* $2 */
		fEitherMem32Dest		/* $3 */
		comma					/* $4 */
		fXmmReg					/* $5 */
		Rparen					/* $6 */
		{
			_here;
			Emitss2sd_m_r( &$<adrs>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToXmm[ $<u>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;
	
	
m8Tkns:
		clflushTkn
		{
			_here;
			$<u>$ = clflush_instr;
		}
				
	|	prefetcht0Tkn
		{
			_here;
			$<u>$ = prefetch0_instr;
		}
				
	|	prefetcht1Tkn
		{
			_here;
			$<u>$ = prefetch1_instr;
		}
				
	|	prefetcht2Tkn
		{
			_here;
			$<u>$ = prefetch2_instr;
		}
				
	|	prefetchntaTkn
		{
			_here;
			$<u>$ = prefetchnta_instr;
		}
	;
	
SingleStmt:
		m8Tkns
		Lparen
		fEitherMemDest
		Rparen
		{
			_here;
			EmitM8Instrs( $<u>1, &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;



SingleStmt:
		pauseTkn
		EmptyParens
		{ 
			_here; 
			$<returns>$ = NULL;
			implied_instr( pause_instr );
			_here;
		}
	;
	
	
// Handle lfence, mfence, and sfence here:

SingleStmt:
		lfenceTkn
		EmptyParens
		{
			_here; 
			$<returns>$ = NULL;
			fence_instr( lfence_instr );
			_here;
		}
	;
		
SingleStmt:
		mfenceTkn
		EmptyParens
		{
			_here; 
			$<returns>$ = NULL;
			fence_instr( mfence_instr );
			_here;
		}
	;
		
SingleStmt:
		sfenceTkn
		EmptyParens
		{
			_here; 
			$<returns>$ = NULL;
			fence_instr( sfence_instr );
			_here;
		}
	;
	
	
				

SingleStmt:
		monitorTkn
		EmptyParens
		{
			_here; 
			$<returns>$ = NULL;
			EmitMonitor( monitor_instr );
			_here;
		}
	;
	
	
SingleStmt:
		mwaitTkn
		EmptyParens
		{
			_here; 
			$<returns>$ = NULL;
			EmitMonitor( mwait_instr );
			_here;
		}
	;
	
	
// Handle ldmxcsr and stmxcsr here:

ldstmxcsrTkns:
		ldmxcsrTkn
		{
			_here;
			$<u>$ = ldmxcsr_instr;
		}
		
	|	stmxcsrTkn
		{
			_here;
			$<u>$ = stmxcsr_instr;
		}
	;
	
	
SingleStmt:
		ldstmxcsrTkns		/* $1 */
		Lparen				/* $2 */
		fEitherMem32Dest	/* $3 */
		Rparen				/* $4 */
		{
			_here;
			EmitMxcsr( $<u>1, &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );	
		}
	;



///////////////////////////////////////////////////////////////////////////////
//
// One-byte instruction opcodes


genericTkns:
		addTkn
		{
			_here;
			$<u>$ = add_instr;
		}
		
	|	lockaddTkn
		{
			_here;
			$<u>$ = lockadd_instr;
		}
		
	|	adcTkn
		{
			_here;
			$<u>$ = adc_instr;
		}
		
	|	lockadcTkn
		{
			_here;
			$<u>$ = lockadc_instr;
		}
		
	|	andTkn
		{
			_here;
			$<u>$ = and_instr;
		}
		
	|	lockandTkn
		{
			_here;
			$<u>$ = lockand_instr;
		}
		
	|	xorTkn
		{
			_here;
			$<u>$ = xor_instr;
		}
		
	|	lockxorTkn
		{
			_here;
			$<u>$ = lockxor_instr;
		}
		
	|	orTkn
		{
			_here;
			$<u>$ = or_instr;
		}
		
	|	lockorTkn
		{
			_here;
			$<u>$ = lockor_instr;
		}
		
	|	sbbTkn
		{
			_here;
			$<u>$ = sbb_instr;
		}
		
	|	locksbbTkn
		{
			_here;
			$<u>$ = locksbb_instr;
		}
		
	|	subTkn
		{
			_here;
			$<u>$ = sub_instr;
		}
		
	|	locksubTkn
		{
			_here;
			$<u>$ = locksub_instr;
		}
	;
		

SingleStmt:
		genericTkns	/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<reg.Size>3 != $<reg.Size>5 )
			
				yyerror( "Register operands must be the same size" );
				$<reg.Size>3 = $<reg.Size>5;
				
			_endif
			EmitGeneric_r_r( $<u>1, $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
		}
	;		
		

SingleStmt:
		genericTkns		/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		comma			/* $4 */
		fEitherMemDest	/* $5 */
		Rparen			/* $6 */
		{
			_here;
			_if( $<reg.Size>3 != $<adrs.Size>5 && $<adrs.Size>5 != 0 )
			
				yyerror( "Operands must be the same size" );
				$<reg.Size>3 = $<adrs.Size>5;
				
			_endif
			$<adrs.forcedSize>3 = 0;
			EmitGeneric_r_m( $<u>1, $<reg.encoding>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;
		}
	;		
		

SingleStmt:
		genericTkns			/* $1 */
		Lparen				/* $2 */
		fEitherMem			/* $3 */
		comma				/* $4 */
		fRegister			/* $5 */
		Rparen				/* $6 */
		{
			_here;
			_if( $<adrs.Size>3 == 0 )
			
				$<adrs.Size>3 = $<reg.Size>5;
				$<adrs.forcedSize>3 = 0;
				
			_endif
			_if( $<reg.Size>5 != $<adrs.Size>3 )
			
				yyerror( "Operands must be the same size" );
				$<reg.Size>5 = $<adrs.Size>3;
				
			_endif
			EmitGeneric_m_r( $<u>1, &$<adrs>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;		
		

SingleStmt:
		genericTkns	/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<v.pType>3 != tPointer || $<reg.Size>5 != 4 )
			 
				_if( !IsOrdinal( $<v.pType>3 ))
				
					yyerror( "Expected an ordinal type for constant operand" );
					
				_elseif( $<reg.Size>5 == 1 && numBits32( YYS &$<v>3 ) > 8 )
				
					yyerror( "Expected an 8-bit ordinal type in constant expression" );
				
				_elseif( $<reg.Size>5 == 2 && numBits32( YYS &$<v>3 ) > 16 )
				
					yyerror( "Expected a 16-bit ordinal type in constant expression" );
					
				_elseif( $<reg.Size>5 == 4 )
				
					_if( $<v.pType>3 != tPointer && numBits32( YYS &$<v>3 ) > 32 )
				
						yyerror
						( 
							"Expected a 32-bit ordinal type in constant expression" 
						);
						
					_endif
					
				_endif
				
			_endif
			EmitGeneric_i_r( $<u>1, YYS &$<v>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;		
		

SingleStmt:
		genericTkns	/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fMemory		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<v.pType>3 != tPointer || $<adrs.Size>5 != 4 )
			 
				_if( !IsOrdinal( $<v.pType>3 ))
				
					yyerror( "Expected an ordinal type for constant operand" );
					
				_elseif( $<adrs.Size>5 == 1 && numBits32( YYS &$<v>3 ) > 8 )
				
					yyerror( "Expected an 8-bit ordinal type in constant expression" );
				
				_elseif( $<adrs.Size>5 == 2 && numBits32( YYS &$<v>3 ) > 16 )
				
					yyerror( "Expected a 16-bit ordinal type in constant expression" );
					
				_elseif( $<adrs.Size>5 == 5 && numBits32( YYS &$<v>3 ) > 32 )
				
					yyerror( "Expected a 32-bit ordinal type in constant expression" );
					
				_endif
				
			_endif
			EmitGeneric_i_m( $<u>1, YYS &$<v>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;
			
SingleStmt:
		genericTkns	/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fAnonMem	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			yyerror( "Unspecified memory size" );
			$<returns>$ = NULL;
			FreeValue( YYS &$<v>3 );
			FreeAdrs( &$<adrs>5 );
			_here;
		}
	;		

// The CMP instruction has to be handled specially because the operands are
// reversed.



SingleStmt:
		cmpTkn		/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<reg.Size>3 != $<reg.Size>5 )
			
				yyerror( "Register operands must be the same size" );
				$<reg.Size>3 = $<reg.Size>5;
				
			_endif
			EmitGeneric_r_r( cmp_instr, $<reg.encoding>5, $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
		}
	;		
		

SingleStmt:
		cmpTkn		/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fEitherMem	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<reg.Size>3 != $<adrs.Size>5 && $<adrs.Size>5 != 0 )
			
				yyerror( "Operands must be the same size" );
				$<reg.Size>3 = $<adrs.Size>5;
				
			_endif
			EmitGeneric_m_r( cmp_instr, &$<adrs>5, $<reg.encoding>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;
		}
	;		
		

SingleStmt:
		cmpTkn				/* $1 */
		Lparen				/* $2 */
		fMemory				/* $3 */
		comma				/* $4 */
		fRegister			/* $5 */
		Rparen				/* $6 */
		{
			_here;
			_if( $<adrs.Size>3 == 0 )
			
				$<adrs.Size>3 = $<reg.Size>5;
				
			_endif
			_if( $<reg.Size>5 != $<adrs.Size>3 )
			
				yyerror( "Operands must be the same size" );
				$<reg.Size>5 = $<adrs.Size>3;
				
			_endif
			EmitGeneric_r_m( cmp_instr, $<reg.encoding>5, &$<adrs>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;		
		

SingleStmt:
		cmpTkn				/* $1 */
		Lparen				/* $2 */
		fAnonMem			/* $3 */
		comma				/* $4 */
		fRegister			/* $5 */
		Rparen				/* $6 */
		{
			_here;
			$<adrs.Size>3 = $<reg.Size>5;
			EmitGeneric_r_m( cmp_instr, $<reg.encoding>5, &$<adrs>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;		
		

SingleStmt:
		cmpTkn		/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fConstExpr	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<v.pType>5 != tPointer || $<reg.Size>3 != 4 )
			 
				_if( !IsOrdinal( $<v.pType>5 ))
				
					yyerror( "Expected an ordinal type for constant operand" );
					
				_elseif( $<reg.Size>3 == 1 && numBits32( YYS &$<v>5 ) > 8 )
				
					yyerror( "Expected an 8-bit ordinal type in constant expression" );
				
				_elseif( $<reg.Size>3 == 2 && numBits32( YYS &$<v>5 ) > 16 )
				
					yyerror( "Expected a 16-bit ordinal type in constant expression" );
					
				_elseif( $<reg.Size>3 == 4 )
				
					_if( $<v.pType>5 != tPointer && numBits32( YYS &$<v>5 ) > 32 )
				
						yyerror
						( 
							"Expected a 32-bit ordinal type in constant expression" 
						);
						
					_endif
					
				_endif
				
			_endif
			EmitGeneric_i_r( cmp_instr, YYS &$<v>5, $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ] );
			FreeValue( YYS &$<v>5 );
			_here;
		}
	;		
		

SingleStmt:
		cmpTkn		/* $1 */
		Lparen		/* $2 */
		fMemory		/* $3 */
		comma		/* $4 */
		fConstExpr	/* $5 */
		Rparen		/* $6 */
		{

			_here;
			_if( $<v.pType>5 != tPointer || $<adrs.Size>3 != 4 )
			 
				_if( !IsOrdinal( $<v.pType>5 ))
				
					yyerror( "Expected an ordinal type for constant operand" );
					
				_elseif( $<adrs.Size>3 == 1 && numBits32( YYS &$<v>5 ) > 8 )
				
					yyerror( "Expected an 8-bit ordinal type in constant expression" );
				
				_elseif( $<adrs.Size>3 == 2 && numBits32( YYS &$<v>5 ) > 16 )
				
					yyerror( "Expected a 16-bit ordinal type in constant expression" );
					
				_elseif( $<adrs.Size>3 == 5 && numBits32( YYS &$<v>5 ) > 32 )
				
					yyerror( "Expected a 32-bit ordinal type in constant expression" );
					
				_endif
				
			_endif
			EmitGeneric_i_m( cmp_instr, YYS &$<v>5, &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			FreeValue( YYS &$<v>5 );
			_here;
		}
	;
			
SingleStmt:
		cmpTkn		/* $1 */
		Lparen		/* $2 */
		fAnonMem	/* $3 */
		comma		/* $4 */
		fConstExpr	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			yyerror( "Unspecified memory size" );
			$<returns>$ = NULL;
			FreeValue( YYS &$<v>5 );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;		


 /*
 ** Single general operand instructions
 **
 **	Syntax:
 **
 **		dec( Reg8 );
 **		dec( Reg16 );
 **		dec( Reg32 );
 **		dec( mem );
 **
 **	Ditto for inc, neg, and not.
 */


unaryTkns:
		decTkn
		{
			_here;
			$<u>$ = dec_instr;
		}
		
	|	incTkn
		{
			_here;
			$<u>$ = inc_instr;
		}
		
	|	negTkn
		{
			_here;
			$<u>$ = neg_instr;
		}
		
	|	notTkn
		{
			_here;
			$<u>$ = not_instr;
		}
		
	|	lockdecTkn
		{
			_here;
			$<u>$ = lockdec_instr;
		}
		
	|	lockincTkn
		{
			_here;
			$<u>$ = lockinc_instr;
		}
		
	|	locknegTkn
		{
			_here;
			$<u>$ = lockneg_instr;
		}
		
	|	locknotTkn
		{
			_here;
			$<u>$ = locknot_instr;
		}
	;
		

SingleStmt:
		unaryTkns	/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		Rparen		/* $4 */
		{
			_here;
			EmitUnary_r( $<u>1, $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ] );
			_here;
		}
	;


SingleStmt:
		unaryTkns		/* $1 */
		Lparen			/* $2 */
		fMemoryDest		/* $3 */
		Rparen			/* $4 */
		{
			_here;
			EmitUnary_m( $<u>1, &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>3 );
			_here;
		}
	;

SingleStmt:
		unaryTkns
		Lparen
		fAnonMem
		Rparen
		{
			yyerror( "Unspecified destination operand size" );
			$<returns>$ = NULL;
			FreeAdrs( &$<adrs>2 );
			_here;
		}
	;





// Handle mul, imul, div, and idiv here:




 /*
 ** Handle the (unsigned) division instruction here.
 **
 **	Syntax:
 **
 **	div( reg8 )
 ** div( reg16)
 ** div( reg32 )
 ** div( mem )
 **
 **	div( reg8, ax )
 ** div( reg16, dx:ax)
 ** div( reg32, edx:eax )
 **
 **	div( mem, ax )
 ** div( mem, dx:ax)
 ** div( mem, edx:eax )
 **
 ** div( const, ax )
 ** div( const, dx:ax )
 ** div( const, edx:eax )
 **
 ** div( AnonMem, ax )
 ** div( AnonMem, dx:ax )
 ** div( AnonMem, edx:eax )
 */


OptCommaDA:
		','
		axTkn
		{
			_here;
			$<u>$ = 2;
		}

	|	','
		dxaxTkn
		{
			_here;
			$<u>$ = 4;
		}

	|	','
		edxeaxTkn
		{
			_here;
			$<u>$ = 8;
		}
		
	|	','
		fstmt
		axTkn
		{
			_here;
			$<u>$ = 2;
		}

	|	','
		fstmt
		dxaxTkn
		{
			_here;
			$<u>$ = 4;
		}

	|	','
		fstmt
		edxeaxTkn
		{
			_here;
			$<u>$ = 8;
		}
	;
	
divmodTkns:
		divTkn
		{
			_here;
			$<u>$ = div_instr;
		}	

	|	modTkn
		{
			_here;
			$<u>$ = mod_instr;
		}	

	|	idivTkn
		{
			_here;
			$<u>$ = idiv_instr;
		}	

	|	imodTkn
		{
			_here;
			$<u>$ = imod_instr;
		}
	;	




SingleStmt:
		divmodTkns	/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		Rparen		/* $4 */
		{
			_here;
			EmitUnary_r( $<u>1, $<reg.encoding>3 );
			$<returns>$ = 
				_ifx
				(
					$<u>1 == div_instr || $<u>1 == idiv_instr,
					hlastrdup2( divRETURNS[ $<reg.Size>3 ] ),
					hlastrdup2( modRETURNS[ $<reg.Size>3 ] )
				);
			_here;
		}
	;


		
SingleStmt:
		divmodTkns		/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		OptCommaDA		/* $4 */
		Rparen			/* $5 */
		{
			_here;
			_if( $<u>4 / 2 != $<reg.Size>3 )

				yyerror( "Illegal source register size" );

			_endif
			EmitUnary_r( $<u>1, $<reg.encoding>3 );
			$<returns>$ = 
				_ifx
				(
					$<u>1 == div_instr || $<u>1 == idiv_instr,
					hlastrdup2( divRETURNS[ $<reg.Size>3 ] ),
					hlastrdup2( modRETURNS[ $<reg.Size>3 ] )
				);
		}


	;



SingleStmt:
		divmodTkns		/* $1 */
		Lparen			/* $2 */
		fEitherMem		/* $3 */
		Rparen			/* $4 */
		{			
			_here;
			_if( $<adrs.Size>3 == 0 )
				
				yyerror( "Must specify operand size" );
				$<adrs.Size>3 = 4;
				$<adrs.forcedSize>3 = 4;
				
			_endif
			EmitUnary_m( $<u>1, &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = 
				_ifx
				(
					$<u>1 == div_instr || $<u>1 == idiv_instr,
					hlastrdup2( divRETURNS[ $<reg.Size>3 ] ),
					hlastrdup2( modRETURNS[ $<reg.Size>3 ] )
				);
			_here;
		}
	;

SingleStmt:
		divmodTkns		/* $1 */
		Lparen			/* $2 */
		fEitherMem		/* $3 */
		OptCommaDA		/* $4 */
		Rparen			/* $5 */
		{
			_here;
			_if( $<adrs.Size>3 == 0 )
			
				$<adrs.Size>3 = $<u>4 / 2;
				$<adrs.forcedSize>3 = $<adrs.Size>3;
				
			_endif
			_if( $<u>4 / 2 != $<adrs.Size>3 )

				yyerror( SizeMismatchStr );

			_endif
			EmitUnary_m( $<u>1, &$<adrs>3 );
			$<returns>$ = 
				_ifx
				(
					$<u>1 == div_instr || $<u>1 == idiv_instr,
					hlastrdup2( divRETURNS[ $<reg.Size>3 ] ),
					hlastrdup2( modRETURNS[ $<reg.Size>3 ] )
				);
			_here;
		}
	;




SingleStmt:
		divmodTkns	/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		OptCommaDA	/* $4 */
		Rparen		/* $5 */
		{
			char			*divisor;
			enum PrimType	instrSize;
			int				size;
			struct	adrsYYS adrs;
			char			label[64];

			_here;
			size = $<u>4 * 4;
			_if( $<u>1 == idiv_instr || $<u>1 == imod_instr )

				divisor = CheckOrdinal( YYS &$<v>3, size );

			_else

				divisor = CheckUnsigned( YYS &$<v>3, size );

			_endif
			sprintf( label, "divisor" sympost "%d", LblCntr++ );
			startStrSeg();
			instrSize =
				_ifx
				(
					size == 8,
					tByte,
					_ifx( size == 16, tWord, tDWord )
				);
			
			EmitData
			( 
				label,
				instrSize, 
				divisor 
			);
			endStrSeg();
			initLbl( &adrs, label, 0 );
			adrs.Size = $<u>4 / 2;
			_if( $<u>4 == 2 )	// $<u>4 is register pair size
			
				adrs.pType = tByte;
				adrs.Type = &byte_ste;
				
			_elseif( $<u>4 == 4 )
			
				adrs.pType = tWord;
				adrs.Type = &word_ste;
				
			_else
			
				adrs.pType = tDWord;
				adrs.Type = &dword_ste;
				
			_endif
			EmitUnary_m( $<u>1, &adrs );
			free2( vss divisor );
			FreeValue( YYS &$<v>3 );
			$<returns>$ = 
				_ifx
				(
					$<u>1 == div_instr || $<u>1 == idiv_instr,
					hlastrdup2( divRETURNS[ $<u>4 ] ),
					hlastrdup2( modRETURNS[ $<u>4 ] )
				);
			_here;
		}
	;



SingleStmt:
		divmodTkns	/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		Rparen		/* $4 */
		{
			yyerror
			( 
				"DIV/IDIV/MOD/IMOD requires a second register operand "
				"with a constant operand"
			);
			FreeValue( YYS &$<v>3 );
			$<returns>$ = hlastrdup2( "eax" );
		}
	;




 /*
 ** Handle the (unsigned) multiplication instruction here.
 **
 **	Syntax:
 **
 **	mul( reg8 )
 ** mul( reg16)
 ** mul( reg32 )
 ** mul( mem )
 **
 ** mul( reg8, al )
 ** mul( reg16, ax )
 ** mul( reg32, eax )
 **
 ** mul( mem, al )
 ** mul( mem, ax )
 ** mul( mem, eax )
 **
 ** mul( const, al )
 ** mul( const, ax )
 ** mul( const, eax )
 **
 ** mul( AnonMem, ax )
 ** mul( AnonMem, dx:ax )
 ** mul( AnonMem, edx:eax )
 */

Mul2ndOperand:
		','
		alTkn
		{
			_here;
			$<u>$ = 1;
		}

	|	','
		axTkn
		{
			_here;
			$<u>$ = 2;
		}

	|	','
		eaxTkn
		{
			_here;
			$<u>$ = 4;
		}
		
	|	','
		fstmt
		alTkn
		{
			_here;
			$<u>$ = 1;
		}

	|	','
		fstmt
		axTkn
		{
			_here;
			$<u>$ = 2;
		}

	|	','
		fstmt
		eaxTkn
		{
			_here;
			$<u>$ = 4;
		}
	;


mulTkns:
		mulTkn
		{
			_here;
			$<u>$ = mul_instr;
		}

	|	imulTkn
		{
			_here;
			$<u>$ = imul_instr;
		}
	;



SingleStmt:
		mulTkns		/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		Rparen		/* $4 */
		{
			_here;
			EmitUnary_r( $<u>1,  $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( mulRETURNS[ $<reg.Size>3 ] );
			_here;
		}
	;





SingleStmt:
		mulTkns			/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		Mul2ndOperand	/* $4 */
		Rparen			/* $5 */
		{
			_here;
			_if( $<reg.Size>3 != $<u>4 )

				yyerror( "Illegal mul operand sizes" );

			_endif
			EmitUnary_r( $<u>1,  $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( mulRETURNS[ $<u>4 ] );
			_here;
		}
	;




SingleStmt:
		mulTkns		/* $1 */
		Lparen		/* $2 */
		fEitherMem	/* $3 */
		Rparen		/* $4 */
		{			/* $5 */
			_here;
			_if( $<adrs.Size>3 == 0 )
				
				yyerror( "Must specify operand size" );
				$<adrs.Size>3 = 4;
				$<adrs.forcedSize>3 = 4;
				
			_endif
			EmitUnary_m( $<u>1, &$<adrs>3 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( mulRETURNS[ $<reg.Size>3 ] );
			_here;
		}
	;




SingleStmt:
		mulTkns			/* $1 */
		Lparen			/* $2 */
		fEitherMem		/* $3 */
		Mul2ndOperand	/* $4 */
		Rparen			/* $5 */
		{
			_here;
			_if( $<adrs.Size>3 == 0 )
			
				$<adrs.Size>3 = $<u>4;
				$<adrs.forcedSize>3 = $<u>4;
				
			_endif
			_if( $<adrs.Size>3 != $<u>4 )

				yyerror( SizeMismatchStr );
				$<returns>$ = hlastrdup2( "ax" );

			_else

				EmitUnary_m( $<u>1, &$<adrs>3 );

			_endif
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( mulRETURNS[ $<reg.Size>3 ] );
			_here;
		}
	;







SingleStmt:
		mulTkns			/* $1 */
		Lparen			/* $2 */
		fConstExpr		/* $3 */
		Mul2ndOperand	/* $4 */
		Rparen			/* $5 */
		{
			char			*mplier;
			enum PrimType	instrSize;
			int				size;
			struct	adrsYYS adrs;
			char			label[64];

			_here;
			size = $<u>4 * 8;
			_if( $<u>1 == imul_instr )

				mplier = CheckOrdinal( YYS &$<v>3, size );

			_else

				mplier = CheckUnsigned( YYS &$<v>3, size );

			_endif
			sprintf( label, "mplier" sympost "%d", LblCntr++ );
			startStrSeg();
			
			instrSize =
				_ifx
				(
					size == 8,
					tByte,
					_ifx( size == 16, tWord, tDWord )
				);
			
			EmitData
			( 
				label,
				instrSize, 
				mplier 
			);
			endStrSeg();
			initLbl( &adrs, label, 0 );
			adrs.Size = $<u>4;
			EmitUnary_m( $<u>1, &adrs );
			free2( vss mplier );
			FreeValue( YYS &$<v>3 );
			$<returns>$ = hlastrdup2( mulRETURNS[ $<u>4 ] );
			_here;
		}
	;







 /*
 ** Handle some common MUL instruction errors here.
 */

SingleStmt:
		mulTkns
		Lparen
		fConstExpr
		Rparen
		{
			yyerror
			( 
				"MUL requires a second register operand "
				"with a constant operand"
			);
			FreeValue( YYS &$<v>3 );
			$<returns>$ = hlastrdup2( "eax" );
		}
	;





 /*
 ** The Bound instruction.
 **
 **	Syntax:
 **
 **	bound( Reg16, mem )
 ** bound( Reg16, constL, constH ) -- extended syntax
 ** bound( Reg16, AnonMem )
 **
 **	bound( Reg32, mem )
 ** bound( Reg32, ConstL, ConstH ) -- extended syntax
 ** bound( Reg32, AnonMem )
 */

SingleStmt:
		boundTkn
		Lparen
		fRegister
		comma
		fMemoryDest
		Rparen
		{
			_here;
			_if( $<reg.Size>3 == 1 )

				yyerror( "Eight bit registers are not allowed here" );

			_endif
			_if( CompileBound )
			
				EmitBound_r_m
				( 
					$<reg.encoding>3, 
					&$<adrs>5, 
					$<reg.Size>3 
				);
				
			_endif
			
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ] );
			_here;
		}
	;




SingleStmt:
		boundTkn
		Lparen
		fRegister
		comma
		fConstExpr
		','
		fConstExpr
		Rparen
		{
			unsigned LBound;
			unsigned UBound;

			_here;
			_if( $<reg.Size>3 == 1 )

				yyerror( "Eight bit registers are not allowed here" );

			_endif
			LBound = CheckUnsignedSize( YYS &$<v>5, $<reg.Size>3 * 8 );
			UBound = CheckUnsignedSize( YYS &$<v>7, $<reg.Size>3 * 8 );
			_if( CompileBound )
			
				EmitBound_r_c_c
				( 
					$<reg.encoding>3, 
					LBound,
					UBound,
					$<reg.Size>3 
				);

			_endif
			FreeValue( YYS &$<v>5 );
			FreeValue( YYS &$<v>7 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
			_here;
		}
	;



SingleStmt:
		boundTkn
		Lparen
		fRegister
		comma
		fAnonMem
		Rparen
		{
			_here;
			_if( $<reg.Size>3 == 1 )

				yyerror( "Eight bit registers are not allowed here" );

			_endif
			_if( CompileBound )

				EmitBound_r_m( $<reg.encoding>3, &$<adrs>5, $<reg.Size>3 );

			_endif
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
			FreeAdrs( &$<adrs>5 );
			_here;
		}
	;





// Handle ARPL here:

SingleStmt:
		arplTkn		/* $1 */
		Lparen		/* $2 */
		fReg16		/* $3 */
		comma		/* $4 */
		fReg16 		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitArpl_r_r( $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
		}
	;
		
SingleStmt:
		arplTkn		/* $1 */
		Lparen		/* $2 */
		fReg16		/* $3 */
		comma		/* $4 */
		fMemoryDest	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<adrs.Size>5 != 2 )
			
				yyerror( "ARPL operands must be word operands" );
				
			_endif
			EmitArpl_r_m( $<reg.encoding>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 ); 
			_here;
		}
	;
		
SingleStmt:
		arplTkn		/* $1 */
		Lparen		/* $2 */
		fReg16		/* $3 */
		comma		/* $4 */
		fAnonMem	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			$<adrs.Size>5 = 2;
			EmitArpl_r_m( $<reg.encoding>3, &$<adrs>5 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 ); 
			_here;
		}
	;
		
SingleStmt:
		arplTkn
		Lparen
		error
		Rparen
		{
			yyerror
			( 
				"Syntax error in arpl instr. Should be 'arpl(r16,r16)' "
				"or 'arpl(r16, m16)'"
			);
			$<returns>$ = NULL;
		}
	;
		

	

		

	
	
/*
** Conditional jump instructions.
**
** Syntax:
**
**	ja label;
**
**	Ditto for 
**
**	jae, jb, jbe, jc, je, jg, jge
**	jl, jle, jo, jp, jpe, jpo, js, jz,
**
**	jna, jnae, jnb, jnbe, jnc, jne, jng, jnge, jnl, jnle, jno,
**	jnp, jns, jnz,
**
**	jcxz, jecxz, loop, loope, loopz, loopne, and loopnz.
**
*/

jccTkns:
		jaTkn
		{
			_here;
			$<u>$ = ja_instr;
		}
	  	
	|	jaeTkn 	
		{
			_here;
			$<u>$ = jae_instr;
		}
	  	
	|	jbTkn  	
		{
			_here;
			$<u>$ = jb_instr;
		}
	  	
	|	jbeTkn 	
		{
			_here;
			$<u>$ = jbe_instr;
		}
	  	
	|	jcTkn  	
		{
			_here;
			$<u>$ = jc_instr;
		}
	  	
	|	jeTkn  	
		{
			_here;
			$<u>$ = je_instr;
		}
	  	
	|	jgTkn  	
		{
			_here;
			$<u>$ = jg_instr;
		}
	  	
	|	jgeTkn 	
		{
			_here;
			$<u>$ = jge_instr;
		}
	  	
	|	jlTkn  	
		{
			_here;
			$<u>$ = jl_instr;
		}
	  	
	|	jleTkn 	
		{
			_here;
			$<u>$ = jle_instr;
		}
	  	
	|	jnaTkn 	
		{
			_here;
			$<u>$ = jna_instr;
		}
	  	
	|	jnaeTkn	
		{
			_here;
			$<u>$ = jnae_instr;
		}
	  	
	|	jnbTkn 	
		{
			_here;
			$<u>$ = jnb_instr;
		}
	  	
	|	jnbeTkn	
		{
			_here;
			$<u>$ = jnbe_instr;
		}
	  	
	|	jncTkn 	
		{
			_here;
			$<u>$ = jnc_instr;
		}
	  	
	|	jneTkn 	
		{
			_here;
			$<u>$ = jne_instr;
		}
	  	
	|	jngTkn 	
		{
			_here;
			$<u>$ = jng_instr;
		}
	  	
	|	jngeTkn	
		{
			_here;
			$<u>$ = jnge_instr;
		}
	  	
	|	jnlTkn 	
		{
			_here;
			$<u>$ = jnl_instr;
		}
	  	
	|	jnleTkn	
		{
			_here;
			$<u>$ = jnle_instr;
		}
	  	
	|	jnoTkn 	
		{
			_here;
			$<u>$ = jno_instr;
		}
	  	
	|	jnpTkn 	
		{
			_here;
			$<u>$ = jnp_instr;
		}
	  	
	|	jnsTkn 	
		{
			_here;
			$<u>$ = jns_instr;
		}
	  	
	|	jnzTkn 	
		{
			_here;
			$<u>$ = jnz_instr;
		}
	  	
	|	joTkn 	
		{
			_here;
			$<u>$ = jo_instr;
		}
	  	
	|	jpTkn  	
		{
			_here;
			$<u>$ = jp_instr;
		}
	  	
	|	jpeTkn 	
		{
			_here;
			$<u>$ = jpe_instr;
		}
	  	
	|	jpoTkn 	
		{
			_here;
			$<u>$ = jpo_instr;
		}
	  	
	|	jsTkn  	
		{
			_here;
			$<u>$ = js_instr;
		}
	  	
	|	jzTkn  	
		{
			_here;
			$<u>$ = jz_instr;
		}
	  	
	|	jcxzTkn  	
		{
			_here;
			$<u>$ = jcxz_instr;
		}
	  	
	|	jecxzTkn  	
		{
			_here;
			$<u>$ = jecxz_instr;
		}
	  	
	|	loopTkn  	
		{
			_here;
			$<u>$ = loop_instr;
		}
	  	
	|	loopeTkn  	
		{
			_here;
			$<u>$ = loope_instr;
		}
	  	
	|	loopneTkn  	
		{
			_here;
			$<u>$ = loopne_instr;
		}
	  	
	|	loopzTkn  	
		{
			_here;
			$<u>$ = loopz_instr;
		}
	  	
	|	loopnzTkn  	
		{
			_here;
			$<u>$ = loopnz_instr;
		}
	;	
	
	
	
	
SingleStmt:
		jccTkns
		AnyID
		{
			_here;
			processCondJump( $<u>1, $<neID.idStr>2, TrueLabel, FalseLabel );
			$<returns>$ = NULL;
			_here;
			
		}
	;

SingleStmt:
		jccTkns	/* $1 */
		Lparen	/* $2 */
		AnyID	/* $3 */
		Rparen	/* $4 */
		{
			_here;
			processCondJump( $<u>1, $<neID.idStr>3, TrueLabel, FalseLabel );
			$<returns>$ = NULL;
			_here;
		}
	;
	
SingleStmt:
		jccTkns
		hereTkn
		';'
		{
			char label[64];
			
			_here;
			sprintf( label, "here" sympost "%d", LblCntr++ );
			EmitStmtLbl( label );
			EmitCondJump( $<u>1, label );
			PushBackStr( ";" );
			$<returns>$ = NULL;
			_here;
		}
	;
		
		
SingleStmt:
		jccTkns			/* $1 */
		hereTkn			/* $2 */
		'['				/* $3 */
		fConstOnlyExpr	/* $4 */
		Rbrack			/* $5 */
		{
			int  disp;
			char label[64];
			
			_here;
			disp = CheckOrdinalSize( YYS &$<v>4, 32 );
			sprintf( label, "here" sympost "%d", LblCntr );
			EmitStmtLbl( label );
			sprintf
			( 
				label, 
				"(here" sympost "%d%s%d)" , 
				LblCntr++, 
				_ifx( disp < 0, "", "+"),
				disp 
			);
			EmitCondJump( $<u>1, label );
			$<returns>$ = NULL;
			_here;
		}
	;
		


// Handle the TEST instruction:

SingleStmt:
		testTkn		/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<reg.Size>3 != $<reg.Size>5 )
			
				yyerror( SizeMismatchStr );
				
			_endif
			EmitTest_r_r( $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( "@nz" );
			_here;
		}
	;

SingleStmt:
		testTkn			/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		comma			/* $4 */
		fEitherMemDest	/* $5 */
		Rparen			/* $6 */
		{
			_here;
			_if( $<adrs.Size>5 == 0 )
			
				$<adrs.Size>5 = $<reg.Size>3;
				
			_endif
			_if( $<reg.Size>3 != $<adrs.Size>5 )
			
				yyerror( SizeMismatchStr );
				
			_endif
			EmitTest_r_m( $<reg.encoding>3, &$<adrs>5 );
			FreeAdrs( &$<adrs>5 );
			$<returns>$ = hlastrdup2( "@nz" );
			_here;
		}
	;


SingleStmt:
		testTkn			/* $1 */
		Lparen			/* $2 */
		fEitherMem		/* $3 */
		comma			/* $4 */
		fRegister		/* $5 */
		Rparen			/* $6 */
		{
			_here;
			_if( $<adrs.Size>3 == 0 )
			
				$<adrs.Size>3 = $<reg.Size>5;
				
			_endif
			_if( $<reg.Size>5 != $<adrs.Size>3 )
			
				yyerror( SizeMismatchStr );
				
			_endif
			EmitTest_m_r( &$<adrs>3, $<reg.encoding>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( "@nz" );
			_here;
		}
	;

SingleStmt:
		testTkn		/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( !IsOrdinal( $<v.pType>3 ) )

				yyerror( "Expected an ordinal type in constant expression" );
			
			_endif
			_if( $<reg.Size>5 == 1 && numBits32( YYS &$<v>3 ) > 8 )
			
				yyerror( "Expected an 8-bit constant" );
				
			_elseif( $<reg.Size>5 == 2 && numBits32( YYS &$<v>3 ) > 16 )
			
				yyerror( "Expected a 16-bit constant" );
				
			_elseif( numBits32( YYS &$<v>3 ) > 32 )
			
				yyerror( "Expected a 32-bit constant" );
			
			_endif
			EmitTest_c_r( YYS &$<v>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( "@nz" );
			_here;
		}
	;

SingleStmt:
		testTkn		/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fMemoryDest	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( !IsOrdinal( $<v.pType>3 ) )

				yyerror( "Expected an ordinal type in constant expression" );
			
			_endif
			_if( $<adrs.Size>5 == 1 && numBits32( YYS &$<v>3 ) > 8 )
			
				yyerror( "Expected an 8-bit constant" );
				
			_elseif( $<adrs.Size>5 == 2 && numBits32( YYS &$<v>3 ) > 16 )
			
				yyerror( "Expected a 16-bit constant" );
				
			_elseif( numBits32( YYS &$<v>3 ) > 32 )
			
				yyerror( "Expected a 32-bit constant" );
			
			_endif
			EmitTest_c_m( YYS &$<v>3, &$<adrs>5 );
			FreeAdrs( &$<adrs>5 );
			$<returns>$ = hlastrdup2( "@nz" );
			_here;
		}
	;






// Handle the XCHG instruction here:

xchgTkns:
		xchgTkn
		{
			_here;
			$<u>$ = 0;
		}
		
	|	lockxchgTkn
		{
			_here;
			$<u>$ = 1;
		}
	;

SingleStmt:
		xchgTkns	/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<reg.Size>3 != $<reg.Size>5 )
			
				yyerror( SizeMismatchStr );
				
			_else
			
				EmitXchg_r_r( $<u>1, $<reg.encoding>3, $<reg.encoding>5 );
				
			_endif
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
		}
	;

SingleStmt:
		xchgTkns	/* $1 */
		Lparen		/* $2 */
		fEitherMem	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<adrs.Size>3 != $<reg.Size>5 && $<adrs.Size>3 != 0 )
			
				yyerror( SizeMismatchStr );
				
			_else
			
				EmitXchg_r_m( $<u>1, $<reg.encoding>5, &$<adrs>3 );
				
			_endif
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;
		}
	;

SingleStmt:
		xchgTkns	/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fEitherMem	/* $5 */
		Rparen		/* $6 */
		{
			_here;
			_if( $<adrs.Size>5 != $<reg.Size>3 && $<adrs.Size>5 != 0 )
			
				yyerror( SizeMismatchStr );
				
			_else
			
				EmitXchg_r_m( $<u>1, $<reg.encoding>3, &$<adrs>5 );
				
			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;
		}
	;

		
				
 /*
 ** Handle the string instructions here.
 **
 ** Syntax:
 **
 **		lodsb
 **		lodsw
 **		lodsd
 **
 ***************************
 **
 **		cmpsb
 **		cmpsw
 **		cmpsd
 **
 **		repe.cmpsb
 **		repe.cmpsw				 
 **		repe.cmpsd
 **
 **		repne.cmpsb
 **		repne.cmpsw
 **		repne.cmpsd
 **
 **	Ditto (as above) for scasX
 **
 ***************************
 **
 **		insb
 **		insw
 **		insd
 **
 **		rep.insb
 **		rep.insw
 **		rep.insd
 **
 **	Ditto (from insX) for:
 **
 **		movsX
 **		outsX
 **		stosX
 **
 */
	
SingleStmt:
		StringInstrs
		EmptyParens
		{
			_here; 
			$<returns>$ = $<returns>1;
		}
	;
		
		
		
StringInstrs:
		lodsbTkn
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "al" );
			str_instr( lodsb_instr );
		}

	|	lodsdTkn
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "eax" );
			str_instr( lodsd_instr );
		}

	|	lodswTkn
		{ 
			_here; 
			$<returns>$ = hlastrdup2( "ax" );
			str_instr( lodsw_instr );
		}
	;


StringInstrs:
		strMnemonics
		{
			_here; 
			$<returns>$ = NULL;
			str_instr( $<u>1 );
		}

	;


// Special cases for cmpsd and movsd as they conflict
// with MMX/SSE instructions of the same name:

	
SingleStmt:
		cmpsdTkn	/* $1 */
		EmptyParens	/* $2 */
		{
			_here; 
			$<returns>$ = NULL;
			str_instr( cmpsd_instr );
			_here;
		}
	;

	
SingleStmt:
		movsdTkn	/* $1 */
		EmptyParens	/* $2 */
		{			
			_here; 
			$<returns>$ = NULL;
			str_instr( movsd_instr );
			_here;
		}
	;

strMnemonics:
		repecmpsbTkn { _here; $<u>$ = repe_cmpsb_instr; }
	|	repecmpswTkn { _here; $<u>$ = repe_cmpsw_instr; }
	|	repecmpsdTkn { _here; $<u>$ = repe_cmpsd_instr; }
	
	|	repzcmpsbTkn { _here; $<u>$ = repe_cmpsb_instr; }
	|	repzcmpswTkn { _here; $<u>$ = repe_cmpsw_instr; }
	|	repzcmpsdTkn { _here; $<u>$ = repe_cmpsd_instr; }
	
	|	repescasbTkn { _here; $<u>$ = repe_scasb_instr; }
	|	repescaswTkn { _here; $<u>$ = repe_scasw_instr; }
	|	repescasdTkn { _here; $<u>$ = repe_scasd_instr; }
	
	|	repzscasbTkn { _here; $<u>$ = repe_scasb_instr; }
	|	repzscaswTkn { _here; $<u>$ = repe_scasw_instr; }
	|	repzscasdTkn { _here; $<u>$ = repe_scasd_instr; }

	|	repnecmpsbTkn { _here; $<u>$ = repne_cmpsb_instr; }
	|	repnecmpswTkn { _here; $<u>$ = repne_cmpsw_instr; }
	|	repnecmpsdTkn { _here; $<u>$ = repne_cmpsd_instr; }
	
	|	repnzcmpsbTkn { _here; $<u>$ = repne_cmpsb_instr; }
	|	repnzcmpswTkn { _here; $<u>$ = repne_cmpsw_instr; }
	|	repnzcmpsdTkn { _here; $<u>$ = repne_cmpsd_instr; }
	
	|	repnescasbTkn { _here; $<u>$ = repne_scasb_instr; }
	|	repnescaswTkn { _here; $<u>$ = repne_scasw_instr; }
	|	repnescasdTkn { _here; $<u>$ = repne_scasd_instr; }
	
	|	repnzscasbTkn { _here; $<u>$ = repe_scasb_instr; }
	|	repnzscaswTkn { _here; $<u>$ = repe_scasw_instr; }
	|	repnzscasdTkn { _here; $<u>$ = repe_scasd_instr; }
	
	|	repmovsbTkn { _here; $<u>$ = rep_movsb_instr; }
	|	repmovswTkn { _here; $<u>$ = rep_movsw_instr; }
	|	repmovsdTkn	{ _here; $<u>$ = rep_movsd_instr; }
	
	|	repstosbTkn { _here; $<u>$ = rep_stosb_instr; }
	|	repstoswTkn { _here; $<u>$ = rep_stosw_instr; }
	|	repstosdTkn	{ _here; $<u>$ = rep_stosd_instr; }
	
	|	repinsbTkn { _here; $<u>$ = rep_insb_instr; }
	|	repinswTkn { _here; $<u>$ = rep_insw_instr; }
	|	repinsdTkn { _here; $<u>$ = rep_insd_instr; }
	
	|	repoutsbTkn { _here; $<u>$ = rep_outsb_instr; }
	|	repoutswTkn { _here; $<u>$ = rep_outsw_instr; }
	|	repoutsdTkn	{ _here; $<u>$ = rep_outsd_instr; }
	
	|	cmpsbTkn	{ _here; $<u>$ = cmpsb_instr; }
	|	cmpswTkn	{ _here; $<u>$ = cmpsw_instr; }

	|	scasbTkn	{ _here; $<u>$ = scasb_instr; }
	|	scaswTkn	{ _here; $<u>$ = scasw_instr; }		
	|	scasdTkn	{ _here; $<u>$ = scasd_instr; }

	|	movsbTkn	{ _here; $<u>$ = movsb_instr; }
	|	movswTkn	{ _here; $<u>$ = movsw_instr; }

	|	stosbTkn	{ _here; $<u>$ = stosb_instr; }
	|	stoswTkn	{ _here; $<u>$ = stosw_instr;; }
	|	stosdTkn	{ _here; $<u>$ = stosd_instr; }

	|	insbTkn 	{ _here; $<u>$ = insb_instr;	}
	|	inswTkn 	{ _here; $<u>$ = insw_instr;	}
	|	insdTkn		{ _here; $<u>$ = insd_instr;	}

	|	outsbTkn	{ _here; $<u>$ = outsb_instr; }
	|	outswTkn	{ _here; $<u>$ = outsw_instr; }
	|	outsdTkn	{ _here; $<u>$ = outsd_instr; }
	;





 /*
 ** Shift and rotate instructions.
 **
 ** Syntax:
 **
 **	shl( const, Reg8 )
 ** shl( const, Reg16 )
 ** shl( const, Reg32 )
 **
 ** shl( const, mem )
 **
 **	shl( cl, Reg8 )
 ** shl( cl, Reg16 )
 ** shl( cl, Reg32 )
 **
 ** shl( cl, mem )
 **
 **	Ditto for:
 **
 **	rcl, rcr, rol, ror, sal, sar, and shr.
 */

shiftAndRotateTkns:
		rolTkn
		{
			_here; 
			$<u>$ = rol_instr;
		}

	|	rorTkn
		{
			_here; 
			$<u>$ = ror_instr;
		}

	|	rclTkn
		{
			_here; 
			$<u>$ = rcl_instr;
		}

	|	rcrTkn
		{
			_here; 
			$<u>$ = rcr_instr;
		}

	|	shlTkn
		{
			_here; 
			$<u>$ = shl_instr;
		}

	|	salTkn
		{
			_here; 
			$<u>$ = sal_instr;
		}

	|	shrTkn
		{
			_here; 
			$<u>$ = shr_instr;
		}

	|	sarTkn
		{
			_here; 
			$<u>$ = sar_instr;
		}
	;


fcl:
		clTkn

	|	fstmt
		clTkn
	;
	
	

SingleStmt:
		shiftAndRotateTkns	/* $1 */
		Lparen				/* $2 */
		fConstExpr			/* $3 */
		comma				/* $4 */
		fRegister			/* $5 */
		Rparen				/* $6 */
		{
			unsigned Shift;

			_here; 
			Shift = CheckUnsignedSize( YYS &$<v>3, shiftSize[ $<reg.Size>5 ] );
			EmitShiftRotate_c_r
			( 
				$<u>1, 
				Shift,  
				$<reg.encoding>5,
				$<reg.Size>5 
			);
			FreeValue( YYS &$<v>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
			_here; 
		}
	;


SingleStmt:
		shiftAndRotateTkns	/* $1 */
		Lparen				/* $2 */
		fConstExpr			/* $3 */
		comma				/* $4 */
		fMemoryDest			/* $5 */
		Rparen				/* $6 */
		{
			unsigned Shift;

			_here; 
			Shift = CheckUnsignedSize( YYS &$<v>3, shiftSize[ $<adrs.Size>5 ] );
			EmitShiftRotate_c_m
			( 
				$<u>1, 
				Shift,  
				&$<adrs>5 
			);
			FreeValue( YYS &$<v>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here; 
		}
	;


SingleStmt:
		shiftAndRotateTkns	/* $1 */
		Lparen				/* $2 */
		fcl					/* $3 */
		comma				/* $4 */
		fRegister			/* $5 */
		Rparen				/* $6 */
		{
			_here; 
			EmitShiftRotate_cl_r
			( 
				$<u>1, 
				$<reg.encoding>5,
				$<reg.Size>5 
			);
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
			_here; 
		}
	;


SingleStmt:
		shiftAndRotateTkns	/* $1 */
		Lparen				/* $2 */
		fcl					/* $3 */
		comma				/* $4 */
		fMemoryDest			/* $5 */
		Rparen				/* $6 */
		{
			_here; 
			EmitShiftRotate_cl_m
			( 
				$<u>1, 
				&$<adrs>5 
			);
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here; 
		}
	;


	/*
	** Untyped memory operands are illegal.
	*/

SingleStmt:
		shiftAndRotateTkns	/* $1 */
		Lparen				/* $2 */
		fConstExpr			/* $3 */
		comma				/* $4 */
		fAnonMem			/* $5 */
		Rparen				/* $6 */
		{
			yyerror( "Unspecified memory size" );
			$<returns>$ = NULL;
			FreeAdrs( &$<adrs>5 );
			FreeValue( YYS &$<v>3 );
			_here;
		}
	;


SingleStmt:
 		shiftAndRotateTkns	/* $1 */
		Lparen				/* $2 */
		fcl					/* $3 */
		comma				/* $4 */
		fAnonMem			/* $5 */
		Rparen				/* $6 */
		{
			_here;
			yyerror( "Unspecified memory size" );
			$<returns>$ = NULL;
			FreeAdrs( &$<adrs>5 );
			_here;
		}
	;




 /*
 ** Handle the RET instruction here.
 */

SingleStmt:
		retTkn
		Lparen
		fConstExpr
		Rparen
		{
			_here; 
			_if( checkSmallUns( YYS &$<v>3 ))

				_if( $<v.u.unsval>3 != 0 )

					ret_instr( $<v.u.unsval>3 );

				_else

					ret_instr( -1 );

				_endif

			_else
			
				yyerror( "Expected 32-bit non-negative constant" );

			_endif
			FreeValue( YYS &$<v>3 );
			$<returns>$ = NULL;
			_here; 
		}


	|	retTkn
		EmptyParens
		{
			_here; 
			ret_instr( -1 );
			$<returns>$ = NULL;
		}
	;

				


ldsegTkns:	
		ldsTkn
		{
			$<u>$ = reg_dseg;
			_here;
		}
	
	|	lesTkn
		{
			$<u>$ = reg_eseg;
			_here;
		}
	
	|	lfsTkn
		{
			$<u>$ = reg_fseg;
			_here;
		}
	
	|	lgsTkn
		{
			$<u>$ = reg_gseg;
			_here;
		}
	
	|	lssTkn
		{
			$<u>$ = reg_sseg;
			_here;
		}
	;
	
SingleStmt:
		ldsegTkns		/* $1 */
		Lparen			/* $2 */
		fReg32			/* $3 */
		comma			/* $4 */
		fEitherMemDest	/* $5 */
		Rparen			/* $6 */
		{
			_here; 
			EmitLxS( $<u>1, $<reg.encoding>3, &$<adrs>5 );
			$<returns>$ = hlastrdup2( uToSeg[ $<u>1 ] );
			FreeAdrs( &$<adrs>5 );
			_here; 
		}
	;
	
	

///////////////////////////////////////
//
// Handle all the MOV instructions here	
//
// mov( gpreg, gpreg );

SingleStmt:
		movTkn		/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{			
			_here; 
			CompatGpReg( $<reg.encoding>3, $<reg.encoding>5 );
			EmitMov_r_r( $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here; 
		}
	;
	

// mov( const, gpreg );
	
SingleStmt:
		movTkn		/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here; 
			_if( $<v.pType>3 == tPointer )
			
				_if( $<reg.Size>5 == 4 )
				
					EmitMov_o_r( $<v.u.strval>3, 0, $<reg.encoding>5 );
					
				_else
				
					yyerror( "Pointer const requires a 32-bit register" );
					
				_endif
			
			_else
			
				CompatGpRegConst( YYS &$<v>3, $<reg.encoding>5 );
				EmitMov_c_r( $<v.u.unsval>3, $<reg.encoding>5 );
				
			_endif  
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here; 
		}
	;
	
// mov( const, edx:eax );
		
SingleStmt:
		movTkn		/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fedxeax		/* $5 */
		Rparen		/* $6 */
		{
			_here; 
			_if( IsOrdinal( $<v.pType>3 ) )
			
				_if( $<v.u.lwordval>3[2] != 0 || $<v.u.lwordval>3[3] != 0 )
				
					_if
					( 
							$<v.u.lwordval>3[2] != 0xffffffff 
						||	$<v.u.lwordval>3[3] != 0xffffffff
						||	$<v.u.lwordval>3[1] <  0x80000000
					)
					
						yyerror( "Constant value is out of range" );
						
					_endif

				_endif
				
			_else
			
				yyerror( "Expected an ordinal type as constant operand" );
				
			_endif
			EmitMov_c_r( $<v.u.lwordval>3[1], reg_edx ); 		
			EmitMov_c_r( $<v.u.lwordval>3[0], reg_eax );
			$<returns>$ = hlastrdup2( "edx:eax" ); 		
			_here; 
		}
	;
	
	
// mov( const, dx:ax );
		
SingleStmt:
		movTkn		/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fdxax		/* $5 */
		Rparen		/* $6 */
		{
			_here; 
			_if( IsOrdinal( $<v.pType>3 ) )
			
				_if
				( 
						$<v.u.lwordval>3[1] != 0 
					||	$<v.u.lwordval>3[2] != 0 
					||	$<v.u.lwordval>3[3] != 0 
				)
				
					_if
					( 
							$<v.u.lwordval>3[2] != 0xffffffff 
						||	$<v.u.lwordval>3[3] != 0xffffffff
						||	$<v.u.lwordval>3[1] != 0xffffffff
						||	$<v.u.lwordval>3[0] <  0x80000000
					)
					
						yyerror( "Constant value is out of range" );
						
					_endif

				_endif
				
			_else
			
				yyerror( "Expected an ordinal type as constant operand" );
				
			_endif
			EmitMov_c_r( ($<v.u.lwordval>3[0] >> 16) & 0xffff, reg_dx ); 		
			EmitMov_c_r( $<v.u.lwordval>3[0] & 0xffff, reg_ax );
			$<returns>$ = hlastrdup2( "dx:ax" ); 		
			_here; 
		}
	;
	

// mov( const, memory );
	
SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fConstExpr		/* $3 */
		comma			/* $4 */
		fMemoryDest		/* $5 */
		Rparen			/* $6 */
		{
			_here; 
			_if( $<adrs.Size>5 != 1 && $<adrs.Size>5 != 2 && $<adrs.Size>5 != 4 )
			
				yyerror( "Memory operand must by a byte, word, or dword" );
				
			_else
			
				_if( $<v.pType>3 == tPointer )
				
					_if( $<adrs.Size>5 == 4 )
					
						EmitMov_o_m( $<v.u.strval>3, 0, &$<adrs>5 );
						
					_else
					
						yyerror( "Pointer const requires a dword memory operand" );
						
					_endif
				
				_else
				
					CompatMemConst( YYS &$<v>3, &$<adrs>5 );
					EmitMov_c_m( $<v.u.unsval>3, &$<adrs>5 );
					
				_endif
				
			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;			
		}
	;
	
// mov( segReg, gpreg );

SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fSegReg			/* $3 */
		comma			/* $4 */
		fRegister		/* $5 */
		Rparen			/* $6 */
		{
			_here;			
			CompatGpReg( reg_ax, $<u>5 );	// Make sure GPreg is 16-bits
			EmitMov_sr_r( $<u>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			_here;			
		}
	;
	
	
// mov( gpreg, segReg );

SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		comma			/* $4 */
		fSegReg			/* $5 */
		Rparen			/* $6 */
		{
			_here;			
			CompatGpReg( reg_ax, $<reg.encoding>3 );	// Make sure GPreg is 16-bits
			_if( $<u>5 == reg_cseg )
			
				yyerror( "Destination register cannot be cseg" );
				
			_endif
			EmitMov_r_sr( $<reg.encoding>3, $<u>5 );
			$<returns>$ = hlastrdup2( uToSeg[ $<u>5 ] );
			_here;			
		}
	;

// mov( segReg, memory );

SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fSegReg			/* $3 */
		comma			/* $4 */
		fEitherMemDest	/* $5 */
		Rparen			/* $6 */
		{
			_here; 
			_if
			( 
					$<adrs.Size>5 != 2 
				&&	$<adrs.Size>5 != 0 
			)
			
				yyerror( "Memory operand must be a word" );
				
			_else
			
				EmitMov_sr_m( $<u>3, &$<adrs>5 );
				
			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;			
		}
	;
	

// mov( memory, segReg );

SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fEitherMem		/* $3 */
		comma			/* $4 */
		fSegReg			/* $5 */
		Rparen			/* $6 */
		{
			_here; 
			_if( $<u>5 == reg_cseg )
			
				yyerror( "Destination cannot be cseg" );
				
			_endif
			_if
			( 
					$<adrs.Size>3 != 2 
				&&	$<adrs.Size>3 != 0 
			)
			
				yyerror( "Memory operand must be a word" );
				
			_else
			
				EmitMov_m_sr( &$<adrs>3, $<u>5 );
				
			_endif
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( uToSeg[ $<u>5 ] );
			_here;			
		}
	;
	
	
// mov( ctrlReg, gpReg );

SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fCtrlRegister	/* $3 */
		comma			/* $4 */
		fRegister		/* $5 */
		Rparen			/* $6 */
		{
			_here;
			CompatGpReg( reg_eax, $<reg.encoding>5 );	// Make sure GPreg is 32 bits
			EmitMov_cr_r( $<u>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[$<reg.encoding>5] );
			_here;			
		}
	;	
	
	
// mov( gpReg, ctrlReg );

SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		comma			/* $4 */
		fCtrlRegister	/* $5 */
		Rparen			/* $6 */
		{
			_here;			
			CompatGpReg( reg_eax, $<reg.encoding>3 );	// Make sure GPreg is 32 bits
			EmitMov_r_cr( $<reg.encoding>3, $<u>5 );
			$<returns>$ = hlastrdup2( ctrlStrs[$<u>5] );			
			_here;			
		}
	;	
	
	
	
	
// mov( debReg, gpReg );

SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fDbgRegister	/* $3 */
		comma			/* $4 */
		fRegister		/* $5 */
		Rparen			/* $6 */
		{
			_here;
			CompatGpReg( reg_eax, $<reg.encoding>5 );	// Make sure GPreg is 32 bits
			EmitMov_dr_r( $<u>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[$<reg.encoding>5] );
			_here;			
		}
	;	
	
	
// mov( gpReg, debReg );

SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		comma			/* $4 */
		fDbgRegister	/* $5 */
		Rparen			/* $6 */
		{
			_here;			
			CompatGpReg( reg_eax, $<reg.encoding>3 );	// Make sure GPreg is 32 bits
			EmitMov_r_dr( $<reg.encoding>3, $<u>5 );
			$<returns>$ = hlastrdup2( ctrlStrs[$<u>5] );			
			_here;			
		}
	;
	
	
// mov( mem, mem );	
	
SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fEitherMem		/* $3 */
		comma			/* $4 */
		fEitherMemDest	/* $5 */
		Rparen			/* $6 */
		{
			// Memory sizes must agree
			// Operands must be 16 or 32 bits
			// Can't both have size 0.
			
			_here; 
			_if( $<adrs.Size>3 == 0 && $<adrs.Size>5 == 0 )
			
				yyerror( "Must specify at least one operand size" );
				
			_else
			
				_if( $<adrs.Size>3 == 0 )
				
					$<adrs.Size>3 = $<adrs.Size>5;
					
				_endif
				_if( $<adrs.Size>5 == 0 )
				
					$<adrs.Size>5 = $<adrs.Size>3;
					
				_endif
				_if( $<adrs.Size>3 != $<adrs.Size>5 )
				
					yyerror( "Operands must be the same size" );
					$<adrs.Size>3 = 4;
					$<adrs.Size>5 = 4;
					
				_endif
				_if( $<adrs.Size>3 != 2 && $<adrs.Size>3 != 4 )
				
					yyerror( "Memory operands must be word or dword" );
					$<adrs.Size>3 = 4;
					$<adrs.Size>5 = 4;
					
				_endif
				push_mem( &$<adrs>3, $<adrs.Size>3 );
				pop_mem( &$<adrs>5, $<adrs.Size>5 );
				
			_endif
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_if( langLevel <= medium_level )
			
				yyerror
				( 
					"Memory-to-memory moves are illegal except in \n"
					"high-level language mode."
				);
				
			_endif
			_here; 
			
		}
	;
			
	
			
			
// mov( reg, memory );
	
SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		comma			/* $4 */
		fEitherMemDest	/* $5 */
		Rparen			/* $6 */
		{
			int memSize;
			int regSize;
			
			_here; 
			regSize = $<reg.Size>3;
			memSize = _ifx( $<adrs.Size>5 == 0, regSize, $<adrs.Size>5 );
			_if( memSize != 1 && memSize != 2 && memSize != 4 )
			
				yyerror( "Memory operand must by a byte, word, or dword" );
				
				
			_elseif( regSize != memSize )
			
				yyerror( "Register and memory operands must be the same size!" );
				
			_else
			
				EmitMov_r_m( $<reg.encoding>3, &$<adrs>5, regSize );
					
			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;
		}
	;


			
			
// mov( edx:eax, memory );
	
SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fedxeax			/* $3 */
		comma			/* $4 */
		fEitherMemDest	/* $5 */
		Rparen			/* $6 */
		{
			_here; 
			_if( $<adrs.Size>5 != 8  )
			
				yyerror( "Memory operand must by a qword" );
				
				
			_else
			
				EmitMov_r_m( reg_eax, &$<adrs>5, 4 );
				$<adrs.Disp>5 += 4;
				EmitMov_r_m( reg_edx, &$<adrs>5, 4 );
				$<adrs.Disp>5 -= 4;
				
					
			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>5 );
			_here;
		}
	;


// mov( mem, reg );
	
SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fEitherMem		/* $3 */
		comma			/* $4 */
		fRegister		/* $5 */
		Rparen			/* $6 */
		{
		
			int memSize;
			int regSize;
			
			_here; 
			regSize = $<reg.Size>5;
			memSize = _ifx( $<adrs.Size>3 == 0, regSize, $<adrs.Size>3 );
			_if( memSize != 1 && memSize != 2 && memSize != 4 )
			
				yyerror( "Memory operand must by a byte, word, or dword" );
				
				
			_elseif( regSize != memSize )
			
				yyerror( "Register and memory operands must be the same size!" );
				
			_else
			
				EmitMov_m_r( &$<adrs>3, $<reg.encoding>5, regSize );
			
			_endif
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ] );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;


// mov( mem, reg );
	
SingleStmt:
		movTkn			/* $1 */
		Lparen			/* $2 */
		fEitherMem		/* $3 */
		comma			/* $4 */
		fedxeax			/* $5 */
		Rparen			/* $6 */
		{
			_here; 
		
			_if( $<adrs.Size>3 != 8 )
			
				yyerror( "Memory operand must by a qword" );
				
				
			_else
			
				EmitMov_m_r( &$<adrs>3, reg_eax, 4 );
				$<adrs.Disp>3 += 4;
				EmitMov_m_r( &$<adrs>3, reg_edx, 4 );
				$<adrs.Disp>3 -= 4;
			
			_endif
			$<returns>$ = hlastrdup2( "edx:eax" );
			FreeAdrs( &$<adrs>3 );
			_here;
		}
	;



	


 /*
 ** Handle the IN instruction here.
 **
 **	Syntax:
 **
 **		in( port, al )
 **		in( port, ax )
 **		in( port, eax )
 **
 **		in( dx, al )
 **		in( dx, ax )
 **		in( dx, eax )
 */

accTkn:	
		alTkn 
		{ 
			_here; 
			$<u>$ = reg_al; 
		}

	|	axTkn
		{ 
			_here; 
			$<u>$ = reg_ax; 
		}

	|	eaxTkn
		{ 
			_here; 
			$<u>$ = reg_eax; 
		}
	;

  	   

facc:
		accTkn
		{
			_here; 
			$<u>$ = $<u>1;
		}

	|	fstmt
		accTkn
		{
			_here; 
			$<u>$ = $<u>2;
		}
	;

fdx:
		dxTkn

	|	fstmt
		dxTkn
	;



SingleStmt:
		inTkn		/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		facc		/* $5 */
		Rparen		/* $6 */
		{
			unsigned Port;

			_here; 
			Port = CheckUnsignedSize( YYS &$<v>3, 8 );
			EmitInOut( in_instr, Port, $<u>5 );
			FreeValue( YYS &$<v>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<u>5 ] );
			_here; 
		}
	;


SingleStmt:
		inTkn		/* $1 */
		Lparen		/* $2 */
		fdx			/* $3 */
		comma		/* $4 */
		facc		/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitInOutDX( in_instr, $<u>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<u>5 ] );
			_here; 
		}
	;



SingleStmt:
		outTkn		/* $1 */
		Lparen		/* $2 */
		facc		/* $3 */
		comma		/* $4 */
		fConstExpr	/* $5 */
		Rparen		/* $6 */
		{
			unsigned Port;

			_here; 
			Port = CheckUnsignedSize( YYS &$<v>5, 8 );
			EmitInOut( out_instr, Port, $<u>3 );
			FreeValue( YYS &$<v>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<u>3 ] );
			_here; 
		}
	;


SingleStmt:
		outTkn		/* $1 */
		Lparen		/* $2 */
		facc		/* $3 */
		comma		/* $4 */
		fdx			/* $5 */
		Rparen		/* $6 */
		{
			_here;
			EmitInOutDX( out_instr, $<u>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<u>3 ] );
			_here; 
		}
	;







 /*
 ** Handle the extended signed multiplication (INTMUL) instruction here.
 **
 **	Syntax:
 **
 **
 **	intmul( const, Reg16 )
 ** intmul( const, Reg16, Reg16 )
 ** intmul( const, mem, Reg16 )
 ** intmul( const, AnonMem, Reg16 )
 **
 **	intmul( const, Reg32 )
 ** intmul( const, Reg32, Reg32 )
 ** intmul( const, mem, Reg32 )
 ** intmul( const, AnonMem, Reg32 )
 **
 **	intmul( Reg16, Reg16 )
 ** intmul( mem, Reg16 )
 ** intmul( AnonMem, Reg16 )
 **
 **	intmul( Reg32, Reg32 )
 ** intmul( mem, Reg32 )
 ** intmul( AnonMem, Reg32 )
 **
 */



SingleStmt:
		intmulTkn	/* $1 */
		Lparen		/* $2 */
		fRegister	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			_here; 
			_if( $<reg.Size>3 != $<reg.Size>5 )

				yyerror( "Registers must be the same size" );

			_endif
			_if( $<reg.Size>3 == 1 )

				yyerror( "intmul requires 16 or 32 bit registers" );

			_endif
			EmitIntMul_r_r( $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
			_here; 
		}
	;


SingleStmt:
		intmulTkn	/* $1 */
		Lparen		/* $2 */
		fEitherMem	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			char adrs[ 256 ];

			_here; 
			_if( $<reg.Size>5 == 1 )

				yyerror( "intmul requires 16 or 32 bit registers" );

			_endif
			EmitIntMul_m_r( &$<adrs>3, $<reg.encoding>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
			_here; 
		}
	;







SingleStmt:
		intmulTkn	/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		Rparen		/* $6 */
		{
			int multiplier;

			_here; 
			_if( $<reg.Size>5 == 1 )

				yyerror( "intmul requires 16 or 32 bit registers" );

			_endif
			multiplier = CheckOrdinalSize( YYS &$<v>3, $<reg.Size>5*8 );
			EmitIntMul_c_r_r( multiplier, $<reg.encoding>5, $<reg.encoding>5 );
			FreeValue( YYS &$<v>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>5 ]);
			_here; 
		}
	;






SingleStmt:
		intmulTkn	/* $1 */
		Lparen		/* $2 */
		fConstExpr	/* $3 */
		comma		/* $4 */
		fRegister	/* $5 */
		','			/* $6 */
		fRegister	/* $7 */
		Rparen		/* $8 */
		{
			int multiplier;

			_here; 
			_if( $<reg.Size>5 != $<reg.Size>7 )

				yyerror( "Registers must be the same size" );

			_endif
			_if( $<reg.Size>7 == 1 )

				yyerror( "intmul requires 16 or 32 bit registers" );

			_endif
			multiplier = CheckOrdinalSize( YYS &$<v>3, $<reg.Size>7*8 );
			EmitIntMul_c_r_r( multiplier, $<reg.encoding>5, $<reg.encoding>7 );
			FreeValue( YYS &$<v>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>7 ]);
			_here; 
		}
	;



SingleStmt:
		intmulTkn		/* $1 */
		Lparen			/* $2 */
		fConstExpr		/* $3 */
		comma			/* $4 */
		fEitherMemDest	/* $5 */
		','				/* $6 */
		fRegister		/* $7 */
		Rparen			/* $8 */
		{
			_here;
			_if( $<reg.Size>7 == 1 )

				yyerror( "intmul requires 16 or 32 bit registers" );

			_endif
			EmitIntMul_c_m_r( $<v.u.unsval>3, &$<adrs>5, $<reg.encoding>7 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>7 ]);
			_here;
		}
	;




 /*
 ** Handle the ENTER instruction here.
 **
 **	Syntax:
 **
 **		enter( LocalVarSize, NestingLevel )
 **		       ConstExpr	 ConstExpr
 **				word			byte
 */

SingleStmt:
		enterTkn
		Lparen
		fConstExpr
		comma
		fConstExpr
		Rparen
		{
			unsigned LocalSize;
			unsigned NestLevel;

			_here; 
			LocalSize = CheckUnsignedSize( YYS &$<v>3, 16 );
			NestLevel = CheckUnsignedSize( YYS &$<v>5, 8 );
			EmitEnter_c_c( LocalSize, NestLevel );
			$<returns>$ = NULL;
			FreeValue( YYS &$<v>3 );
			FreeValue( YYS &$<v>5 );
			_here; 
		}
	;



 /*
 ** Handle the INT instruction here:
 **
 **	Syntax:
 **
 **		int( ConstExpr:byte );
 */


SingleStmt:
		intTkn
		Lparen
		fConstExpr
		Rparen
		{
			unsigned IntNum;

			_here; 
			IntNum = CheckUnsignedSize( YYS &$<v>3, 8 );
			EmitInt_c( IntNum );
			FreeValue( YYS &$<v>3 );
			$<returns>$ = hlastrdup( "" );
			_here; 
		}
	;


 /*
 ** Handle the JMP instruction here.
 **
 **	Syntax:
 **
 **		jmp	Label
 **		jmp	LocalProcedureLabel
 **		jmp	NonLocalProcedureLabel
 **		jmp( dwordMemPtr )
 **		jmp( anonMemPtr )
 **		jmp( reg32 )
 */

SingleStmt:
		jmpTkn
		UndefLabel
		{
			_here;
			jmpTargetID( $<idStr>2 );
			free2( vss $<idStr>2 );
			$<returns>$ = NULL;
			_here;
		}
	;
		
SingleStmt:
		jmpTkn
		JmpTargetID
		{
			_here;
			EmitJmpLabel( $<s>2->StaticName );
			SetReferenced( $<s>2 );
			$<returns>$ = NULL;
			_here;
		}
	;
	
SingleStmt:
		jmpTkn
		hereTkn
		';'
		{
			char label[64];
			
			_here;
			sprintf( label, "here" sympost "%d", LblCntr++ );
			EmitStmtLbl( label );
			EmitJmpLabel( label );
			PushBackStr( ";" );
			$<returns>$ = NULL;
			_here; 
		}
	;
		
		
SingleStmt:
		jmpTkn
		hereTkn
		'['
		fConstOnlyExpr
		Rbrack
		{
			int  disp;
			char label[64];
			
			_here;
			disp = CheckOrdinalSize( YYS &$<v>4, 32 );
			sprintf( label, "here" sympost "%d", LblCntr );
			EmitStmtLbl( label );
			sprintf
			( 
				label, 
				"(here" sympost "%d%s%d)" , 
				LblCntr++, 
				_ifx( disp < 0, "", "+"),
				disp 
			);
			EmitJmpLabel( label );
			$<returns>$ = NULL;
			_here; 
		}
	;
		
		
// Process indirect jmps through dword memory locations here.
		
SingleStmt:
		jmpTkn
		Lparen
		fEitherMemDest
		Rparen
		{
			_here; 
			_if( $<adrs.Size>3 != 4 && $<adrs.Size>3 != 0 )

				yyerror( "Pointer must be four bytes long" );

			_else

				EmitJmp_m( &$<adrs>3 );

			_endif
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here; 
		}
	;
	
// Handle indirect jmps through registers here.
		
SingleStmt:
		jmpTkn
		Lparen
		fReg32
		Rparen
		{
			_here; 
			EmitJmp_r( $<reg.encoding>3 );
			$<returns>$ = NULL;
			_here; 
		}
	;
	

JmpTargetID:
		LocalLabelID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}
	
	|	NonLocalLabelID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}
	
	|	LocalProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	LocalIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	NonLocalProcID

		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	NonLocalIterID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	ClassProcID
		{
			_here;
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}
	;




UndefLabel:
		NonLocalID
		{
			_here;
			$<idStr>$ = hlastrdup2( $<s>1->TrueName );
			SetReferenced( $<s>1 );
		}

	|	NonLocalVarID
		{
			_here;
			$<idStr>$ = hlastrdup2( $<s>1->TrueName );
			SetReferenced( $<s>1 );
		}

	|	NonLocalStaticID
		{
			_here;
			$<idStr>$ = hlastrdup2( $<s>1->TrueName );
			SetReferenced( $<s>1 );
		}

	|	UndefID
		{
			_here;
			$<idStr>$ = $<idStr>1;
		}
	|	NonLocalConstID
		{
			_here;
			$<idStr>$ = hlastrdup2( $<s>1->TrueName );
			SetReferenced( $<s>1 );
		}

	;
	
	
 /*
 ** bswap instruction.
 **
 **	Syntax:
 **
 **	bswap( Reg32 )
 **
 */
 	
SingleStmt:
		bswapTkn
		Lparen
		fReg32
		Rparen
		{
			_here; 
			EmitBswap_r( $<reg.encoding>3 );
			$<returns>$ = hlastrdup2( regStrs[ $<reg.encoding>3 ]);
			_here; 
		}
	;

SingleStmt:
		bswapTkn
		Lparen
		fEitherMem
		Rparen
		{
			yyerror( "BSWAP requires a 32-bit register operand" );
			$<returns>$ = NULL;
		}

	|	bswapTkn
		Lparen
		fConstExpr
		Rparen
		{
			yyerror( "BSWAP requires a 32-bit register operand" );
			$<returns>$ = NULL;
		}
	;


 /*
 ** Handle the CMPXCHG instruction here.
 **
 ** Syntax:
 **
 **	cmpxchg( reg/mem, reg )
 **
 **	cmpxchg( Reg8, Reg8 )
 ** cmpxchg( Reg8, Memory )
 ** cmpxchg( Reg8, AnonMem )
 **
 **	cmpxchg( Reg16, Reg16 )
 ** cmpxchg( Reg16, Memory )
 ** cmpxchg( Reg16, AnonMem )
 **
 **	cmpxchg( Reg32, Reg32 )
 ** cmpxchg( Reg32, Memory )
 ** cmpxchg( Reg32, AnonMem )
 **
 */

SingleStmt:
		cmpxchgTkn
		Lparen
		fRegister
		comma
		fRegister
		Rparen
		{
			_if( $<reg.Size>3 != $<reg.Size>5 )
			_here; 

				yyerror( "Registers must be the same size" );

			_endif
			EmitCmpXchg_r_r( 0, $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = NULL;
			_here; 
		}
	;
	
SingleStmt:	
		lockcmpxchgTkn
		Lparen
		fRegister
		comma
		fRegister
		Rparen
		{
			_here; 
			_if( $<reg.Size>3 != $<reg.Size>5 )

				yyerror( "Registers must be the same size" );

			_endif
			EmitCmpXchg_r_r( 1, $<reg.encoding>3, $<reg.encoding>5 );
			$<returns>$ = NULL;
			_here; 
		}
	;



SingleStmt:
		cmpxchgTkn
		Lparen
		fEitherMemDest
		comma
		fRegister
		Rparen
		{
			_here;
			EmitCmpXchg_m_r( 0, &$<adrs>3, $<reg.encoding>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}
	;
		
SingleStmt:
		lockcmpxchgTkn
		Lparen
		fMemoryDest
		comma
		fRegister
		Rparen
		{
			_here;
			EmitCmpXchg_m_r( 1, &$<adrs>3, $<reg.encoding>5 );
			FreeAdrs( &$<adrs>3 );
			$<returns>$ = NULL;
			_here;
		}
	;





	

/*****************************************************************************/
	


	


 /*
 ** Handle the "setthunk" statement here.
 */

SingleStmt:
		thunkTkn		/* $1 */
		doSetThunkTkn	/* $2 */
		fMemoryDest		/* $3 */
		Assign			/* $4 */
		PreSetThunk		/* $5 */
		stmtsTkn		/* $6 */
		Stmts			/* $7 */
		endstmtsTkn		/* $8 */
		{				/* $9 */

			char thunkname[ 256 ];
			char adrs[ 256 ];
			char constant[ 256 ];

			_here;
			sprintf( thunkname, "thunk_%u" sympost, $<v.u.unsval>5 );
			pop_r( reg_ebp );
			ret_instr( 4 );
			EndProc( thunkname );
			NewLn();
			{
				char lbl[ 256 ];
				
				sprintf( lbl, "endthunk_%u" sympost, $<v.u.unsval>5 );
				EmitStmtLbl( lbl );
			}
			$<adrs.Disp>3 += 4;
			EmitMov_o_m( thunkname, 0, &$<adrs>3 );
			$<adrs.Disp>3 -= 4;
			EmitMov_r_m( reg_ebp, &$<adrs>3, 4 );

			/*
			** Okay, now that we've processed this thunk, let's
			** make sure it's legal to have a thunk here.
			*/

			_if( $<adrs.pType>3 != tThunk )

				yyerror
				( 
					"Type mismatch, expected a thunk type"
				);

			_endif
			$<returns>$ = FreeAdrs2( &$<adrs>3 );

			inThunk = $<v.u.unsval>2;
			_here;
		}
	;

doSetThunkTkn:
		{
			_here; 
			$<v.u.unsval>$ = inThunk;
			inThunk = 1;
		}
	;


PreSetThunk:
		{
			int ThunkNum;
			char thunkname[ 256 ];
			char endthunk[ 256 ];
			struct adrsYYS adrs;

			_here;
			ThunkNum = LblCntr++;
			sprintf( thunkname, "thunk_%d" sympost, ThunkNum );
			sprintf( endthunk, "endthunk_%d" sympost, ThunkNum );
			EmitJmpLabel( endthunk );
			NewLn();
			EmitComment( "thunk begins here" );
			StartProc( thunkname );
			push_r( reg_ebp );
			initAdrs( &adrs, reg_esp, -1, 0, 8 );
			EmitMov_m_r( &adrs, reg_ebp, 4 );

			$<v.u.intval>$ = ThunkNum;
			_here;
		}
	;




 /*
 ** Handle the try..exception..endtry HLL block here.
 **
 */

	/*
	** StartTry-
	**
	**	Sets up the code needed at the beginning of the try stmt.
	**	Also sets aside two label values: one for the endtry
	**	and one for the first exception.
	*/

StartTry:
		{
			struct adrsYYS adrs;
			char symbol[ 256 ];
			char label[ 256 ];
			char mem[256];

			_here;
			need_raise = 1;
			$<v.u.intval>$ = EndTryLabel;	/* Save current endtry lbl	*/
			EndTryLabel = LblCntr++;	/* Label for the endtry		*/
			++LblCntr;					/* Label for the 1st excptn	*/

			sprintf( symbol, "exception" sympost "%d", EndTryLabel+1 );
			PushStaticAdrs( symbol );
			push_r( reg_ebp );

			_if( targetOS == windows_os )
			
				initAdrs( &adrs, -1, -1, 0, 0 );
				fseg_prefix();
				EmitMov_m_r( &adrs, reg_ebp, 4 );
			
			_else
			
				_if( threadSafe )
				
					EmitCallLabel( "_HLA_GET_EXCEPTIONPTREBP" );
					need_HLA_GET_EXCEPTIONPTREBP = 1;
				
				_else
				
					initLbl( &adrs, ExceptionPtr, 0 );
					EmitMov_m_r( &adrs, reg_ebp, 4 );
					need_ExceptionPtr = 1;
					
				_endif
				
			_endif
			
			initAdrs( &adrs, reg_ebp, -1, 0, 8 );
			push_mem( &adrs, 4 );
			initAdrs( &adrs, reg_esp, -1, 0, 4 );
			EmitMov_m_r( &adrs, reg_ebp, 4 ); 			
			_if( targetOS == windows_os )
						
				PushStaticAdrs( "HWexcept" sympost );
				need_raise = 1;
				fseg_prefix();
				initAdrs( &adrs, -1, -1, 0, 0 );
				push_mem( &adrs, 4 );
				fseg_prefix();
				EmitMov_r_m( reg_esp, &adrs, 4 );
				
			_else
			
				// Linux/BSD/MacOS don't have SEH frames (like Windows),
				// so we'll use the entry at ESP+4 as a
				// signature value.
				
				_if( threadSafe )
				
					Pushd( 0xe8ce972 );
					push_r( reg_eax );
					EmitCallLabel( "_HLA_PUSH_EXCEPTIONPTR" );
					push_r( reg_eax );
					initLea_m_r( reg_esp, 4, reg_eax );
					push_r( reg_eax );
					EmitCallLabel( "_HLA_SET_EXCEPTIONPTR" );
					pop_r( reg_eax );
					need_HLA_PUSH_EXCEPTIONPTR = 1;
					need_HLA_SET_EXCEPTIONPTR  = 1;
				
				_else
				
					Pushd( 0xe8ce972 );
					initLbl( &adrs, ExceptionPtr, 0 );
					push_mem( &adrs, 4 );
					EmitMov_r_m( reg_esp, &adrs, 4 );
					need_ExceptionPtr = 1;
					
				_endif 			

			_endif
			_here;
		}
	;



													
PopExcepts:
		{
			struct adrsYYS adrs;

			_here;
			_if( targetOS == windows_os )
			
				fseg_prefix();
				initAdrs( &adrs, -1, -1, 0, 0 );
				EmitMov_m_r( &adrs, reg_esp, 4 );
				fseg_prefix();
				pop_memInit( NULL, -1, 0, 4 );
				EmitGeneric_c_r( add_instr, 8, reg_esp ); 
				pop_r( reg_ebp );
				EmitGeneric_c_r( add_instr, 4, reg_esp );
				
			_else
			
				_if( threadSafe )
				
					EmitCallLabel( "_HLA_GET_EXCEPTIONPTREBP" );
					EmitMov_r_r( reg_ebp, reg_esp );
					EmitCallLabel( "_HLA_SET_EXCEPTIONPTR" );
					EmitGeneric_c_r( add_instr, 8, reg_esp );
					pop_r( reg_ebp );
					EmitGeneric_c_r( add_instr, 4, reg_esp );
					need_HLA_GET_EXCEPTIONPTREBP = 1;
					need_HLA_SET_EXCEPTIONPTR    = 1;
					
				_else
				
					initLbl( &adrs, ExceptionPtr, 0 );
					EmitMov_m_r( &adrs, reg_esp, 4 );
					pop_mem( &adrs, 4 );
					EmitGeneric_c_r( add_instr, 8, reg_esp );
					pop_r( reg_ebp );
					EmitGeneric_c_r( add_instr, 4, reg_esp );
					need_ExceptionPtr = 1;
					
				_endif

			_endif
			_here;
		}
	;


 /*
 ** Weird try..endtry block without an exception handler.
 */

SingleStmt:
		tryTkn
		StartTry
		Stmts
		endtryTkn
		PopExcepts
		{
			WarnNear
			( 
				"try..endtry block without exception handler", 
				"endtry" 
			);
			EmitBackPatchds
			( 
				"exception" sympost "%d", 
				EndTryLabel + 1, 
				"Raise" sympost 
			);
			EndTryLabel = $<v.u.intval>2;
			$<returns>$ = NULL;
		}
	;

 /*
 ** Weird try..unprotected..endtry block without an exception handler.
 */

SingleStmt:
		tryTkn				/* $1 */
		StartTry			/* $2 */
		Stmts				/* $3 */
		unprotectedTkn		/* $4 */
		PopExcepts			/* $5 */
		Stmts				/* $6 */
		endtryTkn			/* $7 */
		{					/* $8 */

			WarnNear
			( 
				"try..unprotected..endtry block without exception handler", 
				"endtry" 
			);
			EmitBackPatchds
			( 
				"exception" sympost "%d", 
				EndTryLabel+1, 
				"Raise" sympost 
			); 
			EndTryLabel = $<v.u.intval>2;
			$<returns>$ = NULL;
		}
	;



 /*
 ** try..endtry block with only a single "anyexception" handler.
 */

SingleStmt:
		tryTkn				/* $1 */
		StartTry			/* $2 */
		Stmts				/* $3 */
		anyexceptionTkn		/* $4 */
		PopExcepts			/* $5 */
		{					/* $6 */

			char label[ 256 ];

			_here; 
			sprintf( label, "endtry" sympost "%d", EndTryLabel );
			EmitJmpLabel( label );
			EmitStmtLblNum( "exception" sympost "%d", EndTryLabel + 1 );
			_here; 
		}

		Stmts				/* $7 */
		endtryTkn			/* $8 */
		{					/* $9 */

			_here; 
			EmitStmtLblNum( "endtry" sympost "%d", EndTryLabel ); 
			EndTryLabel = $<v.u.intval>2;
			$<returns>$ = NULL;
			_here; 
		}
	;






 /*
 ** try..unprotected..endtry block with only a single "anyexception" handler.
 */

SingleStmt:
		tryTkn				/* $1 */
		StartTry			/* $2 */
		Stmts				/* $3 */
		unprotectedTkn		/* $4 */
		PopExcepts			/* $5 */
		Stmts				/* $6 */
		anyexceptionTkn		/* $7 */
		{					/* $8 */

			char label[ 256 ];

			_here; 
			sprintf( label, "endtry" sympost "%d", EndTryLabel );
			EmitJmpLabel( label );
			EmitStmtLblNum( "exception" sympost "%d", EndTryLabel + 1 );
			_here; 

		}

		Stmts				/* $9  */
		endtryTkn			/* $10 */
		{					/* $11 */
			_here; 
			EmitStmtLblNum( "endtry" sympost "%d", EndTryLabel );
			EndTryLabel = $<v.u.intval>2;
			$<returns>$ = NULL;
			_here; 
		}
	;



 /*
 ** try..endtry block that allows multiple exceptions.
 ** Possible anyexception handler.
 ** No unprotected block.
 */

SingleStmt:
		tryTkn					/* $1  */
		StartTry				/* $2  */
		Stmts					/* $3  */
		
		exceptionTkn			/* $4  */
		Lparen					/* $5  */
		fConstExpr				/* $6  */
		Rparen					/* $7  */
		PopExcepts				/* $8  */
		{						/* $9  */

			_here; 
			$<v.u.intval>$ = LblCntr++;	/* Target for next exception */
			_if( !IsOrdinal( $<v.pType>6 ) || numBits32( YYS &$<v>6 ) > 32 )
			
				ErrorNear
				( 
					"Expected a 32-bit ordinal value", 
					"exception",
					__LINE__,
					__FILE__ 
				);
				
			_else
			 
				char label[ 256 ];
				char constant[ 256 ];

				sprintf( label, "endtry" sympost "%d", EndTryLabel );
				EmitJmpLabel( label );
				EmitStmtLblNum( "exception" sympost "%d", EndTryLabel+1 );
				EmitGeneric_i_r( cmp_instr, YYS &$<v>6, reg_eax );
				sprintf( label, "exception" sympost "%u", $<v.u.unsval>$ );
				EmitCondJump( jne_instr, label );

			_endif
			_here; 
		}

		Stmts					/* $10 */
		
		{						/* $11 */

			$<v.u.intval>$ = $<v.u.intval>9;
		}
				
		ZeroOrMoreExceptions	/* $12 */
		endtryTkn				/* $13 */
		{						/* $14 */
			_here; 
			EmitBackPatchds
			( 
				"exception" sympost "%u", 
				$<v.u.unsval>12, 
				"Raise" sympost 
			);
			EmitStmtLblNum( "endtry" sympost "%d", EndTryLabel );
			EndTryLabel = $<v.u.intval>2;
			(void) $<v.u.intval>11;	// shut up bison
			$<returns>$ = NULL;
			_here;
		}
	;




 /*
 ** try..endtry block that allows multiple exceptions.
 ** Possible anyexception handler.
 ** Has an unprotected block.
 */

SingleStmt:
		tryTkn					/* $1  */
		StartTry				/* $2  */
		Stmts					/* $3  */
		unprotectedTkn			/* $4  */
		PopExcepts				/* $5  */
		Stmts					/* $6  */

		exceptionTkn			/* $7  */
		Lparen					/* $8  */
		fConstExpr				/* $9  */
		Rparen					/* $10 */
		{						/* $11 */

			_here; 
			$<v.u.intval>$ = LblCntr++;	/* Target for next exception */
			_if( !IsOrdinal( $<v.pType>9 ) || numBits32( YYS &$<v>9 ) > 32 )
			
				ErrorNear
				( 
					"Expected a 32-bit ordinal value", 
					"exception",
					__LINE__,
					__FILE__ 
				);
				
			_else

				char label[ 256 ];
				char constant[16];
			 
				sprintf( label, "endtry" sympost "%d", EndTryLabel );
				EmitJmpLabel( label );
				EmitStmtLblNum( "exception" sympost "%d", EndTryLabel+1 );
				EmitGeneric_i_r( cmp_instr, YYS &$<v>9, reg_eax );
				sprintf( label, "exception" sympost "%u", $<v.u.unsval>$ );
				EmitCondJump( jne_instr, label );


			_endif
			_here; 
		}

		Stmts					/* $12 */
		
		{						/* $13 */

			$<v.u.intval>$ = $<v.u.intval>11;
		}
				
		ZeroOrMoreExceptions	/* $14 */
		endtryTkn				/* $15 */
		{						/* $16 */
			_here; 
			EmitBackPatchds
			( 
				"exception" sympost "%d", 
				$<v.u.intval>14, 
				"Raise" sympost 
			);
			EmitStmtLblNum( "endtry" sympost "%d", EndTryLabel );
			EndTryLabel = $<v.u.intval>2;
			$<returns>$ = NULL;
			(void) $<v.u.intval>13;	// shut up bison
			_here
		}
	;


	


	




	/*
	** Note $<v.u.intval>0 is the label number for this exception.
	** This production returns the label it jumps to.
	*/

ZeroOrMoreExceptions:
		Empty
		{
			_here; 
			$<v.u.intval>$ = $<v.u.intval>0;
		}

	|	OneOrMoreExceptions		/* $1 */
		{
			_here; 
			$<v.u.intval>$ = $<v.u.intval>1;
		}
	;


OneOrMoreExceptions:
		LastException			/* $1 */
		{						/* $2 */
			_here; 
			$<v.u.intval>$ = $<v.u.intval>1;
		}

	|	OneException		/* $1 */
		OneOrMoreExceptions	/* $2 */
		{
			_here; 
			$<v.u.intval>$ = $<v.u.intval>2;
		}
	;


LastException:
		OneException
		{
			_here; 
			$<v.u.intval>$ = $<v.u.intval>1;
		}
	
	|	anyexceptionTkn
		{
			char label[ 256 ];

			_here; 
			sprintf( label, "endtry" sympost "%d", EndTryLabel );
			EmitJmpLabel( label );
			EmitStmtLblNum( "exception" sympost "%d", $<v.u.intval>0 );
			_here; 
		}
		Stmts
		{
			_here; 
			$<v.u.intval>$ = LblCntr++;
			(void) $<s>2;	// shut up bison
		}
	;


OneException:
		exceptionTkn		/* $1 */
		Lparen				/* $2 */
		fConstExpr			/* $3 */
		Rparen				/* $4 */
		{					/* $5 */

			char label[ 256 ];
			char constant[16];

			_here; 
			_if( !IsOrdinal( $<v.pType>3 ) || numBits32( YYS &$<v>3 ) > 32 )

				ErrorNear
				( 
					"Expected a 32-bit ordinal value", 
					"exception",
					__LINE__,
					__FILE__ 
				);

			_endif
			$<v.u.intval>$ = LblCntr++;

			sprintf( label, "endtry" sympost "%d", EndTryLabel );
			EmitJmpLabel( label );
			EmitStmtLblNum( "exception" sympost "%d", $<v.u.intval>0 );
			EmitGeneric_i_r( cmp_instr, YYS &$<v>3, reg_eax );
			sprintf( label, "exception" sympost "%u", $<v.u.unsval>$ );
			EmitCondJump( jne_instr, label );
			_here; 
		}
		Stmts				/* $6 */
		{					/* $7 */
			_here; 
			$<v.u.intval>$ = $<v.u.intval>5;
		}
	;


 /*
 ** Handle the RAISE HLL statement here.
 */

SingleStmt:
		raiseTkn		/* $1 */
		Lparen			/* $2 */
		fConstExpr		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */

			char constant[16];

			_here; 
			_if( !IsOrdinal( $<v.pType>3 ) || numBits32( YYS &$<v>3 ) > 32 )

				ErrorNear
				( 
					"Expected a 32-bit ordinal constant", 
					"raise",
					__LINE__,
					__FILE__ 
				);

			_endif
			EmitMov_c_r( $<v.u.unsval>3, reg_eax );
			EmitJmpLabel( "Raise" sympost );
			need_raise = 1;
			$<returns>$ = NULL;
			_here; 
		}

	|	raiseTkn		/* $1 */
		Lparen			/* $2 */
		fRegister		/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here; 
			_if( $<reg.Size>3 != 4 )

				EmitMovxx_r_r( movzx_instr, $<reg.encoding>3, reg_eax );

			_elseif( stricmp( regStrs[ $<reg.encoding>3 ], "eax" ) != 0 )

				EmitMov_r_r( $<reg.encoding>3, reg_eax );

			_endif
			EmitJmpLabel( "Raise" sympost );
			need_raise = 1;
		    $<returns>$ = NULL;
			_here; 
		}


	|	raiseTkn		/* $1 */
		Lparen			/* $2 */
		fMemory			/* $3 */
		Rparen			/* $4 */
		{				/* $5 */
			_here; 
			_if( $<adrs.Size>3 > 4 )

				yyerror( "Raise expression must be a 32-bit value" );

			_endif
			_if( $<adrs.Size>3 == 1 || $<adrs.Size>3 == 2 )

				EmitMovxx_m_r( movzx_instr, &$<adrs>3, reg_eax );

			_else 

				EmitMov_m_r( &$<adrs>3, reg_eax, 4 );

			_endif
			EmitJmpLabel( "Raise" sympost );
			FreeAdrs( &$<adrs>3 );
			need_raise = 1;
			$<returns>$ = NULL;
			_here; 
		}
	;




 /*
 ** Handle the FOR HLL statement here.
 **
 ** Syntax:
 **
 **	for( stmt, expr, stmt ) do
 **
 **		statements
 **
 **	endfor;
 */

SingleStmt:
		forTkn			/* $1  */
		Lparen			/* $2  */
		SingleStmt		/* $3  */
		Semicolon		/* $4  */
		EmitForLabel	/* $5  */
		BoolExpr		/* $6  */
		Semicolon		/* $7  */
		SaveForPosn		/* $8  */
		SingleStmt		/* $9  */
		Rparen			/* $10 */
		SaveForCond		/* $11 */
		GetDoTkn		/* $12 */
		SaveForBreak	/* $13 */
		Stmts			/* $14 */
		endforTkn		/* $15 */
		{				/* $16 */

			char tmpLabel[256];

			_here;
			EmitStmtLblNum( "continue" sympost "%d", $<labels.l1.label1>5 );
			asmPuts( $<v.u.strval>11 );
			asmPutc( '\n' );
			EmitStmtLblNum( "StartFor" sympost "%d", $<labels.l1.label1>5 );
			sprintf( tmpLabel, "for" sympost "%d", $<labels.l1.label1>5 );
			EmitBooleanExpr
			( 
				$<opnode>6, 
				tmpLabel,
				1 
			);
			EmitStmtLblNum( "exitloop" sympost "%d",	$<labels.l1.label1>5 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<labels.l1.label1>13;

			free2( vss $<v.u.strval>11 );
			$<returns>$ = NULL;
			_here;
		}
	;

 /*
 ** Handle the FOR HLL statement here.
 **
 ** Syntax:
 **
 **	for( stmt, expr, stmt ) do
 **
 **		statements
 **
 ** felse
 **
 **		statements
 **
 **	endfor;
 */

SingleStmt:
		forTkn			/* $1  */
		Lparen			/* $2  */
		SingleStmt		/* $3  */
		Semicolon		/* $4  */
		EmitForLabel	/* $5  */
		BoolExpr		/* $6  */
		Semicolon		/* $7  */
		SaveForPosn		/* $8  */
		SingleStmt		/* $9  */
		Rparen			/* $10 */
		SaveForCond		/* $11 */
		GetDoTkn		/* $12 */
		SaveForBreak	/* $13 */
		Stmts			/* $14 */
		felseTkn		/* $15 */
		{				/* $16 */

			char tmpLabel[32];
			
			_here;
			EmitStmtLblNum( "continue" sympost "%d", $<labels.l1.label1>5 );
			asmPuts( $<v.u.strval>11 );
			asmPutc( '\n' );
			EmitStmtLblNum( "StartFor" sympost "%d", $<labels.l1.label1>5 );
			sprintf( tmpLabel, "for" sympost "%d", $<labels.l1.label1>5 );
			EmitBooleanExpr
			( 
				$<opnode>6, 
				tmpLabel,
				1 
			);
			_here; 
		}
		Stmts			/* $17 */
		endforTkn		/* $18 */
		{				/* $19 */
		
			_here;
			EmitStmtLblNum( "exitloop" sympost "%d",	$<labels.l1.label1>5 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<labels.l1.label1>13;

			free2( vss $<v.u.strval>11 );
			$<returns>$ = NULL;
			_here;
		}
	;
	
	
	
SaveForPosn:
		{
			_here;
			$<v.u.intval>$ = asmBuf->offset;
			_here;
		}
	;
	
SaveForCond:
		{
		
			char	*t;
			int		size;

			_here;
			size = asmBuf->offset - $<v.u.intval>-2;
			t = malloc2( size + 2 );
			memcpy( t, asmBuf->base + $<v.u.intval>-2, size );
			t[ size ] = '\0'; 
			$<v.u.strval>$ = t;
			
			// Now that we've captured the "inc" statement,
			// reset the offset so we'll overwrite it with the
			// next code
			
			asmBuf->offset = $<v.u.intval>-2;
			_here;
		}
	;
	
SaveForBreak:
		{

			/*
			** Save the break/breakif label value so we can
			** restore it later.  Then set the break/breakif label
			** value to the exit value for this loop.
			*/

			$<labels.l1.label1>$ = BreakLbl;
			BreakLbl = $<labels.l1.label1>-7;
			_here;
		}
	;


EmitForLabel:
		{
			char label[ 256 ];

			_here;

			/*
			** Emit the header for the FOR loop.
			*/

			$<labels.l1.label1>$ = LblCntr++;
			NewLn();
			sprintf( label, "StartFor" sympost "%d", $<labels.l1.label1>$ );
			EmitJmpLabel( label );
			EmitStmtLblNum( "for" sympost "%d", $<labels.l1.label1>$ );
			StartOfStmt = asmBuf->offset; 
			_here;
		}
	;




 /*
 ** Handle the WHILE HLL statement here.
 **
 **	Syntax:
 **
 **	while( BoolExpr ) do
 **
 **		statements
 **
 **	endwhile
 */

SingleStmt:
		whileTkn		/* $1  */
		Lparen			/* $2  */
		EmitWhileLabel	/* $3  */
		BoolExpr		/* $4  */
		Rparen			/* $5  */
		GetDoTkn		/* $6  */
		SetBreakLbl		/* $7  */
		Stmts			/* $8  */
		endwhileTkn		/* $9  */
		{				/* $10 */

			char tmpLabel[32];
			
			_here;

			/*
			** Emit the loop termination test.
			*/
			EmitStmtLblNum( "continue" sympost "%d", $<labels.l1.label1>3 );
			sprintf( tmpLabel, "while" sympost "%d", $<labels.l1.label1>3 );
			EmitBooleanExpr
			( 
				$<opnode>4, 
				tmpLabel,
				1 
			);
			EmitStmtLblNum( "exitloop" sympost "%d", $<labels.l1.label1>3 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<labels.l1.label1>7;

			$<returns>$ = NULL;
			_here;
		}
	;



 /*
 ** Handle the WHILE..WELSE..ENDWHILE HLL statement here.
 **
 **	Syntax:
 **
 **	while( BoolExpr ) do
 **
 **		statements
 **
 ** welse
 **
 **		statements
 **
 **	endwhile
 */

SingleStmt:
		whileTkn		/* $1  */
		Lparen			/* $2  */
		EmitWhileLabel	/* $3  */
		BoolExpr		/* $4  */
		Rparen			/* $5  */
		GetDoTkn		/* $6  */
		SetBreakLbl		/* $7  */
		Stmts			/* $8  */
		welseTkn		/* $9  */
		{				/* $10 */
		
			char label[ 32 ];
			
			/*
			** Emit the loop termination test.
			** Note that if the termination test fails, the
			** code falls into the welse section.
			*/

			_here;
			EmitStmtLblNum( "continue" sympost "%d", $<labels.l1.label1>3 );
			sprintf( label, "while" sympost "%d", $<labels.l1.label1>3 );
			EmitBooleanExpr
			( 
				$<opnode>4, 
				label,
				1 
			);

			_here;		
		}
		Stmts			/* $11 */
		endwhileTkn		/* $12 */
		{				/* $13 */
		
			_here;

			/*
			** Emit the target for a break statement:
			*/
						
			EmitStmtLblNum( "exitloop" sympost "%d", $<labels.l1.label1>3 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<labels.l1.label1>7;
			$<returns>$ = NULL;
			_here;
		}
	;



EmitWhileLabel:
		{
			char label[ 256 ];

			_here;

			/*
			** Allocate two labels:
			** One for the label at the beginning
			** of the while loop and one for the
			** exit location.
			*/

			$<labels.l1.label1>$ = LblCntr++;
			$<labels.l2.label2>$ = LblCntr++;
			sprintf( label, "continue" sympost "%d", $<labels.l1.label1>$ );
			EmitJmpLabel( label );
			EmitStmtLblNum( "while" sympost "%d", $<labels.l1.label1>$ );
			StartOfStmt = asmBuf->offset;
			_here;
		}
	;
	
SetBreakLbl:
		{
		
			_here;


			/*
			** Save the break/breakif label value so we can
			** restore it later.  Then set the break/breakif label
			** value to the exit value for this loop.
			*/

			$<labels.l1.label1>$ = BreakLbl;
			BreakLbl = $<labels.l1.label1>-3;
			_here;
		}
	;




 /*
 ** Handle the WHILE HLL statement here.
 **
 ** Syntax #2:
 **
 **	while
 ** (
 **		#{ statements }#
 ** )
 **
 **		statments
 **
 **	endwhile
 */


SingleStmt:
		whileTkn		/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		EmitWhileCode	/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		GetDoTkn		/* $8  */
		EmitTrueLabel	/* $9  */
		SetBreakLbl2	/* $10 */
		Stmts			/* $11 */
		endwhileTkn		/* $12 */
		{				/* $13 */
			
			char label[ 256 ];

			/*
			** Emit the target label for SetFalseLabel.
			*/

			_here;
			sprintf( label, "while" sympost "%d", $<labels.l1.label1>4 );
			EmitJmpLabel( label );
			EmitStmtLblNum( "exitloop" sympost "%d", $<labels.l1.label1>4 );
			EmitStmtLblNum( "exitloop" sympost "%d", $<labels.label4>4 );
			EmitStmtLblNum( "false" sympost "%d", $<labels.l1.label1>4 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<labels.l1.label1>10;
			$<returns>$ = NULL;
			_here;
		}
	;



 /*
 ** Handle the WHILE/ELSE/ENDWHILE HLL statement here.
 **
 ** Syntax #2:
 **
 **	while
 ** (
 **		#{ statements }#
 ** )
 **
 **		statments
 **
 ** welse
 **
 **		statements
 **
 **	endwhile
 */


SingleStmt:
		whileTkn		/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		EmitWhileCode	/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		GetDoTkn		/* $8  */
		EmitTrueLabel	/* $9  */
		SetBreakLbl2	/* $10 */
		Stmts			/* $11 */
		welseTkn		/* $12 */
		{				/* $13 */
			
			char label[ 256 ];
			
			/*
			** Emit the code for the welse section:
			*/
			
			_here;
			sprintf( label, "while" sympost "%d", $<labels.l1.label1>4 );
			EmitJmpLabel( label );
			EmitStmtLblNum( "exitloop" sympost "%d", $<labels.l1.label1>4 );
			EmitStmtLblNum( "false" sympost "%d", $<labels.l1.label1>4 );
			_here;
		}
		Stmts			/* $14 */
		endwhileTkn		/* $15 */
		{				/* $16 */
			
			/*
			** Emit the target label for SetFalseLabel.
			*/

			_here;
			EmitStmtLblNum( "exitloop" sympost "%d", $<labels.label4>4 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<labels.l1.label1>10;
			$<returns>$ = NULL;
			_here;
		}
	;



EmitWhileCode:
		{
			_here;
			$<labels.l1.label1>$ = LblCntr++;
			$<labels.l2.label2>$ = TrueLabel;
			$<labels.l3.label3>$ = FalseLabel;
			$<labels.label4>$ = LblCntr++;
			TrueLabel = $<labels.l1.label1>$;
			FalseLabel = $<labels.l1.label1>$;
			NewLn();
			EmitStmtLblNum( "while" sympost "%d", $<labels.l1.label1>$ ); 
			EmitStmtLblNum( "continue" sympost "%d", $<labels.label4>$ );
			_here; 
		}
	;


SetBreakLbl2:
		{
		
			_here;


			/*
			** Save the break/breakif label value so we can
			** restore it later.  Then set the break/breakif label
			** value to the exit value for this loop.
			*/

			$<labels.l1.label1>$ = BreakLbl;
			BreakLbl = $<labels.label4>-5;
			_here;
		}
	;





	

GetDoTkn:
		Empty
		{
			yyerror( "Expected 'do'" );
		}

	|	doTkn
	;


 /*
 ** Handle the REPEAT..UNTIL HLL statement here.
 **
 **	Syntax:
 **
 **	repeat
 **
 **		statements
 **
 **	until ( BoolExpr );
 */

SingleStmt:
		repeatTkn		/* $1  */
		SaveTrueLabel	/* $2  Just a placeholder to prevent conflicts.	*/
		SaveFalseLabel	/* $3  Also a placeholder.						*/
		EmitRepeatLabel	/* $4  */	 
		SaveBreakLbl	/* $5  */	 
		Stmts			/* $6  */	 
		untilTkn		/* $7  */	 
		PutContinueLbl	/* $8  */	 
		Lparen			/* $9  */	 
		BoolExpr		/* $10 */	 
		Rparen			/* $11 */	 
		{				/* $12 */	 
			
			char tmpLabel[32];
									 
			_here;

			/*
			** Emit the loop termination test.
			*/

			sprintf( tmpLabel, "repeat" sympost "%d", $<v.u.intval>4 );
			EmitBooleanExpr
			( 
				$<opnode>10, 
				tmpLabel,
				0 
			);
			EmitStmtLblNum( "exitloop" sympost "%d", $<v.u.intval>4 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<v.u.intval>5;


			/*
			** Restore true and false labels.
			*/

			FalseLabel = $<v.u.intval>3;
			TrueLabel = $<v.u.intval>2;


			$<returns>$ = NULL;
			_here;
		}
	;

SaveTrueLabel:
		{
			_here; 
			$<v.u.intval>$ = TrueLabel;
		}
	;

SaveFalseLabel:
		{
			_here; 
			$<v.u.intval>$ = FalseLabel;
		}
	;

EmitRepeatLabel:
		{

			_here;

			$<v.u.intval>$ = LblCntr;
			FalseLabel = LblCntr++;
			TrueLabel = $<v.u.intval>$;
			EmitStmtLblNum( "false" sympost "%d", FalseLabel );
			EmitStmtLblNum( "repeat" sympost "%d", FalseLabel );
			_here;
		}
	;



 /*
 ** Handle the REPEAT..UNTIL HLL statement here.
 **
 **	Syntax #2:
 **
 **	repeat
 **
 **		statements
 **
 **	until(#{ stmts }#);
 */

SingleStmt:
		repeatTkn		/* $1  */
		SaveTrueLabel	/* $2  */
		SaveFalseLabel	/* $3  */
		EmitRepeatLabel	/* $4  */
		SaveBreakLbl	/* $5  */
		Stmts			/* $6  */
		untilTkn		/* $7  */
		PutContinueLbl	/* $8  */
		Lparen			/* $9  */
		stmtsTkn		/* $10 */
		Stmts			/* $11 */
		endstmtsTkn		/* $12 */
		Rparen			/* $13 */
		{				/* $14 */

			_here;
			EmitStmtLblNum( "true" sympost "%d", TrueLabel );
			EmitStmtLblNum( "exitloop" sympost "%d", TrueLabel );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<v.u.intval>5;

			/*
			** Restore true and false labels.
			*/

			FalseLabel = $<v.u.intval>3;
			TrueLabel = $<v.u.intval>2;

			$<returns>$ = NULL;
			_here;
		}
	;









SaveBreakLbl:
		{
			_here; 
			$<v.u.intval>$ = BreakLbl;
			BreakLbl = $<v.u.intval>0;
		}
	;


PutContinueLbl:
		{
		
			_here;
			EmitStmtLblNum( "continue" sympost "%d", abs( BreakLbl ) );
			_here;
		}
	;

	
	


 /*
 ** Handle the foreach..endfor HLL statement here.
 **
 ** Syntax:
 **
 **		foreach iterator() do
 **
 **			statements
 **
 **		endfor;
 */


SingleStmt:
		callIteratorID
		{
			$<returns>$ = NULL;
		}
	;
	
SingleStmt:
		callIndirectIterator
		{
			_here; 
			$<returns>$ = NULL;
		}
	;
	
SingleStmt:
		callIndexedIterator
		{
			_here; 
			$<returns>$ = NULL;
		}
	;
	
callIterators:
		callIteratorID
		{
			_here; 
			$<returns>$ = NULL;
		}
		
	|	callIndirectIterator
		{
			_here; 
			$<returns>$ = NULL;
		}
		
	|	callIndexedIterator
		{
			_here; 
			$<returns>$ = NULL;
		}
	;
		
	
		
	
callIteratorID:
		foreachTkn			/* $1 */
		IterID				/* $2 */
		CallParameters		/* $3 */
		{					/* $4 */

			struct adrsYYS adrs;
			char symbol[ 256 ];

			_here;
			$<v.u.intval>$ = -( LblCntr++ );

			sprintf( symbol, "exitfor" sympost "%d", -$<v.u.intval>$ );
			PushStaticAdrs( symbol );
			EmitCallLabel( $<s>2->StaticName );
			push_r( reg_ebp );
			initAdrs( &adrs, reg_esp, -1, 0, 8 );
			EmitMov_m_r( &adrs, reg_ebp, 4 );
			_here;
		}
		SaveBreakLbl		/* $5 */
		GetDoTkn			/* $6 */
		Stmts				/* $7 */
		endforTkn			/* $8 */
		{					/* $9 */
			_here;
			EmitStmtLblNum( "continue" sympost "%d", abs( BreakLbl ) );
			pop_r( reg_ebp );
			ret_instr( 4 );
			EmitStmtLblNum( "exitfor" sympost "%d", -$<v.u.intval>4 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<v.u.intval>5;


			$<returns>$ = NULL;
			_here;
		}
	;



callIteratorID:
		foreachTkn			/* $1 */
		OverloadedID		/* $2 */
		'('					/* $3 */
		saveYYText			/* $4 */
		CollectParameters	/* $5 */
		')'					/* $6 */
		{					/* $7 */
			char			*pbStmt;
			struct	SymNode	*sig;
			char			msg[256];
			
			_here;
			$<returns>$ = NULL;
			LastRefdObject = $<s>4;
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level procedure calls are illegal in low and machine\n"
					"level language mode."
				);
				
			_endif
			
			// Search for the matching signature:
			
			sig =	matchSignature
					( 
						$<s>2, 
						$<collectedParms.parmCnt>5, 
						$<collectedParms.types>5, 
						$<collectedParms.pForms>5 
					);
					
			_if( sig == NULL )
			
				yyerror
				( 
					"No matching signature/parameter list for overloaded call."
				);
				
			_else	// We matched a signature
			
				// Emit the code to call the associated function:
				
				pbStmt = 	malloc2
							( 
								strlen( sig->u.ovld.procName ) +
								strlen( $<collectedParms.parms>5 )
								+256
							);
							
				sprintf
				(
					pbStmt,
					"foreach %s( %s )",
					sig->u.ovld.procName,
					$<collectedParms.parms>5
				);
				PushBackStr( pbStmt );
				$<returns>$ = pbStmt;
				
			_endif
			_if( $<collectedParms.parms>5 != NULL )
			
				free( $<collectedParms.parms>5 );
				
			_endif
			_if( $<collectedParms.types>5 != NULL )
			
				free( $<collectedParms.types>5 );
				
			_endif
			_here; 
		}
		
		// Must reinvoke SingleStmt to process the
		// string we just pushed back on the lexer input:
		
		callIterators	/* $8 */
		{
			$<returns>$ = $<returns>8;
			_if( $<returns>7 != NULL )
			
				free( $<returns>7 ); 
				
			_endif
		}
	;





 /*
 ** Handle "foreach clsvar.iter(parms) do" here.
 */

callIndirectIterator:
		foreachTkn				/* $1 */
		SimpleMemoryVar			/* $2 */
		FieldStuff				/* $3 */
		parenPushBack			/* $4 */
		SMVm1					/* $5 = FieldStuff's adrs.sym field */
		IndirectCallParameters	/* $6 */
		{						/* $7 */

			int  			useLEA = 1;
			int	 			offset = 0;
			struct	SymNode	*typ;
			char 			*size;
			struct adrsYYS	yysAdrs;
			char 			address[ 256 ];
			char 			adrs[ 256 ];
			char 			name[ 256 ];

			_here;

			/*
			** Set the attribute of the endfor label value.
			*/

			$<v.u.intval>$ = -( LblCntr++ );

			/*
			** Handle classes specially because we get to use the
			** ESI and EDI registers for class invocations.
			*/

			_if
			( 
					$<adrs.pType>2 == tClass

				||	(
							$<adrs.pType>2 == tArray
						&&	GetBaseType( $<adrs.Type>2 )->pType == tClass
					)

				||	(
							(
									$<adrs.pType>2 == tPointer
								||	(
											$<adrs.pType>2 == tArray
										&&	GetBaseType( $<adrs.Sym>2 )->pType 
														== tPointer
									)
							)
						&&	$<adrs.Sym>2->Base->pType == tClass
					)
			)

				/*
				** The assumption to this point is that we have
				** a class variable.  Check to see if what we've
				** really got is a pointer to a class object.  The
				** only difference in the code generation is "lea"
				** (for class vars) vs. "mov" (for class pointers).
				*/

				_if
				( 
						$<adrs.pType>2 == tPointer
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tPointer
						)
				)

					useLEA = 0;
					_if
					( 
							$<adrs.SymClass>2 == cParm 
						&&	$<adrs.pClass>2 == refp_pc 
					)
						yyerror
						( 
							"Cannot pass a pointer by reference here"
						);

					_endif

				_elseif
				(
						IsStaticClass( $<adrs.SymClass>2 ) 
					&&	$<adrs.StaticName>2 != NULL 
					&&	*$<adrs.StaticName>2 != '\0'
					&&	$<adrs.BaseReg>2 == NULL
					&&	$<adrs.IndexReg>2 == NULL
				)

					useLEA = 0;
					offset = 1;

				_endif

				/*
				** Emit the code that moves the address of the
				** object into the ESI register (this).
				** Note that the address of the object is
				** the SimpleMemoryVar, not the FieldStuff value.
				*/

				_if
				( 
						$<adrs.SymClass>2 == cVar 
					||	$<adrs.SymClass>2 == cStatic
				)

					_if( !useLEA )	// See if emitting MOV instr
					
						_if( offset )
						
							EmitMov_oa_r( &$<adrs>2, reg_esi ); 
						
						_else
						
							EmitMov_m_r( &$<adrs>2, reg_esi, 4 );
						
						_endif
					
					_else
					
						EmitLea_m_r2( &$<adrs>2, reg_esi );
						
					_endif

				_elseif( $<adrs.SymClass>2 == cParm )

					/*
					** Handle pass by value of the object here.
					*/

					_if( $<adrs.pClass>2 == valp_pc )

						// Must always be LEA instr at this point!
						
						EmitLea_m_r2( &$<adrs>2, reg_esi );

					/*
					** Handle pass by reference of the object
					** here.
					**
					**	BUG! This doesn't seem to work (parser never
					**  gets to this point).
					*/

					_elseif( $<adrs.pClass>2 == refp_pc )

						EmitMov_m_r( &$<adrs>2, reg_esi, 4 );
						initAdrs( &yysAdrs, reg_esi, -1, 0, 0 );
						EmitMov_m_r( &yysAdrs, reg_esi, 4 );

					/*
					** Don't allow the other parameter passing methods.
					*/

					_else

						yyerror
						(
							"Object pointer must be passed by "
							"value or reference"
						);

					_endif

				_else

					yyerror( "Expected class object" );

				_endif


				/*
				** If the field is a class iterator, issue the
				** call here.
				*/

				_if( $<adrs.SymClass>3 == cClassIter )

					char symbol[ 256 ];
					char adrs[ 256 ];
					char mem[ 256 ];

					/*
					** Since this is an iterator, the following
					** should always have some sort of value
					** (besides NULL).
					*/
					
					assert( $<adrs.Sym>3->StaticName != NULL );
					assert( $<adrs.Sym>3->u.proc.returns != NULL );

					/*
					** This is just a class procedure.
					** Call it directly.
					*/

					initAdrs( &yysAdrs, reg_esi, -1, 0, 0 );
					EmitMov_m_r( &yysAdrs, reg_edi, 4 );
					sprintf( symbol, "exitfor" sympost "%d", -$<v.u.intval>$ );
					PushStaticAdrs( symbol );
					initAdrs1( &yysAdrs, reg_edi, $<adrs.Sym>3->Offset );
					EmitCall_m( &yysAdrs );
					push_r( reg_ebp );
					initAdrs( &yysAdrs, reg_esp, -1, 0, 8 );
					EmitMov_m_r( &yysAdrs, reg_ebp, 4 );

				/*
				** If the field is neither a method nor a procedure,
				** then this is an illegal call.
				*/

				_else

					yyerror( "Expected an iterator" );

				_endif


			_else
			
				yyerror( "Expected a class iterator" );

			_endif

			FreeAdrs( &$<adrs>2 );
			FreeAdrs( &$<adrs>3 );
			_here;
		}

		SaveBreakLbl		/* $8  */
		GetDoTkn			/* $9  */
		Stmts				/* $10 */
		endforTkn			/* $11 */
		{					/* $12 */
			_here;
			EmitStmtLblNum( "continue" sympost "%d", abs( BreakLbl ) );
			pop_r( reg_ebp );
			ret_instr( 4 );
			EmitStmtLblNum( "exitfor" sympost "%d", -$<v.u.intval>7 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<v.u.intval>8;


			$<returns>$ = NULL;
			_here;
		}

	;


 


callIndirectIterator:
		foreachTkn				/* $1  */
		SimpleMemoryVar			/* $2  */
		FieldStuff				/* $3  */
		parenPushBack			/* $4  */
		ovldClassTkn			/* $5  */
		saveYYText				/* $6  */
		CollectParameters		/* $7  */
		')'						/* $8  */
		{						/* $9  */
			char			*pbStmt;
			struct	SymNode	*sig;
			
			_here;
			$<returns>$ = NULL;
			LastRefdObject = $<s>6;
			_if( langLevel <= low_level )
			
				yyerror
				( 
					"High-level procedure calls are illegal in low and machine\n"
					"level language mode."
				);
				
			_endif
			
			// Search for the matching signature:
			
			sig =	matchSignature
					( 
						$<adrs.Sym>3, 
						$<collectedParms.parmCnt>7, 
						$<collectedParms.types>7, 
						$<collectedParms.pForms>7 
					);
			_if( sig == NULL )
			
				yyerror
				( 
					"No matching signature/parameter list for overloaded call."
				);
				
			_else	// We matched a signature
			
				// Emit the code to call the associated function:
				
				pbStmt = 	malloc2
							( 
								strlen( sig->u.ovld.procName ) +
								strlen( $<collectedParms.parms>7 )
								+256
							);
							
				sprintf
				(
					pbStmt,
					"foreach %s( %s )",
					sig->u.ovld.procName,
					$<collectedParms.parms>7
				);
				PushBackStr( pbStmt );
				$<returns>$ = pbStmt;
				
			_endif
			_if( $<collectedParms.parms>7 != NULL )
			
				free( $<collectedParms.parms>7 );
				
			_endif
			_if( $<collectedParms.types>7 != NULL )
			
				free( $<collectedParms.types>7 );
				
			_endif
			_here; 
		}
		
		// Must reinvoke SingleStmt to process the
		// string we just pushed back on the lexer input:
		
		callIterators	/* $10 */
		{
			_here; 
			$<returns>$ = $<returns>10;
			_if( $<returns>9 != NULL )
			
				free( $<returns>9 ); 
				
			_endif
		}
	;


 

 /*
 ** foreach iter[index](parameters) do 
 ** is handled here.
 */


callIndexedIterator:
		foreachTkn				/* $1 */
		SimpleMemoryVar			/* $2 */
		FieldStuff				/* $3 */
		IndexAdrsMode			/* $4 */
		SMVm1					/* $5 */
		IndirectCallParameters	/* $6 */
		{						/* $7 */

			char *size;
			char address[ 256 ];
			char name[ 256 ];
			int  useLEA = 1;
			int  offset = 0;
			struct adrsYYS yysAdrs;

			_here;

			/*
			** Combine the index information with the base information
			** so we can use the code from the previous production.
			*/

			CombineAddresses( &$<adrs>2, &$<adrs>4 );


			/*
			** Set the attribute of the endfor label value.
			*/


			$<v.u.intval>$ = -( LblCntr++ );

			/*
			** Handle classes specially because we get to use the
			** ESI and EDI registers for class invocations.
			*/

			_if
			( 
					$<adrs.pType>2 == tClass

				||	(
							$<adrs.pType>2 == tArray
						&&	GetBaseType( $<adrs.Type>2 )->pType == tClass
					)

				||	(
							(
									$<adrs.pType>2 == tPointer
								||	(
											$<adrs.pType>2 == tArray
										&&	GetBaseType( $<adrs.Sym>2 )->pType 
														== tPointer
									)
							)
						&&	$<adrs.Sym>2->Base->pType == tClass
					)
			)

				/*
				** The assumption to this point is that we have
				** a class variable.  Check to see if what we've
				** really got is a pointer to a class object.  The
				** only difference in the code generation is "lea"
				** (for class vars) vs. "mov" (for class pointers).
				*/

				_if
				( 
						$<adrs.pType>2 == tPointer
					||	(
								$<adrs.pType>2 == tArray
							&&	GetBaseType( $<adrs.Type>2 )->pType == tPointer
						)
				)

					useLEA = 0;
					_if
					( 
							$<adrs.SymClass>2 == cParm 
						&&	$<adrs.pClass>2 == refp_pc 
					)
						yyerror
						( 
							"Cannot pass a pointer by reference here"
						);

					_endif

				_elseif
				(
						IsStaticClass( $<adrs.SymClass>2 ) 
					&&	$<adrs.StaticName>2 != NULL 
					&&	*$<adrs.StaticName>2 != '\0'
					&&	$<adrs.BaseReg>2 == NULL
					&&	$<adrs.IndexReg>2 == NULL
				)

					useLEA = 0;
					offset = 1;

				_endif

				/*
				** Emit the code that moves the address of the
				** object into the ESI register (this).
				** Note that the address of the object is
				** the SimpleMemoryVar, not the FieldStuff value.
				*/

				_if
				( 
						$<adrs.SymClass>2 == cVar
					||	$<adrs.SymClass>2 == cStatic 
				)
				
					char adrs[256];
				
				
					_if( !useLEA )	// See if emitting MOV instr
						
					
						_if( offset )
						
							
							EmitMov_oa_r( &$<adrs>2, reg_esi ); 
						
						_else
						
							EmitMov_m_r( &$<adrs>2, reg_esi, 4 );
						
						_endif
					
					_else
					
						EmitLea_m_r2( &$<adrs>2, reg_esi );
						
					_endif

				_elseif( $<adrs.SymClass>2 == cParm )

					/*
					** Handle pass by value of the object here.
					*/
					_if( $<adrs.pClass>2 == valp_pc )

						// Must always be an LEA instruction at this point!
						
						EmitLea_m_r2( &$<adrs>2, reg_esi );

					/*
					** Handle pass by reference of the object
					** here.
					** BUG! Does this code even get called?
					*/

					_elseif( $<adrs.pClass>2 == refp_pc )

						EmitMov_m_r( &$<adrs>2, reg_esi, 4 );
						initAdrs( &yysAdrs, reg_esi, -1, 0, 0 );
						EmitMov_m_r( &yysAdrs, reg_esi, 4 );

					/*
					** Don't allow the other parameter passing methods.
					*/

					_else

						yyerror
						(
							"Object pointer must be passed by "
							"value or reference"
						);

					_endif

				_else

					yyerror( "Expected class object" );

				_endif


				/*
				** If the field is a class iterator, issue the
				** call here.
				*/

				_if( $<adrs.SymClass>3 == cClassIter )

					char label[ 256 ];

					/*
					** Since this is a procedure, the following
					** should always have some sort of value
					** (besides NULL).
					*/
					
					assert( $<adrs.Sym>3->StaticName != NULL );
					assert( $<adrs.Sym>3->u.proc.returns != NULL );

					/*
					** This is just a class iterator.
					** Call it directly.
					*/

					initAdrs( &yysAdrs, reg_esi, -1, 0, 0 );
					EmitMov_m_r( &yysAdrs, reg_edi, 4 );
					sprintf
					( 
						label, 
						"exitfor" sympost "%d", 
						-$<v.u.intval>$
					);
					PushStaticAdrs( label );
					initAdrs1( &yysAdrs, reg_edi, $<adrs.Sym>3->Offset );
					EmitCall_m( &yysAdrs );
					
					push_r( reg_ebp );
					initAdrs( &yysAdrs, reg_esp, -1, 0, 8 );
					EmitMov_m_r( &yysAdrs, reg_ebp, 4 );
					 
				/*
				** If the field is neither a method nor a procedure,

				** then this is an illegal call.
				*/

				_else

					yyerror( "Expected an iterator" );

				_endif


			/*
			** If it wasn't a class variable, see if it is a procedure
			** pointer variable or a thunk.
			*/

			_else
			
				yyerror( "Expected a class iterator" );

			_endif

			FreeAdrs( &$<adrs>2 );
			FreeAdrs( &$<adrs>3 );
			_here;
		}

		SaveBreakLbl		/* $7  */
		GetDoTkn			/* $8  */
		Stmts				/* $9  */
		endforTkn			/* $10 */
		{					/* $11 */
			_here;
			EmitStmtLblNum( "continue" sympost "%d", abs( BreakLbl ) );
			pop_r( reg_ebp );
			ret_instr( 4 );
			EmitStmtLblNum( "exitfor" sympost "%d", -$<v.u.intval>7 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<v.u.intval>7;


			$<returns>$ = NULL;
			_here;
		}

	;


 



IterID:
		LocalIterID
		{
			_here; 
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}

	|	NonLocalIterID
		{
			_here; 
			$<s>$ = $<s>1;
			SetReferenced( $<s>1 );
		}
	;






 /*
 ** Handle the forever..endfor HLL statement here.
 **
 **	Syntax:
 **
 **	forever
 **
 **		statements
 **
 **	endfor;
 */

SingleStmt:
		foreverTkn		/* $1 */
		{				/* $2 */

			_here;

			/*
			** Allocate two labels:
			** One for the label at the beginning
			** of the do..until loop and one for the
			** exit location.
			*/

			$<v.u.intval>$ = LblCntr++;
			++LblCntr;
			EmitStmtLblNum( "forever" sympost "%d", $<v.u.intval>$ + 1 );
			EmitStmtLblNum( "continue" sympost "%d", $<v.u.intval>$ );
			_here;
		}
		SaveBreakLbl	/* $3 */
		Stmts			/* $4 */
		endforTkn		/* $5 */
		{				/* $6 */

			char label[ 256 ];

			_here;
			sprintf( label, "forever" sympost "%d", $<v.u.intval>2 + 1 );
			EmitJmpLabel( label );
			EmitStmtLblNum( "exitloop" sympost "%d", $<v.u.intval>2 );
			NewLn();

			/*
			** Restore the original BreakLbl value.
			*/

			BreakLbl = $<v.u.intval>3;


			$<returns>$ = NULL;
			_here;
		}
	;




 /*
 ** Handle the begin..end statement here.
 */
 
 SingleStmt:
	 	beginTkn		/* $1 */
		AnyID			/* $2 */
		Semicolon		/* $3 */
		{				/* $4 */

			struct	contextListType *p;
			char					msg[ 256 ];

			_here;
			
			/*
			** First, check to make sure this context doesn't already exist.
			** If it does, print an appropriate error message.
			*/
			
			p = contextList;
			_while( p != NULL )
			
				_if( _streq( $<neID.idStr>2, p->label ))
				
					sprintf
					(
						msg,
						"Context <<begin %s>> is already active",
						$<neID.idStr>2
					);
					yyerror( msg );
					break;
					
				_endif
				p = p->Next;
				
			_endwhile
			
			
			/*
			** Generate a MASM-compatible label for output to the
			** source file upon encountering the endcontext clause.
			*/
			
			sprintf
			(
				msg,
				"exit" sympost "%d",
				LblCntr++,
				$<neID.idStr>2
			);
			
			/*
			** Add the current context to the context list.
			*/
			
			p = malloc2( sizeof( struct contextListType ));
			p->Next = contextList;
			p->label = $<neID.idStr>2;
			p->StaticName = hlastrdup2( msg );
			p->LexLevel = CurLexLevel;
			p->IsProc = 0;
			p->HasDisplay = 1;
			p->SizeParms = 0;
			contextList = p;
			$<idStr>$ = p->StaticName;
			_here;
					
		}
		Stmts			/* $5 */
		endTkn			/* $6 */
		AnyID			/* $7 */
		{
		
			struct contextListType	*cNode;
		
			_here;
			
			/*
			** Be sure the labels after the context and endcontext
			** reserved words are the same.
			*/
			
			_if( _strne( $<neID.idStr>2, $<idStr>7 ))
			
				char msg[ 256 ];
				
				
				sprintf
				(
					msg,
					"Context label <<begin %s>> must match "
					"label <<end %s>>",
					$<neID.idStr>2, 
					$<idStr>7
				);
				yyerror( msg );

			_else
			
				EmitStmtLbl( $<idStr>4 );
				
				/*
				** This should be a redundant check, but just to be
				** sure, let's ensure the most recent context's label
				** matches the endcontext label as well.
				*/
				
				assert( _streq( $<idStr>4, contextList->StaticName ));
				
				
			_endif

			/*
			** Remove the current context from the context stack.
			*/
			
			assert( contextList != NULL );
			cNode = contextList;
			contextList = cNode->Next;

			assert( _streq( cNode->label, $<neID.idStr>2 ));
			free2( vss cNode->StaticName );	/* frees $<idStr>4 */
			free2( vss cNode->label );		/* frees $<neID.idStr>2 */
			
			free2( vss $<idStr>7 );
			$<returns>$ = NULL;
			_here;
		}
	;

	
	
 /*
 ** Handle the exit statement here.
 */
 
 SingleStmt:
 		exitTkn		/* $1 */
		AnyID		/* $2 */
		{			/* $3 */
		
			struct	contextListType	*cNode;
			char					msg[256];
			unsigned				AllHaveDisplays;
			
			_here;
			
			/*
			** Search for the leave ID in the context list.
			*/
	
			cNode = contextList;
			AllHaveDisplays = 1;
			_while( cNode != NULL && _strne( $<neID.idStr>2, cNode->label ))
			
				AllHaveDisplays = AllHaveDisplays && cNode->HasDisplay;
				cNode = cNode->Next;
				
			_endwhile

			_if( !AllHaveDisplays )

				ErrorNear
				(
					"Attempt to exit from a set of nested procedures\n"
					"but not all the (nested) procedures have a display",
					$<neID.idStr>2,
					__LINE__,
					__FILE__
				);

			_endif

			
			/*
			** cNode contains a non-NULL value if we found the
			** label in the context list.
			*/
			
			_if( cNode != NULL )
			
				_if
				( 
						cNode->IsProc == 0 
					||	(
								cNode->IsProc == 1
							&&	cNode->LexLevel == CurLexLevel
						)
				)

					EmitJmpLabel( cNode->StaticName );

						


				_elseif( cNode->IsProc == 1 )

					char mem[ 256 ];
					struct adrsYYS adrs;

					/*
					** If exiting from a non-local procedure,
					** then we've got to unwind the stack.
					** Grab the save stack frame pointer from
					** the display and use that for this purpose.
					*/

					initAdrs( &adrs, reg_ebp, -1, 0, -( cNode->LexLevel + 1 ) * 4 );
					EmitMov_m_r( &adrs, reg_esp, 4 );
					pop_r( reg_ebp );

					/*
					** Determine how many parameters to remove
					** from the stack on return.
					*/

					ret_instr( _ifx(cNode->SizeParms == 0, -1, cNode->SizeParms ));



				_elseif( cNode->IsProc == 2 )


					/*
					** Handle the main program here.
					*/

					EmitExit();

				_else

					/*
					** Catchall for unknown context IsProc values.
					*/

					assert( "Unknown context type" == NULL );

				_endif
				
			_else
				
				sprintf
				( 
					msg,								 
					"Currently not in context of <<begin %s>>..<<end %s>>\n"
					"or 'NOFRAME' option is active",
					$<neID.idStr>2,
					$<neID.idStr>2
				);
				ErrorNear
				(
					msg,
					$<neID.idStr>2,
					__LINE__,
					__FILE__
				);
				
			_endif
			free2( vss $<neID.idStr>2 );
			$<returns>$ = NULL;
			_here;
		}
	;


	

  /*
  ** Handle the "exitif( expr ) label" statement here.
  */
	
SingleStmt:	
		exitifTkn					/* $1 */
		Lparen						/* $2 */
		GetLbl						/* $3 */
		BoolExpr					/* $4 */
		Rparen						/* $5 */
		AnyID						/* $6 */
		{							/* $7 */
		
			struct	contextListType	*cNode;
			char	msg[256];
			char	mem[ 256 ];
			char	tmpLabel[32];
			struct adrsYYS yysAdrs;
			
			_here;
			
			/*
			** Search for the EXIT ID in the context list.
			*/
	
			cNode = contextList;
			_while( cNode != NULL && _strne( $<neID.idStr>6, cNode->label ))
			
				cNode = cNode->Next;
				
			_endwhile
			
			/*
			** cNode contains a non-NULL value if we found the
			** label in the context list.
			*/
			
			_if( cNode != NULL )
			
				_if
				( 
						cNode->IsProc == 0 
					||	(
								CurLexLevel == cNode->LexLevel
							&&	cNode->IsProc == 1
						)
				)

					EmitBooleanExpr
					( 
						$<opnode>4, 
						cNode->StaticName,
						1 
					);


				_elseif( cNode->IsProc == 1 )

					/*
					** Handle exits from a non-local procedure here.
					**
					** If exiting from a non-local procedure,
					** then we've got to unwind the stack.
					** Grab the save stack frame pointer from
					** the display and use that for this purpose.
					*/

					sprintf( tmpLabel, "exitif" sympost "%d", LblCntr );
					EmitBooleanExpr
					( 
						$<opnode>4, 
						tmpLabel,
						0 
					);


					initAdrs( &yysAdrs, reg_ebp, -1, 0, -( cNode->LexLevel + 1 ) * 4 );
					EmitMov_m_r( &yysAdrs, reg_esp, 4 );
					pop_r( reg_ebp );
					ret_instr( _ifx( cNode->SizeParms > 0, cNode->SizeParms, -1 ));
					EmitStmtLblNum( "exitif" sympost "%d", LblCntr++ );


				_elseif( cNode->IsProc == 2 )

					/*
					** Handle the main program here.
					*/

					EmitExit();					
					

				_else

					/*
					** Catchall for unknown context IsProc values.
					*/

					assert( "Unknown context type" == NULL );

				_endif
				
			_else
				
				sprintf
				( 
					msg,								 
					"Currently not in context of <<begin %s>>..<<end %s>>\n"
					"or 'NOFRAME' option is active",
					$<neID.idStr>6,
					$<neID.idStr>6
				);
				ErrorNear
				(
					msg,
					$<neID.idStr>6,
					__LINE__,
					__FILE__
				);
				
			_endif


			$<returns>$ = NULL;
			free2( vss $<neID.idStr>6 );
			_here;
		}
	;


	
GetLbl:
		{
			_here; 
			$<labels.l1.label1>$ = LblCntr;
			$<labels.l2.label2>$ = LblCntr;
			$<labels.l3.label3>$ = LblCntr++;
		}
	;
			
		
  /*
  ** Handle the "exitif( #{ stmts }# ) label;" statement here.
  */
	
SingleStmt:	
		exitifTkn					/* $1 */
		Lparen						/* $2 */
		stmtsTkn					/* $3 */
		exitifCode					/* $4 */
		Stmts						/* $5 */
		endstmtsTkn					/* $6 */
		Rparen						/* $7 */
		AnyID						/* $8 */
		{							/* $9 */
		
			struct	contextListType	*cNode;
			char	msg[256];
			char	mem[ 256 ];
			struct adrsYYS yysAdrs;
			
			
			_here;
			
			/*
			** Search for the leave ID in the context list.
			*/
	
			cNode = contextList;
			_while( cNode != NULL && _strne( $<neID.idStr>8, cNode->label ))
			
				cNode = cNode->Next;
				
			_endwhile
			
			
			/*
			** cNode contains a non-NULL value if we found the
			** label in the context list.
			*/
			
			_if( cNode != NULL )
			
				_if
				( 
						cNode->IsProc == 0 
					||	(
								CurLexLevel == cNode->LexLevel
							&&	cNode->IsProc == 1
						)
				)

					EmitStmtLblNum( "true" sympost "%d", TrueLabel );
					EmitJmpLabel( cNode->StaticName );
					EmitStmtLblNum( "false" sympost "%d", FalseLabel );

				_elseif( cNode->IsProc == 1 )

					/*
					** Handle exits from a non-local procedure here.
					**
					** If exiting from a non-local procedure,
					** then we've got to unwind the stack.
					** Grab the save stack frame pointer from
					** the display and use that for this purpose.
					*/

					EmitStmtLblNum( "true" sympost "%d", TrueLabel );
					initAdrs( &yysAdrs, reg_ebp, -1, 0, -( cNode->LexLevel + 1 ) * 4 );
					EmitMov_m_r( &yysAdrs, reg_esp, 4);
					pop_r( reg_ebp );
					ret_instr( _ifx( cNode->SizeParms > 0, cNode->SizeParms, -1 ));
					EmitStmtLblNum( "false" sympost "%d", FalseLabel );


				_elseif( cNode->IsProc == 2 )

					/*
					** Handle the main program here.
					*/

					EmitStmtLblNum( "true" sympost "%d", TrueLabel );
					EmitExit();
					EmitStmtLblNum( "false" sympost "%d", FalseLabel );


				_else

					/*
					** Catchall for unknown context IsProc values.
					*/

					assert( "Unknown context type" == NULL );

				_endif
				
			_else
				
				sprintf
				( 
					msg,								 
					"Currently not in context of <<begin %s>>..<<end %s>>\n"
					"or 'NOFRAME' option is active",
					$<neID.idStr>8,
					$<neID.idStr>8
				);
				ErrorNear
				(
					msg,
					$<neID.idStr>8,
					__LINE__,
					__FILE__
				);
				
			_endif
			TrueLabel = $<labels.l1.label1>4;
			FalseLabel = $<labels.l2.label2>4;
			$<returns>$ = NULL;
			free2( vss $<neID.idStr>8 );
			_here;
		}
	;


	
exitifCode:
		{
			_here; 
			$<labels.l1.label1>$ = TrueLabel;
			$<labels.l2.label2>$ = FalseLabel;
			TrueLabel = LblCntr++;
			FalseLabel = TrueLabel;
		}
	;

		

 /*
 ** Handle the break statement here.
 */

SingleStmt:
		breakTkn
		{
			char label[ 256 ];

			_here;
			_if( BreakLbl > 0 )


				sprintf( label, "exitloop" sympost "%d", abs( BreakLbl ) );
				EmitJmpLabel( label );

			_elseif( BreakLbl < 0 )

				/*
				** If BreakLbl is negative, then we're breaking
				** out of an iterator.  This is problematic because
				** we've got junk on the stack.  Be sure to issue
				** a warning.
				*/

				WarnNear
				(
					"Breaking out of a foreach loop leaves garbage\n"
					"on the stack",
					"break"
				);
				sprintf( label, "exitfor" sympost "%d", abs( BreakLbl ) );
				EmitJmpLabel( label );

			_else

				yyerror( "\"break\" appears outside a loop" );

			_endif
			$<returns>$ = NULL;
			_here;
		}
	;


 /*
 ** Handle the "breakif( expr );" statement here.
 */

SingleStmt:
		breakifTkn					/* $1 */
		Lparen						/* $2 */
		GetLbl						/* $3 */
		BoolExpr					/* $4 */
		Rparen						/* $5 */
		{							/* $6 */
		
			char tmpLabel[32];
			
			_here;
			_if( BreakLbl > 0 )

				sprintf( tmpLabel, "exitloop" sympost "%d", BreakLbl );
				EmitBooleanExpr
				(
					$<opnode>4,
					tmpLabel,
					1
				);

			_elseif( BreakLbl < 0 )

				/*
				** If BreakLbl is negative, then we're breaking
				** out of an iterator.  This is problematic because
				** we've got junk on the stack.  Be sure to issue
				** a warning.
				*/

				WarnNear
				(
					"Breaking out of a foreach loop leaves garbage "
					"on the stack",
					"breakif"
				);
				sprintf( tmpLabel, "exitfor" sympost "%d", abs( BreakLbl ));
				EmitBooleanExpr
				(
					$<opnode>4,
					tmpLabel,
					1
				);


			_else

				yyerror( "\"breakif\" appears outside a loop" );

			_endif
			$<returns>$ = NULL;
			_here;
		}
	;

	
		



 /*
 ** Handle the "breakif( #{ stmts }# );" statement here.
 */

SingleStmt:
		breakifTkn					/* $1 */
		Lparen						/* $2 */
		stmtsTkn					/* $3 */
		breakifCode					/* $4 */
		Stmts						/* $5 */
		endstmtsTkn					/* $6 */
		Rparen						/* $7 */
		{							/* $8 */
			_here;
			_if( BreakLbl > 0 )

				EmitBackPatchddc
				(
					"true" sympost "%d",
					TrueLabel,
					"exitloop" sympost "%d",
					BreakLbl,
					"breakif"
				);
				EmitStmtLblNum( "false" sympost "%d", FalseLabel );

			_elseif( BreakLbl < 0 )

				/*
				** If BreakLbl is negative, then we're breaking
				** out of an iterator.  This is problematic because
				** we've got junk on the stack.  Be sure to issue
				** a warning.
				*/

				WarnNear
				(
					"Breaking out of a foreach loop leaves garbage "
					"on the stack",
					"breakif"
				);
				EmitBackPatchddc
				(
					"true" sympost "%d",
					TrueLabel,
					"exitloop" sympost "%d",
					abs( BreakLbl ),
					"breakif"
				);
				EmitStmtLblNum( "false" sympost "%d", FalseLabel );


			_else

				yyerror( "\"breakif\" appears outside a loop" );

			_endif
			$<returns>$ = NULL;
			TrueLabel = $<labels.l1.label1>4;
			FalseLabel = $<labels.l2.label2>4;
			_here;
		}
	;


breakifCode:
		{
			_here; 
			$<labels.l1.label1>$ = TrueLabel;
			$<labels.l2.label2>$ = FalseLabel;
			TrueLabel = LblCntr++;
			FalseLabel = TrueLabel;
		}
	;
	
		

 /*
 ** Handle the continue and continueif statements here.
 */

SingleStmt:
		continueTkn
		{
			char label[ 256 ];
			_here;
			_if( BreakLbl != 0 )

				sprintf( label, "continue" sympost "%d", abs( BreakLbl ) );
				EmitJmpLabel( label );

			_else

				yyerror( "\"continue\" appears outside a loop" );

			_endif
			$<returns>$ = NULL;
			_here;
		}
	;



SingleStmt:
		continueifTkn				/* $1 */
		Lparen						/* $2 */
		GetLbl						/* $3 */
		BoolExpr					/* $4 */
		Rparen						/* $5 */
		{							/* $6 */
			char	tmpLabel[32];
			_here;
			_if( BreakLbl != 0 )

				sprintf( tmpLabel, "continue" sympost "%d", abs( BreakLbl ));
				EmitBooleanExpr
				(
					$<opnode>4,
					tmpLabel,
					1
				);


			_else

				yyerror( "\"continueif\" appears outside a loop" );

			_endif
			$<returns>$ = NULL;
			_here;
		}
	;

SingleStmt:
		continueifTkn				/* $1 */
		Lparen						/* $2 */
		stmtsTkn					/* $3 */
		continueifCode				/* $4 */
		Stmts						/* $5 */
		endstmtsTkn					/* $6 */
		Rparen						/* $7 */
		{							/* $8 */
			_here;
			_if( BreakLbl != 0 )

				EmitBackPatchddc
				(
					"true" sympost "%d",
					TrueLabel,
					"continue" sympost "%d",
					abs( BreakLbl ),
					"continueif"
				);
				EmitStmtLblNum( "false" sympost "%d", FalseLabel );

			_else

				yyerror( "\"continueif\" appears outside a loop" );

			_endif
			TrueLabel = $<labels.l1.label1>4;
			FalseLabel = $<labels.l2.label2>4;
			$<returns>$ = NULL;
			_here;
		}
	;

	


continueifCode:
		{
			_here; 
			$<labels.l1.label1>$ = TrueLabel;
			$<labels.l2.label2>$ = FalseLabel;
			TrueLabel = LblCntr++;
			FalseLabel = TrueLabel;
		}
	;
		





/**************************************************************************
**
** Handle the JF (jmp if false) and JT (jmp if true) pseudo-instructions
** here.
*/


FalseParm:
		{
			_here; 
			$<v.u.unsval>$ = 0;
		}
	;


TrueParm:
		{
			_here; 
			$<v.u.unsval>$ = 1;
		}
	;

SingleStmt:
		jfTkn			/* $1 */
		Lparen			/* $2 */
		BoolExpr		/* $3 */
		Rparen			/* $4 */
		AnyID			/* $5 */
		FalseParm		/* $6 */
		EmitJmp			/* $7 */
		{
			_here; 
			$<returns>$ = NULL;
		}
	;

SingleStmt:
		jtTkn			/* $1 */
		Lparen			/* $2 */
		BoolExpr		/* $3 */
		Rparen 			/* $4 */
		AnyID			/* $5 */
		TrueParm		/* $6 */
		EmitJmp			/* $7 */
		{
			_here; 
			$<returns>$ = NULL;
		}
	;




SingleStmt:
		jtTkn			/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		jtfCode			/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		AnyID			/* $8  */
		{				/* $9  */

			struct SymNode			*sym;
			struct StaticListType	*sList;
			struct FwdRefLabelType	*temp;
			struct FwdRefLabelType	*flist;
			char 					target[ 256 ];


			_here; 
			sym = $<neID.s>8;

			/*
			** See if "AnyID" ($8 above) is "true" or "false":
			*/

			_if
			(
					sym == &true_ste
			)

				/*
				** Make sure it's legal to JT to the "true" label.
				*/

				_if( $<labels.l1.trueTarget>4 != -1 )

					EmitBackPatchddc
					(
						"true" sympost "%d",
						TrueLabel,
						"true"  sympost "%d",
						$<labels.l1.trueTarget>4,
						"JT"
					);
					EmitStmtLblNum( "false" sympost "%d", FalseLabel ); 
					
				_else

					yyerror( "\"true\" cannot be used as a label here" );

				_endif


			_elseif
			(
					sym == &false_ste
			)

				/*
				** Make sure it's legal to JT to the "false" label.
				*/

				_if( $<labels.l2.falseTarget>4 != -1 )

					EmitBackPatchddc
					(
						"true" sympost "%d",
						TrueLabel,
						"false" sympost "%d",
						$<labels.l2.falseTarget>4,
						"JT"
					);
					EmitStmtLblNum( "false" sympost "%d", FalseLabel ); 


				_else

					yyerror( "\"false\" cannot be used as a label here" );

				_endif


			/*
			** Okay, AnyID is not "true" or "false", make sure it's a legal
			** statement label and emit a jump to it.
			*/

			_elseif
			(
					sym != NULL 
				&&	sym->LexLevel == CurLexLevel
				&&	sym->SymClass != cLabel
			)

				/*
				** Attempting to jump to something that is not a label.
				*/

				yyerror( "Illegal branch target" );

			_elseif
			( 
					sym != NULL 
				&&	sym->LexLevel == CurLexLevel
				&&	sym->SymClass == cLabel
			)

				/*
				** We've got a jump to a label that is already defined.
				*/

					EmitBackPatchds
					(
						"true" sympost "%d",
						TrueLabel,
						sym->StaticName
					);
					EmitStmtLblNum( "false" sympost "%d", FalseLabel ); 

			_else

				/*
				** We've got a jump to a label that has yet to be defined
				** in this procedure (note that the label could be defined
				** outside the current procedure as anything, but we'll
				** defer judgement on this until we finish processing the
				** current procedure).
				*/



				/*
				** First, let's see if there is already a reference
				** to this particular identifier so we can use the
				** existing StaticName.
				*/

				flist = FwdLabelsList;
				_while( flist != NULL )

					_breakif( _streq( $<neID.idStr>8, flist->label ));
					flist = flist->Next;

				_endwhile

				_if( flist != NULL )

					flist->referenced = 1;
					
					/*
					** We found the symbol in the forward reference
					** list.  So just use the StaticName field of the
					** symbol we located as the target label.
					*/

					EmitBackPatchds
					(
						"true" sympost "%d",
						TrueLabel,
						flist->StaticName
					);
					EmitStmtLblNum( "false" sympost "%d", FalseLabel ); 

				_else

					/*
					** We didn't find the symbol in the forward reference
					** list, so add it to that list.
					*/


					temp = malloc2( sizeof( struct FwdRefLabelType ));
					temp->Next = FwdLabelsList;
					temp->label = hlastrdup2( $<neID.idStr>8 );
					temp->lexLevel = CurLexLevel;
					sprintf( target, "%s" sympost "%d", $<neID.idStr>8, LblCntr++ );
					temp->StaticName = hlastrdup2( target );
					temp->isExternal = 0;
					temp->referenced = 0;
					FwdLabelsList = temp;
					EmitBackPatchds
					(
						"true" sympost "%d",
						TrueLabel,
						temp->StaticName
					);
					EmitStmtLblNum( "false" sympost "%d", FalseLabel ); 

				_endif

			_endif

			TrueLabel = $<labels.l1.trueTarget>4;
			FalseLabel = $<labels.l2.falseTarget>4;
			$<returns>$ = NULL;
			_here; 
		}
	;





SingleStmt:
		jfTkn			/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		jtfCode			/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		AnyID			/* $8  */
		{				/* $10 */

			struct SymNode *sym;

			_here; 
			sym = lookup( $<neID.idStr>8, 1 );

			/*
			** See if "AnyID" ($8 above) is "true" or "false":
			*/

			_if
			(
					sym == &true_ste
			)

				/*
				** Make sure it's legal to JF to the "true" label.
				*/

				_if( $<labels.l1.trueTarget>4 != -1 )

					EmitBackPatchddc
					(
						"false" sympost "%d",
						TrueLabel,
						"true" sympost "%d",
						$<labels.l1.trueTarget>4,
						"JF"
					);
					EmitStmtLblNum( "true" sympost "%d", FalseLabel ); 

				_else

					yyerror( "\"true\" cannot be used as a label here" );

				_endif


			_elseif
			(
					sym == &false_ste
			)

				/*
				** Make sure it's legal to JT to the "false" label.
				*/

				_if( $<labels.l2.falseTarget>4 != -1 )

					EmitBackPatchddc
					(
						"false" sympost "%d",
						TrueLabel,
						"false" sympost "%d",
						$<labels.l2.falseTarget>4,
						"JF"
					);
					EmitStmtLblNum( "true" sympost "%d", FalseLabel ); 


				_else

					yyerror( "\"false\" cannot be used as a label here" );

				_endif


			/*
			** Okay, AnyID is not "true" or "false", make sure it's a legal
			** statement label and emit a jump to it.
			*/

			_elseif
			(
					sym != NULL 
				&&	sym->LexLevel == CurLexLevel
				&&	sym->SymClass != cLabel
			)

				/*
				** Attempting to jump to something that is not a label.
				*/

				yyerror( "Illegal branch target" );

			_elseif
			( 
					sym != NULL 
				&&	sym->LexLevel == CurLexLevel
				&&	sym->SymClass == cLabel
			)

				/*
				** We've got a jump to a label that is already defined.
				*/

					EmitBackPatchds
					(
						"false" sympost "%d",
						TrueLabel,
						sym->StaticName
					);
					EmitStmtLblNum( "true" sympost "%d", FalseLabel ); 

			_else

				/*
				** We've got a jump to a label that has yet to be defined
				** in this procedure (note that the label could be defined
				** outside the current procedure as anything, but we'll
				** defer judgement on this until we finish processing the
				** current procedure).
				*/

				struct FwdRefLabelType *flist;


				/*
				** First, let's see if there is already a reference
				** to this particular identifier so we can use the
				** existing StaticName.
				*/

				flist = FwdLabelsList;
				_while( flist != NULL )

					_breakif( _streq( $<neID.idStr>8, flist->label ));
					flist = flist->Next;

				_endwhile

				_if( flist != NULL )

					flist->referenced = 1;
					
					/*
					** We found the symbol in the forward reference
					** list.  So just use the StaticName field of the
					** symbol we located as the target label.
					*/

					EmitBackPatchds
					(
						"false" sympost "%d",
						TrueLabel,
						flist->StaticName
					);
					EmitStmtLblNum( "true" sympost "%d", FalseLabel ); 

				_else
				
					char target[ 256 ];

					/*
					** We didn't find the symbol in the forward reference
					** list, so add it to that list.
					*/

					struct FwdRefLabelType *temp;

					temp = malloc2( sizeof( struct FwdRefLabelType ));
					temp->Next = FwdLabelsList;
					temp->label = hlastrdup2( $<neID.idStr>8 );
					temp->lexLevel = CurLexLevel;
					temp->isExternal = 0;
					temp->referenced = 1;
					sprintf( target, "%s" sympost "%d", $<neID.idStr>8, LblCntr++ );
					temp->StaticName = hlastrdup2( target );
					FwdLabelsList = temp;
					EmitBackPatchds
					(
						"false" sympost "%d",
						TrueLabel,
						temp->StaticName
					);
					EmitStmtLblNum( "true" sympost "%d", FalseLabel ); 



				_endif

			_endif

			TrueLabel = $<labels.l1.trueTarget>4;
			FalseLabel = $<labels.l2.falseTarget>4;
			$<returns>$ = NULL;
			_here; 
		}
	;

 
 

jtfCode:
		{
			_here; 
			$<labels.l1.trueTarget>$ = TrueLabel;
			$<labels.l2.falseTarget>$ = FalseLabel;
			TrueLabel = LblCntr;
			FalseLabel = LblCntr++;
		}
	;





/**************************************************************************
**
** Handle the JF (jmp if false) and JT (jmp if true) pseudo-instructions
** here.
*/

	/*
	** EmitJmp- Emits the appropriate jump and macro invocation
	** used by the JT and JF instructions.
	**
	**	Parameters:
	**
	**		$0:		1 if JT, 0 if JF
	**		$-1:	String containing target label.
	**		$-3:	<opnode> value for expression.
	*/

EmitJmp:
		{

			/*
			** We've got to look up the target label to see
			** if it already exists.  If not, we've got to add
			** it to the labels forward reference list.
			*/

			struct StaticListType	*sList;
			char					*jmp;
			struct FwdRefLabelType	*flist;
			struct FwdRefLabelType	*temp;
			struct SymNode			*sym;
			char					target[256];
			char					tmpLabel[32];

			assert( $<neID.idStr>-1 != NULL );

			_here; 
			sym = $<neID.s>-1;
			_if
			(
					sym == &true_ste
			)

				_if( TrueLabel != -1 )

					sprintf
					(
						target,
						"true" sympost "%d",
						TrueLabel
					);

				_else

					yyerror( "\"true\" cannot be used as a label here" );

				_endif


			_elseif
			(
					sym == &false_ste
			)

				_if( FalseLabel != -1 )

					sprintf
					(
						target,
						"false" sympost  "%d",
						FalseLabel
					);

				_else

					yyerror( "\"false\" cannot be used as a label here" );

				_endif


			_elseif
			(
					sym != NULL 
				&&	sym->LexLevel == CurLexLevel
				&&	sym->SymClass != cLabel
			)

				/*
				** Attempting to jump to something that is not a label.
				*/

				yyerror( "Illegal branch target" );

			_elseif
			( 
					sym != NULL 
				&&	sym->LexLevel == CurLexLevel
				&&	sym->SymClass == cLabel
			)

				/*
				** We've got a jump to a label that is already defined.
				*/

				strcpy( target, sym->StaticName );

			_else

				/*
				** We've got a jump to a label that has yet to be defined
				** in this procedure (note that the label could be defined
				** outside the current procedure as anything, but we'll
				** defer judgement on this until we finish processing the
				** current procedure).
				**
				** Also note that compiler defined labels always begin with
				** a question mark, we'll just ignore those and assume that
				** the compiler will eventually emit the label.
				*/



				/*
				** First, let's see if there is already a reference
				** to this particular identifier so we can use the
				** existing StaticName.
				*/


				flist = FwdLabelsList;
				_while( flist != NULL )

					_breakif( _streq( $<neID.idStr>-1, flist->label ));
					flist = flist->Next;

				_endwhile

				_if( flist != NULL )

					flist->referenced = 1;
					
					/*
					** We found the symbol in the forward reference
					** list.  So just use the StaticName field of the
					** symbol we located as the target label.
					*/

					strcpy( target, flist->StaticName );

				_else


					// See if this symbol is in the StaticList. Use the
					// existing static name if it is:
					
					sList = searchStatic( $<neID.idStr>-1 );
					_if( sList == NULL )
					
						/*
						** We didn't find the symbol in the static list,
						** so add it to the forward reference list
						*/


						temp = malloc2( sizeof( struct FwdRefLabelType ));
						temp->Next = FwdLabelsList;
						temp->label = hlastrdup2( $<neID.idStr>-1 );
						temp->lexLevel = CurLexLevel;
						temp->isExternal = 0;
						temp->referenced = 1;
						sprintf
						( 
							target, 
							"%s" sympost "%d", 
							$<neID.idStr>-1, 
							LblCntr++ 
						);
						temp->StaticName = hlastrdup2( target );
						FwdLabelsList = temp;
						
					_else
					
						// It was in the static list, so use the existing
						// static name:

						strcpy( target, sList->StaticName );
						
					_endif

				_endif

			_endif


			/*
			** Emit the instruction for this conditional jump instruction.
			*/

			EmitBooleanExpr
			(
				$<opnode>-3,
				target,
				$<v.u.unsval>0
			);

			free2( vss $<neID.idStr>-1 );
			_here; 
		}
	;







/**************************************************************************


 /*
 ** Handle the IF HLL statement here.
 **
 ** Syntax #1:
 **
 **	if ( BoolExpr ) then
 **
 **		statments
 **
 **	endif
 **
 **
 **	Note: throughout the IF section, the following LABELS
 **		  attributes are used as follows:
 **
 **			labels.l1.trueTarget-	True label
 **			labels.l2.falseTarget-	False label
 **			labels.l3.exitTarget-	endif label
 */

SingleStmt:
		ifTkn						/* $1  */
		Lparen						/* $2  */
		GetLbl						/* $3  */
		BoolExpr					/* $4  */
		Rparen						/* $5  */
		GetThen						/* $6  */
		EmitSkipThen				/* $7  */
		Stmts						/* $8  */
		endifTkn					/* $9  */
		{							/* $10 */

			/*
			** Emit the target label for the conditional jump
			** output by "EmitSkipThen" above.
			*/

			_here; 
			EmitStmtLblNum( "false" sympost "%d", $<v.u.unsval>7 );
			$<returns>$ = NULL;
		}
	;



	/*
	** EmitSkipThen-
	**
	**	Emits the conditional jump instruction needed to skip
	**	over the "then" portion of some code if a condition is
	**	false.  Also returns the target label as the intval
	**	attribute.
	*/

EmitSkipThen:
		{
			char tmpLabel[32];
			
			_here;
			$<v.u.unsval>$ = $<labels.l2.falseTarget>-3;
			sprintf( tmpLabel, "false" sympost "%d", $<v.u.unsval>$);
			EmitBooleanExpr
			(
				$<opnode>-2,
				tmpLabel,
				0
			);
			_here;
		}
	;





 /*
 ** Handle the IF HLL statement here.
 **
 ** Syntax #2:
 **
 **	if ( BoolExpr ) then
 **
 **		statments
 **
 ** else
 **
 **		statements
 **
 **	endif
 */

SingleStmt:
		ifTkn			/* $1  */
		Lparen			/* $2  */
		GetLbl			/* $3  */
		BoolExpr		/* $4  */
		Rparen			/* $5  */
		GetThen			/* $6  */
		EmitSkipThen	/* $7  */
		Stmts			/* $8  */
		elseTkn			/* $9  */
		{				/* $10 */

			char label[ 256 ];

			_here; 
			sprintf( label, "endif" sympost "%d", $<labels.l3.exitTarget>3 );
			EmitJmpLabel( label );
			EmitStmtLblNum( "false" sympost "%d", $<v.u.unsval>7 );
			_here; 
		}
		Stmts			/* $13 */
		endifTkn		/* $14 */
		{				/* $15 */
			/*
			** Emit the target label for the conditional jump
			** output by semantic action $10, above.
			*/

			_here; 
			EmitStmtLblNum( "endif" sympost "%d", $<labels.l3.exitTarget>3 );
			$<returns>$ = NULL;
			_here; 
		}
	;






 /*
 ** Handle the IF HLL statement here.
 **
 ** Syntax #3:
 **
 **	if ( BoolExpr ) then
 **
 **		statments
 **
 ** elseif( BoolExpr) then
 **
 **		statements
 **
 **	endif
 */

SingleStmt:
		ifTkn			/* $1  */
		Lparen			/* $2  */
		GetLbl			/* $3  */
		BoolExpr		/* $4  */
		Rparen			/* $5  */
		GetThen			/* $6  */
		EmitSkipThen	/* $7  */
		Stmts			/* $8  */

		ExitIfLabel7	/* $9	Emit jmp to exit THEN & false label	*/
		ElseIFs			/* $10 */

		endifTkn		/* $11 */
		{				/* $12 */
			/*
			** Emit the target label for the conditional jump
			** output by "ExitIfLabel" and used by "ElseIfs" above.
			*/

			_here; 
			EmitStmtLblNum( "endif" sympost "%d", $<labels.l3.exitTarget>3 );
			$<returns>$ = NULL;
			_here; 
		}
	;


ExitIfLabel7: 
		{ 
			char label[ 256 ];

			_here; 
			$<labels.l1.trueTarget>$ = $<labels.l1.trueTarget>-5;		// true label
			$<labels.l2.falseTarget>$ = $<labels.l2.falseTarget>-5;	// false label
			$<labels.l3.exitTarget>$ = $<labels.l3.exitTarget>-5;		// exit label

			sprintf( label, "endif" sympost "%d", $<labels.l3.exitTarget>$ );
			EmitJmpLabel( label );
		}
	;

















 /*
 ** Handle the IF HLL statement here.
 **
 ** Syntax #4:
 **
 **	if ( BoolExpr ) then
 **
 **		statments
 **
 ** elseif( BoolExpr) then
 **
 **		statements
 **
 **	else
 **
 **		statements
 **
 **	endif
 */

SingleStmt:
		ifTkn			/* $1  */
		Lparen			/* $2  */
		GetLbl			/* $3  */
		BoolExpr		/* $4  */
		Rparen			/* $5  */
		GetThen			/* $6  */
		EmitSkipThen	/* $7  */
		Stmts			/* $8  */

		ExitIfLabel7	/* $9  False and Exitif parameters for ELSEIFs2	*/
		ElseIFs2		/* $10 */

		elseTkn			/* $11 */
		Stmts			/* $12 */
		endifTkn		/* $13 */
		{				/* $14 */
			/*
			** Emit the target label for the conditional jump
			** output by "ExitIfLabel" and used by "ElseIfs" above.
			*/

			_here; 
			EmitStmtLblNum( "endif" sympost "%d", $<labels.l3.exitTarget>3 );
			$<returns>$ = NULL;
		}
	;








 /*
 ** Handle the IF HLL statement here.
 **
 ** Syntax #5:
 **
 **	if({ statements }) then
 **
 **		statments
 **
 **	endif
 */


ifCode:
		{
			_here; 
			$<labels.saveTrue>$ = TrueLabel;
			$<labels.saveFalse>$ = FalseLabel;
			$<labels.l1.trueTarget>$ = LblCntr;
			$<labels.l2.falseTarget>$ = LblCntr;
			$<labels.l3.exitTarget>$ = LblCntr;
			TrueLabel = LblCntr++;
			FalseLabel = TrueLabel;
		}
	;



SingleStmt:
		ifTkn			/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		ifCode			/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		GetThen			/* $8  */
		EmitTrueLabel4	/* $9  */
		Stmts			/* $10 */
		endifTkn		/* $11 */
		{				/* $12 */
			/*
			** Emit the target label for SetFalseLabel.
			*/

			_here; 
			EmitStmtLblNum( "false" sympost "%d", $<labels.l2.falseTarget>9 );
			$<returns>$ = NULL;
		}
	;


EmitTrueLabel4:
		{
			_here;
			EmitStmtLblNum( "true" sympost "%d", TrueLabel );


			/*
			** Do not allow further use of "true" or "false"
			** as jump target labels (at least, not the labels
			** associated with this if statement).  However,
			** we do have to save FalseLabel's value so we can
			** emit the label later.
			*/

			$<labels.l1.trueTarget>$ = TrueLabel;
			$<labels.l2.falseTarget>$ = FalseLabel;
			FalseLabel = $<labels.saveFalse>-4;
			TrueLabel = $<labels.saveTrue>-4;
		}

	;





 /*
 ** Handle the IF HLL statement here.
 **
 ** Syntax #6:
 **
 **	if( #{ statements }#) then
 **
 **		statments
 **
 **	else
 **
 **		statements
 **
 **	endif
 */

SingleStmt:
		ifTkn			/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		ifCode			/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		GetThen			/* $8  */
		EmitTrueLabel4	/* $9  */
		Stmts			/* $10 */
		elseTkn			/* $11 */
		{				/* $12 */

			_here; 
			$<labels.l2.falseTarget>$ = $<labels.l2.falseTarget>9;
		}
		EmitFalseLabel	/* $13 */
		Stmts			/* $14 */
		endifTkn		/* $15 */
		{				/* $16 */
			/*
			** Emit the target label for SetFalseLabel.
			*/

			_here;
			EmitStmtLblNum( "endif" sympost "%d", $<labels.l3.exitTarget>13 );
			$<returns>$ = NULL;
			(void) $<labels.l2.falseTarget>12;	// shut up bison
			_here;
		}
	;







 /*
 ** Handle the IF HLL statement here.
 **
 ** Syntax #7:
 **
 **	if(#{ statements }#) then
 **
 **		statments
 **
 **	elseif( --- )
 **
 **		statements
 **
 **	endif
 */

SingleStmt:
		ifTkn			/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		ifCode			/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		GetThen			/* $8  */
		EmitTrueLabel4	/* $9  */
		Stmts			/* $10 */

		ExitIfLabel6	/* $11 False and EXITIF parameters to ELSEIFs	*/
		ElseIFs			/* $12 */

		endifTkn		/* $13 */
		{				/* $14 */
			/*
			** Emit the target label for SetFalseLabel.
			*/

			_here;
			EmitStmtLblNum( "endif" sympost "%d", $<labels.l3.exitTarget>4 );
			$<returns>$ = NULL;
			_here;
		}
	;



ExitIfLabel6: 
		{
			char label[ 256 ];

			_here; 
			$<labels.l2.falseTarget>$ = $<labels.l3.exitTarget>-6;
			$<labels.l3.exitTarget>$ = $<labels.l3.exitTarget>-6;

			sprintf( label, "endif" sympost "%d", $<labels.l3.exitTarget>$ );
			EmitJmpLabel( label );
			_here;
		}
	;





 /*
 ** Handle the IF HLL statement here.
 **
 ** Syntax #8:
 **
 **	if( #{ statements }#) then
 **
 **		statments
 **
 **	elseif( --- )
 **
 **		statements
 **
 **	else
 **
 **		statements
 **
 **	endif
 */

				SingleStmt:
		ifTkn			/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		ifCode			/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		GetThen			/* $8  */
		EmitTrueLabel4	/* $9  */
		Stmts			/* $10 */

		ExitIfLabel6	/* $12 */
		ElseIFs2		/* $13 */

		elseTkn			/* $14 */
		Stmts			/* $15 */
		endifTkn		/* $16 */
		{				/* $17 */
			/*
			** Emit the target label for SetFalseLabel.
			*/

			_here;
			EmitStmtLblNum( "endif" sympost "%d", $<labels.l3.exitTarget>4 );
			$<returns>$ = NULL;
			_here;
		}
	;






 /*
 ** ElseIFs-
 **
 **	Handle a chain of elseif statements when there is no
 ** else clause.
 */

ElseIF:
		elseifTkn
		SavePosn
	;
 /*
 ** This production handles elseif(boolexpr) that isn't the
 ** last elseif in a chain of elseifs.
 */

ElseIFs:
		ElseIF			/* $1  */
		Lparen			/* $2  */
		PutElseIfSTL	/* $3  */
		GetLbl			/* $4  */
		BoolExpr		/* $5  */
		Rparen			/* $6  */
		GetThen			/* $7  */
		EmitSkipThen	/* $8  */

		Stmts			/* $9  */

		ExitIfLabel5_9	/* $10 Copies $4 here and jmps to it.			*/
		ElseIFs			/* $11 */
	;

ExitIfLabel5_9:
		{
			char label[ 256 ];

			_here; 
			$<labels.l2.falseTarget>$ = $<labels.l2.falseTarget>-5;
			$<labels.l3.exitTarget>$ = $<labels.l3.exitTarget>-9;
			sprintf( label, "endif" sympost "%d", $<labels.l3.exitTarget>$ );
			EmitJmpLabel( label );
			_here; 
		}
	;


 /*
 ** This expression handles the last (or only) elseif(expr).
 */

ElseIFs:
		ElseIF			/* $1  */
		Lparen			/* $2  */
		PutElseIfSTL	/* $3  */
		GetLbl			/* $4  */
		BoolExpr		/* $5  */
		Rparen			/* $6  */
		GetThen			/* $7  */
		EmitSkipThen	/* $8  */
		Stmts			/* $9  */
		{				/* $10 */


			/*
			** Emit the target label for the conditional jump
			** output by "EmitSkipThen" above.
			*/
			
			_here;
			EmitStmtLblNum( "false" sympost "%d", $<labels.l2.falseTarget>4 );
			_here;
		}
	;

 /*
 ** This production handles all but the last 
 ** "elseif(#{ stmts }#) then " clauses in an elseif chain.
 */

ElseIFs:
		ElseIF			/* $1  											*/
		Lparen			/* $2											*/
		stmtsTkn		/* $3  											*/
		elseifCode4		/* $4  Sets up True/False labels!				*/
		Stmts			/* $5  											*/
		endstmtsTkn		/* $6  											*/
		Rparen			/* $7											*/
		GetThen			/* $8											*/
		EmitTrueLabel4	/* $9  Emits true label							*/
		Stmts			/* $10  										*/

		ExitIfLabel6_10	/* $11 ELSEIFs' false and exitif parameters.	*/
		ElseIFs			/* $12 Handle additional elseifs				*/
	;

   

elseifCode4:
		{
			_here;
			$<labels.saveTrue>$ = TrueLabel;
			$<labels.saveFalse>$ = FalseLabel;
			$<labels.l1.trueTarget>$ = LblCntr;
			$<labels.l2.falseTarget>$ = LblCntr;
			$<labels.l3.exitTarget>$ = $<labels.l3.exitTarget>-3;
			TrueLabel = LblCntr++;
			FalseLabel = TrueLabel;
			EmitStmtLblNum( "false" sympost "%d", $<labels.l2.falseTarget>-3 );
			_here;
		}
	;


ExitIfLabel6_10: 
		{
			char label[ 256 ];

			_here; 
			$<labels.l2.falseTarget>$ = $<labels.l2.falseTarget>-6;
			$<labels.l3.exitTarget>$ = $<labels.l3.exitTarget>-10;

			sprintf( label, "endif" sympost "%d", $<labels.l3.exitTarget>$ );
			EmitJmpLabel( label );
			_here;
		}
	;








 /*
 ** This production handles the last (or only) 
 ** "elseif({ stmts }) then" clause.
 */

ElseIFs:
		ElseIF			/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		elseifCode4		/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		GetThen			/* $8  */
		EmitTrueLabel4	/* $9  */
		Stmts			/* $10 */
		{				/* $11 */


			/*
			** Emit the false label.
			*/

			_here;
			EmitStmtLblNum( "false" sympost "%d", $<labels.l2.falseTarget>9 );
			_here;
		}
	;








 /*
 ** ElseIFs2-
 **
 **	Handle a chain of elseif statements when there is an
 ** else clause.
 */

 /*
 ** This production handles elseif(boolexpr) that isn't the
 ** last elseif in a chain of elseifs.
 */

ElseIFs2:
		ElseIF				/* $1  */
		Lparen				/* $2  */
		PutElseIfSTL		/* $3  */
		GetLbl				/* $4  */
		BoolExpr			/* $6  */
		Rparen				/* $7  */
		GetThen				/* $8  */
		EmitSkipThen		/* $10 */

		Stmts				/* $11 */

		ExitIfLabel5_9		/* $12  ELSEIFs' exitif and false parameters.	*/
		ElseIFs2			/* $13 */
	;


 /*
 ** This expression handles the last (or only) elseif(expr).
 */

ElseIFs2:
		ElseIF			/* $1  */
		Lparen			/* $2  */
		PutElseIfSTL	/* $3  */
		GetLbl			/* $4  */
		BoolExpr		/* $6  */
		Rparen			/* $7  */
		GetThen			/* $8  */
		EmitSkipThen	/* $10 */
		Stmts			/* $11 */
		{				/* $12 */

			char label[ 256 ];

			_here;

			/*
			** Emit the target label for the conditional jump
			** output by "EmitSkipThen" above.
			*/

			sprintf( label, "endif" sympost "%d", $<labels.l3.exitTarget>0 );
			EmitJmpLabel( label );
			EmitStmtLblNum( "false" sympost "%d", $<labels.l2.falseTarget>4 );
			_here;
		}
	;




 /*
 ** This production handles all but the last "elseif( #{ stmts }# )" clauses
 ** in an elseif chain.
 */

ElseIFs2:
		ElseIF			/* $1  Sets up True/False labels too!			*/
		Lparen			/* $2											*/
		stmtsTkn		/* $3  											*/
		elseifCode4		/* $4											*/
		Stmts			/* $5  											*/
		endstmtsTkn		/* $6  											*/
		Rparen			/* $7											*/
		GetThen			/* $8											*/
		EmitTrueLabel4	/* $9  Emits true label							*/
		Stmts			/* $10 											*/

		ExitIfLabel6_10	/* $12	ElseIFs2's parameters					*/
		ElseIFs2		/* $13	Handle additional elseifs				*/
	;



 /*
 ** This production handles the last (or only) "elseif(#{ stmts }#) then"
 ** clause.
 */

ElseIFs2:
		ElseIF			/* $1  */
		Lparen			/* $2  */
		stmtsTkn		/* $3  */
		elseifCode4		/* $4  */
		Stmts			/* $5  */
		endstmtsTkn		/* $6  */
		Rparen			/* $7  */
		GetThen			/* $8  */
		EmitTrueLabel4	/* $9  */
		Stmts			/* $10 */
		{				/* $11 */

			char label[ 256 ];

			/*
			** Emit the false label.
			*/

			_here; 
			sprintf( label, "endif" sympost "%d", $<labels.l3.exitTarget>0 );
			EmitJmpLabel( label );
			EmitStmtLblNum( "false" sympost "%d", $<labels.l2.falseTarget>9 );
			_here; 
		}
	;









EmitTrueLabel:
		{
			_here;
			EmitStmtLblNum( "true" sympost "%d", TrueLabel );

			/*
			** Do not allow further use of "true" or "false"
			** as jump target labels (at least, not the labels
			** associated with this if statement).  However,
			** we do have to save FalseLabel's value so we can
			** emit the label later.
			*/

			$<labels.l1.trueTarget>$ = TrueLabel;
			$<labels.l2.falseTarget>$ = FalseLabel;
			FalseLabel = $<labels.saveFalse>-3;
			TrueLabel = $<labels.saveTrue>-3;
			_here;
		}

	;


EmitFalseLabel:
		{
			char label[ 256 ];

			_here;
			$<labels.l3.exitTarget>$ = LblCntr++;

			sprintf( label, "endif" sympost "%d", $<labels.l3.exitTarget>$ );
			EmitJmpLabel( label );
			EmitStmtLblNum( "false" sympost "%d", $<labels.l2.falseTarget>0 );
			_here;
		}
	;








PutElseIfSTL:
		{
			_here;
			EmitStmtLblNum( "false" sympost "%d", $<labels.l2.falseTarget>-2 );
			_here;
		}
	;




GetThen:
		Empty
		{
			yyerror( "Expected 'then'" );
		}

	|	thenTkn
	;




//////////////////////////////////////////////////////////////////////////////
//
// Handle the switch HLL statement here.

SingleStmt:
		switchTkn		// $1
		Lparen			// $2
		fReg32			// $3
		Rparen			// $4
		SwitchLabel		// $5
		InitCaseCnt		// $6
		OneOrMoreCases	// $7
		OptionalDefault	// $8
		endswitchTkn	// $9
		{
			int 			sorted;
			int 			temp;
			int				spread;
			int				index;
			int				maxCase;
			int				curCase;
			char			*codeForCases;
			struct adrsYYS	adrs;
			char			jmpTbl[64];
			char			jmpToEnd[64];
			char			label[64];
			char			msg[128];
			
			_here;
			
			// Sort the case table here:
			// Just use a stupid bubble sort because there are rarely more
			// than a couple dozen cases in a switch statement. 
			
			assert( $<cases.cnt>6 > 0 );
			_do
			
				
				sorted = 1;
				_for( int i = 1, i < $<cases.cnt>6, ++i )
				
					_if( (int) $<cases.cases>6[i-1] > (int) $<cases.cases>6[i] )
					
						sorted = 0;
						temp = $<cases.cases>6[i-1];
						$<cases.cases>6[i-1] = $<cases.cases>6[i];
						$<cases.cases>6[i] = temp;
						
						temp = $<cases.caseLbls>6[i-1];
						$<cases.caseLbls>6[i-1] = $<cases.caseLbls>6[i];
						$<cases.caseLbls>6[i] = temp;
						
					_endif
					
				_endfor
						
			_until( sorted );
			
			// Make a quick pass through the table and make sure there
			// are no duplicate entries:
			
			_for( int i = 1, i < $<cases.cnt>6, ++i )
			
				_if( $<cases.cases>6[i-1] == $<cases.cases>6[i] )
				
					sprintf
					( 
						msg, 
						"Duplicate case value: %d", 
						$<cases.cases>6[i] 
					);
					yyerror( msg );
					
				_endif
				
			_endfor

			// Grab all the code emitted for the cases so
			// we can insert the indirect jump in front of it.
			
			codeForCases = getFileStr( $<cases.startOfCases>6 );
			
			
			// Emit the jmp table at this point.
			// Note that this goes to the constants (strings) section,
			// not into the current code section.
			//
			// Begin by doing some sanity checks to make
			// sure the table isn't too big or too sparse:
			
			spread = $<cases.cases>6[ $<cases.cnt>6 - 1 ] - $<cases.cases>6[ 0 ];
			
			// First, check to see if we're even going to emit a jump table.
			// If there are three or fewer cases, or if the count is small
			// and the spread is large, then we're going to emit a sequence
			// of cmp/Jcc instructions.
			
			_if
			( 
					$<cases.cnt>6 <= 3
				||	(spread > 256 && $<cases.cnt>6 < 32) 
			)
			
				// At this point, the cases don't justify the use of
				// a jump table. Just emit a sequence of cmp/je instructions.
				
				_for( int i=0, i < $<cases.cnt>6, ++i )
				
					EmitGeneric_c_r
					( 
						cmp_instr, 
						$<cases.cases>6[i], 
						$<reg.encoding>3 
					);
					sprintf( label, "case" sympost "%d", $<cases.caseLbls>6[i] );
					EmitCondJump( je_instr, label );
					
				_endfor
				
				// At the end of the cmp/JE sequence, emit a jump to the
				// default case:
				
				sprintf( label, "default" sympost "%d", $<u>5 );
				EmitJmpLabel( label );
			
			_elseif( spread > 16384 )
			
				yyerror( "Spread of case values is too large" );
				
			_else
			
				_if( spread > 4096 )
			
					WarnNear
					( 
						"The case table is going to be very large", 
						"switch" 
					);
					
				_endif
				_if( spread/16 > $<cases.cnt>6 )
			
					WarnNear
					( 
						"The case table is very sparse", 
						"switch" 
					);
					
				_endif
				
				// Okay, emit the jmp table:
				
				startStrSeg();	// Put the jump table in the constants section.
				sprintf( jmpTbl, "jmpTbl" sympost "%d", $<u>5 );
				EmitTypedLabel( jmpTbl, tDWord );
				maxCase = $<cases.cases>6[ $<cases.cnt>6 - 1 ];
				curCase = $<cases.cases>6[0];
				index = 0;
				_while( curCase <= maxCase )

					_if( curCase == $<cases.cases>6[index] )
					
						sprintf
						( 
							label, 
							"case" sympost "%d", 
							$<cases.caseLbls>6[index] 
						);
						++index;
					
					_else	// Fill in default address
					
						sprintf( label, "default" sympost "%d", $<u>5 );
						 
					_endif
					EmitOffset( label, 0 );
					++curCase;
				
				_endwhile 
				endStrSeg();	// Return back to the code section.
				
				// Compare the value against the minimum and maximum range
				// values and bail to the default case if it's out of range:
				//
				// Note: special case for the minimum case is zero
				
				_if( $<cases.cases>6[0] != 0 )
				
					EmitGeneric_c_r
					( 
						cmp_instr, 
						$<cases.cases>6[0], 
						$<reg.encoding>3 
					);
					sprintf( label, "default" sympost "%d", $<u>5 );
					EmitCondJump( jl_instr, label );
					
				_endif
				EmitGeneric_c_r
				( 
					cmp_instr, 
					$<cases.cases>6[ $<cases.cnt>6 - 1 ], 
					$<reg.encoding>3 
				);
				sprintf( label, "default" sympost "%d", $<u>5 );
				EmitCondJump( jg_instr, label );
					
				// Okay, emit the indirect jump statement:
				
				initAdrs2
				( 
					&adrs,
					jmpTbl,
					-1, 
					$<reg.encoding>3,
					4,
					-$<cases.cases>6[0] * 4	// minimum index into table.
				);
				EmitJmp_m( &adrs );
				
			_endif
			
			// Emit the code for all the cases after the indirect jump
			// (or sequence of cmp/Jcc instrs if we bailed on the
			// conditional jump).
			
			asmPuts( codeForCases  );
			
			// Emit the end of switch label:
			
			EmitStmtLblNum( "endswitch" sympost "%d", $<u>5 );
			
			// If there was no default clause, we need to emit
			// a default label as well:
			
			_if( $<u>8 )
			
				EmitStmtLblNum( "default" sympost "%d", $<u>5 );
				
			_endif
			
			// Clean up:
				 
			free2( vss codeForCases );
			free2( vss $<cases.cases>6 );
			free2( vss $<cases.caseLbls>6 );
			$<returns>$ = NULL;
			_here; 
		}
	;
	
// Handle the default clause here:

OptionalDefault:
		Empty
		{
			_here; 
			$<u>$ = 1;	// Need a default label at the end
		}
		
	|	defaultTkn
		{
			char jmpToEnd[64];

			// Emit a jmp from the previous case to the
			// end of the switch statement:
			
			_here; 
			sprintf( jmpToEnd, "endswitch" sympost "%d", $<u>-2 );
			EmitJmpLabel( jmpToEnd );
			
			// Emit the label for the default case:
			
			sprintf( jmpToEnd, "default" sympost "%d", $<u>-2 );
			EmitGlobalStmtLbl( jmpToEnd );
			_here; 
		}
		Stmts
		{
			_here; 
			$<u>$ = 0;	// No default label needed.
		}
	;
		
	
// SwitchLabel-
//
//	Generates a unique label constant for this particular switch stmt.

SwitchLabel:
		optionalSemicolon
		{
			_here; 
			$<u>$ = LblCntr++;
		}
	;	


// Handle all the cases:		

InitCaseCnt:
		{
			_here; 
			$<cases.cnt>$ = 0;				// Total number of cases.
			$<cases.exitLbl>$ = $<u>0;		// Where a case jumps when it's done.
			$<cases.defaultLbl>$ = $<u>0;	// The initial default case.
			
			// Save a pointer to the start of the cases code so we can
			// insert the indirect jump and the jump table before this code.
			
			$<cases.startOfCases>$ = asmBuf->offset;
		}
	;
	
// Switch statements must have at least one "case" clause:

OneOrMoreCases:
		caseTkn				// $1
		Lparen				// $2
		OneOrMoreCaseVals	// $3
		EmitCaseLbl			// $4
		Rparen				// $5
		Stmts				// $6
		{
			// Handle the first case here.
			// Note that we do not need to emit a JMP to
			// the end of the switch before this guy.
			
			// Allocate storage for, and copy all the case values to the 
			// cases.cases array.
			
			_here; 
			$<cases.cnt>0 = $<caseVals.cnt>3;
			$<cases.cases>0 = malloc2( sizeof( int ) * $<caseVals.cnt>3 );
			memcpy
			( 
				$<cases.cases>0, 
				$<caseVals.cases>3,
				$<caseVals.cnt>3 * sizeof( int )
			);
			
			// Allocate storage for, and copy the case label to the
			// caseVals.caseLbls array:
			
			$<cases.caseLbls>0 = malloc2( sizeof( int ) * $<caseVals.cnt>3 );
			_for( int i=0, i < $<caseVals.cnt>3, ++i )
			
				$<cases.caseLbls>0[i] = $<u>4;
				
			_endfor
			free2( vss $<caseVals.cases>3 );			 
			_here; 
		}
		
	|	OneOrMoreCases		// $1
		caseTkn				// $2
		{					// $3
		
			char jmpToEnd[64];

			// Emit a jmp from the previous case to the
			// end of the switch statement:
			
			_here; 
			sprintf( jmpToEnd, "endswitch" sympost "%d", $<cases.exitLbl>0 );
			EmitJmpLabel( jmpToEnd );

			_here; 
		}
		Lparen				// $4
		OneOrMoreCaseVals	// $5
		EmitCaseLbl			// $6
		Rparen				// $7
		Stmts				// $8
		{
			int		startCase;
			int		*newCases;
			int		*newLbls;
			int		newCnt;
			
			_here; 
			(void) $<u>3;	// To shut up bison.

			// Okay, handle the current case.

			startCase = $<cases.cnt>0;
			newCnt = $<cases.cnt>0 + $<caseVals.cnt>5;

			// Allocate storage for, and copy all the case values to the 
			// caseVals.cases array.
			
			newCases = 
				malloc2( sizeof( int ) * newCnt );
				
			memcpy
			(
				newCases,
				$<cases.cases>0,
				$<cases.cnt>0 * sizeof( int )
			);
			memcpy
			( 
				&newCases[ startCase ], 
				$<caseVals.cases>5,
				$<caseVals.cnt>5 * sizeof( int )
			);
			free2( vss $<cases.cases>0 );
			$<cases.cases>0 = newCases;
			
			// Allocate storage for, and copy the case label to the
			// caseVals.caseLbls array:
			
			newLbls = 
				malloc2( sizeof( int ) * newCnt );
				
			memcpy
			(
				newLbls,
				$<cases.caseLbls>0,
				$<cases.cnt>0 * sizeof( int )
			);
			_for( int i=0, i < $<caseVals.cnt>5, ++i )
			
				newLbls[ startCase + i ] = $<u>6;
				
			_endfor
			free2( vss $<cases.caseLbls>0 );
			$<cases.caseLbls>0 = newLbls;
			$<cases.cnt>0 = newCnt;

			free2( vss $<caseVals.cases>5 );
			_here;			 
		}
	;


// EmitCaseLbl-
//
//	Emits a label for the current case.
//  The $<u>$ attribute returns the label number associated with this label.
	
EmitCaseLbl:
		{
			char globLbl[64];
			
			_here; 
			$<u>$ = LblCntr++;
			sprintf( globLbl, "case" sympost "%d", $<u>$ );
			EmitGlobalStmtLbl( globLbl );
			_here; 
		}
	;

// Handle case constants within a case clause, e.g, "case( 1,2,3 )":
// This is ugly, like IndexList and DimList, but there are rarely more
// than one or two cases in a case statement, so all the memcpy'ing that
// takes place won't affect performance that much.

OneOrMoreCaseVals:	
			ConstOnlyExpr		// $1
			{
				// Handle the first case (that is, the first constant
				// within the "case" clause).
				
				_here; 
				$<caseVals.cnt>$ = 1;	// Initialize the count to one.
				
				// Allocate storage for this single element:
				
				$<caseVals.cases>$ =
					malloc2
					( 
						sizeof( int ) 
					);

				// Store away this single value:
				
				*$<caseVals.cases>$ = CheckOrdinalSize( YYS &$<v>1, 32 );
				
				_here;
			}

		|	OneOrMoreCaseVals	// $1
			','					// $2 
			ConstOnlyExpr		// $3
			{
				// Handle the 2nd through nth items in the case clause
				// here. We need to bump up the count, allocate storage
				// to hold everything encountered thus far, copy every
				// thing encountered thus far, and then store away
				// the current value at the end of the list.
				
				_here; 
				$<caseVals.cnt>$ = $<caseVals.cnt>1 + 1;
				$<caseVals.cases>$ =
					malloc2
					( 
						sizeof( unsigned ) * ( $<caseVals.cnt>$ )
					);

				memcpy
				( 
					$<caseVals.cases>$, 
					$<caseVals.cases>1,
					sizeof( int ) * ($<caseVals.cnt>1 )
				);
				$<caseVals.cases>$[$<caseVals.cnt>1] = 
					CheckOrdinalSize( YYS &$<v>3, 32 );
					
				free2( vss $<caseVals.cases>1 );
				_here; 

			}
		;

/****************************************************************************/


  /************

	BoolExpr builds an abstract syntax tree containing the following
	records:

	struct _opNode
	{
		struct 	_opNode		*left;		// Left operand
		struct 	_opNode		*right;		// Right operand
		enum	astTknClass	tknType;	// This node's type
		struct	operand_ast	thisNode;	// Operand/operator associated with
										// this node.
	}opnode;

  *************/


BoolExpr:
		BoolExpr	/* $1 */
		landTkn		/* $2 */
		BoolExpr	/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				
			_here;
			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftSubexpression = $<opnode>1;
			thisNode->r.rightSubexpression = $<opnode>3;
			thisNode->operator = and_astop;
			$<opnode>$ = thisNode;
			_here;
		}
	;


BoolExpr:
		BoolExpr	/* $1 */
		lorTkn		/* $2 */
		BoolExpr	/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				
			_here;
			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftSubexpression = $<opnode>1;
			thisNode->r.rightSubexpression = $<opnode>3;
			thisNode->operator = or_astop;
			$<opnode>$ = thisNode;
			_here;
		}
	;


BoolExpr:
		Lparen
		BoolExpr
		Rparen
		{
			_here; 
			$<opnode>$ = $<opnode>2;
		}
	;


BoolExpr:
		'!'
		Lparen
		BoolExpr
		Rparen
		{

			struct opnodeYYS *thisNode;
				
			_here;
			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftSubexpression = $<opnode>3;
			thisNode->r.rightSubexpression = NULL;
			thisNode->operator = not_astop;
			$<opnode>$ = thisNode;
			_here;
		}
	;




BoolExpr:
		be_reg		/* $1 */ 
		relop 		/* $2 */
		be_reg		/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = $<operand>3;
			thisNode->operator = $<v.u.unsval>2;
			ComparableNodes
			( 
				(struct operandYYS *) $<operand>1, 
				(struct operandYYS *) $<operand>3, 
				relop2Operators[ $<v.u.unsval>2 - eq_astop ] 
			);
			_if
			(
					$<operand>1->o.reg->IsSigned
				||	$<operand>3->o.reg->IsSigned
			)

				thisNode->operator = CnvrtToSigned( $<v.u.unsval>2 );

			_endif
			$<opnode>$ = thisNode;
			_here;
		}
	;



BoolExpr:
		be_mem		/* $1 */ 
		relop 		/* $2 */
		be_reg		/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = $<operand>3;
			thisNode->operator = $<v.u.unsval>2;
			ComparableNodes
			( 
				(struct operandYYS *) $<operand>1, 
				(struct operandYYS *) $<operand>3, 
				relop2Operators[ $<v.u.unsval>2 - eq_astop ] 
			);
			_if
			(
					$<operand>3->o.reg->IsSigned
				||	IsInt( $<operand>1->o.adrs->pType )
			)

				thisNode->operator = CnvrtToSigned( $<v.u.unsval>2 );

			_endif
			$<opnode>$ = thisNode;
			_here;
		}
	;




BoolExpr:
		be_anonmem	/* $1 */ 
		relop 		/* $2 */
		be_reg		/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = $<operand>3;
			thisNode->operator = $<v.u.unsval>2;

			// Force the sizes to agree.

			$<operand>1->o.adrs->ObjectSize = $<operand>3->o.reg->Size;
			_if( $<operand>3->o.reg->IsSigned	)

				thisNode->operator = CnvrtToSigned( $<v.u.unsval>2 );

			_endif
			$<opnode>$ = thisNode;
			_here;
		}
	;




BoolExpr:
		be_reg		/* $1 */ 
		relop 		/* $2 */
		be_mem		/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = $<operand>3;
			thisNode->operator = $<v.u.unsval>2;
			ComparableNodes
			( 
				(struct operandYYS *) $<operand>1, 
				(struct operandYYS *) $<operand>3, 
				relop2Operators[ $<v.u.unsval>2 - eq_astop ] 
			);
			_if
			(
					$<operand>1->o.reg->IsSigned
				||	IsInt( $<operand>3->o.adrs->pType )
			)

				thisNode->operator = CnvrtToSigned( $<v.u.unsval>2 );

			_endif
			$<opnode>$ = thisNode;
			_here;
		}
	;






BoolExpr:
		be_reg		/* $1 */ 
		relop 		/* $2 */
		be_anonmem	/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = $<operand>3;
			thisNode->operator = $<v.u.unsval>2;

			// Force the sizes to agree on anon references.

			$<operand>3->o.adrs->ObjectSize = $<operand>1->o.reg->Size;
			_if( $<operand>1->o.reg->IsSigned )

				thisNode->operator = CnvrtToSigned( $<v.u.unsval>2 );

			_endif
			$<opnode>$ = thisNode;
			_here;
		}
	;






BoolExpr:
		be_reg		/* $1 */ 
		relop 		/* $2 */
		be_const	/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = $<operand>3;
			thisNode->operator = $<v.u.unsval>2;
			ComparableNodes
			( 
				(struct operandYYS *) $<operand>1, 
				(struct operandYYS *) $<operand>3, 
				relop2Operators[ $<v.u.unsval>2 - eq_astop ] 
			);
			_if
			(
					$<operand>1->o.reg->IsSigned
				||	IsInt( $<operand>3->o.v.pType )
			)

				thisNode->operator = CnvrtToSigned( $<v.u.unsval>2 );

			_endif
			$<opnode>$ = thisNode;
			_here;
		}
	;





BoolExpr:
		be_mem		/* $1 */ 
		relop 		/* $2 */
		be_const	/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = $<operand>3;
			thisNode->operator = $<v.u.unsval>2;
			ComparableNodes
			( 
				(struct operandYYS *) $<operand>1, 
				(struct operandYYS *) $<operand>3, 
				relop2Operators[ $<v.u.unsval>2 - eq_astop ] 
			);
			_if
			(
					IsInt( $<operand>1->o.adrs->pType )
				||	IsInt( $<operand>3->o.v.pType )
			)

				thisNode->operator = CnvrtToSigned( $<v.u.unsval>2 );

			_endif
			$<opnode>$ = thisNode;
			_here;
		}
	;



inOrnotin:
		inTkn			{ $<v.u.unsval>$ = 1; }
	|	notTkn inTkn	{ $<v.u.unsval>$ = 0; }
	;

BoolExpr:
		be_reg		/* $1 */
		inOrnotin	/* $2 */
		be_mem		/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			_if( $<operand>1->o.reg->Size != 1 )

				yyerror( "Register operand must be a byte register" );

			_endif
			_if( $<operand>3->o.adrs->pType != tCset )

				yyerror( "Memory operand must be a CSET object" );

			_endif
			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = $<operand>3;
			thisNode->operator = 
				_ifx( $<v.u.unsval>2 == 1, in_astop, notin_astop );

			$<opnode>$ = thisNode;
			_here;
		}
	;

BoolExpr:
		be_reg		/* $1 */
		inOrnotin	/* $2 */
		be_const    /* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
			struct	adrsYYS		*m;
			struct	operandYYS	*oprnd;
			char	sn[ 256 ];
				

			_here;

			thisNode = malloc2( sizeofOpnode );

			_if( $<operand>1->o.reg->Size != 1 )

				yyerror( "Register operand must be a byte register" );

			_endif
			_if( $<v.pType>3 != tCset )

				yyerror( "Constant operand must be a CSET object" );

			_endif

			startStrSeg();
			sprintf( sn, "cset" sympost "%d", LblCntr++ );
			OutValue( sn, $<v.Type>3, YYS &$<v>3 );
			endStrSeg();

			// Free up the storage associated with the constant operand:

			FreeValue( YYS &$<operand>3->o.v );
			free2( vss $<operand>3 );


			// Okay, construct the operation for this node:
			
			thisNode->l.leftOperand = $<operand>1;

			// $<operand>3 is a constant, but we've converted it
			// to a memory operand.  So we have to build the r.rightOperand
			// as a memory operand.

			m = malloc2( sizeofAdrsYYS );
			m->Size = 16;
			m->ObjectSize = 16;
			m->StaticName = hlastrdup2( sn );
			m->BaseReg = NULL;
			m->IndexReg = NULL;
			m->regnum = -1;
			m->Scale = 0;
			m->Disp = 0;
			m->Sym = NULL;
			m->Type = &cset_ste;
			m->pType = tCset;
			m->SymClass = cStatic;
			m->pClass = 0;
			m->BaseType = NULL;


			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = mem_optype;
			oprnd->text = NULL;
			oprnd->o.adrs = m;

			thisNode->r.rightOperand = oprnd;
			thisNode->operator = 
				_ifx( $<v.u.unsval>2 == 1, in_astop, notin_astop );

			$<opnode>$ = thisNode;

			_here;
		}
	;

BoolExpr:
		be_reg		/* $1 */
		inOrnotin	/* $2 */
		be_const	/* $3 */
		DotDot		/* $4 */
		be_const	/* $5 */
		{

			struct	opnodeYYS	*thisNode;
			struct	opnodeYYS	*reg1Node;
			struct	opnodeYYS	*reg2Node;
			struct	operandYYS	*oprnd;
				
			_here;

			// We must make a copy of the register operand because
			// it will get deleted twice later on.

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = reg_optype;
			oprnd->text = NULL; // Don't need to copy the macro.
			oprnd->o.reg = malloc2( sizeofRegYYS );	
			oprnd->o.reg->Size = $<operand>1->o.reg->Size;
			oprnd->o.reg->IsSigned = $<operand>1->o.reg->IsSigned;
			oprnd->o.reg->Type = $<operand>1->o.reg->Type;
			oprnd->o.reg->pType = $<operand>1->o.reg->pType;
			oprnd->o.reg->encoding = $<operand>1->o.reg->encoding;

			oprnd->regname = hlastrdup2( $<operand>1->regname );

			// Build and "AND"/"OR" node out of the register and
			// the two constant operands.

			thisNode = malloc2( sizeofOpnode );
			reg1Node = malloc2( sizeofOpnode );
			reg2Node = malloc2( sizeofOpnode );

			reg1Node->operator = _ifx( $<v.u.unsval>2, ae_astop, b_astop );
			reg1Node->l.leftOperand = $<operand>1;
			reg1Node->r.rightOperand = $<operand>3;

			reg2Node->operator = _ifx( $<v.u.unsval>2, be_astop, a_astop );
			reg2Node->l.leftOperand = oprnd;
			reg2Node->r.rightOperand = $<operand>5;


			_if
			(
					$<operand>1->o.reg->IsSigned
				||	IsInt( $<operand>3->o.v.pType )
				||	IsInt( $<operand>5->o.v.pType )
			)
			
				_if
				( 
						numBits32( YYS &$<operand>3 ) > 32 
					||	numBits32( YYS &$<operand>5 ) > 32 
				)
				
					yyerror( "Upper or lower range constant is too large" );
					
				_endif
				

				_if( $<operand>3->o.v.u.intval > $<operand>5->o.v.u.intval )
				
					yyerror
					( 
						"Lower bounds is greater than upper bounds" 
						"in expression" 
					);
					
				_endif
					
				reg1Node->operator = _ifx( $<v.u.unsval>2, ge_astop, l_astop );
				reg2Node->operator = _ifx( $<v.u.unsval>2, le_astop, g_astop );
				
			_elseif
			( 
					IsOrdinal( $<operand>3->o.v.pType ) 
				&&	numBits32( YYS &$<operand>3 ) <= 32 
			)
			
				_if( $<operand>3->o.v.u.intval > $<operand>5->o.v.u.intval )
				
					yyerror
					( 
						"Lower bounds is greater than upper bounds "
						"in expression" 
					);
					
				_endif

			_endif

			thisNode->l.leftSubexpression = reg1Node;
			thisNode->r.rightSubexpression = reg2Node;
			thisNode->operator = _ifx( $<v.u.unsval>2, and_astop, or_astop );
			$<opnode>$ = thisNode;
			_here;
		}
	;



BoolExpr:
		be_mem		/* $1 */
		inOrnotin	/* $2 */
		be_const	/* $3 */
		DotDot		/* $4 */
		be_const	/* $5 */
		{

			struct	opnodeYYS	*thisNode;
			struct	opnodeYYS	*mem1Node;
			struct	opnodeYYS	*mem2Node;
			struct	adrsYYS		*m;
			struct	operandYYS	*oprnd;
				
			_here;

			// We must make a copy of the memory operand because
			// it will get deleted twice later on.

			m = malloc2( sizeofAdrsYYS );
			memcpy( m, $<operand>1->o.adrs, sizeofAdrsYYS );
			m->StaticName = 
				_ifx
				( 
					$<operand>1->o.adrs->StaticName == NULL, 
					NULL, 
					hlastrdup2( $<operand>1->o.adrs->StaticName ) 
				);

			m->BaseReg = 
				_ifx
				( 
					$<operand>1->o.adrs->BaseReg == NULL, 
					NULL, 
					hlastrdup2( $<operand>1->o.adrs->BaseReg ) 
				);

			m->IndexReg = 
				_ifx
				( 
					$<operand>1->o.adrs->IndexReg == NULL, 
					NULL, 
					hlastrdup2( $<operand>1->o.adrs->IndexReg ) 

				);

			m->regnum = -1;
			
			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = mem_optype;
			oprnd->text = NULL; // No need to copy the macro
			oprnd->o.adrs = m;
				

			// Build an "AND"/"OR" node out of the register and
			// the two constant operands.

			thisNode = malloc2( sizeofOpnode );
			mem1Node = malloc2( sizeofOpnode );
			mem2Node = malloc2( sizeofOpnode );

			mem1Node->operator = _ifx( $<v.u.unsval>2, ae_astop, b_astop );
			mem1Node->l.leftOperand = $<operand>1;
			mem1Node->r.rightOperand = $<operand>3;

			mem2Node->operator = _ifx( $<v.u.unsval>2, be_astop, a_astop );
			mem2Node->l.leftOperand = oprnd;
			mem2Node->r.rightOperand = $<operand>5;

			_if
			(
					IsInt( $<operand>1->o.adrs->pType )
				||	IsInt( $<operand>3->o.v.pType )
				||	IsInt( $<operand>5->o.v.pType )
			)

				_if
				( 
						numBits32( YYS &$<operand>3 ) > 32 
					||	numBits32( YYS &$<operand>5 ) > 32 
				)
				
					yyerror( "Upper or lower range constant is too large" );
					
				_endif

				_if( $<operand>3->o.v.u.intval > $<operand>5->o.v.u.intval )
				
					yyerror
					( 
						"Lower bounds is greater than upper bounds" 
						"in expression" 
					);
					
				_endif
				mem1Node->operator = _ifx( $<v.u.unsval>2, ge_astop, l_astop );
				mem2Node->operator = _ifx( $<v.u.unsval>2, le_astop, g_astop );

			_elseif
			( 
					IsOrdinal( $<operand>3->o.v.pType ) 
				&&	numBits32( YYS &$<operand>3 ) <= 32 
			)
			
				_if( $<operand>3->o.v.u.intval > $<operand>5->o.v.u.intval )
				
					yyerror
					( 
						"Lower bounds is greater than upper bounds "
						"in expression" 
					);
					
				_endif

			_endif

			thisNode->l.leftSubexpression = mem1Node;
			thisNode->r.rightSubexpression = mem2Node;
			thisNode->operator = _ifx( $<v.u.unsval>2, and_astop, or_astop );
			$<opnode>$ = thisNode;
			_here;
		}
	;


BoolExpr:
		be_reg		/* $1 */ 
		{			/* $2 */

			struct opnodeYYS *thisNode;

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = NULL;
			thisNode->operator = ne0_astop;
			$<opnode>$ = thisNode;
			_here;
		}
	;

BoolExpr:
		'!'			/* $1 */
		be_reg		/* $2 */ 
		{			/* $3 */

			struct opnodeYYS *thisNode;

			_here;

			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>2;
			thisNode->r.rightOperand = NULL;
			thisNode->operator = eq0_astop;
			$<opnode>$ = thisNode;
			_here;
		}
	;

BoolExpr:
		be_mem		/* $1 */ 
		{			/* $2 */

			struct	opnodeYYS	*thisNode;
			_here;
			_if
			(
					  
					$<operand>1->o.adrs->pType != tBoolean
				&&	$<operand>1->o.adrs->pType != tByte 
				&&	$<operand>1->o.adrs->pType != tWord 
				&&	$<operand>1->o.adrs->pType != tDWord
			)
			
				yyerror
				( 
					"Variable in expression must be boolean, byte, word, or dword" 
				);

			_endif


			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>1;
			thisNode->r.rightOperand = NULL;
			thisNode->operator = ne0_astop;
			$<opnode>$ = thisNode;
			_here;
		}
	;

BoolExpr:
		'!'			/* $1 */
		be_mem		/* $2 */ 
		{			/* $3 */

			struct	opnodeYYS	*thisNode;
				
			_here;
			_if
			(
					  
					$<operand>2->o.adrs->pType != tBoolean
				&&	$<operand>2->o.adrs->pType != tByte 
				&&	$<operand>2->o.adrs->pType != tWord 
				&&	$<operand>2->o.adrs->pType != tDWord
			)
			
				yyerror
				( 
					"Variable in expression must be boolean, byte, word, or dword"
				);

			_endif


			thisNode = malloc2( sizeofOpnode );

			thisNode->l.leftOperand = $<operand>2;
			thisNode->r.rightOperand = NULL;
			thisNode->operator = eq0_astop;
			$<opnode>$ = thisNode;
			_here;
		}

	;



BoolExpr:
		CPUFlag		/* $1 */
		{			/* $2 */

			struct opnodeYYS *thisNode;

			_here;

			thisNode = malloc2( sizeofOpnode );

			// Note: l.leftOperand cannot be NULL.

			thisNode->l.leftOperand = malloc2( sizeofOperandYYS );
			thisNode->l.leftOperand->operandType = flag_optype;
			thisNode->l.leftOperand->text = NULL;
			thisNode->r.rightOperand = NULL;
			thisNode->operator = $<v.u.unsval>1;
			$<opnode>$ = thisNode;
			_here;
		}

	|	fstmt		/* $1 */
		CPUFlag		/* $2 */
		{			/* $3 */

			struct opnodeYYS *thisNode;
			int					CurStmt;
			int					lastChar;
			char				*text;
			char				*eoln;


			_here;

			thisNode = malloc2( sizeofOpnode );

			// Note: l.leftOperand cannot be NULL.

			thisNode->l.leftOperand = malloc2( sizeofOperandYYS );
			thisNode->l.leftOperand->operandType = flag_optype;
			thisNode->r.rightOperand = NULL;
			thisNode->operator = $<v.u.unsval>2;

			// Set StartofStmt for the next operand (if any).

			text = getFileStr( StartOfStmt );
			thisNode->l.leftOperand->text = text;
			$<opnode>$ = thisNode;
			_here;
		}
	
	|	'!'			/* $1 */
		CPUFlag		/* $2 */
		{			/* $3 */

			struct opnodeYYS *thisNode;

			_here;

			thisNode = malloc2( sizeofOpnode );

			// Note: l.leftOperand cannot be NULL.

			thisNode->l.leftOperand = malloc2( sizeofOperandYYS );
			thisNode->l.leftOperand->operandType = flag_optype;
			thisNode->r.rightOperand = NULL;
			thisNode->l.leftOperand->text = NULL;
			thisNode->operator = InvertFlag( $<v.u.unsval>2 );
			$<opnode>$ = thisNode;
			_here;
		}

	|	fstmt		/* $1 */
		'!'			/* $2 */
		CPUFlag		/* $3 */
		{			/* $4 */

			struct opnodeYYS	*thisNode;
			char				*text;

			_here;

			thisNode = malloc2( sizeofOpnode );

			// Note: l.leftOperand cannot be NULL.

			thisNode->l.leftOperand = malloc2( sizeofOperandYYS );
			thisNode->l.leftOperand->operandType = flag_optype;
			thisNode->r.rightOperand = NULL;
			thisNode->operator = InvertFlag( $<v.u.unsval>3 );

			// Set StartofStmt for the next operand (if any).


			text = getFileStr( StartOfStmt );
			thisNode->l.leftOperand->text = text;
			$<opnode>$ = thisNode;
			_here;
		}

	|	'!'			/* $1 */
		fstmt		/* $2 */
		CPUFlag		/* $3 */
		{			/* $4 */

			struct opnodeYYS *thisNode;
			char				*text;

			_here;

			thisNode = malloc2( sizeofOpnode );

			// Note: l.leftOperand cannot be NULL.

			thisNode->l.leftOperand = malloc2( sizeofOperandYYS );
			thisNode->l.leftOperand->operandType = flag_optype;
			thisNode->r.rightOperand = NULL;
			thisNode->operator = InvertFlag( $<v.u.unsval>3 );

			// Set StartofStmt for the next operand (if any).


			text = getFileStr( StartOfStmt );
			thisNode->l.leftOperand->text = text;

			$<opnode>$ = thisNode;
			_here;
		}
	;





BoolExpr:
		be_mem	/* $1 */
		relop	/* $2 */
		be_mem	/* $3 */
		{
			yyerror( "Memory to memory comparisons are illegal" );
			FreeOperand( (struct opnodeYYS *) $<operand>3 );
			$<operand>$ = $<operand>1;
		}
	;

BoolExpr:
		be_anonmem	/* $1 */
		relop		/* $2 */
		be_anonmem	/* $3 */
		{
			yyerror( "Memory to memory comparisons are illegal" );
			FreeOperand( (struct opnodeYYS *) $<operand>3 );
			$<operand>$ = $<operand>1;
		}
	;

BoolExpr:
		be_anonmem	/* $1 */
		relop		/* $2 */
		be_mem		/* $3 */
		{
			yyerror( "Memory to memory comparisons are illegal" );
			FreeOperand( (struct opnodeYYS *) $<operand>1 );
			$<operand>$ = $<operand>3;
		}
	;

BoolExpr:
		be_anonmem	/* $1 */
		relop		/* $2 */
		be_const	/* $3 */
		{
			yyerror( "Must specify memory size" );
			FreeOperand( (struct opnodeYYS *) $<operand>1 );
			$<operand>$ = $<operand>3;
		}
	;


BoolExpr:
		be_mem		/* $1 */
		relop		/* $2 */
		be_anonmem	/* $3 */
		{
			yyerror( "Memory to memory comparisons are illegal" );
			FreeOperand( (struct opnodeYYS *) $<operand>3 );
			$<operand>$ = $<operand>1;
		}
	;




	






relop:
		'='				{ _here; $<v.u.unsval>$ = eq_astop; }
	|	neTkn			{ _here; $<v.u.unsval>$ = ne_astop; }
	|	'<'				{ _here; $<v.u.unsval>$ = b_astop; }
	|	leTkn			{ _here; $<v.u.unsval>$ = be_astop; }
	|	'>'				{ _here; $<v.u.unsval>$ = a_astop; }
	|	geTkn			{ _here; $<v.u.unsval>$ = ae_astop; }
	;

CPUFlag:
 		cTkn	{ _here; $<v.u.unsval>$ = c_flag;	}
 		
 	|	ncTkn	{ _here; $<v.u.unsval>$ = nc_flag;	}
 	|	sTkn	{ _here; $<v.u.unsval>$ = s_flag;	}
 	|	nsTkn	{ _here; $<v.u.unsval>$ = ns_flag;	}
 	|	oTkn	{ _here; $<v.u.unsval>$ = o_flag;	}
 	|	noTkn	{ _here; $<v.u.unsval>$ = no_flag;	}
 	|	zTkn	{ _here; $<v.u.unsval>$ = z_flag;	}
 	|	nzTkn	{ _here; $<v.u.unsval>$ = nz_flag;	}
 	|	aTkn	{ _here; $<v.u.unsval>$ = a_flag;	}
 	|	naTkn	{ _here; $<v.u.unsval>$ = na_flag;	}
 	|	aeTkn	{ _here; $<v.u.unsval>$ = ae_flag;	}
 	|	naeTkn	{ _here; $<v.u.unsval>$ = nae_flag;	}
 	|	bTkn	{ _here; $<v.u.unsval>$ = b_flag;	}
 	|	nbTkn	{ _here; $<v.u.unsval>$ = nb_flag;	}
 	|	beTkn	{ _here; $<v.u.unsval>$ = be_flag;	}
 	|	nbeTkn	{ _here; $<v.u.unsval>$ = nbe_flag;	}
 	|	lTkn	{ _here; $<v.u.unsval>$ = l_flag;	}
 	|	nlTkn	{ _here; $<v.u.unsval>$ = nl_flag;	}
 	|	leTkn	{ _here; $<v.u.unsval>$ = le_flag;	}
 	|	nleTkn	{ _here; $<v.u.unsval>$ = nle_flag;	}
 	|	gTkn	{ _here; $<v.u.unsval>$ = g_flag;	}
 	|	ngTkn	{ _here; $<v.u.unsval>$ = ng_flag;	}
 	|	geTkn	{ _here; $<v.u.unsval>$ = ge_flag;	}
 	|	ngeTkn	{ _here; $<v.u.unsval>$ = nge_flag;	}
 	|	eTkn	{ _here; $<v.u.unsval>$ = e_flag;	}
 	|	neTkn	{ _here; $<v.u.unsval>$ = ne_flag;	}
 	|	peTkn	{ _here; $<v.u.unsval>$ = pe_flag;	}
 	|	poTkn	{ _here; $<v.u.unsval>$ = po_flag;	}
 	|	pTkn	{ _here; $<v.u.unsval>$ = p_flag;	}
 	|	npTkn	{ _here; $<v.u.unsval>$ = np_flag;	}
	;
	


be_reg:
		Register	/* $1 */
		{			/* $2 */

			struct	regYYS		*r;
			struct	operandYYS	*oprnd;
				
			_here;
			r = malloc2( sizeofRegYYS );
			*r = $<reg>1;

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = reg_optype;
			oprnd->text = NULL;
			oprnd->o.reg = r;
			oprnd->regname = hlastrdup2( regStrs[ $<reg.encoding>1 ]);
			$<operand>$ = oprnd;
			_here;
		}

	|	fstmt		/* $1 */
		Register	/* $2 */
		{			/* $3 */

			struct	regYYS		*r;
			struct	operandYYS	*oprnd;
			char				*text;
				
			_here;
			r = malloc2( sizeofRegYYS );
			*r = $<reg>2;

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = reg_optype;
			text = getFileStr( StartOfStmt );
			oprnd->text = text;
			oprnd->o.reg = r;
			oprnd->regname = hlastrdup2( regStrs[ $<reg.encoding>2 ]);

			$<operand>$ = oprnd;
			_here;
		}

	;






be_mem:
		Memory	/* $1 */
		{		/* $2 */

			struct	adrsYYS		*m;
			struct	operandYYS	*oprnd;

			_here;
			m = malloc2( sizeofAdrsYYS );
			memcpy( m, &$<adrs>1, sizeofAdrsYYS );

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = mem_optype;
			oprnd->text = NULL;
			oprnd->o.adrs = m;
			$<operand>$ = oprnd;
		}

	|	fstmt	/* $1 */
		Memory	/* $2 */
		{		/* $3 */

			struct	adrsYYS		*m;
			struct	operandYYS	*oprnd;
			char				*text;

			_here;
			m = malloc2( sizeofAdrsYYS );
			memcpy( m, &$<adrs>2, sizeofAdrsYYS );

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = mem_optype;
			oprnd->o.adrs = m;

			// Grab the text emitted by fstmt (if any).

			text = getFileStr( StartOfStmt );
			oprnd->text = text;
			$<operand>$ = oprnd;
		}
	;




be_anonmem:
		AnonMem
		{
			struct	adrsYYS		*m;
			struct	operandYYS	*oprnd;
			_here;
			m = malloc2( sizeofAdrsYYS );
			memcpy( m, &$<adrs>1, sizeofAdrsYYS );

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = mem_optype;
			oprnd->o.adrs = m;
			oprnd->text = NULL;
			$<operand>$ = oprnd;
		}

	|	fstmt		/* $1 */
		AnonMem		/* $2 */
		{			/* $3 */

			struct	adrsYYS		*m;
			struct	operandYYS	*oprnd;
			char				*text;

			_here;
			m = malloc2( sizeofAdrsYYS );
			memcpy( m, &$<adrs>2, sizeofAdrsYYS );

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = mem_optype;
			oprnd->o.adrs = m;

			// Grab the text emitted by fstmt (if any).

			text = getFileStr( StartOfStmt );
			oprnd->text = text;
			$<operand>$ = oprnd;
		}
	;



be_const:
		ConstExpr
		{
			struct	SymNode 	*v;
			struct	operandYYS	*oprnd;

			_here;
			_if
			( 
					!( IsOrdinal( $<v.pType>1 ) && numBits32( YYS &$<v>1 ) <= 32 ) 
				&&	$<v.pType>1 != tCset
				&&	$<v.pType>1 != tPointer 
			)

				yyerror( "Illegal constant type" );

				// Set up a dummy type so the following code
				// does not fail.

				FreeValue( YYS &$<v>1 );
				memcpy( &$<v>1, &boolean_ste, sizeofSymNode );

			_endif

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = const_optype;
			oprnd->text = NULL;
			memcpy( &oprnd->o.v, &$<v>1, sizeofSymNode );
			$<operand>$ = oprnd;
			_here;
		}

	|	fstmt
		ConstExpr
		{
			struct	SymNode 	*v;
			struct	operandYYS	*oprnd;
			char				*text;

			_here;
			_if
			( 
					!( IsOrdinal( $<v.pType>2 ) && numBits32( YYS &$<v>2 ) <= 32 ) 
				&&	$<v.pType>2 != tCset
				&&	$<v.pType>2 != tPointer 
			)

				yyerror( "Illegal constant type" );

				// Set up a dummy type so the following code
				// does not fail.

				FreeValue( YYS &$<v>2 );
				memcpy( &$<v>2, &boolean_ste, sizeofSymNode );

			_endif

			oprnd = malloc2( sizeofOperandYYS );
			oprnd->operandType = const_optype;
			oprnd->text = NULL;
			memcpy( &oprnd->o.v, &$<v>2, sizeofSymNode );

			// Grab the text emitted by fstmt (if any).

			text = getFileStr( StartOfStmt );
			oprnd->text = text;
			$<operand>$ = oprnd;
			_here;
		}
	;



/*************************************************************************/
/*************************************************************************/


	/*
	** The following production processes parses anything that can
	** be used as a source or destination memory location.
	**
	**	This production returns an "adrs" attribute.
	**
	**	The "adrs.Size" field contains the offset from the base address
	**	to the actual variable (this is a signed integer).
	**
	**	The "adrs.StaticName" field contains a pointer to the static
	**	name of this object (NULL if there is no static name).
	**
	**	The "adrs.BaseReg" field contains a pointer to the base register.
	**
	**	The "adrs.IndexReg" field contains a pointer to the index register.
	**
	**	The "adrs.Scale" field is an integer with the scaled index value.
	**
	**	The "adrs.Disp" field is an integer with the displacement value.
	*/


Memory:
		SimpleMemoryVar 
		IndexAdrsMode
		{
			_here;

			/*
			** Since this memory operand has an index,
			** set the ObjectSize (which would be the size
			** of an array) to the Size field (which is the
			** size of an element).
			*/

			$<adrs.ObjectSize>1 = $<adrs.Size>1;
			_if( $<adrs.forcedSize>1 != 0 )
			
				$<adrs.forcedSize>1 = $<adrs.Size>1;
				
			_endif
 

			/*
			** If there is an index attached to this
			** memory reference and it's an array reference,
			** return the base type as the type of this object.
			*/

			_if( $<adrs.pType>1 == tArray )

				assert( $<adrs.Type>1 != NULL );
				$<adrs.Type>1 = GetBaseType( $<adrs.Type>1 );
				$<adrs.pType>1 = $<adrs.Type>1->pType;

			_endif;


 			CombineAddresses( &$<adrs>1, &$<adrs>2 );
			FreeAdrs( &$<adrs>2 );
			memcpy( &$<adrs>$, &$<adrs>1, sizeof( union YYSTYPE ));
			_here;
		}
	;


Memory:
		SimpleMemoryVar 
		Empty
		{
			_here;
			memcpy( &$<adrs>$, &$<adrs>1, sizeof( union YYSTYPE ) );
			_here;
		}
	;


Memory:
		SimpleMemoryVar		/* $1 */ 
		FieldStuff			/* $2 */
		IndexAdrsMode		/* $3 */
		{					/* $4 */

			char address[ 256 ];
			char name[ 256 ];
			char *size;

			/*
			** Pointer variables (to class/record/union) are only
			** legal for calls, not for memory accesses.
			*/

			_here;
			_if( $<adrs.pType>1 == tPointer )

				yyerror( "Illegal use of pointer variable" );

			_endif


			/*
			** Since this memory operand has an index,
			** set the ObjectSize (which would be the size
			** of an array) to the Size field (which is the
			** size of an element).
			*/

			$<adrs.ObjectSize>2 = $<adrs.Size>2;
			_if( $<adrs.forcedSize>2 != 0 )
			
				$<adrs.forcedSize>2 = $<adrs.Size>2;
				
			_endif

			/*
			** If there is an index attached to this
			** memory reference and it's an array reference,
			** return the base type as the type of this object.
			*/

			_if( $<adrs.pType>2 == tArray )

				assert( $<adrs.Type>2 != NULL );
				$<adrs.Type>2 = GetBaseType( $<adrs.Type>2 );
				$<adrs.pType>2 = $<adrs.Type>2->pType;

			_endif;


			/*
			** Merge the base name with the fields to get the
			** full name plus the adjusted offsets.
			*/

			memcpy( &$<adrs>$, &$<adrs>2, sizeof( union YYSTYPE ) );

			/*
			** Merge the fully qualified name above with the index
			** information.
			*/

			CombineAddresses( &$<adrs>$, &$<adrs>3 );
			$<adrs.forcedSize>$ = $<adrs.ObjectSize>$;
			FreeAdrs( &$<adrs>1 );
			FreeAdrs( &$<adrs>3 );

			_here;
		}
	;


Memory:
		SimpleMemoryVar		/* $1 */ 
		FieldStuff			/* $2 */
		Empty				/* $3 */
		{					/* $4 */

			char address[ 256 ];
			char name[ 256 ];
			char *size;


			/*
			** Pointer variables (to class/record/union) are only
			** legal for calls, not for memory accesses.
			*/

			_here;
			_if( $<adrs.pType>1 == tPointer )

				yyerror( "Illegal use of pointer variable" );

			_endif

			/*
			** Merge the base name with the fields to get the
			** full name plus the adjusted offsets.
			*/

			memcpy( &$<adrs>$, &$<adrs>2, sizeof( union YYSTYPE ) );
			$<adrs.forcedSize>$ = $<adrs.ObjectSize>$;
			FreeAdrs( &$<adrs>1 );
		}
	;


	/*
	** MemoryDest is a special version of memory used only for
	** destination operands.  The principle purpose for this is
	** to allow us to check for additional errors that cannot
	** be detected by Memory (due to shift/reduce or reduce/reduce
	** conflicts that would occur).
	*/


MemoryDest:
		SimpleMemoryVar 
		IndexAdrsMode
		{
			_here;

			/*
			** Since this memory operand has an index,
			** set the ObjectSize (which would be the size
			** of an array) to the Size field (which is the
			** size of an element).
			*/

			$<adrs.ObjectSize>1 = $<adrs.Size>1;
			_if( $<adrs.forcedSize>1 != 0 )
			
				$<adrs.forcedSize>1 = $<adrs.Size>1;
				
			_endif

			/*
			** If there is an index attached to this
			** memory reference and it's an array reference,
			** return the base type as the type of this object.
			*/

			_if( $<adrs.pType>1 == tArray )

				assert( $<adrs.Type>1 != NULL );
				$<adrs.Type>1 = GetBaseType( $<adrs.Type>1 );
				$<adrs.pType>1 = $<adrs.Type>1->pType;

			_endif;
 			CombineAddresses( &$<adrs>1, &$<adrs>2 );
			memcpy( &$<adrs>$, &$<adrs>1, sizeof( union YYSTYPE ) );
			FreeAdrs( &$<adrs>2 );
			_here;
		}
	;


MemoryDest:
		SimpleMemoryVar 
		Empty
		{
			_here;
			memcpy( &$<adrs>$, &$<adrs>1, sizeof( union YYSTYPE ) );
			_here;
		}
	;


MemoryDest:
		SimpleMemoryVar		/* $1 */ 
		FieldStuff			/* $2 */
		IndexAdrsMode		/* $3 */
		{					/* $4 */

			char address[ 256 ];
			char name   [ 256 ];
			char *size;

			/*
			** Pointer variables (to class/record/union) are only
			** legal for calls, not for memory accesses.
			*/

			_here;
			_if( $<adrs.pType>1 == tPointer )

				yyerror( "Illegal use of pointer variable" );

			_endif

			/*
			** Since this memory operand has an index,
			** set the ObjectSize (which would be the size
			** of an array) to the Size field (which is the
			** size of an element).
			*/

			$<adrs.ObjectSize>2 = $<adrs.Size>2;
			_if( $<adrs.forcedSize>2 != 0 )
			
				$<adrs.forcedSize>2 = $<adrs.Size>2;
				
			_endif

			/*
			** If there is an index attached to this
			** memory reference and it's an array reference,
			** return the base type as the type of this object.
			*/

			_if( $<adrs.pType>2 == tArray )

				assert( $<adrs.Type>2 != NULL );
				$<adrs.Type>2 = GetBaseType( $<adrs.Type>2 );
				$<adrs.pType>2 = $<adrs.Type>2->pType;

			_endif;

			/*
			** Merge the base name with the fields to get the
			** full name plus the adjusted offsets.
			*/

			memcpy( &$<adrs>$, &$<adrs>2, sizeof( union YYSTYPE ) );


			/*
			** Merge the fully qualified name above with the index
			** information.
			*/

			CombineAddresses( &$<adrs>$, &$<adrs>3 );
			$<adrs.forcedSize>$ = $<adrs.ObjectSize>$;
			FreeAdrs( &$<adrs>1 );
			FreeAdrs( &$<adrs>3 );

			_here;
		}
	;


MemoryDest:
		SimpleMemoryVar		/* $1 */ 
		FieldStuff			/* $2 */
		Empty				/* $3 */
		{					/* $4 */

			char address[ 256 ];
			char name[ 256 ];
			char *size;

			/*
			** Pointer variables (to class/record/union) are only
			** legal for calls, not for memory accesses.
			*/

			_here;
			_if( $<adrs.pType>1 == tPointer )

				yyerror( "Illegal use of pointer variable" );

			_endif

			/*
			** Merge the base name with the fields to get the
			** full name plus the adjusted offsets.
			*/

			memcpy( &$<adrs>$, &$<adrs>2, sizeof( union YYSTYPE ) );

			/*
			** $<adrs.Disp>1 was already factored into $<adrs>$
			** by the FieldStuff production.  Don't factor it
			** in twice.
			*/


			//CombineAddresses( &$<adrs>$, &$<adrs>1 );
			$<adrs.forcedSize>$ = $<adrs.ObjectSize>$;
			FreeAdrs( &$<adrs>1 );
		}
	;


MemoryDest:
		UndefID
		{
			ErrorNear
			( 
				"Undefined identifier (dest memory operand)",
				yytext,
				__LINE__,
				__FILE__ 
			);
			$<adrs.Size>$ = 1;
			$<adrs.forcedSize>$ = 0;
			$<adrs.ObjectSize>$ = 1;
			$<adrs.StaticName>$ = NULL;
			$<adrs.regnum>$ = -1;
			$<adrs.BaseReg>$ = NULL;
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.Disp>$ = 0;
			$<adrs.regnum>$ = -1;
			$<adrs.Sym>$ = &false_ste;
			$<adrs.Type>$ = &boolean_ste;
			$<adrs.pType>$ = tBoolean;		/* No real type 	*/
			$<adrs.pClass>$ = valp_pc;		/* No real pClass	*/
			$<adrs.SymClass>$ = cStatic;	/* No real class	*/
			_here;
		}
	;


MemoryDest:
		NotMemoryID
		{
			ErrorNear
			( 
				"Expected a memory operand",
				$<idStr>1,
				__LINE__,
				__FILE__ 
			);
			$<adrs.Size>$ = 1;
			$<adrs.forcedSize>$ = 0;
			$<adrs.ObjectSize>$ = 1;
			$<adrs.StaticName>$ = NULL;
			$<adrs.regnum>$ = -1;
			$<adrs.BaseReg>$ = NULL;
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.Disp>$ = 0;
			$<adrs.regnum>$ = -1;
			$<adrs.Sym>$ = &false_ste;
			$<adrs.Type>$ = &boolean_ste;
			$<adrs.pType>$ = tBoolean;		/* No real type 	*/
			$<adrs.pClass>$ = valp_pc;		/* No real pClass	*/
			$<adrs.SymClass>$ = cStatic;	/* No real class	*/
			_here;
		}
	;




 /*
 ** NotMemoryID-
 **
 **	Matches identifiers that are not local, intermediate, or static
 ** variables.  Used to detect syntax errors.
 */

NotMemoryID:
		LocalConstID
		{
			_here;
			$<idStr>$ = $<s>1->TrueName;
		}

	|	LocalLabelID
		{
			_here;
			$<idStr>$ = $<s>1->TrueName;
		}

	|	LocalID
		{
			_here;
			_if( $<s>1->pType == tClass )
			
				ErrorNear
				( 
					"Expected appropriate field specification for "
					"Class object",
					$<s>1->TrueName,
					__LINE__,
					__FILE__
				);

			_endif
			$<idStr>$ = $<s>1->TrueName;
		}

	|	NonLocalConstID
		{
			_here;
			$<idStr>$ = $<s>1->TrueName;
		}

	|	NonLocalLabelID
		{
			_here;
			$<idStr>$ = $<s>1->TrueName;
		}

	|	NonLocalID
		{
			_here;
			$<idStr>$ = $<s>1->TrueName;
		}
	;



/////////////////////////////////////////////////////////////////////////////
//
// Utility productions used by IndexAdrsMode and AnonMem:

 /*
 ** Displacement-
 **
 **	Looks for "+const" or "-const" and returns an appropriate
 ** $<v>$ record if it finds one of these values.
 **
 */

Displacement:
		'+'
		ConstOnlyExpr
		{
			_here;
			$<v>$ = $<v>2;
			_if( !( IsOrdinal( $<v.pType>2 ) && numBits32( YYS &$<v>2 ) <= 32 ))

				yyerror( "Expected a 32-bit ordinal displacement value" );
				FreeValue( YYS &$<v>2 );
				$<v.u.intval>$ = 0;
				$<v.pType>$ = tInt32;
				$<v.Type>$ = &int32_ste;

			_endif
		}

	|	'-'
		{
			_here;
			PushBackStr( "0 - " );
		}
		ConstOnlyExpr
		{
			_here;
			$<v>$ = $<v>3;
			_if( IsOrdinal( $<v.pType>3 ) && numBits32( YYS &$<v>3 ) <= 32 )

				$<v.u.intval>$ = $<v.u.intval>3;
				$<v.pType>$ = tInt32;
				$<v.Type>$ = &int32_ste;

			_else

				yyerror( "Expected a 32-bit ordinal displacement value" );
				FreeValue( YYS &$<v>3 );
				$<v.u.intval>$ = 0;
				$<v.pType>$ = tInt32;
				$<v.Type>$ = &int32_ste;

			_endif
			_here;
		}
	;


Displacement2:
		ConstOnlyExpr
		{
			_here;
			$<v>$ = $<v>1;
			_if( !( IsOrdinal( $<v.pType>1 ) && numBits32( YYS &$<v>1 ) <= 32 ))

				yyerror( "Expected a 32-bit ordinal displacement value" );
				FreeValue( YYS &$<v>1 );
				$<v.u.intval>$ = 0;
				$<v.pType>$ = tInt32;
				$<v.Type>$ = &int32_ste;

			_endif
		}
	;
	
 /*
 ** ScaledIndex-
 **
 ** Check for "*1", "*2", "*4", or "*8".
 ** Returns value of scaled index item in $<v.u.unsval>$.
 **	Returns one if there is no legal scaled value.
 */

ScaledIndex:
		'*'
		intconst
		{
			_here;
			_if( $<v.u.intval>2 == 1 )

				$<v.u.unsval>$ = 1;

			_elseif( $<v.u.intval>2 == 2 )

				$<v.u.unsval>$ = 2;

			_elseif( $<v.u.intval>2 == 4 )

				$<v.u.unsval>$ = 4;

			_elseif( $<v.u.intval>2 == 8 )

				$<v.u.unsval>$ = 8;

			_else

				$<v.u.unsval>$ = 1;
				yyerror( "Illegal scaled index value" );

			_endif
		}
	;




// amGutz-
//	Handles the "guts" of an addressing mode. That is, the stuff that
//	comes after a '[' in an memory addressing mode.

amGutz:
		iamRegister		/* $1 */
		Rbrack			/* $2 */
		{
			_here;
			$<mem.base>$  = $<reg.encoding>1;
			$<mem.index>$ = -1;
			$<mem.scale>$ = 0;
			$<mem.disp>$  = 0;

		}
	
	|	iamRegister		/* $1 */
		'+'				/* $2 */
		iamRegister		/* $3 */
		Rbrack			/* $4 */
		{
			_here;
			$<mem.base>$  = $<reg.encoding>1;
			$<mem.index>$ = $<reg.encoding>3;
			$<mem.scale>$ = 0;
			$<mem.disp>$  = 0;
			
		}
	
	|	iamRegister		/* $1 */
		'+'				/* $2 */
		iamRegister		/* $3 */
		ScaledIndex		/* $4 */
		Rbrack			/* $5 */
		{
			_here;
			$<mem.base>$  = $<reg.encoding>1;
			$<mem.index>$ = $<reg.encoding>3;
			$<mem.scale>$ = $<v.u.unsval>4;
			$<mem.disp>$  = 0;
		}
	
	|	iamRegister		/* $1 */
		ScaledIndex		/* $2 */
		Rbrack			/* $3 */
		{
			_here;
			$<mem.base>$  = -1;
			$<mem.index>$ = $<reg.encoding>1;
			$<mem.scale>$ = $<v.u.unsval>2;
			$<mem.disp>$  = 0;
		}
		
		
	|	iamRegister		/* $1 */
		Displacement	/* $2 */
		Rbrack			/* $3 */
		{
			_here;
			$<mem.base>$  = $<reg.encoding>1;
			$<mem.index>$ = -1;
			$<mem.scale>$ = 0;
			$<mem.disp>$  = $<v.u.unsval>2;
		}
	
	|	iamRegister		/* $1 */
		'+'				/* $2 */
		iamRegister		/* $3 */
		Displacement	/* $4 */
		Rbrack			/* $5 */
		{
			_here;
			$<mem.base>$  = $<reg.encoding>1;
			$<mem.index>$ = $<reg.encoding>3;
			$<mem.scale>$ = 0;
			$<mem.disp>$  = $<v.u.unsval>4;
			_here;
		}
	
	|	iamRegister		/* $1 */
		'+'				/* $2 */
		iamRegister		/* $3 */
		ScaledIndex		/* $4 */
		Displacement	/* $5 */
		Rbrack			/* $6 */
		{
			_here;
			$<mem.base>$  = $<reg.encoding>1;
			$<mem.index>$ = $<reg.encoding>3;
			$<mem.scale>$ = $<v.u.unsval>4;
			$<mem.disp>$  = $<v.u.unsval>5;
		}
	
	|	iamRegister		/* $1 */
		ScaledIndex		/* $2 */
		Displacement	/* $3 */
		Rbrack			/* $4 */
		{
			_here;
			$<mem.base>$  = -1;
			$<mem.index>$ = $<reg.encoding>1;
			$<mem.scale>$ = $<v.u.unsval>2;
			$<mem.disp>$  = $<v.u.unsval>3;
		}
	;
	

// zeroOrMoreGutz-
//	Allows us to have concatenated bracket expressions, e.g.,
//		[eax][ebx*2][4]

zeroOrMoreGutz:
		'['				/* $1 */
		amGutz			/* $2 */
		zeroOrMoreGutz	/* $3 */
		{
			_here;
			$<mem>$ = $<mem>2;
			mergeMem( YYM &$<mem>$, YYM &$<mem>3 );
		}
		
	|	'['				/* $1 */
		Displacement2	/* $2 */
		Rbrack			/* $3 */
		zeroOrMoreGutz	/* $4 */
		{
			_here;
			$<mem>$ = $<mem>4;
			$<mem.disp>$ += $<v.u.unsval>2;
		}
	
	|	/* empty */
		{
			_here;
			$<mem.base>$ = -1;
			$<mem.index>$ = -1;
			$<mem.scale>$ = 0;
			$<mem.disp>$ = 0;
		}
	;



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// IndexAdrsMode -
//
//	Handles address expression objects following a variable name, e.g.,
//		d[eax][ebx*2][4]

iamRegister:
		fRegister //Register
		{
			_here;
			_if( $<reg.Size>1 != 4 )

				yyerror( "Register must be 32 bits" );

			_endif
			$<reg>$ = $<reg>1;
		}
	;

IndexAdrsMode:
		'['				/* $1 */
		amGutz			/* $2 */
		zeroOrMoreGutz	/* $3 */
		{
			int		index;
			char	comment[256];
			
			_here;
			mergeMem( YYM &$<mem>2, YYM &$<mem>3 );
			
			// Check for the use of ESP as an index register:
			
			_if( $<mem.index>2 == reg_esp )
			
				_if( $<mem.base>2 == reg_esp || $<mem.scale>2 > 1 )
				
					yyerror( "ESP cannot be used as an index register" );
					
				_endif
				
				// Swap the base and index registers to try and make
				// this legal:
				
				index = $<mem.index>2;
				$<mem.index>2 = $<mem.base>2;
				$<mem.base>2 = index;
				
			_endif	
			initAdrs
			( 
				YYA &$<adrs>$,
				$<mem.base>2,
				$<mem.index>2,
				$<mem.scale>2,
				$<mem.disp>2
			);
			_here;
		}
		
	|	'['				/* $1 */
		Displacement2	/* $2 */
		Rbrack			/* $3 */
		zeroOrMoreGutz	/* $4 */
		{
			_here;
			initAdrs
			( 
				YYA &$<adrs>$,
				$<mem.base>4,
				$<mem.index>4,
				$<mem.scale>4,
				$<mem.disp>4+$<v.u.intval>2
			);
			_here;
		}
	;




 /*
 ** AnonMem-
 **
 **	A nameless memory addressing mode.
 ** Fills in a $<adrs>$ structure the the appropriate data for
 ** the addressing mode.
 */
 
	

	
AnonMem:
		'['					/* $1 */
		SetElementCnt		/* $2 */
		amGutz				/* $3 */
		zeroOrMoreGutz		/* $4 */
		{
			int				index;
			struct	SymNode	*s;
			
			_here;
			mergeMem( YYM &$<mem>3, YYM &$<mem>4 );
			
			// Check for the use of ESP as an index register:
			
			_if( $<mem.index>3 == reg_esp )
			
				_if( $<mem.base>3 == reg_esp || $<mem.scale>3 > 1 )
				
					yyerror( "ESP cannot be used as an index register" );
					
				_endif
				
				// Swap the base and index registers to try and make
				// this legal:
				
				index = $<mem.index>3;
				$<mem.index>3 = $<mem.base>3;
				$<mem.base>3 = index;
				
			_endif	
			initAdrs
			( 
				YYA &$<adrs>$,
				$<mem.base>3,
				$<mem.index>3,
				$<mem.scale>3,
				$<mem.disp>3
			);
			
			// Create a dummy symbol for the <adrs.Sym> field so it is never NULL.
			
			s = SymbolTable;
			InsertSym
			( 
				" (anonsym) ", 
				&dword_ste,		/* Default is int32 object.		*/
				tDWord,
				cStatic,		/* Not really static, but...	*/ 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				0,				/* No initialization			*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);
			$<adrs.Sym>$ = SymbolTable;
			SymbolTable = s;
			_here;
		}


	;






/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


 /*
 ** The following productions handle an item that corresponds to
 ** a memory reference.  This code be an identifier, a record or
 ** class ID (with fields), an anonymous memory reference, etc.
 **
 ** On return, the $<adrs>$ record contains the pertinent information
 ** about this memory reference.
 */

	/*
	** A simple memory variable is a single ID or a type coerced ID.
	** This could be a local, intermediate, or static object,
	** but there will be no fieldnames associated with this reference.
	*/

SimpleMemoryVar:

		/*
		** Handle a single local identifier here.
		*/

		LocalVarID
		{
			char *p;
			_here;
			SetReferenced( $<s>1 );			
			_if
			( 
					$<s>1->SymClass == cParm 
				&&	ByAddress( $<s>1->pClass )
			)

				$<adrs.Type>$ = &pointer_ste;
				$<adrs.pType>$ = tPointer;
				$<adrs.Size>$ = 4;
				$<adrs.forcedSize>$ = 4;

			_else

				$<adrs.Type>$ = $<s>1->Type;
				$<adrs.pType>$ = $<s>1->pType;

				_if( $<s>1->Arity == 0 )

					/*
					** If a scalar type, set the size to the
					** size of this object.
					*/

					$<adrs.Size>$ = $<s>1->ObjectSize;

				_else

					/*
					** If an array type, set the size to the size
					** of the base type.
					*/

					$<adrs.Size>$ = GetBaseType( $<s>1->Type )->ObjectSize;

				_endif

			_endif
			$<adrs.ObjectSize>$ = $<s>1->ObjectSize;
			$<adrs.Sym>$ = $<s>1;
			$<adrs.pClass>$ = $<s>1->pClass;
			$<adrs.SymClass>$ = $<s>1->SymClass;
			$<adrs.BaseType>$ = $<s>1->Base;
			$<adrs.regnum>$ = $<s>1->regnum;
			
			_if( $<s>1->StaticName == NULL )

				$<adrs.StaticName>$ = NULL;
				$<adrs.BaseReg>$ = hlastrdup2( CurBaseReg );
				$<adrs.IndexReg>$ = NULL;
				$<adrs.Scale>$ = 0;
				$<adrs.regnum>$ = -1;
				$<adrs.Disp>$ = $<s>1->Offset;
				$<adrs.forcedSize>$ = 
					_ifx( $<adrs.Size>$ <= 4, $<adrs.Size>$, 0 );

			_else
				
				/*
				** If we get here, we've got a parameter that
				** was passed in a register.  So we must return
				** the register name in the StaticName field
				** and clean out all the other stuff.
				*/
				$<adrs.StaticName>$ = hlastrdup2( $<s>1->StaticName );
				$<adrs.regnum>$ = strToReg( $<s>1->StaticName );
				$<adrs.BaseReg>$ = NULL;
				$<adrs.IndexReg>$ = NULL;
				$<adrs.Scale>$ = 0;
				$<adrs.Disp>$ = 0;
				$<adrs.forcedSize>$ = 0;

			_endif
			_here;
		}
	;




// Handle a Class VAR ID here.

SimpleMemoryVar:
		ClassVarID
		{
			char name[ 256 ];

			_here;
			SetReferenced( $<s>1 );
			sprintf
			(
				name,
				"this.%s",
				$<s>1->TrueName
			);
			_if( $<s>1->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>1->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>1->Type )->ObjectSize;

			_endif
			$<adrs.ObjectSize>$ = $<s>1->ObjectSize;
			$<adrs.forcedSize>$ = $<adrs.Size>$;
			$<adrs.StaticName>$ = NULL;
			$<adrs.regnum>$ = $<s>1->regnum;
			$<adrs.BaseReg>$ = hlastrdup2( "esi" );
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.regnum>$ = -1;
			$<adrs.Disp>$ = $<s>1->Offset;
			$<adrs.Sym>$ = $<s>1;
			$<adrs.Type>$ = $<s>1->Type;
			$<adrs.pType>$ = $<s>1->pType;
			$<adrs.pClass>$ = $<s>1->pClass;
			$<adrs.SymClass>$ = $<s>1->SymClass;
			_here;

		}
	;

SimpleMemoryVar:
		ClassStaticID
		{
			_here;
			assert( $<s>1 != NULL );
			SetReferenced( $<s>1 );
			_if( $<s>1->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>1->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>1->Type )->ObjectSize;

			_endif
			$<adrs.ObjectSize>$ = $<s>1->ObjectSize;
			$<adrs.forcedSize>$ = 0;
			$<adrs.StaticName>$ = hlastrdup2( $<s>1->StaticName );
			$<adrs.regnum>$ = $<s>1->regnum;
			$<adrs.BaseReg>$ = NULL;
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.Disp>$ = $<s>1->Offset;
			$<adrs.Sym>$ = $<s>1;
			$<adrs.Type>$ = $<s>1->Type;
			$<adrs.pType>$ = $<s>1->pType;
			$<adrs.pClass>$ = $<s>1->pClass;
			$<adrs.SymClass>$ = $<s>1->SymClass;
			_here;
		}
	;


		  


// Handle intermediate variables (non-local and
// non-static) here.  The syntax is:
//
//	reg32::id
//
//	e.g.,
//
//		ebx::i

	

SimpleMemoryVar:
		Register
		coloncolonTkn
		NonLocalVarID
		{
			char name[ 256 ];

			_here;
			SetReferenced( $<s>3 );
			_if( $<reg.Size>1 != 4 )

				yyerror( "Base register must be 32-bits" );

			_endif
			sprintf
			(
				name,
				"%s:%s",
				regStrs[ $<reg.encoding>1 ],
				$<s>3->TrueName
			);
			_if
			( 
					$<s>3->SymClass == cParm 
				&&	ByAddress( $<s>3->pClass )
			)

				$<adrs.Type>$ = &pointer_ste;
				$<adrs.pType>$ = tPointer;
				$<adrs.Size>$ = 4;

			_else

				$<adrs.Type>$ = $<s>3->Type;
				$<adrs.pType>$ = $<s>3->pType;
				_if( $<s>3->Arity == 0 )

					/*
					** If a scalar type, set the size to the
					** size of this object.
					*/

					$<adrs.Size>$ = $<s>3->ObjectSize;

				_else

					/*
					** If an array type, set the size to the size
					** of the base type.
					*/

					$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

				_endif

			_endif


			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<adrs.Size>$;
			$<adrs.StaticName>$ = NULL;
			$<adrs.regnum>$ = -1;
			$<adrs.BaseReg>$ = hlastrdup2( regStrs[$<reg.encoding>1] );
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.Disp>$ = $<s>3->Offset;
			$<adrs.Sym>$ = $<s>3;
			$<adrs.pClass>$ = $<s>3->pClass;
			$<adrs.SymClass>$ = $<s>3->SymClass;
			$<adrs.BaseType>$ = $<s>3->Base;
			_here;

		}
	;




// Handle a single static identifier (at any lex level)
// here.


SimpleMemoryVar:
		AnyStaticID
		{
			_here;
			SetReferenced( $<s>1 );
			_if( $<s>1->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>1->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>1->Type )->ObjectSize;

			_endif
			$<adrs.ObjectSize>$ = $<s>1->ObjectSize;
			$<adrs.forcedSize>$ = 0;
			$<adrs.StaticName>$ = hlastrdup2( $<s>1->StaticName );
			$<adrs.regnum>$ = -1;
			$<adrs.BaseReg>$ = NULL;
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.Disp>$ = 0;
			$<adrs.Sym>$ = $<s>1;
			$<adrs.Type>$ = $<s>1->Type;
			$<adrs.pType>$ = $<s>1->pType;
			$<adrs.pClass>$ = $<s>1->pClass;
			$<adrs.SymClass>$ = $<s>1->SymClass;
			_here;
		}
	;

		


		/*
		** Handle type coercion here.
		**
		**	e.g.,	"( type int8 i )"	
		**					and
		**			"( type int8 i[2] )"
		*/

	
SimpleMemoryVar:
		'('					/* $1 */
		typeTkn				/* $2 */
		TypeID				/* $3 */
		SimpleMemoryVar		/* $4 */
		')'					/* $5 */
		{					/* $6 */

			struct	SymNode	*s;
			char 			adrs[256];

			_here;

			/*
			** If the SymClass is cParm and the pClass is
			** not valp_pc, then change the pClass to valp_pc
			** and make other appropriate adjustments.
			*/

			_if( $<adrs.SymClass>4 == cParm && $<adrs.pClass>4 != valp_pc )

				$<adrs.SymClass>4 = cParm;
				$<adrs.pClass>4 = valp_pc;
				$<adrs.Type>4 = &dword_ste;
				$<adrs.pType>4 = tDWord;
	
			_endif



			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif
			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<s>3->ObjectSize;
			$<adrs.StaticName>$ = $<adrs.StaticName>4;
			$<adrs.regnum>$ = $<adrs.regnum>4;
			$<adrs.BaseReg>$ = $<adrs.BaseReg>4;
			$<adrs.IndexReg>$ = $<adrs.IndexReg>4;
			$<adrs.Scale>$ = $<adrs.Scale>4;
			$<adrs.Disp>$ = $<adrs.Disp>4;
			$<adrs.Sym>$ = $<adrs.Sym>4;
			$<adrs.SymClass>$ = $<adrs.SymClass>4;
			$<adrs.pClass>$ = $<adrs.pClass>4;

			
			// Memory leak! We have to guarantee that Sym's type matches Type.
			// In order to do this, we have to create a new symbol table entry
			// and copy Sym's data to it (shallow copy is fine) so we can copy
			// the TYPE field to Sym's type without affecting the original
			// symbol's definition.
			
			s = (struct	SymNode	*) malloc2( sizeof( struct SymNode ));
			memcpy
			( 
				s, 
				$<adrs.Sym>$, 
				sizeof( struct SymNode ) - sizeof( union ValuesSize )
			);
			s->Type = $<s>3;
			s->pType = $<s>3->pType;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			$<adrs.Sym>$ = s;
			
			// Copy the parameter information from the type:
			
			memcpy( &s->u, &$<s>3->u, sizeof( union ValuesSize ));
			_here;
		}
	;



SimpleMemoryVar:
		'('					/* $1 */
		typeTkn				/* $2 */
		TypeID				/* $3 */
		fstmt				/* $4 */
		SimpleMemoryVar		/* $5 */
		')'					/* $6 */
		{					/* $7 */

			struct	SymNode	*s;
			char 			adrs[256];

			_here;


			/*
			** If the SymClass is cParm and the pClass is
			** not valp_pc, then change the pClass to valp_pc
			** and make other appropriate adjustments.
			*/

			_if( $<adrs.SymClass>5 == cParm && $<adrs.pClass>5 != valp_pc )

				$<adrs.SymClass>5 = cParm;
				$<adrs.pClass>5 = valp_pc;
				$<adrs.Type>5 = &dword_ste;
				$<adrs.pType>5 = tDWord;
	
			_endif



			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif
			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<s>3->ObjectSize;
			$<adrs.StaticName>$ = $<adrs.StaticName>5;
			$<adrs.regnum>$ = $<adrs.regnum>5;
			$<adrs.BaseReg>$ = $<adrs.BaseReg>5;
			$<adrs.IndexReg>$ = $<adrs.IndexReg>5;
			$<adrs.Scale>$ = $<adrs.Scale>5;
			$<adrs.Disp>$ = $<adrs.Disp>5;
			$<adrs.Sym>$ = $<adrs.Sym>5;
			$<adrs.SymClass>$ = $<adrs.SymClass>5;
			$<adrs.pClass>$ = $<adrs.pClass>5;
			
			// Memory leak! We have to guarantee that Sym's type matches Type.
			// In order to do this, we have to create a new symbol table entry
			// and copy Sym's data to it (shallow copy is fine) so we can copy
			// the TYPE field to Sym's type without affecting the original
			// symbol's definition.
			
			s = (struct SymNode *) malloc2( sizeof( struct SymNode ));
			memcpy
			( 
				s, 
				$<adrs.Sym>$, 
				sizeof( struct SymNode ) - sizeof( union ValuesSize )
			);
			s->Type = $<s>3;
			s->pType = $<s>3->pType;
			$<adrs.Sym>$ = s;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			
			// Copy the parameter information from the type:
			
			memcpy( &s->u, &$<s>3->u, sizeof( union ValuesSize ));
			_here;
		}
	;



SimpleMemoryVar:
		'('					/* $1 */
		typeTkn				/* $2 */
		TypeID				/* $3 */
		SimpleMemoryVar		/* $4 */
		IndexAdrsMode		/* $5 */
		Rparen				/* $6 */
		{					/* $7 */

			struct	SymNode	*s;

			_here;

			/*
			** If the SymClass is cParm and the pClass is
			** not valp_pc, then change the pClass to valp_pc
			** and make other appropriate adjustments.
			*/

			_if( $<adrs.SymClass>4 == cParm && $<adrs.pClass>4 != valp_pc )

				$<adrs.SymClass>4 = cParm;
				$<adrs.pClass>4 = valp_pc;
				$<adrs.Type>4 = &dword_ste;
				$<adrs.pType>4 = tDWord;
	
			_endif

 			CombineAddresses( &$<adrs>4, &$<adrs>5 );


			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.

				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif
			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<s>3->ObjectSize;
			$<adrs.StaticName>$ = $<adrs.StaticName>4;
			$<adrs.regnum>$ = $<adrs.regnum>4;
			$<adrs.BaseReg>$ = $<adrs.BaseReg>4;
			$<adrs.IndexReg>$ = $<adrs.IndexReg>4;
			$<adrs.Scale>$ = $<adrs.Scale>4;
			$<adrs.Disp>$ = $<adrs.Disp>4;
			$<adrs.Sym>$ = $<adrs.Sym>4;
			$<adrs.SymClass>$ = $<adrs.SymClass>4;
			$<adrs.pClass>$ = $<adrs.pClass>4;

			
			// Memory leak! We have to guarantee that Sym's type matches Type.
			// In order to do this, we have to create a new symbol table entry
			// and copy Sym's data to it (shallow copy is fine) so we can copy
			// the TYPE field to Sym's type without affecting the original
			// symbol's definition.
			
			s = (struct SymNode *) malloc2( sizeof( struct SymNode ));
			memcpy
			( 
				s, 
				$<adrs.Sym>$, 
				sizeof( struct SymNode ) - sizeof( union ValuesSize )
			);
			s->Type = $<s>3;
			s->pType = $<s>3->pType;
			$<adrs.Sym>$ = s;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			
			// Copy the parameter information from the type:
			
			memcpy( &s->u, &$<s>3->u, sizeof( union ValuesSize ));

			FreeAdrs( &$<adrs>5 );
			_here;
		}
	;



SimpleMemoryVar:
		'('					/* $1 */
		typeTkn				/* $2 */
		TypeID				/* $3 */
		fstmt				/* $4 */
		SimpleMemoryVar		/* $5 */
		IndexAdrsMode		/* $6 */
		Rparen				/* $7 */
		{					/* $8 */
		
			struct	SymNode	*s;

			_here;

			/*
			** If the SymClass is cParm and the pClass is
			** not valp_pc, then change the pClass to valp_pc
			** and make other appropriate adjustments.
			*/

			_if( $<adrs.SymClass>5 == cParm && $<adrs.pClass>5 != valp_pc )

				$<adrs.SymClass>5 = cParm;
				$<adrs.pClass>5 = valp_pc;
				$<adrs.Type>5 = &dword_ste;
				$<adrs.pType>5 = tDWord;
	
			_endif

 			CombineAddresses( &$<adrs>5, &$<adrs>6 );


			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.

				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif
			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<s>3->ObjectSize;
			$<adrs.regnum>$ = $<adrs.regnum>5;
			$<adrs.StaticName>$ = $<adrs.StaticName>5;
			$<adrs.regnum>$ = $<adrs.regnum>5;
			$<adrs.BaseReg>$ = $<adrs.BaseReg>5;
			$<adrs.IndexReg>$ = $<adrs.IndexReg>5;
			$<adrs.Scale>$ = $<adrs.Scale>5;
			$<adrs.Disp>$ = $<adrs.Disp>5;
			$<adrs.Sym>$ = $<adrs.Sym>5;
			$<adrs.SymClass>$ = $<adrs.SymClass>5;
			$<adrs.pClass>$ = $<adrs.pClass>5;

			
			// Memory leak! We have to guarantee that Sym's type matches Type.
			// In order to do this, we have to create a new symbol table entry
			// and copy Sym's data to it (shallow copy is fine) so we can copy
			// the TYPE field to Sym's type without affecting the original
			// symbol's definition.
			
			s = (struct SymNode *) malloc2( sizeof( struct SymNode ));
			memcpy
			( 
				s, 
				$<adrs.Sym>$, 
				sizeof( struct SymNode ) - sizeof( union ValuesSize )
			);
			s->Type = $<s>3;
			s->pType = $<s>3->pType;
			$<adrs.Sym>$ = s;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			
			// Copy the parameter information from the type:
			
			memcpy( &s->u, &$<s>3->u, sizeof( union ValuesSize ));

			FreeAdrs( &$<adrs>6 );
			_here;
		}
	;



SimpleMemoryVar:
		'('					/* $1 */
		typeTkn				/* $2 */
		TypeID				/* $3 */
		SimpleMemoryVar		/* $4 */
		FieldStuff			/* $5 */
		Rparen				/* $6 */
		{					/* $7 */
		
			struct	SymNode	*s;
			
			_here;
			memcpy( &$<adrs>$, &$<adrs>5, sizeof( union YYSTYPE ));
			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif

			/*
			** Copy all the remaining fields not processed by FieldStuff.
			*/

			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<s>3->ObjectSize;

			
			// Memory leak! We have to guarantee that Sym's type matches Type.
			// In order to do this, we have to create a new symbol table entry
			// and copy Sym's data to it (shallow copy is fine) so we can copy
			// the TYPE field to Sym's type without affecting the original
			// symbol's definition.
			
			s = (struct SymNode *) malloc2( sizeof( struct SymNode ));
			memcpy
			( 
				s, 
				$<adrs.Sym>$, 
				sizeof( struct SymNode ) - sizeof( union ValuesSize )
			);
			s->Type = $<s>3;
			s->pType = $<s>3->pType;
			$<adrs.Sym>$ = s;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			
			// Copy the parameter information from the type:
			
			memcpy( &s->u, &$<s>3->u, sizeof( union ValuesSize ));

			FreeAdrs( &$<adrs>4 );
			_here;
		}
	;



SimpleMemoryVar:
		'('					/* $1 */
		typeTkn				/* $2 */
		TypeID				/* $3 */
		fstmt				/* $4 */
		SimpleMemoryVar		/* $5 */
		FieldStuff			/* $6 */
		Rparen				/* $7 */
		{					/* $8 */

			struct	SymNode	*s;
			
			_here;
			memcpy( &$<adrs>$, &$<adrs>6, sizeof( union YYSTYPE ));
			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif

			/*
			** Copy all the remaining fields not processed by FieldStuff.
			*/

			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<s>3->ObjectSize;

			
			// Memory leak! We have to guarantee that Sym's type matches Type.
			// In order to do this, we have to create a new symbol table entry
			// and copy Sym's data to it (shallow copy is fine) so we can copy
			// the TYPE field to Sym's type without affecting the original
			// symbol's definition.
			
			s = (struct SymNode *) malloc2( sizeof( struct SymNode ));
			memcpy
			( 
				s, 
				$<adrs.Sym>$, 
				sizeof( struct SymNode ) - sizeof( union ValuesSize )
			);
			s->Type = $<s>3;
			s->pType = $<s>3->pType;
			$<adrs.Sym>$ = s;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			
			// Copy the parameter information from the type:
			
			memcpy( &s->u, &$<s>3->u, sizeof( union ValuesSize ));

			
			FreeAdrs( &$<adrs>5 );
			_here;
		}
	;



SimpleMemoryVar:
		'('					/* $1 */
		typeTkn				/* $2 */
		TypeID				/* $3 */
		SimpleMemoryVar		/* $4 */
		FieldStuff			/* $5 */
		IndexAdrsMode		/* $6 */
		Rparen				/* $7 */
		{					/* $8 */

			struct	SymNode	*s;
			
			_here;
			memcpy( &$<adrs>$, &$<adrs>5, sizeof( union YYSTYPE ));
			CombineAddresses( &$<adrs>$, &$<adrs>6 );
			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif

			/*
			** Copy all the remaining fields processed by FieldStuff.
			*/

			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<s>3->ObjectSize;

			
			// Memory leak! We have to guarantee that Sym's type matches Type.
			// In order to do this, we have to create a new symbol table entry
			// and copy Sym's data to it (shallow copy is fine) so we can copy
			// the TYPE field to Sym's type without affecting the original
			// symbol's definition.
			
			s = (struct SymNode *) malloc2( sizeof( struct SymNode ));
			memcpy
			( 
				s, 
				$<adrs.Sym>$, 
				sizeof( struct SymNode ) - sizeof( union ValuesSize )
			);
			s->Type = $<s>3;
			s->pType = $<s>3->pType;
			$<adrs.Sym>$ = s;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			
			// Copy the parameter information from the type:
			
			memcpy( &s->u, &$<s>3->u, sizeof( union ValuesSize ));

			FreeAdrs( &$<adrs>4 );
			FreeAdrs( &$<adrs>6 );
			_here;
		}
	;



SimpleMemoryVar:
		'('					/* $1 */
		typeTkn				/* $2 */
		TypeID				/* $3 */
		fstmt				/* $4 */
		SimpleMemoryVar		/* $5 */
		FieldStuff			/* $6 */
		IndexAdrsMode		/* $7 */
		Rparen				/* $8 */
		{					/* $9 */

			struct	SymNode	*s;
			
			_here;
			memcpy( &$<adrs>$, &$<adrs>6, sizeof( union YYSTYPE ));
			CombineAddresses( &$<adrs>$, &$<adrs>7 );
			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif

			/*
			** Copy all the remaining fields processed by FieldStuff.
			*/

			$<adrs.forcedSize>$ = $<s>3->ObjectSize;
			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;

			
			// Memory leak! We have to guarantee that Sym's type matches Type.
			// In order to do this, we have to create a new symbol table entry
			// and copy Sym's data to it (shallow copy is fine) so we can copy
			// the TYPE field to Sym's type without affecting the original
			// symbol's definition.
			
			s = (struct SymNode *) malloc2( sizeof( struct SymNode ));
			memcpy
			( 
				s, 
				$<adrs.Sym>$, 
				sizeof( struct SymNode ) - sizeof( union ValuesSize )
			);
			s->Type = $<s>3;
			s->pType = $<s>3->pType;
			$<adrs.Sym>$ = s;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			
			// Copy the parameter information from the type:
			
			memcpy( &s->u, &$<s>3->u, sizeof( union ValuesSize ));

			FreeAdrs( &$<adrs>5 );
			FreeAdrs( &$<adrs>7 );
			_here;
		}
	;



/*
** Handle type coercion of anonymous memory operands here.
**
**	e.g.,  "( type int8 [ebx] )"
*/

SimpleMemoryVar:
		'('
		typeTkn
		TypeID
		fAnonMem
		Rparen

		{
			struct	SymNode	*s;
			
			_here;
			_if( $<s>3->Arity == 0 )

				/*
				** If a scalar type, set the size to the
				** size of this object.
				*/

				$<adrs.Size>$ = $<s>3->ObjectSize;

			_else

				/*
				** If an array type, set the size to the size
				** of the base type.
				*/

				$<adrs.Size>$ = GetBaseType( $<s>3->Type )->ObjectSize;

			_endif

			/*
			** Note: StaticName cannot be returned as NULL because
			** that would suggest that this variable uses EBP as
			** the base register.
			*/

			$<adrs.StaticName>$ = hlastrdup2("");
			$<adrs.regnum>$ = -1;
			$<adrs.ObjectSize>$ = $<s>3->ObjectSize;
			$<adrs.forcedSize>$ = $<s>3->ObjectSize;
			$<adrs.BaseReg>$ = $<adrs.BaseReg>4;
			$<adrs.IndexReg>$ = $<adrs.IndexReg>4;
			$<adrs.Scale>$ = $<adrs.Scale>4;
			$<adrs.Disp>$ = $<adrs.Disp>4;
			$<adrs.Type>$ = $<s>3;
			$<adrs.pType>$ = $<s>3->pType;
			$<adrs.pClass>$ = valp_pc;
			$<adrs.SymClass>$ = cVar;
			$<adrs.BaseType>$ = $<s>3;
			
			// Create a dummy symbol so that the SYM field is never NULL
			
			s = SymbolTable;
			InsertSym
			( 
				" (anon sym) ", 
				$<s>3,			/* Type							*/
				$<s>3->pType,
				cStatic, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				NULL,			/* No initialization			*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);
			
			$<adrs.Sym>$ = SymbolTable;
			SymbolTable = s;
			_here;
		}
	;



		/*
		** Typical errors to expect:
		*/

SimpleMemoryVar:
		NonLocalVarID
		{
			_here;
			SetReferenced( $<s>1 );
			_if
			( 
					$<s>1->SymClass == cVar 
				||	$<s>1->SymClass == cParm
			)

				yyerror( "Non-local name requires a base register" );

			_endif
			$<adrs.Size>$ = 0;
			$<adrs.forcedSize>$ = 0;
			$<adrs.ObjectSize>$ = 0;
			$<adrs.StaticName>$ = NULL;
			$<adrs.regnum>$ = -1;
			$<adrs.BaseReg>$ = NULL;
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.Disp>$ = 0;
			$<adrs.Sym>$ = $<s>1;
			$<adrs.Type>$ = $<s>1->Type;
			$<adrs.BaseType>$ = $<s>1->Type;
			$<adrs.pType>$ = $<s>1->pType;
			$<adrs.pClass>$ = $<s>1->pClass;
			$<adrs.SymClass>$ = $<s>1->SymClass;
			_here;
		}
	;


SimpleMemoryVar:
		Register			/* $1 */ 
		coloncolonTkn 		/* $2 */
		NotIntermediateVar	/* $3 */
		{
			_here;
			yyerror( "Local and Static objects do not allow base register" );
			$<adrs.Size>$ = 0;
			$<adrs.forcedSize>$ = 0;
			$<adrs.ObjectSize>$ = 0;
			$<adrs.StaticName>$ = NULL;
			$<adrs.regnum>$ = -1;
			$<adrs.BaseReg>$ = NULL;
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.Disp>$ = 0;
			$<adrs.Sym>$ = $<s>3;
			$<adrs.Type>$ = $<s>3->Type;
			$<adrs.BaseType>$ = $<s>3->Type;
			$<adrs.pType>$ = $<s>3->pType;
			$<adrs.pClass>$ = $<s>3->pClass;
			$<adrs.SymClass>$ = $<s>3->SymClass;
			_here;
		}

	;


SimpleMemoryVar:
		Register		/* $1 */
		coloncolonTkn	/* $2 */
		UndefID			/* $3 */
		{
			struct	SymNode *s;
			_here;
			yyerror( "Undefined intermediate ID" );
			$<adrs.Size>$ = 0;
			$<adrs.forcedSize>$ = 0;
			$<adrs.ObjectSize>$ = 0;
			$<adrs.StaticName>$ = NULL;
			$<adrs.regnum>$ = -1;
			$<adrs.BaseReg>$ = NULL;
			$<adrs.IndexReg>$ = NULL;
			$<adrs.Scale>$ = 0;
			$<adrs.Disp>$ = 0;
			$<adrs.Type>$ = &boolean_ste;
			$<adrs.BaseType>$ = &boolean_ste;
			$<adrs.pType>$ = tBoolean;
			$<adrs.pClass>$ = valp_pc;
			$<adrs.SymClass>$ = cStatic;
			
			
			// Create a dummy symbol so that the SYM field is never NULL
			
			s = SymbolTable;
			InsertSym
			( 
				" (anon sym) ", 
				$<adrs.Type>$,	/* Type							*/
				$<adrs.pType>$,
				cStatic, 
				0,				/* Arity						*/
				NULL,			/* Dimensions					*/
				0, 				/* NumElements					*/
				NULL,			/* No initialization			*/
				0,				/* Object size					*/
				0,				/* Offset						*/
				NULL,			/* Static Name					*/
				NULL,			/* Base							*/
				NULL,			/* Fields						*/
				0				/* FieldCnt						*/
			);
			
			$<adrs.Sym>$ = SymbolTable;
			SymbolTable = s;
			_here;
		}
	;




NotIntermediateVar:
		LocalVarID 
	|	LocalStaticID 
	|	NonLocalStaticID
	;






 /*
 ** FieldStuff-
 **
 ** Handles fieldnames for a class, record, or union object.
 **
 **	$<adrs.Type>0 must be a copy of a symbol table entry whose fields we
 ** are searching through.	Note that a call to SimpleMemoryVar always
 ** precedes the FieldStuff grammar symbol.
 **
 ** This production returns a $<adrs> object.  The important return
 ** fields are SymClass, Offset, StaticName, BaseReg, and Comment. 
 ** StaticName contains the static name if this is a static object.
 ** BaseReg will contain "EBP" (or "ESP") if this is a local object 
 ** (determined by looking at $<adrs.BaseReg>0).  
 ** Comment contains the field's name for output as a comment to the 
 ** output file.
 */

FieldStuff:
		recFieldStuff
		{
			/*
			** Merge the <adrs> fields of $1 with the <adrs> fields
			** of $0 and return the combined values as $<adrs>$.
			*/

			_here;
			$<adrs.Size>$ = $<adrs.Size>1;
			$<adrs.forcedSize>$ = 0;
			$<adrs.ObjectSize>$ = $<adrs.Size>1;
			_if
			( 
					IsStaticClass( $<adrs.SymClass>1 )
				&&	$<adrs.StaticName>1 != NULL 
				&&	*$<adrs.StaticName>1 != '\0'
			)

				$<adrs.StaticName>$ = hlastrdup2( $<adrs.StaticName>1 );
				$<adrs.regnum>$ = $<adrs.regnum>1;
				$<adrs.BaseReg>$ = NULL;
				$<adrs.IndexReg>$ = NULL;
				$<adrs.Scale>$ = 0;
				$<adrs.Disp>$ = $<adrs.Disp>1;

			_else

				$<adrs.StaticName>$ = hlastrdup2( $<adrs.StaticName>0 );
				$<adrs.regnum>$ = $<adrs.regnum>0;
				$<adrs.BaseReg>$ = hlastrdup2( $<adrs.BaseReg>0 );
				$<adrs.IndexReg>$ = hlastrdup2( $<adrs.IndexReg>0 );
				$<adrs.Scale>$ = $<adrs.Scale>0;
				$<adrs.Disp>$ = $<adrs.Disp>0 + $<adrs.Disp>1;

			_endif
			$<adrs.Sym>$ = $<adrs.Sym>1;
			$<adrs.Type>$ = $<adrs.Type>1;
			$<adrs.pType>$ = $<adrs.pType>1;

			/*
			** Determining the resulting class is tricky.
			** If the recFieldStuff is static, then the
			** whole thing is static.  If the recFieldStuff
			** is not static and $0 is a parameter, then
			** we go with the $0 class info.  If the two
			** conditions above are false, then we just go
			** with the recFieldStuff class information.
			*/

			_if( IsStaticClass( $<adrs.SymClass>1 ))

				$<adrs.SymClass>$ = $<adrs.SymClass>1;
				$<adrs.pClass>$ = $<adrs.pClass>1;

			_elseif( IsStaticClass( $<adrs.SymClass>0 ))
	   			
				$<adrs.SymClass>$ = $<adrs.SymClass>0;
				$<adrs.pClass>$ = $<adrs.pClass>0;

			_elseif
			(
					( 
							$<adrs.SymClass>0 == cParm 
						&&	NotStaticClass( $<adrs.SymClass>1 )
					)
				||	IsStaticClass( $<adrs.SymClass>0 )
			)

				$<adrs.SymClass>$ = $<adrs.SymClass>0;
				$<adrs.pClass>$ = $<adrs.pClass>0;


			_else

				$<adrs.SymClass>$ = $<adrs.SymClass>1;
				$<adrs.pClass>$ = $<adrs.pClass>1;

			_endif
			FreeAdrs( &$<adrs>1 );
			_here;

		}		
	;





// This production handles all the "intermediate" field names;
// that is, those with periods on both sides of the name.


recFieldStuff:
		PointAtFields	/* $1 */
		PeriodAndSaveST	/* $2 */
		AnyID			/* $3 */
		LookupSym		/* $4   $<s>$ points at sym tbl entry for AnyID	 */
		recFieldStuff	/* $5   Process remaining field names			 */
		{				/* $6 */

			struct SymNode	*sym;
			struct SymNode	*type0;
			struct SymNode	*type5;

			_here;
			
			// The following adrs fields are the same no matter
			// what else happens, so deal with them here.
			

			$<adrs.Scale>$ = 0;
			$<adrs.BaseReg>$ = NULL;
			$<adrs.IndexReg>$ = NULL;

			// For memory objects of the form "(type xxx yyy)" the
			// symbol passed in could be returned as a type ID (xxx),
			// so handle that here.
			
			type0 = $<adrs.Type>0;
			_if( type0 == NULL )
			
				type0 = $<adrs.Sym>0;
				
			_endif
			assert( type0 != NULL );
			
			// SymbolTable is NULL if there was an error along the
			// fieldname list leading up to this point.  If this
			// is the case, don't do any processing since we don't
			// know the validity of any of the pointers.
			

			_if( $<s>1 == NULL )

				// Okay, there is no "Fields" pointer for the
				// previous symbol.  We don't have to print an
				// error message because doing so would be redundant.
				// The previous production will print an appropriate
				// error message since LookUpSym in this production
				// will pass NULL on through to any other names appearing
				// in the field list (which eventually passes NULL as
				// $<s>0 to the production above).
				

				$<adrs.Size>$ = 1;
				$<adrs.forcedSize>$ = 0;
				$<adrs.StaticName>$ = NULL;
				$<adrs.regnum>$ = $<adrs.regnum>0;
				$<adrs.Disp>$ = 0;
				$<adrs.Sym>$ = $<adrs.Sym>0;
				$<adrs.Type>$ = type0;
				$<adrs.pType>$ = $<adrs.pType>0;
				$<adrs.pClass>$ = $<adrs.pClass>0;
				$<adrs.SymClass>$ = $<adrs.SymClass>0;

			_else /* SymbolTable is non-NULL, so no error (yet) */

				/*
				** Okay, lookup the current symbol in the previous
				** symbol's "Fields" symbol table.
				*/

				sym = $<adrs.Sym>4;
				_if( sym != NULL )

					type5 = $<adrs.Type>5;
					_if( type5 == NULL )
					
						type5 = $<adrs.Sym>5;
						
					_endif
					assert( type5 != NULL );
					
					$<adrs.Size>$ = type5->ObjectSize;
					$<adrs.forcedSize>$ = 0;
					$<adrs.ObjectSize>$ = $<adrs.Size>$;
					_if
					( 
							NotStaticClass( $<adrs.SymClass>5 )
						||	$<adrs.StaticName>5 == NULL 
					)

						_if
						( 
								IsStaticClass( sym->SymClass )
							&&	sym->StaticName != NULL 
						)

							/*
							** If FieldStuff's ($5) static name is NULL
							** but AnyID's ($4) is not, then return
							** the static ID of AnyID and the Disp value
							** for FieldStuff.
							*/

							$<adrs.Disp>$ = $<adrs.Disp>5;
							$<adrs.StaticName>$ = hlastrdup2( sym->StaticName );

						_else

							/*
							** If AnyID's static name is NULL and so
							** is FieldStuff's static name, then just
							** return the displacement of these two
							** items.
							*/

							$<adrs.StaticName>$ = NULL;
							$<adrs.Disp>$ = sym->Offset + $<adrs.Disp>5;

						_endif

					_else

						/*
						** If FieldStuff's ($5) StaticName field is non-NULL,
						** then return it's static name and displacement.
						*/

						$<adrs.Disp>$ = sym->Offset + $<adrs.Disp>5;
						$<adrs.StaticName>$ = $<adrs.StaticName>5;

						/*
						** Clear $5's StaticName field so FreeAdrs won't
						** deallocate it later.
						*/

						$<adrs.StaticName>5 = NULL;

					_endif
					$<adrs.Sym>$ = $<adrs.Sym>5;
					$<adrs.Type>$ = type5;
					$<adrs.pType>$ = $<adrs.pType>5;
					$<adrs.pClass>$ = $<adrs.pClass>5;
					$<adrs.regnum>$ = $<adrs.regnum>5;

					_if( IsStaticClass( $<adrs.SymClass>5 ))

						$<adrs.SymClass>$ = $<adrs.SymClass>5;

					_else

						$<adrs.SymClass>$ = sym->SymClass;

					_endif

				_else

					/*
					** If the field name doesn't appear in the current
					** symbol table (field list), this section prints
					** an appropriate error message.
					*/

					char msg[ 256 ];

					sprintf( msg, "Undefined field name <<%s>>", $<neID.idStr>3 );
					yyerror( msg );
					$<adrs.Size>$ = 1;
					$<adrs.forcedSize>$ = 0;
					$<adrs.ObjectSize>$ = 1;
					$<adrs.StaticName>$ = NULL;
					$<adrs.regnum>$ = -1;
					$<adrs.Disp>$ = 0;
					$<adrs.Sym>$ = $<adrs.Sym>0;
					$<adrs.Type>$ = type0;
					$<adrs.pType>$ = $<adrs.pType>0;
					$<adrs.pClass>$ = $<adrs.pClass>0;
					$<adrs.SymClass>$ = $<adrs.SymClass>0;

				_endif

			_endif
			_if
			( 
					IsStaticClass( $<adrs.SymClass>0 ) 
				&&	NotStaticClass( $<adrs.SymClass>$ )
			)

				$<adrs.SymClass>$ = $<adrs.SymClass>0;

			_endif
 
			free2( vss $<neID.idStr>3 );
			FreeAdrs( &$<adrs>5 );
			_here;
		}
	;


/*
** This production processes the last fieldname
** in a qualified field name list.
*/

recFieldStuff:
		PointAtFields	/* $1 */
		PeriodAndSaveST	/* $2 */
		AnyID			/* $3 */
		{				/* $4 */

			struct SymNode	*sym;
			struct SymNode	*type0;

			_here;

			SymbolTable = $<s>2;

			type0 = $<adrs.Type>0;
			_if( type0 == NULL )
			
				type0 = $<adrs.Sym>0;
				
			_endif
			assert( type0 != NULL );
			
			// $<s>1 (PointAtFields) is NULL if there was an error along the
			// fieldname list leading up to this point.  If this
			// is the case, don't do any processing since we don't
			// know the validity of any of the pointers.
			

			_if( $<s>1 == NULL )
			
				_here;

				/*
				** Okay, there is no "Fields" pointer for the
				** previous symbol.  This is definitely an
				** error so we should display the error message
				** and quit.  Also, return some fake information
				** to keep the calling code happy.
				*/

				yyerror( "Expected Class, Record, or Union type" );
				
				$<adrs.Size>$ = 1;
				$<adrs.forcedSize>$ = 0;
				$<adrs.ObjectSize>$ = 1;
				$<adrs.StaticName>$ = NULL;
				$<adrs.regnum>$ = -1;
				$<adrs.BaseReg>$ = NULL;
				$<adrs.IndexReg>$ = NULL;
				$<adrs.Scale>$ = 0;
				$<adrs.Disp>$ = 0;
				$<adrs.Sym>$ = $<adrs.Sym>0;
				$<adrs.Type>$ = type0;					
				$<adrs.pType>$ = $<adrs.pType>0;
				$<adrs.pClass>$ = $<adrs.pClass>0;
				$<adrs.SymClass>$ = $<adrs.SymClass>0;

			_else /* SymbolTable is non-NULL, so no error (yet) */

				_here;

				
				// Okay, lookup the current symbol in the previous
				// symbol's "Fields" symbol table.
				
				sym = lookupin( $<neID.idStr>3, $<s>1 );
				_if( sym != NULL )

					
					// The symbol exists.  This is good!
					// Now fill in the adrs fields with the
					// data gleened from this symbol.
					//
					//	Begin by computing the object's size.
					//	If it's an array, we want the size of
					//	an element, not the size of the whole array.
					
					_here;
					_if( sym->Arity == 0 )

						/*
						** If a scalar type, set the size to the
						** size of this object.
						*/

						$<adrs.Size>$ = sym->ObjectSize;
						$<adrs.ObjectSize>$ = $<adrs.Size>$;

					_else

						
						// If an array type, set the size to the size
						// of the base type.
						

						$<adrs.Size>$ = sym->Type->ObjectSize;
						$<adrs.ObjectSize>$ = sym->ObjectSize;

					_endif
					$<adrs.forcedSize>$ = 0;

					/*
					** If this object is static, pass back it's
					** static name and a displacement of zero.
					** If it's not static, just pass back the
					** symbol's Offset as the displacement.
					*/

					_here;
					_if( IsStaticClass( sym->SymClass ))

						$<adrs.StaticName>$ = hlastrdup2( sym->StaticName );
						$<adrs.Disp>$ = 0;
				
					_else

						$<adrs.Disp>$ = sym->Offset;
						$<adrs.StaticName>$ = NULL;

					_endif
					$<adrs.BaseReg>$ = NULL;
					$<adrs.IndexReg>$ = NULL;
					$<adrs.Scale>$ = 0;
					$<adrs.regnum>$ = -1;
					$<adrs.Sym>$ = sym;
					$<adrs.pType>$ = sym->pType;
					$<adrs.regnum>$ = sym->regnum;
					_here;
					_if( sym->pType == tProcptr )

						$<adrs.Type>$ = &proctype_ste;

					_else

						$<adrs.Type>$ = 
							_ifx( sym->Type == NULL, sym, sym->Type );

					_endif
					$<adrs.pClass>$ = sym->pClass;
					$<adrs.SymClass>$ = sym->SymClass;
					_here;
					_if
					( 
							IsStaticClass( $<adrs.SymClass>0 )
						&&	NotStaticClass( sym->SymClass )
					)

						$<adrs.SymClass>$ = $<adrs.SymClass>0;

					_endif

				_else

					
					// If the field name doesn't appear in the current
					// symbol table (field list), this section prints
					// an appropriate error message and sets up the
					// return values to indicate an undefined variable.
					

					char msg[ 256 ];

					sprintf( msg, "Undefined field name <<%s>>", $<neID.idStr>3 );
					yyerror( msg );
					$<adrs.Size>$ = 1;
					$<adrs.forcedSize>$ = 0;
					$<adrs.ObjectSize>$ = 1;
					$<adrs.StaticName>$ = NULL;
					$<adrs.regnum>$ = $<adrs.regnum>0;
					$<adrs.BaseReg>$ = NULL;
					$<adrs.IndexReg>$ = NULL;
					$<adrs.Scale>$ = 0;
					$<adrs.Disp>$ = 0;
					$<adrs.Sym>$ = $<adrs.Sym>0;
					$<adrs.Type>$ = 
						_ifx
						( 
							$<adrs.Type>0 == NULL, 
							$<adrs.Sym>0, 
							$<adrs.Type>0 
						);
					
					$<adrs.pType>$ = $<adrs.pType>0;
					$<adrs.pClass>$ = $<adrs.pClass>0;
					$<adrs.SymClass>$ = $<adrs.SymClass>0;

				_endif

			_endif
			free2( vss $<neID.idStr>3 );
			_here;
		}
	;


PeriodAndSaveST:
		'.'
		{
			_here;
			$<s>$ = SymbolTable;
			SymbolTable = &dummy_ste;
		}
	;







	/*
	** This production looks up the "AnyID" symbol in the FieldStuff
	** production.  It sets its attribute value $<adrs.Sym>$ to the symbol
	** table entry for that field name (NULL if the field name does not
	** exist).  If an error occurs, this code also sets SymbolTable to
	** NULL (the FieldStuff production preserves SymbolTable, so we won't
	** lose the symbol table info by doing this). If the current field
	** is a class, record, or union object, then this code points the
	** SymbolTable variable at the field list for that class/record/union.
	**
	** Parameters to this production:
	**
	**	$<s>-2:		PointAtFields value.
	**	$<idStr>0:	Identifier we are looking up.
	*/

LookupSym:
		{
			struct SymNode *sym;

			/*
			** Restore saved SymbolTable value from
			** "PeriodAndSaveST".
			*/

			_here;
			SymbolTable = $<s>-1;

			/*
			** If there is an outstanding error, don't bother with
			** this operation since we can guarantee its consistency.
			*/

			_if( $<s>-2 != NULL )	/* PointAtFields value */

				/*
				** Okay, no error so far, look up the symbol in the
				** current field list (pointed at by SymbolTable).
				** Since LookupSym is called from the FieldStuff
				** production that handles interior names in the
				** field list, the name we are looking up must be
				** a record, union, or class type (since those are
				** the only names that allow periods on both sides
				** of the name).
				*/

				sym = lookupin( $<idStr>0, $<s>-2 );

				_if( sym != NULL )

					_if
					( 
							sym->pType == tRecord 
						||	sym->pType == tUnion
						||	sym->pType == tClass 
					)

						$<adrs.Sym>$ = sym;
						$<adrs.Type>$ = sym->Type;

					_elseif
					(
							sym->pType == tArray
						&&	sym->Type != NULL
						&&	(
									sym->Type->pType == tRecord 
								||	sym->Type->pType == tUnion
								||	sym->Type->pType == tClass
							)
					)
					 
						$<adrs.Sym>$ = sym;
						$<adrs.Type>$ = sym->Type;

					_else

						yyerror( "Illegal field specification" );
						$<adrs.Sym>$ = NULL;	/* Denote an error */
						$<adrs.Type>$ = NULL;

					_endif

				_else

					char msg[ 256 ];

					sprintf( msg, "Undefined field name <<%s>>", $<idStr>0 );
					yyerror( msg );
					$<adrs.Sym>$ = NULL; /* Denote an error */
					$<adrs.Type>$ = NULL;

				_endif

			_endif
			_here;
		}
	;



/*
** The following is a quick utility function that points
** the $<s>$ attribute at the current field list of the
** symbol located by the LookupSym production or the original
** class/record/union object that got us into this code.
*/

PointAtFields:
		{
			struct	SymNode	*s;
			_here;
			_if( $<adrs.Type>0 != NULL )

				_if( $<adrs.Type>0->pType == tPointer )

					_if( $<adrs.Sym>0 != NULL )

						/*
						** If it's a variable, link off the Sym field.
						*/

						_if( $<adrs.Sym>0->Base == NULL )

								yyerror
								( 
									"Dot operator applied to ID w/o fields" 
								);
								$<s>$ = NULL;
							
						_else

							$<s>$ = $<adrs.Sym>0->Base->Fields;

						_endif

					_else

						/*
						** If adrs.Sym is NULL then index off the
						** Type field rather than the sym field.
						*/

						_if( $<adrs.Type>0->Base == NULL )

								yyerror
								( 
									"Dot operator applied to ID w/o fields" 
								);
								$<s>$ = NULL;
							
						_else

							$<s>$ = $<adrs.Type>0->Base->Fields;

						_endif

					_endif

				_elseif( $<adrs.Type>0->pType == tArray )
				
					assert( $<adrs.Type>0->Type != NULL );
					$<s>$ = $<adrs.Type>0->Type->Fields;
				
					
				_else

					$<s>$ = $<adrs.Type>0->Fields;

				_endif

				
			_elseif( $<adrs.Sym>0 != NULL )
 
				_if( $<adrs.Sym>0->pType == tPointer )

					assert( $<adrs.Sym>0->Base != NULL );
					$<s>$ = $<adrs.Sym>0->Base->Fields;

				_elseif
				( 
						$<adrs.Sym>0->pType == tArray 
					&&	GetBaseType( $<adrs.Sym>0 )->pType == tPointer
				)

					assert( $<adrs.Sym>0->Base != NULL );
					$<s>$ = $<adrs.Sym>0->Base->Fields;

				_else

					$<s>$ = $<adrs.Sym>0->Fields;

				_endif

			_else

				$<s>$ = NULL;

			_endif
			_here;
		}
	;










/*
** Match a floating point register and return
** the true MASM name as the return attribute.
*/

cls_fpReg:
		st0Tkn
	|	st1Tkn
	|	st2Tkn
	|	st3Tkn
	|	st4Tkn
	|	st5Tkn
	|	st6Tkn
	|	st7Tkn
	;






/***************************************************************************/


/*
** Classify-
**
**	This set of productions classifies a string as one of the
**	following:
**
**	(1) An eight-bit general purpose register
**	(2) A 16-bit general purpose register
**	(3) A 32-bit general purpose register
**	(4)	A single identifier
**	(5) A constant expression
**	(6)	A memory address
**	(7) None of the above.
*/

				  

Classify:
		UnprocessedID	/* $1 */
		AnyExpr			/* $2 */
		ProcessedID		/* $3 */
		{				/* $4 */

			_here;
			$<cls.cls>$ = $<cls.cls>2;
			$<cls.sym>$ = $<cls.sym>2;
			$<cls.arity>$ = $<cls.arity>2;
			$<cls.type>$ = $<cls.type>2;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
			_here;
		}


	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		AnyExpr			/* $3 */
		ProcessedID		/* $4 */
		{				/* $5 */

			_here;
			$<cls.cls>$ = $<cls.cls>3;
			$<cls.sym>$ = $<cls.sym>3;
			$<cls.arity>$ = $<cls.arity>3;
			$<cls.type>$ = $<cls.type>3;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
			_here;
		}


	|	UnprocessedID	/* $1 */
		AnyMemory		/* $2 */
		ProcessedID		/* $3 */
		{				/* $4 */

			_here;
			$<cls.cls>$ = $<cls.cls>2 & ~cfy_SingleID;
			$<cls.sym>$ = $<cls.sym>2;
			$<cls.arity>$ = $<cls.arity>2;
			$<cls.type>$ = $<cls.type>2;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
			_here;
		}

	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		AnyMemory		/* $3 */
		ProcessedID		/* $4 */
		{				/* $5 */

			_here;
			$<cls.cls>$ = $<cls.cls>3 & ~cfy_SingleID;
			$<cls.sym>$ = $<cls.sym>3;
			$<cls.arity>$ = $<cls.arity>3;
			$<cls.type>$ = $<cls.type>3;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
			_here;
		}

	|	UnprocessedID	/* $1 */
		CoercedMemory	/* $2 */
		ProcessedID		/* $3 */
		{				/* $4 */

			_here;
			$<cls.cls>$ = $<cls.cls>2 & ~cfy_SingleID;
			$<cls.sym>$ = $<cls.sym>2;
			$<cls.arity>$ = $<cls.arity>2;
			$<cls.type>$ = $<cls.type>2;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
			_here;
		}

	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		CoercedMemory	/* $3 */
		ProcessedID		/* $4 */
		{				/* $5 */

			_here;
			$<cls.cls>$ = $<cls.cls>3 & ~cfy_SingleID;
			$<cls.sym>$ = $<cls.sym>3;
			$<cls.arity>$ = $<cls.arity>3;
			$<cls.type>$ = $<cls.type>3;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
			_here;
		}

	|	UnprocessedID	/* $1 */
		Reg8a			/* $2 */
		ProcessedID		/* $3 */
		{				/* $4 */

			_here;
			$<cls.cls>$ = cfy_Reg8 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 1;
			_here;
		}

	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		Reg8a			/* $3 */
		ProcessedID		/* $4 */
		{				

			_here;
			$<cls.cls>$ = cfy_Reg8 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 1;
			_here;
		}

	|	UnprocessedID	/* $1 */
		'('				/* $2 */
		typeTkn			/* $3 */
		UndefID			/* $4 */
		Reg8a			/* $5 */
		Rparen			/* $6 */
		ProcessedID		/* $7 */
		{				/* $8 */

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>4, SymbolTable );
			_if( s == NULL || s->SymClass != cType )

				yyerror( "Expected a type identifier" );
				s = &byte_ste;

			_elseif( s->ObjectSize != 1 )

				yyerror( "Coercion type's size must be one byte" );
				s = &byte_ste;

			_endif
			$<cls.cls>$ = cfy_Reg8 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= s;
			$<cls.ObjectSize>$ = s->ObjectSize;
			$<cls.arity>$ = 0;
			free2( vss $<idStr>4 );
			_here;
		}



	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		'('				/* $3 */
		typeTkn			/* $4 */
		UndefID			/* $5 */
		Reg8a			/* $6 */
		Rparen			/* $7 */
		ProcessedID		/* $8 */
		{				/* $9 */

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>5, SymbolTable );
			_if( s == NULL || s->SymClass != cType )

				yyerror( "Expected a type identifier" );
				s = &byte_ste;

			_elseif( s->ObjectSize != 1 )

				yyerror( "Coercion type's size must be one byte" );
				s = &byte_ste;

			_endif
			$<cls.cls>$ = cfy_Reg8 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= s;
			$<cls.ObjectSize>$ = s->ObjectSize;
			$<cls.arity>$ = 0;
			free2( vss $<idStr>5 );
			_here;
		}


	|	UnprocessedID	/* $1 */
		Reg16a			/* $2 */
		ProcessedID		/* $3 */
		{				/* $4 */

			_here;
			$<cls.cls>$ = cfy_Reg16 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 2;
			_here;
		}

	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		Reg16a			/* $3 */
		ProcessedID		/* $4 */
		{				

			_here;
			$<cls.cls>$ = cfy_Reg16 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 2;
			_here;
		}

	|	UnprocessedID	/* $1 */
		'('				/* $2 */
		typeTkn			/* $3 */
		UndefID			/* $4 */
		fReg16			/* $5 */
		Rparen			/* $6 */
		ProcessedID		/* $7 */
		{				/* $8 */

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>4, SymbolTable );
			_if( s == NULL || s->SymClass != cType )

				yyerror( "Expected a type identifier" );
				s = &word_ste;

			_elseif( s->ObjectSize != 2 )

				yyerror( "Coercion type's size must be two bytes" );
				s = &word_ste;

			_endif
			$<cls.cls>$ = cfy_Reg16 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= s;
			$<cls.ObjectSize>$ = s->ObjectSize;
			$<cls.arity>$ = 0;
			free2( vss $<idStr>4 );
			_here;
		}


	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		'('				/* $3 */
		typeTkn			/* $4 */
		UndefID			/* $5 */
		fReg16			/* $6 */
		Rparen			/* $7 */
		ProcessedID		/* $8 */
		{				

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>5, SymbolTable );
			_if( s == NULL || s->SymClass != cType )

				yyerror( "Expected a type identifier" );
				s = &word_ste;

			_elseif( s->ObjectSize != 2 )

				yyerror( "Coercion type's size must be two bytes" );
				s = &word_ste;

			_endif
			$<cls.cls>$ = cfy_Reg16 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= s;
			$<cls.ObjectSize>$ = s->ObjectSize;
			$<cls.arity>$ = 0;
			free2( vss $<idStr>5 );
			_here;
		}


	|	UnprocessedID	/* $1 */
		Reg32a			/* $2 */
		ProcessedID		/* $3 */
		{				/* $4 */

			_here;
			$<cls.cls>$ = cfy_Reg32 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 4;
			_here;
		}

	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		Reg32a			/* $3 */
		ProcessedID		/* $4 */
		{				

			_here;
			$<cls.cls>$ = cfy_Reg32 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 4;
			_here;
		}

	|	UnprocessedID	/* $1 */
		'('				/* $2 */
		typeTkn			/* $3 */
		UndefID			/* $4 */
		Reg32a			/* $5 */
		Rparen			/* $6 */
		ProcessedID		/* $7 */
		{				/* $8 */

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>4, SymbolTable );
			_if( s == NULL || s->SymClass != cType )

				yyerror( "Expected a type identifier" );
				s = &dword_ste;

			_elseif( s->ObjectSize != 4 )

				yyerror( "Coercion type's size must be four bytes" );
				s = &dword_ste;

			_endif
			$<cls.cls>$ = cfy_Reg32 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= s;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = s->ObjectSize;
			free2( vss $<idStr>4 );
			_here;
		}


	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		'('				/* $3 */
		typeTkn			/* $4 */
		UndefID			/* $5 */
		Reg32a			/* $6 */
		Rparen			/* $7 */
		ProcessedID		/* $8 */
		{				

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>5, SymbolTable );
			_if( s == NULL || s->SymClass != cType )

				yyerror( "Expected a type identifier" );
				s = &dword_ste;

			_elseif( s->ObjectSize != 4 )

				yyerror( "Coercion type's size must be four bytes" );
				s = &dword_ste;

			_endif
			$<cls.cls>$ = cfy_Reg32 | cfy_Reg | cfy_BooleanExpr;
			$<cls.sym>$ = NULL;
			$<cls.type>$= s;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = s->ObjectSize;
			free2( vss $<idStr>5 );
			_here;
		}


	|	UnprocessedID	/* $1 */
		cls_fpReg		/* $2 */
		ProcessedID		/* $3 */
		{				/* $4 */

			_here;
			$<cls.cls>$ = cfy_fpReg;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.ObjectSize>$ = 10;
			$<cls.arity>$ = 0;
			_here;
		}

	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		cls_fpReg		/* $3 */
		ProcessedID		/* $4 */
		{				/* $5 */

			_here;
			$<cls.cls>$ = cfy_fpReg;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 10;
			_here;
		}

	|	UnprocessedID	/* $1 */
		mmxReg_a		/* $2 */
		ProcessedID		/* $3 */
		{				/* $4 */

			_here;
			$<cls.cls>$ = cfy_mmxReg;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.ObjectSize>$ = 8;
			$<cls.arity>$ = 0;
			_here;
		}

	|	UnprocessedID	/* $1 */
		fstmt			/* $2 */
		mmxReg_a		/* $3 */
		ProcessedID		/* $4 */
		{				/* $5 */

			_here;
			$<cls.cls>$ = cfy_mmxReg;
			$<cls.sym>$ = NULL;
			$<cls.type>$= NULL;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 8;
			_here;
		}
	;
	
		


		


 /*
 ** UnprocessedID-
 ** This turns off the ProcessID function in the lexer.
 ** After executing this code, the lexer doesn't look up
 ** identifiers, instead it just returns the UndefID token.
 */

UnprocessedID:
		{
			_here;
			startUnprocessedID();
			_here;
		}
	;

 /*
 ** ProcessedID-
 **
 **	This production turns lexer ID processing back on.
 */

ProcessedID:
		{
			_here;
			Begin0();
			_here;
		}
	;





 /*
 ** AnyMemory matches those things that *must* be
 ** memory address expressions (specifically, things
 ** that have indexes [with registers] attached to them).
 */

AnyMemory:
		UndefID			/* $1 */
		AnyIndex		/* $2 */
		{				/* $3 */

			_here;
			setMemoryClassification( YYS &$<cls>$, $<idStr>1 );
			free2( vss $<idStr>1 );
			_here;
		}

	|	UndefID			/* $1 */
		ScaledIndexMode	/* $2 */
		{				/* $3 */

			_here;
			setMemoryClassification( YYS &$<cls>$, $<idStr>1 );
			free2( vss $<idStr>1 );
			_here;
		}

	|	UndefID			/* $1 */
		ScaledIndexMode	/* $2 */
		BracketedExpr	/* $3 */
		{				/* $4 */

			_here;
			setMemoryClassification( YYS &$<cls>$, $<idStr>1 );
			free2( vss $<idStr>1 );
			_here;
		}

	|	UndefID			/* $1 */
		ScaledIndexPlus	/* $2 */
		{				/* $3 */

			_here;
			setMemoryClassification( YYS &$<cls>$, $<idStr>1 );
			free2( vss $<idStr>1 );
			_here;
		}

	|	AnyIndex
		{

			_here;
			$<cls.cls>$ = cfy_MemoryExpr | cfy_AnonMem;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = NULL;
			$<cls.ObjectSize>$ = 1;
			$<cls.arity>$ = 0;
			_here;
		}

	;

CoercedMemory:
		'('				/* $1 */
		typeTkn			/* $2 */
		UndefID			/* $3 */
		AnyMemory		/* $4 */
		')'				/* $5 */
		optionalIndex	/* $6 */
		{

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>3, SymbolTable );
			_if( s == NULL )

				yyerror( "Undefined data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->SymClass != cType )

				yyerror( "Expected a data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_else

				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = s;
				$<cls.arity>$ = s->Arity;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = s->ObjectSize;
				_if
				( 
						s->pType == tBoolean 
					||	s->pType == tByte
					||	s->pType == tWord
					||	s->pType == tDWord
				)

					$<cls.cls>$ |= cfy_BooleanExpr;

				_endif

			_endif
			_here;
		}


	|	'('				/* $1 */
		typeTkn			/* $2 */
		UndefID			/* $3 */
		CoercedMemory	/* $4 */
		')'				/* $5 */
		optionalIndex	/* $6 */
		{

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>3, SymbolTable );
			_if( s == NULL )

				yyerror( "Undefined data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->SymClass != cType )

				yyerror( "Expected a data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_else

				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = s;
				$<cls.arity>$ = s->Arity;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = s->ObjectSize;
				_if
				( 
						s->pType == tBoolean 
					||	s->pType == tByte
					||	s->pType == tWord
					||	s->pType == tDWord
				)

					$<cls.cls>$ |= cfy_BooleanExpr;

				_endif

			_endif
			_here;
		}


	|	'('				/* $1 */
		typeTkn			/* $2 */
		UndefID			/* $3 */
		AnyMemory		/* $4 */
		')'				/* $5 */
		'.'				/* $6 */
		UndefID			/* $7 */
		optionalIndex	/* $8 */
		{

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>3, SymbolTable );
			_if( s == NULL )

				yyerror( "Undefined data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->SymClass != cType )

				yyerror( "Expected a data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->Fields == NULL )
			
				yyerror
				( 
					"Expected a class, record, or union type in coercion operator" 
				);
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;
		
			_else
			
				struct SymNode *t;

				t = ClassifyLookup( $<idStr>7, s->Fields );
				setMemoryClassification_sym( YYS &$<cls>$, t );
				
				_if
				( 
						s->pType == tBoolean 
					||	s->pType == tByte
					||	s->pType == tWord
					||	s->pType == tDWord
				)

					$<cls.cls>$ |= cfy_BooleanExpr;

				_endif

			_endif
			_here;
		}


	|	'('				/* $1 */
		typeTkn			/* $2 */
		UndefID			/* $3 */
		CoercedMemory	/* $4 */
		')'				/* $5 */
		'.'				/* $6 */
		UndefID			/* $7 */
		optionalIndex	/* $8 */
		{

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>3, SymbolTable );
			_if( s == NULL )

				yyerror( "Undefined data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->SymClass != cType )

				yyerror( "Expected a data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->Fields == NULL )
			
				yyerror
				( 
					"Expected a class, record, or union type in coercion operator" 
				);
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;
		
			_else
			
				struct SymNode *t;

				t = ClassifyLookup( $<idStr>7, s->Fields );
				setMemoryClassification_sym( YYS &$<cls>$, t );
				
				_if
				( 
						s->pType == tBoolean 
					||	s->pType == tByte
					||	s->pType == tWord
					||	s->pType == tDWord
				)

					$<cls.cls>$ |= cfy_BooleanExpr;

				_endif

			_endif
			_here;
		}


	|	'('				/* $1 */
		typeTkn			/* $2 */
		UndefID			/* $3 */
		AnyExpr			/* $4 */
		')'				/* $5 */
		optionalIndex	/* $6 */
		{

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>3, SymbolTable );
			_if( s == NULL )

				yyerror( "Undefined data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->SymClass != cType )

				yyerror( "Expected a data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif(( $<cls.cls>4 & cfy_MemoryExpr ) == 0 )

				yyerror( "Expected a memory operand" );
				$<cls.cls>$ = ($<cls.cls>4 | cfy_MemoryExpr ) & ~cfy_ConstExpr;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_else

				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = s;
				$<cls.arity>$ = s->Arity;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = s->ObjectSize;
				_if
				( 
						s->pType == tBoolean 
					||	s->pType == tByte
					||	s->pType == tWord
					||	s->pType == tDWord
				)

					$<cls.cls>$ |= cfy_BooleanExpr;

				_endif

			_endif
			_here;
		}

	|	'('				/* $1 */
		typeTkn			/* $2 */
		UndefID			/* $3 */
		AnyExpr			/* $4 */
		')'				/* $5 */
		'.'				/* $6 */
		UndefID			/* $7 */
		optionalIndex	/* $8 */
		{

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>3, SymbolTable );
			_if( s == NULL )

				yyerror( "Undefined data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->SymClass != cType )

				yyerror( "Expected a data type in coercion operator" );
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->Fields == NULL )
			
				yyerror
				( 
					"Expected a class, record, or union type in coercion operator" 
				);
				$<cls.cls>$ = $<cls.cls>4;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = $<cls.arity>4;
				$<cls.sym>$ = $<cls.sym>4;
				$<cls.ObjectSize>$ = 1;
		
			_else
			
				struct SymNode *t;

				t = ClassifyLookup( $<idStr>7, s->Fields );
				setMemoryClassification_sym( YYS &$<cls>$, t );

				_if
				( 
						s->pType == tBoolean 
					||	s->pType == tByte
					||	s->pType == tWord
					||	s->pType == tDWord
				)

					$<cls.cls>$ |= cfy_BooleanExpr;

				_endif

			_endif
			_here;
		}


	;

// optionalIndex --
// Allows either an indirect memory reference (invoving
// registers and indexed addressing modes) or constant offsets.

optionalIndex:
		/* empty */
	|	AnyIndex
	|	BracketedExpr
	;

 /*
 ** AnyIndex-
 **
 ** Match an index-based addressing mode.
 */

AnyIndex:

		/*
		** Handle indicies like
		**
		**	[reg+reg*scale+disp] 
		**
		**	here.
		*/

		FullIndex		/* $1 */
		{				/* $2 */

			_here;
		}
		
		/*
		** Handle "[reg][reg]" here.
		*/

	|	SingleIndex		/* $1 */
		SingleIndex		/* $2 */
		{				/* $3 */

			_here;
		}
		
		/*
		** Handle "[reg][reg*scale]" here.
		*/

	|	SingleIndex		/* $1 */
		ScaledIndexMode	/* $2 */
		{				/* $3 */

			_here;
		}

		/*
		** Handle "[reg][expr]" here.
		*/

	|	SingleIndex		/* $1 */
		BracketedExpr	/* $2 */
		{				/* $3 */

			_here;
		}
		
		/*
		** Handle "[reg][reg][expr]" here.
		*/

	|	SingleIndex		/* $1 */
		SingleIndex		/* $2 */
		BracketedExpr	/* $3 */
		{				/* $4 */

			_here;
		}

		/*
		** Handle "[reg][reg*scale][expr]" here.
		*/

	|	SingleIndex		/* $1 */
		ScaledIndexMode	/* $2 */
		BracketedExpr	/* $3 */
		{				/* $4 */

			_here;
		}
	;



SingleIndex:
		'['				/* $1 */
		fReg32			/* $2 */
		']'				/* $3 */
		{				/* $4 */
			_here;
		}
	;

ScaledIndexMode:
		'['				/* $1 */
		fReg32			/* $2 */
		'*'				/* $3 */
		intconst		/* $4 */
		']'				/* $5 */
		{				/* $6 */

			int index = $<v.u.unsval>4;

			_here;
			_if
			( 
					numBits32( YYS &$<v>4 ) > 32
				||	(
							index != 1 
						&&	index != 2
						&&	index != 4
						&&	index != 8
					)
			)

				yyerror( "Illegal scaled index value" );

			_endif
			_here;
		}
	;

ScaledIndexPlus:
		'['				/* $1 */
		fReg32			/* $2 */
		'*'				/* $3 */
		intconst		/* $4 */
		'+'				/* $5 */
		AnyExpr			/* $6 */
		']'				/* $7 */
		{				/* $8 */

			int index = $<v.u.unsval>4;

			_here;
			_if
			( 
					numBits32( YYS &$<v>4 ) > 32
				||	(
							index != 1 
						&&	index != 2
						&&	index != 4
						&&	index != 8
					)
			)

				yyerror( "Illegal scaled index value" );

			_endif
			_if( ( $<cls.cls>6 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif
			_here;

		}
	;

ScaledIndexPlus:
		'['				/* $1 */
		fReg32			/* $2 */
		'*'				/* $3 */
		intconst		/* $4 */
		'-'				/* $5 */
		AnyExpr			/* $6 */
		']'				/* $7 */
		{				/* $8 */

			int index = $<v.u.unsval>4;

			_here;
			_if
			( 
					numBits32( YYS &$<v>4 ) > 32
				||	(
							index != 1 
						&&	index != 2
						&&	index != 4
						&&	index != 8
					)
			)

				yyerror( "Illegal scaled index value" );

			_endif
			_if( ( $<cls.cls>6 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif
			_here;
		}
	;



		/*
		** Handle indicies like
		**
		**	[reg+reg*scale+disp] 
		**
		**	here.
		*/

FullIndex:
		'['				/* $1 */
		fReg32			/* $2 */
		']'				/* $3 */
		{				/* $4 */

			_here;
		}

	|	'['				/* $1 */
		fReg32			/* $2 */
		'+'				/* $3 */
		AnyExpr			/* $4 */
		']'				/* $5 */
		{				/* $6 */

			_here;
			_if( ( $<cls.cls>4 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif
		}

	|	'['				/* $1 */
		fReg32			/* $2 */
		'-'				/* $3 */
		AnyExpr			/* $4 */
		']'				/* $5 */
		{				/* $6 */

			_here;
			_if( ( $<cls.cls>4 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif
		}

	|	'['				/* $1 */
		fReg32			/* $2 */
		'+'				/* $3 */
		fReg32			/* $4 */
		OptionalScaled	/* $5 */
		OptDisp			/* $6 */
		']'				/* $7 */
		{				/* $8 */
			_here;
		}
	;

OptionalScaled:
		Empty

	|	'*'				/* $1 */
		intconst		/* $2 */
		{				/* $3 */

			int index = $<v.u.unsval>2;

			_here;
			_if
			( 
					numBits32( YYS &$<v>2 ) > 32
				||	(
							index != 1 
						&&	index != 2
						&&	index != 4
						&&	index != 8
					)
			)

				yyerror( "Illegal scaled index value" );

			_endif
			_here;
		}
	;

OptDisp:
		Empty

	|	'+'				/* $1 */
		AnyExpr			/* $2 */
		{				/* $3 */

			_here;
			_if( ( $<cls.cls>2 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif

		}

	|	'-'				/* $1 */
		AnyExpr			/* $2 */
		{				/* $3 */

			_here;
			_if( ( $<cls.cls>2 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif

		}
	;




BracketedExpr:
		'['				/* $1 */
		AnyExpr			/* $2 */
		']'				/* $3 */
		{				/* $4 */

			_here;
			_if( ( $<cls.cls>2 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif
		}
	;




/*
** Handle arbitrary expressions.
** These are usually constant expressions.  However, there
** are two special cases for memory objects that these productions
** must handle:
**
**	(1)	A single identifier
**	(2) A single identifier following by "[" AnyExpr "]"
**
**	If the identifiers are memory objects, these productions
**	must treat these expressions as memory expressions.  Syntactically,
**	there is no way to differentiate these sequences from constant
**	expressions, so we must handle this semantically.
*/

AnyExpr:
		UndefID			/* $1 */
		'['				/* $2 */
		AnyExpr			/* $3 */
		']'				/* $4 */
		{				/* $5 */

			struct SymNode *s;

			_here;
			setClassification( YYS &$<cls>$, $<idStr>1 );
			_if( ( $<cls.cls>3 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif
			_if( $<cls.cls>$ & cfy_IsArray )

				_if( $<cls.cls>$ & cfy_ConstExpr )

					/*
					** Okay, it's a constant and it's an array.
					** We've got to look this symbol up in order
					** to determine it's arity.  This will tell
					** us whether applying an index to it still
					** produces an array.
					*/
						
					_if(( $<cls.sym>$ == NULL ) || ( $<cls.sym>$->Arity <= 1 ))					

						unArray( YYS &$<cls>$ );
						$<cls.arity>$ = $<cls.arity>$ - 1;

					_endif

				_else

					/*
					** It's probably a memory object.  Regardless, it's
					** not a constant so drop the array classification.
					*/

					unArray( YYS &$<cls>$ );
					$<cls.arity>$ = 0;

				_endif

			_endif

			/*
			** This isn't a single ID, so clear that bit if set.
			*/

			$<cls.cls>$ &= ~cfy_SingleID;
			free2( vss $<idStr>1 );
			_here;
		}
	;



AnyExpr:
		UndefID			/* $1 */
		'['				/* $2 */
		AnyExpr			/* $3 */
		AnyExprList		/* $4 */
		']'				/* $5 */
		{				/* $6 */

			struct SymNode *s;

			_here;
			setClassification( YYS &$<cls>$, $<idStr>1 );
			_if( ( $<cls.cls>3 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif
			_if( $<cls.cls>$ & cfy_IsArray )

				_if( $<cls.cls>$ & cfy_ConstExpr )

					/*
					** Okay, it's a constant and it's an array.
					** We've got to look this symbol up in order
					** to determine it's arity.  This will tell
					** us whether applying an index to it still
					** produces an array.
					*/
						
					_if
					(
							( $<cls.sym>$ == NULL ) 
						||	( $<cls.sym>$->Arity <= ($<cls.arity>4 + 1) ))					

						unArray( YYS &$<cls>$ );
						$<cls.arity>$ = $<cls.arity>$ - $<cls.arity>4 - 1;

					_endif

				_else

					/*
					** It's probably a memory object.  Regardless, it's
					** not a constant so drop the array classification.
					*/

					unArray( YYS &$<cls>$ );
					$<cls.arity>$ = 0;

				_endif

			_endif

			/*
			** This isn't a single ID, so clear that bit if set.
			*/

			$<cls.cls>$ &= ~cfy_SingleID;
			free2( vss $<idStr>1 );
			_here;
		}
	;
	

AnyExprList:				
		','					/* $1 */
		AnyExpr				/* $2 */
		{					/* $3 */

			_here;
			_if(( $<cls.cls>2 & cfy_ConstExpr ) == 0 )

				yyerror( "Array index/element must be a constant expression" );

			_endif
			$<cls.cls>$ = $<cls.cls>2;
			$<cls.sym>$ = $<cls.sym>2;
			$<cls.arity>$ = 1;
			$<cls.ObjectSize>$ = 1;
		}

	|	','					/* $1 */
		AnyExpr				/* $2 */
		AnyExprList			/* $3 */
		{
			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>2, YYS &$<cls>3 );
			_if(( $<cls.cls>2 & cfy_ConstExpr ) == 0 )

				yyerror( "Array index/element must be a constant expression" );

			_endif
			$<cls.arity>$ = $<cls.arity>3 + 1;
		}
	;





AnyExpr:
		UndefID			/* $1 */
		{

			_here;

			setClassification( YYS &$<cls>$, $<idStr>1 );
			$<cls.cls>$ |= cfy_SingleID;
			_if
			(
					$<cls.sym>$ != NULL
				&&	(
							$<cls.sym>$->pType == tBoolean 
						||	$<cls.sym>$->pType == tByte
						||	$<cls.sym>$->pType == tWord
						||	$<cls.sym>$->pType == tDWord
					)
			)

				$<cls.cls>$ |= cfy_BooleanExpr;

			_endif
			
			/*
			** Should free $<idStr>1 here, but somebody else
			** seems to be doing it and doing so here crashes
			** the system.  A memory leak is better than a
			** crash, so I removed the following call (could
			** not trace down the cause of this problem).
			**
			** free2( $<idStr>1 );
			*/

			_here;
		}
	;

AnyExpr:
		Lparen			/* $1 */
		AnyExpr			/* $2 */
		Rparen			/* $3 */
		{				/* $4 */
			_here;
			_if(( $<cls.cls>2 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected a constant expression" );

			_endif
			$<cls.cls>$ = $<cls.cls>2 & ~cfy_SingleID;
			$<cls.sym>$ = $<cls.sym>2;
			$<cls.type>$ = $<cls.type>2;
			$<cls.arity>$ = $<cls.arity>2;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
			_here; 
		}
	;

AnyExpr:
		'&'				/* $1 */
		UndefID			/* $2 */
		{				/* $3 */

			struct SymNode *s;

			_here;
			setClassification( YYS &$<cls>$, $<idStr>2 );
			$<cls.type>$ = &pointer_ste;
			$<cls.ObjectSize>$ = 4;
			$<cls.arity>$ = 0;
			_if(( $<cls.cls>$ & cfy_Undefined )  == 0 )

				assert( $<cls.sym>$ != NULL );

				_if( !CanBePtrConst( $<cls.sym>$->SymClass ) ) 

					yyerror
					(
						"'&' operator must be followed by a static object" 
					);

				_else

					_if( StaticProc( $<cls.sym>$->SymClass ))

						$<cls.cls>$ |= cfy_IsProcPtr;

					_endif

				_endif

			_endif
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst | cfy_IsPointer;
			free2( vss $<idStr>2 );
			_here;
		}
	;

AnyExpr:
		intconst		/* $1 */
		{
			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = $<v.Type>1;
			$<cls.ObjectSize>$ = $<v.ObjectSize>1;
			$<cls.arity>$ = 0;
			_here;
		}
	;

AnyExpr:
		binconst		/* $1 */
		{				/* $2 */

			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = $<v.Type>1;
			$<cls.ObjectSize>$ = $<v.ObjectSize>1;
			$<cls.arity>$ = 0;
			_here;
		}
	;


AnyExpr:
		hexconst		/* $1 */
		{				/* $2 */

			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = $<v.Type>1;
			$<cls.ObjectSize>$ = $<v.ObjectSize>1;
			$<cls.arity>$ = 0;
			_here;
		}
	;

AnyExpr:
		fltconst		/* $1 */
		{				/* $2 */

			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = $<v.Type>1;
			$<cls.ObjectSize>$ = $<v.ObjectSize>1;
			$<cls.arity>$ = 0;
			_here;
		}
	;


AnyExpr:
		charconst		/* $1 */
		{				/* $2 */

			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = &char_ste;
			$<cls.ObjectSize>$ = 1;
			$<cls.arity>$ = 0;
			_here;
		}
	;
	

AnyExpr:
		wcharconst		/* $1 */
		{				/* $2 */

			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = &wchar_ste;
			$<cls.ObjectSize>$ = 2;
			$<cls.arity>$ = 0;
			_here;
		}
	;
	

AnyExpr:
		StringConst		/* $1 */
		{				/* $2 */

			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = &string_ste;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 4;
			FreeValue( YYS &$<v>1 );
			_here;
		}
	;
	

AnyExpr:
		WStringConst	/* $1 */
		{				/* $2 */

			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = &wstring_ste;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 4;
			FreeValue( YYS &$<v>1 );
			_here;
		}
	;


AnyExpr:
		nullTkn			/* $1 */
		{				/* $2 */

			_here;
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = &pointer_ste;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = 4;
			_here;
		}
	;


AnyExpr:
		'{'				/* $1 */
		PreserveGlobal	/* $2 */
		ClearSet		/* $3 */
		ProcessedID		/* $4 */
		SetItems		/* $5 */
		'}'				/* $6 */
		UnprocessedID	/* $7 */
		{				/* $8 */

			_here;
			memcpy( &GlobalCset, &$<v.u.csetval>2, CSetSizeInBytes );
			$<cls.cls>$ = cfy_ConstExpr | cfy_LiteralConst;
			$<cls.sym>$ = NULL;
			$<cls.type>$ = &cset_ste;
			$<cls.ObjectSize>$ = CSetSizeInBytes;
			$<cls.arity>$ = 0;
			_here;
		}
	;


AnyExpr:
		'['				/* $1 */
		AnyExpr			/* $2 */
		']'				/* $3 */
		{				/* $4 */

			_here;
			_if(( $<cls.cls>2 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected constant expression as array element" );

			_endif
			$<cls.sym>$ = NULL;
			$<cls.type>$ = $<cls.type>2;
			$<cls.arity>$ = 1;		
			$<cls.ObjectSize>$ = 4;
			$<cls.cls>$ = 
					cfy_Undefined	
				|	cfy_LiteralConst
				|	cfy_ConstExpr	
				|	cfy_IsArray;

			_here;
		}
	;


AnyExpr:
		'['				/* $1 */
		AnyExpr			/* $2 */
		AnyExprList		/* $3 */
		']'				/* $4 */
		{				/* $5 */

			_here;
			_if(( $<cls.cls>2 & cfy_ConstExpr ) == 0 )

				yyerror( "Expected constant expression as array element" );

			_endif
			$<cls.sym>$ = NULL;		
			$<cls.type>$ = MakeAnyCompat( YYS &$<cls>2, YYS &$<cls>3 );
			$<cls.arity>$ = 1;		
			$<cls.ObjectSize>$ = 
				_ifx
				( 
					$<cls.ObjectSize>2 > $<cls.ObjectSize>3,
					$<cls.ObjectSize>2,
					$<cls.ObjectSize>3
				);

			$<cls.cls>$ = 
					cfy_Undefined	
				|	cfy_LiteralConst
				|	cfy_ConstExpr	
				|	cfy_IsArray;

			_here;
		}
	;


AnyExpr:
		UndefID			/* $1 */
		':'				/* $2 */
		'['				/* $3 */
		AnyExpr			/* $4 */
		AnyExprList		/* $5 */
		']'				/* $6 */
		{				/* $7 */

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>1, SymbolTable );
			_if( s == NULL || s->pType != tRecord || s->SymClass != cType )

				yyerror( "Expected record type name" );
				$<cls.cls>$ = cfy_Undefined | cfy_ConstExpr | cfy_IsRecord;
				$<cls.sym>$ = NULL;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = 0;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->FieldCnt !=	( $<cls.arity>5 + 1) )

				yyerror( "Fields do not agree with record type" );
				$<cls.cls>$ = cfy_ConstExpr | cfy_IsRecord;
				$<cls.sym>$ = s;
				$<cls.type>$ = s->Type;
				$<cls.arity>$ = 0;
				$<cls.ObjectSize>$ = 1;

			_else

				$<cls.sym>$ = s;
				$<cls.type>$ = s->Type;
				$<cls.ObjectSize>$ = s->ObjectSize;
				$<cls.arity>$ = 0;
				$<cls.cls>$ = cfy_ConstExpr | cfy_IsRecord | cfy_LiteralConst;

			_endif
			_here;
		}
	;


AnyExpr:
		UndefID			/* $1 */
		':'				/* $2 */
		'['				/* $3 */
		AnyExpr			/* $4 */
		']'				/* $6 */
		{				/* $7 */

			struct SymNode *s;

			_here;
			s = ClassifyLookup( $<idStr>1, SymbolTable );
			_if( s == NULL || s->pType != tRecord || s->SymClass != cType )

				yyerror( "Expected record type name" );
				$<cls.cls>$ = cfy_Undefined | cfy_ConstExpr | cfy_IsRecord;
				$<cls.sym>$ = NULL;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = 0;
				$<cls.ObjectSize>$ = 1;

			_elseif( s->FieldCnt !=	1 )

				yyerror( "Fields do not agree with record type" );
				$<cls.cls>$ = cfy_ConstExpr | cfy_IsRecord;
				$<cls.sym>$ = s;
				$<cls.type>$ = s->Type;
				$<cls.arity>$ = 0;
				$<cls.ObjectSize>$ = 1;

			_else

				$<cls.sym>$ = s;
				$<cls.cls>$ = cfy_ConstExpr | cfy_IsRecord | cfy_LiteralConst;
				$<cls.type>$ = s->Type;
				$<cls.arity>$ = 0;
				$<cls.ObjectSize>$ = s->ObjectSize;

			_endif
			_here;
		}
	;

AnyExpr:
		'-'
		AnyExpr %prec UMINUS
		{

			_here;
			$<cls.cls>$ = $<cls.cls>2;
			_if(( $<cls.cls>2 & cfy_ConstExpr ) == 0 ) 

				yyerror( "Constant expressions require constant operands" );
				$<cls.cls>$ &= ~(cfy_MemoryExpr | cfy_AnonMem);
				$<cls.cls>$ |= cfy_ConstExpr;

			_endif
			$<cls.sym>$ = $<cls.sym>2;
			assert( $<cls.type>2 != NULL );
			_switch( $<cls.type>2->pType )

				_case( tInt8 )

					$<cls.type>$ = &uns8_ste;

				_endcase


				_case( tInt16 )

					$<cls.type>$ = &uns16_ste;

				_endcase


				_case( tInt32 )

					$<cls.type>$ = &uns32_ste;

				_endcase


				_case( tInt64 )

					$<cls.type>$ = &uns64_ste;

				_endcase


				_case( tInt128 )

					$<cls.type>$ = &uns128_ste;

				_endcase





				_case( tUns8 )

					$<cls.type>$ = &int8_ste;

				_endcase


				_case( tUns16 )

					$<cls.type>$ = &int16_ste;

				_endcase


				_case( tUns32 )

					$<cls.type>$ = &int32_ste;

				_endcase


				_case( tUns64 )

					$<cls.type>$ = &int64_ste;

				_endcase


				_case( tUns128 )

					$<cls.type>$ = &int128_ste;

				_endcase




				_default
					$<cls.type>$ = $<cls.type>2;

			_endswitch
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
			_here;
		}
	;


AnyExpr:
		'!'
		AnyExpr %prec UMINUS
		{

			_here;
			$<cls.cls>$ = $<cls.cls>2;
			_if( ($<cls.cls>2 & cfy_ConstExpr ) == 0 ) 

				yyerror( "Constant expressions require constant operands" );
				$<cls.cls>$ &= ~(cfy_MemoryExpr | cfy_AnonMem);
				$<cls.cls>$ |= cfy_ConstExpr;

			_endif
			$<cls.sym>$ = $<cls.sym>2;			
			$<cls.type>$ = $<cls.type>2;
			$<cls.arity>$ = 0;
			$<cls.ObjectSize>$ = $<cls.ObjectSize>2;
		}
	;


AnyExpr:
		AnyExpr			/* $1 */
		'+'				/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		'-'				/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		'*'				/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		'/'				/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		divTkn			/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		modTkn			/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		'&'				/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;	
	


AnyExpr:
		AnyExpr			/* $1 */
		'|'				/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		shlopTkn		/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		shropTkn		/* $2 */
		AnyExpr			/* $3 */
		{

			_here;

			CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );
			_here;
		}
	;		
		


AnyExpr:
		AnyExpr			/* $1 */
		'='				/* $2 */
		AnyExpr			/* $3 */
		{				/* $4 */

			_here;
			_if(( $<cls.cls>1 & cfy_ConstExpr ) != 0 )

				CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );

			_else

				_if
				(
						( $<cls.cls>1 & cfy_MemoryExpr ) != 0 
					&&	( $<cls.cls>3 & cfy_ConstExpr ) != 0
				)

					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_else

					yyerror( "Illegal boolean expression syntax" );
					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_endif

			_endif
			$<cls.ObjectSize>$ = 1;
			_here;
		}
	;		




AnyExpr:
		AnyExpr			/* $1 */
		neTkn			/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			_if(( $<cls.cls>1 & cfy_ConstExpr ) != 0 )

				CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );

			_else

				_if
				(
						( $<cls.cls>1 & cfy_MemoryExpr ) != 0 
					&&	( $<cls.cls>3 & cfy_ConstExpr ) != 0
				)

					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_else

					yyerror( "Illegal boolean expression syntax" );
					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_endif

			_endif
			$<cls.ObjectSize>$ = 1;
			_here;
		}
	;		




AnyExpr:
		AnyExpr			/* $1 */
		'<'				/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			_if(( $<cls.cls>1 & cfy_ConstExpr ) != 0 )

				CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );

			_else

				_if
				(
						( $<cls.cls>1 & cfy_MemoryExpr ) != 0 
					&&	( $<cls.cls>3 & cfy_ConstExpr ) != 0
				)

					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_else

					yyerror( "Illegal boolean expression syntax" );
					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_endif

			_endif
			$<cls.ObjectSize>$ = 1;
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		leTkn			/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			_if(( $<cls.cls>1 & cfy_ConstExpr ) != 0 )

				CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );

			_else

				_if
				(
						( $<cls.cls>1 & cfy_MemoryExpr ) != 0 
					&&	( $<cls.cls>3 & cfy_ConstExpr ) != 0
				)

					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_else

					yyerror( "Illegal boolean expression syntax" );
					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_endif

			_endif
			$<cls.ObjectSize>$ = 1;
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		'>'				/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			_if(( $<cls.cls>1 & cfy_ConstExpr ) != 0 )

				CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );

			_else

				_if
				(
						( $<cls.cls>1 & cfy_MemoryExpr ) != 0 
					&&	( $<cls.cls>3 & cfy_ConstExpr ) != 0
				)

					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_else

					yyerror( "Illegal boolean expression syntax" );
					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_endif

			_endif
			$<cls.ObjectSize>$ = 1;
			_here;
		}
	;		


AnyExpr:
		AnyExpr			/* $1 */
		geTkn			/* $2 */
		AnyExpr			/* $3 */
		{

			_here;
			_if(( $<cls.cls>1 & cfy_ConstExpr ) != 0 )

				CombineAttrs( YYS &$<cls>$, YYS &$<cls>1, YYS &$<cls>3 );

			_else

				_if
				(
						( $<cls.cls>1 & cfy_MemoryExpr ) != 0 
					&&	( $<cls.cls>3 & cfy_ConstExpr ) != 0
				)

					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_else

					yyerror( "Illegal boolean expression syntax" );
					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_endif

			_endif
			$<cls.ObjectSize>$ = 1;
			_here;
		}
	;
	


AnyExpr:
		AnyExpr			/* $1 */
		inTkn			/* $2 */
		AnyExpr			/* $3 */ 
		{

			_here;
			_if(( $<cls.cls>1 & cfy_ConstExpr ) != 0 )

				$<cls.cls>$ = $<cls.cls>1;
				$<cls.sym>$ = $<cls.sym>1;
				$<cls.type>$ = &boolean_ste;
				$<cls.arity>$ = 0;

			_else

				_if
				(
						( $<cls.cls>1 & cfy_MemoryExpr ) != 0 
					&&	( $<cls.cls>3 & cfy_ConstExpr ) != 0
				)

					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_else

					yyerror( "Illegal boolean expression syntax" );
					$<cls.cls>$ = cfy_BooleanExpr;
					$<cls.sym>$ = NULL;
					$<cls.type>$ = NULL;
					$<cls.arity>$ = 0;

				_endif

			_endif
			$<cls.ObjectSize>$ = 1;
			_here;
		}
	;
	

			
/*
** Simulate the type coercion functions down here.
*/

AnyExpr:
		UndefID			/* $1 */
		'('				/* $2 */
		AnyExpr			/* $3 */
		')'				/* $4 */
		{				/* $5 */

			_if
			(
					_strne( $<idStr>1, "boolean" )

				&&	_strne( $<idStr>1, "uns8" )
				&&	_strne( $<idStr>1, "uns16" )
				&&	_strne( $<idStr>1, "uns32" )

				&&	_strne( $<idStr>1, "byte" )
				&&	_strne( $<idStr>1, "word" )
				&&	_strne( $<idStr>1, "dword" )

				&&	_strne( $<idStr>1, "int8" )
				&&	_strne( $<idStr>1, "int16" )
				&&	_strne( $<idStr>1, "int32" )

				&&	_strne( $<idStr>1, "real32" )
				&&	_strne( $<idStr>1, "real64" )
				&&	_strne( $<idStr>1, "real80" )

				&&	_strne( $<idStr>1, "char" )
				&&	_strne( $<idStr>1, "string" )
				&&	_strne( $<idStr>1, "cset" )
			)

				yyerror
				( 
					"Constant type coercion operation must have\n"
					"a primitive type name (e.g., 'byte')"
				);
				$<cls.cls>$ = $<cls.cls>3;
				$<cls.sym>$ = $<cls.sym>3;
				$<cls.type>$ = NULL;
				$<cls.arity>$ = 0;
				$<cls.ObjectSize>$ = 1;

			_else

				$<cls.cls>$ = $<cls.cls>3;
				$<cls.sym>$ = $<cls.sym>3;
				$<cls.type>$ = lookup( $<idStr>1, 1 );
				$<cls.arity>$ = 0;
				$<cls.ObjectSize>$ = $<cls.type>$->ObjectSize;

			_endif

		}
	;



AnyExpr:
		ProcessedID		/* $1 */
		ConstFunc		/* $2 */
		UnprocessedID	/* $3 */
		{

			_here;
			$<cls.sym>$ = NULL;
			$<cls.cls>$ = cfy_ConstExpr;
			$<cls.arity>$ = 0;
			_if( $<v.pType>2 == tArray )

				$<cls.cls>$ |= cfy_IsArray;
				$<cls.arity>$ = $<v.Arity>2;

			_elseif( $<v.pType>2 == tRecord )

				$<cls.cls>$ |= cfy_IsRecord;

			_endif
			$<cls.ObjectSize>$ = $<v.Type>2->ObjectSize;
			FreeValue( YYS &$<v>2 );
			_here;
		}
	;


AnyExpr:
		ProcessedID		/* $1 */
		atToken			/* $2 */
		Lparen			/* $3 */
		ConstExpr		/* $4 */
		Rparen			/* $5 */
		UnprocessedID	/* $6 */
		{

			_here;
			$<cls.sym>$ = NULL;
			$<cls.cls>$ = cfy_ConstExpr;
			$<cls.arity>$ = 0;
			$<cls.type>$ = $<v.Type>2;
			$<cls.ObjectSize>$ = $<v.Type>2->ObjectSize;
			FreeValue( YYS &$<v>4 );
			_here;
		}
	;


AnyExpr:
		ProcessedID		/* $1 */
		SymTblFunc		/* $2 */
		UnprocessedID	/* $3 */
		{

			_here;
			$<cls.sym>$ = NULL;
			$<cls.cls>$ = cfy_ConstExpr;
			$<cls.arity>$ = 0;
			_if( $<v.pType>2 == tArray )

				$<cls.cls>$ |= cfy_IsArray;
				$<cls.arity>$ = $<v.Arity>2;

			_elseif( $<v.pType>2 == tRecord )

				$<cls.cls>$ |= cfy_IsRecord;

			_endif
			$<cls.ObjectSize>$ = $<v.Type>2->ObjectSize;
			FreeValue( YYS &$<v>2 );
			_here;
		}
	;





%%




static void
ExpectedOrdinalConst( void )
_begin( ExpectedOrdinalConst )

	yyerror( "Expected an ordinal constant" );

_end( ExpectedOrdinalConst )



void
ConstTooBig( void )
_begin( ConstTooBig )

	yyerror( "Constant expression is out of range for specified operand" );

_end( ConstTooBig )


void
SizeMismatch( void )
_begin( SizeMismatch )

	yyerror( "Operand size mismatch" );

_end( SizeMismatch )



static void
PressReturnToContinue(void)
_begin( PressReturnToContinue )

	char dummy[16];
	_if( MsgOut == stderr )
	
		fprintf( MsgOut, "\nPress the enter key to continue:" );
		fgets( dummy, 8, stdin );
		fprintf( MsgOut, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" );

	_endif
	
_end( PressReturnToContinue )


static void
Usage( void )
_begin( Usage )

	fprintf
	(
		MsgOut,
		"Usage: hlaparse options filename\n"
		"\n"
		"HLA (High Level Assembler)\n"
		"%s\n"
		"\n"
		" options:\n"
		"  -license Display license information\n"
		"  -@       Do not create linker response file.\n"
		"  -@@      Force creation of new linker response file.\n"
		"  -dXXXX   Defines XXXX as \"?XXXX:boolean := true;\"\n"
		"  -dxx=yy  Defines XX as \"?XX:string:=YY;\"\n"
		"  -pXXXX   Output path for .asm/.inc/.link files "
		"  -sh      Produce pseudo-HLA ASM output file.\n"
		"  -sg      Produce GAS compatible ASM output file.\n"
		"  -sx      Produce Mac OSX GAS compatible ASM output file.\n"
		"  -st      Produce TASM compatible ASM output file.\n"
		"  -sm      Produce MASM compatible ASM output file.\n"
		"  -sf      Produce FASM compatible ASM output file.\n"
		"  -sn      Produce NASM compatible ASM output file.\n"
		"  -source  Produce instruction translation (rather than hex output)\n"
		"  -obj:XX  Output path for coff/elf object files.\n"
		"  -win32   Generate COFF file for Win32 OS.\n"
		"  -linux   Generate ELF file for Linux OS.\n"
		"  -freebsd Generate ELF file for freeBSD OS.\n"
		"  -macos   Generate Mach-o file for Mac OSX.\n"
		"  -sym     Dump symbol table after compile.\n"
		"  -test    Send diagnostic info to stdout rather than stderr\n"
		"  -v       Verbose compile.\n"
		"  -?       Display this help message.\n\n"
		"  -level=high     Full HLA language (default)\n"
		"  -level=medium   Disables HLL control constructs\n"
		"  -level=low      Disables HL-like procedure calls\n"
		"  -level=machine  Disable exception handling constructs\n"
		"  -main:xxxx      Names the main program 'xxxx' (default='start')",
		VersionInformation
	);

_end( Usage )


static void
License( void )
_begin( License )

	fprintf
	(
		MsgOut,
		"\n\n\n"
		"*******************************************************\n"
		"*                                                     *\n"
		"*              HLA License Information                *\n"
		"*                                                     *\n"
		"*******************************************************\n"
		"\n"
		"The HLA shell program ('HLA.EXE' under Windows, 'hla'\n"
		"under other operating systems) is open source and public\n"
		"domain. You may do anything you like with this code,\n"
		"without restriction. Here is the official license code\n"
		"for HLA public domain components:\n"
		"\n"

"I, Randall Hyde, hereby agree to waive all claim of copyright (economic \n"
"and moral) in all content contributed by me, the user, and immediately	 \n"
"place any and all contributions by me into the public domain; I grant	 \n"
"anyone the right to use my work for any purpose, without any			 \n"
"conditions, to be changed or destroyed in any manner whatsoever		 \n"
"without any attribution or notice to the creator.  I also absolve myself\n"
"of any responsibility for the use of this code, the user assumes all	 \n"
"responsibilities for using this software in an appropriate manner.		 \n"
"																		 \n"
"Notice of declaration of public domain, 3/2/2007, by Randall Hyde		 \n"
"\n"
		"You can assume that all HLA sample programs written by\n"
		"Randall Hyde and distributed as part of the HLA system\n"
		"are public domain (governed by the public domain \n"
		"declaration given earlier). You are free to use those\n"
		"sample programs in part or in whole as you desire.\n"
		"The HLA Standard Library source code is also public\n"
		"domain and you may use that code in any manner you\n"
		"see fit.\n"
	);
		
_end( License )



void
SetSeg( char* src, char* dest, char* defaultStr )
_begin( SetSeg )

	_here;
	_if( strlen( src ) == 0 || *src == '.' )

		strcpy( dest, defaultStr );

	_elseif( stricmp( src, "_text" ) == 0 )

		strcpy( dest, ".text" );

	_elseif( stricmp(src, "_data" ) == 0 )
	
		strcpy( dest, ".data" );
		
	_elseif( stricmp( src, "_bss" ) == 0 )
	
		strcpy( dest, ".bss" );
		
	_elseif( stricmp( src, "CONST" ) == 0 )
	
		strcpy( dest, ".text" );
		
	_else
	
		strcpy( dest, src );
		
	_endif 

_end( SetSeg )



// A cheesy "file exists" function

int
fexists( char *filename )
_begin( fexists )

	FILE *f;
	
	f = fopen( filename, "r" );
	_if( f != NULL )
	
		fclose( f );
		
	_endif
	_return f != NULL;

_end( fexists )



int
main( int argc, char *argv[] )
_begin( main )

	int				ResponseFile = 1;	// Generate linker response file.
	FILE			*linkOut;			// ".link" output file pointer.
	struct segmentList_t *s;			// Used when creating the ".link" file.
	struct	timeb	CompileTimeStart;	// Measure the compile time.
	char 			option[256];		// Hold a command-line argument string.

	MsgOut = stderr;
	RecordValues = malloc2( sizeofSymNode );

	assert( sizeofSymNode == sizeof( YYSTYPE ));

	/*
	** Initialize the reserved array so that HLA treats all the
	** reserved words as though they *were* reserved words.
	*/
	
	memset( ReservedWords, 1, sizeof( ReservedWords ));
	

	/*
	** Symbol Table initialization
	*/

	initSymbolTable();

	/*
	** Get the environment variables this program uses
	** (if they are present).
	*/

	hlainc = (char *) getenv( "hlainc" );
	hlaauxinc = (char *) getenv( "hlaauxinc" );
	_if( hlaauxinc == NULL )
	
		hlaauxinc = "";
		
	_endif
	outPath = (char *) getenv( "hlatmp" );
	_if( outPath == NULL )
	
		outPath = "";
		
	_endif
	outPath = hlastrdup( outPath );

	/*
	** Better have at least one command line argument!
	*/

	_if( argc < 2 )
	
		Usage();
		_return 1;

	_endif
	_here;
	

	/*
	** Grab all the command line arguments from the command line
	** and pick up all the filenames, too.
	**
	** Here are the command line arguments we process:
	**
	**	-@				Don't create a linker response file.
	**	-@@				Force creation of new linker response file.
	**	-source			Source code (instructions) output rather than hex values.
	**	-thread			Create thread-safe code and set @thread to true.
	**	-sh				Source output in pseudo-HLA format.
	**	-sm				Source output in MASM format.
	**	-st				Source output in TASM format.
	**  -sf				Source output in FASM format.
	**  -sn				Source output in NASM format.
	**	-sg				Source output in GAS format.
	**	-sx				Source output in Mac OSX GAS format.
	**	-win32			Generate COFF code for Win32 OS.
	**	-linux			Generate ELF code for Linux OS.
	**	-freebsd		Generate ELF code for freeBSD OS.
	**	-macos			Generate Mach-o code for Mac OSX.
	**	-d<sym>			Define a symbol.
	**	-sym			Dump the symbol table.
	**	-v				Verbose output
	**  -p<path>    	Path for temporary files (must have trailing backslash)
	**	-obj<path>		Path for object file output (internal HLA back engine).
	**  -level=high		Enable full HLA language (default)
	**	-level=medium	Medium-level assembly (no HLL control constructs)
	**	-level=low		Low-level assembly (no HL procedure calls/code gen)
	**	-level=machine	Machine instrs only (no exception HLL constructs)
	**  -main:<name>	Name of main program in HLA code.
	**  -license        Display license information
	**	-test			Send output to stdout rather than stderr.
	**	-?				Help
	*/
	
	// First, scan through the arguments for a targetOS specification
	// because that has to be processed before handling any other
	// command-line options.
	
	_for( CurArg = 1, CurArg < argc, ++CurArg )
	
		_if( argv[ CurArg ][0] == '-' )
		
			strcpy( option, argv[ CurArg ] );
			strupr( option );
			_if( _streq( option, "-WIN32" ))
			
				targetOS = windows_os;
				assembler = hlabe;
				useHLABE = 1;
				_break;
				
			_elseif( _streq( option, "-LINUX" ))
			
				targetOS = linux_os;
				assembler = hlabe;
				useHLABE = 1;
				_break;
				
			_elseif( _streq( option, "-FREEBSD" ))
			
				targetOS = freeBSD_os;
				assembler = hlabe;
				useHLABE = 1;
				_break;
				
			_elseif( _streq( option, "-MACOS" ))
			
				targetOS = macOS_os;
				assembler = hlabe;
				useHLABE = 1;
				_break;
				
			_endif
			
		_endif
		
	_endfor
	_here;

	CurArg = 1;
	langLevel = high_level;
	_while( CurArg < argc )

		_if( argv[ CurArg ][ 0 ] == '-' )

			char *s = argv[ CurArg ];

			// Copy the argument and convert it to upper case
			// for comparison purposes.  Also replace any leading
			// "/" character with a "-".

			strcpy( option, s );
			strupr( option );

			// Check for option to disable linker response file:

			_if( _streq( option, "-@" ))

				ResponseFile = 0;


			// Check for option to force creation of new linker response file:

			_elseif( _streq( option, "-@@" ))

				ResponseFile = 2;


			// Check for the -Dxxxx option:

			_elseif( option[1] == 'D' )

				char *NewSymbol;
				char *strValue;
				union YYSTYPE dummy;

				NewSymbol = hlastrdup2(&argv[ CurArg ][2 ] );
				strValue = strchr( NewSymbol, '=');
				_if( strValue == NULL )
				 
					/*
					** Create a boolean symbol with the specified name
					** and initialize it to true.
					*/

					_here;
					ClrConst
					(
						YYS &dummy,
						tBoolean,
						&boolean_ste
					);
					dummy.v.u.boolval = 1;
					InsertSym
					( 
						NewSymbol, 
						&boolean_ste,	/* This is a BOOLEAN object.	*/
						tBoolean,
						cValue, 
						0,				/* Arity						*/
						NULL,			/* Dimensions					*/
						0, 				/* NumElements					*/
						YYS &dummy,		/* Set to TRUE					*/
						1,				/* Object size					*/
						0,				/* Offset						*/
						NULL,			/* Static Name					*/
						NULL,			/* Base							*/
						NULL,			/* Fields						*/
						0				/* FieldCnt						*/
					);
					
				_else // we have -Dsymbol=string

					/*
					** Create a string symbol with the specified name
					** and initialize it to the remainder of the argument
					** following the "=".
					*/

					_here;
					ClrConst
					(
						YYS &dummy,
						tString,
						&string_ste
					);
					dummy.v.u.strval = strValue+1;
					*strValue = '\0';
					InsertSym
					( 
						NewSymbol, 
						&string_ste,	/* This is a STRING object.		*/
						tString,
						cValue, 
						0,				/* Arity						*/
						NULL,			/* Dimensions					*/
						0, 				/* NumElements					*/
						YYS &dummy,		/* Set to TRUE					*/
						1,				/* Object size					*/
						0,				/* Offset						*/
						NULL,			/* Static Name					*/
						NULL,			/* Base							*/
						NULL,			/* Fields						*/
						0				/* FieldCnt						*/
					);
					
				
				_endif


			// Check for the -Pxxxx option:

			_elseif( option[1] == 'P' )

				 outPath = hlastrdup(&argv[ CurArg ][ 2 ] );

			// Check for assembly output options:
			
			_elseif( _streq( option, "-SOURCE" ) )
			
				sourceOutput = 1;

			// Check for thread-safe compilation:
			
			_elseif( _streq( option, "-THREAD" ) )
			
				threadSafe = 1;

			_elseif( _streq( option, "-S" ) )

				// Default, assembler is MASM

				assembler 	= masm;
				useHLABE	= 0;

			_elseif( _streq( option, "-SM" ) )

				// Explicit, assembler is MASM

				assembler 	= masm;
				useHLABE	= 0;

			_elseif( _streq( option, "-SH" ) )

				// Explicit, assembler is pseudo-HLA

				assembler	= hla;
				useHLABE	= 0;

			_elseif( _streq( option, "-ST" ) )

				// Explicit, assembler is TASM

				assembler 	= tasm;
				useHLABE	= 0;


			_elseif( _streq( option, "-SN" ) )

				// Explicit, assembler is NASM

				assembler 	= nasm;
				useHLABE	= 0;


			_elseif( _streq( option, "-SF" ) )

				// Explicit, assembler is FASM

				assembler 	= fasm;				
				useHLABE	= 0;
				


			_elseif( _streq( option, "-SG" ) )

				// Explicit, assembler is Gas

				assembler 	= gas;
				gasSyntax 	= stdGas;
				useHLABE	= 0;
				
			_elseif( _streq( option, "-SX" ) )

				// Explicit, assembler is Gas for Mac OSX

				assembler 	= gas;
				gasSyntax 	= macGas;				
				useHLABE	= 0;
				
			_elseif( _streq( option, "-HLABE" ))
			
				assembler = hlabe;
				useHLABE = 0;		// We want source output
				testMode = 0;
				sourceOutput = 0;


			
			// check for "-main:<name>" here:
			
			_elseif( strncmp( option, "-MAIN:", 6) == 0 )

				mainName = hlastrdup2( &argv[ CurArg ][6] );

			// check for "-obj:<path>" here:
			
			_elseif( strncmp( option, "-OBJ:", 5) == 0 )

				objPath = hlastrdup2( &argv[ CurArg ][5] );

			_elseif( strncmp( option, "-B:", 3) == 0 )

				binName = hlastrdup2( &argv[ CurArg ][3] );

			// Check for symbol table dump option:

			_elseif( _streq( option, "-SYM" ) )

				DumpSymbols = 1;

			// Check for TEST output option:

			_elseif( _streq( option, "-TEST" ) )

				MsgOut 		= stdout;
				testMode 	= 1;
				testMode2 	= 1;

			// Check for LEVEL options

			_elseif( _streq( option, "-LEVEL=HIGH" ) )

				langLevel = high_level;

			_elseif( _streq( option, "-LEVEL=MEDIUM" ) )

				langLevel = medium_level;

			_elseif( _streq( option, "-LEVEL=LOW" ) )

				langLevel = low_level;
				
			_elseif( _streq( option, "-LEVEL=MACHINE" ) )

				langLevel = machine_level;

			// Check for VERBOSE option

			_elseif( _streq( option, "-V" ))

				Verbose = 1;

			// Check for license option:

			_elseif( _streq( option, "-LICENSE" ) )

				License();
				_return 1;
			

			// Check for HELP option:

			_elseif( _streq( option, "-?" ) )

				Usage();
				_return 1;
			
			_elseif
			(
					_streq( option, "-WIN32" )
				||	_streq( option, "-LINUX" )
				||	_streq( option, "-FREEBSD" )
				||	_streq( option, "-MACOS" )
			)
			
				// Already handled these options, ignore them.
				
			_else
			
				fprintf
				(
					MsgOut,
					"Illegal command line option (%s)\n",
					argv[ CurArg ]
				);
				Usage();
				_return 1;
				
			_endif



		/*
		** If the current command line argument doesn't begin with "-" or "/"
		** then assume it is some sort of file name.  Filenames should take
		** one of two different forms:
		**
		**	name		HLA source file with default ".HLA" suffix.
		**	name.hla	HLA source file.
		**
		** Any other suffix is assumed to be a special case of the first
		** case above where "name" just happens to contain one or more
		** periods.
		*/

		_else

			char *name;
			int	 namelen;

			name = hlastrdup( argv[ CurArg ] );
			assert( name != NULL );
			strlwr( name );
			namelen = strlen( name );
			_if( SourceFile != NULL )
			
				yyerror( "Too many filenames supplied on command line" );

			_elseif
			(
					namelen < 4
				||	_strne( name + namelen - 4, ".hla" )
			)

				/*
				** At this point, the filename doesn't end with
				** ".hla", so append ".hla" to it.
				*/

				SourceFile = malloc2( namelen + 5 );
				strcpy( SourceFile, argv[ CurArg ] );
				strcat( SourceFile, ".hla" );

			_else /* we found a good suffix */

				SourceFile = hlastrdup( argv[ CurArg ] );
				assert( SourceFile != NULL );

			_endif
		 
		_endif
		++CurArg;

	_endwhile
	_if( assembler == hlabe )
	
		// Force source output and testMode to false if
		// using the HLA back-end.
		
		sourceOutput = 0;
		testMode = 0;
		
	_endif
	_here;
	
	
	/*
	** Make sure outPath has a trailing directory separator character.
	*/
	
	
	_begin( fixOutPath )
	
		int len;
		char *newPath;
		
		len = strlen( outPath );
		_if( len > 0 && outPath[len-1] != DIR_SEP_CHAR )
		
			newPath = malloc2( len + 2 );
			strcpy( newPath, outPath );
			newPath[len] = DIR_SEP_CHAR;
			newPath[len+1] = '\0';
			free2( vss outPath );
			outPath = newPath;
			
		_endif
		
	_end( fixOutPath )

	/*
	** If verbose mode was specified, echo all the command line
	** values (primarily to test the command line argument processor).
	*/

	_if( Verbose )

		fprintf
		(
			MsgOut,
			"HLA (High Level Assembler) Parser\n"
			"use '-license' to view license information\n"
			"%s\n"
			"%s"
			"%s"
			"File: %s\n"
			"Output Path: \"%s\"\n"
			"hlainc Path: \"%s\"\n"
			"hlaauxinc Path: \"%s\"\n"
			"Compiler generating code for %s OS\n"
			"Back-end assembler: %s%s\n"
			"Language Level: %s\n"
			"\n",
			VersionInformation,
			_ifx( DumpSymbols, "-sym active\n", "" ),
			_ifx( MsgOut == stdout, "-test active\n", "" ),
			SourceFile,
			outPath,
			hlainc,
			hlaauxinc,
			OSChoiceStrs[ targetOS ],
			_ifx( assembler == gas && gasSyntax == macGas, "Mac OSX ", "" ),
			ASMChoiceStrs[assembler],
			_ifx
			(
				langLevel == high_level, "high",
				_ifx
				(
					langLevel == medium_level, "medium",
					_ifx
					(
						langLevel == low_level, "low",
						"machine"
					)
				)
			)
		);


	_endif


	/*
	** If the user didn't specify any filenames, quit at this point.
	*/

	_if( SourceFile == NULL)

		fprintf
		(
			MsgOut,
			"Nothing more to do!\n"
		);
		Usage();
		_return 1;

	_endif
	
	
	/*
	** Set up the ID array based on the language level
	*/
	
	_switch( langLevel )
	
		_case( machine_level )
		
			ReservedWords[ tryTkn  ] = 0;
			ReservedWords[ unprotectedTkn  ] = 0;
			ReservedWords[ exceptionTkn  ] = 0;
			ReservedWords[ anyexceptionTkn  ] = 0;
			ReservedWords[ endtryTkn  ] = 0;
			ReservedWords[ raiseTkn  ] = 0;
				
		_case( low_level )
		
			// Disable medium-level control structures
			// (and high-level procedure calls, which is
			// handled elsewhere).

			ReservedWords[ jfTkn  ] = 0;
			ReservedWords[ jtTkn  ] = 0;
			
			// Disable automatic stack frame generation
			// at low-level and below:
			
			AlignStackDefault = 0;
			FrameDefault = 0;
			DisplayDefault = 0;
			AlignDefault = 0;
			LeaveDefault = 1;
			EnterDefault = 1;
			
		_case( medium_level )
		
			// Disable HLL-like control structures
			// (except exception handling).
		
			ReservedWords[ downtoTkn  ] = 0;
			ReservedWords[ ifTkn  ] = 0;
			ReservedWords[ thenTkn  ] = 0;
			ReservedWords[ elseifTkn  ] = 0;
			ReservedWords[ elseTkn  ] = 0;
			ReservedWords[ endifTkn  ] = 0;

			ReservedWords[ whileTkn  ] = 0;
			ReservedWords[ doTkn  ] = 0;
			ReservedWords[ endwhileTkn  ] = 0;
			ReservedWords[ welseTkn  ] = 0;

			ReservedWords[ repeatTkn  ] = 0;
			ReservedWords[ untilTkn  ] = 0;

			ReservedWords[ forTkn  ] = 0;
			ReservedWords[ foreverTkn  ] = 0;
			ReservedWords[ foreachTkn  ] = 0;
			ReservedWords[ endforTkn  ] = 0;
			ReservedWords[ felseTkn  ] = 0;

			ReservedWords[ breakTkn  ] = 0;
			ReservedWords[ breakifTkn  ] = 0;
			ReservedWords[ continueTkn  ] = 0;
			ReservedWords[ continueifTkn  ] = 0;

			ReservedWords[ exitTkn  ] = 0;
			ReservedWords[ exitifTkn  ] = 0;



		_case( high_level )
		
			// Don't disable anything
			
		_endcase
		
	_endswitch
		
	_here;



	/*
	** Okay, run the HLA compiler on the ".HLA" file.
	*/


	// First, begin by allocating storage to hold the
	// intermediate file data:
	
	
	preambleBuf.size = 16*1024;	// 16K initial allocation.
	preambleBuf.base = malloc2( preambleBuf.size );
	preambleBuf.offset = 0;
	asmBuf = &preambleBuf;
	
	
	codeBuf.size = 4*1024*1024;	// 4MB initial allocation.
	codeBuf.base = malloc2( codeBuf.size );
	codeBuf.offset = 0;
		
	dataBuf.size = 1*1024*1024;	// 1MB initial allocation.
	dataBuf.base = malloc2( dataBuf.size );
	dataBuf.offset = 0;
		
	extBuf.size = 1*1024*1024;	// 1MB initial allocation.
	extBuf.base = malloc2( extBuf.size );
	extBuf.offset = 0;
		
	constBuf.size = 1*1024*1024;	// 1MB initial allocation.
	constBuf.base = malloc2( constBuf.size );
	constBuf.offset = 0;
		
	bssBuf.size = 512*1024;	// 1/2MB initial allocation.
	bssBuf.base = malloc2( bssBuf.size );
	bssBuf.offset = 0;
		
	roBuf.size = 512*1024;	// 1/2MB initial allocation.
	roBuf.base = malloc2( roBuf.size );
	roBuf.offset = 0;
		


	FileName = SourceFile;
	Suffix = strlen( FileName ) - 4;

	_here;
	yyin = fopen( FileName, "r" );
	_if( yyin == NULL )

		fprintf( MsgOut, "Could not open %s\n", SourceFile );
		_return 1;

	_endif
	{
		char *pPathPosn;
		char name[ MAX_PATH+1 ];
		char path[ MAX_PATH+1 ];
		char tempName[ MAX_PATH+1 ];
		char *baseName;
		char *targetName;
		
		// Get the base name of the source file (without the path prefix):
		
		strcpy( tempName, SourceFile );
		_if( (baseName = strrchr( tempName, DIR_SEP_CHAR ))  == NULL )
		
			baseName = tempName-1;
			
		_endif
		++baseName;
		
		// Get a copy of the path prefix:
		
		path[0] = '\0';
		_if( baseName != tempName )
		
			memcpy( path, tempName, baseName-tempName );
			path[ baseName - tempName ] = '\0';
			
		_endif
		
		// Remove the ".hla" suffix:
		
		baseName[ strlen( baseName ) - 4 ] = '\0';
		
		_if( useHLABE )
		
			// If the "-obj:path" option was specified, then
			// write the object file to the specified path:
			
			_if( objPath != NULL )
			
				int len;
			
				len = strlen( objPath );
				_if
				( 
						len != 0 
					&&	objPath[ len-1 ] != DIR_SEP_CHAR
				)
				
					objPath[ len ] = DIR_SEP_CHAR;
					++len;
					objPath[ len ] = '\0';
					
				_endif
				strcpy( name, objPath );
				_if( binName != NULL )	// Use supplied "-b:name" output filename.
				
					strcpy( name+len, binName );
					
				_else	// no -b:name option, so use file's base name:
				
					strcpy( name+len, baseName );
					
				_endif
				
			_else
			
				// If no "-obj:path" option was specified,
				// just use the base file name as the output
				// file.
				
				strcpy( name, path );
				_if( binName != NULL )	// Use supplied "-b:name" output filename.
				
					strcat( name, binName );

				_else	// no -b:name option, so use file's base name:

					strcat( name, baseName );
					
				_endif
				
			_endif
			
			// When using the internal HLA back engine, we're really creating
			// an .obj file, but the common code that follows expects the output
			// filename in the AsmName variable:
			
			strcpy( AsmName, name );

			// As we're generating an object file (using internal HLABE)
			// rather than a ".asm" file, put the appropriate suffix on
			// the "AsmName":
			
			_if( binName == NULL ) 	// -b:name option assumes suffix is present
			
				_switch( targetOS )
				
					_case( windows_os )

						strcat( AsmName, ".obj" );
						
					_endcase
					
					_case( macOS_os )
					_case( freeBSD_os )
					_case( linux_os )
					
						strcat( AsmName, ".o" );
						
					_endcase
					
					_default

						yyerror( "Target OS doesn't support the use of HLABE" );
						strcat( AsmName, ".o" );
						
				_endswitch
				
			_endif
		
			// Okay, the .link file needs to go in the temporary directory,
			// not in the objPath directory:
			
			_if( *outPath != '\0' )
			
				strcpy( LinkName, outPath );		// Start with output path
				
			_else // outPath is the empty string
			
				// If no outPath, then use the path prefix
				// of the original filename.
				
				strcpy( LinkName, path );
				
			_endif
			
			// The .link file also goes in the outPath directory:
			
			strcat( LinkName, baseName );
			strcat( LinkName , ".link" );
			
		_else
		
			// If we're not using the internal HLA back engine, then
			// we're creating an ".asm" file as output and we need to
			// put it in the temp (outPath) directory, if one was specified.
			
			_if( *outPath != '\0' )
			
				strcpy( name, outPath );		// Start with output path
				
			_else // outPath is the empty string
			
				// If no outPath, then use the path prefix
				// of the original filename.
				
				strcpy( name, path );
				
			_endif
			strcat( name, baseName );		// Append the filename.
			strcpy( AsmName, name );
			strcat( AsmName, ".asm" );
			
			// The .link file also goes in the outPath directory:
			
			strcpy( LinkName, name );
			strcat( LinkName , ".link" );
			
		_endif
	}



	_if( Verbose )

		fprintf
		(
			MsgOut,
			"Assembling \"%s\" to \"%s\"\n",
			FileName,
			AsmName
		);
		#if defined( windows_c ) || defined( linux_c )
		
			ftime( &CompileTimeStart );
		
		#endif

	_endif



	/*
	** Okay, process the source file
	*/
	
	_here;
	yyparse();
	_here;
	
	_if( yyerrCount != 0 )
	
		fprintf
		(
			MsgOut,
			"HLAPARSE assembly failed with %d errors\n",
			yyerrCount
		);
		_return yyerrCount;
	
	_endif
	
	
	_if( Verbose )
	
		struct timeb	CompileTime;
		double			milliseconds;
		double			LinesPerSecond;
		
		fprintf
		(
			MsgOut,
			"HLAPARSE assembly complete, %d lines",
			TotalLines
		);
		#if defined( windows_c ) || defined( linux_c )
		
			ftime( &CompileTime );
			milliseconds = 
					CompileTime.millitm - CompileTimeStart.millitm
				+	(CompileTime.time - CompileTimeStart.time) * 1000.0
				+	0.1; // To prevent a division by zero.
				
			LinesPerSecond = (double)((TotalLines * 1000.0)/milliseconds);
			fprintf
			(
				MsgOut,
				", %7.3f seconds, %7.0f lines/second",
				milliseconds/1000.0, 
				LinesPerSecond
			);
			
		#endif
		fprintf( MsgOut, "\n" );
	
	_endif

	// Guarantee that source files end with a newline:

	_here;
	asmPuts( "\n" );
	
	


	/*
	** Create a linker response file here:
	*/

	_if( ResponseFile >= 2 )
	
		// If we're forcing the creation of a new link file,
		// begin by deleting the old one if it exists.
		
		unlink( LinkName );
		
	_endif
	
	
	_if
	( 
			ResponseFile 
		&&	( wasProgram || (ResponseFile >= 2) ) 
		&& 	(targetOS == windows_os || includeLibList != NULL ))
	
		_if( ResponseFile == 2 || !fexists( LinkName ))

			linkOut = fopen( LinkName, "w" );
			_if( linkOut == NULL )
			
				char msg[256];
				
				sprintf( msg, "Could not create file '%s'", LinkName );
				yyerror( msg );
				exit( 1 );
				
			_endif
			SetSeg( CsegName, csname, ".text" );
			SetSeg( DsegName, dataname, ".data" );
			SetSeg( BssSegName, bssname, ".bss" );
			SetSeg( ROsegName, roname, ".text" );
			SetSeg( StrSegName, constname, ".text" );
			_if( targetOS == windows_os )
			
				fprintf
				(
					linkOut,
					"-heap:0x1000000,0x1000000\n"
					"-stack:0x1000000,0x1000000\n"
					"-base:0x4000000\n"
					"-entry:HLAMain\n"
					"-section:%s,ER\n" 
					"-section:%s,RW\n"
					"-section:%s,RW\n",
					csname,
					dataname,
					bssname
				);
			
				

				// We don't support segments anymore, so the 
				// following is a waste of time:
				
				s = SegmentList;
				assert( s == NULL );
				fprintf
				(
					linkOut,
					"kernel32.lib\n"
					"user32.lib\n"
					"gdi32.lib\n"
				);
				
			_endif
			
			// The following is done for all OSes. Note that
			// for Linux, FreeBSD, and MacOS, the HLA program
			// simply copies the following text to the linker's
			// command line.
			
			_while( includeLibList != NULL )
			
				fprintf
				(
					linkOut,
					"%s\n",
					includeLibList->lib
				);
				includeLibList = includeLibList->next;
				
			_endwhile

			fclose( linkOut );
			
		_endif

	_endif
		

	_here;
	
	// Copy all the data to one buffer (mainly for HLA Back Engine
	// compilation):
	
	
	_begin( outputBuffer )
	
		outputBuf	buffer;
		
		_here;
		extPubIterator( &extBuf );
		_here;
		
		buffer.offset = 0;
		buffer.size =
				preambleBuf.offset
			+	extBuf.offset
			+	codeBuf.offset
			+	dataBuf.offset
			+	roBuf.offset
			+	bssBuf.offset
			+	constBuf.offset
			+	16384;		// For the extra stuff we're going to tack on.

		_here;
		buffer.base = malloc2( buffer.size );
		asmBuf = &buffer;
		
		asmCpy( preambleBuf.base, preambleBuf.offset );
		asmCpy( extBuf.base, extBuf.offset );
		
		EmitSegments( &buffer );
		
		_if( assembler == masm || assembler == tasm )
		
			asmPrintf( "\t\tend\n" );
			
		_elseif( assembler == hlabe )
		
			asmPuts( "\n" hlabe_end "\n" );
				
		_endif
		asmPrintf( "\n" );	

		_if( !useHLABE )
		
			fOut = fopen( AsmName, "w+" );
			_if( fOut == NULL )

				fprintf
				( 
					MsgOut, 
					"Could not open output file '%s'\n%s\n", 
					AsmName,
					strerror( errno )
				);
				_return 1;

			_endif
			fwrite( buffer.base, buffer.offset, 1,  fOut );
			fclose( fOut );
			
		_else
		
			
		
			_if( targetOS == windows_os )
			 
				hlabe_compile
				(
					FileName,
					AsmName, 
					buffer.base, 
					buffer.base + buffer.offset,
					objt_pecoff_c,
					Verbose 
				);
				
			_elseif( targetOS == linux_os )
			 
				hlabe_compile
				(
					FileName,
					AsmName, 
					buffer.base, 
					buffer.base + buffer.offset,
					objt_elfLinux_c,
					Verbose 
				);
				
			
			_elseif( targetOS == freeBSD_os )
			 
				hlabe_compile
				(
					FileName,
					AsmName, 
					buffer.base, 
					buffer.base + buffer.offset,
					objt_elfFreeBSD_c,
					Verbose 
				);
				
			
			_elseif( targetOS == macOS_os )
			
				hlabe_compile
				(
					FileName,
					AsmName, 
					buffer.base, 
					buffer.base + buffer.offset,
					objt_macho_c,
					Verbose 
				);

			_else
			
				fprintf
				( 
					MsgOut, 
					"Unknown target OS (internal HLAPARSE error)\n" 
				);
				_return 1;
				
			_endif
				
		
		_endif
		free2( vss buffer.base );
		free2( vss preambleBuf.base );
		free2( vss codeBuf.base );
		free2( vss dataBuf.base );
		free2( vss roBuf.base );
		free2( vss bssBuf.base );
		free2( vss constBuf.base );
	
	_end( outputBuffer )
	fclose( yyin );
	
	_here;

	/*
	** Print the symbol table when we're done.
	*/

	_if( DumpSymbols )
	
		fprintf( MsgOut, "\n\nSymbol Table:\n\n" );
		DumpSym( SymbolTable, 0 );

	_endif


	_here;
	_return yyerrCount;

_end( main )
