	.TITLE	X25ACLS1 - X.25 packet level routines for XOS (part 1)

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR
	.INCLUD	LAPBA.PAR
	.INCLUD	X25A.PAR

;This module implements the X.25 packet level protocol.

MAJV   =!1t
MINV   =!0t
EDITNUM=!1t

;1.0.1 - 21-Apr-95
;	Added IOPAR_NETLCLNETA IO parameter.


	LKEHEAD	X25ACLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

	CODE

	.SBTTL	SVC dispatch table for X25A devices

;SVC dispatch table for X25A devices

x25dsp:	.LONG	knlRtnZero##	;sd_mount	=  0. - Mount
	.LONG	knlRtnZero##	;sd_cleardev	=  4. - Clear device
	.LONG	x25givedcb	;sd_cleardcb	=  8. - Clear DCB
	.LONG	knlRtnZero##	;sd_commit	= 12. - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold    = 16. - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew    = 20. - Transfer device/new
	.LONG	knlNullQio##	;sd_opena	= 24. - Open additional
	.LONG	x25open		;sd_open1	= 28. - Open device/file
	.LONG	x25devparm	;sd_devparm     = 32. - Device parameters
	.LONG	knlIFnDev##	;sd_delete	= 36. - Delete file
	.LONG	knlIFnDev##	;sd_rename	= 40. - Rename file
	.LONG	x25inpblk	;sd_inblock	= 44. - Input block
	.LONG	x25outblk	;sd_outblock	= 48. - Output block
	.LONG	x25outblk1	;sd_outblockq	= 52. - Output block (XFF)
	.LONG	x25outstr	;sd_outstring	= 56. - Output string
	.LONG	knlRtnMOne##	;sd_getiosts	= 60. - Get input/output status
	.LONG	knlIFnDevGQ##	;sd_special     = 64. - Special device function
	.LONG	x25close	;sd_close	= 68. - Close file
	.LONG	knlNullLabel##	;sd_label       = 72. - Get device label
	.LONG	knlNullQioGQ##	;sd_commitfunc	= 76. - Commit data to disk
	.LONG	x25devinfo	;sd_devinfo     = 80. - Get device info
X25DSPSZ=!{$-x25dsp}/4

;Class function dispatch table for X25A class devices

	.LONG	X25CLSFMX
x25cls::.LONG	x25addunit	;CF_ADDUNIT =  8. - Add unit
	.LONG	x25unitinfo	;CF_PUNITS  =  9. - Get information about
				;		      physical units
	.LONG	knlIFnDevGQ##	;CF_AUNITS  = 10. - Get information about active
				;		      units
X25CLSFMX=!{$-x25cls}/4
.PAGE
;Device characteristics tables for the X25A devices

	DATA

	.MOD	4
x25dctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS  , TEXT, ,  8, knlDcMsgClass##  , knlDcGetClass##, knlDcSetClass##, 0
 DCHARENT  LAPBDEV, TEXT, , 16, msglapbdev       , getlapbdev     , 0              , sdb_name
 DCHARH    condc  , gethdcdc, findcdc
 DCHARENT  ACCESS , TEXT, ,  4, knlDcMsgAccess## , getpdbdata     , setaccess      , pdb_x25access
 DCHARENT  NCTO   , DECV, ,  4, msgncto          , getpdbticks    , setpdbticks    , pdb_x25nctoval
 DCHARENT  MAXCHNL, DECV, ,  4, msgmaxchnl       , getpdbdata     , 0              , pdb_x25maxchnl
 DCHARENT  ACDOWN , TEXT, ,  4, msgacdown        , getconfig      , setconfig      , X25C$ACDOWN
 DCHARENT  LCLADDR, STR , , 24, msglcladdr       , getaddress     , setaddress     , pdb_x25lcladdr
 DCHARENT  DFTADDR, STR , , 24, msgdftaddr       , getaddress     , setaddress     , pdb_x25dftaddr
 DCHARENT  T20    , DECV, ,  4, msgt20           , getpdbsecs     , setpdbsecs     , pdb_x25t20val
 DCHARENT  T21    , DECV, ,  4, msgt21           , getpdbsecs     , setpdbsecs     , pdb_x25t21val
 DCHARENT  T22    , DECV, ,  4, msgt22           , getpdbsecs     , setpdbsecs     , pdb_x25t22val
 DCHARENT  T23    , DECV, ,  4, msgt23           , getpdbticks    , setpdbticks    , pdb_x25t23val
 DCHARENT  T28    , DECV, ,  4, msgt28           , getpdbsecs     , setpdbsecs     , pdb_x25t28val
 DCHARENT  WINRCV , DECV, ,  4, msgwinrcv        , getpdbbyte     , setpdbwin      , pdb_x25rcvwinsz
 DCHARENT  WINLVL , DECV, ,  4, msgwinlvl        , getpdbbyte     , setpdbbyte     , pdb_x25rcvwinlvl
 DCHARENT  WINDLY , DECV, ,  4, msgwindly        , getpdbmsticks  , setpdbmsticks  , pdb_x25rcvwindly
 DCHARENT  WINSND , DECV, ,  4, msgwinsnd        , getpdbbyte     , setpdbwin      , pdb_x25sndwinsz
 DCHARENT  PKTIN  , DECV, ,  4, xosnetMsgPktIn## , getpdbdata     , setpdbdata     , pdb_x25cntpktin
 DCHARENT  BYTEIN , DECV, ,  4, knlDcMsgByteIn## , getpdbdata     , setpdbdata     , pdb_x25cntbytein
 DCHARENT  PKTOUT , DECV, ,  4, xosnetMsgPktOut##, getpdbdata     , setpdbdata     , pdb_x25cntpktout
 DCHARENT  BYTEOUT, DECV, ,  4, knlDcMsgByteOut##, getpdbdata     , setpdbdata     , pdb_x25cntbyteout
 DCHARENT  OUTSEQ , DECV, ,  4, msgoutseq        , getpdbdata     , setpdbdata     , pdb_x25cntoutseq
 DCHARENT  OUTWIN , DECV, ,  4, msgoutwin        , getpdbdata     , setpdbdata     , pdb_x25cntoutwin
 DCHARENT  FLOWOVR, DECV, ,  4, msgflowovr       , getpdbdata     , setpdbdata     , pdb_x25cntflowovr
 DCHARENT  UNXTYPE, DECV, ,  4, msgunxtype       , getpdbdata     , setpdbdata     , pdb_x25cntunxtype
 DCHARENT  RSTSENT, DECV, ,  4, msgrstsent       , getpdbdata     , setpdbdata     , pdb_x25cntrstsent
 DCHARENT  RSTRCVD, DECV, ,  4, msgrstrcvd       , getpdbdata     , setpdbdata     , pdb_x25cntrstrcvd
 DCHARENT  CLOST  , DECV, ,  4, msgclost         , getpdbdata     , setpdbdata     , pdb_x25cntclost

	CODE

msglapbdev:  DCHARINFO  {LAPB device}
msgconmsgdst:DCHARINFO  {Message dest. for in-comming call}
msgncto:     DCHARINFO  {New connection time-out (sec)}
msgmaxchnl:  DCHARINFO  {Maximum X.25 logical channel}
msgacdown:   DCHARINFO  {Allocate channels down from maximum}
msglcladdr:  DCHARINFO  {Local X.25 address}
msgdftaddr:  DCHARINFO  {Default remote X.25 address}
msgt20:      DCHARINFO  {Restart request time-out (sec)}
msgt21:      DCHARINFO  {Call request time-out (sec)}
msgt22:      DCHARINFO  {Reset request time-out (sec)}
msgt23:      DCHARINFO  {Clear request time-out (sec)}
msgt28:      DCHARINFO  {Registration request time-out (sec)}
msgwinrcv:   DCHARINFO  {Default receive window size}
msgwinlvl:   DCHARINFO  {Receive window RR delay level}
msgwindly:   DCHARINFO  {Receive window RR delay time (ms)}
msgwinsnd:   DCHARINFO  {Default send window size}
msgoutseq:   DCHARINFO  {Discarded - out of sequence packets}
msgoutwin:   DCHARINFO  {Discarded - out of window packets}
msgflowovr:  DCHARINFO  {Discarded - flow control overrun}
msgunxtype:  DCHARINFO  {Number of packets of unexpected type}
msgoosnum:   DCHARINFO  {Number of out-of-seq packets queued}
msgoosmax:   DCHARINFO  {Maximum out-of-seq packets queued}
msgrexmit:   DCHARINFO  {Number of retransmitted packets}
msgclost:    DCHARINFO  {Number of lost connections}
msgrstsent:  DCHARINFO  {Number of resets sent}
msgrstrcvd:  DCHARINFO  {Number of resets received}
.PAGE
;Device parameter table for X25A open

	.MOD	4
	.LONG	OPARMMAX
x25opnparms:
	.LONG	x25opngenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	x25opnnetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
OPARMMAX=!{$-x25opnparms}/4

	.LONG	OPARMGENMAX	;Size of table
x25opngenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopDummyS##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
OPARMGENMAX=!{$-x25opngenparms}/4

	.LONG	OPARMNETMAX
x25opnnetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	0		;IOPAR_NETPROTOCOL = 0502h
	.LONG	x25plclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	x25ioprmtnetas	;IOPAR_NETRMTNETAS = 0506h
	.LONG	x25ioprmtnetar	;IOPAR_NETRMTNETAR = 0507h
	.LONG	0		;IOPAR_NETRMTPORTS = 0508h
	.LONG	0		;IOPAR_NETRMTPORTR = 0509h
	.LONG	0		;IOPAR_NETDSTNAME  = 050Ah
	.LONG	0		;IOPAR_NETSMODE    = 050Bh
	.LONG	0		;IOPAR_NETCMODE    = 050Ch
	.LONG	0		;IOPAR_NETRCVWIN   = 050Dh
	.LONG	x25ioplclneta	;IOPAR_NETLCLNETA  = 050Eh
OPARMNETMAX=!{$-x25opnnetparms}/4
.PAGE
	.LONG	PARMMAX
x25ioparms:
	.LONG	x25iogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	x25ionetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
PARMMAX=!{$-x25ioparms}/4

	.LONG	PARMGENMAX	;Size of table
x25iogenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIoxFilOptn##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIoxFilSpec##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
PARMGENMAX=!{$-x25iogenparms}/4

	.LONG	PARMNETMAX
x25ionetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	0		;IOPAR_NETPROTOCOL = 0502h
	.LONG	x25plclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	0		;IOPAR_NETRMTNETAS = 0506h
	.LONG	x25ioprmtnetar	;IOPAR_NETRMTNETAR = 0507h
	.LONG	0		;IOPAR_NETRMTPORTS = 0508h
	.LONG	0		;IOPAR_NETRMTPORTR = 0509h
	.LONG	0		;IOPAR_NETDSTNAME  = 050Ah
	.LONG	0		;IOPAR_NETSMODE    = 050Bh
	.LONG	0		;IOPAR_NETCMODE    = 050Ch
	.LONG	0		;IOPAR_NETRCVWIN   = 050Dh
	.LONG	x25ioplclneta	;IOPAR_NETLCLNETA  = 050Eh
PARMNETMAX=!{$-x25ionetparms}/4
.PAGE
	.SBTTL	x25init - Initialization routine

	INITSUB	x25init

;The command for installing X25ACLS is:
;	LKELOAD X25ACLS

x25init:MOVL	EDI, #x25chk		;Install the X25A class
	MOVL	EBX, #x25cls		;Offset of class function dispatch table
	CLRL	ECX
	MOVL	EAX, #'X25A'
	CLRL	EDX
	MOVL	ESI, #x25ccb
	CALL	knlNewClass##
	JC	4$.S			;This should not fail!
	MOVL	ECX, #xcodetop#
	CLRL	EDX
	CLRL	EAX
4$:	MOVL	EBX, #QSTS$DONE
	RET

	CODE
.PAGE
	.SBTTL	x25addunit - Subroutine to add X25A unit

;Subroutine to add X25A unit - this implements an X.25 packet level device for
;  a single LAPB device.  Since LAPB does not support multiple higher level
;  protocols, only one X.25 device can be implemented for each LAPB device.
;	c{ES:EDI} = Address of data block
;	CALL	x25addunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count

$$$=!0
FRM x25au_unit   , 4t		;Unit number
FRM x25au_sdb    , 4t		;Offset of LAPB SDB
FRM x25au_maxchnl, 4t		;Maximum number of channels
x25au_SIZE=!$$$

	DATA

	.MOD	4
x25aublk:				;Parameter description block for
 DCHARBGN  3, knlDCharValCom##		;  adduparms
 DCHARENT  UNIT   , DECV, ,  1, 0, 0, x25auunit   , 0
 DCHARENT  LAPBDEV, TEXT, , 16, 0, 0, x25aulapbdev, 0
 DCHARENT  MAXCHNL, DECV, ,  4, 0, 0, x25aumaxchnl, 0

	CODE

	IFFAULT	8$
x25addunit:
	LFSL	EDX, iorb_buffer2.B[ESI]
	CALL	knlGiveQel##		;Give up the IORB
	ENTER	x25au_SIZE, 0		;Allocate our stack frame
	CLRL	EAX
	MOVL	x25au_sdb.B[EBP], EAX
	MOVL	x25au_maxchnl.B[EBP], EAX
	DECL	EAX
	MOVL	x25au_unit.B[EBP], EAX
	MOVL	EBX, #x25aublk
	MOVB	AL, #0			;Fail on bad names
	CALL	knlAddUnitChar##	;Process the characteristics
	JC	4$.S			;If error
	CMPL	x25au_sdb.B[EBP], #0.B	;Was a LAPB device specified?
	JE	2$.S			;No
	CMPL	x25au_maxchnl.B[EBP], #0.B ;Was number of channels specified?
	JE	2$.S			;No
	CMPL	x25au_unit.B[EBP], #0.B	;Yes - was a unit number specified?
	JGE	10$.S			;Yes - go on
2$:	MOVL	EAX, #ER_CHARM		;No - fail
4$:	CLRL	ECX
6$:	MOVL	EBX, #QSTS$DONE
	LEAVE
	TOFORK
	RET
		
;Here if address error with the IORB

	FAULTHDR
8$:	CALL	knlGiveQel##
	MOVL	EAX, #ER_ADRER
	JMP	4$.S

;Here with characteristics processed

10$:	MOVL	EDI, x25pdbhead		;Look for PDB for transport protocol

	MOVB	AL, x25au_unit.B[EBP]
12$:	TESTL	EDI, EDI
	JE	16$.S
	CMPB	pdb_unit.B[EDI], AL
	JE	14$.S
	MOVL	EDI, pdb_nextd.B[EDI]
	JMP	12$.S

;Here if device is already defined

14$:	MOVL	EAX, #ER_DUADF
	JMP	24$

;Here if desired X25A device is not now defined - first allocate space for
;  the PDB for the device

16$:	CALL	knlGetXRes##		;Get the exec memory resource
	MOVL	ECX, x25au_maxchnl.B[EBP] ;Allocate the PDB
	SHLL	ECX, #2t
	ADDL	ECX, #pdb_mSIZE+pdb_x25SIZE+4
	CALL	knlGetXMem##
	JC	22$			;If error
	CALL	knlGiveXRes##		;Give up the exec memory resource
	ADDL	EDI, #pdb_mSIZE.B
	MOVL	pdb_receive.B[EDI], #x25rcvpkt# ;Store receive dispatch offset
	MOVL	pdb_linkup.B[EDI], #x25linkup# ;Store link up dispatch offset
	MOVL	pdb_linkdown.B[EDI], #x25linkdown# ;Store link down dispatch
						   ;  offset
	MOVL	pdb_magic.B[EDI], #'PDB' ;Store magic number for PDB
	MOVL	EAX, x25au_unit.B[EBP]	;Get unit number
	MOVB	pdb_unit.B[EDI], AL
	MOVL	pdb_name+0.B[EDI], #'X25A'
	LEAL	EBX, pdb_name+4.B[EDI]
	CALL	knlPutDecNmbr##		;Insert number into name
	MOVL	pdb_dcbsizex.B[EDI], #dcb_x25INDEX ;Store size index for DCBs
	MOVL	pdb_ccb.B[EDI], #x25ccb ;Store offset of the CCB
	MOVL	EAX, x25au_maxchnl.B[EBP]
	MOVL	pdb_x25maxchnl.B[EDI], EAX
	MOVL	pdb_x25sndpktmax.B[EDI], #1024t
	MOVL	pdb_x25rcvpktmax.B[EDI], #1024t
	MOVL	pdb_x25t20val.B[EDI], #180t*XT_SECOND ;Store default time-out
	MOVL	pdb_x25t21val.B[EDI], #200t*XT_SECOND ;  values
	MOVL	pdb_x25t22val.B[EDI], #180t*XT_SECOND
	MOVL	pdb_x25t23val.B[EDI], #180t*TICKSPERSEC
	MOVL	pdb_x25t28val.B[EDI], #300t*XT_SECOND
	MOVL	pdb_x25nctoval.B[EDI], #10t*TICKSPERSEC
	MOVB	pdb_x25rcvwinsz.B[EDI], #3 ;Store default default window sizes
	MOVB	pdb_x25sndwinsz.B[EDI], #3
	MOVB	pdb_x25rcvwinlvl.B[EDI], #2
	MOVL	pdb_x25rcvwindly.B[EDI], #5
	MOVL	ESI, x25au_sdb.B[EBP]
	MOVL	sdb_pdbhead.B[ESI], EDI	;This is the first (only) PDB
	MOVL	sdb_pdbtail.B[ESI], EDI
	MOVL	pdb_sdb.B[EDI], ESI
	MOVL	EAX, sdb_idb.B[ESI]
	MOVL	pdb_idb.B[EDI], EAX
	MOVL	EAX, x25pdbhead
	MOVL	pdb_nextd.B[EDI], EAX
	MOVL	x25pdbhead, EDI
	CLRL	EAX
	MOVL	ECX, #1
18$:	MOVL	EBX, #QSTS$DONE
	LEAVE
	TOFORK
	RET
		
;Here if error allocating memory for the PDB

22$:	CALL	knlGiveXRes##		;Give up the exec memory resource
24$:	CLRL	ECX
	JMP	18$.S
.PAGE
;Subroutine called by adduparms for the "UNIT" parameter

x25auunit:
	CMPL	EAX, #99t.B		;Valid value?
	JA	knlBadCharV##		;No - fail
	MOVL	x25au_unit.B[EBP], EAX	;Yes - store it
	CLC
	RET

;Subroutine called by adduparms for the "LAPBDEV" parameter

x25aulapbdev:
	CMPL	x25au_sdb.B[EBP], #0.B	;Already have a LAPB device?
	JNE	8$.S			;Yes - fail
	CMPL	knlDcValue##+0, #'LAPB'
	JNE	6$.S
	MOVL	EAX, knlDcValue##+8
	ORL	EAX, knlDcValue##+12t
	JNE	6$.S
	MOVL	EDI, xoslpaSdbHead##	;No - get offset of first LAPB SDB
	MOVL	EAX, knlDcValue##+4
2$:	TESTL	EDI, EDI
	JE	6$.S
	CMPL	sdb_name+4.B[EDI], EAX
	JE	4$.S
	MOVL	EDI, sdb_nextd.B[EDI]
	JMP	2$.S

;Here with the requested SDB

4$:	CMPL	sdb_pdbhead.B[EDI], #0.B ;Already have a packet device?
	JNE	10$.S			;Yes - fail
	MOVL	x25au_sdb.B[EBP], EDI	;No - store PDB offset
	RET

;Here if cannot find requested LAPB device

6$:	MOVL	EAX, #ER_NSDEV
	STC
	RET

;Here if more than one LAPB device specified

8$:	MOVL	EAX, #ER_TMDDV
	STC
	RET

;Here if already have a packet level device associated with the LAPB device

10$:	MOVL	EAX, #ER_DEVIU
	STC
	RET

;Subroutine called by adduparms for the "MAXCHNL" parameter

x25aumaxchnl:
	CMPL	EAX, #0FFFh		;Valid value?
	JA	knlBadCharV##		;No
	TESTL	EAX, EAX		;Maybe
	JE	knlBadCharV##		;No
	MOVL	x25au_maxchnl.B[EBP], EAX ;Yes - store it
	RET
.PAGE
	.SBTTL	x25unitinfo - X25A get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  X25A class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	x25unitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

x25unitinfo:
	MOVL	EAX, #ER_NIYT
	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	RET
.PAGE
	.SBTTL	getpdbdata - Get 4-byte data value from the PDB

;Here to get a 4-byte data value from the PDB

getpdbdata:
	ADDL	EBX, dcb_netpdb.B[EDI]
	MOVL	EAX, [EBX]
	RET

	.SBTTL	setpdbdata - Store 4-byte data value in the PDB

;Here to store a 4-byte data value in the PDB

setpdbdata:
	ADDL	EBX, dcb_netpdb.B[EDI]
	MOVL	[EBX], EAX
	RET

	.SBTTL	getpdbbyte - Get 1-byte data value from the PDB

;Here to get a 1-byte data value from the PDB

getpdbbyte:
	ADDL	EBX, dcb_netpdb.B[EDI]
	MOVZBL	EAX, [EBX]
	RET

	.SBTTL	setpdbbyte - Set 1-byte data value in the PDB

;Here to set a 1-byte data value in the PDB

setpdbbyte:
	ADDL	EBX, dcb_netpdb.B[EDI]
	MOVB	[EBX], AL
	RET

	.SBTTL	getpdbtext - Get text value from the PDB

;Here to get a text value from the PDB

getpdbtext:
	ADDL	EDX, dcb_netpdb.B[EDI]
	JMP	knlGetSysStr##

	.SBTTL	setpdbtext - Set text value in the PDB

;Here to set a text value in the PDB

setpdbtext:
	ADDL	EDX, dcb_netpdb.B[EDI]
	JMP	knlSetSysStr##

	.SBTTL	getpdbticks - Get seconds data value from the PDB

;Here to get a seconds data value from the PDB (stored as ticks)

getpdbticks:
	ADDL	EBX, dcb_netpdb.B[EDI]
	MOVL	EAX, [EBX]
	CLRL	EDX
	DIVL	litTICKSPERSEC
	CLC
	RET

	.SBTTL	setpdbticks - Set seconds data value in the PDB

;Here to set a seconds data value in the PDB (stored as ticks)

setpdbticks:
	ADDL	EBX, dcb_netpdb.B[EDI]
	TESTL	EAX, EAX		;0 value?
	JNE	2$.S			;No
	INCL	EAX			;Yes - make it 1
2$:	MULL	litTICKSPERSEC		;Change to ticks
	MOVL	[EBX], EAX		;Store value
	CLC
	RET

	.SBTTL	getpdbsecs - Get seconds data value from the PDB

;Here to get seconds data value from the PDB (stored as fractional day)

getpdbsecs:
	ADDL	EBX, dcb_netpdb.B[EDI]
	MOVL	EAX, [EBX]
	CLRL	EDX
	DIVL	litXT_SEC
	CLC
	RET

	.SBTTL	setpdbsecs - Store seconds data value in the PDB

;Here to store seconds data value in the PDB (stored as fractional day)

setpdbsecs:
	ADDL	EBX, dcb_netpdb.B[EDI]
	TESTL	EAX, EAX		;0 value?
	JNE	6$.S			;No
	INCL	EAX			;Yes - make it 1
6$:	MULL	litXT_SEC		;Change to fractional days
	TESTL	EDX, EDX		;More than 1 day?
	JE	8$.S			;No
	MOVL	EAX, #0FFFFFFFFh	;Yes - make it 1 day!
8$:	MOVL	[EBX], EAX		;Store value
	RET

	.SBTTL	setaccess - Store access class name in the PDB

;Here to store the access class name (ACCESS characteristic) in the PDB

setaccess:
	ADDL	EBX, dcb_netpdb.B[EDI]
	JMP	knlSetAccess##

	.SBTTL	getpdbmsticks - Get ms data value from the PDB as ticks

;Here to get ms data value from the PDB (stored as ticks)

getpdbmsticks:
	ADDL	EBX, dcb_netpdb.B[EDI]
	MOVL	EAX, [EBX]
	MULL	litMSPERTICK
	CLC
	RET

	.SBTTL	setpdbmsticks - Set ms data value in the PDB as ticks

;Here to set ms data value in the PDB (stored as ticks)

setpdbmsticks:
	ADDL	EBX, dcb_netpdb.B[EDI]
	ADDL	EAX, #litMSPERTICK-1
	CLRL	EDX
	DIVL	litMSPERTICK
	TESTL	EAX, EAX
	JNE	10$.S
	INCL	EAX
10$:	MOVL	[EBX], EAX
	RET

	.SBTTL	setpdbwin - Store window size value in the PDB

;Here to store window size value in the PDB

setpdbwin:
	ADDL	EBX, dcb_netpdb.B[EDI]
	CMPL	EAX, #7			;Too big?
	JBE	12$.S			;No
	MOVL	EAX, #7			;Yes - make it as big as we can
12$:	TESTL	EAX, EAX		;Zero?
	JNE	14$.S			;No
	INCL	EAX			;Yes - make it 1
14$:	MOVL	[EBX], EAX
	RET
.PAGE
	.SBTTL	getconfig - Get value of characteristic for configuration

;Here to get the value of a characteristic which indicates configuraiton

getconfig:
	MOVL	ESI, dcb_netpdb.B[EDI]
	MOVL	EAX, #'YES'		;Assume its set
	TESTB	pdb_x25config.B[ESI], BL	;Right?
	JNE	4$.S			;Yes
	MOVL	EAX, #'NO'		;No
4$:	CLRL	EDX
6$:	RET

	.SBTTL	setconfig - Set value of characteristic for configuration

;Here to set the value of a characteristic which indicates configuraiton

setconfig:
	MOVL	ESI, dcb_netpdb.B[EDI]
	CALL	knlGetYesNo##
	JC	6$.S
	JNE	8$.S
	ORB	pdb_x25config.B[ESI], BL
	RET

8$:	NOTB	BL
	ANDB	pdb_x25config.B[ESI], BL
	RET

	.SBTTL	getaddress - Get value of ADDRESS characteristic

;Here to get the value of the ADDRESS characeristic

getaddress:
	TESTL	ECX, ECX
	JE	16$.S
	ADDL	EDX, dcb_netpdb.B[EDI]
	MOVZBL	ESI, [EDX]
	PUSHL	EBX
	INCL	EDX
10$:	DECL	ESI
	JS	12$.S
	DECL	ECX
	JS	14$.S
	MOVB	AL, [EDX]
	SHRB	AL, #4t
	ADDB	AL, #'0'
	MOVB	ES:[EBX], AL
	INCL	EBX
	DECL	ESI
	JS	12$.S
	DECL	ECX
	JS	14$.S
	MOVB	AL, [EDX]
	INCL	EDX
	ANDB	AL, #0Fh
	ADDB	AL, #'0'
	MOVB	ES:[EBX], AL
	INCL	EBX
	JMP	10$.S

12$:	MOVB	ES:[EBX], #0
14$:	MOVL	ECX, EBX
	POPL	EAX
	SUBL	ECX, EAX
16$:	RET

	.SBTTL	setaddress - Set value of ADDRESS characteristic

;Here to set the value of the ADDRESS characeristic

setaddress:
	ADDL	EDX, dcb_netpdb.B[EDI]
	JMP	storebcd

	.SBTTL	getlapbdev - Get value of LAPBDEV device characteristic

;Here to get the value of the LAPBDEV device characteristic

getlapbdev:
	MOVL	EDX, dcb_netpdb.B[EDI]
	ADDL	EBX, pdb_sdb.B[EDX]	;Get offset of underlying SDB
	MOVL	EAX, EBX		;Get offset of name in right register
	RET
.PAGE
	.SBTTL	gethdcdc - Get head routine for CON* device characteristics

;Get head routine for CON* device characteristics

gethdcdc:
	MOVL	ESI, dcb_netpdb.B[EDI]	;Get offset of PDB
	MOVL	ESI, pdb_x25condsthead.B[ESI] ;Get first block
	TESTL	ESI, ESI		;Set Z if not block
	RET

	.SBTTL	findcdc - Find element routine for CON* device characteristics

;Find element routine for CON* device characteristics.  If the characteristic
;  name is of the form CONnnnnn and is not found, an entry is created with a
;  null value.
;	c{EBX,EDX} = Characteristic name
;	c{EDI}     = Offset of DCB
;	CALL	findcdc
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:clr = No match
;	  Z:set = Match found
;	    c{ESI} = Offset of block

findcdc:MOVL	EAX, EBX
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'CON'
	JNE	8$.S
	PUSHL	EBX
	PUSHL	EDX
	MOVL	temp+0, EBX
	MOVL	temp+4, EDX
	CLRL	EAX
	MOVL	EBX, #temp+3
2$:	MOVB	DL, [EBX]
	INCL	EBX
	CMPB	DL, #0
	JE	10$.S
	CMPB	DL, #'0'
	JB	6$.S
	CMPB	DL, #'9'
	JA	6$.S
4$:	ANDL	EDX, #0Fh.B
	IMULL	EAX, #10t.B
	ADDL	EAX, EDX
	JMP	2$.S

;Here if found non-digit character - this is not a possible name

6$:	POPL	EDX
	POPL	EBX
8$:	TESTL	ESP, ESP
	RET

;Here with sub-address value

10$:	TESTL	EAX, EAX		;0 is not valid
	JE	6$.S
	CMPL	EAX, #99t.B		;Must be 99t or less
	JA	6$.S
	MOVL	EBX, #temp+3
	MOVL	1.B[EBX], #0
	PUSHL	EAX			;Rebuild the name to eliminate possible
	CALL	knlPutDecNmbr##		;  leading 0s
	POPL	EAX
	MOVL	EDX, dcb_netpdb.B[EDI]
	LEAL	EDX, pdb_x25condsthead.B[EDX]
12$:	MOVL	ESI, [EDX]
	TESTL	ESI, ESI
	JE	14$.S
	CMPL	dct_x25subaddr.B[ESI], EAX ;This one?
	JE	16$.S			;Yes - found it
	JA	14$.S			;If past where it goes
	LEAL	EDX, dct_lnknext.B[ESI]	;Advance to next block
	JMP	12$.S

;Here if need to insert a new block

14$:	CALL	knlGetQel##		;Get a queue element
	JC	16$.S			;If error
	MOVL	dct_x25subaddr.B[ESI], EAX ;Store sub-address value
	MOVL	EAX, temp+0		;Store name
	MOVL	dct_name+0.B[ESI], EAX
	MOVL	EAX, temp+4
	MOVL	dct_name+4.B[ESI], EAX
	MOVB	[ESI], #REP_TEXT
	MOVB	dct_flags.B[ESI], #DCTF$LNKELMT
	MOVW	dct_length.B[ESI], #16t
	MOVL	dct_getsub.B[ESI], #knlDcGetLong##
	MOVL	dct_setsub.B[ESI], #knlDcSetLong##
	MOVL	dct_lnkdone.B[ESI], #donecdc
	MOVL	dct_infopnt.B[ESI], #msgconmsgdst
	LEAL	EBX, dct_x25msgdst.B[ESI]
	MOVL	dct_data.B[ESI], EBX	;Store offset of the value
	CLRL	EAX
	MOVL	[EBX], EAX		;Clear the value
	MOVL	4t.B[EBX], EAX
	MOVL	8t.B[EBX], EAX
	MOVL	12t.B[EBX], EAX
	MOVL	EAX, [EDX]		;Link it into our list
	MOVL	[EDX], ESI
	MOVL	dct_lnknext.B[ESI], EAX
	MOVL	dct_x25prev.B[ESI], EDX
	TESTL	EAX, EAX		;Have a next block?
	JE	16$.S			;No
	LEAL	EDX, dct_lnknext.B[ESI]
	MOVL	dct_x25prev.B[EAX], EDX
	CLRL	EAX			;Set Z
16$:	POPL	EDX
	POPL	EBX
18$:	RET

;Subroutine called when done using an element block.  If the element has a
;  null value, the block is discarded, otherwise nothing is done here.
;	c{ESI} = Offset of block
;	CALL	donecdc
;  FS and EDX are preserved

donecdc:CMPB	dct_x25msgdst.B[ESI], #0 ;Have a null value?
	JNE	18$.S			;No - nothing needed here
	MOVL	EBX, dct_x25prev.B[ESI]	;Yes - unlink this block
	MOVL	EAX, dct_lnknext.B[ESI]
	MOVL	[EBX], EAX
	TESTL	EAX, EAX
	JE	20$.S
	MOVL	dct_x25prev.B[EAX], EBX
20$:	JMP	knlGiveQel##		;Give up the memory block
.PAGE
;Device check routine for X25A class devices
;	c{SS:EBX} = Address of device name (16 characters)
;	CALL	x25chk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  ESI is preserved

;X.25 devices work somewhat differently from IP suite devices.  The generic
;  X.25 device name is XAn, where n is the unit number (between 0 and 99).
;  When the generic name is used, a logical channel is assigned and an
;  out-going call is established using that channel.  The actual device opened
;  is given a specific X.25 device name of the form XAnCm, where m is the
;  logical channel number between 1 and FFF (represented in hex).  Specific
;  devices can also be specified.  This will work provided the device is
;  already open as described above or if there was an in-coming call which
;  created the specific device.  In-coming calls create specific devices which
;  are destroyed in T4 seconds if they are not opened first.  In-coming calls
;  can also be configured to cause a IPM message to be sent.

$$$=!0
FRM chk_name   , 20t
FRM chk_unit   , 4t
FRM chk_channel, 4t
chk_SIZE=!$$$

x25chk:	CMPW	SS:[EBX], #'XA'		;Is this XA*?
	JNE	4$.S			;No
	ENTER	chk_SIZE, 0		;Yes - check some more
	MOVL	EAX, SS:[EBX]
	MOVL	chk_name+0.B[EBP], EAX
	MOVL	EAX, SS:4.B[EBX]
	MOVL	chk_name+4.B[EBP], EAX
	MOVL	EAX, SS:8.B[EBX]
	MOVL	chk_name+8.B[EBP], EAX
	MOVL	EAX, SS:12t.B[EBX]
	MOVL	chk_name+12t.B[EBP], EAX
	CLRL	ECX
	MOVB	chk_name+16t.B[EBP], CL
	MOVL	chk_unit.B[EBP], #80000000h
	PUSHL	EAX
	LEAL	EDX, chk_name+2.B[EBP]
2$:	MOVB	AL, SS:[EDX]
	INCL	EDX
	CMPB	AL, #0			;End of name?
	JE	12$.S			;Yes - this is a specific X.25 name
	CMPB	AL, #'0'		;No - digit?
	JB	6$.S			;No
	CMPB	AL, #'9'		;Maybe
	JA	6$.S			;No
	ANDL	EAX, #0Fh.B		;Yes - add in to value
	IMULL	ECX, chk_unit.B[EBP], #10t.B
	ADDL	EAX, ECX
	MOVL	chk_unit.B[EBP], EAX
	JMP	2$.S			;Continue

;Here if name does not begin with XA

4$:	CLC
	RET

;Here if number not terminated by end of name

6$:	CMPB	AL, #'C'		;Is this a specific name?
	JNE	20$.S			;No - not an X.25 name
	CLRL	ECX			;Yes - now collect channel number
8$:	MOVB	AL, SS:[EDX]
	INCL	EDX
	CMPB	AL, #0
	JE	16$.S
	CMPB	AL, #'0'
	JB	20$.S
	CMPB	AL, #'9'
	JBE	10$.S
	CMPB	AL, #'A'
	JB	20$.S
	CMPB	AL, #'F'
	JA	20$.S
	ADDB	AL, #9
10$:	ANDL	EAX, #0Fh.B
	SHLL	ECX, #4t
	ADDL	ECX, EAX
	JMP	8$.S

;Here if have a generic X.25 device name

12$:	CALL	findunit		;Find the X.25 device
	JNE	20$.S			;If not found
	POPL	EAX			;Found it - create an X.25 DCB
	CALL	x25makedcb
	JC	14$.S			;If error
	MOVL	dcb_x25channel.B[EDI], #-1 ;OK - indicate no channel assigned
	CLRL	EAX
14$:	LEAVE
	RET

;Here with channel number

16$:	MOVL	chk_channel.B[EBP], ECX
	CALL	findunit		;Find the X.25 device
	JNE	20$.S			;If not found
	MOVL	EAX, chk_channel.B[EBP]	;Found the unit
	CMPL	EAX, pdb_x25maxchnl.B[EDI] ;Valid channel for unit?
	JA	22$.S			;No
	MOVL	EDI, pdb_x25chnltbl[EDI+EAX*4] ;Yes - is it connected?
	TESTL	EDI, EDI
	JE	18$.S			;No
	CMPB	dcb_x25state.B[EDI], #X25S_ESTAB
	JE	20$.S
18$:	TESTL	ESP, ESP
20$:	POPL	EAX
22$:	LEAVE
	CLC
	RET
.PAGE
	.SBTTL	sd_cleardcb - Clear DCB

;Here for the clear DCB entry

x25givedcb::
	CMPB	dcb_x25state.B[EDI], #X25S_IDLE ;Idle now?
	JNE	x25clear		;No - clear the call (the device fork
					;  code which handles call clearing
					;  will eventually give up the DCB)
	MOVL	ESI, dcb_netpdb.B[EDI]	;Yes
	CALL	x25givechnl#
	CALL	x25giveall#		;Make sure no buffers allocated
	JMP	xosnetGiveDcb##		;Just give up the DCB
.PAGE
findunit:
	MOVB	AL, chk_unit.B[EBP]	;Get unit number
	MOVL	EDI, x25pdbhead		;Get offset first TCP PDB
2$:	TESTL	EDI, EDI		;Have another?
	JE	4$.S			;No
	CMPB	pdb_unit.B[EDI], AL	;Yes - this one?
	JE	6$.S			;No
	MOVL	EDI, pdb_nextd.B[EDI]	;Yes - advance to next unit
	JMP	2$.S			;Continue

4$:	TESTL	ESP, ESP
6$:	RET
.PAGE
;Subroutine to create an X.25 DCB
;	c{SS:EBX} = Address of device name (16 characters)
;	c{EDI}    = Offset of PDB
;	CALL	x25makedcb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset of DCB

x25makedcb::
	PUSHL	ESI
	PUSHL	EDI			;Save offset of the PDB
	PUSHL	SS:12t.B[EBX]		;Device name
	PUSHL	SS:8t.B[EBX]
	PUSHL	SS:4t.B[EBX]
	PUSHL	SS:[EBX]
	MOVZBL	EAX, pdb_unit.B[EDI]	;Primary unit number
	PUSHL	EAX
	PUSHL	#0.B			;Secondary unit number
	PUSHL	#dcb_x25INDEX.B		;Size index
	PUSHL	#x25ccb			;Offset of CCB
	PUSHL	pdb_idb.B[EDI]		;Offset of IDB
	PUSHL	#DS$DUPLEX|DS$QOUT|DS$QIN ;Description bits
	CALL	xosnetMakeDcb##		;Get a network DCB
	POPL	EDX
	POPL	ESI
	JC	4$.S			;If error
	MOVL	dcb_netmode.B[EDI], #0	;Set default modes
	MOVL	dcb_devchar.B[EDI], #x25dctbl ;Use our device characteristics
	MOVL	dcb_sdisp.B[EDI], #x25dsp ;Store offset of SVC dispatch table
	MOVL	dcb_netpdb.B[EDI], EDX	;Store offset of the PDB in the DCB
	MOVL	EAX, pdb_sdb.B[EDX]	;Store offset of the SDB in the DCB
	MOVL	dcb_netsdb.B[EDI], EAX
	MOVB	AL, pdb_x25rcvwinsz.B[EDX] ;Initialize the X.25 parameters to
	MOVB	dcb_x25rcvwinsz.B[EDI], AL ;  their default values
	MOVB	dcb_x25rcvwinavl.B[EDI], AL
	MOVB	AL, pdb_x25rcvwinlvl.B[EDX]
	MOVB	dcb_x25rcvwinlvl.B[EDI], AL
	MOVL	EAX, pdb_x25rcvwindly.B[EDX]
	MOVL	dcb_x25rcvwindly.B[EDI], EAX
	MOVL	EAX, pdb_x25rcvpktmax.B[EDX]
	MOVL	dcb_x25rcvpktmax.B[EDI], EAX
	MOVB	AL, pdb_x25sndwinsz.B[EDX]
	MOVB	dcb_x25sndwinsz.B[EDI], AL
	MOVB	dcb_x25sndwinavl.B[EDI], AL
	MOVL	EAX, pdb_x25sndpktmax.B[EDX]
	MOVL	dcb_x25sndpktmax.B[EDI], EAX
4$:	RET
.PAGE
	.SBTTL	sd_devinfo - Get device information

;Here for the get device information entry
;	c{ECX}    = Length of user buffer
;	c{ES:EDI} = Address of user buffer
;	c{ESI}    = Offset of DCB
;	CALL	x25devinfo

$$$=!0
FRM info_left  , 4t
FRM info_amount, 4t
info_SIZE=!$$$

x25devinfo:
	ENTER	info_SIZE, 0
	MOVL	info_left.B[EBP], ECX
	CLRL	EAX
	MOVL	info_amount.B[EBP], EAX
	MOVZBL	EDX, dcb_x25state.B[ESI] ;Get X.25 state
	LEAL	EBX, infoname[EDX*4]	;Get offset of name string
	MOVL	ECX, #4			;Its 4 characters long
	CALL	knlInfoStr##		;Store the name

	CMPL	dcb_x25channel.B[ESI], #0.B ;Have a channel?
	JS	2$.S			;No
	MOVL	EBX, #chnllbl		;Yes - display it
	CLRL	ECX
	CALL	knlInfoStr##
	MOVL	EAX, dcb_x25channel.B[ESI]
	CALL	knlInfoHex##
2$:	LEAL	EBX, dcb_x25rmtaddr+1.B[ESI]
	MOVZBL	ECX, -1.B[EBX]
	JREGZ	ECX, 6$
	MOVB	AL, #' '
	CALL	knlInfoChr##
	MOVB	AL, #'R'
	CALL	knlInfoChr##
	MOVB	AL, #'='
	CALL	knlInfoChr##
4$:	MOVB	AL, [EBX]
	SHRB	AL, #4t
	ADDB	AL, #'0'
	CALL	knlInfoChr##
	DECL	ECX
	JE	6$.S
	MOVB	AL, [EBX]
	INCL	EBX
	ANDB	AL, #0Fh
	ADDB	AL, #'0'
	CALL	knlInfoChr##
	LOOP	ECX, 4$
6$:	LEAVE
	CLRL	EAX
	RET

	DATA

	.MOD	4
infoname:
	.ASCII	"IDLE"		;X25S_IDLE    = 0 - Idle
	.ASCII	"CALS"		;X25S_CALLSNT = 1 - Call request sent
	.ASCII	"ESTB"		;X25S_ESTAB   = 2 - Connection established
	.ASCII	"CLRS"		;X25S_CLRSNT  = 3 - Clear request sent

chnllbl:.ASCIZ	" C="

	CODE
.PAGE
	.SBTTL	sd_open - Open device

;Here for the open device entry
;	c{EDX} = Offset of name buffer
;	c{EDI} = Offset of DCB
;	CALL	x25open
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

OX=!O$REPEAT|O$REQFILE|O$ODF|O$FAILEX|O$CREATE|O$TRUNCA|O$TRUNCW|O$APPEND
OX=!OX|O$UNQNAME|O$CONTIG|O$FAPPEND

x25open:CALL	chknewcall
	TESTL	SS:xffCmd##, #OX	;Check for illegal bits
	JNE	knlIFnDev##
	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Physical or raw IO?
	JNE	24$.S			;Yes
	MOVB	SS:xffQueue##, #dcb_outframe ;No - set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	CMPL	dcb_x25channel.B[EDI], #-1.B ;Have a channel now?
	JNE	opendn.S		;Yes - go on
	CALL	x25connect		;No - establish the X.25 connection
	JC	22$.S			;If error
opendn:	CMPL	SS:xffParm##, #0.B	;Have a parameter list?
	JE	20$.S			;No
	MOVL	EBX, #x25opnparms	;Yes - process device parameters
	MOVL	ECX, #knlComDPParms##	;  (IGNORE ERRORS FOR NOW!)
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	TESTL	SS:xffPVFilOpt##, #FO$NODENAME|FO$NODENUM ;Want node number?
	JE	20$.S			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX ;Yes - want prefix code?
	JC	6$.S			;No
	MOVB	AL, #FS_NODENUM		;Yes
	CALL	knlGivUChr##
6$:

; CODE HERE TO STORE X.25 ADDRESS

	CALL	knlGivUColon##		;Put :: after the X.25 address
	CALL	knlGivUColon##
20$:	CLRL	EAX
22$:	RET

;Here for the devparm function or if physical or raw IO requested

x25devparm:
	CALL	chknewcall
24$:	ANDB	SS:xffCmd##, #~{O$IN|O$OUT} ;No IO allowed
	JMP	opendn			;Thats all

chknewcall:
	CMPB	dcb_x25state.B[EDI], #X25S_ESTAB
	JNE	22$.S
	CMPL	dcb_x25callwake.B[EDI], #0.B ;New connection timer active?
	JE	22$.S			;No
	MOVL	ESI, dcb_x25callwake.B[EDI] ;Yes - clear it
	CLRL	EAX
	MOVL	dcb_x25callwake.B[EDI], EAX
	JMP	knlWakeRemove##
.PAGE
	.SBTTL	x25ioplclport - Here for the IOPAR_NETLCLPORT parameter for open or transfer

;Here for the IOPAR_NETLCLPORT parameter - Set or get local port number for open
;  or transfer

	DPARMHDR  GET, DECV
x25plclport:
	MOVL	EAX, dcb_x25channel.B[EDI] ;Get value to return
	JMP	knlStrParm4##

	.SBTTL	x25ioprmtnetas - Here for the IOPAR_NETRMTNETAS parameter for open

;Here for the IOPAR_NETRMTNETAS parameter - Get remote network address for open

	DPARMHDR  BOTH, DECV
x25ioprmtnetas:
	TESTB	AH, #PAR$GET		;Want value returned?
	JE	ret010.S		;No
8$:

; CODE HERE TO GET X.25 ADDRESS

	CLRL	EAX
	JMP	knlStrParm4##

ret010:	RET

	.SBTTL	x25ioprmtnetar - Here for the IOPAR_NETRMTNETAR parameter

;Here for the IOPAR_NETRMTNETAR parameter - Get remote network address

	DPARMHDR  GET, DECV
x25ioprmtnetar:
	JMP	8$.S

	.SBTTL	x25ioplclneta - Here for the IOPAR_NETLCLNETA

;Here for the IOPAR_NETLCLNETA parameter - Get local network address

	DPARMHDR  GET, DECV
x25ioplclneta:
	CLRL	EAX			;DO THIS SOON!!!
	JMP	knlStrParm4##
.PAGE
	.SBTTL	x25connect - Subroutine to establish X.25 connection for open

;Subroutine to establish an X.25 connection for open - must be called in
;  extended fork context
;	c{EDX} = Offset of name buffer (on stack)
;	c{EDI} = Offset of DCB
;	CALL	x25connect
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX} = Offset of next part of name

;A network address may be specified after the device name.  The format is a
;  string of up to 16 decimal digits terminated by a double colon, for example:
;	XA5:12345678987654::

$$$=!0
FRM con_frame1 , 4
FRM con_frame2 , 4
FRM con_name   , 4	;Offset of name buffer
con_SIZE=!$$$

x25connect:
	PUSHL	EDX
	CALL	x25getchnl#		;Allocate an X.25 logical channel
	POPL	EDX
	JC	ret010.S		;If error
	ENTER	con_SIZE, 2
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%RMTNETAS ;Have an address parameter?
	JNC	2$.S			;No	
	MOVL	EBX, con_frame1.B[EBP]	;Yes - get its value

; CODE HERE TO GET X.25 ADDRESS SPECIFIED AS PARAMETER VALUE

	JMP	conhva			;Continue

;Here if address parameter (IOPAR_RMTNETAS) not specified

2$:	CALL	xosnetChkNetAddr##	;See if an address was specified
	JE	4$.S			;If address given
	MOVL	EBX, dcb_netpdb.B[EDI]	      ;No address give - use our
	MOVL	EAX, pdb_x25dftaddr+0.B[EBX] ;  default remote address
	MOVL	dcb_x25rmtaddr+0.B[EDI], EAX
	MOVL	EAX, pdb_x25dftaddr+4.B[EBX]
	MOVL	dcb_x25rmtaddr+4.B[EDI], EAX
	MOVL	EAX, pdb_x25dftaddr+8.B[EBX]
	MOVL	dcb_x25rmtaddr+8.B[EDI], EAX
	JMP	conhva			;Continue

;Here if a network address was given

4$:	MOVL	EBX, EDX
	PUSHL	SS
	POPL	ES
	LEAL	EDX, dcb_x25rmtaddr.B[EDI]
	CALL	storebcd		;Collect the address
	POPL	EBX
	JC	x25conf
conhva:	MOVL	con_name.B[EBP], EDX	;Save offset of name buffer
	MOVL	ECX, #20t		;Allocate a call request packet
	MOVZBL	ECX, dcb_x25rmtaddr+0.B[EDI]
	MOVL	ESI, dcb_netpdb.B[EDI]
	ADDB	CL, pdb_x25lcladdr+0.B[ESI]
	ADDL	ECX, #3.B
	SHRL	ECX, #1
	MOVB	AL, #X25P_CALLREQ
	CALL	x25getpkt#
	JC	x25conf			;If no buffer available
	PUSHL	EBX			;Save offset of packet buffer
	PUSHL	EDX			;And of start of the X.25 data
	LEAL	EBX, dcb_x25rmtaddr.B[EDI] ;Get offset of the remote address
	MOVB	AL, pdb_x25lcladdr+0.B[ESI] ;Store address lengths
	SHLB	AL, #4t
	MOVZBL	ECX, [EBX]
	INCL	EBX
	ORB	AL, CL
	MOVB	[EDX], AL
	MOVB	AH, CL
	INCL	ECX
	SHRL	ECX, #1
	JE	22$.S
20$:	MOVB	AL, [EBX]
	INCL	EBX
	INCL	EDX
	MOVB	[EDX], AL
	LOOP	ECX, 20$
22$:	MOVB	CL, pdb_x25lcladdr+0.B[ESI]
	INCL	ECX
	SHRL	ECX, #1t
	JE	28$.S
	LEAL	EBX, pdb_x25lcladdr+1.B[ESI]
	TESTB	AH, #01h		;Even number of digits in called addr?
	JNE	26$.S			;No - this is harder
24$:	MOVB	AL, [EBX]		;Yes - this is easy
	INCL	EBX
	INCL	EDX
	MOVB	[EDX], AL
	LOOP	ECX, 24$
	JMP	28$.S

;Here if had odd number of digits in the called address

26$:	MOVB	AL, [EBX]
	INCL	EBX
	MOVB	AH, AL
	SHRB	AH, #4t
	ORB	[EDX], AH
	INCL	EDX
	SHLB	AL, #4t
	MOVB	[EDX], AL
	LOOP	ECX, 26$
	TESTB	pdb_x25lcladdr+1.B[ESI], #01 ;Even number of bytes?
	JE	30$.S			;Yes
28$:	INCL	EDX			;No
30$:	INCL	pdb_x25cntpktout.B[ESI]	;Count the packet
	POPL	EAX			;Restore offset of start of X.25 data
	POPL	EBX			;And of packet buffer
	SUBL	EDX, EAX		;Get number of X.25 data bytes
	ADDL	npb_count.B[EBX], EDX
	ADDL	pdb_x25cntbyteout[ESI], EDX
	MOVB	dcb_x25rcvsnum[EDI], #0
	MOVB	dcb_x25sndsnum[EDI], #0
	MOVB	npb_seqnum+1.B[EBX], #0
	MOVB	dcb_x25state.B[EDI], #X25S_CALLSNT ;Set connection state
	MOVL	ESI, dcb_netsdb.B[EDI]
	CALL	xoslpaSendInfo##	;Send the packet
	JC	x25conf.S		;If error
x25con4:MOVL	EAX, #TIMEOUT_RESP	;Wait for the response
	CALL	xosnetRspWait##
	JNC	x25con6.S		;If normal
x25conf:MOVB	dcb_x25state.B[EDI], #X25S_IDLE ;Indicate idle
	MOVB	dcb_x25rmtaddr.B[EDI], #0
	CALL	x25giveall#		;Make sure don't have any buffers
	PUSHL	EAX
	CALL	x25givechnl#		;Remove DCB from the hash table
	POPL	EAX
	STC				;Indicate error
	LEAVE
	RET
.PAGE
;Here when get a reply to our CONREQ packet

x25con6:CALL	x25getinputpkt		;Get the CALLACP packet
	JC	4$.S			;If error

;;; CODE HERE TO HANDLE POSSIBLE FACILITIES

	CALL	xosnetGiveBufr##	;Give up the packet
	CLRL	EAX
4$:	LEAVE
	RET
.PAGE	
;Subroutine to get value of next network address field
;	c{EDX} = Offset of address string
;	CALL	getval
;	c(AL)  = Stopper character
;	c(BL)  = Value
;	c{EDX} = Offset of next character in address string

getval:	MOVB	AL, #0
2$:	MOVB	BL, SS:[EDX]		;Get character
	INCL	EDX			;Bump pointer
	CMPB	BL, #'0'		;Is it a digit?
	JB	4$.S			;No
	CMPB	BL, #'9'
	JA	4$.S
	ANDB	BL, #0Fh		;Yes - get value
	MULB	lit10			;And add into value for field
	ADDB	AL, BL
	JMP	2$.S

;Here if next character is not a digit

4$:	XCHGB	AL, BL			;Get things in right registers
	RET				;Return
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	x25close
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

x25close:
	CMPL	dcb_opencnt.B[EDI], #1.B ;Final close?
	JNE	2$.S			;No
	CMPL	dcb_x25channel.B[EDI], #-1.B ;Yes - do we have a connection?
	JNE	10$.S			;Yes
2$:	CMPL	iorb_parm.B[ESI], #0.B	;No - have any device parameters?
	JE	4$			;No
	MOVL	EBX, #x25ioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	8$
	LFSL	EDX, iorb_parm.B[ESI]
	CALL	knlProcDevParm##
	JC	6$.S
4$:	CLRL	EAX
6$:	TOFORK				;No
	JMP	knlCloseFin##

	FAULTHDR
8$:	MOVL	EAX, #ER_ADRER
	JMP	6$.S

;Here if final close

10$:	CALL	knlIoClsLock##		;Lock the QAB
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #x25close1
	JMP	knlXfQueue##		;Switch to extended fork context

	FAULTHDR
12$:	MOVL	EAX, #ER_ADRER
	JMP	16$.S

;Here in extended fork context

x25close1:
	MOVL	SS:xffTimeOut##, #XT_SECOND*30t
	CMPL	SS:xffParm##+0, #0.B
	JE	14$.S
	MOVL	EBX, #x25ioparms	;Process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	12$
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	16$.S
14$:	CLRL	EAX
16$:	PUSHL	EAX
	CALL	x25clear		;Terminate our connection
	JC	18$.S
	CMPB	dcb_x25state.B[EDI], #X25S_IDLE ;Is it cleared yet?
	JE	20$.S			;Yes
	MOVL	ESI, dcb_netpdb.B[EDI]	;No
	MOVL	EAX, #-1		;No time-out here (we count on the
					;  timer started in x25clear)
	CALL	xosnetRspWait##		;Wait for the call to be cleared
	JNC	20$.S
	CMPL	EAX, #ER_NCCLR
	JE	20$.S
18$:	MOVL	[ESI], EAX
20$:	POPL	EAX
	JMP	knlXfCloseFin##		;Go finish up
.PAGE
	.SBTTL	x25clear - Subroutine to clear an X.25 connection

;Subroutine to clear an X.25 connection.  This is an immediate clear.  It is
;  done by sending an X25P_CLRREQ packet.  This will discard any unreceived
;  data on either end.  May be called in extended fork context or at device
;  fork level.
;	c(AL)  = Diagnostic value
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IDB
;	CALL	x25clear
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

x25clear::
	REQUIREFORK
	MOVZBL	EDX, dcb_x25state.B[EDI] ;Get connection state
	JMPIL	CS:clrdsp[EDX*4]	;Dispatch on the state

	.MOD	4
clrdsp:	.LONG	knlRtnZero##	;X25S_IDLE    = 0 - Idle
	.LONG	clrestab	;X25S_CALLSNT = 1 - Call request sent
	.LONG	clrestab	;X25S_ESTAB   = 2 - Connection established
	.LONG	knlRtnZero##	;X25S_CLRSNT  = 3 - Clear request sent

;Here when clearing if the connection state is X25S_ESTAB

clrestab:
	PUSHL	EAX			;Save the clearing cause
	MOVL	ESI, dcb_netpdb.B[EDI]	;Get offset of the PDB
	CALL	x25giveall#		;Make sure no buffers allocated
	MOVB	dcb_x25state.B[EDI], #X25S_CLRSNT ;Update state
	MOVL	ECX, #2			;Make a clear request packet
	MOVB	AL, #X25P_CLRREQ
	CALL	x25getpkt#		;Send it
	POPL	ECX
	JC	clrerr.S		;If error
	MOVB	[EDX], #80h		;Store clearing cause
	MOVB	1.B[EDX], CL		;Store diagnostic value
	ADDL	npb_count.B[EBX], #2.B
	MOVL	ESI, dcb_netsdb.B[EDI]
	CALL	xoslpaSendInfo##	;Send the packet
	JC	clrerr.S		;If error
	MOVL	ESI, dcb_x25callwake.B[EDI]
	TESTL	ESI, ESI
	JE	4$.S
	CLRL	EAX
	MOVL	dcb_x25callwake.B[EDI], EAX
	CALL	knlWakeRemove##
4$:	MOVL	ESI, dcb_netpdb.B[EDI]
	MOVL	EAX, pdb_x25t23val.B[ESI] ;Start the clear timer
	MOVL	EBX, #clrcallto
	CALL	knlWakeRequest##
	JC	clrerr.S
	MOVL	dcb_x25callwake.B[EDI], ESI
	RET

;Here if error when clearing a call which prevents us from completing the
;  clearing.  This is a serious problem since it will leave the link in an
;  illegal state.  For this reason, we take the link down whenever this
;  happens!!

clrerr:
	CRASH	????

;Here with time-out when expecting a X25P_CLRCON packet

clrcallto:
	MOVB	dcb_x25state.B[EDI], #X25S_IDLE ;Update our state
	MOVB	dcb_x25rmtaddr.B[EDI], #0
	CMPL	dcb_opencnt.B[EDI], #0.B ;Is this device open?
	JE	6$.S			;No - just give up the DCB here
	CALL	x25givechnl#
	MOVL	EAX, #ER_NCCLR		;Wake up anyone who might be waiting
	CALL	xosnetAllDone##
	MOVL	ESI, dcb_netpdb.B[EDI]
	JMP	8$.S

6$:	PUSHL	dcb_netpdb.B[EDI]
	CALL	xosnetGiveDcb##		;Give up the DCB
	POPL	ESI
8$:	JMP	x25linkfail#		;Indicate link failure
.PAGE
	.SBTTL	x25lost - Subroutine to indicate that connection is lost

;Subroutine to indicate that an X.25 connection has been lost
;	c{EDI} = Offset of DCB
;	CALL	x25lost
;  c{EAX} is respected

x25lost::
	CRASH	????
.PAGE
	.SBTTL	sd_inpblock - Input block

;Here for the input block entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	x25inpblk
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

$$$=!0
FRM inp_amount , 4t
FRM inp_status , 4t
FRM            , 3t
FRM inp_more   , 1t
inp_SIZE=!$$$

x25inpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock all buffer pages
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_inpframe
	MOVL	iorb_routine.B[ESI], #x25inpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here if don't really want input

6$:	CLRL	EAX
8$:	LEAVE
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

;Here in extended fork context

x25inpblk1:
	ENTER	inp_SIZE, 0
	MOVL	inp_amount.B[EBP], #0
	MOVL	inp_status.B[EBP], #QSTS$DONE
	MOVL	SS:xffTimeOut##, #-1	;Default is no time-out
	CMPL	SS:xffParm##+0, #0.B	;Have any device parameters?
	JE	10$.S			;No
	MOVL	EBX, #x25ioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	8$.S
10$:	CMPL	SS:xffCount##, #0.B	;Really want input?
	JE	6$.S			;No
12$:	CALL	x25getinputpkt		;Yes - get an input packet
	JC	8$.S
	MOVB	AL, x25_type.B[EDX]	;Save the M bit
	MOVB	inp_more.B[EBP], AL
	MOVL	EAX, ECX
	CMPL	EAX, SS:xffCount##	;Bigger than his buffer?
	JBE	14$.S			;No
	ORB	inp_status.B[EBP], #QSTS$TRUNC ;Yes - indicate truncation
	MOVL	EAX, SS:xffCount##	;Only give him what fits in his buffer
14$:	CMPB	x25_type.B[EDX], #X25P_INT ;Interrupt packet?
	JNE	16$.S			;No
	ORB	inp_status.B[EBP], #QSTS$INTD ;Yes - tell him that
16$:	TESTB	[EDX], #80h		;Qualified data packet?
	JE	18$.S			;No
	ORB	inp_status.B[EBP], #QSTS$OOBD ;Yes - tell him that
18$:	TESTL	EAX, EAX		;Can we transfer anything at all?
	JE	22$.S			;No
	PUSHL	EDI			;Yes
	LESL	EDI, SS:xffBuffer1##	;Get address of his buffer
	ADDL	SS:xffBuffer1##, EAX
	ADDL	inp_amount.B[EBP], EAX
	LEAL	ESI, x25_data.B[EDX]
	CMPL	EAX, #4t.B
	JBE	20$.S
	CLRL	ECX
	SUBL	ECX, EDI
	ANDL	ECX, #03.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], [ESI]		;Copy his data from the packet (we do
	MOVL	ECX, EAX		;  as much as we can as a long-alligned
	SHRL	ECX, #2t		;  4-byte move)
	RMOVSL	[EDI], [ESI]
	ANDL	EAX, #03.B
20$:	MOVL	ECX, EAX
	RMOVSB	[EDI], [ESI]
	POPL	EDI
22$:	CALL	xosnetGiveBufr##	;Give up the packet
	CALL	x25openwindow#		;Open our receive window by 1 packet
	TESTB	inp_more.B[EBP], #10h	;Is this packet continued?
	JNE	12$.S			;Yes - get the next piece
	MOVL	ECX, inp_amount.B[EBP]	;No - get amount transfered
	MOVL	EBX, inp_status.B[EBP]	;Get status bits
	LEAVE
	CLRL	EAX			;Indicate OK
	RET				;Finished
.PAGE
	.SBTTL	sd_outstring - Output string

;Here for the output string entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	x25outstr
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

x25outstr:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoStringLock##	;Lock the string pages
	JNC	4$.S			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	sd_outblock - Output block

;Here for the output block entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	x25outblk
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

x25outblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock all buffer pages
	JC	2$.S			;If error
4$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #x25outblk1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

$$$=!0
FRM out_amount, 4t
out_SIZE=!$$$

x25outblk1:
	ENTER	out_SIZE, 0
	CLRL	EAX
	MOVL	out_amount.B[EBP], EAX
	DECL	EAX
	MOVL	SS:xffTimeOut##, EAX	;Default is no time-out
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	6$.S			;No
	MOVL	EBX, #x25ioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	10$.S
6$:	CMPL	SS:xffCount##, #0.B
	JE	18$			;If nothing to output
8$:	MOVL	EAX, SS:xffTimeOut##	;Get time-out value
	CALL	x25chkwin#		;Wait if packet level window is closed
	JC	10$.S			;If error
	CALL	xoslpaWaitWin##		;Wait if link level window is closed
10$:	JC	18$
	MOVL	ECX, SS:xffCount##	;Allocate a packet
	MOVB	AL, #0
	CALL	x25getpkt#
	JC	20$
	TESTB	SS:xffFunc##+1, #QFNC$OOBD>8t ;Should this be qualified data?
	JE	12$.S			;No
	ORB	-3.B[EDX], #80h		;Yes
12$:	MOVL	EAX, SS:xffCount##
	CMPL	dcb_x25sndpktmax.B[EDI], EAX ;Is this too much?
	JAE	14$.S			;No
	MOVL	EAX, dcb_x25sndpktmax.B[EDI] ;Yes - just send as much as we can
	ORB	-1.B[EDX], #10		;Set the M-bit
14$:	ADDL	npb_count.B[EBX], EAX
	SUBL	SS:xffCount##, EAX
	LFSL	ESI, SS:xffBuffer1##	;OK - get address of buffer
	ADDL	SS:xffBuffer1##, EAX
	PUSHL	EDI
	MOVL	EDI, EDX
	PUSHL	DS
	POPL	ES
	CMPL	EAX, #8t.B
	JBE	16$.S
	CLRL	ECX
	SUBL	ECX, EDI
	ANDL	ECX, #03.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], FS:[ESI]		;Copy his data to the packet (we do as
	MOVL	ECX, EAX		;  much as we can as a long-alligned
	SHRL	ECX, #2t		;  4-byte move)
	RMOVSL	[EDI], FS:[ESI]
	ANDL	EAX, #03h.B
16$:	MOVL	ECX, EAX
	RMOVSB	[EDI], FS:[ESI]
	POPL	EDI
	CALL	x25senddata#
	JC	18$.S
	CMPL	SS:xffCount##, #0.B	;More to output?
	JNE	8$			;Yes - continue
	CLRL	EAX			;No - finished
18$:	MOVL	ECX, out_amount.B[EBP]
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

20$:	CALL	xoslpaGiveWin##
	JMP	18$.S
.PAGE
	.SBTTL	x25getinputpkt - Subroutine to get next input packet

;Subroutine to get next input packet
;	c{EDI} = Offset of DCB
;	CALL	x25getinputpkt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EBX} = Offset of packet buffer
;	  c{ECX} = Length of data part (does not include the X.25 header)
;	  c{EDX} = Offset of start of X.25 header

x25getinputpkt:
	CMPB	dcb_x25state.B[EDI], #X25S_ESTAB ;Yes - still have a connection?
	JNE	10$.S			;No
2$:	MOVL	EBX, dcb_x25rcvhead.B[EDI] ;Yes - get a received packet
	TESTL	EBX, EBX		;Do we have one?
	JNE	4$.S			;Yes - go on
	MOVL	EAX, SS:xffTimeOut##	;No - wait until we do
	CALL	xosnetRspWait#
	JNC	x25getinputpkt.S	;Check again if OK
	RET				;Give up if error while waiting

;Here with a packet

4$:	MOVL	EAX, npb_next.B[EBX]	;Remove packet from the receive list
	MOVL	dcb_x25rcvhead.B[EDI], EAX
	TESTL	EAX, EAX
	JNE	6$.S
	MOVL	dcb_x25rcvtail.B[EDI], EAX
6$:	MOVZBL	EDX, npb_tpofs.B[EBX]	;Get offset of the X.25 header
	ADDL	EDX, EBX
	MOVL	ECX, npb_count.B[EBX]	;Get size of the packet
	RET

;Here if we have lost our connection

10$:	MOVL	EAX, #ER_NCCLR
	TESTB	dcb_x25sts1.B[EDI], #X25S1$LOST
	JE	12$.S
	MOVB	AL, #ER_NCLST&0FFh
12$:	STC
	RET
.PAGE
	.SBTTL	storebcd - Subroutine to collect BCD value

;Subroutine to collect BCD value
;	c{ES:EBX} = Address of string
;	c{EDX}    = Offset of buffer to receive value
;	CALL	storebcd
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = normal

storebcd:
	MOVB	AH, #0
	MOVL	ECX, #22t
	PUSHL	EDX
	INCL	EDX
8$:	MOVB	AL, ES:[EBX]
	INCL	EBX
	CMPB	AL, #0
	JE	18$.S
	CMPB	AL, #':'
	JE	16$.S
	CMPB	AL, #'0'
	JB	14$.S
	CMPB	AL, #'9'
	JA	14$.S
	TESTB	AH, #01h
	JNE	10$.S
	SHLB	AL, #4t
	MOVB	[EDX], AL
	JMP	12$.S

10$:	ANDB	AL, #0Fh
	ORB	[EDX], AL
	INCL	EDX
12$:	INCB	AH
	LOOP	ECX, 8$
14$:	POPL	EDX
	MOVL	EAX, #ER_NILAD
	STC
	RET

;Here at end of network address

16$:	ADDL	EBX, #2.B
18$:	NEGL	ECX
	ADDL	ECX, #22t.B
	POPL	EDX
	MOVB	[EDX], CL
	CLC
	RET
.PAGE
	DATA

x25ccb::   .BLKB ccb_SIZE	;X25A CCB
x25pdbhead:.LONG 0		;Offset of first X25A device TPDB
x25addr:   .BLKB 28t		;Buffer for building X.25 address
temp:	   .BLKB 12t		;Buffer for destination message names
lit10:     .LONG 10t
litXT_SEC: .LONG XT_SECOND
litTICKSPERSEC:
	   .LONG TICKSPERSEC
litMSPERTICK:
	   .LONG MSPERTICK
	END
