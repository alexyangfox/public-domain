	.TITLE	XFPCLS - XFP routines for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXIPS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXRCP.PAR
	.INCLUD	XOSINC:\XMAC\XOSXXFP.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!2t
MINV   =!0t
EDITNUM=!0t

	LKEHEAD	XFPCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

FOBITS=!FO$NODENUM|FO$NODENAME|FO$RXOSNAME|FO$RDOSNAME|FO$RVOLNAME
FOBITS=!FOBITS|FO$PATHNAME|FO$PATHDOS|FO$FILENAME|FO$FILEDOS|FO$ATTR|FO$VERSION

$$$=0
FRM opx_frame1  , 4t
FRM opx_frame2  , 4t
FRM opx_rsppkt  , 4t		;Offset of response packet buffer
FRM opx_rspsize , 4t		;Response size
FRM opx_newname , 4t		;Offset of new name string for rename
FRM opx_newnsize, 4t		;Size of new name string for rename
FRM opx_datasize, 4t		;Size of data or name
FRM opx_parmsize, 4t		;Size of parameter list

FRM opx_reqpkt  , 4t		;Offset of request packet buffer
FRM opx_reqtype , 1t		;Request type
FRM opx_rsptype , 1t		;Response type
FRM opx_header2 , 1t		;Second header byte from response packet
FRM opx_headerf , 1t		;Function value from response packet header
FRM opx_error   , 4t		;Error code
FRM opx_parmerr1, 4t		;Parameter error bits
FRM opx_parmerr2, 4t
FRM opx_devsts  , 4t
FRM opx_unitnum , 4t
FRM opx_filattr , 4t
FRM opx_glbid   , 16t
FRM opx_amount  , 4t
FRM opx_parm    , 4t
opx_SIZE=!$$$-8

	CODE

	.SBTTL	SVC dispatch table for XFP devices

;SVC dispatch table for XFP devices

xfpdsp:	.LONG	knlRtnZero##	;sd_mount	=  0. - Mount
	.LONG	knlRtnZero##	;sd_cleardev	=  4. - Clear device
	.LONG	xosrcpGiveDcb##	;sd_cleardcb	=  8. - Clear DCB
	.LONG	knlRtnZero##	;sd_commit	= 12. - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold    = 16. - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew    = 20. - Transfer device/new
	.LONG	knlNullQio##	;sd_opena	= 24. - Open additional
	.LONG	xfpopen		;sd_open1	= 28. - Open device/file
	.LONG	xfpdevparm	;sd_devparm     = 32. - Device parameters
	.LONG	xfpdelete	;sd_delete	= 36. - Delete file
	.LONG	xfprename	;sd_rename	= 40. - Rename file
	.LONG	xfpinpblk	;sd_inblock	= 44. - Input block
	.LONG	xfpoutblk	;sd_outblock	= 48. - Output block
	.LONG	xfpoutblk1	;sd_outblockq	= 52. - Output block (XFF)
	.LONG	xfpoutstr	;sd_outstring	= 56. - Output string
	.LONG	knlRtnMOne##	;sd_getiosts	= 60. - Get input/output status
	.LONG	knlIFnDevGQ##	;sd_special     = 64. - Special device function
	.LONG	xfpclose	;sd_close	= 68. - Close file
	.LONG	knlNullLabel##	;sd_label       = 72. - Get device label
	.LONG	xfpcommit	;sd_commitfunc	= 76. - Commit data to disk
	.LONG	knlInfoNone##	;sd_devinfo     = 80. - Get device info
XFPDSPSZ=!{$-xfpdsp}/4

;Class function dispatch table for XFP class devices

	.LONG	XFPCLSFMX
xfpcls::.LONG	xfpaddunit	;CF_ADDUNIT = 1. - Add unit
	.LONG	xfpunitinfo	;CF_PUNITS  = 2. - Get information about
				;		     physical units
	.LONG	knlIFnDev##	;CF_AUNITS  = 3. - Get information about active
				;		     units
XFPCLSFMX=!{$-xfpcls}/4
.PAGE
;Device characteristics tables for the XFP devices

	DATA

	.MOD	4
xfpdctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS  , TEXT, , 8, knlDcMsgClass##  , knlDcGetClass##    , knlDcSetClass##    , 0
 DCHARENT  RCPDEV , TEXT, ,16, xosrcpMsgRcpDev##, xosrcpGetRcpDev##  , 0                  , 0
 DCHARENT  RETRY1 , DECV, , 1, xosipsMsgRetry1##, xosipsGetDpdbByte##, xosipsSetDpdbByte##, dpdb_rcpxfpretry1
 DCHARENT  RETRY2 , DECV, , 1, xosipsMsgRetry2##, xosipsGetDpdbByte##, xosipsSetDpdbByte##, dpdb_rcpxfpretry2
 DCHARENT  RMTPORT, DECV, , 4, msgrmtport       , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rmtport
 DCHARENT  PKTIN  , DECV, , 4, msgmsgin         , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rcpxfpcntpktin
 DCHARENT  BYTEIN , DECV, , 4, knlDcMsgByteIn## , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rcpxfpcntbytein
 DCHARENT  PKTOUT , DECV, , 4, msgmsgout        , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rcpxfpcntpktout
 DCHARENT  BYTEOUT, DECV, , 4, knlDcMsgByteOut##, xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rcpxfpcntbyteout
 DCHARENT  PROERR , DECV, , 4, msgproerr        , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rcpxfpcntproerr

	CODE

msgrmtport:DCHARINFO  {Remote (server) port}
msgmsgin:  DCHARINFO  {Number of messages input}
msgmsgout: DCHARINFO  {Number of messages output}
msgproerr: DCHARINFO  {Protocol errors}
.PAGE
	.SBTTL	xfpinit - Initialization routine for XFP class devices

	INITSUB	xfpinit

;The command for installing XFPCLS is:
;	LKELOAD XFPCLS

xfpinit:MOVL	EDI, #xfpchk		;Install the XFP class
	MOVL	EBX, #xfpcls		;Offset of class function dispatch table
	CLRL	ECX
	MOVL	EAX, #'XFP'
	CLRL	EDX
	MOVL	ESI, #xfpccb
	CALL	knlNewClass##
	JC	10$.S
	MOVL	ECX, #codetop
	CLRL	EDX
	CLRL	EAX
10$:	MOVL	EBX, #QSTS$DONE
	RET

	CODE
.PAGE
	.SBTTL	xfpaddunit - Subroutine to add XFP "unit"

;Subroutine to add XFP "unit" - this is a logical unit which implements the
;  XFP application level protocol for a single transport level (RCP) unit
;  - multiple XPF units may be set up for different RCP units if desired
;	c{ES:EDI} = Address of data block
;	CALL	xfpaddunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count

$$$=!0
FRM xfpau_tpdb, 4t	;RCP device name
FRM xfpau_unit, 4t	;Unit number
FRM xfpau_pdb , 4t	;Offset of PDB
xfpau_SIZE=!$$$

	DATA

	.MOD	4
xfpaublk:				;Parameter description block for
 DCHARBGN  2, knlDCharValCom##		;  adduparms
 DCHARENT  UNIT  , DECV, , 1, knlDcMsgUnit##, 0, xfpauunit  , 0
 DCHARENT  RCPDEV, TEXT, ,16, 0             , 0, xfpaurcpdev, 0

	CODE

xfpaddunit:
	ENTER	xfpau_SIZE, 0		;Allocate our stack frame
	CLRL	EAX
	MOVL	xfpau_tpdb.B[EBP], EAX	;Store illegal values for RCP TPDB
	DECL	EAX			;  and unit number
	MOVL	xfpau_unit.B[EBP], EAX
	IFFAULT	4$
	LFSL	EDX, iorb_buffer2.B[ESI]
	CALL	knlGiveQel##		;Give up the IORB
	MOVL	EBX, #xfpaublk		;Process the characteristics
	MOVB	AL, #0			;Fail on bad names
	CALL	knlAddUnitChar##
	JC	2$.S			;If error
	MOVL	EAX, xfpau_tpdb.B[EBP]	;Make sure RCP device and unit number
	DECL	EAX
	ORL	EAX, xfpau_unit.B[EBP]	;  are specified
	INCL	EAX
	JNE	6$.S
	MOVL	EAX, #ER_CHARM
2$:	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	LEAVE
	TOFORK
	RET
		
;Here if address error with the IORB

4$:	CALL	knlGiveQel##
	MOVL	EAX, #ER_ADRER
	JMP	2$.S

;Here if have all required characteristics

6$:	PUSHL	xfpau_unit.B[EBP]	;Stack unit number
	PUSHL	#dpdb_rcpxfpSIZE	;Stack DPDB size
	PUSHL	#'XFP'			;Stack base name
	PUSHL	#dcb_xfpINDEX.B		;Stack size index for DCB
	PUSHL	#xfpccb			;Stack offset of the XFP CCB
	PUSHL	xfpau_tpdb.B[EBP]	;Stack offset of first RCP TPDB
	PUSHL	#xfpdpdbhead		;Stack offset of XFP DPDB head pointer
	CALL	xosipsMakeDev##		;Create new network device
	JC	2$.S			;If error
	CALL	knlGiveXRes##		;Give up the exec memory resource
	MOVB	CL, dpdb_unit.B[EDI]	;Get unit number
10$:	MOVL	dpdb_rmtport.B[EDI], #UDPP_XFP ;Store default remote port
	MOVB	dpdb_rcpxfpretry1.B[EDI], #RETRY_TRN1 ;Initialize default retry
	MOVB	dpdb_rcpxfpretry2.B[EDI], #RETRY_TRN2 ;  levels
	MOVL	EDI, dpdb_nextd.B[EDI]
	TESTL	EDI, EDI
	JE	12$.S
	CMPB	CL, dpdb_unit.B[EDI]
	JE	10$.S
12$:	CLRL	EAX
	JMP	2$.S
.PAGE
;Subroutine called by adduparms for the "UNIT" parameter

xfpauunit:
	CMPL	EAX, #99t.B		;Valid value?
	JA	knlBadCharV##
	MOVL	xfpau_unit.B[EBP], EAX
	CLC
	RET

;Subroutine called by adduparms for the "RCPDEV" parameter

xfpaurcpdev:
	MOVL	EAX, xfpau_tpdb.B[EBP]	;Get current RCP TPDB offset
	CALL	xosrcpAuRcpDev##	;Get RCP TPDB offset
	JC	2$.S			;If error
	MOVL	xfpau_tpdb.B[EBP], EDI	;OK - store RCP TPDB offset
2$:	RET
.PAGE
	.SBTTL	xfpunitinfo - XFP class get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  XFP class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	xfpunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

xfpunitinfo:
	CRASH	NIYT
.PAGE
	.SBTTL	xfpchk - Device check routine for XFP class devices

;Device check routine for XFP class devices
;	c{SS:EBX} = Address of device name (16 characters)
;	CALL	xfpchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  EBX and ESI are preserved

xfpchk:	MOVL	EAX, SS:[EBX]
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'XFP'		;Is this XFP*?
	JNE	4$.S			;No
	MOVL	EDI, xfpdpdbhead	;Yes - get offset of first XFP DPDB
	LEAL	ECX, 3.B[EBX]		;Get offset of 1st unit number character
	MOVL	EDX, #DS$SODIR|DS$FILE
	CALL	xosipsFindDev##		;Find matching network device
	JC	6$.S			;If error
	JNE	6$.S			;Or if not a match
	MOVL	dcb_sdisp.B[EDI], #xfpdsp ;Store offset of SVC dispatch table
	MOVL	EAX, dcb_ipsdpdb.B[EDI]
	MOVW	AX, dpdb_rcpxfpretry1.B[EAX] ;Store default retransmission
	MOVW	dcb_rcpretry1.B[EDI], AX     ;  threshold values
	MOVL	dcb_netmode.B[EDI], #0	;Set default modes
	MOVL	dcb_devchar.B[EDI], #xfpdctbl ;Use our device characteristics
	MOVB	dcb_ipsprot.B[EDI], #IPP_UDP ;Store protocol value
	CALL	xosrcpDfltPort##	;Assign default port number
	JC	10$.S
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Store remote port number
	MOVL	EAX, dpdb_rmtport.B[EAX]
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport.B[EDI], AX
	JMP	xosrcpChkFin##

;Here if not an XFP device

4$:	CLC
6$:	RET

;Here if can't allocate default port number

10$:	PUSHL	EAX
	CALL	xosnetGiveDcb##
	POPL	EAX
	STC
	RET
.PAGE
	.SBTTL	sd_devparm - Device parameter function

;Here for the device parameter function entry
;	c{SS:EDX} = Offset of name buffer
;	c{EDI}    = Offset of DCB
;	CALL	xfpdevparm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpdevparm:
	MOVB	AL, #XFPF_PARM
	JMP	4$.S

2$:	ANDB	SS:xffCmd##, #~{O$IN|O$OUT} ;No IO allowed
	MOVL	ECX, #1
	CLRL	EAX
	RET

	.SBTTL	sd_open - Open device

;Here for the open device entry
;	c{SS:EDX} = Offset of name buffer
;	c{EDI}    = Offset of DCB
;	CALL	xfpopen
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpopen:MOVB	AL, #XFPF_OPEN
4$:	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Raw or physical IO?
	JE	open2.S			;No
	CMPB	SS:[EDX], #0		;Yes - have any file spec?
	JE	2$.S			;No - make this a local open
open2:	MOVB	SS:xffQueue##, #dcb_outframe ;Yes - set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	ENTER	opx_SIZE, 2
	MOVB	opx_reqtype.B[EBP], AL
	MOVL	opx_newname.B[EBP], ESI	;Store offset of new name in case rename
	CLRL	EAX
	MOVL	SS:xffCount##, EAX
	MOVL	opx_newnsize.B[EBP], EAX
	MOVW	dcb_outframe.B[EDI], SS	;Set up an output queue
	MOVB	SS:xffQueue##, #dcb_outframe
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%LCLPORT ;Local port number specified?
	JNC	6$.S			;No
	MOVL	ECX, opx_frame1.B[EBP]	;Yes
	MOVL	ECX, SS:opn_lclport[ECX] ;Use it
	PUSHL	EDX
	CALL	xosrcpGetPort##
	POPL	EDX
	JC	16$.S			;If error setting the local port number
6$:	BTL	SS:xffHvValue1##, #IOV1%RMTPORTS ;Remote port number specified?
	JNC	8$.S			;No
	MOVL	EAX, opn_rmtports[EBP]	;Yes - use it
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport.B[EDI], AX
8$:	CLRL	ECX
	MOVB	dcb_xfpsts1[EDI], CL	;Clear our network status byte
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Want to search open directory?
	JNC	18$.S			;No
	CALL	xosnetChkNetAddr##	;Yes - skip possible network address
	JNE	14$.S
	LEAL	EDX, 1.B[ECX]
14$:	CMPB	opx_reqtype.B[EBP], #XFPF_OPEN ;Is this an open?
	JNE	havercp.S		;No - this is OK
	MOVL	EAX, #ER_IFDEV		;CAN'T HANDLE THIS YET!!!!
16$:	CLRL	ECX
	LEAVE
	STC
	RET

;Here to establish an RCP connection

18$:	MOVL	EAX, #5t		;Get window size
	MOVL	ECX, #60t		;Get keep-alive time
	CALL	xosrcpConnect##		;Establish the RCP connection
	JC	16$.S			;If error
					;OK - fall into havercp on next page
.PAGE
;Here when we have an RCP connection - any errors after this point MUST clear
;  this connection before returning (except that we abandon the connection
;  if have a serious protocol error)!

havercp:CALL	checkspec
	MOVL	opx_datasize.B[EBP], ECX
	PUSHL	EDX
	CMPB	opx_reqtype.B[EBP], #XFPF_RENAME ;Is this a rename?
	JNE	2$.S			;No
	MOVL	EDX, opx_newname.B[EBP]	;Yes - get length of new name
	CALL	checkspec
	MOVL	opx_newnsize.B[EBP], ECX
2$:	CALL	checkparm
	MOVL	EAX, opx_datasize.B[EBP] ;Get total length for message
	ADDL	ECX, EAX
	CALL	getvalsize
	CMPB	opx_reqtype.B[EBP], #XFPF_RENAME ;Is this a rename?
	JNE	4$.S			;No
	MOVL	EAX, opx_newnsize.B[EBP]
	ADDL	ECX, EAX
	CALL	getvalsize
4$:	ADDL	ECX, #6.B
	CALL	xfpgetpkt		;Get packet for the open command
	POPL	EDX
	JC	opener			;If error
	PUSHL	EDX
	MOVB	AL, opx_reqtype.B[EBP]	;Construct header
	MOVB	AH, #11h
	MOVW	[EBX], AX
	MOVL	EAX, SS:xffCmd##	;Store device command bits
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	2t.B[EBX], EAX
	ADDL	EBX, #6t.B
	POPL	EDX
	MOVL	EAX, opx_datasize.B[EBP]
	CALL	storespec		;Store file specification in packet
	CMPB	opx_reqtype.B[EBP], #XFPF_RENAME ;Is this a rename?
	JNE	6$.S			;No
	MOVL	EDX, opx_newname.B[EBP]	;Yes
	MOVL	EAX, opx_newnsize.B[EBP]
	CALL	storespec
6$:	CMPL	opx_parmsize.B[EBP], #0.B
	JE	8$.S
	CALL	storeparm		;Store parameters in the packet
8$:	CALL	xfpsendpkt		;Send the packet
	JC	opener.S		;If error
	CALL	opendn
	LEAVE
	RET
.PAGE
;Here with file open request message sent

opendn:	MOVB	AH, #XFPF_RESPONSE
	CALL	xfprcvrsp		;Get the response
	MOVL	SS:xffCount##, ECX	;Save the item count
	JC	8$.S			;If local error
	TESTL	EAX, EAX
	JE	12$.S			;If no server reported error
	JNS	openft.S		;If positive (fatal error)
opener:	CMPB	dcb_xfpfcnt[EDI], #0	;Have any other files open on the
					;  connection?
	JNE	10$.S			;Yes
8$:	PUSHL	EAX			;No - save error code
	CALL	xosrcpClear##		;Clear the RCP connection
	POPL	EAX
10$:	BTL	EAX, #31t		;Set C if error
	JMP	14$.S

;Here if no errors on the open

12$:	CMPB	SS:xffFunc##, #QFNC_OPEN ;Really an open?
	JNE	opener.S		;No - close the connection if need to
	INCB	dcb_xfpfcnt[EDI]	;Yes - count the open file
	BTL	SS:xffCmd##, #O%ODF	;Is this a open as a directory?
	JNC	14$.S			;No
	ORB	dcb_sts2.B[EDI], #D2$DIRECT ;Yes - indicate this
14$:	MOVL	ECX, SS:xffCount##	;Get item count
	RET				;All done

openft:	CALL	proterr			;Positive - fatal error!
	JMP	8$.S
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	xfpclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

xfpclose:
	CALL	knlIoClsLock##		;Lock the QAB
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfpclose1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

xfpclose1:
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	CMPL	dcb_opencnt.B[EDI], #1.B ;Final close?
	JNE	2$.S			;No
	TESTB	dcb_rcpsts1.B[EDI], #RCPS1$FATAL ;Is the XFP level still alive?
	JNE	2$.S			;No
	CMPB	dcb_rcpstate.B[EDI], #RCPS_ESTAB ;Yes - is the connection open?
	JE	10$.S			;Yes

;Here if not final close or if the RCP connection is already closed

2$:	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	4$.S			;No
	MOVL	EBX, #ioparms		;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	8$
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	6$.S
4$:	CLRL	EAX
6$:	JMP	knlXfCloseFin##

	FAULTHDR
8$:	MOVL	EAX, #ER_ADRER
	JMP	6$.S

;Here if final close and the RCP connection is still open

10$:	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	18$.S			;If error
	ENTER	opx_SIZE, 2
	CALL	checkparm		;See how much space for parameters
	ADDL	ECX, #6.B
	CALL	xfpgetpkt		;Get packet for the close message
	JC	16$.S			;If error
	MOVW	[EBX], #XFPF_CLOSE+1100h
	MOVL	EAX, SS:xffOption##	;Get the close command bits
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	2t.B[EBX], EAX
	ADDL	EBX, #6t.B
	CMPL	opx_parmsize.B[EBP], #0.B
	JE	12$.S
	CALL	storeparm		;Store possible parameters
12$:	CALL	xfpsendpkt		;Send the close message
	JC	16$.S			;If error
	DECB	dcb_xfpfcnt[EDI]	;Reduce the open file count
	CALL	opendn			;Get response and clear the connection
	LEAVE
	LEAVE
14$:	JMP	knlXfCloseFin##

;Here if error

16$:	LEAVE
18$:	LEAVE
	PUSHL	EAX
	CALL	xosrcpClear##		;Clear the RCP connection
	POPL	EAX
	JMP	14$.S
.PAGE
;Here for the sd_commitfunc entry - commit data to disk
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	xfpcommit
;	c{EAX} = Error code
;	c{ECX} = Item count
;	c{EBX} = Status bits

xfpcommit:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoParmLock##		;Lock the parameter list
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfpcommit1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
ret006:	RET

;Here in extended fork context

xfpcommit1:
	MOVL	EAX, dcb_rcpaptime[EDI]
	MOVL	SS:xffTimeOut##, EAX
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	14$.S			;If error
	ENTER	opx_SIZE, 2
	CALL	checkparmio		;Calculate space needed for parameters
	ADDL	ECX, #2.B
	MOVL	EAX, SS:xffTimeOut##
	CALL	xfpgetpkt		;Get packet for the command
	JC	14$.S			;If error
	MOVW	[EBX], #XFPF_COMMIT+1100h ;Store the message header
	ADDL	EBX, #2t.B
	CMPL	opx_parmsize.B[EBP], #0.B
	JE	4$.S
	CALL	storeparm		;Store parameters
4$:	CALL	xfpsendpkt		;Send the command
	JC	14$.S			;If error
10$:	MOVB	AH, #XFPF_RESPONSE
	CALL	xfprcvrsp		;Get the response
12$:	LEAVE
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

14$:	CLRL	ECX
	JMP	12$.S
.PAGE
;Here for the sd_inpblock entry - input block
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	xfpinpblock
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpinpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock the buffer pages
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_inpframe
	MOVL	iorb_routine.B[ESI], #xfpinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here in extended fork context

xfpinpblk1:
	MOVL	EAX, dcb_rcpaptime[EDI]
	MOVL	SS:xffTimeOut##, EAX
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	6$.S			;If error
	ENTER	opx_SIZE, 2
	CALL	checkparmio		;Calculate space needed for parameters
	CMPL	SS:xffCount##, #0.B	;Really doing IO?
	JNE	10$.S			;Yes
	TESTL	ECX, ECX		;No - have any parameters?
	JNE	12$.S			;Yes
	CLRL	EAX			;No - nothing to do here
	LEAVE
6$:	LEAVE
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

8$:	LEAVE
	JMP	knlIllInpLv##

;Here if really doing input

10$:	TESTB	SS:xffCmd##, #O$IN	;Is input allowed?
	JE	8$.S			;No - fail
12$:	CLRL	EAX			;Yes
	MOVL	opx_amount.B[EBP], EAX
	ADDL	ECX, #2.B
	MOVL	EAX, SS:xffCount##
	CALL	getvalsize
	CALL	xfpgetpkt		;Get packet for the data request
	JC	16$.S			;If error
	MOVW	[EBX], #XFPF_DATAREQ+0100h ;Store the message header
	ADDL	EBX, #2t.B
	MOVL	EAX, SS:xffCount##	;Store amount wanted
	CALL	putvalue
	CMPL	opx_parmsize.B[EBP], #0.B
	JE	14$.S
	CALL	storeparm		;Store parameters
	CLRL	EAX
	MOVL	opx_parmsize.B[EBP], EAX
14$:	CALL	xfpsendpkt		;Send the data request
16$:	JC	30$			;If error
18$:	MOVB	AH, #XFPF_DATARESP
	CALL	xfprcvrsp
	JC	26$.S
	JNE	34$			;Serious protocol error if not data!
	MOVL	opx_error.B[EBP], EAX
	MOVL	EAX, ECX
	TESTL	EAX, EAX
	JE	24$.S
	SUBL	SS:xffCount##, EAX	;Bigger than we wanted?
	JC	34$			;Yes - serious error!
	SUBL	opx_rspsize.B[EBP], EAX
	ADDL	opx_amount.B[EBP], EAX
	PUSHL	EDI
	LESL	EDI, SS:xffBuffer1##
	ADDL	SS:xffBuffer1##, EAX
	MOVL	ESI, EBX
	CLD
	CMPL	EAX, #4.B
	JBE	22$.S
	CLRL	ECX
	SUBL	ECX, EDI
	ANDL	ECX, #03h.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], [ESI]
	MOVL	ECX, EAX
	SHRL	ECX, #2t
	RMOVSL	[EDI], [ESI]
	ANDL	EAX, #03h.B
22$:	MOVL	ECX, EAX
	RMOVSB	[EDI], [ESI]
	POPL	EDI
	MOVL	EBX, ESI
24$:	CMPL	opx_rspsize.B[EBP], #0.B ;Have any parameters?
	JE	28$.S			;No
	CALL	xfpparms		;Yes - process them
26$:	JC	30$.S
28$:	MOVL	EBX, opx_rsppkt.B[EBP]
	CALL	xosnetGiveBufr##
	CLRL	EAX
	MOVL	opx_rsppkt.B[EBP], EAX
	INCL	dcb_rcprcvwina.B[EDI]	;Open our receive window
	CALL	xosrcpOpenWindow##	;Report the window if we need to now
	TESTB	opx_header2.B[EBP], #90h ;Final part?
	JE	18$			;No - continue
	MOVL	EAX, opx_error.B[EBP]	;Yes
30$:	MOVL	ECX, opx_amount.B[EBP]
32$:	LEAVE
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

;Here if have fatal protocol error

34$:	MOVL	EAX, #ER_NPERR
	CLRL	ECX
	JMP	32$.S
.PAGE
	.SBTTL	xfpoutstr - Queued output null terminated string

;Here for the sd_outstring entry - output null terminated string
;	c{EDI}    = Offset of DCB
;	c{FS:EDX} = Address of QAB
;	CALL	xfpoutstr
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpoutstr:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoStringLock##	;Lock the string pages
	JNC	4$.S			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	xfpoutblk - Queued output block

;Here for the sd_outblock entry - output block
;	c{ESI} = Offset of QAB
;	c{EDI} = Offset of DCB
;	CALL	xfpoutblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpoutblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock the buffer pages
	JC	2$.S			;If error
4$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfpoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context

6$:	CLRL	ECX			;Report nothing received
8$:	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET				;And return

;Here in extended fork context

xfpoutblk1:
	MOVL	EAX, dcb_rcpaptime[EDI]
	MOVL	SS:xffTimeOut##, EAX
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	6$.S			;If error
	ENTER	opx_SIZE, 2		;Set up our stack frame
	CALL	checkparmio		;See how much space is needed for
					;  parameters
12$:	CMPL	dcb_rcpsndwina[EDI], #0.B ;Is the window open now?
	JE	14$.S			;No
	CALL	knlXffAllow##		;Yes
	JMP	16$.S

14$:	MOVL	EAX, SS:xffTimeOut##
	CALL	xosrcpChkWin##		;Wait if window not open
	JC	24$.S			;If error
16$:	CMPL	dcb_rcprcvhead.B[EDI], #0 ;Have an input packet now?
	JE	18$.S			;No - go on
	MOVB	AH, #XFPF_RESPONSE	;Yes - get it
	CALL	xfprcvrsp
	LEAVE
	JC	6$.S
	TESTL	EAX, EAX		;Error reported?
	JS	8$.S			;Yes - return the error
	MOVL	EAX, #ER_NPERR
	JMP	6$.S

;Here if no input available (normal case)

18$:	MOVL	ECX, SS:xffCount##	;Get amount wanted
	CMPL	ECX, #XFPMXSIZE		;Too much for one message?
	JB	20$.S			;No
	MOVL	ECX, #XFPMXSIZE		;Yes - just use maximum
20$:	SUBL	SS:xffCount#, ECX	;Reduce amount needed
	MOVL	opx_datasize.B[EBP], ECX ;Save amount for this time
	CMPL	opx_parmsize.B[EBP], #0.B ;Have any parameters?
	JE	22$.S			;No
	MOVL	EAX, ECX		;Yes
	CALL	getvalsize
	ADDL	ECX, opx_parmsize.B[EBP]
22$:	ADDL	ECX, #2.B		;Plus header bytes
	CALL	xfpgetpkt		;Allocate a packet buffer
24$:	JC	40$			;If error
	MOVL	EAX, #XFPF_DATA+1100h	;Get the message header (assume want
					;  response)
	CMPL	SS:xffCount##, #0.B	;Right?
	JE	26$.S			;Yes
	MOVB	AH, #01h		;No
26$:	CMPL	opx_parmsize.B[EBP], #0.B ;Have any parameters?
	JE	28$.S			;No
	ORB	AH, #20h		;Yes
28$:	MOVW	[EBX], AX
	ADDL	EBX, #2t.B
	TESTB	AH, #20h		;Have any parameters?
	JE	30$.S			;No
	MOVL	EAX, opx_datasize.B[EBP] ;Yes - store size of data area
	CALL	putvalue
30$:	MOVL	EAX, opx_datasize.B[EBP] ;Get amount to output this time
	TESTL	EAX, EAX
	JE	34$.S			;If nothing to output
	LFSL	ESI, SS:xffBuffer1##	;Get address of the user's buffer
	ADDL	SS:xffBuffer1##, EAX	;Bump address
	PUSHL	EDI
	MOVL	EDI, EBX
	PUSHL	DS
	POPL	ES
	CLD
	CMPL	EAX, #4t.B
	JBE	32$.S
	CLRL	ECX
	SUBL	ECX, EDI
	ANDL	ECX, #03h.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], FS:[ESI]
	MOVL	ECX, EAX
	SHRL	ECX, #2t
	RMOVSL	[EDI], FS:[ESI]
	ANDL	EAX, #03h
32$:	MOVL	ECX, EAX
	RMOVSB	[EDI], FS:[ESI]
	MOVL	EBX, EDI
	POPL	EDI
34$:	CMPL	opx_parmsize.B[EBP], #0	;Have any parameters?
	JE	36$.S			;No
	CALL	storeparm		;Yes - store them
	CLRL	EAX
	MOVL	opx_parmsize.B[EBP], EAX
36$:	CALL	xfpsendpkt		;Send the data request
	JC	40$.S			;If error
	CMPL	SS:xffCount##, #0.B	;Want any more?
	JNE	12$			;Yes
	MOVB	AH, #XFPF_RESPONSE
	CALL	xfprcvrsp		;No - get the response
38$:	LEAVE
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

40$:	CLRL	ECX
	JMP	38$.S
.PAGE
	.SBTTL	xfpdelete - Delete file

;Here for SV_delete function - delete file
;	c{SS:EDX} = Address of expanded file name
;	c{EDI}    = Offset of DCB for file to delete or its directory
;	c{ESI}    = Device table offset for file to delete or its directory
;	CALL	xfpdelete
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Item count
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Item count

xfpdelete:
	MOVB	AL, #XFPF_DELETE	;Get message type
	JMP	open2			;Continue with common code
.PAGE
	.SBTTL	xfprename - Rename file

;Here for SV_RENAME function - Rename file
;	c{SS:ESI} = Address of buffer containing processed new name
;	c{ECX}    = Option bits
;	c{SS:EDX} = Address of expanded file specification
;	c{EDI}    = Offset of DCB for old file or directory
;	CALL	xfprename
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Item count
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Item count

xfprename:
	PUSHL	EDX
	LEAL	EBX, opn_devname.B[EBP] ;Get physical device name
	MOVL	EDX, opn_frame1.B[EBP]
	ADDL	EDX, #opn_devname.B
	MOVL	EAX, SS:[EBX]		;Same device?
	CMPL	SS:[EDX], EAX
	JNE	10$.S			;No - fail!
	MOVL	EAX, SS:4.B[EBX]
	CMPL	SS:4.B[EDX], EAX
	JNE	10$.S
	MOVL	EAX, SS:8.B[EBX]
	CMPL	SS:8.B[EDX], EAX
	JNE	10$.S
	MOVL	EAX, SS:12t.B[EBX]
	CMPL	SS:12t.B[EDX], EAX
	POPL	EDX
	JNE	10$.S
	PUSHL	ESI			;Scan the new name to see if there is
	CLD				;  a network address
2$:	LODSB	SS:[ESI]
	CMPB	AL, #0
	JE	4$.S
	CMPB	AL, #':'
	JNE	2$.S
	LODSB	SS:[ESI]
	CMPB	AL, #':'
	JNE	4$.S
	POPL	EAX			;Have network address - discard it!
	JMP	6$.S

;Here if don't have a network address

4$:	POPL	ESI			;Restore offset of start of name string
6$:	MOVB	AL, #XFPF_RENAME	;Get message type
	JMP	open2			;Continue with common code

;Here if new name is different

10$:	MOVL	EAX, #ER_DFDEV
	CLRL	ECX
	STC
	RET
.PAGE
	.SBTTL	checkspec - Subroutine to determine length of file specification

;Subroutine to determine length of file specification
;	c{SS:EDX} = Address of file specification
;	CALL	checkspec
;	c{ECX} = Length of file specification (in bytes)

checkspec:
	PUSHL	EDI
	MOVL	EDI, EDX		;Get length of file specification
	PUSHL	SS
	POPL	ES
	MOVB	AL, #0
	CLD
	MOVL	ECX, #-1
	RNSCASB	[EDI]
	POPL	EDI
	NOTL	ECX
	DECL	ECX
	RET

	.SBTTL	storespec - Subroutine to store file specification

;Subroutine to store file specification in command message
;	c{EAX}    = Total length for file specification (includes count byte(s))
;	c{SS:EDX} = Address of file specification
;	CALL	storespec
;	c{EDX} = Offset of first byte after file specification

storespec:
	PUSHL	EAX
	CALL	putvalue		;Store count
	POPL	EAX			;Restore actual length of file spec.
	MOVL	ESI, EDX
	PUSHL	EDI
	MOVL	EDI, EBX
	PUSHL	DS
	POPL	ES
	CLD
	CMPL	EAX, #4.B
	JBE	4$.S
	CLRL	ECX
	SUBL	ECX, EDI
	ANDL	ECX, #03h.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], SS:[ESI]
	MOVL	ECX, EAX
	SHRL	ECX, #2t
	RMOVSL	[EDI], SS:[ESI]
	ANDL	EAX, #03h
4$:	MOVL	ECX, EAX
	RMOVSB	[EDI], SS:[ESI]
	MOVL	EBX, EDI
	MOVL	EDX, ESI
	POPL	EDI
	RET
.PAGE
	.SBTTL	checkparm - Subroutine to determine space needed for parameters

;Subroutine to determine space needed for parameters
;	CALL	checkparm
;	c{ECX} = c{opx_parmsize{EBP}} = Number of bytes needed for parameter
;					  list
;  Enter at checkparmio for additional set up for input and output calls

checkparmio:
	MOVL	EAX, SS:xffParm##
	MOVL	opx_parm.B[EBP], EAX
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
checkparm:
	CLRL	ECX
	MOVL	EAX, SS:xffPVFilOpt##	;Need IOPAR_FILOPTN parameter?
	ANDL	EAX, #FOBITS
	JE	6$.S			;No
	ADDL	ECX, #6.B		;Yes
	CMPL	SS:xffPPFilSpc##+0, #0.B ;Need IOPAR_FILSPEC parameter?
	JE	6$.S			;No
	ADDL	ECX, #2.B		;Yes
	MOVZWL	EAX, SS:xffPSFilSpc##	;Get length of his buffer
	TESTL	SS:xffPVFilOpt##, #FO$XOSNAME|FO$DOSNAME|FO$VOLNAME
					;Does he want the device name?
	JE	4$.S			;No
	SUBL	EAX, #12t.B		;Yes - subtract space for device name
	CMPL	EAX, #12t.B		;Big enough?
	JA	4$.S			;Yes
	MOVL	EAX, #12t		;No - do the best we can!
4$:	CMPL	EAX, #0Fh.B		;Need more than 4 bits for the length?
	JBE	6$.S			;No
	INCL	ECX			;Yes
6$:	MOVL	EDX, SS:xffHvValue1##	;Get both the "have" and "need" bits
	ORL	EDX, SS:xffNdValue1##
	JE	80$			;If nothing needed at all
	BTL	EDX, #IOV1%DEVSTS	;Need IOPAR_DEVSTS parameter?
	JNC	8$.S			;No
	ADDL	ECX, #2.B		;Yes
8$:	BTL	EDX, #IOV1%UNITNUM	;Need IOPAR_UNITNUM parameter?
	JNC	10$.S			;No
	ADDL	ECX, #2.B		;Yes
10$:	BTL	EDX, #IOV1%GLBID	;Need IOPAR_GLBID parameter?
	JNC	12$.S			;No
	ADDL	ECX, #3.B		;Yes
12$:	BTL	EDX, #IOV1%SRCATTR	;Have IOPAR_SRCATTR parameter?
	JNC	14$.S			;No
	ADDL	ECX, #3.B		;Yes
14$:	BTL	EDX, #IOV1%FILATTR	;Need IOPAR_FILATTR parameter?
	JNC	16$.S			;No
	ADDL	ECX, #2.B
	BTL	SS:xffHvValue1##, #IOV1%FILATTR ;Yes
	JNC	16$.S
	INCL	ECX
16$:	BTL	EDX, #IOV1%DIROFS	;Need IOPAR_DIROFS parameter?
	JNC	18$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%DIROFS ;Have value?
	JNC	18$.S			;No
	ADDL	ECX, #4.B		;Yes
18$:	BTL	EDX, #IOV1%ABSPOS	;Need IOPAR_xxxPOS parameter?
	JNC	20$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%ABSPOS ;Have value?
	JNC	20$.S			;No
	ADDL	ECX, #4.B		;Yes
20$:	BTL	EDX, #IOV1%LENGTH	;Need IOPAR_LENGTH parameter?
	JNC	24$.S			;No
	ADDL	ECX, #2.B
	BTL	SS:xffHvValue1##, #IOV1%LENGTH ;Yes - have value?
	JNC	24$.S			;No
	ADDL	ECX, #4.B		;Yes
24$:	BTL	EDX, #IOV1%DIRHNDL	;Have IOPAR_DIRHNDL parameter?
	JNC	26$.S			;No
	ADDL	ECX, #3.B		;Yes
26$:	BTL	EDX, #IOV1%REQALLOC	;Need IOPAR_REQALLOC parameter?
	JNC	28$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%REQALLOC ;Have value?
	JNC	28$.S			;No
	ADDL	ECX, #4.B		;Yes
28$:	BTL	EDX, #IOV1%RQRALLOC	;Need IOPAR_RQRALLOC parameter?
	JNC	30$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%RQRALLOC ;Have value?
	JNC	30$.S			;No
	ADDL	ECX, #4.B		;Yes
30$:	BTL	EDX, #IOV1%GRPSIZE	;Need IOPAR_GRPSIZE parameter?
	JNC	32$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%GRPSIZE ;Have value?
	JNC	32$.S			;No
	ADDL	ECX, #4.B		;Yes
32$:	MOVL	EAX, opx_frame1.B[EBP]
	BTL	EDX, #IOV1%ADATE	;Need IOPAR_ADATE parameter?
	JNC	36$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%ADATE ;Have value?
	JNC	36$.S			;No
	ADDL	ECX, #4.B		;Yes
	TESTB	SS:opn_datefmt.B[EAX], #DF$DOSADATE ;Have DOS format value?
	JNE	36$.S			;Yes
	ADDL	ECX, #4.B		;No
36$:	BTL	EDX, #IOV1%CDATE	;Need IOPAR_CDATE parameter?
	JNC	40$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%CDATE ;Have value?
	JNC	40$.S			;No
	ADDL	ECX, #4.B		;Yes
	TESTB	SS:opn_datefmt.B[EAX], #DF$DOSCDATE ;Have DOS format value?
	JNE	40$.S			;Yes
	ADDL	ECX, #4.B		;No
40$:	BTL	EDX, #IOV1%MDATE	;Need IOPAR_MDATE parameter?
	JNC	44$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%MDATE ;Have value?
	JNC	44$.S			;No
	ADDL	ECX, #4.B		;Yes
	TESTB	SS:opn_datefmt.B[EAX], #DF$DOSMDATE ;Have DOS format value?
	JNE	44$.S			;Yes
	ADDL	ECX, #4.B		;No
44$:	BTL	EDX, #IOV1%PROT		;Need IOPAR_PROT parameter?
	JNC	48$.S			;No
	ADDL	ECX, #2.B
	BTL	SS:xffHvValue1##, #IOV1%PROT ;Yes - have value?
	JNC	48$.S			;No
	ADDL	ECX, #4.B		;Yes
48$:	BTL	EDX, #IOV1%OWNER	;Need IOPAR_OWNNER parameter?
	JNC	52$.S			;No
	ADDL	ECX, #2.B
	BTL	SS:xffHvValue1##, #IOV1%OWNER ;Yes - have value?
	JNC	52$.S			;No
	ADDL	ECX, #16t.B		;Yes
52$:	TESTL	EDX, #IOV1$SETLOCK|IOV1$CLRLOCK ;Need IOPAR_SETLOCK or
						;  IOPAR_CLRLOCK parameter?
	JE	60$.S			;No
	ADDL	ECX, #10t.B		;Yes
60$:	MOVL	EDX, SS:xffHvValue2##	;Get both the "have" and "need" bits
	ORL	EDX, SS:xffNdValue2##
	JE	80$.S
	BTL	EDX, #IOV2%FSTYPE	;Need IOPAR_FSTYPE parameter?
	JNC	62$.S			;No
	ADDL	ECX, #2.B		;Yes
62$:	BTL	EDX, #IOV2%SECTSIZE	;Need IOPAR_SECTSIZE parameter?
	JNC	64$.S			;No
	ADDL	ECX, #2.B		;Yes
64$:	BTL	EDX, #IOV2%CLSSIZE	;Need IOPAR_CLSSIZE parameter?
	JNC	66$.S			;No
	ADDL	ECX, #2.B		;Yes
66$:	BTL	EDX, #IOV2%TTLSPACE	;Need IOPAR_TTLSPACE parameter?
	JNC	68$.S			;No
	ADDL	ECX, #2.B		;Yes
68$:	BTL	EDX, #IOV2%AVLSPACE	;Need IOPAR_AVLSPACE parameter?
	JNC	70$.S			;No
	ADDL	ECX, #2.B		;Yes
70$:	BTL	EDX, #IOV2%NUMSECT	;Need IOPAR_NUMSECT parameter?
	JNC	72$.S			;No
	ADDL	ECX, #2.B		;Yes
72$:	BTL	EDX, #IOV2%NUMHEAD	;Need IOPAR_NUMHEAD parameter?
	JNC	74$.S			;No
	ADDL	ECX, #2.B		;Yes
74$:	BTL	EDX, #IOV2%NUMCYLN	;Need IOPAR_NUMCYLN parameter?
	JNC	80$.S			;No
	ADDL	ECX, #2.B		;Yes
80$:	MOVL	opx_parmsize.B[EBP], ECX ;Store parameter length
	RET				;Finished
.PAGE
	.SBTTL	storeparm - Subroutine to store parameters

;Subroutine to store parameters into XFP packet
;	c{EBX} = Pointer to packet being built
;	CALL	storeparm

storeparm:
	CLRL	EAX
	MOVL	opx_parmerr1.B[EBP], EAX
	MOVL	opx_parmerr2.B[EBP], EAX
	MOVL	EAX, SS:xffPVFilOpt##	;Need IOPAR_FILOPTN parameter?
	ANDL	EAX, #FOBITS
	JE	18$			;No
	MOVW	[EBX], #XFPAR_FILOPTN|8400h ;Yes - store parameter
	ADDL	EBX, #2t.B
	MOVL	EAX, SS:xffPVFilOpt##	;Get value
	ANDL	EAX, #FOBITS		;Clear unneeded bits
	BTL	EAX, #FO%RXOSNAME	;Want remote name?
	JNC	2$.S			;No
	BTSL	EAX, #FO%XOSNAME	;Yes - get device name
2$:	BTL	EAX, #FO%RDOSNAME	;Want remote DOS name?
	JNC	3$.S			;No
	BTSL	EAX, #FO%DOSNAME	;Yes - get DOS name
3$:	BTL	EAX, #FO%RVOLNAME	;Want remote volume name?
	JNC	4$.S			;No
	BTSL	EAX, #FO%VOLNAME	;Yes - get volume name
4$:	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Searching open directory?
	JNC	6$.S			;No
	ANDL	EAX, #~{FO$NODENUM|FO$NODENAME} ;Yes - node can't change here!
6$:	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	[EBX], EAX
	ADDL	EBX, #4t.B
	CMPL	SS:xffPPFilSpc##+0, #0.B ;Need IOPAR_FILSPEC parameter?
	JE	18$.S			;No
	MOVB	[EBX], #XFPAR_FILSPEC
	INCL	EBX
	MOVZWL	EAX, SS:xffPSFilSpc##	;Get length of his buffer
	CMPL	EAX, #1036t		;Too big?
	JBE	8$.S			;No
	MOVL	EAX, #1036t		;Yes - just use maximum
8$:	TESTL	SS:xffPVFilOpt##, #FO$XOSNAME|FO$DOSNAME|FO$VOLNAME
					;Does he want the device name?
	JE	10$.S			;No
	SUBL	EAX, #12t.B		;Yes - subtract space for device name
	CMPL	EAX, #12t.B		;Big enough?
	JA	10$.S			;Yes
	MOVL	EAX, #12t		;No - do the best we can!
10$:	CMPL	EAX, #0Fh.B		;Need more than 4 bits for the length?
	JA	12$.S			;Yes
	ORB	AL, #40h		;No - store 4 bit length value
	MOVB	[EBX], AL
	INCL	EBX
	JMP	18$.S

12$:	CMPL	EAX, #0FFFh		;Need more than 12 bits?
	JB	14$.S			;No
	MOVL	EAX, #0FFFh		;Yes - just give him as much as we can!
14$:	ORB	AH, #50h		;Store 12 bit length value
	XCHGB	AL, AH
	MOVW	[EBX], AX
	ADDL	EBX, #2t.B
18$:	PUSHL	SS:xffHvValue1##	;Get both the "have" and "need" bits
	MOVL	EAX, SS:xffNdValue1##
	ORL	[ESP], EAX
	JE	100$			;If nothing at all needed
	BTL	[ESP], #IOV1%DEVSTS	;Need IOPAR_DEVSTS parameter?
	JNC	20$.S			;No
	MOVW	[EBX], #XFPAR_DEVSTS|4400h ;Yes - store parameter
	ADDL	EBX, #2t.B
20$:	BTL	[ESP], #IOV1%UNITNUM	;Need IOPAR_UNITNUM parameter?
	JNC	22$.S			;No
	MOVW	[EBX], #XFPAR_UNITNUM|4400h ;Yes - store parameter
	ADDL	EBX, #2t.B
22$:	BTL	[ESP], #IOV1%GLBID	;Need IOPAR_GLBID parameter?
	JNC	24$.S			;No
	MOVB	[EBX], #XFPAR_GLBID	;Yes
	INCL	EBX
	MOVW	[EBX], #1050h
	ADDL	EBX, #2t.B
24$:	BTL	[ESP], #IOV1%SRCATTR	;Need IOPAR_SRCATTR parameter?
	JNC	26$.S			;No
	MOVW	[EBX], #XFPAR_SRCATTR|8100h ;Yes - store parameter
	ADDL	EBX, #2t.B
	MOVL	EAX, opx_frame1.B[EBP]
	MOVB	AL, SS:opn_srcattr.B[EAX] ;Store value
	MOVB	[EBX], AL
	INCL	EBX
26$:	BTL	[ESP], #IOV1%FILATTR	;Need IOPAR_FILATTR parameter?
	JNC	32$.S			;No
	MOVL	EAX, #XFPAR_FILATTR|0100h
	BTL	SS:xffNdValue1##, #IOV1%FILATTR
	JNC	28$.S
	ORB	AH, #40h
28$:	BTL	SS:xffHvValue1##, #IOV1%FILATTR
	JNC	30$.S
	ORB	AH, #80h
30$:	MOVW	[EBX], AX
	ADDL	EBX, #2t.B
	TESTB	AH, #80h
	JE	32$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVB	AL, SS:opn_filattr.B[EAX]
	MOVB	[EBX], AL
	INCL	EBX
32$:	MOVL	ECX, #IOV1%DIROFS
	BTL	[ESP], ECX		;Need IOPAR_DIROFS parameter?
	JNC	34$.S			;No
	MOVB	AL, #XFPAR_DIROFS	;Yes
	MOVL	EDX, #opn_dirofs
	CALL	sparm4
34$:	MOVL	ECX, #IOV1%ABSPOS
	BTL	[ESP], ECX		;Need IOPAR_xxxPOS parameter?
	JNC	38$.S			;No
	MOVB	AL, #XFPAR_ABSPOS	;Yes - assume need IOPAR_ABSPOS
	TESTL	[ESP], #IOV1$RELPOS|IOV1$EOFPOS ;Right?
	JE	36$.S			;Yes
	MOVB	AL, #XFPAR_RELPOS	;No - assume need IOPAR_RELPOS
	BTL	[ESP], #IOV1%RELPOS	;Right?
	JC	36$.S			;Yes
	MOVB	AL, #XFPAR_EOFPOS	;No - must be IOPAR_EOFPOS
36$:	MOVL	EDX, #opn_iopos
	CALL	sparm4
38$:	MOVL	ECX, #IOV1%LENGTH
	BTL	[ESP], ECX		;Need IOPAR_LENGTH parameter?
	JNC	40$.S			;No
	MOVB	AL, #XFPAR_LENGTH	;Yes
	MOVL	EDX, #opn_length
	CALL	sparm4
40$:	BTL	[ESP], #IOV1%DIRHNDL	;Need IOPAR_DIRHNDL parameter?
	JNC	42$.S			;No
	MOVW	[EBX], #XFPAR_DIRHNDL|8100h ;Yes
	MOVB	2.B[EBX], #1		;Store value (always 1 for now!)
	ADDL	EBX, #3t.B
42$:	MOVL	ECX, #IOV1%REQALLOC
	BTL	[ESP], ECX		;Need IOPAR_REQALLOC parameter?
	JNC	44$.S			;No
	MOVB	AL, #XFPAR_REQALLOC
	MOVL	EDX, #opn_reqalloc
	CALL	sparm4
44$:	MOVL	ECX, #IOV1%RQRALLOC
	BTL	[ESP], ECX		;Need IOPAR_RQRALLOC parameter?
	JNC	46$.S			;No
	MOVB	AL, #XFPAR_RQRALLOC
	MOVL	EDX, #opn_rqralloc
	CALL	sparm4
46$:	MOVL	ECX, #IOV1%GRPSIZE
	BTL	[ESP], ECX		;Need IOPAR_GRPSIZE parameter?
	JNC	48$.S			;No
	MOVB	AL, #XFPAR_GRPSIZE
	MOVL	EDX, #opn_grpsize
	CALL	sparm4
48$:	MOVL	ECX, #IOV1%ADATE
	BTL	[ESP], ECX		;Need IOPAR_ADATE parameter?
	JNC	50$.S			;No
	MOVB	AL, #XFPAR_ADATE
	MOVB	AH, #DF$DOSADATE
	MOVL	EDX, #opn_adate
	CALL	sparmdt
50$:	MOVL	ECX, #IOV1%CDATE
	BTL	[ESP], ECX		;Need IOPAR_CDATE parameter?
	JNC	52$.S			;No
	MOVB	AL, #XFPAR_CDATE
	MOVB	AH, #DF$DOSCDATE
	MOVL	EDX, #opn_cdate
	CALL	sparmdt
52$:	MOVL	ECX, #IOV1%MDATE
	BTL	[ESP], ECX		;Need IOPAR_MDATE parameter?
	JNC	54$.S			;No
	MOVB	AL, #XFPAR_MDATE
	MOVB	AH, #DF$DOSMDATE
	MOVL	EDX, #opn_mdate
	CALL	sparmdt
54$:	MOVL	ECX, #IOV1%PROT
	BTL	[ESP], ECX		;Need IOPAR_PROT parameter?
	JNC	56$.S			;No
	MOVB	AL, #XFPAR_PROT
	MOVL	EDX, #opn_prot
	CALL	sparm4
56$:	MOVL	ECX, #IOV1%OWNER
	BTL	[ESP], ECX		;Need IOPAR_OWNER parameter?
	JNC	68$.S			;No
	MOVB	[EBX], #XFPAR_OWNER	;Yes
	INCL	EBX
	MOVL	EDX, opx_frame1.B[EBP]
	ADDL	EDX, #opn_owner		;Determine length of the name
	PUSHL	EDX
	CLRL	EAX
58$:	CMPB	SS:[EDX], #0
	JE	60$.S
	INCL	EAX
	JMP	58$.S

60$:	POPL	EDX
	MOVB	AH, #10h
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	62$.S			;No
	ORB	AH, #40h		;Yes
62$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	64$.S			;No
	ORB	AH, #80h		;Yes
64$:	XCHGB	AL, AH
	MOVW	[EBX], AX
	ADDL	EBX, #2t.B
	POPL	EDX
	TESTB	AH, #80h		;Need value?
	JE	68$.S			;No
66$:	MOVB	AL, SS:[EDX]		;Yes - store value
	CMPB	AL, #0
	JE	68$.S
	INCL	EDX
	PUSHL	EDX
	MOVB	[EBX], AL
	INCL	EBX
	POPL	EDX
	JMP	66$.S

68$:	MOVL	ECX, #IOV1%SETLOCK	;Need IOPAR_SETLOCK parameter?
	BTL	[ESP], ECX
	JNC	70$.S			;No
	MOVB	AL, #XFPAR_SETLOCK	;Yes
	MOVL	EDX, #opn_lockval
	CALL	sparm8
70$:	MOVL	ECX, #IOV1%CLRLOCK	;Need IOPAR_CLRLOCK parameter?
	BTL	[ESP], ECX
	JNC	100$.S			;No
	MOVB	AL, #XFPAR_CLRLOCK	;Yes
	MOVL	EDX, #opn_lockval
	CALL	sparm8
100$:	MOVL	EAX, SS:xffHvValue2##	;Get both the "have" and "need" bits
	ORL	EAX, SS:xffNdValue2##
	JE	200$			;If nothing at all needed here
	MOVL	[ESP], EAX
	BTL	EAX, #IOV2%FSTYPE	;Need IOPAR_FSTYPE parameter?
	JNC	102$.S			;No
	MOVW	[EBX], #XFPAR_FSTYPE|4100h ;Yes - store parameter
	ADDL	EBX, #2t.B
102$:	BTL	[ESP], #IOV2%SECTSIZE	;Need IOPAR_SECTSIZE parameter?
	JNC	104$.S			;No
	MOVW	[EBX], #XFPAR_SECTSIZE|4200h ;Yes - store parameter
	ADDL	EBX, #2t.B
104$:	BTL	[ESP], #IOV2%CLSSIZE	;Need IOPAR_CLSSIZE parameter?
	JNC	106$.S			;No
	MOVW	[EBX], #XFPAR_CLSSIZE|4100h ;Yes - store parameter
	ADDL	EBX, #2t.B
106$:	BTL	[ESP], #IOV2%TTLSPACE	;Need IOPAR_TTLSPACE parameter?
	JNC	108$.S			;No
	MOVW	[EBX], #XFPAR_TTLSPACE|4400h ;Yes - store parameter
	ADDL	EBX, #2t.B
108$:	BTL	[ESP], #IOV2%AVLSPACE	;Need IOPAR_AVLSPACE parameter?
	JNC	110$.S			;No
	MOVW	[EBX], #XFPAR_AVLSPACE|4400h ;Yes - store parameter
	ADDL	EBX, #2t.B
110$:	BTL	[ESP], #IOV2%NUMHEAD	;Need IOPAR_NUMHEAD parameter?
	JNC	112$.S			;No
	MOVW	[EBX], #XFPAR_NUMHEAD|4200h ;Yes - store parameter
	ADDL	EBX, #2t.B
112$:	BTL	[ESP], #IOV2%NUMSECT	;Need IOPAR_NUMSECT parameter?
	JNC	114$.S			;No
	MOVW	[EBX], #XFPAR_NUMSECT|4200h ;Yes - store parameter
	ADDL	EBX, #2t.B
114$:	BTL	[ESP], #IOV2%NUMCYLN	;Need IOPAR_NUMCYLN parameter?
	JNC	200$.S			;No
	MOVW	[EBX], #XFPAR_NUMCYLN|4200h ;Yes - store parameter
	ADDL	EBX, #2t.B
200$:	POPL	EAX			;Fix up the stack
ret010:	RET				;Finished
.PAGE
;Subroutine to store parameter with 4 byte value
;	c(AL)  = Parameter index
;	c{EBX} = Pointer to message being built
;	c{ECX} = Bit to test (bit number)
;	c{EDX} = Offset of value for parameter
;	CALL	sparm4

sparm4:	ADDL	EDX, opx_frame1.B[EBP]
	MOVB	AH, #4
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	2$.S			;No
	ORB	AH, #40h		;Yes
2$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	4$.S			;No
	ORB	AH, #80h		;Yes
4$:	MOVW	[EBX], AX
	ADDL	EBX, #2t.B
	TESTB	AH, #80h
	JNE	14$.S
	RET

;Subroutine to store date/time parameter
;	c(AL)  = Parameter index
;	c(AH)  = Date format bit to test
;	c{EBX} = Pointer to message being built
;	c{ECX} = Bit to test (bit number)
;	c{EDX} = Offset of value for parameter
;	CALL	sparmdt

sparmdt:
	PUSHL	EDX
	MOVL	EDX, opx_frame1.B[EBP]
	TESTB	SS:opn_datefmt.B[EDX], AL ;Have DOS format date/time value?
	POPL	EDX
	JNE	sparm4.S		;Yes - store 4 byte value
sparm8:	ADDL	EDX, opx_frame1.B[EBP]	;No
	MOVB	AH, #08h		;Get value length
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	10$.S			;No
	ORB	AH, #40h		;Yes
10$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	12$.S			;No
	ORB	AH, #80h		;Yes
12$:	MOVW	[EBX], AX
	ADDL	EBX, #2t.B
	TESTB	AH, #80h		;Need value?
	JE	ret010.S		;No - finished here
	MOVL	EAX, SS:4.B[EDX]	;Yes - store first 4 bytes of value
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	[EBX], EAX
	ADDL	EBX, #4t.B
14$:	MOVL	EAX, SS:[EDX]		;Store second 4 bytes of value
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	[EBX], EAX
	ADDL	EBX, #4t.B
	RET
.PAGE
	.SBTTL	xfpsendpkt - Subroutine to send XFP request packet

;Subroutine to send XFP request packet
;	c{EDI} = Offset of DCB
;	CALL	xfpsendpkt

xfpsendpkt:
	MOVL	EBX, opx_reqpkt.B[EBP]
	MOVL	ECX, npb_apcnt.B[EBX]
	SUBL	ECX, #rcp_data-udp_data.B
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the output packet
	INCL	dpdb_rcpxfpcntpktout.B[EAX]
	ADDL	dpdb_rcpxfpcntbyteout.B[EAX], ECX
	JMP	xosrcpSendData##
.PAGE
	.SBTTL	xfprcvrsp - Subroutine to get received XFP response

;Subroutine to get received XFP response and process parameters - must be called
;  in extended fork context
;	c(AH)  = Desired function
;	c{EDI} = Offset of DCB
;	CALL	xfprcvrsp
;	C:set = Error, packet given up
;	  c{EAX} = Error code
;	  c{ECX} = 0
;	C:clr = Normal
;	  Z:set = Data message, still have packet
;	    c{EAX} = Length of data part
;	    c{EBX} = Offset of first byte following parameters
;	    c(DL)  = Final flag (bit 4)
;	  Z:clr = Response message, packet given up
;	    c{EAX} = Error code
;	    c{ECX} = Item count

xfprcvrsp:
	PUSHL	EAX
	CALL	xosrcpGetInputPkt##	;Get an input packet
	JC	12$.S			;If error
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the received message
	INCL	dpdb_rcpxfpcntpktin.B[EAX]
	ADDL	dpdb_rcpxfpcntbytein.B[EAX], ECX
	MOVL	opx_rsppkt.B[EBP], EBX
	LEAL	EBX, rcp_data.B[EDX]
	POPL	EDX
	SUBL	ECX, #2t.B
	JS	rprote.S
	MOVL	opx_rspsize.B[EBP], ECX
	MOVB	AL, [EBX]		;Get the function
	ANDL	EAX, #0Fh.B
	MOVB	opx_headerf.B[EBP], AL
	MOVB	DL, 1.B[EBX]		;Get the channel number and bits
	MOVB	opx_header2.B[EBP], DL	;Save it for later
	ADDL	EBX, #2t.B
	CMPB	AL, DH			;Is this the right function?
	JE	14$.S			;Yes
rprote:	MOVL	EAX, #ER_NPERR
4$:	PUSHL	EAX
	MOVL	EBX, opx_rsppkt.B[EBP]
	CLRL	EAX
	MOVL	opx_rsppkt.B[EBP], EAX
	CALL	xosnetGiveBufr##
	POPL	EAX			;Discard count
6$:	JMP	xosrcpFatal##

;Here if error

10$:	POPL	ECX
12$:	POPL	ECX
	JMP	6$.S

;Here if have the desired response

14$:	CLRL	EAX			;Assume no error indicated
	TESTB	DL, #80h		;Right?
	JE	16$.S			;Yes
	MOVL	EAX, [EBX]		;No - get the error code
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	ADDL	EBX, #4t.B
	SUBL	opx_rspsize.B[EBP], #4t.B
16$:	PUSHL	EAX			;Save error code
	CMPB	opx_headerf.B[EBP], #XFPF_RESPONSE ;Response?
	JNE	rcvdata.S		;No - must be data
	CALL	getvalue		;Yes - get the item count
	JC	12$.S			;If error
	PUSHL	EAX			;OK - save item count
	TESTB	DL, #10h		;Is the final bit set?
	JNE	22$.S			;Yes
	ORB	3.B[ESP], #80h		;No - set high bit of the item count
22$:	CMPL	opx_rspsize.B[EBP], #0.B ;Have any parameters?
	JE	24$.S			;No
	CALL	xfpparms		;Yes - process the parameters
	JC	10$.S
24$:	MOVL	EBX, opx_rsppkt.B[EBP]
	CLRL	EAX
	MOVL	opx_rsppkt.B[EBP], EAX
	CALL	xosnetGiveBufr##
	INCL	dcb_rcprcvwina.B[EDI]	;Open our receive window
	CALL	xosrcpOpenWindow##	;Report the window if we need to now
	POPL	ECX
	POPL	EAX
	TESTL	ESP, ESP		;Clear Z and C
	RET

;Here if have data

rcvdata:TESTB	DL, #20h		;Have parameters?
	JE	26$.S			;No
	CALL	getvalue		;Yes
	JC	10$.S			;If error
	MOVL	ECX, EAX		;OK
	JMP	28$.S

26$:	MOVL	ECX, opx_rspsize.B[EBP]
28$:	POPL	EAX
	CLRL	EDX			;Set Z, clear C
	RET
.PAGE
getvalue:
	DECL	opx_rspsize.B[EBP]
2$:	JS	rprote
	MOVZBL	EAX, [EBX]
	INCL	EBX
	BTZL	EAX, #7t
	JNC	4$.S
	DECL	opx_rspsize.B[EBP]
	JS	2$.S
	MOVB	AH, AL
	MOVB	AL, [EBX]
	INCL	EBX
	BTZL	EAX, #14t
	JNC	4$.S
	DECL	opx_rspsize.B[EBP]
	JS	2$.S
	SHLL	EAX, #8t
	MOVB	AL, [EBX]
	INCL	EBX
	BTZL	EAX, #21t
	JNC	4$.S
	DECL	opx_rspsize.B[EBP]
	JS	2$.S
	SHLL	EAX, #8t
	MOVB	AL, [EBX]
	INCL	EBX
4$:	RET
.PAGE
;Subroutine to get number of bytes required for a variable length value
;	c{EAX} = Value
;	c{ECX} = Current size value
;	CALL	getvalsize
;	c{ECX} = Updated size value

getvalsize:
	INCL	ECX			;Assume 1 byte will do
	CMPL	EAX, #7Fh		;Right?
	JBE	2$.S			;Yes
	INCL	ECX			;No
	TESTL	EAX, #0FFFFC000h	;Will 2 bytes do?
	JE	2$.S			;Yes
	INCL	ECX			;No
	TESTL	EAX, #0FF700000h	;Will 3 bytes do?
	JE	2$.S			;Yes
	INCL	ECX			;No
2$:	RET

;Subroutine to store variable length value in a packet
;	c{EAX} = Value to store
;	c{EBX} = Offset for next byte to store
;	CALL	putvalue

putvalue:
	CMPL	EAX, #7Fh.B		;Will it fit in 1 byte?
	JA	4$.S			;No
	MOVB	[EBX], AL		;Yes
	INCL	EBX
	RET

;Here if value will not fit in 1 byte

4$:	TESTL	EAX, #0FFFFC000h	;Will it fit in 2 bytes?
	JNE	6$.S			;No
	ORB	AH, #80h		;Yes
	JMP	8$.S

;Here if value will not fit in 2 bytes

6$:	TESTL	EAX, #0FF700000h	;Will it fit in 3 bytes?
	JNE	10$.S			;No
	RORL	EAX, #16t		;Yes
	ORB	AL, #0C0h
	MOVB	[EBX], AL
	INCL	EBX
	RORL	EAX, #16t
8$:	XCHGB	AL, AH
	MOVW	[EBX], AX
	ADDL	EBX, #2t.B
	RET

;Here if value will not fit in 3 bytes

10$:	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	ORB	AL, #0E0h
	MOVL	[EBX], EAX
	ADDL	EBX, #4t.B
	RET
.PAGE
;Subroutine to allocate an XFP packet

xfpgetpkt:
	MOVB	AL, #RCPP_DATA
	PUSHL	ECX
	CALL	xosrcpGetPkt##		;Get an RCP data packet
	POPL	ECX
	JC	ret018.S
	MOVL	opx_reqpkt.B[EBP], EBX	;Remember its offset
	LEAL	EBX, rcp_data.B[EDX]	;Point to first data byte
ret018:	RET
.PAGE
	.SBTTL	xfpparms - Subroutine to process received XFP parameters

;Subroutine to process received XFP parameters
;	CALL	xfpparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpparms:
	CMPL	opx_rspsize.B[EBP], #0.B ;Any more left in message?
	JLE	6$.S			;No - finished with parameters
	SUBL	opx_rspsize.B[EBP], #2t.B ;Must have at least two bytes here
	JS	proterr.S
	MOVB	AL, [EBX]
	PUSHL	EAX
	MOVB	AL, 1.B[EBX]		;Get bits and first part of count
	ADDL	EBX, #2t.B
	PUSHL	EAX
	TESTB	AL, #10h		;Need another count byte?
	JE	2$.S			;No
	DECL	opx_rspsize.B[EBP]	;Yes
	JS	10$.S
	ANDL	EAX, #0Fh
	MOVB	AH, AL
	MOVB	AL, [EBX]
	INCL	EBX
	JMP	4$.S

2$:	ANDL	EAX, #0Fh.B
4$:	SUBL	opx_rspsize.B[EBP], EAX	;Reduce count, make sure have enough
	JS	10$.S			;If not enough there
	MOVL	ECX, EAX
	POPL	EAX			;Restore error bit
	POPL	EDX			;Restore parameter index
	MOVZBL	EDX, DL
	CMPB	DL, #MAXXFPAR		;Legal parameter index?
	JA	proterr.S		;No
	CALLI	CS:xfpartbl[EDX*4]	;Yes - dispatch on the parameter
	JNC	xfpparms.S		;Continue if OK
	RET				;Error

;Here when finished with the parameters

6$:	CMPL	SS:xffParm##+0, #0.B	;Have a parameter list?
	JE	8$.S			;No
	PUSHL	EBX
	MOVL	EBX, #ioparms		;Yes - process parameters a final time
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	POPL	EBX
	CLC				;Ignore errors here (should not be any!)
8$:	RET				;Finished

;Here if error

10$:	POPL	EAX			;Fix up the stack
	POPL	EAX
proterr:MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the protocol error
	INCL	dpdb_rcpxfpcntproerr.B[EAX]
	MOVL	EBX, opx_rsppkt.B[EBP]	;Give up the packet buffer
	CALL	xosnetGiveBufr##
	CLRL	EAX
	MOVL	opx_rsppkt.B[EBP], EAX
	MOVL	EAX, #ER_NPERR
	JMP	xosrcpFatal##
.PAGE
	.MOD	4
xfpartbl:
	.LONG	proterr		;		= 0.   - Illegal
	.LONG	proterr		;XFPAR_FILOPTN  = 1.   - File option bits
	.LONG	xfparfilspec	;XFPAR_FILSPEC  = 2.   - File specification
	.LONG	xfpardevsts	;XFPAR_DEVSTS   = 3.   - Device status
	.LONG	xfparunitnum	;XFPAR_UNITNUM  = 4.   - Unit number
	.LONG	xfparglbid	;XFPAR_GLBID    = 5.   - Global device ID
	.LONG	proterr		;XFPAR_NUMOPN   = 6.   - Number of times device
				;			   is open
	.LONG	proterr		;		= 7.   - Illegal
	.LONG	proterr		;		= 8.   - Illegal
	.LONG	proterr		;		= 9.   - Illegal
	.LONG	proterr		;		= 10.  - Illegal
	.LONG	proterr		;		= 11.  - Illegal
	.LONG	xfpardirhndl	;XFPAR_DIRHNDL  = 12.  - Directory handle for
				;			   search
	.LONG	proterr		;		= 13.  - Illegal
	.LONG	xfparsrcattr	;XFPAR_SRCATTR  = 14.  - File attributes for
				;			   search
	.LONG	xfparfilattr	;XFPAR_FILATTR  = 15.  - File attributes for
				;			   file
	.LONG	xfpardirofs	;XFPAR_DIROFS   = 16.  - Dir. offset for srch
	.LONG	xfpariopos	;XFPAR_ABSPOS   = 17.  - Absolute pos. in file
	.LONG	xfpariopos	;XFPAR_RELPOS   = 18.  - Relative pos. in file
	.LONG	xfpariopos	;XFPAR_EOFPOS   = 19.  - Pos. relative to EOF
	.LONG	proterr		;		= 20.  - Illegal
	.LONG	xfparlength	;XFPAR_LENGTH   = 21.  - Written length of file
	.LONG	xfparalloc	;XFPAR_REQALLOC = 22.  - Request allocation
	.LONG	xfparalloc	;XFPAR_RQRALLOC = 23.  - Require allocation
	.LONG	xfpargrpsize	;XFPAR_GRPSIZE  = 24.  - Allocation group size
	.LONG	xfparadate	;XFPAR_ADATE    = 25.  - Last access date/time
	.LONG	xfparcdate	;XFPAR_CDATE    = 26.  - Creation date/time
	.LONG	xfparmdate	;XFPAR_MDATE    = 27.  - Modify date/time
	.LONG	xfparprot	;XFPAR_PROT     = 28.  - File protection
	.LONG	xfparowner	;XFPAR_OWNER    = 29.  - Owner name
	.LONG	proterr		;		= 30.  - Illegal
	.LONG	xfpsetlock	;XFPAR_SETLOCK	= 31.  - Set record lock
	.LONG	xfpclrlock	;XFPAR_CLRLOCK	= 32.  - Clear record lock
	.LONG	proterr		;		= 33.  - Illegal
	.LONG	proterr		;		= 34.  - Illegal
	.LONG	proterr		;		= 35.  - Illegal
	.LONG	proterr		;		= 36.  - Illegal
	.LONG	proterr		;		= 37.  - Illegal
	.LONG	proterr		;		= 38.  - Illegal
	.LONG	proterr		;		= 39.  - Illegal
	.LONG	proterr		;		= 40.  - Illegal
	.LONG	proterr		;		= 41.  - Illegal
	.LONG	proterr		;		= 42.  - Illegal
	.LONG	proterr		;		= 43.  - Illegal
	.LONG	proterr		;		= 44.  - Illegal
	.LONG	proterr		;		= 45.  - Illegal
	.LONG	proterr		;		= 46.  - Illegal
	.LONG	proterr		;		= 47.  - Illegal
	.LONG	proterr		;		= 48.  - Illegal
	.LONG	proterr		;		= 49.  - Illegal
	.LONG	proterr		;		= 50.  - Illegal
	.LONG	proterr		;		= 51.  - Illegal
	.LONG	proterr		;		= 52.  - Illegal
	.LONG	proterr		;		= 53.  - Illegal
	.LONG	proterr		;		= 54.  - Illegal
	.LONG	proterr		;		= 55.  - Illegal
	.LONG	proterr		;		= 56.  - Illegal
	.LONG	proterr		;		= 57.  - Illegal
	.LONG	proterr		;		= 58.  - Illegal
	.LONG	proterr		;		= 59.  - Illegal
	.LONG	proterr		;		= 60.  - Illegal
	.LONG	proterr		;		= 61.  - Illegal
	.LONG	proterr		;		= 62.  - Illegal
	.LONG	proterr		;		= 63.  - Illegal
	.LONG	proterr		;		= 64.  - Illegal
	.LONG	proterr		;		= 65.  - Illegal
	.LONG	proterr		;		= 66.  - Illegal
	.LONG	proterr		;		= 67.  - Illegal
	.LONG	proterr		;		= 68.  - Illegal
	.LONG	proterr		;		= 69.  - Illegal
	.LONG	proterr		;		= 70.  - Illegal
	.LONG	proterr		;		= 71.  - Illegal
	.LONG	proterr		;		= 72.  - Illegal
	.LONG	proterr		;		= 73.  - Illegal
	.LONG	proterr		;		= 74.  - Illegal
	.LONG	proterr		;		= 75.  - Illegal
	.LONG	proterr		;		= 76.  - Illegal
	.LONG	proterr		;		= 77.  - Illegal
	.LONG	proterr		;		= 78.  - Illegal
	.LONG	proterr		;		= 79.  - Illegal
	.LONG	proterr		;		= 80.  - Illegal
	.LONG	proterr		;		= 81.  - Illegal
	.LONG	proterr		;		= 82.  - Illegal
	.LONG	proterr		;		= 83.  - Illegal
	.LONG	proterr		;		= 84.  - Illegal
	.LONG	proterr		;		= 85.  - Illegal
	.LONG	proterr		;		= 86.  - Illegal
	.LONG	proterr		;		= 87.  - Illegal
	.LONG	proterr		;		= 88.  - Illegal
	.LONG	proterr		;		= 89.  - Illegal
	.LONG	proterr		;		= 90.  - Illegal
	.LONG	proterr		;		= 91.  - Illegal
	.LONG	proterr		;		= 92.  - Illegal
	.LONG	proterr		;		= 93.  - Illegal
	.LONG	proterr		;		= 94.  - Illegal
	.LONG	proterr		;		= 95.  - Illegal
	.LONG	xfpfstype	;XFPAR_FSTYPE   = 96.  - File system type
	.LONG	xfpsectsize	;XFPAR_SECTSIZE = 97.  - Sector size
	.LONG	xfpclssize	;XFPAR_CLSSIZE  = 98.  - Cluster size
	.LONG	xfpttlspace	;XFPAR_TTLSPACE = 99.  - Total space
	.LONG	xfpavlspace	;XFPAR_AVLSPACE = 100. - Available space
	.LONG	xfpnumhead	;XFPAR_NUMHEAD  = 101. - Number of heads
	.LONG	xfpnumsect	;XFPAR_NUMSECT  = 102. - Number of sectors
	.LONG	xfpnumcyln	;XFPAR_NUMCYLN  = 103. - Number of cylinders
MAXXFPAR=!{$-xfpartbl}/4-1
.PAGE
;Here for the XFPAR_FILSPEC parameter - File specification string

xfparfilspec:
	TESTB	AL, #PAR$ERROR
	JE	2$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%FILSPEC
2$:	TESTL	SS:xffPVFilOpt##, #FO$NODENUM|FO$NODENAME
					;Want node specification?
	JE	10$.S			;No
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Yes - searching open directory?
	JC	10$.S			;Yes
	CMPB	SS:xffRtdName##+0, #0	;No - have rooted name pending?
	JNE	10$.S			;Yes
	PUSHL	ECX			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX
	JC	3$.S
	MOVB	AL, #FS_NODENUM
	CALL	knlGivUChr##
3$:	MOVL	ECX, #4
	PUSHL	EBX
	LEAL	EBX, dcb_ipsrmtaddr.B[EDI]
4$:	MOVZBL	EAX, [EBX]
	INCL	EBX
	CALL	knlGivUNum##
	DECL	ECX
	JREGZ	ECX, 6$
	MOVB	AL, #'.'
	CALL	knlGivUChr##
	JMP	4$.S

6$:	POPL	EBX
	MOVB	AL, #':'
	CALL	knlGivUChr##
	MOVB	AL, #':'
	CALL	knlGivUChr##
	POPL	ECX
10$:	JREGZ	ECX, 22$		;If no data
12$:	PUSHL	ECX			;Save count
	MOVB	AL, [EBX]
	INCL	EBX
	CMPB	AL, #FS_XOSNAME		;Device?
	JNE	14$.S			;No
	MOVB	AL, #FS_RXOSNAME	;Yes - change to remove device?
14$:	CMPB	AL, #FS_DOSNAME		;DOS device?
	JNE	15$.S			;No
	MOVB	AL, #FS_RDOSNAME	;Yes - change to remote DOS device
15$:	CMPB	AL, #FS_VOLNAME		;Volume device?
	JNE	16$.S			;No
	MOVB	AL, #FS_RVOLNAME	;Yes - change to remote volume device
16$:	CMPB	AL, #FS_MIN		;Prefix code?
	JB	18$.S			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX ;Yes - do we want it?
	JNC	19$.S			;Yes
	JMP	20$.S			;No

;Here if data

18$:	CMPB	SS:xffRtdName##+0, #0	;Have outstanding rooted name?
	JNE	20$.S			;Yes - don't give him the character
19$:	CALL	knlGivUChr##		;No - give him the character
20$:	POPL	ECX			;Restore count
	LOOP	ECX, 12$		;Continue if more
22$:	CLC
	RET
.PAGE
;Here for the XFPAR_DEVSTS parameter - Device status

xfpardevsts:
	TESTB	AL, #PAR$ERROR
	JE	8$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%DEVSTS
8$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	opx_devsts.B[EBP], EAX	;Save it
	RET

;Here for the XFPAR_UNITNUM parameter - Unit number

xfparunitnum:
	TESTB	AL, #PAR$ERROR
	JE	12$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%UNITNUM
12$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	opx_unitnum.B[EBP], EAX	;Save it
	RET

;Here for the XFPAR_GLBID parameter - Global device ID

xfparglbid:
	TESTB	AL, #PAR$ERROR
	JE	16$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%GLBID
16$:	LEAL	EDX, opx_glbid.B[EBP]
	JMP	getparmval16		;Get up to 16 bytes of value

;Here for the XFPAR_DIRHNDL parameter - Directory handle

xfpardirhndl:
	TESTB	AL, #PAR$ERROR
	JE	17$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%DIRHNDL
17$:	JMP	getparmval4		;Discard possible value

;Here for the XFPAR_SRCATTR parameter - Search attributes

xfparsrcattr:
	TESTB	AL, #PAR$ERROR
	JE	18$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%SRCATTR
18$:	JMP	getparmval4		;Discard possible value

;Here for the XFPAR_FILATTR parameter - File attributes

xfparfilattr:
	TESTB	AL, #PAR$ERROR
	JE	19$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%FILATTR
19$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	opx_filattr.B[EBP], EAX	;Save it
	RET

;Here for the XFPAR_DIROFS parameter - Directory offset for search

xfpardirofs:
	TESTB	AL, #PAR$ERROR
	JE	22$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%DIROFS
22$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_dirofs.B[EDX], EAX ;Save it
	RET

;Here for the XFPAR_ABSPOS, XFPAR_RELPOS, or XFPAR_EOFPOS parameter - Position
;  in file

xfpariopos:
	TESTB	AL, #PAR$ERROR
	JE	26$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%ABSPOS
26$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_iopos[EDX], EAX	;Save it
	RET

;Here for the XFPAR_LENGTH parameter - Written length of file

xfparlength:
	TESTB	AL, #PAR$ERROR
	JE	30$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%LENGTH
30$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_length.B[EDX], EAX ;Save it
	RET

;Here for the XFPAR_REQALLOC or XFPAR_RQRALLOC parameter - Allocated size of
;  file

xfparalloc:
	TESTB	AL, #PAR$ERROR
	JE	34$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%REQALLOC
34$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_reqalloc[EDX], EAX ;Save it
	RET

;Here for the XFPAR_GRPSIZE parameter - Allocation group size

xfpargrpsize:
	TESTB	AL, #PAR$ERROR
	JE	38$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%GRPSIZE
38$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_grpsize[EDX], EAX ;Save it
	RET

;Here for the XFPAR_ADATE parameter - Last access date/time

xfparadate:
	TESTB	AL, #PAR$ERROR
	JE	42$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%ADATE
42$:	CALL	getparmval8		;Get up to 64 bits of value
	MOVL	ECX, opx_frame1.B[EBP]
	MOVL	SS:opn_adate+0[ECX], EAX ;Save it
	MOVL	SS:opn_adate+4[ECX], EDX
	RET

;Here for the XFPAR_CDATE parameter - Creation date/time

xfparcdate:
	TESTB	AL, #PAR$ERROR
	JE	46$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%CDATE
46$:	CALL	getparmval8		;Get up to 64 bits of value
	MOVL	ECX, opx_frame1.B[EBP]
	MOVL	SS:opn_cdate+0[ECX], EAX ;Save it
	MOVL	SS:opn_cdate+4[ECX], EDX
	RET

;Here for the XFPAR_MDATE parameter - Modify date/time

xfparmdate:
	TESTB	AL, #PAR$ERROR
	JE	50$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%MDATE
50$:	CALL	getparmval8		;Get up to 64 bits of value
	MOVL	ECX, opx_frame1.B[EBP]
	MOVL	SS:opn_mdate+0[ECX], EAX ;Save it
	MOVL	SS:opn_mdate+4[ECX], EDX
	RET

;Here for the XFPAR_PROT parameter - File protection

xfparprot:
	TESTB	AL, #PAR$ERROR
	JE	54$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%PROT
54$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_prot[EDX], EAX	;Save it
	RET

;Here for the XFPAR_OWNER parameter - Owner name

xfparowner:
	TESTB	AL, #PAR$ERROR
	JE	58$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%OWNER
58$:	MOVL	EDX, opx_frame1.B[EBP]
	ADDL	EDX, #opn_owner
	JMP	getparmval16		;Get up to 16 bytes of value
.PAGE
;Here for the XFPAR_SETLOCK parameter - Set record lock

xfpsetlock:
	TESTB	AL, #PAR$ERROR		;Error?
	JE	4$.S			;No
	BTSL	opx_parmerr1.B[EBP], #IOV1%SETLOCK ;Yes
	JMP	4$.S

;Here for the XFPAR_CLRLOCK parameter - Clear record lock

xfpclrlock:
	TESTB	AL, #PAR$ERROR		;Error?
	JE	4$.S			;No
	BTSL	opx_parmerr1.B[EBP], #IOV1%CLRLOCK ;Yes
4$:	CALL	getparmval8		;Get the value
	MOVL	ECX, opx_frame1.B[EBP]
	MOVL	SS:opn_lockval+0.B[ECX], EAX
	MOVL	SS:opn_lockval+4.B[ECX], EDX
	RET
.PAGE
;Here for the XFPAR_FSTYPE parameter - File system type

xfpfstype:
	TESTB	AL, #PAR$ERROR
	JE	4$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%FSTYPE
4$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVB	SS:opn_fstype[EDX], AL	;Save it
	RET

;Here for the XFPAR_SECTSIZE parameter - Sector size

xfpsectsize:
	TESTB	AL, #PAR$ERROR
	JE	7$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%SECTSIZE
7$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVW	SS:opn_sectsize[EDX], AX ;Save it
	RET

;Here for the XFPAR_CLSSIZE parameter - Cluster size

xfpclssize:
	TESTB	AL, #PAR$ERROR
	JE	8$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%CLSSIZE
8$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVB	SS:opn_clssize[EDX], AL	;Save it
	RET

;Here for the XFPAR_TTLSPACE parameter - Total space (in clusters)

xfpttlspace:
	TESTB	AL, #PAR$ERROR
	JE	10$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%TTLSPACE
10$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_ttlspace[EDX], EAX ;Save it
	RET

;Here for the XFPAR_AVLSPACE parameter - Available space (in clusters)

xfpavlspace:
	TESTB	AL, #PAR$ERROR
	JE	12$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%AVLSPACE
12$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_avlspace[EDX], EAX ;Save it
	RET

;Here for the XFPAR_NUMHEAD parameter - Number of heads

xfpnumhead:
	TESTB	AL, #PAR$ERROR
	JE	14$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%NUMHEAD
14$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVW	SS:opn_numhead[EDX], AX	;Save it
	RET

;Here for the XFPAR_NUMSECT parameter - Number of sectors

xfpnumsect:
	TESTB	AL, #PAR$ERROR
	JE	18$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%NUMSECT
18$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVW	SS:opn_numsect[EDX], AX	;Save it
	RET

;Here for the XFPAR_NUMCYLN parameter - Number of cylinders

xfpnumcyln:
	TESTB	AL, #PAR$ERROR
	JE	20$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%NUMCYLN
20$:	CALL	getparmval4		;Get up to 32 bits of value
	MOVL	EDX, opx_frame1.B[EBP]
	MOVW	SS:opn_numcyln[EDX], AX	;Save it
	RET
.PAGE
;Subroutine to get 32-bit parameter value
;	c{ECX} = Number of value bytes available
;	CALL	getparmval4
;	C:clr always
;	c{EAX} = Value

getparmval4:
	CMPL	ECX, #4t.B		;Have too many value bytes?
	JBE	4$.S			;No
	ADDL	EBX, ECX		;Yes - discard the extra bytes
	MOVL	ECX, #4
	SUBL	EBX, ECX
4$:	PUSHL	#0.B			;Clear the value
	JREGZ	ECX, 8$			;If no value to get
	LEAL	EDX, [ESP+ECX]		;Point to high order byte + 1
6$:	MOVB	AL, [EBX]		;Get a byte
	INCL	EBX
	DECL	EDX
	MOVB	SS:[EDX], AL		;Store the byte in the value
	LOOP	ECX, 6$
8$:	POPL	EAX			;Get value
	CLC
	RET				;Return with it

;Subroutine to get 64-bit parameter value - this is a numeric value which is
;  byte reversed
;	c{ECX} = Number of value bytes available
;	c{EBX} = Offset to receive value
;	CALL	getparmval8
;	C:clr always
;	c{EDX,EAX} = Value

getparmval8:
	CMPL	ECX, #8.B		;Have too many value bytes?
	JBE	14$.S			;No
	ADDL	EBX, ECX		;Yes - discard the extra bytes
	MOVL	ECX, #8t
	SUBL	EBX, ECX
14$:	PUSHL	#0.B
	PUSHL	#0.B
	JREGZ	ECX, 18$
	MOVL	EDX, ESP
	ADDL	EDX, ECX		;Point to high order byte
16$:	MOVB	AL, [EBX]
	INCL	EBX
	DECL	EDX
	MOVB	SS:[EDX], AL		;Store the byte in the value
	LOOP	ECX, 16$
18$:	POPL	EAX
	POPL	EDX
	CLC
	RET				;Finished
.PAGE
;Subroutine to get 16-byte parameter value - this is a byte string value which
;  is not byte reversed
;	c{ECX} = Number of value bytes available
;	c{EDX} = Offset to receive value
;	CALL	getparmval16
;	C:clr always

getparmval16:
	JREGZ	ECX, 8$
	CMPL	ECX, #16t.B		;Have too many value bytes?
	JBE	4$.S			;No
	ADDL	EBX, ECX		;Yes - discard the extra bytes
	MOVL	ECX, #16t
	SUBL	EBX, ECX
4$:	MOVB	AL, [EBX]
	INCL	EBX
	MOVB	SS:[EDX], AL		;Store the byte in the value
	INCL	EDX
	LOOP	ECX, 4$
8$:	CLC
	RET				;Finished
.PAGE
	.MOD	4
	.LONG	PARMMAX
ioparms:.LONG	iogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	iofilparms	 ;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	iodskparms	 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
PARMMAX=!{$-ioparms}/4

	.LONG	PARMGENMAX	;Size of table
iogenparms:
	.LONG	0		;		   = 0000h
	.LONG	ioparfiloptn	;IOPAR_FILOPTN     = 0001h
	.LONG	ioparfilspec	;IOPAR_FILSPEC     = 0002h
	.LONG	iopardevsts	;IOPAR_DEVSTS      = 0003h
	.LONG	ioparunitnum	;IOPAR_UNITNUM     = 0004h
	.LONG	ioparglbid	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	knlIopIoSts##	;IOPAR_INPSTS      = 0008h
	.LONG	knlIopIoSts##	;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
PARMGENMAX=!{$-iogenparms}/4

	.LONG	PARMFILMAX
iofilparms:
	.LONG	0		;		   = 0100h
	.LONG	iopardirhndl	;IOPAR_DIRHNDL     = 0101h
	.LONG	ioparsrcattr	;IOPAR_SRCATTR     = 0102h
	.LONG	ioparfilattr	;IOPAR_FILATTR     = 0103h
	.LONG	iopardirofs	;IOPAR_DIROFS      = 0104h
	.LONG	iopariopos	;IOPAR_ABSPOS      = 0105h
	.LONG	iopariopos	;IOPAR_RELPOS      = 0106h
	.LONG	iopariopos	;IOPAR_EOFPOS      = 0107h
	.LONG	0		;IOPAR_VBOF	   = 0108h
	.LONG	ioparlength	;IOPAR_LENGTH      = 0109h
	.LONG	ioparalloc	;IOPAR_REQALLOC    = 010Ah
	.LONG	ioparalloc	;IOPAR_RQRALLOC    = 010Bh
	.LONG	iopargrpsize	;IOPAR_GRPSIZE     = 010Ch
	.LONG	ioparadate	;IOPAR_ADATE       = 010Dh
	.LONG	ioparcdate	;IOPAR_CDATE       = 010Eh
	.LONG	ioparmdate	;IOPAR_MDATE       = 010Fh
	.LONG	ioparprot	;IOPAR_PROT        = 0110h
	.LONG	ioparowner	;IOPAR_OWNER       = 0111h
	.LONG	0		;		   = 0112h
	.LONG	ioparlock	;IOPAR_SETLOCK     = 0113h
	.LONG	ioparlock	;IOPAR_CLRLOCK     = 0114h
	.LONG	0		;IOPAR_CLSTIME     = 0115h
	.LONG	0		;IOPAR_CLSNAME     = 0116h
	.LONG	0		;IOPAR_CLSMSG	   = 0117h
	.LONG	0		;IOPAR_SHRPARMS    = 0118h
PARMFILMAX=!{$-iofilparms}/4

	.LONG	PARMDSKMAX
iodskparms:
	.LONG	0		;		   = 0300h
	.LONG	ioparfstype	;IOPAR_DSKFSTYPE   = 0301h
	.LONG	ioparsectsize	;IOPAR_DSKSECTSIZE = 0302h
	.LONG	ioparclssize	;IOPAR_DSKCLSSIZE  = 0303h
	.LONG	ioparttlspace	;IOPAR_DSKTTLSPACE = 0304h
	.LONG	ioparavlspace	;IOPAR_DSKAVLSPACE = 0305h
	.LONG	ioparnumhead	;IOPAR_DSKNUMHEAD  = 0306h
	.LONG	ioparnumsect	;IOPAR_DSKNUMSECT  = 0307h
	.LONG	ioparnumcyln	;IOPAR_DSKNUMCYLN  = 0308h
PARMDSKMAX=!{$-iodskparms}/4
.PAGE
;Here for IOPAR_FILOPTN - File specification options

	DPARMHDR  SET, HEXV
ioparfiloptn:
	BTL	opx_parmerr1.B[EBP], #IOV1%FILOPTN
	JC	4$.S
	RET

;Here for IOPAR_FILSPEC - File specification

	DPARMHDR  GET, STR
ioparfilspec:
	BTL	opx_parmerr1.B[EBP], #IOV1%FILSPEC
	JC	4$.S
	RET

;Here for IOPAR_DEVSTS - Device status

	DPARMHDR  GET, HEXV
iopardevsts:
	BTL	opx_parmerr1.B[EBP], #IOV1%DEVSTS
	JC	4$.S
	MOVL	EAX, opx_devsts.B[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_UNITNUM - Unit number

	DPARMHDR  GET, HEXV
ioparunitnum:
	BTL	opx_parmerr1.B[EBP], #IOV1%UNITNUM
	JC	4$.S
	MOVL	EAX, opx_unitnum.B[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_DIRHNDL - Directory handle for search

	DPARMHDR  SET, HEXV
iopardirhndl:
	BTL	opx_parmerr1.B[EBP], #IOV1%DIRHNDL
	JC	4$.S
	RET

;Here for IOPAR_SRCATTR - Search attributes

	DPARMHDR  BOTH, HEXV
ioparsrcattr:
	BTL	opx_parmerr1.B[EBP], #IOV1%SRCATTR
	JC	4$.S
2$:	RET

;Here for IOPAR_FILATTR - File attributes for file

	DPARMHDR  BOTH, HEXV
ioparfilattr:
	BTL	opx_parmerr1.B[EBP], #IOV1%FILATTR
	JC	4$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_filattr.B[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_DIROFS - Directory offset for file

	DPARMHDR  BOTH, DECV
iopardirofs:
	BTL	opx_parmerr1.B[EBP], #IOV1%DIROFS
	JC	4$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_dirofs.B[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_ABSPOS, IOPAR_RELPOS, and IOPAR_EOFPOS - Position in file

	DPARMHDR  BOTH, DECV
iopariopos:
	BTL	opx_parmerr1.B[EBP], #IOV1%ABSPOS
4$:	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_iopos.B[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_LENGTH - Written length of file

	DPARMHDR  BOTH, DECV
ioparlength:
	BTL	opx_parmerr1.B[EBP], #IOV1%LENGTH
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_length.B[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_REQALLOC or IOPAR_RQRALLOC - File allocation

	DPARMHDR  BOTH, DECV
ioparalloc:
	BTL	opx_parmerr1.B[EBP], #IOV1%REQALLOC
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_reqalloc[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_GRPSIZE - Allocation group size

	DPARMHDR  BOTH, DECV
iopargrpsize:
	BTL	opx_parmerr1.B[EBP], #IOV1%GRPSIZE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_grpsize[EAX]
	JMP	knlStrParm4##

6$:	MOVL	EAX, #ER_PARMV
8$:	RET

;Here for IOPAR_ADATE - Last access date/time

	DPARMHDR  BOTH, HEXV
ioparadate:
	BTL	opx_parmerr1.B[EBP], #IOV1%ADATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_adate
	JMP	10$.S

;Here for IOPAR_CDATE - Creation date/time

	DPARMHDR  BOTH, HEXV
ioparcdate:
	BTL	opx_parmerr1.B[EBP], #IOV1%CDATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_cdate
	JMP	10$.S

;Here for IOPAR_MDATE - Modify date/time

	DPARMHDR  BOTH, HEXV
ioparmdate:
	BTL	opx_parmerr1.B[EBP], #IOV1%MDATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_mdate
10$:	ADDL	EAX, opx_frame1.B[EBP]
	MOVL	EDX, SS:4.B[EAX]
	MOVL	EAX, SS:[EAX]
	JMP	knlStrParm8##

;Here for IOPAR_PROT - File protection

	DPARMHDR  BOTH, HEXV
ioparprot:
	BTL	opx_parmerr1.B[EBP], #IOV1%PROT
12$:	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_prot[EAX]
	JMP	knlStrParm4##

14$:	RET

;Here for IOPAR_OWNER - Owner name

	DPARMHDR  BOTH, TEXT
ioparowner:
	BTL	opx_parmerr1.B[EBP], #IOV1%OWNER
	JC	12$.S
	TESTB	AH, #PAR$GET
	JE	14$.S
	MOVL	ESI, #opn_owner
	JMP	16$.S
16$:	ADDL	ESI, opx_frame1.B[EBP]
18$:	PUSHL	SS
	POPL	FS
	MOVL	EAX, #16t
	JMP	knlStrParmLng##

;Here for IOPAR_GLBID - Global device ID

	DPARMHDR  GET, HEXV
ioparglbid:
	BTL	opx_parmerr1.B[EBP], #IOV1%GLBID
	JC	12$.S
	LEAL	ESI, opx_glbid.B[EBP]
	JMP	18$.S
.PAGE
;Here for IOPAR_SETLOCK or IOPAR_CLRLOCK - Set or clear record lock

	DPARMHDR  BOTH, HEXV
ioparlock:
	TESTL	opx_parmerr1.B[EBP], #IOV1$SETLOCK|IOV1$CLRLOCK
	JNE	4$.S
2$:	RET

4$:	STC
6$:	MOVL	EAX, #ER_PARMV
	RET

;Here for IOPAR_FSTYPE - File system type

	DPARMHDR  GET, DECV
ioparfstype:
	BTL	opx_parmerr2.B[EBP], #IOV2%FSTYPE
	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZBL	EAX, SS:opn_fstype[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_SECTSIZE - Sector size

	DPARMHDR  GET, DECV
ioparsectsize:
	BTL	opx_parmerr2.B[EBP], #IOV2%SECTSIZE
	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZWL	EAX, SS:opn_sectsize[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_CLSSIZE - Cluster size

	DPARMHDR  GET, DECV
ioparclssize:
	BTL	opx_parmerr2.B[EBP], #IOV2%CLSSIZE
	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZBL	EAX, SS:opn_clssize[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_TTLSPACE - Total space

	DPARMHDR  GET, DECV
ioparttlspace:
	BTL	opx_parmerr2.B[EBP], #IOV2%TTLSPACE
	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_ttlspace[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_AVLSPACE - Available space

	DPARMHDR  GET, DECV
ioparavlspace:
	BTL	opx_parmerr2.B[EBP], #IOV2%AVLSPACE
10$:	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_avlspace[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMHEAD - Number of heads

	DPARMHDR  GET, DECV
ioparnumhead:
	BTL	opx_parmerr2.B[EBP], #IOV2%NUMHEAD
	JC	10$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZWL	EAX, SS:opn_numhead[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMSECT - Number of sectors

	DPARMHDR  GET, DECV
ioparnumsect:
	BTL	opx_parmerr2.B[EBP], #IOV2%NUMSECT
	JC	10$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZWL	EAX, SS:opn_numsect[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMCYLN - Number of cylinders

	DPARMHDR  GET, DECV
ioparnumcyln:
	BTL	opx_parmerr2.B[EBP], #IOV2%NUMCYLN
	JC	10$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZWL	EAX, SS:opn_numcyln[EAX]
	JMP	knlStrParm4##
.PAGE
	DATA

xfpccb:	    .BLKB ccb_SIZE	;XFP CCB
xfpdpdbhead:.LONG 0		;Offset of first XFP DPDB

	LKEEND
