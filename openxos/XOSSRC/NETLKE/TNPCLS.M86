	.TITLE	TNPCLS - TNP (TAM-Net Protocol) routines for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!1t
MINV   =!1t
EDITNUM=!0t

;1.0.3  1-Jul-93 (Penang)
;	Fixed problem with length of DELETE message when searching open
;	directory
;1.0.4  22-Jul-93 (SC)
;	Added code to check for pending input before doing input, output; or
;	close functions; added code to check for EOF on input before sending
;	request to server; changed output function so attempt to write beyond
;	EOF writes at EOF.
;1.0.5  25-Aug-93 (Malaka)
;	Fixed bug introduced in 1.0.4 (caused problems when receiving
;	partial messages from a Unix system

	LKEHEAD	TNPCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

	CODE

	.SBTTL	SVC dispatch table for TNP devices

;SVC dispatch table for TNP devices

tnpdsp:	.LONG	knlRtnZero##	;sd_mount	=  0. - Mount
	.LONG	knlRtnZero##	;sd_cleardev	=  4. - Clear device
	.LONG	xostcpCDcb##	;sd_cleardcb	=  8. - Clear DCB
	.LONG	knlRtnZero##	;sd_commit	= 12. - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold    = 16. - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew    = 20. - Transfer device/new
	.LONG	knlNullQio##	;sd_opena	= 24. - Open additional
	.LONG	tnpopen		;sd_open1	= 28. - Open device/file
	.LONG	tnpopen		;sd_devparm     = 32. - Device parameters
	.LONG	tnpdelete	;sd_delete	= 36. - Delete file
	.LONG	tnprename	;sd_rename	= 40. - Rename file
	.LONG	tnpinpblk	;sd_inblock	= 44. - Input block
	.LONG	tnpoutblk	;sd_outblock	= 48. - Output block
	.LONG	tnpoutblk1	;sd_outblockq	= 52. - Output block (XFF)
	.LONG	tnpoutstr	;sd_outstring	= 56. - Output string
	.LONG	knlRtnMOne##	;sd_getiosts	= 60. - Get input/output status
	.LONG	tnpspecial	;sd_special     = 64. - Special device function
	.LONG	tnpclose	;sd_close	= 68. - Close file
	.LONG	knlNullLabel##	;sd_label       = 72. - Get device label
	.LONG	knlNullQioGQ##	;sd_commitfunc	= 76. - Commit data to disk
	.LONG	knlInfoNone##	;sd_devinfo     = 80. - Get device info
TNPDSPSZ=!{$-tnpdsp}/4

;Class function dispatch table for TNP class devices

	.LONG	TNPCLSFMX
tnpcls: .LONG	tnpaddunit	;CF_ADDUNIT = 1. - Add unit
	.LONG	tnpunitinfo	;CF_PUNITS  = 2. - Get information about
				;		     physical units
	.LONG	knlIFnDev##	;CF_AUNITS  = 3. - Get information about active
				;		     units
TNPCLSFMX=!{$-tnpcls}/4
.PAGE
;Device characteristics tables for the TNP devices

tnpdctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS  , TEXT, , 8, knlDcMsgClass##  , knlDcGetClass##    , knlDcSetClass##    , 0
 DCHARENT  RETRY1 , DECV, , 1, xosipsMsgRetry1##, xosipsGetDpdbByte##, xosipsSetDpdbByte##, dpdb_tcptnpretry1
 DCHARENT  RETRY2 , DECV, , 1, xosipsMsgRetry2##, xosipsGetDpdbByte##, xosipsSetDpdbByte##, dpdb_tcptnpretry2
 DCHARENT  RMTPORT, DECV, , 4, msgrmtport       , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rmtport
 DCHARENT  MSGIN  , DECV, , 4, msgmsgin         , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcptnpcntmsgin
 DCHARENT  BYTEIN , DECV, , 4, knlDcMsgByteIn## , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcptnpcntbytein
 DCHARENT  MSGOUT , DECV, , 4, msgmsgout        , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcptnpcntmsgout
 DCHARENT  BYTEOUT, DECV, , 4, knlDcMsgByteOut##, xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcptnpcntbyteout
 DCHARENT  PROERR , DECV, , 4, msgproerr        , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcptnpcntfprot

msgrmtport:DCHARINFO  {Remote (server) port}
msgmsgin:  DCHARINFO  {Number of messages input}
msgmsgout: DCHARINFO  {Number of messages output}
msgproerr: DCHARINFO  {Protocol errors}

	.MOD	4
.PAGE
;Device parameter table for TNP open operations - these parameters are used
;  during an open after the open is complete

	.LONG	OPARMMAX
tnpopnparms:
	.LONG	tnpopngenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	tnpopnfilparms	 ;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	tnpopnnetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
OPARMMAX=!{$-tnpopnparms}/4

	.LONG	OPARMGENMAX	;Size of table
tnpopngenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopDummyS##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	knlIopIoSts##	;IOPAR_INPSTS      = 0008h
	.LONG	knlIopIoSts##	;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT     = 0010h
OPARMGENMAX=!{$-tnpopngenparms}/4

	.LONG	OPARMFILMAX
tnpopnfilparms:
	.LONG	0		;		   = 0100h
	.LONG	knlIopDummyN##	;IOPAR_DIRHNDL     = 0101h
	.LONG	knlIopDummyN##	;IOPAR_SRCATTR     = 0102h
	.LONG	tnpopnattr	;IOPAR_FILATTR     = 0103h
	.LONG	tnpopndirofs	;IOPAR_DIROFS      = 0104h
	.LONG	0		;IOPAR_ABSPOS	   = 0105h
	.LONG	0		;IOPAR_RELPOS	   = 0106h
	.LONG	0		;IOPAR_EOFPOS	   = 0107h
	.LONG	0		;		   = 0108h
	.LONG	tnpopnlength	;IOPAR_LENGTH      = 0109h
	.LONG	tnpopnalloc	;IOPAR_REQALLOC    = 010Ah
	.LONG	tnpopnalloc	;IOPAR_RQRALLOC    = 010Bh
	.LONG	tnpopngrpsize	;IOPAR_GRPSIZE     = 010Ch
	.LONG	tnpopndate	;IOPAR_ADATE       = 010Dh
	.LONG	tnpopndate	;IOPAR_CDATE       = 010Eh
	.LONG	tnpopndate	;IOPAR_MDATE       = 010Fh
	.LONG	tnpopnprot	;IOPAR_PROT        = 0110h
	.LONG	tnpopnowner	;IOPAR_OWNER       = 0111h
	.LONG	0		;		   = 0112h
	.LONG	0		;IOPAR_SETLOCK     = 0113h
	.LONG	0		;IOPAR_CLRLOCK     = 0114h
	.LONG	0		;IOPAR_CLSTIME     = 0115h
	.LONG	0		;IOPAR_CLSNAME     = 0116h
	.LONG	0		;IOPAR_CLSMSG	   = 0117h
OPARMFILMAX=!{$-tnpopnfilparms}/4

	.LONG	OPARMNETMAX
tnpopnnetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	knlIopNullN##	;IOPAR_NETPROTOCOL = 0502h
	.LONG	tnpopnlclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	tnpopnrmtnode	;IOPAR_NETRMTNETAS = 0506h
	.LONG	0		;IOPAR_NETRMTNETAR = 0507h
	.LONG	tnpopnrmtports	;IOPAR_NETRMTPORTS = 0508h
	.LONG	0		;IOPAR_NETRMTPORTR = 0509h
	.LONG	0		;IOPAR_NETDSTNAME  = 050Ah
	.LONG	0		;IOPAR_NETSMODE    = 050Bh
	.LONG	0		;IOPAR_NETCMODE    = 050Ch
OPARMNETMAX=!{$-tnpopnparms}/4
.PAGE
;Device parameter table for TNP IO operations

	.LONG	PARMMAX
tnpioparms:
	.LONG	tnpiogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	tnpiofilparms	 ;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	tnpionetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
PARMMAX=!{$-tnpioparms}/4

	.LONG	PARMGENMAX	;Size of table
tnpiogenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopFilOptn##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopFilSpec##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT	   = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT	   = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT     = 0010h
PARMGENMAX=!{$-tnpiogenparms}/4

	.LONG	PARMFILMAX
tnpiofilparms:
	.LONG	0		;		   = 0100h
	.LONG	0		;IOPAR_DIRHNDL     = 0101h
	.LONG	0		;IOPAR_SRCATTR     = 0102h
	.LONG	0		;IOPAR_FILATTR     = 0103h
	.LONG	0		;IOPAR_DIROFS      = 0104h
	.LONG	tnpiopabspos	;IOPAR_ABSPOS	   = 0105h
	.LONG	tnpioprelpos	;IOPAR_RELPOS	   = 0106h
	.LONG	tnpiopeofpos	;IOPAR_EOFPOS	   = 0107h
	.LONG	0		;IOPAR_VBOF	   = 0108h
	.LONG	tnpioplength	;IOPAR_LENGTH      = 0109h
	.LONG	0		;IOPAR_REQALLOC    = 010Ah
	.LONG	0		;IOPAR_RQRALLOC    = 010Bh
	.LONG	0		;IOPAR_GRPSIZE     = 010Ch
	.LONG	tnpiopadate	;IOPAR_ADATE       = 010Dh
	.LONG	tnpiopcdate	;IOPAR_CDATE       = 010Eh
	.LONG	tnpiopmdate	;IOPAR_MDATE       = 010Fh
	.LONG	0		;IOPAR_PROT        = 0110h
	.LONG	0		;IOPAR_OWNER       = 0111h
	.LONG	0		;		   = 0112h
	.LONG	0		;IOPAR_SETLOCK	   = 0113h
	.LONG	0		;IOPAR_CLRLOCK	   = 0114h
	.LONG	knlIopNullN##	;IOPAR_CLSTIME     = 0115h
	.LONG	knlIopNullN##	;IOPAR_CLSNAME     = 0116h
	.LONG	knlIopNullN##	;IOPAR_CLSMSG      = 0117h
	.LONG	0		;IOPAR_SHRRETRY    = 0118h
	.LONG	0		;IOPAR_SHRDELAY    = 0119h
PARMFILMAX=!{$-tnpiofilparms}/4

	.LONG	PARMNETMAX
tnpionetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	knlIopNullN##	;IOPAR_NETPROTOCOL = 0502h
	.LONG	tnpopnlclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	tnpopnrmtnode	;IOPAR_NETRMTNETAS = 0506h
	.LONG	0		;IOPAR_NETRMTNETAR = 0507h
	.LONG	tnpopnrmtports	;IOPAR_NETRMTPORTS = 0508h
PARMNETMAX=!{$-tnpionetparms}/4
.PAGE
	.SBTTL	tnpinit - Initialization routine for TNP class devices

	INITSUB	tnpinit

;The command for installing TNPCLS is:
;	LKELOAD TNPCLS

tnpinit:MOVL	EDI, #tnpchk		;Install the TNP class
	MOVL	EBX, #tnpcls		;Offset of class function dispatch table
	CLRL	ECX
	MOVL	EAX, #'TNP'
	CLRL	EDX
	MOVL	ESI, #tnpccb
	CALL	knlNewClass##
	JC	10$.S
	MOVL	ECX, #codetop
	CLRL	EDX
	CLRL	EAX
10$:	MOVL	EBX, #QSTS$DONE
	RET

	CODE
.PAGE
	.SBTTL	tnpaddunit - Subroutine to add TNP "unit"

;Subroutine to add TNP "unit" - this is a logical unit which implements the
;  TNP application level protocol for a single transport level (TCP) unit
;  - multiple TNP units may be set up for different TCP units if desired
;	c{ES:EDI} = Address of data block
;	CALL	tnpaddunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count

$$$=!0
FRM tnpau_tcpdev, 8	;TCP device name
FRM tnpau_unit  , 4	;Unit number
FRM tnpau_pdb   , 4	;Offset of PDB
tnpau_SIZE=!$$$

	.MOD	4
tnpaublk:				;Parameter description block for
 DCHARBGN  2, knlDCharValCom##		;  adduparms
 DCHARENT  UNIT    , DECV, , 1, knlDcMsgUnit##, 0, tnpauunit  , 0
 DCHARENT  TCPDEV  , TEXT, , 8, 0             , 0, tnpautcpdev, 0

tnpaddunit:
	ENTER	tnpau_SIZE, 0		;Allocate our stack frame
	CLRL	EAX
	DECL	EAX
	MOVL	tnpau_tcpdev+0.B[EBP], EAX ;Store illegal values for TCP
	MOVL	tnpau_tcpdev+4.B[EBP], EAX ;  device name and unit number
	MOVL	tnpau_unit.B[EBP], EAX
	IFFAULT	4$
	LFSL	EDX, iorb_buffer2.B[ESI]
	CALL	knlGiveQel##		;Give up the IORB
	MOVL	EBX, #tnpaublk		;Process the characteristics
	MOVB	AL, #0			;Fail on bad names
	CALL	knlAddUnitChar##
	JC	2$.S			;If error
	MOVL	EAX, tnpau_unit.B[EBP]	 ;Make sure TCP device and unit number
	ORL	EAX, tnpau_tcpdev.B[EBP] ;  are specified
	INCL	EAX
	JNE	6$.S
	MOVL	EAX, #ER_CHARM
2$:	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	LEAVE
	TOFORK
	RET
		
;Here if address error with the IORB

4$:	CALL	knlGiveQel##
	MOVL	EAX, #ER_ADRER
	JMP	2$.S

;Here if have all required characteristics

6$:	PUSHL	tnpau_unit.B[EBP]	;Stack unit number
	PUSHL	#dpdb_tcptnpSIZE	;Stack DPDB size
	PUSHL	#'TNP'			;Stack base name
	PUSHL	#dcb_tnpINDEX.B		;Stack size index for DCB
	PUSHL	#tnpccb			;Stack offset of the XFP CCB
	PUSHL	xostcpTpdbHead##		;Stack offset of first TCP TPDB
	PUSHL	#tnpdpdbhead		;Stack offset of XFP DPDB head pointer
	CALL	xosipsMakeDev##		;Create new network device
	JC	2$.S			;If error
	CALL	knlGiveXRes##
	MOVB	CL, dpdb_unit.B[EDI]	;Get unit number
10$:	MOVL	dpdb_rmtport.B[EDI], #TCPP_TNP ;Store default remote port
	MOVL	EDI, dpdb_nextd.B[EDI]
	TESTL	EDI, EDI
	JE	12$.S
	CMPB	CL, dpdb_unit.B[EDI]
	JE	10$.S
12$:	CLRL	EAX
	JMP	2$.S
.PAGE
;Subroutine called by adduparms for the "UNIT" parameter

tnpauunit:
	CMPL	EAX, #100t.B		;Valid value?
	JAE	4$.S
	MOVL	tnpau_unit.B[EBP], EAX
	CLC
	RET

4$:	MOVL	EAX, #ER_CHARV
	STC
	RET

;Subroutine called by adduparms for the "TCPDEV" parameter

tnpautcpdev:
	MOVL	tnpau_tcpdev+0.B[EBP], EAX
	MOVL	tnpau_tcpdev+4.B[EBP], EDX
	RET
.PAGE

	.SBTTL	tnpunitinfo - TNP class get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  TNP class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	tnpunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

tnpunitinfo:
	CRASH	NIYT
.PAGE
	.SBTTL	tnpchk - Device check routine for TNP class devices

;Device check routine for TNP class devices
;	c{EBX:EAX} = Device name (8 bytes)
;	CALL	tnpchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  ESI is preserved

tnpchk:	PUSHL	EAX
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'TNP'		;Is this TNP*?
	POPL	EAX
	JNE	4$.S			;No
	MOVL	EDI, tnpdpdbhead	;Yes - get offset of first TNP DPDB
	MOVL	ECX, EAX		;Get shifted device name
	SHRDL	ECX, EBX, #24t
	MOVL	EDX, #DS$SODIR|DS$FILE
	CALL	xosipsFindDev##		;Find matching network device
	JC	2$.S			;If error
	JNE	2$.S			;Or if not a match
	MOVL	dcb_sdisp.B[EDI], #tnpdsp ;Store offset of SVC dispatch table
	MOVL	dcb_tcpfuncdisp.B[EDI], #xostcpFncDisp## ;Store offset of func
							 ;  dispatch table
	MOVL	dcb_devchar.B[EDI], #tnpdctbl ;Use our device characteristics
	MOVL	dcb_netmode.B[EDI], #NMTCP$PUSH ;Set default modes
	MOVB	dcb_ipsprot.B[EDI], #IPP_TCP ;Store protocol value
	MOVL	ECX, #80000401h		;Assign default port number
	CALL	xosipsGetPort#
	JC	10$.S
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Store remote port number
	MOVL	EAX, dpdb_rmtport.B[EAX]	
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport.B[EDI], AX
	CLRL	EAX			;Set Z
2$:	RET				;And return

4$:	CLC
	RET

;Here if can't allocate default port number

10$:	PUSHL	EAX
	CALL	xosnetCDcb##
	POPL	EAX
	STC
	RET
.PAGE
	.SBTTL	sd_open - Open device

;Here for the open device entry
;	c{SS:EDX} = Offset of name buffer
;	c{EDI}    = Offset of DCB
;	CALL	tnpopen
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

$$$=!0
FRM opx_frame1  , 4t
FRM opx_frame2  , 4t
FRM opx_filspec , 4t		;Offset of given file spec
FRM opx_filspsz , 4t		;Length of given file spec
FRM opx_nfilspec, 4t		;Offset of given file spec
FRM opx_nfilspsz, 4t		;Length of given file spec
FRM opx_itemcnt , 4t
FRM opx_opsize  , 4t
FRM opx_optype  , 1t
FRM opx_status  , 1t
FRM             , 2t
FRM opx_pktsize , 4t
FRM opx_flength , 4t
FRM opx_fdate   , 4t
FRM opx_ftime   , 4t
FRM opx_error   , 4t
opx_SIZE=!$$$-8

tnpopen:MOVB	SS:xffQueue##, #dcb_outframe ;Set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	ENTER	opx_SIZE, 2		;Set up a level 2 stack frame
	TESTL	SS:xffCmd##, #O$CONTIG|O$FAPPEND ;Bad options?
	JNE	16$			;Yes - fail
	BTL	SS:xffHvValue1##, #IOV1%LCLPORT ;Local port number specified?
	JNC	6$.S			;No
	MOVL	ECX, opx_frame1.B[EBP]	;Yes
	MOVL	ECX, SS:opn_lclport.B[ECX] ;Use it
	PUSHL	EDX
	CALL	xosipsGetPort##
	POPL	EDX
	JC	12$.S			;If error setting the local port number
6$:	BTL	SS:xffHvValue1##, #IOV1%RMTPORTS ;Remote port number specified?
	JNC	8$.S			;No
	MOVL	EAX, opn_rmtports.B[EBP] ;Yes - use it
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport.B[EDI], AX
8$:	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;No - physical or raw IO?
	JE	10$.S			;No - go on
	ANDB	SS:xffCmd##, #~{O$IN|O$OUT} ;No IO allowed
	LEAVE
	MOVL	ECX, #1
	CLRL	EAX
	RET

;Here if not requesting raw or physical IO

10$:	MOVL	opx_filspec.B[EBP], EDX	;Save offset of file spec
	CLRL	EAX
	MOVL	opx_opsize.B[EBP], EAX
	MOVL	opx_itemcnt.B[EBP], EAX
	MOVL	opx_flength.B[EBP], EAX
	MOVL	dcb_tnpfilelen[EDI], EAX
	MOVL	opx_fdate.B[EBP], EAX
	MOVL	opx_ftime.B[EBP], EAX
	MOVW	dcb_outframe.B[EDI], SS	;Yes - Set up an output queue
	MOVB	SS:xffQueue##, #dcb_outframe
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%SRCATTR ;Should we use attributes?
	JNC	14$.S			;No
	MOVL	ECX, opx_frame1.B[EBP]	;Yes
	MOVB	CL, SS:opn_srcattr.B[ECX] ;Get attribute byte
	ORB	CL, CL			;Anything specified?
	JE	14$.S			;No - just do normal search
	TESTB	CL, #A$LABEL		;Yes - want labels?
	JE	14$.S			;No - also normal search
	MOVL	EAX, #ER_FILNF		;Yes - say file not found!
12$:	JMP	openlv.S

14$:	CALL	chkspec			;Get length of file specification
	JC	openlv.S		;If error
	MOVL	opx_filspsz.B[EBP], ECX	;Save length for later
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Want to search open directory?
	JNC	open2.S			;No
	CMPB	SS:xffFunc##, #QFNC_DEVPARM ;Yes - want to close immediately?
	JE	open4.S			;Yes - OK
16$:	MOVL	EAX, #ER_IFDEV		;No - can't handle this yet!
openlv:	LEAVE
	CLRL	ECX
	STC
	RET
.PAGE
;Here if do not want to search open directory - must establish a TCP connection

open2:	MOVL	EAX, #2070t+15t		;Get window sizes
	MOVB	CL, #3
	MOVL	EDX, opx_filspec.B[EBP]
	CALL	xostcpConnect##		;Establish the TCP connection
	JC	openlv.S		;If error
	MOVL	opx_filspec.B[EBP], EDX
open4:	MOVL	ECX, opx_filspsz.B[EBP]
	ADDL	ECX, #8.B		;Add space for rest of command stuff
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Want to search open directory?
	JNC	2$.S			;No
	ADDL	ECX, #4.B		;Yes
2$:	MOVL	opx_pktsize.B[EBP], ECX
	CALL	xostcpAlloc##		;Allocate space for the open command
	JC	opendn			;If error
	MOVL	EAX, opx_pktsize.B[EBP]	;Construct command header
	ORB	AH, #80h
	CALL	xostcpPutWord##
	MOVL	EAX, #{TNPF_OPEN<24t}|TNPO$RFLEN ;Get function
	CMPB	SS:xffFunc##, #QFNC_OPEN ;Really an open?
	JE	4$.S			;Yes
	XORL	EAX, #TNPO$CLOSE|TNPO$RFLEN ;No - must be device parameter
4$:	CALL	getbits			    ;  funtion
	CALL	xostcpPutLong##		;Store first four bytes
open6:	MOVL	EDX, opx_filspec.B[EBP]
	MOVL	EAX, opx_filspsz.B[EBP]
open8:	CALL	storespec		;Store file specification in packet
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL
	JNC	6$.S
	MOVL	EAX, #{TNPO_DHANDLE<24t}|040001h
	CALL	xostcpPutLong##
6$:	CALL	tnppush			;Send the packet
	JC	opendn			;If error
					;OK - fall into code on next page
.PAGE
;Here with file open request block sent

	CALL	tnprcvblk		;Get the response
	JC	4$.S			;If error
	MOVL	opx_pktsize.B[EBP], ECX
	CMPB	AL, #TNPF_RESPN		;It must be a response
	JNE	openft
	SUBL	opx_pktsize.B[EBP], #9.B ;Do we have enough data here?
	JL	openft			;No - fail!
	CALL	xostcpGetByte##		;Yes - get next byte
	JC	4$.S
	MOVB	opx_status.B[EBP], AL	;Remember status bits
	CALL	xostcpGetWord##		;Get and discard file handle!
	JC	4$.S
	CALL	xostcpGetWord##		;Get error code
	JC	4$.S
	MOVL	opx_error.B[EBP], EAX	;Store error code
	CALL	xostcpGetWord##		;Get item count
	JC	4$.S
	BTZL	EAX, #15t		;Is the sign bit set?
	JNC	3$.S			;No
	BTSL	EAX, #31t		;Yes - move it to bit 31
3$:	MOVL	opx_itemcnt.B[EBP], EAX
	CALL	xostcpGetWord##		;Get file name length
4$:	JC	opener
	MOVL	opx_opsize.B[EBP], EAX
	TESTL	EAX, EAX
	JE	openop			;No - go process any options we have
	SUBL	opx_pktsize.B[EBP], EAX	;Yes - reduce amount left in block
	JL	openft			;Fail if not enough there
8$:	CALL	xostcpGetByte##		;Get next character
	JC	4$.S			;If error
	CMPB	AL, #0F1h		;OK - special character?
	JB	14$.S			;No - just store it
	JNE	10$.S			;Yes - start of path?
	MOVB	AL, #FS_PATH		;Yes
	JMP	14$.S

10$:	CMPB	AL, #0F2h		;Start of name?
	JNE	12$.S			;No
	MOVB	AL, #FS_FILENAME	;Yes
	JMP	14$.S

12$:	CMPB	AL, #0F3h		;Version number?
	JNE	13$.S			;No
	MOVB	AL, #FS_VERSION		;Yes
	JMP	14$.S

13$:	CMPB	AL, #0F4h		;New path?
	JNE	133$.S			;No
	MOVB	AL, #FS_NPATH		;Yes
	JMP	14$.S

133$:	CMPB	AL, #0F5h		;New name?
	JNE	135$.S			;No
	MOVB	AL, #FS_NFILENAME	;Yes
	JMP	14$.S

135$:	CMPB	AL, #0F6h		;New version number?
	JNE	16$.S			;No - discard it!
14$:	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX
	JC	16$.S
	CALL	knlGivUChr##		;Give user the character
16$:	DECL	opx_opsize.B[EBP]	;Reduce amount left to get
	JG	8$.S			;Continue if more to get
					;Finished here - fall into openop on
					;  next page
.PAGE
;Here to process options in the open command response

openop:	DECL	opx_pktsize.B[EBP]	;Any more left in block?
	JS	20$			;No - go on
	CALL	xostcpGetByte##		;Yes - get next byte
	JC	12$.S
	MOVB	opx_optype.B[EBP], AL	;Save option type
	DECB	opx_pktsize.B[EBP]	;No - discard this option
	JS	2$.S
	CALL	xostcpGetByte##		;Get option length
	JC	12$.S
	SUBB	AL, #2
	JLE	openft
	SUBB	opx_pktsize.B[EBP], AL	;Is it all there?
2$:	JS	openft			;No - fail!
	MOVB	opx_opsize.B[EBP], AL	;Yes - store length
	MOVB	AL, opx_optype.B[EBP]
	CMPB	AL, #TNPO_WRTN		;File length value?
	JE	10$.S			;Yes
	CMPB	AL, #TNPO_CDATE		;Date and time value?
	JE	14$.S			;Yes
4$:	CALL	xostcpGetByte##		;No - get next byte
	JC	12$.S
	DECB	opx_opsize.B[EBP]	;More for this option?
	JG	4$.S			;Yes
	JMP	openop.S		;No - go get next option

;Here with file length value

10$:	CMPB	opx_opsize.B[EBP], #4	;Value must be 4 bytes long
	JNE	openft.S
	CALL	xostcpGetLong##		;Get file length
12$:	JC	opendn.S
	MOVL	opx_flength.B[EBP], EAX	;Store it
	MOVL	dcb_tnpfilelen[EDI], EAX
	JMP	openop.S

;Here with creation date/time value

14$:	CMPB	opx_opsize.B[EBP], #8	;Value must be 8 bytes long
	JNE	openft.S
	CALL	xostcpGetLong##		;Get date
	JC	opendn.S
	MOVL	opx_fdate.B[EBP], EAX
	CALL	xostcpGetLong##		;Get time
	JC	opendn.S
	MOVL	opx_ftime.B[EBP], EAX
	JMP	openop

;Here with all options processed

20$:	MOVXWL	EAX, opx_error.B[EBP]	;Get error code
	TESTL	EAX, EAX
	JE	24$.S			;If no error
	JNS	openft.S		;If positive (fatal error)
	CMPL	EAX, #MAXERR		;Negative - is it in our table?
	JL	opener.S		;No
	MOVXWL	EAX, errtbl[EAX*2]	;Yes - translate it
opener:	PUSHL	EAX			;Save error code
22$:	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Searching open directory?
	JC	28$.S			;Yes - leave the connection open
	CALL	xostcpClear##		;No - give up the TCP connection
	JMP	28$.S

openft:	CALL	proterr			;Positive - fatal error!
	JMP	opener.S

24$:	BTL	SS:xffCmd##, #O%ODF
	JNC	opendn.S
	ORB	dcb_sts2.B[EDI], #D2$DIRECT
opendn:	CMPB	SS:xffFunc##, #QFNC_OPEN ;Really an open function?
	JNE	opener.S		;No
26$:	PUSHL	EAX			;Yes
28$:	CMPL	SS:xffParm##, #0.B	;Have a parameter list?
	JE	30$.S			;No
	MOVL	EBX, #tnpopnparms	;Yes - process parameters a final time
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	32$.S			;If error
30$:	POPL	EAX
	BTL	EAX, #31t
	MOVL	ECX, opx_itemcnt.B[EBP]	;Get item count
	LEAVE
ret010:	RET				;All done

;Here if error processing parameter list

32$:	CMPL	[ESP], #0.B		;Already have an error?
	JNE	30$.S			;Yes - ignore this error
	MOVL	[ESP], EAX		;No - report this error
	CLRL	EAX			;Don't let it happen again
	MOVL	SS:xffParm##, EAX
	JMP	22$			;Continue

	DATA

IOX1$RINFO=!IOV1$REQALLOC|IOV1$RQRALLOC|IOV1$GRPSIZE|IOV1$PROT|IOV1$GRPSIZE
IOX1$RINFO=!IOX1$RINFO|IOV1$OWNER
IOX1$DATE =!IOV1$ADATE|IOV1$CDATE|IOV1$MDATE

cmdtbl:	.LONG	O$IN             , TNPO$IN	;Allow input
	.LONG	O$OUT            , TNPO$OUT	;Allow output
	.LONG	O$XWRITE         , TNPO$XWRITE	;Exclusive write access
	.LONG	O$XREAD          , TNPO$XREAD	;Exclusive read access
	.LONG	O$TRUNCA|O$TRUNCW, TNPO$TRUNC	;Truncate existing file
	.LONG	O$CREATE         , TNPO$CREATE	;Create file if it does not
						;  exist
	.LONG	O$FAILEX         , TNPO$FAILEX	;Fail if file exists
	.LONG	O$ODF            , TNPO$ODF	;Open directory as file
	.LONG	O$REPEAT         , TNPO$REPEAT	;Repeated operation
	.LONG	O$DFLTWILD       , TNPO$WDFLT	;* is default extension
CMDTBLSZ=!{$-cmdtbl}/8
	.LONG	FO$xosNAME       , TNPO$RDVNM	;Return device name
	.LONG	FO$PATH          , TNPO$RPATH	;Return path
	.LONG	FO$FILENAME      , TNPO$RFLNM	;Return file name (includes
						;  extension)
	.LONG	FO$ATTR          , TNPO$RATTR	;Return file attribute byte
	.LONG	FO$VERSION       , TNPO$RVRSN	;Return file version number
FOPTBLSZ=!{$-cmdtbl}/8-CMDTBLSZ
	.LONG   IOX1$RINFO       , TNPO$RINFO
	.LONG	IOV1$LENGTH      , TNPO$RFLEN
	.LONG	IOV1$DIROFS      , TNPO$RDIRO
	.LONG	IOX1$DATE        , TNPO$RCDATE
IOVTBLSZ=!{$-cmdtbl}/8-FOPTBLSZ-CMDTBLSZ

	CODE
.PAGE
;Here for IOPAR_FILATTR for open - File attributes for file

	DPARMHDR  BOTH, HEXV
tnpopnattr:
	TESTB	AH, #PAR$GET
	JE	ret010.S
	MOVL	EAX, #A$NORMAL
	JMP	knlStrParm4##

;Here for IOPAR_DIROFS for open - Directory offset for file

	DPARMHDR  BOTH, DECV
tnpopndirofs:
	TESTB	AH, #PAR$GET
	JE	ret010.S
	CLRL	EAX			;For now, just return 0!!!!
	JMP	knlStrParm4##

;Here for IOPAR_LENGTH for open - Written length of file

	DPARMHDR  GET, DECV
tnpopnlength:
	TESTB	AH, #PAR$GET
	JE	ret010.S
	MOVL	EAX, opx_flength.B[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_REQALLOC or IOPAR_RQRALLOC for open - File allocation

	DPARMHDR  BOTH, DECV
tnpopnalloc:
	JMP	tnpopnlength.S		;For now, just return written length!

;Here for IOPAR_GRPSIZE for open - Allocation group size

	DPARMHDR  BOTH, DECV
tnpopngrpsize:
	TESTB	AH, #PAR$GET
	JE	ret010.S
	CLRL	EAX
	JMP	knlStrParm4##

;Here for IOPAR_CDATE, IOPAR_MDATE, or IOPAR_ADATE for open - File date/time

	DPARMHDR  BOTH, HEXV
tnpopndate:
	TESTB	AH, #PAR$GET
	JE	ret010.S
	MOVL	EAX, opx_ftime.B[EBP]	;Get time
	CMPL	ECX, #4.B		;Want DOS format value?
	JBE	2$.S			;Yes
	MOVL	EDX, opx_fdate.B[EBP]	;No - give him the knl format value
	JMP	knlStrParm8##

;Here if want DOS format date and time values

2$:	CALL	knlSys2DosTime##	;Convert to DOS format time
	PUSHL	EAX
	MOVL	EAX, opx_fdate.B[EBP]	;Get date
	CALL	knlSys2DosDate##	;Convert to DOS format date
	JNC	4$.S			;If valid date
	MOVL	EAX, #21h		;Bad date - say 1-Jan-1970!
4$:	MOVW	2.B[ESP], AX
	POPL	EAX
	JMP	knlStrParm4##

;Here for IOPAR_PROT for open - File protection

	DPARMHDR  BOTH, HEXV
tnpopnprot:
	TESTB	AH, #PAR$GET
	JE	6$.S
	CLRL	EAX
	JMP	knlStrParm4##

6$:	RET

;Here for IOPAR_OWNER for open - Owner name

	DPARMHDR  BOTH, TEXT
tnpopnowner:
	TESTB	AH, #PAR$GET
	JE	6$.S
	CLRL	EAX
	RET
.PAGE
;Here for IOPAR_LCLPORT for open - Network local port number

tnpopnlclport:
	TESTB	AH, #PAR$GET
	JE	6$.S
2$:	MOVZWL	EAX, dcb_ipslclport.B[EDI]
	XCHGB	AL, AH
	JMP	knlStrParm4##

;Here for IOPAR_RMTPORTS for open - Network remote port number

tnpopnrmtports:
	TESTB	AH, #PAR$GET
	JE	6$.S
	MOVZWL	EAX, dcb_ipsrmtport.B[EDI]
	JMP	2$.S

6$:	RET

;Here for IOPAR_RMTNODE for open - Network remote node address

tnpopnrmtnode:
	TESTB	AH, #PAR$GET
	JE	6$.S
	MOVL	EAX, dcb_ipsrmtaddr.B[EDI]
	XCHGB	AL, AH
	RORL	EAX, #16t
	JMP	2$.S
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	tnpclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

$$$=!0
FRM xc_error  , 4t
FRM xc_temp   , 4t
FRM xc_pktsize, 4t
xc_SIZE=!$$$

tnpclose:
	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Have any input available now?
	JE	2$.S			;No
	CALL	tnprcvblk		;Yes - get the complete message
	JC	4$.S			;If error reported
	CALL	proterr			;No error - this should not be possible
	JMP	4$.S			;  so report it as a protocol error!

2$:	CLRL	EAX
4$:	CMPL	dcb_opencnt.B[EDI], #1.B ;Final close?
	JNE	20$			;No
	TESTB	dcb_tcpsts1.B[EDI], #TCPS1$FATAL ;Yes - is the TNP level alive?
	JNE	5$.S			;No
	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;Yes - what about TCP?
5$:	JNE	18$			;No
	MOVL	ESI, dcb_netpdb.B[EDI]	;Yes - point to the PDB
	MOVL	EAX, dcb_ipsrmtaddr.B[EDI] ;Using the default remote address?
	CMPL	pdb_ipdripa.B[ESI], EAX
	JNE	8$.S			;No
	TESTB	pdb_ipsts1[ESI], #PS1$HOSTDOWN ;Yes - is it available?
	JNE	hostgone		;No - fail
8$:	ENTER	xc_SIZE, 0		;Yes
	MOVL	xc_error.B[EBP], EAX	;Store error code
	CALL	tnppush
	MOVL	ECX, #6			;Allocate space for the close command
	MOVL	EAX, #TIMEOUT_CON
	CALL	xostcpAlloc##
	JC	10$.S			;If error
	MOVL	EAX, #80060000h+{TNPF_CLOSE<8}
	CALL	xostcpPutLong##
	MOVL	EAX, #1
	CALL	xostcpPutWord##
	CALL	tnppush			;Send the data
	JC	14$.S			;If error
	CALL	tnprcvblk		;Get the response
	JC	14$.S			;If error
	CMPB	AL, #TNPF_RESPN		;It must be a response
	JNE	12$.S
	MOVL	xc_pktsize.B[EBP], ECX
	SUBL	xc_pktsize.B[EBP], #3.B	;Must have at least the status byte and
	JS	12$.S			;  file handle
	CALL	xostcpGetByte##		;Get status byte
	JC	14$.S
	CMPB	AL, #0			;It must be 0!
	JNE	12$.S
	CALL	xostcpGetByte##		;Get and discard the file handle
	JC	14$.S
	CALL	xostcpGetByte##
	JC	14$.S
	CMPL	xc_pktsize.B[EBP], #2.B	;If have more, it must be the error code
	JNE	12$.S
	CALL	xostcpGetByte##		;Get first error code byte
10$:	JC	14$.S
	MOVB	xc_temp+1.B[EBP], AL
	CALL	xostcpGetByte##		;Get second error code byte
	JC	14$.S
	MOVB	xc_temp+0.B[EBP], AL
	MOVXWL	EAX, xc_temp.B[EBP]	;Get error code
	CMPL	EAX, #0.B		;Must not be greater than 0
	JLE	14$.S	
12$:	CALL	proterr			;Indicate fatal error
14$:	CMPL	xc_error.B[EBP], #0.B	;Already have an error?
	JE	16$.S			;No
	MOVL	EAX, xc_error.B[EBP]	;Yes - return original error
16$:	LEAVE
18$:	PUSHL	EAX
	CALL	xostcpClear##		;Clear the TCP connection
	POPL	EAX
20$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
ret020:	RET
.PAGE
;Here for the sd_inpblock entry - input block
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	tnpinpblock
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

$$$=!0
FRM xi_count , 4
FRM xi_iosize, 4
FRM xi_amount, 4
xi_SIZE=!$$$

tnpinpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock the buffer pages
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_inpframe
	MOVL	iorb_routine.B[ESI], #tnpinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here in extended fork context

tnpinpblk1:
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP
	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Have any input available now?
	JE	4$.S			;No
	CALL	tnprcvblk		;Yes - get the complete message
	JC	10$.S			;If error
	CALL	proterr
	JMP	10$.S

;Here if don't have any input pending

4$:	CMPL	SS:xffParm##+0, #0.B	;Have any parameters?
	JE	6$.S			;No
	MOVL	EBX, #tnpioparms	;Yes - process the parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	10$.S			;If error
6$:	CMPL	SS:xffCount##, #0.B	;OK - really want to do input?
	JNE	12$.S			;Yes
8$:	CLRL	EAX			;No
10$:	CLRL	ECX			;Report nothing received
	MOVL	EBX, #QSTS$DONE
	RET				;And return

;Here if host is no longer available

hostgone:
	CALL	xostcpFatal##		;Indicate fatal error
	MOVL	EAX, #ER_NHSNA
	JMP	10$.S

;Here if really want to do input

12$:	TESTB	SS:xffCmd##, #O$IN	;Yes - is input allowed?
	JE	knlIllInp##		;No - fail
	MOVL	ESI, dcb_netpdb.B[EDI]	;Point to the PDB
	MOVL	EAX, dcb_ipsrmtaddr.B[EDI] ;Using the default remote address?
	CMPL	pdb_ipdripa.B[ESI], EAX
	JNE	14$.S			;No
	TESTB	pdb_ipsts1[ESI], #PS1$HOSTDOWN ;Yes - is it available?
	JNE	hostgone.S		;No - fail
14$:	ENTER	xi_SIZE, 0		;Yes - set up our stack frame
	CLRL	EAX			;Clear amount received
	MOVL	xi_amount.B[EBP], EAX
16$:	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Have any input available now?
	JE	18$.S			;No
	CALL	tnprcvblk		;Yes - get the complete message (this
					;  must be an error message)
	JC	20$.S			;If error (which it should be)
	JMP	40$			;Serious error if this message did not
					;  report an error

;Here if no input is pending

18$:	MOVL	EAX, dcb_tnpreqpos[EDI]	;Trying to read past EOF?
	CMPL	EAX, dcb_tnpfilelen[EDI]
	JB	22$.S			;No
	CMPL	xi_amount.B[EBP], #0.B	;Yes - have anything yet?
	JNE	32$			;Yes - return what we have
	MOVL	EAX, #ER_EOF		;No - error = End Of File
20$:	JMP	34$

22$:	MOVL	ECX, #7			;Assume do not need to change position
	MOVL	EAX, dcb_tnpreqpos[EDI]	;Has the file position been changed?
	CMPL	EAX, dcb_tnpcurpos[EDI]
	JE	24$.S			;No
	MOVL	dcb_tnpcurpos[EDI], EAX	;Yes - remember new position
	ADDL	ECX, #4.B		;Increase header size
24$:	MOVL	xi_iosize.B[EBP], ECX
	CALL	xostcpAlloc##		;Allocate space for the data request
	JC	42$			;If error
	MOVL	EAX, xi_iosize.B[EBP]	;Get size of block
	ORB	AH, #80h		;Set high bit to indicate command
	CALL	xostcpPutWord##
	MOVB	AL, #TNPF_DREQ		;Store command
	CALL	xostcpPutByte##
	MOVL	EAX, #1			;Store file handle
	CALL	xostcpPutWord##
	MOVL	EAX, SS:xffCount##	;Get amount wanted
	CMPL	EAX, #TNPMXSIZE		;Too large?
	JBE	26$.S			;No
	MOVL	EAX, #TNPMXSIZE		;Yes - just ask for as much as we can
26$:	CALL	xostcpPutWord##
	CMPL	xi_iosize.B[EBP], #7.B	;Need position?
	JE	28$.S			;No
	MOVL	EAX, dcb_tnpcurpos[EDI]	;Yes
	CALL	xostcpPutLong##		;Store position in block
28$:	CALL	tnppush			;Send the packet
	JC	42$			;If error
	CALL	tnprcvblk		;Get the response
	JC	38$.S			;If error
	JNE	40$.S			;OK - did we get a data block?
	SUBL	SS:xffCount##, ECX	;Yes - bigger than we wanted?
	JC	40$.S			;Yes - serious error!
	ADDL	dcb_tnpcurpos[EDI], ECX ;Bump position in file
	ADDL	dcb_tnpreqpos[EDI], ECX
30$:	LESL	EBX, SS:xffBuffer1##
	PUSHL	ECX
	MOVL	EAX, #TIMEOUT_AP	;Get time-out value
	CALL	xostcpGetBlk##		;Give the data to the user
	POPL	EDX
	JC	36$.S			;If error
	ADDL	SS:xffBuffer1##, ECX
	ADDL	xi_amount.B[EBP], ECX
	SUBL	EDX, ECX		;Need more from this message?
	MOVL	ECX, EDX
	JNE	30$.S			;Yes
	CMPL	SS:xffCount##, #0.B	;No - need another message?
	JNE	16$			;Yes - continue
32$:	CLRL	EAX
34$:	MOVL	ECX, xi_amount.B[EBP]
	MOVL	EBX, #QSTS$DONE
	LEAVE
	RET

;Here if error return from tcpgetblk

36$:	ADDL	xi_amount.B[EBP], ECX
	JMP	34$.s

;Here if error returned by tnprcvblk

38$:	CMPL	EAX, #ER_EOF.B		;End of file?
	JNE	34$.S			;No - just report the error
	CMPL	xi_amount.B[EBP], #0.B	;Yes - did we get any data?
	JE	34$.S			;No - report the EOF
	JMP	32$.S			;Yes - just give him what we got

;Here if have fatal protocol error

40$:	CALL	proterr
	JMP	34$.S

;Here if have other fatal error

42$:	CALL	xostcpFatal##
	JMP	34$.S
.PAGE
	.SBTTL	tnpoutstr - Queued output null terminated string

;Here for the sd_outstring entry - output null terminated string
;	c{EDI}    = Offset of DCB
;	c{FS:EDX} = Address of QAB
;	CALL	tnpoutstr
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

tnpoutstr:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoStringLock##	;Lock the string pages
	JNC	4$.S			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	tnpoutblk - Queued output block

;Here for the sd_outblock entry - output block
;	c{ESI} = Offset of QAB
;	c{EDI} = Offset of DCB
;	CALL	tnpoutblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

$$$=!0
FRM xo_count  , 4t
FRM xo_iosize , 4t
FRM xo_amount , 4t
FRM xo_error  , 4t
FRM xo_pktsize, 4t
xo_SIZE=!$$$

tnpoutblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock the buffer pages
	JC	2$.S
4$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #tnpoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context

6$:	CLRL	EAX
8$:	CLRL	ECX			;Report nothing received
	MOVL	EBX, #QSTS$DONE
	RET				;And return

;Here in extended fork context

tnpoutblk1:
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP
	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Have any input available now?
	JE	10$.S			;No
	CALL	tnprcvblk		;Yes - get the complete message
	JC	8$.S			;If error
	CALL	proterr
	JMP	8$.S

;Here if no input is pending

10$:	CMPL	SS:xffParm##+0, #0.B	;Have any parameters?
	JE	12$.S			;No
	MOVL	EBX, #tnpioparms	;Yes - process the parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	8$.S			;If error
12$:	MOVL	ECX, SS:xffCount##	;Get count
	JREGZ	ECX, 6$			;If not really doing output
	TESTB	SS:xffCmd##, #O$OUT	;Is output allowed?
	JE	knlIllOut##		;No - fail
	MOVL	ESI, dcb_netpdb.B[EDI]	;Yes - point to the PDB
	MOVL	EAX, dcb_ipsrmtaddr.B[EDI] ;Using the default remote address?
	CMPL	pdb_ipdripa.B[ESI], EAX
	JNE	14$.S			;No
	TESTB	pdb_ipsts1[ESI], #PS1$HOSTDOWN ;Yes - is it available?
	JNE	hostgone		;No - fail
14$:	ENTER	xo_SIZE, 0
	CLRL	EAX
	MOVL	xo_amount.B[EBP], EAX
	MOVL	EAX, dcb_tnpreqpos[EDI]	;Has the file position been changed?
	CMPL	EAX, dcb_tnpcurpos[EDI]
	JE	26$			;No
	CMPL	EAX, dcb_tnpfilelen[EDI] ;Yes - past end of file?
	JBE	16$.S			;No
	MOVL	EAX, dcb_tnpfilelen[EDI] ;Yes - write at end of file
	MOVL	dcb_tnpreqpos[EDI], EAX
16$:	MOVL	dcb_tnpcurpos[EDI], EAX	;We need to send command first
	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Have any input available now?
	JE	20$.S			;No
	CALL	tnprcvblk		;Yes - get the complete message
	JC	24$			;If error
	JMP	proterr

;Here if no input is available

20$:	MOVL	ECX, #9.B
	MOVL	EAX, SS:xffTimeOut##
	CALL	xostcpAlloc##		;Allocate space for the position command
	JC	24$.S			;If error
	ORB	CH, #80h
	XCHGB	CH, CL
	MOVL	EAX, #8009h		;Store block count
	CALL	xostcpPutWord##
	MOVB	AL, #6			;Store function
	CALL	xostcpPutByte##
	MOVL	EAX, #1			;Store file handle (always 1 for now!)
	CALL	xostcpPutWord##
	MOVL	EAX, dcb_tnpcurpos[EDI]	;Get position
	CALL	xostcpPutLong##		;Store it
	CALL	tnppush			;Send the packet
	JC	24$.S			;If error
	CALL	tnprcvblk		;Get the response
	JC	24$.S			;If error
	CMPB	AL, #TNPF_RESPN		;It must be a response
22$:	JNE	36$
	SUBL	ECX, #3.B		;Do we have enough data here?
	JL	22$.S			;No - fail!
	MOVL	xo_pktsize.B[EBP], ECX	;OK - remember amount left
	CALL	xostcpGetByte##		;Get and discard status byte
	JC	24$.S
	CALL	xostcpGetByte##		;Get and discard file handle!
	JC	24$.S
	CALL	xostcpGetByte##
24$:	JC	28$.S
	CMPL	xo_pktsize.B[EBP], #0.B	;Have error code?
	JE	26$.S			;No - all done here
	CMPL	xo_pktsize.B[EBP], #2.B	;Yes - have right amount?
	JNE	36$			;No - fail
	CALL	xostcpGetByte##		;Yes - get next byte
	JC	30$.S
	MOVB	xo_error+1.B[EBP], AL	;Remember high byte of error code
	CALL	xostcpGetByte##		;Get next byte
	JC	30$.S
	MOVB	xo_error+0.B[EBP], AL	;Remember low byte of error code
	MOVXWL	EAX, xo_error.B[EBP]
	TESTL	EAX, EAX
	JS	34$

;Here with position in file set

26$:	MOVL	ECX, SS:xffCount##	;Get amount to output
	CMPL	ECX, #TNPMXSIZE		;Too large?
	JB	28$.S			;No
	MOVL	ECX, #TNPMXSIZE		;Yes - just output as much as we can
28$:	MOVL	xo_count.B[EBP], ECX	;Store amount to get from user
	SUBL	SS:xffCount##, ECX	;Reduce amount to output
	ADDL	dcb_tnpcurpos[EDI], ECX	;Bump position in file
	ADDL	dcb_tnpreqpos[EDI], ECX
	MOVL	EAX, SS:xffTimeOut##
	CALL	xostcpChkWin##		;Make sure window is open
	JC	34$.S			;If error
	ADDL	ECX, #4			;Allocate space for the message
	CALL	xostcpAlloc##
30$:	JC	34$.S			;If error
	MOVL	EAX, xo_count.B[EBP]	;Get count
	ADDL	EAX, #4.B
	SHLL	EAX, #16t
	MOVB	AL, #1			;Get file handle
	CALL	xostcpPutLong##		;Store it all
	LESL	EBX, SS:xffBuffer1##
	MOVL	ECX, xo_count.B[EBP]
	CALL	xostcpPutBlk##		;Output the data
	JC	34$.S			;If error
	CALL	tnppush			;Force out the packet
	JC	34$.S
	MOVL	EAX, xo_count.B[EBP]	;Add into amount done
	ADDL	xo_amount.B[EBP], EAX
	ADDL	SS:xffBuffer1##, EAX	;Bump position in buffer
	CMPL	SS:xffCount##, #0.B	;Have any more to output now?
	JNE	26$			;Yes - continue
	MOVL	EAX, dcb_tnpcurpos[EDI]	 ;No - finished - has file been
	CMPL	dcb_tnpfilelen[EDI], EAX ;  extended?
	JAE	32$.S			;No
	MOVL	dcb_tnpfilelen[EDI], EAX ;Yes
32$:	CLRL	EAX
34$:	MOVL	ECX, xo_amount.B[EBP]
	MOVL	EBX, #QSTS$DONE
	LEAVE
	RET

;Here if fatal protocol error

36$:	CALL	proterr			;Positive - fatal error!
	JMP	34$.S
.PAGE
;Here for IOPAR_ABSPOS for IO transfer - Absolute position in file

	DPARMHDR  BOTH, DECV
tnpiopabspos:
	TESTB	AH, #PAR$SET		;Want to change value?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get value for position
	JC	6$.S
	MOVL	dcb_tnpreqpos[EDI], EAX	;Store value
2$:	POPL	EAX
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No
	MOVL	EAX, dcb_tnpreqpos[EDI]	;Yes - get value
	JMP	knlStrParm4##		;Give it to him

6$:	POPL	ECX			;Fix up the stack
8$:	RET

;Here for IOPAR_RELPOS for IO transfer - Relative position in file

	DPARMHDR  BOTH, DECV
tnpioprelpos:
	TESTB	AH, #PAR$SET		;Want to change value?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get value for position
	JC	6$.S
	ADDL	dcb_tnpreqpos[EDI], EAX	;Store value
	JMP	2$.S			;Continue

;Here for IOPAR_EOFPOS for IO transfer - Position in file relative to EOF

	DPARMHDR  BOTH, DECV
tnpiopeofpos:
	MOVL	EAX, #ER_PARMI
	STC
	RET

;Here for IOPAR_LENGTH for IO transfer - Written length of file

	DPARMHDR  GET, DECV
tnpioplength:
	MOVL	EAX, dcb_tnpfilelen[EDI]
	JMP	knlStrParm4##

;Here for IOPAR_ADATE for IO transfer - Last access date/time

	DPARMHDR  BOTH, DECV
tnpiopadate:
	MOVL	EAX, #ER_PARMI
	STC
	RET

;Here for IOPAR_CDATE for IO transfer - Creation date/time

	DPARMHDR  BOTH, DECV
tnpiopcdate:
	MOVL	EAX, #ER_PARMI
	STC
	RET

;Here for IOPAR_MDATE for IO transfer - Modify date/time

	DPARMHDR  BOTH, DECV
tnpiopmdate:
	MOVL	EAX, #ER_PARMI
	STC
	RET
.PAGE
	.SBTTL	tnpdelete - Delete file

;Here for SV_delete function - delete file
;	c{SS:EDX} = Address of expanded file name
;	c{EDI}    = Offset of DCB for file to delete or its directory
;	c{ESI}    = Device table offset for file to delete or its directory
;	CALL	tnpdelete
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Item count
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Item count

tnpdelete:
	MOVB	SS:xffQueue##, #dcb_outframe ;Set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	ENTER	opx_SIZE, 2		;Set up a level 2 stack frame
	MOVL	opx_filspec.B[EBP], EDX
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	CLRL	EAX
	MOVL	opx_opsize.B[EBP], EAX
	MOVL	opx_flength.B[EBP], EAX
	MOVL	opx_fdate.B[EBP], EAX
	MOVL	opx_ftime.B[EBP], EAX
	MOVL	opx_itemcnt.B[EBP], EAX	;Clear item count
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%LCLPORT ;Was a local port specified?
	JNC	6$.S			;No
	MOVL	EAX, opx_frame1.B[EBP]	;Yes
	MOVL	ECX, SS:opn_lclport.B[EAX] ;Get the local port number
	PUSHL	EDX
	CALL	xosipsGetPort##
	POPL	EDX
6$:	CALL	chkspec			;Get length of file specification
	JC	tcplv.S
	MOVL	opx_filspsz.B[EBP], ECX
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Want to search open directory?
	JC	10$.S			;Yes
	MOVL	EAX, #1024t		;No - get window sizes
	MOVB	CL, #2
	CALL	xostcpConnect##		;Establish the TCP connection
	JC	tcplv.S			;If error
10$:	MOVL	ECX, opx_filspsz.B[EBP]
	ADDL	ECX, #6.B		;Add space for rest of command stuff
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL
	JNC	12$.S
	ADDL	ECX, #4.B
12$:	MOVL	EAX, #TIMEOUT_CON
	CALL	xostcpAlloc##		;Allocate space for the open command
	JC	opendn			;If error
	MOVL	EAX, opx_filspsz.B[EBP]	;Store command header
	ADDL	EAX, #8006h
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL
	JNC	14$.S
	ADDL	EAX, #4.B
14$:	CALL	xostcpPutWord##
	MOVL	EAX, #TNPF_DELETE<24t	;Get function
	CALL	strbitx
	JMP	open6

tcplv:	CLRL	ECX
	STC
	LEAVE
	RET
.PAGE
	.SBTTL	tnprename - Rename file

;Here for SV_RENAME function - Rename file
;	c{SS:ESI} = Address of buffer containing processed new name
;	c{ECX}    = Option bits
;	c{SS:EDX} = Address of expanded file specification
;	c{EDI}    = Offset of DCB for old file or directory
;	CALL	tnprename
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Item count
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Item count

tnprename:
	MOVB	SS:xffQueue##, #dcb_outframe ;Set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	ENTER	opx_SIZE, 2		;Set up a level 2 stack frame
	MOVL	opx_nfilspec.B[EBP], ESI ;Store offset of new name
	MOVL	opx_filspec.B[EBP], EDX	;Store offset of old name
	CLRL	EAX
	MOVL	opx_itemcnt.B[EBP], EAX	;Clear item count
	MOVL	opx_opsize.B[EBP], EAX
	MOVL	opx_flength.B[EBP], EAX
	MOVL	opx_fdate.B[EBP], EAX
	MOVL	opx_ftime.B[EBP], EAX
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%LCLPORT ;Was a local port specified?
	JNC	6$.S			;No
	MOVL	EAX, opx_frame1.B[EBP]	;Yes
	MOVL	ECX, SS:opn_lclport.B[EAX] ;Get the local port number
	PUSHL	EDX
	CALL	xosipsGetPort##
	POPL	EDX
6$:	CALL	chkspec			;Get length of old file specification
	JC	tcplv.S
	MOVL	opx_filspsz.B[EBP], ECX	;Save it
	MOVL	EDX, opx_nfilspec.B[EBP] ;Get length of new file specification
	CALL	chkspec
8$:	JC	tcplv.S
	MOVL	opx_nfilspsz.B[EBP], ECX
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Want to search open directory?
	JC	10$.S			;Yes
	MOVL	EAX, #1024t		;No - get window sizes
	MOVB	CL, #2
	CALL	xostcpConnect##		;Establish the TCP connection
	JC	8$.S			;If error
	MOVL	EDX, opx_filspec.B[EBP]
10$:	MOVL	ECX, opx_nfilspsz.B[EBP]
	ADDL	ECX, opx_filspsz.B[EBP]
	ADDL	ECX, #8.B		;Add space for rest of command stuff
	MOVL	EAX, #TIMEOUT_CON
	CALL	xostcpAlloc##		;Allocate space for the open command
	JC	opendn			;If error
	MOVL	EAX, opx_filspsz.B[EBP]
	ADDL	EAX, opx_nfilspsz.B[EBP]
	ADDL	EAX, #8008		;Store command header
	CALL	xostcpPutWord##
	MOVL	EAX, #TNPF_RENAME<24t	;Get function
	CALL	strbitx
	MOVL	EDX, opx_filspec.B[EBP]
	MOVL	EAX, opx_filspsz.B[EBP]
	CALL	storespec		;Store old file specification in packet
	MOVL	EDX, opx_nfilspec.B[EBP]
	MOVL	EAX, opx_nfilspsz.B[EBP] ;Store new file specification in packet
	JMP	open8
.PAGE
	.SBTTL	tnpspecial - Special device function for TNP

;Here for the QFNC_special queued IO function for disks - Do special device
;  functions
;  QAB fields used:
;	qab_option:	Low 8 bits contain sub-function, high 24 bits may be
;			  used to modify sub-function
;	qab_count:	May be used to pass single 32 bit argument value
;	qab_buffer1:	Pointer to argument/result buffer
;  Contents of qab_amount depends on function

tnpspecial:
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #tnpspec1
	JMP	knlXfQueue##		;Switch to extended fork context

tnpspec1:
	MOVZBL	EAX, SS:xffOption##	;Get sub-function
	CMPL	EAX, #TNPSFMAX.B	;Legal sub-function?
	JAE	knlIFnDev##		;No
	JMPIL	tnpsfdsp[EAX*4]		;Yes - dispatch on the subfunction

;Dispatch table for special device functions for TNP

	DATA

tnpsfdsp:
	.LONG	knlIFnDev##	;	      = 0. - Illegal
	.LONG	tnpcksum	;NS_CKSUM = 1. - Get file checksum value
TNPSFMAX=!{$-tnpsfdsp}/4

	CODE
.PAGE
;Here for the NS_CKSUM function - Get file checksum value
;	qab_count   = Checksum type: 0 = image, 1 = LF alpha, 2 = binary
;	qab_buffer1 = Pointer to 8 byte result buffer:
;		Offset  Size        Use
;		   0     4     File length (returned)
;		   4     4     File checksum (returned)
;  On return:
;	qab_amount = 0

2$:	MOVL	EAX, #ER_FUNC
4$:	JMP	20$

tnpcksum:
	MOVL	EAX, SS:xffCount##	;Get checksum type
	CMPL	EAX, #2.B		;Valid value?
	JA	2$.S			;No - fail
	PUSHL	EAX			;Yes - save type
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	MOVL	ECX, #6			;Allocate packet for the checksum
	CALL	xostcpAlloc##		;  request command
	JC	5$.S			;If error
	MOVL	EAX, #80060000+{TNPF_CKSUMREQ<8}
	CALL	xostcpPutLong##
5$:	POPL	EDX			;Restore checksum type
	JC	4$.S
	MOVB	AH, #1			;Get file handle
	MOVB	AL, DL
	CALL	xostcpPutWord##
	CALL	tnppush			;Send the packet
	JC	4$.S			;If error
	CALL	tnprcvblk		;Get the response
	JC	4$.S			;If error
	CMPB	AL, #TNPF_CKSUMRSP	;It must be a checksum response
	JNE	6$.S
	SUBL	ECX, #10t.B		;Do we have the right amount of data?
6$:	JNE	22$.S			;No - fail!
	CALL	xostcpGetByte##		;Skip file handle field
	JC	20$.S
	CALL	xostcpGetByte##
	JC	20$.S
	LESL	EBX, SS:xffBuffer1##	;Get address of response buffer
	MOVL	ECX, #8
	ADDL	EBX, ECX		;Point to end of buffer
10$:	PUSHL	ES
	PUSHL	EBX
	PUSHL	ECX
	CALL	xostcpGetByte##		;Get next byte
	POPL	ECX
	POPL	EBX
	POPL	ES
	JC	20$.S
	DECL	EBX
	MOVB	ES:[EBX], AL		;Store byte
	LOOP	ECX, 10$
	CLRL	EAX			;Give good return
20$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

;Here if protocol error

22$:	CALL	proterr
	JMP	20$.S
.PAGE
	.SBTTL	strbitx - Subroutine to store command bits for delete and rename

;Subroutine to store command bits for delete and rename
;	c{EAX} = Initial header bits
;	CALL	strbitx
;	c{EAX} = Final header bits

strbitx:CALL	getbits			;Get the bits
	ANDL	EAX, #0FFF9FFFFh	;Remove unwanted bits
	BTL	EAX, #TNPO%REPEAT	;Want to repeat?
	JNC	4$.S			;No
	BTSL	EAX, #17t		;Yes - set the right bit
4$:	SHRL	EAX, #16t		;Get in in the right place
	JMP	xostcpPutWord##		;Store bits and return
.PAGE
	.SBTTL	getbits - Subroutine to get command bits for open

;Subroutine to get command bits for open
;	c{EAX} = Initial header bits
;	CALL	getbits
;	c{EAX} = Final header bits

getbits:MOVL	EDX, SS:xffCmd##	;Get device command bits
	MOVL	ECX, #CMDTBLSZ		;Get number of command bits to check
	MOVL	EBX, #cmdtbl		;Point to table of bits
2$:	TESTL	EDX, [EBX]		;Do we want this bit?
	JE	4$.S			;No
	ORL	EAX, 4.B[EBX]		;Yes
4$:	ADDL	EBX, #8.B		;Bump pointer
	LOOP	ECX, 2$
	MOVL	EDX, SS:xffPVFilOpt##	;Get file option bits
	MOVB	CL, #FOPTBLSZ		;Get number of option bits to check
6$:	TESTL	EDX, [EBX]		;Do we want this bit?
	JE	8$.S			;No
	ORL	EAX, 4.B[EBX]		;Yes
8$:	ADDL	EBX, #8.B		;Bump pointer
	LOOP	ECX, 6$
	MOVL	EDX, SS:xffNdValue1##	;Get value request bits
	MOVB	CL, #IOVTBLSZ		;Get number of option bits to check
10$:	TESTL	EDX, [EBX]		;Do we want this bit?
	JE	12$.S			;No
	ORL	EAX, 4.B[EBX]		;Yes
12$:	ADDL	EBX, #8.B		;Bump pointer
	LOOP	ECX, 10$
	RET
.PAGE
	.SBTTL	chkspec - Subroutine to get length of file spec. and check for wild cards

;Subroutine to get length of file specification
;	c{SS:EDX} = Address of file specification
;	CALL	chkspec
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of file specification

chkspec:MOVL	ESI, EDX
	CLRL	ECX
2$:	LODSB	SS:[ESI]
	CMPB	AL, #0
	JE	6$.S
	CMPB	AL, #'{'
	JE	4$.S
	CMPB	AL, #'}'
	JE	4$.S
	INCL	ECX
	JMP	2$.S

;Here if have illegal character if file specification

4$:	MOVL	EAX, #ER_BDSPC
	STC
6$:	RET
.PAGE
	.SBTTL	storespec - Subroutine to store file specification

;Subroutine to store file specification in command block
;	c{EAX}    = Length of file specification
;	c{SS:EDX} = Address of file specification
;	CALL	storespec

storespec:
	PUSHL	EAX
	PUSHL	EDX
	CALL	xostcpPutWord##		;Store length of file specification
	POPL	EBX
	POPL	ECX
	PUSHL	SS
	POPL	ES
	JMP	xostcpPutBlk##		;Store file specification
.PAGE
	.SBTTL	tnppush - Subroutine to output TNP block

;Subroutine to output TNP block
;	c{EDI} = Offset of DCB
;	CALL	tnppush
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

tnppush:MOVL	EAX, SS:xffTimeOut##	;Get time-out value
	CALL	xostcpPush##		;Send the TCP packet
	JC	6$.S			;If error
	SUBL	ECX, #3.B		;OK - get length of TCP part output
	JLE	4$.S			;If none
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the transmitted message
	ADDL	dpdb_tcptnpcntbyteout.B[EAX], ECX
	INCL	dpdb_tcptnpcntmsgout.B[EAX]
4$:	CLC
6$:	RET
.PAGE
	.SBTTL	tnprcvblk - Subroutine to get received TNP block

;Subroutine to get received TNP block - must be called at fork level with
;  nothing on the stack
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IDB
;	CALL	tnprcvblk
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Block type (0 = data block, not received yet; otherwise
;		   command block, completely received)
;	  c{ECX} = Block size

tnprcvblk:
	PUSHL	#0.B
	CALL	xostcpGetByte#		;Get first count byte
	JC	2$.S
	MOVB	1.B[ESP], AL
	CALL	xostcpGetByte##		;Get second count byte
	JC	2$.S
	MOVB	[ESP], AL
	BTZL	[ESP], #15t		;Is this a data or command block?
	JC	4$.S			;If a command block
	SUBL	[ESP], #4.B		;Data block - adjust size
	JLE	8$.S
	CALL	xostcpGetByte##		;Get and discard the file handle!
	JC	2$.S
	CALL	xostcpGetByte##
	JC	2$.S
	POPL	ECX			;Get count in right register
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the received message
	INCL	dpdb_tcptnpcntmsgin.B[EAX]
	ADDL	dpdb_tcptnpcntbytein.B[EAX], ECX
	INCL	dpdb_tcptnpcntbytein.B[EAX]
	CLRL	EAX			;Type = 0
	RET

;Here if error

2$:	POPL	ECX
	RET

;Here if have a command block

4$:	SUBL	[ESP], #3.B		;Adjust block size
	JL	8$.S
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the received message
	INCL	dpdb_tcptnpcntmsgin.B[EAX]
	MOVL	ECX, [ESP]
	ADDL	dpdb_tcptnpcntbytein.B[EAX], ECX
	CALL	xostcpGetByte##		;Get the function byte
	JC	2$.S
	CMPB	AL, #TNPF_EOF		;End of file?
	JE	10$.S			;Yes
	CMPB	AL, #TNPF_ERROR		;Error indication?
	JE	12$.S			;Yes - go handle that
	CLC				;No - give normal return
	POPL	ECX
6$:	RET

;Here if have fatal protocol error

8$:	POPL	EAX
proterr:MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the protocol error
	INCL	dpdb_tcptnpcntfprot[EAX]
	MOVL	EAX, #ER_NPERR
	JMP	xostcpFatal##		;Indicate fatal error

;Here if have end of file response

10$:	POPL	EAX
	CMPL	EAX, #3.B		;Is the length right?
	JNE	8$.S			;No
	CALL	xostcpGetByte##		;Yes - get and discard status byte
	JC	6$.S
	CALL	xostcpGetByte##		;Get and discard the file handle!
	JC	6$.S
	CALL	xostcpGetByte##
	JC	6$.S
	MOVL	EAX, #ER_EOF		;Get error code
	STC
	RET

;Here if have general error indication

12$:	CMPL	[ESP], #5.B		;Is the length right?
	JNE	8$.S			;No
	CALL	xostcpGetByte##		;Yes - get and discard status byte
	JC	6$.S
	CALL	xostcpGetByte##		;Get and discard the file handle!
	JC	6$.S
	CALL	xostcpGetByte##
	JC	6$.S
	CALL	xostcpGetByte##		;Get high byte of error code
	JC	6$.S
	MOVB	1.B[ESP], AL
	CALL	xostcpGetByte##		;Get low byte of error code
	JC	6$.S
	MOVB	[ESP], AL
	POPL	EAX
	CWL				;Expand to 32 bits
	TESTL	EAX, EAX		;Negative?
	JNS	18$.S			;No - say protocol error!
	CMPL	EAX, #MAXERR		;Yes - is this one in our table?
	JL	16$.S			;No - just return it as-is!
	MOVXWL	EAX, errtbl[EAX*2]	;Yes - get translated error code
16$:	STC				;Indicate error
	RET

18$:	MOVL	EAX, #ER_NPERR
	STC
	RET
.PAGE
	.SBTTL	Data

	DATA

tnpccb:     .BLKB ccb_SIZE	;TNP CCB
tnpdpdbhead:.LONG 0		;Offset of first TNP DPDB

MAXERR=!-138t
	.WORD	ER_VALUE	; -138 - Illegal value
	.WORD	ER_NTIMP	; -137 - Not implemented
	.WORD	ER_ERROR	; -136 - Too many arguments
	.WORD	ER_PARMM	; -135 - Required parameter missing
	.WORD	ER_NSTYP	; -134 - No such device type
	.WORD	ER_IMEMA	; -133 - Illegal memory address
	.WORD	ER_NOPAP	; -132 - Printer is out of paper
	.WORD	ER_NCOMP	; -131 - Not compatible
	.WORD	ER_ALDEF	; -130 - Already allocated
	.WORD	ER_NOMEM	; -129 - No memory allocated
	.WORD	ER_IDSPC	; -128 - Illegal destination file specification
	.WORD	ER_IINUM	; -127 - Illegal interrupt number
	.WORD	ER_NMBTS	; -126 - Name buffer is too small
	.WORD	ER_ERROR	; -125 - Too many users for device
	.WORD	ER_ERROR	; -124 - Unspecified general error
	.WORD	ER_FILRF	; -123 - Cannot rename file
	.WORD	ER_FILXF	; -122 - Cannot extend file
	.WORD	ER_FILCF	; -121 - Cannot create file
	.WORD	ER_FILAF	; -120 - Cannot access file
	.WORD	ER_IDREN	; -119 - Invalid directory rename
	.WORD	ER_CDAND	; -118 - LKE common data area not defined
	.WORD	ER_ERROR	; -117 - LKE load resource is in use
	.WORD	ER_XFRBK	; -116 - Data transfer blocked
	.WORD	ER_INCMO	; -115 - Incomplete output operation
	.WORD	ER_NHSNA	; -114 - Network host not available
	.WORD	ER_NCLST	; -113 - Network connection lost
	.WORD	ER_NTTIM	; -112 - Network time out
	.WORD	ER_NSNOD	; -111 - No such network node
	.WORD	ER_NRTER	; -110 - Network routing error
	.WORD	ER_NCONG	; -109 - Network congestion
	.WORD	ER_NPERR	; -108 - Illegal network access requested
	.WORD	ER_NPERR	; -107 - Incompatible request
	.WORD	ER_NILRF	; -106 - Illegal request format
	.WORD	ER_NILAD	; -105 - Illegal network address
	.WORD	ER_NILPR	; -104 - Illegal socket number
	.WORD	ER_NPRIU	; -103 - Socket or channel not idle
	.WORD	ER_NPRNO	; -102 - Socket or channel not open
	.WORD	ER_NPERR	; -101 - Network protocol error
	.WORD	ER_TMDVC	; -100 - Too many devices open for device class
	.WORD	ER_ERROR	;  -99 - Device already setup for buffered IO
	.WORD	ER_CLSAD	;  -98 - Device class already defined
	.WORD	ER_NSCLS	;  -97 - No such device class
	.WORD	ER_DUADF	;  -96 - Device unit already defined
	.WORD	ER_PDADF	;  -95 - Physcial device already defined
	.WORD	ER_PDNAV	;  -94 - Physical device not available
	.WORD	ER_ERROR	;  -93 - Buffer or buffer header block error
	.WORD	ER_TMPSS	;  -92 - Too many processes or shared segments in system
	.WORD	ER_NORSP	;  -91 - Time-out error
	.WORD	ER_NTLNG	;  -90 - Name is too long
	.WORD	ER_WLDNA	;  -89 - Wild card name not allowed
	.WORD	ER_BDLNM	;  -88 - Bad logical name
	.WORD	ER_NTDEF	;  -87 - Not defined
	.WORD	ER_FSINC	;  -86 - File system is inconsistant
	.WORD	ER_ERROR	;  -85 - Process has too many messages waiting
	.WORD	ER_ERROR	;  -84 - Process not enabled to receive messages
	.WORD	ER_ERROR	;  -83 - Requested message not available
	.WORD	ER_NTFIL	;  -82 - Not a file structured device
	.WORD	ER_DRWER	;  -81 - Directory write error
	.WORD	ER_DRRER	;  -80 - Directory read error
	.WORD	ER_DRFER	;  -79 - Directory format error
	.WORD	ER_SBWER	;  -78 - SAT write error
	.WORD	ER_SBRER	;  -77 - SAT read error
	.WORD	ER_SBFER	;  -76 - SAT format error
	.WORD	ER_HMRER	;  -75 - HOM read error
	.WORD	ER_HMFER	;  -74 - HOM format error
	.WORD	ER_FBWER	;  -73 - FIB write error
	.WORD	ER_FBRER	;  -72 - FIB read error
	.WORD	ER_FBPER	;  -71 - FIB pointer error
	.WORD	ER_FBFER	;  -70 - FIB format error
	.WORD	ER_DLOCK	;  -69 - Deadlock error
	.WORD	ER_BPIPE	;  -68 - Pipe error
	.WORD	ER_ILSEK	;  -67 - Illegal seek function
	.WORD	ER_NTTRM	;  -66 - Device is not a terminal
	.WORD	ER_ISDIR	;  -65 - File is a directory
	.WORD	ER_NTDIR	;  -64 - File is not a directory
	.WORD	ER_NTRDY	;  -63 - Device not ready
	.WORD	ER_FMTER	;  -62 - Format error
	.WORD	ER_NACT		;  -61 - Device not active
	.WORD	ER_RTOBG	;  -60 - Record too big
	.WORD	ER_MDCHG	;  -59 - Disk changed
	.WORD	ER_IADEV	;  -58 - Illegal buffer address for device
	.WORD	ER_ICDEV	;  -57 - Illegal count for device
	.WORD	ER_IFDEV	;  -56 - Illegal function for device
	.WORD	ER_NOSTK	;  -55 - No stack specified in image file
	.WORD	ER_NOSAD	;  -54 - No starting address specified in image file
	.WORD	ER_RELTR	;  -53 - Relocation truncation in image file
	.WORD	ER_IIFRD	;  -52 - Illegal relocation data in image file
	.WORD	ER_IIFF		;  -51 - Illegal image file format
	.WORD	ER_IIFT		;  -50 - Illegal image file type
	.WORD	ER_ADRER	;  -49 - Address error
	.WORD	ER_NOIN		;  -48 - Input not allowed
	.WORD	ER_NOOUT	;  -47 - Output not allowed
	.WORD	ER_BDDVH	;  -46 - Bad device descriptor
	.WORD	ER_BDDBK	;  -45 - Bad disk block number
	.WORD	ER_NORSP	;  -44 - Device did not respond
	.WORD	ER_DATTR	;  -43 - Data truncated
	.WORD	ER_DEVER	;  -42 - Device error
	.WORD	ER_WPRER	;  -41 - Write protect error
	.WORD	ER_WRTER	;  -40 - Write fault error
	.WORD	ER_LSTER	;  -39 - Lost data error
	.WORD	ER_RNFER	;  -38 - Record not found error
	.WORD	ER_SEKER	;  -37 - Seek error
	.WORD	ER_IDFER	;  -36 - ID field error
	.WORD	ER_DATER	;  -35 - Data error
	.WORD	ER_DIRTD	;  -34 - Directory level too deep
	.WORD	ER_DIRNE	;  -33 - Directory not empty
	.WORD	ER_DIRFL	;  -32 - Directory full
	.WORD	ER_DIRNF	;  -31 - Directory not found
	.WORD	ER_FILAD	;  -30 - File protection failure
	.WORD	ER_BUSY		;  -29 - File or device is busy
	.WORD	ER_FILEX	;  -28 - File exists
	.WORD	ER_FILNF	;  -27 - File not found
	.WORD	ER_DFDEV	;  -26 - Different device for rename
	.WORD	ER_TMDVP	;  -25 - Too many devices open for process
	.WORD	ER_DEVFL	;  -24 - Device is full
	.WORD	ER_ERROR	;  -23 - Device not assigned
	.WORD	ER_ERROR	;  -22 - Device not open
	.WORD	ER_DEVIO	;  -21 - Device is open
	.WORD	ER_DEVIU	;  -20 - Device in use
	.WORD	ER_NSDEV	;  -19 - No such device
	.WORD	ER_BDSPC	;  -18 - Bad device or file specification
	.WORD	ER_ACT		;  -17 - Device is active
	.WORD	ER_NOBUF	;  -16 - No system buffer available
	.WORD	ER_NOBUF	;  -15 - No queue element available
	.WORD	ER_MAERR	;  -14 - Memory allocation error
	.WORD	ER_MACFT	;  -13 - Memory allocation conflict
	.WORD	ER_NEMA		;  -12 - Not enough memory available
	.WORD	ER_NSEGA	;  -11 - No address space available
	.WORD	ER_PRIV		;  -10 - Not enough privilege
	.WORD	ER_NSP		;   -9 - No such process
	.WORD	ER_BDPID	;   -8 - Bad process ID
	.WORD	ER_BDNAM	;   -7 - Bad process name
	.WORD	ER_FUNCM	;   -6 - Illegal function for current mode
	.WORD	ER_PARMV	;   -5 - Illegal parameter value
	.WORD	ER_PARMI	;   -4 - Illegal parameter name
	.WORD	ER_FUNC		;   -3 - Illegal function
	.WORD	ER_SVC		;   -2 - Illegal SVC function
	.WORD	ER_EOF		;   -1 - End of file
errtbl:	.WORD	ER_NOERR	;    0 - Normal return

	LKEEND
