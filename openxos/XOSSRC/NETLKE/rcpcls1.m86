	.TITLE	RCPCLS1 - RCP routines for XOS (part 1)

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXIPS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXUDP.PAR
	.INCLUD	XOSINC:\XMAC\XOSXRCP.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

;This module implements the RCP transport level protocol.

MAJV   =!2t
MINV   =!0t
EDITNUM=!0t

;1.0.1 - 21-Apr-95
;	Added IOPAR_NETLCLNETA IO parameter.
;1.0.3 - 12-Oct-95
;	Changed keep-alive value to 2 bytes.
;1.0.4 - 1-Apr-96
;	Fixed problem with trying to retransmit a packet which was being
;	output when something ACKed.

	LKEHEAD	RCPCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

	.EXPORT	xosrcpAcceptCon
	.EXPORT	xosrcpAuRcpDev
	.EXPORT	xosrcpChkFin
	.EXPORT	xosrcpGiveDcb
	.EXPORT	xosrcpClear
	.EXPORT	xosrcpConnect
	.EXPORT	xosrcpDfltPort
	.EXPORT	xosrcpGetInputPkt
	.EXPORT	xosrcpGetRcpDev
	.EXPORT	xosrcpGetPort
	.EXPORT	xosrcpGivePort
	.EXPORT	xosrcpMsgRcpDev
	.EXPORT	xosrcpPutConWait
	.EXPORT	xosrcpRmvConWait
	.EXPORT	xosrcpSendCONACK
	.EXPORT	xosrcpTpdbHead

	CODE

	.SBTTL	SVC dispatch table for RCP devices

;SVC dispatch table for RCP devices

rcpdsp::.LONG	knlRtnZero##	;sd_mount	=  0. - Mount
	.LONG	knlRtnZero##	;sd_cleardev	=  4. - Clear device
	.LONG	xosrcpGiveDcb	;sd_cleardcb	=  8. - Clear DCB
	.LONG	knlRtnZero##	;sd_commit	= 12. - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold    = 16. - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew    = 20. - Transfer device/new
	.LONG	rcpopena	;sd_opena	= 24. - Open additional
	.LONG	rcpopen1	;sd_open1	= 28. - Open device/file
	.LONG	rcpdevparm	;sd_devparm     = 32. - Device parameters
	.LONG	knlIFnDev##	;sd_delete	= 36. - Delete file
	.LONG	knlIFnDev##	;sd_rename	= 40. - Rename file
	.LONG	rcpinpblk	;sd_inblock	= 44. - Input block
	.LONG	rcpoutblk	;sd_outblock	= 48. - Output block
	.LONG	rcpoutblk1	;sd_outblockq	= 52. - Output block (XFF)
	.LONG	rcpoutstr	;sd_outstring	= 56. - Output string
	.LONG	knlRtnMOne##	;sd_getiosts	= 60. - Get input/output status
	.LONG	knlIFnDevGQ##	;sd_special     = 64. - Special device function
	.LONG	rcpclose	;sd_close	= 68. - Close file
	.LONG	knlNullLabel##	;sd_label       = 72. - Get device label
	.LONG	knlNullQioGQ##	;sd_commitfunc	= 76. - Commit data to disk
	.LONG	rcpdevinfo	;sd_devinfo     = 80. - Get device info
RCPDSPSZ=!{$-rcpdsp}/4

;Class function dispatch table for RCP class devices

	.LONG	RCPCLSFMX
rcpcls::.LONG	rcpaddunit	;CF_ADDUNIT =  8. - Add unit
	.LONG	rcpunitinfo	;CF_PUNITS  =  9. - Get information about
				;		      physical units
	.LONG	knlIFnDevGQ##	;CF_AUNITS  = 10. - Get information about active
				;		      units
RCPCLSFMX=!{$-rcpcls}/4
.PAGE
;Device characteristics tables for the RCP devices

	DATA

	.MOD	4
rcpdctbl::
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS  , TEXT, , 8, knlDcMsgClass##  , knlDcGetClass##    , knlDcSetClass##    , 0
 DCHARENT  UDPDEV , TEXT, ,16, msgudpdev        , getudpdev          , 0                  , 0
 DCHARENT  RETRY1 , DECV, , 1, xosipsMsgRetry1##, xosipsGetTpdbByte##, xosipsSetTpdbByte##, tpdb_rcpretry1
 DCHARENT  RETRY2 , DECV, , 1, xosipsMsgRetry2##, xosipsGetTpdbByte##, xosipsSetTpdbByte##, tpdb_rcpretry2
 DCHARENT  ACCESS , TEXT, , 4, knlDcMsgAccess## , xosipsGetTpdbData##, setaccess          , tpdb_rcpaccess
 DCHARH    condc  , gethdcdc, findcdc
 DCHARENT  PKTIN  , DECV, , 4, xosnetMsgPktIn## , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntpktin
 DCHARENT  BYTEIN , DECV, , 4, knlDcMsgByteIn## , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntbytein
 DCHARENT  PKTOUT , DECV, , 4, xosnetMsgPktOut##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntpktout
 DCHARENT  BYTEOUT, DECV, , 4, knlDcMsgByteOut##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntbyteout
 DCHARENT  NODST  , DECV, , 4, xosipsMsgNoDst## , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntnodst
 DCHARENT  BADHDR , DECV, , 4, xosipsMsgBadHdr##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntbadhdr
 DCHARENT  BADCONT, DECV, , 4, msgbadcont       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntbadcont
 DCHARENT  PSLTMN , DECV, , 4, xosipsMsgPSLtMn##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntpsltmn
 DCHARENT  OUTSEQ , DECV, , 4, msgoutseq        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntoutseq
 DCHARENT  OUTWIN , DECV, , 4, msgoutwin        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntoutwin
 DCHARENT  FLOWOVR, DECV, , 4, msgflowovr       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntflowovr
 DCHARENT  UNXTYPE, DECV, , 4, msgunxtype       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntunxtype
 DCHARENT  OOSNUM , DECV, , 4, msgoosnum        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntoosnum
 DCHARENT  OOSMAX , DECV, , 4, msgoosmax        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntoosmax
 DCHARENT  REXMIT , DECV, , 4, msgrexmit        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntrexmit
 DCHARENT  RSTSENT, DECV, , 4, msgrstsent       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntrstsent
 DCHARENT  RSTRCVD, DECV, , 4, msgrstrcvd       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntrstrcvd
 DCHARENT  CLOST  , DECV, , 4, msgclost         , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_rcpcntclost

	CODE

msgudpdev:      DCHARINFO  {UDP device}
msgbadcont:     DCHARINFO  {Discarded - bad packet contents}
msgconmsgdst:   DCHARINFO  {Message dest for connect to port}
msgoutseq:      DCHARINFO  {Discarded - out of sequence packets}
msgoutwin:      DCHARINFO  {Discarded - out of window packets}
msgflowovr:     DCHARINFO  {Discarded - flow control overrun}
msgunxtype:     DCHARINFO  {Number of packets of unexpected type}
msgoosnum:      DCHARINFO  {Number of out-of-seq packets queued}
msgoosmax:      DCHARINFO  {Maximum out-of-seq packets queued}
msgrexmit:      DCHARINFO  {Number of retransmitted packets}
msgclost:       DCHARINFO  {Number of lost connections}
msgrstsent:     DCHARINFO  {Number of resets sent}
msgrstrcvd:     DCHARINFO  {Number of resets received}
xosrcpMsgRcpDev:DCHARINFO  {RCP device}
.PAGE
;Device parameter table for RCP open

	.MOD	4
	.LONG	OPARMMAX
rcpopnparms:
	.LONG	rcpopngenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	rcpopnnetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
;;;;	.LONG	0		 ;IOPAR_IPMxxx = 06xx - IPM IO parameters
;;;;	.LONG	rcpmsgparms	 ;IOPAR_MSGxxx = 07xx - Message IO parameters
OPARMMAX=!{$-rcpopnparms}/4

	.LONG	OPARMGENMAX	;Size of table
rcpopngenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopDummyS##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	rcpiopdiscvect	;IOPAR_SIGVECT1    = 000Ch
	.LONG	rcpiopintpvect	;IOPAR_SIGVECT2    = 000Dh
	.LONG	rcpiopvectdata	;IOPAR_SIGDATA     = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
OPARMGENMAX=!{$-rcpopngenparms}/4

	.LONG	OPARMNETMAX
rcpopnnetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	0		;IOPAR_NETPROTOCOL = 0502h
	.LONG	rcpioplclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	rcpioprmtnetas	;IOPAR_NETRMTNETAS = 0506h
	.LONG	rcpioprmtnetar	;IOPAR_NETRMTNETAR = 0507h
	.LONG	rcpioprmtports	;IOPAR_NETRMTPORTS = 0508h
	.LONG	rcpioprmtportr	;IOPAR_NETRMTPORTR = 0509h
	.LONG	0		;IOPAR_NETDSTNAME  = 050Ah
	.LONG	0		;IOPAR_NETSMODE    = 050Bh
	.LONG	0		;IOPAR_NETCMODE    = 050Ch
	.LONG	0		;IOPAR_NETRCVWIN   = 050Dh
	.LONG	rcpioplclneta	;IOPAR_NETLCLNETA  = 050Eh
OPARMNETMAX=!{$-rcpopnnetparms}/4
.PAGE
	.LONG	PARMMAX
rcpioparms:
	.LONG	rcpiogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	rcpionetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
PARMMAX=!{$-rcpioparms}/4

	.LONG	PARMGENMAX	;Size of table
rcpiogenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIoxFilOptn##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIoxFilSpec##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	rcpiopdiscvect	;IOPAR_SIGVECT1    = 000Ch
	.LONG	rcpiopintpvect	;IOPAR_SIGVECT2    = 000Dh
	.LONG	rcpiopvectdata	;IOPAR_SIGDATA     = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
PARMGENMAX=!{$-rcpiogenparms}/4

	.LONG	PARMNETMAX
rcpionetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	0		;IOPAR_NETPROTOCOL = 0502h
	.LONG	rcpxplclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	0		;IOPAR_NETRMTNETAS = 0506h
	.LONG	rcpioprmtnetar	;IOPAR_NETRMTNETAR = 0507h
	.LONG	0		;IOPAR_NETRMTPORTS = 0508h
	.LONG	rcpioprmtportr	;IOPAR_NETRMTPORTR = 0509h
	.LONG	0		;IOPAR_NETDSTNAME  = 050Ah
	.LONG	0		;IOPAR_NETSMODE    = 050Bh
	.LONG	0		;IOPAR_NETCMODE    = 050Ch
	.LONG	0		;IOPAR_NETRCVWIN   = 050Dh
	.LONG	rcpioplclneta	;IOPAR_NETLCLNETA  = 050Eh
PARMNETMAX=!{$-rcpionetparms}/4

;;;;	.LONG	PARMDGMAX
;;;;ipmmsgparms:
;;;;	.LONG	0		;		   = 0700h
;;;;	.LONG	lcladdr		;IOPAR_MSGLCLADDR  = 0701h
;;;;	.LONG	rmtaddrs	;IOPAR_MSGRMTADDRS = 0702h
;;;;	.LONG	rmtaddrr	;IOPAR_MSGRMTADDRR = 0703h
;;;;PARMDGMAX=!{$-ipmmsgparms}/4
.PAGE
	.SBTTL	rcpinit - Initialization routine

	INITSUB	rcpinit

;The command for installing RCPCLS is:
;	LKELOAD RCPCLS

rcpinit:
	MOVL	EBX, #rcpoas#		;Set up our once-a-second routine
	CALL	knlSetupOAS##
	MOVL	EDI, #rcpchk		;Install the RCP class
	MOVL	EBX, #rcpcls		;Offset of class function dispatch table
	CLRL	ECX
	MOVL	EAX, #'RCP'
	CLRL	EDX
	MOVL	ESI, #rcpccb
	JMP	knlNewClass##

	CODE
.PAGE
	.SBTTL	rcpaddunit - Subroutine to add RCP unit

;Subroutine to add RCP unit - this implements a RCP protocol device for a
;  single UDP device.  Multiple RCP units can be implemented for a single
;  UDP device, but there is not point in this, since they all share the UDP
;  device's port space.
;	c{ES:EDI} = Address of data block
;	CALL	rcpaddunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count

$$$=!0
FRM rcpau_snapnum, 4t		;Number of SNAP devices specified
FRM rcpau_unit   , 4t		;Unit number
FRM rcpau_netnum , 4t
FRM rcpau_count  , 4t
FRM rcpau_tpdb   , 4t		;Offset of UDP TPDB
rcpau_SIZE=!$$$

	DATA

	.MOD	4
rcpaublk:				;Parameter description block for
 DCHARBGN  3, knlDCharValCom##		;  adduparms
 DCHARENT  UNIT  , DECV, ,  1, 0, 0, rcpauunit  , 0
 DCHARENT  UDPDEV, TEXT, , 16, 0, 0, rcpauudpdev, 0

	CODE

	IFFAULT	8$
rcpaddunit:
	LFSL	EDX, iorb_buffer2.B[ESI]
	CALL	knlGiveQel##		;Give up the IORB
	ENTER	rcpau_SIZE, 0		;Allocate our stack frame
	CLRL	EAX
	LEAL	EDI, -rcpau_SIZE[EBP]	;Clear our stack frame
	MOVL	ECX, #rcpau_SIZE/4
	PUSHL	SS
	POPL	ES
	CLD
	RSTOSL	[EDI]
	DECL	rcpau_unit.B[EBP]	;Indicate illegal unit number
	MOVL	EBX, #rcpaublk
	MOVB	AL, #0			;Fail on bad names
	CALL	knlAddUnitChar##	;Process the characteristics
	JC	4$.S			;If error
	CMPL	rcpau_tpdb.B[EBP], #0.B	;Was a UDP device specified?
	JE	2$.S			;No
	CMPL	rcpau_unit.B[EBP], #0.B	;Yes - was a unit number specified?
	JGE	10$.S			;Yes
2$:	MOVL	EAX, #ER_CHARM		;No - fail
4$:	CLRL	ECX
6$:	MOVL	EBX, #QSTS$DONE
	LEAVE
	TOFORK
	RET
		
;Here if address error with the IORB

	FAULTHDR
8$:	CALL	knlGiveQel##
	MOVL	EAX, #ER_ADRER
	JMP	4$.S

;Here with characteristics processed

10$:	PUSHL	rcpau_unit.B[EBP]
	PUSHL	#tpdb_rcpSIZE
	PUSHL	#'RCP'
	PUSHL	#dcb_rcpINDEX.B
	PUSHL	#256t*4
	PUSHL	#tpdb_rcprcvhash
	PUSHL	#rcprcv#
	PUSHL	#rcpccb
	MOVL	EAX, rcpau_tpdb.B[EBP]
	PUSHL	tpdb_pdb.B[EAX]
	PUSHL	#xosrcpTpdbHead
	CALL	xosipsNewTransProt##	;Set up the new transport protocol
	JC	4$.S			;If error
	IMULL	EAX, knlTickCnt##, #1Dch ;Get a mostly random number as the
					 ;  initial sequence number
	MOVL	EDX, rcpau_tpdb.B[EBP]	;Get first underlying UDP TPDB
	MOVB	CL, tpdb_unit.B[EDI]	;Get unit number
12$:	MOVB	tpdb_rcpretry1.B[EDI], #RETRY_TRN1 ;Initialize default retry
	MOVB	tpdb_rcpretry2.B[EDI], #RETRY_TRN2 ;  levels
	MOVL	tpdb_rcpdfltport.B[EDI], #401h ;Initialize default port number
	MOVL	tpdb_tpdb.B[EDI], EDX
	MOVL	EDX, tpdb_nextd.B[EDX]
	MOVL	tpdb_rcpseqnumber.B[EDI], EAX
	MOVL	EDI, dpdb_nextd.B[EDI]
	TESTL	EDI, EDI
	JE	14$.S
	CMPB	CL, tpdb_unit.B[EDI]
	JE	12$.S
14$:	CLRL	EAX
	MOVL	ECX, #1			;OK
	JMP	6$
.PAGE
;Subroutine called by adduparms for the "UNIT" parameter

rcpauunit:
	CMPL	EAX, #99t.B		;Valid value?
	JA	knlBadCharV##		;No - fail
	MOVL	rcpau_unit.B[EBP], EAX	;Yes - store it
	CLC
	RET

;Subroutine called by adduparms for the "UDPDEV" parameter

rcpauudpdev:
	MOVL	EAX, rcpau_tpdb.B[EBP]	;Get current UDP TPDB offset
	CALL	xosudpAuUdpDev##	;Get UDP TPDB offset
	JC	2$.S			;If error
	MOVL	rcpau_tpdb.B[EBP], EDI	;OK - store UDP TPDB offset
2$:	RET
.PAGE
	.SBTTL	xosrcpAuRcpDev - Subroutine to process RCPDEV addunit characteristic

;Subroutine to process RCPDEV addunit characteristic for devices which use RCP
;  as their underlying protocol
;	c{EAX} = Current RCP TPDB offset
;	CALL	xosrcpAuRcpDev
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset of RCP TPDB

xosrcpAuRcpDev:
	ORL	EAX, EAX		;Alreay have a RCP TPDB?
	JNE	2$.S			;Yes - fail
	MOVL	EBX, #knlDcValue##	;No
	PUSHL	12t.B[EBX]
	PUSHL	8.B[EBX]
	PUSHL	4.B[EBX]
	MOVL	EAX, [EBX]
	PUSHL	EAX
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'RCP'
	JNE	4$.S
	LEAL	ECX, 3.B[ESP]
	MOVL	EDI, xosrcpTpdbHead	;Get offset of first TPDB
	CALL	xosnetSrchBlock##	;Find the correct TPDB
	JNE	4$.S			;If can't find it
	CMPB	SS:[ECX], #0		;Did he specify a specific network?
	JNE	4$.S			;Yes - fail
	ADDL	ESP, #16t.B
	RET

;Here if more than one RCP device specified

2$:	MOVL	EAX, #ER_TMDDV
	STC
	RET

;Here if cannot find requested RCP device

4$:	ADDL	ESP, #16t.B
	MOVL	EAX, #ER_NSDEV
	STC
	RET
.PAGE
	.SBTTL	setaccess - Set value of the ACCESS characteristic

;Here ot set the value of the ACCESS characteristic

setaccess:
	ADDL	EBX, dcb_ipstpdb.B[EDI]
	JMP	knlSetAccess##
.PAGE
	.SBTTL	rcpunitinfo - RCP get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  RCP class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	rcpunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

rcpunitinfo:
	MOVL	EAX, #ER_NIYT
	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	RET
.PAGE
	.SBTTL	getudpdev - Get value of UDPDEV device characteristic

;Here to get the value of the UDPDEV device characteristic

getudpdev:
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Get offset of our TPDB
	MOVL	EAX, tpdb_tpdb.B[EAX]	;Get offset of underlying TPDB
	ADDL	EAX, #tpdb_name.B	;Get offset of name
	RET
.PAGE
	.SBTTL	xosrcpGetRcpDev - Here to get value of RCPDEV characteristic

;Here to the the value of the RCPDEV characteristic for an application protocol
;  level device

xosrcpGetRcpDev:
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Get offset of TPDB
	ADDL	EAX, #tpdb_name+0.B	;Get offset of name
	RET
.PAGE
	.SBTTL	gethdcdc - Get head routine for CON* device characteristics

;Get head routine for CON* device characteristics

gethdcdc:
	MOVL	ESI, dcb_ipstpdb.B[EDI]	;Get offset of TPDB
	MOVL	ESI, tpdb_rcpcondsthead.B[ESI]
	TESTL	ESI, ESI
	RET

	.SBTTL	findcdc - Find element routine for CON* device characteristics

;Find element routine for CON* device characteristics.  If the characteristic
;  name is of the form CONnnnnn and is not found, an entry is created with a
;  null value.
;	c{EBX,EDX} = Characteristic name
;	c{EDI}     = Offset of DCB
;	CALL	findcdc
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:clr = No match
;	  Z:set = Match found
;	    c{ESI} = Offset of block

findcdc:MOVL	EAX, EBX
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'CON'
	JNE	8$.S
	PUSHL	EBX
	PUSHL	EDX
	MOVL	temp+0, EBX
	MOVL	temp+4, EDX
	CLRL	EAX
	MOVL	EBX, #temp+3
2$:	MOVB	DL, [EBX]
	INCL	EBX
	CMPB	DL, #0
	JE	10$.S
	CMPB	DL, #'0'
	JB	6$.S
	CMPB	DL, #'9'
	JA	6$.S
4$:	ANDL	EDX, #0Fh.B
	IMULL	EAX, #10t.B
	ADDL	EAX, EDX
	JMP	2$.S

;Here if found non-digit character - this is not a possible name

6$:	POPL	EDX
	POPL	EBX
8$:	TESTL	ESP, ESP
	RET

;Here with port number

10$:	TESTL	EAX, EAX		;0 is not valid
	JE	6$.S
	TESTL	EAX, #0FFFF0000		;Must be 0xFFFF or less
	JNE	6$.S
	MOVL	EBX, #temp+3
	MOVL	1.B[EBX], #0
	PUSHL	EAX			;Rebuild the name to eliminate possible
	CALL	knlPutDecNmbr##		;  leading 0s
	POPL	EAX
	MOVL	EDX, dcb_ipstpdb.B[EDI]
	LEAL	EDX, tpdb_rcpcondsthead.B[EDX]
12$:	MOVL	ESI, [EDX]
	TESTL	ESI, ESI
	JE	14$.S
	CMPL	dct_rcpport.B[ESI], EAX	;This port?
	JE	16$.S			;Yes - found it
	JA	14$.S			;If past where it goes
	LEAL	EDX, dct_lnknext.B[ESI]	;Advance to next block
	JMP	12$.S

;Here if need to insert a new block

14$:	CALL	knlGetQel##		;Get a queue element
	JC	16$.S			;If error
	MOVL	dct_rcpport.B[ESI], EAX	;Store port number
	MOVL	EAX, temp+0		;Store name
	MOVL	dct_name+0.B[ESI], EAX
	MOVL	EAX, temp+4
	MOVL	dct_name+4.B[ESI], EAX
	MOVB	[ESI], #REP_TEXT
	MOVB	dct_flags.B[ESI], #DCTF$LNKELMT
	MOVW	dct_length.B[ESI], #16t
	MOVL	dct_getsub.B[ESI], #knlDcGetLong##
	MOVL	dct_setsub.B[ESI], #setconmsgdst
	MOVL	dct_lnkdone.B[ESI], #donecdc
	MOVL	dct_infopnt.B[ESI], #msgconmsgdst
	LEAL	EBX, dct_rcpmsgdst.B[ESI]
	MOVL	dct_data.B[ESI], EBX	;Store offset of the value
	CLRL	EAX
	MOVL	[EBX], EAX		;Clear the value
	MOVL	4t.B[EBX], EAX
	MOVL	8t.B[EBX], EAX
	MOVL	12t.B[EBX], EAX
	MOVL	dct_rcppdcb.B[ESI], EAX	;Clear pointer to the pseudo-DCB
	MOVL	EAX, [EDX]		;Link it into our list
	MOVL	[EDX], ESI
	MOVL	dct_lnknext.B[ESI], EAX
	MOVL	dct_rcpprev.B[ESI], EDX
	TESTL	EAX, EAX		;Have a next block?
	JE	16$.S			;No
	LEAL	EDX, dct_lnknext.B[ESI]
	MOVL	dct_rcpprev.B[EAX], EDX
	CLRL	EAX			;Set Z
16$:	POPL	EDX
	POPL	EBX
18$:	RET

;Subroutine called when done using an element block.  If the element has a
;  null value, the block is discarded, otherwise nothing is done here.
;	c{ESI} = Offset of block
;	CALL	donecdc
;  FS and EDX are preserved

donecdc:CMPB	dct_rcpmsgdst.B[ESI], #0 ;Have a null value?
	JNE	18$.S			;No - nothing needed here
	MOVL	EBX, dct_rcpprev.B[ESI]	;Yes - unlink this block
	MOVL	EAX, dct_lnknext.B[ESI]
	MOVL	[EBX], EAX
	TESTL	EAX, EAX
	JE	20$.S
	MOVL	dct_rcpprev.B[EAX], EBX
20$:	JMP	knlGiveQel##		;Give up the memory block
.PAGE
	.SBTTL	setconmsgdst - Set value of a CON* device characteristic

;Here to set the value of a CON* device characteristic
;	c{EBX} = Offset of value
;	c{EDI} = Offset of DCB
;	CALL	knlDcSetLong
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

;We need to set up a UDP pseudo-DCB in the UDP port hash list to connect the
;  indicated port to the RCP receive code.  We do this by partially setting up
;  the port and hash table for the DCB which is open here (which must not
;  already have a port assigned), connecting it to our device characteristics
;  block, and then breaking the pseudo-DCB's connection to our DCB.  We give
;  up the port we got as soon as this has all been done.

setconmsgdst:
	TOFORK
	PUSHL	ESI
	CMPW	dcb_ipslclport.B[EDI], #0.B ;Does DCB already have a port?
	JNE	12$			;Yes - fail!
	CMPL	dct_rcppdcb.B[ESI], #0.B ;No - have a pseudo-DCB for this now?
	JNE	6$.S			;Yes - go on
	CMPB	knlDcValue##+0, #0	;No - setting to null value?
	JE	6$.S			;Yes - don't need a pseudo-DCB
	MOVL	ECX, dct_rcpport.B[ESI]	;No - assign a port (We don't really
	BTSL	ECX, #30t		;  need the port here, but rcphashsetudp
	CALL	xosrcpGetPort		;  expects a port and allocating one is
					;  an easy way to make sure its not in
					;  use otherwise.  We give it up below.)
	JC	16$.S			;If error
	CALL	rcphashsetudp#		;OK - set up the UDP hash list entry
	JC	14$.S			;If error
	MOVL	ESI, [ESP]		;OK
	MOVL	EAX, dcb_rcphashdcb.B[EDI] ;Store offset of the pseudo-DCB
	MOVL	dct_rcppdcb.B[ESI], EAX
	MOVL	dcb_udprcpmsg.B[EAX], ESI
	DECL	dcb_udprcpcnt.B[EAX]	;Reduce use count in the pseudo-DCB
	CLRL	EAX
	MOVL	dcb_rcphashdcb.B[EDI], EAX ;This DCB is not longer using the
					   ;  pseudo-DCB
	CALL	xosrcpGivePort		;Give up the RCP port
	MOVL	ESI, [ESP]
6$:	LEAL	EBX, dct_rcpmsgdst.B[ESI]
	CALL	knlDcSetLong##
	POPL	ESI
	PUSHL	#0.B
	JNC	8$.S
	MOVL	[ESP], EAX
	CLRL	EAX
	MOVL	dct_rcpmsgdst+0.B[ESI], EAX
	MOVL	dct_rcpmsgdst+4.B[ESI], EAX
	MOVL	dct_rcpmsgdst+8.B[ESI], EAX
	MOVL	dct_rcpmsgdst+12t.B[ESI], EAX
8$:	MOVL	EBX, dct_rcppdcb.B[ESI]	;Have a pseudo-DCB now?
	TESTL	EBX, EBX
	JE	10$.S			;No
	CMPB	dct_rcpmsgdst+0.B[ESI], #0 ;Yes - is value null?
	JNE	10$.S			;No - finished now
	CLRL	EAX			;Yes - unlink the pseudo-DCB
	MOVL	dcb_udprcpmsg.B[EBX], EAX
	MOVL	dct_rcppdcb.B[ESI], EAX
	CMPL	dcb_udprcpcnt.B[EBX], #0.B ;Is the pseudo-DCB in use otherwise?
	JNE	10$.S			;Yes
	CALL	rcphashclr2#		;No - give it up
10$:	POPL	EAX			;Restore error code
	FROMFORK
	BTL	EAX, #31t		;Set C if error
	RET

;Here if device already has a port allocated - say device is busy

12$:	MOVL	EAX, #ER_BUSY
	JMP	16$.S

;Here if error setting up the UDP hash list entry

14$:	PUSHL	EAX
	CALL	xosrcpGivePort		;Give up the RCP port
	POPL	EAX
16$:	POPL	ESI
	FROMFORK
	STC
	RET
.PAGE
;Device check routine for RCP class devices
;	c{SS:EBX} = Address of device name (16 characters)
;	CALL	rcpchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  EBX and ESI are preserved

rcpchk:	MOVL	EAX, SS:[EBX]
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'RCP'		;Is this RCP*?
	JNE	6$.S			;No
	MOVL	EDI, xosrcpTpdbHead	;Yes - get offset of first RCP TPDB
	LEAL	ECX, 3.B[EBX]		;Get offset of 1st unit number character
	MOVL	EDX, #DS$DUPLEX		;Get description bits
	CALL	xosipsFindDev##		;Find matching network device
	JC	4$.S			;If error
	JNE	4$.S			;Or if not a match
	CMPL	dcb_sdisp.B[EDI], #0.B	;Is this DCB already set up?
	JNE	2$.S			;Yes
	MOVL	dcb_sdisp.B[EDI], #rcpdsp ;Store offset of SVC dispatch table
	MOVL	EDX, dcb_ipstpdb.B[EDI]
	MOVW	AX, tpdb_rcpretry1.B[EDX] ;Store default retransmission
	MOVW	dcb_rcpretry1.B[EDI], AX  ;  threshold values
	MOVB	dcb_ipsprot.B[EDI], #IPP_UDP ;Store IP protocol value
	MOVL	dcb_netmode.B[EDI], #0	;Set default modes
	MOVL	dcb_devchar.B[EDI], #rcpdctbl ;Use our device characteristics
xosrcpChkFin:
	MOVL	EAX, rcptwhead		;Link this DCB to our timer list
	MOVL	dcb_rcptimenext.B[EDI], EAX
	MOVL	rcptwhead, EDI
2$:	CLRL	EAX			;Set Z
4$:	RET				;And return

6$:	CLC
	RET
.PAGE
	.SBTTL	sd_cleardcb - Clear DCB

;Here for the clear DCB entry

xosrcpGiveDcb:
	MOVL	EAX, #1			;Assume don't have a port
	CMPW	dcb_ipslclport.B[EDI], #0.B ;Right?
	JE	2$.S			;Yes
	MOVB	AL, #TIMECNT_LAN_TW	;No - assume on same sub-net
	TESTB	dcb_rcpsts2.B[EDI], #RCPS2$NLCL ;Right?
	JE	2$.S			;Yes
	MOVB	AL, #TIMECNT_IN_TW	;No
2$:	MOVL	dcb_rcptimecnt.B[EDI], EAX
	MOVB	dcb_rcpstate.B[EDI], #RCPS_TIMEWT
	RET				;Thats all for now
.PAGE
	.SBTTL	sd_devinfo - Get device information

;Here for the get device information entry
;	c{ECX}    = Length of user buffer
;	c{ES:EDI} = Address of user buffer
;	c{ESI}    = Offset of DCB
;	CALL	rcpdevinfo

$$$=!0
FRM info_left  , 4t
FRM info_amount, 4t
info_SIZE=!$$$

rcpdevinfo:
	ENTER	info_SIZE, 0
	MOVL	info_left.B[EBP], ECX
	CLRL	EAX
	MOVL	info_amount.B[EBP], EAX
	MOVZBL	EDX, dcb_rcpstate.B[ESI] ;Get RCP state
	LEAL	EBX, infoname[EDX*4]	;Get offset of name string
	MOVL	ECX, #4			;Its 4 characters long
	CALL	knlInfoStr##		;Store the name
	MOVL	EBX, #kalbl
	CALL	knlInfoStr##
	MOVL	EAX, dcb_rcptimecnt.B[ESI]
	CALL	knlInfoDec##
	MOVB	AL, #' '
	CALL	knlInfoChr##
	JMP	xosipsDevInfoLcl##

	DATA

	.MOD	4
infoname:
	.ASCII	"CLSD"		;RCPS_CLOSED =  0 - Idle
	.ASCII	"LSTN"		;RCPS_LISTEN =  1 - Waiting for connection
	.ASCII	"CRQR"		;RCPS_CRQRCD =  2 - CONREQ received
	.ASCII	"CRQS"		;RCPS_CRWSNT =  3 - CONREQ sent
	.ASCII	"CAKR"		;RCPS_CAKRCD =  4 - CONACK received
	.ASCII	"CAKS"		;RCPS_CAKSNT =  5 - CONACK sent
	.ASCII	"ESTB"		;RCPS_ESTAB  =  6 - Connection established
	.ASCII	"CLRR"		;RCPS_CLRREQ =  7 - Supervisory CLRREQ sent
	.ASCII	"KILS"		;RCPS_KILSNT =  8 - KILREQ sent
	.ASCII	"KILA"		;RCPS_KILACK =  9 - KILACK sent
	.ASCII	"LOST"		;RCPS_LOST   = 10 - Connection has been lost
	.ASCII	"TMWT"		;RCPS_TIMEWT = 11 - All finished - timing out
				;		      port

kalbl:	.ASCIZ	" KA="
lcllbl:	.ASCIZ	"L="
rmtlbl:	.ASCIZ	" R="

	CODE
.PAGE
	.SBTTL	sd_open - Open device

;Here for the open device entry
;	c{EDX} = Offset of name buffer
;	c{EDI} = Offset of DCB
;	CALL	rcpopen
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

OX=!O$REPEAT|O$REQFILE|O$ODF|O$FAILEX|O$CREATE|O$TRUNCA|O$TRUNCW|O$APPEND
OX=!OX|O$UNQNAME|O$CONTIG|O$FAPPEND

rcpopena:
	TESTL	SS:xffCmd##, #OX	;Check for illegal bits
	JNE	knlIFnDev##
	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Physical or raw IO?
	JNE	rcpdevparm		;Yes
;;;;;;;	TESTB	SS:xffCmd##, #O$IN|O$OUT ;No - no IO?
;;;;;;;	JE	rcpdevparm		;Yes
	CMPB	dcb_rcpstate.B[EDI], #RCPS_CLOSED ;Is device idle?
	JE	2$.S			;Yes - go on
	CMPB	dcb_rcpstate.B[EDI], #RCPS_ESTAB ;No - normal connection?
	JE	opendn			;Yes
	MOVL	EAX, #ER_BUSY		;No - say device is busy
	STC
	RET

	.SBTTL	sd_open1 - Open device first time

;Here for the open device first time entry
;	c{EDX} = Offset of name buffer
;	c{EDI} = Offset of DCB
;	CALL	rcpopen1
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

rcpopen1:
	TESTL	SS:xffCmd##, #OX	;Check for illegal bits
	JNE	knlIFnDev##
	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Physical or raw IO?
	JNE	rcpdevparm		;Yes
;;;;;;;	TESTB	SS:xffCmd##, #O$IN|O$OUT ;No - no IO?
;;;;;;;	JE	rcpdevparm		;Yes
2$:	MOVB	SS:xffQueue##, #dcb_outframe ;No - set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	CMPB	dcb_rcpstate.B[EDI], #RCPS_CRQRCD ;Is this an incoming
						  ;  connection?
	JE	rcpopenin		;Yes - go handle that
	PUSHL	EDX
	BTL	SS:xffHvValue1##, #IOV1%LCLPORT ;Local port number specified?
	JNC	4$.S			;No
	MOVL	ECX, opn_lclport[EBP]	;Yes - use it
	CALL	xosrcpGetPort
	JMP	6$.S

4$:	CALL	xosrcpDfltPort
6$:	POPL	EDX
	JC	12$.S			;If error setting the local port number
	BTL	SS:xffHvValue1##, #IOV1%RMTPORTS ;Remote port number specified?
	JNC	8$.S			;No
	MOVL	EAX, opn_rmtports[EBP] ;Yes - use it
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport.B[EDI], AX
8$:	BTL	SS:xffHvValue1##, #IOV1%RMTNETAS ;IP address specified?
	JC	10$.S			;Yes - not passive
	CMPL	SS:[EDX], #'*::'	;Is this a pasive open?
	JE	rcpopenpas		;Yes - go handle that
10$:	MOVL	EAX, #5t		;No
	MOVL	ECX, #30t
	CALL	xosrcpConnect		;Establish the RCP connection
12$:	JC	22$.S
opendn:	CMPL	SS:xffParm##, #0.B	;Have a parameter list?
	JE	20$.S			;No
	MOVL	EBX, #rcpopnparms	;Yes - process device parameters
	MOVL	ECX, #knlComDPParms##	;  (IGNORE ERRORS FOR NOW!)
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	TESTL	SS:xffPVFilOpt##, #FO$NODENAME|FO$NODENUM ;Want node number?
	JE	20$.S			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX ;Yes - want prefix code?
	JC	14$.S			;No
	MOVB	AL, #FS_NODENUM		;Yes
	CALL	knlGivUChr##
14$:	LEAL	EBX, dcb_ipsrmtaddr.B[EDI] ;Point to the node number
	MOVL	ECX, #4t		;Give him 4 bytes
16$:	MOVZBL	EAX, [EBX]		;Get byte
	CALL	knlGivUNum##		;Give him the value?
	DECL	ECX			;Finished?
	JE	18$.S			;Yes
	INCL	EBX			;No - bump pointer
	MOVB	AL, #'.'		;Give him a period
	CALL	knlGivUChr##
	JMP	16$.S			;Continue

;Here with node number given to the user

18$:	CALL	knlGivUColon##		;Put :: after the node number
	CALL	knlGivUColon##
20$:	CLRL	EAX
22$:	RET

;Here for the devparm function or if physical or raw IO requested

rcpdevparm:
	ANDB	SS:xffCmd##, #~{O$IN|O$OUT} ;No IO allowed
	JMP	opendn			;Thats all
.PAGE
;Here for passive open to wait for an in-coming connection

rcpopenpas:
	CALL	rcphashsetudp#		;Set up the UDP hash list entry
	CALL	xosrcpPutConWait	;Put this DCB in the connect wait list
	MOVL	EAX, SS:xffTimeOut##	;Get time-out value
	CALL	xosnetRspWait##		;Wait for a connection request
	JC	10$.S			;If error
	CALL	xosrcpRmvConWait	;Remove DCB from the connect wait list
rcpopenin:
	CALL	xosrcpTimerRmv#		;Clear the connect timer
	CALL	xosrcpAcceptCon		;Accept the connection
	MOVB	SS:xffCount##, #4-1	;Retry this 4 times
4$:	CALL	xosrcpSendCONACK
	JC	8$.S
	MOVL	EAX, dcb_rcprxmttime[EDI] ;Get time-out value
	IMULL	EAX, #FDPERTICK
	CALL	xosnetRspWait##		;Wait for the ACK
	JNC	opendn			;If OK
	CMPL	EAX, #ER_NORSP.B	;Did this time-out?
	JNE	opnerr.S		;No
	DECB	SS:xffCount##		;Yes - should we try again?
	JNS	4$.S			;Yes
	MOVB	AL, #ER_NCLST		;No - get right error code
opnerr:	PUSHL	EAX			;Save error code
	CALL	xosrcpHashClr#		;Remove DCB from the hash table
	MOVB	dcb_rcpstate.B[EDI], #RCPS_CLOSED
6$:	POPL	EAX
	STC
8$:	RET

;Here with error while we are in the connect wait list

10$:	PUSHL	EAX
	CALL	xosrcpRmvConWait
	JMP	6$.S
.PAGE
	.SBTTL	rcpiopdiscvect - Here for the IOPAR_SIGVECT1 parameter

;Here for the IOPAR_SIGVECT1 parameter - this vector is used for disconnects

	DPARMHDR  BOTH, HEXV
rcpiopdiscvect:
	LEAL	ESI, dcb_rcpdiscvect[EDI]
	JMP	2$.S

	.SBTTL	rcpiopintpvect - Here for the IOPAR_SIGVECT2 parameter

;Here for the IOPAR_SIGVECT2 parameter - this vector is used for notification
;  of received interrupt packets

	DPARMHDR  BOTH, HEXV
rcpiopintpvect:
	LEAL	ESI, dcb_rcpintpvect[EDI]
2$:	TESTB	AH, #PAR$SET		;Want to set the value?
	JE	12$.S			;No
	PUSHL	EAX
	CALL	knlGetParm##		;Yes - get value
	JC	18$.S
	TESTL	EAX, EAX		;Clearing the vector?
	JNE	4$.S			;No
	MOVW	dcb_rcpdiscpda-dcb_rcpdiscvect.B[ESI], AX
	MOVW	[ESI], AX
	JMP	10$.S

;Here if not clearing the vector

4$:	MOVL	EDX, EAX
	CALL	knlChkVector##		;Check for valid vector number
	JC	16$.S
	MOVW	[ESI], DX		;OK - store new value
	MOVW	AX, SS:xffPda##
	MOVW	dcb_rcpdiscpda-dcb_rcpdiscvect.B[ESI], AX
	MOVZWL	EAX, dcb_sunit.B[EDI]
	SHLL	EAX, #16t
	MOVB	AL, dcb_punit.B[EDI]
10$:	MOVL	dcb_rcpvectdata[EDI], EAX
	POPL	EAX
12$:	TESTB	AH, #PAR$GET		;Want to get value?
	JE	20$.S			;No
	MOVZWL	EAX, [ESI] ;Yes
	JMP	knlStrParm4#

;Here if error

16$:	MOVL	EAX, #ER_PARMV
18$:	POPL	EDX
20$:	RET

	.SBTTL	rcpiopvectdata - Here for the IOPAR_SIGDATA1 IO parameter

;Here for the IOPAR_SIGDATA1 IO parameter - Get or set vector data

	DPARMHDR  BOTH, HEXV
rcpiopvectdata:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	22$.S			;No
	PUSHL	EAX
	CALL	knlGetParm##		;Yes - get value
	JC	18$.S
	MOVL	dcb_rcpvectdata[EDI], EAX ;Store new value
	POPL	EAX
22$:	TESTB	AH, #PAR$GET		;Want to get value?
	JE	20$.S			;No
	MOVL	EAX, dcb_rcpvectdata[EDI] ;Yes
	JMP	knlStrParm4#
.PAGE
	.SBTTL	rcpioplclport - Here for the IOPAR_NETLCLPORT parameter for open

;Here for the IOPAR_NETLCLPORT parameter - Set or get local port number for open

	DPARMHDR  BOTH, DECV
rcpioplclport:
	TESTB	AH, #PAR$GET		;Want value returned?
	JE	10$.S			;No
2$:	MOVZWL	EAX, dcb_ipslclport.B[EDI] ;Yes - return current value
	JMP	knlStrParm4##

	.SBTTL	rcpxplclport - Here for the IOPAR_NETLCLPORT parameter for transfer

;Here for the IOPAR_NETLCLPORT parameter - Get local port number for transfer

	DPARMHDR  GET, DECV
rcpxplclport:
	JMP	2$.S

	.SBTTL	rcpioprmtports - Here for the IOPAR_NETRMTPORS parameter for open

;Here for the IOPAR_NETRMTPORTS parameter - Get or set remote port for open

	DPARMHDR  BOTH, DECV
rcpioprmtports:
	TESTB	AH, #PAR$GET		;Want value returned?
	JE	10$.S			;No
4$:	MOVZWL	EAX, dcb_ipsrmtport.B[EDI] ;Yes - return current value
6$:	XCHGB	AL, AH			;Fix up the byte order
	JMP	knlStrParm4##

	.SBTTL	rcpioprmtportr - Here for the IOPAR_NETRMTPORTR parameter

;Here for the IOPAR_NETRMTPORTR parameter - Get remote port number

	DPARMHDR  GET, DECV
rcpioprmtportr:
	JMP	4$.S

	.SBTTL	rcpioprmtnetas - Here for the IOPAR_NETRMTNETAS parameter for open

;Here for the IOPAR_NETRMTNETAS parameter - Get remote network address for open

	DPARMHDR  BOTH, DECV
rcpioprmtnetas:
	TESTB	AH, #PAR$GET		;Want value returned?
	JE	10$.S			;No
8$:	MOVL	EAX, dcb_ipsrmtaddr.B[EDI] ;Yes - return current value
	JMP	knlStrParm4##

10$:	RET

	.SBTTL	rcpioprmtnetar - Here for the IOPAR_NETRMTNETAR parameter

;Here for the IOPAR_NETRMTNETAR parameter - Get remote network address

	DPARMHDR  GET, DECV
rcpioprmtnetar:
	JMP	8$.S

	.SBTTL	rcpioplclneta - Here for the IOPAR_NETLCLNETA

;Here for the IOPAR_NETLCLNETA parameter - Get local network address

	DPARMHDR  GET, DECV
rcpioplclneta:
	MOVL	EAX, dcb_netpdb.B[EDI]
	MOVL	EAX, pdb_ipaddr.B[EAX]
	JMP	knlStrParm4##
.PAGE
.IF NE 0

qqqqqqqq
;Subroutine called when scanning parameters for the IOPAR_IPMLCLADDR parameter
;	c{ES:EBX} = Address of value
;	c{ECX}    = Size of value field
;	CALL	rmtpid

	DPARMHDR  GET, STR
lcladdr:PUSHL	EDI
	LEAL	ESI, dcb_ipmourname.B[EDI]
	MOVZWL	EAX, dcb_ipmourlen.B[EDI]
	JMP	4$.S

;Subroutine called when scanning parameters for the IOPAR_IPMRMTADDRS parameter
;	c{ES:EBX} = Address of buffer for string
;	c{ECX}    = Length of the buffer
;	c{FS:EDX} = Address of word to receive length of string
;	CALL	rmtaddrs

	DPARMHDR  BOTH, STR
rmtaddrs:
	TESTB	AH, #PAR$SET		;Want to set the value?
	JE	2$.S			;No
	PUSHL	EAX			;Yes
	PUSHL	ES
	PUSHL	EBX
	PUSHL	FS
	PUSHL	EDX
	MOVL	ESI, EBX
	PUSHL	ES
	POPL	FS
	MOVL	EBX, #dcb_ipmdstname
	CALL	strname
	POPL	EDX
	POPL	FS
	POPL	EBX
	POPL	ES
	JC	8$.S			;If error
	POPL	EAX
2$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	6$.S			;No - finished now
	LEAL	ESI, dcb_ipmdstname.B[EDI] ;Yes
	MOVZWL	EAX, dcb_ipmdstlen.B[EDI]
4$:	XCHGL	ECX, EAX
	CMPL	ECX, EAX
	JAE	12$.S
	IFFAULT	knlRtnAdrEr#
	MOVW	FS:[EDX], CX		;Store length of the name
	PUSHL	EDI
	MOVL	EDI, EBX
	IFFAULT	10$
	RMOVSB	[EDI], [ESI]		;Store name
	CLRL	EAX
	IFFAULT	10$
	STOSB	[EDI]			;Store final null
	POPL	EDI
6$:	RET

;Here if error storing the remote name

8$:	POPL	ECX			;Fix up the stack
	RET				;Return (C is set)

;Here if address error

10$:	POPL	EDI
	JMP	knlRtnAdrEr#

;Here if field is too small

12$:	MOVL	EAX, #ER_PARMS
	STC
	RET

;Subroutine called when scanning parameters for the IOPAR_IPMRMTPID parameter
;	c{ES:EBX} = Address of value
;	c{ECX}    = Size of value field
;	CALL	rmtpid

	DPARMHDR  GET, HEXV
rmtpid:	CMPL	ECX, #4.B		;Is the field big enough?
	JB	10$.S			;No
	MOVL	ipmi_rmtpidv+0.B[EBP], EBX ;Yes - store address for the value
	MOVL	ipmi_rmtpidv+4.B[EBP], ES
	MOVL	ipmi_rmtpids.B[EBP], ECX ;And store size of value field
	CLC
	RET
.PAGE

qqqqqqq
.ENDC

	.SBTTL	xosrcpConnect - Subroutine to establish RCP connection for open

;Subroutine to establish RCP connection for open - must be called in extended
;  fork context
;	c{EAX} = Receive window size
;	c{ECX} = Keep-alive time (seconds, 0 means no keep-alive)
;	c{EDX} = Offset of name buffer (on stack)
;	c{EDI} = Offset of DCB
;	CALL	xosrcpConnect
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX} = Offset of next part of name

;A network address may be specified after the device name.  It must be
;  terminated with a double colon as follows:
;	RCP0:147.23.45.67.34::
;  The fifth byte is optional, if included, specifies the value to be used
;  for the low order byte of the local network address.

;The data in a RCP_CONREQ packet is used as follows:
;  Offset Size    Description
;     0     2    Maximum packet size
;     2     2    Keep-alive time
;     4     1    RCP version number
;     5     3    Reserved, must be 0
;     8     2    Maximum retransmit time (ms)
;    10     2    Initial retransmit time (ms)

$$$=!0
FRM con_frame1, 4t
FRM con_frame2, 4t
FRM con_name  , 4t	;Offset of name buffer
FRM con_retry , 4t	;Retry counter
FRM con_bfr   , 4t	;Offset of packet buffer used to send CONREQ
con_SIZE=!$$$

xosrcpConnect:
	ENTER	con_SIZE, 2
	MOVL	dcb_rcprcvwina.B[EDI], EAX ;Store our receive window size
	MOVL	dcb_rcprcvwinm.B[EDI], EAX
	MOVL	dcb_rcpkareqtm.B[EDI], ECX ;Store our keep-alive time
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%RMTNETAS ;Have an address parameter?
	JNC	2$.S			;No	
	MOVL	EBX, con_frame1.B[EBP]	;Yes - get its value
	MOVL	EBX, SS:opn_rmtnetas[EBX]
	JMP	gethva1			;Continue

;Here if address parameter (IOPAR_RMTNETAS) not specified

2$:	CALL	xosnetChkNetAddr##	;Was a network address given?
	JNE	getpds.S		;No - fail

;Here if a network address was given

4$:	CMPB	SS:[EDX], #'A'		;Is the first character alpha?
	JB	getipa.S		;No - go collect Internet address
	CALL	xosipsDnsGetIpA##	;Yes - translate domain name
	JNC	gethva2.S		;Go on if OK
	LEAVE				;Error
	RET
.PAGE
getipa:	CLRL	EBX
	MOVL	ECX, #4			;Remote IP address may contain up to 4
2$:	CALL	getval			;  fields
	RORL	EBX, #8
	CMPB	AL, #':'		;End of remote IP address?
	JE	10$.S			;Yes
	CMPB	AL, #'.'		;No - is it the separator?
	JNE	getpds.S		;No - fail
	LOOP	ECX, 2$			;Yes - continue
getpds:	MOVL	EAX, #ER_NILAD
6$:	STC
	LEAVE
	RET

;Here if default host is not available

8$:	MOVL	EAX, #ER_NHSNA
	JMP	6$.S

;Here with the internet address
;	c{EBX} = IP address

10$:	INCL	EDX			;Skip the second colon
gethva1:CMPL	EBX, #0.B		;Is entire address 0?
	JE	getpds.S		;Yes - fail!
gethva2:MOVL	con_name.B[EBP], EDX	;Save offset of name buffer
	MOVL	EDX, dcb_netpdb.B[EDI]	;Get offset of the PDB
	TESTL	EBX, pdb_ipsubnetmask.B[EDX] ;Did he specify the network part?
	JNE	12$.S			;Yes
	MOVL	EAX, pdb_ipaddr.B[EDX]	;No - use our network address
	ANDL	EAX, pdb_ipsubnetmask.B[EDX]
	ORL	EBX, EAX
12$:	MOVL	dcb_ipsrmtaddr.B[EDI], EBX ;Store IP address
14$:	CALL	xosrcpHashSet#		;Put DCB into the RCP hash table
	JC	rcpconf			;If error
	MOVL	ECX, #12t		;Allocate a CONREQ packet
	MOVB	AL, #RCPP_CONREQ
	CALL	xosrcpGetPkt#
	JC	rcpconf			;If no buffer available
	MOVL	con_bfr.B[EBP], EBX	;OK
	MOVL	ESI, dcb_netpdb.B[EDI]
	MOVL	EAX, dcb_ipstpdb.B[EDI]
	INCL	tpdb_rcpcntpktout.B[EAX] ;Count the packet
	ADDL	tpdb_rcpcntbyteout.B[EAX], #rcp_data+12t.B
	MOVL	EAX, pdb_ipmaxpktsz[ESI] ;Get maximum packet size
	SUBL	EAX, #rcp_data.B
	XCHGB	AL, AH			;Fix up the byte order
	MOVL	rcp_data+0.B[EDX], EAX	;Store in the packet and clear the next
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;  2 bytes
	ADDL	tpdb_rcpseqnumber.B[EAX], #55555h
	MOVL	EAX, tpdb_rcpseqnumber.B[EAX] ;Initialize the sequence number
	MOVL	dcb_rcpsndsnum[EDI], EAX
	DECL	EAX
	MOVL	dcb_rcprcvanum.B[EDI], EAX
	MOVL	npb_seqnum.B[EBX], EAX	;Store it in the header in our normal
	XCHGB	AL, AH			;  byte order
	RORL	EAX, #16t		;Reverse the byte order
	XCHGB	AL, AH			;Store it in the packet in network byte
	MOVL	rcp_seqnum.B[EDX], EAX	;  order
	MOVL	EAX, dcb_rcpkareqtm.B[EDI] ;Store the keep-alive time
	XCHGB	AL, AH
	MOVW	rcp_data+2.B[EDX], AX
	CLRL	EAX			;Set acknowledgement number to 0
	MOVL	dcb_rcprcvsnum.B[EDI], EAX
	MOVL	rcp_data+4.B[EDX], EAX	;Clear the reserved items
	MOVL	rcp_data+8.B[EDX], EAX
	CALL	rcpinittimeouts#	;Set up the time-out values
	MOVB	dcb_rcpstate.B[EDI], #RCPS_CRQSNT ;Set connection state
	MOVB	con_retry.B[EBP], #RETRY_CON ;Initialize retry counter
	ANDB	dcb_ipssts1.B[EDI], #~IPSS1$RROUTE ;Clear removed route flag
	CALL	rcpsetack#
	CALL	xosipsSendSetup##	;Finish setting up the IP header
rcpcon2:MOVL	ESI, dcb_netsdb.B[EDI]	;Make sure have SDB offset
	MOVL	EAX, #xosnetOutDone##	;Output the packet
	CALL	xossnpSendPkt##
	JC	16$.S
	MOVL	ESI, dcb_netidb.B[EDI]
	MOVL	EAX, #-1		;Wait here so will see possible ARP
	CALL	xosnetWaitPkt##		;  errors
16$:	JC	rcpcone.S		;If error
rcpcon4:CMPL	dcb_rcprcvhead.B[EDI], #0.B ;Do we have a response yet?
	JNE	rcpcon6			;Yes (unusual but not impossible!)

	MOVL	EAX, dcb_rcprxmttime[EDI] ;No - wait for the response
	IMULL	EAX, #FDPERTICK
	CALL	xosnetRspWait##
	JNC	rcpcon6.S		;If normal
	MOVL	EBX, con_bfr.B[EBP]	;Restore pointer to our packet
	CMPL	EAX, #ER_NORSP		;Time-out error?
	JNE	rcpcone.S		;No - fail now
	DECB	con_retry.B[EBP]	;Should we do it again?
	JS	18$.S			;No
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Yes
	INCL	tpdb_rcpcntrexmit[EAX]	;Count the retransmission
	JMP	rcpcon2.S		;Continue

;Here if have tried enough

18$:	TESTB	npb_sts.B[EBX], #NPS$USEDARP ;Did we use ARP this time?
	JNE	20$.S			;Yes - fail
	TESTB	dcb_ipssts1.B[EDI], #IPSS1$RROUTE ;Just to be safe, have we done
						  ;  this before here?
	JNE	20$.S			;Yes - fail!
	ORB	dcb_ipssts1.B[EDI], #IPSS1$RROUTE ;No - remember we have now
	MOVL	EAX, dcb_ipsrmtaddr.B[EDI] ;Remove this entry from our routing
	PUSHL	EDI			  ;  table
	MOVL	ESI, dcb_netsdb.B[EDI]	;Make sure have SDB offset
	MOVL	EDI, dcb_netpdb.B[EDI]
	MOVB	DL, #0
	CALL	xosipsRtRmvOne##
	POPL	EDI
	MOVL	EBX, con_bfr.B[EBP]
	JC	20$.S			;Forget it if error here
	CALL	xosnetGiveBufr##	;OK - Give up the buffer
	CALL	xosrcpHashClr#		;Remove DCB from the hash table
	JMP	14$			;Go try again

;Here if cannot find destination node

20$:	MOVL	EAX, #ER_NSNOD		;Get error code
rcpcone:CALL	xosnetGiveBufr##	;Give up our buffer
rcpconf:MOVB	dcb_rcpstate.B[EDI], #RCPS_CLOSED ;Indicate idle
	CALL	xosrcpGiveAll#		;Make sure don't have any buffers
	PUSHL	EAX
	CALL	xosrcpHashClr#		;Remove DCB from the hash table
	CLRL	EAX
	MOVL	dcb_ipsrmtaddr.B[EDI], EAX ;Clear remote IP address
	POPL	EAX
	STC				;Indicate error
	LEAVE
	RET
.PAGE
;Here when get a reply to our CONREQ packet

rcpcon6:MOVL	EBX, dcb_rcprcvhead.B[EDI] ;Get offset of packet
	CLRL	EDX
	MOVL	dcb_rcprcvhead.B[EDI], EDX
	MOVB	DL, npb_tpofs.B[EBX]	;Get offset of RCP header
	ADDL	EDX, EBX
	MOVL	EAX, rcp_acknum.B[EDX]	;Get the ACK number
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	CMPL	dcb_rcpsndsnum[EDI], EAX ;Is it right?
	JNE	4$.S			;No - discard it
	MOVL	dcb_rcprcvanum.B[EDI], EAX ;Yes
	CMPB	rcp_type.B[EDX], #RCPP_CONACK ;CONACK?
	JE	18$			;Yes - go on
	CMPB	rcp_type.B[EDX], #RCPP_CONREJ ;CONREJ?
	JE	10$.S
	CMPB	rcp_type.B[EDX], #RCPP_CONBSY ;CONBSY?
	JE	8$.S
	MOVL	ECX, dcb_ipstpdb.B[EDI]	;No
	INCL	tpdb_rcpcntbadhdr[ECX]	;Count this
2$:	CALL	xosnetGiveBufr##	;And ignore the packet!
	JMP	rcpcon4			;Continue waiting for a response

;Here if packet is out of sequence

4$:	MOVL	ECX, dcb_ipstpdb.B[EDI]
	INCL	tpdb_rcpcntoutseq[ECX]
	JMP	2$.S

;Here if have CONBSY - this means the other side has a half open connection -
;  We send a RSTREQ followed immediately by a retransmission of our CONREQ.

8$:	MOVL	ECX, dcb_ipstpdb.B[EDI]
	INCL	tpdb_rcpcntpktout.B[ECX]
	ADDL	tpdb_rcpcntbyteout.B[ECX], #20t.B
	CLRL	ECX
	MOVB	AL, #RCPP_RSTREQ
	MOVL	ESI, dcb_ipstpdb.B[EDI]
	PUSHL	EDI
	MOVL	EDI, dcb_netpdb.B[EDI]
	CALL	rcpsendback#
	POPL	EDI
	MOVL	EBX, con_bfr.B[EBP]	;Restore offset of our CONREQ packet
	JMP	rcpcon2			;Go send it again

;Here if have CONREJ

10$:	MOVL	EAX, #ER_NCRFS		;Get error code
12$:	CALL	xosnetGiveBufr##
14$:	MOVL	EBX, con_bfr.B[EBP]
	JMP	rcpcone

;Here with CONREQ as response to our CONREQ

16$:	JMP	2$			;DO THIS SOON!!!

;Here with CONACK as response to our CONREQ

18$:	MOVZWL	EAX, rcp_window.B[EDX]	;Get window size
	XCHGB	AL, AH
	MOVL	dcb_rcpsndwina[EDI], EAX ;Store it
	MOVL	dcb_rcpsndwinm[EDI], EAX
	MOVL	EAX, rcp_seqnum.B[EDX]	;Initialize the remote sequence number
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	INCL	EAX
	MOVL	dcb_rcprcvsnum.B[EDI], EAX
	DECL	EAX
	MOVL	dcb_rcprcvtnum.B[EDI], EAX
	MOVZWL	EAX, rcp_window.B[EDX]	;Store window value
	XCHGB	AL, AH
	MOVL	dcb_rcpsndwina[EDI], EAX
	MOVL	dcb_rcpsndwinm[EDI], EAX
	MOVL	dcb_rcpkareqtm.B[EDI], #0 ;Assume no keep-alives wanted
	MOVL	EAX, rcp_data.B[EDX]	;Get maximum packet size and keep-alive
					;  time
	TESTW	AX, AX			;Check for old version which can't
	JE	20$.S			;  handle keep-alive requests
	CMPW	AX, #6666h
	JE	20$.S
	SHRL	EAX, #16t		;Get keep-alive time
	XCHGB	AL, AH
	CMPL	EAX, #0.B		;If don't want keep-alive requests
	JE	20$.S
	MOVL	dcb_rcpkareqtm.B[EDI], EAX ;Store keep-alive time
	ORB	dcb_rcpsts1.B[EDI], #RCPS1$KASEND ;Indicate should send
						  ;  keep-alive requests
	MOVL	dcb_rcptimecnt.B[EDI], EAX ;Start the keep-alive timer
20$:	CALL	xosnetGiveBufr##	;Finished with this packet
	MOVB	dcb_rcpstate.B[EDI], #RCPS_CAKRCD ;Update the connection state
	MOVL	EBX, con_bfr.B[EBP]
	CALL	xosnetGiveBufr##
	CALL	rcpsendacknow#		;Send an ACK
	CLRL	EAX			;Indicate success
	MOVL	EDX, con_name.B[EBP]	;Get pointer to rest of name
	LEAVE
	RET
.PAGE	
;Subroutine to get value of next network address field
;	c{EDX} = Offset of address string
;	CALL	getval
;	c(AL)  = Stopper character
;	c(BL)  = Value
;	c{EDX} = Offset of next character in address string

getval:	MOVB	AL, #0
2$:	MOVB	BL, SS:[EDX]		;Get character
	INCL	EDX			;Bump pointer
	CMPB	BL, #'0'		;Is it a digit?
	JB	4$.S			;No
	CMPB	BL, #'9'
	JA	4$.S
	ANDB	BL, #0Fh		;Yes - get value
	MULB	lit10			;And add into value for field
	ADDB	AL, BL
	JMP	2$.S

;Here if next character is not a digit

4$:	XCHGB	AL, BL			;Get things in right registers
	RET				;Return
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	rcpclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

rcpclose:
	MOVL	EAX, SS
	CMPW	AX, dcb_rcpdiscpda[EDI] ;Are we getting the disconnect signal?
	JNE	2$.S			;No
	MOVW	dcb_rcpdiscpda[EDI], #0	;Yes - but not any more
2$:	CMPL	dcb_opencnt.B[EDI], #1.B ;Final close?
	JE	10$.S			;Yes
	CMPL	iorb_parm.B[ESI], #0.B	;No - have any device parameters?
	JE	4$			;No
	MOVL	EBX, #rcpioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	8$
	LFSL	EDX, iorb_parm.B[ESI]
	CALL	knlProcDevParm##
	JC	6$.S
4$:	CLRL	EAX
6$:	TOFORK				;No
	JMP	knlCloseFin##

	FAULTHDR
8$:	MOVL	EAX, #ER_ADRER
	JMP	6$.S

;Here if final close

10$:	CALL	knlIoClsLock##		;Lock the QAB
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #rcpclose1
	JMP	knlXfQueue##		;Switch to extended fork context

	FAULTHDR
12$:	MOVL	EAX, #ER_ADRER
	JMP	16$.S

;Here in extended fork context

rcpclose1:
	MOVL	SS:xffTimeOut##, #XT_SECOND*30t
	CMPL	SS:xffParm##+0, #0.B
	JE	14$.S
	MOVL	EBX, #rcpioparms	;Process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	12$
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	16$.S
14$:	CLRL	EAX
16$:	PUSHL	EAX
	CALL	rcpgivercv#		;Give up any pending receive packets
	MOVL	dcb_rcprcvwina.B[EDI], #10t ;Make sure we get the response
	BTL	SS:xffOption##, #C%KILL	;Want to kill the connection?
	JC	18$.S			;Yes
	MOVL	EAX, SS:xffTimeOut##	;No
	CALL	xosrcpClear		;Terminate our connection
	JMP	20$.S

18$:	CALL	xosrcpKill
20$:	JNC	22$.S
	MOVL	[ESP], EAX
22$:	POPL	EAX
	JMP	knlXfCloseFin##		;Go finish up
.PAGE
	.SBTTL	xosrcpRmvConWait - Subroutine to remove DCB from connect wait list

;Subroutine to remove DCB from the connect wait list
;	c{EDI} = Offset of DCB
;	CALL	xosrcpRmvConWait

xosrcpRmvConWait::
	MOVL	EDX, dcb_ipstpdb.B[EDI]	;Point to the RCP TPDB
	LEAL	EBX, tpdb_rcpconhead.B[EDX] ;Point to head pointer
20$:	MOVL	ECX, [EBX]		;Get next DCB
	JREGZ	ECX, 22$		;If no more
	CMPL	ECX, EDI		;This one?
	JE	24$.S			;Yes
	LEAL	EBX, dcb_ipshashnext.B[ECX] ;No - advance pointer
	JMP	20$.S			;Continue

22$:	CRASH	BCWL			;[Bad CONREQ Wait List]

;Here with DCB

24$:	MOVL	EAX, dcb_ipshashnext.B[EDI] ;Remove from list
	MOVL	[EBX], EAX		;Update pointer
	TESTL	EAX, EAX		;Was this last on the list?
	JNE	28$.S			;No - finished since list can't be
					;  empty now
	SUBL	EBX, #dcb_ipshashnext.B	;Assume not only one on list
	CMPL	tpdb_rcpconhead.B[EDX], #0.B ;Right?
	JNE	26$.S			;Yes
	CLRL	EBX			;No - list is empty now
26$:	MOVL	tpdb_rcpcontail.B[EDX], EBX ;Update tail pointer
28$:	MOVL	dcb_ipshashnext.B[EDI], #-1
	RET
.PAGE
	.SBTTL	xosrcpPutConWait - Subroutine to put DCB into connect wait list

;Subroutine to put DCB into the connect wait list - also sets connection state
;  to RCPS_LISTEN
;	c{EDI} = Offset of DCB
;	CALL	xosrcpPutConWait

xosrcpPutConWait::
	MOVL	EDX, dcb_ipstpdb.B[EDI]	;Get offset of the TPDB
	MOVL	ECX, tpdb_rcpcontail.B[EDX] ;Get tail of the CONREQ wait list
	JREGZ	ECX, 2$			;If list is empty
	MOVL	dcb_ipshashnext.B[ECX], EDI ;Not empty - link to end of list
	JMP	4$.S

2$:	MOVL	tpdb_rcpconhead.B[EDX], EDI
4$:	MOVL	tpdb_rcpcontail.B[EDX], EDI
	CLRL	EAX
	MOVL	dcb_ipshashnext.B[EDI], EAX
	MOVB	dcb_rcpstate.B[EDI], #RCPS_LISTEN ;Update connection state
	RET
.PAGE
	.SBTTL	xosrcpAcceptCon - Subroutine to accept connection when CONREQ received

;Subroutine to accept connection when CONREQ received on DCB in the RCPS_LISTEN
;  state
;	c{EDI} = Offset of DCB
;	CALL	xosrcpAcceptCon

xosrcpAcceptCon::
	MOVB	dcb_rcpstate.B[EDI], #RCPS_CAKSNT ;Update connection state
	MOVL	EBX, dcb_rcprcvhead.B[EDI] ;Get offset of packet
	CLRL	EDX
	MOVL	dcb_rcprcvhead.B[EDI], EDX
	MOVB	DL, npb_npofs.B[EBX]	;Point to IP header in packet
	MOVL	EAX, ip_srcipaddr.B[EBX+EDX] ;Get the remote IP address
	MOVL	dcb_ipsrmtaddr.B[EDI], EAX
	MOVZBL	EDX, npb_tpofs.B[EBX]	;Point to RCP header in packet
	ADDL	EDX, EBX
	MOVW	AX, [EDX]		;Get the remote port number
	MOVW	dcb_ipsrmtport.B[EDI], AX
	MOVL	EAX, rcp_seqnum.B[EDX]	;Get packet sequence number
	XCHGB	AL, AH			;Fix up the byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	dcb_rcprcvtnum.B[EDI], EAX
	INCL	EAX			;Plus one
	MOVL	dcb_rcprcvsnum.B[EDI], EAX ;Store as initial receive number
	MOVL	dcb_rcprcvwina.B[EDI], #5t ;Initialize receive window amount
	MOVL	dcb_rcprcvwinm.B[EDI], #5t
	MOVZWL	EAX, rcp_window.B[EDX]	;Initialize send window amount
	XCHGB	AL, AH
	MOVL	dcb_rcpsndwina[EDI], EAX
	MOVL	dcb_rcpsndwinm[EDI], EAX
	MOVL	EAX, rcp_data+0.B[EDX]	;Get packet size and keep-alive time
	SHRL	EAX, #16t		;Get keep-alive time
	XCHGB	AL, AH
	ADDL	EAX, EAX		;Times 2
	MOVL	dcb_rcpkareqtm.B[EDI], EAX
	MOVB	AL, rcp_data+4.B[EDX]	;Get RCP protocol version number
	MOVB	dcb_rcpversion.B[EDI], AL ;Store it
	CALL	rcpinittimeouts		;Set up our standard time-outs
	MOVL	ECX, rcp_data+8t.B[EDX] ;Get maximum retransmit time and
	MOVZWL	EAX, CX			;  initial retransmit time
	TESTL	EAX, EAX
	JE	2$.S
	ADDL	EAX, #MSPERTICK-1
	CLRL	EDX
	DIVL	knlLitMSPERTICK##
	MOVL	dcb_rcprxmtmax[EDI], EAX
2$:	MOVL	EAX, ECX		;Get initial retransmit time
	SHRL	EAX, #16t
	JE	4$.S
	ADDL	EAX, #MSPERTICK-1
	CLRL	EDX
	DIVL	knlLitMSPERTICK##
	MOVL	dcb_rcprxmttime[EDI], EAX
	SHLL	EAX, #3t
	MOVL	dcb_rcprxmtave[EDI], EAX
4$:	CALL	xosnetGiveBufr##	;Give up the received packet
	MOVL	EAX, dcb_ipstpdb.B[EDI]
	ADDL	tpdb_rcpseqnumber.B[EAX], #1000t
	MOVL	EAX, tpdb_rcpseqnumber.B[EAX] ;Initialize the sequence number
	MOVL	dcb_rcpsndsnum[EDI], EAX
	MOVL	dcb_rcprcvanum.B[EDI], EAX
	CMPL	dcb_ipshashnext[EDI], #-1.B ;Already in the hash table?
	JNE	12$.S			;Yes
	CALL	xosrcpHashSet#		;No - put DCB into the hash table now
12$:	CLC
	RET
.PAGE
	.SBTTL	xosrcpSendCONACK - Subroutine to send CONACK packet

;Subroutine to send CONACK packet
;	c{EDI} = Offset of DCB
;	CALL	xosrcpSendCONACK

xosrcpSendCONACK::
	MOVL	ECX, #12t.B
	MOVB	AL, #RCPP_CONACK
	CALL	xosrcpGetPkt#		;Get a CONACK packet
	JC	6$.S			;If can't get one
	MOVL	npb_dcb.B[EBX], EDI
	MOVZBL	ECX, npb_tpofs.B[EBX]
	ADDL	ECX, EBX
	MOVL	EAX, dcb_rcpsndsnum[EDI]
	MOVL	npb_seqnum.B[EBX], EAX
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	rcp_seqnum.B[ECX], EAX
	MOVL	EAX, dcb_rcpkareqtm.B[EDI] ;Get keep-alive time
	SHRL	EAX, #1
	XCHGB	AL, AH
	SHLL	EAX, #16t
	MOVL	EDX, dcb_netpdb.B[EDI]
	ORL	EAX, pdb_ipmaxpktsz[EDX] ;Get maximum packet size
	SUBL	EAX, #rcp_data.B
	XCHGB	AL, AH			;Fix up the byte order
	MOVL	rcp_data+0.B[ECX], EAX	;Store keep-alive time and maximum
	CLRL	EAX			;  packet size in the packet
	MOVL	rcp_data+4.B[ECX], EAX	;Clear the remaining reserved items
	MOVL	rcp_data+8.B[ECX], EAX
	CALL	rcpsetack#		;Set up acknowlegement stuff in packet
	CALL	xosipsSendSetup##	;Set up final IP header stuff
	MOVL	EAX, dcb_ipstpdb.B[EDI]
	INCL	tpdb_rcpcntpktout.B[EAX] ;Count the packet
	ADDL	tpdb_rcpcntbyteout.B[EAX], #rcp_data+12t.B
	MOVL	EAX, #xosnetGiveBufr##	;Send the packet and then give up the
	CALL	xossnpSendPkt##		;  buffer (but don't wait)
	CLC
6$:	RET
.PAGE
	.SBTTL	xosrcpClear - Subroutine to clear RCP connection

;Subroutine to clear RCP connection.  This is a graceful clear - it is done
;  by sending a RCPSF_KILREQ suppervisory packet and waiting for the other
;  end to send a RCPP_KILLREQ in reply.  If the KILLREQ is not received in
;  the interval specified by the value in EAX, a RCPP_KILLREQ packet is sent
;  anyway.  In this case, an ER_NORSP error is returned.  Must be called in
;  extended fork context
;	c{EAX} = Time-out value
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IDB
;	CALL	xosrcpClear
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosrcpClear:
	CMPL	EAX, #XT_SECOND*60t
	JBE	2$.S
	MOVL	EAX, #XT_SECOND*60t
2$:	MOVZBL	EDX, dcb_rcpstate.B[EDI] ;Get connection state
	JMPIL	CS:clrdsp[EDX*4]	;Dispatch on the state

	.MOD	4
clrdsp:	.LONG	clridle		;RCPS_CLOSED = 0  - Idle
	.LONG	clridle		;RCPS_LISTEN = 1  - Waiting for CONREQ
	.LONG	clrestab	;RCPS_CRQRCD = 2  - CONREQ received
	.LONG	clrestab	;RCPS_CRQSNT = 3  - CONREQ sent
	.LONG	clrestab	;RCPS_CAKRCD = 4  - CONACK received
	.LONG	clrestab	;RCPS_CAKSNT = 5  - CONACK sent
	.LONG	clrestab	;RCPS_ESTAB  = 6  - Connection established
	.LONG	clridle		;RCPS_KILREQ = 7  - Supervisory KILREQ sent
	.LONG	clridle		;RCPS_KILSNT = 8  - KILREQ sent
	.LONG	clridle		;RCPS_KILACK = 9  - KILACK sent
	.LONG	clridle		;RCPS_LOST   = 10 - Connection has been lost
	.LONG	clridle		;RCPS_TIMEWT = 11 - All finished - timing out
				;		      port

;Here when clearing if already idle or quiet

clridle:CALL	xosrcpGiveAll#		;Make sure don't have any buffers
	CLRL	EAX
	RET

;Here when clearing if a connection is established.  We send a RCPSF_KILREQ
;  supervisory packet and then wait for the other end to send a RCPP_KILLREQ
;  packet.

clrestab:
	PUSHL	EAX
	CALL	xosrcpChkWin		;Wait until window is open
	JC	10$.S
	MOVL	ECX, #5			;Get a 5 byte packet
	MOVB	AL, #RCPP_SUPER
	CALL	xosrcpGetPkt#
	JC	10$.S
	MOVB	rcp_data+0.B[EDX], #RCPSF_CLRREQ ;Store supervisory function
	MOVL	rcp_data+1.B[EDX], #RCPKR_REQ<24t ;Store reason
	CALL	xosrcpSendData#		;Send the packet
	JC	10$.S			;If error
	ORB	dcb_rcpsts1.B[EDI], #RCPS1$CLRREQ ;Remember this was sent
6$:	MOVL	EAX, [ESP]
	CALL	rcprspwait#		;Wait for a response
	JC	10$.S	
	TESTB	dcb_rcpsts1.B[EDI], #RCPS1$CLRRSP
	JE	6$.S
	CLRL	EAX
10$:	POPL	EDX			;Fix up the stack
	PUSHL	EAX			;Save the error code
	CALL	xosrcpKill		;Now try to kill it!
	JNC	14$.S
	MOVL	[ESP], EAX
14$:	POPL	EAX			;Restore error code
	BTL	EAX, #31t		;Set C if error
	RET
.PAGE
	.SBTTL	xosrcpKill - Subroutine to Kill an RCP connection

;Subroutine to kill an RCP connection.  This is an immediate kill.  It is done
;  by sending an RCPP_KILREQ packet.  This will discard any unreceived data
;  on either end.  Must be called in extended fork context
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IDB
;	CALL	xosrcpKill
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosrcpKill:
	MOVZBL	EAX, dcb_rcpstate.B[EDI] ;Get connection state
	JMPIL	CS:killdsp[EAX*4]	;Dispatch on the state

	.MOD	4
killdsp:.LONG	clridle		;RCPS_CLOSED =  0 - Idle
	.LONG	clridle		;RCPS_LISTEN =  1 - Waiting for CONREQ
	.LONG	killestab	;RCPS_CRQRCD =  2 - CONREQ received
	.LONG	killestab	;RCPS_CRQSNT =  3 - CONREQ sent
	.LONG	killestab	;RCPS_CAKRCD =  4 - CONREQ received
	.LONG	killestab	;RCPS_CAKSNT =  5 - CONACK sent
	.LONG	killestab	;RCPS_ESTAB  =  6 - Connection established
	.LONG	killestab	;RCPS_CLRREQ =  7 - Supervisory CLRREQ sent
	.LONG	clridle		;RCPS_KILSNT =  8 - KILREQ sent
	.LONG	clridle		;RCPS_KILACK =  9 - KILACK sent
	.LONG	clridle		;RCPS_LOST   = 10 - Connection has been lost
	.LONG	clridle		;RCPS_TIMEWT = 11 - All finished - timing out
				;		      port

;Here when killing if a connection is established - we send a KILREQ and then
;  wait for the reply KILACK

killestab:
	CALL	xosrcpGiveAll#		;Make sure no buffers allocated
	MOVB	dcb_rcpstate.B[EDI], #RCPS_KILSNT ;Update state
	CLRL	EAX			;Close our receive window
	MOVL	dcb_rcprcvwina.B[EDI], EAX
	MOVL	ECX, #4			;Get a 4 byte packet
	MOVB	AL, #RCPP_KILREQ
	CALL	xosrcpGetPkt#
	JC	8$.S
	MOVL	rcp_data.B[EDX], #RCPKR_REQ<24t ;Store reason
	CALL	xosrcpSendData#		;Send the packet
	JC	8$.S
6$:	CALL	rcprspwait#		;Wait for a response
	JC	8$.S			;If error
	CMPB	dcb_rcpstate.B[EDI], #RCPS_TIMEWT
	JNE	6$.S			;No - continue waiting
	JMP	10$.S			;Yes

;Here if error while sending a KILREQ or waiting for his KILACK

8$:	MOVB	dcb_rcpstate.B[EDI], #RCPS_TIMEWT ;Indicate almost idle

	CMPL	EAX, #ER_NORSP		;Time-out error?
	JNE	10$.S			;No
	MOVL	EAX, #ER_NCLST		;Yes - get right error code
10$:	PUSHL	EAX			;Save error code
	CALL	xosrcpGiveAll#		;Make sure don't have any buffers
	POPL	EAX
	BTL	EAX, #31t		;Set C if error
	RET
.PAGE
	.SBTTL	sd_inpblock - Input block

;Here for the input block entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	rcpinpblk
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

$$$=!0
FRM inp_amount , 4
inp_SIZE=!$$$

rcpinpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock all buffer pages
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_inpframe
	MOVL	iorb_routine.B[ESI], #rcpinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here if don't really want input

6$:	CLRL	EAX
8$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

;Here in extended fork context

rcpinpblk1:
	MOVL	SS:xffTimeOut##, #-1	;Default is no time-out
	CMPL	SS:xffParm##+0, #0.B	;Have any device parameters?
	JE	10$.S			;No
	MOVL	EBX, #rcpioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	8$.S
10$:	CMPL	SS:xffCount##, #0.B	;Really want input?
	JE	6$.S			;No
	CALL	xosrcpGetInputPkt	;Yes - get an input packet
	JC	8$.S
	MOVL	EAX, ECX
	MOVL	ECX, #QSTS$DONE
	CMPL	EAX, SS:xffCount##	;Bigger than his buffer?
	JBE	16$.S			;No
	ORB	CL, #QSTS$TRUNC		;Yes - indicate truncation
	MOVL	EAX, SS:xffCount##	;Only give him what fits in his buffer
16$:	CMPB	rcp_type.B[EDX], #RCPP_INT ;Interrupt packet?
	JNE	18$.S			;No
	ORB	CL, #QSTS$OOBD		;Yes - tell him that
18$:	PUSHL	ECX			;Save status bits
	PUSHL	EAX			;Save amount
	PUSHL	EDI
	LESL	EDI, SS:xffBuffer1##	;Get address of his buffer
	LEAL	ESI, rcp_data.B[EDX]
	CMPL	EAX, #4t.B
	JBE	20$.S
	CLRL	ECX
	SUBL	ECX, EDI
	ANDL	ECX, #03.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], [ESI]		;Copy his data from the packet (we do
	MOVL	ECX, EAX		;  as much as we can as a long-alligned
	SHRL	ECX, #2t		;  4-byte move)
	RMOVSL	[EDI], [ESI]
	ANDL	EAX, #03.B
20$:	MOVL	ECX, EAX
	RMOVSB	[EDI], [ESI]
	POPL	EDI
	CALL	xosnetGiveBufr##	;Give up the packet
	INCL	dcb_rcprcvwina.B[EDI]	;Open our receive window
22$:	MOVL	EBX, dcb_rcprcvhead.B[EDI] ;Have another packet?
	TESTL	EBX, EBX
	JE	24$.S			;No
	MOVZBL	EDX, npb_tpofs.B[EBX]	;Yes
	ADDL	EDX, EBX
	CMPB	rcp_type.B[EDX], #RCPP_SUPER ;Is it a supervisory packet
	JE	26$.S			;Yes
24$:	CALL	xosrcpOpenWindow#	;No - open sender's window if need to
	POPL	ECX			;Restore amount to return
	POPL	EBX			;Restore status bits
	CLRL	EAX			;Indicate OK
	RET				;Finished

;Here if have a supervisory packet

26$:	MOVL	EAX, npb_next.B[EBX]	;Remove packet from the receive list
	MOVL	dcb_rcprcvhead.B[EDI], EAX
	TESTL	EAX, EAX
	JNE	28$.S
	MOVL	dcb_rcprcvtail[EDI], EAX
28$:	INCL	dcb_rcprcvwina.B[EDI]	;Open our receive window
	CALL	rcpprocsuper#		;Process the supervisory packet
	JMP	22$.S			;Continue
.PAGE
	.SBTTL	sd_outstring - Output string

;Here for the output string entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	rcpoutstr
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

rcpoutstr:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoStringLock##	;Lock the string pages
	JNC	4$.S			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	sd_outblock - Output block

;Here for the output block entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	rcpoutblk
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

rcpoutblk:
	MOVL	EAX, dcb_netpdb.B[EDI]	;Get maximum packet size
	MOVL	EAX, pdb_ipmaxpktsz[EAX]
	SUBL	EAX, #rcp_data.B
	CMPL	iorb_count.B[ESI], EAX	;Is this packet too big?
	JA	knlICnDevGQ##		;Yes - fail
	CALL	knlIoQabLock##		;No - lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock all buffer pages
	JC	2$.S			;If error
4$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #rcpoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

rcpoutblk1:
	MOVL	SS:xffTimeOut##, #-1	;Default is no time-out
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	8$.S			;No
	MOVL	EBX, #rcpioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	10$.S
8$:	CMPL	SS:xffCount##, #0.B
	JE	14$			;If nothing to output
	MOVL	EAX, SS:xffTimeOut##	;Get time-out value
	CALL	xosrcpChkWin#		;Wait if window is closed
10$:	JC	16$.S			;If error
	MOVL	ECX, SS:xffCount##	;Allocate a packet
	MOVB	AL, #RCPP_DATA
	CALL	xosrcpGetPkt#
	JC	16$.S
	MOVL	EAX, SS:xffCount##
	LFSL	ESI, SS:xffBuffer1##	;OK - get address of buffer
	PUSHL	EDI
	LEAL	EDI, rcp_data.B[EDX]
	PUSHL	DS
	POPL	ES
	CMPL	EAX, #8t.B
	JBE	12$.S
	CLRL	ECX
	SUBL	ECX, EDI
	ANDL	ECX, #03.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], FS:[ESI]		;Copy his data to the packet (we do as
	MOVL	ECX, EAX		;  much as we can as a long-alligned
	SHRL	ECX, #2t		;  4-byte move)
	RMOVSL	[EDI], FS:[ESI]
	ANDL	EAX, #03h.B
12$:	MOVL	ECX, EAX
	RMOVSB	[EDI], FS:[ESI]
	POPL	EDI
	CALL	xosrcpSendData#
	JC	16$.S
	CLRL	EAX			;Finished
	MOVL	ECX, SS:xffCount##
14$:	MOVL	EBX, #QSTS$DONE
	RET

16$:	CLRL	ECX
	JMP	14$.S
.PAGE
	.SBTTL	xosrcpDfltPort - Subroutine to allocate default RCP port

;Subroutine to get default RCP port (which is really a UDP port!)
;	c{EDI} = Offset of DCB
;	CALL	xosrcpDfltPort
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c[CX] = Port number stored in dcb_ipslclport

xosrcpDfltPort::
	MOVL	EBX, dcb_ipstpdb.B[EDI]
	MOVL	EAX, tpdb_rcpdfltport.B[EBX] ;Get current default port number
	LEAL	ECX, 80000000[EAX]	;Set the search bit
	INCL	EAX			;Increment the number
	TESTB	AH, #80h		;Check for wrap-around
	JE	2$.S
	MOVL	EAX, #401
2$:	MOVL	tpdb_rcpdfltport.B[EBX], EAX
					;Fall into xosrcpGetPort

	.SBTTL	xosrcpGetPort - Subroutine to allocate an RCP port

;Subroutine to get an RCP port (which is really a UDP port!)
;	c{ECX} = Desired port number, bit 31 set if should increment number
;		   if not acceptable, bit 30 set if duplicate number OK (bit 30
;		   is tested first)
;	c{EDI} = Offset of DCB
;	CALL	xosrcpGetPort
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c[CX] = Port number stored in dcb_ipslclport

xosrcpGetPort:
	MOVL	EAX, dcb_ipstpdb.B[EDI]
	PUSHL	EAX			;Save the offset of the RCP TPDB
	MOVL	EAX, tpdb_tpdb.B[EAX]	;Change it to be the underlying UDP TPDB
	MOVL	dcb_ipstpdb.B[EDI], EAX
	CALL	xosipsGetPort##		;Allocate the port
	POPL	dcb_ipstpdb.B[EDI]	;Restore offset of our TPDB
	RET				;Thats all

	.SBTTL	xosrcpGivePort - Subroutine to give up an RCP port

;Subroutine to give up an RCP port (which is really a UDP port!)
;	c{EDI} = Offset of DCB
;	CALL	xosrcpGivePort
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c[CX] = Port number stored in dcb_ipslclport

xosrcpGivePort:
	MOVL	EAX, dcb_ipstpdb.B[EDI]
	PUSHL	EAX			;Save the offset of the RCP TPDB
	MOVL	EAX, tpdb_tpdb.B[EAX]	;Change it to be the underlying UDP TPDB
	MOVL	dcb_ipstpdb.B[EDI], EAX
	CALL	xosipsGivePort##	;Allocate the port
	POPL	dcb_ipstpdb.B[EDI]	;Restore offset of our TPDB
	RET				;Thats all
.PAGE
	.SBTTL	xosrcpGetInputPkt - Subroutine to get next input packet

;Subroutine to get next input packet
;	c{EDI} = Offset of DCB
;	CALL	xosrcpGetInputPkt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EBX} = Offset of packet buffer
;	  c{ECX} = Length of data part (does not include the RCP header)
;	  c{EDX} = Offset of start of RCP header

xosrcpGetInputPkt:
	CMPB	dcb_rcpstate.B[EDI], #RCPS_ESTAB ;Yes - still have a connection?
	JE	2$.S			;Yes
	CMPB	dcb_rcpstate.B[EDI], #RCPS_CAKRCD ;Maybe
	JE	2$.S			;Yes
	CMPB	dcb_rcpstate.B[EDI], #RCPS_CAKSNT ;Maybe
	JNE	10$.S			;No
2$:	MOVL	EBX, dcb_rcprcvhead.B[EDI] ;Yes - get a received packet
	TESTL	EBX, EBX		;Do we have one?
	JNE	4$.S			;Yes - go on
	MOVL	EAX, SS:xffTimeOut##	;No - wait until we do
	CALL	xosnetRspWait#
	JNC	xosrcpGetInputPkt.S	;Check again if OK
	RET				;Give up if error while waiting

;Here with a packet

4$:	MOVL	EAX, npb_next.B[EBX]	;Remove packet from the receive list
	MOVL	dcb_rcprcvhead.B[EDI], EAX
	TESTL	EAX, EAX
	JNE	6$.S
	MOVL	dcb_rcprcvtail[EDI], EAX
6$:	MOVZBL	EDX, npb_tpofs.B[EBX]
	MOVL	ECX, npb_count.B[EBX]	;Get size of the packet
	SUBL	ECX, EDX
	ADDL	EDX, EBX		;Get offset of the RCP header
	SUBL	ECX, #rcp_data.B
	JS	14$.S			;If too small for the header
	RET

;Here if we have lost our connection

10$:	MOVL	EAX, #ER_NCCLR
	TESTB	dcb_rcpsts1.B[EDI], #RCPS1$LOST
	JE	12$.S
	MOVB	AL, #ER_NCLST&0FFh
12$:	STC
	RET

;Here if packet is too small - this should have been caught sooner!

14$:	CRASH	RCPS			;[RCP Size error]
.PAGE
	DATA

rcpccb::       .BLKB ccb_SIZE	;RCP CCB
rcptwhead::    .LONG 0		;Head pointer for RCP timer list
xosrcpTpdbHead:.LONG 0		;Offset of first RCP device DPDB
temp:	       .BLKB 12t	;Buffer for destination message names
lit10:         .LONG 10t

	LKEEND
