	.TITLE	XFPOCLS - XFPO routines for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXIPS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTCP.PAR
	.INCLUD	XOSINC:\XMAC\XOSXXFPO.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!2t
MINV   =!0t
EDITNUM=!0t

	LKEHEAD	XFPOCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

FOBITS=!FO$NODENUM|FO$NODENAME|FO$RXOSNAME|FO$RDOSNAME|FO$RVOLNAME
FOBITS=!FOBITS|FO$PATHNAME|FO$PATHDOS|FO$FILENAME|FO$FILEDOS|FO$ATTR|FO$VERSION

$$$=0
FRM opx_frame1  , 4t
FRM opx_frame2  , 4t
FRM opx_newname , 4t		;Offset of new name string for rename
FRM opx_newnsz  , 4t		;Size of new name string for rename
FRM opx_rspsz   , 4t		;Response size
FRM opx_datasz  , 4t		;Size of data or name
FRM opx_parmsz  , 4t		;Size of parameter list
FRM opx_msgsz   , 4t		;Total message size
FRM opx_msgtype , 1t		;Message type
FRM             , 3t
FRM opx_error   , 4t		;Error code
FRM opx_parmerr1, 4t		;Parameter error bits
FRM opx_parmerr2, 4t
FRM opx_devsts  , 4t
FRM opx_unitnum , 4t
FRM opx_filattr , 4t
FRM opx_glbid   , 16t
FRM opx_amount  , 4t
FRM opx_parm    , 4t
opx_SIZE=!$$$-8

	CODE

	.SBTTL	SVC dispatch table for XFPO devices

;SVC dispatch table for XFPO devices

xfpdsp:	.LONG	knlRtnZero##	;sd_mount	=  0. - Mount
	.LONG	knlRtnZero##	;sd_cleardev	=  4. - Clear device
	.LONG	xostcpGiveDcb##	;sd_cleardcb	=  8. - Clear DCB
	.LONG	knlRtnZero##	;sd_commit	= 12. - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold    = 16. - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew    = 20. - Transfer device/new
	.LONG	knlNullQio##	;sd_opena	= 24. - Open additional
	.LONG	xfpopen		;sd_open1	= 28. - Open device/file
	.LONG	xfpdevparm	;sd_devparm     = 32. - Device parameters
	.LONG	xfpdelete	;sd_delete	= 36. - Delete file
	.LONG	xfprename	;sd_rename	= 40. - Rename file
	.LONG	xfpinpblk	;sd_inblock	= 44. - Input block
	.LONG	xfpoutblk	;sd_outblock	= 48. - Output block
	.LONG	xfpoutblk1	;sd_outblockq	= 52. - Output block (XFF)
	.LONG	xfpoutstr	;sd_outstring	= 56. - Output string
	.LONG	knlRtnMOne##	;sd_getiosts	= 60. - Get input/output status
	.LONG	knlIFnDevGQ##	;sd_special     = 64. - Special device function
	.LONG	xfpclose	;sd_close	= 68. - Close file
	.LONG	knlNullLabel##	;sd_label       = 72. - Get device label
	.LONG	xfpcommit	;sd_commitfunc	= 76. - Commit data to disk
	.LONG	knlInfoNone##	;sd_devinfo     = 80. - Get device info
XFPDSPSZ=!{$-xfpdsp}/4

;Class function dispatch table for XFP class devices

	.LONG	XFPCLSFMX
xfpcls::.LONG	xfpaddunit	;CF_ADDUNIT = 1. - Add unit
	.LONG	xfpunitinfo	;CF_PUNITS  = 2. - Get information about
				;		     physical units
	.LONG	knlIFnDev##	;CF_AUNITS  = 3. - Get information about active
				;		     units
XFPCLSFMX=!{$-xfpcls}/4
.PAGE
;Device characteristics tables for the XFP devices

	DATA

	.MOD	4
xfpdctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS  , TEXT, ,  8, knlDcMsgClass##  , knlDcGetClass##    , knlDcSetClass##    , 0
 DCHARENT  TCPDEV , TEXT, , 16, xostcpMsgTcpDev##, xostcpGetTcpDev##  , 0                  , 0
 DCHARENT  RETRY1 , DECV, ,  1, xosipsMsgRetry1##, xosipsGetDpdbByte##, xosipsSetDpdbByte##, dpdb_tcpxfporetry1
 DCHARENT  RETRY2 , DECV, ,  1, xosipsMsgRetry2##, xosipsGetDpdbByte##, xosipsSetDpdbByte##, dpdb_tcpxfporetry2
 DCHARENT  RMTPORT, DECV, ,  4, msgrmtport       , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rmtport
 DCHARENT  MSGIN  , DECV, ,  4, msgmsgin         , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpocntmsgin
 DCHARENT  BYTEIN , DECV, ,  4, knlDcMsgByteIn## , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpocntbytein
 DCHARENT  MSGOUT , DECV, ,  4, msgmsgout        , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpocntmsgout
 DCHARENT  BYTEOUT, DECV, ,  4, knlDcMsgByteOut##, xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpocntbyteout
 DCHARENT  PROERR , DECV, ,  4, msgproerr        , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpocntproerr

	CODE

msgrmtport:DCHARINFO  {Remote (server) port}
msgmsgin:  DCHARINFO  {Number of messages input}
msgmsgout: DCHARINFO  {Number of messages output}
msgproerr: DCHARINFO  {Protocol errors}
.PAGE
	.SBTTL	xfpinit - Initialization routine for XFPO class devices

	INITSUB	xfpinit

;The command for installing XFPOCLS is:
;	LKELOAD XFPCLS

xfpinit:MOVL	EDI, #xfpchk		;Install the XFP class
	MOVL	EBX, #xfpcls		;Offset of class function dispatch table
	CLRL	ECX
	MOVL	EAX, #'XFPO'
	CLRL	EDX
	MOVL	ESI, #xfpccb
	CALL	knlNewClass##
	JC	10$.S
	MOVL	ECX, #codetop
	CLRL	EDX
	CLRL	EAX
10$:	MOVL	EBX, #QSTS$DONE
	RET

	CODE
.PAGE
	.SBTTL	xfpaddunit - Subroutine to add XFP "unit"

;Subroutine to add XFPO "unit" - this is a logical unit which implements the
;  XFPO application level protocol for a single transport level (TCP) unit
;  - multiple XFPO units may be set up for different TCP units if desired
;	c{ES:EDI} = Address of data block
;	CALL	xfpaddunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count

$$$=!0
FRM xfpau_tpdb, 4t	;Offset of TCP TPDB
FRM xfpau_unit, 4t	;Unit number
FRM xfpau_pdb , 4t	;Offset of PDB
xfpau_SIZE=!$$$

	DATA

	.MOD	4
xfpaublk:				;Parameter description block for
 DCHARBGN  2, knlDCharValCom##		;  adduparms
 DCHARENT  UNIT  , DECV, ,  1, 0, 0, xfpauunit  , 0
 DCHARENT  TCPDEV, TEXT, , 16, 0, 0, xfpautcpdev, 0

	CODE

xfpaddunit:
	ENTER	xfpau_SIZE, 0		;Allocate our stack frame
	CLRL	EAX
	MOVL	xfpau_tpdb.B[EBP], EAX	;Store illegal values for TCP TPDB
	DECL	EAX			;  and unit number
	MOVL	xfpau_unit.B[EBP], EAX
	IFFAULT	4$
	LFSL	EDX, iorb_buffer2.B[ESI]
	CALL	knlGiveQel##		;Give up the IORB
	MOVL	EBX, #xfpaublk		;Process the characteristics
	MOVB	AL, #0			;Fail on bad names
	CALL	knlAddUnitChar##
	JC	2$.S			;If error
	MOVL	EAX, xfpau_tpdb.B[EBP]	;Make sure TCP device and unit number
	DECL	EAX			;  are specified
	ORL	EAX, xfpau_unit.B[EBP]
	INCL	EAX
	JNE	6$.S
	MOVL	EAX, #ER_CHARM
2$:	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	LEAVE
	TOFORK
	RET
		
;Here if address error with the IORB

4$:	CALL	knlGiveQel##
	MOVL	EAX, #ER_ADRER
	JMP	2$.S

;Here if have all required characteristics

6$:	PUSHL	xfpau_unit.B[EBP]	;Stack unit number
	PUSHL	#dpdb_tcpxfpoSIZE	;Stack DPDB size
	PUSHL	#'XFP'			;Stack base name
	PUSHL	#dcb_xfpoINDEX.B		;Stack size index for DCB
	PUSHL	#xfpccb			;Stack offset of the XFPO CCB
	PUSHL	xfpau_tpdb.B[EBP]	;Stack offset of first TCP TPDB
	PUSHL	#xfpdpdbhead		;Stack offset of XFPO DPDB head pointer
	CALL	xosipsMakeDev##		;Create new network device
	JC	2$.S			;If error
	CALL	knlGiveXRes##		;Give up the exec memory resource
	MOVB	CL, dpdb_unit.B[EDI]	;Get unit number
10$:	MOVL	dpdb_rmtport.B[EDI], #TCPP_XFPO ;Store default remote port
	MOVB	dpdb_tcpxfporetry1.B[EDI], #RETRY_TRN1 ;Initialize default retry
	MOVB	dpdb_tcpxfporetry2.B[EDI], #RETRY_TRN2 ;  levels
	MOVL	EDI, dpdb_nextd.B[EDI]
	TESTL	EDI, EDI
	JE	12$.S
	CMPB	CL, dpdb_unit.B[EDI]
	JE	10$.S
12$:	CLRL	EAX
	JMP	2$.S
.PAGE
;Subroutine called by adduparms for the "UNIT" parameter

xfpauunit:
	CMPL	EAX, #100t.B		;Valid value?
	JAE	knlBadParmV##
	MOVL	xfpau_unit.B[EBP], EAX
	CLC
	RET

;Subroutine called by adduparms for the "TCPDEV" parameter

xfpautcpdev:
	MOVL	EAX, xfpau_tpdb.B[EBP]	;Get current TCP TPDB offset
	CALL	xostcpAuTcpDev##	;Get TCP TPDB offset
	JC	2$.S			;If error
	MOVL	xfpau_tpdb.B[EBP], EDI	;OK - store TCP TPDB offset
2$:	RET
.PAGE
	.SBTTL	xfpunitinfo - XFPO class get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  XFPO class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	xfpunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

xfpunitinfo:
	CRASH	NIYT
.PAGE
	.SBTTL	xfpchk - Device check routine for XFPO class devices

;Device check routine for XFPO class devices
;	c{SS:EBX} = Address of device name (16 characters)
;	CALL	xfpchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  ESI is preserved

xfpchk:	CMPL	SS:[EBX], #'XFPO'	;Is this XFPO*?
	JNE	4$.S			;No
	MOVL	EDI, xfpdpdbhead	;Yes - get offset of first XFP DPDB
	LEAL	ECX, 3.B[EBX]		;Get offset of 1st unit number character
	MOVL	EDX, #DS$SODIR|DS$FILE
	CALL	xosipsFindDev##		;Find matching network device
	JC	2$.S			;If error
	JNE	2$.S			;Or if not a match
	MOVL	dcb_sdisp.B[EDI], #xfpdsp ;Store offset of SVC dispatch table
	MOVL	dcb_tcpfuncdisp.B[EDI], #xostcpFncDisp## ;Store offset of func
	MOVL	EAX, dcb_ipsdpdb.B[EDI]			 ;  dispatch table
	MOVW	AX, dpdb_tcpxfporetry1.B[EAX] ;Store default retransmission
	MOVW	dcb_tcpretry1.B[EDI], AX  ;  threshold values
	MOVL	dcb_netmode.B[EDI], #NMTCP$PUSH ;Set default modes
	MOVL	dcb_devchar.B[EDI], #xfpdctbl ;Use our device characteristics
	MOVB	dcb_ipsprot.B[EDI], #IPP_TCP ;Store protocol value
	MOVL	ECX, #80000401h		;Assign default port number
	CALL	xosipsGetPort##
	JC	10$.S
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Store remote port number
	MOVL	EAX, dpdb_rmtport.B[EAX]	
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport.B[EDI], AX
	CLRL	EAX			;Set Z
2$:	RET				;And return

4$:	CLC
	RET

;Here if can't allocate default port number

10$:	PUSHL	EAX
	CALL	xosnetGiveDcb##
	POPL	EAX
	STC
	RET
.PAGE
	.SBTTL	sd_devparm - Device parameter function

;Here for the device parameter function entry
;	c{SS:EDX} = Offset of name buffer
;	c{EDI}    = Offset of DCB
;	CALL	xfpdevparm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpdevparm:
	MOVB	AL, #XFPOF_PARM
	JMP	4$.S

2$:	ANDB	SS:xffCmd##, #~{O$IN|O$OUT} ;No IO allowed
	MOVL	ECX, #1
	CLRL	EAX
	RET

	.SBTTL	sd_open - Open device

;Here for the open device entry
;	c{SS:EDX} = Offset of name buffer
;	c{EDI}    = Offset of DCB
;	CALL	xfpopen
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpopen:MOVB	AL, #XFPOF_OPEN
4$:	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Raw or physical IO?
	JE	open2.S			;No
	CMPB	SS:[EDX], #0		;Yes - have any file spec?
	JE	2$.S			;No - make this a local open
open2:	MOVB	SS:xffQueue##, #dcb_outframe ;Yes - set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	ENTER	opx_SIZE, 2
	MOVB	opx_msgtype.B[EBP], AL
	MOVL	opx_newname.B[EBP], ESI	;Store offset of new name in case rename
	CLRL	EAX
	MOVL	SS:xffCount##, EAX
	MOVL	opx_newnsz.B[EBP], EAX
	MOVW	dcb_outframe.B[EDI], SS	;Set up an output queue
	MOVB	SS:xffQueue##, #dcb_outframe
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%LCLPORT ;Local port number specified?
	JNC	6$.S			;No
	MOVL	ECX, opx_frame1.B[EBP]	;Yes
	MOVL	ECX, SS:opn_lclport[ECX] ;Use it
	PUSHL	EDX
	CALL	xosipsGetPort##
	POPL	EDX
	JC	16$.S			;If error setting the local port number
6$:	BTL	SS:xffHvValue1##, #IOV1%RMTPORTS ;Remote port number specified?
	JNC	8$.S			;No
	MOVL	EAX, opn_rmtports[EBP]	;Yes - use it
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport.B[EDI], AX
8$:	CLRL	ECX
	MOVB	dcb_xfposts1[EDI], CL	;Clear our network status byte
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Want to search open directory?
	JNC	18$.S			;No
	CALL	xosnetChkNetAddr##		;Yes - skip possible network address
	JNE	14$.S
	LEAL	EDX, 1.B[ECX]
14$:	CMPB	opx_msgtype.B[EBP], #XFPOF_OPEN ;Is this an open?
	JNE	havetcp.S		;No - this is OK
	MOVL	EAX, #ER_IFDEV		;CAN'T HANDLE THIS YET!!!!
16$:	CLRL	ECX
	LEAVE
	STC
	RET

;Here to establish a TCP connection

18$:	MOVL	EAX, #2070t+15t		;Get window sizes
	MOVB	CL, #3
	CALL	xostcpConnect##		;Establish the TCP connection
	JC	16$.S			;If error
					;OK - fall into havetcp on next page
.PAGE
;Here when we have a TCP connection - any errors after this point MUST clear
;  this connection before returning (except that we abandon the connection
;  if have a serious protocol error)!

havetcp:CALL	checkspec
	MOVL	opx_datasz.B[EBP], ECX
	PUSHL	EDX
	CMPB	opx_msgtype.B[EBP], #XFPOF_RENAME ;Is this a rename?
	JNE	2$.S			;No
	MOVL	EDX, opx_newname.B[EBP]	;Yes - get length of new name
	CALL	checkspec
	MOVL	opx_newnsz.B[EBP], ECX
2$:	CALL	checkparm
	ADDL	ECX, #4.B		;Assume need one byte for count
	ADDL	ECX, opx_datasz.B[EBP]	;Get total length for message
	ADDL	ECX, opx_newnsz.B[EBP]
	PUSHL	ECX
	ADDL	ECX, #4.B
	CALL	xostcpAlloc##		;Allocate space for the open command
	POPL	ECX
	POPL	EDX
	JC	opener			;If error
	PUSHL	EDX
	MOVB	AL, opx_msgtype.B[EBP]	;Construct header
	SHLL	EAX, #24t
	ORL	EAX, ECX
	CALL	xostcpPutLong##		;Store it
	MOVL	EAX, SS:xffCmd##	;Store device command bits
	CALL	xostcpPutLong
	POPL	EDX
	MOVL	EAX, opx_datasz.B[EBP]
	CALL	storespec		;Store file specification in packet
	CMPB	opx_msgtype.B[EBP], #XFPOF_RENAME ;Is this a rename?
	JNE	4$.S			;No
	MOVL	EDX, opx_newname.B[EBP]	;Yes
	MOVL	EAX, opx_newnsz.B[EBP]
	CALL	storespec
4$:	CALL	storeparm		;Store parameters in the packet
	CALL	xfppush			;Send the packet
	JC	opener.S		;If error
	CALL	opendn
	LEAVE
	RET
.PAGE
;Here with file open request message sent

opendn:	CALL	xfprcvblk		;Get the response
	JC	8$.S			;If error
	TESTL	EAX, EAX		;Error reported by server?
	JS	4$.S			;Yes - don't check response type
	MOVB	BH, #XFPOF_RESPONSE	;No - assume not open
	CMPB	opx_msgtype.B[EBP], #XFPOF_OPEN ;Right?
	JNE	2$.S			;Yes
	MOVB	BH, #XFPOF_OPNRESP
2$:	CMPB	BL, BH			;Is the response type right?
	JNE	openft			;No - fail
4$:	MOVL	opx_error.B[EBP], EAX	;Yes - save error code
	MOVL	SS:xffCount##, ECX	;Save item count
	MOVL	opx_rspsz.B[EBP], EDX	;Save bytes remaining in message
	CALL	xfpparm			;Process parameters
	JC	opener.S		;If error
	CALL	xfppar2			;OK
	MOVL	EAX, opx_error.B[EBP]	;Get server's error code
	TESTL	EAX, EAX
	JE	12$.S			;If no error
	JNS	openft.S		;If positive (fatal error)
opener:	CMPB	dcb_xfpofcnt[EDI], #0	;Have any other files open on the
					;  connection?
	JNE	10$.S			;Yes
8$:	PUSHL	EAX			;No - save error code
	CALL	xostcpClear##		;Clear the TCP connection
	POPL	EAX
10$:	BTL	EAX, #31t		;Set C if error
	JMP	14$.S

;Here if no errors on the open

12$:	CMPB	opx_msgtype.B[EBP], #XFPOF_OPEN ;Really an open?
	JNE	opener.S		;No - close the connection if need to
	INCB	dcb_xfpofcnt[EDI]	;Yes - count the open file
	BTL	SS:xffCmd##, #O%ODF	;Is this a open as a directory?
	JNC	14$.S			;No
	ORB	dcb_sts2.B[EDI], #D2$DIRECT ;Yes - indicate this
14$:	MOVL	ECX, SS:xffCount##	;Get item count
	RET				;All done

openft:	CALL	proterr			;Positive - fatal error!
	JMP	8$.S
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	xfpclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

xfpclose:
	CALL	knlIoClsLock##		;Lock the QAB
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfpclose1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

xfpclose1:
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	CMPL	dcb_opencnt.B[EDI], #1.B ;Final close?
	JNE	2$.S			;No
	TESTB	dcb_tcpsts1.B[EDI], #TCPS1$FATAL ;Is the XFPO level still alive?
	JNE	2$.S			;No
	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;Yes - is the connection open?
	JE	10$.S			;Yes

;Here if not final close or if the TCP connection is already closed

2$:	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	4$.S			;No
	MOVL	EBX, #ioparms		;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	8$
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	6$.S
4$:	CLRL	EAX
6$:	JMP	knlXfCloseFin##

	FAULTHDR
8$:	MOVL	EAX, #ER_ADRER
	JMP	6$.S

;Here if final close and the TCP connection is still open

10$:	CALL	xfppush			;Make sure all output done
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	16$.S			;If error
	ENTER	opx_SIZE, 2
	CALL	checkparm		;See how much space for parameters
	ADDL	ECX, #2.B
	PUSHL	ECX
	ADDL	ECX, #4.B
	MOVL	EAX, #TIMEOUT_CON
	CALL	xostcpAlloc##		;Allocate space for the close message
	POPL	ECX
	JC	14$.S			;If error
	LEAL	EAX, XFPOF_CLOSE<24t[ECX] ;Store the message header
	CALL	xostcpPutLong##
	MOVL	EAX, #1
	CALL	xostcpPutWord##
	CALL	storeparm		;Store possible parameters
	CALL	xfppush			;Send the close message
	JC	14$.S			;If error
	DECB	dcb_xfpofcnt[EDI]	;Reduce the open file count
	CALL	opendn			;Get response and clear the connection
	LEAVE
	LEAVE
12$:	JMP	knlXfCloseFin##

;Here if error

14$:	LEAVE
16$:	LEAVE
	PUSHL	EAX
	CALL	xostcpClear##		;Clear the TCP connection
	POPL	EAX
	JMP	12$.S
.PAGE
;Here for the sd_commitfunc entry - commit data to disk
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	xfpcommit
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpcommit:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoParmLock##		;Lock the parameter list
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfpcommit1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
ret006:	RET

;Here in extended fork context

xfpcommit1:
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	16$.S			;If error
	ENTER	opx_SIZE, 2
	CALL	checkparmio		;Calculate space needed for parameters
	INCL	ECX
	PUSHL	ECX
	ADDL	ECX, #4.B
	MOVL	EAX, SS:xffTimeOut##
	CALL	xostcpAlloc##		;Allocate space for the command
	POPL	ECX
	JC	16$.S			;If error
	LEAL	EAX, XFPOF_COMMIT<24t[ECX] ;Store the message header
	CALL	xostcpPutLong##
	MOVB	AL, #1			;Store the file handle
	CALL	xostcpPutByte##
	CALL	storeparm		;Store parameters
	CLRL	EAX
	MOVL	SS:xffParm##, EAX
	CALL	xfppush			;Send the command
	JC	16$.S			;If error
10$:	CALL	xfprcvblk		;Get the response
	JC	16$.S			;If error
	TESTL	EAX, EAX		;Error reported by server?
	JS	14$.S			;Yes - don't check response type
	CMPB	BL, #XFPOF_RESPONSE	;Is the response type right?
	JNE	20$.S			;No - fail
14$:	MOVL	opx_error.B[EBP], EAX	;Yes - save error code
	MOVL	SS:xffCount##, ECX	;Save item count
	MOVL	opx_rspsz.B[EBP], EDX	;Save bytes remaining in message
	CALL	xfpparm			;Process parameters
	JC	16$.S			;If error
	CALL	xfppar2			;OK
	MOVL	EAX, opx_error.B[EBP]	;Get server's error code
	CMPL	EAX, #0.B
	JG	20$.S			;If bad error code
16$:	LEAVE
	LEAVE
	MOVL	ECX, SS:xffCount##	;Get item count
	MOVL	EBX, #QSTS$DONE
	RET

;Here with fatal protocol error

20$:	CALL	proterr
	CLRL	ECX
	LEAVE
	LEAVE
	RET
.PAGE
;Here for the sd_inpblock entry - input block
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	xfpinpblock
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpinpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock the buffer pages
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_inpframe
	MOVL	iorb_routine.B[ESI], #xfpinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here in extended fork context

xfpinpblk1:
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	6$.S			;If error
	ENTER	opx_SIZE, 2
	CALL	checkparmio		;Calculate space needed for parameters
	CMPL	SS:xffCount##, #0.B	;Really doing IO?
	JNE	10$.S			;Yes
	TESTL	ECX, ECX		;No - have any parameters?
	JNE	12$.S			;Yes
	CLRL	EAX			;No - nothing to do here
	LEAVE
6$:	LEAVE
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

8$:	LEAVE
	JMP	knlIllInpLv##

;Here if really doing input

10$:	TESTB	SS:xffCmd##, #O$IN	;Is input allowed?
	JE	8$.S			;No - fail
12$:	ADDL	ECX, #5.B		;Yes
	PUSHL	ECX
	ADDL	ECX, #4.B
	MOVL	EAX, SS:xffTimeOut##
	CALL	xostcpAlloc##		;Allocate space for the data request
	POPL	ECX
14$:	JC	38$			;If error
	LEAL	EAX, XFPOF_DATAREQ<24t[ECX] ;Store the message header
	CALL	xostcpPutLong##
	MOVB	AL, #1			;Store the file handle
	CALL	xostcpPutByte##
	MOVL	EAX, SS:xffCount##	;Store amount wanted
	CALL	xostcpPutLong##
	CALL	storeparm		;Store parameters
	CLRL	EAX
	MOVL	SS:xffParm##, EAX
	CALL	xfppush			;Send the data request
	JC	14$.S			;If error
16$:	CALL	xfprcvblk		;Get the response
	JC	14$.S			;If error
	MOVL	ECX, EDX		;No
	MOVL	opx_rspsz.B[EBP], ECX	;Store amount left
	TESTL	EAX, EAX		;Error reported by server?
	JS	40$			;Yes
	CMPB	BL, #XFPOF_DRESP		;Valid message type?
	JB	46$			;No
	CMPB	BL, #XFPOF_DRESPFPAR	;Maybe
	JA	46$			;No - protocol error!
	MOVB	opx_msgtype.B[EBP], BL	;Remember the message type
	TESTB	BL, #01			;Have any parameters?
	JNE	24$.S			;No
	DECL	opx_rspsz.B[EBP]	;Yes - must have at least a count byte
	JS	18$.S
	CALL	xostcpGetByte##		;Get the first count byte
	JC	20$.S
	MOVB	AH, #0			;Assume only need one count byte
	TESTB	AL, #80h		;Need a second count byte?
	JE	22$.S			;No
	DECL	opx_rspsz.B[EBP]	;Yes
18$:	JS	46$
	PUSHL	EAX
	CALL	xostcpGetByte##		;Get it
	POPL	EDX
20$:	JC	48$
	MOVB	AH, DL
22$:	ANDL	EAX, #7FFFh
	MOVL	ECX, EAX
24$:	SUBL	opx_rspsz.B[EBP], ECX	;Reduce amount we have
	JC	26$.S			;Fail if not enough there
	SUBL	SS:xffCount##, ECX	;Bigger than we wanted?
26$:	JC	46$			;Yes - serious error!
28$:	PUSHL	ECX
	JREGZ	ECX, 30$
	LESL	EBX, SS:xffBuffer1##

;;;;;;;	MOVL	EAX, #25t*XT_SECOND	;;;;;;;;;; INSERT THIS TO TEST
;;;;;;;	CALL	knlXfWait##		;;;;;;;;;; WINDOW PROBES!

	MOVL	EAX, #TIMEOUT_AP	;Get time-out value
	CALL	xostcpGetBlk##		;Give the data to the user
	JC	44$.S
30$:	PUSHL	ECX
	CALL	xfpparm			;Process parameters from the message
	JC	32$.S
	CALL	xostcpOpenWindow##	;Open our window if we need to now
32$:	POPL	ECX
	POPL	EDX
	JC	46$.S
	ADDL	SS:xffBuffer1##, ECX
	ADDL	opx_amount.B[EBP], ECX
	SUBL	EDX, ECX		;Need more from this message?
	MOVL	ECX, EDX
	JNE	28$.S			;Yes
	CMPB	opx_msgtype.B[EBP], #XFPOF_DRESPF ;No - final part?
	JAE	34$.S			;Yes - stop here
	CMPL	SS:xffCount##, #0.B	;No - need another message?
	JNE	16$			;Yes - continue
34$:	CLRL	EAX
36$:	PUSHL	EAX
	MOVL	EAX, opx_parm.B[EBP]	;Restore parameter list offset
	MOVL	SS:xffParm##, EAX
	CALL	xfppar2			;Process parameter list
	POPL	EAX
38$:	MOVL	ECX, opx_amount.B[EBP]
	LEAVE
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

;Here if error reported by host

40$:	PUSHL	EAX
	CALL	xfpparm			;Process parameters from the message
	JC	42$.S			;If error
	CALL	xostcpOpenWindow#	;Open our window if we need to now
	POPL	EAX
	CMPL	EAX, #ER_EOF		;End of file?
	JNE	36$.S			;No
	CMPL	opx_amount.B[EBP], #0.B	;Yes - did we get anything at all?
	JE	36$.S			;No - report the error
	JMP	34$.S			;Yes - just return what we got

;Here if error while processing parameters

42$:	POPL	ECX			;Discard the original error code
	JMP	36$.S

;Here if error return from tcpgetblk

44$:	POPL	EDX
	ADDL	opx_amount.B[EBP], ECX
	JMP	38$.S

;Here if have fatal protocol error

46$:	CALL	proterr
	JMP	38$.S

48$:	CALL	xostcpFatal##
	JMP	38$.S
.PAGE
	.SBTTL	xfpoutstr - Queued output null terminated string

;Here for the sd_outstring entry - output null terminated string
;	c{EDI}    = Offset of DCB
;	c{FS:EDX} = Address of QAB
;	CALL	xfpoutstr
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpoutstr:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoStringLock##	;Lock the string pages
	JNC	4$.S			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	xfpoutblk - Queued output block

;Here for the sd_outblock entry - output block
;	c{ESI} = Offset of QAB
;	c{EDI} = Offset of DCB
;	CALL	xfpoutblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

$$$=!0
FRM xo_count  , 4
FRM xo_iosize , 4
FRM xo_amount , 4
FRM xo_error  , 4
FRM xo_pktsize, 4
xo_SIZE=!$$$

xfpoutblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock the buffer pages
	JC	2$.S			;If error
4$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfpoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context

6$:	LEAVE
	CLRL	ECX			;Report nothing received
	MOVL	EBX, #QSTS$DONE
	RET				;And return

;Here in extended fork context

xfpoutblk1:
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	6$.S			;If error
	ENTER	opx_SIZE, 2		;Set up our stack frame
	CALL	checkparmio		;See how much space is needed for
					;  parameters
8$:	MOVL	ECX, SS:xffCount##	;Get amount wanted
	CMPL	ECX, #XFPOMXSIZE	;Too much for one message?
	JB	10$.S			;No
	MOVL	ECX, #XFPOMXSIZE	;Yes - just use maximum
10$:	SUBL	SS:xffCount#, ECX	;Reduce amount needed
	MOVL	opx_datasz.B[EBP], ECX	;Save amount for this time
	ADDL	ECX, opx_parmsz.B[EBP]	;Plus space for parameters
	CMPL	opx_parmsz.B[EBP], #0.B	;Have any parameters?
	JE	12$.S			;No
	ADDL	ECX, #2.B		;Yes - allow for the data count bytes
12$:	INCL	ECX			;Allow for the handle byte
	MOVL	opx_msgsz.B[EBP], ECX	;Save total message size
	ADDL	ECX, #4.B		;Plus header bytes
	MOVL	EAX, SS:xffTimeOut##
	CALL	xostcpChkWin##		;Wait if window not open
	JC	14$.S			;If error
	CALL	xostcpAlloc##		;Allocate space for the packet
14$:	JC	28$			;If error
	MOVL	EAX, opx_msgsz.B[EBP]	;Get the message header (assume want
	ORL	EAX, #XFPOF_DATA<24t	;  response)
	CMPL	SS:xffCount##, #0.B	;Right?
	JE	16$.S			;Yes
	XORL	EAX, #{XFPOF_DATANR^XFPOF_DATA}<24t ;No
16$:	CMPL	opx_parmsz.B[EBP], #0.B	;Have any parameters?
	JE	18$.S			;No
	ADDL	EAX, #{XFPOF_DATAPAR-XFPOF_DATA}<24t ;Yes
18$:	CALL	xostcpPutLong##		;Store message header
	MOVB	AL, #1			;Store file handle
	CALL	xostcpPutByte
	CMPL	opx_parmsz.B[EBP], #0.B	;Have any parameters?
	JE	20$.S			;No
	MOVL	EAX, opx_datasz.B[EBP]	;Yes - store data size
	ORB	AH, #80h
	CALL	xostcpPutWord
20$:	MOVL	ECX, opx_datasz.B[EBP]	;Get amount to output this time
	JREGZ	ECX, 22$		;If nothing to output
	LESL	EBX, SS:xffBuffer1##	;Get address of the user's buffer
	ADDL	SS:xffBuffer1##, ECX	;Bump address
	CALL	xostcpPutBlk		;Store data in packet
	JC	42$
22$:	CALL	storeparm		;Store parameters
	CLRL	EAX
	MOVL	SS:xffParm##, EAX
	MOVL	opx_parmsz.B[EBP], EAX
	CALL	xfppush			;Send the data request
	JC	28$.S			;If error
	MOVL	EAX, opx_datasz.B[EBP]	;Increate amount done
	ADDL	opx_amount.B[EBP], EAX
	CMPL	SS:xffCount##, #0.B	;Want any more?
	JNE	8$			;Yes
	CALL	xfprcvblk		;No - get the response
	JC	28$			;If error
	TESTL	EAX, EAX		;Error reported by server?
	JS	30$			;Yes
	MOVL	opx_rspsz.B[EBP], EDX	;No- store amount left
	MOVL	opx_amount.B[EBP], ECX
	CMPB	BL, #XFPOF_RESPONSE	;Did we get a response?
	JNE	34$			;No - protocol error!
24$:	CLRL	EAX
26$:	PUSHL	EAX
	CALL	xfpparm			;Process parameters from the message
	JC	33$.S
	MOVL	EAX, opx_parm.B[EBP]	;Restore parameter list offset
	MOVL	SS:xffParm##, EAX
	CALL	xfppar2			;Process parameter list
	POPL	EAX
28$:	MOVL	ECX, opx_amount.B[EBP]
	LEAVE
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

;Here if error reported by host

30$:	CMPL	EAX, #ER_EOF		;End of file?
	JNE	26$.S			;No
	CMPL	opx_amount.B[EBP], #0.B	;Yes - did we get anything at all?
	JE	26$.S			;No - report the error
	JMP	24$.S			;Yes - just return what we got

;Here if error return from tcpgetblk

32$:	ADDL	opx_amount.B[EBP], ECX
	JMP	28$.S

;Here if have fatal protocol error

33$:	POPL	ECX			;Discard original error code
34$:	CALL	proterr
	JMP	28$.S

;Here if error while storing parameters into the data message

42$:	CALL	xostcpGiveSnd##		;Give up the packet buffer
	JMP	28$.S
.PAGE
	.SBTTL	xfpdelete - Delete file

;Here for SV_delete function - delete file
;	c{SS:EDX} = Address of expanded file name
;	c{EDI}    = Offset of DCB for file to delete or its directory
;	c{ESI}    = Device table offset for file to delete or its directory
;	CALL	xfpdelete
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Item count
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Item count

xfpdelete:
	MOVB	AL, #XFPOF_DELETE	;Get message type
	JMP	open2			;Continue with common code
.PAGE
	.SBTTL	xfprename - Rename file

;Here for SV_RENAME function - Rename file
;	c{SS:ESI} = Address of buffer containing processed new name
;	c{ECX}    = Option bits
;	c{SS:EDX} = Address of expanded file specification
;	c{EDI}    = Offset of DCB for old file or directory
;	CALL	xfprename
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Item count
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Item count

xfprename:
	PUSHL	EDX
	LEAL	EBX, opn_devname.B[EBP] ;Get physical device name
	MOVL	EDX, opn_frame1.B[EBP]
	ADDL	EDX, #opn_devname.B
	MOVL	EAX, SS:[EBX]		;Same device?
	CMPL	SS:[EDX], EAX
	JNE	10$.S			;No - fail!
	MOVL	EAX, SS:4.B[EBX]
	CMPL	SS:4.B[EDX], EAX
	JNE	10$.S
	MOVL	EAX, SS:8.B[EBX]
	CMPL	SS:8.B[EDX], EAX
	JNE	10$.S
	MOVL	EAX, SS:12t.B[EBX]
	CMPL	SS:12t.B[EDX], EAX
	POPL	EDX
	JNE	10$.S
	PUSHL	ESI			;Scan the new name to see if there is
	CLD				;  a network address
2$:	LODSB	SS:[ESI]
	CMPB	AL, #0
	JE	4$.S
	CMPB	AL, #':'
	JNE	2$.S
	LODSB	SS:[ESI]
	CMPB	AL, #':'
	JNE	4$.S
	POPL	EAX			;Have network address - discard it!
	JMP	6$.S

;Here if don't have a network address

4$:	POPL	ESI			;Restore offset of start of name string
6$:	MOVB	AL, #XFPOF_RENAME	;Get message type
	JMP	open2			;Continue with common code

;Here if new name is different

10$:	MOVL	EAX, #ER_DFDEV
	CLRL	ECX
	STC
	RET
.PAGE
	.SBTTL	checkspec - Subroutine to determine length of file specification

;Subroutine to determine length of file specification
;	c{SS:EDX} = Address of file specification
;	CALL	checkspec
;	c{ECX} = Length of file specification (in bytes)

checkspec:
	PUSHL	EDI
	MOVL	EDI, EDX		;Get length of file specification
	PUSHL	SS
	POPL	ES
	MOVB	AL, #0
	CLD
	MOVL	ECX, #-1
	RNSCASB	[EDI]
	POPL	EDI
	NOTL	ECX
	CMPL	ECX, #127t.B		;Need two bytes for the count?
	JBE	4$.S			;No
	INCL	ECX			;Yes
4$:	RET

	.SBTTL	storespec - Subroutine to store file specification

;Subroutine to store file specification in command message
;	c{EAX}    = Total length for file specification (includes count byte(s))
;	c{SS:EDX} = Address of file specification
;	CALL	storespec
;	c{EBX} = Offset of first byte after file specification

storespec:
	PUSHL	EDX			;Save offset of file specification
	DECL	EAX			;Adjust count
	CMPL	EAX, #127t		;Will it fit in one byte?
	JBE	6$.S			;Yes
	DECL	EAX			;No
	PUSHL	EAX
	ORB	AH, #80h		;Indicate two byte value
	CALL	xostcpPutWord##
	JMP	8$.S

6$:	PUSHL	EAX			;Store one byte vaue
	CALL	xostcpPutByte##
8$:	POPL	ECX			;Restore actual length of file spec.
	POPL	EBX			;Restore offset of file spec.
	PUSHL	SS
	POPL	ES			;Store the file specification and
	JMP	xostcpPutBlk##		;  return
.PAGE
	.SBTTL	checkparm - Subroutine to determine space needed for parameters

;Subroutine to determine space needed for parameters
;	CALL	checkparm
;	c{ECX} = c{opx_parmsz{EBP}} = Number of bytes needed for parameter list
;  Enter at checkparmio for additional set up for input and output calls

checkparmio:
	CLRL	EAX
	MOVL	opx_amount.B[EBP], EAX
	MOVL	EAX, SS:xffParm##
	MOVL	opx_parm.B[EBP], EAX
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
checkparm:
	CLRL	ECX
	MOVL	EAX, SS:xffPVFilOpt##	;Need IOPAR_FILOPTN parameter?
	ANDL	EAX, #FOBITS
	JE	6$.S			;No
	ADDL	ECX, #6.B		;Yes
	CMPL	SS:xffPPFilSpc##+0, #0.B ;Need IOPAR_FILSPEC parameter?
	JE	6$.S			;No
	ADDL	ECX, #2.B		;Yes
	MOVZWL	EAX, SS:xffPSFilSpc##	;Get length of his buffer
	TESTL	SS:xffPVFilOpt##, #FO$XOSNAME|FO$DOSNAME|FO$VOLNAME
					;Does he want the device name?
	JE	4$.S			;No
	SUBL	EAX, #12t.B		;Yes - subtract space for device name
	CMPL	EAX, #12t.B		;Big enough?
	JA	4$.S			;Yes
	MOVL	EAX, #12t		;No - do the best we can!
4$:	CMPL	EAX, #0Fh.B		;Need more than 4 bits for the length?
	JBE	6$.S			;No
	INCL	ECX			;Yes
6$:	MOVL	EDX, SS:xffHvValue1##	;Get both the "have" and "need" bits
	ORL	EDX, SS:xffNdValue1##
	JE	80$			;If nothing needed at all
	BTL	EDX, #IOV1%DEVSTS	;Need IOPAR_DEVSTS parameter?
	JNC	8$.S			;No
	ADDL	ECX, #2.B		;Yes
8$:	BTL	EDX, #IOV1%UNITNUM	;Need IOPAR_UNITNUM parameter?
	JNC	10$.S			;No
	ADDL	ECX, #2.B		;Yes
10$:	BTL	EDX, #IOV1%GLBID	;Need IOPAR_GLBID parameter?
	JNC	12$.S			;No
	ADDL	ECX, #3.B		;Yes
12$:	BTL	EDX, #IOV1%SRCATTR	;Have IOPAR_SRCATTR parameter?
	JNC	14$.S			;No
	ADDL	ECX, #3.B		;Yes
14$:	BTL	EDX, #IOV1%FILATTR	;Need IOPAR_FILATTR parameter?
	JNC	16$.S			;No
	ADDL	ECX, #2.B
	BTL	SS:xffHvValue1##, #IOV1%FILATTR ;Yes
	JNC	16$.S
	INCL	ECX
16$:	BTL	EDX, #IOV1%DIROFS	;Need IOPAR_DIROFS parameter?
	JNC	18$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%DIROFS ;Have value?
	JNC	18$.S			;No
	ADDL	ECX, #4.B		;Yes
18$:	BTL	EDX, #IOV1%ABSPOS	;Need IOPAR_xxxPOS parameter?
	JNC	20$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%ABSPOS ;Have value?
	JNC	20$.S			;No
	ADDL	ECX, #4.B		;Yes
20$:	BTL	EDX, #IOV1%LENGTH	;Need IOPAR_LENGTH parameter?
	JNC	24$.S			;No
	ADDL	ECX, #2.B
	BTL	SS:xffHvValue1##, #IOV1%LENGTH ;Yes - have value?
	JNC	24$.S			;No
	ADDL	ECX, #4.B		;Yes
24$:	BTL	EDX, #IOV1%DIRHNDL	;Have IOPAR_DIRHNDL parameter?
	JNC	26$.S			;No
	ADDL	ECX, #3.B		;Yes
26$:	BTL	EDX, #IOV1%REQALLOC	;Need IOPAR_REQALLOC parameter?
	JNC	28$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%REQALLOC ;Have value?
	JNC	28$.S			;No
	ADDL	ECX, #4.B		;Yes
28$:	BTL	EDX, #IOV1%RQRALLOC	;Need IOPAR_RQRALLOC parameter?
	JNC	30$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%RQRALLOC ;Have value?
	JNC	30$.S			;No
	ADDL	ECX, #4.B		;Yes
30$:	BTL	EDX, #IOV1%GRPSIZE	;Need IOPAR_GRPSIZE parameter?
	JNC	32$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%GRPSIZE ;Have value?
	JNC	32$.S			;No
	ADDL	ECX, #4.B		;Yes
32$:	MOVL	EAX, opx_frame1.B[EBP]
	BTL	EDX, #IOV1%ADATE	;Need IOPAR_ADATE parameter?
	JNC	36$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%ADATE ;Have value?
	JNC	36$.S			;No
	ADDL	ECX, #4.B		;Yes
	TESTB	SS:opn_datefmt.B[EAX], #DF$DOSADATE ;Have DOS format value?
	JNE	36$.S			;Yes
	ADDL	ECX, #4.B		;No
36$:	BTL	EDX, #IOV1%CDATE	;Need IOPAR_CDATE parameter?
	JNC	40$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%CDATE ;Have value?
	JNC	40$.S			;No
	ADDL	ECX, #4.B		;Yes
	TESTB	SS:opn_datefmt.B[EAX], #DF$DOSCDATE ;Have DOS format value?
	JNE	40$.S			;Yes
	ADDL	ECX, #4.B		;No
40$:	BTL	EDX, #IOV1%MDATE	;Need IOPAR_MDATE parameter?
	JNC	44$.S			;No
	ADDL	ECX, #2.B		;Yes
	BTL	SS:xffHvValue1##, #IOV1%MDATE ;Have value?
	JNC	44$.S			;No
	ADDL	ECX, #4.B		;Yes
	TESTB	SS:opn_datefmt.B[EAX], #DF$DOSMDATE ;Have DOS format value?
	JNE	44$.S			;Yes
	ADDL	ECX, #4.B		;No
44$:	BTL	EDX, #IOV1%PROT		;Need IOPAR_PROT parameter?
	JNC	48$.S			;No
	ADDL	ECX, #2.B
	BTL	SS:xffHvValue1##, #IOV1%PROT ;Yes - have value?
	JNC	48$.S			;No
	ADDL	ECX, #4.B		;Yes
48$:	BTL	EDX, #IOV1%OWNER	;Need IOPAR_OWNNER parameter?
	JNC	52$.S			;No
	ADDL	ECX, #2.B
	BTL	SS:xffHvValue1##, #IOV1%OWNER ;Yes - have value?
	JNC	52$.S			;No
	ADDL	ECX, #16t.B		;Yes
52$:	TESTL	EDX, #IOV1$SETLOCK|IOV1$CLRLOCK ;Need IOPAR_SETLOCK or
						;  IOPAR_CLRLOCK parameter?
	JE	60$.S			;No
	ADDL	ECX, #10t.B		;Yes
60$:	MOVL	EDX, SS:xffHvValue2##	;Get both the "have" and "need" bits
	ORL	EDX, SS:xffNdValue2##
	JE	80$.S
	BTL	EDX, #IOV2%FSTYPE	;Need IOPAR_FSTYPE parameter?
	JNC	62$.S			;No
	ADDL	ECX, #2.B		;Yes
62$:	BTL	EDX, #IOV2%SECTSIZE	;Need IOPAR_SECTSIZE parameter?
	JNC	64$.S			;No
	ADDL	ECX, #2.B		;Yes
64$:	BTL	EDX, #IOV2%CLSSIZE	;Need IOPAR_CLSSIZE parameter?
	JNC	66$.S			;No
	ADDL	ECX, #2.B		;Yes
66$:	BTL	EDX, #IOV2%TTLSPACE	;Need IOPAR_TTLSPACE parameter?
	JNC	68$.S			;No
	ADDL	ECX, #2.B		;Yes
68$:	BTL	EDX, #IOV2%AVLSPACE	;Need IOPAR_AVLSPACE parameter?
	JNC	70$.S			;No
	ADDL	ECX, #2.B		;Yes
70$:	BTL	EDX, #IOV2%NUMSECT	;Need IOPAR_NUMSECT parameter?
	JNC	72$.S			;No
	ADDL	ECX, #2.B		;Yes
72$:	BTL	EDX, #IOV2%NUMHEAD	;Need IOPAR_NUMHEAD parameter?
	JNC	74$.S			;No
	ADDL	ECX, #2.B		;Yes
74$:	BTL	EDX, #IOV2%NUMCYLN	;Need IOPAR_NUMCYLN parameter?
	JNC	80$.S			;No
	ADDL	ECX, #2.B		;Yes
80$:	MOVL	opx_parmsz.B[EBP], ECX	;Store parameter length
	RET				;Finished
.PAGE
	.SBTTL	storeparm - Subroutine to store parameters

;Subroutine to store parameters for OPEN, PARM, DELETE, and RENAME functions
;	CALL	storeparm

storeparm:
	CLRL	EAX
	MOVL	opx_parmerr1.B[EBP], EAX
	MOVL	opx_parmerr2.B[EBP], EAX
	MOVL	EAX, SS:xffPVFilOpt##	;Need IOPAR_FILOPTN parameter?
	ANDL	EAX, #FOBITS
	JE	18$			;No
	MOVL	EAX, #{XFOPAR_FILOPTN<8}|84h ;Yes - store parameter
	CALL	xostcpPutWord##
	MOVL	EAX, SS:xffPVFilOpt##	;Get value
	ANDL	EAX, #FOBITS		;Clear unneeded bits
	BTL	EAX, #FO%RXOSNAME	;Want remote name?
	JNC	2$.S			;No
	BTSL	EAX, #FO%XOSNAME	;Yes - get device name
2$:	BTL	EAX, #FO%RDOSNAME	;Want remote DOS name?
	JNC	3$.S			;No
	BTSL	EAX, #FO%DOSNAME	;Yes - get DOS name
3$:	BTL	EAX, #FO%RVOLNAME	;Want remote volume name?
	JNC	4$.S			;No
	BTSL	EAX, #FO%VOLNAME	;Yes - get volume name
4$:	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Searching open directory?
	JNC	6$.S			;No
	ANDL	EAX, #~{FO$NODENUM|FO$NODENAME} ;Yes - node can't change here!
6$:	CALL	xostcpPutLong##
	CMPL	SS:xffPPFilSpc##+0, #0.B ;Need IOPAR_FILSPEC parameter?
	JE	18$.S			;No
	MOVB	AL, #XFOPAR_FILSPEC
	CALL	xostcpPutByte##
	MOVZWL	EAX, SS:xffPSFilSpc##	;Get length of his buffer
	TESTL	SS:xffPVFilOpt##, #FO$XOSNAME|FO$DOSNAME|FO$VOLNAME
					;Does he want the device name?
	JE	10$.S			;No
	SUBL	EAX, #12t.B		;Yes - subtract space for device name
	CMPL	EAX, #12t.B		;Big enough?
	JA	10$.S			;Yes
	MOVL	EAX, #12t		;No - do the best we can!
10$:	CMPL	EAX, #0Fh.B		;Need more than 4 bits for the length?
	JA	12$.S			;Yes
	ORB	AL, #40h		;No - store 4 bit length value
	CALL	xostcpPutByte##
	JMP	18$.S

12$:	CMPL	EAX, #0FFFh		;Need more than 12 bits?
	JB	14$.S			;No
	MOVL	EAX, #0FFFh		;Yes - just give him as much as we can!
14$:	ORB	AH, #50h		;Store 12 bit length value
	CALL	xostcpPutWord##
18$:	PUSHL	SS:xffHvValue1##	;Get both the "have" and "need" bits
	MOVL	EAX, SS:xffNdValue1##
	ORL	[ESP], EAX
	JE	100$			;If nothing at all needed
	BTL	[ESP], #IOV1%DEVSTS	;Need IOPAR_DEVSTS parameter?
	JNC	20$.S			;No
	MOVL	EAX, #{XFOPAR_DEVSTS<8}|44h ;Yes - store parameter
	CALL	xostcpPutWord##
20$:	BTL	[ESP], #IOV1%UNITNUM	;Need IOPAR_UNITNUM parameter?
	JNC	22$.S			;No
	MOVL	EAX, #{XFOPAR_UNITNUM<8}|44h ;Yes - store parameter
	CALL	xostcpPutWord##
22$:	BTL	[ESP], #IOV1%GLBID	;Need IOPAR_GLBID parameter?
	JNC	24$.S			;No
	MOVB	AL, #XFOPAR_GLBID	;Yes
	CALL	xostcpPutByte##
	MOVL	EAX, #5010h
	CALL	xostcpPutWord##
24$:	BTL	[ESP], #IOV1%SRCATTR	;Need IOPAR_SRCATTR parameter?
	JNC	26$.S			;No
	MOVL	EAX, #{XFOPAR_SRCATTR<8}|81h ;Yes - store parameter
	CALL	xostcpPutWord##
	MOVL	EAX, opx_frame1.B[EBP]
	MOVB	AL, SS:opn_srcattr.B[EAX] ;Store value
	CALL	xostcpPutByte##
26$:	BTL	[ESP], #IOV1%FILATTR	;Need IOPAR_FILATTR parameter?
	JNC	32$.S			;No
	MOVL	EAX, #{XFOPAR_FILATTR<8}|1
	BTL	SS:xffNdValue1##, #IOV1%FILATTR
	JNC	28$.S
	ORB	AL, #40h
28$:	BTL	SS:xffHvValue1##, #IOV1%FILATTR
	JNC	30$.S
	ORB	AL, #80h
30$:	CALL	xostcpPutWord##
	TESTB	AL, #80h
	JE	32$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVB	AL, SS:opn_filattr.B[EAX]
	CALL	xostcpPutByte##
32$:	MOVL	ECX, #IOV1%DIROFS
	BTL	[ESP], ECX		;Need IOPAR_DIROFS parameter?
	JNC	34$.S			;No
	MOVB	AH, #XFOPAR_DIROFS	;Yes
	MOVL	EDX, #opn_dirofs
	CALL	sparm4
34$:	MOVL	ECX, #IOV1%ABSPOS
	BTL	[ESP], ECX		;Need IOPAR_xxxPOS parameter?
	JNC	38$.S			;No
	MOVB	AH, #XFOPAR_ABSPOS	;Yes - assume need IOPAR_ABSPOS
	TESTL	[ESP], #IOV1$RELPOS|IOV1$EOFPOS ;Right?
	JE	36$.S			;Yes
	MOVB	AH, #XFOPAR_RELPOS	;No - assume need IOPAR_RELPOS
	BTL	[ESP], #IOV1%RELPOS	;Right?
	JC	36$.S			;Yes
	MOVB	AH, #XFOPAR_EOFPOS	;No - must be IOPAR_EOFPOS
36$:	MOVL	EDX, #opn_iopos
	CALL	sparm4
38$:	MOVL	ECX, #IOV1%LENGTH
	BTL	[ESP], ECX		;Need IOPAR_LENGTH parameter?
	JNC	40$.S			;No
	MOVB	AH, #XFOPAR_LENGTH	;Yes
	MOVL	EDX, #opn_length
	CALL	sparm4
40$:	BTL	[ESP], #IOV1%DIRHNDL	;Need IOPAR_DIRHNDL parameter?
	JNC	42$.S			;No
	MOVL	EAX, #{XFOPAR_DIRHNDL<<8}|81h ;Yes
	CALL	xostcpPutWord##
	MOVB	AL, dcb_xfpodirhndl[EDI]	;Store value
	CALL	xostcpPutByte##
42$:	MOVL	ECX, #IOV1%REQALLOC
	BTL	[ESP], ECX		;Need IOPAR_REQALLOC parameter?
	JNC	44$.S			;No
	MOVB	AH, #XFOPAR_REQALLOC
	MOVL	EDX, #opn_reqalloc
	CALL	sparm4
44$:	MOVL	ECX, #IOV1%RQRALLOC
	BTL	[ESP], ECX		;Need IOPAR_RQRALLOC parameter?
	JNC	46$.S			;No
	MOVB	AH, #XFOPAR_RQRALLOC
	MOVL	EDX, #opn_rqralloc
	CALL	sparm4
46$:	MOVL	ECX, #IOV1%GRPSIZE
	BTL	[ESP], ECX		;Need IOPAR_GRPSIZE parameter?
	JNC	48$.S			;No
	MOVB	AH, #XFOPAR_GRPSIZE
	MOVL	EDX, #opn_grpsize
	CALL	sparm4
48$:	MOVL	ECX, #IOV1%ADATE
	BTL	[ESP], ECX		;Need IOPAR_ADATE parameter?
	JNC	50$.S			;No
	MOVB	AH, #XFOPAR_ADATE
	MOVB	AL, #DF$DOSADATE
	MOVL	EDX, #opn_adate
	CALL	sparmdt
50$:	MOVL	ECX, #IOV1%CDATE
	BTL	[ESP], ECX		;Need IOPAR_CDATE parameter?
	JNC	52$.S			;No
	MOVB	AH, #XFOPAR_CDATE
	MOVB	AL, #DF$DOSCDATE
	MOVL	EDX, #opn_cdate
	CALL	sparmdt
52$:	MOVL	ECX, #IOV1%MDATE
	BTL	[ESP], ECX		;Need IOPAR_MDATE parameter?
	JNC	54$.S			;No
	MOVB	AH, #XFOPAR_MDATE
	MOVB	AL, #DF$DOSMDATE
	MOVL	EDX, #opn_mdate
	CALL	sparmdt
54$:	MOVL	ECX, #IOV1%PROT
	BTL	[ESP], ECX		;Need IOPAR_PROT parameter?
	JNC	56$.S			;No
	MOVB	AH, #XFOPAR_PROT
	MOVL	EDX, #opn_prot
	CALL	sparm4
56$:	MOVL	ECX, #IOV1%OWNER
	BTL	[ESP], ECX		;Need IOPAR_OWNER parameter?
	JNC	68$.S			;No
	MOVB	AL, #XFOPAR_OWNER	;Yes
	CALL	xostcpPutByte##		;Store parameter index
	MOVL	EDX, opx_frame1.B[EBP]
	ADDL	EDX, #opn_owner		;Determine length of the name
	PUSHL	EDX
	CLRL	EAX
58$:	CMPB	SS:[EDX], #0
	JE	60$.S
	INCL	EAX
	JMP	58$.S

60$:	POPL	EDX
	MOVB	AH, #10h
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	62$.S			;No
	ORB	AH, #40h		;Yes
62$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	64$.S			;No
	ORB	AH, #80h		;Yes
64$:	CALL	xostcpPutWord##
	POPL	EDX
	TESTB	AH, #80h		;Need value?
	JE	68$.S			;No
66$:	MOVB	AL, SS:[EDX]		;Yes - store value
	CMPB	AL, #0
	JE	68$.S
	INCL	EDX
	PUSHL	EDX
	CALL	xostcpPutByte##
	POPL	EDX
	JMP	66$.S

68$:	MOVL	ECX, #IOV1%SETLOCK	;Need IOPAR_SETLOCK parameter?
	BTL	[ESP], ECX
	JNC	70$.S			;No
	MOVB	AH, #XFOPAR_SETLOCK	;Yes
	MOVL	EDX, #opn_lockval
	CALL	sparm8
70$:	MOVL	ECX, #IOV1%CLRLOCK	;Need IOPAR_CLRLOCK parameter?
	BTL	[ESP], ECX
	JNC	100$.S			;No
	MOVB	AH, #XFOPAR_CLRLOCK	;Yes
	MOVL	EDX, #opn_lockval
	CALL	sparm8
100$:	MOVL	EAX, SS:xffHvValue2##	;Get both the "have" and "need" bits
	ORL	EAX, SS:xffNdValue2##
	JE	200$			;If nothing at all needed here
	MOVL	[ESP], EAX
	BTL	EAX, #IOV2%FSTYPE	;Need IOPAR_FSTYPE parameter?
	JNC	102$.S			;No
	MOVL	EAX, #{XFOPAR_FSTYPE<8}|41h ;Yes - store parameter
	CALL	xostcpPutWord##
102$:	BTL	[ESP], #IOV2%SECTSIZE	;Need IOPAR_SECTSIZE parameter?
	JNC	104$.S			;No
	MOVL	EAX, #{XFOPAR_SECTSIZE<8}|42h ;Yes - store parameter
	CALL	xostcpPutWord##
104$:	BTL	[ESP], #IOV2%CLSSIZE	;Need IOPAR_CLSSIZE parameter?
	JNC	106$.S			;No
	MOVL	EAX, #{XFOPAR_CLSSIZE<8}|41h ;Yes - store parameter
	CALL	xostcpPutWord##
106$:	BTL	[ESP], #IOV2%TTLSPACE	;Need IOPAR_TTLSPACE parameter?
	JNC	108$.S			;No
	MOVL	EAX, #{XFOPAR_TTLSPACE<8}|44h ;Yes - store parameter
	CALL	xostcpPutWord##
108$:	BTL	[ESP], #IOV2%AVLSPACE	;Need IOPAR_AVLSPACE parameter?
	JNC	110$.S			;No
	MOVL	EAX, #{XFOPAR_AVLSPACE<8}|44h ;Yes - store parameter
	CALL	xostcpPutWord##
110$:	BTL	[ESP], #IOV2%NUMHEAD	;Need IOPAR_NUMHEAD parameter?
	JNC	112$.S			;No
	MOVL	EAX, #{XFOPAR_NUMHEAD<8}|42h ;Yes - store parameter
	CALL	xostcpPutWord##
112$:	BTL	[ESP], #IOV2%NUMSECT	;Need IOPAR_NUMSECT parameter?
	JNC	114$.S			;No
	MOVL	EAX, #{XFOPAR_NUMSECT<8}|42h ;Yes - store parameter
	CALL	xostcpPutWord##
114$:	BTL	[ESP], #IOV2%NUMCYLN	;Need IOPAR_NUMCYLN parameter?
	JNC	200$.S			;No
	MOVL	EAX, #{XFOPAR_NUMCYLN<8}|42h ;Yes - store parameter
	CALL	xostcpPutWord##
200$:	POPL	EAX			;Fix up the stack
ret010:	RET				;Finished
.PAGE
;Subroutine to store parameter with 4 byte value
;	c(AH)  = Parameter index
;	c{EBX} = Pointer to message being built
;	c{ECX} = Bit to test (bit number)
;	c{EDX} = Offset of value for parameter
;	CALL	sparm4

sparm4:	ADDL	EDX, opx_frame1.B[EBP]
	MOVB	AL, #4
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	2$.S			;No
	ORB	AL, #40h		;Yes
2$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	4$.S			;No
	ORB	AL, #80h		;Yes
4$:	PUSHL	EDX
	CALL	xostcpPutWord##		;Store parameter index and length
	POPL	EDX
	TESTB	AL, #80h
	JE	ret010.S
	MOVL	EAX, SS:[EDX]		;Get value
	JMP	xostcpPutLong##

;Subroutine to store date/time parameter
;	c(AL)  = Date format bit to test
;	c(AH)  = Parameter index
;	c{EBX} = Pointer to message being built
;	c{ECX} = Bit to test (bit number)
;	c{EDX} = Offset of value for parameter
;	CALL	sparmdt

sparmdt:
	PUSHL	EDX
	MOVL	EDX, opx_frame1.B[EBP]
	TESTB	SS:opn_datefmt.B[EDX], AL ;Have DOS format date/time value?
	POPL	EDX
	JNE	sparm4.S		;Yes - store 4 byte value
sparm8:	ADDL	EDX, opx_frame1.B[EBP]	;No
	MOVB	AL, #8			;Get value length
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	10$.S			;No
	ORB	AL, #40h		;Yes
10$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	12$.S			;No
	ORB	AL, #80h		;Yes
12$:	PUSHL	EDX
	CALL	xostcpPutWord##
	POPL	EDX
	TESTB	AL, #80h		;Need value?
	JE	ret010.S		;No - finished here
	MOVL	EAX, SS:4.B[EDX]	;Yes - store first 4 bytes of value
	PUSHL	EDX
	CALL	xostcpPutLong##
	POPL	EDX
	MOVL	EAX, SS:[EDX]		;Store second 4 bytes of value
	JMP	xostcpPutLong##
.PAGE
	.SBTTL	xfppush - Subroutine to send XFP message

;Subroutine to send XFP message
;	c{EBX} = Offset of packet buffer
;	c{EDI} = Offset of DCB
;	CALL	xfppush

xfppush:MOVL	EAX, SS:xffTimeOut##	;Get time-out value
	CALL	xostcpPush##		;Send the packet
	MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the output message
	ADDL	dpdb_tcpxfpocntbyteout.B[EAX], ECX
	INCL	dpdb_tcpxfpocntmsgout.B[EAX]
	RET
.PAGE
	.SBTTL	xfprcvblk - Subroutine to get received XFP message

;Subroutine to get received XFP mesage - must be called in extended fork
;  context
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IDB
;	CALL	xfprcvblk
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Response value
;	  c(BL)  = Message type
;	  c{ECX} = Item count (undefined for data messages)
;	  c{EDX} = Bytes remaining in message

xfprcvblk:
	CALL	xostcpGetByte##		;Get function byte
	JC	ret012.S
	PUSHL	EAX			;Save it	
	CALL	xostcpGetByte##		;Get and discard the unused byte
	JC	6$.S
	CALL	xostcpGetWord##		;Get the count
	JC	6$.S
	MOVL	EDX, dcb_ipsdpdb.B[EDI]	;Count the received message
	INCL	dpdb_tcpxfpocntmsgin.B[EDX]
	ADDL	dpdb_tcpxfpocntbytein.B[EDX], EAX
	XCHGL	EAX, [ESP]		;Save count, restore function byte
	ANDL	EAX, #0Fh.B		;Get just function value
	CMPB	AL, #MAXXFPF
	JA	rfatp1.S		;If illegal function
	JMPIL	rcvdsp[EAX*4]		;Dispatch on the function

;Here if error

6$:	POPL	ECX			;Fix up the stack
ret012:	RET

;Here if have illegal function value in the message

rfatp4:	POPL	EAX
rfatp3:	POPL	EAX
	POPL	EAX
rfatp1:	POPL	EAX			;Discard count
	JMP	proterr			;Indicate fatal error

	DATA

rcvdsp:	.LONG	rfatp1		;	        = 0
	.LONG	rcvdata		;XFPOF_DATA      = 1
	.LONG	rfatp1		;	        = 2
	.LONG	rcvdata		;XFPOF_DRESP     = 3
	.LONG	rcvdata		;XFPOF_DRESPPAR  = 4
	.LONG	rcvdata		;XFPOF_DRESPF    = 5
	.LONG	rcvdata		;XFPOF_DRESPFPAR = 6
	.LONG	rcvorsp		;XFPOF_OPNRESP   = 7
	.LONG	rcvrsp		;XFPOF_RESPONSE  = 8
	.LONG	rcveof		;XFPOF_EOF       = 9
	.LONG	rcverr		;XFPP_ERROR     = 10
MAXXFPF=!{$-rcvdsp}/4-1

	CODE
.PAGE
rcvdata:MOVB	BL, AL			;Get type in right register
	CLRL	EAX			;Value = 0
2$:	POPL	EDX			;Get count in right register
	RET

;Here if have open response

rcvorsp:DECL	[ESP]
	JS	rfatp1.S
	CALL	xostcpGetByte##		;Get the file handle
	JC	rfatp1.S
	BTL	SS:xffCmd##, #O%ODF	;Opening directory as file?
	JNC	4$.S			;No
	MOVB	dcb_xfpodirhndl[EDI], AL	;Yes - store directory handle
4$:	PUSHL	#0.B
	PUSHL	#XFPOF_OPNRESP.B
	JMP	12$.S

;Here if have response

rcvrsp:	PUSHL	#0.B
	JMP	10$.S

;Here if have end of file response

rcveof:	PUSHL	#ER_EOF.B
	PUSHL	#XFPOF_RESPONSE
	CLRL	ECX
	JMP	16$.S

;Here if have general error indication

rcverr:	SUBL	[ESP], #4.B
	JS	rfatp1.S
	CALL	xostcpGetLong##		;Get the error code
	JC	rfatp1.S
	TESTL	EAX, EAX		;It must be negative!
	JNS	rfatp1.S
	PUSHL	EAX			;Save it
10$:	PUSHL	#XFPOF_RESPONSE
12$:	CLRL	ECX			;Assume no count value
	CMPL	8.B[ESP], #0.B		;Right?
	JE	16$.S			;Yes
	SUBL	8.B[ESP], #4.B		;No - must have 4 bytes
	JS	rfatp3.S
	CALL	xostcpGetLong##		;Get the item count
	JC	rfatp3.S
	MOVL	ECX, EAX
16$:	POPL	EBX			;Restore message type
	POPL	EAX			;Restore error code
	POPL	EDX			;Get amount left in message
ret020:	RET
.PAGE
	.SBTTL	xfpparm - Subroutine to process received XFP parameters

;Subroutine to process received XFP parameters
;	CALL	xfpparm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpparm:DECL	opx_rspsz.B[EBP]	;Any more left in message?
	JS	ret020.S		;No - finished with parameters
	DECL	opx_rspsz.B[EBP]	;Must have at least two bytes here
	JS	proterr.S
	CALL	xostcpGetByte##		;Yes - get parameter index
	JC	ret020.S
	PUSHL	EAX
	CALL	xostcpGetByte##		;Get bits and first part of count
	JC	14$.S
	PUSHL	EAX
	MOVB	AH, #0
	TESTB	AL, #10h		;Need another count byte?
	JE	2$.S			;No
	DECL	opx_rspsz.B[EBP]	;Yes - make sure have it
	JS	8$.S
	PUSHL	EAX
	CALL	xostcpGetByte##		;Get second part of count
	POPL	EDX
	JC	12$.S
	MOVB	AH, DL
	JMP	4$.S

2$:	ANDL	EAX, #0Fh.B
4$:	ANDL	EAX, #0FFFh
	SUBL	opx_rspsz.B[EBP], EAX	;Reduce count, make sure have enough
	JS	8$.S			;If not enough there
	MOVL	ECX, EAX
	POPL	EAX			;Restore error bit
	POPL	EDX			;Restore parameter index
	MOVZBL	EDX, DL
	CMPB	DL, #MAXXFOPAR		;Legal parameter index?
	JA	proterr.S		;No
	CALLI	xfopartbl[EDX*4]		;Yes - dispatch on the parameter
	JNC	xfpparm.S
	RET

;Here if error

8$:	POPL	EAX			;Fix up the stack
	POPL	EAX
proterr:MOVL	EAX, dcb_ipsdpdb.B[EDI]	;Count the protocol error
	INCL	dpdb_tcpxfpocntproerr.B[EAX]
	MOVL	EAX, #ER_NPERR
	JMP	xostcpFatal##

12$:	POPL	ECX
14$:	POPL	ECX
	RET

	DATA

xfopartbl:
	.LONG	proterr		;		= 0.   - Illegal
	.LONG	proterr		;XFOPAR_FILOPTN  = 1.   - File option bits
	.LONG	xfoparfilspec	;XFOPAR_FILSPEC  = 2.   - File specification
	.LONG	xfopardevsts	;XFOPAR_DEVSTS   = 3.   - Device status
	.LONG	xfoparunitnum	;XFOPAR_UNITNUM  = 4.   - Unit number
	.LONG	xfoparglbid	;XFOPAR_GLBID    = 5.   - Global device ID
	.LONG	proterr		;XFOPAR_NUMOPN   = 6.   - Number of times device
				;			   is open
	.LONG	proterr		;		= 7.   - Illegal
	.LONG	proterr		;		= 8.   - Illegal
	.LONG	proterr		;		= 9.   - Illegal
	.LONG	proterr		;		= 10.  - Illegal
	.LONG	proterr		;		= 11.  - Illegal
	.LONG	xfopardirhndl	;XFOPAR_DIRHNDL  = 12.  - Directory handle for
				;			   search
	.LONG	proterr		;		= 13.  - Illegal
	.LONG	xfoparsrcattr	;XFOPAR_SRCATTR  = 14.  - File attributes for
				;			   search
	.LONG	xfoparfilattr	;XFOPAR_FILATTR  = 15.  - File attributes for
				;			   file
	.LONG	xfopardirofs	;XFOPAR_DIROFS   = 16.  - Dir. offset for srch
	.LONG	xfopariopos	;XFOPAR_ABSPOS   = 17.  - Absolute pos. in file
	.LONG	xfopariopos	;XFOPAR_RELPOS   = 18.  - Relative pos. in file
	.LONG	xfopariopos	;XFOPAR_EOFPOS   = 19.  - Pos. relative to EOF
	.LONG	proterr		;		= 20.  - Illegal
	.LONG	xfoparlength	;XFOPAR_LENGTH   = 21.  - Written length of file
	.LONG	xfoparalloc	;XFOPAR_REQALLOC = 22.  - Request allocation
	.LONG	xfoparalloc	;XFOPAR_RQRALLOC = 23.  - Require allocation
	.LONG	xfopargrpsize	;XFOPAR_GRPSIZE  = 24.  - Allocation group size
	.LONG	xfoparadate	;XFOPAR_ADATE    = 25.  - Last access date/time
	.LONG	xfoparcdate	;XFOPAR_CDATE    = 26.  - Creation date/time
	.LONG	xfoparmdate	;XFOPAR_MDATE    = 27.  - Modify date/time
	.LONG	xfoparprot	;XFOPAR_PROT     = 28.  - File protection
	.LONG	xfoparowner	;XFOPAR_OWNER    = 29.  - Owner name
	.LONG	proterr		;		= 30.  - Illegal
	.LONG	xfpsetlock	;XFOPAR_SETLOCK	= 31.  - Set record lock
	.LONG	xfpclrlock	;XFOPAR_CLRLOCK	= 32.  - Clear record lock
	.LONG	proterr		;		= 33.  - Illegal
	.LONG	proterr		;		= 34.  - Illegal
	.LONG	proterr		;		= 35.  - Illegal
	.LONG	proterr		;		= 36.  - Illegal
	.LONG	proterr		;		= 37.  - Illegal
	.LONG	proterr		;		= 38.  - Illegal
	.LONG	proterr		;		= 39.  - Illegal
	.LONG	proterr		;		= 40.  - Illegal
	.LONG	proterr		;		= 41.  - Illegal
	.LONG	proterr		;		= 42.  - Illegal
	.LONG	proterr		;		= 43.  - Illegal
	.LONG	proterr		;		= 44.  - Illegal
	.LONG	proterr		;		= 45.  - Illegal
	.LONG	proterr		;		= 46.  - Illegal
	.LONG	proterr		;		= 47.  - Illegal
	.LONG	proterr		;		= 48.  - Illegal
	.LONG	proterr		;		= 49.  - Illegal
	.LONG	proterr		;		= 50.  - Illegal
	.LONG	proterr		;		= 51.  - Illegal
	.LONG	proterr		;		= 52.  - Illegal
	.LONG	proterr		;		= 53.  - Illegal
	.LONG	proterr		;		= 54.  - Illegal
	.LONG	proterr		;		= 55.  - Illegal
	.LONG	proterr		;		= 56.  - Illegal
	.LONG	proterr		;		= 57.  - Illegal
	.LONG	proterr		;		= 58.  - Illegal
	.LONG	proterr		;		= 59.  - Illegal
	.LONG	proterr		;		= 60.  - Illegal
	.LONG	proterr		;		= 61.  - Illegal
	.LONG	proterr		;		= 62.  - Illegal
	.LONG	proterr		;		= 63.  - Illegal
	.LONG	proterr		;		= 64.  - Illegal
	.LONG	proterr		;		= 65.  - Illegal
	.LONG	proterr		;		= 66.  - Illegal
	.LONG	proterr		;		= 67.  - Illegal
	.LONG	proterr		;		= 68.  - Illegal
	.LONG	proterr		;		= 69.  - Illegal
	.LONG	proterr		;		= 70.  - Illegal
	.LONG	proterr		;		= 71.  - Illegal
	.LONG	proterr		;		= 72.  - Illegal
	.LONG	proterr		;		= 73.  - Illegal
	.LONG	proterr		;		= 74.  - Illegal
	.LONG	proterr		;		= 75.  - Illegal
	.LONG	proterr		;		= 76.  - Illegal
	.LONG	proterr		;		= 77.  - Illegal
	.LONG	proterr		;		= 78.  - Illegal
	.LONG	proterr		;		= 79.  - Illegal
	.LONG	proterr		;		= 80.  - Illegal
	.LONG	proterr		;		= 81.  - Illegal
	.LONG	proterr		;		= 82.  - Illegal
	.LONG	proterr		;		= 83.  - Illegal
	.LONG	proterr		;		= 84.  - Illegal
	.LONG	proterr		;		= 85.  - Illegal
	.LONG	proterr		;		= 86.  - Illegal
	.LONG	proterr		;		= 87.  - Illegal
	.LONG	proterr		;		= 88.  - Illegal
	.LONG	proterr		;		= 89.  - Illegal
	.LONG	proterr		;		= 90.  - Illegal
	.LONG	proterr		;		= 91.  - Illegal
	.LONG	proterr		;		= 92.  - Illegal
	.LONG	proterr		;		= 93.  - Illegal
	.LONG	proterr		;		= 94.  - Illegal
	.LONG	proterr		;		= 95.  - Illegal
	.LONG	xfpfstype	;XFOPAR_FSTYPE   = 96.  - File system type
	.LONG	xfpsectsize	;XFOPAR_SECTSIZE = 97.  - Sector size
	.LONG	xfpclssize	;XFOPAR_CLSSIZE  = 98.  - Cluster size
	.LONG	xfpttlspace	;XFOPAR_TTLSPACE = 99.  - Total space
	.LONG	xfpavlspace	;XFOPAR_AVLSPACE = 100. - Available space
	.LONG	xfpnumhead	;XFOPAR_NUMHEAD  = 101. - Number of heads
	.LONG	xfpnumsect	;XFOPAR_NUMSECT  = 102. - Number of sectors
	.LONG	xfpnumcyln	;XFOPAR_NUMCYLN  = 103. - Number of cylinders
MAXXFOPAR=!{$-xfopartbl}/4-1

	CODE
.PAGE
;Here with all parameters from the response processed - now we must process
;  the user's parameter list again to give him any values we got (but only
;  if we acutally got one or more values)

xfppar2:CMPL	SS:xffParm##, #0.B	;Have a parameter list?
	JE	4$.S			;No
	MOVL	EBX, #ioparms		;Yes - process parameters a final time
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	CLC				;Ignore errors here (should not be any!)
4$:	RET				;Finished
.PAGE
	.MOD	4

	.LONG	PARMMAX
ioparms:.LONG	iogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	iofilparms	 ;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	iodskparms	 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
PARMMAX=!{$-ioparms}/4

	.LONG	PARMGENMAX	;Size of table
iogenparms:
	.LONG	0		;		   = 0000h
	.LONG	ioparfiloptn	;IOPAR_FILOPTN     = 0001h
	.LONG	ioparfilspec	;IOPAR_FILSPEC     = 0002h
	.LONG	iopardevsts	;IOPAR_DEVSTS      = 0003h
	.LONG	ioparunitnum	;IOPAR_UNITNUM     = 0004h
	.LONG	ioparglbid	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	knlIopIoSts##	;IOPAR_INPSTS      = 0008h
	.LONG	knlIopIoSts##	;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
PARMGENMAX=!{$-iogenparms}/4

	.LONG	PARMFILMAX
iofilparms:
	.LONG	0		;		   = 0100h
	.LONG	iopardirhndl	;IOPAR_DIRHNDL     = 0101h
	.LONG	ioparsrcattr	;IOPAR_SRCATTR     = 0102h
	.LONG	ioparfilattr	;IOPAR_FILATTR     = 0103h
	.LONG	iopardirofs	;IOPAR_DIROFS      = 0104h
	.LONG	iopariopos	;IOPAR_ABSPOS      = 0105h
	.LONG	iopariopos	;IOPAR_RELPOS      = 0106h
	.LONG	iopariopos	;IOPAR_EOFPOS      = 0107h
	.LONG	0		;IOPAR_VBOF	   = 0108h
	.LONG	ioparlength	;IOPAR_LENGTH      = 0109h
	.LONG	ioparalloc	;IOPAR_REQALLOC    = 010Ah
	.LONG	ioparalloc	;IOPAR_RQRALLOC    = 010Bh
	.LONG	iopargrpsize	;IOPAR_GRPSIZE     = 010Ch
	.LONG	ioparadate	;IOPAR_ADATE       = 010Dh
	.LONG	ioparcdate	;IOPAR_CDATE       = 010Eh
	.LONG	ioparmdate	;IOPAR_MDATE       = 010Fh
	.LONG	ioparprot	;IOPAR_PROT        = 0110h
	.LONG	ioparowner	;IOPAR_OWNER       = 0111h
	.LONG	0		;		   = 0112h
	.LONG	ioparlock	;IOPAR_SETLOCK     = 0113h
	.LONG	ioparlock	;IOPAR_CLRLOCK     = 0114h
	.LONG	0		;IOPAR_CLSTIME     = 0115h
	.LONG	0		;IOPAR_CLSNAME     = 0116h
	.LONG	0		;IOPAR_CLSMSG	   = 0117h
	.LONG	0		;IOPAR_SHRPARMS    = 0118h
PARMFILMAX=!{$-iofilparms}/4

	.LONG	PARMDSKMAX
iodskparms:
	.LONG	0		;		   = 0300h
	.LONG	ioparfstype	;IOPAR_DSKFSTYPE   = 0301h
	.LONG	ioparsectsize	;IOPAR_DSKSECTSIZE = 0302h
	.LONG	ioparclssize	;IOPAR_DSKCLSSIZE  = 0303h
	.LONG	ioparttlspace	;IOPAR_DSKTTLSPACE = 0304h
	.LONG	ioparavlspace	;IOPAR_DSKAVLSPACE = 0305h
	.LONG	ioparnumhead	;IOPAR_DSKNUMHEAD  = 0306h
	.LONG	ioparnumsect	;IOPAR_DSKNUMSECT  = 0307h
	.LONG	ioparnumcyln	;IOPAR_DSKNUMCYLN  = 0308h
PARMDSKMAX=!{$-iodskparms}/4
.PAGE
;Here for the XFOPAR_FILSPEC parameter - File specification string

xfoparfilspec:
	TESTB	AL, #PAR$ERROR
	JE	2$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%FILSPEC
2$:	TESTL	SS:xffPVFilOpt##, #FO$NODENUM|FO$NODENAME
					;Want node specification?
	JE	10$.S			;No
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Yes - searching open directory?
	JC	10$.S			;Yes
	CMPB	SS:xffRtdName##+0, #0	;No - have rooted name pending?
	JNE	10$.S			;Yes
	PUSHL	ECX			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX
	JC	3$.S
	MOVB	AL, #FS_NODENUM
	CALL	knlGivUChr##
3$:	MOVL	ECX, #4
	LEAL	EBX, dcb_ipsrmtaddr.B[EDI]
4$:	MOVZBL	EAX, [EBX]
	INCL	EBX
	CALL	knlGivUNum##
	DECL	ECX
	JREGZ	ECX, 6$
	MOVB	AL, #'.'
	CALL	knlGivUChr##
	JMP	4$.S

6$:	MOVB	AL, #':'
	CALL	knlGivUChr##
	MOVB	AL, #':'
	CALL	knlGivUChr##
	POPL	ECX
10$:	JREGZ	ECX, 22$		;If no data
12$:	PUSHL	ECX			;Save count
	CALL	xostcpGetByte##		;Get a byte
	JC	24$.S			;If error
	CMPB	AL, #FS_XOSNAME		;Device?
	JNE	14$.S			;No
	MOVB	AL, #FS_RXOSNAME	;Yes - change to remove device?
14$:	CMPB	AL, #FS_DOSNAME		;DOS device?
	JNE	15$.S			;No
	MOVB	AL, #FS_RDOSNAME	;Yes - change to remote DOS device
15$:	CMPB	AL, #FS_VOLNAME		;Volume device?
	JNE	16$.S			;No
	MOVB	AL, #FS_RVOLNAME	;Yes - change to remote volume device
16$:	CMPB	AL, #FS_MIN		;Prefix code?
	JB	18$.S			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX ;Yes - do we want it?
	JNC	19$.S			;Yes
	JMP	20$.S			;No

;Here if data 

18$:	CMPB	SS:xffRtdName##+0, #0	;Have outstanding rooted name?
	JNE	20$.S			;Yes - don't give him the character
19$:	CALL	knlGivUChr##		;No - give him the character
	JC	24$.S			;If error
20$:	POPL	ECX			;Restore count
	LOOP	ECX, 12$		;Continue if more
22$:	CLC
	RET

;Here if fatal error

24$:	POPL	ECX
	RET
.PAGE
;Here for the XFOPAR_DEVSTS parameter - Device status

xfopardevsts:
	TESTB	AL, #PAR$ERROR
	JE	8$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%DEVSTS
8$:	CALL	getparmval		;Get up to 32 bits of value
	JC	10$.S
	MOVL	opx_devsts.B[EBP], EAX	;Save it
10$:	RET

;Here for the XFOPAR_UNITNUM parameter - Unit number

xfoparunitnum:
	TESTB	AL, #PAR$ERROR
	JE	12$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%UNITNUM
12$:	CALL	getparmval		;Get up to 32 bits of value
	JC	14$.S
	MOVL	opx_unitnum.B[EBP], EAX	;Save it
14$:	RET

;Here for the XFOPAR_GLBID parameter - Global device ID

xfoparglbid:
	TESTB	AL, #PAR$ERROR
	JE	16$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%GLBID
16$:	LEAL	EBX, opx_glbid.B[EBP]
	JMP	getparmv16b		;Get up to 16 bytes of value

;Here for the XFOPAR_DIRHNDL parameter - Directory handle

xfopardirhndl:
	TESTB	AL, #PAR$ERROR
	JE	17$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%DIRHNDL
17$:	JMP	getparmval

;Here for the XFOPAR_SRCATTR parameter - Search attributes

xfoparsrcattr:
	TESTB	AL, #PAR$ERROR
	JE	18$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%SRCATTR
18$:	JMP	getparmval

;Here for the XFOPAR_FILATTR parameter - File attributes

xfoparfilattr:
	TESTB	AL, #PAR$ERROR
	JE	19$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%FILATTR
19$:	CALL	getparmval		;Get up to 32 bits of value
	JC	20$.S
	MOVL	opx_filattr.B[EBP], EAX	;Save it
20$:	RET

;Here for the XFOPAR_DIROFS parameter - Directory offset for search

xfopardirofs:
	TESTB	AL, #PAR$ERROR
	JE	22$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%DIROFS
22$:	CALL	getparmval		;Get up to 32 bits of value
	JC	24$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_dirofs.B[EDX], EAX ;Save it
24$:	RET

;Here for the XFOPAR_ABSPOS, XFOPAR_RELPOS, or XFOPAR_EOFPOS parameter - Position
;  in file

xfopariopos:
	TESTB	AL, #PAR$ERROR
	JE	26$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%ABSPOS
26$:	CALL	getparmval		;Get up to 32 bits of value
	JC	28$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_iopos[EDX], EAX	;Save it
28$:	RET

;Here for the XFOPAR_LENGTH parameter - Written length of file

xfoparlength:
	TESTB	AL, #PAR$ERROR
	JE	30$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%LENGTH
30$:	CALL	getparmval		;Get up to 32 bits of value
	JC	32$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_length.B[EDX], EAX ;Save it
32$:	RET

;Here for the XFOPAR_REQALLOC or XFOPAR_RQRALLOC parameter - Allocated size of
;  file

xfoparalloc:
	TESTB	AL, #PAR$ERROR
	JE	34$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%REQALLOC
34$:	CALL	getparmval		;Get up to 32 bits of value
	JC	36$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_reqalloc[EDX], EAX ;Save it
36$:	RET

;Here for the XFOPAR_GRPSIZE parameter - Allocation group size

xfopargrpsize:
	TESTB	AL, #PAR$ERROR
	JE	38$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%GRPSIZE
38$:	CALL	getparmval		;Get up to 32 bits of value
	JC	40$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_grpsize[EDX], EAX ;Save it
40$:	RET

;Here for the XFOPAR_ADATE parameter - Last access date/time

xfoparadate:
	TESTB	AL, #PAR$ERROR
	JE	42$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%ADATE
42$:	CALL	getparmdt		;Get up to 64 bits of value
	JC	44$.S
	MOVL	ECX, opx_frame1.B[EBP]
	MOVL	SS:opn_adate+0[ECX], EAX ;Save it
	MOVL	SS:opn_adate+4[ECX], EDX
44$:	RET

;Here for the XFOPAR_CDATE parameter - Creation date/time

xfoparcdate:
	TESTB	AL, #PAR$ERROR
	JE	46$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%CDATE
46$:	CALL	getparmdt		;Get up to 64 bits of value
	JC	48$.S
	MOVL	ECX, opx_frame1.B[EBP]
	MOVL	SS:opn_cdate+0[ECX], EAX ;Save it
	MOVL	SS:opn_cdate+4[ECX], EDX
48$:	RET

;Here for the XFOPAR_MDATE parameter - Modify date/time

xfoparmdate:
	TESTB	AL, #PAR$ERROR
	JE	50$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%MDATE
50$:	CALL	getparmdt		;Get up to 64 bits of value
	JC	52$.S
	MOVL	ECX, opx_frame1.B[EBP]
	MOVL	SS:opn_mdate+0[ECX], EAX ;Save it
	MOVL	SS:opn_mdate+4[ECX], EDX
52$:	RET

;Here for the XFOPAR_PROT parameter - File protection

xfoparprot:
	TESTB	AL, #PAR$ERROR
	JE	54$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%PROT
54$:	CALL	getparmval		;Get up to 32 bits of value
	JC	56$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_prot[EDX], EAX	;Save it
56$:	RET

;Here for the XFOPAR_OWNER parameter - Owner name

xfoparowner:
	TESTB	AL, #PAR$ERROR
	JE	58$.S
	BTSL	opx_parmerr1.B[EBP], #IOV1%OWNER
58$:	MOVL	EBX, opx_frame1.B[EBP]
	ADDL	EBX, #opn_owner

	CRASH	????

	JMP	getparmv16b		;Get up to 16 bytes of value
.PAGE
;Here for the XFOPAR_SETLOCK parameter - Set record lock

xfpsetlock:
	TESTB	AL, #PAR$ERROR		;Error?
	JE	4$.S			;No
	BTSL	opx_parmerr1.B[EBP], #IOV1%SETLOCK ;Yes
	JMP	4$.S

;Here for the XFPAR_CLRLOCK parameter - Clear record lock

xfpclrlock:
	TESTB	AL, #PAR$ERROR		;Error?
	JE	4$.S			;No
	BTSL	opx_parmerr1.B[EBP], #IOV1%CLRLOCK ;Yes
4$:	MOVL	EBX, opx_frame1.B[EBP]
	ADDL	EBX, #opn_lockval
	JMP	getparmval		;Get the value
.PAGE
;Here for the XFOPAR_FSTYPE parameter - File system type

xfpfstype:
	TESTB	AL, #PAR$ERROR
	JE	4$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%FSTYPE
4$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVB	SS:opn_fstype[EDX], AL	;Save it
6$:	RET

;Here for the XFPAR_SECTSIZE parameter - Sector size

xfpsectsize:
	TESTB	AL, #PAR$ERROR
	JE	7$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%SECTSIZE
7$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVW	SS:opn_sectsize[EDX], AX ;Save it
	RET

;Here for the XFOPAR_CLSSIZE parameter - Cluster size

xfpclssize:
	TESTB	AL, #PAR$ERROR
	JE	8$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%CLSSIZE
8$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVB	SS:opn_clssize[EDX], AL	;Save it
	RET

;Here for the XFOPAR_TTLSPACE parameter - Total space (in clusters)

xfpttlspace:
	TESTB	AL, #PAR$ERROR
	JE	10$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%TTLSPACE
10$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_ttlspace[EDX], EAX ;Save it
	RET

;Here for the XFOPAR_AVLSPACE parameter - Available space (in clusters)

xfpavlspace:
	TESTB	AL, #PAR$ERROR
	JE	12$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%AVLSPACE
12$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVL	SS:opn_avlspace[EDX], EAX ;Save it
	RET

;Here for the XFOPAR_NUMHEAD parameter - Number of heads

xfpnumhead:
	TESTB	AL, #PAR$ERROR
	JE	14$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%NUMHEAD
14$:	CALL	getparmval		;Get up to 32 bits of value
	JC	16$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVW	SS:opn_numhead[EDX], AX	;Save it
16$:	RET

;Here for the XFOPAR_NUMSECT parameter - Number of sectors

xfpnumsect:
	TESTB	AL, #PAR$ERROR
	JE	18$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%NUMSECT
18$:	CALL	getparmval		;Get up to 32 bits of value
	JC	16$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVW	SS:opn_numsect[EDX], AX	;Save it
	RET

;Here for the XFOPAR_NUMCYLN parameter - Number of cylinders

xfpnumcyln:
	TESTB	AL, #PAR$ERROR
	JE	20$.S
	BTSL	opx_parmerr2.B[EBP], #IOV2%NUMCYLN
20$:	CALL	getparmval		;Get up to 32 bits of value
	JC	16$.S
	MOVL	EDX, opx_frame1.B[EBP]
	MOVW	SS:opn_numcyln[EDX], AX	;Save it
	RET
.PAGE
;Subroutine to get 32 bit parameter value
;	c{ECX} = Number of value bytes available
;	CALL	getparmval
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getparmval:
	JREGZ	ECX, 8$			;If no value to get
	CMPL	ECX, #4.B		;Have too many value bytes?
	JBE	4$.S			;No
	PUSHL	ECX			;Yes - discard one
	CALL	xostcpGetByte##
	POPL	ECX
	JC	10$.S			;If error
	LOOP	ECX, getparmval		;Continue

;Here with 4 or less value bytes left

4$:	PUSHL	#0.B			;Clear the value
	LEAL	EBX, [ESP+ECX]		;Point to high order byte
6$:	PUSHL	EBX
	PUSHL	ECX
	CALL	xostcpGetByte##		;Get a value byte
	POPL	ECX
	POPL	EBX
	JC	12$.S			;If error
	DECL	EBX
	MOVB	SS:[EBX], AL		;Store the byte in the value
	LOOP	ECX, 6$
	POPL	EAX			;Get value
8$:	CLC
10$:	RET				;Return with it

;Here if error getting byte

12$:	POPL	ECX			;Fix up the stack
	RET
.PAGE
;Subroutine to get 64 bit parameter value (date and time value) - this is
;  a numeric value which is byte reversed
;	c{ECX} = Number of value bytes available
;	c{EBX} = Offset to receive value
;	CALL	getparmdt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX,EAX} = Value

getparmdt:
	CMPL	ECX, #8.B		;Have too many value bytes?
	JBE	4$.S			;No
	PUSHL	ECX			;Yes - discard one
	CALL	xostcpGetByte##
	POPL	ECX
	JC	10$.S			;If error
	LOOP	ECX, getparmdt		;Continue

;Here with 8 or fewer value bytes

4$:	PUSHL	#0.B
	PUSHL	#0.B
	MOVL	EBX, ESP
	ADDL	EBX, ECX		;Point to high order byte
6$:	JREGZ	ECX, 10$
8$:	PUSHL	EBX
	PUSHL	ECX
	CALL	xostcpGetByte##		;Get a value byte
	POPL	ECX
	POPL	EBX
	JC	12$.S			;If error
	DECL	EBX
	MOVB	SS:[EBX], AL		;Store the byte in the value
	LOOP	ECX, 8$
	POPL	EAX
	POPL	EDX
10$:	RET				;Finished

12$:	POPL	EDX
	POPL	EDX
	RET
.PAGE
;Subroutine to get 16 byte parameter value - this is a byte string value which
;  is not byte reversed
;	c{ECX} = Number of value bytes available
;	c{EBX} = Offset to receive value
;	CALL	getparmdt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

getparmv16b:
	CMPL	ECX, #16t.B		;Have too many value bytes?
	JBE	4$.S			;No
	PUSHL	EBX
	PUSHL	ECX			;Yes - discard one
	CALL	xostcpGetByte##
	POPL	ECX
	POPL	EBX
	JC	8$.S			;If error
	LOOP	ECX, getparmv16b	;Continue

;Here with 16 or fewer value bytes

4$:	JREGZ	ECX, 8$
6$:	PUSHL	EBX
	PUSHL	ECX
	CALL	xostcpGetByte##		;Get a value byte
	POPL	ECX
	POPL	EBX
	JC	8$.S			;If error
	MOVB	SS:[EBX], AL		;Store the byte in the value
	INCL	EBX
	LOOP	ECX, 6$
8$:	RET				;Finished
.PAGE
;Here for IOPAR_FILOPTN - File specification options

	DPARMHDR  SET, HEXV
ioparfiloptn:
	BTL	opx_parmerr1.B[EBP], #IOV1%FILOPTN
	JC	4$.S
	RET

;Here for IOPAR_FILSPEC - File specification

	DPARMHDR  GET, STR
ioparfilspec:
	BTL	opx_parmerr1.B[EBP], #IOV1%FILSPEC
	JC	4$.S
	RET

;Here for IOPAR_DEVSTS - Device status

	DPARMHDR  GET, HEXV
iopardevsts:
	BTL	opx_parmerr1.B[EBP], #IOV1%DEVSTS
	JC	4$.S
	MOVL	EAX, opx_devsts.B[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_UNITNUM - Unit number

	DPARMHDR  GET, HEXV
ioparunitnum:
	BTL	opx_parmerr1.B[EBP], #IOV1%UNITNUM
	JC	4$.S
	MOVL	EAX, opx_unitnum.B[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_DIRHNDL - Directory handle for search

	DPARMHDR  SET, HEXV
iopardirhndl:
	BTL	opx_parmerr1.B[EBP], #IOV1%DIRHNDL
	JC	4$.S
	RET

;Here for IOPAR_SRCATTR - Search attributes

	DPARMHDR  BOTH, HEXV
ioparsrcattr:
	BTL	opx_parmerr1.B[EBP], #IOV1%SRCATTR
	JC	4$.S
2$:	RET

;Here for IOPAR_FILATTR - File attributes for file

	DPARMHDR  BOTH, HEXV
ioparfilattr:
	BTL	opx_parmerr1.B[EBP], #IOV1%FILATTR
	JC	4$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_filattr.B[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_DIROFS - Directory offset for file

	DPARMHDR  BOTH, DECV
iopardirofs:
	BTL	opx_parmerr1.B[EBP], #IOV1%DIROFS
	JC	4$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_dirofs.B[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_ABSPOS, IOPAR_RELPOS, and IOPAR_EOFPOS - Position in file

	DPARMHDR  BOTH, DECV
iopariopos:
	BTL	opx_parmerr1.B[EBP], #IOV1%ABSPOS
4$:	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_iopos.B[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_LENGTH - Written length of file

	DPARMHDR  BOTH, DECV
ioparlength:
	BTL	opx_parmerr1.B[EBP], #IOV1%LENGTH
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_length.B[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_REQALLOC or IOPAR_RQRALLOC - File allocation

	DPARMHDR  BOTH, DECV
ioparalloc:
	BTL	opx_parmerr1.B[EBP], #IOV1%REQALLOC
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_reqalloc[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_GRPSIZE - Allocation group size

	DPARMHDR  BOTH, DECV
iopargrpsize:
	BTL	opx_parmerr1.B[EBP], #IOV1%GRPSIZE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_grpsize[EAX]
	JMP	knlStrParm4##

6$:	MOVL	EAX, #ER_PARMV
8$:	RET

;Here for IOPAR_ADATE - Last access date/time

	DPARMHDR  BOTH, HEXV
ioparadate:
	BTL	opx_parmerr1.B[EBP], #IOV1%ADATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_adate
	JMP	10$.S

;Here for IOPAR_CDATE - Creation date/time

	DPARMHDR  BOTH, HEXV
ioparcdate:
	BTL	opx_parmerr1.B[EBP], #IOV1%CDATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_cdate
	JMP	10$.S

;Here for IOPAR_MDATE - Modify date/time

	DPARMHDR  BOTH, HEXV
ioparmdate:
	BTL	opx_parmerr1.B[EBP], #IOV1%MDATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_mdate
10$:	ADDL	EAX, opx_frame1.B[EBP]
	MOVL	EDX, SS:4.B[EAX]
	MOVL	EAX, SS:[EAX]
	JMP	knlStrParm8##

;Here for IOPAR_PROT - File protection

	DPARMHDR  BOTH, HEXV
ioparprot:
	BTL	opx_parmerr1.B[EBP], #IOV1%PROT
12$:	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_prot[EAX]
	JMP	knlStrParm4##

14$:	RET

;Here for IOPAR_OWNER - Owner name

	DPARMHDR  BOTH, TEXT
ioparowner:
	BTL	opx_parmerr1.B[EBP], #IOV1%OWNER
	JC	12$.S
	TESTB	AH, #PAR$GET
	JE	14$.S
	MOVL	ESI, #opn_owner
	JMP	16$.S
16$:	ADDL	ESI, opx_frame1.B[EBP]
18$:	PUSHL	SS
	POPL	FS
	MOVL	EAX, #16t
	JMP	knlStrParmLng##

;Here for IOPAR_GLBID - Global device ID

	DPARMHDR  GET, HEXV
ioparglbid:
	BTL	opx_parmerr1.B[EBP], #IOV1%GLBID
	JC	12$.S
	LEAL	ESI, opx_glbid.B[EBP]
	JMP	18$.S
.PAGE
;Here for IOPAR_qqqqq

;Here for IOPAR_SETLOCK or IOPAR_CLRLOCK - Set or clear record lock

	DPARMHDR  BOTH, HEXV
ioparlock:
	TESTL	opx_parmerr1.B[EBP], #IOV1$SETLOCK|IOV1$CLRLOCK
	JNE	4$.S
2$:	RET

4$:	STC
6$:	MOVL	EAX, #ER_PARMV
	RET

;Here for IOPAR_FSTYPE - File system type

	DPARMHDR  GET, DECV
ioparfstype:
	BTL	opx_parmerr2.B[EBP], #IOV2%FSTYPE
	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZBL	EAX, SS:opn_fstype[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_SECTSIZE - Sector size

	DPARMHDR  GET, DECV
ioparsectsize:
	BTL	opx_parmerr2.B[EBP], #IOV2%SECTSIZE
	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZWL	EAX, SS:opn_sectsize[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_CLSSIZE - Cluster size

	DPARMHDR  GET, DECV
ioparclssize:
	BTL	opx_parmerr2.B[EBP], #IOV2%CLSSIZE
	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZBL	EAX, SS:opn_clssize[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_TTLSPACE - Total space

	DPARMHDR  GET, DECV
ioparttlspace:
	BTL	opx_parmerr2.B[EBP], #IOV2%TTLSPACE
	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_ttlspace[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_AVLSPACE - Available space

	DPARMHDR  GET, DECV
ioparavlspace:
	BTL	opx_parmerr2.B[EBP], #IOV2%AVLSPACE
10$:	JC	6$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVL	EAX, SS:opn_avlspace[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMHEAD - Number of heads

	DPARMHDR  GET, DECV
ioparnumhead:
	BTL	opx_parmerr2.B[EBP], #IOV2%NUMHEAD
	JC	10$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZWL	EAX, SS:opn_numhead[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMSECT - Number of sectors

	DPARMHDR  GET, DECV
ioparnumsect:
	BTL	opx_parmerr2.B[EBP], #IOV2%NUMSECT
	JC	10$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZWL	EAX, SS:opn_numsect[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMCYLN - Number of cylinders

	DPARMHDR  GET, DECV
ioparnumcyln:
	BTL	opx_parmerr2.B[EBP], #IOV2%NUMCYLN
	JC	10$.S
	MOVL	EAX, opx_frame1.B[EBP]
	MOVZWL	EAX, SS:opn_numcyln[EAX]
	JMP	knlStrParm4##
.PAGE
	DATA

xfpccb:	    .BLKB ccb_SIZE	;XFP CCB
xfpdpdbhead:.LONG 0		;Offset of first XFP DPDB

	LKEEND
