	.TITLE	NETCLS - Network class driver for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!1t
MINV   =!2t
EDITNUM=!2t

;1.2.2 - 31-Oct-95
;	Fixed a couple of problems in netclose routine: was loading parameter
;	list address from wrong place, was using wrong register to pick up
;	offset of fork level close routine from the IDB.

	LKEHEAD	NETCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

;This device class implements the low-level raw interface to the network(s).
;  This is a non-buffered block oriented interface.  Data is transfered
;  directly between the user's buffers and the network interface.  Each
;  input or output operation transfers a single complete network packet.

	.EXPORT	xosnetAbort
	.EXPORT	xosnetAllDone
	.EXPORT	xosnetChkNetAddr
	.EXPORT	xosnetExtendBufr
	.EXPORT	xosnetFinXmit
	.EXPORT	xosnetFinXmit2
	.EXPORT	xosnetGetBufr
	.EXPORT	xosnetGetIdbData
	.EXPORT	xosnetGetSdbData
	.EXPORT	xosnetGiveDcb
	.EXPORT	xosnetGiveBufr
	.EXPORT	xosnetGiveList
	.EXPORT	xosnetIdbHead
	.EXPORT	xosnetIdbTail
	.EXPORT	xosnetIopCMode
	.EXPORT	xosnetIopSMode
	.EXPORT	xosnetMakeDcb
	.EXPORT	xosnetMakeIdb
	.EXPORT	xosnetMsgBadSize
	.EXPORT	xosnetMsgTooBig
	.EXPORT	xosnetMsgBcPktIn
	.EXPORT	xosnetMsgCrcErr
	.EXPORT	xosnetMsgDev
	.EXPORT	xosnetMsgFixedCnt
	.EXPORT	xosnetMsgLnkDown
	.EXPORT	xosnetMsgNetAddr
	.EXPORT	xosnetMsgNoSap
	.EXPORT	xosnetMsgNoSBfr
	.EXPORT	xosnetMsgOvrErr
	.EXPORT	xosnetMsgPktIn
	.EXPORT	xosnetMsgPktOut
	.EXPORT	xosnetMsgSapDev
	.EXPORT	xosnetMsgSapNext
	.EXPORT	xosnetMsgSapThis
	.EXPORT	xosnetMsgXHung
	.EXPORT	xosnetNewDrive
	.EXPORT	xosnetOutDone
	.EXPORT	xosnetOutWait
	.EXPORT	xosnetRcvPkt
	.EXPORT	xosnetRspDone
	.EXPORT	xosnetRspDoneOut
	.EXPORT	xosnetRspWait
	.EXPORT	xosnetSendPkt
	.EXPORT	xosnetSetIdbData
	.EXPORT	xosnetSetSdbData
	.EXPORT	xosnetSndDone
	.EXPORT	xosnetSndWait
	.EXPORT	xosnetSrchBlk2
	.EXPORT xosnetSrchBlock
	.EXPORT	xosnetWaitPkt

	.SBTTL	SVC dispatch table for network class devices

;SVC dispatch table for network class devices

	CODE

netdsp: .LONG	knlRtnZero##	;sd_mount	=  0. - Mount
	.LONG	knlRtnZero##	;sd_cleardev	=  4. - Clear device
	.LONG	xosnetGiveDcb	;sd_cleardcb	=  8. - Clear DCB
	.LONG	knlRtnZero##	;sd_commit	= 12. - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold    = 16. - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew    = 20. - Transfer device/new
	.LONG	knlNullQio##	;sd_opena	= 24. - Open additional
	.LONG	netopen		;sd_open1	= 28. - Open device/file
	.LONG	netopen		;sd_devparm     = 32. - Device parameters
	.LONG	knlIFnDev##	;sd_delete	= 36. - Delete file
	.LONG	knlIFnDev##	;sd_rename	= 40. - Rename file
	.LONG	netinpblk	;sd_inblock	= 44. - Input block
	.LONG	netoutblk	;sd_outblock	= 48. - Output block
	.LONG	netoutblk1	;sd_outblockq	= 52. - Output block (XFF)
	.LONG	knlIFnDevGQ##	;sd_outstring	= 56. - Output string
	.LONG	knlRtnMOne##	;sd_getiosts	= 60. - Get input/output status
	.LONG	knlIFnDevGQ##	;sd_special     = 64. - Special device function
	.LONG	netclose	;sd_close	= 68. - Close file
	.LONG	knlNullLabel##	;sd_label       = 72. - Get device label
	.LONG	knlNullQioGQ##	;sd_commitfunc	= 76. - Commit data to disk
NETDSPSZ=!{$-netdsp}/4

;Class function dispatch table for network class devices

	.LONG	CLSFMX
netcls:	.LONG	netaddunit	;CF_ADDUNIT =  8. - Add unit
	.LONG	netunitinfo	;CF_PUNITS  =  9. - Get information about
				;		      physical units
	.LONG	knlIFnDevGQ##	;CF_AUNITS  = 10. - Get information about active
				;		      units
CLSFMX=!{$-netcls}/4
.PAGE
;Device characteristics tables for NET devices are defined in the network
;  interface driver modules

;Class characteristics tables for the NET device class

	DATA

	.MOD	4
netcctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  NUMBER , DECV, , 4, msgnumber , knlGetSysVal##, 0             , netdcbnum
 DCHARENT  MAXIMUM, DECV, , 4, msgmaximum, knlGetSysVal##, knlSetSysVal##, netdcbmax
 DCHARENT  LIMIT  , DECV, , 4, msglimit  , knlGetSysVal##, knlSetSysVal##, netdcblmt

	CODE

msgnumber:  DCHARINFO  {Number of in use NET devices}
msgmaximum: DCHARINFO  {Maximum number of in use NET devices}
msglimit:   DCHARINFO  {Maximum number of NET devices allowed}

xosnetMsgBadSize: DCHARINFO  {Discarded - bad size for packet}
xosnetMsgTooBig:  DCHARINFO  {Discarded - packet is too big}
xosnetMsgFixedCnt:DCHARINFO  {Number of times input byte count fixed}
xosnetMsgBcPktIn: DCHARINFO  {Number of broadcast packets input}
xosnetMsgCrcErr:  DCHARINFO  {Discarded - input CRC error}
xosnetMsgDev:     DCHARINFO  {Network interface device}
xosnetMsgLnkDown: DCHARINFO  {Discarded - link down}
xosnetMsgNetAddr: DCHARINFO  {Physcial network address}
xosnetMsgNoSBfr:  DCHARINFO  {Discarded - no system buffer available}
xosnetMsgNoSap:   DCHARINFO  {Discarded - no destination for SAP}
xosnetMsgOvrErr:  DCHARINFO  {Discarded - input overrun error}
xosnetMsgPktIn:   DCHARINFO  {Number of packets input}
xosnetMsgPktOut:  DCHARINFO  {Number of packets output}
xosnetMsgSapDev:  DCHARINFO  {Device for SAP}
xosnetMsgSapNext: DCHARINFO  {This SAP}
xosnetMsgSapThis: DCHARINFO  {Next SAP}
xosnetMsgXHung:   DCHARINFO  {Number of hung output errors}
.PAGE
;Device parameter table for NET: opens

	.MOD	4
	.LONG	OPARMMAX
netopnparms:
	.LONG	netopngenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File IO parameters
	.LONG	netopntrmparms	 ;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	netopnnetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
OPARMMAX=!{$-netopnparms}/4

	.LONG	OPARMGENMAX	;Size of table
netopngenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopDummyS##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT	   = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT	   = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
OPARMGENMAX=!{$-netopngenparms}/4

	.LONG	OPARMTRMMAX
netopntrmparms:
	.LONG	0		;		   = 0200h
	.LONG	0		;IOPAR_TRMSINPMODE = 0201h
	.LONG	0		;IOPAR_TRMCINPMODE = 0202h
	.LONG	0		;IOPAR_TRMSOUTMODE = 0203h
	.LONG	0		;IOPAR_TRMCOUTMODE = 0204h
	.LONG	0		;IOPAR_TRMBFRLIMIT = 0205h
	.LONG	0		;IOPAR_TRMCLRBUFR  = 0206h
	.LONG	0		;IOPAR_TRMCURTYPE  = 0207h
	.LONG	0		;IOPAR_TRMCURPOS   = 0208h
	.LONG	0		;IOPAR_TRMDISPAGE  = 0209h
	.LONG	0		;IOPAR_TRMSPSTATUS = 020Ah
	.LONG	0		;IOPAR_TRMSPBREAK  = 020Bh
	.LONG	netiopmodem	;IOPAR_TRMSPMODEM  = 020Ch
OPARMTRMMAX=!{$-netopntrmparms}/4

	.LONG	OPARMNETMAX
netopnnetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	netiopprotocol	;IOPAR_NETPROTOCOL = 0502h
OPARMNETMAX=!{$-netopnnetparms}/4

;Device parameter table for NET: IO operations

	.LONG	PARMMAX
netioparms:
	.LONG	netiogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File IO parameters
	.LONG	netiotrmparms	 ;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	netionetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
PARMMAX=!{$-netioparms}/4

	.LONG	PARMGENMAX	;Size of table
netiogenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopFilOptn##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopFilSpec##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT	   = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT	   = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
PARMGENMAX=!{$-netiogenparms}/4

	.LONG	PARMTRMMAX
netiotrmparms:
	.LONG	0		;		   = 0200h
	.LONG	0		;IOPAR_TRMSINPMODE = 0201h
	.LONG	0		;IOPAR_TRMCINPMODE = 0202h
	.LONG	0		;IOPAR_TRMSOUTMODE = 0203h
	.LONG	0		;IOPAR_TRMCOUTMODE = 0204h
	.LONG	0		;IOPAR_TRMBFRLIMIT = 0205h
	.LONG	0		;IOPAR_TRMCLRBUFR  = 0206h
	.LONG	0		;IOPAR_TRMCURTYPE  = 0207h
	.LONG	0		;IOPAR_TRMCURPOS   = 0208h
	.LONG	0		;IOPAR_TRMDISPAGE  = 0209h
	.LONG	0		;IOPAR_TRMSPSTATUS = 020Ah
	.LONG	0		;IOPAR_TRMSPBREAK  = 020Bh
	.LONG	netiopmodem	;IOPAR_TRMSPMODEM  = 020Ch
PARMTRMMAX=!{$-netiotrmparms}/4

	.LONG	PARMNETMAX
netionetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	netiopprotocol	;IOPAR_NETPROTOCOL = 0502h
PARMNETMAX=!{$-netionetparms}/4

;Device dependent parameter table for NET: IO operations

	.LONG	1
netddparms:
	.LONG	netdd0parms

	.LONG	2
netdd0parms:
	.LONG	knlIoparClass##	;IOPAR_CLASS       = 8000 - Device class
	.LONG	netiopctlmode	;IOPAR_NET_CTLMODE = 8001 - Set or clear control
				;			      mode
.PAGE
	.SBTTL	Initialization routine

	INITSUB	initnet

initnet:MOVL	EDI, #netchk		;Install our class
	MOVL	EBX, #netcls		;Offset of class function dispatch table
	MOVL	EAX, #'NET'
	CLRL	EDX
	MOVL	ECX, #netcctbl
	MOVL	ESI, #netccb
	CALL	knlNewClass##
	JC	4$.S			;This should not fail!
	MOVL	ECX, #codetop
	CLRL	EDX
	CLRL	EAX
4$:	RET

	CODE
.PAGE
	.SBTTL	xosnetNewDrive - Subroutine to register low level network driver

;Subroutine to register low level network driver - must be called with the
;  exec memory resource
;	c{EBX} = Name of driver (4 characters)
;	c{EDX} = Offset of addunit subroutine
;	CALL	xosnetNewDrive
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosnetNewDrive:
	MOVL	ECX, #12t
	CALL	knlGetXMem##		;Get memory for the driver data block
	JC	4$.S			;If error
	MOVL	4.B[EDI], EBX		;OK - store name
	MOVL	8.B[EDI], EDX		;Store offset of addunit subroutine
	MOVL	EAX, fnetdrv		;Link into list of network drivers
	MOVL	[EDI], EAX
	MOVL	fnetdrv, EDI
	CLRL	EAX			;Make sure C is clear and return 0
4$:	RET
.PAGE
	.SBTTL	netadadunit - Class function to add unit

;Here for the CL_ADDUNIT function - for this device the add unit function
;  actually sets up a single network interface.  It does this by calling
;  the apropriate network device driver.
;	c{ES:EDI} = Address of parameter block
;	CALL	netaddunit
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX}  = 0

;Description block for addunitchar

	DATA

	.MOD	4
netaublk:
 DCHARBGN  2, knlDCharValCom##
 DCHARENT  UNIT, DECV, , 1, knlDcMsgUnit##, 0, nauunit, 0
 DCHARENT  TYPE, TEXT, , 4, knlDcMsgType##, 0, nautype, 0

	CODE

$$$=!0
FRM nau_unit  , 4t		;Unit number
FRM nau_type  , 4t		;Controller type
FRM nau_char  , 8t		;Address of chracteristics list
nau_SIZE=!$$$

netaddunit:
	ENTER	nau_SIZE, 0		;Set up and initialize our stack frame
	CLRL	EAX
	DECL	EAX
	MOVL	nau_unit.B[EBP], EAX
	MOVL	nau_type.B[EBP], EAX
	IFFAULT	6$
	LFSL	EDX, iorb_buffer2.B[ESI]
	MOVL	nau_char+0.B[EBP], EDX
	MOVL	nau_char+4.B[EBP], FS
	CALL	knlGiveQel##		;Give up the IORB
	MOVL	EBX, #netaublk		;Process the characteristics
	MOVB	AL, #1			;Ignore bad names here
	CALL	knlAddUnitChar##
	JNC	8$.S			;If no error
4$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	LEAVE				;Fail
	TOFORK
	STC
	RET

;Here if address error with IORB

	FAULTHDR
6$:	CALL	knlGiveQel##
	FAULTHDR
7$:	MOVL	EAX, #ER_ADRER
	JMP	4$.S

;Here with all parameters processed - make sure we got everything we need

8$:	MOVL	EAX, nau_unit.B[EBP]
	TESTL	EAX, EAX
	JS	10$.S
	MOVL	EDX, nau_type.B[EBP]
	CMPL	EDX, #-1.B
	JNE	16$.S
10$:	MOVL	EAX, #ER_CHARM
	JMP	4$.S

;Here if network unit is already defined

12$:	MOVL	EAX, #ER_DUADF
	JMP	4$.S

;Here network driver type not defined

14$:	MOVL	EAX, #ER_NSTYP
	JMP	4$.S

;Here with all needed parameters found

16$:	MOVL	ESI, xosnetIdbHead	;Point to first IDB
18$:	TESTL	ESI, ESI
	JE	21$.S			;If no more IDBs
	CMPB	idb_unit.B[ESI], AL	;Same unit?
	JE	12$.S			;Yes - fail
20$:	MOVL	ESI, idb_nextd.B[ESI]	;Not this one - try next
	JMP	18$.S			;Continue

;Here if this unit not defined now

21$:	MOVL	EBX, fnetdrv		;Point to first Ethernet driver data
					;  block
22$:	TESTL	EBX, EBX		;Have another to check?
	JE	14$.S			;No - no such Ethernet driver
	CMPL	4.B[EBX], EDX		;Yes - is this the one we want?
	JE	24$.S			;Yes
	MOVL	EBX, [EBX]		;No - advance to next
	JMP	22$.S

;Here with data block for requested network driver

24$:	MOVL	EAX, nau_unit.B[EBP]	;Get unit number
	IFFAULT	7$
	LFSL	EDX, nau_char.B[EBP]	;Get address of the characteristics list
	LEAVE
	JMPIL	8.B[EBX]		;Dispatch to addunit routine for driver
.PAGE
;Subroutine called by adduchars when "TYPE" characteristic found

nautype:MOVL	nau_type.B[EBP], EAX
	CLC
	RET

;Subroutine called by adduchars when "UNIT" characteristic found

nauunit:MOVL	nau_unit.B[EBP], EAX
	CLC
	RET
.PAGE
	.SBTTL	xosnetGetIdbData - Subroutine to get data item from an IDB

;Subroutine to get data item from an IDB for QFNC_DEVCHAR
;	c{EBX} = Offset of item
;	c{EDI} = Offset of DCB
;	CALL	xosnetGetIdbData
;	C:clr always
;	c{EAX} = Data value

xosnetGetIdbData:
	ADDL	EBX, dcb_netidb.B[EDI]	;Point to the data item
	MOVL	EAX, [EBX]		;Get value
	CLC
	RET				;Thats all

	.SBTTL	xosnetGetSdbData - Subroutine to get data item from an SDB

;Subroutine to get data item from an SDB for QFNC_DEVCHAR
;	c{EBX} = Offset of item
;	c{EDI} = Offset of DCB
;	CALL	xosnetGetSdbData
;	C:clr always
;	c{EAX} = Data value

xosnetGetSdbData:
	ADDL	EBX, dcb_netsdb.B[EDI]	;Point to the data item
	MOVL	EAX, [EBX]		;Get value
	CLC
	RET				;Thats all

	.SBTTL	xosnetSetIdbData - Subroutine to set data item in an IDB

;Subroutine to set data item in an IDB for QFNC_DEVCHAR
;	c{EAX} = Data value
;	c{EBX} = Offset of item
;	c{EDI} = Offset of DCB
;	CALL	xosnetSetIdbData
;	C:clr always

xosnetSetIdbData:
	ADDL	EBX, dcb_netidb.B[EDI]	;Point to the data item
	MOVL	[EBX], EAX		;Store value
	CLC
	RET				;Thats all

	.SBTTL	xosnetSetSdbData - Subroutine to set data item in an SDB

;Subroutine to set data item in an SDB for QFNC_DEVCHAR
;	c{EAX} = Data value
;	c{EBX} = Offset of item
;	c{EDI} = Offset of DCB
;	CALL	xosnetSetSdbData
;	C:clr always

xosnetSetSdbData:
	ADDL	EBX, dcb_netsdb.B[EDI]	;Point to the data item
	MOVL	[EBX], EAX		;Store value
	CLC
	RET				;Thats all
.PAGE
	.SBTTL	netunitinfo - Network class get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  network class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	netunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

netunitinfo:
	CRASH	NIYT
.PAGE
	.SBTTL	xosnetMakeIdb - Subroutine to create network IDB

;Subroutine to create network interface data block (IDB) - must be called
;  with the exec memory resource
;	c{EAX} = Unit number
;	c{ECX} = Size of IDB
;	c{EDX} = Offset of device characteristics table for NET: device
;	CALL	xosnetMakeIdb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ESI} = Address of IDB just created

xosnetMakeIdb:
	PUSHL	EAX			;Save unit number
	PUSHL	EDX			;Save device characteristics offset
	CALL	knlGetXMem##		;Allocate exec memory for the IDB
	POPL	ECX			;Restore device characteristics offset
	POPL	EDX			;Restore unit number
	JC	6$.S			;If error
	LEAL	ESI, idb_mSIZE[EDI]
	MOVL	idb_magic.B[ESI], #'IDB*'
	MOVL	idb_devchar.B[ESI], ECX	;Store device characteristics offset
	MOVL	idb_unit.B[ESI], EDX	;Store unit number
	MOVL	idb_sffdisp.B[ESI], #netsffork ;Store send-self fork dispatch
	DECL	idb_sffnext.B[ESI]
	MOVL	EAX, xosnetIdbTail	;Link into our chain of IDBs
	TESTL	EAX, EAX
	JE	2$.S
	MOVL	idb_nextd.B[EAX], ESI
	JMP	4$.S

2$:	MOVL	xosnetIdbHead, ESI
4$:	MOVL	xosnetIdbTail, ESI
	DECL	idb_fnext.B[ESI]
	LEAL	EBX, idb_name+3.B[ESI]	;Construct unit name
	MOVL	-3.B[EBX], #'NET'
	MOVL	EAX, EDX
	CALL	knlPutDecNmbr##
	CLC
6$:	RET
.PAGE
	.SBTTL	xosnetAbort - Subroutine to terminate all IO for a network interface

;Subroutine to terminate all IO for a network interface
;	c{ESI} = Offset of IDB
;	CALL	xosnetAbort

xosnetAbort:
	PUSHL	idb_outhead.B[ESI]
	CLRL	EAX
	MOVL	idb_outhead.B[ESI], EAX
	MOVL	idb_outtail.B[ESI], EAX
	MOVL	EBX, idb_outbuf.B[ESI]	;Get current output packet
	TESTL	EBX, EBX
	JE	2$.S			;If none
	MOVL	EAX, #ER_ABORT		;Do output done processing
	CALL	xosnetFinXmit2
2$:	POPL	EBX
4$:	TESTL	EBX, EBX
	JE	6$.S
	PUSHL	npb_nextsnd.B[EBX]
	MOVL	EAX, #ER_ABORT		;Do output done processing
	CALL	xosnetFinXmit2
	POPL	EBX			;Restore offset of next packet
	JMP	4$.S

6$:	PUSHL	ESI
	MOVL	ESI, idb_sdbhead.B[ESI]
8$:	TESTL	ESI, ESI
	JE	10$.S
	CALLI	sdb_abort.B[ESI]
	MOVL	ESI, [ESI]
	JMP	8$.S

10$:	POPL	ESI
	RET
.PAGE
	.SBTTL	netchk - Device check routine for network(s)

;Device check routine for network(s)
;	c{SS:EBX} = Address of device name (16 characters)
;	CALL	netchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  EBX and ESI are preserved

netchk:	MOVL	EAX, SS:[EBX]
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'NET'		;Is this NET*?
	JNE	4$.S			;No
	MOVL	EDI, xosnetIdbHead	;Yes - point to first network IDB
	LEAL	ECX, 3.B[EBX]		;Get offset of 1st unit number character
	CALL	xosnetSrchBlock
	JNE	4$.S
	MOVL	EDX, #netccb		;Get offset of our CCB
	CALLI	idb_makedcb.B[EDI]	;Make the DCB
	JC	6$.S
	MOVL	dcb_sdisp.B[EDI], #netdsp ;Store offset of SVC dispatch table
4$:	CLC
6$:	RET
.PAGE
	.SBTTL	sd_cleardcb - Clear DCB

;Here for the clear DCB entry
;	c{EDI} = Offset of DCB

xosnetGiveDcb:
	DECL	netdcbnum		;Reduce in-use count
	MOVZBL	ECX, dcb_netdcbsizex.B[EDI] ;Get size index for the DCB
	JMP	knlGiveDymDcb##		;Give up the DCB
.PAGE
	.SBTTL	xosnetSrchBlock - Search for data block for network device

;Subroutine to search for data block for network device
;	c{SS:ECX} = Address of start of unit number in device name
;	c{EDI} = Offset of first data block (PDB, TPDB, or DPDB)
;	CALL	xosnetSrchBlock
;	C:clr Always
;	Z:clr = Not found
;	Z:set = Found
;	  c{EDI}    = Offset of data block
;	  c{SS:ECX} = Address of network letter in device name (will point to
;			final null character is not network specified)
;  EBX and ESI are preserved

;Original device names are of the form NAMEppXssss, where NAME is a 2 to 4
;  character network device name, p is a 1 or 2 digit primary unit number, X
;  is the interface letter, and ssss is a 0 to 5 character secondary unit
;  number.  The secondary unit number is optional and is not used here.  X may
;  be missing, indicating the default interface.  The value passed in SS:ECX is
;  the address of the first character of the primary unit number in this name.

xosnetSrchBlock:
	CLRL	EDX
	MOVB	AL, SS:[ECX]
	CMPB	AL, #'0'
	JB	12$.S
	CMPB	AL, #'9'
	JA	12$.S
2$:	INCL	ECX
	IMULL	EDX, #10t.B
	ANDL	EAX, #0Fh.B
	ADDL	EDX, EAX
	MOVB	AL, SS:[ECX]
	CMPB	AL, #0
	JE	4$.S
	CMPB	AL, #'0'
	JB	4$.S
	CMPB	AL, #'9'
	JBE	2$.S
4$:	CMPL	EDX, #99t.B		;Valid unit number?
	JA	12$.S			;No
	CMPB	AL, #0			;Yes - do we have an interface letter?
	JE	xosnetSrchBlk2.S	;No - want default interface
	CMPB	AL, #'A'		;Yes - is it a letter?
	JB	12$.S			;No
	CMPB	AL, #'Z'		;Maybe
	JA	12$.S			;No
	SUBB	AL, #'A'-1		;Yes - get interface number
xosnetSrchBlk2:
	TESTL	EDI, EDI		;Have another data block
	JE	12$.S			;No - indicate not found
	CMPB	pdb_unit.B[EDI], DL	;Yes - same unit number?
	JNE	10$.S			;No
	CMPB	AL, #0			;Yes - want default network?
	JE	14$.S			;Yes
	CMPB	pdb_netnum.B[EDI], AL	;No - does network number match?
	JE	14$.S			;Yes - found it
10$:	MOVL	EDI, pdb_nextd.B[EDI]	;No - try next
	JMP	xosnetSrchBlk2.S	;Continue

;Here if no match on name

12$:	TESTL	ESP, ESP		;Clear Z
14$:	RET
.PAGE
	.SBTTL	xosnetMakeDcb - Subroutine to allocate a network DCB

;Subroutine to allocate a network DCB
;	c{{ESP}+24t} = Device name (16 characters)
;	c{{ESP}+20t} = Primary unit number
;	c{{ESP}+16t} = Secondary unit number
;	c{{ESP}+12t} = Size index for DCB
;	c{{ESP}+8t}  = Offset of CCB
;	c{{ESP}+4t}  = Offset of IDB
;	c{{ESP}+0t}  = Description bits
;	CALL	xosnetMakeDcb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset of network DCB allocated
;  On return, 40 bytes (10 longs) are removed from the stack

gd_name   =!32t		;Device name (16 characters)
gd_punit  =!28t		;Primary unit number
gd_sunit  =!24t		;Secondary unit number
gd_sizex  =!20t		;Size index for DCB
gd_ccb    =!16t		;Offset of CCB
gd_idb    =!12t		;Offset of IDB
gd_desc   =!8t		;Description bits

$$$=!0
FRM gd_index  , 4t
FRM gd_numpdb , 4t	;Number of PDBs
FRM gd_hashtbl, 4t	;Offset of hash table
gd_SIZE=!$$$

xosnetMakeDcb:
	ENTER	gd_SIZE, 0
	MOVL	EAX, netdcbnum
	CMPL	EAX, netdcblmt
	JAE	8$.S
	LEAL	EBX, gd_name.B[EBP]
	MOVL	ECX, gd_sizex.B[EBP]
	MOVL	EDI, gd_desc.B[EBP]
	CALL	knlGetDymDcb##
	JC	6$.S
	MOVL	EAX, gd_punit.B[EBP]	;Store unit numbers in the DCB
	MOVB	dcb_punit.B[EDI], AL
	MOVL	EAX, gd_sunit.B[EBP]
	MOVW	dcb_sunit.B[EDI], AX
	MOVL	ESI, gd_ccb.B[EBP]
	CALL	knlLinkDcb##
	INCL	netdcbnum
	MOVL	EAX, netdcbnum
	CMPL	EAX, netdcbmax
	JB	4$.S
	MOVL	netdcbmax, EAX
4$:	MOVL	EAX, gd_sizex.B[EBP]
	MOVB	dcb_netdcbsizex.B[EDI], AL ;Store size index in the DCB
	MOVL	ESI, gd_idb.B[EBP]
	MOVL	EAX, idb_typname.B[ESI]	;Copy type name
	MOVL	dcb_type.B[EDI], EAX
	MOVL	EAX, idb_devchar.B[ESI]	;Copy offset of device characteristics
	MOVL	dcb_devchar.B[EDI], EAX	;  table of interface device
	MOVL	dcb_netidb.B[EDI], ESI	;Store IDB offset in the DCB
	LEAVE
	CLC				;Make sure C is clear
	RET	40t

;Here if no network DCB is available

8$:	MOVL	EAX, #ER_TMDVC		;Error = Too Many DeVices open for
6$:	LEAVE	
	STC
	RET	40t
.PAGE
	.SBTTL	netiopprotocol - Process IOPAR_PROTOCOL device parameter

;Here to process the IOPAR_PROTOCOL device parameter - Low level protocol

	DPARMHDR  BOTH, DECV, 4
netiopprotocol:
	MOVL	ESI, dcb_netidb.B[EDI]
	JMPIL	idb_iopprotocol.B[ESI]
.PAGE
	.SBTTL	netiopctlmode - Process IOPAR_NET_CTLMODE device parameter

;Here to process the IOPAR_NET_CTLMODE device parameter - Set or clear link
;  control mode.  Link control mode allows a serial network port to be used
;  as a normal async port for communicating with a modem.  A non-zero parameter
;  value enables link control mode, a zero value disables it and resumes normal
;  link operation.  Link control mode is exclusive (only one DCB can have link
;  control mode set at a time) and is cleared automatically when the DCB is
;  closed.  When link control mode is set, all normal network IO is suspended
;  and normal input and output calls can be used to talk to a connected modem.
;  Synchronous links switch to async operation when link control mode is
;  enabled.  If bit 1 is set, DTR is forced low (this forces some modems into
;  command mode).

	DPARMHDR  SET, DECV, 1
netiopctlmode:
	CALL	knlGetParm##		;Get parameter value
	JC	ret002.S		;If error
	MOVL	ESI, dcb_netidb.B[EDI]	;OK - get IDB offset
	CMPL	EAX, #0.B
	JE	4$.S
	MOVL	EAX, #LNKCTL_SET
4$:	MOVL	EDX, EAX
	JMPIL	idb_lnkctl.B[ESI]	;Dispatch to the link level driver
.PAGE
	.SBTTL	netiopspmodem - Process IOPAR_SPMODEM device parameter

;Here to process the IOPAR_SPMODEM device parameter - Set or clear modem
;  control bits

	DPARMHDR  BOTH, DECV, 2
netiopmodem:
	MOVL	ESI, dcb_netidb.B[EDI]
	CMPL	idb_lnkctldcb.B[ESI], EDI ;In modem control mode?
	JNE	10$.S			;No - fail
	TESTB	AH, #PAR$SET		;Yes - want to change the values?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get parameter value
	JC	ret002.S		;If error
	MOVL	EDX, #LNKCTL_SETMC
	CALLI	idb_lnkctl.B[ESI]
	JC	6$.S
	POPL	EAX
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	ret002.S
	MOVL	EDX, #LNKCTL_GETMC
	CALLI	idb_lnkctl.B[ESI]
	JMPIL	knlStrParm4##

6$:	POPL	EDX
ret002:	RET

;Here if not in link control mode - report as illegal parameter index

10$:	MOVL	EAX, #ER_PARMI
	STC
	RET

	.SBTTL	xosnetIopSMode - Process IOPAR_NETSMODE device parameter

;Here to process the IOPAR_NETSMODE device parameter - Set network mode bits

	DPARMHDR  BOTH, HEXV, 4
xosnetIopSMode:
	TESTB	AH, #PAR$SET		;Want to change the value?
	JE	14$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get parameter value
	JC	6$.S
	ORL	dcb_netmode.B[EDI], EAX	;Set the bits
	JMP	12$.S

	.SBTTL	xosnetIopCMode - Process IOPAR_NETCMODE device parameter

;Here to process the IOPAR_NETCMODE device parameter - Clear network mode bits

	DPARMHDR  BOTH, HEXV, 4
xosnetIopCMode:
	TESTB	AH, #PAR$SET		;Want to change the value?
	JE	14$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get parameter value
	JC	6$.S
	NOTL	EAX
	ANDL	dcb_netmode.B[EDI], EAX	;Clear the bits
12$:	POPL	EAX
14$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	ret002.S		;No
	MOVL	EAX, dcb_netmode.B[EDI]	;Yes - get value
	JMPIL	knlStrParm4##
.PAGE
	.SBTTL	sd_open - Open device

;Here for the open device entry (sd_open) - also used for the device parameters
;  entry (sd_parm)
;	c{EDI} = Offset of DCB

netopen:CMPL	SS:xffParm##, #0.B
	JE	4$.S
	MOVL	EBX, #netopnparms	;Process device parameters
	MOVL	ECX, #netddparms
	IFFAULT	knlRtnAdrEr##
	LFSL	EDX, SS:xffParm##
	JMP	knlProcDevParm##

4$:	CLRL	EAX
	RET
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	CALL	netclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

netclose:
	CMPL	iorb_parm+0.B[ESI], #0.B ;Have any device parameters?
	JE	2$			;No
	MOVL	EBX, #netioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	8$
	LFSL	EDX, iorb_parm.B[ESI]
	CALL	knlProcDevParm##
	JNC	4$.S
2$:	CLRL	EAX
4$:	CMPL	dcb_opencnt.B[EDI], #1.B ;Final close?
	JE	10$.S			;Yes
6$:	TOFORK				;No
	JMP	knlCloseFin##		;Go finish up

	FAULTHDR
8$:	MOVL	EAX, #ER_ADRER
	JMP	4$.S

;Here if final close

10$:	MOVL	EBX, dcb_netidb.B[EDI]	;Get offset of our IDB
	CMPL	idb_lnkctldcb.B[EBX], EDI ;Are we in link control mode?
	JE	12$.S			;Yes
	LEAL	EBX, dcb_ndvsdb.B[EDI]	;No - get offset of our SDB
	CMPL	sdb_sapnext.B[EBX], #-1.B ;Have a SAP address?
	JE	6$.S			;No - don't bother with a fork
12$:	MOVL	EDX, idb_netclose1.B[EBX] ;Yes - get offset of fork routine
	TESTL	EDX, EDX		;Is there one?
	JE	6$.S			;No - just finish up here
	MOVL	iorb_count.B[ESI], EAX	;Yes - save error code from here
	CALL	knlIoClsLock##		;Lock the QAB
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], EDX
	JMP	knlXfQueue##		;Switch to extended fork context
.PAGE
	.SBTTL	sd_inpblock - Input block

;Here for the sd_inpblock entry - input block
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	netinpblock
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

netinpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock all buffer pages
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_inpframe
	MOVL	iorb_routine.B[ESI], #netinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here in extended fork context

netinpblk1:
	MOVL	SS:xffTimeOut##, #-1
	CMPL	SS:xffParm##+0, #0.B
	JE	4$.S
	MOVL	EBX, #netioparms	;Process parameters
	MOVL	ECX, #netddparms
	IFFAULT	knlQAdrErr0##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	8$.S			;If error
4$:	CMPL	SS:xffCount##, #0.B	;Really want to do input?
	JE	16$			;No
	MOVL	ESI, dcb_netidb.B[EDI]	;Yes - get offset of our IDB
	CMPL	idb_lnkctldcb.B[ESI], #0 ;In link control mode?
	JE	10$.S			;No
	CMPL	idb_lnkctldcb.B[ESI], EDI ;Yes - by us?
	JNE	6$.S			;No - fail
	MOVL	EDX, #LNKCTL_INPUT	;Yes
	JMPIL	idb_lnkctl.B[ESI]	;Go to device driver routine

6$:	MOVL	EAX, #ER_BUSY
8$:	JMP	18$.S

;Here if not in link control mode

10$:	MOVL	EAX, SS:xffTimeOut##	;Wait for input to appear
	CALL	knlXfWait##
	JC	18$.S			;If error
	MOVL	EBX, dcb_ndvrcvpkt.B[EDI] ;Get offset of the packet
	CLRL	EAX
	MOVL	dcb_ndvrcvpkt.B[EDI], EAX
	PUSHL	EDI
	PUSHL	ESI
	MOVL	ESI, EBX
	IFFAULT	20$
	LESL	EDI, SS:xffBuffer1##	;Get address of buffer
	MOVL	ECX, npb_count.B[EBX]
	CMPL	ECX, #4.B		;4 bytes or fewer?
	JBE	12$.S			;Yes
	MOVL	EAX, ECX		;No
	CLRL	ECX			;Get destination long aligned
	SUBL	ECX, EDI
	ANDL	ECX, #03.B
	SUBL	EAX, ECX
	IFFAULT	20$
	RMOVSB	[EDI], [ESI]
	MOVL	ECX, EAX
	SHRL	ECX, #2
	IFFAULT	20$
	RMOVSL	[EDI], [ESI]
	MOVL	ECX, EAX
	ANDL	ECX, #03.B
12$:	IFFAULT	20$
	RMOVSB	[EDI], [ESI]
	POPL	ESI
	POPL	EDI
	PUSHL	npb_count.B[EBX]
	CALL	xosnetGiveBufr		;Give up the buffer
	POPL	ECX
	CLRL	EAX
14$:	MOVL	EBX, #QSTS$DONE
	RET

;Here if nothing to input

16$:	CLRL	EAX
18$:	CLRL	ECX
	JMP	14$.S

;Here if address error

	FAULTHDR
20$:	POPL	ESI
	POPL	EDI
	MOVL	EAX, #ER_ADRER
	JMP	18$.S
.PAGE
	.SBTTL	xosnetRcvPkt - Subroutine called when packet has been input

;Subroutine called when packet has been input for network level device
;	c{EBX} = Offset of start of packet
;	c{ECX} = Length of packet
;	c{EDI} = Offset of PDB
;	c{ESI} = Offset of IDB
;	CALL	xosnetRcvPkt

xosnetRcvPkt:
	SUBL	EDI, #dcb_ndvsdb.B	;Point to our DCB
	CMPW	dcb_inpframe.B[EDI], #0.B ;Is input active?
	JE	4$.S			;No - ignore this packet
	CMPL	dcb_ndvrcvpkt.B[EDI], #0.B ;Yes - have a packet pending now?
	JNE	4$.S			;Yes - ignore this one
	MOVL	dcb_ndvrcvpkt.B[EDI], EBX ;No - accept this one
	CLRL	EAX
	JMP	knlResumeInput##	;Yes - continue with input

;Here if no one is ready for the received packet

4$:	INCL	idb_cntublxcd.B[ESI]	;Count this
	CALL	xosnetGiveBufr
	RET
.PAGE
	.SBTTL	sd_outblock - Output block

;Here for the sd_outblock entry - output block
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	netoutblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

netoutblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock the buffer pages
	JC	2$.S
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #netoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here in extended fork context

netoutblk1:
	MOVL	SS:xffTimeOut##, #-1
	CMPL	SS:xffParm##, #0.B	;Have any parameters?
	JE	4$.S			;No
	MOVL	EBX, #netioparms	;Yes - process parameters
	MOVL	ECX, #netddparms
	IFFAULT	knlQAdrErr0##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	12$.S			;If error
4$:	CLRL	EAX
	MOVL	ECX, SS:xffCount##
	JREGZ	ECX, 8$		;If nothing to output
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	CMPL	idb_lnkctldcb.B[ESI], #0 ;In link control mode?
	JE	10$.S			;No
	CMPL	idb_lnkctldcb.B[ESI], EDI ;Yes - by us?
	JNE	6$.S			;No - fail
	MOVL	EDX, #LNKCTL_OUTPUT	;Yes
	JMPIL	idb_lnkctl.B[ESI]	;Go to device driver routine

6$:	CLRL	ECX
	MOVL	EAX, #ER_BUSY
8$:	JMP	14$.S

;Here if not in link control mode

10$:	CMPL	dcb_netpdb.B[EDI], #0.B	;Do we have a protocol?
	JE	16$.S			;No - fail
	CALL	xosnetGetBufr		;Yes - allocate a buffer
12$:	JC	20$.S			;If error
	MOVL	npb_count.B[EBX], ECX	;OK - store buffer size
	CLRL	EAX
	MOVL	npb_next.B[EBX], EAX
	PUSHL	EDI
	PUSHL	ESI
	MOVL	EDI, EBX
	PUSHL	DS
	POPL	ES
	IFFAULT	18$
	LFSL	ESI, SS:xffBuffer1##	;Get address of buffer
	MOVL	EAX, ECX		;Copy user's data to our buffer
	SHRL	ECX, #2t
	CLD
	IFFAULT	18$
	RMOVSL	[EDI], FS:[ESI]
	MOVL	ECX, EAX
	ANDL	ECX, #03.B
	IFFAULT	18$
	RMOVSB	[EDI], FS:[ESI]
	POPL	ESI
	POPL	EDI
	MOVL	npb_outdone.B[EBX], #xosnetOutDone
	CALL	xosnetSendPkt		;Output the packet
	JC	20$.S			;If error
	MOVL	EAX, SS:xffTimeOut##	;Get time-out value
	CALL	xosnetWaitPkt
	JC	20$.S			;If error while waiting
	MOVL	ECX, SS:xffCount##	;Get amount we output
14$:	MOVL	EBX, #QSTS$DONE
	RET

;Here if no network protocol defined for the device

16$:	MOVL	EAX, #ER_NNOPC
	JMP	14$.S

;Here if address error

	FAULTHDR
18$:	POPL	ESI
	POPL	EDI
	MOVL	EAX, #ER_ADRER
20$:	CLRL	ECX
	JMP	14$.S
.PAGE
	.SBTTL	xosnetWaitPkt - Subroutine to wait until packet has been output

;Subroutine to wait until packet has been output - upon return output is either
;  complete or has been canceled, in either case, the packet may be used
;  freely, including being deallocated immediately - note: an error return
;  from this routine does NOT guarentee that the packet was not output, but
;  it probably was not output in this case
;	c{EAX} = Timeout value
;	c{EBX} = Offset of packet header
;	c{ESI} = Offset of IDB
;	CALL	xosnetWaitPkt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

xosnetWaitPkt:
	CMPL	idb_magic.B[ESI], #'IDB*' ;Make sure really have an IDB here
	JNE	12$.S
	CMPL	npb_nextsnd.B[EBX], #-1.B ;Is output already finished?
	JE	10$.S			;Yes - nothing needed here
	MOVL	npb_outdone.B[EBX], #xosnetOutDone ;No - change done dispatch
2$:	PUSHL	EAX			;Save timeout value
4$:	CALL	xosnetOutWait		;Wait until output is done
	JC	netwper.S		;If error while waiting
	CMPL	npb_nextsnd.B[EBX], #-1.B ;Is output really finished?
	JE	8$.S			;Yes - all done here
	POPL	EAX			;No - restore timeout value
	JMP	2$.S			;Wait some more

;Here if have error sending the packet

6$:	ADDL	ESP, #4.B		;Fix up the stack (don't change any
	STC				;  registers)
	RET				;Indicate error and return

;Here if finished with output

8$:	POPL	EAX			;Discard timeout value from the stack
10$:	CLRL	EAX			;Return 0
	RET

12$:	CRASH	NIDB			;[Not an IDB]
.PAGE
;Here if error while waiting

netwper:ADDL	ESP, #4.B		;Discard timeout value from the stack
	CMPL	npb_nextsnd.B[EBX], #-1.B ;Is the packet idle now?
	JE	24$			;Yes - just return the error
	CMPL	idb_outbuf.B[ESI], EBX	;No - is it being output now?
	JNE	4$.S			;No - go remove it from the queue
	PUSHL	EAX
2$:	MOVL	EAX, #-1		  ;Yes - must wait until interface gets
	CALL	xosnetOutWait		  ;  done with it (which should happen
	CMPL	npb_nextsnd.B[EBX], #-1.B ;  soon since all output has a
	JNE	2$.S			  ;  hardware level time-out)
	POPL	EAX
	STC
	RET

;Here if have error and the packet has not been output yet - remove it from
;  the output queue, the send self list, or the routing table hold list

4$:	PUSHL	EAX
	PUSHL	EDX
	TESTB	npb_sts.B[EBX], #NPS$SELF ;No - did we send it to ourselves?
	JE	14$.S			;No
	LEAL	EDX, idb_sfhead.B[ESI]	;Yes - find predecessor in send-self
					;  list
6$:	CMPL	[EDX], EBX		;This one?
	JE	8$.S			;Yes
	MOVL	EDX, [EDX]		;No - advance to next
	TESTL	EDX, EDX
	JE	12$.S
	ADDL	EDX, #npb_nextsnd.B
	JMP	6$.S

;Here with predecessor in send self list

8$:	MOVL	EAX, npb_nextsnd.B[EBX]	;Remove this packet from the list
	MOVL	[EDX], EAX
	TESTL	EAX, EAX		;Last packet in list?
	JNE	22$.S			;No - finished
	CMPL	idb_sfhead.B[ESI], #0.B ;Yes - was it the only one?
	JE	10$.S			;Yes
	LEAL	EAX, -npb_nextsnd.B[EDX] ;No - point to start of new tail packet
10$:	MOVL	idb_sftail.B[ESI], EAX	;Update tail pointer for list
	JMP	22$.S

12$:	CRASH	BPSL			;[Bad Packet Send-self List]

;Here if not sending the packet to ourselves

14$:	CMPL	npb_holdrt.B[EBX], #0.B	;Is this packet being held by a routing
					;  table entry?
	JE	15$.S			;No
	CALL	unholdpkt		;Yes - remove it
	JMP	22$.S			;Continue

;Here if packet should be in the output list

15$:	LEAL	EDX, idb_outhead.B[ESI]	;Find predecessor in output list
16$:	CMPL	[EDX], EBX
	JE	18$.S
	MOVL	EDX, [EDX]
	TESTL	EDX, EDX
	JE	26$.S
	ADDL	EDX, #npb_nextsnd.B
	JMP	16$.S

;Here with predecessor in packet output list

18$:	MOVL	EAX, npb_nextsnd.B[EBX]	;Remove this packet from the list
	MOVL	[EDX], EAX
	TESTL	EAX, EAX		;Last packet in list?
	JNE	22$.S			;No - finished
	CMPL	idb_outhead.B[ESI], #0.B ;Yes - was it the only one?
	JE	20$.S			;Yes
	LEAL	EAX, -npb_nextsnd.B[EDX] ;No - point to start of new tail packet
20$:	MOVL	idb_outtail.B[ESI], EAX	;Update tail pointer for list
22$:	MOVL	npb_nextsnd.B[EBX], #-1
	POPL	EDX
	POPL	EAX			;Restore error code
24$:	STC				;Indicate error
	RET

26$:	CRASH	BPOL			;[Bad Packet Output List]
.PAGE
	.SBTTL	unholdpkt - Subroutine to remove packet from routing hold list

;Subroutine to remove packet from a routing table hold list

unholdpkt:
	PUSHL	ECX
	MOVL	ECX, npb_holdrt.B[EBX]	;Get offset of routing table entry
	LEAL	EDX, rt_holdhead.B[ECX]	;Find predecessor in hold list
2$:	CMPL	[EDX], EBX
	JE	4$.S
	MOVL	EDX, [EDX]
	TESTL	EDX, EDX
	JE	10$.S
	ADDL	EDX, #npb_nextsnd.B
	JMP	2$.S

;Here with predecessor in packet hold list

4$:	MOVL	EAX, npb_nextsnd.B[EBX]	;Remove this packet from the list
	MOVL	[EDX], EAX
	TESTL	EAX, EAX		;Last packet in list?
	JNE	8$.S			;No - finished
	CMPL	rt_holdhead.B[ECX], #0.B ;Yes - was it the only one?
	JE	6$.S			;Yes
	LEAL	EAX, npb_nextsnd.B[EDX]	;No - point to start of new tail packet
6$:	MOVL	rt_holdtail.B[ECX], EAX	;Update tail pointer for list
8$:	POPL	ECX
	RET

10$:	CRASH	BPHL			;[Bad Packet Hold List]
.PAGE
	.SBTTL	xosnetSendPkt - Subroutine to send packet

;Subroutine to send packet without waiting - caller may later call netWaitPkt
;  to wait until output is finished - must be called in extended fork context
;  or at device fork level
;	c{EBX} = Offset of packet buffer (npb_outdone must be set)
;	c{ESI} = Offset of IDB
;	CALL	xosnetSendPkt
;	C:set = Error (output done routine WILL NOT be called (???) )
;	  c{EAX} = Error code
;	  c{EBX} = Offset of packet buffer
;	C:clr = Normal
;	  c{EBX} = 0

xosnetSendPkt:

	CMPL	npb_count.B[EBX], #0
	JNE	1$.S
	INT3
1$:

	CMPL	idb_magic.B[ESI], #'IDB*' ;Make sure really have an IDB here
	JNE	2$.S
	CMPL	npb_nextsnd.B[EBX], #-1.B ;Is this packet on an output list now?
	JNE	netbadoutlist.S		;Yes - fail big!
	CMPL	npb_outdone.B[EBX], #0.B ;No - have output done dispatch offset?
	JE	netnodonedisp.S		;No!
	CMPL	idb_outbuf.B[ESI], EBX	;Yes - now outputing this packet?
	JE	netoutbusy.S		;Yes!
	CMPL	idb_lnkctldcb.B[ESI], #0.B ;In link control mode?
	JNE	4$.S			;Yes - fail
	CMPB	idb_state.B[ESI], #LNKS_CNCTD ;No - connected or established?
	JB	4$.S			;No - fail
	TESTB	npb_sts.B[EBX], #NPS$SELF ;Yes - is it for us?
	JNE	sendself.S		;Yes
	TESTB	idb_sts.B[ESI], #IS$RESET|IS$REXMIT ;No - doing hardware reset?
	JNE	10$.S			;Yes - must queue this packet
	CMPL	idb_xmtavail.B[ESI], #0.B ;No - can we do output now?
	JE	10$.S			;No - must queue this packet
	DECL	idb_xmtavail.B[ESI]	;Yes - reduce output availability
sendpk4:CLRL	EAX
	MOVL	npb_nextsnd.B[EBX], EAX	;Set link to 0 to indicate packet is
					;  being output
	MOVL	npb_holdrt.B[EBX], EAX	;Also make sure hold list back pointer
					;  is clear
	MOVL	idb_outbuf.B[ESI], EBX	;Store buffer as current output buffer
	CALLI	idb_sendpkt.B[ESI]	;Dispatch to the driver
	RET				;Finished

2$:	CRASH	NIDB

;Here if in link control mode

4$:	MOVL	EAX, #ER_NLKNA
	STC
	RET

;Here if packet output is busy - queue this packet for output later

10$:	INCL	npb_nextsnd.B[EBX]	;Put request on the output list
	MOVL	EAX, idb_outtail.B[ESI]
	TESTL	EAX, EAX
	JE	12$.S			;If list is empty now
	MOVL	npb_nextsnd.B[EAX], EBX	;Link to end of list
	JMP	14$.S

;Here if output list was empty

12$:	MOVL	idb_outhead.B[ESI], EBX
14$:	MOVL	idb_outtail.B[ESI], EBX
	CLRL	EBX			;Clear pointer to discourage fiddling
	RET				;  with the packet while its being sent!

;Here if packet to be sent is already on an output list!

netbadoutlist:
	CRASH	BPOL			;[Bad Packet Output List]

netnodonedisp:
	CRASH	BPDO			;[Bad Packet Done Offset]

netoutbusy:
	CRASH	SPK2			;[Sending PacKet 2 times]
.PAGE
;Here if sending this packet to ourselves

sendself:
	MOVL	EAX, idb_sftail.B[ESI]	;Link it to the end of our send-self
	TESTL	EAX, EAX		;  list
	JNE	2$.S
	MOVL	idb_sfhead.B[ESI], EBX
	JMP	4$.S

2$:	MOVL	npb_nextsnd.B[EAX], EBX
4$:	MOVL	idb_sftail.B[ESI], EBX
	CLRL	EAX
	MOVL	npb_nextsnd.B[EBX], EAX
	PUSHL	EDI
	LEAL	EDI, idb_sfidb.B[ESI]
	CALL	knlReqFork##
	POPL	EDI
	CLRL	EBX
ret004:	RET
.PAGE
;Send-self fork routine

netsffork:
	LEAL	ESI, -idb_sfidb.B[EDI]	;Point to the IDB
2$:	MOVL	EBX, idb_sfhead.B[ESI]	;Get a packet
	TESTL	EBX, EBX
	JE	ret004.S
	MOVL	EAX, npb_nextsnd.B[EBX]	;Remove from list
	MOVL	idb_sfhead.B[ESI], EAX
	TESTL	EAX, EAX
	JNE	4$.S
	MOVL	idb_sftail.B[ESI], EAX
4$:	MOVL	npb_nextsnd.B[EBX], #-1
	MOVL	ECX, npb_count.B[EBX]	;Get length of packet
	PUSHL	ESI
	PUSHL	ECX
	PUSHL	EBX
	CLRL	EDI			;No DCB or PDB
	CALL	xosnetGetBufr		;Get a network buffer
	JC	18$.S			;If error
	MOVL	ESI, [ESP]		;OK - set up to copy the data
	MOVL	EDI, EBX
	PUSHL	DS
	POPL	ES
	CLD
	MOVL	EDX, [ESP]
	MOVZBL	EAX, npb_sizex.B[ESI]	;Get size index for buffer
	MOVL	EAX, knlXmbSize##[EAX*4]
	SUBL	EAX, #npb_mSIZE.B
10$:	CMPL	ECX, EAX		;Is this the last chunk?
	JLE	12$.S			;Yes
	SUBL	ECX, EAX		;No - calculate amount left after this
	PUSHL	ECX
	MOVL	ECX, EAX
	SHRL	ECX, #2			;Get number of longs in this chunk
	RMOVSL	[EDI], [ESI]		;Copy chunk to the output packet buffer
	MOVL	EDX, npc_link.B[EDX]	;Point to next chunk
	MOVL	ESI, EDX
	MOVZBL	EAX, npc_sizex.B[ESI]	;Get size index for buffer
	MOVL	EAX, knlXmbSize##[EAX*4]
	SUBL	EAX, #npc_mSIZE.B	;Get size
	POPL	ECX			;Restore amount left to copy
	JMP	10$.S			;Continue

;Here with last chunk of packet to copy

12$:	ADDL	ECX, #3.B
	SHRL	ECX, #2			;Get number of longs
	RMOVSL	[EDI], [ESI]		;Copy packet to the output packet buffer
	XCHGL	EBX, [ESP]		;Save offset of "received" packet,
					;  get offset of "transmitted" packet
	MOVL	ESI, 8.B[ESP]		;Restore offset of IDB
	MOVL	EDI, npb_dcb.B[EBX]	;Restore offset of sender's DCB
	MOVL	ECX, npb_outdone.B[EBX]
	CLRL	EAX
	MOVL	npb_outdone.B[EBX], EAX
	CALLI	ECX			;Do output done processing
	POPL	EBX			;Restore offset of "received" packet
	POPL	ECX			;Restore size of packet
	MOVL	ESI, [ESP]
	CALLI	idb_rcvpkt.B[ESI]	;Process the "received" packet
	POPL	ESI
16$:	JMP	2$

;Here if cannot allocate a buffer

18$:	POPL	EBX			;Restore registers
	POPL	ECX
	POPL	ESI
	JMP	16$.S
.PAGE
	.SBTTL	xosnetFinXmit - Subroutine to do output done processing

;Subroutine to do output done processing
;	c{ESI} = Offset of IDB
;	c{EAX} = Error code (0 if no error)
;	CALL	xosnetFinXmit

xosnetFinXmit:
	MOVL	EBX, idb_outbuf.B[ESI]	;Get offset of output buffer
	TESTL	EBX, EBX		;Really have a buffer?
	JE	2$.S			;No
xosnetFinXmit2:
	INCL	idb_cntpktout.B[ESI]	;Yes - count the packet
	MOVL	EDX, npb_count.B[EBX]	;Add in to byte count
	ADDL	idb_cntbyteout.B[ESI], EDX
	MOVL	npb_nextsnd.B[EBX], #-1	;Indicate not being output
	MOVL	EDI, npb_dcb.B[EBX]	;Restore offset of DCB
	MOVL	ECX, npb_outdone.B[EBX]
	CLRL	EDX
	MOVL	idb_outbuf.B[ESI], EDX
	MOVL	npb_outdone.B[EBX], EDX
	CALLI	ECX			;Do output done processing (this may
					;  queue another request)
2$:	TESTB	idb_sts.B[ESI], #IS$RESET|IS$REXMIT
	JNE	6$.S
	MOVL	EBX, idb_outhead.B[ESI]	;Have another output request now?
	TESTL	EBX, EBX
	JNE	10$.S			;Yes
6$:	INCL	idb_xmtavail.B[ESI]	;No - increase output availability
	MOVB	idb_outtimer.B[ESI], #0	;Clear output timer
	RET				;Thats all for now

;Here if have another output request

10$:	TESTB	idb_sts.B[ESI], #IS$RESET|IS$REXMIT ;Is interface being reset?
	JNE	6$.S			;Yes - stop for now
	MOVL	EAX, npb_nextsnd.B[EBX]	;No - remove buffer from the output list
	MOVL	idb_outhead.B[ESI], EAX
	TESTL	EAX, EAX
	JNE	12$.S
	MOVL	idb_outtail.B[ESI], EAX
12$:	MOVL	npb_nextsnd.B[EBX], #-1
	JMP	sendpk4
.PAGE
	.SBTTL	xosnetOutWait - Subroutine to wait until output is done

;Subroutine to wait until output is done
;	c{EAX} = Time-out value
;	c{EDI} = Offset of DCB
;	CALL	xosnetOutWait
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosnetOutWait:
	CMPB	SS:xffQueue##, #dcb_outframe ;Is this the output fork?
	JNE	2$.S			;No
	ORB	dcb_netsts1.B[EDI], #NS1$OFWOUT ;Yes
	CALL	knlXfWait##
	ANDB	dcb_netsts1.B[EDI], #~NS1$OFWOUT
	BTL	EAX, #31t
	RET

2$:	ORB	dcb_netsts1.B[EDI], #NS1$IFWOUT
	CALL	knlXfWait##
	ANDB	dcb_netsts1.B[EDI], #~NS1$IFWOUT
	BTL	EAX, #31t
	RET

	.SBTTL	xosnetSndWait - Subroutine to wait until output window is open

;Subroutine to wait until output window is open
;	c{EAX} = Time-out value
;	c{EDI} = Offset of DCB
;	CALL	xosnetSndWait
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosnetSndWait:
	CMPB	SS:xffQueue##, #dcb_outframe ;Is this the output fork?
	JNE	4$.S			;No
	ORB	dcb_netsts1.B[EDI], #NS1$OFWSND ;Yes
	CALL	knlXfWait##
	ANDB	dcb_netsts1.B[EDI], #~NS1$OFWSND
	BTL	EAX, #31t
	RET

4$:	ORB	dcb_netsts1.B[EDI], #NS1$IFWSND
	CALL	knlXfWait##
	ANDB	dcb_netsts1.B[EDI], #~NS1$IFWSND
	BTL	EAX, #31t
	RET

	.SBTTL	xosnetRspWait - Subroutine to wait for a response

;Subroutine to wait for a response
;	c{EAX} = Time-out value
;	c{EDI} = Offset of DCB
;	CALL	xosnetRspWait
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosnetRspWait:
	CMPB	SS:xffQueue##, #dcb_outframe ;Is this the output fork?
	JNE	6$.S			;No
	ORB	dcb_netsts1.B[EDI], #NS1$OFWRSP ;Yes
	CALL	knlXfWait##
	ANDB	dcb_netsts1.B[EDI], #~NS1$OFWRSP
	BTL	EAX, #31t
	RET

6$:	ORB	dcb_netsts1.B[EDI], #NS1$IFWRSP
	CALL	knlXfWait##
	ANDB	dcb_netsts1.B[EDI], #~NS1$IFWRSP
	BTL	EAX, #31t
ret010:	RET
.PAGE
	.SBTTL	xosnetOutDone - Subroutine called when output is complete

;Subroutine called when output is complete
;	c{EAX} = Error code
;	c{EDI} = Offset of DCB
;	CALL	xosnetOutDone
;  All registers except ES are preserved

xosnetOutDone:
	TESTB	dcb_netsts1.B[EDI], #NS1$OFWOUT ;Is output fork waiting?
	JE	2$.S			;No
	ANDB	dcb_netsts1.B[EDI], #~NS1$OFWOUT ;Yes
	PUSHL	EAX
	CALL	knlResumeOutput##
	POPL	EAX
2$:	TESTB	dcb_netsts1.B[EDI], #NS1$IFWOUT ;Is input fork waiting?
	JE	ret010.S		;No
	ANDB	dcb_netsts1.B[EDI], #~NS1$IFWOUT ;Yes
	JMP	knlResumeInput##

	.SBTTL	xosnetSndDone - Subroutine called when output window is open

;Subroutine called when output window is open
;	c{EAX} = Error code
;	c{EDI} = Offset of DCB
;	CALL	xosnetSndDone
;  All registers except ES are preserved

xosnetSndDone:
	TESTB	dcb_netsts1.B[EDI], #NS1$OFWSND ;Is output fork waiting?
	JE	4$.S			;No
	ANDB	dcb_netsts1.B[EDI], #~NS1$OFWSND ;Yes
	PUSHL	EAX
	CALL	knlResumeOutput##
	POPL	EAX
4$:	TESTB	dcb_netsts1.B[EDI], #NS1$IFWSND ;Is input fork waiting?
	JE	ret010.S		;No
	ANDB	dcb_netsts1.B[EDI], #~NS1$IFWSND ;Yes
	JMP	knlResumeInput##

	.SBTTL	xosnetRspDone - Subroutine called when a response is received

;Subroutine called when a response is received
;	c{EAX} = Error code
;	c{EDI} = Offset of DCB
;	CALL	xosnetRspDone		;Enter at netRspDoneOut to only
;					;  check output fork frame
;  All registers except ES are preserved

xosnetRspDone:
	TESTB	dcb_netsts1.B[EDI], #NS1$IFWRSP ;Is input fork waiting?
	JE	xosnetRspDoneOut.S	;No
	ANDB	dcb_netsts1.B[EDI], #~NS1$IFWRSP ;Yes
	PUSHL	EAX
	CALL	knlResumeInput##
	POPL	EAX
xosnetRspDoneOut:
	TESTB	dcb_netsts1.B[EDI], #NS1$OFWRSP ;Is output fork waiting?
	JE	ret010.S		;No
	ANDB	dcb_netsts1.B[EDI], #~NS1$OFWRSP ;Yes
	JMP	knlResumeOutput##

	.SBTTL	xosnetAllDone - Subroutine to wake up all waiters

;Subroutine to wake up all extended forks waiting for a network event
;	c{EAX} = Error code
;	c{EDI} = Offset of DCB
;	CALL	xosnetAllDone
;  All registers except ES are preserved

xosnetAllDone:
	TESTB	dcb_netsts1.B[EDI], #NS1$IFWRSP|NS1$IFWSND|NS1$IFWOUT
					;Is input fork waiting?
	JE	8$			;No
	ANDB	dcb_netsts1.B[EDI], #~{NS1$IFWRSP|NS1$IFWSND|NS1$IFWOUT} ;Yes
	PUSHL	EAX
	CALL	knlResumeInput##
	POPL	EAX
8$:	TESTB	dcb_netsts1.B[EDI], #NS1$OFWRSP|NS1$OFWSND|NS1$OFWOUT
					;Is output fork waiting?
	JE	ret010.S		;No
	ANDB	dcb_netsts1.B[EDI], #~{NS1$OFWRSP|NS1$OFWSND|NS1$OFWOUT} ;Yes
	JMP	knlResumeOutput##
.PAGE
	.SBTTL	xosnetGetBufr - Subroutine to allocate network buffer

;Subroutine to allocate a network buffer - must be called at fork level
;	c{ECX} = Data space needed
;	c{EDI} = Offset of DCB, PDB, or SDB
;	c{ESI} = Offset of IDB
;	CALL	xosnetGetBufr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EBX} = Offset of buffer
;  EAX is destroyed, all other registers (except EBX) are preserved

xosnetGetBufr:
	REQUIREFORK
	PUSHL	ECX
	PUSHL	EDX
	PUSHL	ESI
	LEAL	EDX, npb_mSIZE.B[ECX]	;Get exec memory buffer size index
	CALL	knlGetIndex##
	JC	2$.S
	CALL	knlGetXmb##		;Get an exec memory buffer
	LEAL	EBX, npb_mSIZE.B[ESI]
2$:	POPL	ESI
	POPL	EDX
	JC	6$.S
	ORL	ECX, #NPB_MAGIC<16t
	XCHGB	CL, CH
	MOVL	npb_sts.B[EBX], ECX	;This stores size index, clears npb_sts,
	POPL	ECX			;  and stores the magic number
	MOVL	npb_dcb.B[EBX], EDI	;Store offset of the DCB, PDB, or SDB
	CLRL	EAX
	MOVL	npb_next.B[EBX], EAX	;Clear pointer to next buffer
	MOVL	npb_outdone.B[EBX], EAX	;Clear output done dispatch
	MOVL	npb_holdrt.B[EBX], EAX	;Clear hold list back pointer
	MOVL	npb_link.B[EBX], EAX	;Clear offset of next chunk
	DECL	EAX
	MOVL	npb_nextsnd.B[EBX], EAX	;Indicate not in an output list
	RET				;Finished

;Here if error

6$:	POPL	ECX
	RET
.PAGE
	.SBTTL	xosnetExtendBufr - Subroutine to extend a network buffer

;Subroutine to extend a network buffer - must be called at fork level
;	c{EBX} = Offset of initial buffer chunk
;	c{EDX} = Offset of current buffer chunk
;	c{ECX} = Additional data space needed
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IDB
;	CALL	xosnetExtendBufr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX} = Offset of new chunk
;  EAX is destroyed, all other registers (except EDX) are preserved

xosnetExtendBufr:

	INCL	extendcnt		;########

	REQUIREFORK
	PUSHL	EBX
	PUSHL	ECX
	PUSHL	EDX
	PUSHL	ESI
	LEAL	EDX, npc_mSIZE.B[ECX]	;Get exec memory buffer size index
	CALL	knlGetIndex##
	JC	2$.S
	CALL	knlGetXmb##		;Get an exec memory buffer
	LEAL	EDX, npc_mSIZE.B[ESI]
2$:	POPL	ESI
	POPL	EBX
	JC	4$.S
	ORL	ECX, #NPC_MAGIC<16t
	XCHGB	CL, CH
	MOVL	npc_sts.B[EDX], ECX	;This stores size index, clears npb_sts,
	POPL	ECX			;  and stores the magic number
	CLRL	EAX
	MOVL	npc_link.B[EDX], EAX	;Clear offset of next chunk
	MOVL	npc_link.B[EBX], EDX	;Link to previous chunk
	POPL	EBX
	RET

;Here if error

4$:	POPL	ECX
	POPL	EBX
	RET
.PAGE
	.SBTTL	xosnetGiveLst - Subroutine to give up list of network buffers

;Subroutine to give up list of network buffers
;	c{EBX} = Offset of first buffer in list
;	CALL	xosnetGiveList
;	c{EBX} = 0
;  All registers except EBX are preserved

xosnetGiveList:
	PUSHL	npb_next.B[EBX]
	CALL	xosnetGiveBufr
	POPL	EBX
	TESTL	EBX, EBX
	JNE	xosnetGiveList.S
	RET
.PAGE
	.SBTTL	xosnetGiveBufr - Subroutine to give up network buffer

;Subroutine to give up network buffer - must be called at fork level
;	c{EBX} = Offset of buffer
;	CALL	xosnetGiveBufr
;	c{EBX} = 0
;  All registers except EBX are preserved

xosnetGiveBufr:
	REQUIREFORK
	CMPW	npb_magic.B[EBX], #NPB_MAGIC ;Is this really a network buffer?
	JNE	10$.S			;No!
	CMPL	npb_nextsnd.B[EBX], #-1.B ;Yes - is this buffer being output?
	JNE	6$.S			;Yes - go handle that case
	PUSHL	ECX			;No
	PUSHL	ESI
	PUSHL	npb_link.B[EBX]		;Save offset of additional buffer chunk
	MOVZBL	ECX, npb_sizex.B[EBX]	;Get size index
	LEAL	ESI, -npb_mSIZE.B[EBX]	;Get offset of buffer
2$:	CALL	knlGiveXmb##		;Get up the exec memory buffer
	POPL	ESI
	TESTL	ESI, ESI
	JE	4$.S
	PUSHL	npc_link.B[ESI]
	MOVZBL	ECX, npc_sizex.B[ESI]
	SUBL	ESI, #npc_mSIZE.B
	JMP	2$.S

;Here with all buffer chunks given up

4$:	POPL	ESI
	POPL	ECX
	CLRL	EBX
	RET

;Here if buffer is being output

6$:	MOVL	npb_outdone.B[EBX], #xosnetGiveBufr
	CLRL	EBX			;Change output done dispatch to give up
	RET				;  buffer when output is complete

10$:	CRASH	NANB			;[Not A Network Buffer]
.PAGE
	.SBTTL	xosnetChkNetAddr - Subroutine to see if a network address was specified

;Subroutine to see if a network address was specified - a network address is
;  of the form:
;		stringofchracters::
;  Generally, the string will be of the form n.n.n.n (dotted decimal notation),
;  n-n-n-n ("dotted" hexidecimal notation), or name.name.name... (domain name),
;  although this routine does not care about this.  It only checks for the ::.
;	c{EDX} = Offset of start of name string
;	CALL	xosnetChkNetAddr
;	c{EDX} = Unchanged
;	Z:set = Network address specified
;	  c{ECX} = Offset of second colon after network address
;	Z:clr = No network address

xosnetChkNetAddr:
	MOVL	ECX, EDX		;Save name offset
4$:	MOVB	AL, SS:[EDX]		;Look for a double colon
	INCL	EDX
	CMPB	AL, #0
	JE	6$.S
	CMPB	AL, #':'
	JNE	4$.S
	CMPB	SS:[EDX], AL
	JE	10$.S			;Have double colon
6$:	MOVL	EDX, ECX		;No colon - restore name pointer
	TESTL	EDX, EDX		;Clear Z
	RET				;Finished

;Here if a network address was given - Z is set here

10$:	XCHGL	EDX, ECX		;Restore name pointer
	RET
.PAGE
	.SBTTL	Network class driver data

	DATA
		
netdcbnum:    .LONG 0		;Number of in use network DCBs
netdcbmax:    .LONG 0		;Maximum in use network DCBs
netdcblmt:    .LONG 10000t	;Maximum number of network DCBs allowed
netccb:	      .BLKB ccb_SIZE	;Network CCB
fnetdrv:      .LONG 0		;Offset of first network driver data block
thisprotpdb:  .LONG 0		;Data for PROTTHIS, PROTNEXT, and PROTDEV device
				;  charateristics

extendcnt::   .LONG 0		;#########
xosnetIdbHead:.LONG 0
xosnetIdbTail:.LONG 0

	LKEEND
