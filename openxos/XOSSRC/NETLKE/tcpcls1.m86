	.TITLE	TCPCLS1 - TCP routines for XOS (part 1)

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXIPS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTCP.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!2t
MINV   =!0t
EDITNUM=!5t

;1.0.1 2-Dec-94
;	Fixed problem with receiving FIN|ACK after connection closed (A JMP
;	was lost when the TPDB handling was changed!).
;1.1.0 3-Sep-99
;	Added type 3 in-coming connection handling.
;1.1.1  1-Feb-01
;	Fixed problem with rejected incoming connections corrupting the ARP
;	receive dispatch pointer.
;1.1.2 22-Feb-01
;	Fixed problem with resetting retransmission values when accepting a
;	type 3 new connection.
;1.2.0 19-Aug-02
;	Modified use of npb_count in received packets. Added call to
;	knlGetRandom32 to get initial sequence number.
;2.0.0 ??-Dec-02
;	Rewrite of output handling to change to late packetizing.
;2.0.1 ??-Jan-03
;	Fixed several output problems.
;2.0.2 29-Jan-03
;	Fixed major problem with output retransmission.
;2.0.3  3-Feb-03
;	Fixed problem which caused outgoing connections forever to be retried
;	forever.
;2.0.4 27-Feb-03
;	Fixed problem with timeouts for SYNR state.
;2.0.5 6-Mar-03
;	Fixed problem with not starting output when window closed.

	LKEHEAD	TCPCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

;This module implements the TCP transport level protocol.  It supports the full
;  protocol with the following exceptions:
;	Out of order packets are discarded
;	Urgent data is not handled correctly
;	The TIMEWAIT state is not implemented - ports are made idle as soon as
;	  a connection is cleared

;2 types of passive opens are supported:

;  Type 1: The TCP device is opened specifying * as the network address (for
;          example, TCP0:*::. The open does not complete until there is an
;          incomming connection on the port.  Multiple opens can be active
;          at the same time to allow over lapped processing of multiple
;          connections.  This has the disadvantage that each active open
;          ties up a DCB and an extended fork frame.

;  Type 2: The TCP device is opened specifying a non-zero value for the
;          IOPAR_NETCONLIMIT IO parameter.  This specifies the maximum
;          number of incomming connections which will queued on the port.
;          this open completes immediately.  Another open is done specify
;          the handle returned by the first open as the value of the
;          IOPAR_NETCONHNDL IO parameter.  This open does not complete
;          until there is an incoming connection.  Up to the number of
;          incoming connections specified in the first open will be queued
;          by the TCP driver allowing overlapped processing of incoming
;          connections. Two DCBs and one extended fork frame are tied up when
;          doing this.  This provides a resonable compromise in resource usage
;          between methods 1 and 2 and is easier to use and is much more
;          compatable with the Berkley Sockets method of accepting connections.

;Type 1 opens are deprecated when used to accept multiple connections.  They
;  are still considered current for cases where a program wishes to accept
;  exactly 1 incoming connection.  All new code should use type 2 opens except
;  when accepting exactly 1 incoming connection.

	.EXPORT	xostcpAcceptSyn
	.EXPORT	xostcpAuTcpDev
	.EXPORT	xostcpClear
	.EXPORT	xostcpConnect
	.EXPORT	xostcpFncDisp
	.EXPORT	xostcpGetTcpDev
	.EXPORT	xostcpGiveDcb
	.EXPORT	xostcpMsgTcpDev
	.EXPORT	xostcpPutSynWait
	.EXPORT	xostcpRmvSynWait
	.EXPORT	xostcpSendSynAck
	.EXPORT	xostcpTpdbHead

	CODE

	.SBTTL	SVC dispatch table for TCP devices

;SVC dispatch table for TCP devices

tcpdsp::.LONG	knlRtnZero##	;sd_mount	=  0. - Mount
	.LONG	knlRtnZero##	;sd_cleardev	=  4. - Clear device
	.LONG	xostcpGiveDcb	;sd_cleardcb	=  8. - Clear DCB
	.LONG	knlRtnZero##	;sd_commit	= 12. - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold    = 16. - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew    = 20. - Transfer device/new
	.LONG	tcpopena	;sd_opena	= 24. - Open additional
	.LONG	tcpopen1	;sd_open1	= 28. - Open device/file
	.LONG	tcpdevparm	;sd_devparm     = 32. - Device parameters
	.LONG	knlIFnDev##	;sd_delete	= 36. - Delete file
	.LONG	knlIFnDev##	;sd_rename	= 40. - Rename file
	.LONG	tcpinpblk	;sd_inblock	= 44. - Input block
	.LONG	tcpoutblk	;sd_outblock	= 48. - Output block
	.LONG	tcpoutblk1	;sd_outblockq	= 52. - Output block (XFF)
	.LONG	tcpoutstr	;sd_outstring	= 56. - Output string
	.LONG	knlRtnMOne##	;sd_getiosts	= 60. - Get input/output status
	.LONG	knlIFnDevGQ##	;sd_special     = 64. - Special device function
	.LONG	tcpclose	;sd_close	= 68. - Close file
	.LONG	knlNullLabel##	;sd_label       = 72. - Get device label
	.LONG	knlNullQioGQ##	;sd_commitfunc	= 76. - Commit data to disk
	.LONG	tcpdevinfo	;sd_devinfo     = 80. - Get device info
TCPDSPSZ=!{$-tcpdsp}/4

;Class function dispatch table for TCP class devices

	.LONG	TCPCLSFMX
tcpcls::.LONG	tcpaddunit	;CF_ADDUNIT =  8. - Add unit
	.LONG	tcpunitinfo	;CF_PUNITS  =  9. - Get information about
				;		      physical units
	.LONG	knlIFnDevGQ##	;CF_AUNITS  = 10. - Get information about active
				;		      units
TCPCLSFMX=!{$-tcpcls}/4
.PAGE
;TCP internal function dispatch table for TCP protocol level devices (TCPn)

xostcpFncDisp:
	.LONG	xosnetRspDone##	;tcpf_synsent = 0.
	.LONG	xosnetRspDone##	;tcpf_synrcvd = 4.
	.LONG	xosnetRspDone##	;tcpf_ackrcvd = 8.
	.LONG	tcpestab#	;tcpf_estab   = 12.
	.LONG	tcprcvfin#	;tcpf_rcvfin  = 16.
	.LONG	xosnetSndDone##	;tcpf_needout = 20.
.PAGE
;Device characteristics tables for the TCP devices

	DATA

	.MOD	4
tcpdctbl::
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS   , TEXT, ,  8, knlDcMsgClass##  , knlDcGetClass##    , knlDcSetClass##    , 0
 DCHARENT  IPSDEV  , TEXT, , 16, xosipsMsgIpsDev##, xosipsGetIpsDev##  , 0                  , 0
 DCHARENT  IPPROT  , DECV, ,  1, xosipsMsgIpProt##, xosipsGetTpdbByte##, xosipsSetIpProt##  , tpdb_ipprot
 DCHARENT  RETRY1  , DECV, ,  1, xosipsMsgRetry1##, xosipsGetTpdbByte##, xosipsSetTpdbByte##, tpdb_tcpretry1
 DCHARENT  RETRY2  , DECV, ,  1, xosipsMsgRetry2##, xosipsGetTpdbByte##, xosipsSetTpdbByte##, tpdb_tcpretry2
 DCHARENT  ACCESS  , TEXT, ,  4, knlDcMsgAccess## , xosipsGetTpdbData##, setaccess          , tpdb_tcpaccess
 DCHARENT  ACCESSFT, TEXT, ,  4, msgaccessft      , xosipsGetTpdbData##, setaccess          , tpdb_tcpaccessft
 DCHARENT  PKTIN   , DECV, ,  4, xosnetMsgPktIn## , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntpktin
 DCHARENT  BYTEIN  , DECV, ,  4, knlDcMsgByteIn## , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntbytein
 DCHARENT  PKTOUT  , DECV, ,  4, xosnetMsgPktOut##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntpktout
 DCHARENT  BYTEOUT , DECV, ,  4, knlDcMsgByteOut##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntbyteout
 DCHARENT  CHKSUM  , DECV, ,  4, xosipsMsgChkSum##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntchksum
 DCHARENT  NODST   , DECV, ,  4, xosipsMsgNoDst## , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntnodst
 DCHARENT  BADHDR  , DECV, ,  4, xosipsMsgBadHdr##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntbadhdr
 DCHARENT  PSLTMN  , DECV, ,  4, xosipsMsgPSLtMn##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntpsltmn
 DCHARENT  PSLTHL  , DECV, ,  4, xosipsMsgPSLtHL##, xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntpslthl
 DCHARENT  NOACK   , DECV, ,  4, msgnoack         , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntnoack
 DCHARENT  OUTSEQ  , DECV, ,  4, msgoutseq        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntoutseq
 DCHARENT  OUTWIN  , DECV, ,  4, msgoutwin        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntoutwin
 DCHARENT  FLOWOVR , DECV, ,  4, msgflowovr       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntflowovr
 DCHARENT  UNXFIN  , DECV, ,  4, msgunxfin        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntunxfin
 DCHARENT  MERGED  , DECV, ,  4, msgmerged        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntmerge
 DCHARENT  OOSNUM  , DECV, ,  4, msgoosnum        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntoosnum
 DCHARENT  OOSMAX  , DECV, ,  4, msgoosmax        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntoosmax
 DCHARENT  OOSMRGD , DECV, ,  4, msgoosmrgd       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntoosmrgd
 DCHARENT  REXMIT  , DECV, ,  4, msgrexmit        , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntrexmit
 DCHARENT  RSTSENT , DECV, ,  4, msgrstsent       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntrstsent
 DCHARENT  RSTRCVD , DECV, ,  4, msgrstrcvd       , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntrstrcvd
 DCHARENT  CLOST   , DECV, ,  4, msgclost         , xosipsGetTpdbData##, xosipsSetTpdbData##, tpdb_tcpcntclost

	CODE

msgaccessft:    DCHARINFO  {Access class for file transfers}
msgconmsgdst:   DCHARINFO  {Message dest for connect to port}
msgnoack:       DCHARINFO  {Discarded - ACK not indicated}
msgoutseq:      DCHARINFO  {Discarded - out of sequence packets}
msgoutwin:      DCHARINFO  {Discarded - out of window packets}
msgflowovr:     DCHARINFO  {Discarded - flow control overrun}
msgunxfin:      DCHARINFO  {Number of unexpected FIN packets}
msgmerged:      DCHARINFO  {Number of merged input packets}
msgoosnum:      DCHARINFO  {Number of out-of-seq packets queued}
msgoosmax:      DCHARINFO  {Maximum out-of-seq packets queued}
msgoosmrgd:     DCHARINFO  {Number of out-of-seq packets merged}
msgrexmit:      DCHARINFO  {Number of retransmitted packets}
msgclost:       DCHARINFO  {Number of lost connections}
msgrstsent:     DCHARINFO  {Number of resets sent}
msgrstrcvd:     DCHARINFO  {Number of resets received}
xostcpMsgTcpDev:DCHARINFO  {TCP device}
.PAGE
;Device parameter table for TCP open

	.MOD	4
	.LONG	OPARMMAX
tcpopnparms:
	.LONG	tcpopngenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	tcpopnnetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
OPARMMAX=!{$-tcpopnparms}/4

	.LONG	OPARMGENMAX	;Size of table
tcpopngenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopDummyS##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
OPARMGENMAX=!{$-tcpopngenparms}/4

	.LONG	OPARMNETMAX
tcpopnnetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	0		;IOPAR_NETPROTOCOL = 0502h
	.LONG	tcpioplclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	tcpioprmtnetas	;IOPAR_NETRMTNETAS = 0506h
	.LONG	tcpioprmtnetar	;IOPAR_NETRMTNETAR = 0507h
	.LONG	tcpioprmtports	;IOPAR_NETRMTPORTS = 0508h
	.LONG	tcpioprmtportr	;IOPAR_NETRMTPORTR = 0509h
	.LONG	0		;IOPAR_NETDSTNAME  = 050Ah
	.LONG	0		;IOPAR_NETSMODE    = 050Bh
	.LONG	0		;IOPAR_NETCMODE    = 050Ch
	.LONG	0		;IOPAR_NETRCVWIN   = 050Dh
	.LONG	tcpioplclneta	;IOPAR_NETLCLNETA  = 050Eh
	.LONG	0		;IOPAR_NETKATIME   = 050Fh
	.LONG	knlIopDummyN##	;IOPAR_NETCONLIMIT = 0510h
	.LONG	knlIopDummyN##	;IOPAR_NETCONHNDL  = 0511h
OPARMNETMAX=!{$-tcpopnnetparms}/4
.PAGE
	.LONG	PARMMAX
tcpioparms:
	.LONG	tcpiogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	0		 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	0		 ;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	tcpionetparms	 ;IOPAR_NETxxx = 05xx - Network IO parameters
PARMMAX=!{$-tcpioparms}/4

	.LONG	PARMGENMAX	;Size of table
tcpiogenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIoxFilOptn##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIoxFilSpec##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
PARMGENMAX=!{$-tcpiogenparms}/4

	.LONG	PARMNETMAX
tcpionetparms:
	.LONG	0		;		   = 0500h
	.LONG	0		;IOPAR_NETSUBUMASK = 0501h
	.LONG	0		;IOPAR_NETPROTOCOL = 0502h
	.LONG	tcpxplclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	0		;IOPAR_NETRMTNETAS = 0506h
	.LONG	tcpioprmtnetar	;IOPAR_NETRMTNETAR = 0507h
	.LONG	0		;IOPAR_NETRMTPORTS = 0508h
	.LONG	tcpioprmtportr	;IOPAR_NETRMTPORTR = 0509h
	.LONG	0		;IOPAR_NETDSTNAME  = 050Ah
	.LONG	0		;IOPAR_NETSMODE    = 050Bh
	.LONG	0		;IOPAR_NETCMODE    = 050Ch
	.LONG	0		;IOPAR_NETRCVWIN   = 050Dh
	.LONG	tcpioplclneta	;IOPAR_NETLCLNETA  = 050Eh
	.LONG	0		;IOPAR_NETKATIME   = 050Fh
PARMNETMAX=!{$-tcpionetparms}/4
.PAGE
	.SBTTL	tcpinit - Initialization routine

	INITSUB	tcpinit

;The command for installing TCPCLS is:
;	LKELOAD TCPCLS

tcpinit:MOVL	EDI, #tcpchk		;Install the TCP class
	MOVL	EBX, #tcpcls		;Offset of class function dispatch table
	MOVL	EAX, #'TCP'
	CLRL	EDX
	MOVL	ESI, #tcpccb
	CALL	knlNewClass##
	JC	4$.S			;If error
	MOVL	ECX, #xcodetop#		;OK
	CLRL	EDX
	CLRL	EAX
4$:	MOVL	EBX, #QSTS$DONE
	RET

	CODE
.PAGE
	.SBTTL	tcpaddunit - Subroutine to add TCP unit

;Subroutine to add TCP unit - this implements a TCP protocol device for a
;  single IPS device.  Multiple TCP units with different IP protocol may be
;  set up for each IPS device if desired.
;	c{ES:EDI} = Address of data block
;	CALL	tcpaddunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count

$$$=!0
FRM tcpau_snapnum , 4t		;Number of SNAP devices specified
FRM tcpau_unit    , 4t		;Unit number
FRM tcpau_netnum  , 4t
FRM tcpau_count   , 4t
FRM tcpau_pdb     , 4t		;Offset of PDB
tcpau_SIZE=!$$$

	DATA

	.MOD	4
tcpaublk:				;Parameter description block for
 DCHARBGN  3, knlDCharValCom##		;  adduparms
 DCHARENT  UNIT  , DECV, ,  1, 0, 0, tcpauunit  , 0
 DCHARENT  IPSDEV, TEXT, , 16, 0, 0, tcpauipsdev, 0

	CODE

	IFFAULT	8$
tcpaddunit:
	LFSL	EDX, iorb_buffer2.B[ESI]
	CALL	knlGiveQel##		;Give up the IORB
	ENTER	tcpau_SIZE, 0		;Allocate our stack frame
	CLRL	EAX
	LEAL	EDI, -tcpau_SIZE[EBP]	;Clear our stack frame
	MOVL	ECX, #tcpau_SIZE/4
	PUSHL	SS
	POPL	ES
	CLD
	RSTOSL	[EDI]
	DECL	tcpau_unit.B[EBP]	;Indicate illegal unit number
	MOVL	EBX, #tcpaublk
	MOVB	AL, #0			;Fail on bad names
	CALL	knlAddUnitChar##	;Process the characteristics
	JC	4$.S			;If error
	CMPL	tcpau_pdb.B[EBP], #0.B	;Was a IPS device specified?
	JE	2$.S			;No
	CMPL	tcpau_unit.B[EBP], #0.B	;Yes - was a unit number specified?
	JGE	10$.S			;Yes
2$:	MOVL	EAX, #ER_CHARM		;No - fail
4$:	CLRL	ECX
6$:	MOVL	EBX, #QSTS$DONE
	LEAVE
	TOFORK
	RET
		
;Here if address error with the IORB

	FAULTHDR
8$:	CALL	knlGiveQel##
	MOVL	EAX, #ER_ADRER
	JMP	4$.S

;Here with characteristics processed

10$:	PUSHL	tcpau_unit.B[EBP]
	PUSHL	#tpdb_tcpSIZE
	PUSHL	#'TCP'
	PUSHL	#dcb_tcpINDEX.B
	PUSHL	#256t*4
	PUSHL	#tpdb_tcprcvhash.B
	PUSHL	#tcprcv#
	PUSHL	#tcpccb
	PUSHL	tcpau_pdb.B[EBP]
	PUSHL	#xostcpTpdbHead
	CALL	xosipsNewTransProt##	;Set up the new transport protocol
	JC	4$.S			;If error
	MOVB	CL, tpdb_unit.B[EDI]	;Get unit number
12$:	MOVB	tpdb_tcpretry1.B[EDI], #RETRY_TRN1 ;Initialize default retry
	MOVB	tpdb_tcpretry2.B[EDI], #RETRY_TRN2 ;  levels
	MOVL	tpdb_tcpnextport.B[EDI], #0A000h ;Initialize default port
	MOVL	EDI, dpdb_nextd.B[EDI]
	TESTL	EDI, EDI
	JE	14$.S
	CMPB	CL, tpdb_unit.B[EDI]
	JE	12$.S
14$:	CLRL	EAX
	MOVL	ECX, #1			;OK
	JMP	6$.S
.PAGE
;Subroutine called by adduparms for the "UNIT" parameter

tcpauunit:
	CMPL	EAX, #99t.B		;Valid value?
	JA	knlBadCharV##		;No - fail
	MOVL	tcpau_unit.B[EBP], EAX	;Yes - store it
	CLC
	RET

;Subroutine called by adduparms for the "IPSDEV" parameter

tcpauipsdev:
	MOVL	EAX, tcpau_pdb.B[EBP]	;Get current IPS PDB offset
	CALL	xosipsAuIpsDev##	;Get IPS PDB offset
	JC	2$.S			;If error
	MOVL	tcpau_pdb.B[EBP], EDI	;OK - store IPS PDB offset
2$:	RET
.PAGE
	.SBTTL	xostcpAuUdpDev - Subroutine to process TCPDEV addunit characteristic

;Subroutine to process TCPDEV addunit characteristic for devices which use TCP
;  as their underlying protocol
;	c{EAX} = Current TCP TPDB offset
;	CALL	xosudpAuTcpDev
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset of UDP TPDB

xostcpAuTcpDev:
	ORL	EAX, EAX		;Alreay have a TCP TPDB?
	JNE	2$.S			;Yes - fail
	MOVL	EBX, #knlDcValue##	;No
	PUSHL	12t.B[EBX]
	PUSHL	8.B[EBX]
	PUSHL	4.B[EBX]
	MOVL	EAX, [EBX]
	PUSHL	EAX
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'TCP'
	JNE	4$.S
	LEAL	ECX, 3.B[ESP]
	MOVL	EDI, xostcpTpdbHead	;Get offset of first TPDB
	CALL	xosnetSrchBlock##	;Find the correct TPDB
	JNE	4$.S			;If can't find it
	CMPB	SS:[ECX], #0		;Did he specify a specific network?
	JNE	4$.S			;Yes - fail
	ADDL	ESP, #16t.B
	RET

;Here if more than one TCP device specified

2$:	MOVL	EAX, #ER_TMDDV
	STC
	RET

;Here if cannot find requested TCP device

4$:	ADDL	ESP, #16t.B
	JMP	knlBadCharV##
.PAGE
	.SBTTL	xostcpGetTcpDev - Here to get value of TCPDEV characteristic

;Here to the the value of the TCPDEV characteristic for an application protocol
;  level device

xostcpGetTcpDev:
	MOVL	EDX, dcb_ipstpdb.B[EDI]	;Get offset of TPDB
	LEAL	EAX, tpdb_name.B[EDX]	;Get offset of device name
	RET
.PAGE
	.SBTTL	setaccess - Set value of the ACCESS and ACCESSFT characteristics

;Here ot set the value of the ACCESS and ACCESSFT characteristics

setaccess:
	ADDL	EBX, dcb_ipstpdb.B[EDI]
	JMP	knlSetAccess##

	.SBTTL	tcpunitinfo - TCP get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  TCP class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	tcpunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

tcpunitinfo:
	CALL	knlGiveQel##
	MOVL	EAX, #ER_NIYT
	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	TOFORK
	RET
.PAGE
;Device check routine for TCP class devices
;	c{SS:EBX} = Address of device name (16 characters)
;	CALL	tcpchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  EBX and ESI are preserved

tcpchk:	MOVL	EAX, SS:[EBX]
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'TCP'		;Is this TCP*?
	JNE	8$			;No
	MOVL	EDI, xostcpTpdbHead	;Yes - get offset first TCP TPDB
	LEAL	ECX, 3.B[EBX]		;Get offset of 1st unit number character
	MOVL	EDX, #DS$DUPLEX		;Get description bits
	CALL	xosipsFindDev##		;Find matching network device
	JC	6$			;If error
	JNE	6$			;Or if not a match
	MOVL	ECX, #6			;Get a 4K output ring buffer (for now)
	CALL	knlGetXmb##
	JC	12$			;If error
	MOVL	dcb_tcpoutbufr[EDI], ESI
	MOVL	dcb_tcpoutsize[EDI], #1000h-4
	MOVL	dcb_tcpoutpush[EDI], #-1
	CMPL	dcb_sdisp.B[EDI], #0.B	;Is this DCB already set up?
	JNE	4$.S			;Yes
	MOVL	dcb_sdisp.B[EDI], #tcpdsp ;Store offset of SVC dispatch table
	MOVL	dcb_tcpfuncdisp.B[EDI], #xostcpFncDisp ;Store offset of function
	MOVL	EDX, dcb_ipstpdb.B[EDI]		       ;  dispatch table
	MOVW	AX, tpdb_tcpretry1.B[EDX] ;Store default retransmission
	MOVW	dcb_tcpretry1.B[EDI], AX  ;  threshold values
	MOVB	dcb_ipsprot.B[EDI], #IPP_TCP ;Store protocol value
	MOVL	dcb_netmode.B[EDI], #NMTCP$PUSH|NMTCP$CONSEND ;Set default modes
	MOVL	dcb_devchar.B[EDI], #tcpdctbl ;Use our device characteristics
	MOVL	dcb_tcpmaxseg[EDI], #1460t
	MOVL	dcb_tcpoutpkt+npb_nextsnd[EDI], #-1
	MOVL	dcb_tcpoutpkt+npb_dcb[EDI], EDI
	MOVL	ECX, tpdb_tcpnextport.B[EDX] ;Assign default port number
	BTSL	ECX, #31t
	INCL	tpdb_tcpnextport.B[EDX]
	CMPL	tpdb_tcpnextport.B[EDX], #0FF00h
	JB	2$.S
	MOVL	tpdb_tcpnextport.B[EDX], #0A000h
2$:	CALL	xosipsGetPort##
	JC	10$.S
4$:	CLRL	EAX			;Set Z
6$:	RET				;And return

;Here if not a TCP device - clear C and leave Z clear

8$:	CLC
	RET

;Here if can't assign a default port

10$:	MOVL	ESI, dcb_tcpoutbufr[EDI]
	MOVL	ECX, #6
	CALL	knlGiveXmb##

;Here if can't allocate an exec buffer for the output ring buffer

12$:	PUSHL	EAX
	CALL	xostcpGiveDcb		;Give up the DCB
	POPL	EAX
	STC
	RET
.PAGE
	.SBTTL	sd_cleardcb - Clear DCB

;Here for the clear DCB entry

xostcpGiveDcb:
	CMPL	dcb_tcpackwake[EDI], #0.B
	JE	6$.S
	PUSHL	ESI
	MOVL	ESI, dcb_tcpackwake[EDI]
	MOVL	dcb_tcpackwake[EDI], #0
	CALL	knlWakeRemove##
	POPL	ESI
6$:	CMPW	dcb_tcpconlimit[EDI], #0.B ;Is this a base DCB?
	JE	20$.S			;No
	PUSHL	EDI			;Yes
10$:	CMPL	dcb_tcpconpend[EDI], #0.B ;Give up all pending DCBs
	JE	12$.S
	MOVL	EDI, dcb_tcpconpend[EDI]
	CALL	xostcpGiveDcb
	MOVL	EDI, [ESP]
	JMP	10$.S

12$:	CMPL	dcb_tcpconwait[EDI], #0.B ;Give up all waiting DCBs
	JE	14$.S
	MOVL	EDI, dcb_tcpconwait[EDI]
	CALL	xostcpGiveDcb
	MOVL	EDI, [ESP]
	JMP	12$.S

14$:	CMPL	dcb_tcpconbase[EDI], #0.B ;Is there a DCB waiting for
					  ;  connections?
	JE	16$.S			;No
	MOVL	EDX, dcb_tcpconbase[EDI] ;Yes - unlink it from this DCB
	CLRL	EAX
	MOVL	dcb_tcpconbase[EDI], EAX
	MOVL	dcb_tcpconbase[EDX], EAX
	MOVL	EDI, EDX
	MOVL	EAX, #ER_ABORT		;Terminate it
	MOVL	EDX, dcb_tcpfuncdisp.B[EDI]
	CALL	xosnetSndDone##
16$:	POPL	EDI
	JMP	38$

;Here if this is not a base DCB

20$:	CMPL	dcb_tcpconbase[EDI], #0.B ;Is this DCB involved in a type 2
					  ;  open?
	JE	38$.S			;No - go on
	MOVL	EAX, dcb_tcpconbase[EDI] ;Yes - is this the real DCB which is
	CMPL	EDI, dcb_tcpconbase[EAX]
	JNE	22$.S			;No
	MOVL	dcb_tcpconbase[EAX], #0	;Yes
	JMP	36$.S

;Here if this is a temporary type 2 connection DCB

22$:	ADDL	EAX, #dcb_tcpconpend	;First look for it in the pending list
24$:	CMPL	[EAX], #0.B
	JE	26$.S
	CMPL	[EAX], EDI
	JE	34$.S
	MOVL	EAX, [EAX]
	ADDL	EAX, #dcb_tcpconnext
	JMP	24$.S

26$:	MOVL	EAX, dcb_tcpconbase[EDI] ;Then look for it in the waiting list
	ADDL	EAX, #dcb_tcpconwait
28$:	CMPL	[EAX], #0.B
	JE	30$.S
	CMPL	[EAX], EDI
	JE	34$.S
	MOVL	EAX, [EAX]
	ADDL	EAX, #dcb_tcpconnext
	JMP	28$.S

30$:	CRASH	BCNL			;[Bad CoNnection List]

34$:	MOVL	EDX, dcb_tcpconnext[EDI]
	MOVL	[EAX], EDX
36$:	MOVL	dcb_tcpconbase[EDI], #0

;Here with the type 2 open stuff cleaned up if necessary

38$:	CMPB	dcb_tcpstate.B[EDI], #TCPS_LISTEN
	JNE	40$.S
	CMPL	dcb_ipshashnext[EDI], #-1.B
	JE	40$.S
	CALL	xostcpRmvSynWait
40$:
;;;;;	CMPB	dcb_tcpstate.B[EDI], #TCPS_CLOSED ;Is it idle now?
;;;;;	JNE	46$.S			;No
tcpgdcb::
	MOVB	dcb_tcpstate.B[EDI], #0 ;Yes
	MOVL	ESI, dcb_tcpoutbufr[EDI] ;Do we have an output buffer?
	TESTL	ESI, ESI
	JE	42$.S			;No
	MOVL	ECX, #6			;Yes - give it up
	CALL	knlGiveXmb##
42$:	CALL	xostcpHashClr#		;Remove DCB from the hash table
	CALL	xostcpGiveAll#		;Make sure no buffers allocated
	CMPW	dcb_ipslclport.B[EDI], #0.B ;Have a local port number?
	JE	44$.S			;No
	CALL	xosipsGivePort##	;Yes - give it up
44$:	JMP	xosipsGiveDcb##		;Give up the DCB

;Here if DCB is not idle

46$:	MOVL	EAX, tcptwdcb		;Link to the timed wait list
	MOVL	dcb_tcptwnext[EDI], EAX
	MOVL	tcptwdcb, EDI
	MOVB	dcb_tcptwcnt[EDI], #TIMECNT_TW
	RET				;Thats all for now (will get to tcpgdcb
					;  when this timer goes off)
.PAGE
	.SBTTL	sd_devinfo - Get device information

;Here for the get device information entry
;	c{ECX}    = Length of user buffer
;	c{ES:EDI} = Address of user buffer
;	c{ESI}    = Offset of DCB
;	CALL	tcpdevinfo

$$$=!0				;Must match definitions in IPSCLS!
FRM info_left  , 4t
FRM info_amount, 4t
info_SIZE=!$$$

tcpdevinfo:
	ENTER	info_SIZE, 0
	MOVL	info_left.B[EBP], ECX
	CLRL	EAX
	MOVL	info_amount.B[EBP], EAX
	MOVZBL	EDX, dcb_tcpstate.B[ESI] ;Get TCP state
	CMPB	DL, #TCPS_LISTEN	;Is it TCPS_LISTEN?
	JNE	4$.S			;No
	CMPW	dcb_tcpconlimit[ESI], #0.B ;Yes - have a connection queue?
	JE	4$.S			;No
	MOVB	DL, #12t		;Yes - fix up the state name
4$:	LEAL	EBX, CS:infoname[EDX*4]	;Get offset of name string
	MOVL	ECX, #4			;Its 4 characters long
	CALL	knlInfoStr##		;Store the name
	MOVB	AL, #' '
	CALL	knlInfoChr##
	JMP	xosipsDevInfoLcl##

	DATA
	.MOD	4
infoname:
	.ASCII	"CLSD"		;TCPS_CLOSED    = 0  - Idle
	.ASCII	"LSTN"		;TCPS_LISTEN    = 1  - Waiting for SYN
	.ASCII	"SYNS"		;TCPS_SYNSENT   = 2  - SYN sent
	.ASCII	"SYNA"		;TCPS_SYNACKD   = 3  - ACK sent for SYN|ACK
	.ASCII	"SYNR"		;TCPS_SYNRCVD   = 4  - SYN received
	.ASCII	"ESTB"		;TCPS_ESTAB     = 5  - Connection established
	.ASCII	"FIN1"		;TCPS_FINWAIT1  = 6  - FIN sent, waiting for FIN
				;			 in reply and for ACK
	.ASCII	"FIN2"		;TCPS_FINWAIT2  = 7  - ACK for FIN received,
				;			 still waiting for FIN
	.ASCII	"CLSG"		;TCPS_CLOSING   = 8  - Reply FIN received
				;			 without ACK, waiting
				;			 for ACK for the FIN
	.ASCII	"CLSW"		;TCPS_CLOSEWAIT = 9  - FIN received, waiting
				;			 for process to close
				;			 TCP device
	.ASCII	"LACK"		;TCPS_LASTACK   = 10 - Reply FIN sent, waiting
				;			 for final ACK
	.ASCII	"TMWT"		;TCPS_TIMEWAIT  = 11 - All finished - timing out
				;			 port
	.ASCII	"LSTQ"
	CODE
.PAGE
	.SBTTL	sd_opena - Open device additional times

;Here for the open device additional times entry
;	c{EDX} = Offset of name buffer
;	c{EDI} = Offset of DCB
;	CALL	tcpopena
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

OX=!O$REPEAT|O$REQFILE|O$ODF|O$FAILEX|O$CREATE|O$TRUNCA|O$TRUNCW|O$APPEND
OX=!OX|O$UNQNAME|O$CONTIG|O$FAPPEND

tcpopena:
	TESTL	SS:xffCmd##, #OX	;Check for illegal bits
	JNE	knlIFnDev##
	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Physical or raw IO?
	JNE	tcpdevparm		;Yes
	TESTB	SS:xffCmd##, #O$IN|O$OUT ;No - no IO?
	JE	tcpdevparm		;Yes
	CMPB	dcb_tcpstate.B[EDI], #TCPS_CLOSED ;Is device idle?
	JE	2$.S			;Yes - go on
	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;No - normal connection?
	JE	opendn			;Yes
	MOVL	EAX, #ER_BUSY		;No - say device is busy
	STC
	RET

	.SBTTL	sd_open1 - Open device first time

;Here for the open device first time entry
;	c{EDX} = Offset of name buffer
;	c{EDI} = Offset of DCB
;	CALL	tcpopen1
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

tcpopen1:
	TESTL	SS:xffCmd##, #OX	;Check for illegal bits
	JNE	knlIFnDev##
	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Physical or raw IO?
	JNE	tcpdevparm		;Yes
	CMPW	opn_conlimit.B[EBP], #0.B ;No - was an incoming connection queue
					  ;  specified?
	JNE	2$.S			;Yes
	TESTB	SS:xffCmd##, #O$IN|O$OUT ;No - no IO?
	JE	tcpdevparm		;Yes
2$:	MOVB	SS:xffQueue##, #dcb_outframe ;No - set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	CMPB	dcb_tcpstate.B[EDI], #TCPS_SYNRCVD ;Is this an incoming
						   ;  connection?
	JE	tcpopenin		;Yes - go handle that
	CMPW	opn_conhndl.B[EBP], #0.B ;No - was an incomming device handle
					 ;  specified?
	JNE	tcpopentype2		;Yes - go handle that
	MOVL	ESI, dcb_netidb.B[EDI]	;No - get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%LCLPORT ;Local port number specified?
	JNC	4$.S			;No
	MOVL	ECX, opn_lclport[EBP]	;Yes - use it
	PUSHL	EDX
	CALL	xosipsGetPort##
	POPL	EDX
	JC	20$			;If error setting the local port number
4$:	CMPW	opn_conlimit.B[EBP], #0.B ;Was an incoming connection queue
					  ;  limit specified?
	JE	10$.S			;No - go on
	MOVZWL	EAX, opn_conlimit.B[EBP] ;Yes - save the value
	MOVW	dcb_tcpconlimit[EDI], AX
	CALL	xostcpPutSynWait	;Put this DCB in the SYN wait list (also
	JMP	opendn.S		;  sets state to TCPS_LISTEN)

;Here if no connection limit was specified

10$:	BTL	SS:xffHvValue1##, #IOV1%RMTPORTS ;Remote port number specified?
	JNC	12$.S			;No
	MOVL	EAX, opn_rmtports[EBP]	;Yes - use it
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport.B[EDI], AX
12$:	BTL	SS:xffHvValue1##, #IOV1%RMTNETAS ;IP address specified?
	JNC	16$.S			;No
	CMPL	opn_rmtnetas[EBP], #-1.B ;Yes - passive address?
	JNE	18$.S			;No
	JMP	tcpopenpas

;Here if no IP address specified

16$:	CMPL	SS:[EDX], #'*::'	;Is this a pasive open?
	JE	tcpopenpas		;Yes - go handle that
18$:	MOVL	EAX, #2600t		;No
	MOVB	CL, #5
	CALL	xostcpConnect		;Establish the TCP connection
20$:	JC	30$.S
opendn:	CMPL	SS:xffParm##, #0.B	;Have a parameter list?
	JE	28$.S			;No
	MOVL	EBX, #tcpopnparms	;Yes - process device parameters
	MOVL	ECX, #knlComDPParms##	;  (IGNORE ERRORS FOR NOW!)
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	TESTL	SS:xffPVFilOpt##, #FO$NODENAME|FO$NODENUM ;Want node number?
	JE	28$.S			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX ;Yes - want prefix code?
	JC	22$.S			;No
	MOVB	AL, #FS_NODENUM		;Yes
	CALL	knlGivUChr##
22$:	LEAL	EBX, dcb_ipsrmtaddr.B[EDI] ;Point to the node number
	MOVL	ECX, #4t		;Give him 4 bytes
24$:	MOVZBL	EAX, [EBX]		;Get byte
	CALL	knlGivUNum##		;Give him the value?
	DECL	ECX			;Finished?
	JE	26$.S			;Yes
	INCL	EBX			;No - bump pointer
	MOVB	AL, #'.'		;Give him a period
	CALL	knlGivUChr##
	JMP	24$.S			;Continue

;Here with node number given to the user

26$:	CALL	knlGivUColon##		;Put :: after the node number
	CALL	knlGivUColon##
28$:	CLRL	EAX
30$:	RET

;Here for the devparm function or if physical or raw IO requested

tcpdevparm:
	ANDB	SS:xffCmd##, #~{O$IN|O$OUT} ;No IO allowed
	JMP	opendn			;Thats all
.PAGE
;Here for type 2 passive open - We first find the indicated DCB.  If there
;  is a pending SYN sequence queued, we use it.  If not, we wait until there
;  is one. Note that only one DCB can be waiting for a connection using a
;  base DCB.

tcpopentype2:
	MOVZWL	EAX, opn_conhndl.B[EBP]
	PUSHL	EDI
	CALL	knlXfGetDcb##
	MOVL	EDX, EDI
	POPL	EDI
	JC	4$.S
	CMPL	dcb_ccb.B[EDX], #tcpccb	;Is this a TCP DCB?
	JNE	4$.S			;No
	MOVB	AL, dcb_punit.B[EDI]	;Yes - is it the same unit?
	CMPB	AL, dcb_punit.B[EDX]
	JNE	4$.S			;No
	CMPB	dcb_tcpstate.B[EDX], #TCPS_LISTEN
	JNE	4$.S
	CMPW	dcb_tcpconlimit[EDX], #0.B
	JE	4$.S
	CMPL	dcb_tcpconbase[EDX], #0.B
	JE	8$.S
4$:	MOVL	EAX, #ER_PARMV
	STC
6$:	RET

;Here with a valid device for type 2 incoming connections

8$:	MOVZWL	ECX, dcb_ipslclport.B[EDX]
	CMPW	CX, dcb_ipslclport.B[EDI]
	JE	10$.S
	BTSL	ECX, #30t
	PUSHL	EDX
	CALL	xosipsGetPort##
	POPL	EDX
	JC	6$.S
10$:	CMPL	dcb_tcpconwait[EDX], #0.B ;Is a connection available now?
	JNE	14$.S			;Yes
	MOVB	dcb_tcpstate.B[EDI], #TCPS_LISTEN ;Update the connection state
	MOVL	dcb_tcpconbase[EDX], EDI
	MOVL	dcb_tcpconbase[EDI], EDX
	MOVL	EAX, SS:xffTimeOut##
	CALL	xosnetSndWait##		;Wait for a while
	JNC	10$.S
	RET

;Here with an incoming connection to use

14$:	CLRL	EAX			;Unlink from the base DCB for this port
	MOVL	dcb_tcpconbase[EDX], EAX
	MOVL	dcb_tcpconbase[EDI], EAX
	MOVL	EBX, dcb_tcpconwait[EDX]
	MOVL	ECX, dcb_tcpconnext[EBX]
	MOVL	dcb_tcpconwait[EDX], ECX
	MOVL	dcb_tcpconnext[EBX], EAX
	MOVL	dcb_tcpconbase[EBX], EAX
	PUSHL	EDI
	MOVL	EDI, EBX
	MOVL	ESI, dcb_tcpackwake[EDI] ;Clear the ACK timer if its running
	TESTL	ESI, ESI
	JE	16$.S
	MOVL	dcb_tcpackwake[EDI], #0
	CALL	knlWakeRemove##
16$:	MOVL	EAX, dcb_tcpprmerr.B[EDI] ;Get error code
	TESTL	EAX, EAX
	JNS	18$.S			;Go on if no error
	PUSHL	EAX
	CALL	xostcpGiveDcb		;Give up the temporary DCB
	POPL	EAX			;Restore error code
	POPL	EDI			;Restore DCB offset
	STC
	RET

;Here if no error on the open

18$:	PUSHL	EDI
	LEAL	ESI, dcb_tcpcopybgn.B[EDI]
	MOVL	EBX, 4.B[ESP]
	MOVL	EAX, dcb_ipsrmtaddr.B[EDI]
	MOVL	dcb_ipsrmtaddr.B[EBX], EAX
	MOVW	AX, dcb_ipsrmtport.B[EDI]
	MOVW	dcb_ipsrmtport.B[EBX], AX
	LEAL	EDI, dcb_tcpcopybgn.B[EBX]
	MOVL	ECX, #{dcb_tcpcopyend-dcb_tcpcopybgn}/4
	CLD
	PUSHL	DS
	POPL	ES
	RMOVSL	[EDI], [ESI]
	MOVL	EDI, [ESP]
	ADDL	EDI, #dcb_tcpcopybgn.B
	MOVL	ECX, #{dcb_tcpcopyend-dcb_tcpcopybgn}/4
	CLRL	EAX
	RSTOSL	[EDI]
	POPL	EDI
	MOVZWL	EAX, dcb_ipslclport.B[EDI]
	PUSHL	EAX
	CALL	xostcpHashClr#		;Remove DCB from the hash table
	CALL	xosipsGivePort##	;Give up its local port
	CALL	xostcpGiveDcb		;Give up the DCB
	POPL	ECX
	BTSL	ECX, #30t
	POPL	EDI
	CALL	xosipsGetPort##
	CALL	tcpcalhash#
	CALL	xostcpHashSet#		;Put DCB into the hash table
	CALL	xostcpSendAck#		;Send an ACK if we need to
	JMP	opendn
.PAGE
;Here for type 1 passive open to wait for an in-coming connection

tcpopenpas:
	MOVL	dcb_tcprndave[EDI], #{TIMEOUT_TRNBGN/FDPERTICK}<3t
	MOVL	dcb_tcprndvar[EDI], #0
	MOVL	dcb_tcprxmtint[EDI], #TIMEOUT_TRNBGN/FDPERTICK+4
	CALL	xostcpPutSynWait	;Put this DCB in the SYN wait list
	MOVL	EAX, SS:xffTimeOut##	;Get time-out value
	CALL	xosnetRspWait##		;Wait for a SYN
	JC	8$			;If error
	CALL	xostcpRmvSynWait	;Remove DCB from the SYN wait list
tcpopenin:
	CALL	xostcpTimerRmv#		;Stop the connect timer
	CALL	xostcpAcceptSyn		;Accept the connection
	MOVB	SS:xffCount##, #4-1	;Retry this 4 times
2$:	CALL	xostcpSendSynAck
	JC	6$.S
	MOVL	EAX, dcb_tcprcvwinb.B[EDI]
	MOVL	dcb_tcprcvwina.B[EDI], EAX
	MOVL	dcb_tcprcvwinm.B[EDI], EAX
	MOVL	dcb_tcprndave[EDI], #{TIMEOUT_TRNBGN/FDPERTICK}<3t
	MOVL	dcb_tcprndvar[EDI], #0
	MOVL	dcb_tcprxmtint[EDI], #TIMEOUT_TRNBGN/FDPERTICK+4
	MOVL	EAX, #TIMEOUT_CON	;Get time-out value
	CALL	xosnetSndWait##		;Wait for the ACK
	JNC	opendn			;If OK
	CMPL	EAX, #ER_NORSP.B	;Did this time-out?
	JNE	opnerr.S		;No
	DECB	SS:xffCount##		;Yes - should we try again?
	JNS	2$.S			;Yes
	MOVB	AL, #ER_NCLST		;No - get right error code
opnerr:	PUSHL	EAX			;Save error code
	CALL	xostcpHashClr#		;Remove DCB from the hash table
	MOVB	dcb_tcpstate.B[EDI], #TCPS_CLOSED
4$:	POPL	EAX
	STC
6$:	RET

;Here with error while we are in the SYN wait list

8$:	PUSHL	EAX
	CALL	xostcpRmvSynWait
	JMP	4$.S
.PAGE
	.SBTTL	tcpioplclneta - Here for the IOPAR_NETLCLNETA parameter

	DPARMHDR GET, DECV
tcpioplclneta:
	MOVL	EAX, dcb_netpdb.B[EDI]
	MOVL	EAX, pdb_ipaddr.B[EAX]
	JMP	knlStrParm4##

	.SBTTL	tcpioplclport - Here for the IOPAR_NETLCLPORT parameter for open

;Here for the IOPAR_NETLCLPORT parameter - Set or get local port number for open

	DPARMHDR  BOTH, DECV
tcpioplclport:
	TESTB	AH, #PAR$GET		;Want value returned?
	JE	10$.S			;No
2$:	MOVZWL	EAX, dcb_ipslclport.B[EDI] ;Yes - return current value
	JMP	knlStrParm4##

	.SBTTL	tcpxplclport - Here for the IOPAR_LCLPORT parameter for transfer

;Here for the IOPAR_LCLPORT parameter - Get local port number for transfer

	DPARMHDR  GET, DECV
tcpxplclport:
	JMP	2$.S

	.SBTTL	tcpioprmtports - Here for the IOPAR_RMTPORS parameter for open

;Here for the IOPAR_RMTPORTS parameter - Get or set remote port for open

	DPARMHDR  BOTH, DECV
tcpioprmtports:
	TESTB	AH, #PAR$GET		;Want value returned?
	JE	10$.S			;No
4$:	MOVZWL	EAX, dcb_ipsrmtport.B[EDI] ;Yes - return current value
6$:	XCHGB	AL, AH			;Fix up the byte order
	JMP	knlStrParm4##

	.SBTTL	tcpioprmtportr - Here for the IOPAR_RMTPORTR parameter

;Here for the IOPAR_RMTPORTR parameter - Get remote port number

	DPARMHDR  GET, DECV
tcpioprmtportr:
	JMP	4$.S

	.SBTTL	tcpioprmtnetas - Here for the IOPAR_RMTNETAS parameter for open

;Here for the IOPAR_RMTNETAS parameter - Get remote network address for open

	DPARMHDR  BOTH, DECV
tcpioprmtnetas:
	TESTB	AH, #PAR$GET		;Want value returned?
	JE	10$.S			;No
8$:	MOVL	EAX, dcb_ipsrmtaddr.B[EDI] ;Yes - return current value
	JMP	knlStrParm4##

10$:	RET

	.SBTTL	tcpioprmtnetar - Here for the IOPAR_RMTNETAR parameter

;Here for the IOPAR_RMTNETAR parameter - Get remote network address

	DPARMHDR  GET, DECV
tcpioprmtnetar:
	JMP	8$.S
.PAGE
	.SBTTL	xostcpConnect - Subroutine to establish TCP connection for open

;Subroutine to establish TCP connection for open - must be called in extended
;  fork context
;	c{EAX} = Receive byte window size
;	c(CL)  = Send packet window size
;	c{EDX} = Offset of name buffer (on stack)
;	c{EDI} = Offset of DCB
;	CALL	xostcpConnect
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX} = Offset of next part of name

;A network address may be specified after the device name.  It must be
;  terminated with a double colon as follows:
;	TCP0:147.23.45.67.34::
;  The fifth byte is optional, if included, specifies the value to be used
;  for the low order byte of the local network address.

$$$=!0
FRM con_frame1 , 4
FRM con_frame2 , 4
FRM con_name   , 4	;Offset of name buffer
FRM con_retry  , 4	;Retry counter
FRM con_bfr    , 4	;Offset of packet buffer used to send SYNC
con_SIZE=!$$$

xostcpConnect:
	ENTER	con_SIZE, 2
	MOVL	dcb_tcprcvwinb.B[EDI], EAX ;Store our receive byte window size
	MOVL	dcb_tcprcvwinm.B[EDI], EAX
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%RMTNETAS ;Have an address parameter?
	JNC	2$.S			;No	
	MOVL	EBX, con_frame1.B[EBP]	;Yes - get its value
	MOVL	EBX, SS:opn_rmtnetas[EBX]
	JMP	gethva1			;Continue

;Here if address parameter (IOPAR_RMTNETAS) not specified

2$:	CALL	xosnetChkNetAddr##	;Was a network address given?
	JNE	getpds.S		;No - fail!

;Here if a network address was given

4$:	CMPB	SS:[EDX], #'A'		;Is the first character alpha?
	JB	getipa.S		;No - go collect Internet address
	CALL	xosipsDnsGetIpA##	;Yes - translate domain name
	JNC	gethva2.S		;Go on if OK
	LEAVE				;Error
	RET
.PAGE
getipa:	CLRL	EBX
	MOVL	ECX, #4			;Remote IP address may contain up to 4
2$:	CALL	getval			;  fields
	RORL	EBX, #8
	CMPB	AL, #':'		;End of remote IP address?
	JE	10$.S			;Yes
	CMPB	AL, #'.'		;No - is it the separator?
	JNE	getpds.S		;No - fail
	LOOP	ECX, 2$			;Yes - continue
getpds:	MOVL	EAX, #ER_NILAD
6$:	STC
	LEAVE
	RET

;Here with internet address
;	c{EBX} = IP address

10$:	INCL	EDX			;Skip the second colon
gethva1:CMPL	EBX, #0.B		;Is entire address 0?
	JE	getpds.S		;Yes - fail!
gethva2:MOVL	con_name.B[EBP], EDX	;Save offset of name buffer
	MOVL	EDX, dcb_netpdb.B[EDI]	;Get offset of the PDB
	TESTL	EBX, pdb_ipsubnetmask.B[EDX] ;Did he specify the network part?
	JNE	12$.S			;Yes
	MOVL	EAX, pdb_ipaddr.B[EDX]	;No - use our network address
	ANDL	EAX, pdb_ipsubnetmask.B[EDX]
	ORL	EBX, EAX
12$:	MOVL	dcb_ipsrmtaddr.B[EDI], EBX ;Store IP address
	ANDB	dcb_ipssts1.B[EDI], #~IPSS1$RROUTE ;Clear removed route flag
14$:	CALL	knlGetRandom32##	;Initialize the sequence number
	MOVL	dcb_tcpoutsnum[EDI], EAX
	MOVL	dcb_tcprcvanum.B[EDI], EAX
	CLRL	EAX			;Set acknowledgement number to 0
	MOVL	dcb_tcprcvsnum.B[EDI], EAX
	CALL	tcpcalhash#		;Calculate hash index
	CALL	xostcpHashSet#		;Put DCB into the TCP hash table
	MOVL	ECX, #60t
	CALL	xosnetGetBufr##		;Get a network buffer
	JC	tcpconf			;If no buffer available
	MOVL	con_bfr.B[EBP], EBX	;OK
	CALL	tcpsetpkt#		;Set up the TCP packet header
	JC	16$
	MOVZBL	ECX, npb_tpofs.B[EBX]
	MOVL	EAX, dcb_tcpoutsnum[EDI]
	MOVL	npb_seqnum.B[EBX], EAX
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	tcp_seqnum.B[EBX+ECX], EAX
	ORB	tcp_code.B[EBX+ECX], #TCPC$SYN ;Set the SYN bit
	MOVL	EAX, dcb_tcprcvwinb.B[EDI]
	MOVL	dcb_tcprcvwina.B[EDI], EAX
	XCHGB	AL, AH
	MOVW	tcp_window.B[EBX+ECX], AX
	MOVL	dcb_tcprndave[EDI], #{TIMEOUT_TRNBGN/FDPERTICK}<3t
	MOVL	dcb_tcprndvar[EDI], #0
	MOVL	dcb_tcprxmtint[EDI], #TIMEOUT_TRNBGN/FDPERTICK+4
	MOVB	dcb_tcpstate.B[EDI], #TCPS_SYNSENT ;Set connection state
	MOVB	con_retry.B[EBP], #RETRY_CON ;Initialize retry counter
	CALL	tcpchksum#
	CALL	xosipsSendSetup##	;Finish setting up the IP header
tcpcon2:MOVL	ESI, dcb_netsdb.B[EDI]	;Make sure have SDB offset
	MOVL	EAX, #xosnetOutDone##	;Output the packet
	CALL	xossnpSendPkt##

	JNC	15$.S
	TESTL	EAX, EAX
	JNE	tcpcone
	INT3

;;;	JC	tcpcone.S

15$:

	MOVL	ESI, dcb_netidb.B[EDI]
	MOVL	EAX, #-1		;Wait here so will see possible ARP
	CALL	xosnetWaitPkt##		;  errors

16$:
	JNC	tcpcon4.S
	TESTL	EAX, EAX
	JNE	tcpcone
	INT3

;;;	JC	tcpcone.S		;If error

tcpcon4:CMPL	dcb_tcprcvputb.B[EDI], #0.B ;Do we have a response yet?
	JNE	tcpcon6			;Yes (unusual but not impossible!)
	MOVL	EAX, #TIMEOUT_TRNBGN	;No - wait for the response
	CALL	xosnetRspWait##
	JNC	tcpcon6.S		;If normal
	MOVL	EBX, con_bfr.B[EBP]	;Restore pointer to our packet
	CMPL	EAX, #ER_NORSP		;Time-out error?

	JE	17$.S
	TESTL	EAX, EAX
	JNE	tcpcone
	INT3

;;;	JNE	tcpcone.S		;No - fail now

17$:	DECB	con_retry.B[EBP]	;Should we do it again?
	JS	18$.S			;No
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Yes
	INCL	tpdb_tcpcntrexmit[EAX]	;Count the retransmission
	MOVL	EBX, con_bfr.B[EBP]
	JMP	tcpcon2.S		;Continue

;Here if have tried enough

18$:	TESTB	npb_sts.B[EBX], #NPS$USEDARP ;Did we use ARP this time?
	JNE	20$.S			;Yes - fail
	TESTB	dcb_ipssts1.B[EDI], #IPSS1$RROUTE ;Just to be safe, have we done
						  ;  this before here?
	JNE	20$.S			;Yes - fail!
	ORB	dcb_ipssts1.B[EDI], #IPSS1$RROUTE ;No - remember we have now
	MOVL	EAX, dcb_ipsrmtaddr.B[EDI] ;Remove this entry from our routing
	PUSHL	EDI			  ;  table
	MOVL	ESI, dcb_netsdb.B[EDI]	;Make sure have SDB offset
	MOVL	EDI, dcb_netpdb.B[EDI]
	MOVB	DL, #0
	CALL	xosipsRtRmvOne##
	POPL	EDI
	MOVL	EBX, con_bfr.B[EBP]
	JC	20$.S			;Forget it if error here
	CALL	xosnetGiveBufr##	;OK - Give up the buffer
	CALL	xostcpHashClr#		;Remove DCB from the hash table
	JMP	14$			;Go try again

;Here if cannot find destination node

20$:	MOVL	EAX, #ER_NSNOD		;Get error code
tcpcone:CALL	xosnetGiveBufr##	;Give up our buffer
tcpconf:MOVB	dcb_tcpstate.B[EDI], #TCPS_CLOSED ;Indicate idle
	CALL	xostcpGiveAll#		;Make sure don't have any buffers
	PUSHL	EAX
	CALL	xostcpHashClr#		;Remove DCB from the hash table
	CLRL	EAX
	MOVL	dcb_ipsrmtaddr.B[EDI], EAX ;Clear remote IP address
	POPL	EAX
	STC				;Indicate error
	LEAVE
	RET
.PAGE
;Here when get a reply to our initial SYN packet - the reply must have both
;  the SYN and ACK bits set (and no others) - if we get a reply that has just
;  the ACK bit set, then the other side must have a half-open connection - we
;  send a reset packet followed by another SYN packet - if we get just a SYN,
;  then it must have crossed his SYN - we send an ACK - if we get a SYN with
;  a FIN, the other side has rejected the connection - we reply with a FIN|ACK

tcpcon6:MOVL	EBX, dcb_tcprcvputb.B[EDI] ;Restore pointer to packet
	CLRL	EAX
	MOVL	dcb_tcprcvputb.B[EDI], EAX
	MOVL	EDX, dcb_tcprcvputp.B[EDI]
	MOVB	AL, tcp_code.B[EDX]
	ANDB	AL, #~TCPC$PSH
	CMPB	AL, #TCPC$SYN		;SYN only?
	JE	16$			;Yes
	TESTB	AL, #TCPC$ACK		;No - have ACK bit?
	JE	2$.S			;No - ignore it
	CMPB	al, #TCPC$ACK		;Yes - ACK bit only?
	JE	8$.S			;Yes - means a half open connection!
	MOVL	EAX, tcp_acknum.B[EDX]	;No - is this the one we want?
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	DECL	EAX
	CMPL	dcb_tcpoutsnum[EDI], EAX
	JNE	6$.S			;No - ignore it
	MOVB	AL, tcp_code.B[EDX]
	ANDB	AL, #~TCPC$PSH
	CMPB	AL, #TCPC$SYN|TCPC$ACK	;SYN + ACK?
	JE	18$			;Yes - go on
	TESTB	AL, #TCPC$RST|TCPC$FIN	;No - RST or FIN bits?
	JNE	10$.S			;Yes
2$:	MOVL	ECX, dcb_ipstpdb.B[EDI]	;No
	INCL	tpdb_tcpcntbadhdr[ECX]	;Count this
4$:	CALL	xosnetGiveBufr##	;And ignore the packet!
	JMP	tcpcon4			;Continue waiting for a response

;Here if ACK number is wrong

6$:	MOVL	ECX, dcb_ipstpdb.B[EDI]
	INCL	tpdb_tcpcntoutseq[ECX]	;Count the out of sequence packet
	JMP	4$.S			;Ignore the packet

;Here if have ACK only - this means the other side has a half open connection

8$:	PUSHL	dcb_tcpoutsnum[EDI]
	MOVL	EAX, tcp_acknum.B[EDX]
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	dcb_tcpoutsnum[EDI], EAX
	CALL	xostcpSendReset#
	POPL	dcb_tcpoutsnum[EDI]

	JNC	9$.S
	TESTL	EAX, EAX
	JNE	tcpcone
	INT3


;;;	JC	tcpcone


9$:	MOVL	EBX, con_bfr.B[EBP]
	JMP	tcpcon2			;Go send the SYN again

;Here if have RESET or FIN with ACK

10$:	MOVL	EAX, #ER_NCRFS		;Get error code
12$:	CALL	xosnetGiveBufr##
14$:	MOVL	EBX, con_bfr.B[EBP]

	TESTL	EAX, EAX
	JNE	tcpcone
	INT3

;;;	JMP	tcpcone

;Here with SYN as response to our initial SYN

16$:	JMP	4$			;DO THIS SOON!!!

;Here with SYN|ACK as response to our initial SYN

18$:	MOVL	EAX, tcp_seqnum.B[EDX]	;Initialize the remote sequence number
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	INCL	EAX
	MOVL	dcb_tcprcvsnum.B[EDI], EAX
	DECL	EAX			   ;Set the sent number to 1 less so we
	MOVL	dcb_tcprcvtnum.B[EDI], EAX ;  will always send the first ACK
	MOVZWL	EAX, tcp_window.B[EDX]	;Store window value
	XCHGB	AL, AH
	MOVL	ECX, dcb_tcpoutsize[EDI]
	SUBL	ECX, #8t.B
	CMPL	EAX, ECX
	JLE	20$.S
	MOVL	EAX, ECX
20$:	MOVL	dcb_tcpoutwina[EDI], EAX
	MOVL	dcb_tcpoutwinm[EDI], EAX
	CALL	xosnetGiveBufr##	;Finished with this packet
	MOVB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;Update connection state
	INCL	dcb_tcpoutsnum[EDI]	;Fix up the send sequence number to
	INCL	dcb_tcprcvanum[EDI]	;Also fix the ACK number
	CALL	tcpsendacknow#		;Send an ACK
	CLRL	EAX			;Indicate success
	MOVL	EDX, con_name.B[EBP]	;Get pointer to rest of name
	LEAVE
	RET
.PAGE	
;Subroutine to get value of next network address field
;	c{EDX} = Offset of address string
;	CALL	getval
;	c(AL)  = Stopper character
;	c(BL)  = Value
;	c{EDX} = Offset of next character in address string

getval:	MOVB	AL, #0
2$:	MOVB	BL, SS:[EDX]		;Get character
	INCL	EDX			;Bump pointer
	CMPB	BL, #'0'		;Is it a digit?
	JB	4$.S			;No
	CMPB	BL, #'9'
	JA	4$.S
	ANDB	BL, #0Fh		;Yes - get value
	MULB	lit10			;And add into value for field
	ADDB	AL, BL
	JMP	2$.S

;Here if next character is not a digit

4$:	XCHGB	AL, BL			;Get things in right registers
	RET				;Return
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	tcpclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

tcpclose:
	CALL	knlIoClsLock##		;Lock the QAB
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #tcpclose1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

tcpclose1:
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	2$			;No
	MOVL	EBX, #tcpioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	4$.S
2$:	CLRL	EAX
4$:	CMPL	dcb_opencnt.B[EDI], #1.B ;Final close?
	JNE	8$.S			;No
	PUSHL	EAX			;Yes - save the current error code
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	CALL	xostcpClear		;Terminate our connection
	JNC	6$.S
	MOVL	[ESP], EAX
6$:	POPL	EAX
8$:	JMP	knlXfCloseFin##		;Go finish up
.PAGE
	.SBTTL	xostcpRmvSynWait - Subroutine to remove DCB from SYN wait list

;Subroutine to remove DCB from the SYN wait list
;	c{EDI} = Offset of DCB
;	CALL	xostcpRmvSynWait

xostcpRmvSynWait::
	MOVL	EDX, dcb_netpdb.B[EDI]	;Point to the PDB
	LEAL	EBX, pdb_ipsynhead[EDX]	;Point to head pointer
20$:	MOVL	ECX, [EBX]		;Get next DCB
	JREGZ	ECX, 22$		;If no more
	CMPL	ECX, EDI		;This one?
	JE	24$.S			;Yes
	LEAL	EBX, dcb_ipshashnext[ECX] ;No - advance pointer
	JMP	20$.S			;Continue

22$:	CRASH	BSWL			;[Bad SYN Wait List]

;Here with DCB

24$:	MOVL	EAX, dcb_ipshashnext[EDI] ;Remove from list
	MOVL	[EBX], EAX		;Update pointer
	TESTL	EAX, EAX		;Was this last on the list?
	JNE	28$.S			;No - finished since list can't be
					;  empty now
	SUBL	EBX, #dcb_ipshashnext.B	;Assume not only one on list
	CMPL	pdb_ipsynhead[EDX], #0.B ;Right?
	JNE	26$.S			;Yes
	CLRL	EBX			;No - list is empty now
26$:	MOVL	pdb_ipsyntail[EDX], EBX	;Update tail pointer
28$:	MOVL	dcb_ipshashnext[EDI], #-1
	RET
.PAGE
	.SBTTL	xostcpPutSynWait - Subroutine to put DCB into SYN wait list

;Subroutine to put DCB into the SYN wait list - also sets connection state to
;  TCPS_LISTEN
;	c{EDI} = Offset of DCB
;	CALL	xostcpPutSynWait

xostcpPutSynWait::
	MOVL	EDX, dcb_netpdb.B[EDI]	;Get offset of the PDB
	MOVL	ECX, pdb_ipsyntail[EDX]	;Get tail of the SYN wait list
	JREGZ	ECX, 2$			;If list is empty
	MOVL	dcb_ipshashnext.B[ECX], EDI ;Not empty - link to end of list
	JMP	4$.S

2$:	MOVL	pdb_ipsynhead[EDX], EDI
4$:	MOVL	pdb_ipsyntail[EDX], EDI
	CLRL	EAX
	MOVL	dcb_ipshashnext.B[EDI], EAX
	MOVB	dcb_tcpstate.B[EDI], #TCPS_LISTEN ;Update connection state
	RET
.PAGE
	.SBTTL	xostcpAcceptSyn - Subroutine to accept connection when SYN received

;Subroutine to accept connection when SYN received on DCB in the TCPS_LISTEN
;  state
;	c{EDI} = Offset of DCB
;	CALL	xostcpAcceptSyn

xostcpAcceptSyn::
	MOVL	EBX, dcb_tcprcvputb.B[EDI] ;Point to IP header in packet
tcpacceptsyn::
	MOVB	dcb_tcpstate.B[EDI], #TCPS_SYNRCVD ;Update connection state
	CLRL	EAX
	MOVL	dcb_tcprcvputb.B[EDI], EAX
	MOVZBL	EDX, npb_npofs.B[EBX]	;Point to IP header in packet
	MOVL	EAX, ip_srcipaddr.B[EBX+EDX] ;Get the remote IP address
	MOVL	dcb_ipsrmtaddr.B[EDI], EAX
	MOVZBL	EDX, npb_tpofs.B[EBX]	;Point to TCP header in packet
	MOVW	AX, [EBX+EDX]		;Get the remote port number
	MOVW	dcb_ipsrmtport.B[EDI], AX
	MOVL	EAX, tcp_seqnum.B[EBX+EDX] ;Get packet sequence number
	XCHGB	AL, AH			;Fix up the byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	dcb_tcprcvtnum.B[EDI], EAX
	INCL	EAX			;Plus one
	MOVL	dcb_tcprcvsnum.B[EDI], EAX ;Store as initial receive number
	MOVL	dcb_tcprcvwinb.B[EDI], #3000t ;Initialize receive window amount
	MOVL	dcb_tcprcvwinm.B[EDI], #3000t
	MOVZWL	EAX, tcp_window.B[EBX+EDX] ;Initialize send window amount
	XCHGB	AL, AH
	MOVL	ECX, dcb_tcpoutsize[EDI]
	SUBL	ECX, #8t.B
	CMPL	EAX, ECX
	JLE	4$.S
	MOVL	EAX, ECX
4$:	MOVL	dcb_tcpoutwina[EDI], EAX
	MOVL	dcb_tcpoutwinm[EDI], EAX
	CALL	xosnetGiveBufr##	;Give up the received packet
	CALL	knlGetRandom32##	;Initialize the sequence number
	MOVL	dcb_tcpoutsnum[EDI], EAX
	MOVL	dcb_tcprcvanum.B[EDI], EAX
	CALL	tcpcalhash#
	CALL	xostcpHashSet#		;Put DCB into the hash table
	CLC
	RET
.PAGE
	.SBTTL	xostcpSendSynAck - Subroutine to send SYN|ACK packet

;Subroutine to send SYN|ACK packet
;	c{EDI} = Offset of DCB
;	CALL	xostcpSendSynAck

xostcpSendSynAck::
	MOVL	ECX, #60t.B
	CALL	xosnetGetBufr##		;Get a buffer
	JC	4$.S			;If can't get one
	CALL	tcpsetpkt#		;Set up the packet header
	JC	6$.S
	MOVL	npb_dcb.B[EBX], EDI
	MOVZBL	ECX, npb_tpofs.B[EBX]
	MOVL	EAX, dcb_tcpoutsnum[EDI]
	MOVL	npb_seqnum.B[EBX], EAX
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	tcp_seqnum.B[EBX+ECX], EAX
	MOVB	tcp_code.B[EBX+ECX], #TCPC$SYN|TCPC$ACK
	CALL	tcpsetack#		;Set up acknowlegement stuff in packet
	CALL	xosipsSendSetup##	;Set up final IP header stuff
	MOVL	EAX, #xosnetGiveBufr##	;Send the packet and then give up the
	CALL	xossnpSendPkt##		;  buffer (but don't wait)
	CLC
4$:	RET

6$:	CALL	xosnetGiveBufr##
	STC
	RET
.PAGE
	.SBTTL	xostcpClear - Subroutine to clear TCP connection

;Subroutine to clear TCP connection - must be called in extended fork
;  context
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IDB
;	CALL	xostcpClear
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xostcpClear:
	MOVZBL	EAX, dcb_tcpstate.B[EDI] ;Get connection state
	JMPIL	CS:clrdsp[EAX*4]	;Dispatch on the state

	.MOD	4
clrdsp:	.LONG	clridle		;TCPS_CLOSED    = 0  - Idle
	.LONG	clrlisten	;TCPS_LISTEN    = 1  - Waiting for SYN
	.LONG	clrestab	;TCPS_SYNSENT   = 2  - SYN sent
	.LONG	clrestab	;TCPS_SYNACKD   = 3  - ACK sent for SYN|ACK
	.LONG	clrestab	;TCPS_SYNRCVD   = 4  - SYN received
	.LONG	clrestab	;TCPS_ESTAB     = 5  - Connection established
	.LONG	clridle		;TCPS_FINWAIT1  = 6  - FIN sent, waiting for FIN
				;			 in reply and for ACK
	.LONG	clridle		;TCPS_FINWAIT2  = 7  - ACK for FIN received,
				;			 still waiting for FIN
	.LONG	clridle		;TCPS_CLOSING   = 8  - Reply FIN received
				;			 without ACK, waiting
				;			 for ACK for the FIN
	.LONG	clrclosewait	;TCPS_CLOSEWAIT = 9  - FIN received, waiting
				;			 for process to close
				;			 TCP device
	.LONG	clridle		;TCPS_LASTACK   = 10 - Reply FIN sent, waiting
				;			 for final ACK
	.LONG	clridle		;TCPS_TIMEWAIT  = 11 - All finished - timing out
				;			 port

.PAGE
;Here when clearing if already idle or quiet

clridle:CALL	xostcpGiveAll#		;Make sure don't have any buffers
	CLRL	EAX
	RET

;Here when clearing if waiting for SYN

clrlisten:
	CMPL	dcb_tcpconbase[EDI], #0.B
	JNE	clridle.S
4$:	MOVL 	EAX, dcb_tcpconnext[EDI]
	TESTL	EAX, EAX
	JE	clridle.S

;Here if this is a SYN queue DCB with at least one DCB waiting for a
;  connection - we must wake up all DCB's that are waiting

	MOVL	EAX, dcb_tcpconnext[EDI] ;Remove him from the list
	MOVL	EDX, dcb_tcpconnext[EAX]
	MOVL	dcb_tcpconnext[EDI], EDX
	CLRL	EDX
	MOVL	dcb_tcpconnext[EAX], EDX
	MOVL	dcb_tcpconbase[EAX], EDX
	PUSHL	EDI
	MOVL	EDI, EAX
	MOVL	EAX, #ER_ABORT
	CALL	knlResumeOutput##	;Wake him up
	POPL	EDI
	JMP	4$.S

;Here when clearing if have already received a FIN - in this case we send the
;  reply FIN and then wait for the final ACK

clrclosewait:
	CALL	xostcpSendFin#		;Send a FIN
	JC	10$.S
	MOVB	dcb_tcpstate.B[EDI], #TCPS_LASTACK ;Update state
	CALL	tcprspwait#		;Wait for the final ACK
10$:	RET

;Here when clearing if a connection is established - we send a FIN and then
;  wait for the reply FIN

clrestab:				       ;Is the application level
	TESTB	dcb_tcpsts2.B[EDI], #TCPS2$FATAL ;  protocol alive?
	JE	14$.S			;Yes
	CALL	xostcpGiveAll#		;No - make sure no buffers allocated
14$:	CALL	xostcpSendFin#		;Send a FIN
	JC	18$.S
	MOVB	dcb_tcpstate.B[EDI], #TCPS_FINWAIT1 ;Update state
16$:	CALL	tcprspwait#		;Wait for a response
	JC	18$.S			;If error
	CMPB	dcb_tcpstate.B[EDI], #TCPS_CLOSING ;OK - did we get a FIN?
	JE	20$.S			;Yes
	CMPB	dcb_tcpstate.B[EDI], #TCPS_TIMEWAIT ;Maybe
	JNE	16$.S			;No - continue waiting
	JMP	20$.S			;Yes

;Here if error while sending a FIN or waiting for his FIN

18$:	MOVB	dcb_tcpstate.B[EDI], #TCPS_TIMEWAIT ;Indicate almost idle
	CMPL	EAX, #ER_NORSP		;Time-out error?
	JNE	20$.S			;No
	MOVL	EAX, #ER_NCLST		;Yes - get right error code
20$:	PUSHL	EAX			;Save error code
	CALL	xostcpGiveAll#		;Make sure don't have any buffers
	POPL	EAX
	BTL	EAX, #31t		;Set C if error
ret020:	RET
.PAGE
	.SBTTL	tcplost - Subroutine to indicate that connection is lost

;Subroutine to indicate that a TCP connection has been lost
;	c{EDI} = Offset of DCB
;	CALL	tcplost
;  c{EAX} is respected

tcplost::
	CMPL	dcb_ipsrmtaddr.B[EDI], #0.B ;Do we have a remote address now?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the lost connection
	INCL	tpdb_tcpcntclost[EAX]
	CALL	xostcpHashClr#		;Remove DCB from its hash list
	CLRL	EAX
	MOVL	dcb_ipsrmtaddr.B[EDI], EAX ;Clear remote IP address
	POPL	EAX
4$:	ORB	dcb_tcpsts2.B[EDI], #TCPS2$FATAL ;Indicate application level is
					       ;  dead
	CMPL	dcb_opencnt.B[EDI], #0.B ;Is the DCB in use?
	JE	6$.S			;No
	MOVL	EAX, #ER_NCLST		;Yes - wake him up if he's waiting for
	CALL	knlResumeInput##	;  anything
	MOVL	EAX, #ER_NCLST
	JMP	knlResumeOutput##

;Here if DCB is not in use - give it up

6$:	MOVL	EAX, dcb_sdisp.B[EDI]	;Give up the DCB
	JMPIL	sd_cleardcb.B[EAX]
.PAGE
	.SBTTL	sd_inpblock - Input block

;Here for the input block entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	tcpinpblk
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

$$$=!0
FRM inp_amount , 4
inp_SIZE=!$$$

tcpinpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock all buffer pages
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_inpframe
	MOVL	iorb_routine.B[ESI], #tcpinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here in extended fork context

tcpinpblk1:
	ENTER	inp_SIZE, 0
	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;Do we have a connection?
	JE	3$.S			;Yes
	CMPB	dcb_tcpstate.B[EDI], #TCPS_CLOSEWAIT ;Maybe
	JNE	10$			;No - fail
3$:	MOVL	SS:xffTimeOut##, #TIMEOUT_AP ;Store default time-out value
	MOVL	inp_amount.B[EBP], #0	;Clear total amount input
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	4$.S			;No
	MOVL	EBX, #tcpioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	12$.S
4$:	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
	MOVL	ECX, SS:xffCount##	;Get count
	JREGZ	ECX, 6$
	LESL	EBX, SS:xffBuffer1##	;Get address of buffer
	MOVL	EAX, SS:xffTimeOut##
	CALL	xostcpGetBlk#
	JC	8$.S
	BTL	SS:xffCmd##, #O%PARTIAL	;Can we accept partial input?
	JC	6$.S			;Yes
	ADDL	inp_amount.B[EBP], ECX	;No - add into total amount
	ADDL	SS:xffBuffer1##, ECX	;Bump buffer offset
	SUBL	SS:xffCount##, ECX	;Reduce amount wanted
	JG	4$.S			;If need more
	MOVL	ECX, inp_amount.B[EBP]	;Finished - get total amount
6$:	CLRL	EAX
	CALL	xostcpOpenWindow#	;Open sender's window if need to
8$:	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

;Here if don't have a connection

10$:	MOVL	EAX, #ER_NCLST
12$:	CLRL	ECX
	JMP	8$.S
.PAGE
	.SBTTL	sd_outstring - Output string

;Here for the output string entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	tcpoutstr
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

tcpoutstr:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoStringLock##	;Lock the string pages
	JNC	4$.S			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	sd_outblock - Output block

;Here for the output block entry
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	tcpoutblk
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Amount transfered

;TCP output is somewhat complex, with silly window syndrome avoidance and
;  packet coalescence (Nagel xosorithm) to worry about.  Since pushes are
;  optional, we may have some unsent data buffered when we get here, but it
;  will always be less than half the "maximum window size".  (This is a somewhat
;  problematical value since it is not directly provided by the protocol.  We
;  keep track of the largest window size reported and use this value.)  When
;  finished here, we always do a push (even if its not requested) if the amount
;  buffered is half the maximum window size or greater.  We do not store data
;  unless the window is open some amount, and we store data in chunks no
;  larger than half the maximum window size.  This means we may over-commit
;  up to half the maximum window size.  An output block is not split across
;  packets unless absolutely necessary.  If there is a packeted buffered and
;  the entire output block can be added to the packet, this is done (even if
;  this means allocating additional chained buffer chunks).  If the output
;  block is too big to fit in a single packet by itself, as much as possible
;  is added to the current packet.  If it will fix in a maximum size packet,
;  the current buffered data is pushed and a new packet is allocated.

;Note that the output code uses a somewhat unusual scheme to avoid the silly
;  window syndrome in addition to this.  If the next packet to be output will
;  not completely fit in the window, nothing is output and a window probe
;  timer is started.  The first time it goes off, as much of the packet as
;  will fit in the window is output, completely closing the window.

$$$=!0
FRM out_amount , 4
out_SIZE=!$$$

tcpoutblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock all buffer pages
	JC	2$.S			;If error
4$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #tcpoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

tcpoutblk1:
	ENTER	out_SIZE, 0
	CLRL	EAX
	MOVL	out_amount.B[EBP], EAX
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP ;Store default time-out value
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	6$.S			;No
	MOVL	EBX, #tcpioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	16$.S
	MOVL	ESI, dcb_netidb.B[EDI]	;Get offset of our IDB
6$:	MOVL	ECX, SS:xffCount##	;Get count
	TESTL	ECX, ECX
	JE	14$.S			;If nothing to output
	MOVL	EAX, SS:xffTimeOut##	;Get time-out value
	LESL	EBX, SS:xffBuffer1##	;Get address of buffer
	PUSHL	ECX
	CALL	xostcpPutBlk#		;Store the data in the output buffer
	POPL	ECX
	JC	16$.S			;If error
	ADDL	SS:xffBuffer1##, ECX	;Bump pointer
	ADDL	out_amount.B[EBP], ECX	;Increase amount done
	SUBL	SS:xffCount##, ECX	;Reduce amount to do
	JG	6$.S			;Continue if more to do
14$:	CLRL	EAX			;Finished
16$:	MOVL	ECX, out_amount.B[EBP]	;Get amount output
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET
.PAGE
	DATA

tcpccb::       .BLKB ccb_SIZE	;TCP CCB
tcptwdcb::     .LONG 0		;Offset of first timed wait DCB
xostcpTpdbHead:.LONG 0		;Offset of first TCP TPDB
temp:	       .BLKB 12t	;Buffer for destination message names
lit10:	       .LONG 10t
tcpxxx:: .LONG 0

	END
