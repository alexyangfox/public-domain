	.TITLE	XFSCLS1 - XOS file system class driver - part 1

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSXDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSXXFS.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!1t
MINV   =!0t
EDITNUM=!0t

;1.0.1 - 27-Jan-99
;	First version, built from DFSCLS 1.0.8.

	LKEHEAD	XFSCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

$$CHKCHAIN=!0

	CODE

;SVC dispatch table for XOS file system class devices

	.MOD	4
xfsdsp::.LONG	xosdskMount##	;sd_mount      = 0.   - Mount
	.LONG	knlRtnZero##	;sd_cleardev   = 4.   - Clear device
	.LONG	xosdskCDcb##	;sd_cleardcb   = 8.   - Clear DCB
	.LONG	xfswritefats#	;sd_commit     = 12.  - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold   = 16.  - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew   = 20.  - Transfer device/new
	.LONG	knlRtnZero##	;sd_opena      = 24.  - Open additional
	.LONG	xosdskLclOpen##	;sd_open1      = 28.  - Open device/file
	.LONG	xosdskLclParm##	;sd_devparm    = 32.  - Device parameters
	.LONG	xosdskLclDelete##;sd_delete    = 36.  - Delete file
	.LONG	xosdskLclRename##;sd_rename    = 40.  - Rename file
	.LONG	xfsinpblk	;sd_inblock    = 44.  - Input block
	.LONG	xfsoutblk	;sd_outblock   = 48.  - Output block
	.LONG	xfsoutblk1	;sd_outblockq  = 52.  - Output block (XFF)
	.LONG	xfsoutstr	;sd_outstring  = 56.  - Output string
	.LONG	knlRtnMOne##	;sd_getiosts   = 60.  - Get input/output status
	.LONG	knlIFnDevGQ##	;sd_special    = 64.  - Special device function
	.LONG	xfsclose#	;sd_close      = 68.  - Close file
	.LONG	xfslabel	;sd_label      = 72.  - Get device label
	.LONG	xfscommit	;sd_commitfunc = 76.  - Commit data to disk
	.LONG	xfsinfo		;sd_devinfo    = 80.  - Return device info
	.LONG	xfsvfychg	;dd_vfychg     = 84.  - Verify changed disk
	.LONG	xfsopen#	;dd_openn      = 88.  - Open file
	.LONG	xfsopen#	;dd_opend      = 92.  - Open file/directory
	.LONG	xfsrename	;dd_rename     = 96.  - Rename file
	.LONG	xfsclose2#	;dd_close      = 100. - Close file
	.LONG	xfsopenparms	;dd_openparms  = 104. - Offset of open parms
	.LONG	xfssetpath	;dd_setpath    = 108. - Set up path data
	.LONG	xfschkpath	;dd_chkpath    = 112. - Check path data
	.LONG	xfsclrpath	;dd_clrpath    = 116. - Clear path data
	.LONG	knlNullCharStr##;dd_gtrtprot   = 120. - Get root protection
	.LONG	knlBadCharF##	;dd_strtprot   = 124. - Set root protection
.PAGE
;IO parameter table for XOS file system open operations

	.LONG	OPARMMAX
xfsopenparms::
	.LONG	opnpgenparms	  ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	opnpfilparms	  ;IOPAR_FILxxx = 01xx - File IO parameters
	.LONG	knlNullTrmParms## ;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	xosdskIoDskParms##;IOPAR_DSKxxx = 03xx - Disk IO parameters
OPARMMAX=!{$-xfsopenparms}/4

	.LONG	OPARMGENMAX
opnpgenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopDummyS##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDummyN##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopDummyN##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS	   = 0009h
	.LONG	0		;IOPAR_INPQLMT	   = 000Ah
	.LONG	0		;IOPAR_OUTQLMT	   = 000Bh
	.LONG	knlIopDummyN##	;IOPAR_SIVECT1     = 000Ch
	.LONG	knlIopDummyN##	;IOPAR_SIVECT2     = 000Dh
	.LONG	knlIopDummyN##	;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	0		;IOPAR_BUFRLMT	   = 0010h
OPARMGENMAX=!{$-opnpgenparms}/4

	.LONG	OPARMFILMAX
opnpfilparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_DIRHNDL     = 0101h
	.LONG	knlIopDummyN##	;IOPAR_SRCATTR     = 0102h
	.LONG	opnpattr	;IOPAR_FILATTR     = 0103h
	.LONG	opnpdirofs	;IOPAR_DIROFS      = 0104h
	.LONG	xosdskOpnPioPos##;IOPAR_ABSPOS	   = 0105h
	.LONG	xosdskOpnPioPos##;IOPAR_RELPOS	   = 0106h
	.LONG	xosdskOpnPioPos##;IOPAR_EOFPOS	   = 0107h
	.LONG	0		;		   = 0108h
	.LONG	opnplength	;IOPAR_LENGTH      = 0109h
	.LONG	opnpalloc	;IOPAR_REQALLOC    = 010Ah
	.LONG	opnpalloc	;IOPAR_RQRALLOC    = 010Bh
	.LONG	opnpgrpsize	;IOPAR_GRPSIZE     = 010Ch
	.LONG	opnpmdate	;IOPAR_ADATE       = 010Dh
	.LONG	opnpmdate	;IOPAR_CDATE       = 010Eh
	.LONG	opnpmdate	;IOPAR_MDATE       = 010Fh
	.LONG	knlIopDummyN##	;IOPAR_PROT        = 0110h
	.LONG	knlIopDummyS##	;IOPAR_OWNER       = 0111h
	.LONG	0		;                  = 0112h
	.LONG	0		;IOPAR_SETLOCK	   = 0113h
	.LONG	0		;IOPAR_CLRLOCK	   = 0114h
	.LONG	knlIopDummyN##	;IOPAR_CLSTIME     = 0115h
	.LONG	knlIopDummyS##	;IOPAR_CLSNAME     = 0116h
	.LONG	knlIopDummyT##	;IOPAR_CLSMSG	   = 0117h
	.LONG	knlIopDummyN##	;IOPAR_SHRPARMS    = 0118h
OPARMFILMAX=!{$-opnpfilparms}/4
.PAGE
;IO parameter table for XOS file system data transfer operations

	.LONG	PARMMAX
xfsioparms::
	.LONG	xfsiogenparms	  ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	xfsiofilparms	  ;IOPAR_FILxxx = 01xx - File IO parameters
	.LONG	knlNullTrmParms## ;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	xosdskIoDskParms##;IOPAR_DSKxxx = 03xx - Disk IO parameters
PARMMAX=!{$-xfsioparms}/4

	.LONG	PARMGENMAX
xfsiogenparms::
	.LONG	0		;		   = 0000h
	.LONG	knlIoxFilOptn##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIoxFilSpec##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopNullN##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopNullN##	;IOPAR_TIMEOUT     = 0007h
	.LONG	knlIopIoSts##	;IOPAR_INPSTS	   = 0008h
	.LONG	knlIopIoSts##	;IOPAR_OUTSTS	   = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT	   = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT	   = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	0		;IOPAR_BUFRLMT     = 0010h
PARMGENMAX=!{$-xfsiogenparms}/4

	.LONG	PARMFILMAX
xfsiofilparms:
	.LONG	0		;		   = 0100h
	.LONG	0		;IOPAR_DIRHNDL     = 0101h
	.LONG	0		;IOPAR_SRCATTR     = 0102h
	.LONG	xfsiopfilattr	;IOPAR_FILATTR     = 0103h
	.LONG	0		;IOPAR_DIROFS      = 0104h
	.LONG	xfsiopabspos	;IOPAR_ABSPOS	   = 0105h
	.LONG	xfsioprelpos	;IOPAR_RELPOS	   = 0106h
	.LONG	xfsiopeofpos	;IOPAR_EOFPOS	   = 0107h
	.LONG	0		;		   = 0108h
	.LONG	xfsioplength	;IOPAR_LENGTH      = 0109h
	.LONG	xfsiopalloc	;IOPAR_REQALLOC    = 010Ah
	.LONG	xfsiopalloc	;IOPAR_RQRALLOC    = 010Bh
	.LONG	xfsiopgrpsize	;IOPAR_GRPSIZE     = 010Ch
	.LONG	xfsiopcdate	;IOPAR_ADATE       = 010Dh
	.LONG	xfsiopcdate	;IOPAR_CDATE       = 010Eh
	.LONG	xfsiopcdate	;IOPAR_MDATE       = 010Fh
	.LONG	knlIopNullN##	;IOPAR_PROT        = 0110h
	.LONG	knlIopDummyT##	;IOPAR_OWNNAME     = 0111h
	.LONG	knlIopDummyT##	;IOPAR_GRPNAME     = 0112h
	.LONG	xfsiopsetlock	;IOPAR_SETLOCK	   = 0113h
	.LONG	xfsiopclrlock	;IOPAR_CLRLOCK	   = 0114h
	.LONG	0		;IOPAR_CLSTIME     = 0115h
	.LONG	0		;IOPAR_CLSNAME     = 0116h
	.LONG	0		;IOPAR_CLSMSG	   = 0117h
	.LONG	xfsiopshrparms	;IOPAR_SHRPARMS	   = 0118h
PARMFILMAX=!{$-xfsiofilparms}/4
.PAGE
	.SBTTL	Initialization routine

	INITSUB	initxfs

initxfs::
	MOVL	EBX, #xfschk1		;Register the file system
	MOVL	EDX, #xfschk2
	CALL	xosdskMakeFscb##
	JC	10$.S			;If error
	MOVL	ECX, #xcodetop#
	CLRL	EDX
	CLRL	EAX
10$:	MOVL	EBX, #QSTS$DONE
	RET

	CODE
.PAGE
;Here for the IOPAR_LENGTH parameter for open - Written length of file

	DPARMHDR  BOTH, DECV
opnplength:
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	ret002.S		;No
	MOVL	EAX, dcb_dkfilepnt.B[EDI] ;Yes - really have a file open?
	TESTL	EAX, EAX
	JE	ret002.S		;No
	MOVL	EAX, fib_size.B[EAX]	;Yes - get written length of file
1$:	JMP	knlAddParm4##		;Give it to the user

;Here for the IOPAR_REQALLOC or IOPAR_RQRALLOC parameters for open - Allocated
;  length of file

	DPARMHDR  BOTH, DECV
opnpalloc:
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	ret002.S		;No
	MOVL	EAX, dcb_dkfilepnt.B[EDI] ;Yes - really have a file open?
	TESTL	EAX, EAX
	JE	ret002.S		;No
	MOVL	EAX, fib_alloc.B[EAX]	;Yes - get number of clusters allocated
	MOVL	ESI, [EDI]		;Get offset of the UCB
	MOVL	ESI, ucb_bpclus.B[ESI]	;Get size of a cluster
	MULL	ESI			;Calculate number of bytes allocated
	JMP	knlAddParm8##		;Give it to the user

;Here for the IOPAR_FILATTR parameter for open - File attributes for file

	DPARMHDR  BOTH, HEXV
opnpattr:
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	ret002.S		;No
	MOVL	EDX, opn_frame1.B[EBP]	;Yes
	MOVZBL	EAX, SS:opn_curattr[EDX]
	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Is the file still open?
	JNE	2$.S			;Yes
	ANDB	AL, #A$DIRECT		;No - just give him the directory bit
2$:	JMP	knlStrParm4##

;Here for the IOPAR_DIROFS parameter for open - Directory offset for search

	DPARMHDR  BOTH, DECV
opnpdirofs:
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	ret002.S		;No
	MOVL	EDX, opn_frame1.B[EBP]
	MOVL	EAX, SS:opn_dirofs.B[EDX]
	JMP	knlStrParm4##

ret002:	RET

;Here for the IOPAR_GRPSIZE parameter for open - Allocation group size

	DPARMHDR  BOTH, DECV
opnpgrpsize:
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	ret002.S		;No
	MOVL	EAX, dcb_dkfilepnt.B[EDI] ;Yes - really have a file open?
	TESTL	EAX, EAX
	JE	4$.S			;No
	MOVL	EAX, fib_grpsize.B[EAX]	;Yes
4$:	JMP	knlStrParm4##

;Here for the IOPAR_MDATE parameter - Modify date/time

	DPARMHDR  BOTH, HEXV
opnpmdate:				;This is the same as creation date/time
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	ret002.S		;No
	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Yes - really have a file open?
	TESTL	EDX, EDX
	JE	4$.S			;No
	MOVL	EAX, fib_mdt+0.B[EDX]	;Yes - file's modify date/time value
	MOVL	EDX, fib_mdt+4.B[EDX]
	CMPL	ECX, #8.B		;Want date and time in DOS format?
	JBE	10$.S			;Yes
	JMP	knlStrParm8##

;Here if want date and time in DOS format

10$:	CALL	knlSys2DosTIme#		;Change time to DOS format
	XCHGL	EAX, EDX
	CALL	knlSys2DosDate#		;Change date to DOS format
	SHRL	EAX, #16t
	MOVW	AX, DX
	JMP	knlStrParm8##		;Go give it to the user
.PAGE
	.SBTTL	xfsiopabspos - IOPAR_ABSPOS - set or get absolute position

;Here for the IOPAR_ABSPOS parameter for a XOS file system transfer - set or
;  get absolute IO position

	DPARMHDR  BOTH, DECV
xfsiopabspos:
	TESTB	AH, #PAR$SET		;Want to change value?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm#		;Get value for position
	JC	6$.S
2$:	MOVL	dcb_dkfpos.B[EDI], EAX	;Store value
	POPL	EAX
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No
	MOVL	EAX, dcb_dkfpos.B[EDI]	;Yes - get value
	JMP	knlStrParm4##		;Give it to him

6$:	POPL	ECX			;Fix up the stack
8$:	RET

	.SBTTL	xfsioprelpos - IOPAR_RELPOL - set or get relative position

;Here for the IOPAR_RELPOS parameter for a XOS file system transfer - set or
;  get relative IO position

	DPARMHDR  BOTH, DECV
xfsioprelpos:
	TESTB	AH, #PAR$SET		;Want to change value?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get value for position
	JC	6$.S
	ADDL	EAX, dcb_dkfpos.B[EDI]	;Make it relative
10$:	JNO	2$.S
	POPL	ECX			;Report value error if overflow
	JMP	knlBadParmV##

	.SBTTL	xfsiopeofpos - IOPAR_EOFPOS - set or get position relative to EOF

;Here for the IOPAR_EOFPOS parameter for a XOS file system transfer - set or
;  get IO position relative to EOF

	DPARMHDR  BOTH, DECV
xfsiopeofpos:
	TESTB	AH, #PAR$SET		;Yes - want to change value?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get value for position
	JC	6$.S
	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Make it relative to EOF
	ADDL	EAX, fib_size.B[EDX]
	JMP	10$.S
.PAGE
	.SBTTL	xfsiopfilattr - IOPAR_FILATTR - Set or get attributes for file

;Here for the IOPAR_FILATTR parameter for a XOS file system transfer - set or
;  get attributes for file

	DPARMHDR  BOTH, HEXV
xfsiopfilattr:
	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter
	TESTB	AH, #PAR$SET		;Yes - want to change value?
	JE	8$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get value for length
	JC	12$.S			;If error
	MOVL	EDX, dcb_dkfilepnt.B[EDI]
	ANDB	AL, #A$DIRECT|A$HIDDEN|A$SYSTEM
	JNE	2$.S
	MOVB	AL, #A$NORMAL
2$:	MOVB	AH, AL			;Trying to change the directory bit?
	XORB	AH, fib_attrib.B[EDX]
	TESTB	AH, #A$DIRECT
	JNE	10$.S			;Yes - fail
	MOVB	fib_attrib.B[EDX], AL	;OK - store new value
	ORB	cb_sts.B[EDX], #CB$CHNGD ;Indicate FIB has been changed
	POPL	EAX
8$:	TESTB	AH, #PAR$GET		;Want to return value?
	JE	ret006.S			;No
	MOVZBL	EAX, fib_attrib.B[EDX]	;Yes - get value
	JMP	knlStrParm4##		;Give it to him

10$:	MOVL	EAX, #ER_PARMV
	STC
12$:	POPL	EBX			;Fix up the stack
ret006:	RET				;Return
.PAGE
	.SBTTL	xfsioplength - XOS file IO parameter - set or get written length

;Here for the IOPAR_LENGTH parameter for a XOS file system transfer - set or get
;  written length of file

	DPARMHDR  BOTH, DECV
xfsioplength:
	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter
	TESTB	AH, #PAR$SET		;Yes - want to change value?
	JE	14$.S			;No
	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Yes
	TESTB	fib_attrib.B[EDX], #A$DIRECT; Directory?
	JNE	knlIllOut##		;Yes - fail
	PUSHL	EAX			;No
	CALL	knlGetParm##		;Get value for length
	JC	12$.S			;If error
	PUSHL	ES			;Save address of the value
	PUSHL	EBX
	PUSHL	EAX
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Lock the file
	CALL	xosdskLockBufrW##
	POPL	EDX			;Restore value
	CMPL	EDX, #-1.B		;Want current position?
	JNE	4$.S			;No
	MOVL	EDX, dcb_dkfpos.B[EDI]	;Yes
4$:	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Get offset of the base FIB
	CMPL	EDX, fib_size.B[EBX]	;Really changing the file length?
	JE	10$.S			;No
	JA	8$.S			;Yes - if increasing the size					       ;  file modified
	MOVL	fib_size.B[EBX], EDX	;Reduce written length of file
	ORB	cb_sts.B[EBX], #CB$CHNGD ;Indicate FIB has been changed
	JMP	10$.S

;Here if value would place us before the beginning of the file

6$:	ADDL	ESP, #12t.B		;Fix up the stack
	MOVL	EAX, #ER_PARMV		;Get error code
	STC				;Fail
	RET

;Here if need to extend file

8$:	MOVL	dcb_dkfpos.B[EDI], EDX	;Set position to desired new EOF
	CLRL	ECX			;Write zero bytes (this will extend
	CALL	xfswrite		;  the file as needed here)
	JC	16$.S			;If error
	MOVL	EBX, dcb_dkfilepnt.B[EDI]
10$:	CALL	xosdskUnlkBufr##	;Unlock the file
	POPL	EBX			;Restore address of the parameter value
	POPL	ES
12$:	JC	retpbx.S		;If error
	POPL	EAX
14$:	TESTB	AH, #PAR$GET		;Want to return value?
	JE	ret010.S		;No
	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Yes - get offset of the base FIB
	MOVL	EAX, fib_size.B[EDX]	;Get length of file
	JMP	knlStrParm4##		;Give it to him

;Here if error writing to the file (file is locked when get here)

16$:	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Unlock the file
	CALL	xosdskUnlkBufr##
	POPL	EBX
	POPL	EBX
retpbx:	POPL	EBX			;Fix up the stack
ret010:	RET				;Return
.PAGE
	.SBTTL	xfsiopalloc - XOS file IO parameter - Get amount allocated

;Here for the IOPAR_REQALLOC or IOPAR_RQRALLOC parameter for a XOS file
;  transfer - Get amount allocated

	DPARMHDR  GET, DECV
xfsiopalloc:
	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter
	TESTB	AH, #PAR$GET		;Yes - want to get the value?
	JE	ret010.S		;No
	MOVL	ESI, [EDI]		;Yes - get offset of our UCB
	TESTL	ESI, ESI		;Make sure have one now
	JE	knlNoUnit##
	PUSHL	ES
	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Get offset of base FIB
	CMPL	fib_alloc.B[EDX], #-1.B	;Have we scanned the FATs yet?
	JNE	2$.S			;Yes
	PUSHL	EBX			;No
	PUSHL	ECX
	MOVL	EBX, EDX
	CALL	xosdskLockBufrW##	;Lock the file
	CALL	xfsscanfats#		;Do it now
	JC	4$.S			;If error
	CALL	xosdskUnlkBufr##
	MOVL	EDX, EBX
	POPL	ECX
	POPL	EBX
2$:	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Get offset of base FIB
	MOVL	EAX, fib_alloc.B[EDX]	;Get amount allocated to file
	MULL	ucb_bpclus.B[ESI]	;Convert to bytes
	POPL	ES
	JMP	knlStrParm8##

;Here if error

4$:	PUSHL	EAX
	CALL	xosdskUnlkBufr##
	POPL	EAX
	POPL	ECX
	POPL	EBX
	POPL	ES
	STC
ret014:	RET

	.SBTTL	xfsiogrpsize - XOS file IO parameter - Get allocation group size

;Here for the IOPAR_GRPSIZE parameter for a XOS file transfer - Get allocation
;  group size

	DPARMHDR  GET, DECV
xfsiopgrpsize:
	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter
	TESTB	AH, #PAR$GET		;Yes - want to get the value?
	JE	ret014.S		;No
	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Yes - get FIB offset
	MOVZWL	EAX, fib_grpsize.B[EDX]	;Get allocation group size
	JMP	knlStrParm4##
.PAGE
	.SBTTL	xfsiopcdate - XOS file IO parameter - Get or set creation date/time

;Here for the IOPAR_CDATE parameter for an XFS file transfer - Get or set file
;  creation date and time

	DPARMHDR  BOTH, HEXV
xfsiopcdate::
	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter
	TESTB	AH, #PAR$SET		;Yes - want to change value?
	JE	opnpmdate		;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get new value
	JC	retpbx
	CMPL	ECX, #8.B		;Already in XOS format?
	JAE	2$.S			;Yes
	PUSHL	EDX			;Save date value
	MOVZWL	EDX, AX
	SHRL	EAX, #16t
	CALL	knlDos2SysDate##	;Convert date to XOS format value
	XCHGL	EAX, EDX
	CALL	knlDos2SysTime##	;Convert time to XOS format value
2$:	PUSHL	EDX
	MOVL	EDX, dcb_dkfilepnt.B[EDI]
	MOVL	fib_cdt+0.B[EDX], EAX	;Date and time
	POPL	fib_cdt+4.B[EDX]
	ORB	cb_sts.B[EDX], #CB$CHNGD ;Indicate FIB has been changed
	ORB	fib_status.B[EDX], #FS$DATESET ;Indicate date and time has
	POPL	EAX			       ;  been set
	JMP	opnpmdate
.PAGE
	.SBTTL	xfsiopsetlock/xfsiopclrlock - IOPAR routines for file system locks

;Here for the IOPAR_SETLOCK parameter for setting a XOS file lock.  This
;  parameter must be specified with 8 data bytes.  The first 4 bytes specify
;  the offset in the file of the start of the region to lock and the 2nd 4
;  bytes specify the length of the region to lock.

;Note: The ordering of the stack frame MUST match the reverse order of the
;      offsets defined in ?????DOS as fle_*, since we bulk-copy the data over

$$$=!0
FRM sl_psp   , 2t	;PSP if DOS process
FRM sl_pda   , 2t	;PDA selector for process owning lock
FRM sl_size  , 4t	;Size of locked region in file
FRM sl_offset, 4t	;Offset of beginning of lock in file
FRM sl_dcb   , 4t	;DCB lock was created under
FRM sl_begin , 0t	;Beginning of data block
sl_SIZE=!$$$

	DPARMHDR  SET, HEXV
xfsiopsetlock:
	ENTER	sl_SIZE, 0

	CRASH	LOCK

.IF NE 0

	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter index
	CMPL	ECX, #8t.B		;Have enough data?
	JB	knlBadParmS##		;No - bad parameter size
	PUSHL	EDI			;Yes - save offset of DCB
	MOVL	ECX, ES:4.B[EBX]	;Get size of locked region
	PUSHL	EBX			;Save pointer to user parameters
	MOVL	EBX, ES:[EBX]		;Get offset of beginning of lock
	CLRL	EAX			;Do strict lock checking
	CALL	xfschklock1		;Yes - Make sure no current lock
	POPL	EBX			;Restore pointer to user parameters
	JC	50$			;Fail if have lock conflict
	MOVW	AX, SS:xffPda##		;OK - get PDA selector for process
	MOVW	sl_pda.b[EBP], AX	;Store in lock
	MOVL	sl_dcb.b[EBP], EDI	;Save current DCB in lock
	MOVL	GS, EAX			;Get selector for PDA
	TESTB	GS:pdaStatus1##, #P1$DOSSEG ;Is this a DOS process?
	JE	5$.S
	PUSHL	#GS_REAL16.B
	POPL	GS			;Point to real mode segment
	MOVL	EAX, GS:dda_curpsp	;Get current PSP
	SHRL	EAX, #4.B		;Shift in 16-bit value
5$:	MOVW	sl_psp.B[EBP], AX	;Save in new lock
	MOVL	EAX, ES:[EBX]		;Get file offset of locked region
	MOVL	sl_offset.B[EBP], EAX
	ADDL	EBX, #4.B		;Move to size of locked region
	MOVL	EAX, ES:[EBX]		;Get size of locked region
	MOVL	sl_size.B[EBP], EAX
	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;No - get FIB offset
;;;;;;;	MOVL	EDI, ff_lock.B[EDX]	;Get head of lock list
10$:	TESTL	EDI, EDI		;Check if any locks defined
	JE	30$.S			;Allocate new lock block

;Search existing lock blocks

	PUSHL	EDI
	ADDL	EDI, #fl_1st		;Point to first item in block
	PUSHL	ECX			;Save EBX, contains offset of lock data
	MOVL	ECX, #60t/fle_SIZE	;Set counter for block
20$:	CMPL	fle_dcb.b[EDI], #0	;Is this lock entry in use?
	JNE	25$
	POPL	EAX			;Done, clear stack
	POPL	EAX
	JMP	40$.S			;No - use it

25$:	ADDL	EDI, #fle_SIZE.B	;Size of a lock entry
	LOOP	ECX, 20$		;Go back around and do next entry
	POPL	ECX
	POPL	EDI			;Done, restore offset of block
	MOVL	EDI, fl_next.B[EDI]	;Get offset of next block
	JMP	10$.S			;And go process it

;Here to allocate new block for lock

30$:	CALL	knlGetQel##		;Get a QEL
	JC	50$.S			;Error getting QEL, return it
	PUSHL	ESI			;Save pointer to head of block
	MOVL	EDI, ESI
	PUSHL	DS			;Clear the block
	POPL	ES
	MOVL	ECX, #64t/4
	CLRL	EAX
	CLD
	RSTOSL	[EDI]
	POPL	EDI			;Restore pointer to block
	MOVL	EDX, [ESP]		;Restore DCB offset
	MOVL	EDX, dcb_dkfilepnt.B[EDX] ;Get FIB offset
;;;;;;;	MOVL	ECX, ff_lock.B[EDX]	;Get head of lock list
	MOVL	fl_next.B[EDI], ECX
;;;;;;;	MOVL	ff_lock.B[EDX], EDI	;Point head to new block
	ADDL	EDI, #fl_1st.B		;Adjust to first entry
40$:	LEAL	ESI, sl_begin.B[EBP]
	MOVL	ECX, #fle_SIZE/4	;Size of entry to copy
	PUSHL	DS
	POPL	ES
	CLD
	RMOVSL	[EDI], SS:[ESI]		;Copy new lock entry over
	CLRL	EAX
	CLC
50$:	POPL	EDI			;Restore offset of DCB
	LEAVE
	RET				;Return error from knlGetQel

.ENDC
.PAGE
;Here for the IOPAR_CLRLOCK parameter for clearing a XOS file lock.  This
;  parameter must be specified with 8 data bytes.  The first 4 bytes specify
;  the offset in the file of the start of the region to lock and the 2nd 4
;  bytes specify the length of the region to lock.  The offset and size must
;  EXACTLY match the values specified when the lock was set.

	DPARMHDR  SET, HEXV
xfsiopclrlock:

	CRASH	LOCK

.IF NE 0

	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter
	TESTB	AH, #PAR$SET		;Yes - want to set the value?
	JE	knlBadParmI##		;No
	CMPL	ECX, #8t.B		;Correct number of bytes?
	JNE	knlBadParmI##		;No - fail
	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Yes - get FIB offset
;;;;;;;	MOVL	ESI, ff_lock.B[EDX]	;Get head of lock list
5$:	TESTL	ESI, ESI		;Any locks defined?
	JE	30$.S			;No - return error
	PUSHL	ESI			;Save ptr to head of block
	ADDL	ESI, #fl_1st.B		;Point to first entry in block
	PUSHL	ECX
	MOVL	ECX, #60t/fle_SIZE	;# of entries in each block
10$:	MOVL	EAX, fle_offset.b[ESI]	;Get offset of this entry
	CMPL	EAX, ES:[EBX]		;Check against request
	JNE	20$.S			;Not this one
	MOVL	EAX, fle_size.B[ESI]	;Get size of region
	CMPL	EAX, ES:4.B[EBX]	;Check against request
	JNE	20$.S			;Not this one
	MOVW	AX, fle_pda.B[ESI]	;Get PDA selector
	CMPW	AX, SS:xffPda##		;Is the the requestor?
	JNE	20$.S			;No
	MOVL	FS, EAX			;Yes
	TESTB	FS:pdaStatus1##, #P1$DOSSEG ;Is this a DOS program?
	JE	15$.S			;No
	PUSHL	#GS_REAL16.B		;Yes
	POPL	FS			;Point to real mode segment
	MOVL	EAX, FS:dda_curpsp	;Get current PSP
	SHRL	EAX, #4.B		;Make into 16-bit value
15$:	CMPW	AX, fle_psp.B[ESI]	;Check against value in lock
	JNE	20$.S			;Doesn't match - not this lock
	CMPL	EDI, fle_dcb.B[ESI]	;Check against requestor DCB
	JE	40$.S			;Correct block - go kill it
20$:	ADDL	ESI, #fle_SIZE.B
	LOOP	ECX, 10$		;Go back around and check next block
	POPL	ECX
	POPL	ESI
	MOVL	ESI, fl_next.B[ESI]	;Point to next block
	JMP	5$.S			;And go process it

30$:	MOVL	EAX, #ER_LOCK		;Didn't find the requested lock
	STC
	RET

;Here with lock to remove

40$:	CLRL	EAX			;Obtain a zero
	MOVL	fle_offset.b[ESI],EAX	;Clear offset of region
	MOVL	fle_size.B[ESI], EAX	;Clear size of region
	MOVL	fle_dcb.B[ESI], EAX	;Clear DCB offset
	MOVL	fle_pda.B[ESI], EAX	;Clear PDA & PSP
	POPL	ECX			;Clean up stack
	POPL	ESI
	CLC
	RET
.ENDC
.PAGE
	.SBTTL	xfschklock - subroutine to check for a lock violation

.IF NE 0

;Subroutine to check for a lock violation
;	c{ECX} = Amount to transfer
;	c{EDI} = Offset of DCB
;	CALL	xfschklock
;	C:set  = Error (conflicting lock found)
;	  C{EAX} = Error code
;	C:clr  = No conflicting locks found

xfschklock:
	PUSHL	EBX			;Save this register
	MOVL	EBX, dcb_dkfpos.B[EDI]	;Get offset for transfer
	MOVB	AL, #1t			;Don't do strict lock checking
	CALL	xfschklock1
	POPL	EBX
	RET

;Internal subroutine to check for a lock violation
;	c(AL)  = Strict flag
;	c{ECX} = Amount
;	c{EBX} = Offset in file
;	c{EDI} = Offset of DCB
;	CALL	xfschklock
;	C:set  = Error (conflicting lock found)
;	  C{EAX} = Error code
;	C:clr  = No conflicting locks found

$$$=!0
FRM chl_strict, 1t	;Flag for strict lock checking
FRM           , 3t
FRM chl_xfersz, 4t	;Size of transfer
FRM chl_count , 4t	;Retry counter
chl_SIZE=!$$$

xfschklock1:
	ENTER	chl_SIZE, 0
	PUSHL	FS
	PUSHL	EDX
	MOVB	chl_strict.B[EBP], AL	;Save the strict flag for now
	MOVL	chl_xfersz.B[EBP], ECX	;Save size of transfer
	MOVZWL	EAX, dcb_dkshrrty.B[EDI] ;Initialize retry count
	MOVL	chl_count.B[EBP], EAX
6$:	MOVL	EDX, dcb_dkfilepnt.B[EDI] ;Get FIB offset
;;;;;;;	MOVL	EDX, ff_lock.B[EDX]	;Get head of lock list
10$:	TESTL	EDX, EDX		;Check if any locks defined
	JE	50$.S			;No - return success
	PUSHL	EDX
	ADDL	EDX, #fl_1st.B		;Point to first item in block
	PUSHL	ECX
	MOVL	ECX, #60t/fle_SIZE	;Set counter for block
20$:	CMPL	fle_dcb.B[EDX], #0	;Is this lock entry in use?
	JE	30$.S			;No - skip it
	MOVL	EAX, EBX		;Get offset in file
	SUBL	EAX, fle_offset.B[EDX]	;Is this a violation?
	JE	28$.S			;Yes - check PDA
	JL	25$.S			;Offset/lock follows offset/xfer
	CMPL	EAX, fle_size.B[EDX]	;Check if lock is before xfer
	JGE	30$.S			;Yes - xfer OK, check next lock
	JMP	28$.S			;No - check PDA for violation

;Here when offset of lock follows offset of xfer

25$:	NEGL	EAX			;Make into a positive value
	CMPL	EAX, chl_xfersz.B[EBP]	;Does xfer end before lock?
	JGE	30$.S			;Yes - xfer OK, check next lock

;Here when xfer overlaps lock - check ownership of lock

28$:	CMPB	chl_strict.B[EBP], #0	;Are we ignoring lock ownership?
	JE	60$.S			;Yes - report lock violation
	MOVW	AX, fle_pda.B[EDX]	;No - get PDA selector of lock owner
	CMPW	AX, SS:xffPda##		;Is this the owner?
	JNE	60$.S			;No - report lock violation
	MOVL	GS, EAX			;Get selector for PDA
	TESTB	GS:pdaStatus1##, #P1$DOSSEG ;Is it a DOS process?
	JE	29$.S			;No - use zero for PSP value
	PUSHL	#GS_REAL16.B		;Get selector for the real mode segment
	POPL	FS
	MOVL	EAX, FS:dda_curpsp	;Get offset of PSP
	SHRL	EAX, #4			;Make into 16-bit value
29$:	CMPW	AX, fle_psp.B[EDX]	;Check against PSP of lock
	JNE	60$.S
	CMPL	EDI, fle_dcb.B[EDX]	;Check against DCB of requestor
	JNE	60$.S			;No - report lock violation

;Here to check next lock

30$:	ADDL	EDX, #fle_SIZE.B	;Size of a lock entry
	LOOP	ECX, 20$		;Go back around and do next entry
	POPL	ECX
	POPL	EDX			;Done, restore offset of block
	MOVL	EDX, fl_next.B[EDX]	;Get offset of next block
	JMP	10$.S			;And go process it

;Here if no lock violation found

50$:	POPL	EDX
	POPL	FS
	CLRL	EAX
	LEAVE
	RET

;Here if lock violation found - we delay and try again if necessary

60$:	POPL	ECX			;Restore original ECX value
	POPL	EDX			;Restore offset of beginning of block
	MOVL	ESI, [EDI]
	DECL	chl_count.B[EBP]	;Should we try again?
	JS	64$.S			;No - fail!
	INCL	ucb_shrretry[ESI]	;Yes - count this
	MOVZWL	EAX, dcb_dkshrdly.B[EDI] ;Get the amount to delay
	IMULL	EAX, #XT_MILLISEC	;Change to fractional days
	IMULL	EAX, ucb_shrdelay.B[ESI] ;Adjust the value
	CALL	knlXfTimeWait##		;Delay that long
	JNC	6$			;Continue if OK

;Here if we have tried this enough or if have error while waiting - return
;  failure

64$:	INCL	ucb_shrfail[ESI]	;Count the failure
	POPL	EDX			;Restore original EDX value
	POPL	FS
	MOVL	EAX, #ER_LOCK		;Lock violation
	STC
	LEAVE

.ENDC

ret020:	RET
.PAGE
;Here for the IOPAR_SHRPARMS parameter.  This parameter sets or gets the share
;  retry parameters for the file.

	DPARMHDR  BOTH, DECV
xfsiopshrparms:
	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter
	TESTB	AH, #PAR$SET		;Yes - want to change the value?
	JE	12$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get new value
	JC	retpbx
	CMPW	AX, #0FFFFFFFFh.B	;Want default for process?
	JNE	2$.S			;No
	MOVW	ES, SS:xffPda##
	MOVW	AX, ES:pdaShrRetry##
2$:	CMPW	AX, #64t.B		;Too big?
	JB	4$.S			;No
	MOVW	AX, #64t		;Yes - reduce it to a reasonable value
4$:	RORL	EAX, #16t
	CMPW	AX, #0FFFFFFFFh.B	;Want default for process?
	JNE	6$.S			;No
	MOVW	ES, SS:xffPda##
	MOVW	AX, ES:pdaShrDelay##
6$:	CMPW	AX, #10t.B		;Too small?
	JA	8$.S			;No
	MOVB	AL, #10t		;Yes - increase it
8$:	CMPW	AX, #5000t		;Too big?
	JB	10$.S			;No
	MOVW	AX, #5000t		;Yes - reduce it to a reasonable value
10$:	RORL	EAX, #16t
	MOVL	dcb_dkshrrty.B[EDI], EAX ;Store new value
	POPL	EAX
12$:	TESTB	AH, #PAR$GET		;Want to get the value?
	JE	ret020.S		;No - finished
	MOVL	EAX, dcb_dkshrrty.B[EDI] ;Yes
	JMP	knlStrParm4##		;Go give it to the user
.PAGE
	.SBTTL	xfschk1 - File system check routine 1 for XOS file system

;File system check routine 1 for XOS file system - this routine is called
;  during the first file system identification scan.  It will only accept a
;  disk as containing a XOS file system if the partition type is a valid
;  XOS partition type and the and home blocks are minimally valid or if the
;  disk is not partitioned and the boot and home blocks are minimally valid.
;	c{EDI} = Offset of DCB
;	CALL	xfschk1
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EAX} = 0
;	  Z:clr = Not found

;Define stack frame offsets for this routine

xfschk1::
	MOVL	ESI, [EDI]		;Point to the UCB
	TESTL	ESI, ESI
	JE	knlNoUnitLv##
	CMPL	ucb_baseucb.B[ESI], #0.B ;Is this a partition?
	JE	4$.S			;No
	CMPB	ucb_fstype.B[ESI], #FS_XFS ;Yes - is this an XFS partition?
	JNE	notxfs3			;No

;Here if have an XOS partition or if the disk is not partitioned - check the
;  boot and home blocks

4$:	CLRL	EAX			;Read the boot block
	MOVL	dcb_dkdblk.B[EDI], EAX
	CLRL	EDX
	CALL	xosdskFindSBufr##
	JC	notxfs3			;If error
	PUSHL	ucb_csects.B[ESI]	;OK - save current disk configuration
	PUSHL	ucb_cheads.B[ESI]
	PUSHL	ucb_ccylns.B[ESI]
	CMPW	xb_btsig[EBX], #0AA55h	;Check for valid signature
	JNE	6$.S
	CMPL	xb_jump+4.B[EBX], #0.B
	JNE	6$.S
	CMPL	xb_xfssig+0.B[EBX], #'XOS*'
	JNE	6$.S
	CMPL	xb_xfssig+4.B[EBX], #'*XFS'
	JNE	6$.S
	CMPW	xb_sectsz.B[EBX], #512t	;Sector size must be 512
6$:	JNE	notxfs1
	MOVZWL	EAX, xb_heads.B[EBX]	;Get number of heads
	TESTL	EAX, EAX		;Cannot be 0
	JE	8$.S
	MOVL	ucb_cheads.B[ESI], EAX
	MOVZWL	EAX, xb_sects.B[EBX]	;Get number of sectors per track
	TESTL	EAX, EAX		;Cannot be 0
	JE	8$.S
	MOVL	ucb_csects.B[ESI], EAX
	MOVL	EAX, xb_cylns.B[EBX]	;Get number of cylinders
	TESTL	EAX, EAX		;Cannot be 0
8$:	JE	notxfs1
	MOVL	ucb_ccylns.B[ESI], EAX	
	CALL	xosdskGiveLkBufr##	;Give up the boot block buffer
	MOVL	EAX, xb_homblk		;Read the home block
	MOVL	dcb_dkdblk.B[EDI], EAX
	CLRL	EDX
	CALL	xosdskFindSBufr##
	JC	notxfs2

;Here with the home block read

	CMPL	[EBX], #'HOM*'		;Check the block header
	JNE	6$.S
	MOVL	EAX, hom_self+0.B[EBX]
	ADDL	EAX, ucb_partnoff.B[ESI]
	CMPL	EAX, dcb_dkdblk.B[EDI]
	JNE	6$.S
	CMPL	hom_self+4.b[EBX], #0.B
	JNE	6$.S
	MOVZBL	EAX, hom_pntsize.B[EBX]	;Get the size of a FIB pointer
	CMPL	EAX, #2.B		;Make sure a valid value
	JB	notxfs1
	CMPL	EAX, #4.B
	JA	notxfs1
	MOVL	ucb_pntsize.B[ESI], EAX	;OK - store value
	MOVZWL	EAX, hom_clussize.B[EBX] ;Get sectors per cluster
	MOVL	ucb_clussize.B[ESI], EAX
	BSFL	EDX, EAX		;Determine shift count
	SHLL	EAX, #9t		;Calculate bytes per cluster
	MOVL	ucb_bpclus.B[ESI], EAX	;Save it
	MOVB	ucb_clusx.B[ESI], DL	;Save shift count
	MOVL	EAX, hom_firstclus.B[EBX] ;Get block number for first cluster
	MOVL	ucb_fcblk.B[ESI], EAX
	MOVL	EAX, hom_numclus.B[EBX]	;Get number of clusters
	MOVL	ucb_total.B[ESI], EAX
	MOVL	EAX, hom_grpsize.B[EBX]	;Get default group size for this disk
	TESTL	EAX, EAX
	JNE	10$.S
	INCL	EAX
10$:	MOVL	ucb_grpsize.B[ESI], EAX
	MOVZWL	EDX, hom_numsats.B[EBX]	;Get number of SATs
	TESTL	EDX, EDX		;Must not be 0!
	JE	notxfs1
	MOVL	ucb_numsat.B[ESI], EDX
	SHLL	EDX, #2t		;Allocate a block for the SAT table
	CALL	knlGetIndex##
	JC	notxfs1
	MOVB	ucb_sattblx.B[ESI], CL
	PUSHL	ESI
	CALL	knlGetXmb##
	MOVL	EDX, ESI
	POPL	ESI
	JC	notxfs1
	MOVL	ucb_sattbl.B[ESI], EDX
	PUSHL	EDI			;Store the SAT table
	PUSHL	ESI
	MOVL	ECX, ucb_numsat.B[ESI]
	MOVL	EDI, EDX
	PUSHL	DS
	POPL	ES
	LEAL	ESI, hom_sattbl.B[EBX]
	CLD
	RMOVSL	[EDI], [ESI]
	POPL	ESI
	POPL	EDI
	PUSHL	hom_root.B[EBX]		;Get cluster for root directory FIB
	CALL	xosdskGiveLkBufr##	;Give up the home block buffer
	POPL	EAX			;Read the root directory FIB
	IMULL	EAX, ucb_clussize.B[ESI]
	ADDL	EAX, ucb_partnoff.B[ESI]
	MOVL	dcb_dkdblk.B[EDI], EAX
	CLRL	EDX
	CALL	xosdskFindSBufr##
	JC	notxfs2
	CMPL	[EBX], #'FIB*'
	JNE	12$.S
	MOVL	EAX, fib_self+0.B[EBX]
	ADDL	EAX, ucb_partnoff.B[ESI]
	CMPL	EAX, dcb_dkdblk.B[EDI]
	JNE	12$.S
	CMPL	fib_self+4.B[EBX], #0.B
12$:	JNE	notxfs1
	MOVL	ucb_rootpnt.B[ESI], EBX
	CALL	xosdskUnlkBufr##	;Unlock the buffer, but keep it so it
					;  will stay around as long as the disk
					;  is mounted

;Here with all information about the structure read from the disk - how
;  scan the SAT blocks and calculate the number of free blocks

	MOVL	ucb_satraa.B[ESI], #7FFFFFFFh ;Read-ahead as much as possible
	TESTB	ucb_bits.B[ESI], #UB$REMOVE ;Is this disk removeable?
	JE	16$.S			;No - don't bother with a checksum
	PUSHL	#0.B			;Yes - checksum the first 4 SAT blocks
	MOVL	EDX, #ucb_fat1cs
14$:	MOVL	EAX, [ESP]
	CALL	xfsgetsatblock#
	JC	20$.S
	CALL	xfsblkcs		;Calculate block checksum
	MOVL	[ESI+EDX], EAX		;Store checksum in UCB
	CALL	xosdskGiveLkBufr##	;Give up the SAT block buffer
	ADDL	[ESP], #4000t
	ADDL	EDX, #4.B
	CMPL	EDX, #ucb_fat4cs	;Finished?
	JB	14$.S			;No - continue
	ADDL	ESP, #4t.B
16$:	CLRL	EAX			;Clear total
	MOVL	ucb_avail.B[ESI], EAX	;Clear amount available on disk
	PUSHL	EAX
18$:	CALL	xfsgetsatblock#		;Read the next SAT block
20$:	JC	notxfs0
	LEAL	EDX, sat_data.B[EBX]	;Set up to scan it
	MOVL	ECX, #500t
22$:	MOVZBL	EAX, [EDX]		;Get next byte
	INCL	EDX
	MOVB	AL, bitstbl[EAX]	;Get number of 0 bits
	ADDL	ucb_avail.B[ESI], EAX
	LOOP	ECX, 22$		;Continue if more bytes in the SAT block
	CALL	xosdskGiveLkBufr##	;Give up the SAT block buffer
	ADDL	[ESP], #4000t 		;Increase cluster number
	MOVL	EAX, [ESP]
	CMPL	EAX, ucb_total.B[EBP]	;More SATs to scan?
	JB	18$.S			;Yes - continue
	ADDL	ESP, #4t.B
	TESTB	ucb_bits.B[ESI], #UB$REMOVE ;Is this disk removeable?
	JE	26$.S			;No - don't bother with a checksum
	MOVL	EBX, ucb_rootpnt.B[ESI]	;Yes - read first block of the root
	CALL	xfsgetfilepntr#
	TESTL	EAX, EAX
	JE	notxfs2
	IMULL	EAX, ucb_clussize.B[ESI]
	ADDL	EAX, ucb_partnoff.B[ESI]
	MOVL	dcb_dkdblk.B[EDI], EAX
	CLRL	EDX
	CALL	xosdskFindSBufr##
	JC	notxfs2
	CALL	xfsblkcs		;Calculate checksum for this block
	MOVL	ucb_root1cs[ESI], EAX	;Store it
	CALL	xosdskRelsLkBufr##	;Release the buffer

26$:

	ORB	ucb_sts1.B[ESI], #U1$MOUNT ;Indicate disk is mounted now
	MOVL	EAX, #xfsdsp		;Use the XFS dispatch tables
	MOVL	ucb_sdisp.B[ESI], EAX
	MOVL	ucb_unmount.B[ESI], #xfsunmount
	MOVL	EDX, #DS$FILE|DS$NAMEEXT|DS$ALIAS|DS$SODIR|DS$NOABORT|DS$LCLDISK|DS$QIN|DS$QOUT
	TESTB	ucb_bits.B[ESI], #UB$REMOVE
	JE	42$.S
	BTSL	EDX, #DS%REMOVE
42$:	MOVL	ucb_dsp.B[ESI], EDX
	TESTL	SS:xffCmd#, #O$PHYS|O$RAW ;Physical IO?
	JNE	44$.S			;Yes
	MOVL	dcb_sdisp.B[EDI], EAX	;No - update DCB pointer and bits
	MOVL	dcb_dsp.B[EDI], EDX
	JMP	46$.S

44$:	TESTB	ucb_bits.B[ESI], #UB$REMOVE
	JE	46$.S
	BTSL	dcb_dsp.B[EDI], #DS%REMOVE
46$:	CLRL	EAX			;Set Z to indicate have XFS disk
	LEAVE
	RET
.PAGE
;Here if this is not an XFS disk

notxfs0:MOVZBL	ECX, ucb_sattblx.B[ESI]
	PUSHL	ESI
	MOVL	ESI, ucb_sattbl.B[ESI]
	CALL	knlGiveXmb##
	POPL	ESI
	MOVL	ucb_sattbl.B[ESI], #0
	JMP	notxfs2.S

notxfs1:CALL	xosdskGiveLkBufr##	;Give up the buffer we were using
notxfs2:POPL	ucb_ccylns.B[ESI]	;Restore previous disk configuration
	POPL	ucb_cheads.B[ESI]
	POPL	ucb_csects.B[ESI]
notxfs3:MOVL	EBX, ucb_rootpnt.B[ESI]
	TESTL	EBX, EBX
	JE	4$.S
	CALL	xosdskGiveUnlkBufr##
4$:	CLRL	EAX
	MOVL	ucb_satraa.B[ESI], EAX	;No more FAT read-ahead
	MOVL	ucb_total.B[ESI], EAX	;Clear file structure related data
	MOVL	ucb_avail.B[ESI], EAX
	MOVL	ucb_satsize.B[ESI], EAX
	MOVL	ucb_ffatblk.B[ESI], EAX
	MOVB	ucb_fstype.B[ESI], AL
	MOVB	ucb_fatmode.B[ESI], AL
	MOVL	ucb_fsname+0[ESI], EAX
	MOVL	ucb_fsname+4[ESI], EAX
	MOVB	ucb_clusx.B[ESI], AL
	MOVL	ucb_clussize.B[ESI], EAX
	MOVL	ucb_bpclus.B[ESI], EAX
	MOVL	ucb_highcl.B[ESI], EAX
	MOVL	ucb_rootpnt.B[ESI], EAX
	MOVL	ucb_numsat.B[ESI], EAX
	MOVL	ucb_fcblk.B[ESI], EAX
	MOVL	ucb_grpsize.B[ESI], EAX
	TESTL	EDI, EDI		;Clear Z to indicate not an XFS disk!
	LEAVE
	RET
.PAGE
	.SBTTL	xfsblkcs - Subroutine to calculate XFS block checksum

;Subroutine to calculate XOS block checksum - this value is only used to
;  determine if a removeable disk has been changed
;	c{EBX} = Offset of buffer containing block
;	CALL	xfsblkcs
;	c{EAX} = Checksum value
;  EDX and ESI are respected

xfsblkcs::
	MOVL	ECX, #512t/4
	PUSHL	EDX
	PUSHL	ESI
	CLRL	EDX
	MOVL	ESI, EBX
	CLD
2$:	LODSL	[ESI]
	RORL	EDX, #1
	XORL	EDX, EAX
	LOOP	ECX, 2$
	MOVL	EAX, EDX
	POPL	ESI
	POPL	EDX
	RET
.PAGE
	.SBTTL	xfschk2 - File system check routine 2 for XOS file system

;File system check routine 2 for XOS file system - this routine is called
;  during the second file system identification scan.  Since we demand that
;  an XOS file system have a minimally correct boot block, this routine
;  always returns failure.
;	c{EDI} = Offset of DCB
;	CALL	xfschk2
;	Z:clr = Always

xfschk2::
	TESTL	EDI, EDI		;Clear Z to indicate failure
	RET
.PAGE
	.SBTTL	xfsvfychg - Verify changed disk

;Here for the verify changed disk entry (dd_chkchg) - this routine is called
;  for XOS file structured disks only
;	c{EDI} = Offset of DCB
;	CALL	xfsvfychg
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfsvfychg:
	CALL	xosdskGetSBufr##	;Get a system buffer
	JC	6$.S			;If error
	MOVW	cb_lockxff.B[EBX], SS	;Lock the buffer (this is needed since
	INCL	SS:xffLockCnt##		;  xosdskReadBufr expects a locked
					;  buffer - it serves no other purpose)
	CLRL	EAX			;Read the boot block
	MOVL	dcb_dkdblk.B[EDI], EAX
	CALL	xosdskReadBufr##
	JC	6$.S			;If error (buffer given up)

;CODE GOES HERE TO CHECK VOLUME ID AND OTHER THINGS IN BOOT BLOCK!!!

	MOVL	EAX, ucb_ffatblk.B[ESI]	;Get the first FAT block
	MOVL	dcb_dkdblk.B[EDI], EAX
	LEAL	EDX, ucb_fat1cs[ESI]
	MOVL	ECX, ucb_numsat.B[ESI]	;Get number of FAT blocks
	CMPL	ECX, #4.B		;Have more than 4?
	JBE	4$.S			;No
	MOVL	ECX, #4			;Yes - just check 4
4$:	PUSHL	ECX
	PUSHL	EDX
	CALL	xosdskReadBufr##
	POPL	EDX
	JC	8$.S			;If error (buffer given up)
	CALL	xfsblkcs		;Calculate block checksum
	POPL	ECX
	CMPL	[EDX], EAX		;Is it the same?
	JNE	12$.S			;No - different disk!
	ADDL	EDX, #4.B		;Bump pointer
	INCL	dcb_dkdblk.B[EDI]	;Bump disk block number
	LOOP	ECX, 4$			;Continue if more to check
	MOVL	EAX, ucb_rootblk.B[ESI]	;Get first block of the root directory
	MOVL	dcb_dkdblk.B[EDI], EAX
	CALL	xosdskReadBufr##
	JC	16$.S
	CALL	xfsblkcs		;Calculate checksum for this block
	CMPL	ucb_root1cs[ESI], EAX	;Is it the same?
	JNE	12$.S			;No - assume disk changed
	CALL	xosdskGiveLkBufr##	;Give up the buffer
	CLRL	EAX			;Set Z to indicate not changed
6$:	RET

;Here if error

8$:	POPL	ECX
	JMP	16$.S

;Here if disk has been changed

12$:	CALL	xosdskGiveLkBufr##	;Give up our buffer
14$:	MOVL	EAX, #ER_MDCHG
16$:	PUSHL	EAX
	CALL	xosdskChanged##		;Unmount the disk
	POPL	EAX
	STC
	RET
.PAGE
	.SBTTL	xfsunmount - Unmount XOS file structured disk

;Here for the unmount disk entry - this routine removes all of knowledge of
;  a disk from the system without attempting to read or write to the disk
;  - it is normally called when it is determined that a removable disk has
;  been changed or when a serious IO error occures (such as an error when
;  updating the FAT blocks) - all buffers for the disk are unhashed - if
;  they are not in use, they are given up, if they are in use, they are
;  marked with an error (ER_MDCHG or ER_???)
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of UCB
;	c{EAX} = Error code for in use buffers
;	CALL	xfsunmount
;  EAX is preserved

xfsunmount::
	PUSHL	EAX			;Save error code
	MOVB	ucb_fstype.B[ESI], #0	;Indicate unknown disk type
	MOVL	ucb_fsname+0[ESI], #'NONE'
	CLRL	EAX
	MOVL	ucb_fsname+4[ESI], EAX
	MOVL	EBX, ucb_rootpnt.B[ESI]	;Get offset of the root FIB
	CALL	xosdskGiveBufr##	;Give it up (use count must be at least
					;  2 here so this does not really give
	MOVL	ucb_rootpnt.B[ESI], #0	;  it up!)
	POPL	EAX			;Restore error code to use
	JMP	xosdskUnmount##		;Go finish up
.PAGE
	.SBTTL	xfsunitinfo - XOS file system get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  XOS file system class to return detailed device information - For the XOS
;  file system, this consists of the complete path and name of the open file.
;	c{ECX}    = Size of buffer
;	c{ES:EDI} = Address of user buffer
;	c{ESI}    = Offset of DCB
;	CALL	xosdskunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count

xfsinfo:CLRL	EDX
	MOVL	ESI, dcb_dkspecbfr.B[ESI] ;Get offset of the file specification
	DECL	ECX			  ;  buffer
	JS	4$.S
	MOVZWL	EAX, [ESI]		;Get length of the file specification
	CMPL	ECX, EAX
	JLE	2$.S
	MOVL	ECX, EAX
2$:	MOVL	EAX, ECX
	ADDL	ESI, #2t.B
	JREGZ	ECX, 4$
	CLD
	IFFAULT	knlRtnAdrEr##
	RMOVSB	[EDI], [ESI]
	IFFAULT	knlRtnAdrEr##
	MOVB	ES:[EDI], #0
4$:	CLC
	RET
.PAGE
	.SBTTL	xfsinpblk - Queued input block

;Here for the sd_qinpblk entry - Input block
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	CALL	xfsinpblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfsinpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock the input buffer
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfsinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

4$:	CLRL	EAX
6$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

;Here in extended fork context

xfsinpblk1:
.IF NE $$CHKCHAIN
	CALL	checkchain#
.ENDC
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	8$.S			;No
	MOVL	EBX, #xfsioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	6$.S			;If error
8$:	MOVL	ECX, SS:xffCount##	;Get count
	JREGZ	ECX, 4$
	BTL	SS:xffCmd##, #O%IN	;Input allowed?
	JNC	knlIllInp##		;No - fail
;;;;;;;	CALL	xfschklock		;Check if a lock violation
;;;;;;;	JC	6$.S			;Yes - fail
	MOVL	EBX, dcb_dkfilepnt.B[EDI]
	CALL	xosdskLockBufrW##	;Lock the file
	LESL	EBX, SS:xffBuffer1##	;Get address of buffer
	MOVL	ESI, #xfsrdpos#		;Get offset of disk address calculate
					;  subroutine
	CALL	xosdskRead##		;Do the transfer
	JC	10$.S
	CLRL	EAX
10$:	MOVL	EBX, dcb_dkfilepnt.B[EDI]
	CALL	xosdskUnlkBufr##	;OK - unlock file and return
.IF NE $$CHKCHAIN
	CALL	checkchain#
.ENDC
	MOVL	EBX, #QSTS$DONE
12$:	RET
.PAGE
	.SBTTL	xfsoutstr - Output null terminated string

;Here for the sd_outstring entry - output null terminated string
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	CALL	xfsoutstr
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfsoutstr:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoStringLock##	;Lock output string
	JNC	4$.S			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	xfsoutblk - Output block

;Here for the sd_outblock entry - output block
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	CALL	xfsoutblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfsoutblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock the output buffer
	JC	2$.S			;If error
4$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfsoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context

6$:	CLRL	EAX
8$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

;Here in extended fork context

xfsoutblk1:
.IF NE $$CHKCHAIN
	CALL	checkchain#
.ENDC
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	10$.S			;No
	MOVL	EBX, #xfsioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	8$.S			;If error
10$:	MOVL	ECX, SS:xffCount##	;Get count
	JREGZ	ECX, 6$
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Is this a directory, a label, or a
					  ;  read-only file?
	TESTB	fib_attrib.B[EBX], #A$DIRECT|A$LABEL|A$RDONLY
	JNE	knlIllOut#		;Yes - can't do this!
	BTL	SS:xffCmd##, #O%OUT	;No - output allowed?
	JNC	knlIllOut##		;No - fail
;;;;;;;	CALL	xfschklock		;Yes - does this violate a record lock?
;;;;;;;	JC	8$.S			;Yes - return error
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;No - lock the file
	CALL	xosdskLockBufrW##
	BTL	SS:xffCmd##, #O%FAPPEND	;Force append?
	JNC	12$.S			;No - go on
	MOVL	EAX, fib_size.B[EBX]	;Yes - set IO position to EOF
	MOVL	dcb_dkfpos.B[EDI], EAX
12$:	ORB	fib_status.B[EBX], #FS$MODIFIED ;Indicate file modified
	LESL	EBX, SS:xffBuffer1##	;Get address of buffer
	CALL	xfswrite		;Do the transfer
	JC	14$.S			;If error
	CLRL	EAX			;OK
14$:	MOVL	EBX, dcb_dkfilepnt.B[EDI]
	CALL	xosdskUnlkBufr##	;Unlock the file
.IF NE $$CHKCHAIN
	CALL	checkchain#
.ENDC
	MOVL	EBX, #QSTS$DONE
	RET
.PAGE
	.SBTTL	xfswrite - Subroutine to write data to the disk

2$:	LEAVE
	RET

;Subroutine to write data to the disk
;	c{ECX}    = Number of bytes to write
;	c{ES:EBX} = Buffer address
;	c{EDI}    = Offset of DCB
;	CALL	xfswrite
;	c{ECX} = Number of bytes written
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

$$$=!0
FRM wr_bufr  , 8t	;Data buffer address
FRM wr_done  , 4t	;Amount transfered
FRM wr_tamnt , 4t	;Amount to transfer
FRM wr_aamnt , 4t	;Amount available at current position in file
FRM wr_xamnt , 4t	;Amount to extend file
FRM wr_ramnt , 4t	;Amount really available when extending
FRM wr_begin , 4t	;Disk block number for first buffer in list
FRM wr_head  , 4t	;Offset of first buffer in list
FRM wr_tail  , 4t	;Offset of last buffer in list
FRM wr_last  , 4t	;Offset of last buffer filled
FRM wr_endpnt, 4t	;Last pointer used to fill last block
FRM wr_blocks, 4t	;Total blocks to output each time
FRM wr_actual, 4t	;Actual amount output each time (does not include parts
wr_SIZE=!$$$		;  of first or last block not filled by user)

xfswrite:
	MOVL	EAX, [EDI]		;Get UCB offset
	TESTL	EAX, EAX
	JE	knlNoUnit##		;If no UCB
	TESTB	ucb_sts1.B[EAX], #U1$WPROT ;Is the disk write protected?
	JNE	knlWPrErr##		;Yes - fail
	ENTER	wr_SIZE, 0		;No - setup a stack frame
	MOVL	wr_tamnt.B[EBP], ECX	;Save amount wanted
	MOVL	wr_bufr+0.B[EBP], EBX	;Save buffer address
	MOVL	wr_bufr+4.B[EBP], ES
	CLRL	EAX			;Initialize some local items:
	MOVL	wr_actual.B[EBP], EAX	;  Amount transfered each time
	MOVL	wr_done.B[EBP], EAX	;  Total amount transfered
	MOVL	wr_head.B[EBP], EAX	;  Buffer list head pointer
	MOVL	wr_tail.B[EBP], EAX	;  Buffer list tail pointer
	MOVL	wr_last.B[EBP], EAX	;  Pointer to last buffer filled
	MOVL	wr_blocks.B[EBP], EAX	;  Number of blocks to output
	MOVL	wr_endpnt.B[EBP], EAX	;  Ending pointer
	MOVL	ESI, [EDI]		;Get offset of our UCB
	TESTL	ESI, ESI
	JE	knlNoUnitLv##
	MOVL	EBX, dcb_dkpbfr.B[EDI]	;Get offset of pending write buffer
	TESTL	EBX, EBX
	JE	4$.S			;If none
	CALL	xosdskLockBufrW##	;Lock it
	JC	xfswrtdone		;If error
4$:	CLRL	EAX
	MOVL	wr_xamnt.B[EBP], EAX
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Point to base FIB
	MOVL	EAX, dcb_dkfpos.B[EDI]	;Get desired position
	SUBL	EAX, fib_mxsz.B[EBX]	;Past end of maximum written extent?
	JBE	xfswrt2			;No
	MOVL	wr_xamnt.B[EBP], EAX	;Yes - store amount to extend file
xfsxtdlp:
	MOVL	EAX, fib_mxsz.B[EBX]	;Set position in file to end of written
	MOVL	dcb_dkfpos.B[EDI], EAX	;  extent
	CALL	xfswrpos#		;Get disk address
	JC	16$.S			;If error
	MOVL	ESI, [EDI]		;Make sure have offset of UCB
	TESTL	ESI, ESI
	JE	knlNoUnitLv##
	MOVL	wr_ramnt.B[EBP], ECX	;Remember the real amount in case want
					;  write after we are done zeroing
	CMPL	ECX, wr_xamnt.B[EBP]	;Is more available than we need?
	JBE	6$.S			;No
	MOVL	ECX, wr_xamnt.B[EBP]	;Yes
6$:	MOVL	EAX, xosdskDBufCnt##
	SHRL	EAX, #1			;Get 1/2 of available buffers
	CMPL	EAX, ucb_wtmax[ESI]	;Is this more than we can use?
	JBE	8$.S			;No
	MOVL	EAX, ucb_wtmax[ESI]	;Yes - just use maximum
8$:	SHLL	EAX, #9			;Change to bytes
	MOVL	EBX, dcb_dkfpos.B[EDI]
	ANDL	EBX, #1FFh
	SUBL	EAX, EBX
	CMPL	ECX, EAX
	JBE	10$.S
	MOVL	ECX, EAX
10$:	MOVL	wr_aamnt.B[EBP], ECX

;Here to fill next buffer

12$:	MOVL	ECX, #200h		;Get amount to zero in this block
	SUBL	ECX, EBX
	CMPL	ECX, wr_aamnt.B[EBP]	;More than we need?
	JBE	14$.S			;No
	MOVL	ECX, wr_aamnt.B[EBP]	;Yes - just get what we need

14$:	CALL	getwriteblk		;Get buffer for block
16$:	JC	xfswrterr		;If error
	JNE	xfswrt4			;If must stop here
	MOVL	EAX, dcb_dkfpos.B[EDI]
	ANDL	EAX, #1FFh
	ADDL	dcb_dkfpos.B[EDI], ECX	;Bump position in file
	PUSHL	EDI
	LEAL	EDI, [EBX+EAX]
	ORB	cb_sts.B[EBX], #CB$FULL|CB$CHNGD ;Make sure block is marked as
	PUSHL	DS				 ;  dirty
	POPL	ES
	SUBL	wr_xamnt.B[EBP], ECX	;Reduce total amount to zero
	SUBL	wr_ramnt.B[EBP], ECX	;Reduce real amount left at this point
	SUBL	wr_aamnt.B[EBP], ECX	;Reduce amount available at this point
	CLRL	EAX
	CLD
	CMPL	ECX, #4.B		;Have fewer than 4 bytes to zero?
	JB	20$.S			;Yes
	MOVL	EDX, ECX		;No - first zero enough bytes to long
	MOVL	ECX, EDI		;  align the destination
	NEGL	ECX
	ANDL	ECX, #03.B
	SUBL	EDX, ECX
	RSTOSB	[EDI]
	MOVL	ECX, EDX		;Next zero as many longs as we can
	SHRL	ECX, #2
	RSTOSL	[EDI]
	MOVL	ECX, EDX		;Finally, zero any bytes left over
	ANDL	ECX, #03.B
20$:	RSTOSB	[EDI]
	MOVL	wr_endpnt.B[EBP], EDI
	LEAL	EAX, -512t[EDI]
	POPL	EDI
	CMPL	EAX, EBX		;Did we zero to the end of the block?
	JB	xfswrt4			;No - must be finished zeroing
	INCL	dcb_dkdblk.B[EDI]	;Yes - bump block on disk
	CMPL	wr_aamnt.B[EBP], #0.B	;More to do here?
	JE	24$.S			;No
	MOVL	EAX, wr_blocks.B[EBP]	;Yes - can we do more now?
	CMPL	EAX, ucb_wtmax[ESI]
	JAE	xfswrt4			;No
	CMPL	xosdskDBufCnt##, #3t.B	;Yes - at least 3 buffers available?
	JB	xfswrt4			;No - stop now
	CLRL	EBX
	JMP	12$

;Here if nothing more to extend in current extent

24$:	CMPL	wr_xamnt.B[EBP], #0.B	;Still more to extend?
	JNE	xfswrt4			;Yes - go write out what we have so far

	CMPL	wr_ramnt.B[EBP], #0.B	;Any space left to write data here?
	JE	xfswrt4			;No
	MOVL	ECX, wr_ramnt.B[EBP]	;Yes
	JMP	xfswrt3.S		;Continue
.PAGE
;Here when ready to start write to file - note that we have have already
;  set up some zeroed (or partly zeroed) buffers if we have to extend the
;  file before the start of this write

xfswrt2:CMPL	wr_tamnt.B[EBP], #0.B	;Really want to write anything?
	JE	xfswrt4			;No
xfswrtlp:
	CALL	xfswrpos#		;Calculate disk address
	JC	20$.S			;If error
	MOVL	ESI, [EDI]		;Make sure have offset of UCB
	TESTL	ESI, ESI
	JE	knlNoUnitLv##
xfswrt3:CMPL	ECX, wr_tamnt.B[EBP]	;Is more available than we want?
	JBE	4$.S			;No
	MOVL	ECX, wr_tamnt.B[EBP]	;Yes
4$:	MOVL	EDX, dcb_dkfpos.B[EDI]	;Get starting offset in block
	ANDL	EDX, #1FFh
	ADDL	ECX, EDX		;Adjust count
	MOVL	EAX, xosdskDBufCnt##
	SHRL	EAX, #1			;Get 1/2 of available buffers
	CMPL	EAX, ucb_wtmax[ESI]	;Is this more than we can use?
	JBE	6$.S			;No
	MOVL	EAX, ucb_wtmax[ESI]	;Yes - just use maximum
6$:	SUBL	EAX, wr_blocks.B[EBP]	;Minus amount from zeroing
	JG	8$.S
	MOVL	EAX, #1
8$:	SHLL	EAX, #9			;Change to bytes
	CMPL	ECX, EAX
	JBE	10$.S
	MOVL	ECX, EAX
10$:	SUBL	ECX, EDX
	MOVL	wr_aamnt.B[EBP], ECX
	MOVL	ECX, #512t		;Get amount to transfer from this block
	SUBL	ECX, EDX

;Here to fill next buffer
;	c{ECX} = Amount to transfer

12$:	CMPL	ECX, wr_aamnt.B[EBP]	;More than we want?
	JB	16$.S			;No
	MOVL	ECX, wr_aamnt.B[EBP]	;Yes - just get what we want
16$:	MOVL	EBX, wr_last.B[EBP]	;Do we already have the block we need?
	TESTL	EBX, EBX
	JE	18$.S			;No
	MOVL	EAX, dcb_dkdblk.B[EDI]	;Maybe
	CMPL	EAX, cb_block.B[EBX]
	JE	22$.S			;Yes
18$:	CALL	getwriteblk
20$:	JC	xfswrterr
	JNE	xfswrt4
22$:	MOVL	EAX, dcb_dkfpos.B[EDI]
	ANDL	EAX, #1FFh
	ADDL	dcb_dkfpos.B[EDI], ECX	;Bump position in file
	PUSHL	EDI
	LEAL	EDI, [EBX+EAX]
	ORB	cb_sts.B[EBX], #CB$FULL|CB$CHNGD ;Make sure block is marked as
	PUSHL	ESI				 ;  dirty
	PUSHL	DS
	POPL	ES
	LFSL	ESI, wr_bufr.B[EBP]
	ADDL	wr_bufr.B[EBP], ECX	;Bump position for next time around
	SUBL	wr_tamnt.B[EBP], ECX	;Reduce amount to go
	SUBL	wr_aamnt.B[EBP], ECX
	ADDL	wr_actual.B[EBP], ECX	;And increase amount done
	CLD
	CMPL	ECX, #4.B		;Have fewer than 4 bytes to copy?
	JB	24$.S			;Yes
	MOVL	EAX, ECX		;No - first copy enough bytes to long
	MOVL	ECX, EDI		;  align the destination
	NEGL	ECX
	ANDL	ECX, #03.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], FS:[ESI]
	MOVL	ECX, EAX		;Next copy as many longs as we can
	SHRL	ECX, #2
	RMOVSL	[EDI], FS:[ESI]
	MOVL	ECX, EAX		;Finally, copy any bytes left over
	ANDL	ECX, #03.B
24$:	RMOVSB	[EDI], FS:[ESI]
	MOVL	wr_endpnt.B[EBP], EDI
	POPL	ESI
	POPL	EDI
	INCL	dcb_dkdblk.B[EDI]	;Bump block on disk
	CMPL	wr_aamnt.B[EBP], #0.B	;More available here?
	JE	xfswrt4.S		;No
	MOVL	ECX, #512t		;Yes - get size for next block
	CMPL	xosdskDBufCnt##, #3t.B	;Yes - at least 3 buffers available?
	JAE	12$			;Yes - continue
					;No - fall into xfswrt4 on next page
.PAGE
;Here if have stopped filling buffers, either because we have output all
;  of our data, we have filled the current available extent, or we have
;  encountered a locked buffer

xfswrt4:MOVL	EBX, dcb_dkpbfr.B[EDI]	;Have something defered now?
	TESTL	EBX, EBX
	JE	4$.S			;No

;Here if we currently have a pending write buffer - We output it first before
;  outputting any of the current buffers. Note that the pending write buffer
;  cannot be the same as one of the current buffers since we check for this
;  when we are collecting the buffers.  Also, note that we have already locked
;  the pending write buffer.

	CLRL	EAX			;This is not the pending write buffer
	MOVL	dcb_dkpbfr.B[EDI], EAX	;  any more
	CALL	xosdskWriteBufr##	;Write out the buffer
	JC	34$			;If error
	CALL	xosdskRelsLkBufr##	;OK - give up the buffer

;Here with the pending write buffer output if necessary

4$:	MOVL	EBX, wr_last.B[EBP]	;Get last buffer filled
	TESTL	EBX, EBX
	JE	12$.S			;If none
	CLRL	EAX
	MOVL	wr_last.B[EBP], EAX
	MOVL	EAX, wr_endpnt.B[EBP]	;Did we completely fill the last buffer?
	SUBL	EAX, #512t
	CMPL	EAX, EBX
	JAE	6$.S			;Yes - don't defer writing it
	BTL	SS:xffCmd##, #O%NODFWR	;No - should we defer writing it?
	JC	6$.S			;No

;Here if we should defer writing the last buffer (note that we don't explicity
;  check that this is the last buffer, but we know that a buffer that was not
;  filled to the end MUST be the last buffer).

	MOVL	dcb_dkpbfr.B[EDI], EBX	;Yes - make it our pending write buffer
	JMP	12$.S

;Here if do not want to defer writing the last buffer, either because it was
;  completely filled or because the user specified no defered writes (note
;  that this may or may not be the last buffer of the transfer, we really don't
;  care which there).

6$:	MOVL	EAX, wr_tail.B[EBP]	;Link the last buffer to the end of
	TESTL	EAX, EAX		;  our list
	JNE	8$.S
	MOVL	wr_head.B[EBP], EBX
	MOVL	EAX, cb_block.B[EBX]
	MOVL	wr_begin.B[EBP], EAX
	JMP	10$.S

8$:	MOVL	cb_xnext.B[EAX], EBX
10$:	MOVL	wr_tail.B[EBP], EBX
	CLRL	EAX
	MOVL	wr_last.B[EBP], EAX
	INCL	wr_blocks.B[EBP]
12$:	MOVL	EBX, wr_head.B[EBP]	;Get offset of first buffer in list
	TESTL	EBX, EBX		;Do we have any?
	JE	16$.S			;No (note that we must update our
					;  totals anyway, since we might have
					;  just defered some output)
	MOVL	EAX, wr_begin.B[EBP]	;Yes - set disk block for first buffer
	MOVL	dcb_dkdblk.B[EDI], EAX	;  in list
	PUSHL	DS
	POPL	ES
	MOVL	ECX, wr_blocks.B[EBP]	;Get total amount to output
	SHLL	ECX, #9t
	MOVL	EAX, #kf_writlist
	CALL	xosdskXfer##		;Do the transfer
	JC	xfswrterr		;If error

	MOVL	EBX, wr_head.B[EBP]	;OK - release the buffers we have just
	CLRL	EAX			;  output
	MOVL	wr_head.B[EBP], EAX
	MOVL	wr_tail.B[EBP], EAX
14$:	ANDB	cb_sts.B[EBX], #~CB$CHNGD
	PUSHL	cb_xnext.B[EBX]
	CALL	xosdskRelsLkBufr##
	POPL	EBX
	TESTL	EBX, EBX
	JNE	14$.S
16$:	MOVL	EAX, wr_actual.B[EBP]	;Update total amount done
	ADDL	wr_done.B[EBP], EAX
	CLRL	EAX
	MOVL	wr_blocks.B[EBP], EAX	;Clear the block count
	MOVL	wr_actual.B[EBP], EAX	;And clear the amount transfered
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Did we extend the file?
	MOVL	EAX, dcb_dkfpos.B[EDI]
	CMPL	fib_size.B[EBX], EAX
	JAE	18$.S			;No
	MOVL	fib_size.B[EBX], EAX	;Yes - update file length
	ORB	cb_sts.B[EBX], #CB$CHNGD ;Indicate FIB has been changed
	CMPL	fib_mxsz.B[EBX], EAX	;Extending maximum written extent?
	JAE	18$.S			;No
	MOVL	fib_mxsz.B[EBX], EAX	;Yes
18$:	TESTB	SS:xffStatus1##, #XF1$ABORT ;Has this operation been aborted?
	JNE	24$.S			;Yes - fail
	CMPL	wr_xamnt.B[EBP], #0.B	;Need to extend some more?
	JNE	xfsxtdlp		;Yes
	CMPL	wr_tamnt.B[EBP], #0.B	;No - need to write more?
	JNE	xfswrtlp		;Yes
	CLRL	EAX			;Indicate no error
20$:	MOVL	EBX, dcb_dkpbfr.B[EDI]	;Have a pending write buffer?
	TESTL	EBX, EBX
	JE	xfswrtdone.S		;No
	PUSHL	EAX
	CALL	xosdskUnlkBufr##	;Yes - unlock it
	POPL	EAX
xfswrtdone:
	MOVL	ECX, wr_done.B[EBP]	;Get count
	LEAVE
	RET

;Here if operation has been aborted

24$:	MOVL	EAX, #ER_ABORT
	JMP	20$.S

;Here if error after at least one buffer has been filled - in this case we
;  mark all of the buffers we have filled as empty (this is conservative:
;  we do not want to try to write anything additional to the disk since we
;  know there is a problem)

xfswrterr:
	PUSHL	EAX
	MOVL	EBX, dcb_dkpbfr.B[EDI]	;Do we have a pending write buffer?
	TESTL	EBX, EBX
	JE	26$.S			;No
	MOVL	EAX, SS			;Yes - do we have it locked?
	CMPW	AX, cb_lockxff.B[EBX]
	JNE	26$.S			;No
	CALL	xosdskUnlkBufr#		;Yes - unlock it
26$:	MOVL	EBX, wr_head.B[EBP]
	TESTL	EBX, EBX
	JE	30$.S
28$:	PUSHL	cb_xnext.B[EBX]
	ANDB	cb_sts.B[EBX], #CB$FULL
	CALL	xosdskGiveLkBufr##
	POPL	EBX
	TESTL	EBX, EBX
	JNE	28$.S
30$:	MOVL	EBX, wr_last.B[EBP]
	TESTL	EBX, EBX
	JE	32$.S
	CALL	xosdskGiveLkBufr##
32$:	POPL	EAX
	STC
	JMP	xfswrtdone.S

;Here if error when writing the pending write buffer

34$:	PUSHL	EAX
	CALL	xosdskGiveLkBufr##	;Give up the pending write buffer
	JMP	26$.S			;Go process the error (This is not	POPL	EAX
					;  really right, since it makes it
					;  look like the error occured on this
					;  buffer, but there's not much else
					;  we can do at this point!)
.PAGE
;Subroutine to get next disk block for write
;	c{dcb_dkdblk{EDI} = Block number on disk
;	CALL	getwriteblk
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Have block
;	  Z:clr = Cannot get block now - need to write all pending blocks first

getwriteblk:
	MOVL	EAX, dcb_dkdblk.B[EDI]	;Get block number
	MOVL	EBX, wr_last.B[EBP]	;Do we have a buffer now?
	TESTL	EBX, EBX
	JE	4$.S			;No
	CMPL	EAX, cb_block.B[EBX]	;Yes - do we have the buffer we want?
	JE	16$.S			;Yes
4$:	MOVL	EBX, dcb_dkpbfr.B[EDI]	;No - do we have a pending write block?
	TESTL	EBX, EBX
	JE	10$.S			;No
	CMPL	EAX, cb_block.B[EBX]	;Yes - do we want the pending write
					;  block?
	JNE	10$.S			;No
	CLRL	EAX			;Yes - its no longer pending (we already
	MOVL	dcb_dkpbfr.B[EDI], EAX	;  have it locked)
	JMP	16$.S

;Here if the block we want is not the pending write block

10$:	PUSHL	ECX
	CALL	xosdskSrchDBufr##	;Find the buffer but don't read block
	POPL	ECX
	JC	22$.S			;If error
	CALL	xosdskLockBufrF##	;OK - try to lock it
	JC	22$.S			;If error
	JE	12$.S			;If lock succeeded
	MOVL	EAX, wr_head.B[EBP]	;Lock attempt failed - do we have any
	ORL	EAX, dcb_dkpbfr.B[EDI]	;  buffers locked now?
	JNE	22$.S			;Yes - return with Z clear
	CALL	xosdskLockBufrW##	;No - wait until we can have this one
	JC	22$.S			;If error

;Here with the desired buffer locked

12$:	TESTB	cb_sts.B[EBX], #CB$FULL	;Is this buffer full now?
	JNE	16$.S			;Yes
	MOVL	EAX, dcb_dkfpos.B[EDI]	;No
	ANDL	EAX, #1FFh		;Does write start at beginning of block?
	JNE	14$.S			;No - must always read block
	CMPL	ECX, #200h		;Yes - writing entire block?
	JE	16$.S			;Yes - don't need to read the block
	MOVL	EAX, dcb_dkfpos.B[EDI]	;No - writing beyond maximum extent of
	ADDL	EAX, ECX		;  file?
	MOVL	EDX, dcb_dkfilepnt.B[EDI]
	CMPL	fib_mxsz.B[EDX], EAX
	JBE	16$.S			;Yes - don't need to read the block
14$:	PUSHL	ECX
	CALL	xosdskReadBufr##	;No - read the disk block
	POPL	ECX
	JC	24$.S			;If error
16$:	MOVL	EAX, wr_last.B[EBP]	;Do we have a last buffer now?
	TESTL	EAX, EAX
	JE	26$.S			;No
	MOVL	EDX, wr_tail.B[EBP]	;Yes - link it to the end of our
	TESTL	EDX, EDX		;  buffer list
	JNE	18$.S
	MOVL	wr_head.B[EBP], EAX
	JMP	20$.S

18$:	MOVL	cb_xnext.B[EDX], EAX
20$:	MOVL	wr_tail.B[EBP], EAX
	INCL	wr_blocks.B[EBP]
22$:	CLRL	EAX
	MOVL	cb_xnext.B[EBX], EAX
	MOVL	wr_last.B[EBP], EBX
24$:	RET

;Here if this is the first block

26$:	MOVL	EAX, dcb_dkdblk.B[EDI]	;Remember block for first buffer in list
	MOVL	wr_begin.B[EBP], EAX
	JMP	22$.S
.PAGE
	.SBTTL	xfsrename - Rename file

;Here for the rename file entry - file to be renamed is open for exclusive
;  write access but is not locked.  New directory is open but is not locked.
;	c{SS:EDX} = Address of new name bufer for file
;	c{EDI}    = Offset of DCB for directory to rename to
;	c{ESI}    = Offset of DCB for file to rename
;	CALL	xfsrename
;	New directory always left open and not locked, file always closed
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Number of files renamed (0 or 1)
;	C:clr = Normal
;	  c{ECX} = 1

;Rename presents a major problem in that two different names must be locked
;  at the same time to prevent races.  The old name is open for exclusive
;  write access, which keeps anyone else from deleting or renaming it even
;  though we do not have it locked.  If we are renaming to the same directory,
;  the call to xfsopen2 returns with the directory locked, which provides
;  enough protection.

xfsrename::
.IF NE $$CHKCHAIN
	CALL	checkchain#
.ENDC

	CRASH	RNAM

.IF NE 0

	PUSHL	EDX			;Save pointer to name
	MOVB	AH, #0
2$:	MOVB	AL, SS:[EDX]		;Get name character
	INCL	EDX
	TESTB	AL, AL			;End of name?
	JE	12$.S			;Yes
	CMPB	AL, #'*'		;No - wild card character?
	JE	4$.S
	CMPB	AL, #'?'
	JE	4$.S
	CMPB	AL, #LB
	JE	4$.S			;Yes - fail
	CMPB	AL, #'.'		;Or period?
	JNE	2$.S			;No - continue
	BTSL	EAX, #8			;Yes - first period?
	JNC	2$.S			;Yes - OK
4$:	POPL	EDX			;Here with illegal character in name
	MOVL	EAX, #ER_BDSPC
	JMP	10$.S

;Here with write protect error

6$:	MOVL	EAX, #ER_WPRER
	JMP	10$.S

;Here if have no UCB

8$:	MOVL	EAX, #ER_MDCHG
10$:	MOVL	EDI, ESI		;Get offset of file DCB
	JMP	rener2			;Go finish up

;Here with name scanned

12$:	POPL	EDX			;Restore pointer to name
	MOVL	EAX, [EDI]		;Is the disk write protected?
	TESTL	EAX, EAX
	JE	8$.S
	TESTB	ucb_sts1.B[EAX], #U1$WPROT
	JNE	6$.S			;Yes - fail
	ENTER	of_SIZE, 2		;Setup stack frame for xfsopen2
	PUSHL	ESI			;Save offset of file's DCB
	PUSHL	SS:xffCmd##
	MOVL	SS:xffCmd##, #O$XWRITE|O$CREATE|O$FAILEX
	CLRL	EAX			;Make sure start search at start of
	MOVL	dcb_dkfpos.B[EDI], EAX	;  directory
	MOVB	AL, #FS_NPATHNAME	;Get prefix character for path string
	CALL	xfsopen2#		;Do first part of open
	POPL	SS:xffCmd##
	JC	38$			;If error
	JNE	34$			;This should not be possible!
					;When get here, the directory for the
					;  new name is open and locked
	MOVL	ESI, [ESP]		;Get offset of the file DCB
	MOVL	EBX, dcb_dkfilepnt.B[ESI] ;Get offset of the file FIB
	MOVL	EAX, cb_dirfib.B[EBX]	;Get offset of FIB for old directory
	CMPL	dcb_dkfilepnt.B[EDI], EAX ;Same directory?
	JNE	chgdir			;No

;Here if renaming in the same directory - In this case we much first determine
;  if the new name will fit in the same or fewer slots as the old name.  If so,
;  we first give up any extra slots and then store the new directory entry
;  over the old entry.  If not, we remove the old entry and create a completely
;  new entry.

	MOVZBL	EAX, fib_dirsize.B[EBX]	;Get current directory entry size - 1
	MOVL	ECX, EAX
	MOVL	EDX, of_dentneed.B[EBP]	;Will the new entry be larger?
	DECL	EDX
	SUBL	ECX, EDX
	JL	renmore			;Yes
	JE	30$.S			;No - go on if same size
	IMULL	EAX, #-32t.B		;Get offset to first entry
	PUSHL	EAX
	PUSHL	ECX
16$:	CALL	xfsgetdirent#		;Get directory entry
	POPL	ECX
	JC	34$			;If error
	POPL	EAX
18$:	MOVB	[EBX+EDX], #0E5		;OK - mark entry as removed
	ADDL	EDX, #32t.B
	ADDL	EAX, #32t.B
	DECL	ECX			;More to do here?
	JE	26$.S			;No
	TESTL	EDX, #1FFh		;Yes - at end of block now?
	JNE	18$.S			;No
	PUSHL	EAX
	PUSHL	ECX
	CALL	xfswritedir#		;Yes - write out this directory block
	JC	22$.S
	CALL	xosdskRelsLkBufr##	;Release the directory buffer
	MOVL	EAX, [ESP]
	JMP	16$.S

;Here if error reading a directory buffer

20$:	POPL	EDX
	JMP	rener2.S

;Here if error writing a directory buffer

22$:	POPL	EDX			;Fix up the stack
	POPL	ECX
24$:	PUSHL	EAX			;Save error code
	JMP	renerr.S

;Here with all extra directory entries for the file removed

26$:	TESTL	EDX, #1FFh		;At end of a block now?
	JNE	28$.S			;No
	CALL	xfswritedir#		;Yes - write out the last directory
	JC	24$.S			;  block
28$:	CALL	xosdskRelsLkBufr##	;Give up the directory buffer
	MOVL	EBX, [ESP]		;Restore offset of the file FIB
	MOVL	EBX, dcb_dkfilepnt.B[EBX]
30$:	MOVL	EAX, of_dentneed.B[EBP]	;Get position for first directory slot
	DECL	EAX
	IMULL	EAX, #-32t.B
	ADDL	EAX, fib_dirpos.B[EBX]
	MOVL	of_holepos.B[EBP], EAX
	MOVB	AL, #1			;Indicate doing rename
	JMP	32$.S

;Here if new directory entry will be larger than the old one

renmore:XCHGL	EDI, [ESP]		;Get file DCB, save directory DCB
	MOVL	SS:xffDcb##, EDI
	CALL	xfsfrmdir#		;Remove the old directory entry
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Get offset of file FIB
	XCHGL	EDI, [ESP]		;Get directory DCB save file DCB
	MOVL	SS:xffDcb##, EDI
	JC	24$.S			;If error
	MOVB	AL, #0			;Indicate not rename
32$:	CALL	xfsputindir#
	JC	renerx.S

.IF NE $$CHKCHAIN
	CALL	checkchain#
.ENDC
	JMP	rencls			;Go finish up

;Here if error while have directory locked

renerx:	PUSHL	EAX
	JMP	36$.S

;Here if new file already exits

34$:	PUSHL	#ER_FILEX.B
	JMP	36$.S

;Here if error writing directory (have directory block)

renerr:	CALL	xosdskGiveLkBufr##	;Give up the directory block
36$:	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Unlock the directory
	CALL	xosdskUnlkBufr##
	POPL	EAX
38$:	POPL	EDI
	LEAVE
rener2:	PUSHL	EAX
	CLRL	ECX
	CALL	xfscfile#		;Close the file
	POPL	EAX
.IF NE $$CHKCHAIN
	CALL	checkchain#
.ENDC
	CLRL	ECX			;Item count = 0
	STC
	RET
.PAGE
;Here if changing directories - the original file is open for exclusive write
;  access but is not locked.  The block containing the old directory entry is
;  in use and locked.  The directory for the new entry is open and locked.
;	c{EBX}            = Offset of buffer containing old directory block
;	c{EDX}            = Offset of entry in old directory block
;	c{EDI}            = Offset of DCB for new directory
;	c{ESI} = c{{ESP}} = Offset of file DCB
;  We must check to see if we are renaming a directory, and if so, if we are
;    renaming it into one of its child directories!

chgdir:	MOVL	EAX, dcb_dkfilepnt.B[ESI] ;Get offset of file FIB
	TESTB	fib_attrib.B[EAX], #A$DIRECT ;Renaming a directory?
	JE	8$.S			;No
	MOVL	EAX, dcb_dkfilepnt.B[EDI] ;Yes
2$:	MOVL	EAX, cb_dirfib.B[EAX]	;Get offset of directory FIB
	TESTL	EAX, EAX
	JE	8$.S			;OK if no more parents
	CMPL	EAX, dcb_dkfilepnt.B[ESI] ;Is this the file we are renaming?
	JNE	2$.S			;No - continue
	PUSHL	#ER_IDREN
4$:	JMP	renerr.S

;Here if error writing new directory

6$:	PUSHL	#ER_DRWER.B
	JMP	renerr

;Here if not renaming a directory or if this is a valid directory rename

8$:

;;;;qqqqqqqqqqqq

	MOVL	ESI, [EDI]


	MOVB	[EBX+EDX], #0E5		;Remove old directory entry
	CALL	xfswritedir#		;Write out the directory block
	JC	6$.S			;If error




	ANDB	cb_sts.B[EBX], #~CB$CHNGD
	CALL	xosdskRelsLkBufr##	;Give up the directory block buffer
	MOVL	ESI, [ESP]		;Get file FIB
	MOVL	EBX, dcb_dkfilepnt.B[ESI]
	CALL	xosdskRmvHash##		;Un-hash this buffer
	CLRL	EAX			;Clear block number (xfsputindir will
	MOVL	cb_block.B[EBX], EAX	;  fix up the block number)
	MOVZWL	EAX, cb_opencnt.B[EBX]	;Get number of times file is open	
	PUSHL	EBX
	MOVL	EBX, cb_dirfib.B[EBX]
	TESTL	EBX, EBX		;Have a directory?
	JE	10$.S			;No
	CALL	xfsgivefibn#		;Yes - reduce its open count
10$:	POPL	EBX			;Restore offset of file FIB
	MOVB	AL, #0			;Indicate not rename since we are moving
					;  the file to a differnt directory
	CALL	xfsputindir#		;Put entry for file in new directory
	JC	renerx
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Get directory FIB
12$:	MOVL	EAX, [ESP]		;Get the open count for the file
	MOVL	EAX, dcb_dkfilepnt.B[EAX]
	MOVZWL	EAX, cb_opencnt.B[EAX]	;Make sure we can increase the
	MOVL	EDX, EAX		;  directory's use count by this much
	ADDW	DX, cb_usecnt.B[EBX]
	JC	13$.S
	MOVW	cb_usecnt.B[EBX], DX	;OK - bump the counts to account for the
	ADDW	cb_opencnt.B[EBX], AX	;  file we just put in the directory
	MOVL	EBX, cb_dirfib.B[EBX]
	TESTL	EBX, EBX
	JNE	12$.S
rencls:	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Unlock the directory
	CALL	xosdskUnlkBufr##
	POPL	EDI
	MOVL	SS:xffDcb##, EDI
	MOVB	AL, #FS_NFILENAME

;;;;;;;qqqqqqqqqqqqq CODE HERE TO GIVE HIM SOME NAMES!!!

	CLRL	ECX
	CALL	xfscfile#		;Close the file
	JC	14$.S
	CLRL	ECX			;Return item count = 1
	INCL	ECX
	CLRL	EAX
	LEAVE
	RET

13$:	CRASH	TMRB		;NEED TO HANDLE THIS BETTER!!!!!

;Here if error closing file - report error but also return item count of 1

14$:	CLRL	ECX			;Item count = 1
	INCL	ECX
	LEAVE
	STC
	RET

.ENDC

.PAGE
	.SBTTL	xfscommit - Commit data function for XOS disks

;Here for the sd_commitfunc entry - Commit data
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	CALL	xfscommit
;	c{EAX} = Error code
;	c{ECX} = Amount (always 0)
;	c{EBX} = Status bits

xfscommit:
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #xfscommit1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

xfscommit1:
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	2$.S			;No
	MOVL	EBX, #xfsioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	4$.S			;If error
2$:	CALL	xosdskFinOut##		;OK - do any defered output
	JC	4$.S
	CALL	xfsupdfile#		;Update the FATs and the directory entry
	JC	4$.S
	CLRL	EAX
4$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET
.PAGE
	.SBTTL	xfslabel - Label functions for XOS disks

;Here for the sd_label entry - Label functions
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	CALL	xfsinpblk
;	c{EAX} = Error code
;	c{ECX} = Amount
;	c{EBX} = Status bits

xfslabel:
	CMPB	iorb_option.B[ESI], #2	;Write function?
	JE	4$.S			;Yes
	CMPB	iorb_option.B[ESI], #1	;No read function?
	JNE	knlIFnDevGQ##		;No - fail
	CALL	knlIoQabLock##		;Yes - lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock input buffer
	JC	2$.S			;If error
	MOVL	iorb_routine.B[ESI], #getlabel
	JMP	6$.S

2$:	TOFORK
	RET

;Here for the write label function

4$:	JMP	knlIFnDevGQ##	;TEMP!!!!!!

	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock output buffer
	JC	2$.S			;If error
	MOVL	iorb_routine.B[ESI], #putlabel
6$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	JMP	knlXfQueue##		;Switch to extended fork context
.PAGE
;Here in extended fork context to read an XFS disk label

bo_label =!16t		;Buffer offset for returned label
bo_length=!32t		;Buffer offset for length of label

getlabel:
	CALL	xosdskFinOut##		;Make sure no output pending
	PUSHL	SS:xffCmd##		;Save state of the current file
	PUSHL	dcb_dkfilepnt.B[EDI]
	PUSHL	dcb_dkcfib.B[EDI]
	PUSHL	dcb_dkfpos.B[EDI]
	MOVB	AL, dcb_sts2.B[EDI]
	PUSHL	EAX
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpenSetup##		;  the open parameters)
	JC	2$.S			;If error
	CLRL	EAX
	MOVL	dcb_dkfilepnt.B[EDI], EAX
	MOVL	dcb_dkcfib.B[EDI], EAX

	CRASH	LABL

2$:	RET
.PAGE
putlabel::
	CRASH	LABL
.PAGE
	.SBTTL	xfssetpath - Set up path data for XOS file structures

;Here for the dd_setpath entry - Set up path data for XOS file structures
;	c{EDI}    = Offset of DCB
;	c{ES:ESI} = Address of path data block
;	CALL	xfssetpath

xfssetpath:
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;Store offset of FIB buffer
	MOVL	ES:pn_fpnt1.B[ESI], EBX
2$:	CMPW	cb_usecnt.B[EBX], #0FFFEh
	JA	6$.S
	MOVL	EBX, cb_dirfib.B[EBX]	;Does it have a directory?
	TESTL	EBX, EBX
	JNE	2$.S			;Yes - continue
	MOVL	EBX, dcb_dkfilepnt.B[EDI] ;No - point to the directory FIB again
4$:	INCW	cb_usecnt.B[EBX]	;Bump use and open counts on the buffer
	INCW	cb_opencnt.B[EBX]
	MOVL	EBX, cb_dirfib.B[EBX]	;Does it have a directory?
	TESTL	EBX, EBX
	JNE	4$.S			;Yes - continue
	RET

;Here if can't increase the use count

6$:	MOVL	EAX, #ER_TMRQB
	STC
	RET

	.SBTTL	xfschkpath - Check path data for XOS file structures

;Here for the dd_chkpath entry - Check path data for XOS file structures
;	c{EDI} = Offset of DCB
;	c{FS:ESI} = Address of path data block
;	CALL	xfschkpath

xfschkpath:
	MOVL	EBX, FS:pn_fpnt1.B[ESI]	;Point to FIB buffer
	TESTL	EBX, EBX
	JE	8$.S			;If no FIB buffer (possible if had
					;  error before)
	CMPW	cb_errcode.B[EBX], #0.B	;Have error on buffer?
	JE	8$.S			;No
	MOVL	FS:pn_fpnt1.B[ESI], #0	;Yes
	PUSHL	ESI
	CALL	xfsgivefib2#		;Give up the buffer
	POPL	ESI
8$:	RET

	.SBTTL	xfsclrpath - Clear path data for XOS file structures

;Here for the dd_clrpath entry - Clear path data for XOS file structures
;  (note that this routine does NOT use EDI)
;	c{ES:ESI} = Address of path data block
;	CALL	xfsclrpath

xfsclrpath:
	REQUIREFORK
	MOVL	EBX, ES:pn_fpnt1.B[ESI]	;Get offset of FIB buffer
	TESTL	EBX, EBX		;Do we have one?
	JE	10$.S			;No
	PUSHL	ES
	PUSHL	ESI			;Yes
	CALL	xfsgivefib2#		;Give up the FIB buffer
	POPL	ESI
	POPL	ES
10$:	RET					;Fall into strpath on next page
.PAGE
	.SBTTL	Data

	DATA

lit13::   .LONG  13t
lit128::  .LONG  128t
lit256::  .LONG  256t
lit512::  .LONG  512t
nonamestr:.ASCIZ "???"
nofilestr:.ASCIZ "No file"

;Generate a 256 bytes table which gives the number of 0 bits in a byte

$$num=!0
bitstbl:.REPT	256t
  $$val=!0
  .IF EQ $$num&01h
    $$val=!$$val+1
  .ENDC
  .IF EQ $$num&02h
    $$val=!$$val+1
  .ENDC
  .IF EQ $$num&04h
    $$val=!$$val+1
  .ENDC
  .IF EQ $$num&08h
    $$val=!$$val+1
  .ENDC
  .IF EQ $$num&10h
    $$val=!$$val+1
  .ENDC
  .IF EQ $$num&20h
    $$val=!$$val+1
  .ENDC
  .IF EQ $$num&40h
    $$val=!$$val+1
  .ENDC
  .IF EQ $$num&80h
    $$val=!$$val+1
  .ENDC
	.BYTE	$$val
$$num=!$$num+1
	.ENDR

	LKEEND
