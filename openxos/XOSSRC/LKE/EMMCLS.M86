	.TITLE	EMMCLS Virtual DOS mode EMS and XMS routines

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

;*--------------------------------------------------------------------------*
;* emmcls.m86
;*
;* Written by: Bruce R. Nevins
;*
;* Edit History:
;* 05/05/90(brn) - Created first version
;* 09/13/92(brn) - Modify to support XOS version 4.7.47 or later
;*
;*--------------------------------------------------------------------------*

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!1t
MINV   =!1t
EDITNUM=!0t

I67MIN=!40h	; Minimum INT 67 subfunction
VCPIFNC=!0DEh	; VCPI sub-function
EMMVER=!40h	; EMM version number

	LKEHEAD	EMMCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

	DATA

	.SBTTL	SVC dispatch table for EMM class devices

;SVC dispatch table for EMM class devices

emmdsp::.LONG	rtnzero#+I$	;sd_mount	=  0. - Mount
	.LONG	rtnzero#+I$	;sd_cleardev	=  4. - Clear device
	.LONG	rtnzero#+I$	;sd_cleardcb	=  8. - Clear DCB
	.LONG	rtnzero#+I$	;sd_commit	= 12. - Commit data to disk
	.LONG	rtnzero#+I$	;sd_transold    = 16. - Transfer device/old
	.LONG	rtnzero#+I$	;sd_transnew    = 20. - Transfer device/new
	.LONG	nullqio#+I$	;sd_opena	= 24. - Open additional
	.LONG	emmopen		;sd_open1	= 28. - Open device/file
	.LONG	emmopen		;sd_devparm     = 32. - Device parameters
	.LONG	ifndev#+I$	;sd_delete	= 36. - Delete file
	.LONG	ifndev#+I$	;sd_rename	= 40. - Rename file
	.LONG	illinpgq#+I$	;sd_inblock	= 44. - Input block
	.LONG	ifndevgq#+I$	;sd_indatagram	= 48. - Input datagram
	.LONG	illoutgq#+I$	;sd_outblock	= 52. - Output block
	.LONG	illinp#+I$	;sd_outblockq	= 56. - Output block (XFF)
	.LONG	illoutgq#+I$	;sd_outstring	= 60. - Output string
	.LONG	ifndevgq#+I$	;sd_outdatagram	= 64. - Output dagagram
	.LONG	rtnmone#+I$	;sd_getiosts	= 68. - Get input/output status
	.LONG	0		;		= 72. - Reserved
	.LONG	ifndevgq#+I$	;sd_special     = 76. - Special device function
	.LONG	rtnzero#+I$	;sd_close	= 80. - Close file
	.LONG	nulllabel#+I$	;sd_label       = 84. - Get device label
EMMDSPSZ=!{$-emmdsp}/4

;Class function dispatch table for EMM interface class devices

	.LONG	CLSFMX
emmcls::.LONG	ifndev#+I$	;CF_ADDUNIT = 1. - Add unit
	.LONG	ifndev#+I$	;CF_PUNITS  = 2. - Get information about
				;		     physical units
	.LONG	ifndev#+I$	;CF_AUNITS  = 3. - Get information about active
				;		     units
CLSFMX=!{$-emmcls}/4

;Class characteristics table for the LPT device class

	DATA

	.MOD	4
emmcctbl:
 DCHARBGN  1, dcharvalcom#+I$

	CODE
.PAGE
;Device parameter table for EMM

emmioparms:
	.LONG	PARMMAX		;Size of table
	.LONG	0		;		= 0  - Reserved
	.LONG	iopfiloptn#+I$	;IOPAR_FILOPTN  = 1  - File option bits
	.LONG	iopfilspec#+I$	;IOPAR_FILSPEC  = 2  - File specification
	.LONG	iopdevsts#+I$	;IOPAR_DEVSTS   = 3  - Device status
	.LONG	iopunitnum#+I$	;IOPAR_UNITNUM  = 4  - Unit number
	.LONG	iopglbid#+I$	;IOPAR_GLBID    = 5  - Global device ID
PARMMAX=!{$-emmioparms}/4-1
.PAGE
;Device characteristics for EMM

	DATA

	.MOD	4
emmdctbl:
 DCHARBGN  2, dcharvalcom#+I$
 DCHARENT  CLASS    , TEXT, 8, dcmsgclass#+I$, dcgetclass#+I$, dcsetclass#+I$, 0
 DCHARENT  EMSMLIMIT, DECV, 4, msgemsmlimit  , getsysval#+I$ , setsysval#+I$ , emsmlimit
 DCHARENT  EMSHLIMIT, DECV, 4, msgemshlimit  , getsysval#+I$ , setsysval#+I$ , emshlimit
 DCHARENT  XMSMLIMIT, DECV, 4, msgxmsmlimit  , getsysval#+I$ , setsysval#+I$ , xmsmlimit
 DCHARENT  PAGEFRAME, HEXV, 4, msgpageframe  , getsysval#+I$ , setsysval#+I$ , pageframe

	CODE

msgemsmlimit: DCHARINFO  {Maximum EMS memory per process (in KB)}
msgemshlimit: DCHARINFO  {Maximum EMS handles per process}
msgxmsmlimit: DCHARINFO  {Maximum XMS memory per process (in KB)}
msgpageframe: DCHARINFO  {Page frame segment}
.PAGE
	.SBTTL	emminit - Real mode once-only initialization routine

;EMM once-only initializataion routine

	INITSUB	emminit
	
emminit:

; Set up the virtual DOS vector

	MOVL	EAX, #67h.B		;Get vector number
	MOVL	EBX, #vdmems67		;Get offset of routine
	MOVL	ECX, #VECTSIZ.B		;Use special real mode routine
	PUSHL	CS
	POPL	ES
	MOVL	EDX, #vectstr		;Set up the vector string
	CALLI	newrmint#		;Set up the vector
	JC	1$.S			;This should not fail!

; Set up the new class

	MOVL	EDI, #emmchk		;Install our class
	MOVL	EBX, #emmcls		;Offset of class function dispatch table
	MOVL	EAX, #'EMM'
	CLRL	EDX
	MOVL	ECX, #emmcctbl
	MOVL	ESI, #emmccb
	CALLI	newclass#
	JC	1$.S			;This should not fail!

; Set up our only DCB

	MOVL	ECX, #dcb_devbgn+dcb_cSIZE ;Create a DCB
	MOVL	EBX, #DS$MLTUSER
	MOVL	EDI, #emmdsp
	CALLI	makedcb#
	JC	1$.S
	MOVL	ESI, #emmccb
	CALLI	linkdcb#
1$:	JC	2$.S

; Register the DOS name

	MOVL	dcb_name+0.B[EDI], #'XEMM' ;Set up device name
	MOVL	dcb_devchar.B[EDI], #emmdctbl ;Store offset of devchar table
	MOVL	EAX, CS			;Set up special DOS device name
	MOVL	FS, EAX
	MOVL	EDX, #dosname
	MOVL	GS, EAX
	MOVL	EBX, #FTEname
	CALLI	dosnamereg#

; Fixup dispatch tables

	MOVL	EBX, #emmdsp		;Fix up indirect vectors in our
	MOVL	ECX, #EMMDSPSZ		;  dispatch tables
	CALLI	fixdsptbl#
	MOVL	EBX, #emmcls
	MOVL	ECX, #CLSFMX
	CALLI	fixdsptbl#
	MOVL	EBX, #emmioparms+4
	MOVL	ECX, #PARMMAX
	CALLI	fixdsptbl#
	MOVL	EBX, #emmdctbl		;Fix up the device characteristics
	CALLI	fixdcharvect#		;  table
	MOVL	EBX, #emmcctbl		;Fix up the class characteristics
	CALLI	fixdcharvect#		;  table
	MOVL	ECX, #codetop
	CLRL	EDX
	CLRL	EAX
2$:	MOVL	EBX, #QSTS$DONE
ret004:	RET

dosname:.ASCIZ	"EMMXXXX0"
FTEname:.ASCIZ	"XEMM"

; Set up the dummy vector for the EMM driver

vectstr:
	HLT
	HLT
	.WORD	67h
	.LONG	0
	.WORD	0
	.ASCII	"EMMXXXX0"
VECTSIZ=!{$-vectstr}
.PAGE
	CODE
	.SBTTL	emmchk - Device check routine for EMM

;Device check routine for EMM
;	c{SS:EBX} = Address of device name (16 bytes)
;	CALL	emmchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  EBX and ESI are preserved

emmchk::MOVL	EDI, emmccb+ccb_dcbhead	;Get offset of DCB in case its for us
	CMPL	SS:[EBX], #'XEMM'	;Is this the "real" name?
	JNE	4$.S			;No
	CMPB	SS:4.B[EBX], #0		;Maybe
2$:	CLC				;No - not for this device
	RET

;Here if not XEMM:

4$:	CMPL	SS:[EBX], #'EMMX'	;Is this the DOS name?
	JNE	2$.S			;No
	CMPL	SS:4.B[EBX], #'XXX0'		;Maybe
	JNE	2$.S
	CMPB	SS:8.B[EBX], #0
	CLC
	RET
.PAGE
	.SBTTL	sd_open - Open device

;Here for the open device entry
;	c{EDI} = Offset of DCB

emmopen::
	BTL	SS:xffCmd##, #O%ODF
	JNC	2$.S			;If no illegal options
	MOVL	EAX, #ER_NTFIL
	STC
2$:	RET
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	emmclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

emmclose::
	CLRL	EAX
	RET
.PAGE
	.SBTTL	vdmems67 - Routine to handle INT 67 in virtual DOS mode

;Routine to handle INT 67 in virtual DOS mode

vdmems67::
;	PUSHL	EBX
;	MOVL	EBX, emsrngpnt		;Get pointer to the debug ring
;	MOVW	[EBX], SS		;Store PDA selector
;	MOVL	EAX, SS:pdaURegEAX##
;	MOVW	2.B[EBX], AX		;Store function and subfunction
;	MOVL	EAX, SS:pdaURegEPC##	;Store user PC
;	MOVW	4.B[EBX], AX
;	MOVL	EAX, SS:pdaURegCS##	;Store user CS
;	MOVW	6.B[EBX], AX
;	ADDL	EBX, #8.B
;	CMPL	EBX, #emsrngend
;	JB	2$.S
;	MOVL	EBX, #emsrngbgn
;2$:	MOVL	emsrngpnt, EBX
;	POPL	EBX
	MOVZBL	EAX, SS:pdaURegEAX##+1	;Get the INT 67 function
	MOVL	lastint67, EAX
	SUBL	EAX, #I67MIN.B		;Based from first
	JB	vbadi67.S
	CMPB	AL, #I67MAX.B		;Too large
	JA	vbadi67.S		;Yes
	CALLI	int67tbl[EAX*4]		;Yes - dispatch to routine for function
	JC	4$.S			;If error
vdmdone:ANDB	40t.B[ESP], #~1		;Clear caller's C bit
	RET

;Here if error return from INT routine

4$:	CMPL	EAX, #ER_NIYT		;Not implemented error?
	JE	10$.S			;Yes
	ORB	40t.B[ESP], #1		;No - set caller's C bit
	PUSHL	#GS_USERCODE
	POPL	ES
	CMPL	EAX, ES:doserrtbl#+4	;Make sure valid error code
	JB	8$.S
	MOVL	EAX, ES:doserrtbl#[EAX*4] ;OK - get DOS error numbers
; The following instruction may want to be removed if this is only to
;  be done by int 21 routines
	MOVL	SS:pdaRMPage0##+dda_lasterr, EAX ;Save DOS error for int 21 59
	MOVB	AH, #0			;Give the user just the error code in
	MOVW	SS:pdaURegEAX##, AX	;  his AX
	RET

;Here if INT 67 function which should be a complete NOP

vnoop:	POPL	EAX			;Discard return address from above
	RET

;Here if undefined INT 67 function

vbadi67:
;	ORB	40t.B[ESP], #1		; Set caller's C bit
;	MOVB	AX, #84h		; Function number not defined error
;	MOVW	SS:pdaURegEAX##, AX	;
;	RET

	MOVZBL	ECX, SS:pdaURegEAX##+1	;Get the INT 67 function
6$:	SHLL	ECX, #16t
	MOVW	CX, #67CDh		;Indicate INT 67h instruction
	JMPIL	unimop#			;Go kill process

;Here if invalid error code

8$:	CRASH	BDEC

;Here with not implemented error

10$:	MOVL	ECX, SS:pdaURegEAX##	;Get callers arguments
	XCHGB	CL, CH
	JMP	6$.S
.PAGE
	.SBTTL	int67tbl - Dispatch table for INT 67 functions

	DATA

int67tbl:
	.LONG	emsgms		; 40 - LIM EMS - GET MANAGER STATUS
	.LONG	emsgpf		; 41 - LIM EMS - GET PAGE FRAME SEGMENT
	.LONG	emsgnp		; 42 - LIM EMS - GET NUMBER OF PAGES
	.LONG	emsgha		; 43 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY
	.LONG	emsmm		; 44 - LIM EMS - MAP MEMORY
	.LONG	emsrhm		; 45 - LIM EMS - RELEASE HANDLE AND MEMORY
	.LONG	emsgev		; 46 - LIM EMS - GET EMM VERSION
	.LONG	emssmc		; 47 - LIM EMS - SAVE MAPPING CONTEXT
	.LONG	emsrmc		; 48 - LIM EMS - RESTORE MAPPING CONTEXT
	.LONG	emsund		; 49 - LIM EMS - (reserved) GET I/O PORT ADDRESSES
	.LONG	emsund		; 4A - LIM EMS - (reserved) GET TRANSLATION ARRAY
	.LONG	emsneh		; 4B - LIM EMS - GET NUMBER OF EMM HANDLES
	.LONG	emspoh		; 4C - LIM EMS - GET PAGES OWNED BY HANDLE
	.LONG	emspah		; 4D - LIM EMS - GET PAGES FOR ALL HANDLES
	.LONG	emsgspm		; 4E - LIM EMS - GET OR SET PAGE MAP
	.LONG	emsgsppm	; 4F - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP
	.LONG	emsmumhp	; 50 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
	.LONG	emsrp		; 51 - LIM EMS 4.0 - REALLOCATE PAGES
	.LONG	emsgsha		; 52 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES
	.LONG	emsgshn		; 53 - LIM EMS 4.0 - GET/SET HANDLE NAME
	.LONG	emsghd		; 54 - LIM EMS 4.0 - GET HANDLE DIRECTORY
	.LONG	emsapmj		; 55 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP
	.LONG	emsapmc		; 56 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL
	.LONG	emsmemr		; 57 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION
	.LONG	emsgmpaa	; 58 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY
	.LONG	emsgemhi	; 59 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION
	.LONG	emsasrp		; 5A - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES
	.LONG	emsamrs		; 5B - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET
	.LONG	emspemhwb	; 5C - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT
	.LONG	emsedofsf	; 5D - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS
	.LONG	emsund		; 5E - Unimplimented operation
	.LONG	emsund		; 5F - Unimplimented operation
	.LONG	emsgpwa		; 60 - EEMS - GET PHYSICAL WINDOW ARRAY
	.LONG	emsgacs		; 61 - EEMS - GENERIC ACCELERATOR CARD SUPPORT
	.LONG	emsund		; 62 - Unimplimented operation
	.LONG	emsund		; 63 - Unimplimented operation
	.LONG	emsund		; 64 - Unimplimented operation
	.LONG	emsund		; 65 - Unimplimented operation
	.LONG	emsund		; 66 - Unimplimented operation
	.LONG	emsund		; 67 - Unimplimented operation
	.LONG	emsgaapfs	; 68 - EEMS - GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM
	.LONG	emsmpif		; 69 - EEMS - MAP PAGE INTO FRAME
	.LONG	emspm		; 6A - EEMS - PAGE MAPPING
I67MAX=!{$-int67tbl}/4-1
.PAGE
	.SBTTL	errtbl - XOS to DOS error code translation table

	.MACRO	E  error, class, action, locus
	.BYTE	DE_'error, DC_'class, DA_'action, DL_'locus
	.ENDM

DE_0=!0
DC_0=!0
DA_0=!0
DL_0=!0

 E FAIL , OUTRS, CLNUP, UNKWN	;ER_TMDVC = -97 Too many devices open for
				;		  device class
 E FAIL , OUTRS, CLNUP, UNKWN	;ER_BFBSY = -96 Buffer IO already in use for
				;		  device
 E FAIL , OUTRS, CLNUP, UNKWN	;ER_NSCLS = -95 No such device class
 E FAIL , OUTRS, CLNUP, UNKWN	;ER_PDNAV = -94 Physical device not available
 E FAIL , OUTRS, CLNUP, UNKWN	;ER_BFERR = -93 Buffer or buffer header block
				;		  error
 E FAIL , OUTRS, CLNUP, UNKWN	;ER_TMPS  = -92 Too many processes in system
 E FAIL , HRDWR, CLNUP, UNKWN	;ER_TIMER = -91 Time-out
 E FAIL , INVTP, CLNUP, UNKWN	;ER_NTLNG = -90 Name is too long
 E FAIL , INVTP, CLNUP, UNKWN	;ER_WLDNA = -89 Wild card name not allowed
 E FAIL , INVTP, CLNUP, UNKWN	;ER_BDLNM = -88 Bad logical name
 E FAIL , INVTP, CLNUP, UNKWN	;ER_NTDEF = -87 Not defined
 E FAIL , INVTP, CLNUP, UNKWN	;ER_FSINC = -86 File system is inconsistant
 E FAIL , INVTP, CLNUP, UNKWN	;ER_MSGOV = -85 Process has too many messages
				;		  waiting
 E FAIL , INVTP, CLNUP, UNKWN	;ER_MSGNE = -84 Process not enabled to receive
 E FAIL , INVTP, CLNUP, UNKWN	;ER_MSGNA = -83 Requested message not available
 E DSKI , APPLI, CLNUP, UNKWN	;ER_NTFIL = -82 Not file structured
 E DATER, HRDWR, CLNUP, UNKWN	;ER_DRWER = -81 Directory write error
 E DATER, HRDWR, CLNUP, UNKWN	;ER_DRRER = -80 Directory read error
 E FMTI , INVTP, CLNUP, BLOCK	;ER_DRFER = -79 Directory format error
 E DATER, HRDWR, CLNUP, UNKWN	;ER_SBWER = -78 SAT write error
 E DATER, HRDWR, CLNUP, UNKWN	;ER_SBRER = -77 SAT read error
 E FMTI , INVTP, CLNUP, UNKWN	;ER_SBFER = -76 SAT format error
 E DATER, HRDWR, CLNUP, UNKWN	;ER_HMRER = -75 HOM read error
 E FMTI , INVTP, CLNUP, UNKWN	;ER_HMFER = -74 HOM format error
 E DATER, HRDWR, CLNUP, UNKWN	;ER_FBWER = -73 FIB write error
 E DATER, HRDWR, CLNUP, UNKWN	;ER_FBRER = -72 FIB read error
 E FMTI , INVTP, CLNUP, UNKWN	;ER_FBPER = -71 FIB pointer error
 E FMTI , INVTP, CLNUP, UNKWN	;ER_FBFER = -70 FIB format error
 E LCKV , TEMP , CLNUP, UNKWN	;ER_DLOCK = -69 Deadlock error
 E DATI , APPLI, CLNUP, UNKWN	;ER_BPIPE = -68 Pipe error
 E FINV , APPLI, CLNUP, UNKWN	;ER_ILSEK = -67 Illegal seek function
 E FAIL , INVTP, CLNUP, UNKWN	;ER_NTTRM = -66 Device not a terminal
 E FAIL , INVTP, CLNUP, UNKWN	;ER_ISDIR = -65 File is a directory
 E PNF  , INVTP, CLNUP, UNKWN	;ER_NTDIR = -64 File not a directory
 E FAIL , TEMP , CLNUP, UNKWN	;ER_NTRDY = -63 Device not ready
 E FMTI , INVTP, CLNUP, UNKWN	;ER_FMTER = -62 Format error
 E FAIL , APPLI, CLNUP, UNKWN	;ER_NACT  = -61 Device not active
 E DATI , INVTP, CLNUP, UNKWN	;ER_RTOBG = -60 Record too big
 E DSKCI, INVTP, INTRV, UNKWN	;ER_DKCHG = -59 Disk changed
 E FAIL , APPLI, CLNUP, UNKWN	;ER_IADEV = -58 Illegal address for device
 E FAIL , APPLI, CLNUP, UNKWN	;ER_ICDEV = -57 Illegal count for device
 E FINV , APPLI, CLNUP, UNKWN	;ER_IFDEV = -56 Illegal function for device
 E FMTI , INVTP, CLNUP, UNKWN	;ER_NOSTK = -55 No stack specified in image
				;		  file
 E FMTI , INVTP, CLNUP, UNKWN	;ER_NOSAD = -54 No starting address specified
				;		  in image file
 E FMTI , INVTP, CLNUP, UNKWN	;ER_RELTR = -53 Reloc. truncation in image file
 E FMTI , INVTP, CLNUP, UNKWN	;ER_IIFRD = -52 Illegal relocation data
 E FMTI , INVTP, CLNUP, UNKWN	;ER_IIFF  = -51 Illegal image file format
 E FMTI , INVTP, CLNUP, UNKWN	;ER_IIFT  = -50 Illegal image file type
 E FAIL , APPLI, CLNUP, UNKWN	;ER_ADRER = -49 Address error
 E RDFLT, APPLI, CLNUP, UNKWN	;ER_OUTO  = -48 Input to output only device
 E WRFLT, APPLI, CLNUP, UNKWN	;ER_INO   = -47 Output to input only device
 E HNDLI, APPLI, CLNUP, UNKWN	;ER_BDDD  = -46 Bad device descriptor
 E DATI , APPLI, CLNUP, UNKWN	;ER_BDDBK = -45 Bad disk block no.
 E FAIL , HRDWR, CLNUP, UNKWN	;ER_NORSP = -44 Device time-out
 E FAIL , APPLI, CLNUP, UNKWN	;ER_DATTR = -43 Data truncated
 E DATER, HRDWR, CLNUP, UNKWN	;ER_DEVER = -42 Device error
 E WRTPR, HRDWR, INTRV, UNKWN	;ER_WPRER = -41 Write protect error
 E WRFLT, HRDWR, CLNUP, UNKWN	;ER_WRTER = -40 Write fault error
 E DATER, HRDWR, CLNUP, UNKWN	;ER_LSTER = -39 Lost data error
 E SCTNF, HRDWR, CLNUP, BLOCK	;ER_RNFER = -38 Record not found
 E SEKER, HRDWR, CLNUP, BLOCK	;ER_SEKER = -37 Seek error
 E DATER, HRDWR, CLNUP, BLOCK	;ER_IDFER = -36 ID field error
 E DATER, HRDWR, CLNUP, UNKWN	;ER_DATER = -35 Data error
 E PNF  , OUTRS, CLNUP, BLOCK	;ER_DIRTD = -34 Directory level too deep
 E ARCD , APPLI, CLNUP, BLOCK	;ER_DIRNE = -33 Directory not empty
 E NOMRF, OUTRS, CLNUP, BLOCK	;ER_DIRFL = -32 Directory full
 E PNF  , NTFND, GTCOR, BLOCK	;ER_DIRNF = -31 Directory not found
 E ACCD , AUTHR, GTCOR, BLOCK	;ER_FILPF = -30 Protection failure
 E FAIL , TEMP , CLNUP, UNKWN	;ER_BUSY  = -29 File or device busy
 E FILEX, APPLI, GTCOR, BLOCK	;ER_FILEX = -28 File exists
 E FNF  , NTFND, GTCOR, BLOCK	;ER_FILNF = -27 File not found
 E NTSMD, OUTRS, CLNUP, UNKWN	;ER_DFDEV = -26 Different device
 E TMOF , OUTRS, CLNUP, UNKWN	;ER_TMDVP = -25 Too many devices for process
 E FAIL , OUTRS, CLNUP, BLOCK	;ER_DEVFL = -24 Device is full
 E FAIL , APPLI, CLNUP, UNKWN	;ER_DNA   = -23 Device not assigned
 E FAIL , APPLI, CLNUP, UNKWN	;ER_DNO   = -22 Device not open
 E FAIL , APPLI, CLNUP, UNKWN	;ER_DIO   = -21 Device is open
 E FAIL , OUTRS, CLNUP, UNKWN	;ER_DIU   = -20 Device in use
 E DSKI , APPLI, CLNUP, UNKWN	;ER_NSDEV = -19 No such device
 E FAIL , APPLI, CLNUP, UNKWN	;ER_BDSPC = -18 Bad device/file specification
 E FAIL , TEMP , CLNUP, UNKWN	;ER_ACT   = -17 Device is active
 E INSFM, OUTRS, CLNUP, UNKWN	;ER_NOBUF = -16 No buffer available
 E INSFM, OUTRS, CLNUP, UNKWN	;ER_NOQEL = -15 No queue element available
 E MCBD , SFTWR, CLNUP, MEM  	;ER_MAERR = -14 Memory allocation error
 E MBAI , APPLI, CLNUP, MEM  	;ER_MACFT = -13 Memory allocation conflict
 E INSFM, OUTRS, CLNUP, MEM  	;ER_NEMA  = -12 Not enough memory available
 E FAIL , OUTRS, CLNUP, UNKWN	;ER_NASA  = -11 No address space available
 E ACCD , AUTHR, CLNUP, BLOCK	;ER_PRIV  = -10 Not enough privilege
 E FAIL , APPLI, CLNUP, UNKWN	;ER_NSP   = -9  No such process
 E FAIL , APPLI, CLNUP, UNKWN	;ER_BDPID = -8  Bad process ID
 E FAIL , APPLI, CLNUP, UNKWN	;ER_BDNAM = -7  Bad process name
 E FINV , APPLI, CLNUP, UNKWN	;ER_FUNCM = -6  Illegal function for mode
 E FAIL , APPLI, CLNUP, UNKWN	;ER_PARMV = -5  Illegal parameter value
 E FAIL , APPLI, CLNUP, UNKWN	;ER_PARMN = -4  Illegal parameter value
 E FINV , APPLI, CLNUP, UNKWN	;ER_FUNC  = -3  Illegal function
 E FINV , APPLI, CLNUP, UNKWN	;ER_SVC   = -2  Illegal SVC
 E DATI , NTFND, CLNUP, BLOCK	;ER_EOF   = -1  End of file
errtbl:
 E 0    , 0    , 0    , 0	;ER_NOERR =  0  Normal return

	CODE

	.SBTTL	emsund - LIM EMS - Undefined function return
;	  AH = 40h
; Return: AH = status
; 	    84h undefined function requested by application
emsund:
	MOVL	EAX, #84H.B
	MOVB	SS:pdaURegEAX##+1, AL
	CLC				; Show no error
	RET

	.SBTTL	emsgms - LIM EMS - GET MANAGER STATUS
;	  AH = 40h
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested by application
; Note:	this call can be used only after establishing that the EMM driver
;	is in fact present
emsgms:
	CLRL	EAX
	MOVB	SS:pdaURegEAX##+1, AL
	CLC				; Show no error
	RET
.PAGE

	.SBTTL	emsgpf - LIM EMS - GET PAGE FRAME SEGMENT
;	  AH = 41h
; Return: AH = 00h function successful
; 	    BX = segment of page frame
;	    AH = error code (see AH=40h)
emsgpf:
	CLRL	EAX
	MOVB	SS:pdaURegEAX##+1, AL
	MOVL	EAX, pageframe
	MOVW	SS:pdaURegEBX##, AX
	CLC				; Show no error
	RET
.PAGE

	.SBTTL	emsgnp - LIM EMS - GET NUMBER OF PAGES
;	  AH = 42h
; Return: AH = 00h function successful
; 	    BX = number of unallocated pages
; 	    DX = total number of pages
;	    AH = error code (see AH=40h)
emsgnp:
	CLRL	EAX
	MOVB	SS:pdaURegEAX##+1, AL	; Show no error occured
	MOVW	SS:pdaURegEBX##, AX
	MOVL	EAX, emsmlimit		; Get the EMS memory limit number
	SHRL	EAX, #14t		; Divide by 16K to get number of pages
	MOVW	SS:pdaURegEDX##, AX	; Return number of pages to user
	CLC				; Show no error
	RET
.PAGE

	.SBTTL	emsgha - LIM EMS - GET HANDLE AND ALLOCATE MEMORY
;	  AH = 43h
; 	  BX = number of logical pages to allocate
; Return: AH = status
; 	    00h function successful
; 		DX = handle
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
; 	    85h no more handles available
; 	    87h more pages requested than physically exist
; 	    88h more pages requested than currently available
; 	    89h zero pages requested
emsgha:
	MOVB	AL, #85h.B
	MOVB	SS:pdaURegEAX##+1, AL
	RET
.PAGE

	.SBTTL	emsmm - LIM EMS - MAP MEMORY
;	  AH = 44h
; 	  AL = physical page number (0-3)
; 	  BX = logical page number
;      	  DX = handle
; Return: AH = status
; 	    00h function successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    8Ah invalid logical page number
; 	    8Bh illegal physical-page number
emsmm:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsrhm - LIM EMS - RELEASE HANDLE AND MEMORY
;	  AH = 45h
; 	  DX = EMM handle
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    86h error in save or restore of mapping context
emsrhm:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgev - LIM EMS - GET EMM VERSION
;	  AH = 46h
; Return: AH = status
; 	    00h successful
; 		AL = EMM version number
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
emsgev:
	MOVL	EAX, #EMMVER
	MOVW	SS:pdaURegEAX##, AX
	CLC
	RET
.PAGE

	.SBTTL	emssmc - LIM EMS - SAVE MAPPING CONTEXT
;	  AH = 47h
; 	  DX = handle
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    8Ch page-mapping hardware state save area is full
; 	    8Dh save of mapping context failed
emssmc:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsrmc - LIM EMS - RESTORE MAPPING CONTEXT
;	  AH = 48h
; 	  DX = handle
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    8Eh restore of mapping context failed
emsrmc:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsneh - LIM EMS - GET NUMBER OF EMM HANDLES
;	  AH = 4Bh
; Return: AH = status
; 	    00h successful
; 		BX = number of EMM handles
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
emsneh:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emspoh - LIM EMS - GET PAGES OWNED BY HANDLE
;	  AH = 4Ch
; 	  DX = EMM handle
; Return: AH = status
; 	    00h successful
; 		BX = number of logical pages
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
emspoh:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emspah - LIM EMS - GET PAGES FOR ALL HANDLES
;	  AH = 4Dh
; 	  ES:DI -> array to receive information
; Return: AH = status
; 	    00h successful
; 		BX = number of active EMM handles
; 		array filled with 2-word entries, consisting of a handle
; 		  and the number of pages allocated to that handle
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
emspah:
	MOVL	EAX, #0
	MOVW	SS:pdaURegEAX##, AX
	MOVW	SS:pdaURegEBX##, AX
	CLC
	RET
.PAGE

	.SBTTL	emsgspm - LIM EMS - GET OR SET PAGE MAP
;	  AH = 4Eh
; 	  AL = 00h if getting mapping registers
; 	       01h if setting mapping registers
; 	       02h if getting and setting mapping registers at once
; 	       03h if getting size of page-mapping array
; 	  DS:SI -> array holding information (AL=01/02)
; 	  ES:DI -> array to receive information (AL=00/02)
; Return: AH = status
; 	    00h successful
; 		AL = bytes in page-mapping array (AL=03h only)
; 		array pointed to by ES:DI receives mapping info (AL=00h/02h)
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
; 	    8Fh undefined subfunction parameter
; 	    A3h contents of source array corrupted (EMS 4.0?)
; Note:	this function was designed to be used by multitasking operating systems
; 	  and should not ordinarily be used by appplication software.
emsgspm:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgsppm - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP
;	  AH = 4Fh
; 	  AL = subfunction
; 	    00h get partial page map
; 	       DS:SI -> structure containing list of segments whose mapping
; 			contexts are to be saved
; 	       ES:DI -> array to receive page map
; 	    01h set partial page map
; 	       DS:SI -> structure containing saved partial page map
; 	    02h get size of partial page map
; 	       BX = number of mappable segments in the partial map to be saved
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
; 	    8Bh one of specified segments is not mappable
; 	    8Fh undefined subfunction parameter
; 	    A3h contents of partial page map corrupted or count of mappable
; 		segments exceeds total number of mappable segments in system
; 	  AL = size of partial page map for subfunction 02h
emsgsppm:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsmumhp - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
;	  AH = 50h
; 	  AL = subfunction
; 	    00h
; 	    01h
; 	  DX = handle
; 	  CX = number of entries in array
; 	  DS:SI -> mapping array
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    8Ah one or more logical pages are invalid
; 	    8Bh one or more physical pages are invalid
; 	    8Fh invalid subfunction
emsmumhp:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsrp - LIM EMS 4.0 - REALLOCATE PAGES
;	  AH = 51h
; 	  DX = handle
; 	  BX = number of pages to be allocated to handle
; Return: BX = actual number of pages allocated to handle
;	  AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    87h more pages requested than present in system
; 	    88h more pages requested than currently available
emsrp:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgsha - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES
;	  AH = 52h
; 	  AL = subfunction
; 	    00h get handle attributes
; 		Return: AL = attribute
; 			    00h handle is volatile
; 			    01h handle is nonvolatile
; 	    01h set handle attributes
; 		BL = new attribute (see returned AL)
; 	    02h get attribute capability
; 		Return: AL = attribute capability
; 			    00h only volatile handles supported
; 			    01h both volatile and non-volatile supported
; 	  DX = handle
; Return:	AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    8Fh undefined subfunction
; 	    90h undefined attribute type
; 	    91h feature not supported
emsgsha:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgshn - LIM EMS 4.0 - GET/SET HANDLE NAME
;	  AH = 53h
; 	  AL = subfunction
; 	    00h get handle name
; 	       ES:DI -> 8-byte handle name array
; 	    01h set handle name
; 	       DS:SI -> 8-byte handle name
; 	  DX = handle
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    8Fh undefined subfunction
; 	    A1h duplicate handle name
emsgshn:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsghd - LIM EMS 4.0 - GET HANDLE DIRECTORY
;	  AH = 54h
; 	  AL = subfunction
; 	    00h get handle directory
; 	       ES:DI -> buffer for handle directory
; 	    01h search for named handle
; 	       DS:SI -> 8-byte name
; 	    02h get total number of handles
; Return: AL = number of entries in handle directory (subfunction 00h)
; 	  DX = value of named handle (subfunction 01h)
; 	  BX = total number of handles (subfunction 02h)
;	  AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
; 	    8Fh undefined subfunction
; 	    A0h no such handle name
; 	    A1h a handle found had no name
emsghd:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsapmj - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP
;	  AH = 55h
; 	  AL = subfunction
; 	    00h physical page numbers provided by caller
; 	    01h segment addresses provided by caller
; 	  DX = handle
; 	  DS:SI -> structure containing map and jump address
; Return: (at target address unless error)
;	  AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware failure
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    8Ah invalid logical page number encountered
; 	    8Bh invalid physical page number encountered
; 	    8Fh invalid subfunction
emsapmj:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsapmc - LIM EMS 4.0 - ALTER PAGE MAP AND CALL
;	  AH = 56h
; 	  AL = subfunction
; 	    00h physical page numbers provided by caller
; 		DX = handle
; 		DS:SI -> structure containing page map and call address
; 	    01h segment addresses provided by caller
; 		DX = handle
; 		DS:SI -> structure containing page map and call address
; 	    02h get page map stack space required
; 		Return: BX = stack space required
; Return: (if successful, the target address is called.  Use a RETF to return and
; 	 restore mapping context)
;	  AH = status (see AH=55h)
emsapmc:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsmemr - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION
;	  AH = 57h
; 	  AL = subfunction
; 	    00h move memory region
; 	    01h exchange memory region
; 	  DS:SI -> structure describing source and destination
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware failure
; 	    83h invalid handle
; 	    84h undefined function requested
; 	    8Ah invalid logical page number encountered
; 	    8Fh undefined subfunction
; 	    92h successful, but a portion of the source region has been
; 		overwritten
; 	    93h length of source or destination region exceeds length of region
; 		allocated to either source or destination handle
; 	    94h conventional and expanded memory regions overlap
; 	    95h offset within logical page exceeds size of logical page
; 	    96h region length exceeds 1M
; 	    97h source and destination EMS regions have same handle and overlap
; 	    98h memory source or destination type undefined
; 	    A2h attempted to wrap around 1M conventional address space
emsmemr:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgmpaa - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY
;	  AH = 58h
; 	  AL = subfunction
; 	    00h get mappable physical address array
; 		ES:DI -> buffer to be filled with array
; 	    01h get number of entries in m.p.a. array
; Return: CX = number of entries in array
;	  AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware failure
; 	    84h undefined function requested
; 	    8Fh undefined subfunction
emsgmpaa:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgemhi - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION
;	  AH = 59h
; 	  AL = subfunction
; 	    00h get hardware configuration array
; 		ES:DI -> buffer to be filled with array (see below)
; 	    01h get unallocated raw page count
; 		Return: BX = unallocated raw pages
; 			DX = total raw pages
; Return:	AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware failure
; 	    84h undefined function requested
; 	    8Fh undefined subfunction
; 	    A4h access denied by operating system
; Note:	subfunction 00h is for use by operating systems only, and can be
; 	  enabled or disabled at any time by the operating system
; 
; Format of hardware configuration array:
; Offset	Size	Description
;  00h	WORD	size of raw EMM pages in paragraphs
;  02h	WORD	number of alternate register sets
;  04h	WORD	size of mapping-context save area in bytes
;  06h	WORD	number of register sets assignable to DMA
;  08h	WORD	DMA operation type
; 		0000h DMA with alternate register sets
; 		0001h only one DMA register set
emsgemhi:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsasrp - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES
;	  AH = 5Ah
; 	  AL = subfunction
; 	    00h allocate standard pages
; 	    01h allocate raw pages
; 	  BX = number of pages to allocate
; Return: DX = handle
;	  AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware failure
; 	    84h undefined function requested
; 	    85h no more handles available
; 	    87h insufficient memory pages in system
; 	    88h insufficient memory pages available
; 	    8Fh undefined subfunction
emsasrp:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsamrs - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET
;	  AH = 5Bh
; 	  AL = subfunction
; 	    00h get alternate map register set
; 		Return: BL = current active alternate map register set number
; 			ES:DI -> map register context save area if BL=00h
; 	    01h set alternate map register set
; 		BL = new alternate map register set number
; 		ES:DI -> map register context save area if BL=0
; 	    02h get alternate map save array size
; 		Return: DX = array size in bytes
; 	    03h allocate alternate map register set
; 		Return: BL = number of map register set; 00h = not supported
; 	    04h deallocate alternate map register set
; 		BL = number of alternate map register set
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
; 	    8Fh undefined subfunction
; 	    9Ah specified alternate map register set not supported
; 	    9Bh all alternate map register sets currently allocated
; 	    9Ch alternate map register sets not supported
; 	    9Dh undefined or unallocated alternate map register set
; 	    A3h source array corrupted
; 	    A4h operating system denied access
;
; or
;
; LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS
;	  AH = 5Bh
; 	  AL = subfunction
; 	    05h allocate DMA register set
; 		Return: BL = DMA register set number, 00h if not supported
; 	    06h enable DMA on alternate map register set
; 	       BL = DMA register set number
; 	       DL = DMA channel number
; 	    07h disable DMA on alternate map register set
; 	       BL = DMA register set number
; 	    08h deallocate DMA register set
; 	       BL = DMA register set number
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
; 	    8Fh undefined subfunction
; 	    9Ah specified DMA register set not supported
; 	    9Bh all DMA register sets currently allocated
; 	    9Ch alternate DMA sets not supported
; 	    9Dh undefined or unallocated DMA register set
; 	    9Eh dedicated DMA channels not supported
; 	    9Fh specified dedicated DMA channel not supported
; 	    A3h source array corrupted
; 	    A4h operating system denied access
; Note:	this function is for use by operating systems only, and can be
; 	  enabled or disabled at any time by the operating system
emsamrs:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emspemhwb - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT
;	  AH = 5Ch
; Return: AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
emspemhwb:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsedofsf - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS
;	  AH = 5Dh
; 	  AL = subfunction
; 	    00h enable OS Function Set
; 	    01h disable OS Function Set
; 	    02h return access key (resets memory manager, returns access key at
; 		next invocation)
; 	  BX,CX = access key returned by first invocation
; Return: BX,CX = access key, returned only on first invocation of function
;	  AH = status
; 	    00h successful
; 	    80h internal error
; 	    81h hardware malfunction
; 	    84h undefined function requested
; 	    8Fh undefined subfunction
; 	    A4h operating system denied access
emsedofsf:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgpwa - EEMS - GET PHYSICAL WINDOW ARRAY
;	  AH = 60h
; 	  ES:DI -> buffer
; Return: AH = status
; 	  AL = number of entries
; 	  buffer at ES:DI filled
emsgpwa:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgacs - EEMS - GENERIC ACCELERATOR CARD SUPPORT
;	  AH = 61h
; 	???
; Return: ???
; Note:	can be used by accelerator card manufacturer to flush RAM cache,
; 	  ensuring that the cache accurately reflects what the processor would
; 	  see without the cache.
emsgacs:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsgaapfs - EEMS - GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM
;	  AH = 68h
; 	  ES:DI -> buffer
; Return: AH = status
; 	  AL = number of entries
; 	  buffer at ES:DI filled
; Note:	equivalent to LIM 4.0 function 58h
emsgaapfs:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emsmpif - EEMS - MAP PAGE INTO FRAME
;	  AH = 69h
; 	  AL = frame number
; 	  BX = page number
; 	  DX = handle
; Return: AH = status
; Note:	similar to EMS function 44h
emsmpif:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE

	.SBTTL	emspm - EEMS - PAGE MAPPING
;	  AH = 6Ah
; 	  AL = subfunction
; 	    00h save partial page map
; 		CH = first page frame
; 		CL = number of frames
; 		ES:DI -> buffer which is to be filled
; 	    01h restore partial page map
; 		CH = first page frame
; 		CL = number of frames
; 		DI:SI -> previously saved page map
; 	    02h save and restore partial page map
; 		CH = first page frame
; 		CL = number of frames
; 		ES:DI = buffer for current page map
; 		DI:SI = new page map
; 	    03h get size of save array
; 		CH = first page frame
; 		CL = number of frames
; 		Return: AL = size of array in bytes
; 	    04h switch to standard map register setting
; 	    05h switch to alternate map register setting
; 	    06h deallocate pages mapped to frames in conventional memory
; 		CH = first page frame
; 		CL = number of frames
; Return: AH = status
; Note:	similar to EMS function 4Eh, except that a subrange of pages can be
; 	  specified
emspm:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE
	.SBTTL	Data

	DATA

;Define offsets in the EMCB (Expanded Memory Control Block)

$$$=!4
BLK emcb_mhandle   , 2t		;Maximum number of memory handles
BLK emcb_chandle   , 2t		;Current number of memory handles in use
BLK emcb_pageframe , 2t		;Virtual Page frame segment
BLK emcb_availpage , 2t		;Available number of memory pages
BLK emcb_totalpage , 2t		;Total number of memory pages
emcb_SIZE=!$$$

lastint67::
	.LONG	0
;emsrngpnt::
;	.LONG	emsrngbgn
;emsrngbgn::
;	.BLKB	32t*8
;emsrngend::

emmccb:	  .BLKB	ccb_SIZE	;EMM CCB
emsmlimit:.LONG	1024000t	;EMS process memory limit
xmsmlimit:.LONG	1024000t	;XMS process memory limit
emshlimit:.WORD	256t		;EMS process handle limit
pageframe:.WORD	0E000h		;Page frame segment

	LKEEND

