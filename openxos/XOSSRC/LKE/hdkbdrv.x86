	.TITLE	HDKBDRV - Hard disk device driver type B
	.SBTTL	Copyright (c) 1987-1994, Saguaro Software, Ltd.

	.PROC	80486
	.INCLUD	ALGINC:\AMAC\ALLEGRO.PAR
	.INCLUD	ALGINC:\AMAC\ALLEGROX.PAR
	.INCLUD	ALGINC:\AMAC\ALGERR.PAR
	.INCLUD	ALGINC:\AMAC\PCAT.PAR
	.INCLUD	ALGINC:\AMAC\ALGXDISK.PAR
	.INCLUD	ALGINC:\AMAC\ALGDISK.PAR
	.INCLUD	ALGINC:\AMAC\ALGLKE.PAR
	.INCLUD	ALGINC:\AMAC\ALGXLKE.PAR
	.INCLUD	ALGINC:\AMAC\ALGXHDK.PAR

;This is the device driver for IDE hard disk controllers which use BIOS
;  configuration mapping.  It supports the LKELOAD-time BOOT characteristic
;  and can be loaded during start-up as the boot device.

MAJV   =!1t
MINV   =!0t
EDITNUM=!0t

;v1.0.0  4-Nov-94
;	Initial version

	LKEHEAD	HDKBDRV, MAJV, MINV, EDITNUM, LKETYPE_DEVICE

;Define time-out values (in seconds)

TO_RESTORE=!20t		;Restore time-out period
TO_XFER   =!6t		;Data transfer time-out period
TO_RESET  =!20t		;Reset time-out period

	CODE

;Hard disk device driver dispatch table.  Note that kf_xxx entries are for
;  controller functions which require ownership of the controller.  They must
;  be called only by passing their index to the algdskXfer routine.  The ks_xxx
;  entires are for general subroutines which do not require controller
;  ownership.  They are called directly.  They must NOT be passed to algdskXfer.

hdkdsp:	.LONG	hdkinit		;kf_init     =  0. - Initialize controller
	.LONG	hdkgetparms	;kf_getparms =  4. - Get drive parameters
	.LONG	hdksetparms	;kf_setparms =  8. - Set drive parameters
	.LONG	hdkreadraw	;kf_readraw  = 12. - Read raw
	.LONG	hdkreaddata	;kf_readdata = 16. - Read block
	.LONG	hdkreadlist	;kf_readlist = 20. - Read buffer list
	.LONG	0		;kf_readid   = 24. - Read ID field
	.LONG	hdkwritraw	;kf_writraw  = 28. - Write raw
	.LONG	hdkwritdata	;kf_writdata = 32. - Write block
	.LONG	hdkwritlist	;kf_writlist = 36. - Write buffer list
	.LONG	hdkformat	;kf_format   = 40. - Format track
	.LONG	0		;kf_chkwp    = 44. - Check write protect status
	.LONG	0		;kf_chkchg   = 48. - Check for possible disk
				;		       change at fork level
				;		       (never called for hard
				;		       disk!)
	.LONG	algdskHdkMedia##;ks_media    = 52. - Determine media type
	.LONG	knlRtnZero##	;ks_chkwp    = 56. - Check write protect status
	.LONG	algdskNotChg##	;ks_chkchg   = 60. - Check for possible disk
				;		       change
	.LONG	algdskNotChg##	;ks_senchg   = 64. - Sense disk change
	.LONG	hdkbaddunit	;ks_addunit  = 68. - Add disk unit
	.LONG	algdskHdkClear##;ks_unmount  = 72. - Unmount disk

;Hard disk type A device characteristics table

hdkdchartbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS   , TEXT, 8  , knlDcMsgClass##    , knlDcGetClass## , knlDcSetClass##   , 0
 DCHARENT  TYPE    , TEXT, 4  , knlDcMsgType##     , knlDcGet4Byte## , 0                 , dcb_type
 DCHARENT  IOREG   , HEXV, 2  , knlDcMsgIoReg##    , algdskGtU2Byte##, 0                 , ucb_ioreg
 DCHARENT  INDEX   , DECV, 1  , knlDcMsgIndex##    , algdskGtU1Byte##, 0                 , ucb_index
 DCHARENT  MODEL   , STR , 42 , knlDcMsgModel##    , algdskGtUxStr## , 0                 , ucbx_model
 DCHARENT  SERIALNO, STR , 22 , knlDcMsgSerialNo## , algdskGtUxStr## , 0                 , ucbx_serialno
 DCHARENT  REVISION, STR , 10 , knlDcMsgRevision## , algdskGtUxStr## , 0                 , ucbx_revision
 DCHARENT  CONFIG  , HEXV, 4  , msgconfig          , algdskGtU4Byte##, 0                 , ucb_hdconfig
 DCHARENT  SECPINT , DECV, 4  , msgsecpint         , algdskGtU4Byte##, 0                 , ucb_hdsecpi
 DCHARENT  BUFSIZE , DECV, 4  , msgbufsize         , algdskGtU4Byte##, 0                 , ucb_hdbufsz
 DCHARENT  UNITTYPE, TEXT, 4  , knlDcMsgUnitType## , algdskUnitType##, 0                 , 0
 DCHARENT  MSENSOR , TEXT, 4  , algdskMsgMSensor## , algdskGetBits## , 0                 , UB$MEDIAC
 DCHARENT  REMOVE  , TEXT, 4  , algdskMsgRemove##  , algdskGetBits## , 0                 , UB$REMOVE
 DCHARENT  DOSNAME , TEXT, 8  , algdskMsgDosName## , algdskGtU8Byte##, algdskStU8Byte##  , ucb_dosname
 DCHARENT  VOLNAME , TEXT, 8  , algdskMsgVolName## , algdskGtU8Byte##, algdskStU8Byte##  , ucb_volname
 DCHARENT  PARTN   , HEXV, 1  , algdskMsgPartn##   , algdskGtU1Byte##, 0                 , ucb_partnx
 DCHARENT  PARTOFF , DECV, 4  , algdskMsgPartOff## , algdskGtU4Byte##, 0                 , ucb_partnoff
 DCHARENT  CBLKSZ  , DECV, 2  , algdskMsgCBlkSz##  , algdskGtU4Byte##, 0                 , ucb_secsz
 DCHARENT  CHEADS  , DECV, 1  , algdskMsgCHeads##  , algdskGtU1Byte##, algdskHdkSetHead##, ucb_headc
 DCHARENT  CSECTS  , DECV, 4  , algdskMsgCSects##  , algdskGtU4Byte##, algdskHdkSetSec## , ucb_secc
 DCHARENT  CCYLNS  , DECV, 4  , algdskMsgCCylns##  , algdskGtU4Byte##, algdskHdkSetCyln##, ucb_cyln
 DCHARENT  DBLKSZ  , DECV, 2  , algdskMsgDBlkSz##  , algdskGtU4Byte##, algdskStU4Byte##  , ucb_secszi
 DCHARENT  DHEADS  , DECV, 1  , algdskMsgDHeads##  , algdskGtU1Byte##, algdskStU1Byte##  , ucb_headci
 DCHARENT  DSECTS  , DECV, 4  , algdskMsgDSects##  , algdskGtU4Byte##, algdskStU4Byte##  , ucb_secci
 DCHARENT  DCYLNS  , DECV, 4  , algdskMsgDCylns##  , algdskGtU4Byte##, algdskStU4Byte##  , ucb_cylni
 DCHARENT  BLOCKS  , DECV, 4  , algdskMsgBlocks##  , algdskGtU4Byte##, 0                 , ucb_blocks
 DCHARENT  RAMAX   , DECV, 4  , knlDcMsgRAMax##    , algdskGtU4Byte##, algdskSetRAMax##  , ucb_ramax
 DCHARENT  RAHLIMIT, DECV, 4  , knlDcMsgRAhLimit## , algdskGtU4Byte##, 0                 , ucb_rahlimit
 DCHARENT  BLOCKIN , DECV, 4  , algdskMsgBlockIn## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_blockin
 DCHARENT  BLOCKOUT, DECV, 4  , algdskMsgBlockOut##, algdskGtU4Byte##, algdskStU4Byte##  , ucb_blockout
 DCHARENT  BYTEIN  , DECV, 4  , knlDcMsgByteIn##   , algdskGtU4Byte##, algdskStU4Byte##  , ucb_bytein
 DCHARENT  BYTEOUT , DECV, 4  , knlDcMsgByteOut##  , algdskGtU4Byte##, algdskStU4Byte##  , ucb_byteout
 DCHARENT  SHRDELAY, DECV, 4  , algdskMsgShrDelay##, algdskGtU4Byte##, algdskStU4Byte##  , ucb_shrdelay
 DCHARENT  SHRRETRY, DECV, 4  , algdskMsgShrRetry##, algdskGtU4Byte##, algdskStU4Byte##  , ucb_shrretry
 DCHARENT  SHRFAIL , DECV, 4  , algdskMsgShrFail## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_shrfail
 DCHARENT  TDEVERR , DECV, 4  , knlDcMsgTDevErr##  , algdskGtU4Byte##, algdskStU4Byte##  , ucb_tdeverr
 DCHARENT  HDEVERR , DECV, 4  , knlDcMsgHDevErr##  , algdskGtU4Byte##, algdskStU4Byte##  , ucb_hdeverr
 DCHARENT  TDATAERR, DECV, 4  , knlDcMsgTDataErr## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_tdataerr
 DCHARENT  HDATAERR, DECV, 4  , knlDcMsgHDataErr## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_hdataerr
 DCHARENT  TSEEKERR, DECV, 4  , algdskMsgTSeekErr##, algdskGtU4Byte##, algdskStU4Byte##  , ucb_tseekerr
 DCHARENT  HSEEKERR, DECV, 4  , algdskMsgHSeekErr##, algdskGtU4Byte##, algdskStU4Byte##  , ucb_hseekerr
 DCHARENT  TIDFERR , DECV, 4  , algdskMsgTIdFErr## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_tidferr
 DCHARENT  HIDFERR , DECV, 4  , algdskMsgHIdFErr## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_hidferr
 DCHARENT  TRNFERR , DECV, 4  , algdskMsgTRNFErr## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_trnferr
 DCHARENT  HRNFERR , DECV, 4  , algdskMsgHRNFErr## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_hrnferr
 DCHARENT  TOVRNERR, DECV, 4  , knlDcMsgTOvrnErr## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_tovrnerr
 DCHARENT  HOVRNERR, DECV, 4  , knlDcMsgHOvrnErr## , algdskGtU4Byte##, algdskStU4Byte##  , ucb_hovrnerr
 DCHARENT  HUNGERR , DECV, 4  , knlDcMsgHungErr##  , algdskGtU4Byte##, algdskStU4Byte##  , ucb_hungerr
 DCHARENT  UXINTERR, DECV, 4  , algdskMsgUnexpInt##, algdskGtU4Byte##, algdskStK4Byte##  , kcb_hduxint
 DCHARENT  FSTYPE  , TEXT, 8  , algdskMsgFSType##  , algdskGtU8Byte##, 0                 , ucb_fsname
 DCHARENT  PROTECT , TEXT, 4  , algdskMsgProtect## , algdskGetBits## , algdskSetProtect##, UB$PROTECT
 DCHARENT  CLSSZ   , DECV, 4  , algdskMsgClsSz##   , algdskGtU4Byte##, 0                 , ucb_clussize
 DCHARENT  CLUSTERS, DECV, 4  , algdskMsgClsters## , algdskGtU4Byte##, 0                 , ucb_total
 DCHARENT  AVAIL   , DECV, 4  , algdskMsgAvail##   , algdskGtU4Byte##, 0                 , ucb_avail
 DCHARENT  FATMODE , HEXV, 1  , algdskMsgFatMode## , algdskGtU1Byte##, 0                 , ucb_fatmode
 DCHARENT  ROOTBLK , DECV, 4  , algdskMsgRootBlk## , algdskGtU4Byte##, 0                 , ucb_rootblk
 DCHARENT  ROOTSIZE, DECV, 4  , algdskMsgRootSize##, algdskGtU4Byte##, 0                 , ucb_rootsize
 DCHARENT  ROOTPROT, STR , 100, algdskMsgRootProt##, algdskGtRtProt##, algdskStRtProt##  , 0

msgconfig:   DCHARINFO {Disk configuration bits}
msgsecpint:  DCHARINFO {Maximum sectors per interrupt}
msgbufsize:  DCHARINFO {Size of internal disk buffer}
.PAGE
	.SBTTL	Initialization

	INITSUB	inithdkb

	.MOD	4
hdkinitblk:					;Characteristics description
 DCHARBGN  2, knlDCharValCom##			;  block for initialization
 DCHARENT  BOOT    , DECV, 4, 0 , 0, initboot, 0

;Initialization subroutine
;	c{FDS:EDX] = Address of characteristics list
;	CALL	inithdkb
;	C:set = Error code
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Offset of first code byte to not save
;	  c{EDX} = Offset of first data byte to not save

inithdkb:
	PUSHL	FS
	PUSHL	EDX
	MOVL	EBX, #'HDKB'		;Get disk driver name
	MOVL	EDX, #hdkdsp		;Get offset of dispatch table
	CALL	algdskNewDriver##	;Register this disk driver
	POPL	EDX
	POPL	FS
	JC	6$.S			;If error
	ORL	EDX, EDX		;Have a characteristics list?
	JE	2$.S			;No
	MOVL	EBX, #hdkinitblk	;Yes - point to characteristics table
	CALL	knlAddUnitChar##	;Process characteristics
	JC	10$.S			;If error
2$:	CLRL	EAX			;OK
	CLRL	EDX
	MOVL	ECX, #codetop
	CMPL	CS:itintcode, #-1.B	;Did we set up an interrupt routine?
	JNE	4$.S			;Yes
	SUBL	ECX, #{codetop-itintcode}.B ;No - don't need that space
4$:	CLC
6$:	RET

;Here if error after driver has been registered

10$:	CALL	algdskUnlinkDriver##
	STC
	RET
.PAGE
	.MOD	4
hrdchar:DCHAR	UNIT   , SET, DECV, 1
hrdunit=!$-hrdchar
	.BYTE	0
	DCHAR	TYPE   , SET, TEXT, 4
	.ASCII	'HDKB'
	DCHAR	IOREG  , SET, HEXV, 2
	.WORD	1F0h
	DCHAR	INT    , SET, HEXV, 1
	.BYTE	14t
	DCHAR	INDEX  , SET, DECV, 1
hrdindex=!$-hrdchar
	.BYTE	1
	DCHAR	DHEADS , SET, DECV, 1
hrdheads=!$-hrdchar
	.BYTE	0
	DCHAR	DSECTS , SET, DECV, 1
hrdsects=!$-hrdchar
	.BYTE	0
	DCHAR	DCYLNS , SET, DECV, 2
hrdcylns=!$-hrdchar
	.WORD	0
	DCHAR	WPCCYLN, SET, DECV, 2
hrdwpcc=!$-hrdchar
	.WORD	0
	.BYTE	0
HRDCHARSZ=!{{$-hrdchar}+3}&{~3}

;Here for the BOOT characteristic

$$$=!0
FRM iboot_char, HRDCHARSZ
iboot_SIZE=!$$$

initboot:
	ENTER	iboot_SIZE, 0
	LEAL	EDI, iboot_char.B[EBP]	;Copy the characteristics list to our
	PUSHL	SS			;  stack frame
	POPL	ES
	MOVL	ESI, #hrdchar
	MOVL	ECX, #HRDCHARSZ/4
	CLD
	RMOVSL	[EDI], CS:[ESI]
	PUSHL	knlXCodePnt##
	MOVL	knlXCodePnt##, #itintcode
	MOVL	ESI, #knlHdkDataC##	;Set up disk C
	CALL	setuphdk
	JC	2$.S
	INCB	iboot_char+hrdunit.B[EBP]
	INCB	iboot_char+hrdindex.B[EBP]
	MOVL	ESI, #knlHdkDataD##	;Set up disk D
	CALL	setuphdk
2$:	POPL	knlXCodePnt##
	LEAVE
4$:	RET

;Subroutine to set up user mode once-only data for adding a hard disk unit
;	c{ESI} = Offset of BIOS hard disk data block
;	CALL	setuphdk

setuphdk:
	MOVZWL	EAX, [ESI]		;Get number of cylinders
	ORL	EAX, EAX		;If zero, disk is not installed
	JE	4$.S
	MOVW	iboot_char+hrdcylns.B[EBP], AX
	MOVB	AL, 2.B[ESI]		;Get number of heads
	MOVB	iboot_char+hrdheads.B[EBP], AL
	MOVZWL	EAX, 5.B[ESI]		;Get write pre-comp cylinder
	MOVW	iboot_char+hrdwpcc.B[EBP], AX
	MOVB	AL, 0E.B[ESI]		;Get number of sectors per track
	MOVB	iboot_char+hrdsects.B[EBP], AL
	CALL	knlGetQelClr##
	JC	4$.S
	LEAL	EAX, iboot_char.B[EBP]
	MOVL	iorb_buffer2+0.B[ESI], EAX
	MOVW	iorb_buffer2+4.B[ESI], SS
	MOVL	EAX, algdskCcb##+ccb_fdsp
	CALLI	CS:CF_ADDUNIT-8.B[EAX]
	FROMFORK
	BTL	EAX, #31t
	RET

	CODE
.PAGE
	.SBTTL	hdkbaddunit - Subroutine to add disk unit

;Subroutine to add disk unit
;	c{EAX}    = Unit number
;	c{EBX}    = Offset of KCB for controller (0 if none)
;	c{ECX}    = Index on controller
;	c{FS:EDX} = Address of characteristics list
;	c{ESI}    = Base IO register
;	CALL	hdkbaddunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count (number of units added)

$$$=!0
FRM hau_char , 8	;Address of characteristics list
FRM hau_ioreg, 4	;Base IO register number
FRM hau_int  , 4	;Interrupt number
FRM hau_index, 4	;Index on controller
FRM hau_unit , 1	;Unit number
FRM hau_info , 1	;Information about drive
FRM          , 1
FRM hau_xres , 1	;Non-zero if need to give up exec memory resource
FRM hau_wpc  , 4	;Write pre-comp cylinder
FRM hau_head , 4	;Number of heads
FRM hau_sect , 4	;Number of sectors per track
FRM hau_cyln , 4	;Number of cylinders
FRM hau_into , 4	;Offset of interrupt routine
FRM hau_kcb  , 4	;Offset of KCB
hau_SIZE=!$$$

;Define bits for hau_info

INFO$NEWKCB=!01h	;New KCB created

	.MOD	4
hdkbublk:					;Characteristics description
 DCHARBGN  3, knlDCharValCom##			;  block for addunit
 DCHARENT  TYPE    , TEXT, 8, 0, 0, knlRtnZero##, 0
 DCHARENT  UNIT    , DECV, 4, 0, 0, knlRtnZero##, 0
 DCHARENT  IOREG   , HEXV, 4, 0, 0, knlRtnZero##, 0
 DCHARENT  INT     , DECV, 1, 0, 0, hdkbuintvec , 0
 DCHARENT  INDEX   , DECV, 4, 0, 0, hdkbuindex  , 0
 DCHARENT  DHEADS  , DECV, 4, 0, 0, hdkbuhead   , 0
 DCHARENT  DSECTS  , DECV, 4, 0, 0, hdkbutsz    , 0
 DCHARENT  DCYLNS  , DECV, 4, 0, 0, hdkbucyln   , 0
 DCHARENT  WPCCYLN , DECV, 4, 0, 0, hdkbuwpc    , 0

hdkbaddunit:
	ENTER	hau_SIZE, 0		;Allocate our stack frame
	ORL	ESI, ESI
	JE	20$
	MOVB	hau_unit.B[EBP], AL	;Store unit number
	MOVL	hau_kcb.B[EBP], EBX	;Store possible KCB offset
	MOVL	hau_ioreg.B[EBP], ESI	;Store base IO register
	CLRL	EAX
	MOVB	hau_info.B[EBP], AL
	MOVB	hau_xres.B[EBP], AL
	DECL	EAX
	MOVL	hau_index.B[EBP], EAX
	MOVL	hau_int.B[EBP], EAX
	MOVL	hau_wpc.B[EBP], EAX
	MOVL	hau_head.B[EBP], EAX
	MOVL	hau_sect.B[EBP], EAX
	MOVL	hau_cyln.B[EBP], EAX
	MOVL	EBX, #hdkbublk		;Point to our characteristics table
	DECL	EAX
	CALL	knlAddUnitChar##	;Process characteristics
	JC	16$			;If error
	MOVL	EAX, hau_head.B[EBP]	;Is the disk configuration completely
	ANDL	EAX, hau_sect.B[EBP]	;  unspecified?
	ANDL	EAX, hau_cyln.B[EBP]
	INCL	EAX
	JNE	6$.S			;No

;Here if the configuration is completely unspecified.  See if this is for one
;  of the standard PC hard disks, and if so, use the machines CMOS data to
;  get the required values.

2$:	CMPL	hau_ioreg.B[EBP], #1F0h	;Is this the standard controler?
4$:	JNE	20$			;No - fail
	MOVL	ESI, hau_index.B[EBP]	;Yes - is it disk 1 or 2?
	CMPL	ESI, #2.B
	JA	4$.S			;No - fail
	SHLL	ESI, #4t
	ADDL	ESI, #knlHdkDataC##-10h	;Yes - point to data for the disk
	MOVZWL	EAX, [ESI]		;Get number of cylinders
	ORL	EAX, EAX		;If zero, disk is not installed
	JE	8$.S
	MOVL	hau_cyln.B[EBP], EAX
	MOVZBL	EAX, 2.B[ESI]		;Get number of heads
	MOVL	hau_head.B[EBP], EAX
	MOVZWL	EAX, 5.B[ESI]		;Get write pre-comp cylinder
	MOVL	hau_wpc.B[EBP], EAX
	MOVZBL	EAX, 0E.B[ESI]		;Get number of sectors per track
	MOVL	hau_sect.B[EBP], EAX
6$:	MOVL	EAX, hau_head.B[EBP]	;Do we have all of the necessary
	ORL	EAX, hau_sect.B[EBP]	;  configuration information?
	ORL	EAX, hau_cyln.B[EBP]
	ORL	EAX, hau_index.B[EBP]
	ORL	EAX, hau_int.B[EBP]
	INCL	EAX
8$:	JE	20$.S			;No - fail
	MOVB	AL, #'D'		;See if this unit is defined now
	MOVB	AH, hau_unit.B[EBP]
	CALL	algdskSrchUnit##
	JE	12$.S			;Defined - fail
	MOVL	EAX, SS			;Do we have the exec memory resource?
	CMPW	knlXResPda##, AX
	JE	10$.S			;Yes
	CALL	knlGetXRes##		;No - get it now
	MOVB	hau_xres.B[EBP], #1
10$:	MOVL	EBX, hau_kcb.B[EBP]	;Is there a KCB now?
	ORL	EBX, EBX
	JE	22$.S			;No
	JMP	30$			;Yes - continue

;Here if unit is already defined

12$:	MOVL	EAX, #ER_DUADF
	JMP	16$.S

;Here if error while have exec memory resource

14$:	CMPB	hau_xres.B[EBP], #0
	JE	16$.S
	CALL	knlGiveXRes##
16$:	LEAVE
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	TOFORK
	RET

;Here if error creating the UCB

18$:	TESTB	hau_info.B[EBP], #INFO$NEWKCB
	JE	14$.S
	MOVL	EBX, hau_kcb.B[EBP]
	CALL	algdskGiveupKcb2##
	JMP	14$.S

;Here if required characteristic value is missing

20$:	MOVL	EAX, #ER_CHARM
	JMP	16$.S

;Here if no KCB now - see if the controller exists

22$:	MOVL	EDX, hau_ioreg.B[EBP]
	A2IOP	P_DCHDCYL		;Point to the cylinder number register
	MOVB	AL, #25h		;Set it to some value
	OUTB	[DX]
	IOPAUSE
	INB	[DX]			;Read it back
	CMPB	AL, #25h		;Is it right?
	JNE	24$.S			;No
	MOVB	AL, #1			;Yes - now set it to another value
	OUTB	[DX]
	IOPAUSE
	INB	[DX]			;Read it back
	CMPB	AL, #1			;Is it right?
	JE	26$.S			;Yes
24$:	MOVL	EAX, #ER_PDNAV		;No - fail
	JMP	16$.S

;Here if controller exits

26$:	MOVL	ECX, #hdkbINTSZ		;Get space for interrupt code
	CALL	knlGetXCode##
	JC	16$.S
	PUSHL	EDI			;Remember where code is going
	MOVL	ESI, #hdkbint		;Copy prototype interrupt routine
	SHRL	ECX, #2
	MOVB	gdtable+GS_CODEALS+5, #DT_RWDATA+PL_0 ;Enable alaised code space
	PUSHL	#GS_CODEALS.B
	POPL	ES
	CLD
	RMOVSL	[EDI], ES:[ESI]
	CLRL	EAX
	MOVL	ES, EAX
	MOVB	gdtable+GS_CODEALS+5, AL
	POPL	ESI
	MOVL	EBX, #hdkdsp
	MOVL	EDX, #'HDKB'
	MOVL	hau_into.B[EBP], ESI
	MOVL	ECX, #kcb_hdSIZE	;Make a KCB
	MOVB	AL, #KB$AHEAD+KB$DEFER
	CLRL	ESI
	CALL	algdskMakeKcb##
	JC	14$
	MOVL	hau_kcb.B[EBP], EDI	;Remember where our KCB is
	ORB	hau_info.B[EBP], #INFO$NEWKCB
	MOVL	EAX, hau_ioreg.B[EBP]	;Store base IO register number in the
	MOVL	kcb_ioreg.B[EDI], EAX	;  KCB
	MOVL	EBX, #temp
	CLRL	EAX
	MOVL	[EBX], EAX
	MOVL	EAX, hau_ioreg.B[EBP]
	CALL	knlPutHex3Nmbr##
	MOVL	EAX, #'HDKB'
	MOVL	EDX, temp
	MOVL	ECX, hau_int.B[EBP]	;Set up our interrupt vector
	MOVB	kcb_intlvl.B[EDI], CL
	MOVL	EBX, hau_into.B[EBP]
	MOVB	CH, #DT_TRAP
	CALL	knlSetIRq##
	JC	14$
	MOVL	EDX, hau_into.B[EBP]
	MOVL	EBX, hau_kcb.B[EBP]
	MOVL	kcb_fdisp.B[EDI], #hdkfork ;Store fork location
	MOVB	gdtable+GS_CODEALS+5, #DT_RWDATA+PL_0 ;Fix up the interrupt
	PUSHL	#GS_CODEALS.B			      ;  code
	POPL	ES
	MOVL	ES:{fix1-hdkbint}+1.B[EDX], EBX
	MOVL	EAX, #hdkbint
	SUBL	EAX, EDX
	ADDL	ES:{fix2-hdkbint}+1.B[EDX], EAX
	CLRL	EAX
	MOVL	ES, EAX
	MOVB	gdtable+GS_CODEALS+5, AL
	MOVL	EAX, hdkbkcb		;Link into our list of KCBs
	MOVL	hdkbkcb, EDI
	MOVL	kcb_nexts.B[EDI], EAX
	ORL	EAX, EAX		;First time?
	JNE	28$.S			;Yes
	MOVL	EBX, #hdkboas		;Yes - setup our once-a-second routine
	CALL	knlSetupOAS##
28$:	MOVL	ECX, hau_int.B[EBP]	;Enable our interrupt
	CALL	knlEnableInt##

;Here with KCB set up or if already have a KCB

30$:	MOVB	AL, #DT_HARD		;Indicate hard disk
	MOVB	AH, #'D'		;Get first letter of our name
	MOVZBL	EDX, hau_unit.B[EBP]	;Get unit number
	MOVL	ECX, #ucb_hdSIZE
	MOVL	EBX, hau_kcb.B[EBP]	;Get offset of KCB
	CALL	algdskMakeUcb##		;Make a UCB
	JC	16$			;If error
	CMPB	hau_xres.B[EBP], #0
	JE	32$.S
	CALL	knlGiveXRes##
32$:	MOVB	AL, hau_head.B[EBP]	;Store number of heads
	MOVB	ucb_headc.B[ESI], AL
	MOVB	ucb_headci.B[ESI], AL
	CMPB	AL, #08h		;More than 8 heads?
	MOVW	AX, #RS_512		;Get values for ucb_sts2 and for the
					;  fixed disk register in the controller
	JBE	34$.S			;8 heads or less
	ORW	AX, #0800h+U2$M8H	;More than 8 heads
34$:	MOVB	ucb_sts2.B[ESI], AL
	MOVB	ucb_hdfdr[ESI], AH
	MOVL	EAX, hau_sect.B[EBP]	;Store number of sectors/track
	MOVL	ucb_secc.B[ESI], EAX
	MOVL	ucb_secci.B[ESI], EAX
	MOVL	EAX, #512t		;Store sector size
	MOVL	ucb_secsz.B[ESI], EAX
	MOVL	ucb_secszi.B[ESI], EAX
	MOVL	EAX, hau_cyln.B[EBP]	;Store number of cylinders
	MOVL	ucb_cyln.B[ESI], EAX
	MOVL	ucb_cylni.B[ESI], EAX
	DECL	EAX
	MOVL	ucb_cylmax.B[ESI], EAX
	MOVL	EAX, hau_wpc.B[EBP]	;Store write pre-comp cylinder
	SHRL	EAX, #2
	MOVB	ucb_hdwpc[ESI], AL
	MOVL	EAX, hau_index.B[EBP]	;Store unit index and select values
	MOVB	ucb_index.B[ESI], AL
	MOVL	EAX, hau_ioreg.B[EBP]	;Store base IO register number in the
	MOVL	ucb_ioreg.B[ESI], EAX	;  UCB
	MOVB	ucb_sts1.B[ESI], #U1$RECAL ;Indicate should recalibrate first
	MOVZBL	EAX, ucb_index.B[ESI]	;Set up the unit select value
	ADDL	EAX, #0Ah-1
	SHLL	EAX, #4
	MOVB	ucb_select.B[ESI], AL		 ;Store offset of our device
	MOVL	ucb_devchar.B[ESI], #hdkdchartbl ;  characteristics table
	MOVL	ucb_ramax.B[ESI], #32t	;Set initial read-ahead maximum
	MOVL	EDX, ESI
	CALL	knlGetQel##		;Get an IORB
	JC	40$.S			;If can't get one, just assume no
					;  identify command (this is almost
					;  impossible - if there's no memory
					;  available here, the system will
					;  probably fail real soon anyway!)
	MOVL	iorb_count.B[ESI], EDX	;Store UCB offset where we can find it
	MOVL	iorb_finish.B[ESI], #initfin
	MOVL	iorb_routine.B[ESI], #initunit
	CLRL	EAX
	MOVB	iorb_queue.B[ESI], AL
	MOVL	iorb_buffer1+4.B[ESI], EAX
	MOVL	iorb_buffer2+4.B[ESI], EAX
	MOVL	iorb_parm+4.B[ESI], EAX
	MOVL	iorb_mlckcnt.B[ESI], EAX
	MOVL	iorb_lock+0.B[ESI], EAX
	MOVL	SS:pdaResponse##, EAX
	CLRL	EDI
	CALL	knlXfBegin##
36$:	PUSHL	SS			;Set up to wait
	POPL	ES
	MOVB	AL, #knlQX_DW2##
	CALL	knlWRequeue##		;Requeue to the suspend queue
	FROMFORK
	CALLF	schedule		;Call the scheduler (this is an
	TOFORK				;  uninterruptable wait!)
	MOVL	EAX, SS:pdaResponse##
	ORL	EAX, EAX
	JE	36$.S
	JS	46$.S
38$:	CLRL	EAX
	MOVL	ECX, #1
	JMP	48$.S

40$:	TOFORK
	JMP	38$.S

44$:	TOFORK
46$:	CLRL	ECX
48$:	MOVL	EBX, #QSTS$DONE
	LEAVE
	RET
.PAGE
;Extended fork context routine to finish setting up a hard disk unit

initunit:
	MOVL	EAX, #'HDKB'		;Get a disk DCB
	MOVL	EBX, #'INIT'
	MOVL	EDX, algdskCcb##
	MOVL	ESI, SS:xffCount##
	CALL	algdskGetDcb##
	JC	16$			;If can't get one
	MOVW	dcb_outframe.B[EDI], SS	;OK - store XFF selector
	MOVL	SS:xffDcb##, EDI
	CLRL	EAX			;Just to be safe, clear some vectors
	MOVL	dcb_sdisp.B[EDI], EAX
	CALL	algdskGetSBufr##	;Get a system cache buffer
	JC	2$.S
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #512t
	MOVB	AL, #kf_init		;Do initialization
	PUSHL	EBX
	CALL	algdskXfer##
	POPL	EBX
	JNC	10$.S			;If OK
	CALL	algdskGiveBufr##	;If error
2$:	CALL	algdskCDcb##
	JMP	16$

;Here if the identify drive command worked

10$:	MOVZWL	EAX, 1t*2.B[EBX]	;Get number of cylinders
	MOVZWL	EDX, 3t*2.B[EBX]	;Get number of heads
	MOVZWL	ECX, 6t*2.B[EBX]	;Get number of sectors
	ORL	EAX, EAX		;Was number of cylinders specified?
	JE	12$.S			;No
	ORL	EDX, EDX		;Was number of heads specified?
	JE	12$.S			;No
	JREGZ	ECX, 12$		;If number of sectors not specified
	MOVL	ucb_cyln.B[ESI], EAX	;Store number of cylinders
	MOVL	ucb_cylni.B[ESI], EAX
	MOVL	ucb_headc.B[ESI], EDX	;Store number of heads
	MOVL	ucb_headci.B[ESI], EDX
	MOVL	ucb_secc.B[ESI], ECX	;Store number of sectors
	MOVL	ucb_secci.B[ESI], ECX
	ORB	ucb_sts1.B[ESI], #U1$FIXCFG ;Indicate configuration is fixed
12$:	MOVZWL	EAX, 0t*2.B[EBX]	;Get configuration bits
	MOVL	ucb_hdconfig[ESI], EAX
	MOVZBL	EAX, 47t*2.B[EBX]	;Get maximum sectors per interrupt
	MOVL	ucb_hdsecpi[ESI], EAX
	MOVZWL	EAX, 21t*2.B[EBX]	;Get number of buffers
	SHLL	EAX, #9			;Change to bytes
	MOVL	ucb_hdbufsz[ESI], EAX
	PUSHL	EBX
	ADDL	EBX, #27t*2.B		;Get model number string
	MOVL	EDX, ucb_ext.B[ESI]
	ADDL	EDX, #ucbx_model.B
	MOVL	ECX, #20t
	CALL	getidstr
	MOVL	EBX, [ESP]
	ADDL	EBX, #10t*2.B		;Get serial number string
	MOVL	EDX, ucb_ext.B[ESI]
	ADDL	EDX, #ucbx_serialno.B
	MOVL	ECX, #10t
	CALL	getidstr
	MOVL	EBX, [ESP]
	ADDL	EBX, #23t*2.B		;Get firmware version string
	MOVL	EDX, ucb_ext.B[ESI]
	ADDL	EDX, #ucbx_revision.B
	MOVL	ECX, #4t
	CALL	getidstr
	POPL	EBX
	CALL	algdskGiveBufr##	;Give up the buffer we used
	CALL	algdskCDcb##		;Give up the DCB we were using
	CLRL	EAX
	MOVL	SS:xffDcb##, EAX
16$:	MOVL	EAX, #1
	MOVL	EBX, #QSTS$DONE
	RET

;Here when finished with the XFF

initfin:MOVW	ES, SS:xffPda##
	MOVL	ES:pdaResponse##, EAX
	CALL	knlRRequeue##
	JMP	knlXfFinish##
.PAGE
;Subroutine called by addunitchar for the INDEX parameter

hdkbuindex:
	ORL	EAX, EAX		;Valid index on controller?
	JE	6$.S			;No
	CMPL	EAX, #2.B		;Maybe
	JA	6$.S			;No
	MOVL	hau_index.B[EBP], EAX	;Yes - store index
	CLC
	RET

;Subroutine called by addunitchar for the "INT" parameter

hdkbuintvec:
	CMPL	EAX, #2.B		;Valid value?
	JB	6$.S			;No
	JNE	2$.S			;Maybe
	MOVB	AL, #9t			;Yes - do vector 2 fixup
2$:	CMPL	EAX, #15t		;Maybe
	JA	6$.S			;No
	MOVL	hau_int.B[EBP], EAX	;Yes - store value
	CLC
	RET

;Subroutine called by addunitchar for the "DHEADS" parameter

hdkbuhead:
	ORL	EAX, EAX		;0?
	JE	6$.S			;Yes - illegal
	MOVL	hau_head.B[EBP], EAX	;OK - store number of heads
	CLC
	RET

6$:	MOVL	EAX, #ER_CHARV
	STC
	RET

;Subroutine called by addunitchar for the "DSECTS" parameter

hdkbutsz:
	MOVL	hau_sect.B[EBP], EAX
	RET

;Subroutine called by addunitchar for the "DCYLN" parameter

hdkbucyln:
	MOVL	hau_cyln.B[EBP], EAX
	RET

;Subroutine called by addunitchar for the "WPCCYLN" parameter

hdkbuwpc:
	CWL				;Extend 16 bit value to 32 bits
	CMPL	EAX, #1024t		;Valid value?
	JB	8$.S			;Yes
	CLRL	EAX			;No - indicate no write pre-comp
	DECL	EAX
8$:	MOVL	hau_wpc.B[EBP], EAX	;Yes - store value
	CLC
	RET
.PAGE
;Subroutine to copy string for the disk unit identify data - these strings are
;  stored as a list of words with reverse byte order - a string may be null
;  terminated or space filled to its maximum length - this routine fixes up
;  the byte order and removes any trailing spaces
;	c{ES:EBX} = Address of start of string
;	c{EDX}    = Offset to receive string
;	c{ECX}    = Maximum length of string (in words)
;	CALL	getidstr

getidstr:
	PUSHL	ECX			;First, fix up the byte order
	PUSHL	EBX
2$:	RORW	ES:[EBX], #8
	ADDL	EBX, #2.B
	LOOP	ECX, 2$
	POPL	EBX			;Restore pointer
	POPL	ECX			;Restore count
	ADDL	ECX, ECX		;Change to byte count
	PUSHL	EDX
4$:	MOVB	AL, ES:[EBX]		;Get byte
	INCL	EBX			;Bump pointer
	MOVB	[EDX], AL		;Store byte
	INCL	EDX			;Bump pointer
	CMPB	AL, #0			;End of string?
	JE	8$.S			;Yes
	CMPB	AL, #' '		;Space?
	JE	6$.S			;Yes
	MOVL	[ESP], EDX		;No - remember this as end
6$:	LOOP	ECX, 4$			;Continue if more to copy
	POPL	EDX			;Restore offset of end of string
	MOVB	[EDX], #0		;Put null at end
	RET

;Here if have null at end of string

8$:	POPL	EDX			;Fix up the stack
	RET				;And return
.PAGE
	.SBTTL	kf_init - Initialize controller

;Here for the initialize controller function - this function does not really
;  initialize the hard disk controller, but it does do an identify drive
;  command to attempt to determine something about the drive
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdkinit
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkinit:
	CLRL	EDX
	MOVB	AH, #K1$INPUT
	MOVB	AL, #0ECh		;Get identify drive command
	JMP	hdkxfer.S		;Go handle it just like a read command!

	.SBTTL	kf_setparms - Set controller parameters

;Here for the set controller parameters function
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdksetparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdksetparms:
	CLRL	EAX
	RET

	.SBTTL	kf_getparms - Get controller parameters

;Here for the get controller parameters function
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdkgetparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkgetparms:
	CLRL	EAX
	RET

	.SBTTL	kf_format - Function to format track

;Here for the format track function
;	c{EDI} = Offset of DCB
;	CALL	hdkformat

hdkformat:
	MOVB	AH, #0
	MOVB	AL, #50h		;Get format command
	JMP	hdkxfer.S
.PAGE
	.SBTTL	kf_readraw - Function to read data using raw disk address

;Here for the read raw block function
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Amount to transfer
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdkreadraw
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkreadraw:
	MOVL	EDX, dcb_dkdblk.B[EDI]	;Use disk address directly
	MOVB	AH, #K1$INPUT
	JMP	4$.S

	.SBTTL	kf_readlist - Function to read data into buffer list

;Here for the read buffer list function
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Amount to transfer
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdkreadlist
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkreadlist:
	CALL	checklist

	CALL	hdkbk2phy
	JC	5$.S
	MOVB	AH, #K1$INPUT|K1$LIST
	JMP	4$.S

	.SBTTL	kf_readdata - Function to read data into single buffer

;Here for the read block function
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Amount to transfer
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdkreaddata
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkreaddata:
	CALL	hdkbk2phy
	JC	5$.S
	MOVB	AH, #K1$INPUT
4$:	MOVB	AL, #20h		;Get read command
	JMP	hdkxfer.S

	.SBTTL	kf_writraw - Function to write data using raw disk address

;Here for the write raw block function
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Amount to transfer
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdkwritraw
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkwritraw:
	MOVL	EDX, dcb_dkdblk.B[EDI]	;Use disk address directly
	MOVB	AH, #0
	JMP	8$.S

	.SBTTL	kf_writlist - Function to write data from buffer list

;Here for the write buffer list function
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Amount to transfer
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdkwritlist
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkwritlist:
	CALL	checklist

	CALL	hdkbk2phy
	JC	5$.S
	MOVB	AH, #K1$LIST
	JMP	8$.S

5$:	CLRL	ECX
	STC
	RET

	.SBTTL	kf_writdata - Function to write data from single buffer

;Here for the write block function
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Amount to transfer
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB
;	CALL	hdkwritdata
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkwritdata:
	CALL	hdkbk2phy
	JC	5$.S
	MOVB	AH, #0
8$:	MOVB	AL, #30h		;Get write command
					;Fall into hdxfer on next page
.PAGE
;Here to actually do the transfer
;	c(AL) = Function code for the interface
;	c(AH) = Value for kbc_sts1
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Amount to transfer
;	c{ESI}    = Offset of UCB
;	c{EDI}    = Offset of DCB

$$$=!0
FRM           , 3t
FRM xfr_func  , 1t		;Function value for interface
FRM xfr_daddr , 4t		;Disk address
FRM xfr_buffer, 8t		;Address of buffer for transfer
FRM xfr_count , 4t		;Amount to transfer
xfr_SIZE=!$$$

hdkxfer:ENTER	xfr_SIZE, 0		;Set up a stack frame
	MOVL	xfr_count.B[EBP], ECX	;Save amount to transfer
	MOVB	xfr_func.B[EBP], AL	;Save disk function
	MOVL	xfr_daddr.B[EBP], EDX	;Save disk address
	MOVL	xfr_buffer+0.B[EBP], EBX ;Store buffer address
	MOVL	xfr_buffer+4.B[EBP], ES	;Also save buffer offset in the KCB in
	MOVL	EDX, EBX		;  case we have a buffer list
	MOVL	EBX, ucb_kcb.B[ESI]
	MOVL	kcb_buffer.B[EBX], EDX
	MOVB	kcb_sts1.B[EBX], AH
	CLRL	EAX			;Clear amount transfered
	MOVL	kcb_amount.B[EBX], EAX
	MOVB	AL, ucb_select.B[ESI]	;Get drive select value
	ORB	AL, xfr_daddr+1.B[EBP]	;Merge in head bits
	MOVL	EDX, ucb_ioreg.B[ESI]
	A2IOP	P_DCHDDH		;Give it to the controller
	OUTB	[DX]
	MOVB	AL, ucb_hdfdr[ESI]	;Get value for the fixed disk register
	A2IOP	P_DCHDCTL-P_DCHDDH
	OUTB	[DX]
	MOVB	AL, ucb_hdwpc[ESI]	;Get write precomp value
	A2IOP	P_DCHDWP-P_DCHDCTL
	OUTB	[DX]
	TESTB	ucb_sts1.B[ESI], #U1$RECAL ;Need to recalibrate now?
	JE	2$.S			;No - go do transfer
	MOVB	kcb_itimer.B[EBX], #TO_RESTORE ;Yes
	MOVB	AL, #10h		;Start a restore operation
	A2IOP	P_DCHDCMD-P_DCHDWP
	OUTB	[DX]
	MOVL	EAX, #-1
	CALL	knlXfWait##		;Wait until done
	JC	xferdn			;If error
	ANDB	ucb_sts1.B[ESI], #~U1$RECAL ;OK - indicate restore done
2$:	MOVB	AL, xfr_daddr+0.B[EBP]	;Give sector number to the controller
	MOVL	EDX, ucb_ioreg.B[ESI]
	A2IOP	P_DCHDSEC
	OUTB	[DX]
	IOPAUSE
	MOVB	AL, xfr_daddr+2.B[EBP]	;Give cylinder number to the controller
	INCL	EDX
	OUTB	[DX]
	IOPAUSE
	MOVB	AL, xfr_daddr+3.B[EBP]
	INCL	EDX
	OUTB	[DX]
	IOPAUSE
	MOVL	EAX, xfr_count.B[EBP]	;Assume not format, get sector count
	SHRL	EAX, #9t
	CMPB	xfr_func.B[EBP], #50h	;Format function?
	JNE	6$.S			;No
	MOVZBL	EAX, ucb_secc.B[ESI]	;Yes - fix up the sector count value
6$:	MOVL	ECX, EAX
	A2IOP	P_DCHDSCN-P_DCHDCYH
	OUTB	[DX]			;Give sector count to the controller
	IOPAUSE
	MOVB	AL, xfr_func.B[EBP]	;Get function
	A2IOP	P_DCHDCMD-P_DCHDSCN	;Give it to the controller
	OUTB	[DX]
	IMULL	EAX, ECX, #512t		;Get number of bytes to transfer
	TESTB	kcb_sts1.B[EBX], #K1$INPUT ;Input function?
	JNE	10$.S			;Yes
	ADDL	ucb_blockout[ESI], ECX	;No
	ADDL	ucb_byteout[ESI], EAX
	MOVL	ECX, #3000t		;Don't wait too long here
	A2IOP	P_DCHDSTS-P_DCHDCMD
	IOPAUSE
8$:	INB	[DX]			;Is controller ready for data?
	TESTB	AL, #08
	LOOPE	ECX, 8$			;Wait until ready
	JE	18$.S			;Fail if didn't come ready
	PUSHL	ESI			;OK
	LESL	ESI, xfr_buffer.B[EBP]	;Get address
	A2IOP	P_DCHDDATA-P_DCHDSTS	;Point to data register
	MOVL	ECX, #256t
	CLD
	ROUTSW	ES:[ESI]		;Output data to controller
	POPL	ESI
	JMP	12$.S

;Here if doing input

10$:	ADDL	ucb_blockin[ESI], ECX
	ADDL	ucb_bytein[ESI], EAX
12$:	MOVL	EAX, #-1
	CALL	knlXfWait##		;Wait until finished

;NEED TO FIX ERROR HANDLING HERE!!!!!!!

	CMPL	EAX, #ER_NORSP.B	;Time-out error?
	JE	xferdn.S		;Yes
	TESTB	kcb_sts1.B[EBX], #K1$INPUT ;No - doing input?
	JE	14$.S			;No
	PUSHL	EDI			;Yes
	MOVL	EDI, kcb_buffer.B[EBX]
	MOVL	ES, xfr_buffer+4.B[EBP]
	MOVL	ECX, #256t
	A2IOP	P_DCHDDATA-P_DCHDSTS	;Point to data register
	CLD
	RINSW	[EDI]			;Input data from controller
	POPL	EDI
14$:	ADDL	kcb_amount.B[EBX], #512t
	MOVL	EDX, ucb_ioreg.B[ESI]
	A2IOP	P_DCHDSTS		;Get controller status
	INB	[DX]
	TESTB	AL, #01h		;Any hard errors?
	JNE	hdkerr.S		;Yes
	BTL	EAX, #2t		;No - did we have a corrected error?
	ADCL	ucb_tdataerr[ESI], #0.B
	LEAVE
	CLRL	EAX
	MOVL	ECX, kcb_amount.B[EBX]
	RET

;Here if have time-out waiting for the output buffer

18$:	MOVL	EAX, #ER_NORSP
	JMP	xferdn.S

;Here if have error

hdkerr:	MOVL	EDX, ucb_ioreg.B[ESI]
	A2IOP	P_DCHDERR		;Get error byte
	INB	[DX]
	MOVL	EBX, #errtbl		;Point to our error table
	MOVL	ECX, #ERRNUM
20$:	TESTB	AL, CS:[EBX]		;This error?
	JNE	22$.S			;Yes
	ADDL	EBX, #3.B		;No
	LOOP	ECX, 20$
22$:	MOVXBL	EAX, CS:1.B[EBX]	;Get error code
	MOVZBL	EBX, CS:2.B[EBX]
	ADDL	EBX, ESI
	INCL	[EBX]			;Bump both the total and hard
	INCL	4.B[EBX]		;  error counts
xferdn:	LEAVE
	MOVL	ECX, kcb_amount.B[EBX]
	BTL	EAX, #31t
	RET
.PAGE
	.SBTTL	kf_bk2phy - Convert block number to physical disk address

;Here for the convert block number to physical address function - unlike most
;  other driver functions, this one may be called at any interrupt
;  level - it does not effect the controller in any way!
;	c{dcb_dkdblk{EDI}} = Block number on disk
;	c{EDI}             = Offset of DCB
;	CALL	hdkbk2phy
;	C:clr = Normal
;	  c{EDX} = Track number (16) Head number (8) Sector number (8)
;	C:set = Error
;	  c{EAX} = Error code

hdkbk2phy:
	CMPL	ucb_secc.B[ESI], #0.B
	JE	4$.S
	CMPL	ucb_headc.B[ESI], #0.B
	JE	4$.S
	MOVL	EAX, dcb_dkdblk.B[EDI]	;Get block number on disk
	ADDL	EAX, ucb_partnoff.B[ESI] ;Plus position of start of partition
	CLRL	EDX
	DIVL	ucb_secc.B[ESI]		;Get sector number
	INCL	EDX
	PUSHL	EDX			;Save sector number
	CLRL	EDX
	DIVL	ucb_headc.B[ESI]	;Get head and cylinder numbers
	MOVB	1.B[ESP], DL		;Store head number
	CMPW	AX, ucb_cylmax.B[ESI]	;Valid cylinder?
	JA	10$.S			;No
	MOVW	2.B[ESP], AX		;Yes - store cylinder number
	POPL	EDX			;Put in right register
	CLC				;Make sure C is clear
	RET				;All done

;Here if disk configuration is not known - return a sector number equal to
;  the block+1 with head and track = 0.  This will allow access to the first
;  track on a disk even when the configuration is not known.

4$:	MOVL	EDX, dcb_dkdblk.B[EDI]
	INCL	EDX
	RET	

;Here if have bad cylinder number

10$:	POPL	EAX			;Fix up the stack
	MOVL	EAX, #ER_BDDBK		;Get error code
	STC
	RET
.PAGE
	.SBTTL	hdkfork - Device fork level routine

;Here at device fork level after operation is complete
;	c{EDI} = Offset of KCB

hdkfork:TESTB	kcb_sts1.B[EDI], #K1$TIMEOUT ;Have a time-out?
	JNE	6$.S			;Yes
	CLRL	EAX			;No
4$:	MOVL	EDI, kcb_curdcb.B[EDI]
	ORL	EDI, EDI
	JNE	knlResumeOutput##
	RET

;Here if have a time-out

6$:	INCL	ucb_hungerr[ESI]
	MOVL	EAX, #ER_NORSP
	JMP	4$.S
.PAGE
	.SBTTL	hdkbint - Hard disk interrupt routine

;Prototype hard disk interrupt routine - this routine is copied to allocated
;  code segment memory to create a seperate interrupt entry for each controller

hdkbint:PUSHAL				;Save all registers
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHL	#GS_DATA.B
	POPL	DS
fix1:	MOVL	EDI, #0			;Get our KCB
fix2:	JMP	hdkbintcom		;Go to common code
hdkbINTSZ=!$-hdkbint

;Common interrupt routine - get here after all registers have been saved on the
;  stack and the offset of the KCB for the controller has been placed in EDI

hdkbintcom:
	CMPL	kcb_curdcb.B[EDI], #0.B	;Are we expecting this?
	JE	8$.S			;No
	TESTB	kcb_sts1.B[EDI], #K1$LIST ;Yes - should we transfer data here?
	JE	10$.S			;No
	TESTB	kcb_sts1.B[EDI], #K1$TIMEOUT ;Yes - time-out interrupt?
	JNE	10$.S			;Yes
	ADDL	kcb_amount.B[EDI], #512t ;No - increase amount done
	MOVL	EDX, kcb_ioreg.B[EDI]	;Get controller status
	A2IOP	P_DCHDSTS
	INB	[DX]
	TESTB	AL, #01h		;Any hard errors?
	JNE	10$.S			;Yes - stop now
	TESTB	kcb_sts1.B[EDI], #K1$INPUT ;Input?
	JE	16$.S			;No - output
	MOVL	ESI, kcb_buffer.B[EDI]	;Yes - point to the buffer
	MOVL	ECX, cb_xnext.B[ESI]	;Get offset of next buffer
	ORL	ECX, ECX		;Have another one?
	JE	10$.S			;No - don't transfer any data here
	MOVL	kcb_buffer.B[EDI], ECX	;Yes
	XCHGL	EDI, ESI
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #256t
	A2IOP	P_DCHDDATA-P_DCHDSTS	;Point to the data register
	CLD
	RINSW	[EDI]			;Input data from the controller
	MOVL	EDI, ESI
	JMP	12$.S			;Thats all for now

;Here if have an unexpected interrupt

8$:	INCL	kcb_hduxint.B[EDI]	;Count it
	JMP	12$.S

;Here to stop transfer

10$:	MOVB	kcb_itimer.B[EDI], #0	;Stop the interrupt timer
	CALL	knlReqFork#
12$:	MOVB	AL, #INT_EOI		;Release interrupt controllers
	CMPB	kcb_intlvl.B[EDI], #7
	CLI
	JBE	14$.S
	OUTB	P_INC2P0
14$:	OUTB	P_INC1P0
	JMP	knlDismissInt2##	;And dismiss interrupt

;Here if doing output

16$:	MOVL	ESI, kcb_buffer.B[EDI]	;Get offset of this buffer
	MOVL	ESI, cb_xnext.B[ESI]	;Get selector for next buffer
	ORL	ESI, ESI		;Was this the last one?
	JE	10$.S			;Yes - finished here
	MOVL	kcb_buffer.B[EDI], ESI	;No - advance to next buffer
	MOVL	ECX, #256t
	A2IOP	P_DCHDDATA-P_DCHDSTS	;Point to the data register
	CLD
	ROUTSW	[ESI]			;Output data to the controller
	ADDL	kcb_amount.B[EDI], #512t ;Increase amount done
	JMP	12$.S
.PAGE
	.SBTTL	hdkboas - Once-a-second routine

;Here once each second

hdkboas:MOVL	EDI, hdkbkcb		;Get first HDKB KCB
2$:	CLI
	CMPB	kcb_itimer.B[EDI], #0	;Is our timer running?
	JE	4$.S			;No - go on
	DECB	kcb_itimer.B[EDI]	;Yes - count it down
	JE	8$.S
4$:	STI
6$:	MOVL	EDI, kcb_nexts.B[EDI]	;Advance to next KCB
	ORL	EDI, EDI		;Continue if have another
	JNE	2$.S
	RET				;Finished

;Here if have hung disk

8$:	ORB	kcb_sts1.B[EDI], #K1$TIMEOUT ;Indicate time-out error
	TESTB	kcb_sts1.B[EDI], #K1$RESET ;Already doing reset?
	JNE	10$.S			;Yes
	ORB	kcb_sts1.B[EDI], #K1$RESET ;No - indicate doing reset now
	MOVB	kcb_itimer.B[EDI], #TO_RESET ;Restart interrupt timer
	MOVL	EDX, kcb_ioreg.B[EDI]
	A2IOP	P_DCHDCTL
	MOVB	AL, #0Ch		;Reset the disks
	OUTB	[DX]
	STI
	MOVL	ECX, #20t
	CALL	knlSDelay##
	MOVB	AL, #0Ah
	OUTB	[DX]
	JMP	6$.S			;Go on

;Here if reset attempt timed out

10$:	CMPL	kcb_curdcb.B[EDI], #0.B
	JE	6$.S
	CLI
	CALL	knlReqFork##		;Force a fork here
	JMP	4$.S
.PAGE
checklist:
	PUSHL	EAX
	PUSHL	EBX
	MOVL	EAX, #512t
4$:	MOVL	EBX, cb_xnext.B[EBX]
	ORL	EBX, EBX
	JE	6$.S
	ADDL	EAX, #512t
	JMP	4$.S

6$:	CMPL	EAX, ECX
	JE	8$.S
	CRASH	LIST

8$:	POPL	EBX
	POPL	EAX
	RET

	.MOD	4
itintcode:
	.LONG	-1
	.BLKL	{hdkbINTSZ-1}/4
.PAGE
	.SBTTL	Data

;Error code table

	.MOD	2
errtbl:	.BYTE	011h, ER_IDFER, ucb_tidferr
	.BYTE	002h, ER_SEKER, ucb_tseekerr
	.BYTE	0C0h, ER_DATER, ucb_tdataerr
	.BYTE	000h, ER_DEVER, ucb_tdeverr
ERRNUM=!{$-errtbl}/3-1

	DATA

	.MOD	4
hdkbkcb:.LONG	0		;Offset of first hard disk KCB
temp:	.LONG	0		;Temp for addunit

	LKEEND
