	.TITLE	PCCACLS - PC-card controller class/device driver for XOS, type A

;*--------------------------------------------------------------------------*
;* PCCACLS.M86
;*
;* Written by: John Goltz
;*
;* Edit History:
;*
;*--------------------------------------------------------------------------*

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!1t
MINV   =!0t
EDITNUM=!0t

	LKEHEAD	PCCACLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

;This device class implements the interface to the Intel 82365SL (and
;  compatables) PC-card controller.  The functions of this device are to
;  initialize the controller, obtain device configuration information, and
;  to set the devices' configuration registers.  This device only provides
;  the mechanism for these functions.  The actual logic which interpets the
;  configuration information and decides how to configure the devices is
;  contained in a user mode program which uses this device to access the
;  PC-card controller.

;This device supports a simple read function which read a devices configuration
;  memory and device characteristics which configure the controller and set
;  device configuration registers.
;  

;This device is implemented using a static DCB for each PC-card controller.
;  The device is sharable, so it can be accessed by multiple processes.
;  Since there is no state saved between accesses and since all accesses
;  are atomic, this works.

;All access to the controller's registers is though the index and data
;  registers.  An index value is written into the index register and the
;  value of the register is read or written through the data register.

;Define IO port offsets (relative to the board's base IO register)

P_INDEX=!0			;(write) Index register
P_DATA =!1			;(both)  Data register
	
;Define register index values

RX_IDREV  =!00h			;(read) Identification and revision
RX_IFSTS  =!01h			;(read) Interface status
RX_PWRCNTL=!02h			;(both) Power and RESETDRV control
RX_INTCNTL=!03h			;(both) Interrupt and general control
RX_STSCHNG=!04h			;(both) Card status change
RX_CSCICFG=!05h			;(both) Card status change interrupt
				;	  configuration
RX_WINENB =!06h			;(both) Window enable
RX_IOCNTL =!07h			;(both) IO control
RX_IO0STL =!08h			;(both) IO window 0 start low byte
RX_IO0STH =!09h			;(both) IO window 0 start high byte
RX_IO0SPL =!0Ah			;(both) IO window 0 stop low byte
RX_IO0SPH =!0Bh			;(both) IO window 0 stop high byte
RX_IO1STL =!0Ch			;(both) IO window 1 start low byte
RX_IO1STH =!0Dh			;(both) IO window 1 start high byte
RX_IO1SPL =!0Eh			;(both) IO window 1 stop low byte
RX_IO1SPH =!0Fh			;(both) IO window 1 stop high byte
RX_MEM0STL=!10h			;(both) Memory window 0 system start low byte
RX_MEM0STH=!11h			;(both) Memory window 0 system start high byte
RX_MEM0SPL=!12h			;(both) Memory window 0 system stop low byte
RX_MEM0SPH=!13h			;(both) Memory window 0 system stop high byte
RX_MEM0OSL=!14h			;(both) Memory window 0 card offset low byte
RX_MEM0OSH=!15h			;(both) Memory window 0 card offset high byte
RX_CDGCNTL=!16h			;(both) Card detect and general control
RX_MEM1STL=!18h			;(both) Memory window 1 system start low byte
RX_MEM1STH=!19h			;(both) Memory window 1 system start high byte
RX_MEM1SPL=!1Ah			;(both) Memory window 1 system stop low byte
RX_MEM1SPH=!1Bh			;(both) Memory window 1 system stop high byte
RX_MEM1OSL=!1Ch			;(both) Memory window 1 card offset low byte
RX_MEM1OSH=!1Dh			;(both) Memory window 1 card offset high byte
RX_GENCNTL=!1Eh			;(both) General control
RX_MEM2STL=!20h			;(both) Memory window 2 system start low byte
RX_MEM2STH=!21h			;(both) Memory window 2 system start high byte
RX_MEM2SPL=!22h			;(both) Memory window 2 system stop low byte
RX_MEM2SPH=!23h			;(both) Memory window 2 system stop high byte
RX_MEM2OSL=!24h			;(both) Memory window 2 card offset low byte
RX_MEM2OSH=!25h			;(both) Memory window 2 card offset high byte
RX_MEM3STL=!28h			;(both) Memory window 3 system start low byte
RX_MEM3STH=!29h			;(both) Memory window 3 system start high byte
RX_MEM3SPL=!2Ah			;(both) Memory window 3 system stop low byte
RX_MEM3SPH=!2Bh			;(both) Memory window 3 system stop high byte
RX_MEM3OSL=!2Ch			;(both) Memory window 3 card offset low byte
RX_MEM3OSH=!2Dh			;(both) Memory window 3 card offset high byte
RX_MEM4STL=!30h			;(both) Memory window 4 system start low byte
RX_MEM4STH=!31h			;(both) Memory window 4 system high byte
RX_MEM4SPL=!32h			;(both) Memory window 4 system stop low byte
RX_MEM4SPH=!33h			;(both) Memory window 4 system stop high byte
RX_MEM4OSL=!34h			;(both) Memory window 4 card offset low byte
RX_MEM4OSH=!35h			;(both) Memory window 4 card offset high byte

;Define bits in the control register (P_CON)





;Define bits in the status register (P_STS)





;Define bits in the interrupt flags register (P_INT)




;Define offsets in the PC-card DCB

$$$=!dcb_devbgn
BLK dcb_pccaioreg   , 4t		;Base IO register
BLK dcb_pccasocket  , 4t		;Socket number of class chars
BLK dcb_pccanumsoc  , 4t		;Number of sockets available on controller
BLK dcb_pccaoffset  , 4t		;Offset of 4KB address space block
BLK dcb_pccamemory  , 4t
BLK dcb_pccacfgaddr , 4t
BLK dcb_pccacfgvalue, 4t
BLK dcb_pccaregs0   , 40h	;Registers for socket 0
BLK dcb_pccaregs1   , 40h	;Registers for socket 1
BLK dcb_pccaregs2   , 40h	;Registers for socket 2
BLK dcb_pccaregs3   , 40h	;Registers for socket 3
dcb_pccaSIZE=!$$$
XMBINDEX dcb_pccaINDEX, dcb_cSIZE+dcb_pccaSIZE

;PC-card controller (type A for Intel 8236SL) device characteristics table

	DATA

	.MOD	4
pccadctbl:
 DCHARBGN  1, pccabeginchar
 DCHARENT  CLASS   , TEXT ,  ,    8, knlDcMsgClass##, knlDcGetClass##, knlDcSetClass##, 0
 DCHARENT  IOREG   , HEXV ,  ,    2, knlDcMsgIoReg##, knlDcGet4Byte##, 0              , dcb_pccaioreg
 DCHARENT  MEM     , HEXV ,  ,    4, msgmem         , knlDcGet4Byte##, 0              , dcb_pccamemory
 DCHARENT  NUMSOC  , DECV ,  ,    1, msgnumsoc      , knlDcGet4Byte##, 0              , dcb_pccanumsoc
 DCHARENT  SOCKET  , DECV ,  ,    1, msgsocket      , knlDcGet4Byte##, setsocket      , dcb_pccasocket
 DCHARENT  CARDTYPE, TEXT ,  ,    8, msgcardtype    , getcardtype    , setcardtype    , 0
 DCHARENT  PRESENT , TEXT ,  ,    4, msgpresent     , getpresent     , 0              , 0
 DCHARENT  CLEAR   , DECV ,  ,    1, msgclear       , knlRtnZero##   , setclear       , 0
 DCHARENT  ENABLE  , TEXT ,  ,    4, msgenable      , getenable      , setenable      , 0
 DCHARENT  SOCINT  , DECV ,  ,    1, msgsocint      , getint         , setint         , 0
 DCHARENT  CFGADDR , HEXV ,  ,    4, msgcfgaddr     , knlDcGet4Byte##, knlDcSet4Byte##, dcb_pccacfgaddr
 DCHARENT  CFGVALUE, HEXV ,  ,    1, msgcfgvalue    , getcfgvalue    , setcfgvalue    , 0
 DCHARENT  IO0SIZE , HEXV ,  ,    4, msgio0size     , getiosize      , setiosize      , RX_IO0STL+400000h
 DCHARENT  IO0REG  , HEXV ,  ,    4, msgio0reg      , getioreg       , setioreg       , RX_IO0STL+400000h
 DCHARENT  IO0WID  , DECV ,  ,    1, msgio0wid      , getiowid       , setiowid       , 0t
 DCHARENT  IO0AWS16, TEXT ,  ,    4, msgio0aws16    , getioaws16     , setioaws16     , 0t
 DCHARENT  IO0ZWS8 , TEXT ,  ,    4, msgio0zws8     , getiozws8      , setiozws8      , 0t
 DCHARENT  IO1SIZE , HEXV ,  ,    4, msgio1size     , getiosize      , setiosize      , RX_IO1STL+800000h
 DCHARENT  IO1REG  , HEXV ,  ,    4, msgio1reg      , getioreg       , setioreg       , RX_IO1STL+800000h
 DCHARENT  IO1WID  , DECV ,  ,    1, msgio1wid      , getiowid       , setiowid       , 4t
 DCHARENT  IO1AWS16, TEXT ,  ,    4, msgio1aws16    , getioaws16     , setioaws16     , 4t
 DCHARENT  IO1ZWS8 , TEXT ,  ,    4, msgio1zws8     , getiozws8      , setiozws8      , 4t
 DCHARENT  MEMRO   , TEXT ,  ,    4, msgmemro       , getmemro       , 0              , 0
 DCHARENT  MEMCS16 , TEXT ,  ,    4, msgmemcs16     , getmemcs16     , setmemcs16     , 0
 DCHARENT  MEMDLY16, TEXT ,  ,    4, msgmemdly16    , getmemdly16    , setmemdly16    , 0
 DCHARENT  MEM0SIZE, HEXV ,  ,    4, msgmem0size    , getmemsize     , setmemsize     , RX_MEM0STL+010000h
 DCHARENT  MEM0SYS , HEXV ,  ,    4, msgmem0sys     , getmemsys      , setmemsys      , RX_MEM0STL
 DCHARENT  MEM0CARD, HEXV ,  ,    4, msgmem0card    , getmemcard     , setmemcard     , RX_MEM0OSL
 DCHARENT  MEM0WP  , TEXT ,  ,    4, msgmem0wp      , getmemwp       , setmemwp       , RX_MEM0OSH
 DCHARENT  MEM0ZWS , TEXT ,  ,    4, msgmem0zws     , getmemzws      , setmemzws      , RX_MEM0STH
 DCHARENT  MEM0WS16, DECV ,  ,    1, msgmem0ws16    , getmemws16     , setmemws16     , RX_MEM0SPH
 DCHARENT  MEM0WID , DECV ,  ,    1, msgmem0wid     , getmemwid      , setmemwid      , RX_MEM0STH
 DCHARENT  MEM1SIZE, HEXV ,  ,    4, msgmem1size    , getmemsize     , setmemsize     , RX_MEM1STL+020000h
 DCHARENT  MEM1SYS , HEXV ,  ,    4, msgmem1sys     , getmemsys      , setmemsys      , RX_MEM1STL
 DCHARENT  MEM1CARD, HEXV ,  ,    4, msgmem1card    , getmemcard     , setmemcard     , RX_MEM1OSL
 DCHARENT  MEM1WP  , TEXT ,  ,    4, msgmem1wp      , getmemwp       , setmemwp       , RX_MEM1OSH
 DCHARENT  MEM1ZWS , TEXT ,  ,    4, msgmem1zws     , getmemzws      , setmemzws      , RX_MEM1STH
 DCHARENT  MEM1WS16, DECV ,  ,    1, msgmem1ws16    , getmemws16     , setmemws16     , RX_MEM1SPH
 DCHARENT  MEM1WID , DECV ,  ,    1, msgmem1wid     , getmemwid      , setmemwid      , RX_MEM1STH
 DCHARENT  MEM2SIZE, HEXV ,  ,    4, msgmem2size    , getmemsize     , setmemsize     , RX_MEM2STL+040000h
 DCHARENT  MEM2SYS , HEXV ,  ,    4, msgmem2sys     , getmemsys      , setmemsys      , RX_MEM2STL
 DCHARENT  MEM2CARD, HEXV ,  ,    4, msgmem2card    , getmemcard     , setmemcard     , RX_MEM2OSL
 DCHARENT  MEM2WP  , TEXT ,  ,    4, msgmem2wp      , getmemwp       , setmemwp       , RX_MEM2OSH
 DCHARENT  MEM2ZWS , TEXT ,  ,    4, msgmem2zws     , getmemzws      , setmemzws      , RX_MEM2STH
 DCHARENT  MEM2WS16, DECV ,  ,    1, msgmem2ws16    , getmemws16     , setmemws16     , RX_MEM2SPH
 DCHARENT  MEM2WID , DECV ,  ,    1, msgmem2wid     , getmemwid      , setmemwid      , RX_MEM2STH
 DCHARENT  MEM3SIZE, HEXV ,  ,    4, msgmem3size    , getmemsize     , setmemsize     , RX_MEM3STL+080000h
 DCHARENT  MEM3SYS , HEXV ,  ,    4, msgmem3sys     , getmemsys      , setmemsys      , RX_MEM3STL
 DCHARENT  MEM3CARD, HEXV ,  ,    4, msgmem3card    , getmemcard     , setmemcard     , RX_MEM3OSL
 DCHARENT  MEM3WP  , TEXT ,  ,    4, msgmem3wp      , getmemwp       , setmemwp       , RX_MEM3OSH
 DCHARENT  MEM3ZWS , TEXT ,  ,    4, msgmem3zws     , getmemzws      , setmemzws      , RX_MEM3STH
 DCHARENT  MEM3WS16, DECV ,  ,    1, msgmem3ws16    , getmemws16     , setmemws16     , RX_MEM3SPH
 DCHARENT  MEM3WID , DECV ,  ,    1, msgmem3wid     , getmemwid      , setmemwid      , RX_MEM3STH
 DCHARENT  CISZWS  , TEXT ,  ,    4, msgciszws      , getmemzws      , setmemzws      , RX_MEM4STH
 DCHARENT  CISDATA , DATAS, H, 1024, msgcisdata     , getcisdata     , 0              , 0

	CODE

msgnumsoc:  DCHARINFO  {Number of sockets}
msgsocket:  DCHARINFO  {Socket number}
msgmem:     DCHARINFO  {Memory address for CIS reads}
msgcardtype:DCHARINFO  {Card type}
msgpresent: DCHARINFO  {Card is present}
msgenable:  DCHARINFO  {Socket is enabled}
msgcfgaddr: DCHARINFO  {Configuration register address}
msgcfgvalue:DCHARINFO  {Configuration register value}
msgclear:   DCHARINFO  {Clear all socket parameters}
msgsocint:  DCHARINFO  {Socket interrupt level}
msgio0reg:  DCHARINFO  {IO window 0 register}
msgio0size: DCHARINFO  {IO window 0 size}
msgio0wid:  DCHARINFO  {IO window 0 data width}
msgio0aws16:DCHARINFO  {IO window 0 additional 16-bit w-s}
msgio0zws8: DCHARINFO  {IO window 0 zero 8-bit w-s}
msgio1reg:  DCHARINFO  {IO window 1 register}
msgio1size: DCHARINFO  {IO window 1 size}
msgio1wid:  DCHARINFO  {IO window 1 data width}
msgio1aws16:DCHARINFO  {IO window 1 additional 16-bit w-s}
msgio1zws8: DCHARINFO  {IO window 1 zero 8-bit w-s}
msgmemro:   DCHARINFO  {Memory read-only status}
msgmemdly16:DCHARINFO  {Memory 16-bit decode delay inhibit}
msgmemcs16: DCHARINFO  {Quick memory 16-bit address decode}
msgmem0sys: DCHARINFO  {Memory window 0 system address}
msgmem0card:DCHARINFO  {Memory window 0 card address}
msgmem0size:DCHARINFO  {Memory window 0 size}
msgmem0wp:  DCHARINFO  {Memory window 0 write protect state}
msgmem0zws: DCHARINFO  {Memory window 0 force zero wait state}
msgmem0ws16:DCHARINFO  {Memory window 0 16-bit wait states}
msgmem0wid: DCHARINFO  {Memory window 0 data width}
msgmem1sys: DCHARINFO  {Memory window 1 system address}
msgmem1card:DCHARINFO  {Memory window 1 card address}
msgmem1size:DCHARINFO  {Memory window 1 size}
msgmem1wp:  DCHARINFO  {Memory window 1 write protect state}
msgmem1zws: DCHARINFO  {Memory window 1 force zero wait state}
msgmem1ws16:DCHARINFO  {Memory window 1 16-bit wait states}
msgmem1wid: DCHARINFO  {Memory window 1 data width}
msgmem2sys: DCHARINFO  {Memory window 2 system address}
msgmem2card:DCHARINFO  {Memory window 2 card address}
msgmem2size:DCHARINFO  {Memory window 2 size}
msgmem2wp:  DCHARINFO  {Memory window 2 write protect state}
msgmem2zws: DCHARINFO  {Memory window 2 force zero wait state}
msgmem2ws16:DCHARINFO  {Memory window 2 16-bit wait states}
msgmem2wid: DCHARINFO  {Memory window 2 data width}
msgmem3sys: DCHARINFO  {Memory window 3 system address}
msgmem3card:DCHARINFO  {Memory window 3 card address}
msgmem3size:DCHARINFO  {Memory window 3 size}
msgmem3wp:  DCHARINFO  {Memory window 3 write protect state}
msgmem3zws: DCHARINFO  {Memory window 3 force zero wait state}
msgmem3ws16:DCHARINFO  {Memory window 3 16-bit wait states}
msgmem3wid: DCHARINFO  {Memory window 3 data width}
msgciszws:  DCHARINFO  {Memory window 4 force zero wait state}
msgcisdata: DCHARINFO  {CIS data}
.PAGE
	.SBTTL	SVC dispatch table for PCCA class devices

;SVC dispatch table for PCCA class devices

	CODE

pccadsp:.LONG	knlRtnZero##	;sd_mount	=  0. - Mount
	.LONG	knlRtnZero##	;sd_cleardev	=  4. - Clear device
	.LONG	knlRtnZero##	;sd_cleardcb	=  8. - Clear DCB
	.LONG	knlRtnZero##	;sd_commit	= 12. - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold    = 16. - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew    = 20. - Transfer device/new
	.LONG	knlNullQio##	;sd_opena	= 24. - Open additional
	.LONG	pccaopen	;sd_open1	= 28. - Open device/file
	.LONG	pccaopen	;sd_devparm     = 32. - Device parameters
	.LONG	knlIFnDev##	;sd_delete	= 36. - Delete file
	.LONG	knlIFnDev##	;sd_rename	= 40. - Rename file
	.LONG	knlIFnDevGQ##	;sd_inblock	= 44. - Input block
	.LONG	knlIFnDevGQ##	;sd_outblock	= 48. - Output block
	.LONG	knlIFnDevGQ##	;sd_outblockq	= 52. - Output block (XFF)
	.LONG	knlIFnDevGQ##	;sd_outstring	= 56. - Output string
	.LONG	knlRtnMOne##	;sd_getiosts	= 60. - Get input/output status
	.LONG	knlIFnDevGQ##	;sd_special     = 64. - Special device function
	.LONG	pccaclose	;sd_close	= 68. - Close file
	.LONG	knlNullLabel##	;sd_getlabel    = 72. - Get device label
	.LONG	knlNullQioGQ##	;sd_commitfunc	= 76. - Commit data to disk
	.LONG	knlInfoNone##	;sd_devinfo     = 80. - Get device info
PCCDSPSZ=!{$-pccadsp}/4

;Class function dispatch table for PCCA class devices

	.LONG	CLSFMX
pccacls:.LONG	pccaaddunit	;CF_ADDUNIT = 1. - Add unit
	.LONG	pccaunitinfo	;CF_PUNITS  = 2. - Get information about
				;		     physical units
	.LONG	knlIFnDev##	;CF_AUNITS  = 3. - Get information about active
				;		     units
CLSFMX=!{$-pccacls}/4
.PAGE

;Class characteristics table for the PCCA device class

	DATA

	.MOD	4
pccacctbl:
 DCHARBGN  2, knlDCharValCom##
 DCHARENT  NUMBER , DECV, , 4, msgnumber , knlGetSysVal##, 0             , pccadcbnum
 DCHARENT  MAXIMUM, DECV, , 4, msgmaximum, knlGetSysVal##, knlSetSysVal##, pccadcbmax
 DCHARENT  LIMIT  , DECV, , 4, msglimit  , knlGetSysVal##, knlSetSysVal##, pccadcblmt

;Device characteristics table for the PCCA device class

	CODE

msgnumber:  DCHARINFO  {Number of in use PCCA devices}
msgmaximum: DCHARINFO  {Maximum number of in use PCCA devices}
msglimit:   DCHARINFO  {Maximum number of PCCA devices allowed}
.PAGE
;Device parameter table for PCCAn: opens

	.MOD	4
	.LONG	OPARMMAX	;Size of table
pccaopnparms:
	.LONG	pccaopngenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
OPARMMAX=!{$-pccaopnparms}/4

	.LONG	OPARMGENMAX	;Size of table
pccaopngenparms:
	.LONG	0		;	       = 0000h
	.LONG	knlIopFilOptn##	;IOPAR_FILOPTN = 0001h
	.LONG	knlIopFilSpec##	;IOPAR_FILSPEC = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS  = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID   = 0005h
OPARMGENMAX=!{$-pccaopngenparms}/4

;Device parameter table for PCCAn: IO operations

	.LONG	PARMMAX		;Size of table
pccaioparms:
	.LONG	pccaiogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms##;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
PARMMAX=!{$-pccaioparms}/4

	.LONG	PARMGENMAX	;Size of table
pccaiogenparms:
	.LONG	0		;	       = 0000h
	.LONG	0		;IOPAR_FILOPTN = 0001h
	.LONG	0		;IOPAR_FILSPEC = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS  = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID   = 0005h
PARMGENMAX=!{$-pccaioparms}/4-1
.PAGE
	.SBTTL	Initialization routine

	DATA

initblk:				;Characteristics description
 DCHARBGN  3, knlDCharValCom##		;  block for initialization
 DCHARENT  BOOT  , DECV, , 4, 0, 0              , initboot, 0
 DCHARENT  RESULT, STR , , 0, 0, knlGetDcNullS##, 0       , 0

	INITSUB	initpcca

initpcca:
	PUSHL	FS
	PUSHL	EDX
	MOVL	EDI, #pccachk		;Install our class
	MOVL	EBX, #pccacls		;Offset of class function dispatch table
	MOVL	EAX, #'PCCA'
	CLRL	EDX
	MOVL	ECX, #pccacctbl
	MOVL	ESI, #pccaccb
	CALL	knlNewClass##		;Create the PCCA class
	POPL	EDX
	POPL	FS
	JC	10$.S			;If error
	TESTL	EDX, EDX		;Have a characteristics list?
	JE	2$.S			;No
	MOVL	EBX, #initblk		;Yes - point to characteristics table
	CALL	knlAddUnitChar##	;Process characteristics
	JC	10$.S			;If error
2$:	CLRL	EAX			;OK
	CLRL	EDX
	MOVL	ECX, #codetop
	CLC
6$:	RET

;Here if error after driver has been registered

10$:	CRASH	PCCA
.PAGE
	 .MOD	4
ibootchar:
	DCHAR	UNIT , SET, DECV, 1
	.BYTE	0
	DCHAR	IOREG, SET, HEXV, 2
	.WORD	3E0h
	.BYTE	0
IBOOTCHARSZ=!{{$-ibootchar}+3}&{~3}

;Here for the BOOT characteristic

$$$=!0
FRM iboot_char, IBOOTCHARSZ
iboot_SIZE=!$$$

initboot:
	ENTER	iboot_SIZE, 0
	LEAL	EDI, iboot_char.B[EBP]	;Copy the characteristics list to our
	PUSHL	SS			;  stack frame
	POPL	ES
	MOVL	ESI, #ibootchar
	MOVL	ECX, #IBOOTCHARSZ/4
	CLD	
	MOVL	EDX, EDI
	PUSHL	SS
	POPL	FS
	RMOVSL	[EDI], CS:[ESI]
	CLRL	ESI
	CALL	pccaaddunit
	FROMFORK
	LEAVE
	BTL	EAX, #31t
	RET
.PAGE
	.SBTTL	pccaaddunit - Class function to add unit

;Here for the CL_ADDUNIT function - for this device the add unit function
;  actually sets up a single PCCA controller.
;	c{ES:EDI} = Address of parameter block
;	CALL	pccaaddunit
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX}  = 0

;Description block for knlAddUnitChar:

	DATA

	.MOD	4
pccaaublk:
 DCHARBGN  4, knlDCharValCom##
 DCHARENT  UNIT , DECV, , 1, 0, 0, auunit  , 0
 DCHARENT  IOREG, HEXV, , 4, 0, 0, aureg   , 0
 DCHARENT  MEM  , HEXV, , 4, 0, 0, aumemory, 0

	CODE

$$$=!0
FRM au_ioreg , 4t		;IO register number
FRM au_memory, 4t
FRM au_unit  , 4t		;Unit number
au_SIZE=!$$$

pccaaddunit:
	ENTER	au_SIZE, 0		;Set up and initialize our stack frame
	CLRL	EAX
	DECL	EAX
	MOVL	au_unit.B[EBP], EAX
	MOVL	au_ioreg.B[EBP], EAX
	MOVL	au_memory.B[EBP], EAX
	TESTL	ESI, ESI		;Is this a BOOT call?
	JE	2$.S			;Yes
	IFFAULT	6$
	LFSL	EDX, iorb_buffer2.B[ESI]
	CALL	knlGiveQel##		;Give up the IORB	
2$:	MOVL	EBX, #pccaaublk		;Process the characteristics
	MOVB	AL, #0			;Fail if bad names here
	CALL	knlAddUnitChar##
	JNC	8$.S			;If no error
4$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	LEAVE				;Fail
	TOFORK
	STC
	RET

;Here if address error with IORB

	FAULTHDR
6$:	CALL	knlGiveQel##
	MOVL	EAX, #ER_ADRER
	JMP	4$.S

;Here with all parameters processed - make sure we got everything we need

8$:	MOVL	EAX, au_unit.B[EBP]
	MOVL	EAX, au_memory.B[EBP]
	ORL	EAX, au_ioreg.B[EBP]
	INCL	EAX
	JNE	12$.S
10$:	MOVL	EAX, #ER_CHARM
	JMP	4$.S

;Here with all needed parameters found

12$:	MOVL	EDX, au_ioreg.B[EBP]	;See if this device is already defined
	MOVL	EDI, pccaccb+ccb_dcbhead
14$:	ORL	EDI, EDI
	JE	20$.S
	CMPB	AL, dcb_punit.B[EDI]
	JE	16$.S
	CMPL	EDX, dcb_pccaioreg.B[EDI]
	JE	18$.S
	MOVL	EDI, dcb_next.B[EDI]
	JMP	14$.S

;Here if unit is already defined

16$:	MOVL	EAX, #ER_DUADF
	JMP	26$.S

;Here if physical unit is already set up

18$:	MOVL	EAX, #ER_PDADF
	JMP	26$.S

;Here if unit is not now defined. Now we must determine if the controller
;  exists - this is somewhat hard to do since the interface has almost no
;  directly accessable registers.  We read the identification and revision
;  register, check for a reasonable value, and verify that we can't change it.

20$:	CLRL	EAX			;See if it looks like we have at least
	CALL	checksoc		;  one socket
	JE	30$.S			;OK
	MOVL	EAX, #ER_PDNAV		;No socket implemented!
26$:	LEAVE
	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	TOFORK
	RET

;Here if error when have the exec memory resource

28$:	CALL	knlGiveXRes##		;Give up the exec memory resource
	JMP	26$.S

;Here if we think the interface exists

30$:	CALL	knlGetXRes##		;Get exec memory resource
	MOVL	ECX, #dcb_pccaSIZE+dcb_cSIZE ;Create a DCB
	MOVL	EBX, #DS$PHYS|DS$DIN|DS$MLTUSER
	MOVL	EDI, #pccadsp
	CALL	knlMakeDcb##
	JC	28$.S
	PUSHL	EDI
	MOVL	ECX, #1000h
	CALL	knlGetXSpace##
	MOVL	EBX, EDI
	POPL	EDI
	JC	28$.S
	MOVL	dcb_pccaoffset.B[EDI], EBX
	ADDL	EBX, #la_data		;Map a page for CIS reads
	MOVL	EDX, au_memory.B[EBP]
	MOVL	dcb_pccamemory.B[EDI], EDX
	MOVL	ECX, #1
	MOVL	EAX, #67h
	PUSHL	EDI
	MOVL	EDI, #-1
	CALL	knlMapPhyPages##
	POPL	EDI
	JC	28$.S
	CALL	knlGiveXRes##		;Give up the exec memory resource
	MOVL	ESI, #pccaccb
	CALL	knlLinkDcb##
	JC	26$
	MOVL	dcb_name+0.B[EDI], #'PCCA' ;Setup device name
	MOVZBL	EAX, au_unit.B[EBP]	;Put in unit number
	MOVB	dcb_punit.B[EDI], AL
	LEAL	EBX, dcb_name+4.B[EDI]
	CALL	knlPutDecNmbr##
	MOVL	dcb_devchar.B[EDI], #pccadctbl ;Store offset of devchar table
	MOVL	EDX, au_ioreg.B[EBP]	;Get base IO register number
	MOVL	dcb_pccaioreg.B[EDI], EDX ;Store it
	MOVL	ECX, #4
	CLRL	EBX
	MOVL	dcb_pccasocket.B[EDI], EBX
32$:	CALL	checksoc		;Is this socket implemented?
	JNE	34$.S			;No
	INCL	dcb_pccanumsoc.B[EDI]	;Yes
	PUSHL	ECX
	CALL	setclear
	POPL	ECX
	INCL	dcb_pccasocket.B[EDI]
	LOOP	ECX, 32$
34$:	LEAVE
	CLRL	EAX
	CLRL	ECX
	INCL	ECX
	MOVL	EBX, #QSTS$DONE
	TOFORK
	RET
.PAGE
;Subroutine to see if a socket is implemented
;	c{EBX} = Register base for socket (0, 40h, 80h, or 0C0h)
;	CALL	checksoc
;	Z:set = Socket is implemented
;  EBX and ECX are preserved

checksoc:
	MOVL	EDX, au_ioreg.B[EBP]	;Point to the index register
	MOVB	AL, BL			;Select the ID and revision register
	OUTB	[DX]
	IOPAUSE
	A2IOP	P_DATA-P_INDEX		;Get the value
	INB	[DX]
	MOVB	AH, AL
	ANDB	AL, #3Fh		;Discard the card bits
	CMPB	AL, #04h		;Is it right?
	JE	2$.S			;Yes
	CMPB	AL, #03h		;Maybe
	JNE	4$.S			;No
2$:	MOVB	AL, #0FFh		;OK - try to change the register
	OUTB	[DX]
	IOPAUSE
	INB	[DX]
	CMPB	AL, AH			;Did it change?
4$:	RET

.PAGE
;Subroutine called by adduchar when "UNIT" characteristics found

auunit:	CMPL	EAX, #99t
	JA	4$.S
	MOVL	au_unit.B[EBP], EAX
	CLC
	RET

;Subroutine called by adduchar when "IOREG" characteristics found

aureg:	CMPL	EAX, #0.B
	JE	4$.S
	CMPL	EAX, #0FFFFh
	JA	4$.S
	MOVL	au_ioreg.B[EBP], EAX
	CLC
	RET

4$:	MOVL	EAX, #ER_CHARV
	STC
	RET

;Subroutine called by adduchar when "MEM" characteristics found

aumemory:
	MOVL	au_memory.B[EBP], EAX
	CLC
	RET
.PAGE
	.SBTTL	pccaunitinfo - PCCA class get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  PCCA class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	pccaunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

pccaunitinfo::
	MOVL	EAX, #ER_NIYT
	CLRL	EAX
	MOVL	EBX, #QSTS$DONE
	RET
.PAGE
pccabeginchar:
	MOVL	dcb_pccasocket.B[EDI], #0
	JMP	knlDCharValCom##

getenable:
	MOVL	EAX, #'???'
	CLC
	RET

;Here to get the value of the SOCINT characteristic

getint:	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	MOVB	AL, dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI]
	ANDL	EAX, #0Fh.B
	RET

;Here to get the value of the CARDTYPE characteristic

getcardtype:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	MOVB	AL, dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI]
	SHRL	EAX, #2t
	ANDL	EAX, #08h.B
	MOVL	EDX, CS:typeval+4[EAX]
	MOVL	EAX, CS:typeval+0[EAX]
	RET

;Here to get the value of the CFGVALUE characteristic

getcfgvalue:
	MOVL	ESI, dcb_pccacfgaddr.B[EDI]
	BTSL	ESI, #31t
	CALL	setupmemory
	ANDL	ESI, #0FFFh
	ADDL	ESI, dcb_pccaoffset.B[EDI]
	MOVZBL	EAX, [ESI]
	JMP	releasememory

;Here to get the value of the PRESENT characteristic - This reads the current
;  value from the interface

getpresent:
	IMULL	EAX, dcb_pccasocket.B[EDI], #40h.B
	ADDL	EAX, #RX_IFSTS.B
	MOVL	EDX, dcb_pccaioreg.B[EDI]
	OUTB	[DX]
	IOPAUSE
	INCL	EDX
	INB	[DX]
	NOTB	AL
	ANDB	AL, #0Ch
	MOVL	EAX, #'Yes'
	JE	2$.S
	MOVL	EAX, #'No'
2$:	CLRL	EDX
	RET

;Here to get the value of the MEMRO characteristic

getmemro:
	IMULL	EAX, dcb_pccasocket.B[EDI], #40h.B
	ADDL	EAX, #RX_IFSTS.B
	MOVL	EDX, dcb_pccaioreg.B[EDI]
	OUTB	[DX]
	IOPAUSE
	INCL	EDX
	INB	[DX]
	TESTB	AL, #10h
	JMP	6$.S

;Here to get the value of the MEMCS16 characteristic

getmemcs16:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	TESTB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], #20h
	JMP	6$.S

;Here to get the value of the MEMDLY16 characteristic

getmemdly16:

	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	TESTB	dcb_pccaregs0+RX_CDGCNTL.B[EDI+ESI], #01h
6$:	MOVL	EAX, #'Yes'
	JNE	8$.S
	MOVL	EAX, #'No'
8$:	CLRL	EDX
	RET
.PAGE
;Here to get the value of the IOnSIZE characteristic

getiosize:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	MOVL	EDX, EBX
	SHRL	EDX, #16t		;Get the enable bit for the window
	TESTB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL ;Is window enabled?
	JNE	4$.S			;Yes
	CLRL	EAX			;No - say size is 0
	RET

;Here if window is enabled

4$:	ADDW	SI, BX			;Get index for the first register for
					;  the window
	MOVZWL	EAX, dcb_pccaregs0+RX_IO0SPL-RX_IO0STL.B[EDI+ESI]
	SUBW	AX, dcb_pccaregs0.B[EDI+ESI]
	INCL	EAX
	CLC
	RET

;Here to get the value of the IOnREG characteristic

getioreg:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ADDW	SI, BX
	MOVZWL	EAX, dcb_pccaregs0.B[EDI+ESI]
	CLC
	RET

;Here to get the value of the IOnWID characteristic

getiowid:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	MOVL	ECX, EBX
	MOVB	AL, dcb_pccaregs0+RX_IOCNTL.B[EDI+ESI]
	SHRB	AL, CL
	ANDL	EAX, #03h.B
	MOVB	AL, CS:iowidtbl[EAX]
	RET

iowidtbl:
	.BYTE	8t
	.BYTE	16t
	.BYTE	0
	.BYTE	0

;Here to get the value of the IOnAWS16 characteristic

getioaws16:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	MOVL	ECX, EBX
	MOVB	AL, dcb_pccaregs0+RX_IOCNTL.B[EDI+ESI]
	SHRB	AL, CL
	TESTB	AL, #08h
	JMP	6$.S

;Here to get the value of the IOnZWS8 characteristic

getiozws8:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	MOVL	ECX, EBX
	MOVB	AL, dcb_pccaregs0+RX_IOCNTL.B[EDI+ESI]
	SHRB	AL, CL
	TESTB	AL, #04h
6$:	MOVL	EAX, #'Yes'
	JNE	8$.S
	MOVL	EAX, #'No'
8$:	CLRL	EDX
	RET

;Here to get the value of the MEMnSIZE characteristic

getmemsize:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	MOVL	EDX, ESI		;First, see if the window is enabled
	SHRL	EDX, #16t
	TESTB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL
	JNE	10$.S			;Yes
	CLRL	EAX			;No - say size is 0
	RET

;Here if window is enabled

10$:	ADDW	SI, BX
	MOVZWL	EAX, dcb_pccaregs0+RX_MEM0SPL-RX_MEM0STL.B[EDI+ESI]
	SUBW	AX, dcb_pccaregs0.B[EDI+ESI]
	DECL	EAX
	ANDL	EAX, #0FFFh
	SHLL	EAX, #12t		;Change to bytes
	CLC
	RET

;Here to get the value of the MEMnSYS characteristic

getmemsys:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ADDL	ESI, EBX
	MOVL	EAX, dcb_pccaregs0.B[EDI+ESI]
	JMP	12$.S

;Here to get the value of the MEMnCARD characteristic

getmemcard:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ADDL	ESI, EBX
	MOVL	EAX, dcb_pccaregs0.B[EDI+ESI]
	ADDL	EAX, dcb_pccaregs0+RX_MEM0OSL-RX_MEM0STL.B[EDI+ESI]
12$:	SHLL	EAX, #12t
	ANDL	EAX, #0FFF000h
	RET

;Here to get the value of the MEMnWP characteristics

getmemwp:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ADDL	ESI, EBX
	MOVB	AL, dcb_pccaregs0.B[EDI+ESI]
	TESTB	AL, #80h
	JMP	14$.S

;Here to get the value of the MEMnZWS characteristic

getmemzws:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ADDL	ESI, EBX
	MOVB	AL, dcb_pccaregs0.B[EDI+ESI]
	TESTB	AL, #40h
14$:	MOVL	EAX, #'Yes'
	JNE	16$.S
	MOVL	EAX, #'No'
16$:	RET

;Here to get the value of the MEMnWS16 characteristic

getmemws16:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ADDL	ESI, EBX
	MOVB	AL, dcb_pccaregs0.B[EDI+ESI]
	SHRB	AL, #6t
	ANDL	EAX, #03h
	RET

;Here to get the value of the MEMnWID characteristic

getmemwid:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ADDL	ESI, EBX
	MOVB	AL, dcb_pccaregs0.B[EDI+ESI]
	SHRB	AL, #4t
	ANDL	EAX, #08h
	ADDL	EAX, #8t
	RET
.PAGE
;Here to set the value of the SOCKET characteristic.  This value determines
;  which socket all of the remaining socket related characteristics refer to.
;  Note that this value is sticky.  There is only one value which affects all
;  open instances of the device!

setsocket:
	CMPL	EAX, dcb_pccanumsoc.B[EDI]
	JB	knlDcSet4Byte##
	JMP	knlBadCharV##

;Here to set the clear characteristic.  This initializes the socket to IO,
;  automatic bus sizing for all windows, all windows disabled, and socket
;  disabled.

setclear:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	PUSHL	EDI
	LEAL	EDI, dcb_pccaregs0.B[EDI+ESI]
	PUSHL	DS
	POPL	ES
	CLD
	MOVL	ECX, #40h/4
	CLRL	EAX
	RSTOSL	[EDI]
	POPL	EDI
	MOVB	dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI], #60h
					;Set the ^RESET and card type bits
	MOVB	dcb_pccaregs0+RX_IOCNTL.B[EDI+ESI], #22h
					;Set IO windows for auto size
	LEAL	ECX, 2t.B[ESI]		;Set all controller registers
4$:	MOVB	BL, dcb_pccaregs0.B[EDI+ECX]
	CALL	putbyte
	CMPL	ECX, #36t.B
	JB	4$.S
6$:	RET

;Here to set the socket enabled status.  All critical registers MUST be set
;  before the socket is enabled.

setenable:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	CALL	knlGetYesNo##		;Does he want to enable the socket?
	JC	6$.S
	JE	10$.S			;Yes
	ANDB	dcb_pccaregs0+RX_PWRCNTL.B[EDI+ESI], #{~80h}&0FFh
					;No - disable the socket
	ANDB	dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI], #~0Fh ;Disable interrupts
	LEAL	ECX, RX_INTCNTL.B[ESI]
	MOVB	BL, dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI]
	CALL	putbyte
	JMP	12$.S

;Here to enable the card

10$:	TESTB	dcb_pccaregs0+RX_PWRCNTL, #06h ;Is power on?
	JE	14$.S			;No - fail
	ORB	dcb_pccaregs0+RX_PWRCNTL.B[EDI+ESI], #80h ;Yes - enable the
							  ;  socket
12$:	MOVB	BL, dcb_pccaregs0+RX_PWRCNTL.B[EDI+ESI]
	LEAL	ECX, RX_PWRCNTL.B[ESI]
	JMP	putbyte

;Here if socket power is not on

14$:	MOVL	EAX, #ER_FUNCM
	STC
	RET
.PAGE
	.MOD	4
typeval:.LONG	'MEMO', 'RY'
	.LONG	'IO', 0
TYPEVALSZ=!{$-typeval}/8t

setcardtype:
	MOVL	EBX, #typeval
	MOVL	ECX, #TYPEVALSZ
	CALL	knlGetDcVal1##
	JC	12$.S
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	SHLB	AL, #5t			;Get bit in right place (00h = memory,
					;  20h = IO)
	ANDB	dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI], #~20h
	JMP	8$.S

	.MOD	4
irqok:	.LONG	0DEB9h

setint:	CMPL	EAX, #15t.B
	JA	knlBadCharV##
	CMPB	AL, #2t
	JNE	4$.S
	MOVB	AL, #9t
	JMP	6$.S

4$:	BTL	CS:irqok, EAX
	JNC	knlBadCharV##
6$:	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ANDB	dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI], #~0Fh
8$:	ORB	dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI], AL
	MOVB	BL, dcb_pccaregs0+RX_INTCNTL.B[EDI+ESI]
	LEAL	ECX, RX_INTCNTL.B[ESI]
	JMP	putbyte

;Here to set the value of the CFGVALUE characteristic

setcfgvalue:
	PUSHL	EAX
	MOVL	ESI, dcb_pccacfgaddr.B[EDI]
	BTSL	ESI, #31t
	CALL	setupmemory
	POPL	EAX
	ANDL	ESI, #0FFFh
	ADDL	ESI, dcb_pccaoffset.B[EDI]
	MOVB	[ESI], AL
	JMP	releasememory

12$:	RET

;Here to set the value of the MEMCS16 characteristic

setmemcs16:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	CALL	knlGetYesNo##
	JC	12$.S
	JE	14$.S
	ANDB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], #~20h
	JMP	16$.S

14$:	ORB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], #20h
16$:	MOVB	BL, dcb_pccaregs0+RX_WINENB.B[EDI+ESI]
	MOVB	CL, #RX_WINENB
	JMP	22$.S

;Here to set the value of the MEMDLY16 characteristic

setmemdly16:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	CALL	knlGetYesNo##
	JC	12$.S
	JE	18$.S
	ANDB	dcb_pccaregs0+RX_CDGCNTL.B[EDI+ESI], #01h
	JMP	20$.S

18$:	ORB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], #01h
20$:	MOVB	BL, dcb_pccaregs0+RX_WINENB.B[EDI+ESI]
	MOVB	CL, #RX_CDGCNTL
22$:	JMP	putbyte
.PAGE
;Here to set the value of the IOnSIZE characteristic - This specifies the
;  size of the IO window.

setiosize:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	MOVL	EDX, EBX
	MOVZWL	EBX, BX			;Get the index for the first window
	ADDL	EBX, ESI		;  register
	SHRL	EDX, #16t		;Get the enable bit for the window
	TESTL	EAX, EAX		;Setting the size to 0?
	JNE	2$.S			;No
	NOTB	DL			;Yes - disable the IO window
	ANDB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL
	JMP	4$.S

;Here if size is not 0

2$:	ORB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL ;Enable the IO window
	ADDW	AX, dcb_pccaregs0.B[EDI+EBX] ;Calculate window stop value
	DECL	EAX
4$:	MOVW	dcb_pccaregs0+RX_IO0SPL-RX_IO0STL.B[EDI+EBX], AX
	LEAL	ECX, RX_IO0SPL-RX_IO0STL.B[EBX]
	MOVL	EBX, EAX
	CALL	putword
	LEAL	ECX, RX_WINENB.B[ESI]
	MOVB	BL, dcb_pccaregs0+RX_WINENB.B[EDI+ESI]
	JMP	putbyte

;Here to set the value of the IOnREG characteristic - This specifies the
;  base register for the IO window.  Setting this value sets the window size
;  to 0 and disables the window.

setioreg:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	MOVL	EDX, EBX
	MOVZWL	EBX, BX			;Get the index for the first window
	ADDL	EBX, ESI		;  register
	SHRL	EDX, #16t		;Get the window enable bit
	PUSHL	EAX
	PUSHL	EBX			;First disable the IO window
	NOTB	DL
	ANDB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL
	LEAL	ECX, RX_WINENB.B[ESI]
	MOVB	BL, dcb_pccaregs0+RX_WINENB.B[EDI+ESI]
	CALL	putbyte
	POPL	EBX
	POPL	EAX
	ADDL	ESI, EBX		;Set the stop address to 0
	MOVW	dcb_pccaregs0+RX_IO0SPL-RX_IO0STL.B[EDI+EBX], #0
	MOVW	dcb_pccaregs0.B[EDI+EBX], AX ;Set the start address
	LEAL	ECX, RX_IO0STL.B[EBX]	;Update the hardware registers
	MOVZWL	EBX, dcb_pccaregs0.B[EDI+EBX]
	CALL	putword
	MOVZWL	EBX, dcb_pccaregs0.B[EDI+EBX]
	JMP	putword

;Here to set the value of the IOnWID characteritsic - This specifies the data
;  width for IO accesses.  Valid values are:
;	 0 - Indicates card will specify access width
;	 8 - Forces 8 bit transfers
;	16 - Forces 16 bit transfers

setiowid:
	TESTL	EAX, EAX		;Get the bits for the register
	JNE	10$.S
	MOVB	AL, #02
	JMP	12$.S

10$:	CMPL	EAX, #8t.B
	JE	12$.S
	CMPL	EAX, #16t.B
	JNE	knlBadCharV##		;If illegal value
	INCL	EAX
12$:	MOVB	AH, #03h
	JMP	14$.S

;Here to set the value of the IOnAWS16 characteristic - This specifies if
;  an additional wait state is added for 16-bit IO accesses

setioaws16:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	CALL	knlGetYesNo##
	JC	16$.S
	SETE	AL
	SHLB	AL, #3t
	ANDB	AH, #04h
	JMP	14$.S

;Here to set the value of the IOnZWS8 characteristic - This specifies if
;  zero wait states are added for 8-bit IO accesses

setiozws8:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	CALL	knlGetYesNo##
	JC	16$.S
	SETE	AL
	SHLB	AL, #2t
	ANDB	AH, #02h
14$:	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	MOVL	ECX, EBX
	SHLL	EAX, CL			;Position bits and mask for window
	NOTB	AH
	ANDB	dcb_pccaregs0+RX_IOCNTL.B[EDI+ESI], AH
	ORB	dcb_pccaregs0+RX_IOCNTL.B[EDI+ESI], AL
	LEAL	ECX, RX_IOCNTL.B[ESI]
	MOVB	BL, dcb_pccaregs0+RX_IOCNTL.B[EDI+ESI]
	JMP	putbyte

16$:	RET
.PAGE
;Here to set the value of the MEMnSIZE characteristic - This specifies the
;  size of the memory window.  If the size is 0, the window is disabled.  If
;  it is non-0, the window is enabled.

setmemsize:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	MOVL	EDX, EBX		;First, see if the window is enabled
	MOVZWL	ECX, BX
	ADDL	ECX, ESI
	SHRL	EDX, #16t
	TESTL	EAX, EAX		;Setting the size to 0?
	JNE	2$.S			;No
	NOTB	DL			;Yes - disable the IO window
	ANDB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL
	JMP	4$.S

2$:	ORB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL ;Enable the IO window
	ADDL	EAX, #0FFFh		;Change to 4K pages (round up)
	SHRL	EAX, #12t
	ADDW	AX, dcb_pccaregs0.B[EDI+ECX] ;Calculate window stop value
	DECL	EAX
4$:	ANDW	dcb_pccaregs0+RX_MEM0SPL-RX_MEM0STL.B[EDI+ECX], #0F000h
	ORW	dcb_pccaregs0+RX_MEM0SPL-RX_MEM0STL.B[EDI+ECX], AX
	ADDL	ECX, #RX_MEM0SPL-RX_MEM0STL.B
	MOVZWL	EBX, dcb_pccaregs0.B[EDI+ECX]
	CALL	putword
	LEAL	ECX, RX_WINENB.B[ESI]
	MOVB	BL, dcb_pccaregs0+RX_WINENB.B[EDI+ESI]
	JMP	putbyte

;Here to set the value of the MEMnSYS characteristic - This specifies the
;  system address for the memory window.  Setting this value also sets the
;  size to 0 and disables the window.

setmemsys:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	MOVL	EDX, EBX
	MOVZWL	EBX, BX
	ADDL	EBX, ESI
	SHRL	EDX, #16t
	PUSHL	EAX
	PUSHL	EBX			;First disable the memory window
	NOTB	DL
	ANDB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL
	LEAL	ECX, RX_WINENB.B[ESI]
	MOVB	BL, dcb_pccaregs0+RX_WINENB.B[EDI+ESI]
	CALL	putbyte
	POPL	ECX
	POPL	EAX
	ANDW	dcb_pccaregs0+RX_IO0SPL-RX_IO0STL.B[EDI+ECX], #0F000h
	SHRL	EAX, #12t		;Change to pages (round down)
	ANDW	dcb_pccaregs0.B[EDI+ECX], #0F000h
	ORW	dcb_pccaregs0.B[EDI+ECX], AX ;Set the start address
	MOVZWL	EBX, dcb_pccaregs0.B[EDI+ECX] ;Update the hardware registers
	CALL	putword
	MOVZWL	EBX, dcb_pccaregs0.B[EDI+ECX]
	JMP	putword

;Here to set the value of the MEMnCARD characteristic - This specifies the
;  card address for the memory window.  Setting this value also sets the
;  size to 0 and disables the window

setmemcard:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	MOVL	EDX, EBX
	MOVZWL	EBX, BX
	ADDL	EBX, ESI
	SHRL	EDX, #16t
	PUSHL	EAX
	PUSHL	EBX			;First disable the memory window
	NOTB	DL
	ANDB	dcb_pccaregs0+RX_WINENB.B[EDI+ESI], DL
	LEAL	ECX, RX_WINENB.B[ESI]
	MOVB	BL, dcb_pccaregs0+RX_WINENB.B[EDI+ESI]
	CALL	putbyte
	POPL	ECX
	POPL	EAX
	ANDW	dcb_pccaregs0+RX_MEM0SPL-RX_MEM0OSL.B[EDI+ECX], #0F000h
	SHRL	EAX, #12t		;Change to pages (round down)
	SUBW	AX, dcb_pccaregs0+RX_MEM0STL-RX_MEM0OSL.B[EDI+ECX]
	ANDB	AH, #0F
	ANDW	dcb_pccaregs0.B[EDI+ECX], #0F000h
	ORW	dcb_pccaregs0.B[EDI+ECX], AX ;Set the card offset
	ADDL	ECX, #RX_MEM0STL-RX_MEM0OSL.B ;Update the hardware registers
	MOVZWL	EBX, dcb_pccaregs0.B[EDI+ECX]
	CALL	putword
	ADDL	ECX, #2t.B
	MOVZWL	EAX, dcb_pccaregs0.B[EDI+ECX]
	JMP	putword
.PAGE
;Here to set the value of the MEMnWP characteristic

setmemwp:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	ADDL	ESI, EBX
	CALL	knlGetYesNo##		;Does he want to set write protect?
	JC	10$.S
	JE	2$.S			;Yes
	ANDB	dcb_pccaregs0.B[EDI+ESI], #{~80h}&0FFh ;No
	JMP	8$.S

2$:	ORB	dcb_pccaregs0.B[EDI+ESI], #80h
	JMP	8$.S

;Here to set the value of the MEMnZWS characteristic

setmemzws:
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	ADDL	ESI, EBX
	CALL	knlGetYesNo##		;Does he want to set write protect?
	JC	10$.S
	JE	6$.S			;Yes
	ANDB	dcb_pccaregs0.B[EDI+ESI], #~40h ;No
	JMP	8$.S

6$:	ORB	dcb_pccaregs0.B[EDI+ESI], #40h
8$:	MOVL	ECX, ESI
	MOVB	BL, dcb_pccaregs0.B[EDI+ESI]
	JMP	putbyte

10$:	RET

;Here to set the value of the MEMnWS16 characteristic

setmemws16:
	CMPL	EAX, #3t.B
	JA	knlBadCharV##
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B	
	ADDL	ESI, EBX
	SHLB	AL, #6t
	ANDB	dcb_pccaregs0.B[EDI+ESI], #3Fh
12$:	ORB	dcb_pccaregs0.B[EDI+ESI], AL
	JMP	8$.S

;Here to set the value of the MEMnWID characteristic - This specifies the
;  access width and must have a numeric value of 8 or 16.

setmemwid:
	CMPL	EAX, #8t
	JNE	14$.S
	CMPL	EAX, #16t
14$:	JNE	knlBadCharV##
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	ADDL	ESI, EBX
	SHLB	AL, #3t
	ANDB	AL, #80h
	ANDB	dcb_pccaregs0.B[EDI+ESI], #{~80h}&0FFh
	JMP	12$.S
.PAGE
;Here to get the value of the CISDATA characteristic - This returns the
;  complete CIS contents for the card.  Long and short links are followed
;  and removed from the data returned.

$$$=!0
FRM cis_count , 4t
FRM cis_amount, 4t
FRM cis_bufr  , 4t
FRM cis_addr  , 4t
FRM cis_link  , 4t
FRM cis_limit , 4t
FRM cis_first , 1t	;Non-0 if processing first tuple list
FRM cis_power , 1t	;Non-0 if card power has been turned on
FRM           , 2t
cis_SIZE=!$$$

getcisdata:
	MOVL	ECX, #1023t
	ENTER	cis_SIZE, 0
	MOVL	cis_count.B[EBP], ECX
	MOVL	cis_bufr.B[EBP], EBX
	CLRL	EAX
	MOVL	cis_amount.B[EBP], EAX	;Initialize amount input
	MOVL	cis_link.B[EBP], EAX
	MOVB	cis_power.B[EBP], AL
	DECL	EAX
	MOVB	cis_first.B[EBP], AL
	MOVL	cis_addr.B[EBP], EAX
	MOVL	cis_limit.B[EBP], #1024t
	MOVL	EAX, dcb_pccasocket.B[EDI] ;Calculate base register offset for
	SHLL	EAX, #6			   ;  socket
	ADDL	EAX, #RX_IFSTS.B	;Get index for interface status register
	MOVL	EDX, dcb_pccaioreg.B[EDI]
	OUTB	[DX]
	IOPAUSE
	INCL	EDX
	INB	[DX]			;Get interface status byte
	NOTB	AL			;Is a card present?
	TESTB	AL, #0Ch
	JE	8$.S			;Yes - go on
	LEAVE				;No - fail
	CLRL	ECX
	MOVL	EAX, #ER_PDNAV
	STC
6$:	RET

;Here if there is a card in the socket

8$:	MOVL	ESI, #80000000h
10$:	CALL	getcisbyte
	JC	20$.S
	CMPB	AL, #0
	JE	10$.S
	CMPB	AL, #0FFh		;End of data?
	JE	30$			;Yes
	CMPB	AL, #14h		;No - No link control tuple?
	JNE	12$.S			;No
	CALL	getcisbyte		;Yes - get link (count) byte
	JC	20$.S
	CMPB	AL, #0			;It must be 0
	JNE	36$
	MOVL	cis_link.B[EBP], #-1	;Indicate no link present
	JMP	10$.S

;Here if not no link control tuple

12$:	CMPB	AL, #12h		;Common long link tuple?
	JNE	14$.S			;No
	MOVB	AL, #0			;Yes - indicate common memory
	JMP	18$.S

;Here if not common long link tuple

14$:	CMPB	AL, #13h		;Attribute long link tuple?
	JNE	22$.S			;No
	MOVB	AL, #80h		;Yes - indicate attribute memory
18$:	MOVB	cis_link+3.B[EBP], AL	;Store attribute memory bit
	CALL	getcisbyte		;Get link (count) byte
20$:	JC	26$.S
	CMPB	AL, #4t			;Must be 4
	JNE	36$
	CALL	getcisbyte		;Get and store the 4 byte link address
	JC	26$.S
	MOVB	cis_link+0.B[EBP], AL
	CALL	getcisbyte
	JC	26$.S
	MOVB	cis_link+1.B[EBP], AL
	CALL	getcisbyte
	JC	26$.S
	MOVB	cis_link+2.B[EBP], AL
	CALL	getcisbyte
	JC	26$.S
	ANDB	AL, #7Fh
	ORB	cis_link+3.B[EBP], AL
	MOVB	cis_first.B[EBP], #0	;Indicate most have a link target
					;  control tuple now
	JMP	10$.S			;Continue

;Here if not a tuple which we process

22$:	CALL	storecisbyte		;Give caller the type byte
	JC	26$.S
	CALL	getcisbyte		;Get the link (count) byte
	JC	26$.S
	CALL	storecisbyte		;Give it to the caller
	JC	26$.S
	MOVZBL	ECX, AL
	JREGZ	ECX, 28$
24$:	CALL	getcisbyte		;Give him the data bytes
26$:	JC	42$.S
	CALL	storecisbyte
	JC	42$.S
	LOOP	ECX, 24$
28$:	JMP	10$

;Here with end of data marker

$$$$end::
30$:	CALL	storecisbyte		;Give caller the end of data byte
	JC	26$.S
	CMPL	cis_link.B[EBP], #-1.B	;All finished?
	JE	40$.S			;Yes
	MOVL	cis_addr.B[EBP], #-1
	MOVL	ESI, cis_link.B[EBP]	;No
	MOVL	cis_link.B[EBP], #-1.B
	CALL	getcisbyte		;Is this a link target control tuple?
	JC	42$.S
	CMPB	AL, #13h
	JNE	32$.S
	CALL	getcisbyte
	JC	42$.S
	CMPB	AL, #03h
	JNE	32$.S
	CALL	getcisbyte
	JC	42$.S
	CMPB	AL, #'C'
	JNE	32$.S
	CALL	getcisbyte
	JC	42$.S
	CMPB	AL, #'I'
	JNE	32$.S
	CALL	getcisbyte
	JC	42$.S
	CMPB	AL, #'S'
	JNE	32$.S
	MOVB	cis_first.B[EBP], #0	;Yes - remember not in first list
	JMP	10$			;Continue

;Here if target of a branch is not a link target control tuple.  Since not
;  all cards properly insert the no link control tuple in the initial list
;  we ignore this quietly if the branch is from the initial list and no
;  branch address was explicitly specified!

32$:	CMPB	cis_first.B[EBP], #0	;In first list?
	JNE	40$.S			;Yes - just terminate quietly
36$:	MOVL	EAX, #ER_IDFMT		;No - indicate illegal data format
	JMP	42$.S

;Here when finished with the CIS data

40$:	CLRL	EAX
42$:	CALL	releasememory
	MOVL	ECX, cis_amount.B[EBP]	;Get count to return
	LEAVE				;Finished
	BTL	EAX, #31t		;Set C if error
	RET
.PAGE
;Subroutine to store CIS byte in the user's buffer
;	c(AL) = Value
;	CALL	storecisbyte
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

storecisbyte:
	DECL	cis_count.B[EBP]
	JS	2$.S
	MOVL	EDX, cis_bufr.B[EBP]
	MOVB	ES:[EDX], AL
	INCL	cis_bufr.B[EBP]
	INCL	cis_amount.B[EBP]
	CLC
	RET

;Here if user's buffer is full - indicate data truncated

2$:	MOVL	EAX, #ER_DATTR
	STC
	RET

;Here if we have too may configuration bytes

4$:	MOVL	EAX, #ER_RTOBG
	STC
	RET

;Subroutine to get a byte from CIS
;	c{ESI} = CIS byte number (common memory if bit 31 = 0, attribute
;		   memory if bit 31 = 1)
;	CALL	getcisbyte
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c(AL)  = Value
;	  c{ESI} = Original value + 1

getcisbyte:
	DECL	cis_limit.B[EBP]
	JS	4$.S
	PUSHL	ESI
	MOVL	EAX, ESI		;Same memory page as last time?
	XORL	EAX, cis_addr.B[EBP]
	TESTL	EAX, #0FFFFF000h
	JE	10$.S			;Yes
	MOVL	cis_addr.B[EBP], ESI	;No - set up to access the new page
	CALL	setupmemory
10$:	ANDL	ESI, #0FFFh
	ADDL	ESI, dcb_pccaoffset.B[EDI]
	MOVB	AL, [ESI]
	POPL	ESI
	ADDL	ESI, #2t.B
	RET
.PAGE
;Subroutine to set up card memory mapping to access configuration data
;	c{ESI} = Card address (bit 31 set if attribute memory)
;	c{EDI} = Offset of DCB

setupmemory:
	PUSHL	ESI
	MOVL	EBX, dcb_pccamemory.B[EDI]
	BTZL	ESI, #31t		;Get the attribute space bit
	SETC	AH
	SHLB	AH, #6t
	SUBL	ESI, EBX		;Get card address difference
	SHRL	EBX, #12t
	IMULL	ECX, dcb_pccasocket.B[EDI], #40h
	ADDL	ECX, #RX_MEM4STL.B
	PUSHL	EBX
	ORB	BH, #40h		;Set zero wait state bit, do not set
					;  data size bit!!!!!
	CALL	putword			;Set system start address
	POPL	EBX			;Restore system stop address
					;Do not set wait state bits!!!!
	CALL	putword			;Set system start address
	MOVL	EBX, ESI		;Get card address difference
	SHRL	EBX, #12t
	ANDL	EBX, #3FFFh
	ORB	BH, AH			;Merge the memory type bit
	CALL	putword
	IMULL	ECX, dcb_pccasocket.B[EDI], #40h.B
	ADDL	ECX, #RX_PWRCNTL.B	;Get index for power control register
	TESTB	dcb_pccaregs0.B[EDI+ECX], #80h ;Is the socket enabled now?
	JNE	8$.S			;Yes - go on
	TESTB	dcb_pccaregs0.B[EDI+ECX], #18h ;No - is the voltage on?
	JNE	6$.S			;Yes
	ORB	dcb_pccaregs0.B[EDI+ECX], #10h ;No - turn it on (5V) now
	MOVB	BL, dcb_pccaregs0.B[EDI+ECX]
	CALL	putbyte
	DECL	ECX
	MOVL	EAX, #4			;Wait for a short time
	CALL	knlTimeWait##
6$:	IMULL	ECX, dcb_pccasocket.B[EDI], #40h
	ADDL	ECX, #RX_PWRCNTL.B	;Get index for power control register
	ORB	dcb_pccaregs0.B[EDI+ECX], #80h ;Enable the socket
	MOVB	BL, dcb_pccaregs0.B[EDI+ECX]
	CALL	putbyte
8$:	IMULL	ECX, dcb_pccasocket.B[EDI], #40h
	ADDL	ECX, #RX_WINENB.B	;Get index for window enable register
	MOVB	BL, dcb_pccaregs0.B[EDI+ECX]
	ORB	BL, #10h		;Enable window 4
	CALL	putbyte
	POPL	ESI
	RET
.PAGE
releasememory:
	PUSHL	EAX
	IMULL	ESI, dcb_pccasocket.B[EDI], #40h.B
	LEAL	ECX, RX_WINENB.B[ESI]	;Get index for window enable register
	MOVB	BL, dcb_pccaregs0.B[EDI+ECX]
	CALL	putbyte
	LEAL	ECX, RX_PWRCNTL.B[ESI]	;Get index for power control register
	MOVB	BL, dcb_pccaregs0.B[EDI+ECX]
	TESTB	BL, #80h		;Is the socket enabled now?
	JNE	4$.S			;Yes - go on
	CALL	putbyte			;No - update hardware register
4$:	POPL	EAX			;Get error code to return
	RET
.PAGE
;Subroutine to output word to the interface chip
;	c[BX]  = Data value
;	c(CL)  = Register index
;	CALL	putbyte
;	C:clr Always
;	c(CL) = Register index + 2

putword:CALL	putbyte
	MOVB	BL, BH

;Subroutine to output byte to the interface chip
;	c(BL)  = Data value
;	c(CL)  = Register index
;	CALL	putbyte
;	C:clr Always
;	c(CL) = Register index + 1

putbyte:MOVB	AL, CL
	MOVL	EDX, dcb_pccaioreg.B[EDI]
	OUTB	[DX]
	IOPAUSE
	INCL	EDX
	MOVB	AL, BL
	OUTB	[DX]
	IOPAUSE
	INCL	ECX
	CLC
	RET
.PAGE
	.SBTTL	pccachk - Device check routine for PCCA class devices

;Device check routine for PCCA class devices
;	c{SS:EBX} = Address of device name (16 bytes)
;	CALL	pccachk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  EBX and ESI are preserved

pccachk:CMPL	SS:[EBX], #'PCCA'	;Is this PCCA*?
	JNE	6$.S			;No
	MOVL	EDI, pccaccb+ccb_dcbhead ;Yes - point to first PCCA ICB
	TESTL	EDI, EDI
	JE	6$.S			;If none at all
2$:	MOVL	EAX, dcb_name+4.B[EDI]	;Does name match?
	CMPL	SS:4.B[EBX], EAX
	JNE	4$.S
	MOVL	EAX, dcb_name+8.B[EDI]
	CMPL	SS:8.B[EBX], EAX
	JNE	4$.S
	MOVL	EAX, dcb_name+12t.B[EDI]
	CMPL	SS:12t.B[EBX], EAX
	JE	8$.S			;Yes - this is it!
4$:	MOVL	EDI, dcb_next.B[EDI]	;No - try next
	TESTL	EDI, EDI
	JNE	2$.S			;Continue if another
6$:	TESTL	ESP, ESP		;No more - clear Z
8$:	RET
.PAGE
	.SBTTL	sd_open - Open device

;Here for the open device entry (sd_open) - also used for the device parameters
;  entry (sd_parm)
;	c{EDI} = Offset of DCB

pccaopen::
	CMPL	SS:xffParm##, #0.B
	JE	4$.S
	MOVL	EBX, #pccaopnparms	;Process device parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	knlRtnAdrEr##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	8$.S
4$:	MOVL	EAX, pccadcbnum
	CMPL	EAX, pccadcblmt
	JAE	10$.S
	INCL	EAX
	CMPL	pccadcbmax, EAX
	JAE	6$.S
	MOVL	pccadcbmax, EAX
6$:	MOVL	pccadcbnum, EAX
	CLRL	EAX
8$:	RET

;Here if have too many PCCA devices open

10$:	MOVL	EAX, #ER_TMDVC
	STC
	RET
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	pccaclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

pccaclose::
	CLRL	EAX
	TOFORK
	JMP	knlCloseFin##
.PAGE
	.SBTTL	PCCA class driver data

	DATA

pccadcbnum:  .LONG 0		;Number of in use PCCA DCBs
pccadcbmax:  .LONG 0		;Maximum in use PCCA DCBs
pccadcblmt:  .LONG 10000t	;Maximum number of PCCA DCBs allowed
pccaccb:     .BLKB ccb_SIZE	;PCCA CCB
pccafirsticb:.LONG 0		;Offset of first PCCA ICB
pccalasticb: .LONG 0		;Offset of last PCCA ICB
enables:     .BYTE 0
	     .BYTE 0, 0, 0

	LKEEND
