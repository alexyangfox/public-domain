	.TITLE	DSKCLS1 - Disk class driver, part 1

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSXDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!1t
MINV   =!0t
EDITNUM=!3t

;1.0.1 - 5-Jan-95
;	Fixed problem with setting up buffer list for write when number of
;	buffers limited by controllers ability to handle memory fragments.
;1.0.3 - 8-Jun-97
;	Added support for EZ-Drive boot blocks; changed to allow 7 bit head
;	number in partition table.

	LKEHEAD	DSKCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

$$DSKWRITE=!0		;Set non-zero for write only debug posting
$$DSKDEBUG=!0		;Set non-zero for general debug posting

	.EXPORT	xosdskCDcb
	.EXPORT	xosdskCcb
	.EXPORT	xosdskDosName
	.EXPORT	xosdskFindDosNm
	.EXPORT	xosdskFinOut
	.EXPORT	xosdskForceDsk
	.EXPORT	xosdskGetBits
	.EXPORT	xosdskGetDcb
	.EXPORT	xosdskGetDiskRes
	.EXPORT	xosdskGetHdDosNm
	.EXPORT xosdskGetRemove
	.EXPORT	xosdskGiveDiskRes
	.EXPORT	xosdskGiveupKcb
	.EXPORT	xosdskGiveupKcb2
	.EXPORT	xosdskGtK1Byte
	.EXPORT	xosdskGtK4Byte
	.EXPORT	xosdskGtRtProt
	.EXPORT	xosdskGtU1Byte
	.EXPORT	xosdskGtU2Byte
	.EXPORT	xosdskGtU4Byte
	.EXPORT	xosdskGtU8Byte
	.EXPORT	xosdskGtU16Byte
	.EXPORT	xosdskGtUStr
	.EXPORT	xosdskGtUxStr
	.EXPORT	xosdskIoDskParms
	.EXPORT	xosdskMakeFscb
	.EXPORT	xosdskMakeKcb
	.EXPORT	xosdskMakeUcb
	.EXPORT	xosdskMount
	.EXPORT	xosdskMsgAvail
	.EXPORT	xosdskMsgBlockIn
	.EXPORT	xosdskMsgBlockOut
	.EXPORT	xosdskMsgCCylns
	.EXPORT	xosdskMsgCBlkSz
	.EXPORT xosdskMsgCBlocks
	.EXPORT	xosdskMsgCHeads
	.EXPORT	xosdskMsgCSects
	.EXPORT	xosdskMsgClsSz
	.EXPORT	xosdskMsgClsters
	.EXPORT	xosdskMsgConDsp
	.EXPORT	xosdskMsgDataDen
	.EXPORT	xosdskMsgDosName
	.EXPORT	xosdskMsgDupFat
	.EXPORT xosdskMsgFatSize
	.EXPORT	xosdskMsgFSType
	.EXPORT	xosdskMsgFatMode
	.EXPORT	xosdskMsgHIdFErr
	.EXPORT	xosdskMsgHRNFErr
	.EXPORT	xosdskMsgHSeekErr
	.EXPORT	xosdskMsgIBlkSz
	.EXPORT xosdskMsgIBlocks
	.EXPORT	xosdskMsgICylns
	.EXPORT	xosdskMsgIHeads
	.EXPORT xosdskMsgISects
	.EXPORT	xosdskMsgMSensor
	.EXPORT xosdskMsgNumFats
	.EXPORT	xosdskMsgPartOff
	.EXPORT	xosdskMsgPartn
	.EXPORT	xosdskMsgProtect
	.EXPORT xosdskMsgReady
	.EXPORT	xosdskMsgRemove
	.EXPORT	xosdskMsgRootBlk
	.EXPORT	xosdskMsgRootProt
	.EXPORT	xosdskMsgRootSize
	.EXPORT	xosdskMsgShrDelay
	.EXPORT	xosdskMsgShrFail
	.EXPORT	xosdskMsgShrRetry
	.EXPORT	xosdskMsgTIdFErr
	.EXPORT	xosdskMsgTRNFErr
	.EXPORT	xosdskMsgTSeekErr
	.EXPORT	xosdskMsgTrkDen
	.EXPORT	xosdskMsgUnexpInt
	.EXPORT	xosdskMsgVolLabel
	.EXPORT	xosdskMsgVolCDT
	.EXPORT	xosdskMsgVolEDT
	.EXPORT	xosdskMsgVolMDT
	.EXPORT	xosdskMsgVolName
	.EXPORT	xosdskMsgVolXDT
	.EXPORT	xosdskMsgWPcCyln
	.EXPORT	xosdskNewDriver
	.EXPORT	xosdskNotChg
	.EXPORT	xosdskOpnPioPos
	.EXPORT	xosdskRead
	.EXPORT	xosdskSetBits
	.EXPORT	xosdskSetDosName
	.EXPORT	xosdskSetProtect
	.EXPORT	xosdskSetRAMax
	.EXPORT	xosdskSetWTMax
	.EXPORT	xosdskSrchUnit
	.EXPORT	xosdskStK4Byte
	.EXPORT	xosdskStRtProt
	.EXPORT	xosdskStU1Byte
	.EXPORT	xosdskStU2Byte
	.EXPORT	xosdskStU4Byte
	.EXPORT	xosdskStU8Byte
	.EXPORT	xosdskUnitDesp
	.EXPORT	xosdskUnitName
	.EXPORT	xosdskUnitType
	.EXPORT	xosdskUnlinkDriver
	.EXPORT	xosdskUnmount
	.EXPORT	xosdskVolName
	.EXPORT	xosdskXfer
.IF NE $$DSKWRITE
	.EXPORT	xosdskwrpnt, xosdskwring, xosdskwrend
.ENDC

	CODE

;SVC dispatch table for disk class devices

	.MOD	4
dskdsp::.LONG	xosdskMount	;sd_mount      = 0.   - Mount
	.LONG	knlRtnZero##	;sd_cleardev   = 4.   - Clear device
	.LONG	xosdskCDcb	;sd_cleardcb   = 8.   - Clear DCB
	.LONG	knlRtnZero##	;sd_commit     = 12.  - Commit data to disk
	.LONG	knlRtnZero##	;sd_transold   = 16.  - Transfer device/old
	.LONG	knlRtnZero##	;sd_transnew   = 20.  - Transfer device/new
	.LONG	knlRtnZero##	;sd_opena      = 24.  - Open additinal
	.LONG	xosdskLclOpen#	;sd_open1      = 28.  - Open device/file
	.LONG	xosdskLclParm#	;sd_devparm    = 32.  - Device parameters
	.LONG	knlIFnDev##	;sd_delete     = 36.  - Delete file
	.LONG	knlIFnDev##	;sd_rename     = 40.  - Rename file
	.LONG	dskinpblk	;sd_inblock    = 44.  - Input block
	.LONG	dskoutblk	;sd_outblock   = 48.  - Output block
	.LONG	dskoutblk1	;sd_outblockq  = 52.  - Output block (XFF)
	.LONG	dskoutstr	;sd_outstring  = 56.  - Output string
	.LONG	knlRtnMOne##	;sd_getiosts   = 60.  - Get input/output status
	.LONG	dskspecial	;sd_special    = 64.  - Special device function
	.LONG	dskclose	;sd_close      = 68.  - Close file
	.LONG	knlNullQioGQ##	;sd_label      = 72.  - Device label functions
	.LONG	knlNullQioGQ##	;sd_commitfunc = 76.  - Commit data to disk
	.LONG	dskinfo		;sd_devinfo    = 80.  - Return device info
	.LONG	xosdskNotChg	;dd_vfychg     = 84.  - Verify changed disk
	.LONG	dskopen		;dd_openn      = 88.  - Open file
	.LONG	knlIFnDev##	;dd_opend      = 92.  - Open file/directory
	.LONG	knlIFnDev##	;dd_rename     = 96.  - Rename file
	.LONG	dskclose2	;dd_close      = 100. - Close file
	.LONG	dskopenparms	;dd_openparms  = 104. - Offset of open parms
	.LONG	knlRtnZero##	;dd_setpath    = 108. - Set up path data
	.LONG	knlRtnZero##	;dd_chkpath    = 112. - Check path data
	.LONG	knlRtnZero##	;dd_clrpath    = 116. - Clear path data
	.LONG	knlNullCharStr##;dd_gtrtprot   = 120. - Get root protection
	.LONG	knlBadCharF##	;dd_strtprot   = 124. - Set root protection

;Class function dispatch table for disk class devices

	.LONG	CLSFMX
dskcls::.LONG	dskaddunit	;CF_ADDUNIT =  8. - Add unit
	.LONG	dskunitinfo	;CF_PUNITS  =  9. - Get information about
				;		      physical units
	.LONG	knlIFnDev	;CF_AUNITS  = 10. - Get information about active
				;		      units (files)
	.LONG	disksrch	;CF_DEVSRCH = 11. - Search for device by name
CLSFMX=!{$-dskcls}/4
.PAGE
;Class characteristics tables for the DISK device class

	DATA

	.MOD	4
diskdctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  NUMBER , DECV ,  , 4        , msgnumber , knlGetSysVal##, 0             , dskdcbnum
 DCHARENT  MAXIMUM, DECV ,  , 4        , msgmaximum, knlGetSysVal##, knlSetSysVal##, dskdcbmax
 DCHARENT  LIMIT  , DECV ,  , 4        , msglimit  , knlGetSysVal##, knlSetSysVal##, dskdcblmt
 DCHARENT  NUMDBUF, DECV ,  , 4        , msgnumdbuf, knlGetSysVal##, setnumdbuf    , numdbuf
 DCHARENT  NUMSBUF, DECV ,  , 4        , msgnumsbuf, knlGetSysVal##, setnumsbuf    , numsbuf
 DCHARENT  DCSINFO, DATAS, H, dcsi_SIZE, msgdcsinfo, dcsinfo#      , 0             , 0

	CODE

msgnumber: DCHARINFO  {Number of in use disk devices}
msgmaximum:DCHARINFO  {Maximum number of in use disk devices}
msglimit:  DCHARINFO  {Maximum number of disk devices allowed}
msgnumdbuf:DCHARINFO  {Number of disk data buffers}
msgnumsbuf:DCHARINFO  {Number of disk system buffers}
msgdcsinfo:DCHARINFO  {Disk cache information}
msgdosnm:  DCHARINFO  {DOS name (drive letter) for unit}
.PAGE
;IO parameter table for raw disk open operations

	.MOD	4
	.LONG	OPARMMAX
dskopenparms::
	.LONG	opnpgenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	opnpfilparms	 ;IOPAR_FILxxx = 01xx - File IO parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	xosdskIoDskParms ;IOPAR_DSKxxx = 03xx - Disk IO parameters
OPARMMAX=!{$-dskopenparms}/4

	.LONG	OPARMGENMAX
opnpgenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopDummyS##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDummyN##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopDummyN##	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS	   = 0009h
	.LONG	0		;IOPAR_INPQLMT	   = 000Ah
	.LONG	0		;IOPAR_OUTQLMT	   = 000Bh
	.LONG	knlIopDummyN##	;IOPAR_SIVECT1     = 000Ch
	.LONG	knlIopDummyN##	;IOPAR_SIVECT2     = 000Dh
	.LONG	knlIopDummyN##	;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
OPARMGENMAX=!{$-opnpgenparms}/4

	.LONG	OPARMFILMAX
opnpfilparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN##	;IOPAR_DIRHNDL     = 0101h
	.LONG	knlIopDummyN##	;IOPAR_SRCATTR     = 0102h
	.LONG	knlIopNullN##	;IOPAR_FILATTR     = 0103h
	.LONG	knlIopNullN##	;IOPAR_DIROFS      = 0104h
	.LONG	xosdskOpnPioPos	;IOPAR_ABSPOS	   = 0105h
	.LONG	xosdskOpnPioPos	;IOPAR_RELPOS	   = 0106h
	.LONG	xosdskOpnPioPos	;IOPAR_EOFPOS	   = 0107h
	.LONG	0		;		   = 0108h
	.LONG	knlIopNullN##	;IOPAR_LENGTH      = 0109h
	.LONG	knlIopNullN##	;IOPAR_REQALLOC    = 010Ah
	.LONG	knlIopNullN##	;IOPAR_RQRALLOC    = 010Bh
	.LONG	knlIopNullN##	;IOPAR_GRPSIZE     = 010Ch
	.LONG	knlIopNullN##	;IOPAR_ADATE       = 010Dh
	.LONG	knlIopNullN##	;IOPAR_CDATE       = 010Eh
	.LONG	knlIopNullN##	;IOPAR_MDATE       = 010Fh
	.LONG	knlIopNullN##	;IOPAR_PROT        = 0110h
	.LONG	knlIopDummyT##	;IOPAR_OWNNAME     = 0111h
	.LONG	knlIopDummyT##	;IOPAR_GRPNAME     = 0112h
	.LONG	0		;IOPAR_SETLOCK	   = 0113h
	.LONG	0		;IOPAR_CLRLOCK	   = 0114h
	.LONG	knlIopDummyN##	;IOPAR_CLSTIME     = 0115h
	.LONG	knlIopDummyS##	;IOPAR_CLSNAME     = 0116h
	.LONG	knlIopDummyT##	;IOPAR_CLSMSG	   = 0117h
	.LONG	knlIopDummyN##	;IOPAR_SHRPARMS    = 0118h
OPARMFILMAX=!{$-opnpfilparms}/4
.PAGE
;Device parameter table for disk IO transfer operations

	.LONG	PARMMAX
dskioparms::
	.LONG	dskiogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	dskiofilparms	 ;IOPAR_FILxxx = 01xx - File IO parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	xosdskIoDskParms ;IOPAR_DSKxxx = 03xx - Disk IO parameters
PARMMAX=!{$-dskioparms}/4

	.LONG	PARMGENMAX	;Size of table
dskiogenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopFilOptn##	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopFilSpec##	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts##	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum##	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId##	;IOPAR_GLBID       = 0005h
	.LONG	0		;IOPAR_DELAY       = 0006h
	.LONG	knlIopNullN##	;IOPAR_TIMEOUT     = 0007h
	.LONG	knlIopIoSts##	;IOPAR_INPSTS	   = 0008h
	.LONG	knlIopIoSts##	;IOPAR_OUTSTS	   = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT	   = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT	   = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	0		;IOPAR_BUFRLMT	   = 0010h
PARMGENMAX=!{$-dskiogenparms}/4

;File IO parameter table for non-file structured disks

	.LONG	PARMFILMAX
dskiofilparms:
	.LONG	0
	.LONG	0		;IOPAR_DIRHNDL     = 0101h
	.LONG	knlIopNullN##	;IOPAR_SRCATTR     = 0102h
	.LONG	knlIopNullN##	;IOPAR_FILATTR     = 0103h
	.LONG	knlIopNullN##	;IOPAR_DIROFS      = 0104h
	.LONG	dskiopabspos	;IOPAR_ABSPOS	   = 0105h
	.LONG	dskioprelpos	;IOPAR_RELPOS	   = 0106h
	.LONG	0		;IOPAR_EOFPOS	   = 0107h
	.LONG	0		;		   = 0108h
	.LONG	knlIopNullN##	;IOPAR_LENGTH      = 0109h
	.LONG	knlIopNullN##	;IOPAR_REQALLOC    = 010Ah
	.LONG	knlIopNullN##	;IOPAR_RQRALLOC    = 010Bh
	.LONG	knlIopNullN##	;IOPAR_GRPSIZE     = 010Ch
	.LONG	knlIopNullN##	;IOPAR_ADATE       = 010Dh
	.LONG	knlIopNullN##	;IOPAR_CDATE       = 010Eh
	.LONG	knlIopNullN##	;IOPAR_MDATE       = 010Fh
	.LONG	knlIopNullN##	;IOPAR_PROT        = 0110h
	.LONG	knlIopNullT##	;IOPAR_OWNNAME     = 0111h
	.LONG	knlIopNullT##	;IOPAR_GRPNAME     = 0112h
	.LONG	knlIopNullN##	;IOPAR_SETLOCK	   = 0113h
	.LONG	knlIopNullN##	;IOPAR_CLRLOCK	   = 0114h
	.LONG	0		;IOPAR_CLSTIME     = 0115h
	.LONG	0		;IOPAR_CLSNAME     = 0116h
	.LONG	0		;IOPAR_CLSMSG	   = 0117h
	.LONG	knlIopNullN##	;IOPAR_SHRRETRY    = 0118h
	.LONG	knlIopNullN##	;IOPAR_SHRDELAY    = 0119h
PARMFILMAX=!{$-dskiofilparms}/4

;Disk IO parameter table for non-file structured disks

	.LONG	PARMDSKMAX
xosdskIoDskParms:
	.LONG	0
	.LONG	dskiopfstype	;IOPAR_DSKFSTYPE   = 0301h
	.LONG	dskiopsectsize	;IOPAR_DSKSECTSIZE = 0302h
	.LONG	dskiopclssize	;IOPAR_DSKCLSSIZE  = 0303h
	.LONG	dskiopttlspace	;IOPAR_DSKTTLSPACE = 0304h
	.LONG	dskiopavlspace	;IOPAR_DSKAVLSPACE = 0305h
	.LONG	dskiopnumhead	;IOPAR_DSKNUMHEAD  = 0306h
	.LONG	dskiopnumsect	;IOPAR_DSKNUMSECT  = 0307h
	.LONG	dskiopnumcyln	;IOPAR_DSKNUMCYLN  = 0308h
	.LONG	dskiopdskblk	;IOPAR_DSKBLOCK    = 0309h

PARMDSKMAX=!{$-xosdskIoDskParms}/4
.PAGE
	.SBTTL	Initialization routine

	INITSUB	initdsk

initdsk::
	MOVL	EDI, #dskchk		;Install our class
	MOVL	EBX, #dskcls
	MOVL	EAX, #'DISK'
	CLRL	EDX
	MOVL	ECX, #diskdctbl
	MOVL	ESI, #xosdskCcb
	CALL	knlNewClass##
	JC	10$.S
	MOVL	knlDskCcb##, ESI
	CALL	initbufr#
	JC	10$.S
	MOVL	ECX, #xcodetop#
	CLRL	EDX
	CLRL	EAX
10$:	RET

	CODE
.PAGE
	.SBTTL	xosdskMakeUcb - Subroutine to create disk UCB

;Subroutine to create disk UCB
;	c(AL)  = Value for ucb_bits
;	c(AH)  = ASCII letter for disk name
;	c{EBX} = Offset of KCB
;	c{ECX} = Size of positive part of UCB
;	c(DL)  = Primary unit number
;	c(DH)  = Secondary unit number
;	CALL	xosdskMakeUcb
;	C:set = Error
;	C:clr = Normal
;	  c{ESI} = Address of UCB just created

xosdskMakeUcb:
	PUSHL	EDI
	PUSHL	EBX			;Save offset of KCB
	PUSHL	EDX			;Save unit numbers
	PUSHL	EAX			;Save ucb_bits value and ASCII letter
	LEAL	EDX, ucb_mSIZE[ECX]
	PUSHL	EDX
	CALL	knlGetIndex##
	JC	2$.S
	CALL	knlGetXmbClr##
	JC	2$.S
	MOVB	ucb_sizex+ucb_mSIZE[ESI], CL
2$:	POPL	ECX
	POPL	EDX			;Restore ucb_bits value and letter
	JC	24$			;If error
	LEAL	EDI, ucb_mSIZE[ESI]	;OK - point to base of UCB
	SHRL	ECX, #2			;Change size to number of longs
6$:	POPL	EAX			;Restore unit numbers
	MOVB	ucb_name.B[EDI], DH	;Store first letter
	MOVB	ucb_bits.B[EDI], DL	;Store descriptor bits
	MOVL	ucb_dsp.B[EDI], #DS$PHYS|DS$NOABORT|DS$LCLDISK|DS$QIN|DS$QOUT
	MOVB	ucb_punit[EDI], AL	;Store unit numbers
	MOVB	ucb_sunit[EDI], AH
	MOVZBL	EAX, AL
	LEAL	EBX, ucb_name+1.B[EDI]	;Also put it in as ASCII
	CALL	knlPutDecNmbr##
	MOVZBL	EAX, ucb_sunit[EDI]	;Need partition number?
	TESTL	EAX, EAX
	JE	12$.S			;No
	MOVB	[EBX], #'P'		;Yes
	INCL	EBX
	CALL	knlPutDecNmbr##
12$:	MOVL	ucb_sdisp.B[EDI], #dskdsp ;Assume not file structured
	MOVL	ECX, #6t		;Get a buffer for the hash table
	CALL	knlGetXmbClr##
	JC	22$
	MOVL	ucb_hash.B[EDI], ESI
	MOVL	ECX, #ucbx_INDEX
	CALL	knlGetXmbClr##
	JC	20$.S
	MOVL	ucb_ext.B[EDI], ESI
	POPL	EBX			;Restore KCB offset
	MOVL	ucb_kcb.B[EDI], EBX
	MOVL	EAX, kcb_disp.B[EBX]	;Store UCB's copy of the function
	MOVL	ucb_disp.B[EDI], EAX	;  dispatch table pointer
	MOVL	EAX, kcb_ioreg1.B[EBX]	;Also store IO register number
	MOVL	ucb_ioreg1.B[EDI], EAX
	MOVW	AX, ucb_punit[EDI]
	LEAL	ECX, kcb_fucb.B[EBX]	;Find place to link in this UCB
14$:	MOVL	EDX, [ECX]		;Get next UCB
	TESTL	EDX, EDX
	JE	18$.S			;If no more
	CMPB	AL, ucb_punit[EDX]	;Check primary unit number
	JB	18$.S			;If less, it goes here
	JA	16$.S			;If greater, advance to next
	CMPB	AH, ucb_sunit[EDX]	;Same, check secondary unit number
	JB	18$.S			;If less, it goes here
16$:	MOVL	ECX, EDX		;Advance to next UCB
	JMP	14$.S

18$:	MOVL	[ECX], EDI
	MOVL	[EDI], EDX
	MOVL	ESI, EDI
	INCL	ucbcount		;Increase number of UCBs
	MOVL	ucb_pblksz[ESI], #1	;Store default physical block size
	MOVL	ucb_fsname+0[ESI], #'NotM'
	MOVL	ucb_fsname+4[ESI], #'ntd'
	MOVL	ucb_shrdelay.B[ESI], #3t
	MOVL	ucb_unmount.B[ESI], #ret010
	CLC				;Make sure C is clear
	POPL	EDI
	RET

;Here if error after UCB is allocated

20$:	MOVL	EDI, ucb_hash.B[ESI]
	CALL	knlGiveXmb##
22$:	MOVL	EDI, ESI		;Give up the UCB
	CALL	knlGiveXmb##
24$:	POPL	EDX			;Restore registers and fail
	POPL	EBX
	POPL	EDI
	RET
.PAGE
	.SBTTL	xosdskNewDriver - Subroutine to register low level disk driver

;Subroutine to register low level disk driver - must be called with the exec
;  memory resource
;	c{EBX} = Name of driver (4 characters)
;	c{EDX} = Offset of disk function dispatch table for driver
;	CALL	xosdskNewDriver
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosdskNewDriver:
	PUSHL	ECX
	MOVL	ECX, #12t
	CALL	knlGetXMem##		;Get memory for the driver data block
	POPL	ECX
	JC	4$.S			;If error
	MOVL	4.B[EDI], EBX		;OK - store name
	MOVL	8.B[EDI], EDX		;Store offset of output dispatch table
	MOVL	EAX, fdskdrv		;Link into list of disk drivers
	MOVL	[EDI], EAX
	MOVL	fdskdrv, EDI
4$:	RET

	.SBTTL	xosdskUnlinkDriver - Subroutine to unlink a low level disk driver

;Subroutine to unlink a low level disk driver.  This routine does NOT give
;  the memory used by the driver data block.  It unlinks the last driver
;  data block set up
;	CALL	xosdskUnlinkDriver

xosdskUnlinkDriver:
	MOVL	EBX, fdskdrv
	MOVL	EDX, [EBX]
	MOVL	fdskdrv, EDX
	RET
.PAGE
	.SBTTL	xosdskMakeKcb - Subroutine to create disk KCB

;Subroutine to create disk KCB - must be called with the exec memory resource
;	c(AL)  = Value for kcb_bits
;	c{ECX} = Size of KCB to make (positive part only)
;	c{EBX} = Offset of controller dispatch table
;	c{EDX} = Type name
;	CALL	xosdskMakeKcb
;	C:set = Error
;	C:clr = Normal
;	  c{EDI} = Address of KCB just created

xosdskMakeKcb:
	PUSHL	EDX			;Save type name
	PUSHL	EBX			;Save offset of dispatch table
	PUSHL	EAX			;Save value for kcb_bits
	LEAL	EDX, kcb_mSIZE.B[ECX]	;Add in size of negative part of KCB
	CALL	knlGetIndex##
	JC	4$.S
	CALL	knlGetXmbClr##
	JC	4$.S
	LEAL	EDI, kcb_mSIZE.B[ESI]
	MOVB	kcb_sizex.B[EDI], CL	;Store size index for the block
	POPL	EAX
	MOVB	kcb_bits.B[EDI], AL	;Store bits in the KCB
	POPL	kcb_disp.B[EDI]		;Store offset of dispatch table
	POPL	EBX
	MOVL	kcb_type.B[EDI], EBX	;Store type name in the KCB
	CLRL	EAX
	DECL	EAX
	MOVL	kcb_fnext.B[EDI], EAX	;Initialize fork list link
	PUSHL	firstkcb		;Link into master KCB chain
	POPL	[EDI]
	MOVL	firstkcb, EDI
	RET				;Thats all

;Here if error

4$:	POPL	EBX			;Fix up the stack
	POPL	EBX
	POPL	EBX
	RET				;And return
.PAGE
	.SBTTL	xosdskGiveupKcb - Subroutine to remove a KCB

;Subroutine to remove a KCB
;	c{EBX} = Offset of KCB
;	c{EDX} = Offset of pointer to first KCB for controller type
;	CALL	xosdskGiveupKcb

xosdskGiveupKcb:
	CMPL	[EDX], EBX
	JE	2$.S
	MOVL	EDX, [EDX]
	TESTL	EDX, EDX
	JE	10$.S
	ADDL	EDX, #kcb_nexts.B
	JMP	xosdskGiveupKcb.S

;Here with location of the KCB in the local list

2$:	MOVL	EAX, kcb_nexts.B[EBX]
	MOVL	[EDX], EAX
xosdskGiveupKcb2:
	MOVL	EDX, #firstkcb		;Point to global first KCB pointer
4$:	CMPL	[EDX], EBX
	JE	6$.S
	MOVL	EDX, [EDX]
	TESTL	EDX, EDX
	JE	10$.S
	ADDL	EDX, #kcb_nexts.B
	JMP	4$.S

;Here with location of the KCB in the global list

6$:	MOVL	EAX, [EBX]
	MOVL	[EDX], EAX
	PUSHL	ESI			;Finally, give up the KCB
	MOVZBL	ECX, kcb_sizex.B[EBX]
	LEAL	ESI, -kcb_mSIZE.B[EBX]
	CALL	knlGiveXmb##
	POPL	ESI
	RET

10$:	CRASH	NKCB
.PAGE
	.SBTTL	xosdskMakeFscb - Subroutine to create disk FSCB

;Subroutine to create disk FSCB
;	c{EBX} = Offset of first file system check routine
;	c{EDX} = Offset of second file system check routine
;	CALL	xosdskMakeFscb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset of FSCB

xosdskMakeFscb:
	MOVL	ECX, #fscb_SIZE		;Get space for the FSCB
	CALL	knlGetXMem##
	JC	4$.S			;If error
	MOVL	EAX, lastfscb		;Link into list of FSCBs
	TESTL	EAX, EAX
	JNE	2$.S
	MOVL	EAX, #firstfscb
2$:	MOVL	[EAX], EDI
	MOVL	lastfscb, EDI
	MOVL	fscb_chk1.B[EDI], EBX
	MOVL	fscb_chk2.B[EDI], EDX
4$:	RET
.PAGE
	.SBTTL	setnumdbuf - Number of disk data buffers

;Here to set the NUMDBUF class characteristic - Number of disk data buffers

setnumdbuf:
	SUBL	EAX, numdbuf
	JBE	retclc.S
	MOVL	ECX, EAX
	MOVL	EBX, #dbuffirst#
	MOVL	EDX, #CB_DATAMAGIC
	CALL	addbufrs#		;Create the data buffers
	JC	2$.S
	ADDL	numdbuf, EAX		;Increase the counts
	ADDL	xosdskDBufCnt#, EAX
2$:	RET				;Thats all

	.SBTTL	setnumsbuf - Number of disk system buffers

;Here to set the NUMSBUF class characteristic - Number of disk system buffers

setnumsbuf:
	SUBL	EAX, numsbuf
	JBE	retclc.S
	MOVL	ECX, EAX
	MOVL	EBX, #sbuffirst#
	MOVL	EDX, #CB_SYSMAGIC
	CALL	addbufrs#		;Create the system buffers
	JC	4$.S
	ADDL	numsbuf, EAX		;Increase the counts
	ADDL	xosdskSBufCnt#, EAX
retclc:	CLC
4$:	RET				;Thats all
.PAGE
	.SBTTL	dskaddunit - Disk class add unit function

;Here for the add unit class function (CL_ADDUNIT) for the disk class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	dskaddunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count (number of units added)

;Description block for adduparms:

	DATA

	.MOD	4
dskaublk:
 DCHARBGN  2, knlDCharValCom##
 DCHARENT  UNIT , DECV, , 1, 0, 0, dauunit , 0
 DCHARENT  TYPE , TEXT, , 4, 0, 0, dauctype, 0
 DCHARENT  INDEX, DECV, , 1, 0, 0, dauindex, 0
 DCHARENT  IOREG, DECV, , 4, 0, 0, daureg  , 0

	CODE

$$$=!0
FRM dau_ioreg , 4t		;IO register number
FRM dau_unit  , 4t		;Unit number
FRM dau_index , 4t		;Index on controller
FRM dau_kcb   , 4t		;Offset of KCB
FRM dau_type  , 4t		;Controller type
FRM dau_char  , 8t		;Address of chracteristics list
dau_SIZE=!$$$

dskaddunit::
	ENTER	dau_SIZE, 0		;Set up and initialize our stack frame
	CLRL	EAX
	MOVL	dau_kcb.B[EBP], EAX
	MOVL	dau_ioreg.B[EBP], EAX
	DECL	EAX
	MOVL	dau_unit.B[EBP], EAX
	MOVL	dau_type.B[EBP], EAX
	MOVL	dau_index.B[EBP], #1
	IFFAULT	6$
	LFSL	EDX, iorb_buffer2.B[ESI]
	MOVL	dau_char+0.B[EBP], EDX
	MOVL	dau_char+4.B[EBP], FS
	CALL	knlGiveQel##		;Give up the IORB
	MOVL	EBX, #dskaublk		;Process the characteristics
	MOVB	AL, #1			;Ignore bad names here
	CALL	knlAddUnitChar##
	JNC	8$.S			;If no error
4$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	LEAVE				;Fail
	TOFORK
	STC
	RET

;Here if address error with IORB

	FAULTHDR
6$:	CALL	knlGiveQel##
	MOVL	EAX, #ER_ADRER
	JMP	4$.S

;Here with all parameters processed - make sure we got everything we need

8$:	MOVL	EAX, dau_unit.B[EBP]
	ORL	EAX, dau_type.B[EBP]
	INCL	EAX
	JNE	12$.S
10$:	MOVL	EAX, #ER_CHARM
	JMP	4$.S

;Here with all needed parameters found

12$:	MOVL	EAX, dau_type.B[EBP]	;Get type name
	MOVL	ECX, fdskdrv		;Point to first disk driver data block
	JREGZ	ECX, 15$		;If none at all!
14$:	CMPL	4.B[ECX], EAX		;Is this the one we want?
	JE	16$.S			;Yes
	MOVL	ECX, [ECX]		;No - advance to next
	TESTL	ECX, ECX
	JNE	14$.S
15$:	MOVL	EAX, #ER_NSTYP
	JMP	4$.S

;Here with data block for disk driver - now we must see if the KCB is already
;  defined

16$:	MOVL	EBX, firstkcb		;Point to first disk KCB
	TESTL	EBX, EBX
	JE	28$.S			;If no KCBs at all
	MOVL	EDX, dau_ioreg.B[EBP]	;Get IO register number
18$:	MOVL	EAX, dau_type.B[EBP]
	CMPL	EAX, kcb_type.B[EBX]	;For this type controller?
	JNE	26$.S			;No
	CMPL	EDX, kcb_ioreg1.B[EBX]	;Yes - for this controller?
	JNE	20$.S			;No
	TESTB	kcb_bits.B[EBX], #KB$ERROR ;Yes - can we use it?
	JNE	30$.S			;No - fail
	MOVL	dau_kcb.B[EBP], EBX	;Yes - remember offset of the KCB
20$:	MOVL	ESI, kcb_fucb.B[EBX]	;Yes - get first UCB
	TESTL	ESI, ESI
	JE	26$.S			;If no UCBs for controller
22$:	MOVB	AL, dau_unit.B[EBP]
	CMPB	ucb_punit[ESI], AL	;Same unit number?
	JE	32$.S			;Yes - fail
	MOVB	AL, dau_index.B[EBP]	;No - same index?
	CMPB	ucb_index.B[ESI], AL
	JNE	24$.S			;No
	CMPL	kcb_ioreg1.B[EBX], EDX	;Yes - on this controller
	JE	32$.S			;Yes - fail
24$:	MOVL	ESI, [ESI]		;No - advance to next UCB
	TESTL	ESI, ESI
	JNE	22$.S
26$:	MOVL	EBX, [EBX]		;No more UCBs, advance to next KCB
	TESTL	EBX, EBX
	JNE	18$.S			;Continue if another KCB
28$:	MOVL	EAX, dau_unit.B[EBP]	;Get unit number
	MOVL	EDI, 8.B[ECX]		;Get offset of dispatch table
	MOVL	EBX, dau_kcb.B[EBP]	;Get offset of KCB (if any)
	MOVL	ECX, dau_index.B[EBP]	;Get index on controller
	MOVL	ESI, dau_ioreg.B[EBP]	;Get base IO register for controller
	LFSL	EDX, dau_char.B[EBP]	;Get address of the characteristics
	LEAVE				;  list
	JMPIL	CS:ks_addunit.B[EDI]	;Dispatch to addunit routine for driver

;Here if bad controller

30$:	MOVL	EAX, #ER_DEVER
	JMP	34$.S

;Here if unit already defined (same unit number)

32$:	MOVL	EAX, #ER_DUADF
34$:	JMP	4$
.PAGE
;Subroutine called by adduchar when "UNIT" characteristics found

dauunit:CMPL	EAX, #99t
	JA	knlBadCharV##
	MOVL	dau_unit.B[EBP], EAX
	CLC
	RET

;Subroutine called by adduchar when "TYPE" characteristics found

dauctype:
	MOVL	dau_type.B[EBP], EAX
	RET

;Subroutine called by adduchar when "IOREG" characteristics found

daureg:	CMPL	EAX, #0.B
	JE	knlBadCharV##
	CMPL	EAX, #0FFFFh
	JA	knlBadCharV##
	MOVL	dau_ioreg.B[EBP], EAX
	CLC
	RET

;Subroutine called by adduchar when "INDEX" characcteristics found

dauindex:
	MOVL	dau_index.B[EBP], EAX
	RET
.PAGE
	.SBTTL	dskunitinfo - Disk class get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  disk class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	dskunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

dskunitinfo:
	MOVL	ECX, ucbcount		;Get number of units
	CMPL	iorb_count.B[ESI], #0.B ;Want number of units only?
	JE	8$.S			;Yes
	CMPL	iorb_count.B[ESI], ECX	;Is the buffer big enough?
	JA	14$.S			;No - fail
	IFFAULT	16$
	LESL	EDI, iorb_buffer2.B[ESI] ;Yes - get buffer address
	MOVL	EDX, firstkcb		;Yes - point to first KCB
2$:	MOVL	EBX, kcb_fucb.B[EDX]	;Get first UCB for controller
	TESTL	EBX, EBX
	JE	6$.S			;If no units at all
4$:	MOVL	EAX, ucb_name+0.B[EBX]
	IFFAULT	16$
	STOSL	[EDI]
	MOVL	EAX, ucb_name+4.B[EBX]
	IFFAULT	16$
	STOSL	[EDI]
	MOVL	EBX, [EBX]		;Get next UCB
	TESTL	EBX, EBX
	JNE	4$.S			;Continue if another
6$:	MOVL	EDX, [EDX]		;Get next KCB
	TESTL	EDX, EDX
	JNE	2$.S			;Continue if another
	MOVL	ECX, ucbcount		;Get number of names we gave him
8$:	CLRL	EAX
10$:	CALL	knlGiveQel##
	MOVL	EBX, #QSTS$DONE		;Yes
	TOFORK
	RET

;Here if count is too small

14$:	MOVL	EAX, #ER_ICDEV
	CLRL	ECX
	JMP	10$.S

	FAULTHDR
16$:	TOFORK
	JMP	knlQAdrErr0##
.PAGE
dskinfo:MOVL	EBX, #physiostr
	MOVL	EDX, #-1
	JMP	knlInfoSimple##
.PAGE
	.SBTTL	dskchk - Device check routine for disks

;Device check routine for disks - we make 3 scans of the UCBs - first we check
;  for a matching physical name, next we check for a matching DOS name, and
;  finally, we check for a matching volume name
;	c{SS:EBX} = Address of device name (16 bytes)
;	CALL	dskchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  EBX and ESI are preserved

dskchk::CALL	disksrch		;Search for the disk unit
	JC	10$.S			;If need to mount the base physical unit
	JNE	8$.S			;If not a disk
	PUSHL	ESI			;If found it
	MOVL	ESI, EDI
	MOVL	EDX, #xosdskCcb
	CALL	xosdskGetDcb		;Get a disk DCB
	JC	6$.S			;If error
2$:	MOVL	EAX, ucb_sdisp.B[ESI]
	MOVL	dcb_sdisp.B[EDI], EAX
	MOVL	EAX, ucb_dsp.B[ESI]	;Assume normal disk description bits
	TESTB	SS:xffStatus1##, #XF1$SPOOL ;Right?
	JE	4$.S			;Yes
	MOVL	EAX, #DS$SPOOL|DS$NOABORT|DS$LCLDISK|DS$MLTUSER|DS$QOUT
					;No - get the spooled bits (Setting
4$:	MOVL	dcb_dsp.B[EDI], EAX	;  DS$MLTUSER here is not really right,
					;  but it does not do any harm!)
	CLRL	EAX			;Set Z
	MOVL	dcb_opencnt.B[EDI], EAX	;Clear open count in DCB
6$:	POPL	ESI
8$:	RET

;Here if partition does not exist and the base unit does exist - we attempt to
;  mount and/or verify another partition or the base unit.  If the base unit is
;  not mounted, we use it.  If the base unit is mounted and has any partitions
;  defined, we use the first partition.  If the base unit is mounted but has no
;  partitions defined, we use the base unit.

10$:	PUSHL	ESI			;Save the secondary unit number
	PUSHL	EAX
	MOVL	ESI, EDI
	TESTB	ucb_sts1.B[ESI], #U1$MOUNT ;Is the base unit mounted?
	JE	12$.S			;No - use it
	MOVL	EDX, ucb_next.B[ESI]	;Yes - see if we have any partitions
	ORL	EDX, EDX
	JE	12$.S			;No partitions - use the base unit
	MOVB	AL, ucb_punit[ESI]
	CMPB	ucb_punit[EDX], AL
	JNE	12$.S
	MOVL	ESI, EDX		;Found a partition - use it
12$:	MOVL	EDX, #xosdskCcb
	CALL	xosdskGetDcb		;Get a disk DCB
	JC	22$			;If error
	MOVL	EAX, ucb_sdisp.B[ESI]	;OK
	MOVL	dcb_sdisp.B[EDI], EAX
	MOVL	EAX, ucb_dsp.B[ESI]
	MOVL	dcb_dsp.B[EDI], EAX
	CLRL	EAX
	MOVL	dcb_opencnt.B[EDI], EAX	;Clear open count in DCB
	MOVB	SS:xffQueue##, #dcb_outframe ;Set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	POPL	EAX			;Restore secondary unit number
	REQUIREXFF
	PUSHL	EAX
	CALL	dskmount2		;Mount the base disk unit if we can
	JNC	14$.S			;If this worked
	CMPL	EAX, #ER_MDCHG.B	;Error - was it "media changed"?
	JNE	18$.S			;No - go fail
	CALL	dskmount2		;Yes - try this again!
	JC	18$.S			;Fail this time for all errors
14$:	POPL	EAX
	TESTB	ucb_sts1.B[ESI], #U1$MOUNT ;OK - did we really mount it?
	JE	18$.S			;No - say our partition is not there
	MOVB	AL, ucb_punit[ESI]	;Yes - now search to see if the
	MOVL	EDX, ESI		;  partition we want is there now
16$:	MOVL	EDX, ucb_next.B[EDX]
	TESTL	EDX, EDX
	JE	17$.S
	CMPB	ucb_punit[EDX], AL
	JNE	17$.S
	CMPB	ucb_sunit[EDX], AH
	JNE	16$.S
	DECL	ucb_dcbcnt.B[ESI]	;Found it - now make this our unit
	INCL	ucb_dcbcnt.B[EDX]
	MOVL	ESI, EDX
	MOVL	[EDI], ESI
	MOVL	EAX, ucb_name+0.B[ESI]
	MOVL	dcb_name+0.B[EDI], EAX
	MOVL	EAX, ucb_name+4.B[ESI]
	MOVL	dcb_name+4.B[EDI], EAX
	MOVL	EAX, ucb_name+8.B[ESI]
	MOVL	dcb_name+8.B[EDI], EAX
	MOVL	EAX, ucb_name+12t.B[ESI]
	MOVL	dcb_name+12t.B[EDI], EAX
	JMP	2$

;Here if did not find the partition we want after mounting the base unit - See
;  if we want a DOS name which also matches the base unit.

17$:	MOVL	EAX, dcb_name.B[EDI]
	CMPL	EAX, ucb_dosname.B[ESI]
	JNE	20$.S			;No - fail
	JMP	2$			;Yes - return the base unit

;Here if either we cannot mount the base unit or we mounted it and the partition
;  we want did not appear!  In this case we must give up the DCB we have been
;  using and indicate failure.  This will happen if there is an error mounting
;  the base unit or if a partition is specified that does not exist on the
;  drive.

18$:	POPL	EAX			;Fix up the stack
20$:	CALL	xosdskCDcb		;Give up the DCB
	JMP	24$.S

22$:	POPL	ESI			;Discard the secondary unit number
24$:	POPL	ESI			;Restore ESI
	MOVL	EAX, #ER_NSDEV
	STC
	RET
.PAGE
	.SBTTL	disksrch - Subroutine to search for disk given name

;Subroutine to search for disk given name
;	c{SS:EBX} = Address of device name (16 bytes)
;	CALL	disksrch
;	C:set = Base unit found, partition not found
;	  c(AL)  = Secondary unit number
;	  c{EDI} = Offset of UCB for base unit
;	C:clr
;	  Z:set = Match found (original name updated)
;	    c{EDI}     = Offset of UCB
;	  Z:clr = Not found
;  EBX and ESI are preserved

$$$=!0
FRM         , 1t
FRM ds_fltr , 1t
FRM ds_sunit, 1t
FRM ds_punit, 1t
FRM ds_EBX  , 4t
ds_SIZE=!$$$

disksrch::
	REQUIREFORK
	MOVZBL	EAX, SS:[EBX]		;Get first letter of name and clear AH
	CMPB	SS:1.B[EBX], #0		;Single character name?
	JNE	disksr2			;No

;Here if have a single character name - we must check to see if it a DOS disk
;  letter

	MOVL	EDX, firstkcb
2$:	TESTL	EDX, EDX
	JE	disksr2
	MOVL	EDI, kcb_fucb.B[EDX]	;Get first UCB
4$:	TESTL	EDI, EDI
	JE	12$.S

	MOVL	ECX, ucb_dosnmdct[EDI]	;Search the DOSNAMEn characteristic
6$:	TESTL	ECX, ECX		;  definitions
	JE	10$.S			;If no more
	CMPB	dct_dosnmname.B[ECX], AL ;This one?
	JE	14$.S			;Yes
	MOVL	ECX, dct_lnknext.B[ECX]	;No - advance to next block
	JMP	6$.S

;Here if no match on the DOSNAMEn definations

10$:	CMPB	ucb_dosname.B[EDI], AL	;Check DOS name for this disk
	JE	disksrd			;If found it
	MOVL	EDI, ucb_next.B[EDI]	;Not this disk - go on to next
	JMP	4$.S

;Here if no more disks for this controller

12$:	MOVL	EDX, kcb_next.B[EDX]	;Go on to next controller
	JMP	2$.S

;Here with a match on the DOS drive letter for a partition

14$:	ENTER	ds_SIZE, 0
	MOVL	ds_EBX.B[EBP], EBX
	MOVB	AL, ucb_punit[EDI]
	MOVB	ds_punit.B[EBP], AL
	MOVB	AL, dct_dosnmpart.B[ECX]
	MOVB	ds_sunit.B[EBP], AL
	MOVB	AL, ucb_name+0.B[EDI]
	MOVB	ds_fltr.B[EBP], AL	;Save first letter of real disk name
	JMP	disksr4.S
.PAGE
2$:	TESTL	ESP, ESP
	RET

;Here if didn't find a match on the DOS disk name

disksr2:CMPB	AL, #'F'		;Is it F (floppy disk)?
	JE	4$.S			;Yes
	CMPB	AL, #'S'		;No - is it S (SCSI disk)?
	JE	4$.S			;Yes
	CMPB	AL, #'D'		;No - is it D (IDE disk)?
	JNE	2$.S			;No - can't be a physial disk name
4$:	ENTER	ds_SIZE, 0		;Yes
	MOVB	ds_fltr.B[EBP], AL	;Save first letter
	MOVL	ds_EBX.B[EBP], EBX
	INCL	EBX
	MOVL	ECX, #15t
	CALL	getnumber		;Get number from the name
	JC	6$.S
	MOVB	ds_punit.B[EBP], DL
	MOVB	ds_sunit.B[EBP], #0
	CMPB	AL, #0			;Partition number specified?
	JE	disksr4.S		;No
	CMPB	AL, #'P'		;Maybe - must have a P next
	JNE	26$			;Not a P, thus not a disk name
	CALL	getnumber
6$:	JC	26$
	CMPB	AL, #0			;End of name?
	JNE	26$.S			;No - not a disk name
	MOVB	ds_sunit.B[EBP], DL
disksr4:MOVL	EDX, firstkcb
8$:	ORL	EDX, EDX
	JE	26$.S
	MOVL	EDI, kcb_fucb.B[EDX]	;Get first UCB
10$:	ORL	EDI, EDI
	JE	14$.S
	MOVB	AL, ds_fltr.B[EBP]	;Check first letter
	CMPB	ucb_name+0.B[EDI], AL
	JNE	12$.S
	MOVL	EAX, ds_punit.B[EBP]	;Check primary unit number
	CMPB	ucb_punit[EDI], AL
	JE	16$.S
12$:	MOVL	EDI, ucb_next.B[EDI]
	JMP	10$.S

14$:	MOVL	EDX, kcb_next.B[EDX]
	JMP	8$.S

;Here with match on the primary unit number

16$:	CMPB	AH, #0			;Want the primary unit?
	JE	20$.S			;Yes - finished
	MOVL	ECX, EDI		;No - remember offset of base UCB
18$:	MOVL	EDI, ucb_next.B[EDI]
	ORL	EDI, EDI
	JE	24$.S			;No more
	CMPB	ucb_punit[EDI], AL	;Same primary unit?
	JNE	24$.S			;No
	CMPB	ucb_sunit[EDI], AH	;Yes - this one?
	JNE	18$.S			;No
20$:	CMPL	ucb_devchar.B[EDI], #0.B ;Is it completely set up?
	JE	26$.S			;No - say not there!
	MOVL	EBX, ds_EBX.B[EBP]	;Restore EBX
	LEAVE
disksrd:MOVL	EAX, ucb_name+0.B[EDI]	;Get unit name
	MOVL	SS:[EBX], EAX
	MOVL	EAX, ucb_name+4.B[EDI]
	MOVL	SS:4.B[EBX], EAX
	MOVL	EAX, ucb_name+8.B[EDI]
	MOVL	SS:8.B[EBX], EAX
	MOVL	EAX, ucb_name+12t.B[EDI]
	MOVL	SS:12t.B[EBX], EAX
	CLRL	EAX			;Set Z and clear C
	RET

;Here if found the base unit but did not find the desired secondary unit

24$:	MOVL	EDI, ECX		;Indicate found base unit but not the
	STC				;  partition
	JMP	28$.S

;Here if disk was not found

26$:	TESTL	ESP, ESP
28$:	MOVL	EBX, ds_EBX.B[EBP]
	LEAVE
30$:	RET

;Subroutine to get number from the current position in the disk name
;	c{SS:EBX} = Pointer to name
;	CALL	getnumber
;	C:set = Not a number
;	C:clr = Have number
;	  c(AL)  = Stopper character
;	  c{EDX} = Number

getnumber:
	MOVB	AL, SS:[EBX]
	CMPB	AL, #'0'
	JB	36$.S
	CMPB	AL, #'9'
	JA	36$.S
	CLRL	EDX
32$:	MOVB	AL, SS:[EBX]
	INCL	EBX
	CMPB	AL, #'0'
	JB	38$.S
	CMPB	AL, #'9'
	JA	38$.S
	ANDL	EAX, #0Fh.B
	IMULL	EDX, #10t.B
	ADDL	EDX, EAX
	JMP	32$.S

36$:	STC
	RET

38$:	CLC
	RET
.PAGE
	.SBTTL	xosdskSrchUnit - Subroutine to search for disk unit

;Subroutine to search for disk unit given unit number and first letter of
;  unit name
;	c(AL) = First character of device name
;	c(AH) = Unit number
;	CALL	xosdskSrchUnit
;	Z:set = Unit found
;	Z:clr = Unit not found

xosdskSrchUnit:
	MOVL	EBX, firstkcb		;Point to first disk KCB
2$:	TESTL	EBX, EBX
	JE	8$.S
	MOVL	EDX, kcb_fucb.B[EBX]	;Point to first UCB for KCB
	TESTL	EDX, EDX
	JE	6$.S
	CMPB	ucb_name+0.B[EDX], AL	;Check first letter of disk name
	JNE	6$.S
4$:	CMPB	ucb_punit[EDX], AH	;Check unit number
	JE	ret002.S		;Found it - return with Z set
	MOVL	EDX, [EDX]		;Advance to next UCB for KCB
	TESTL	EDX, EDX
	JNE	4$.S			;Continue if more UCBs for KCB
6$:	MOVL	EBX, [EBX]		;Advance to nex KCB in system
	JMP	2$.S

8$:	TESTL	ESP, ESP
ret002:	RET
.PAGE
	.SBTTL	xosdskMount - Mount disk

;Here for the mount disk entry (sd_mount) - this routine is called for all
;  disk file systems
;	c{EDI} = Offset of DCB
;	CALL	xosdskMount
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;  ECX is respected

xosdskMount:
	REQUIREXFF
	MOVB	SS:xffQueue##, #dcb_outframe ;Set up output queue
	MOVW	dcb_outframe.B[EDI], SS
	MOVW	dcb_inpframe.B[EDI], #0
	BTL	SS:xffCmd##, #O%NOMOUNT	;Want to suppress mounting the disk?
	JNC	dskmount2.S		;No
	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Yes - can we do this?
	JNE	ret002.S		;Yes - do nothing here
dskmount2:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	knlNoUnit##
	MOVW	dcb_outframe.B[EDI], SS	;Store extended stack frame selector
	MOVL	SS:xffDcb##, EDI
4$:	TESTB	ucb_sts1.B[ESI], #U1$MOUNT ;Is this disk mounted now?
	JE	dskntmn			;No - go mount it
	ANDB	dcb_sts2.B[EDI], #~D2$DCHG ;Yes
	MOVL	EBX, ucb_disp.B[ESI]	;See if media is write protected
	CALLI	CS:ks_chkwp.B[EBX]
	JC	ret002.S		;If error
	CALL	xosdskGetDiskRes
	JC	ret002.S
	MOVL	EBX, ucb_disp.B[ESI]	;OK - see if disk has been changed
	CALLI	CS:ks_senchg.B[EBX]
	JMPIL	CS:dskmdsp[EDX*4]

	.MOD	4
dskmdsp:.LONG	dskvdon		 ;0 - Error
	.LONG	xosdskGiveDiskRes;1 - Disk not changed
	.LONG	dsknoms		 ;2 - Might be changed (no media sensor)
	.LONG	dskprob		 ;3 - Probably changed (try to assume changed)
	.LONG	dskaver		 ;4 - Probably changed (always verify)
	.LONG	dskchanged	 ;5 - Definately changed
.PAGE
;Here if disk does not have a media sensor and it has been long enough that
;  there is some question about the disk

dsknoms:TESTB	dcb_dsp.B[EDI], #DS$FILE ;Is this a physical disk?
	JNE	dskprob.S		;No - treat this as if its media sensor
	CLRL	EAX			;  just went off!
	JMP	20$			;Yes - say not changed!

;Here if disk might have been changed and we should assume changed if no one
;  else is using it

dskprob:CMPL	ucb_dcbcnt.B[ESI], #1.B	;Anyone else using this disk?
	JA	dskaver.S		;Yes - must verify it
dskchanged:
	CMPL	ucb_baseucb.B[ESI], #0.B ;No - is this a partition?
	JE	6$.S			;No
					;Yes - must check all partitions on the
	MOVL	EBX, ucb_baseucb.B[ESI]	;  physical unit
	MOVB	AL, ucb_punit[EBX]
4$:	MOVL	EBX, [EBX]
	TESTL	EBX, EBX
	JE	6$.S
	CMPL	EBX, ESI
	JE	4$.S
	CMPB	ucb_punit[ESI], AL	;Same physical unit?
	JNE	6$.S			;No
	CMPL	ucb_dcbcnt.B[ESI], #0.B	;Anyone else using this disk?
	JE	4$.S
	JMP	dskaver.S		;Yes - verify the change

6$:	CALL	xosdskChanged#		;Unmount the disk
	TESTL	ESI, ESI		;Still have a disk?
	JNE	14$.S			;Yes - go try to mount it again
8$:	MOVL	EAX, #ER_MDCHG
	JMP	dskvdon

;Here if disk might have been changed and we should always verify it

dskaver:MOVL	EBX, dcb_sdisp.B[EDI]
	CALLI	CS:dd_vfychg.B[EBX]
	JNC	dskvdon			;If OK
	TESTB	ucb_sts2.B[ESI], #U2$REQUNMNT
	JE	10$.S
	PUSHL	EAX
	CALL	xosdskChanged#
	POPL	EAX
10$:	CMPL	EAX, #ER_MDCHG		;Was the error media changed?
	JNE	20$.S			;No - just fail
	ORL	ESI, ESI		;Yes - do we still have a unit?
	JNE	14$.S			;Yes - try the mount the disk again
	MOVL	ESI, [EDI]		;No
	JMP	dskvdon

12$:	RET

;Here if disk is not mounted

dskntmn:CALL	xosdskGetDiskRes
	JC	12$.S
14$:	MOVL	EBX, ucb_disp.B[ESI]	;Call the drive's check change routine
	CALLI	CS:ks_chkchg.B[EBX]	;  to clear possible media change
	TESTL	EDX, EDX		;  indication
	JE	20$.S			;If error

;;;;; CAN GET HERE WITH ESI = 0 !!!!!!

18$:	ANDB	dcb_sts2.B[EDI], #~D2$DCHG
	ANDB	ucb_sts2.B[ESI], #~{U2$DCHG|U2$MCHG}
	MOVL	EBX, ucb_disp.B[ESI]	;See if media is write protected
	CALLI	CS:ks_chkwp.B[EBX]
	JC	20$.S
	MOVL	EAX, ucb_disp.B[ESI]	;Check for type of media
	CALLI	CS:ks_media.B[EAX]
	JNC	22$.S			;If OK
	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Error - non-file request?
	JNE	28$.S			;Yes - go on
20$:	JMP	dskvdon.S		;No - fail

;Here with media type determined - now we must see if we can determine the
;  file system type

22$:	JNE	28$.S			;If disk cannot contain a file structure

;Do the first file system scan - this checks in order for each file system using
;  a fairly strict check

	MOVL	EBX, firstfscb		;Get first file structure data block
	TESTL	EBX, EBX
	JE	30$.S			;If no file systems at all!
24$:	PUSHL	EBX
	CALLI	fscb_chk1.B[EBX]	;See if disk contains this file
	POPL	EBX			;  structure (do quick check)
	JBE	dskvdon.S		;Finished if C or Z set
	MOVL	EBX, [EBX]		;Not this one - advance to next
	TESTL	EBX, EBX		;Continue if more file systems
	JNE	24$.S

;We did not find a file system on the first scan - now do the second scan which
;  does a much more forgiving check - this is mainly intended to allow us to
;  find damanged DOS disks while still reconizing other file systems.

	MOVL	EBX, firstfscb		;Get first file structure data block
26$:	PUSHL	EBX
	CALLI	fscb_chk2.B[EBX]	;See if disk contains this file
	POPL	EBX			;  structure (do complete check)
	JBE	dskvdon.S		;Finished if C or Z set
	MOVL	EBX, [EBX]		;Not this one - advance to next
	TESTL	EBX, EBX		;Continue if more file systems
	JNE	26$.S
28$:	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	knlNoUnit##

;If we get here, this disk does not contain a file system that we know about

30$:	MOVL	EAX, #dskdsp
	MOVL	dcb_sdisp.B[EDI], EAX
	MOVL	ucb_sdisp.B[ESI], EAX
	MOVL	ucb_unmount.B[ESI], #xosdskUnmount
	MOVL	EAX, ucb_dsp.B[ESI]
	ANDL	EAX, #DS$REMOVE.B
	ORL	EAX, #DS$PHYS|DS$NOABORT|DS$LCLDISK|DS$QIN|DS$QOUT
	MOVL	dcb_dsp.B[EDI], EAX
	MOVL	ucb_dsp.B[ESI], EAX
	ORB	ucb_sts1.B[ESI], #U1$MOUNT ;Indicate mounted
	ANDB	ucb_sts2.B[ESI], #~U2$REQUNMNT
	MOVB	ucb_fstype.B[ESI], #0FFh ;Indicate no file system
	MOVB	ucb_fatmode.B[ESI], #0
	MOVL	ucb_fsname+0[ESI], #'None'
	CLRL	EAX
	MOVL	ucb_fsname+4[ESI], EAX
dskvdon:CALL	xosdskGiveDiskRes	;Wake up anyone who is waiting
	BTL	EAX, #31t		;Set C if error
	RET				;And return
.PAGE
	.SBTTL	xosdskNotChg - Common subroutine for fixed disks

;Common media check routine for fixed disks.  Always returns "not changed"
;	CALL	xosdskNotChg
;	c{EDX} = 1 (indicates not changed)

xosdskNotChg:
	MOVL	EDX, #1
	RET
.PAGE
	.SBTTL	dskvfychg - Verify changed disk

;Here for the check for the verify disk entry (dd_chkchg) - this routine is
;  called for non-file structured disks - since we know nothing about the
;  structure of such disks, we cannot do much about determining if it has been
;  changed - we always assume it was changed when get here!
;	c{EDI} = Offset of DCB
;	CALL	dskvfychg
;	C:set = Always
;	c{EAX} = Error code = ER_MDCHG

dskvfychg:
	REQUIREXFF
	MOVL	ESI, [EDI]		;Get offset of UCB
	TESTL	ESI, ESI
	JE	4$.S
	MOVL	EAX, #ER_MDCHG		;Indicate media changed error
	CALL	dskidle			;Make sure disk is idle
	CALL	xosdskChanged#		;Unmount the disk
4$:	JMP	knlNoUnit##
.PAGE
	.SBTTL	xosdskGetDiskRes - Subroutine to get disk resource

;Subroutine to get disk resource - must be called in extended fork context.
;  The disk resource is used to make allocation of disk space single threaded.
;  It is also used to interlock mounting and dismounting of disks.
;  IMPORTANT: There must be NO disk blocks or FIBs locked when this subroutine
;  is called!
;	c{ESI} = Offset of UCB
;	CALL	xosdskGetDiskRes
;  All registers are preserved

xosdskGetDiskRes:

	POPL	xxxDiskRes
	PUSHL	xxxDiskRes

	CMPL	SS:xffLockCnt##, #0.B	;Do we have any buffers locked?
	JNE	6$.S
	CMPW	ucb_resxff.B[ESI], #0.B	;Is the resource available?
	JNE	10$.S			;No - must wait
	MOVW	ucb_resxff.B[ESI], SS	;Yes - grab it
	POPL	dskrescall		;Save our call address for debugging
	JMPIL	dskrescall		;Return

6$:	CRASH	HBLK			;[Have Buffer LocKed]

8$:	CRASH	HVDR			;[HaVe Disk Resource]

;Here if disk resource is in use

10$:	PUSHL	EAX
	MOVL	EAX, SS			;Do we have it now?
	CMPW	ucb_resxff.B[ESI], AX
	JE	8$.S			;Yes - fail big!
	MOVZWL	EAX, ucb_restail[ESI]	;No - link us to the wait list
	TESTL	EAX, EAX
	JE	14$.S
	PUSHL	ES
	MOVL	ES, EAX
	MOVW	ES:xffWaitList##, SS
	POPL	ES
	JMP	16$.S

14$:	MOVW	ucb_reshead[ESI], SS
16$:	MOVW	ucb_restail[ESI], SS
	MOVW	SS:xffWaitList##, #0
18$:	CALL	knlXfWaitNTO##		;Wait for the resource
	JC	18$.S			;If error, just wait some more!
	MOVL	EAX, SS
	CMPW	ucb_resxff.B[ESI], AX	;Make sure we really have it!
	JNE	20$.S
	POPL	EAX
	RET

;Here if do not have the disk resource after waiting

20$:	CRASH	DNHR			;[Do Not Have Resource]
.PAGE
	.SBTTL	xosdskGiveDiskRes - Subroutine to give up disk resource

;Subroutine to give up disk resource - must be called in extended fork context
;	c{EDI} = Offset of DCB
;	CALL	xosdskGiveDiskRes
;	C:clr Always
;  All registers are preserved

xosdskGiveDiskRes:
	MOVL	ESI, [EDI]		;Get offset of the UCB
	PUSHL	EAX
	MOVL	EAX, SS
	CMPW	ucb_resxff.B[ESI], AX	;Do we really have the resource?
	JNE	2$.S			;No
	CMPW	ucb_reshead[ESI], #0.B	;Yes - anyone waiting?
	JNE	4$.S			;Yes
	MOVL	ucb_resxff.B[ESI], #0	;No - indicate not locked now
	POPL	EAX
	RET				;Finished

;Here if buffer is not locked by this process

2$:	CRASH	DNHR			;[Do Not Have Resource]

;Here if someone is waiting for this buffer

4$:	PUSHL	ES			;Remove extended fork frame from wait
	MOVL	ES, ucb_reshead[ESI]	;  list for resource
	MOVZWL	EAX, ES:xffWaitList##
	MOVL	ucb_reshead[ESI], EAX
	TESTL	EAX, EAX
	JNE	6$.S
	MOVL	ucb_restail[ESI], EAX
6$:	MOVW	ES:xffWaitList##, #0FFFFh
	MOVW	ucb_resxff.B[ESI], ES
	PUSHL	EDI
	MOVL	EDI, ES:xffDcb##	;Get DCB of requestor
	CLRL	EAX
	CALL	knlResumeOutput##	;Let him have the resource
	POPL	EDI
	POPL	ES
	POPL	EAX
	CLC				;Make sure C is clear
	RET				;And return
.PAGE
	.SBTTL	xosdskGetDcb - Subroutine to allocate disk DCB

;Subroutine to allocate disk DCB
;	c{SS:EBX} = Address of device name (16 characters)
;	c{EDX}    = Offset of CCB
;	c{ESI}    = Offset of UCB
;	CALL	xosdskGetDcb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset of disk DCB allocated (all other registers are
;		     preserved)

xosdskGetDcb:
	PUSHL	ESI
	PUSHL	EDX
	MOVL	EDI, dskdcbnum
	CMPL	EDI, dskdcblmt
	JAE	6$.S
	MOVL	EDI, ucb_dsp.B[ESI]	;Get value for dcb_dsp
	MOVL	ECX, #dcb_dkINDEX
	CALL	knlGetDymDcb##
	JC	4$.S
	POPL	ESI
	CALL	knlLinkDcb##
	INCL	dskdcbnum
	MOVL	EAX, dskdcbnum
	CMPL	EAX, dskdcbmax
	JB	2$.S
	MOVL	dskdcbmax, EAX
2$:	MOVL	dcb_sdisp.B[EDI], #dskdsp
	CLRL	EAX
	DECL	EAX
	MOVL	dcb_fnext.B[EDI], EAX
	POPL	ESI
	MOVL	[EDI], ESI		;Store UCB offset in the DCB
	MOVL	EAX, ucb_kcb.B[ESI]
	MOVL	EAX, kcb_type.B[EAX]	;And store controller type name
	MOVL	dcb_type.B[EDI], EAX
	MOVL	EAX, ucb_devchar.B[ESI]	;Store offset of device characteristics
	MOVL	dcb_devchar.B[EDI], EAX	;  table
	INCL	ucb_dcbcnt.B[ESI]	;Increment DCB count for the UCB
	RET

;Here if error allocating the DCB

4$:	POPL	EDX
	POPL	ESI
	STC
	RET

;Here if no disk DCB is available

6$:	POPL	EDX
	POPL	ESI
	MOVL	EAX, #ER_TMDVC		;Error = Too Many DVices open for class
	STC
	RET
.PAGE
	.SBTTL	Subroutines for QFNC_DEVCHAR function

;Subroutine to get 1 byte value from the UCB

xosdskGtU1Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	MOVZBL	EAX, [ESI+EBX]
	CLRL	EDX
	RET

;Subroutine to get 2 byte value from the UCB

xosdskGtU2Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	MOVZWL	EAX, [ESI+EBX]
	CLRL	EDX
	RET

;Subroutine to get 4 byte value from the UCB

xosdskGtU4Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
4$:	JE	knlNoUnit##
6$:	MOVL	EAX, [ESI+EBX]
	CLRL	EDX
	RET

;Subroutine to get 8 byte value from the UCB

xosdskGtU8Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	MOVL	EAX, [ESI+EBX]
	MOVL	EDX, 4.B[ESI+EBX]
	RET

;Subroutine to get 16 byte value from the UCB

xosdskGtU16Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	LEAL	EAX, [ESI+EBX]
	RET

;Subroutine to get string value from the UCB

xosdskGtUStr:
	CMPL	[EDI], #0.B
	JE	4$.S
	ADDL	EDX, [EDI]
	JMP	knlGetSysStr##
	
;Subroutine to get 1 byte value from the KCB

xosdskGtK1Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	MOVL	ESI, ucb_kcb.B[ESI]
	MOVZBL	EAX, [ESI+EBX]
	CLRL	EDX
	RET

;Subroutine to get 4 byte value from the KCB

xosdskGtK4Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	MOVL	ESI, ucb_kcb.B[ESI]
	JMP	6$.S

xosdskGtUxStr:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	ADDL	EDX, ucb_ext.B[ESI]
	JMP	knlGetSysStr##
	
;Here to get the value of the UNITTYPE characteristic

xosdskUnitType:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	MOVZBL	EAX, ucb_unittype.B[ESI]
	MOVL	EAX, CS:unittypetbl[EAX*4]
	CLRL	EDX
	RET

;Here to get the value of the UNITDESP characteristic

xosdskUnitDesp:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$.S
	MOVZBL	EAX, ucb_bits.B[ESI]
	SHRL	EAX, #6
	MOVL	EAX, CS:unitdesptbl[EAX*4]
	CLRL	EDX
	RET

;Here to get the value of the REMOVE characteristic

xosdskGetRemove:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$
	TESTB	ucb_dsp.B[ESI], #DS$REMOVE
	JMP	8$.S

;Here to get the value of a bit in ucb_bits

xosdskGetBits:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	4$
	TESTB	ucb_bits.B[ESI], BL	;Right
8$:	MOVL	EAX, #'No'		;Assume not set
	JE	10$.S			;Yes
	MOVL	EAX, #'Yes'		;No - its set
10$:	CLRL	EDX
	RET

	.MOD	4
unittypetbl:
	.LONG	'Hard'		;DT_HARD =  0 - Hard disk
	.LONG	'DD3'		;DT_DD3  =  1 - 3.5" double density floppy
	.LONG	'HD3'		;DT_HD3  =  2 - 3.5" high density floppy
	.LONG	'DD5'		;DT_DD5  =  3 - 5.25" double density floppy
	.LONG	'HD5'		;DT_HD5  =  4 - 5.25" high density floppy
	.LONG	'DD8'		;DT_DD8  =  5 - 8" double density floppy
	.LONG	'????'		;        =  6
	.LONG	'????'		;        =  7
	.LONG	'????'		;        =  8
	.LONG	'????'		;        =  9
	.LONG	'UHD3'		;        = 10
	.LONG	'????'		;        = 11
	.LONG	'????'		;        = 12
	.LONG	'????'		;        = 13
	.LONG	'????'		;        = 14
	.LONG	'Mem'		;DT_MEM  = 15 - Memory disk
	.LONG	'Cdrm'		;DT_CDRM = 16 - CD-ROM
	.LONG	'Worm'		;DT_WORM = 17 - WORM
	.LONG	'Optd'		;DT_OPTD = 18 - Optical disk

unitdesptbl:
	.LONG	'F'		;00
	.LONG	'F'		;40
	.LONG	'R'		;80
	.LONG	'RS'		;C0
.PAGE
;Here to set the value of the PROTECT characteristic

xosdskSetProtect:
	BTL	SS:pdaActPriv##, #PP%SYSADMIN ;Can we do this?
	JNC	knlPrivFail##		;No - fail!
					;Yes - fall into dskSetBits

;Here to set the value of a characteristic which sets or clears a bit in
;  ucb_bits

xosdskSetBits:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	6$.S
	CALL	knlGetYesNo##		;See what he said
	JC	4$.S
	JE	2$.S
	NOTB	BL			;He said "NO"
	ANDB	ucb_bits.B[ESI], BL
	RET

2$:	ORB	ucb_bits.B[ESI], BL	;He said "YES"
4$:	RET

;Here to set the value of a characteristic which has a 1 byte value in the
;  UCB

xosdskStU1Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	6$.S
	MOVB	[ESI+EBX], AL
	RET

;Here to set the value of a characteristic which has a 2 byte value in the
;  UCB

xosdskStU2Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
6$:	JE	knlNoUnit##
	MOVW	[ESI+EBX], AX
	RET

;Here to set the value of a characteristic which has a 4 byte value in the
;  UCB

xosdskStU4Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	6$.S
8$:	MOVL	[ESI+EBX], EAX
	RET

;Here to set the value of a characteristic which has an 8 byte value in the
;  UCB

xosdskStU8Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	6$.S
10$:	MOVL	4.B[ESI+EBX], EDX
	JMP	8$.S

;Here to set the value of a characteristic which has a 4 byte value in the
;  KCB

xosdskStK4Byte:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	6$.S
	MOVL	ESI, ucb_kcb.B[ESI]
	JMP	8$.S

;Here to set the value of the WTMAX characteristic

xosdskSetWTMax:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	6$.S
	ORL	EAX, EAX		;Is it 0?
	JNE	14$.S			;No
	INCL	EAX			;Yes - make it 1
14$:	CMPL	ucb_dthlimit[ESI], #0.B ;Do we have a limit?
	JE	16$.S			;No
	CMPL	EAX, ucb_dthlimit[ESI]	;Yes - is the value too big?
	JB	16$.S			;No
	MOVL	EAX, ucb_dthlimit[ESI]	;Yes - use the limit value
16$:	MOVL	ucb_wtmax[ESI], EAX	;Store new value
	CLC
	RET

;Here to set the value of the RAMAX characteristic

xosdskSetRAMax:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	6$.S
	CMPL	ucb_dthlimit[ESI], #0.B ;Do we have a limit?
	JE	18$.S			;No
	CMPL	EAX, ucb_dthlimit[ESI]	;Yes - is the value too big?
	JB	18$.S			;No
	MOVL	EAX, ucb_dthlimit[ESI]	;Yes - use the limit value
18$:	MOVL	ucb_ramax[ESI], EAX	;Store new value
	CLC
	RET
.PAGE
;Here to get the value of the ROOTPROT characteristic

xosdskGtRtProt:
	MOVL	EAX, #dd_gtrtprot
	JMP	4$.S

;Here to set the value of the ROOTPROT characteristic

xosdskStRtProt:
	MOVL	EAX, #dd_strtprot
4$:	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	knlNoUnit##
	ADDL	EAX, dcb_sdisp.B[EDI]
	JMPIL	CS:[EAX]
.PAGE
	.SBTTL	xosdskSetDosName - Set value of the DOSNAME characteristic

;Here to set the value of the DOSNAME characteristic - This characteristic
;  specifies the DOS drive letter for the drive or partition.  Setting this
;  value for a partition also changes the value of the corresponding DOSNAMEn
;  characteristic for the base physical unit.

xosdskSetDosName:
	TESTL	EAX, #0FFFFFF00h	;Have a single letter?
	JNE	knlBadCharV##		;No - fail
	MOVL	ESI, [EDI]		;Yes - get offset of UCB
	TESTL	ESI, ESI
	JE	knlNoUnit##
	CMPB	ucb_partnx.B[ESI], #0	;Is this a base physical unit?
	JNE	6$.S			;No
4$:	MOVL	ucb_dosname.B[ESI], EAX	;Yes - just store the drive letter
	RET

;Here for a partition.  In this case its harder, since we have to change the
;  corresponding DOSNAMEn characteristic for the base physical unit.

6$:	PUSHL	EAX
	MOVZBL	EAX, ucb_sunit[ESI]	;Get secondary unit number
	MOVL	ECX, ucb_baseucb.B[ESI]	;Get offset of base UCB
	MOVL	EDX, EAX		;Construct characteristic name
	SHLL	EDX, #24t
	ADDL	EDX, #'AME0'
	MOVL	EBX, #'DOSN'
	CALL	finddosnm		;Set up the DOSNAMEn characteristic
	JC	10$.S
	POPL	EAX
	LEAL	EBX, dct_dosnmname.B[ESI]
	CALL	setdosnm
	CALL	donedosnm
	CLC
	RET

;Here if error

10$:	POPL	ECX
	RET
.PAGE
	.SBTTL	xosdskGetHdDosNm - Get head routine for DOSNAME* device characteristics

;Get head routine for DOSNAME* device characteristics
;	CALL	xosdskGetHdDosNm
;	Z:set = No blocks
;	Z:clr = Have at least one block
;	  c{ESI} = Offset of first block

xosdskGetHdDosNm:
	MOVL	ESI, [EDI]		;Get offset of UCB
	MOVL	ESI, ucb_dosnmdct[ESI]	;Get offset of first block
	TESTL	ESI, ESI
	RET

	.SBTTL	xosdskFindDosNm - Find element routine for DOSNAME* device characteristics

;Find element routine for DOSNAME* device characteristics.  If the
;  characteristic name is of the form DOSNAMEn and is not found, an entry
;  is created with a null value.
;	c{EBX,EDX} = Characteristic name
;	c{EDI}     = Offset of DCB
;	CALL	xosdskFindDosNm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:clr = No match
;	  Z:set = Match found
;	    c{ESI} = Offset of block

xosdskFindDosNm:
	MOVL	EAX, [EDI]		;Get offset of UCB
	ORL	EAX, EAX		;Just to be safe!
	JE	6$.S
	CMPB	ucb_partnx.B[EAX], #0	;Is this a physical unit?
	JNE	6$.S			;No - say bad characteristic name
	CMPL	EBX, #'DOSN'		;Yes - does it start with "DOSNAME"?
	JNE	6$.S			;No
	MOVL	EAX, EDX		;Maybe
	ANDL	EAX, #0FFFFFF
	CMPL	EAX, #'AME'
	JNE	6$.S			;No


	MOVL	EAX, EDX
	SHRL	EAX, #24t
	CMPB	AL, #'1'		;Is last character a digit?
	JB	6$.S			;No
	CMPB	AL, #'9'		;Maybe
	JA	6$.S			;No
	ANDL	EAX, #0Fh.B		;Yes - get value of digit
	MOVL	ECX, [EDI]
finddosnm:
	PUSHL	EBX
	PUSHL	EDX
	ADDL	ECX, #ucb_dosnmdct
2$:	MOVL	ESI, [ECX]
	TESTL	ESI, ESI
	JE	8$.S
	CMPL	dct_dosnmpart.B[ESI], EAX ;This partition?
	JE	10$.S			;Yes - found it
	JA	8$.S			;If past where it goes
	LEAL	ECX, dct_lnknext.B[ESI]	;Advance to next block
	JMP	2$.S

;Here if name does not match any of our blocks

6$:	TESTL	ESP, ESP		;Clear C and Z
	RET

;Here if need to insert a new block

8$:	CALL	knlGetQel##		;Get a queue element
	JC	10$.S			;If error
	MOVL	dct_dosnmpart.B[ESI], EAX ;Store partition (secondary unit)
					  ;  number
	MOVL	dct_name+0.B[ESI], EBX	;Store name
	MOVL	dct_name+4.B[ESI], EDX
	MOVB	[ESI], #REP_TEXT
	MOVB	dct_flags.B[ESI], #DCTF$LNKELMT
	MOVW	dct_length.B[ESI], #16t
	MOVL	dct_getsub.B[ESI], #knlDcGetLong##
	MOVL	dct_setsub.B[ESI], #setdosnm
	MOVL	dct_lnkdone.B[ESI], #donedosnm
	MOVL	dct_infopnt.B[ESI], #msgdosnm
	LEAL	EBX, dct_dosnmname.B[ESI]
	MOVL	dct_data.B[ESI], EBX	;Store offset of the value
	CLRL	EAX
	MOVL	[EBX], EAX		;Clear the value
	MOVL	4t.B[EBX], EAX
	MOVL	8t.B[EBX], EAX
	MOVL	12t.B[EBX], EAX
	MOVL	EAX, [ECX]		;Link block into our list
	MOVL	[ECX], ESI
	MOVL	dct_lnknext.B[ESI], EAX
	MOVL	dct_dosnmprev.B[ESI], ECX
	TESTL	EAX, EAX		;Have a next block?
	JE	10$.S			;No
	LEAL	EDX, dct_lnknext.B[ESI]
	MOVL	dct_dosnmprev.B[EAX], EDX
	CLRL	EAX			;Set Z
10$:	POPL	EDX
	POPL	EBX
	RET
.PAGE
;Subroutine called when done using an element block.  If the element has a
;  null value, the block is discarded, otherwise nothing is done here.
;	c{ESI} = Offset of block
;	CALL	donedosnm
;  FS and EDX are preserved

donedosnm:
	CMPB	dct_dosnmname.B[ESI], #0 ;Have a null value?
	JNE	12$.S			;No - nothing needed here
	MOVL	EBX, dct_dosnmprev.B[ESI] ;Yes - unlink this block
	MOVL	EAX, dct_lnknext.B[ESI]
	MOVL	[EBX], EAX
	TESTL	EAX, EAX
	JE	4$.S
	MOVL	dct_dosnmprev.B[EAX], EBX
4$:	JMP	knlGiveQel##		;Give up the memory block

	.SBTTL	setdosnm - Set value of a DOSNAME* device characteristic

;Here to set the value of a DOSNAME* device characteristic
;	c{EAX} = New value
;	c{EBX} = Offset of value
;	c{ESI} = Offset of device characterists block
;	c{EDI} = Offset of DCB
;	CALL	setdosnm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setdosnm:
	TESTL	EAX, #0FFFFFF00h	;Have more than 1 letter?
	JNE	knlBadCharV##
	MOVL	[EBX], EAX
	MOVB	CH, dct_dosnmpart.B[ESI] ;Get secondary unit number
	MOVL	EDX, [EDI]		;Get offset of UCB
	MOVB	CL, ucb_punit[EDX]	;Get primary unit number
6$:	ORL	EDX, EDX
	JE	12$.S			;If no more
	CMPB	ucb_punit[EDX], CL	;Same primary unit?
	JNE	10$.S			;No
	CMPB	ucb_sunit[EDX], CH	;Yes - desired secondary unit?
	JE	8$.S
	MOVL	EDX, [EDX]		;No - advance to next UCB
	JMP	6$.S			;Continue

8$:	MOVL	ucb_dosname.B[EDX], EAX	;Yes - store new DOS name
10$:	CLD
12$:	RET
.PAGE
	.SBTTL	xosdskForceDsk - Force physcial or raw disk IO

;Here to force physical or raw disk IO after already setup for file IO
;	c{SS:EDX} = Address of processed file specification
;	c{EDI}    = Offset of disk DCB

xosdskForceDsk:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	knlNoUnit##
	MOVL	dcb_sdisp.B[EDI], #dskdsp ;Change the dispatch address
	MOVL	EAX, ucb_dsp.B[ESI]
	ANDL	EAX, #DS$REMOVE.B
	ORL	EAX, #DS$PHYS|DS$NOABORT|DS$LCLDISK|DS$QIN|DS$QOUT
	MOVL	dcb_dsp.B[EDI], EAX	;And the device description bits
					;Fall into dskopen

	.SBTTL	dskopen - Open device

;Here for the open device entry
;	c{SS:EDX} = Address of processed file specification
;	c{EDI}    = Offset of disk DCB

;NOTE:  Several of the open option bits have a different meaning for a
;  raw/physical disk device than they have for a file structured device:
;	O$XWRITE -> Open disk unit for excluse access, fail if any other current
;		    access to the unit
;	O$XREAD  -> Open disk unit for excluse access, fail if currently open
;		    for exclusive access
;	O$FAILEX -> If O$XWRITE or O$XREAD set, do not allow any additional
;		    access until device is closed, ignored otherwise

dskopen::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	knlNoUnit##
	TESTB	ucb_sts3.B[ESI], #U3$XALL ;Is access disallowed?
	JNE	6$.S			;Yes - fail
	MOVL	EAX, SS:xffCmd##	;No - get open option bits
	TESTL	EAX, #O$PHYS|O$RAW	;Raw or physical mode access?
	JE	20$.S			;No - fail
	BTL	EAX, #O%XWRITE		;Yes - want completely exclusive access?
	JNC	4$.S			;No
	CMPL	ucb_dcbcnt.B[ESI], #1.B	;Yes - is device in use at all now?
	JA	6$.S			;Yes - fail
4$:	BTL	EAX, #O%XREAD		;Want simple exclusive access?
	JNC	8$.S			;No
	CMPL	ucb_xdcb.B[ESI], #0.B	;Yes - already exclusive?
6$:	JNE	knlRtnBusy##		;Yes - fail
8$:	TESTB	AL, #O$OUT		;Does he want to do output?
	JE	10$.S			;No - go on
	INCL	ucb_wrdcb[ESI]		;Yes - increment write count
10$:	TESTB	AL, #O$IN		;Does he want to do input?
	JE	14$.S			;No
	INCL	ucb_rddcb[ESI]		;Yes - increment read count
14$:	CMPL	dcb_opencnt.B[EDI], #1.B ;First open?
	JNE	16$.S			;No - nothing else needed here
	CLRL	EAX			;Yes
	MOVL	dcb_dkfpos.B[EDI], EAX	;Reset position
16$:	TESTL	SS:xffCmd##, #O$XWRITE|O$XREAD ;Want exclusive access?
	JE	18$.S			;No
	MOVL	ucb_xdcb.B[ESI], EDI	;Yes
	BTL	SS:xffCmd##, #O%FAILEX	;Want to disallow all others?
	JE	10$.S			;No
	ORB	ucb_sts3.B[ESI], #U3$XALL ;Yes
18$:	CLC
	RET				;Thats all

;Here if not physical or raw IO - return "not a file structured device" error

20$:	MOVL	EAX, #ER_NTFIL
	STC
	RET
.PAGE
	.SBTTL	dskinpblk - Queued input block

;Here for the sd_qinpblk entry - Input block
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	dskinpblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

dskinpblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoReadLock##		;Lock the buffer
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #dskinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here if error locking the buffer

2$:	TOFORK
	RET

;Here in extended fork context

dskinpblk1:
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	4$.S			;No
	MOVL	EBX, #dskioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	knlQAdrErr0##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	10$.S
4$:	MOVL	ECX, SS:xffCount##	;Get count
	JREGZ	ECX, 6$
	IFFAULT	knlQAdrErr0##
	LESL	EBX, SS:xffBuffer1##	;Get address of buffer
	MOVL	ESI, #dskdadr		;Get offset of disk address calculate
					;  subroutine
	CALL	xosdskRead		;Do the transfer
	JC	10$.S			;If error
	CLRL	EAX
6$:	MOVL	EBX, #QSTS$DONE
	RET

10$:	CLRL	ECX			;Say nothing output for now!
	JMP	6$.S
.PAGE
	.SBTTL	dskoutstr - Queued output null terminated string

;Here for the sd_qoutblk entry - output null terminated string
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	dskoutstr
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

dskoutstr:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoStringLock##	;Lock the string
	JNC	4$.S			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	dskoutblk - Queued output block

;Here for the sd_qoutblk entry - output block
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	dskoutblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

dskoutblk:
	CALL	knlIoQabLock##		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock##	;Lock the buffer
	JC	2$.S			;If error
4$:	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #dskoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context	

;Here in extended fork context

dskoutblk1:
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	6$.S			;No
	MOVL	EBX, #dskioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	knlQAdrErr0#
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	10$.S
6$:	MOVL	ECX, SS:xffCount##	;Get count
	JREGZ	ECX, 8$
	IFFAULT	knlQAdrErr0##
	LESL	EBX, SS:xffBuffer1##	;Get address of buffer
	MOVL	ESI, #dskdadr		;Get offset of disk address calculate
					;  subroutine
	CALL	diskwrite		;Do the transfer
	JC	10$.S			;If error
	CLRL	EAX
8$:	MOVL	EBX, #QSTS$DONE
	RET

10$:	CLRL	ECX
	JMP	8$.S
.PAGE
	.SBTTL	xosdskCDcb - Clear DCB

;Here for the clear DCB entry
;	c{EDI} = Offset of DCB

xosdskCDcb:
	MOVL	ESI, [EDI]		;Get offset of UCB
	TESTL	ESI, ESI		;Do we have one?
	JE	4$.S			;No
	CMPL	ucb_dcbcnt.B[ESI], #1.B	;Is this the only DCB for the UCB?
	JL	6$.S			;If bad count
	JG	4$.S			;If disk is still in use by others
	TESTB	ucb_sts1.B[ESI], #U1$MOUNT ;Is the disk mounted now?
	JE	4$.S			;No
	TESTB	ucb_sts2.B[ESI], #U2$FRCMOUNT ;Yes - was the mount forced?
	JNE	4$.S			;Yes
	CMPB	ucb_fstype.B[ESI], #0	;No - does it contain a file system?
	JG	4$.S			;Yes
	CMPB	ucb_numpartn.B[ESI], #0	;No - does it contain partitions?
	JNE	4$.S			;Yes
	CALL	xosdskUnmount		;No - unmount it now
4$:	DECL	ucb_dcbcnt.B[ESI]
	DECL	dskdcbnum
	MOVL	ECX, #dcb_dkINDEX	;Give up the DCB
	JMP	knlGiveDymDcb##

6$:	CRASH	BDUC			;[BaD UCB Count]
.PAGE
	.SBTTL	xosdskUnitName - Disk IO parameter for open - get unit name

;Here for the IOPAR_DKUNITNAME IO parameter for open - get unit name

	DPARMHDR  GET, STR
xosdskUnitName:
	PUSHL	#ucb_name.B
	JMP	20$.S

	.SBTTL	xosdskDosName - Disk IO parameter for open - get or set DOS name

;Here for the IOPAR_DKDOSNAME IO parameter for open - get or set DOS name

	DPARMHDR  BOTH, STR
xosdskDosName:
	PUSHL	#ucb_dosname.B
	JMP	4$.S

	.SBTTL	xosdskVolName - Disk IO parameter for open - get or set volume name

;Here for the IOPAR_DKVOLNAME IO parameter for open - get or set volume name

	DPARMHDR  BOTH, STR
xosdskVolName:
	PUSHL	#ucb_volname.B
4$:	TESTB	AH, #PAR$SET		;Want to change name?
	JE	20$.S			;No
	PUSHL	EAX
	PUSHL	ECX
	PUSHL	ES
	PUSHL	EBX
	PUSHL	#0.B
	PUSHL	#0.B
	PUSHL	EDI
	PUSHL	ESI
	MOVL	ESI, EBX
	PUSHL	ES
	POPL	GS
	LEAL	EDI, 8.B[ESP]
	PUSHL	SS
	POPL	ES
	MOVL	EBX, #8
8$:	DECL	ECX			;More bytes?
	JS	16$.S			;No
	IFFAULT	10$
	LODSB	GS:[ESI]		;Maybe - get name byte
	CMPB	AL, #0
	JE	16$.S
	DECL	EBX			;Room for more?
	JS	12$.S			;No - fail
	STOSB	[EDI]			;Yes - store byte
	JMP	8$.S			;Continue

	FAULTHDR
10$:	MOVL	EAX, #ER_ADRER
	JMP	14$.S

12$:	MOVL	EAX, #ER_PARMV
14$:	POPL	ESI
	POPL	EDI
	ADDL	ESP, #28t.B
	STC
	RET

;Here at end of given name

16$:	POPL	ESI
	POPL	EDI
	MOVL	ECX, 8.B[ESP]
	POPL	[ESI+ECX]		;Store new name
	POPL	4.B[ESI+ECX]	
	POPL	EBX
	POPL	ES
	POPL	ECX
	POPL	EAX
20$:	TESTB	AH, #PAR$GET		;Want to get the value?
	JE	30$.S			;No
	PUSHL	ESI
	PUSHL	EDI
	ADDL	ESI, 8.B[ESP]		;Yes - get offset of name to return
	MOVL	EDI, EBX
	MOVL	EBX, #8
22$:	DECL	ECX			;Room for more?
	JS	34$.S			;No - fail
	LODSB	[ESI]			;Get byte
	CMPB	AL, #0
	JE	24$.S
	IFFAULT	32$
	STOSB	[EDI]			;Give it to him
	DECL	EBX			;More there?
	JNE	22$.S			;Yes - continue
24$:	DECL	ECX			;Need a null?
	JS	26$.S			;No
	MOVB	AL, #0			;Yes
	IFFAULT	32$
	STOSB	[EDI]
26$:	MOVL	EAX, #8			;Calculate length of name
	SUBL	EAX, EBX
	IFFAULT	32$
	MOVW	FS:[EDX], AX		;Give him the length
	POPL	ESI
	POPL	EDI
30$:	POPL	EAX			;Fix up the stack
	RET				;Finished

	FAULTHDR
32$:	MOVL	EAX, #ER_ADRER
	JMP	14$.S

34$:	MOVL	EAX, #ER_PARMS
36$:	POPL	ESI
	POPL	EDI
	POPL	ECX
	STC
ret006:	RET
.PAGE
;Here for the IOPAR_ABSPOS, IOPAR_RELPOS, or IOPAR_EOFPOS parameter for
;  open - Position for IO

	DPARMHDR  BOTH, DECV
xosdskOpnPioPos:
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	ret006.S		;No
	MOVL	EAX, dcb_dkfpos.B[EDI]	;Yes - get value
	JMP	knlAddParm4##		;Give it to the user
.PAGE
	.SBTTL	dskiopabspos - Disk IO parameter - set or get absolute position

;Here for the IOPAR_ABSPOS parameter for a disk transfer - set or get absolute
;  IO position

	DPARMHDR  BOTH, DECV
dskiopabspos::
	TESTB	AH, #PAR$SET		;Want to change value?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get value for position
	JC	6$.S
2$:	MOVL	dcb_dkfpos.B[EDI], EAX	;Store value
	POPL	EAX
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No
	MOVL	EAX, dcb_dkfpos.B[EDI]	;Yes - get value
	JMP	knlStrParm4##		;Give it to him

6$:	POPL	ECX			;Fix up the stack
8$:	RET

	.SBTTL	dskioprelpos - Disk IO parameter - set or get relative position

;Here for the IOPAR_RELPOS parameter for a disk transfer - set or get relative
;  IO position

	DPARMHDR  BOTH, DECV
dskioprelpos::
	TESTB	AH, #PAR$SET		;Want to change value?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm##		;Get value for position
	JC	6$.S
	ADDL	EAX, dcb_dkfpos.B[EDI]	;Make it relative
	JNO	4$.S
	POPL	EAX			;Report value error if overflow
	JMP	knlBadParmV##
.PAGE
;Here for the IOPAR_FSTYPE parameter - File system type

	DPARMHDR  GET, DECV
dskiopfstype::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	8$.S
	MOVZBL	EAX, ucb_fstype.B[ESI]
	JMP	knlStrParm4##

;Here for the IOPAR_SECTSIZE parameter - Sector size

	DPARMHDR  GET, DECV
dskiopsectsize::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	8$.S
	MOVL	EAX, ucb_csecsz.B[ESI]
	JMP	knlStrParm4##

;Here for the IOPAR_CLSSIZE parameter - Cluster size

	DPARMHDR  GET, DECV
dskiopclssize::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
8$:	JE	knlNoUnit##
	MOVL	EAX, ucb_clussize.B[ESI]
	JMP	knlStrParm4##

;Here for the IOPAR_TTLSPACE parameter - Total space

	DPARMHDR  GET, DECV
dskiopttlspace::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	8$.S
	MOVL	EAX, ucb_total.B[ESI]
	JMP	knlStrParm4##

;Here for the IOPAR_AVLSPACE parameter  - Available space

	DPARMHDR  GET, DECV
dskiopavlspace::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	8$.S
	MOVL	EAX, ucb_avail.B[ESI]
	JMP	knlStrParm4##

;Here for the IOPAR_NUMHEAD parameter - Number of heads

	DPARMHDR  GET, DECV
dskiopnumhead::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	8$.S
	MOVL	EAX, ucb_cheads.B[ESI]
	JMP	knlStrParm4##

;Here for the IOPAR_NUMSECT parameter - Number of sectors

	DPARMHDR  GET, DECV
dskiopnumsect::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	8$.S
	MOVL	EAX, ucb_csects.B[ESI]
	JMP	knlStrParm4##

;Here for the IOPAR_NUMCYLN parameter - Number of cylinders

	DPARMHDR  GET, DECV
dskiopnumcyln::
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	8$.S
	MOVL	EAX, ucb_ccylns.B[ESI]
	JMP	knlStrParm4##

;Here for the IOPAR_DSKBLOCK parameter for getting the number of the last disk
;  block accessed.

	DPARMHDR  GET, DECV
dskiopdskblk:
	CMPL	dcb_dkfilepnt.B[EDI], #0.B ;Have a file open?
	JE	knlBadParmI##		;No - say bad parameter
	TESTB	AH, #PAR$GET		;Yes - want to get the value?
	JE	12$.S			;No
	MOVL	EAX, dcb_dkdblk.B[EDI]	;Get current phycial disk block
	DECL	EAX
	JMP	knlStrParm4##

12$:	RET
.PAGE
	.SBTTL	dskspecial - Special device function for disks

;Here for the QFNC_special queued IO function for disks - Do special device
;  functions
;  QAB fields used:
;	qab_option:	Low 8 bits contain sub-function, high 24 bits may be
;			  used to modify sub-function
;	qab_count:	May be used to pass single 32 bit argument value
;	qab_buffer1:	Pointer to argument buffer
;  Contents of qab_amount depends on function

dskspecial:
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #dskspec1
	JMP	knlXfQueue##		;Switch to extended fork context

dskspec1:
	MOVZBL	EAX, SS:xffOption##	;Get sub-function
	CMPL	EAX, #DSKSFMAX.B	;Legal sub-function?
	JAE	knlIFnDev#		;No
	MOVL	ESI, [EDI]		;Yes - get offset of our UCB
	TESTL	ESI, ESI
	JE	knlNoUnit##
	JMPIL	CS:dsksfdsp[EAX*4]	;Dispatch on the subfunction

;Dispatch table for special device functions for disks

	.MOD	4
dsksfdsp:
	.LONG	knlIFnDev##	;	     = 0. - Illegal
	.LONG	knlIFnDev##	;DS_SETDS    = 1. - Set disk state
	.LONG	dsfdsmnt	;DS_DISMOUNT = 2. - Dismount disk
	.LONG	dsfmount	;DS_MOUNT    = 3. - Mount disk
	.LONG	dsfformat	;DS_FORMAT   = 4. - Format disk
DSKSFMAX=!{$-dsksfdsp}/4

	CODE
.PAGE
	.SBTTL	DS_DISMOUNT - Special device function: Dismount disk

;Here for the DS_DISMOUNT special device function - Dismount disk
;  Value returned is 1 if disk was previously mounted and 0 if it was not
;    mounted

dsfdsmnt:				   ;Is device open for raw or physical
	TESTL	SS:xffCmd##, #O$RAW|O$PHYS ;  IO?
1$:	JE	knlIFnDev##		;No - say illegal function
2$:	CALL	xosdskFinOut		;Finish up any pending output
	TESTB	ucb_sts1.B[ESI], #U1$MOUNT ;Yes - is disk mounted now?
	JE	6$.S			;No - nothing needed here
	CALL	xosdskGetDiskRes
	JC	6$.S
	MOVL	EAX, #ER_DKRMV		;Indicate disk removed error
	CALL	dskidle			;Make the disk idle
	CALLI	ucb_unmount.B[ESI]	;Unmount the disk
	CALL	xosdskGiveDiskRes
4$:	MOVL	ECX, #1			;Return 1
	JMP	8$.S

;Here if disk was not mounted - return 0

6$:	CLRL	ECX
8$:	CLRL	EAX
10$:	MOVL	EBX, #QSTS$DONE
	RET

	.SBTTL	DS_MOUNT - Special device function: Mount disk

;Here for the DS_MOUNT special device function - Mount disk

dsfmount:
	TESTL	SS:xffCmd##, #O$RAW|O$PHYS ;  IO?
	JE	1$.S			;No - say illegal function
	CALL	xosdskFinOut		;Finish up any pending output
	TESTB	ucb_sts1.B[ESI], #U1$MOUNT ;Yes - is disk mounted now?
	JNE	6$.S			;Yes - nothing needed here
	CALL	xosdskMount		;No - mount the disk now
	JNC	4$.S			;OK - return 1
	CLRL	ECX			;Error
	JMP	10$.S
.PAGE
	.SBTTL	DS_FORMAT - Special device function: Format disk

;Here for the DS_FORMAT special device function - Format disk

dsfformat:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE
	.SBTTL	xosdskUnmount - Unmount non-file structured disk

;Here for the unmount disk entry - this routine removes all of knowledge of
;  a disk from the system without attempting to read or write to the disk - it
;  is normally called when it is determined that a removable disk has been
;  changed - all buffers for the disk are unhashed - if they are not in use,
;  they are given up, if they are in use, they are marked with a disk changed
;  (ER_MDCHG) error
;	c{EAX} = Error code
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of UCB
;	CALL	xosdskUnmount
;  c{EAX} is preserved

xosdskUnmount:
	PUSHL	EAX
	ANDB	ucb_sts1.B[ESI], #~U1$MOUNT ;Indicate not mounted
	ANDB	ucb_sts2.B[ESI], #~U2$REQUNMNT
	CLRL	EDX
	MOVL	ucb_unmount.B[ESI], #xosdskUnmount
	CMPL	ucb_baseucb.B[ESI], #0.B ;Is this a partition?
	JNE	1$.S			;Yes
	MOVB	ucb_fstype.B[ESI], DL	;No - indicate unknown disk type
1$:	MOVL	ucb_clussize.B[ESI], EDX ;Clear out some file structure data
	MOVL	ucb_total.B[ESI], EDX
	MOVL	ucb_avail.B[ESI], EDX
	MOVL	ucb_fsname+0[ESI], #'NotM'
	MOVL	ucb_fsname+4[ESI], #'ntd'
	MOVL	ucb_sdisp.B[ESI], #dskdsp
	MOVL	EAX, ucb_dsp.B[ESI]
	ANDL	EAX, #DS$REMOVE.B
	ORL	EAX, #DS$PHYS|DS$NOABORT|DS$LCLDISK|DS$QIN|DS$QOUT
	MOVL	ucb_dsp.B[ESI], EAX
	CALL	xosdskFlush#		;Clear out the hash table
	ANDB	ucb_sts1.B[ESI], #{U1$MOTON|U1$HFTRK} ;Clear most status bits
	ORB	ucb_sts2.B[ESI], #U2$DCHG ;Indicate disk changed
	MOVL	EBX, ucb_kcb.B[ESI]
	MOVL	EAX, kcb_disp.B[EBX]	;Clear driver parameters if necessary
	CALLI	CS:ks_unmount.B[EAX]
	ORL	ESI, ESI		;Do we still have a UCB (we will not
					;  have one here if we just unmonunt a
					;  partition on a removable drive)?
	JE	10$.S			;No - finished here
	MOVL	EAX, ucb_iheads.B[ESI]	;Yes - set number of heads, sectors, and
	MOVL	ucb_cheads.B[ESI], EAX	;  cylinders and sector size to the
	MOVL	EAX, ucb_isects.B[ESI]	;  default values
	MOVL	ucb_csects.B[ESI], EAX
	MOVL	EAX, ucb_icylns.B[ESI]
	MOVL	ucb_ccylns.B[ESI], EAX
	MOVL	EAX, ucb_isecsz.B[ESI]
	MOVL	ucb_csecsz.B[ESI], EAX
	PUSHL	EDI
	CLRL	EAX			;Get a 0 for use below
	MOVL	EDI, xosdskCcb+ccb_dcbhead ;Scan all disk DCBs
	TESTL	EDI, EDI
	JE	8$.S
4$:	CMPL	[EDI], ESI		;Is this one for this unit?
	JNE	6$.S			;No
	ORB	dcb_sts2.B[EDI], #D2$DCHG ;Yes - indicate disk has been changed
	MOVL	[EDI], EAX		;Clear link to the UCB
6$:	MOVL	EDI, dcb_next.B[EDI]	;Advance to next disk DCB
	TESTL	EDI, EDI		;Have another?
	JNE	4$.S			;Yes - continue
8$:	MOVL	ucb_dcbcnt.B[ESI], EAX	;No - finished - clear the UCB's DCB
	POPL	EDI			;  count
	CMPL	[EDI], EAX		;Was this our unit?
	JNE	10$.S			;No
	MOVL	[EDI], ESI		;Yes - re-establish our link to the UCB
	INCL	ucb_dcbcnt.B[ESI]
10$:	POPL	EAX
	RET
.PAGE
	.SBTTL	dskclose - Close disk

dskclose:
	CALL	knlIoClsLock##		;Lock the QAB
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #dskclose1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

dskclose1:
	PUSHL	#0.B
	CMPL	SS:xffParm##, #0.B	;Have any device parameters?
	JE	2$.S			;No
	MOVL	EBX, #dskioparms	;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	6$
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JNC	2$.S
	MOVL	[ESP], EAX
2$:	CALL	dskclose2		;Do the rest of the close
	JNC	4$.S
	MOVL	[ESP], EAX
4$:	POPL	EAX
	JMP	knlXfCloseFin##

	FAULTHDR
6$:	MOVL	[ESP], #ER_ADRER
	JMP	2$.S

dskclose2:
	PUSHL	#0.B
	CALL	xosdskFinOut		;Make sure output is finished
	JNC	8$.S
	MOVL	[ESP], EAX
8$:	MOVL	ESI, [EDI]		;Get UCB offset
	TESTL	ESI, ESI
	JE	10$.S
	CMPL	ucb_xdcb.B[ESI], EDI	;Do we have it single access?
	JNE	10$.S			;No
	CLRL	EAX			;Yes
	MOVL	ucb_xdcb.B[ESI], EAX	;Not any more
	ANDB	ucb_sts3.B[ESI], #{~U3$XALL}&0FFh
10$:	POPL	EAX			;Get error code to return
	BTL	EAX, #31t
ret010:	RET
.PAGE
;Subroutine to finish pending output before closing file
;	c{EDI} = Offset of DCB
;	CALL	xosdskFinOut
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosdskFinOut:
	CMPL	dcb_dkpbfr.B[EDI], #0.B	;Have an output buffer pending?
	JE	ret010.S		;No
	MOVL	EBX, dcb_dkpbfr.B[EDI]	;Yes
	MOVL	dcb_dkpbfr.B[EDI], #0	;Output it now
	CALL	xosdskLockBufrW#
	TESTB	cb_sts.B[EBX], #CB$FULL	;Is the buffer still full?
	JE	4$.S			;No - must have had a write error!
	CALL	xosdskWriteBufr#
	JNC	xosdskRelsLkBufr#
	PUSHL	EAX
2$:	CALL	xosdskGiveLkBufr#
	POPL	EAX
	STC
	RET

;Here if pending buffer is now empty - the only way this can happen is if
;  someone else has tried to write the buffer and the write failed!

4$:	PUSHL	#ER_DEVER.B		;Report this as a device error
	JMP	2$.S
.PAGE
	.SBTTL	dskidle - Subroutine to make a disk unit idle

;Subroutine to make a disk unit idle - all queued transfer requests are
;  terminated with an error, if the controller is active with a request for
;  the unit, the unit is marked as "stopped" and the fork is suppended until
;  the request is complete
;	c{EAX} = Error code to use
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of UCB
;	CALL	dskidle

dskidle::
	PUSHL	EDI			;Save DCB offset
	PUSHL	EAX			;Save error code to use
	MOVL	EBX, ucb_kcb.B[ESI]	;Get offset of KCB
	LEAL	EDX, kcb_reqhead.B[EBX]	;Point to transfer reqeust head pointer
2$:	MOVL	EDI, [EDX]		;Get next transfer request
	TESTL	EDI, EDI
	JE	6$.S			;If no more
	CMPL	[EDI], ESI		;Is it for this unit?
	JNE	4$.S			;No
	MOVL	EAX, dcb_dkreqnext.B[EDI] ;Yes - remove it from the list
	MOVL	[EDX], EAX
	MOVL	EAX, [ESP]		;Tell extended fork that IO is
	PUSHL	EDX			;  complete
	CALL	knlResumeOutput##
	POPL	EDX
	JMP	2$.S

4$:	LEAL	EDX, dcb_dkreqnext.B[EDI]
	JMP	2$.S

6$:	CMPL	kcb_reqhead.B[EBX], #0.B ;Is the list empty now?
	JNE	8$.S			;No
	CLRL	EAX			;Yes - clear tail pointer
	MOVL	kcb_reqtail.B[EBX], EAX
8$:	MOVL	EBX, ucb_kcb.B[ESI]
	MOVL	EAX, kcb_curdcb.B[EBX]	;Is the controller busy now?
	TESTL	EAX, EAX
	JE	10$.S			;No - finished here
	CMPL	[EAX], ESI		;Yes - for this unit?
	JNE	10$.S			;No - finished
	ORB	ucb_sts3.B[ESI], #U3$STOPPED ;Yes - indicate being stopped
	MOVW	ucb_stopxff.B[ESI], SS
	MOVL	EDI, 4.B[ESP]		;Restore DCB offset of we can wait
	CALL	knlXfWaitNTO##		;Wait until its finished
	ANDB	ucb_sts3.B[ESI], #~U3$STOPPED
	JMP	8$.S			;Loop back to make sure

;Here when finished

10$:	POPL	EAX			;Restore error code
	POPL	EDI			;Restore DCB offset
	RET
.PAGE
	.SBTTL	xosdskRead - Subroutine to read data from the disk

;Subroutine to read data from the disk
;	c{ECX}    = Number of bytes to read
;	c{ES:EBX} = Buffer address
;	c{EDI}    = Offset of DCB
;	c{ESI}    = Offset of subroutine to calculate disk address of next
;		      block to read
;	CALL	xosdskRead
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

;Define offsets in our stack frame

$$$=!0
FRM rd_bufr , 8t	;Address of data buffer
FRM rd_cda  , 4t	;Offset of subroutine to calculate disk block
FRM rd_done , 4t	;Total amount transfered
FRM rd_tamnt, 4t	;Amount to transfer
FRM rd_aamnt, 4t	;Amount available on disk
FRM rd_left , 4t	;Amount left
rd_SIZE=!$$$

xosdskRead:
	ENTER	rd_SIZE, 0		;Setup a stack frame
	MOVL	rd_tamnt.B[EBP], ECX	;Save amount wanted
	MOVL	rd_bufr+0.B[EBP], EBX	;Save buffer address
	MOVW	rd_bufr+4.B[EBP], ES
	MOVL	rd_cda.B[EBP], ESI	;Save offset of calculate disk address
	CLRL	EAX			;  subroutine
	MOVL	rd_done.B[EBP], EAX	;Initialize count of amount read
	MOVL	ESI, [EDI]		;Get offset of our UCB
	TESTL	ESI, ESI
	JE	knlNoUnitLv##
	BTL	SS:xffCmd##, #O%RAW	;Raw IO?
	JNC	rdnotraw.S		;No
	CALL	setupraw		;Yes - do common setup
	JC	4$.S			;If error
	MOVL	EAX, #kf_readraw	;Get function
	CALL	xosdskXfer		;Do the transfer
4$:	LEAVE
	RET
.PAGE
;Here if at end of file

2$:	MOVL	ECX, rd_done.B[EBP]	;Get amount transfered
	TESTL	ECX, ECX		;Did we get anything at all?
	JNE	4$.S			;Yes - return with it
	MOVL	EAX, #ER_EOF		;No - report EOF error
	STC
	LEAVE
	RET

4$:	CLRL	EAX
	LEAVE
	RET

;Here if not raw IO

rdnotraw:				;Call subroutine to calculate disk
	CALLI	rd_cda.B[EBP]		;  address
	JC	12$.S			;If error
	JE	2$.S			;If end of file
	MOVL	rd_aamnt.B[EBP], ECX	;Save amount available on disk
	CMPL	ECX, rd_tamnt.B[EBP]	;Is more available than we want?
	JBE	8$.S			;No
	MOVL	ECX, rd_tamnt.B[EBP]	;Yes - only take what we want
8$:	MOVL	rd_left.B[EBP], ECX	;Store amount for this time
10$:	MOVL	EDX, rd_aamnt.B[EBP]
	CALL	xosdskFindDBufr#	;Find block
12$:	JC	36$			;If error
	MOVL	ECX, #200h		;Get amount to transfer from this block
	MOVL	EDX, dcb_dkfpos.B[EDI]
	ANDL	EDX, #1FFh
	SUBL	ECX, EDX
	CMPL	ECX, rd_left.B[EBP]	;More than we have or want?
	JBE	14$.S			;No
	MOVL	ECX, rd_left.B[EBP]	;Yes - just use what we have or want
14$:	ADDL	dcb_dkfpos.B[EDI], ECX	;Bump position
	SUBL	rd_tamnt.B[EBP], ECX	;Reduce amount to go
	SUBL	rd_left.B[EBP], ECX
	SUBL	rd_aamnt.B[EBP], ECX
	ADDL	rd_done.B[EBP], ECX	;And increase amount done
	INCL	dcb_dkdblk.B[EDI]	;Bump disk block
	PUSHL	EDI			;Yes
	PUSHL	ESI
	LEAL	ESI, [EBX+EDX]		;Point to start of data
	LESL	EDI, rd_bufr.B[EBP]
	ADDL	rd_bufr.B[EBP], ECX
	CLD
	CMPL	ECX, #4.B		;Have fewer than 4 bytes to copy?
	JB	16$.S			;Yes
	MOVL	EAX, ECX		;No - first copy enough bytes to long
	MOVL	ECX, EDI		;  align the destination
	NEGL	ECX
	ANDL	ECX, #03.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], [ESI]
	MOVL	ECX, EAX		;Next copy as many longs as we can
	SHRL	ECX, #2
	RMOVSL	[EDI], [ESI]
	MOVL	ECX, EAX		;Finally, copy any bytes left over
	ANDL	ECX, #03.B
16$:	RMOVSB	[EDI], [ESI]
	POPL	ESI
	POPL	EDI
	CMPW	cb_errcode.B[EBX], #0.B	;Error on transfer?
	JE	32$.S			;No - go on
	MOVXWL	EAX, cb_errcode.B[EBX]	;Yes - get error code
28$:	PUSHL	EAX
	CALL	xosdskGiveLkBufr#	;Give up the buffer
	POPL	EAX
	STC				;Indicate error
	JMP	36$.S

;Here after good read

32$:	CALL	xosdskRelsLkBufr#	;Give up the buffer
	CMPL	rd_left.B[EBP], #0.B	;More available here?
	JNE	10$			;Yes - continue
	CMPL	rd_tamnt.B[EBP], #0.B	;No - do we want more?
	JE	34$.S			;No - finished
	TESTB	SS:xffStatus1##, #XF1$ABORT ;Has this operation been aborted?
	JE	rdnotraw		;No - go read another part
writab:	MOVL	EAX, #ER_ABORT		;Yes - get error code
	JMP	writde.S		;Fail

;Here when finished

34$:	CLRL	EAX
36$:	MOVL	ECX, rd_done.B[EBP]	;Finished - get count in right register
	LEAVE
	RET				;Stop here
.PAGE
	.SBTTL	diskwrite - Subroutine to write data from the disk

;Subroutine to write data from the disk
;	c{ECX}    = Number of bytes to write
;	c{ES:EBX} = Buffer address
;	c{EDI}    = Offset of DCB
;	c{ESI}    = Offset of subroutine to calculate disk address of next
;		      block to write
;	CALL	diskwrite
;	c{ECX} = Number of bytes written
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

$$$=!0
FRM wr_bufr  , 8t	;Data buffer address
FRM wr_cda   , 4t	;Offset of subroutine to calculate disk block
FRM wr_done  , 4t	;Amount transfered
FRM wr_tamnt , 4t	;Amount to transfer
FRM wr_aamnt , 4t	;Amount available at current position in file
FRM wr_xamnt , 4t	;Amount to extend file
FRM wr_begin , 4t	;Disk block number for first buffer in list
FRM wr_first , 4t	;Selector of first buffer in list
FRM wr_prev  , 8t	;Pointer to list pointer
FRM wr_blocks, 4t	;Total number of blocks to output each time
FRM wr_actual, 4t	;Actual amount output each time (does not include parts
wr_SIZE=!$$$		;  of first or last block not filled by user)

diskwrite::
	MOVL	EAX, [EDI]		;Get UCB offset
	TESTL	EAX, EAX
	JE	knlNoUnit##		;If no UCB
	TESTB	ucb_sts1.B[EAX], #U1$WPROT ;Is the disk write protected?
	JNE	knlWPrErr##		;Yes - fail
	ENTER	wr_SIZE, 0		;No - setup a stack frame
	MOVL	wr_tamnt.B[EBP], ECX	;Save amount wanted
	MOVL	wr_bufr+0.B[EBP], EBX	;Save buffer address
	MOVL	wr_bufr+4.B[EBP], ES
	MOVL	wr_cda.B[EBP], ESI	;Save offset of calculate disk address
	CLRL	EAX			;  subroutine
	MOVL	wr_done.B[EBP], EAX	;Initialize count of amount written
	MOVL	ESI, [EDI]		;Get offset of our UCB
	TESTL	ESI, ESI
	JE	knlNoUnitLv##
	BTL	SS:xffCmd##, #O%RAW	;Raw IO?
	JNC	writd2.S		;No
	CALL	setupraw		;Yes - do common setup
	JC	2$.S			;If error
	MOVB	ES:[EBX], AL		;Also make sure can write to buffer
	IFFAULT	knlRtnAdrErLv##
	MOVL	EAX, #kf_writraw	;Get function
	CALL	xosdskXfer		;Do the transfer
2$:	LEAVE
	RET
.PAGE
;Here if error while reading block for write

writdew:POPL	EBX
	POPL	ECX
	JMP	writde.S

;Here if finished

writdn:	MOVL	EAX, wr_done.B[EBP]
writde:	MOVL	ECX, wr_done.B[EBP]	;Get amount written
	LEAVE
	RET

;Here when ready to start write to file

writd2:	CMPL	wr_tamnt.B[EBP], #0.B	;Really want to write anything?
	JE	writdn.S		;No - all done now
2$:	CALLI	wr_cda.B[EBP]		;Call subroutine to calculate disk
					;  address
	JC	writde.S		;If error
	MOVL	ESI, [EDI]		;Make sure have offset of UCB
	TESTL	ESI, ESI
	JE	knlNoUnitLv##
	CMPL	ECX, wr_tamnt.B[EBP]	;Is more available than we want?
	JBE	4$.S			;No
	MOVL	ECX, wr_tamnt.B[EBP]	;Yes
4$:	MOVL	EAX, xosdskDBufCnt#
	SHRL	EAX, #1			;Get 1/2 of available buffers
	CMPL	EAX, ucb_ramax[ESI]	;Is this more than we can use?
	JBE	6$.S			;No
	MOVL	EAX, ucb_ramax[ESI]	;Yes - just use maximum
6$:	SHLL	EAX, #9			;Change to bytes
	MOVL	EBX, dcb_dkfpos.B[EDI]
	ANDL	EBX, #1FFh
	SUBL	EAX, EBX
	CMPL	ECX, EAX
	JBE	8$.S
	MOVL	ECX, EAX
8$:	MOVL	wr_aamnt.B[EBP], ECX
	MOVL	ECX, #200h		;Get amount to transfer from this block
	SUBL	ECX, EBX
	CMPL	ECX, wr_tamnt.B[EBP]	;More than we want?
	JB	10$.S			;No
	MOVL	ECX, wr_tamnt.B[EBP]	;Yes - just get what we want
10$:	MOVL	EAX, dcb_dkfpos.B[EDI]
	ANDL	EAX, #1FFh		;Does write start at beginning of block?
	PUSHL	ECX
	PUSHL	EAX
	JNE	12$.S			;No - must always read block
	CMPL	ECX, #200h		;Yes - writing entire block?
	JNE	12$.S			;No - read block
	CALL	xosdskSrchDBufr#	;Yes - find buffer but don't read block
	JC	14$.S			;If error
	CALL	xosdskLockBufrW		;OK - lock it
	JMP	16$.S			;Continue

;Here to read block before partial block write

12$:	CLRL	EDX			;Don't read ahead here!
	CALL	xosdskFindDBufr#	;Get disk block into a buffer
14$:	JC	writdew			;If error
16$:	POPL	EDX
	POPL	ECX
	LEAL	EAX, wr_first.B[EBP]	;Initialize pointer to list pointer
	MOVL	wr_prev+0.B[EBP], EAX
	MOVL	wr_prev+4.B[EBP], SS
	MOVL	EAX, dcb_dkdblk.B[EDI]	;Remember block for first buffer in list
	MOVL	wr_begin.B[EBP], EAX
	CLRL	EAX
	MOVW	wr_first.B[EBP], AX
	MOVL	wr_blocks.B[EBP], EAX
	MOVL	wr_actual.B[EBP], EAX
	CMPL	dcb_dkpbfr.B[EDI], EBX	;Is this our pending write buffer?
	JNE	18$.S			;No
	MOVL	dcb_dkpbfr.B[EDI], EAX	;Yes, but not any more
	DECW	cb_usecnt.B[EBX]	;Adjust use count (it can't go to 0
	JE	24$			;  here since it must be at least 2!)
18$:	PUSHL	EDI
	LEAL	EDI, [EBX+EDX]		;Point to start of data
20$:	ORB	cb_sts.B[EBX], #CB$FULL	;Make sure block is marked as full
	PUSHL	ESI
	PUSHL	DS
	POPL	ES
	LFSL	ESI, wr_bufr.B[EBP]
	ADDL	wr_bufr.B[EBP], ECX	;Bump position for next time around
	SUBL	wr_tamnt.B[EBP], ECX	;Reduce amount to go
	SUBL	wr_aamnt.B[EBP], ECX
	ADDL	wr_actual.B[EBP], ECX	;And increase amount done
	CLD
	CMPL	ECX, #4.B		;Have fewer than 4 bytes to copy?
	JB	22$.S			;Yes
	MOVL	EAX, ECX		;No - first copy enough bytes to long
	MOVL	ECX, EDI		;  align the destination
	NEGL	ECX
	ANDL	ECX, #03.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], FS:[ESI]
	MOVL	ECX, EAX		;Next copy as many longs as we can
	SHRL	ECX, #2
	RMOVSL	[EDI], FS:[ESI]
	MOVL	ECX, EAX		;Finally, copy any bytes left over
	ANDL	ECX, #03.B
22$:	RMOVSB	[EDI], FS:[ESI]
	POPL	ESI
	POPL	EDI
	LFSL	EAX, wr_prev.B[EBP]	;Get pointer to pointer
	MOVL	FS:[EAX], EBX		;Link this buffer to our list
	MOVL	cb_xnext.B[EBX], #0
	LEAL	EAX, cb_xnext.B[EBX]	;Update pointer to pointer
	MOVL	wr_prev+0.B[EBP], EAX
	MOVL	wr_prev+4.B[EBP], DS
	INCL	wr_blocks.B[EBP]	;Increase total blocks to output
	INCL	dcb_dkdblk.B[EDI]	;Bump block on disk
	CMPL	wr_aamnt.B[EBP], #0.B	;More available here?
	JE	36$.S			;No
	MOVL	EAX, wr_blocks.B[EBP]	;Yes - can we do more now?
	CMPL	EAX, ucb_wtmax[ESI]
	JAE	36$.S			;No
	CMPL	xosdskDBufCnt#, #3t.B	;Yes - at least 3 buffers available?
	JB	36$.S			;No - stop now
	CALL	xosdskSrchDBufr#	;Yes - search for next buffer
	JC	36$.S			;This should not fail, but maybe
					;  someone snuck in and took them all!
	CALL	xosdskLockBufrF#	;Lock it (fail if already locked)
	JC	writdef
	JE	26$.S			;Go on if we got it
	CALL	xosdskGiveBufr#		;Already locked - stop now
	JMP	36$.S

24$:	CRASH	DSK?

;Here with next buffer locked

26$:	CMPL	wr_tamnt.B[EBP], #512t	;Will we write the entire block?
	JAE	34$.S			;Yes
	TESTB	cb_sts.B[EBX], #CB$FULL	;No - do we have the block?
	JNE	28$.S			;Yes
	CALL	xosdskReadBufr#		;No - fill it now
	JC	writdef			;If error
28$:	MOVL	ECX, wr_tamnt.B[EBP]	;OK - get amount to transfer
30$:	CMPL	dcb_dkpbfr.B[EDI], EBX	;Is this our pending write buffer?
	JNE	32$.S			;No
	MOVL	dcb_dkpbfr.B[EDI], EAX	;Yes, but not any more
32$:	PUSHL	EDI
	MOVL	EDI, EBX
	JMP	20$

;Here if we are filling the entire block - in this case we don't care if we
;  have the buffer filled now or not

34$:	MOVL	ECX, #512t
	JMP	30$.S

;Here if have stopped filling buffers, either because we have run out of data,
;  have reached the write transfer limit, have filled the current available
;  extent, or have encountered a locked buffer

36$:	MOVL	EAX, wr_begin.B[EBP]	;Set disk block for first buffer in
	MOVL	dcb_dkdblk.B[EDI], EAX	;  list
	MOVL	EBX, wr_first.B[EBP]	;Get address of first buffer
	CMPL	cb_xnext.B[EBX], #0.B	;Is it the only one?
	JNE	42$.S			;No
	CMPL	wr_tamnt.B[EBP], #0.B	;Yes - is there more to do?
	JNE	42$.S			;Yes - don't defer this one
	BTL	SS:xffCmd##, #O%NODFWR	;No - should we defer writes?
	JC	42$.S			;No
	CMPL	dcb_dkpbfr.B[EDI], #0.B	;Yes - already have something defered?
	JE	38$.S			;No
	CMPL	dcb_dkpbfr.B[EDI], EBX	;Yes - is it the same buffer?
	JE	44$.S			;Yes - nothing more needed here
	CALL	xosdskUnlkBufr#		;No - unlock this buffer
	PUSHL	EBX			;Write the previous defered buffer
	MOVL	EBX, dcb_dkpbfr.B[EDI]	;  now
	CLRL	EAX
	MOVL	dcb_dkpbfr.B[EDI], EAX
	CALL	xosdskLockBufrW#
	CALL	xosdskWriteBufr#
	JC	40$.S			;If error
	CALL	xosdskRelsLkBufr#
	POPL	EBX			;Restore offset of current buffer
	CALL	xosdskLockBufrW#	;Lock it again
38$:	CMPW	cb_usecnt.B[EBX], #0FFFFFFFEh.B ;Can we bump its use count?
	JAE	42$.S			;No - don't defer it (very unlikely!)
	MOVL	dcb_dkpbfr.B[EDI], EBX	;Store offset of new defered buffer
	INCW	cb_usecnt.B[EBX]	;Bump its use count so we will keep it
	JMP	44$.S

;Here if error when writing the defered buffer

40$:	PUSHL	EAX
	CALL	xosdskGiveLkBufr#	;Give up the buffer
	POPL	EAX
	POPL	EBX			;Restore offset of current buffer
	PUSHL	EAX
	CALL	xosdskLockBufrW#	;Lock the current buffer again
	POPL	EAX			;Go handle the error as normal (This is
	JMP	writdef.S		;  not really right, since it makes it
					;  look like the error occured on this
					;  buffer, but there's not much else we
					;  can do at this point!)

;Here if should not defer the write, either because we are writing more than
;  one block or because the user specified no defered write

42$:	PUSHL	DS
	POPL	ES
	MOVL	ECX, wr_blocks.B[EBP]	;Get total amount to output
	SHLL	ECX, #9t
	MOVL	EAX, #kf_writlist
	CALL	xosdskXfer		;Do the transfer
	JC	writdef.S		;If error
44$:	MOVL	EAX, wr_actual.B[EBP]	;OK - update amount done
	ADDL	wr_done.B[EBP], EAX
	ADDL	dcb_dkfpos.B[EDI], EAX	;Bump position in file
	MOVL	EBX, wr_first.B[EBP]
46$:	PUSHL	cb_xnext.B[EBX]		;Release the buffers we have just
	CALL	xosdskRelsLkBufr#	;  output
	POPL	EBX
	TESTL	EBX, EBX
	JNE	46$.S
	CMPL	wr_tamnt.B[EBP], #0.B	;Do we want more?
	JE	48$.S			;No - finished here
	TESTB	SS:xffStatus1##, #XF1$ABORT ;Has this operation been aborted?
	JE	2$			;No - go write another part
	JMP	writab			;Yes - fail

;Here when finished

48$:	CLRL	EAX			;Indicate no error
50$:	MOVL	ECX, wr_done.B[EBP]	;Get count
	LEAVE
	RET

;Here if error after at least one buffer has been filled - in this case we
;  mark all of the buffers we have filled as empty (this is conservative:
;  we do not want to try to write anything additional to the disk since we
;  know there is a problem)

writdef:PUSHL	EAX
	MOVL	EBX, wr_first.B[EBP]
52$:	PUSHL	cb_xnext.B[EBX]
	ANDB	cb_sts.B[EBX], #CB$FULL
	CALL	xosdskGiveLkBufr#
	POPL	EBX
	TESTL	EBX, EBX
	JNE	52$.S
	POPL	EAX
	STC
	JMP	50$.S
.PAGE
	.SBTTL	setupraw - Subroutine to set up for raw disk IO

;Subroutine to set up for raw disk IO
;	c{EDI} = Offset of DCB
;	c{EBP] = Frame pointer
;	CALL	setupraw
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = 0
;	C:clr = Normal
;	  c(AL) = Value of first byte in buffer
;	  c{ES:EBX} = Buffer address
;	  c{ECX}    = Buffer size

setupraw:
	IFFAULT	knlRtnAdrEr0##
	LESL	EBX, rd_bufr.B[EBP]	;Get buffer address
	MOVL	ECX, rd_tamnt.B[EBP]	;Get amount to transfer
	MOVL	EAX, dcb_dkfpos.B[EDI]	;Use the position directly
	MOVL	dcb_dkdblk.B[EDI], EAX
	MOVL	EAX, EBX		;Calculate top of buffer
	ADDL	EAX, ECX
	DECL	EAX
	XORL	EAX, EBX		;Is buffer in more than one page?
	TESTL	EAX, #0FFFFF000h
	JNE	knlRtnAdrEr0##		;Yes - fail
	RET				;OK
.PAGE
	.SBTTL	dskdadr - Subroutine to calculate disk block

;Subroutine to calculate disk block given position in file
;	CALL	dskdadr
;	C:clr always
;	Z:clr always
;	c{ECX} = Amount available (always 0FFFFFFFFh)

dskdadr::
	MOVL	EAX, dcb_dkfpos.B[EDI]	;Since this is direct IO, the position
	SHRL	EAX, #9t		;  on disk is the same as the position
					;  in the "file"
	MOVL	dcb_dkdblk.B[EDI], EAX	;Store block on disk
	CLRL	ECX			;Set ECX to -1 and clear Z and C
	DECL	ECX
	RET
.PAGE
	.SBTTL	xosdskXfer - Subroutine to do immediate disk transfer

;Subroutine to do immediate disk transfer - this subroutine is called at
;  extended fork level only - it does not return until IO is complete
;	c{EAX}    = Function
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Amount to transfer
;	c[EDI]    = Offset of DCB
;	CALL	xosdskXfer
;	c{ECX} = Amount transfered
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Amount transfered
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Amount transfered

xosdskXfer:
	MOVL	ESI, [EDI]
	TESTL	ESI, ESI
	JE	knlNoUnit##
	TESTB	ucb_sts3.B[ESI], #U3$STOPPED ;Has this unit been stopped?
	JNE	8$.S			;Yes
	MOVL	EDX, ucb_kcb.B[ESI]	;No - get offset of the KCB
	CMPL	kcb_curdcb.B[EDX], #0.B	;Is the controller busy now?
	JE	14$.S			;No - go on
.IF NE $$DSKWRITE
	INCL	xosdskwrcnt
.ENDC
	CMPL	kcb_curdcb.B[EDX], EDI	;Yes - are we using it?
	JNE	2$.S			;No
	TESTB	dcb_sts2.B[EDI], #D2$DCHG ;Yes - has the disk been changed?
	JNE	24$.S			;Yes - fail
	ADDL	EAX, kcb_disp.B[EDX]	;No - dispatch on the function
	JMPIL	CS:[EAX]

;Here if we need to wait for the controller

2$:	PUSHL	EAX			;No
	CMPL	kcb_reqtail.B[EDX], #0.B ;Link to the end of the request list
	JNE	4$.S
	MOVL	kcb_reqhead.B[EDX], EDI
	JMP	6$.S

4$:	MOVL	EAX, kcb_reqtail.B[EDX]
	MOVL	dcb_dkreqnext.B[EAX], EDI
6$:	MOVL	kcb_reqtail.B[EDX], EDI
	CLRL	EAX
	MOVL	dcb_dkreqnext.B[EDI], EAX
	CALL	knlXfWaitNTO##
	JC	10$.S
	POPL	EAX
	CMPL	kcb_curdcb.B[EDX], EDI	;Did this work right?
	JE	16$.S			;Yes
	CRASH	DKSE			;[Disk Kontroller Scheduling Error]

;Here if disk has been marked as stopped

8$:	MOVL	EAX, #ER_BUSY
	CLRL	ECX
	STC
	RET

;Here if error while waiting for the controller

10$:	POPL	ECX
	CLRL	ECX
	STC
	RET

;Here if controller is not busy

14$:	MOVL	kcb_curdcb.B[EDX], EDI	;Grab the controller
16$:	TESTB	dcb_sts2.B[EDI], #D2$DCHG ;Has the disk been changed?
	JNE	24$.S			;Yes - fail
.IF NE $$DSKDEBUG
	CALL	dskpostbgn
.ENDC
.IF NE $$DSKWRITE
	CMPB	AL, #kf_writdata
	JE	18$.S
	CMPB	AL, #kf_writlist
	JNE	20$.S
18$:	CALL	dskpostwrite
	ADDL	EAX, kcb_disp.B[EDX]	;Dispatch on the function
	CALLI	CS:[EAX]
	ORB	CH, #80h
	CALL	dskpostwrite
	ANDB	CH, #7Fh
	JMP	22$.S

20$:
.ENDC
	ADDL	EAX, kcb_disp.B[EDX]	;Dispatch on the function
	CALLI	CS:[EAX]
.IF NE $$DSKDEBUG
	CALL	dskpostend
.ENDC
22$:	TESTB	dcb_sts2.B[EDI], #D2$DCHG ;Has the disk been changed?
	JE	26$.S			;No
24$:	MOVL	EAX, #ER_MDCHG
	CLRL	ECX
26$:	MOVL	EBX, ucb_kcb.B[ESI]	;Restore KCB offset
	MOVB	kcb_itimer.B[EBX], #0	;Make sure interrupt timer is not active
	CMPL	kcb_reqhead.B[EBX], #0.B ;Is anyone waiting?
	JE	30$.S			;No
	PUSHL	EAX			;Yes
	PUSHL	ECX
	PUSHL	EDI
	PUSHL	ESI
	MOVL	EDI, kcb_reqhead.B[EBX]	;Get next DCB
	MOVL	EAX, dcb_dkreqnext.B[EDI] ;Remove it from the list
	MOVL	kcb_reqhead.B[EBX], EAX
	TESTL	EAX, EAX
	JNE	28$.S
	MOVL	kcb_reqtail.B[EBX], EAX
28$:	MOVL	kcb_curdcb.B[EBX], EDI
	CLRL	EAX
	CALL	knlResumeOutput##	;Wake him up
	POPL	ESI
	POPL	EDI
	POPL	ECX
	POPL	EAX
	JMP	32$.S

;Here if there is no one waiting for the controller

30$:	MOVL	kcb_curdcb.B[EBX], #0
32$:	BTL	EAX, #31t		;Set C if error
	RET				;Finished
.PAGE
.IF NE $$DSKWRITE

dskpostwrite::
	PUSHL	EAX
	PUSHL	EBX
	MOVL	EBX, xosdskwrpnt
	CMPL	EBX, #xosdskwrend
	JAE	4$.S
	MOVL	EAX, dcb_dkdblk.B[EDI]
	MOVL	[EBX], EAX
	MOVL	EAX, dcb_dkfpos.B[EDI]
	MOVL	4.B[EBX], EAX
	MOVW	8.B[EBX], CX
	MOVL	EAX, xosdskwrcnt
	MOVW	10t.B[EBX], AX
	CLRL	EAX
	TESTB	CH, #80
	JNE	3$.S
	MOVL	EAX, [ESP]
	MOVL	EAX, [EAX]
3$:	MOVL	12t.B[EBX], EAX
	ADDL	xosdskwrpnt, #16t.B
4$:	POPL	EBX
	POPL	EAX
	RET
.ENDC

.IF NE $$DSKDEBUG

dskpostbgn::
	PUSHL	EAX
	PUSHL	EBX
	MOVL	EBX, dskrpnt		;Get ring pointer
	ADDL	EBX, #16t.B		;Bump pointer
	CMPL	EBX, #dskrend		;Past end of ring
	JB	6$.S			;No
	MOVL	EBX, #dskring		;Yes - reset pointer
6$:	MOVL	dskrpnt, EBX
	MOVW	[EBX], DI		;Store DCB offset
	MOVL	EAX, dcb_dkdblk.B[EDI]	;Store disk block
	MOVL	4.B[EBX], EAX
;;;;;;;	MOVB	AL, dcb_dkfunc.B[EDI]	;Store function
	MOVB	AL, #0FFh
	MOVB	7.B[EBX], AL
	CALL	gettime#		;Store time
	MOVL	8.B[EBX], EAX
	CLRL	EAX
	MOVL	12t.B[EBX], EAX
	POPL	EBX
	POPL	EAX
	RET

dskpostend::
	PUSHL	EAX
	PUSHL	EBX
	MOVL	EBX, dskrpnt
	CALL	gettime#
	SUBL	EAX, 8.B[EBX]
	MOVL	12t.B[EBX], EAX
	POPL	EBX
	POPL	EAX
	RET
.ENDC
.PAGE
	.SBTTL	Data

xosdskMsgBlockIn: DCHARINFO  {Number of blocks input}
xosdskMsgBlockOut:DCHARINFO  {Number of blocks output}
xosdskMsgShrDelay:DCHARINFO  {File sharing delay factor}
xosdskMsgShrFail: DCHARINFO  {Number of file sharing failures}
xosdskMsgShrRetry:DCHARINFO  {Number of file sharing retries}
xosdskMsgTSeekErr:DCHARINFO  {Total number of seek errors}
xosdskMsgHSeekErr:DCHARINFO  {Number of hard seek errors}
xosdskMsgTIdFErr: DCHARINFO  {Total number of ID field errors}
xosdskMsgHIdFErr: DCHARINFO  {Number of hard ID field errors}
xosdskMsgTRNFErr: DCHARINFO  {Total number of record not found errors}
xosdskMsgHRNFErr: DCHARINFO  {Number of hard record not found errors}
xosdskMsgUnexpInt:DCHARINFO  {Number of unexpected interrupts}
xosdskMsgFSType:  DCHARINFO  {File structure type}
xosdskMsgProtect: DCHARINFO  {File access protection}
xosdskMsgReady:   DCHARINFO  {Disk unit is ready}
xosdskMsgDosName: DCHARINFO  {DOS disk name}
xosdskMsgVolName: DCHARINFO  {Volume name}
xosdskMsgClsSz:   DCHARINFO  {Cluster size}
xosdskMsgClsters: DCHARINFO  {Total number of clusters}
xosdskMsgAvail:   DCHARINFO  {Number of free clusters}
xosdskMsgConDsp:  DCHARINFO  {Controller description}
xosdskMsgMSensor: DCHARINFO  {Drive has media sensor}
xosdskMsgRemove:  DCHARINFO  {Media is removable}
xosdskMsgDupFat:  DCHARINFO  {Duplicate FAT blocks are maintained}
xosdskMsgPartn:   DCHARINFO  {Partition table index}
xosdskMsgPartOff: DCHARINFO  {Partition offset}
xosdskMsgTrkDen:  DCHARINFO  {Track density in TPI}
xosdskMsgDataDen: DCHARINFO  {Data density}
xosdskMsgCBlocks: DCHARINFO  {Current total number of blocks on disk}
xosdskMsgCBlkSz:  DCHARINFO  {Current block size in bytes}
xosdskMsgCHeads:  DCHARINFO  {Current number of heads}
xosdskMsgCSects:  DCHARINFO  {Current number of sectors per track}
xosdskMsgCCylns:  DCHARINFO  {Current number of cylinders}
xosdskMsgIBlocks: DCHARINFO  {Initial total number of blocks on disk}
xosdskMsgIBlkSz:  DCHARINFO  {Initial block size in bytes}
xosdskMsgIHeads:  DCHARINFO  {Initial number of heads}
xosdskMsgISects:  DCHARINFO  {Initial number of sectors per track}
xosdskMsgICylns:  DCHARINFO  {Initial number of cylinders}
xosdskMsgWPcCyln: DCHARINFO  {Write pre-comp cylinder}
xosdskMsgFatMode: DCHARINFO  {DOS FAT mode byte}
xosdskMsgFatSize: DCHARINFO  {Size of DOS FAT block}
xosdskMsgNumFats: DCHARINFO  {Number of DOS FAT blocks}
xosdskMsgVolLabel:DCHARINFO  {Volume label}
xosdskMsgVolCDT:  DCHARINFO  {Volume creation date and time}
xosdskMsgVolMDT:  DCHARINFO  {Volume modification date and time}
xosdskMsgVolXDT:  DCHARINFO  {Volume expriation date and time}
xosdskMsgVolEDT:  DCHARINFO  {Volume effective date and time}
xosdskMsgRootBlk: DCHARINFO  {First block for root directory}
xosdskMsgRootSize:DCHARINFO  {Size of root directory (blocks)}
xosdskMsgRootProt:DCHARINFO  {Root directory protection}

	DATA

numdbuf::   .LONG 7t		;Number of disk data buffers
numsbuf::   .LONG 14t		;Number of disk system buffers
fdskdrv::   .LONG 0		;Offset of first disk driver data block
firstkcb::  .LONG 0		;Offset of first KCB in system
firstfscb:: .LONG 0		;Offset of first file system control block
lastfscb::  .LONG 0		;Offset of last file system control block
ucbcount::  .LONG 0		;Number of disk UCBs
dskdcbnum:  .LONG 0		;Number of in use disk DCBs
dskdcbmax:  .LONG 0		;Maximum number of in use disk DCBs
dskdcblmt:  .LONG 10000t	;Maximum number of disk DCBs allowed
dskrescall::.LONG 0
xosdskCcb:: .BLKB 30h

xxxDiskRes::.LONG 0

.IF NE $$DSKWRITE
  xosdskwrpnt::.LONG xosdskwring
  xosdskwring::.BLKB 4000t*16t
  xosdskwrend::.LONG 66666666h,66666666h
  xosdskwrcnt::.LONG 0
.ENDC

.IF NE $$DSKDEBUG
  dskrpnt:: .LONG dskring-16t
  dskring:: .BLKB 1024t*16t
  dskrend::
.ENDC

physiostr: .ASCIZ  "Physical IO"

	LKEEND
