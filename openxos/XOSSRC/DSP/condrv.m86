	.TITLE	CONDRV - Common console display routines for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\PCAT.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

	.SBTTL	condctbl - Console driver device characteristics table

MAJV   =!1t
MINV   =!0t
EDITNUM=!2t

;1.0.1  4-Dec-94
;	Fixed problem in conDosSetup, stack was messed up if display already
;	set up for DOS use.
;1.0.2	8-Oct-00
;	Add code to set the MSS$NODEALOC bit when creating an msect which
;	maps a display.

	LKEHEAD	CONDRV, MAJV, MINV, EDITNUM, LKETYPE_DEVICE

	.EXPORT	xosconAttrib
	.EXPORT	xosconChkBiosMd
	.EXPORT	xosconClrPgChng
	.EXPORT	xosconFDhdb
	.EXPORT	xosconDosChk
	.EXPORT	xosconDosChkXf
	.EXPORT	xosconDosSet
	.EXPORT	xosconDosUpd
	.EXPORT	xosconDosUpdCP
	.EXPORT	xosconDosUse
	.EXPORT	xosconDspNrm
	.EXPORT	xosconEchChr
	.EXPORT	xosconGetBiosMd
	.EXPORT	xosconNewKeyDriver
	.EXPORT	xosconMakeDhdb
	.EXPORT	xosconMakeTdb
	.EXPORT	xosconMapPhys
	.EXPORT	xosconMapScreen
	.EXPORT	xosconOpen1
	.EXPORT	xosconOutBlk
	.EXPORT	xosconOutBlk2
	.EXPORT	xosconOutChr
	.EXPORT	xosconOutChr2
	.EXPORT	xosconOutStr
	.EXPORT	xosconOutStr2
	.EXPORT	xosconScanMs
	.EXPORT	xosconUnmap
	.EXPORT	xosconUpdPgList

;Console device characteristiics table

	DATA

condctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS   , TEXT, ,  8, knlDcMsgClass##    , knlDcGetClass##   , knlDcSetClass##   , 0
 DCHARENT  TYPE    , TEXT, ,  4, knlDcMsgType##     , knlDcGet4Byte##   , 0                 , dcb_type
 DCHARENT  DISPTYPE, STR , , 64, msgdisptype        , getdisptype       , 0                 , 0
 DCHARENT  DISPDESC, STR , , 64, msgdispdesc        , getdispdesc       , 0                 , 0
 DCHARENT  DISPVER , STR , , 64, msgdispver         , getdispver        , 0                 , 0
 DCHARENT  DISPBUFR, DECV, ,  4, msgdispbufr        , getdispbufr       , 0                 , dhdb_npages
 DCHARENT  VERTFREQ, DECV, ,  4, msgvertfreq        , getvertfreq       , setvertfreq       , 0
 DCHARENT  IOREG   , HEXV, ,  2, knlDcMsgIoReg##    , xosconGet4BDhdb   , 0                 , dhdb_bioreg
 DCHARENT  SCSVTIME, DECV, ,  2, msgscsvtime        , getscsvtime       , setscsvtime       , 0
 DCHARENT  SCSVTYPE, TEXT, ,  8, msgscsvtype        , getscsvtype       , setscsvtype       , 0
 DCHARENT  KBTYPE  , TEXT, ,  4, msgkbtype          , xosconGet4BDhdb   , 0                 , dhdb_kbtype
 DCHARENT  KBIOREG , HEXV, ,  2, msgkbioreg         , xosconGet4BDhdb   , 0                 , dhdb_kbioreg
 DCHARENT  KBINT   , DECV, ,  1, msgkbint           , xosconGet4BDhdb   , 0                 , dhdb_kbint
 DCHARENT  MOUSE   , TEXT, , 16, msgmouse           , getmouse          , 0                 , 0
 DCHARENT  BELLFREQ, DECV, ,  2, knlTrmMsgBFreq##   , knlTrmGet2Byte##  , knlTrmSet2Byte##  , tdb_spkfreq
 DCHARENT  BELLLEN , DECV, ,  2, knlTrmMsgBLen##    , knlTrmGet2Byte##  , knlTrmSet2Byte##  , tdb_spklen
 DCHARENT  IOUTFLOW, TEXT, ,  8, knlTrmMsgIOFlow##  , knlTrmGetOFlow##  , setflow           , tdb_iflow
 DCHARENT  OUTFLOW , TEXT, ,  8, knlTrmMsgOFlow##   , knlTrmGetOFlow##  , setflow           , tdb_flow
 DCHARENT  SESSION , TEXT, ,  4, knlTrmMsgSession## , knlTrmGetSession##, knlTrmSetSession##, 0
 DCHARENT  MSGDST  , STR , , 16, knlTrmMsgMsgDst##  , knlTrmGetText##   , knlTrmSetText##   , tdb_msgdst
 DCHARENT  PROGRAM , STR , , 16, knlTrmMsgProgram## , knlTrmGetText##   , knlTrmSetText##   , tdb_program
 DCHARENT  ACCESS  , TEXT, ,  4, knlDcMsgAccess##   , knlTrmGet4Byte##  , knlTrmSetAccess## , tdb_access
 DCHARENT  PASSWORD, STR , , 12, knlTrmMsgPWrd##    , knlTrmGetText##   , knlTrmSetText##   , tdb_password
 DCHARENT  INRBS   , DECV, ,  2, knlTrmMsgInRBS##   , knlTrmGet4Byte##  , 0                 , tdb_irsize
 DCHARENT  INRBSL  , DECV, ,  2, knlTrmMsgInRBSL##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irbsl
 DCHARENT  INRBPL  , DECV, ,  2, knlTrmMsgInRBPL##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irbpl
 DCHARENT  INRBHELD, DECV, ,  4, knlTrmMsgInRBHeld##, knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irheld
 DCHARENT  INRBLOST, DECV, ,  4, knlTrmMsgInRBLost##, knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irlost
 DCHARENT  INLBS   , DECV, ,  2, knlTrmMsgInLBS##   , knlTrmGet4Byte##  , 0                 , tdb_ibsize
 DCHARENT  CHAROUT , DECV, ,  4, knlTrmMsgCharOut## , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_charout
 DCHARENT  CHARIN  , DECV, ,  4, knlTrmMsgCharIn##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_charin
 DCHARENT  KBCHAR  , DECV, ,  4, knlTrmMsgKbChar##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_kbchar
 DCHARENT  KBTCHAR , DECV, ,  4, knlTrmMsgKbTChar## , xosconGet4BDhdb   , xosconSet4BDhdb   , dhdb_kbtchar

	CODE

msgmouse:   DCHARINFO  {Associated mouse device}
msgdisptype:DCHARINFO  {Display adapter type}
msgdispdesc:DCHARINFO  {Display adapter description}
msgdispver: DCHARINFO  {Display adapter version}
msgdispbufr:DCHARINFO  {Display buffer size (KB)}
msgscsvtime:DCHARINFO  {Screen saver time (sec)}
msgscsvtype:DCHARINFO  {Screen saver type}
msgkbtype:  DCHARINFO  {Keyboard device type}
msgkbioreg: DCHARINFO  {Keyboard base IO register}
msgkbint:   DCHARINFO  {Keyboard interrupt number}
msgvertfreq:DCHARINFO  {Graphics mode vert freq}
.PAGE
	.SBTTL	xosconNewKeyDriver - Register new console keyboard driver

;Subroutine to register new console keyboard driver
;	c{EAX} = Type name for keyboard (4 characters)
;	c{EBX} = Offset of keyboard add unit routine
;	CALL	xosconNewKeyDriver

xosconNewKeyDriver:
	PUSHL	EAX
	MOVL	ECX, #16t		;Get memory
	CALL	knlGetXMem##
	POPL	ECX
	JC	4$.S			;If error
	MOVL	kbdb_kbtype.B[EDI], ECX	;OK - store data
	MOVL	kbdb_addunit.B[EDI], EBX
	MOVL	EAX, xosconFKbdb	;Link in the block
	MOVL	[EDI], EAX
	MOVL	xosconFKbdb, EDI
4$:	RET				;Finished
.PAGE
	.SBTTL	xosconMakeDhdb - Subroutine to make console DHDB

;Subroutine to make console DHDB - must be called with the exec memory resource
;	c(AL)  = Unit number
;	c(AH)  = Keyboard interrupt number
;	c{EBX} = Console driver type name (4 characters)
;	c{ECX} = Keyboard driver type name (4 characters)
;	c{ESI} = Keyboard base IO register
;	CALL	xosconMakeDhdb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset of DHDB
;	  Z:set  = DHDB already set up
;	  Z:clr  = New DHDB just created

$$$=!0
FRM            , 2t
FRM cmd_kbint  , 1t		;Keyboard interrupt number
FRM cmd_unit   , 1t		;Unit number
FRM cmd_contype, 4t		;Console driver type name
FRM cmd_kbtype , 4t		;Keyboard driver type name
FRM cmd_kbioreg, 4t		;Keyboard base IO register
cmd_SIZE=!$$$

xosconMakeDhdb:
	ENTER	cmd_SIZE, 0
	MOVL	cmd_unit.B[EBP], EAX	;Yes - store unit and keyboard interrupt
	MOVL	cmd_contype.B[EBP], EBX	;Store console driver type name
	MOVL	cmd_kbtype.B[EBP], ECX	;Store keyboard driver type name
	MOVL	cmd_kbioreg.B[EBP], ESI	;Store keyboard base IO register
	MOVL	EDI, xosconFDhdb	;See if we already have the DHDB
2$:	TESTL	EDI, EDI
	JE	10$.S
	CMPB	dhdb_unit.B[EDI], AL	;This one?
	JE	4$.S			;Yes
	MOVL	EDI, [EDI]		;No - advance to next
	JMP	2$.S

;Here with an existing DHDB for this unit

4$:	CMPL	dhdb_contype.B[EDI], EBX ;Is the console driver type name right?
	JNE	6$.S			;No - fail!
	CMPL	dhdb_kbtype.B[EDI], ECX	;Yes - is the keyboard driver type name
					;  right?
6$:	JNE	knlBadParmVLv##		;No - fail!
	LEAVE				;OK - finidhed
	RET

;Here if there is no DHDB for this unit - first see if we have the specified
;  keyboard driver

10$:	MOVL	ESI, xosconFKbdb
	MOVL	EAX, cmd_kbtype.B[EBP]
12$:	TESTL	ESI, ESI
	JE	14$.S
	CMPL	kbdb_kbtype.B[ESI], EAX	;This one?
	JE	16$.S			;Yes
	MOVL	ESI, [ESI]		;No - advance to next
	JMP	12$.S

;Here if can't find data block for the keyboard

14$:	LEAVE
	MOVL	EAX, #ER_NSTYP
	STC
	RET

;Here with keyboard data block

16$:	MOVL	ECX, #dhdb_mSIZE+dhdb_SIZE
	CALL	knlGetXMem#		;Allocate memory for the DHDB
	JC	20$.S			;If error
	ADDL	EDI, #dhdb_mSIZE
	DECL	dhdb_fnext.B[EDI]
	MOVB	AL, cmd_unit.B[EBP]	;Store unit number
	MOVB	dhdb_unit.B[EDI], AL
	MOVL	EAX, cmd_contype.B[EBP]	;Store console type name
	MOVL	dhdb_contype.B[EDI], EAX
	MOVL	EAX, xosconFDhdb	;Link in this block
	MOVL	[EDI], EAX
	MOVL	xosconFDhdb, EDI
	MOVL	EAX, cmd_kbtype.B[EBP]
	MOVL	dhdb_kbtype.B[EDI], EAX	;Store keyboard type name
	MOVL	EAX, cmd_kbioreg.B[EBP]
	MOVL	dhdb_kbioreg.B[EDI], EAX ;Store keyboard base IO register
	MOVZBL	EAX, cmd_kbint.B[EBP]
	MOVL	dhdb_kbint.B[EDI], EAX	;Store keyboard interrupt number
	MOVZBL	EBX, cmd_kbint.B[EBP]
	CALLI	kbdb_addunit.B[ESI]	;Set up the keyboard driver
	TESTL	ESP, ESP		;Return with Z clear to indicate new
20$:	LEAVE				;  DHDB
	RET
.PAGE
	.SBTTL	xosconMakeTdb - Subroutine to make console TDB

;Subroutine to make console TDB - must be called with the exec memory resource
;	c{EAX} = Length of input ring buffer + 10000h * length of input
;		   line buffer
;	c{ECX} = Size of positive part of the TDB
;	c(DH)  = Screen number
;	c{EDI} = Offset of DHDB
;	CALL	xosconMakeTdb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosconMakeTdb:
	CMPB	DH, #0
	JE	2$.S
	CMPB	DH, #VDSPMAX		;Is the screen number valid?
2$:	JAE	knlBadParmV##		;No - fail!
	MOVZBL	EBX, DH			;Is the screen defined now?
	CMPL	dhdb_tdbtbl-4[EDI+EBX*4], #0.B
	JNE	2$.S			;Yes - fail
	PUSHL	EDI			;No
	MOVB	DL, dhdb_unit.B[EDI]	;Get unit number
	MOVL	EBX, dhdb_contype.B[EDI] ;Get console driver type name
	CALL	knlTrmMakeTdb##		;Make a TDB
	POPL	EDI
	JC	10$			;If error
	MOVB	tdb_ifdsp.B[ESI], #0	;Indicate terminal does not do queued
					;  output
	MOVB	tdb_stsmisc.B[ESI], #TSM$MAPPED ;Indicate mapped terminal
	MOVL	EAX, dhdb_bioreg.B[EDI]	;Store base IO register
	MOVL	tdb_bioreg[ESI], EAX
	MOVL	EAX, dhdb_disptype.B[EDI] ;Store display type
	MOVL	tdb_disptype.B[ESI], EAX      ;Store offset of device
	MOVL	tdb_devchar.B[ESI], #condctbl ;  characteristics table
	MOVW	tdb_tattrval[ESI], #0707h ;Set initial text attribute values
	MOVW	tdb_battrval[ESI], #0707h
	MOVW	tdb_spkfreq.B[ESI], #893t ;Set initial bell tone frequency
	MOVW	tdb_spklen.B[ESI], #300t ;Set initial bell tone duration
	MOVL	tdb_escdsp.B[ESI], #xosconDspNrm ;Set initial ESC mode dispatch
	MOVL	tdb_response.B[ESI], #02000000h ;Initialize primary DA response
	MOVL	EAX, dhdb_kdisp.B[EDI]	;Store offset of the keyboard dispatch
	MOVL	tdb_kdisp.B[ESI], EAX	;  table
	MOVL	tdb_dhdb.B[ESI], EDI
	MOVZBL	EDX, tdb_snum.B[ESI]	      ;Store offset of the TDB in the
	MOVL	dhdb_tdbtbl-4[EDI+EDX*4], ESI ;  DHDB
	INCL	dhdb_num[EDI]		;Bump number of virtual screens
	MOVL	EAX, conltdb
	MOVL	conltdb, ESI		;Link into our list of TDBs
	TESTL	EAX, EAX
	JE	8$.S
	MOVL	tdb_nexts.B[EAX], ESI
	JMP	10$.S

8$:	MOVL	conftdb, ESI
	MOVL	EBX, #conoas		;Setup our once-a-second routine
	PUSHL	EDI
	PUSHL	ESI
	CALL	knlSetupOAS##
	POPL	ESI
	POPL	EDI
	CLC
10$:	RET
.PAGE
;Here to set 4 byte characteristic value in the DHDB

xosconSet4BDhdb:
	CALL	knlGetTdb
	JC	2$.S
	ADDL	EBX, tdb_dhdb.B[ESI]	;Get offset of the item
	MOVL	[EBX], EAX
	CLC
	RET

	.SBTTL	setflow - Set value of INFLOW or IINFLOW characteristic

;Here to set the value of the INFLOW or IINFLOW characteristic

setflow:CALL	knlGetTdb##		;Get our TDB
	JC	2$.S			;If error
	PUSHL	EBX
	MOVL	ECX, #knlTRMIFLOWTBLDSZ## ;Process value
	MOVL	EBX, #knlTrmIFlowTblD##
	CALL	knlGetDcVal2##
	POPL	EBX
	JC	2$.S			;If error
	SHLB	AL, #4
	ANDB	[ESI+EBX], #0Fh
	ORB	[ESI+EBX], AL		;Store new value
2$:	RET
.PAGE
	.SBTTL	setscsvtime - Set value of SCSVTIME characteristic

;Here to set the value of the SCSVTIME characteristic

setscsvtime:
	CALL	knlGetTdb##		;Get our TDB
	JC	4$.S			;If error
	MOVL	EDX, tdb_dhdb.B[ESI]	;Get offset of the DHDB
	MOVL	dhdb_scsvtime.B[EDX], EAX ;Store new value
	MOVL	dhdb_scsvcnt.B[EDX], EAX ;Also reset the counter
4$:	RET				;Finished

	.SBTTL	setscsvtype - Set value of SCSVTYPE characteristic

;Here to set the value of the SCSVTYPE characteristic

setscsvtype:
	CALL	knlGetTdb##		;Get our TDB
	JC	ret002.S		;If error
	MOVL	EBX, #scsvval
	MOVL	ECX, #SCSVVALSZ
	CALL	knlGetDcVal2##
	JC	ret002.S
	MOVL	EDX, tdb_dhdb.B[ESI]	;Get offset of the DHDB
	MOVB	dhdb_scsvtype.B[EDX], AL	;Store new value
ret002:	RET

	.MOD	4
scsvval:.LONG	'K'   , 0 , 1
	.LONG	'KEY' , 0 , 1
	.LONG	'F'   , 0 , 0
	.LONG	'FULL', 0 , 0
SCSVVALSZ=!{$-scsvval}/12t
.PAGE
	.SBTTL	setvertfreq - Set value of VERTFREQ characteristic

;Here to set the value of the VERTFREQ characteristic

setvertfreq:
	CALL	knlGetTdb##		;Get our TDB
	JC	ret002.S
	MOVL	EBX, tdb_ddisp.B[ESI]
	JMPIL	CS:tf_setgvf.B[EBX]
.PAGE
;Here to get 4 byte characteristic value from the DHDB

xosconGet4BDhdb:
	CALL	knlGetTdb		;Get offset of the TDB
	JC	4$.S			;If error
	ADDL	EBX, tdb_dhdb.B[ESI]	;Get offset of the item
	MOVL	EAX, [EBX]		;Get value
	CLC
4$:	RET

	.SBTTL	getdisptype - Get value of DISPTYPE characteristic

;Here to get the value of the DISPTYPE characteristic

getdisptype:
	CALL	knlGetTdb##		;Get our TDB
	JC	4$.S			;If error
	MOVL	EDX, tdb_dhdb.B[ESI]
	MOVL	EDX, dhdb_dispname.B[EDX]
	JMP	knlGetSysStr##

	.SBTTL	getdispver - Get value of DISPVER characteristic

;Here to get the value of the DISPVER characteristic

getdispver:
	CALL	knlGetTdb##		;Get our TDB
	JC	4$.S			;If error
	MOVL	EDX, tdb_dhdb.B[ESI]
	MOVL	EDX, dhdb_xddb.B[EDX]
	TESTL	EDX, EDX
	JE	8$.S
	ADDL	EDX, #xddb_version.B
	JMP	knlGetSysStr##

	.SBTTL	getdispbufr - Get value of DISPBUFR characteristic

;Here to get the value of the DISPBUFR characteristic

getdispbufr:
	CALL	knlGetTdb##		;Get our TDB
	JC	4$.S			;If error
	MOVL	EBX, tdb_dhdb.B[ESI]
	MOVL	EAX, dhdb_gbfrsize.B[EBX]
	SHRL	EAX, #10t
	CLC
	RET

	.SBTTL	getdisptype - Get value of DISPTYPE characteristic

;Here to get the value of the DISPDESC characteristic

getdispdesc:
	CALL	knlGetTdb##		;Get our TDB
	JC	4$.S			;If error
	MOVL	EDX, tdb_dhdb.B[ESI]
	MOVL	EDX, dhdb_xddb.B[EDX]
	TESTL	EDX, EDX
	JE	8$.S
	ADDL	EDX, #xddb_desc.B
	JMP	knlGetSysStr##

8$:	MOVL	EDX, #nullstr
	JMP	knlGetSysStr##
.PAGE
	.SBTTL	getmouse - Get value of MOUSE characteristic

;Here to get the value of the MOUSE characteristic

getmouse:
	CALL	knlGetTdb##		;Get our TDB
	JC	4$.S			;If error
	MOVL	EDX, tdb_dhdb.B[ESI]	;Get our DHDB
	MOVL	EAX, dhdb_kbmouse.B[EDX] ;Get offset of possible mouse DCB
	TESTL	EAX, EAX		;Do we have a mouse device?
	JNE	2$.S			;Yes
	MOVL	EAX, #nonestr		;No
	RET

;Here if have an associated mouse device

2$:	ADDL	EAX, #dcb_name.B	;Point to the device name
	CLC
	RET

	.SBTTL	getscsvtime - Get value of SCSVTIME characteristic

;Here to get the value of the SCSVTIME characteristic

getscsvtime:
	CALL	knlGetTdb##		;Get our TDB
	JC	4$.S			;If error
	MOVL	EDX, tdb_dhdb.B[ESI]	;Get offset of the DHDB
	MOVL	EAX, dhdb_scsvtime.B[EDX] ;Get value
	CLRL	EDX
4$:	RET

	.SBTTL	getscsvtype - Get value of SCSVTYPE characteristic

;Here to get the value of the SCSVTYPE characteristic

getscsvtype:
	CALL	knlGetTdb##		;Get our TDB
	JC	8$.S			;If error
	MOVL	EDX, tdb_dhdb.B[ESI]	;Get offset of the DHDB
	MOVL	EAX, #'FULL'		;Assume FULL
	CMPB	dhdb_scsvtype.B[EDX], #0 ;Right?
	JE	8$.S			;Yes
	MOVL	EAX, #'KEY'		;No
8$:	CLRL	EDX
ret003:	RET
.PAGE
	.SBTTL	getvertfreq - Get value of VERTFREQ characteristic

;Here to get the value of the VERTFREQ characteristic

getvertfreq:
	CALL	knlGetTdb##		;Get our TDB
	JC	ret003.S
	MOVL	EBX, tdb_ddisp.B[ESI]
	JMPIL	CS:tf_getgvf.B[EBX]
.PAGE
	.SBTTL	xosconChkBiosMd - Subroutine to do mode checking for svcTrmDspode

;Subroutine to do mode checking for svcTrmDspMode routines
;	c{EAX}    = Function bits
;	c{ES:EBX} = Address of user data block
;	CALL	xosconChkBiosMd
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Function bits
;	  c{ES:EBX} = Address of user data block
;	  c{FS:EDX} = Address of data block containing values to use

xosconChkBiosMd::
	BTL	EAX, #DM%BIOSMODE	;Want to use a BIOS mode value?
	JC	4$.S			;Yes
	CMPB	AL, #DM_SETBASE		;No - special base value call?
	JAE	conbasemd.S		;Yes - go handle that
	BTL	EAX, #DM%USEDATA	;No - did he provide some data?
	JNC	2$.S			;No
	PUSHL	ES			;Yes - just copy his data block address
	POPL	FS
	MOVL	EDX, EBX
	CLC
	RET				;Thats all

;Here if no data was provided - point to a dummy data block containing all 0s

2$:	MOVL	EDX, #dummydata
	PUSHL	DS
	POPL	FS
	CLC
	RET

;Here if BIOS mode value was specified

4$:	MOVZBL	EAX, AL			;Clear all other bits
	BTZL	EAX, #7			;Want to clear the display
	JNC	6$.S			;Yes
	BTSL	EAX, #DM%NOCLEAR	;No
6$:	CMPB	AL, #7Fh		;Just want value returned?
	JNE	8$.S			;No
	MOVL	EAX, #DM$BIOSMODE	;Yes
	JMP	2$.S

;Here if really wants to set BIOS mode

8$:	CMPB	AL, #03h		;Valid mode?
	JE	10$.S
	CMPB	AL, #02h
	JNE	knlBadValue##		;No - fail
10$:	MOVB	AL, #DM_TEXT
	MOVL	EDX, #biosmode3		;Get address of data block for mode
	PUSHL	DS
	POPL	FS
	RET				;Finished

	DATA

	.MOD	4
biosmode3:
	.LONG	DM$BIOSMODE|DM_TEXT, 80t, 25t, 0, 0 ;Mode 3

dummydata:
	.BLKB	dm_SIZE

	CODE
.PAGE
;Here to set or use the base mode values

conbasemd:
	JA	4$.S			;If want to use base mode values
	MOVL	EAX, tdb_columns[ESI]	;Set base mode values from current
	MOVW	tdb_bcolumns.B[ESI], AX	;  mode values
	MOVB	AL, tdb_rows[ESI]
	MOVB	tdb_brows.B[ESI], AL
	MOVB	AL, tdb_mode[ESI]
	MOVB	tdb_bmode[ESI], AL
	MOVB	AL, tdb_dsppage[ESI]
	MOVB	tdb_bdsppage[ESI], AL
	MOVW	AX, tdb_curmode[ESI]
	MOVW	tdb_bcurmode[ESI], AX
2$:	CLRL	EAX
	RET

;Here to use base mode values - If the base mode values are different from
;  the current values, the mode is set to match the base values, otherwise
;  no change is made to the mode.  The screen colors are always reset to the
;  base values.

4$:	MOVL	ECX, tdb_keysts1.B[ESI]	;Restore actual shift, control, and
	MOVL	tdb_keysts0.B[ESI], ECX	;  ALT key states
	CALL	escatoff		;Reset the colors
	MOVB	AL, tdb_bmode[ESI]
	CMPB	tdb_mode[ESI], AL
	JNE	8$.S
	MOVZWL	EAX, tdb_bcolumns.B[ESI]
	CMPL	EAX, tdb_columns[ESI]
	JNE	8$.S
	MOVB	AL, tdb_brows.B[ESI]
	CMPB	AL, tdb_rows[ESI]
	JE	2$.S
8$:	MOVL	EDX, #modebfr		;Different - set up argument data
	PUSHL	DS
	POPL	FS
	MOVZWL	EAX, tdb_bcolumns.B[ESI]
	MOVL	dm_columns.B[EDX], EAX
	MOVZBL	EAX, tdb_brows[ESI]
	MOVL	dm_rows.B[EDX], EAX
	CLRL	EAX
	MOVL	dm_horiz.B[EDX], EAX
	MOVL	dm_vert.B[EDX], EAX
	MOVB	AL, tdb_bdsppage[ESI]
	MOVB	dm_actpage.B[EDX], AL
	MOVZBL	EAX, tdb_bmode[ESI]
	BTSL	EAX, #DM%USEDATA
	RET

	DATA

	.MOD	4
modebfr:.BLKB	dm_SIZE

	CODE
.PAGE
	.SBTTL	xosconGetBiosMd - Subroutine to get BIOS display mode value

;Subroutine to get BIOS display mode value for current XOS display mode
;	CALL	xosconGetBiosMd
;	c{EAX} = BIOS display mode

xosconGetBiosMd::
	MOVB	AL, #03h		;Always say 80 column color!
	CLC
ret004:	RET
.PAGE
	.SBTTL	xosconOpen - Function called when terminal is opened

xosconOpen1::
	MOVL	EAX, #DM_TEXT
	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Physical IO?
	JE	4$.S
	ORB	AH, #DM$NOCLEAR>8t	;Yes - don't clear the screen
4$:	MOVL	EBX, tdb_ddisp.B[ESI]
	CALLI	CS:tf_dspmode.B[EBX]
	MOVL	EAX, #DM_SETBASE	;Make this the base mode
	MOVL	EBX, tdb_ddisp.B[ESI]
	CALLI	CS:tf_dspmode.B[EBX]
	MOVL	EBX, tdb_ddisp.B[ESI]
	CALLI	CS:tf_opena.B[EBX]
	MOVL	EBX, tdb_dhdb.B[ESI]
	TESTL	EBX, EBX
	JE	ret004.S
	MOVL	EBX, dhdb_kdisp.B[EBX]
	JMPIL	CS:kf_open.B[EBX]
.PAGE
	.SBTTL	xosconDosSet - Function to set up console for real mode

;Function to set up console for real mode - sets up the screen mapping and the
;  data block needed for keyboard interrupts
;	c{EDI} = Offset of controlling terminal DCB
;	c{ESI} = Offset of controlling terminal TDB
;	CALL	xosconDosSet
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Size of currently mapped buffer (0 means not mapped)
;	  c{EDX} = Offset of currently mapped buffer (meaningless if not mapped)


1$:	POPL	ESI
	RET

xosconDosSet::
	CMPB	SS:pdaRealIO##, #0
	JNE	101$.S
	PUSHL	ESI			;First setup a KIB for handling INT 9
					;  user interrupts and for tracking
					;  page 0 for the process
	CALL	knlGetQel##		;Get a queue element for a KIB
	JC	1$.S
	MOVL	ki_handle.B[ESI], #DH_STDTRM ;Store device handle in the KIB
	MOVL	EBX, ESI
	POPL	ESI
	MOVL	EDX, dcb_trkib.B[EDI]	;Link into our list of KIBs
	MOVL	[EBX], EDX
	MOVL	dcb_trkib.B[EDI], EBX
	MOVL	ki_pda.B[EBX], SS
	MOVL	EAX, tdb_ddisp.B[ESI]
	MOVL	ki_ddisp.B[EBX], EAX
	MOVL	EAX, tdb_kdisp.B[ESI]
	MOVL	ki_kdisp.B[EBX], EAX
	MOVL	ki_tdb.B[EBX], ESI
101$:	PUSHL	EDI
	CMPB	SS:pdaVMode##, #0	;Currently mapped?
	JNS	8$			;Yes
	MOVB	AL, tdb_mode[ESI]
	MOVB	SS:pdaVMode##, AL
	PUSHL	EBP
	MOVL	EDX, #0A0000h		;Get virtual address
	MOVL	ECX, #18000h		;Get amount to fill (display is always
					;  at B8000)
	MOVL	EBP, #0FFF8h		;Get segment selector
	PUSHL	ESI
	MOVL	ESI, knlNonExMem##	;Get physical address to use
	MOVL	EDI, #0FFFFh		;Get increment mask for physical address
	MOVB	BL, #PG$WRITE|PG$READ	;Get page bits
	CALL	knlMapPhysMem##		;Map physical memory below the display
	POPL	ESI
	JC	4$.S			;If error
	MOVL	EDX, #0B8000h		;Get virtual address of buffer
	MOVL	ECX, #8t		;Get amount to map
	SHLL	ECX, #12t
	LEAL	EAX, [ECX+EDX]
	PUSHL	EAX
	MOVL	EBP, #0FFF8h		;Get segment selector
	MOVB	BL, #PG$WRITE|PG$READ	;Get page bits
	MOVL	EAX, tdb_ddisp.B[ESI]
	PUSHL	#2$
	PUSHL	CS:tf_mapphys[EAX]
	CLRL	EAX
	RET				;This is really a CALLI to the
					;  tf_mapphys routine
2$:	POPL	EDX
	JC	4$.S			;If error
	MOVL	ECX, #0C0000h		;Calculate amount left above buffer
	SUBL	ECX, EDX
	JLE	6$.S			;If nothing left
	PUSHL	ESI			;Map space above buffer
	MOVZWL	ESI, DX
	ORL	ESI, knlNonExMem##	;Get physical address to use
	MOVL	EDI, #0FFFFh		;Get increment mask for physical address
	MOVL	EBP, #0FFF8h		;Get segment selector
	MOVB	BL, #PG$WRITE|PG$READ	;Get page bits
	CALL	knlMapPhysMem##
	POPL	ESI
	JNC	6$.S

	JMP	6$.S		;#############

4$:	POPL	EBP
	MOVB	SS:pdaVMode##, #0FFh	;Indicate not mapped
	POPL	EDI
	RET

;Here with screen mapping setup

6$:	POPL	EBP
8$:	POPL	EDI
	MOVW	SS:pdaRMPage0##+bda_vdsp6845, #P_EGACCRTINDX
					;Store display adaptor port number

;NEED TO FINISH WHAT FOLLOWS!!!!

	CALL	xosconGetBiosMd		;Get the BIOS mode value
	MOVB	SS:pdaRMPage0##+bda_vvidmode, AL

	MOVB	DL, #01h		;EGA or VGA color mode

;;;; NEED TO GET CORRECT NUMBER OF FLOPPIES HERE!!!

10$:	MOVL	EAX, #2			;Get number of floppies
	TESTL	EAX, EAX		;Do we have any at all?
	JE	14$.S			;No - go on
	INCL	EDX			;Yes - set bit 0
	CMPL	EAX, #4.B		;More than 4 floppies?
	JB	12$.S
	MOVB	AL, #4			;Yes - just say 4
12$:	DECL	EAX
	SHLB	AL, #6t
	ORB	DL, AL
14$:	MOVL	EAX, #1			;Get number of serial ports
	CMPL	EAX, #7.B		;More than 7?
	JB	16$.S			;No
	MOVB	AL, #7			;Yes - just say 7
16$:	ADDB	AL, AL
	MOVB	DH, AL
	MOVL	EAX, #1			;Get number of parallel ports
	CMPL	EAX, #3.B		;More than 3?
	JB	18$.S			;No
	MOVB	AL, #3			;Yes - just say 3
18$:	SHLB	AL, #6t
	ORB	DH, AL				;Store equipment configuration
	MOVW	SS:pdaRMPage0##+bda_vconfig, DX ;  byte
	MOVL	EAX, tdb_columns[ESI]	;Get screen width
	MOVW	SS:pdaRMPage0##+bda_vvidwidth, AX
	MOVZBL	EBX, tdb_rows[ESI]	;Get screen height
	IMULL	EAX, EBX		;Calculate buffer size
	ADDL	EAX, EAX
	ADDL	EAX, #0FFh
	MOVB	AL, #0			;Round up
	MOVW	SS:pdaRMPage0##+bda_vvidblen, AX ;Store it
	DECL	EBX			;Also store rows - 1
	MOVB	SS:pdaRMPage0##+bda_vrows, BL
	MOVB	AL, tdb_charch[ESI]	;Get character cell height
	MOVB	SS:pdaRMPage0##+bda_vpoints, AL
	MOVB	SS:pdaRMPage0##+bda_vvidinfo, #62h ;TEMP!!!!!
	MOVB	SS:pdaRMPage0##+bda_vegainfo, #16h ;TEMP!!!!!
	MOVL	EBX, #pdaRMPage0##+bda_vcnfgdata
	MOVW	SS:[EBX], #8
	MOVL	EAX, knlMachType##
	MOVL	SS:2.B[EBX], EAX
	CLRL	EAX
	MOVL	SS:6.B[EBX], EAX

	MOVW	SS:pdaRMPage0##+bda_vkeytak, #bda_vkeybufr-400h
	MOVW	SS:pdaRMPage0##+bda_vkeyput, #bda_vkeybufr-400h

	PUSHL	SS			;Get PDA selector in right register for
	POPL	ES			;  the rest of this
xosconDosUpd::				;Enter here to only update page 0 data
	MOVL	EAX, tdb_keysts0.B[ESI]	;Get the keyboard bits
	MOVL	EDX, EAX		;Rearrange the bits to match what DOS
	ANDB	DH, #0F0h		;  programs expect in locations 40:17
	ANDB	DL, #1
	MOVB	BL, AL
	SHLB	BL, #1
	ANDB	BL, #0Ch
	ORB	DL, BL
	SHRB	AL, #3
	ANDB	AL, #0Eh
	ORB	DL, AL
	SHRL	EAX, #4
	ORB	DL, AL
	MOVW	ES:pdaRMPage0##+bda_vkeysts0, DX ;Store value in page 0
	MOVZWL	EAX, tdb_curmode[ESI] ;Get cursor mode value
	ANDB	AH, #3Fh
	MOVW	ES:pdaRMPage0##+bda_vcurmode, AX ;Store cursor mode values
	MOVL	EAX, tdb_curpos+0.B[ESI] ;Store cursor positions on page 0
	MOVL	ES:pdaRMPage0##+bda_vcurpos+0, EAX
	MOVL	EAX, tdb_curpos+4.B[ESI]
	MOVL	ES:pdaRMPage0##+bda_vcurpos+4, EAX
	MOVL	EAX, tdb_curpos+8.B[ESI]
	MOVL	ES:pdaRMPage0##+bda_vcurpos+8, EAX
	MOVL	EAX, tdb_curpos+12t.B[ESI]
	MOVL	ES:pdaRMPage0##+bda_vcurpos+12t, EAX
	MOVB	AL, tdb_dsppage[ESI]	;Also store active display page
	MOVB	ES:pdaRMPage0##+bda_vdsppage, AL
	MOVZBL	EAX, SS:pdaVMode##	;Get mapped mode
	TESTB	AL, AL
	JS	notmapped.S		;If not mapped
	MOVL	EDX, #0A0000h		;Get address
	MOVL	EAX, #20000h		;Get size
	RET

;Here if nothing is mapped

notmapped::
	CLRL	EAX			;Return 0 as mapped size
	CLRL	EDX			;And 0 as offset
	RET
.PAGE
	.SBTTL	xosconDosUse - Function tf_rmset - use terminal data from real mode page 0 values

;Function tf_rmset - use terminal data from real mode page 0 values - this
;  function is called whenever a context FROM the process using the terminal
;  is made to copy the user's real mode page 0 values to the systems data
;  - this is necessary in case the user has modified the terminal data in
;  page 0
;	c{ESI} = Offset of TDB
;	c[ES]  = Selector for PDA
;	CALL	xosconDosUse

xosconDosUse::

;NEED CODE HERE TO GET THE KEYBOARD SHIFT STATE BITS

;NEED CODE HERE TO GET THE CURSOR SIZE

	MOVL	EAX, ES:pdaRMPage0##+bda_vcurpos+0 ;Set cursor positions
	MOVL	tdb_curpos+0.B[ESI], EAX
	MOVL	EAX, ES:pdaRMPage0##+bda_vcurpos+4
	MOVL	tdb_curpos+4.B[ESI], EAX
	MOVL	EAX, ES:pdaRMPage0##+bda_vcurpos+8
	MOVL	tdb_curpos+8.B[ESI], EAX
	MOVL	EAX, ES:pdaRMPage0##+bda_vcurpos+12t
	MOVL	tdb_curpos+12t.B[ESI], EAX
	MOVB	AL, ES:pdaRMPage0##+bda_vdsppage ;Set active display page
	MOVB	tdb_dsppage[ESI], AL
	RET
.PAGE
	.SBTTL	xosconOutBlk - Function to output block

;Function to output block - must be called at main program level raised to
;  fork level
;	c{ECX}    = Number of characters to output
;	c{ES:EBX} = Address of block
;	c{ESI}    = Offset of console TDB
;	CALL	xosconOutBlk
;	c{EAX} = Error code
;	c{EBX} = Queued IO status bits
;	c{ECX} = Number of characters output this time

xosconOutBlk::
	CALL	xosconDosChk		;Is this terminal for a DOS process?
	JE	xosconOutBlk2.S		;No
	MOVZBL	EDX, tdb_dsppage[ESI]		       ;Yes - update cursor pos
	MOVW	AX, GS:pdaRMPage0##+bda_vcurpos[EDX*2] ;  from virtual page 0
	MOVW	tdb_curpos.B[ESI+EDX*2], AX
xosconOutBlk2::
	PUSHL	EBX			;Save initial offset
2$:	FROMFORK
	IFFAULT	conader
	MOVB	AL, ES:[EBX]		;Get character
	TOFORK
	CMPL	tdb_escdsp.B[ESI], #xosconDspNrm ;Processing ESC sequence?
	JNE	4$.S			;Yes - don't hold or junk output
	TESTB	tdb_stsout.B[ESI], #TSO$JUNK|TSO$JUNKX|TSO$HOLDS|TSO$HOLDP
					;No - junking or holding output?
	JNE	12$.S			;Yes
	PUSHL	EBX			;No
	PUSHL	ES
	PUSHL	ECX
	CMPB	AL, #CR			;Is this a return character?
	JNE	6$.S			;No
	MOVL	EBX, tdb_ddisp.B[ESI]	;Yes - update cursor on screen
	CALLI	CS:tf_dspcur[EBX]
	JMP	6$.S

4$:	PUSHL	EBX
	PUSHL	ES
	PUSHL	ECX
6$:	CALL	xosconDspChr		;Display character
	POPL	ECX
	POPL	ES
	POPL	EBX
	INCL	EBX
	CMPB	knlSchedReq##, #0	;Is it time to schedule?
	JNE	14$.S			;Yes
	LOOP	ECX, 2$			;No - loop if more
condone:PUSHL	#0.B			;Yes - save error code value
condon2:PUSHL	#QSTS$DONE		;Save status bits
10$:	PUSHL	EBX			;Save final buffer offset
	MOVL	EBX, tdb_ddisp.B[ESI]	;Update cursor on screen
	CALLI	CS:tf_dspcur[EBX]
	POPL	ECX			;Restore final buffer offset
	POPL	EBX			;Restore status bits
	POPL	EAX			;Restore error code
	POPL	EDX			;Restore initial buffer offset
	SUBL	ECX, EDX		;Calculate amount output
	RET				;Finished

;Here if junking or holding output (get here at fork level)

12$:	TESTB	tdb_stsout.B[ESI], #TSO$HOLDS|TSO$HOLDP ;Are we holding output?
	JE	18$.S			;No
conhold:PUSHL	#0.B
	PUSHL	#QSTS$WAIT		;Get status bits for queued IO
	JMP	10$.S

condon4:PUSHL	#0.B
	JMP	condon2.S

;Here if need to stop console output so can schedule

14$:	DECL	ECX			;Are we finished now?
	JE	condon4.S		;Yes - just finish up normally
conschd:PUSHL	#0.B
	PUSHL	#QSTS$REDO		;No - get status bits for queued IO
	JMP	10$.S

;Here if junking output

18$:	ADDL	EBX, ECX		;Just advance pointer
	JMP	condone.S		;Finished
.PAGE
	.SBTTL	xosconOutStr - Function to output string

;Function to output null terminated string
;	c{ES:EBX} = Address of string
;	c{ECX}    = Maximum number to output (0 means no limit)
;	c{ESI}    = Offset of console TDB
;	CALL	xosconOutStr
;	c{EAX} = Error code
;	c{EBX} = Queued IO status bits
;	c{ECX} = Number of characters output this time

xosconOutStr::
	CALL	xosconDosChk		;Is this terminal for a DOS process?
	JE	xosconOutStr2.S		;No
	MOVZBL	EDX, tdb_dsppage[ESI]		       ;Yes - update cursor pos
	MOVW	AX, GS:pdaRMPage0##+bda_vcurpos[EDX*2] ;  from virtual page 0
	MOVW	tdb_curpos.B[ESI+EDX*2], AX
xosconOutStr2::
	PUSHL	EBX			;Save initial offset
2$:	FROMFORK
	IFFAULT	conader
	MOVB	AL, ES:[EBX]		;No - get character
	TOFORK
	TESTB	AL, AL			;End?
	JE	condone			;Yes
	CMPL	tdb_escdsp.B[ESI], #xosconDspNrm ;Processing ESC sequence?
	JNE	4$.S			;Yes - don't hold or junk output
	TESTB	tdb_stsout.B[ESI], #TSO$JUNK|TSO$JUNKX|TSO$HOLDS|TSO$HOLDP
					;Junking or holding output?
	JNE	14$.S			;Yes
4$:	PUSHL	ECX
	PUSHL	EBX
	PUSHL	ES
	CALL	xosconDspChr		;No - display it
	POPL	ES
	POPL	EBX
	POPL	ECX
6$:	INCL	EBX
	CMPB	knlSchedReq##, #0	;Is it time to schedule?
	JNE	10$.S			;Yes
8$:	LOOP	ECX, 2$			;Continue
	JMP	condone

;Here if need to schedule now

10$:	DECL	ECX			;Finished now?
	JE	12$.S			;Yes
	FROMFORK
	IFFAULT	conader
	MOVB	AL, ES:[EBX]		;Maybe
	TOFORK
	CMPB	AL, #0
	JNE	conschd			;No
12$:	JMP	condon4			;Yes

;Here if junking or holding output

14$:	TESTB	tdb_stsout.B[ESI], #TSO$HOLDS|TSO$HOLDP ;Are we holding output?
	JNE	conhold			;Yes
	JMP	6$.S			;No - must be junking it

;Here if address is out of bounds

	FAULTHDR
conader:TOFORK
	PUSHL	#ER_ADRER.B
	JMP	condon2
.PAGE
	.SBTTL	xosconOutChr - Function to output single character

;Function to output single character
;	c(AL)  = Character to output
;	c{ESI} = Offset of console TDB
;	CALL	xosconOutChr
;	C:set = Error
;	  c{EAX} = Error code (0 means should redo IO, c{EDX} = amount so far)
;	C:clr = Normal
;	  c{EAX} = Number of characters output this time (always 0 or 1)
;  Note: Console output always completes without waiting unless output is
;	 held; no errors are possible

xosconOutChr::
	CALL	xosconDosChk		;Is this terminal for a DOS process?
	JE	xosconOutChr2.S		;No
	MOVZBL	EBX, tdb_dsppage[ESI]		       ;Yes - update cursor pos
	MOVW	CX, GS:pdaRMPage0##+bda_vcurpos[EBX*2] ;  from virtual page 0
	MOVW	tdb_curpos.B[ESI+EBX*2], CX
xosconOutChr2::
	CMPL	tdb_escdsp.B[ESI], #xosconDspNrm ;Processing ESC sequence?
	JNE	4$.S			;Yes - don't hold or junk output
	TESTB	tdb_stsout.B[ESI], #TSO$JUNK|TSO$JUNKX|TSO$HOLDS|TSO$HOLDP
					;Junking or holding output?
	JNE	8$.S			;Yes
4$:	CALL	xosconDspChr		;Display the character
	MOVL	EBX, tdb_ddisp.B[ESI]	;Update cursor on screen
	CALLI	CS:tf_dspcur[EBX]
6$:	CLRL	EAX
	INCL	EAX
	RET

;Here if junking or holding output

8$:	TESTB	tdb_stsout.B[ESI], #TSO$HOLDS|TSO$HOLDP ;Are we holding output?
	JE	6$.S			;No - must be junking it
	CLRL	EDX			;Yes
	CLRL	EAX
	STC
	RET
.PAGE
	.SBTTL	xosconEchChr - Function to echo single character

;Function to echo single character - must be called at fork level
;	c(AL)  = Character to output
;	c{ESI} = Offset of console TDB
;	CALL	xosconEchChr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Number of characters output this time (always 1)

xosconEchChr::
	CALL	xosconDspChr		;Display the character
	CLRL	EAX			;Get return value (always 1)
	INCL	EAX
	MOVL	EBX, tdb_ddisp.B[ESI]	;Update cursor on screen
	JMPIL	CS:tf_dspcur[EBX]	;And return
.PAGE
	.SBTTL	conDspChr - Subroutine to display single character

;Subroutine to display single character
;	c(AL)  = Character
;	c{ESI} = Offset of TDB for console
;	CALL	conDspChr

xosconDspChr::
	CMPB	AL, #ESC		;Is this ESC?
	JE	2$.S			;Yes - go handle that
	JMPIL	tdb_escdsp.B[ESI]	;No - dispatch on current ESC state

;Here if this character is ESC

2$:	MOVL	tdb_escdsp.B[ESI], #escchr1 ;Set dispatch for next time
	MOVB	tdb_escpnt.B[ESI], #0	;Point to first argument
	MOVL	tdb_escarg.B[ESI], #0	;Clear all arguments
	ANDB	tdb_stsansi.B[ESI], #~TSA$ESCMOD
4$:	RET				;Thats all

;Here with first character after ESC

escchr1:MOVL	EDX, EDI
	MOVL	EDI, #esc1tbl
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #ESC1TSZ
	CLD
	RNSCASB	[EDI]			;Search for character
	XCHGL	EDX, EDI
	JNE	6$.S			;If not found
	SUBL	EDX, #esc1tbl+1		;Found
	JMPIL	esc1dsp[EDX*4]		;Dispatch on character

6$:	CMPB	AL, #'@'		;Noise character?
	JB	4$.S			;Yes - ignore it
	JMP	escdone			;No - finished here

	.MACRO	" ECC
	EC	{[}, esccsi	;CSI
	EC	{(}, escdefg0	;Define G0 character set
	EC	{)}, escdefg1	;Define G1 character set
	EC	{=}, esckpam	;Set to application keypad mode
	EC	{>}, esckpnm	;Set to numeric keypad mode
	EC	{7}, escsave	;Save display state
	EC	{8}, escrstr	;Restore display state
	EC	{#}, esclinatr	;Set DEC line attributes
	EC	{M}, escrevindx	;Reverse index
	EC	{Z}, escprida	;Primary DA request (obsolete form)
	.ENDM

	.MACRO	" EC  ltr, address
	.BYTE	'ltr'
	.ENDM

	DATA

esc1tbl:ECC
ESC1TSZ=!$-esc1tbl

	.MACRO	" EC  ltr, address
	.LONG	address
	.ENDM

esc1dsp:ECC

	CODE

;Here if character following ESC is ( - this is a definition for the G0
;  character set

escdefg0:
	MOVL	tdb_escdsp.B[ESI], #escg0chr ;Advance state
	RET				;Thats all for now

;Here if character following ESC is ) - this is a definition for the G1
;  character set

escdefg1:
	MOVL	tdb_escdsp.B[ESI], #escg1chr ;Advance state
	RET				;Thats all for now

;Here if character following ESC is [ - this is the CSI sequence

esccsi:	MOVL	tdb_escdsp.B[ESI], #escchr2 ;Advance state
ret006:	RET				;Finished

;Here if character following ESC is = - this sets the keypad to application
;  mode

esckpam:ORB	tdb_stsansi.B[ESI], #TSA$KPAMOD
	JMP	escdone

;Here if character following ESC is > - this sets the keypad to numeric
;  mode

esckpnm:ANDB	tdb_stsansi.B[ESI], #~TSA$KPAMOD
	JMP	escdone

;Here if character following ESC is 7 - this is a state save request

escsave:MOVW	AX, tdb_tattrval[ESI] ;Save current attribute values
	MOVW	tdb_sattrval[ESI], AX
	MOVZBL	EBX, tdb_dsppage[ESI] ;Get current page number
	MOVW	AX, tdb_curpos.B[ESI+EBX*2] ;Save cursor position
;qqqqqqqq
	MOVW	tdb_scurpos[ESI], AX
	JMP	escdone

;Here if character following ESC is 8 - this is a state restore request

escrstr:MOVZWL	EAX, tdb_sattrval[ESI]	;Get saved attribute values
	TESTL	EAX, EAX		;Were any saved?
	JE	10$.S			;No - do nothing!
	MOVW	tdb_tattrval[ESI], AX	;Yes
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	MOVW	AX, tdb_scurpos[ESI]	;Restore cursor position
;qqqqqqqq
	MOVW	tdb_curpos.B[ESI+EBX*2], AX
10$:	JMP	escdone

;Here if character following ESC is # - this is the DEC set line attributes
;  request - we cannot handle DEC line attributes but we do quietly ignore
;  the ESC-#-5 command which is the set line attributes to normal command

esclinatr:
	MOVL	tdb_escdsp.B[ESI], #esclachr ;Advance state
	RET
.PAGE
;Here if character following ESC is M - this is a reverse index function.  Its
;  basically a backwards line-feed, including scrolling the screen if already
;  at the top.

escrevindx:
	MOVL	tdb_escdsp.B[ESI], #xosconDspNrm ;Reset ESC state dispatch to
						 ;  normal
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	TESTB	tdb_stsinp.B[ESI], #TSI$PASTEND ;Past end of line now?
	JE	2$.S			;No
	MOVB	tdb_curpos+0.B[ESI+EBX*2], #0 ;Yes - just reset to beginning
	ANDB	tdb_stsinp.B[ESI], #~TSI$PASTEND
	RET

;Here if not past end of current line

2$:	MOVB	AL, tdb_curpos+1.B[ESI+EBX*2] ;On first line now?
	INCL	EAX
	CMPB	AL, tdb_scntop.B[ESI]
	JBE	6$.S			;Yes
4$:	DECB	tdb_curpos+1.B[ESI+EBX*2] ;No - just move up a line
	RET

;Here if now on first line of scrolling region (or above)

6$:	JNE	8$.S			;If above scrolling region
	MOVB	CL, #0			;Scroll scrolling region down 1 line
	MOVB	CH, tdb_scntop.B[ESI]
	DECB	CH
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	MOVB	DH, tdb_scnbtm.B[ESI]
	DECB	DH
	MOVB	BH, #1
	MOVB	AL, #1			;Function = scroll down
conscroll::
	PUSHL	EAX
	MOVL	EAX, tdb_ddisp.B[ESI]
	MOVL	EAX, CS:tf_scroll.B[EAX]
	XCHGL	EAX, [ESP]
	RET

;Here if above scrolling region

8$:	CMPB	AL, #0			;At top of physical screen?
	JB	4$.S			;No - just move up a line
	RET				;Yes - do nothing! (NEED TO SEE IF THIS
					;  IS RIGHT!!!)
.PAGE
;Here with character following ESC-( - this character specifies the character
;  set to map to the G0 character space

escg0chr:
	LEAL	EDX, tdb_chrsetG0.B[ESI]
	JMP	4$.S

;Here with character following ESC-) - this character specifies the character
;  set to map to the G1 character space

escg1chr:
	LEAL	EDX, tdb_chrsetG1.B[ESI]
4$:	CMPB	AL, #'B'		;Want standard characters?
	JNE	6$.S			;No
	MOVB	[EDX], #0		;Yes
	JMP	10$.S

6$:	CMPB	AL, #'0'		;DEC special graphic characters?
	JNE	12$.S			;No
	MOVB	[EDX], #CHRX_SGS	;Yes
10$:	BTSL	tdb_omode.B[ESI], #TOM%ANSICM ;Enable ANSI character mapping
12$:	JMP	escdone			;Finished

;Here with character following ESC-# - This is the DEC set line attributes
;  command - we cannot support DEC line attributes so we just ignore this

esclachr:
	JMP	escdone
.PAGE
;Here with character following ESC-[

escchr2:CMPB	AL, #'?'		;Special prefix?
	JNE	2$.S			;No
	ORB	tdb_stsansi.B[ESI], #TSA$ESCMOD ;Yes - remember we have this
	RET				;Thats all

2$:	CMPB	AL, #';'		;Argument separator?
	JE	6$.S			;Yes
	CMPB	AL, #'0'		;No - digit?
	JB	10$.S			;No
	CMPB	AL, #'9'		;Maybe
	JA	10$.S			;No
	ANDB	AL, #0F			;Yes - get value
	PUSHL	EAX
	MOVZBL	EBX, tdb_escpnt.B[ESI]	;Get argument pointer
	MOVZBL	EAX, tdb_escarg.B[ESI+EBX] ;Get current argument value
	IMULL	EAX, #10t.B		;Times 10
	MOVB	tdb_escarg.B[ESI+EBX], AL
	POPL	EAX
	ADDB	tdb_escarg.B[ESI+EBX], AL ;Add in value of this digit
4$:	RET				;Thats all

;Here with semi-colon (argument separator)

6$:	CMPB	tdb_escpnt.B[ESI], #3	;Too many arguments?
	JAE	4$.S			;Yes - ignore this
	INCB	tdb_escpnt.B[ESI]	;No - bump to next argument
	RET

;Here with non-numeric character

10$:	CMPB	AL, #'@'		;Noise character?
	JB	4$.S			;Yes - ignore it
	TESTB	tdb_stsansi.B[ESI], #TSA$ESCMOD ;No - have modifier?
	JNE	escdone			;Yes - ignore it for now!!!
	MOVL	EDX, EDI		;No
	MOVL	EDI, #escctbl
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #ESCCTSZ
	CLD
	RNSCASB	[EDI]			;Search for character
	XCHGL	EDX, EDI
	JNE	escdone			;If not found
	SUBL	EDX, #escctbl+1		;Found
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	CMPL	EDX, #FIXCURLMT.B	;Should we do cursor position fixup now?
	JAE	12$.S			;No
	TESTB	tdb_stsinp.B[ESI], #TSI$PASTEND ;Yes - is cursor past end of
						;  line?
	JE	12$.S			;No
	MOVB	tdb_curpos+0.B[ESI+EBX*2], #0	 ;Yes - put cursor at beginning
	ANDB	tdb_stsinp.B[ESI], #~TSI$PASTEND ;  of next line
	PUSHL	EDX
	CALL	downln
	POPL	EDX
12$:	JMPIL	esccdsp[EDX*4]		;Dispatch on character

	.MACRO	" ECC
	EC	B, esccurdown	;Cursor down
	EC	C, esccurrght	;Cursor right
	EC	K, esclinclr	;Clear line
	EC	J, escscnclr	;Clear screen
	EC	L, esclinins	;Insert line(s)
	EC	M, esclindel	;Delete line(s)
	EC	P, escchrdel	;Delete character(s)
	EC	@, escchrins	;Insert character(s)
	EC	n, escstsreq	;Request terminal status
	EC	s, escsave	;Save cursor position and attributes
.IF NDF FIXCURLMT  FIXCURLMT=!$-escctbl ;All functions above here require
					;  cursor fixup if the cursor is
					;  past the end of the line
	EC	A, esccurup	;Cursor up
	EC	D, esccurleft	;Cursor left
	EC	H, esccurpos	;Set cursor position
	EC	c, escprida	;Primary DA request
	EC	f, esccurpos	;Set cursor position
	EC	h, escmodeset	;Mode set
	EC	l, escmodeclr	;Mode clear
	EC	m, escattrib	;Set attributes
	EC	r, escregion	;Set scrolling region
	EC	u, escrstr	;Restore cursor position and attributes
	EC	v, esccurmode	;Set cursor mode
	.ENDM

	.MACRO	" EC  ltr, address
	.BYTE	'ltr'
	.ENDM

	DATA

escctbl:ECC
ESCCTSZ=!$-escctbl

	.MACRO	" EC  ltr, address
	.LONG	address
	.ENDM

esccdsp:ECC

	CODE
.PAGE
;Here with cursor up command

esccurup:
	TESTB	tdb_stsinp.B[ESI], #TSI$PASTEND ;Past end of line?
	JE	1$.S			;No
	MOVB	tdb_curpos+0.B[ESI+EBX*2], #0	 ;Yes - just reset to beginning
	ANDB	tdb_stsinp.B[ESI], #~TSI$PASTEND ;  of line
	JMP	escdone

1$:	MOVB	AH, tdb_escarg.B[ESI]	;Get argument value
	TESTB	AH, AH			;0 value?
	JNE	2$.S			;No
	INCB	AH			;Yes - make it 1
2$:	CMPB	tdb_curpos+1.B[ESI+EBX*2], AH ;Trying to go too far?
	JBE	4$.S			;Yes
	SUBB	tdb_curpos+1.B[ESI+EBX*2], AH ;No - store new position
	JMP	escdone.S

4$:	MOVB	tdb_curpos+1.B[ESI+EBX*2], #0
	JMP	escdone.S

;Here with cursor down command

esccurdown:
	MOVB	AH, tdb_escarg.B[ESI]	;Get argument value
	TESTB	AH, AH			;0 value?
	JNE	6$.S			;No
	INCB	AH			;Yes - make it 1
6$:	MOVB	AL, tdb_rows[ESI]	;Get height of screen
	ADDB	tdb_curpos+1.B[ESI+EBX*2], AH
	JC	8$.S
	CMPB	tdb_curpos+1.B[ESI+EBX*2], AL
	JB	escdone.S
8$:	DECB	AL
	MOVB	tdb_curpos+1.B[ESI+EBX*2], AL
	JMP	escdone.S

;Here with cursor left command

esccurleft:
	TESTB	tdb_stsinp.B[ESI], #TSI$PASTEND ;Past end of line?
	JE	9$.S			;No
	ANDB	tdb_stsinp.B[ESI], #~TSI$PASTEND ;Yes - but not now
	RET

9$:	MOVB	AH, tdb_escarg.B[ESI]	;Get argument value
	TESTB	AH, AH			;0 value?
	JNE	10$.S			;No
	INCB	AH			;Yes - make it 1
10$:	CMPB	tdb_curpos+0.B[ESI+EBX*2], AH ;Too much?
	JBE	12$.S
	SUBB	tdb_curpos+0.B[ESI+EBX*2], AH ;No
	JMP	escdone.S

12$:	MOVB	tdb_curpos+0.B[ESI+EBX*2], #0
	JMP	escdone.S

;Here with cursor right command

esccurrght:
	MOVB	AH, tdb_escarg.B[ESI]	;Get argument value
	TESTB	AH, AH			;0 value?
	JNE	14$.S			;No
	INCB	AH			;Yes - make it 1
14$:	MOVB	AL, tdb_columns[ESI]	;Get width of screen
	ADDB	tdb_curpos+0.B[ESI+EBX*2], AH
	JC	6$.S
	CMPB	tdb_curpos+0.B[ESI+EBX*2], AL
	JB	escdone.S
16$:	DECB	AL
	MOVB	tdb_curpos+0.B[ESI], AL
escdone:MOVL	tdb_escdsp.B[ESI], #xosconDspNrm ;Reset ESC state dispatch to
						 ;  normal
	RET				;Thats all
.PAGE
;Here with primary DA request

escprida:
	PUSHL	EBX
	MOVL	EAX, #KB$IMAGE+ESC
	CALL	knlTrmInp##
	MOVL	EAX, #KB$IMAGE+'['
	CALL	knlTrmInp##
	MOVL	EAX, #KB$IMAGE+'?'
	CALL	knlTrmInp##
	MOVL	EAX, #KB$IMAGE+'6'
	CALL	knlTrmInp##
	MOVL	EAX, #KB$IMAGE+'0'
	ADDB	AL, tdb_response+3.B[ESI]
	CALL	knlTrmInp##
	MOVL	EDX, tdb_response.B[ESI]
	ANDL	EDX, #0FFFFFFh
	CLRL	EAX
2$:	TESTL	EDX, EDX
	JE	8$.S
4$:	INCL	EAX
	SHRL	EDX, #1
	JNC	2$.S
	PUSHL	EDX
	PUSHL	EAX
	CLRL	EDX
	IDIVL	lit10
	TESTL	EAX, EAX
	JE	6$.S
	ADDL	EAX, #KB$IMAGE+'0'
	PUSHL	EDX
	CALL	knlTrmInp##
	POPL	EDX
6$:	LEAL	EAX, KB$IMAGE+'0'[EDX]
	CALL	knlTrmInp##
	POPL	EAX
	POPL	EDX
	TESTL	EDX, EDX
	JE	8$.S
	MOVL	EAX, #KB$IMAGE+';'
	CALL	knlTrmInp##
	JMP	4$.S

8$:	MOVL	EAX, #KB$IMAGE+'c'
	CALL	knlTrmInp##
	POPL	EBX
	JMP	escdone
.PAGE
;Here with cursor position command

esccurpos:
	MOVB	AL, tdb_escarg+0.B[ESI]	;Get first argument
	TESTB	AL, AL
	JE	2$.S
	DECB	AL
2$:	CMPB	AL, tdb_rows[ESI]
	JB	4$.S
	MOVB	AL, tdb_rows[ESI]
	DECB	AL
4$:	MOVB	tdb_curpos+1.B[ESI+EBX*2], AL
	MOVB	AL, tdb_escarg+1.B[ESI]	;Get second argument
	TESTB	AL, AL
	JE	6$.S
	DECB	AL
6$:	CMPB	AL, tdb_columns[ESI]
	JB	8$.S
	MOVB	AL, tdb_columns[ESI]
	DECB	AL
8$:	MOVB	tdb_curpos+0.B[ESI+EBX*2], AL
	ANDB	tdb_stsinp.B[ESI], #~TSI$PASTEND
	JMP	escdone
.PAGE
;Here with insert line command

esclinins:
	MOVB	AL, #1			;Function = scroll down
	JMP	2$.S

;Here with delete line command

esclindel:
	MOVB	AL, #0			;Function = scroll up
2$:	PUSHL	EBX
	MOVB	tdb_curpos+0.B[ESI+EBX*2], #0 ;Set cursor to beginning of line
	MOVW	CX, tdb_curpos.B[ESI+EBX*2] ;Get upper left corner of region
	MOVB	DL, tdb_columns[ESI]	    ;  to scroll
	DECL	EDX			;Get lower right corner
	MOVB	DH, tdb_scnbtm.B[ESI]
	DECB	DH
	JMP	6$.S			;Continue

;Here with character delete command

escchrdel:
	MOVB	AL, #3			;Function = scroll left
	JMP	4$.S

;Here with the character insert command

escchrins:
	MOVB	AL, #2			;Function = scroll right
4$:	PUSHL	EBX
	MOVW	CX, tdb_curpos+0.B[ESI+EBX*2]
	MOVB	DL, tdb_columns[ESI]
	DECL	EDX
	MOVB	DH, CH
6$:	MOVB	BH, tdb_escarg.B[ESI]	;Get first argument (number to delete)
	CMPB	BH, #0
	JNE	8$.S
	MOVB	BH, #1
8$:	CALL	conscroll
	POPL	EBX
	JMP	escdone
.PAGE
;Here with line clear command

esclinclr:
	MOVB	AL, tdb_escarg.B[ESI]	;Get first argument
	TESTB	AL, AL
	JS	escdone
	DECB	AL			;Clear from cursor to end of line?
	JNS	4$.S			;No
2$:	MOVW	CX, tdb_curpos.B[ESI+EBX*2] ;Yes
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	MOVB	DH, CH
	JMP	esclin2.S

;Here if function is not clear from cursor to end of line

4$:	JNE	10$.S			;Clear from beginning of line to
					;  cursor?
	MOVW	DX, tdb_curpos.B[ESI+EBX*2] ;Yes
	MOVB	CL, #0
	MOVB	CH, DH
esclin2:MOVB	AL, #0
	CALL	conscroll		;Clear the line
	JMP	escdone

;Here if function is clear entire line

10$:	MOVB	tdb_curpos+0.B[ESI+EBX*2], #0 ;Set cursor to beginning of line
	JMP	2$.S
.PAGE
;Here with screen clear command
;	ESC[0J - Erase from cursor to end of display
;	ESC[1J - Erase from beginning of display to cursor
;	ESC[2J - Erase entire display (home cursor)

escscnclr:
	MOVB	AL, tdb_escarg.B[ESI]	;Get first argument
	TESTB	AL, AL
	JS	escdone
	DECB	AL			;Erase from cursor to end of display?
	JNS	6$.S			;No
	MOVW	CX, tdb_curpos.B[ESI+EBX*2] ;Yes - get position
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	CMPB	CL, DL			;At end of line now?
	JAE	2$.S			;Yes
	MOVB	DH, CH			;No - clear to end of line
	MOVB	AL, #0
	CALL	conscroll
	MOVZBL	EBX, tdb_dsppage[ESI]
2$:	MOVB	CH, tdb_curpos+1.B[ESI+EBX*2] ;Now clear everything below the
	MOVB	DH, tdb_rows[ESI]	      ;  line
	DECB	DH
	CMPB	CH, DH			;At bottom now?
	JAE	escdone			;Yes - finished
	MOVB	CL, #0			;No
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	JMP	esclin2.S

;Here if do not want to clear bottom part of screen

6$:	DECB	AL			;Erase from beginning to cursor?
	JNS	12$.S			;No
	MOVW	DX, tdb_curpos.B[ESI+EBX*2] ;Yes - get position
	CMPB	DL, #0			;At beginning of line now?
	JE	8$.S			;Yes
	MOVB	CL, #0			;No - clear beginning of line
	MOVB	CH, DH
	MOVB	AL, #0
	CALL	conscroll
	MOVZBL	EBX, tdb_dsppage[ESI]
8$:	MOVB	DH, tdb_curpos+1.B[ESI+EBX*2] ;Clear everything above the line
	CMPB	DH, #0			;At top now?
	JE	escdone			;Yes - finished
	MOVB	DL, tdb_columns[ESI]	;No
	CLRL	ECX
	JMP	esclin2

;Here if do not want to clear top part of screen

12$:	DECB	AL			;Erase entire display?
	JNS	escdone			;No - ignore this
	MOVW	tdb_curpos.B[ESI+EBX*2], #0 ;Yes - set cursor to home position
	CLRL	ECX
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	MOVB	DH, tdb_rows[ESI]
	DECB	DH
	JMP	esclin2
.PAGE
;Here with terminal status request command

escstsreq:
	CMPB	tdb_escarg+0.B[ESI], #6	;Argument must be 6 for position
	JNE	escdone			;  request
	MOVL	EBX, tdb_irsize[ESI]	;Do we have room for at least 10
	SUBL	EBX, #10t.B		;  characters?
	CMPL	tdb_ircnt[ESI], EBX
	JAE	6$.S			;No - forget about this!
	MOVL	EAX, #80000000+ESC
	CALL	knlTrmStrChr##
	MOVB	AL, #'['
	CALL	knlTrmStrChr##
	MOVL	EBX, tdb_vert[ESI]
	INCL	EBX
	CALL	escputval
	MOVB	AL, #';'
	CALL	knlTrmStrChr##
	MOVL	EBX, tdb_horiz[ESI]
	INCL	EBX
	CALL	escputval
	MOVB	AL, #'R'
	CALL	knlTrmStrChr##
6$:	JMP	escdone

;Subroutine to place decimal value into the terminal input buffer
;	c{EAX} = Value
;	CALL	escputval

escputval:
	CLRL	EDX
	DIVL	lit10			;Get next digit value
	PUSHL	EDX			;Stack it
	TESTL	EAX, EAX		;More to get?
	JE	10$.S			;No
	CALL	escputval		;Yes - recur
10$:	POPL	EAX			;Get digit value
	ADDL	EAX, #80000000+'0'	;Convert to ASCII value for our buffer
	JMP	knlTrmStrChr##		;Store character in input buffer
.PAGE
;Here with mode set command

escmodeset:
	CLRL	EDX
2$:	MOVZBL	EAX, tdb_escarg.B[ESI+EDX] ;Get argument value
	CMPL	EAX, #ESCMSMAX.B	;Legal value?
	JA	4$.S			;No - ignore it
	CALLI	escmsdsp[EAX*4]		;Yes - dispatch on the argument
4$:	INCL	EDX			;Bump argument pointer
	CMPB	DL, tdb_escpnt.B[ESI]	;More arguments?
	JBE	2$.S			;Yes
	JMP	escdone			;No - all finished

	DATA

escmsdsp:
	.LONG	ret006		;      =  0
	.LONG	ret006		; GATM =  1 - Guarded area transfer
	.LONG	ret006		; KAM  =  2 - Keyboard action
	.LONG	ret006		; CRM  =  3 - Control representation
	.LONG	insmodeset	; IRM  =  4 - Insert/replace mode
	.LONG	ret006		;      =  5
	.LONG	ret006		; ERM  =  6 - Erasure
	.LONG	chrwrapset	;      =  7 - Enable character wrap
	.LONG	ret006		;      =  8
	.LONG	ret006		;      =  9
	.LONG	ret006		; HEM  = 10 - Horizontal editing
	.LONG	ret006		;      = 11
	.LONG	ret006		; SRM  = 12 - Send/receive
	.LONG	ret006		;      = 13
	.LONG	ret006		;      = 14
	.LONG	ret006		; MATM = 15 - Multiple area transfer
	.LONG	ret006		; TTM  = 16 - Transmit termination
	.LONG	ret006		; SATM = 17 - Selected area transfer
	.LONG	ret006		;      = 18
	.LONG	ret006		;      = 19
	.LONG	ret006		; LNM  = 20 - Line feed/new line
ESCMSMAX=!{$-escmsdsp}/4-1

	CODE
.PAGE
;Here for the enable insert mode command (<ESC>[4h)

insmodeset:
	ORB	tdb_stsinp.B[ESI], #TSI$INSERT
	RET

;Here for the enable character wrap command (<ESC>[7h)

chrwrapset:
	ANDB	tdb_stsout.B[ESI], #{~TSO$NOWRAP}&0FFh
	RET
.PAGE
;Here with mode clear command

escmodeclr:
	CLRL	EDX
2$:	MOVZBL	EAX, tdb_escarg.B[ESI+EDX] ;Get argument value
	CMPL	EAX, #ESCMCMAX.B	;Legal value?
	JA	4$.S			;No - ignore it
	CALLI	escmcdsp[EAX*4]		;Yes - dispatch on the argument
4$:	INCL	EDX			;Bump argument pointer
	CMPB	DL, tdb_escpnt.B[ESI]	;More arguments?
	JBE	2$.S			;Yes
	JMP	escdone			;No - all finished

	DATA

escmcdsp:
	.LONG	ret006		;      =  0
	.LONG	ret006		; GATM =  1 - Guarded area transfer
	.LONG	ret006		; KAM  =  2 - Keyboard action
	.LONG	ret006		; CRM  =  3 - Control representation
	.LONG	insmodeclr	; IRM  =  4 - Insert/replace mode
	.LONG	ret006		;      =  5
	.LONG	ret006		; ERM  =  6 - Erasure
	.LONG	chrwrapclr	;      =  7 - Enable character wrap
	.LONG	ret006		;      =  8
	.LONG	ret006		;      =  9
	.LONG	ret006		; HEM  = 10 - Horizontal editing
	.LONG	ret006		;      = 11
	.LONG	ret006		; SRM  = 12 - Send/receive
	.LONG	ret006		;      = 13
	.LONG	ret006		;      = 14
	.LONG	ret006		; MATM = 15 - Multiple area transfer
	.LONG	ret006		; TTM  = 16 - Transmit termination
	.LONG	ret006		; SATM = 17 - Selected area transfer
	.LONG	ret006		;      = 18
	.LONG	ret006		;      = 19
	.LONG	ret006		; LNM  = 20 - Line feed/new line
ESCMCMAX=!{$-escmcdsp}/4-1

	CODE
.PAGE
;Here for the disable insert mode command (<ESC>[4l)

insmodeclr:
	ANDB	tdb_stsinp.B[ESI], #~TSI$INSERT
	RET

;Here for the disable character wrap command (<ESC>[7l)

chrwrapclr:
	ORB	tdb_stsout+1.B[ESI], #TSO$NOWRAP>8
	RET
.PAGE
;Here with set scrolling region command (<ESC>[t;br)

escregion:
	MOVL	EAX, tdb_escarg+0.B[ESI] ;Get argument values
	CMPB	AL, #0			;First argument given?
	JNE	2$.S			;Yes
	MOVB	AL, #1			;No - assume first line
2$:	CMPB	AH, #0			;Second argument given?
	JE	4$.S			;No
	CMPB	AH, tdb_rows[ESI]	;Yes - is in within range?
	JBE	6$.S			;Yes
4$:	MOVB	AH, tdb_rows[ESI]	;No - set to bottom of screen
6$:	MOVW	tdb_scntop.B[ESI], AX	;Store top and bottom values
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	MOVW	tdb_curpos.B[ESI+EBX*2], #0 ;Reset cursor to home position
	JMP	escdone			;Thats all
.PAGE
;Here with set cursor mode command

esccurmode:
	CLRL	EDX
2$:	MOVZBL	EAX, tdb_escarg.B[ESI+EDX] ;Get argument value
	CMPL	EAX, #ESCCMMAX.B	;Legal value?
	JA	4$.S			;No - ignore it
	CALLI	esccmdsp[EAX*4]		;Yes - dispatch on the argument
4$:	INCL	EDX			;Bump argument pointer
	CMPB	DL, tdb_escpnt.B[ESI]	;More arguments?
	JBE	2$.S			;Yes
	JMP	escdone			;No - all finished

	DATA

esccmdsp:
	.LONG	concurvis	; 0 - Make cursor visible
	.LONG	concurinv	; 1 - Make cursor invisible
	.LONG	esccurund	; 2 - Change to underline cursor
	.LONG	esccurblk	; 3 - Change to block cursor
	.LONG	ret006		; 4 - Make cursor non-blinking
	.LONG	ret006		; 5 - Make cursor blinking
ESCCMMAX=!{$-esccmdsp}/4-1

	CODE
.PAGE
;Here for the make cursor invisible command (<ESC>[0v)

concurinv:
	MOVZWL	ECX, tdb_curmode[ESI]
	ORB	CH, #20h
	JMP	8$.S

;Here for the make cursor visible command (<ESC>[1v)

concurvis:
	MOVZWL	ECX, tdb_curmode[ESI]
	ANDB	CH, #~20h
	JMP	8$.S

;Here for the change to underline cursor command (<ESC>[2v)

esccurund:
	MOVB	CH, tdb_curmode+1[ESI]
	ANDB	CH, #20h
	ORB	CH, #06h
	JMP	6$.S

;Here for the change to block cursor command (<ESC>[3v)

esccurblk:
	MOVB	CH, tdb_curmode+1[ESI]
	ANDB	CH, #20h
6$:	MOVB	CL, #07h
8$:	PUSHL	EDX
	MOVL	EAX, tdb_ddisp.B[ESI]
	CALLI	CS:tf_curtype.B[EAX]	;Go set cursor type
	POPL	EDX
	RET
.PAGE
;Here with set attributes command

escattrib::
	CLRL	EDX
2$:	MOVZBL	EAX, tdb_escarg.B[ESI+EDX] ;Get argument value
	CMPL	EAX, #ESCATMAX.B	;Legal value?
	JA	4$.S			;No - ignore it
	CALLI	escatdsp[EAX*4]		;Yes - dispatch on the argument
4$:	INCL	EDX			;Bump argument pointer
	CMPB	DL, tdb_escpnt.B[ESI]	;More arguments?
	JBE	2$.S			;Yes
	JMP	escdone			;No - all finished

	DATA

escatdsp:
	.LONG	escatoff	; 0 - All attributes off
	.LONG	escatbold	; 1 - Set bold on
	.LONG	escatnorm	; 2 - Set bold off
	.LONG	ret006		; 3 - Illegal
	.LONG	escatulon	; 4 - Underline on
	.LONG	escatblinkon	; 5 - Blink on
	.LONG	ret006		; 6 - Illegal
	.LONG	escatrevon	; 7 - Reverse video on
	.LONG	escatcon	; 8 - Concealed
	.LONG	ret006		; 9 - Illegal
	.LONG	ret006		;10 - Illegal
	.LONG	ret006		;11 - Illegal
	.LONG	ret006		;12 - Illegal
	.LONG	ret006		;13 - Illegal
	.LONG	ret006		;14 - Illegal
	.LONG	ret006		;15 - Illegal
	.LONG	ret006		;16 - Illegal
	.LONG	ret006		;17 - Illegal
	.LONG	ret006		;18 - Illegal
	.LONG	ret006		;19 - Illegal
	.LONG	ret006		;20 - Illegal
	.LONG	ret006		;21 - Illegal
	.LONG	escatnorm	;22 - Set bold off
	.LONG	ret006		;23 - Illegal
	.LONG	escatuloff	;24 - Underline off
	.LONG	escatblinkoff	;25 - Blink off
	.LONG	ret006		;26 - Illegal
	.LONG	escatrevoff	;27 - Reverse video off
	.LONG	ret006		;28 - Illegal
	.LONG	ret006		;29 - Illegal
	.LONG	escatfblack	;30 - Set foreground to black
	.LONG	escatfred	;31 - Set foreground to red
	.LONG	escatfgreen	;32 - Set foreground to green
	.LONG	escatfyellow	;33 - Set foreground to yellow
	.LONG	escatfblue	;34 - Set foreground to blue
	.LONG	escatfmagenta	;35 - Set foreground to magenta
	.LONG	escatfcyan	;36 - Set foreground to cyan
	.LONG	escatfwhite	;37 - Set foreground to white
	.LONG	ret006		;38 - Illegal
	.LONG	ret006		;39 - Illegal
	.LONG	escatbblack	;40 - Set background to black
	.LONG	escatbred	;41 - Set background to red
	.LONG	escatbgreen	;42 - Set background to green
	.LONG	escatbyellow	;43 - Set background to yellow
	.LONG	escatbblue	;44 - Set background to blue
	.LONG	escatbmagenta	;45 - Set background to magenta
	.LONG	escatbcyan	;46 - Set background to cyan
	.LONG	escatbwhite	;47 - Set background to white
ESCATMAX=!{$-escatdsp}/4-1

	CODE
.PAGE
;Here for ESC[0m - All attributes off

escatoff:
	MOVW	AX, tdb_battrval[ESI]
	MOVW	tdb_tattrval[ESI], AX
	RET

;Here for ESC[1m - Set bold on

escatbold:
	ORB	tdb_tattrval[ESI], #08h	;Set bold bit
	ORB	tdb_tattrfil[ESI], #08h
	RET

;Here for ESC[2m - Set bold off

escatnorm:
	ANDB	tdb_tattrval[ESI], #0F7h ;Clear bold bit
	ANDB	tdb_tattrfil[ESI], #0F7h
	RET

;Here for ESC[4m - Set underline on

escatulon:
	NOP
	RET

;Here for ESC[24m - Set underline off

escatuloff:
	NOP
	RET

;Here for ESC[5m - Set blink on

escatblinkon:
	ORB	tdb_tattrval[ESI], #80h ;Set blink bit
	ORB	tdb_tattrfil[ESI], #80h
	RET

;Here for ESC[25m - Set blink off

escatblinkoff:
	ANDB	tdb_tattrval[ESI], #7Fh	;Clear blink bit
	ANDB	tdb_tattrfil[ESI], #7Fh
	RET

;Here for ESC[7m - Set reverse video

escatrevon:
	MOVB	AL, tdb_battrval[ESI]
	MOVB	AH, tdb_tattrval[ESI]
	ANDB	AH, #88h
	ANDB	AL, #77h
	RORB	AL, #4t
	ORB	AL, AH
	MOVB	tdb_tattrval[ESI], AL
;;;;;;	MOVB	AL, tdb_battrfil[ESI]
;;;;;;	MOVB	AH, AL
;;;;;;	ANDB	AH, #88h
;;;;;;	ANDB	AL, #77h
;;;;;;	RORB	AL, #4t
;;;;;;	ORB	AL, AH
;;;;;;	MOVB	tdb_tattrfil[ESI], AL
	RET

;Here for ESC[27m - Clear reverse video

escatrevoff:
	MOVW	AX, tdb_battrval[ESI]
	ANDW	AX, #7777h
	ANDW	tdb_tattrval[ESI], #8888h
	ORW	tdb_tattrval[ESI], AX
	RET

;Here for ESC[8m - Set concealed text

escatcon:
	MOVB	AL, tdb_battrval[ESI]	;Yes - set both foreground and background
	MOVB	AH, AL			;  to the background color
	ANDB	AL, #0F8h
	SHRB	AH, #4t
	ANDB	AH, #07h
	ORB	AL, AH
	MOVB	tdb_tattrval[ESI], AL
6$:	RET

;Here for ESC[30m - Set foreground to black

escatfblack:
	MOVB	AL, #0
	JMP	8$.S

;Here for ESC[31m - Set foreground to red

escatfred:
	MOVB	AL, #4
	JMP	8$.S

;Here for ESC[32m - Set foreground to green

escatfgreen:
	MOVB	AL, #2
	JMP	8$.S

;Here for ESC[33m - Set foreground to yellow (really brown!)

escatfyellow:
	MOVB	AL, #6
	JMP	8$.S

;Here for ESC[34m - Set foreground to blue

escatfblue:
	MOVB	AL, #1
	JMP	8$.S

;Here for ESC[35m - Set foreground to magenta

escatfmagenta:
	MOVB	AL, #5
	JMP	8$.S

;Here for ESC[36m - Set foreground to cyan

escatfcyan:
	MOVB	AL, #3
	JMP	8$.S

;Here for ESC[37m - Set foreground to while

escatfwhite:
	MOVB	AL, #7
8$:	ANDB	tdb_tattrval[ESI], #0F8h ;Clear all but bold bit
	ORB	tdb_tattrval[ESI], AL	;Merge in new color value
	ANDB	tdb_tattrfil[ESI], #0F8h
	ORB	tdb_tattrfil[ESI], AL
	RET

;Here for ESC[40m - Set background to black

escatbblack:
	MOVB	AL, #00h
	JMP	10$.S

;Here for ESC[41m - Set background to red

escatbred:
	MOVB	AL, #40h
	JMP	10$.S

;Here for ESC[42m - Set background to green

escatbgreen:
	MOVB	AL, #20h
	JMP	10$.S

;Here for ESC[43m - Set background to yellow (really brown!)

escatbyellow:
	MOVB	AL, #60h
	JMP	10$.S

;Here for ESC[44m - Set background to blue

escatbblue:
	MOVB	AL, #10h
	JMP	10$.S

;Here for ESC[45m - Set background to magenta

escatbmagenta:
	MOVB	AL, #50h
	JMP	10$.S

;Here for ESC[46m - Set background to cyan

escatbcyan:
	MOVB	AL, #30h
	JMP	10$.S

;Here for ESC[47m - Set background to white

escatbwhite:
	MOVB	AL, #70h
10$:	ANDB	tdb_tattrval[ESI], #8Fh	;Clear all but bold bit
	ORB	tdb_tattrval[ESI], AL	;Merge in new color value
	ANDB	tdb_tattrfil[ESI], #8Fh	;Store as fill value also
	ORB	tdb_tattrfil[ESI], AL
	RET
.PAGE
xosconDspNrm::
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	CMPB	AL, #' '		;Printing character?
	JNC	onscrn			;Yes
	MOVZBL	EAX, AL			;No - dispatch on the control character
	JMPIL	ctldsp[EAX*4]

	DATA

ctldsp:	.LONG	ret004		; 00    NUL
	.LONG	notspec		; 01 ^A SOH
	.LONG	notspec		; 02 ^B STX
	.LONG	notspec		; 03 ^C ETX
	.LONG	notspec		; 04 ^D EOT
	.LONG	notspec		; 05 ^E ENQ
	.LONG	notspec		; 06 ^F ACK
	.LONG	ctlbel		; 07 ^G BEL
	.LONG	ctlbs		; 08 ^H BS
	.LONG	ctlht		; 09 ^I HT
	.LONG	downln		; 0A ^J LF
	.LONG	ctlalf		; 0B ^K VT
	.LONG	ctlalf		; 0C ^L FF
	.LONG	ctlcr		; 0D ^M CR
	.LONG	ctlso		; 0E ^N SO
	.LONG	ctlsi		; 0F ^O SI
	.LONG	notspec		; 10 ^P DLE
	.LONG	notspec		; 11 ^Q DC1
	.LONG	notspec		; 12 ^R DC2
	.LONG	notspec		; 13 ^S DC3
	.LONG	notspec		; 14 ^T DC4
	.LONG	notspec		; 15 ^U NAK
	.LONG	notspec		; 16 ^V SYN
	.LONG	notspec		; 17 ^W ETB
	.LONG	notspec		; 18 ^X CAN
	.LONG	notspec		; 19 ^Y EM
	.LONG	notspec		; 1A ^Z SUB
	.LONG	notspec		; 1B ^[ ESC
	.LONG	notspec		; 1C ^\ FS
	.LONG	notspec		; 1D ^] GS
	.LONG	notspec		; 1E ^^ RS
	.LONG	notspec		; 1F ^_ US

	CODE

;Here for non-printing character which is not special

notspec:BTL	tdb_omode.B[ESI], #TOM%ANSICM ;Doing ANSI character mapping?
	JC	4$.S			;Yes - ignore this character
	JMP	onscrn			;No - display the character

;Here if bell character (BEL)

ctlbel:	PUSHL	EAX			;Save character
	MOVZWL	EDX, tdb_spkfreq.B[ESI]	;Get frequency
	MOVZWL	EAX, tdb_spklen.B[ESI]	;Get duration
	MOVL	ECX, tdb_kdisp.B[ESI]	;Beep
	CALLI	CS:kf_beep.B[ECX]
	POPL	EAX
	JC	notspec.S		;Just display character if error
	RET				;Finished

;Here if carriage return character (CR)

ctlcr:	MOVB	tdb_curpos+0.B[ESI+EBX*2], #0 ;Reset position
	ANDB	tdb_stsinp.B[ESI], #~TSI$PASTEND
4$:	RET

;Here if backspace character (BS)

ctlbs:	CMPB	tdb_curpos+0.B[ESI+EBX*2], #0.B ;At beginning of line?
	JE	8$.S			;Yes
	DECB	tdb_curpos+0.B[ESI+EBX*2] ;No - reduce position
	RET				;Thats all

8$:	CMPB	tdb_curpos+1.B[ESI+EBX*2], #0
	JE	10$.S
	DECB	tdb_curpos+1.B[ESI+EBX*2]
10$:	MOVB	AL, tdb_columns[ESI]
	DECB	AL
	MOVB	tdb_curpos+0.B[ESI+EBX*2], AL
	RET

;Here if horizontal tab character (HT)

ctlht:	BTL	tdb_omode.B[ESI], #TOM%ANSICM ;In ANSI mode?
	JC	14$.S			;Yes
12$:	MOVB	AL, #' '		;No - output space
	CALL	onscrn
	TESTB	tdb_curpos+0.B[ESI+EBX*2], #7 ;At tab stop yet?
	JNE	12$.S			;No - continue
	RET				;Yes - finished

;Here if horizontal tab character in ANSI character mapping mode - in this case
;  tabs are transparent and stop at the right side of the screen

14$:	MOVB	AL, tdb_curpos+0.B[ESI+EBX*2]
	ADDB	AL, #8
	ANDB	AL, #0F8h
	MOVB	AH, tdb_columns[ESI]	;Too far right?
	DECB	AH
	CMPB	AH, AL
	JA	16$.S
	MOVB	AL, AH
16$:	MOVB	tdb_curpos+0.B[ESI+EBX*2], AL
	RET

;Here if SO character

ctlso:	BTL	tdb_omode.B[ESI], #TOM%ANSICM ;In ANSI mode?
	JNC	onscrn.S		;No - just display the character
	MOVB	tdb_chrsetGL.B[ESI], #1	;Yes - map G1 into GL
	RET

;Here if SI character

ctlsi:	BTL	tdb_omode.B[ESI], #TOM%ANSICM ;In ANSI mode?
	JNC	onscrn.S		;No - just display the character
	MOVB	tdb_chrsetGL.B[ESI], #0	;Yes - map G0 into GL
	RET

;Here if character which acts like LF in ANSI mode

ctlalf:	BTL	tdb_omode.B[ESI], #TOM%ANSICM ;In ANSI mode?
	JNC	onscrn.S		;No - just display the character
	MOVB	AL, #LF			;Yes - change to LF
	JMP	downln			;And display it
.PAGE
;Here to place character on the screen

onscrn:	TESTB	tdb_stsdsp+1.B[ESI], #TSD$ACTDSP>8 ;Is this the active display?
	JE	4$.S			;No
	MOVL	EDX, tdb_dhdb.B[ESI]	;Yes
	CMPB	dhdb_scsvtype.B[EDX], #0 ;Should this reset the screen saver?
	JNE	4$.S			;No - go on
	MOVL	ECX, dhdb_scsvtime.B[EDX] ;Yes
	JREGZ	ECX, 4$			;If not enabled
	CMPL	dhdb_scsvcnt.B[EDX], #0.B ;Enabled - has it run out?
	MOVL	dhdb_scsvcnt.B[EDX], ECX
	JNE	4$.S			;No - just reset the counter
	PUSHL	EAX			;Yes - enable the screen
	PUSHL	EBX
	MOVL	ECX, tdb_ddisp.B[ESI]
	CALLI	CS:tf_enable.B[ECX]
	POPL	EBX
	POPL	EAX
4$:	TESTB	tdb_stsinp.B[ESI], #TSI$PASTEND ;Need to wrap now?
	JE	6$.S			;No
	ANDB	tdb_stsinp.B[ESI], #~TSI$PASTEND ;Yes
	MOVB	tdb_curpos+0.B[ESI+EBX*2], #0 ;Reset position in line
	PUSHL	EAX			;Save character
	PUSHL	EBX
	CALL	downln			;Move down to next line
	POPL	EBX
	POPL	EAX			;Restore character
6$:	TESTB	tdb_stsinp.B[ESI], #TSI$INSERT ;In insert mode?
	JE	7$.S			;No
	PUSHL	EAX			;Yes
	PUSHL	EBX
	MOVW	CX, tdb_curpos.B[ESI+EBX]
	MOVL	EDX, tdb_columns[ESI]	;Get screen width
	DECL	EDX
	MOVB	DH, CH
	MOVB	BH, #1			;Move 1 position
	MOVB	AL, #2			;Function = scroll right
	CALL	conscroll
	POPL	EBX
	POPL	EAX
7$:	BTL	tdb_omode.B[ESI], #TOM%ANSICM ;Want ANSI character mapping?
	JNC	10$.S			;No
	MOVZBL	ECX, tdb_chrsetGL.B[ESI] ;Yes - assume low character
	TESTB	AL, #80h		;Right?
	JE	8$.S			;Yes
	MOVZBL	ECX, tdb_chrsetGR.B[ESI] ;No - its a high character
8$:	MOVZBL	ECX, tdb_chrsetG0.B[ESI+ECX] ;Get character set index
	TESTL	ECX, ECX		;Want any translation at all?
	JE	10$.S			;No
	MOVL	ECX, chrxtbl#-4[ECX]	;Yes - get address of character table
	ANDL	EAX, #7Fh
	MOVB	AL, [ECX+EAX]		;Get translated display code
10$:	MOVB	AH, tdb_tattrval[ESI]	;Get attribute byte
	MOVW	DX, tdb_curpos.B[ESI+EBX*2] ;Get position
	CALLI	tdb_dspchr.B[ESI]	;Put character on screen
	MOVB	DL, tdb_columns[ESI]	;Too far right now?
	DECL	EDX
	CMPB	DL, tdb_curpos+0.B[ESI+EBX*2]
	JBE	12$.S			;Yes
	INCB	tdb_curpos+0.B[ESI+EBX*2] ;No - bump the position
	RET

;Here if to far right

12$:	TESTB	tdb_stsout+1.B[ESI], #TSO$NOWRAP>8 ;Yes - want line wrap?
	JNE	14$.S			;No
	ORB	tdb_stsinp.B[ESI], #TSI$PASTEND ;Yes
14$:	RET
.PAGE
;Here to move down one line

downln:	MOVB	AL, tdb_curpos+1.B[ESI+EBX*2] ;On last line now?
	INCB	AL
	CMPB	AL, tdb_scnbtm.B[ESI]
	JAE	4$.S			;Yes
2$:	MOVB	tdb_curpos+1.B[ESI+EBX*2], AL ;No - just move down a line
	RET

;Here if now on last line of scrolling region (or below)

4$:	JNE	6$.S			;If below scrolling region
	PUSHL	EBX
	MOVB	CL, #0			;Scroll scrolling region up 1 line
	MOVB	CH, tdb_scntop.B[ESI]
	DECB	CH
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	MOVB	DH, tdb_scnbtm.B[ESI]
	DECB	DH
	MOVB	BH, #1
	MOVB	AL, #0			;Function = scroll up
	CALL	conscroll
	POPL	EBX
	RET

;Here if below scrolling region

6$:	CMPB	AL, tdb_rows[ESI]	;At bottom of physical screen?
	JB	2$.S			;No - just move down a line
	RET				;Yes - do nothing! (NEED TO SEE IF THIS
					;  IS RIGHT!!!)
.PAGE
	.SBTTL	xosconAttrib - Subroutine to get or set display attributes

;Subroutine to get or set display attributes
;	c(AL)     = Function value:
;		      Bit 7 set to change current values
;		      Bit 6 set to return current values
;		      Bits 0-5 specify set of values:
;			1 - Base values
;			2 - Illegal
;			3 - Current values
;	c{ESI}    = Offset of TDB
;	c{ES:EDI} = Address of data block
;	CALL	xosconAttrib
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

;Format of the data block:
;	long foreground; 	// Foreground color
;	long background;	// Background color
;	long forgndfill;	// Foreground fill color
;	long backgndfill;	// Background fill color

xosconAttrib::
	MOVZBL	EBX, AL			;Get function
	ANDL	EBX, #3Fh.B
	CMPB	BL, #3t
	JA	2$.S
	JMPIL	attrdsp[EBX*4]		;Dispatch on the function

;Here if illegal function value

2$:	MOVL	EAX, #ER_FUNC
	STC
	RET

	DATA

attrdsp:.LONG	2$		; 0 = Illegal
	.LONG	settbase	; 1 = Set base values
	.LONG	2$		; 2 = Illegal
	.LONG	settcur		; 3 = Set current values

	CODE

;Here to get or set the base text attribute values

settbase:
	LEAL	EDX, tdb_battrval[ESI]
	JMP	4$.S

;Here to get or set the current text attribute values

settcur:LEAL	EDX, tdb_tattrval[ESI]
4$:	TESTB	AL, #80h		;Want to change values?
	JE	12$.S			;No
	IFFAULT	knlRtnAdrEr##		;Yes
	MOVL	ECX, ES:[EDI]		;Get foreground value
	TESTL	ECX, ECX
	JS	6$.S
	ANDB	CL, #0Fh		;Only 4 bits
	ANDB	[EDX], #0F0h
	ORB	[EDX], CL
	IFFAULT	knlRtnAdrEr##
6$:	MOVL	ECX, ES:4t.B[EDI]	;Get background value
	TESTL	ECX, ECX
	JS	8$.S
	SHLB	CL, #4t
	ANDB	CL, #0F0h
	ANDB	[EDX], #0Fh
	ORB	[EDX], CL
	IFFAULT	knlRtnAdrEr##
8$:	MOVL	ECX, ES:8t.B[EDI]	;Get foreground fill value
	TESTL	ECX, ECX
	JS	10$.S
	ANDB	CL, #0Fh		;Only 4 bits
	ANDB	1.B[EDX], #0F0h
	ORB	1.B[EDX], CL
	IFFAULT	knlRtnAdrEr##
10$:	MOVL	ECX, ES:12t.B[EDI]	;Get background fill value
	TESTL	ECX, ECX
	JS	12$.S
	SHLB	CL, #4t
	ANDB	CL, #0F0h
	ANDB	1.B[EDX], #0Fh
	ORB	1.B[EDX], CL
12$:	TESTB	AL, #40h		;Want values returned?
	JE	14$.S			;No
	MOVZBL	EAX, [EDX]		;Yes - get color values
	MOVL	ECX, EAX
	ANDB	AL, #0Fh		;Get foreground value
	IFFAULT	knlRtnAdrEr##
	STOSL	[EDI]
	MOVL	EAX, ECX
	SHRL	EAX, #4t
	IFFAULT	knlRtnAdrEr##
	STOSL	[EDI]
	MOVB	AL, 1.B[EDX]		;Get attribute fill value
	MOVL	ECX, EAX
	ANDB	AL, #0Fh		;Get foreground fill value
	IFFAULT	knlRtnAdrEr##
	STOSL	[EDI]
	MOVL	EAX, ECX
	SHRL	EAX, #4t
	IFFAULT	knlRtnAdrEr##
	STOSL	[EDI]
14$:	CLRL	EAX
	RET
.PAGE
	.SBTTL	xosconDosUpdCP - Subroutine to update cursor position for real mode

;Subroutine to update cursor position from the DOS real mode page 0 values
;	c{EBX} = Page number
;	c{ESI} = Offset of TDB
;	CALL	xosconDosUpdCP
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c[GS]  = Selector for PDA for process
;	  c{EDX} = Previous cursor positon
;	  Z:set  = No DOS environment
;	  Z:clr  = Have DOS environment

xosconDosUpdCP::
	CMPL	EBX, #8t.B		;Valid page number?
	JAE	10$.S			;No
	MOVZWL	EDX, tdb_curpos[ESI+EBX*2] ;Yes - get current cursor position
	CALL	xosconDosChk		;Is this terminal for a DOS process?
	JE	8$.S			;No
	MOVW	AX, GS:pdaRMPage0##+bda_vcurpos[EBX*2] ;Yes - get position
	CMPB	AL, tdb_columns[ESI]	;Check horizontal position
	JB	4$.S			;If OK
	MOVB	AL, tdb_columns[ESI]	;Too big - fix it
	DECL	EAX
4$:	CMPB	AH, tdb_rows[ESI]	;Check vertical position
	JB	6$.S			;If OK
	MOVB	AH, tdb_rows[ESI]	;Too big - fix it
	DECB	AH
6$:	MOVW	tdb_curpos.B[ESI+EBX*2], AX ;Store new position
	TESTL	ESP, ESP		;Make sure Z is clear
8$:	RET

;Here if have illegal page number

10$:	MOVL	EAX, #ER_VALUE
	STC
	RET
.PAGE
	.SBTTL	xosconDosChk - Subroutine to check for DOS process

;Subroutine to check for DOS process whose page 0 should be updated when
;  terminal parameters are changed, i.e., the current process if it is a DOS
;  process and this is its controlling terminal
;	CALL	xosconDosChk		;Enter at condoschkxf if in extended
;					;  fork context
;	c[GS] = Selector for PDA for process
;	Z:set = No DOS environment
;	Z:clr = Have DOS environment

xosconDosChkXf::
	MOVL	GS, SS:xffPda##
	JMP	2$.S

xosconDosChk::
	MOVL	GS, knlCurPda##		;Get selector for PDA of current process
2$:	TESTB	GS:pdaStatus1##, #P1$DOSSEG ;Is this a DOS process?
	JE	ret010.S		;No - return with Z set
	PUSHL	EAX
	MOVZWL	EAX, GS:pdaHndlTbl##	;Yes - get pointer to device table
	MOVL	EAX, GS:DH_STDTRM*32t[EAX] ;Get offset of DCB for
	CMPL	EAX, #1000h		   ;  controlling terminal
	JB	4$.S
	TESTL	EAX, #0F0000000h
	JNE	4$.S
	CMPL	[ESI], EAX		;Is it this terminal
	JNE	6$.S			;No
	INCL	EAX			;Yes - clear Z
4$:	POPL	EAX
ret010:	RET

;Here if this is not the controlling terminal for the current process

6$:	CLRL	EAX			;Set Z
	POPL	EAX
	RET
.PAGE
	.SBTTL	xosconMapScreen - Function to map screen buffer

;Function to map screen buffer
;	c{ES:EBX} = Address for msect
;	c{ECX}    = Size for msect
;	c{EAX}    = Offset in buffer
;	c{EDI}    = Offset of DCB
;	c{ESI}    = Offset of TCB
;	CALL	xosconMapScreen
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Size of msect

xosconMapScreen::
	PUSHL	EDI
	CMPB	tdb_mode[ESI], #DM_TEXT ;Text mode?
	JNE	2$.S			;No
	MOVL	EDX, #8000h		;Yes - get maximum size for text buffer
	JMP	4$.S

;Here if not text mode

2$:	MOVL	EDX, tdb_gbfrsize[ESI]	;Get maximum size for graphics buffer
4$:	CMPL	ECX, EDX		;Is requested size too big?
	JBE	6$.S			;No
	MOVL	ECX, EDX		;Yes - just use maximum
6$:	PUSHL	EBP

	MOVL	EDX, tdb_ddisp.B[ESI]
	PUSHL	#8$
	PUSHL	CS:tf_mapphys[EDX]
	MOVL	EDX, EBX		;Get user address in right registers
	MOVL	EBP, ES
	MOVB	BL, #PG$WRITE|PG$READ	;Get page type bits
	RET				;This is really a CALLI to the
					;  tf_mapphys routine
8$:	POPL	EBP
	POPL	EDI
	RET				;And return

.PAGE
	.SBTTL	conmapphys - Subroutine to physically map console screen

;Subroutine to physically map console screen
;	c(BL)     = Page bits
;	c{ECX}    = Amount to map
;	c{EAX}    = Offset in buffer
;	c{BP:EDX} = Virtual address
;	C{ESI}    = Offset of TDB
;	CALL	conmapphys
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Size of display buffer

xosconMapPhys::
	PUSHL	ESI			;Save offset of our TDB
	PUSHL	EBX
	MOVL	EBX, tdb_dhdb.B[ESI]
	CMPB	tdb_mode[ESI], #DM_TEXT ;Text mode?
	JNE	2$.S
	ADDL	EAX, dhdb_ptaddr.B[EBX]	;Yes - get physical address of buffer
	JMP	6$.S

;Here if graphics mode

2$:	BTZL	EAX, #31t		;Want to map the register window?
	JNC	4$.S			;No
	ADDL	EAX, dhdb_praddr.B[EBX]	;Yes
	JMP	6$.S

4$:	ADDL	EAX, dhdb_pgaddr.B[EBX]
6$:	MOVL	ESI, EAX		;Get physical address in right register
	POPL	EBX
	MOVL	EDI, #0FFFFFFFFh
	CALL	knlMapPhysMem##		;Map physical memory
	MOVL	EDX, EDI
	POPL	ESI
	JC	10$.S			;If error
	MOVB	mdb_devtype.B[EDX], #1
	ORB	mdb_sts.B[EDX], #MSS$NODEALOC ;Indicate not to deallocate
	MOVL	mdb_remove.B[EDX], #xosconUnmap ;Store offset of subroutine to
						;  call when msect is given up
	ORB	mdb_sts.B[EDX], #MSS$FIXED ;Indicate now fixed size
	MOVL	mdb_devpnt.B[EDX], ESI	;Link TDB to the MDB
	TOFORK
	MOVL	EAX, tdb_mdb.B[ESI]	;Link the MDB into the list of MDBs
	MOVL	tdb_mdb.B[ESI], EDX	;  which map this display
	MOVL	mdb_devnext.B[EDX], EAX
	MOVL	ECX, mdb_size.B[EDX]	;Get number of pages
	PUSHL	ECX			;Save for return value
	CMPB	tdb_mode[ESI], #DM_TEXT ;Text mode?
	JNE	9$.S			;No
	MOVL	EBX, tdb_vtaddr.B[ESI]	  ;Yes - get linear address of exec
					  ;  mapping for buffer
	ADDL	EBX, #la_data		;  for this display
	SHRL	EBX, #10t		;Change to page table index
	MOVL	EDX, mdb_la.B[EDX]	;Get linear address for msect
	SHRL	EDX, #10t		;Change to page table index
8$:	MOVL	EAX, pgtable[EBX]	;Copy page table entries from the exec
	MOVL	pgtable[EDX], EAX	;  mapping to the msect we just set up
	ADDL	EBX, #4.B		;  (We must do this in case this screen
	ADDL	EDX, #4.B		;  has been virtualized - this will
	LOOP	ECX, 8$			;  also handle the case of the screen
9$:	FROMFORK			;  being blocked)
	POPL	EAX			;Restore number of pages
	SHLL	EAX, #12t		;Change to number of bytes (also
10$:	RET				;  clears C)
.PAGE
	.SBTTL	xosconUnmap - Subroutine called when console screen is unmapped

;Subroutine called when msect mapped to console screen is given up - this
;  subroutine is called by the routine which removes msects by dispatching
;  through the mdb_remove item in the MDB
;	c{EDI} = Offset of MDB
;	CALL	xosconUnmap
;	C:clr always
;  Preserves all registers

xosconUnmap::
	PUSHAL				;Save all registers
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	MOVL	ESI, mdb_devpnt.B[EDI]	;Get offset of TDB
	CMPB	tdb_mode[ESI], #DM_TEXT ;Text mode?
	JNE	2$.S			;No
	PUSHL	EDI			;Yes
	MOVL	EDX, EDI		;Get MDB offset where we need it
	CALL	updmsect		;Update page list for the display for
	POPL	EDI			;  this msect
2$:	LEAL	EBX, tdb_mdb-mdb_devnext[ESI] ;Scan through our list of mapped
					      ;  MDBs and find this one
4$:	CMPL	mdb_devnext.B[EBX], #0.B ;Is there another MDB?
	JE	8$.S			;No!
	CMPL	mdb_devnext.B[EBX], EDI	;Yes - is this it?
	JE	6$.S			;Yes
	MOVL	EBX, mdb_devnext.B[EBX]	;No - advance to next
	JMP	4$.S			;Continue

;Here with MDB
;	c{EBX} = Offset of previous MDB in list for device

6$:	MOVL	EAX, mdb_devnext.B[EDI]	;Remove this MDB from the list
	MOVL	mdb_devnext.B[EBX], EAX
	MOVW	mdb_pda.B[EDI], #0
	POPL	GS			;Restore registers
	POPL	FS
	POPL	ES
	POPAL
	RET

;Here if cannot find this MDB in the list of MDBs for the terminal

8$:	CRASH	BDML			;[BaD MDB List]
.PAGE
;Subroutine to scan all msects which map a console screen
;	c{EBX} = Data for subroutine pointed to by ECX
;	c{ECX} = Offset of subroutine to execute for each msect
;	c{EDI} = Data for subroutine pointed to by ECX
;	c{ESI} = Offset of TDB
;	CALL	xosconScanMs

;The subroutine pointed to by ECX must preserve EDX, but may change any other
;  registers that can normally be changed by subroutines

xosconScanMs::
	MOVL	EDX, tdb_mdb.B[ESI]	;Get first MDB
	TESTL	EDX, EDX		;Mapped at all?
	JE	6$.S			;No - nothing to do here!
	CLRL	EAX			;Yes - make sure no local selectors
	MOVL	ES, EAX
	MOVL	FS, EAX
	MOVL	GS, EAX
	MOVL	EAX, CR3		;Get current map address
	PUSHL	EAX			;Save it
	PUSHL	ECX			;Save offset of subroutine to call
4$:	MOVL	ES, mdb_pda.B[EDX]	;Get PDA selector for msect
	MOVL	EAX, ES:pdaCR3##	;Map to its address space
	MOVL	SS:pdaTss#+tss_CR3, EAX
	MOVL	CR3, EAX
	CALLI	[ESP]			;Block or unblock this msect
	MOVL	EDX, mdb_devnext.B[EDX]	;Get next MDB which has terminal mapped
	TESTL	EDX, EDX
	JNE	4$.S			;Continue if have another
	POPL	EAX			;Discard subroutine offset
	POPL	EAX			;Finished - restore mapping
	MOVL	SS:pdaTss##+tss_CR3, EAX
	MOVL	CR3, EAX
6$:	RET
.PAGE
	.SBTTL	xosconClrPgChng - Subroutine to clear all page modified bites

;Subroutine to clear all page modified (dirty) bits for the display memory
;	c{ESI} = Offset of TDB for terminal
;	CALL	xosconClrPgChng

xosconClrPgChng::
	CMPB	knlCrashed##, #0	;Has the system crashed?
	JNE	10$.S			;Yes - do nothing here!
	CMPB	tdb_mode[ESI], #DM_TEXT ;No - in text mode?
	JNE	10$.S			;No - for now, do nothing!
	MOVL	EAX, #la_data		;Yes - get linear address of the exec
	ADDL	EAX, tdb_vtaddr.B[ESI]	;   mapping of the screen
	SHRL	EAX, #12t		;Change to page map index
	MOVL	ECX, #16t		;Get number of exec mapped pages
2$:	ANDB	pgtable[EAX*4], #~40h	;Clear the dirty bit
	INCL	EAX			;Bump page table offset
	LOOP	ECX, 2$
	MOVL	ECX, #conclrpgchngmsc	;Update bits from any other msects
	JMP	xosconScanMs		;  which are mapped

;Subroutine to clear page modified (dirty) bits for single msect
;	c{EDX} = Offset of MDB for msect
;	c{ESI} = Offset of TDB for terminal
;	CALL	conclrpgchngmsc

conclrpgchngmsc:
	MOVL	EAX, mdb_la.B[EDX]	;Get linear address of msect
	MOVL	ECX, mdb_size.B[EDX]	;Get size of msect
	SHRL	EAX, #12t		;Get index into page map
6$:	ANDB	pgtable[EAX*4], #~40h	;Clear the dirty bit
	INCL	EAX			;Bump page table offset
	LOOP	ECX, 6$
10$:	RET
.PAGE
	.SBTTL	xosconUpdPgList - Subroutine to update page list entries

;Subroutine to update page list entries for the display memory - Bit 31 and 
;  28 are set in the entires for all modified pages to indicate that the pages
;  have been changed.  The hardware modified bit is also cleared for all pages.
;	c{ESI} = Offset of TDB for terminal
;	CALL	xosconUpdPgList

xosconUpdPgList::
	CMPB	knlCrashed##, #0	;Has the system crashed?
	JNE	10$.S			;Yes - do nothing here!
	CMPB	tdb_mode[ESI], #DM_TEXT ;No - in text mode?
	JNE	10$.S			;No - for now, do nothing!
	MOVL	EBX, #la_data		;Yes - get linear address of the exec
	ADDL	EBX, tdb_vtaddr.B[ESI]	;   mapping of the screen
	MOVL	ECX, #16t		;Get number of exec mapped pages
	CALL	updloop			;Scan the map and update the page list
	MOVL	ECX, #updmsect		;Update bits from any other msects
	JMP	xosconScanMs		;  which are mapped

;Subroutine to update page list entries for single msect
;	c{EDX} = Offset of MDB for msect
;	c{ESI} = Offset of TDB for terminal
;	CALL	conupdpglistmsc

updmsect:
	MOVL	EBX, mdb_la.B[EDX]	;Get linear address of msect
	MOVL	ECX, mdb_size.B[EDX]	;Get size of msect
updloop:SHRL	EBX, #12t		;Get index into page map
	CLRL	EAX
6$:	TESTB	pgtable[EBX*4], #40h	;Has this page been changed?
	JE	8$.S			;No
	ANDB	pgtable[EBX*4], #~40h	;Yes - clear the modified bit
	ORB	tdb_pglist+3[ESI+EAX*4], #{PL$MODIFIED|PL$INCMOD}>24t
8$:	INCL	EAX			;Bump page number
	INCL	EBX			;Bump page table offset
	LOOP	ECX, 6$
10$:	RET
.PAGE
	.SBTTL	conoas - Console once-a-second routine

conoas:	MOVL	EDI, xosconFDhdb	;Point to the first DHDB
2$:	CMPL	dhdb_scsvcnt.B[EDI], #0.B ;Is the screen saver enabled?
	JE	4$.S			;No
	DECL	dhdb_scsvcnt.B[EDI]	;Yes - time to disable the screen?
	JNE	4$.S			;No
	ORB	dhdb_keysts.B[EDI], #KS$VOFF ;Yes - indicate that
	MOVL	ESI, dhdb_curtdb.B[EDI]	;Get offset of TDB for current screen
	MOVL	EAX, tdb_ddisp.B[ESI]	;Disable the screen
	CALLI	CS:tf_disable.B[EAX]
4$:	MOVL	EDI, [EDI]		;Get next DHDB
	TESTL	EDI, EDI
	JNE	2$.S			;Go on if have another
	RET				;Finished
.PAGE
	.SBTTL	Data

	DATA

lit10:      .LONG  10t
conftdb:    .LONG  0		;Offset of first console TDB
conltdb:    .LONG  0		;Offset of last console TDB
xosconFDhdb:.LONG  0
xosconFKbdb:.LONG  0		;Offset of first keyboard driver block
nonestr:    .ASCII "None"
nullstr:    .BYTE  0

	LKEEND
