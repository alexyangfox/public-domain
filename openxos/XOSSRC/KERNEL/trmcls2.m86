	.TITLE	TRMCLS2 - General terminal class driver for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR

	CODE

	.SBTTL	Parameter table for terminals

;IO parameter tables used when opening terminals

	.LONG	PARMOPNMAX
trmopnparms::
	.LONG	trmopngenparms	;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms#;IOPAR_FILxxx = 01xx - File system IO parameters
	.LONG	trmopntrmparms	;IOPAR_TRMxxx = 02xx - Terminal IO parameters
PARMOPNMAX=!{$-trmopnparms}/4

	.LONG	PARMOPNGENMAX	;Size of table
trmopngenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopDummyN#	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopDummyS#	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts#	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum#	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId#	;IOPAR_GLBID       = 0005h
	.LONG	knlIopNullN#	;IOPAR_DELAY       = 0006h
	.LONG	knlIopNullN#	;IOPAR_TIMEOUT	   = 0007h
	.LONG	trmiopinpsts	;IOPAR_INPSTS      = 0008h
	.LONG	trmiopoutsts	;IOPAR_OUTSTS	   = 0009h
	.LONG	0		;IOPAR_INPQLMT	   = 000Ah
	.LONG	0		;IOPAR_OUTQLMT	   = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen#	;IOPAR_NUMOPEN     = 000Fh
	.LONG	0		;IOPAR_BUFRLMT	   = 0010h
PARMOPNGENMAX=!{$-trmopngenparms}/4

	.LONG	OPNTRMMAX
trmopntrmparms:
	.LONG	0
	.LONG	trmsinpmode	;IOPAR_TRMSINPMODE = 0201h
	.LONG	trmcinpmode	;IOPAR_TRMCINPMODE = 0202h
	.LONG	trmsoutmode	;IOPAR_TRMSOUTMODE = 0203h
	.LONG	trmcoutmode	;IOPAR_TRMCOUTMODE = 0204h
	.LONG	trmbfrlimit	;IOPAR_TRMBFRLIMIT = 0205h
	.LONG	trmclrbufr	;IOPAR_TRMCLRBUFR  = 0206h
	.LONG	trmcurtype	;IOPAR_TRMCURTYPE  = 0207h
	.LONG	trmcurpos	;IOPAR_TRMCURPOS   = 0208h
	.LONG	trmdisppage	;IOPAR_TRMDISPAGE  = 0209h
	.LONG	0		;IOPAR_TRMSPSTATUS = 020Ah
	.LONG	0		;IOPAR_TRMSPBREAK  = 020Bh
	.LONG	trmmodem	;IOPAR_TRMSPMODEM  = 020Ch
	.LONG	trmsetdfc	;IOPAR_TRMSETDFC   = 020Dh
	.LONG	trmclrdfc	;IOPAR_TRMCLRDFC   = 020Eh
	.LONG	trmlstdfc	;IOPAR_TRMLSTDFC   = 020Fh
	.LONG	trmalldfc	;IOPAR_TRMALLDFC   = 0210h
	.LONG	trmccvect	;IOPAR_TRMCCVECT   = 0211h
	.LONG	trmccdata	;IOPAR_TRMCCDATA   = 0212h
	.LONG	trmcpvect	;IOPAR_TRMCPVECT   = 0213h
	.LONG	trmcpdata	;IOPAR_TRMCPDATA   = 0214h
	.LONG	trmhuvect	;IOPAR_TRMHUVECT   = 0215h
	.LONG	trmhudata	;IOPAR_TRMHUDATA   = 0216h
OPNTRMMAX=!{$-trmopntrmparms}/4
.PAGE

	.LONG	PARMIOMAX
trmioparms::
	.LONG	trmiogenparms	;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	knlNullFilParms#;IOPAR_FILxxx = 01xx - File system IO parameters
	.LONG	trmiotrmparms	;IOPAR_TRMxxx = 02xx - Terminal IO parameters
PARMIOMAX=!{$-trmioparms}/4

	.LONG	PARMIOGENMAX	;Size of table
trmiogenparms:
	.LONG	0
	.LONG	knlIoxFilOptn#	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIoxFilSpec#	;IOPAR_FILSPEC     = 0002h
	.LONG	knlIopDevSts#	;IOPAR_DEVSTS      = 0003h
	.LONG	knlIopUnitNum#	;IOPAR_UNITNUM     = 0004h
	.LONG	knlIopGlbId#	;IOPAR_GLBID       = 0005h
	.LONG	trmiopdelay	;IOPAR_DELAY       = 0006h
	.LONG	trmioptimeout	;IOPAR_TIMEOUT	   = 0007h
	.LONG	trmiopinpsts	;IOPAR_INPSTS      = 0008h
	.LONG	trmiopoutsts	;IOPAR_OUTSTS	   = 0009h
	.LONG	0		;IOPAR_INPQLMT	   = 000Ah
	.LONG	0		;IOPAR_OUTQLMT	   = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen#	;IOPAR_NUMOPEN     = 000Fh
	.LONG	0		;IOPAR_BUFRLMT	   = 0010h
PARMIOGENMAX=!{$-trmiogenparms}/4

	.LONG	PARMIOTRMMAX
trmiotrmparms:
	.LONG	0
	.LONG	trmiosinpmode	;IOPAR_TRMSINPMODE = 0201h
	.LONG	trmiocinpmode	;IOPAR_TRMCINPMODE = 0202h
	.LONG	trmiosoutmode	;IOPAR_TRMSOUTMODE = 0203h
	.LONG	trmiocoutmode	;IOPAR_TRMCOUTMODE = 0204h
	.LONG	trmiobfrlimit	;IOPAR_TRMBFRLIMIT = 0205h
	.LONG	trmioclrbufr	;IOPAR_TRMCLRBUFR  = 0206h
	.LONG	trmiocurtype	;IOPAR_TRMCURTYPE  = 0207h
	.LONG	trmiocurpos	;IOPAR_TRMCURPOS   = 0208h
	.LONG	trmiodisppage	;IOPAR_TRMDISPAGE  = 0209h
	.LONG	0		;IOPAR_TRMSPSTATUS = 020Ah
	.LONG	0		;IOPAR_TRMSPBREAK  = 020Bh
	.LONG	trmiomodem	;IOPAR_TRMSPMODEM  = 020Ch
	.LONG	trmiosetdfc	;IOPAR_TRMSETDFC   = 020Dh
	.LONG	trmioclrdfc	;IOPAR_TRMCLRDFC   = 020Eh
	.LONG	trmiolstdfc	;IOPAR_TRMLSTDFC   = 020Fh
	.LONG	trmioalldfc	;IOPAR_TRMALLDFC   = 0210h
	.LONG	trmccvect	;IOPAR_TRMCCVECT   = 0211h
	.LONG	trmccdata	;IOPAR_TRMCCDATA   = 0212h
	.LONG	trmcpvect	;IOPAR_TRMCPVECT   = 0213h
	.LONG	trmcpdata	;IOPAR_TRMCPDATA   = 0214h
	.LONG	trmhuvect	;IOPAR_TRMHUVECT   = 0215h
	.LONG	trmhudata	;IOPAR_TRMHUDATA   = 0216h
PARMIOTRMMAX=!{$-trmiotrmparms}/4

;Terminal IO parameter table for non-terminal devices

	.LONG	NULLTRMMAX
knlNullTrmParms::
	.LONG	0
	.LONG	knlIopNullN#	;IOPAR_TRMSINPMODE = 0201h
	.LONG	knlIopNullN#	;IOPAR_TRMCINPMODE = 0202h
	.LONG	knlIopNullN#	;IOPAR_TRMSOUTMODE = 0203h
	.LONG	knlIopNullN#	;IOPAR_TRMCOUTMODE = 0204h
	.LONG	knlIopNullN#	;IOPAR_TRMBFRLIMIT = 0205h
	.LONG	knlIopNullN#	;IOPAR_TRMCLRBUFR  = 0206h
	.LONG	knlIopNullN#	;IOPAR_TRMCURTYPE  = 0207h
	.LONG	knlIopNullN#	;IOPAR_TRMCURPOS   = 0208h
	.LONG	knlIopNullN#	;IOPAR_TRMDISPAGE  = 0209h
	.LONG	knlIopNullN#	;IOPAR_TRMSPSTATUS = 020Ah
	.LONG	knlIopNullN#	;IOPAR_TRMSPBREAK  = 020Bh
	.LONG	knlIopNullN#	;IOPAR_TRMSPMODEM  = 020Ch
	.LONG	knlIopNullN#	;IOPAR_TRMSETDFC   = 020Dh
	.LONG	knlIopNullN#	;IOPAR_TRMCLRDFC   = 020Eh
	.LONG	knlIopNullN#	;IOPAR_TRMLSTDFC   = 020Fh
	.LONG	knlIopNullN#	;IOPAR_TRMALLDFC   = 0210h
	.LONG	knlIopNullN#	;IOPAR_TRMCCVECT   = 0211h
	.LONG	knlIopNullN#	;IOPAR_TRMCCDATA   = 0212h
	.LONG	knlIopNullN#	;IOPAR_TRMCPVECT   = 0213h
	.LONG	knlIopNullN#	;IOPAR_TRMCPDATA   = 0214h
	.LONG	knlIopNullN#	;IOPAR_TRMHUVECT   = 0215h
	.LONG	knlIopNullN#	;IOPAR_TRMHUDATA   = 0216h
NULLTRMMAX=!{$-knlNullTrmParms}/4
.PAGE
	.SBTTL	pgfmterm - Display buffer page fail routine

;Get here on page fail trap on reference to available but blocked display
;  buffer page - EAX and DS only have been saved on the stack, DS contains
;  GS_DATA - in this case the page table entry is a normal map entry for
;  the physical or virtual terminal buffer except that the P bit is clear
;	c{{ESP}+0}  = Saved DS
;	c{{ESP}+4}  = Saved EAX
;	c{{ESP}+8}  = CR2
;	c{{ESP}+12} = Trap error code
;	c{{ESP}+16} = Trap EIP
;	c{{ESP}+20} = Trap CS
;	c{{ESP}+24} = Trap EFR

pgfterm::
	POPL	DS			;Restore registers
	POPL	EAX
	PUSHAL				;And save all registers the right way
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHL	#GS_DATA.B
	POPL	DS
	CMPB	knlForkLvl#, #FORK_MFORK
	JA	10$.S
	MOVL	EBX, 30h.B[ESP]		;Yes - get page fault linear address
	SHRL	EBX, #12t		;Get index into page table
	MOVL	ESI, pgtable[EBX*4]	;Get page table entry
	SHRL	ESI, #6t		;Get offset of TDB (which was stored in
					;  the address field!)
	MOVL	EAX, tdb_ddisp.B[ESI]
	TOFORK	2$			;Raise to fork level is need to
	CALLI	CS:tf_sspageflt.B[EAX]
	JMP	pgfuagn#

2$:	CALLI	CS:tf_sspageflt.B[EAX]
	TOFORK
	JMP	pgfuagn#

10$:	CRASH	TPFE			;[Terminal Page Fail Error]
.PAGE
	.SBTTL	sd_parm - Device parameters

;Here for the device parameters - get here in extended fork context
;	c{EDI} = Offset of DCB
;	CALL	trmparm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

trmparm::
	CLRL	EAX
	RET
.PAGE
	.SBTTL	sd_open - Open device

;Here for the open additional device entry - get here in extended fork context
;	c{ECX}    = Device command bits
;	c{EDI}    = Offset of DCB
;	CALL	trmopena
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = 0
;	C:clr = Normal
;	  c{ECX} = 1

trmopena::
	TESTL	ECX, #O$ODF
	JNE	2$.S			;If illegal options
	CMPL	SS:xffParm#, #0.B	;Have any parameters?
	JE	trmtransnew.S		;No
	MOVL	ESI, dcb_trtdb.B[EDI]	;Yes - point to our TDB
	TESTL	ESI, ESI		;Fail if none
	JE	5$.S
	MOVL	EBX, #trmopnparms	;Process the parameters
	MOVL	ECX, #knlComDPParms#
	IFFAULT	knlQAdrErr0#
	LFSL	EDX, SS:xffParm#
	CALL	knlProcDevParm#
	JC	4$.S
trmtransnew::
	MOVL	ESI, dcb_trtdb.B[EDI]
	TESTL	ESI, ESI
	JE	5$.S
	MOVL	EBX, tdb_ddisp.B[ESI]	;Do terminal type dependent stuff
	CALLI	CS:tf_opena.B[EBX]
1$:	JMP	14$

2$:	MOVL	EAX, #ER_NTFIL
4$:	CLRL	ECX
	STC
	RET

;Here if no TDB when opening the device

5$:	MOVL	EAX, #ER_TRMNA
	JMP	4$.S

;Here for the open device entry - get here in extended fork context
;	c{EDI} = Offset of DCB
;	CALL	trmopen1
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = 0
;	C:clr = Normal
;	  c{ECX} = 1

trmopen1::
	TESTL	SS:xffCmd#, #O$ODF
	JNE	2$.S			;If illegal options
	MOVL	ESI, dcb_trtdb.B[EDI]	;Point to our TDB
	TESTL	ESI, ESI		;Fail if none
	JE	5$.S
	CMPL	SS:xffParm#+0, #0.B	;Have any parameters?
	JE	6$.S			;No
	MOVL	EBX, #trmopnparms	;Yes - process them
	MOVL	ECX, #knlComDPParms#
	IFFAULT	knlRtnAdrEr0#
	LFSL	EDX, SS:xffParm#
	CALL	knlProcDevParm#
	JC	4$.S
6$:	CLRL	EAX
	MOVL	dcb_trccstcnt.B[EDI], EAX
	MOVB	AL, tdb_iflow.B[ESI]	;Initialize flow control enables
	MOVB	tdb_flow.B[ESI], AL
	MOVB	AL, tdb_imodem.B[ESI]	;Initialize modem control state
	MOVB	tdb_modem.B[ESI], AL
	MOVL	EBX, tdb_ddisp.B[ESI]	;Do terminal type dependent stuff
	CALLI	CS:tf_open1.B[EBX]
	TESTL	SS:xffCmd#, #O$PHYS|O$RAW ;Is "physical IO" specified?
	JNE	10$.S			;Yes
	MOVL	tdb_imode.B[ESI], #TIM$ECHO|TIM$ILFACR ;No
	CALL	trmsetdfcline		;Default is line mode input with
					;  echoing enabled
	MOVL	tdb_omode.B[ESI], #TOM$ICRBLF  ;And normal output with CR
					       ;  inserted before LF
	CALL	trmclrtypa#		;Clear out any input
	JMP	12$.S

;Here if "physical IO" specified

10$:	MOVL	tdb_imode.B[ESI], #TIM$IMAGE|TIM$ILFACR  ;Default is image input
	CALL	trmsetdfcimg				 ;  without echo
	MOVL	tdb_omode.B[ESI], #TOM$IMAGE ;And image mode output
12$:	CLRL	EDX
	MOVL	EAX, tdb_ddisp.B[ESI]	;Tell the driver which input bits we set
	CALLI	CS:tf_imodechng[EAX]
	CLRL	EDX
	MOVL	EAX, tdb_ddisp.B[ESI]	;Tell the driver which output bits we
	CALLI	CS:tf_omodechng[EAX]	;  set
14$:	CLRL	EAX
	MOVL	ECX, #1
	RET
.PAGE
	.SBTTL	Routines for QFNC_DEVCHAR functions

;Information text

knlTrmMsgBFreq::   DCHARINFO  {Bell tone frequency (Hertz)}
knlTrmMsgBLen::    DCHARINFO  {Bell tone length (millisec)}
knlTrmMsgSession:: DCHARINFO  {Terminal can create session}
knlTrmMsgMsgDst::  DCHARINFO  {Initial message distination}
knlTrmMsgProgram:: DCHARINFO  {Initial program to run}
knlTrmMsgPWrd::    DCHARINFO  {Password}
knlTrmMsgIOFlow::  DCHARINFO  {Initial output flow control}
knlTrmMsgIIFlow::  DCHARINFO  {Initial input flow control}
knlTrmMsgIModem::  DCHARINFO  {Initial modem control}
knlTrmMsgModem::   DCHARINFO  {Current modem control}
knlTrmMsgOFlow::   DCHARINFO  {Current output flow control}
knlTrmMsgIFlow::   DCHARINFO  {Current input flow control}
knlTrmMsgKbChar::  DCHARINFO  {Keyboard characters}
knlTrmMsgKbTChar:: DCHARINFO  {Total keyboard characters}
knlTrmMsgInRBS::   DCHARINFO  {Input ring buffer size}
knlTrmMsgInRBSL::  DCHARINFO  {Input ring buffer stop level}
knlTrmMsgInRBPL::  DCHARINFO  {Input ring buffer panic level}
knlTrmMsgInRBHeld::DCHARINFO  {Input ring buffer held count}
knlTrmMsgInRBLost::DCHARINFO  {Input ring buffer lost count}
knlTrmMsgInLBS::   DCHARINFO  {Input line buffer size}
knlTrmMsgCharIn::  DCHARINFO  {Number of characters input}
knlTrmMsgCharOut:: DCHARINFO  {Number of characters output}

;Here to get the value of the SESSION characteristic

knlTrmGetSession::
	CALL	knlGetTdb
	JC	2$.S
	MOVL	EAX, #'YES'
	TESTB	tdb_stsmisc.B[ESI], #TSM$SESSION
	JNE	2$.S
	MOVL	EAX, #'NO'
2$:	RET

;Here to get the value of the PASSWORD or PROGRAM characteristic

knlTrmGetText::
	CALL	knlGetTdb
	JC	2$.S
	ADDL	EDX, ESI
	JMP	knlGetSysStr#

;Here to get the value of the IOUTFLOW or OUTFLOW characteristic

knlTrmGetOFlow::
	CALL	knlGetTdb
	JC	2$.S
	MOVB	AL, [ESI+EBX]
	ANDL	EAX, #0F0h
	MOVL	EBX, #knlTrmOFlowTbl
	MOVL	ECX, #knlTRMOFLOWTBLSZ
	JMP	knlGetDcName#

;Here to get the value of the IINFLOW or INFLOW characteristic

knlTrmGetIFlow::
	CALL	knlGetTdb
	JC	2$.S
	MOVB	AL, [ESI+EBX]
	ANDL	EAX, #0Fh.B
	MOVL	EBX, #knlTrmIFlowTbl
	MOVL	ECX, #knlTRMIFLOWTBLSZ
	JMP	knlGetDcName#

	.MOD	4
knlTrmOFlowTbl::
	.LONG	'DSR' , 0    , TFC$ODSR
	.LONG	'CTS' , 0    , TFC$OCTS
	.LONG	'REVC', 'TS' , TFC$OCTS|TFC$OREV
	.LONG	'REV' , 0    , TFC$OCTS|TFC$OREV
knlTrmOFlowTblD::
	.LONG	'NONE', 0    , 0
	.LONG	'XONX', 'OFF', TFC$OXONXOFF
	.LONG	'XON' , 0    , TFC$OXONXOFF
	.LONG	'PAUS', 'E'  , TFC$OXONXOFF|TFC$OREV
	.LONG	'PAU' , 0    , TFC$OXONXOFF|TFC$OREV
knlTRMOFLOWTBLDSZ==!{$-knlTrmOFlowTblD}/12t
knlTRMOFLOWTBLSZ ==!{$-knlTrmOFlowTbl}/12t

	.MOD	4
knlTrmIFlowTbl::
	.LONG	'DTR' , 0    , TFC$IDTR
	.LONG	'RTS' , 0    , TFC$IRTS
	.LONG	'REVC', 'TS' , TFC$IRTS|TFC$IREV
	.LONG	'REV' , 0    , TFC$IRTS|TFC$IREV
knlTrmIFlowTblD::
	.LONG	'NONE', 0    , 0
	.LONG	'XONX', 'OFF', TFC$IXONXOFF
	.LONG	'XON' , 0    , TFC$IXONXOFF
	.LONG	'PAUS', 'E'  , TFC$IXONXOFF|TFC$IREV
	.LONG	'PAU' , 0    , TFC$IXONXOFF|TFC$IREV
knlTRMIFLOWTBLDSZ==!{$-knlTrmIFlowTblD}/12t
knlTRMIFLOWTBLSZ ==!{$-knlTrmIFlowTbl}/12t
.PAGE
;Here to get the value of the MODEM characteristic

knlTrmGetModem::
	CALL	knlGetTdb
	JC	4$.S
	ADDL	EBX, ESI
	MOVL	EAX, #'None'		;Assume NONE
	CLRL	EDX
	TESTB	[EBX], #TMC$MODEM	;Right?
	JE	4$.S			;Yes
	MOVL	EAX, #'Full'		;No - assume FULL
	TESTB	[EBX], #TMC$DETACH	;Right?
	JE	4$.S			;Yes
	MOVL	EAX, #'Deta'		;No - its DETACH
	MOVL	EDX, #'ch'
4$:	RET

;Here to set the value of the MODEM characteristic

knlTrmSetModem::
	CALL	knlGetTdb
	JC	4$.S
	ADDL	ESI, EBX
	MOVL	EBX, #modemtbl
	MOVL	ECX, #MODEMTBLSZ
	CALL	knlGetDcVal1#
	JC	4$.S
	MOVB	AL, CS:modembits[EAX]
	MOVB	[ESI], AL
	RET

	.MOD	4
modemtbl:
	.LONG	'NONE', 0
	.LONG	'DETA', 'CH'
	.LONG	'FULL', 0
MODEMTBLSZ=!{$-modemtbl}/8

modembits:
	.BYTE	0, TMC$MODEM|TMC$DETACH, TMC$MODEM
.PAGE
;Here to set the value of the SESSION characteristic

knlTrmSetSession::
	CALL	knlGetTdb
	JC	4$.S
	CALL	knlGetYesNo#
	JC	4$.S
	JE	2$.S
	ANDB	tdb_stsmisc.B[ESI], #~TSM$SESSION
	RET

2$:	ORB	tdb_stsmisc.B[ESI], #TSM$SESSION
4$:	RET

;Here to set the value of the ACCESS characteristic

knlTrmSetAccess::
	CALL	knlGetTdb
	JC	4$.S
	ADDL	EBX, ESI
	JMP	knlSetAccess#

;Here to set the value of the PASSWORD or PROGRAM characteristic

knlTrmSetText::
	CALL	knlGetTdb
	JC	4$.S
	ADDL	EDX, ESI
	JMP	knlSetSysStr#

;Here to set 2 byte characteristic value

knlTrmSet2Byte::
	CALL	knlGetTdb
	JC	4$.S
	MOVW	[ESI+EBX], AX
	RET

;Here to set 4 byte characteristic value

knlTrmSet4Byte::
	CALL	knlGetTdb
	JC	4$.S
	MOVL	[ESI+EBX], EAX
	RET
.PAGE
;Here to get 1 byte characteristic value

knlTrmGet1Byte::
	CALL	knlGetTdb
	JC	2$.S
	MOVZBL	EAX, [ESI+EBX]
2$:	RET

;Here to get 2 byte characteristic value

knlTrmGet2Byte::
	CALL	knlGetTdb
	JC	2$.S
	MOVZWL	EAX, [ESI+EBX]
	RET

;Here to get 4 byte characteristic value

knlTrmGet4Byte::
	CALL	knlGetTdb		;Get offset of the TDB
	JC	2$.S			;If error
	MOVL	EAX, [ESI+EBX]		;Store value
	RET
.PAGE
	.SBTTL	sd_cleardev - Clear device

;Here for the clear device entry.  This routine is called by clearall which
;  is called when an image is being replaced to ensure than the device is not
;  linked to any existing code.  In the case of a terminal, it removes any
;  KIBs which have been set up.  Must be called at main program level raised
;  to fork level.
;	c{EDI} = Offset of DCB
;	c{ESI} = Device handle
;	CALL	trmclear

trmclear::
	MOVL	EAX, SS
	MOVL	EBX, #dcb_trccsvect
	CALL	trmclrsig
	ADDL	EBX, #dcb_trcpsvect-dcb_trccsvect.B
	CALL	trmclrsig
	LEAL	EBX, dcb_trkib.B[EDI]
2$:	MOVL	EDX, [EBX]		;Have any KIBs for this terminal?
	TESTL	EDX, EDX
	JE	12$.S			;No
	CMPW	ki_pda.B[EDX], AX	;Yes - see if we need to remove one
	JNE	6$.S
	CMPL	ki_handle.B[EDX], ESI
	JE	10$.S
6$:	MOVL	EBX, EDX		;Advance to next KIB
	JMP	2$.S

;Here with KIB to give up

10$:	PUSHL	EAX
	PUSHL	ESI
	MOVL	EAX, ki_kdisp.B[EDX]	;Fix up possible hung keyboard interrupt
	PUSHL	EDX
	PUSHL	EBX
	CALLI	CS:kf_clrkeyi.B[EAX]
	POPL	EBX
	POPL	EDX
	MOVL	EAX, [EDX]		;Unlink the KIB
	MOVL	[EBX], EAX
	MOVL	ESI, EDX		;And give up the queue element
	CALL	knlGiveQel#
	POPL	ESI
	POPL	EAX
	JMP	2$.S			;Continue

;Here with all relevent KIBs given up

12$:	CMPL	ESI, #DH_STDTRM.B	;Controlling terminal?
	JNE	14$.S			;No
	MOVB	SS:pdaVMode#, #-1	;Yes - indicate not mapped now
14$:	RET

;Subroutine to clear terminal signal vector if necessary
;	c{EBX} = Offset of vector number in DCB
;	c{EDI} = Offset of DCB
;	c{ESI} = Handle
;	c{EAX} = Selector for PDA
;	CALL	trmclrsig

trmclrsig:
	CMPB	[EDI+EBX], #0
	JE	14$.S
	CMPW	dcb_trccspda-dcb_trccsvect.B[EDI+EBX], AX
	JNE	14$.S
	CMPW	dcb_trccshndl-dcb_trccsvect.B[EDI+EBX], SI
	JNE	14$.S
	MOVB	[EDI+EBX], #0
	RET
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry - this is an extended fork context routine for
;  all terminals
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	CALL	trmclose
;	c{EAX} = Error code (always 0)
;	c{EBX} = Status bits (always 0)
;	c{ECX} = 0

trmclose::
	TOFORK
	PUSHL	ESI
	MOVZWL	ESI, iorb_handle.B[ESI]
	CALL	trmclear		;Give up any KIBs we have
	POPL	ESI
	CMPL	dcb_opencnt.B[EDI], #1.B ;Anyone else have this open?
	JE	4$.S			;No
	CALL	checkvects		;Yes
	JMP	knlCloseFin#		;Nothing more needed here

;Here if last close for device

4$:	FROMFORK
	CALL	knlIoClsLock#		;Lock the QAB
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #trmclose1
	JMP	knlXfQueue#		;Switch to extended fork context

;Here in extended fork context

trmclose1:
	MOVL	ESI, dcb_trtdb.B[EDI]	;Get address of TDB
	TESTL	ESI, ESI		;Do we have one?
	JE	10$.S			;No - skip this stuff
	ANDB	tdb_stsout.B[ESI], #~{TSO$JUNK|TSO$JUNKX|TSO$HOLDS|TSO$HOLDP}
	BTSL	tdb_stsout.B[ESI], #TSO%OUTA;Reset some stuff
	JC	6$.S			;Make sure doing output if have some
	PUSHL	EDI			;  to do now
	MOVL	EBX, tdb_ddisp.B[ESI]
	CALLI	CS:tf_resume.B[EBX]
	POPL	EDI
6$:	CALL	checkvects
	CMPL	tdb_outrcnt[ESI], #0.B	;Anything in the output ring?
	JE	8$.S			;No
	ORB	tdb_stsout+1.B[ESI], #TSO$FLOUT>8 ;Yes - set the flush output
						  ;  bit
	MOVB	tdb_owkv.B[ESI], #0	;Wait until buffer is empty
	ORB	tdb_stsout+1.B[ESI], #TSO$QOWAIT>8
	MOVL	EAX, #10t*XT_SECOND	;Only wait for 10 seconds here!
	CALL	knlXfWait#
	CALL	trmstopout#		;Make sure output stopped
	MOVL	EBX, tdb_ddisp.B[ESI]	;Clear output ring buffer
	CALLI	CS:tf_clrout.B[EBX]
	ANDB	tdb_stsout.B[ESI], #~{{TSO$QOWAIT|TSO$FLOUT}>8}
8$:

;;;;;;;	MOVB	dcb_sts3.B[EDI], #0

	MOVL	EBX, tdb_ddisp.B[ESI]	;Ensure output is complete
	CALLI	CS:tf_finout[EBX]
	CALL	trmmkidle
	CALL	trmcirg#		;Clear the input ring buffer
	MOVB	AL, tdb_iflow.B[ESI]	;Reset flow control enables
	MOVB	tdb_flow.B[ESI], AL
	MOVB	AL, tdb_imodem.B[ESI]	;Reset modem control state
	MOVB	tdb_modem.B[ESI], AL
10$:	JMP	knlXfCloseFin#

trmmkidle::
	ANDB	tdb_stsmisc.B[ESI], #~TSM$IMSG
	ANDB	tdb_stsout+1.B[ESI], #~{TSO$NOWRAP>8}
	MOVL	tdb_imode.B[ESI], #TIM$IMAGE|TIM$ILFACR
	CALL	trmsetdfcimg
	MOVL	tdb_omode.B[ESI], #TOM$ICRBLF
	MOVL	EBX, tdb_ddisp.B[ESI]	;Reset terminal to idle state
	JMPIL	CS:tf_idle.B[EBX]

;Subroutine to clear an async terminal vectors when closing the terminal
;	c{EBX} = Offset of vector number (in DCB)

checkvects:
	CMPB	knlForkLvl#, #FORK_MFORK
	JA	12$.S
	MOVL	EAX, SS
	MOVZWL	EDX, iorb_handle.B[ESI]
	JMP	14$.S

12$:	MOVZWL	EAX, SS:xffPda#
	MOVZWL	EDX, SS:xffHandle#
14$:	LEAL	EBX, dcb_trccsvect.B[EDI]
	CALL	16$
	LEAL	EBX, dcb_trcpsvect.B[EDI]
	CALL	16$
	LEAL	EBX, dcb_trhusvect.B[EDI]
16$:	CMPW	dcb_trccspda-dcb_trccsvect.B[EBX], AX
	JNE	18$.S			;No
	CMPW	dcb_trccshndl-dcb_trccsvect.B[EBX], DX
	JNE	18$.S			;No
	CLRL	ECX			;Yes - clear it out
	MOVL	[EBX], ECX
	MOVL	4.B[EBX], ECX
	MOVL	8.B[EBX], ECX
18$:	RET
.PAGE
	.SBTTL	sd_cleardcb - Clear DCB

;Here for the clear DCB entry
;	c{EDI} = Offset of DCB

trmcdcb::
	MOVL	ESI, dcb_trtdb.B[EDI]	;Are we attached now?
	TESTL	ESI, ESI
	JE	2$.S			;No
	CLRL	EAX			;Yes - but now now
	MOVL	[ESI], EAX
	MOVL	dcb_trtdb.B[EDI], EAX
	MOVL	EBX, tdb_ddisp.B[ESI]	;Report status change to screen
	CALLI	CS:tf_ssstatus[EBX]	;  symbiont if need to
2$:	DECL	trmdcbnum#		;Reduce count
	MOVL	ECX, #dcb_trINDEX	;Give up the DCB
	JMP	knlGiveDymDcb#
.PAGE
	.SBTTL	sd_inpblock - Input block

;Here for the input block entry
;	c{EDI} = Offset of DCB
;	CALL	trminpblk
;	C:set = Error
;	  c{EAX} = Error code
;	  c{EBX} = Status bits
;	  c{ECX} = Amount output
;	C:clr = Normal
;	  c{EBX} = Status bits
;	  c{ECX} = Amount output

$$$=!0
FRM tio_delay  , 4t		;Delay value
FRM tio_timeout, 4t		;Time-out value
FRM tio_amount , 4t		;Amount input
FRM tio_iorb   , 4t		;Offset of IORB if not in extended fork context
FRM tio_xff    , 1t		;Non-zero if in extended fork context
FRM tio_cont   , 1t		;Non-zero if main program level continued IO
FRM tio_out    , 1t		;Non-zero if output
FRM tio_hifunc , 1t		;High order 8 bits from qab_func
tio_SIZE=!$$$

trminpblk::
	TESTB	iorb_func+1.B[ESI], #QFNC$DIO>8 ;Do we want to do queued input?
	JNE	trminpblkd.S		;No
	CALL	knlIoQabLock#		;Yes - lock the QAB
	JC	4$.S			;If error
	CALL	knlIoReadLock#		;Lock the buffer pages
	JC	4$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_inpframe
	MOVL	iorb_routine.B[ESI], #trminpblkq
	JMP	knlXfQueue#		;Switch to extended fork context

2$:	CALL	knlGiveQel#
	MOVL	ESI, EBX
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	LEAVE
4$:	TOFORK
ret002:	RET

;Here at main program level if doing direct input

trminpblkd:
	BTL	ECX, #O%IN		;Is input allowed?
	JC	6$.S			;Yes - go on
	CMPL	iorb_count.B[ESI], #0.B ;No - really doing input?
	JNE	knlIllInpGQ#		;Yes - fail
6$:	ENTER	tio_SIZE, 0		;No - OK
	CMPL	iorb_count.B[ESI], #0.B	;Really doing doing input?
	JE	8$.S			;No
	IFFAULT	20$			;Yes - make sure buffer is writable
	LESL	EBX, iorb_buffer1.B[ESI]
	MOVL	ECX, iorb_count.B[ESI]
	CALL	knlIoBufrChk#
	JC	2$.S
8$:	CLRL	EAX
	MOVL	tio_amount.B[EBP], EAX	;Initialize amount input
	MOVB	tio_xff.B[EBP], AL
	MOVB	tio_cont.B[EBP], AL
	MOVB	tio_out.B[EBP], AL
	DECL	EAX
	MOVL	tio_timeout.B[EBP], EAX	;Initialize time-out value
	MOVB	AL, iorb_func+1.B[ESI]	;Get high byte of the function value
	MOVB	tio_hifunc.B[EBP], AL
	MOVL	tio_iorb.B[EBP], ESI
	MOVL	EBX, ESI
	TOFORK
	CALL	knlGetTdb
	JC	16$.S
	ANDB	tdb_imode.B[ESI], #~TIM$XIMAGE
	BTL	tdb_imode.B[ESI], #TIM%DEBUG ;Debug mode input?
	JNC	9$.S			;No
	MOVL	EAX, tdb_dhdb.B[ESI]	;Yes - clear system shift menu state
	TESTL	EAX, EAX		;  if this is a display
	JE	9$.S
	ANDB	dhdb_keysts.B[EAX], #~KS$SYSSHFT
9$:	TESTB	iorb_func+1.B[EBX], #QFNC$CONT>8t ;Continued operation?
	JE	10$.S			;No
	INCB	tio_cont.B[EBP]		;Yes - indicate continued operation
10$:	CMPL	iorb_parm.B[EBX], #0.B	;Do we have a parameter list?
	JE	12$.S			;No
	IFFAULT	20$
	LFSL	EDX, iorb_parm.B[EBX]	;Yes - get address of parameter list
	PUSHL	EBX
	MOVL	EBX, #trmioparms	;Process parameters
	MOVL	ECX, #knlComDPParms#
	CALL	knlProcDevParm#
	POPL	EBX
	JC	16$.S			;If error
12$:	MOVL	ECX, iorb_count.B[EBX]	;Get count
	JREGZ	ECX, 14$		;Finished if 0
	IFFAULT	20$
	LESL	EDX, iorb_buffer1.B[EBX] ;Get address of buffer
	XCHGL	ESI, EBX
	CALL	knlGiveQel#		;Give up the IORB
	MOVL	ESI, EBX
	MOVL	EBX, EDX
	JMP	trminpc			;Continue

14$:	CLRL	EAX
16$:	XCHGL	ESI, EBX
	CALL	knlGiveQel#
	MOVL	ESI, EBX
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	LEAVE
	RET

	FAULTHDR
20$:	MOVL	EAX, #ER_ADRER
	JMP	14$.S
.PAGE
;Here in extended fork context if doing queued input

trminpblkq:
	BTL	SS:xffCmd#, #O%IN	;Is input allowed?
	JC	2$.S			;Yes
	CMPL	SS:xffCount#, #0.B	;No - really doing input?
	JNE	knlIllInp#		;Yes - fail
2$:	ENTER	tio_SIZE, 0		;No - OK
	CLRL	EAX
	MOVL	tio_amount.B[EBP], EAX	;Initialize amount input
	MOVB	tio_cont.B[EBP], AL
	MOVB	tio_out.B[EBP], AL
	DECL	EAX
	MOVL	tio_timeout.B[EBP], EAX	;Initialize time-out value
	MOVB	tio_xff.B[EBP], AL
	MOVB	AL, SS:xffFunc#+1	;Get high byte of the function value
	MOVB	tio_hifunc.B[EBP], AL
	CALL	knlGetTdb		;Get our TDB
	JC	14$			;If error
	MOVL	EAX, tdb_ibsize[ESI]	;OK - initialize input buffer limit
	MOVL	tdb_iblen[ESI], EAX
	CMPL	SS:xffParm#, #0.B	;Do we have a parameter list?
	JE	4$.S			;No
	IFFAULT	knlQAdrErr0Lv#
	LFSL	EDX, SS:xffParm#	;Yes - get address of parameter list
	MOVL	EBX, #trmioparms	;Process parameters
	MOVL	ECX, #knlComDPParms#
	CALL	knlProcDevParm#
	JC	12$.S			;If error
4$:	BTL	tdb_imode.B[ESI], #TIM%DEBUG ;Debug mode input?
	JC	8$.S			;Yes - fail!
	MOVL	ECX, SS:xffCount#	;No - get count
	JREGZ	ECX, 10$		;Finished if 0
	IFFAULT	knlQAdrErr0Lv#
	LESL	EBX, SS:xffBuffer1#	;Get address of buffer
trminpc:MOVL	EAX, tdb_ibsize[ESI]
	SUBL	EAX, #2.B
	MOVL	tdb_iblen[ESI], EAX
	CMPL	ECX, EAX		;Is the count too big?
	JBE	6$.S			;No
	MOVL	ECX, EAX		;Yes - reduce it
6$:	TESTB	tdb_imode.B[ESI], #TIM$XIMAGE|TIM$IMAGE|TIM$CHAR
					;Doing line mode input?
	JE	16$.S			;Yes
	MOVL	tdb_iblen[ESI], ECX	;No - make our buffer same size as his
	JMP	inplp.S

;Here if TIM$DEBUG set for queued IO

8$:	MOVL	EAX, #ER_IFDEV
	JMP	12$.S

10$:	CLRL	EAX
12$:	ANDB	tdb_stsinp.B[ESI], #~TSI$INACT ;Indicate input not active
14$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	LEAVE
	RET

16$:	DECL	tdb_iblen[ESI]		;Adjust buffer size
	BTL	tdb_imode.B[ESI], #TIM%ILFACR ;Want CR after LF?
	JNC	inplp.S			;No
	DECL	tdb_iblen[ESI]		;Yes - allow room for that too
inplp:	ANDB	tdb_stsout.B[ESI], #~TSO$JUNK ;Stop junking output now
	TESTB	tdb_stsinp.B[ESI], #TSI$INAVL ;De we have input available now?
	JNE	20$.S			;Yes - go get it
	TESTB	tdb_stsinp.B[ESI], #TSI$INACT ;No - is input active now?
	JNE	34$			;Yes - just go wait
	CALL	trmbgninput		;No - begin input
	TESTB	tdb_stsinp.B[ESI], #TSI$INACT ;Did we get something immediately?
	JNE	34$			;No - must wait

;Here with data ready in the input buffer

20$:	MOVL	EAX, tdb_ibpnt[ESI]	;Get next character
	MOVL	EDX, tdb_ibufr[ESI]
	MOVL	EAX, [EDX+EAX*4]
	TESTB	tdb_modem.B[ESI], #TMC$MODEM ;Using modem control?
	JE	28$.S			;No - go on
	BTZL	EAX, #KB%CARDET		;Yes - have carrier for this character?
	JC	26$.S			;Yes
	TESTB	tio_hifunc.B[EBP], #QFNC$OOBD>8 ;No - should we have it?
	JNE	28$.S			;No - go on
	MOVL	EAX, #ER_MDNCN		;Yes - fail!
	JMP	24$.S

22$:	MOVL	EAX, #ER_MDICN
24$:	JMP	inpdn

;Here if have carrier for the character

26$:	TESTB	tio_hifunc.B[EBP], #QFNC$OOBD>8 ;Should we have carrier here?
	JNE	22$.S			;No - fail!
28$:	BTZL	EAX, #31t		;Already have ASCII code?
	JC	32$.S			;Yes
	PUSHL	EBX			;No - save registers we need to use here
	PUSHL	ECX			;Convert to ASCII and external scan
	CALL	trmgetascii#		;  code
	BTL	tdb_imode.B[ESI], #TIM%PCSCNC ;Using PC mode scan codes?
	JC	30$.S			;Yes
	TESTL	EAX, #KB$LFTALT|KB$RHTALT ;No - was either ALT key pressed?
	JE	30$.S			;No
	CMPB	AL, #0			;Yes - non-ASCII code?
	JE	30$.S			;Yes
	ORB	AL, #80h		;No - set the high bit for ALT
30$:	MOVZBL	EBX, tdb_scstate.B[ESI]	;Dispatch on special code state
	JMPIL	CS:xspcddsp[EBX*4]

	.MOD	4
xspcddsp:
	.LONG	xspcdnrm	;SCS_NORM = 0 - Normal
	.LONG	xspcd2c		;SCS_SC1  = 1 - 2st character of special code
	.LONG	xspcd3c		;SCS_SC2  = 2 - 3rd character of special code
	.LONG	xspcd4c		;SCS_SC3  = 3 - 4th character of special code
	.LONG	xspescf		;SCS_ESCF = 4 - ESC function character next
	.LONG	xspesc1		;SCS_ESC1 = 5 - 1st ESC sequence character
				;		  next
	.LONG	xspesc2		;SCS_ESC2 = 6 - 2nd ESC sequence character
				;		  next
	.LONG	xspesc3		;SCS_ESC3 = 7 - 3rd ESC sequence character
				;		  next

;Here if already have ASCII code

32$:	INCL	tdb_ibpnt[ESI]		;Bump buffer pointer
	DECL	tdb_ibcnt[ESI]		;Reduce the character count
	JNE	inphvchar
	ANDB	tdb_stsinp.B[ESI], #{~TSI$INAVL}&0FFh
	JMP	inphvchar

;Here if nothing to get

34$:	CMPB	tio_xff.B[EBP], #0	;In extended fork context?
	JE	36$.S			;No
	MOVL	EAX, tio_timeout.B[EBP]	;Yes - get timeout value
	CALL	knlXfWait#		;Wait
	JNC	inplp			;Continue if OK
	ANDB	tdb_stsinp.B[ESI], #~TSI$INACT ;Error - indicate input not
	JMP	inpdn			       ;  active

;Here to wait if not in extended fork context

36$:	CLRL	ECX
	CMPL	tio_timeout.B[EBP], #0.B ;Want to wait at all?
	JE	38$.S			;No
	MOVL	EBX, #QSTS$WAIT		;Yes
	CLRL	EAX			;NEED TO IMPLEMENT A TIMEOUT HERE!!!
	LEAVE
	RET

;Here if want immediate time-out

38$:	ANDB	tdb_stsinp.B[ESI], #~TSI$INACT ;Indicate input not active
	MOVL	EBX, #QSTS$DONE
	MOVL	EAX, #ER_NORSP
	LEAVE
	RET
.PAGE
;Here if not returning special code

xspcdnrm:				;Always want scan codes?
	TESTL	tdb_imode.B[ESI], #TIM$SCNCODE|TIM$SCNALL
	JNE	8$			;Yes
	TESTL	tdb_imode.B[ESI], #TIM$ANSI7|TIM$ANSI8 ;No - want ANSI ESC
						       ;  sequences?
	JE	3$.S			;No
	MOVZBL	EDX, AH			;Yes - does this key generate one?
	MOVZBL	EDX, keyansitbl#[EDX]
	TESTL	EDX, EDX
	JNE	4$.S			;Yes
1$:	TESTB	AL, AL			;No - have ASCII code?
	JNE	12$			;Yes - just return it
	DECL	tdb_ibcnt[ESI]		;No - ignore the key!
	JNE	2$.S
	ANDB	tdb_stsinp.B[ESI], #{~TSI$INAVL}&0FFh
2$:	JMP	16$

;Here if do not want ANSI ESC sequences

3$:	TESTB	AL, AL			;Have ASCII code?
	JNE	12$			;Yes - just return it
	JMP	8$.S			;No - return NULL sequence

;Here with key which generates an ESC sequence

4$:	BTZL	EDX, #7			;Need to check for shift, etc.?
	JNC	47$.S			;No
	TESTL	tdb_keysts0.B[ESI], #KS0$LSHFT|KS0$RSHFT|KS0$LCTRL|KS0$RCTRL
	JE	47$.S
	INCL	EDX
47$:	MOVL	EDX, aesbase#[EDX*4]	;Get the ESC sequence data
	MOVL	tdb_escseq.B[ESI], EDX	;Save it
	MOVZBL	EDX, DL			;Get just the function index
	TESTL	EDX, EDX		;Need to check keypad mode?
	JNE	5$.S			;No
	TESTB	tdb_stsansi.B[ESI], #TSA$KPAMOD ;Yes
	JE	1$.S			;In numeric keypad mode - just return
					;  ASCII character
5$:	BTL	tdb_imode.B[ESI], #TIM%ANSI8 ;Want 8 bit codes?
	JC	6$.S			;Yes
	MOVB	tdb_scstate.B[ESI], #SCS_ESCF ;No use 7 bit codes
	MOVB	AL, #ESC
	JMP	14$			;Give him an ESC first

;Here if want 8-bit ESC sequence

6$:	MOVB	tdb_scstate.B[ESI], #SCS_ESC1
	MOVB	AL, escf8bit#[EDX]	;Get the 8-bit function code
	JMP	14$

;Here if need second character of special code

xspcd2c:MOVB	AL, AH			;Get the scan-code value
	BTL	tdb_imode.B[ESI], #TIM%PCSCNC ;Want PC mode codes?
	JC	10$.S			;Yes - finished with this
	JMP	8$.S			;No - advance state

;Here if need third character of special code

xspcd3c:SHRL	EAX, #16t		;Get shift-control-ALT bits
8$:	INCB	tdb_scstate.B[ESI]	;Advance state
	JMP	14$

;Here if need fourth character of special code

xspcd4c:SHRL	EAX, #24t		;Get the lock bits
	JMP	10$.S

;Here if need ESC sequence function character

xspescf:MOVZBL	EDX, tdb_escseq+0.B[ESI] ;Get ESC function
	MOVB	AL, escf7bit#[EDX]	;Get corresponding 7-bit character
	JMP	8$.S			;Continue

;Here if need first character of ESC sequence

xspesc1:MOVB	AL, tdb_escseq+1.B[ESI]	;Get first character
	CMPB	tdb_escseq+2.B[ESI], #0	;Is there a second character?
	JNE	8$.S			;Yes
	JMP	10$.S			;No - this is the last one

;Here if need secnd character of ESC sequence

xspesc2:MOVB	AL, tdb_escseq+2.B[ESI]	;Get second character
	CMPB	tdb_escseq+3.B[ESI], #0	;Is there a third character?
	JNE	8$.S			;Yes
	JMP	10$.S			;No - this is the last one

;Here if need third character of ESC sequence

xspesc3:MOVB	AL, tdb_escseq+3.B[ESI]	;Get third character
10$:	MOVB	tdb_scstate.B[ESI], #SCS_NORM ;Reset state
12$:	INCL	tdb_ibpnt[ESI]		;Bump buffer pointer
	DECL	tdb_ibcnt[ESI]		;Reduce the character count
	JNE	14$.S
	ANDB	tdb_stsinp.B[ESI], #{~TSI$INAVL}&0FFh
14$:	POPL	ECX			;Restore registers
	POPL	EBX
	MOVZBL	EAX, AL			;Clear high 24 bits
inphvchar:
	INCL	tio_amount.B[EBP]	;Count it
	IFFAULT	24$
	MOVB	ES:[EBX], AL		;Store character in memory
	INCL	EBX			;Bump pointer
16$:	CMPL	tdb_ibcnt[ESI], #0.B	;More there?
	JNE	20$.S			;Yes - continue
	TESTB	tdb_imode.B[ESI], #TIM$XIMAGE|TIM$IMAGE ;No - line mode?
	JNE	18$.S			;No
	TESTB	tdb_imode.B[ESI], #TIM$CHAR ;Maybe
	JNE	22$.S			;Yes - finished here
18$:	BTL	tdb_imode.B[ESI], #TIM%DEFER ;No - should we stop now?
	JNC	22$.S			;Yes
20$:	DECL	ECX			;No - more space in buffer?
	JG	inplp			;Yes - continue
22$:	CLRL	EAX			;No - stop input now
inpdn:	MOVL	ECX, tio_amount.B[EBP]	;Get count
	MOVL	EBX, #QSTS$DONE
	LEAVE
ret008:	RET

;Here if address error while copying line to user's buffer

	FAULTHDR
24$:	MOVL	EAX, #ER_ADRER		;Try to report the error!
	JMP	inpdn.S
.PAGE
	.SBTTL	sd_outblock - Output block

;Here for the output block entry
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	c{ECX} = IO command bits
;	CALL	trmoutblk
;	C:set = Error
;	  c{EAX} = Error code
;	  c{EBX} = Status bits
;	  c{ECX} = Amount output
;	C:clr = Normal
;	  c{EBX} = Status bits
;	  c{ECX} = Amount output

trmoutblk::
	BTL	dcb_dsp.B[EDI], #DS%QOUT ;Can we do queued output?
	JNC	2$.S			;No
	TESTB	iorb_func+1.B[ESI], #QFNC$DIO>8 ;Yes - do we want to?
	JE	trmoutblkq		;Yes
2$:	BTL	ECX, #O%OUT		;No - is output allowed?
	JC	4$.S			;Yes - go on
	CMPL	iorb_count.B[ESI], #0.B ;No - really doing output?
	JNE	knlIllOutGQ#		;Yes - fail
4$:	ENTER	tio_SIZE, 0
	CLRL	EAX
	MOVB	tio_xff.B[EBP], AL
	MOVB	tio_cont.B[EBP], AL
	DECL	EAX
	MOVL	tio_timeout.B[EBP], EAX
	MOVB	tio_out.B[EBP], AL
	TOFORK
	MOVL	tio_iorb.B[EBP], ESI
	MOVL	EBX, ESI
	CALL	knlGetTdb
	JC	14$.S
	CMPL	iorb_parm.B[EBX], #0.B	;Do we have a parameter list?
	JE	6$.S			;No
	IFFAULT	16$
	LFSL	EDX, iorb_parm.B[EBX]	;Yes - get address of parameter list
	PUSHL	EBX
	MOVL	EBX, #trmioparms	;Process parameters
	MOVL	ECX, #knlComDPParms#
	CALL	knlProcDevParm#
	POPL	EBX
	JC	14$.S			;If error
6$:	MOVL	ECX, iorb_count.B[EBX]	;Get count
	JREGZ	ECX, 12$		;Finished if 0
	IFFAULT	16$
	LESL	EDX, iorb_buffer1.B[EBX] ;Get address of string
	XCHGL	ESI, EBX
	CALL	knlGiveQel#		;Give up the IORB
	MOVL	ESI, EBX		;Get TDB offset in right register
	MOVL	EBX, EDX
	MOVL	EDX, tio_timeout.B[EBP]	;Get time-out value
	MOVL	EAX, tdb_ddisp.B[ESI]	;Dispatch to driver routine
	CALLI	CS:tf_doutblk.B[EAX]
8$:	TESTL	ESI, ESI
	JE	10$.S
	MOVL	EDI, [ESI]		;Get offset of DCB
	LEAVE
	RET

10$:	CLRL	EDI
	LEAVE
	RET

12$:	CLRL	EAX
14$:	XCHGL	ESI, EBX
	CALL	knlGiveQel#
	MOVL	ESI, EBX
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	JMP	8$.S

	FAULTHDR
16$:	MOVL	EAX, #ER_ADRER
	JMP	14$.S
.PAGE
;Here if should do queued output

trmoutblkq:
	CALL	knlIoQabLock#		;Lock the QAB
	JC	2$.S			;If error
	CALL	knlIoWriteLock#		;Lock the buffer
trmoutblk2:
	JC	2$.S			;If error
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #trmoutblkf
	JMP	knlXfQueue#		;Switch to extended fork context

2$:	TOFORK
	RET

trmoutblkf:
	BTL	SS:xffCmd#, #O%OUT	;Is output allowed?
	JC	14$.S			;Yes - go on
	CMPL	SS:xffCount#, #0.B	;No - really doing output?
	JNE	knlIllOut#		;Yes - fail
14$:	ENTER	tio_SIZE, 0		;No - OK
	CLRL	EAX
	MOVB	tio_cont.B[EBP], AL
	MOVL	tio_delay.B[EBP], EAX
	DECL	EAX
	MOVB	tio_out.B[EBP], AL
	MOVB	tio_xff.B[EBP], AL
	CALL	knlGetTdb		;Get our TDB
	JC	20$.S			;If error
	CMPL	SS:xffParm#, #0.B	;OK - do we have a parameter list?
	JE	16$.S			;No
	IFFAULT	knlQAdrErr0Lv#
	LFSL	EDX, SS:xffParm#	;Yes - get address of parameter list
	MOVL	EBX, #trmioparms	;Process parameters
	MOVL	ECX, #knlComDPParms#
	CALL	knlProcDevParm#
	JC	20$.S			;If error
	MOVL	EAX, tio_delay.B[EBP]	;OK - want any initial delay?
	TESTL	EAX, EAX
	JE	16$.S			;No
	CALL	knlXfTimeWait#		;Yes - do the delay
	JC	20$.S			;If error during the delay
16$:	MOVL	ECX, SS:xffCount#	;Get count
	JREGZ	ECX, 18$		;Finished if 0
	IFFAULT	knlQAdrErr0Lv#
	LESL	EBX, SS:xffBuffer1#	;Get address of string
	MOVL	EAX, tdb_ddisp.B[ESI]	;Dispatch to driver routine
	CALLI	CS:tf_qoutblk[EAX]
	LEAVE
	RET

;Here if nothing to output

18$:	CLRL	EAX
	JMP	22$.S

;Here if error

20$:	CLRL	ECX
22$:	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET
.PAGE
	.SBTTL	sd_outstring - Output string

;Here for the output string entry
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IORB
;	CALL	trmoutstrm
;	C:set = Error
;	  c{EAX} = Error code
;	  c{EBX} = Status bits
;	  c{ECX} = Amount output
;	C:clr = Normal
;	  c{EBX} = Status bits
;	  c{ECX} = Amount output

trmoutstr::
	BTL	dcb_dsp.B[EDI], #DS%QOUT ;Can we do queued output?
	JNC	2$.S			;No
	TESTB	iorb_func+1.B[ESI], #QFNC$DIO>8 ;Yes - do we want to?
	JE	12$			;Yes
2$:	ENTER	tio_SIZE, 0		;No
	CLRL	EAX
	MOVB	tio_xff.B[EBP], AL
	MOVB	tio_cont.B[EBP], AL
	MOVL	tio_delay.B[EBP], EAX
	DECL	EAX
	MOVL	tio_timeout.B[EBP], EAX
	MOVB	tio_out.B[EBP], AL
	TOFORK
	MOVL	tio_iorb.B[EBP], ESI
	MOVL	EBX, ESI
	CALL	knlGetTdb
	JC	6$.S
	CMPL	iorb_parm.B[EBX], #0.B	;No - Do we have a parameter list?
	JE	4$.S			;No
	IFFAULT	knlQAdrErr0#
	LFSL	EDX, iorb_parm.B[EBX]	;Yes - get address of parameter list
	PUSHL	EBX
	MOVL	EBX, #trmioparms	;Process parameters
	MOVL	ECX, #knlComDPParms#
	CALL	knlProcDevParm#
	POPL	EBX
	JC	6$.S			;If error
4$:	IFFAULT	knlQAdrErr0#
	LESL	EDX, iorb_buffer1.B[EBX] ;Get address of string
	MOVL	ECX, iorb_count.B[EBX]	;Get count
	XCHGL	ESI, EBX
	CALL	knlGiveQel#		;Give up the IORB
	MOVL	ESI, EBX
	MOVL	EBX, EDX
	MOVL	EAX, tdb_ddisp.B[ESI]	;Dispatch to driver routine
	CALLI	CS:tf_doutstr.B[EAX]
	LEAVE
	RET

;Here if error

6$:	MOVL	ESI, EBX
	CALL	knlGiveQel
8$:	LEAVE
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

;Here is terminal can do queued output

12$:	CALL	knlIoQabLock#		;Lock the QAB
	JC	14$.S			;If error
	CALL	knlIoStringLock#	;Get length of string and lock pages
14$:	JMP	trmoutblk2		;Continue
.PAGE
	.SBTTL	sd_getiosts - Get input/output status

;Here for the get input/output status entry
;	c(DL)  = 0 if want input status, 1 if want output status
;	c{EDI} = Offset of DCB
;	CALL	trmiosts
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0 if ready, -1 if not ready

trmiosts::
	CMPB	DL, #0			;Want input status?
	JNE	knlRtnMOne#		;No - output - always say ready for now!
	CALL	knlGetTdb		;Yes - get offset of the TDB
	JC	knlRtnMOne#		;If error
	CLRL	EAX			;Assume no input
	MOVL	ECX, tdb_ircnt[ESI]	;Right?
	ORL	ECX, tdb_ibcnt[ESI]
	JE	4$.S			;Yes
	DECL	EAX			;No - indicate have data
4$:	RET
.PAGE
	.SBTTL	trmbgninput - Subroutine to begin input

;Subroutine to begin input

trmbgninput::
	CLRL	EAX
	MOVL	tdb_ibpnt[ESI], EAX	;Initialize input buffer
	MOVL	tdb_ibpos[ESI], EAX
	MOVL	tdb_ibcnt[ESI], EAX
	ANDB	tdb_stsinp.B[ESI], #{~{TSI$ICWAIT|TSI$INAVL}}&0FFh
					;Not waiting for image character
	ANDB	tdb_stsinp.B[ESI], #~TSI$OVER ;Assume want insert type input
	BTL	tdb_imode.B[ESI], #TIM%OVER ;Right?
	JNC	2$.S			;Yes
	ORB	tdb_stsinp.B[ESI], #TSI$OVER ;No - want overlay type input
2$:	ORB	tdb_stsinp.B[ESI], #TSI$INACT ;Indicate input is active
	CMPL	tdb_ircnt[ESI], EAX	;Anything there to echo now?
	JE	4$.S			;No
	TOFORK	10$.S			;Yes - make sure at fork level
	CALL	10$
	FROMFORK
4$:	RET

10$:	BTSL	tdb_stsout.B[ESI], #TSO%OUTA ;Is terminal output active now?
	JC	12$.S			;Yes
	ORB	tdb_stsinp+1.B[ESI], #TSI$NORSM>8
	PUSHL	EBX			;No
	PUSHL	ECX
	PUSHL	EDX
	PUSHL	ES
	MOVL	EAX, tdb_ddisp.B[ESI]	;Start it up
	CALLI	CS:tf_resume.B[EAX]
	POPL	ES
	POPL	EDX
	POPL	ECX
	POPL	EBX
	ANDB	tdb_stsinp+1.B[ESI], #~{TSI$NORSM>8}
12$:	RET
.PAGE
	.SBTTL	trmgetpc - Subroutine to get PC format code from terminal

;Subroutine to get PC format code from terminal
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of TDB
;	CALL	trmgetpc
;	C:set = Nothing available now, at fork level!
;	C:clr = Normal
;	  c[AX] = 2 byte PC character value

trmgetpc::

;;;;;;;	CMPL	tdb_ircnt[ESI], #0.B	;Any input buffered?
;;;;;;;	JNE	6$.S

;;;;;;;	MOVZWL	EBX, SS:pdaRMPage0#+bda_vkeytak ;Get BIOS ring taker
;;;;;;;	CMPW	SS:pdaRMPage0#+bda_vkeyput, BX ;Anything in BIOS ring buffer?
;;;;;;;	JE	6$.S			;No
;;;;;;;	CMPL	EBX, #bda_vkeybufr-400h+32t.B ;Yes - make sure pointer is OK
;;;;;;;	JAE	4$.S
;;;;;;;	CMPL	EBX, #bda_vkeybufr-400h.B
;;;;;;;	JB	4$.S
;;;;;;;	MOVZWL	EAX, SS:pdaRMPage0#+400[EBX] ;Get character
;;;;;;;	ADDL	EBX, #2.B		;Bump pointer
;;;;;;;	CMPL	EBX, #bda_vkeybufr-400h+32t.B ;Check for warp-around
;;;;;;;	JB	2$.S
;;;;;;;	MOVB	BL, #bda_vkeybufr-400h
;;;;2$:	MOVB	SS:pdaRMPage0#+bda_vkeytak, BL ;Update pointer
;;;;;;;	CLC				;Make sure C is clear
;;;;;;;	RET				;Return with character

;Here if have bad BIOS ring buffer pointer - reset the BIOS ring buffer

;;;;4$:	MOVW	SS:pdaRMPage0#+bda_vkeytak, #bda_vkeybufr-400h
;;;;;;;	MOVW	SS:pdaRMPage0#+bda_vkeyput, #bda_vkeybufr-400h

;Here if nothing in the page 0 BIOS ring buffer

6$:	CALL	trmpcc			;Get character
	JC	14$.S			;If none there
	MOVL	EBX, tdb_irtak[ESI]
	ADDL	EBX, #4.B		;Bump the pointer
	CMPL	EBX, tdb_ibufr[ESI]	;At end of ring now?
	JB	10$.S			;No
	MOVL	EBX, tdb_iring[ESI]	;Yes - reset pointer to beginning
10$:	MOVL	tdb_irtak[ESI], EBX
	DECL	tdb_ircnt[ESI]		;Reduce the input ring count
	TESTB	tdb_stsinp+1.B[ESI], #TSI$IRBHELD>8 ;Have we held off input?
	JE	12$.S			;No
	CALL	chkinheld#		;Yes - see if should start it up again
12$:	FROMFORK			;Dismiss the fork
	CLC
	RET				;Return with character

;Here if no character available

14$:	ORB	tdb_stsinp.B[ESI], #TSI$ICWAIT ;Indicate waiting for image char
	STC				;Indicate need to wait
	RET				;Return
.PAGE
	.SBTTL	trmchkpc - Subroutine to check for PC format code from terminal

;Subroutine to check for PC format code from terminal, current character is
;  returned but is not removed from the input ring
;	c{EAX} = Input mode bits to set
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of TDB
;	CALL	trmchkpc
;	C:set = Nothing available now
;	C:clr = Normal
;	  c[AX] = 2 byte PC character value

trmchkpc::

;;;;;;;	CMPL	tdb_ircnt[ESI], #0.B	;Any input buffered?
;;;;;;;	JNE	6$.S

;;;;;;;	MOVZWL	EBX, SS:pdaRMPage0#+bda_vkeytak ;Get BIOS ring taker
;;;;;;;	CMPW	SS:pdaRMPage0#+bda_vkeyput, BX ;Anythign in the BIOS ring?
;;;;;;;	JE	6$.S			;No
;;;;;;;	CMPL	EBX, #bda_vkeybufr-400h+32t.B ;Yes - make sure pointer OK
;;;;;;;	JAE	4$.S
;;;;;;;	CMPL	EBX, #bda_vkeybufr-400h.B
;;;;;;;	JB	4$.S
;;;;;;;	MOVZWL	EAX, SS:pdaRMPage0#+400[EBX] ;Get character
;;;;;;;	RET				;Return with it

;Here if have bad BIOS ring buffer pointer - reset the BIOS ring buffer

;;;;4$:	MOVW	SS:pdaRMPage0#+bda_vkeytak, #bda_vkeybufr-400h
;;;;;;;	MOVW	SS:pdaRMPage0#+bda_vkeyput, #bda_vkeybufr-400h

;Here if nothing in the page 0 BIOS ring buffer

6$:	CALL	trmpcc			;Get character
	JC	10$.S			;If none there
	FROMFORK			;Dismiss the fork
	CLC
	RET				;Return with character

10$:	FROMFORK
	STC
	RET
.PAGE
	.SBTTL	trmpcc - Subroutine to get PC format character from terminal

;Subroutine to get PC format character from terminal, character is returned
;  but is NOT removed from the ring (KB$INTERN characters are removed when
;  encountered)
;	c{EAX} = Input mode bits to set
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of TDB
;	c(DL)  = Mode (0 = 84-key keyboard, 1 = 101-key keyboard scan codes)
;	CALL	trmpcc
;	C:set = Nothing available now, AT FORK LEVEL!
;	C:clr = Normal, AT FORK LEVEL!
;	  c(AL) = ASCII code
;	  c(AH) = Scan-code
;	  c(DL) = Status bits if knl mode

trmpcc:	TOFORK				;Raise to fork level
	ANDB	tdb_stsinp.B[ESI], #~TSI$ICWAIT ;Clear image character wait
	ANDL	tdb_imode.B[ESI], #~{TIM$PC101|TIM$ANSI7|TIM$ANSI8|TIM$ECHO|TIM$CHAR}
	ORL	tdb_imode.B[ESI], EAX	;Set the input mode bits we want
	CMPL	tdb_ircnt[ESI], #0.B	;Any input buffered?
	JE	14$.S			;No
	MOVL	EBX, tdb_irtak[ESI]	;Yes - get input ring taker pointer
8$:	MOVL	EAX, [EBX]		;Get input character
	BTL	EAX, #KB%INTERN		;Should we ignore this one?
	JC	10$.S			;Yes
	CALL	trmgetascii#		;No - get corresponding ASCII code
	TESTW	AX, AX			;Is this a valid code for this mode?
	JNE	16$.S			;Yes - return it
	MOVL	EBX, tdb_irtak[ESI]	;No - get taker pointer again

;Here with input character to ignore

10$:	ADDL	EBX, #4.B		;Bump the pointer
	CMPL	EBX, tdb_ibufr[ESI]	;At end of ring now?
	JB	12$.S			;No
	MOVL	EBX, tdb_iring[ESI]	;Yes - reset pointer to beginning
12$:	MOVL	tdb_irtak[ESI], EBX
	DECL	tdb_ircnt[ESI]		;Reduce the input ring count
	JNE	8$.S			;Continue if more there
14$:	STC				;Indicate must wait
16$:	RET				;And return
.PAGE
	.SBTTL	trmiopdelay - Here for the IOPAR_DELAY parameter for input

	DPARMHDR  SET, HEXV
trmiopdelay:
	CALL	knlGetParm#		;Get his value
	JC	4$.S			;If error
	MOVL	tio_delay.B[EBP], EAX	;Store it
	RET

	.SBTTL	trmioptimeout - Here for the IOPAR_TIMEOUT parameter for input

	DPARMHDR  SET, HEXV
trmioptimeout:
	CALL	knlGetParm#		;Get his value
	JC	4$.S			;If error
	MOVL	tio_timeout.B[EBP], EAX	;Store it
4$:	RET

	.SBTTL	trmiopinpsts - Here for the IOPAR_INPSTS parameter for IO

	DPARMHDR  GET, HEXV
trmiopinpsts:
	CLRL	EAX			;Assume no input
	MOVL	ECX, tdb_ircnt[ESI]	;Right?
	ORL	ECX, tdb_ibcnt[ESI]
	JE	6$.S			;Yes
	INCL	EAX			;No - indicate have data
6$:	JMP	knlStrParm4#		;Store the value

	.SBTTL	trmiopoutsts - Here for the IOPAR_OUTSTS parameter for IO

	DPARMHDR  GET, HEXV
trmiopoutsts:
	MOVL	EAX, #1			;For now, always say can take more data
	JMP	knlStrParm4#
.PAGE
	.SBTTL	knlGetDcbTdb - Subroutine to offsets of DCB and TDB

knlGetDcbTdb::
	MOVL	EAX, SS:pdaArg1#	;Get device descriptor from user's
	ANDL	EAX, #7FFFh		;  argument
	CALL	knlGetDcb#		;Get the DCB
	JC	2$.S			;If error
knlChkGetTdb::
	CMPL	dcb_ccb.B[EDI], #knlTrmCcb# ;Is it really a terminal?
	JE	knlGetTdb.S		;Yes - go on
	MOVL	EAX, #ER_NTTRM
	STC
2$:	RET

	.SBTTL	knlGetTdb - Subroutine to get offset of TDB given DCB

;Subroutine to get offset of TDB given offset of DCB
;	c{EDI} = Offset of DCB
;	CALL	knlGetTdb
;	C:clr = Normal
;	  c{ESI} = Offset of TDB
;	C:set = No TDB attached
;	  c{EAX} = Error code
;	  c{EDX} = 0 (Number of bytes input or output)

knlGetTdb::
	MOVL	ESI, dcb_trtdb.B[EDI]	;Get address of TDB
	TESTL	ESI, ESI		;Do we have one?
	JE	4$.S			;No - fail
	RET				;Yes

;Here if no TDB

4$:	CLRL	EDX			;Clear EDX
	MOVL	EAX, #ER_NTRDY
	STC
	RET
.PAGE
	.SBTTL	trmcinpmode - Here for the IOPAR_TRMCINPMODE IO parameter

;Here for the IOPAR_TRMCINPMODE IO parameter - clear input mode bits

	DPARMHDR  BOTH, HEXV
trmiocinpmode:
	CMPB	tio_cont.B[EBP], #0
	JE	trmcinpmode.S
	RET

	DPARMHDR  BOTH, HEXV
trmcinpmode:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	18$			;No
	PUSHL	EAX
	CALL	knlGetParm#		;Yes - get value
	JC	6$.S
	NOTL	EAX
	MOVL	EDX, tdb_imode.B[ESI]	;Get previous bits
	ANDL	tdb_imode.B[ESI], EAX	;Clear bits
	TESTB	AL, #TIM$DEBUG		;Clearing debug mode
	JNE	1$.S			;No
	TESTB	DL, #TIM$DEBUG		;Yes - was it already clear?
	JE	1$.S			;Yes
	MOVB	AL, tdb_svstsinp.B[ESI]	;No - restore some input status bits
	MOVB	tdb_stsinp.B[ESI], AL
1$:	TESTB	AL, #TIM$IMAGE		;Did we clear the image bit?
	JNE	2$.S			;No
	TESTB	tdb_imode.B[ESI], #TIM$CHAR ;Yes - in character mode now?
	JNE	10$.S			;Yes - make all characters be data
	JMP	4$.S			;  forwarding characters

;Here if did not clear the TIM$IMAGE bit

2$:	TESTB	tdb_imode.B[ESI], #TIM$IMAGE ;Image mode now?
	JNE	12$.S			;Yes - don't check for line mode
	TESTB	AL, #TIM$CHAR		;No - did we just clear character mode?
	JNE	12$.S			;No
4$:	CALL	trmsetdfcline		;No - set up line mode data forwarding
	JMP	12$.S			;  characters

6$:	POPL	EBX
8$:	RET

	.SBTTL	trmsinpmode - Here for the IOPAR_TRMSINPMODE IO parameter

;Here for the IOPAR_TRMSINPMODE IO parameter - set input mode bits

	DPARMHDR  BOTH, HEXV
trmiosinpmode:
	CMPB	tio_cont.B[EBP], #0
	JE	trmsinpmode.S
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	8$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm#
	ANDL	EAX, #TIM$XIMAGE.B
	ORL	tdb_imode.B[ESI], EAX
	POPL	EAX
	RET

	DPARMHDR  BOTH, HEXV
trmsinpmode:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	18$.S			;No
	PUSHL	EAX
	CALL	knlGetParm#		;Yes - get value
	JC	6$.S
	MOVL	EDX, tdb_imode.B[ESI]	;Get previous bits
	ORL	tdb_imode.B[ESI], EAX	;Set bits
	TESTB	AL, #TIM$DEBUG		;Setting debug mode
	JE	9$.S			;No
	TESTB	DL, #TIM$DEBUG		;Yes - was it already set?
	JNE	9$.S			;Yes
	MOVB	AL, tdb_stsinp.B[ESI]	;No - save some input status bits
	MOVB	tdb_svstsinp.B[ESI], AL
9$:	TESTB	AL, #TIM$IMAGE		;Did we set image mode?
	JNE	10$.S			;Yes
	TESTB	tdb_imode.B[ESI], #TIM$IMAGE ;No - in image mode now?
	JNE	12$.S			;Yes - don't check for character mode
	TESTB	AL, #TIM$CHAR		;No - did we set character mode?
	JE	12$.S			;No
10$:	CALL	trmsetdfcimg		;Yes - make all characters be data
					;  forwarding characters
12$:	CMPL	tdb_imode.B[ESI], EDX	;Did we change any bits?
	JE	16$.S			;No - go on
14$:	MOVL	EAX, tdb_ddisp.B[ESI]	;Yes tell the driver which input bits
	CALLI	CS:tf_imodechng[EAX]	;  we changed
16$:	POPL	EAX
18$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No
	MOVL	EAX, tdb_imode.B[ESI]	;Yes - return current value
	JMP	knlStrParm4#
.PAGE
	.SBTTL	trmcoutmode - Here for the IOPAR_TRMCOUTMODE IO parameter

;Here for the IOPAR_TRMCOUTMODE IO parameter - clear output mode bits

	DPARMHDR  BOTH, HEXV
trmiocoutmode:
	CMPB	tio_cont.B[EBP], #0
	JE	trmcoutmode.S
	RET

	DPARMHDR  BOTH, HEXV
trmcoutmode:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	PUSHL	EAX
	CALL	knlGetParm#		;Yes - get value
	JC	6$.S
	NOTL	EAX
	ANDL	tdb_omode.B[ESI], EAX	;Clear bits
2$:	POPL	EAX
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No
	MOVL	EAX, tdb_omode.B[ESI]	;Yes - get value
	JMP	knlStrParm4#

6$:	POPL	EBX
8$:	RET

	.SBTTL	trmsoutmode - Here for the IOPAR_TRMSOUTMODE IO parameter

;Here for the IOPAR_TRMSOUTMODE IO parameter - set output mode bits

	DPARMHDR  BOTH, HEXV
trmiosoutmode:
	CMPB	tio_cont.B[EBP], #0
	JE	trmsoutmode.S
	RET

	DPARMHDR  BOTH, HEXV
trmsoutmode:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	PUSHL	EAX
	CALL	knlGetParm#		;Yes - get value
	JC	6$.S
	ORL	tdb_omode.B[ESI], EAX	;Set bits
	JMP	2$.S
.PAGE
	.SBTTL	trmbfrlimit - Here for the IOPAR_TRMBFRLIMIT IO parameter

;Here for the IOPAR_TRMBFRLIMIT IO parameter - set input buffer limit

	DPARMHDR  SET, HEXV
trmiobfrlimit:
	CMPB	tio_cont.B[EBP], #0
	JE	trmbfrlimit.S
	RET

	DPARMHDR  SET, HEXV
trmbfrlimit:
	CALL	knlGetParm#		;Get value
	JC	4$.S
	CMPL	EAX, tdb_ibsize[ESI]	;Is the value too big?
	JBE	2$.S			;No
	MOVL	EAX, tdb_ibsize[ESI]	;Yes - just make it as big as we can
2$:	MOVL	tdb_iblen[ESI], EAX	;Store buffer limit
	CLC
4$:	RET

	.SBTTL	trmclrinpbufr - Here for the IOPAR_TRMCLRBUFR IO parameter

;Here for the IOPAR_TRMCLRBFR IO parameter - clear buffer

	DPARMHDR  SET, HEXV
trmioclrbufr:
	CMPB	tio_cont.B[EBP], #0
	JE	trmclrbufr.S
	RET

	DPARMHDR  SET, HEXV
trmclrbufr:
	CALL	knlGetParm#		;Get value
	JC	4$.S			;If error
	TESTB	AL, #CB$OUTPUT		;Want to clear output buffer?
	JE	10$.S			;No
	PUSHL	EAX			;Yes
	CALL	trmcorg#
	POPL	EAX
10$:	TESTB	AL, #CB$INPUT		;Want to clear input buffer?
	JE	12$.S			;No
	PUSHL	EAX			;Yes
	CALL	trmcirg#
	POPL	EAX
12$:	TESTB	AL, #CB$AHEAD		;Want to clear type-ahead buffer?
	JE	14$.S			;No
	CALL	trmclrtypa#		;Yes
14$:	CLC
	RET

	.SBTTL	trmcurtype - Here for the IOPAR_TRMCURTYPE IO parameter

;Here for the IOPAR_TRMCURTYPE IO parameter - Set or get cursor type

	DPARMHDR  BOTH, HEXV
trmiocurtype:
	CMPB	tio_cont.B[EBP], #0
	JE	trmcurtype.S
	RET

	DPARMHDR  BOTH, HEXV
trmcurtype:
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE
	.SBTTL	trmcurpos - Here for the IOPAR_TRMCURPOS IO parameter

;Here for the IOPAR_TRMCURPOS IO parameter - Set or get cursor position

	DPARMHDR  BOTH, HEXV
trmiocurpos:
	CMPB	tio_cont.B[EBP], #0
	JE	trmcurpos.S
	RET

	DPARMHDR  BOTH, HEXV
trmcurpos:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	6$.S			;No
	PUSHL	EAX
	PUSHL	ECX
	PUSHL	EBX
	PUSHL	ES
	CALL	knlGetParm#		;Yes - get value
	POPL	ES
	POPL	EBX
	POPL	ECX
	JC	10$.S
	MOVZBL	EBX, tdb_dsppage[ESI]
	CMPL	ECX, #2.B		;Have a 2 byte value?
	JA	2$.S			;No
	MOVZBL	ECX, AL			;Yes - use two 8 bit values
	MOVZBL	EDX, AH
	JMP	4$.S

2$:	MOVZWL	ECX, AX			;Use 2 word values
	MOVL	EDX, EAX
	SHRL	EDX, #16t
4$:	MOVL	EAX, tdb_ddisp.B[ESI]	;Dispatch to driver for this function
	CALLI	CS:tf_curpos.B[EAX]
	JC	10$.S
	POPL	EAX
6$:	TESTB	AH, #PAR$GET
	JE	12$.S

	PUSHL	ECX
	PUSHL	EBX
	PUSHL	ES
	CLRL	ECX
	DECL	ECX
	MOVL	EDX, ECX
	MOVZBL	EBX, tdb_dsppage[ESI]
	MOVL	EAX, tdb_ddisp.B[ESI]	;Dispatch to driver for this function
	CALLI	CS:tf_curpos.B[EAX]
	POPL	ES
	POPL	EBX
	POPL	ECX
	JC	12$.S
	CMPL	ECX, #2.B
	JBE	8$.S
	SHLL	EAX, #8t
	SHRW	AX, #8
8$:	JMP	knlStrParm4#

10$:	POPL	EDX
12$:	RET
.PAGE
	.SBTTL	trmdisppage - Here for the IOPAR_TRMDISPAGE IO parameter

;Here for the IOPAR_TRMDISPAGE IO parameter - Set or get display page

	DPARMHDR  BOTH, DECV
trmiodisppage:
	CMPB	tio_cont.B[EBP], #0
	JE	trmdisppage.S
	RET

	DPARMHDR  BOTH, DECV
trmdisppage:
	TESTB	AH, #PAR$SET		;Want to change the value?
	JE	4$.S
	PUSHL	EAX
	CALL	knlGetParm#		;Get parameter value
	JC	6$.S
	MOVL	EBX, EAX
	MOVL	EAX, tdb_ddisp.B[ESI]	;Dispatch to driver for this function
	CALLI	CS:tf_dsppage.B[EAX]
	JC	6$.S
	POPL	EAX
4$:	TESTB	AH, #PAR$GET		;Want to get the value?
	JE	8$.S			;No
	MOVZBL	EAX, tdb_dsppage[ESI]	;Yes
	JMP	knlStrParm4#

6$:	POPL	EDX
8$:	RET
.PAGE
	.SBTTL	trmmodem - Here for the IOPAR_TRMSPMODEM IO parameter

;Here for the IOPAR_TRMSPMODEM IO parameter - Set or return modem control bits
;  for serial port
;	Bit 0 of value specifies and returns DTR state
;	Bit 1 of value specifies and returns RTS state
;	Bit 4 of value returns CTS state
;	Bit 5 of value returns DSR state
;	Bit 7 of value returns CD state
;	Other bits are not used and should be 0

	DPARMHDR  BOTH, HEXV
trmiomodem:
	CMPB	tio_cont.B[EBP], #0
	JE	trmmodem.S
	RET

	DPARMHDR  BOTH, HEXV
trmmodem:
	TESTB	AH, #PAR$SET		;Want to change the value?
	JE	4$.S
	PUSHL	EAX
	CALL	knlGetParm#		;Get parameter value
	JC	6$.S
	PUSHL	EAX
	ANDL	EAX, #01h.B
	MOVL	ECX, tdb_ddisp.B[ESI]
	CALLI	CS:tf_setdtr[ECX]
	POPL	EAX
	SHRL	EAX, #1t
	ANDL	EAX, #01h.B
	MOVL	ECX, tdb_ddisp.B[ESI]
	CALLI	CS:tf_setrts[ECX]
	POPL	EAX
4$:	TESTB	AH, #PAR$GET		;Want to get the value?
	JE	8$.S			;No
	MOVL	ECX, tdb_ddisp.B[ESI]	;Yes
	CALLI	CS:tf_getdsb[ECX]
	JMP	knlStrParm4#

6$:	POPL	EDX
8$:	RET
.PAGE
	.SBTTL	trmsetdfc - Here for the IOPAR_TRMSETDFC IO parameter

;Here for the IOPAR_TRMSETDFC IO parameter - Set data forwarding characters

	DPARMHDR  SET, HEXV
trmiosetdfc:
	CMPB	tio_cont.B[EBP], #0
	JE	trmsetdfc.S
	RET

	DPARMHDR  SET, HEXV
trmsetdfc:
	JREGZ	ECX, 4$
	IFFAULT	knlRtnAdrEr#
2$:	MOVZBL	EAX, ES:[EBX]		;Get character value
	INCL	EBX
	BTSL	tdb_dfctbl[ESI], EAX	;Set bit for character
	LOOP	ECX, 2$			;Continue if more
4$:	CLC
	RET

	.SBTTL	trmclrdfc - Here for the IOPAR_TRMCLRDFC IO parameter

;Here for the IOPAR_TRMCLRDFC IO parameter - Clear data forwarding characters

	DPARMHDR  SET, HEXV
trmioclrdfc:
	CMPB	tio_cont.B[EBP], #0
	JE	trmclrdfc.S
	RET

	DPARMHDR  SET, HEXV
trmclrdfc:
	JREGZ	ECX, 8$
	IFFAULT	knlRtnAdrEr#
6$:	MOVZBL	EAX, ES:[EBX]		;Get character value
	INCL	EBX
	BTZL	tdb_dfctbl[ESI], EAX	;Clear bit for character
	LOOP	ECX, 6$			;Continue if more
8$:	CLC
	RET

	.SBTTL	trmlstdfc - Here for the IOPAR_TRMLSTDFC IO parameter

;Here for the IOPAR_TRMLSTDFC IO parameter - Get or set data forwarding
;  characters using character list.  This IO parameter uses a string value
;  containing byte pairs.  Each pair contains an ASCII character code followed
;  by a DFC state value (0 or 1).

	DPARMHDR  BOTH, STR
trmiolstdfc:
	CMPB	tio_cont.B[EBP], #0
	JE	trmlstdfc.S
	RET

	DPARMHDR  BOTH, STR
trmlstdfc:
	SHRL	ECX, #1t
	TESTB	AH, #PAR$SET		;Want to change value?
	JE	16$.S			;No
	JREGZ	ECX, 16$
	PUSHL	EAX
	PUSHL	ECX
	PUSHL	EBX
	CLRL	EAX
	IFFAULT	24$
10$:	MOVB	AL, ES:[EBX]		;Get character code
	CMPB	ES:1.B[EBX], #0		;Want to set it?
	JE	12$.S			;No
	BTSL	tdb_dfctbl[ESI], EAX	;Yes
	JMP	14$.S			;Continue

12$:	BTZL	tdb_dfctbl[ESI], EAX
14$:	ADDL	EBX, #2t.B
	LOOP	ECX, 10$
	POPL	EBX
	POPL	ECX
	POPL	EAX
16$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	20$.S			;No - finished
	IFFAULT	knlRtnAdrEr#
	MOVW	FS:[EDX], #0
	JREGZ	ECX, 20$
	CLRL	EAX
	IFFAULT	knlRtnAdrEr#
18$:	MOVB	AL, ES:[EBX]		;Get character code
	BTL	tdb_dfctbl[ESI], EAX	;Get current state
	SETC	AL
	IFFAULT	knlRtnAdrEr#
	MOVB	ES:1.B[EBX], AL
	IFFAULT	knlRtnAdrEr#
	ADDW	FS:[EDX], #2.B
	ADDL	EBX, #2t.B
	LOOP	ECX, 18$
20$:	RET

;Here if address error when setting state

24$:	ADDL	ESP, #12t.B
	JMP	knlRtnAdrEr#
.PAGE
	.SBTTL	trmalldfc - Here for the IOPAR_TRMALLDFC IO parameter

;Here for the IOPAR_TRMALLDFC IO parameter - Get or set all data forwarding
;  characters using bit array.

	DPARMHDR  BOTH, STR
trmioalldfc:
	CMPB	tio_cont.B[EBP], #0
	JE	trmalldfc.S
	RET

	DPARMHDR  BOTH, STR
trmalldfc:
	CMPL	ECX, #32t.B		;Is the string too long?
	JBE	2$.S			;No
	MOVL	ECX, #32t		;Yes - just use as much as we want
2$:	TESTB	AH, #PAR$SET		;Want to set values?
	JE	4$.S			;No
	PUSHL	ECX
	PUSHL	ESI
	PUSHL	EDI
	PUSHL	ES
	PUSHL	ES
	POPL	GS
	PUSHL	DS
	POPL	ES
	LEAL	EDI, tdb_dfctbl[ESI]
	MOVL	ESI, EBX
	CLD
	IFFAULT	10$.S
	RMOVSB	[EDI], GS:[ESI]
	POPL	ES
	POPL	EDI
	POPL	ESI
	POPL	ECX
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No
	IFFAULT	knlRtnAdrEr#		;Yes
	MOVW	FS:[EDX], CX		;Give him the length we will store
6$:	PUSHL	ESI
	PUSHL	EDI
	MOVL	EDI, EBX
	ADDL	ESI, #tdb_dfctbl
	CLD
	IFFAULT	knlRtnAdrEr#
	RMOVSB	[EDI], [ESI]
	POPL	EDI
	POPL	ESI
8$:	RET

;Here if have address error when setting values

10$:	POPL	ES
	POPL	EDI
	POPL	ESI
	POPL	ECX
	POPL	EBX
	JMP	knlRtnAdrEr
.PAGE
	.SBTTL trmsetdfcimg - Set data forwarding table for image mode input

;Subroutine to set up the terminal's data forwarding table for image mode
;  input
;	CALL	trmsetdfcimg
;  EDX, EDI, and ESI are preserved

trmsetdfcimg:
	PUSHL	EDI
	PUSHL	DS
	POPL	ES
	LEAL	EDI, tdb_dfctbl[ESI]
	MOVL	EAX, #0FFFFFFFFh
	MOVL	ECX, #8t
	CLD
	RSTOSL	[EDI]
	POPL	EDI
	RET

	.SBTTL setdfcline - Set data forwarding table for line mode input

;Subroutine to set up the terminal's data forwarding table for line mode
;  input
;	CALL	setdfcline
;  EDX, EDI, and ESI are preserved

trmsetdfcline::
	PUSHL	ESI
	PUSHL	EDI
	PUSHL	DS
	POPL	ES
	LEAL	EDI, tdb_dfctbl[ESI]
	MOVL	ESI, #trmdfctbl#
	MOVL	ECX, #8t
	CLD
	RMOVSL	[EDI], [ESI]
	POPL	EDI
	POPL	ESI
	RET
.PAGE
	.SBTTL	trmccvect - Here for the IOPAR_TRMCCVECT IO parameter

;Here for the IOPAR_TRMCCVECT IO parameter - Get or set control-C vector number

	DPARMHDR  BOTH, HEXV
trmccvect::
	PUSHL	ESI
	MOVL	ESI, #dcb_trccsvect
	JMP	2$.S

	.SBTTL	trmcpvect - Here for the IOPAR_TRMCPVECT IO parameter

;Here for the IOPAR_TRMCPVECT IO parameter - Get or set control-P vector number

	DPARMHDR  BOTH, HEXV
trmcpvect::
	PUSHL	ESI
	MOVL	ESI, #dcb_trcpsvect
	JMP	2$.S

	.SBTTL	trmhuvect - Here for the IOPAR_TRMHUVECT IO parameter

;Here for the IOPAR_TRMHUVECT IO parameter - Get or set hang-up vector number

	DPARMHDR  BOTH, HEXV
trmhuvect::
	PUSHL	ESI
	MOVL	ESI, #dcb_trhusvect
2$:	ADDL	ESI, EDI
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	12$.S			;No
	PUSHL	EAX
	CALL	knlGetParm#		;Yes - get value
	JC	18$.S
	TESTL	EAX, EAX		;Clearing the vector?
	JNE	4$.S			;No
	MOVW	[ESI], AX
	MOVW	dcb_trccspda-dcb_trccsvect.B[ESI], AX
	MOVW	dcb_trccshndl-dcb_trccsvect.B[ESI], AX
	JMP	10$.S

;Here if not clearing the vector

4$:	MOVL	EDX, EAX
	CALL	knlChkVector#		;Check for valid vector number
	JC	16$.S
	MOVW	[ESI], DX		;OK - store new value
	CMPB	knlForkLvl#, #FORK_XFF
	JB	6$.S
	MOVW	AX, SS:xffPda#
	MOVW	DX, SS:xffHandle#
	JMP	8$.S

6$:	MOVL	EAX, SS
	MOVL	EDX, tio_iorb.B[EBP]
	MOVW	DX, iorb_handle.B[EDX]
8$:	MOVW	dcb_trccspda-dcb_trccsvect.B[ESI], AX
	MOVW	dcb_trccshndl-dcb_trccsvect.B[ESI], DX
	MOVZWL	EAX, dcb_sunit.B[EDI]
	SHLL	EAX, #16t
	MOVB	AL, dcb_punit.B[EDI]
10$:	MOVL	dcb_trccsdata-dcb_trccsvect.B[ESI], EAX
	POPL	EAX
12$:	TESTB	AH, #PAR$GET		;Want to get value?
	JE	14$.S			;No
	MOVZWL	EAX, [ESI] ;Yes
	CALL	knlStrParm4#
14$:	POPL	ESI
	RET

;Here if error

16$:	MOVL	EAX, #ER_PARMV
18$:	POPL	ESI
	POPL	ESI
	RET

	.SBTTL	trmccdata - Here for the IOPAR_TRMCCDATA IO parameter

;Here for the IOPAR_TRMCCDATA IO parameter - Get or set control-C vector data

	DPARMHDR  BOTH, HEXV
trmccdata::
	PUSHL	ESI
	MOVL	ESI, #dcb_trccsdata
	JMP	20$.S

	.SBTTL	trmcpdata - Here for the IOPAR_TRMCPDATA IO parameter

;Here for the IOPAR_TRMCPDATA IO parameter - Get or set control-P vector data

	DPARMHDR  BOTH, HEXV
trmcpdata::
	PUSHL	ESI
	MOVL	ESI, #dcb_trcpsdata
	JMP	20$.S

	.SBTTL	trmhudata - Here for the IOPAR_TRMHUDATA IO parameter

;Here for the IOPAR_TRMHUDATA IO parameter - Get or set hang-up vector data

	DPARMHDR  BOTH, HEXV
trmhudata::
	PUSHL	ESI
	MOVL	ESI, #dcb_trhusdata
20$:	ADDL	ESI, EDI
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	22$.S			;No
	PUSHL	EAX
	CALL	knlGetParm#		;Yes - get value
	JC	18$.S
	MOVL	[ESI], EAX		;Store new value
	POPL	EAX
22$:	TESTB	AH, #PAR$GET		;Want to get value?
	JE	24$.S			;No
	MOVL	EAX, [ESI] ;Yes
	CALL	knlStrParm4#
24$:	POPL	ESI
	RET

	END
