	.TITLE	SIGNAL - Signal routines

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR

	CODE

	.SBTTL	svcSchReqSignal - Request a signal

;Here for the svcSchReqSignal SVC - Request a signal
;	long      number;	// Vector number
;	long far *datapnt;	// Address of data array
;	long      datasize;	// Size of data array
;	long      pid;		// Process ID
;	rtn = svcSchReqSignal(number, datapnt, datasize, pid);
;  Value returned is 0 if normal or negative error code if error

rsvcSchReqSignal::
	MOVL	EBP, #pdaArg3#
	CALL	vfixaddr#
	JMP	2$.S

psvcSchReqSignal::
	SVCENTR	CNTSchReqSignal#
	MOVL	EBX, SS:pdaArg5#	;Get selector for process
2$:	CALL	getproc#
	JC	5$.S			;If error
	MOVL	EAX, ES			;Our own process?
	CMPW	knlCurPda#, AX
	JE	4$.S			;Yes - all vectors are OK
	MOVL	EAX, SS:pdaArg1#	;No - must be a protected mode XOS
	CMPL	EAX, #100h		;  vector with the remote enable bit
	JAE	10$.S			;  set
	TESTB	ES:pdaIdt#+it_type[EAX*8], #08h
	JE	10$.S
4$:	CALL	knlGetQel#
5$:	JC	8$.S
	MOVB	slb_szindx.B[ESI], #0
	MOVL	ECX, SS:pdaArg4#	;Get number of data items	
	JREGZ	ECX, 6$
	CMPL	ECX, #8.B
	JA	10$.S
	MOVL	EBX, ECX
	PUSHL	ESI
	PUSHL	ES
	IFFAULT	14$
	LEAL	EDI, slb_data.B[ESI]
	LFSL	ESI, SS:pdaArg3#
	PUSHL	DS
	POPL	ES
	CLD
	IFFAULT	12$
	RMOVSL	[EDI], FS:[ESI]
	POPL	ES
	POPL	ESI
6$:	MOVL	ECX, EBX
	MOVL	EAX, SS:pdaArg1#	;Get vector number

	CMPL	EAX, #200h
	JB	7$.S
$$$$ss1::INT3
7$:

	MOVB	BL, #SIGT_NORMAL
	CLRL	EDX
	TOFORK
	CALL	knlReqSignal
	JC	18$.S
	FROMFORK
	CLRL	EAX
8$:	RET

10$:	MOVL	EAX, #ER_VALUE
	JMP	16$.S

	FAULTHDR
12$:	POPL	ESI
	POPL	ESI
	FAULTHDR
14$:	MOVL	EAX, #ER_ADRER
16$:	JMP	knlGiveQel#

18$:	FROMFORK
	RET
.PAGE
;Here to process software interrupt request

dosint::MOVB	knlForkLvl#, #FORK_SFORK ;Raise to fork level
	JMPIL	sigdsp[EBX*4]		;Dispatch on the request

;Software interrupt request dispatch table

	DATA

	.MOD	4
sigdsp:	.LONG	systemsig	;System level request
	.LONG	siglvl7		;Level 7 request
	.LONG	siglvl6		;Level 6 reqeust
	.LONG	siglvl5		;Level 5 reqeust
	.LONG	siglvl4		;Level 4 request
	.LONG	siglvl3		;Level 3 request
	.LONG	siglvl2		;Level 2 reqeust
	.LONG	siglvl1		;Level 1 reqeust

	CODE

;Here to grant level 1 signal

siglvl1:MOVB	AL, #7Fh		;Get mask for clearing request
	MOVL	EDI, #pdaL1HeadP#	;Get pointer
	MOVW	CX, #7F01h		;Get new level and mask
	JMP	2$.S

;Here to grant level 2 signal

siglvl2:MOVB	AL, #0BFh		;Get mask for clearing request
	MOVL	EDI, #pdaL2HeadP#	;Get pointer
	MOVW	CX, #3F02h		;Get new level and mask
	JMP	2$.S

;Here to grant level 3 signal

siglvl3:MOVB	AL, #0DFh		;Get mask for clearing request
	MOVL	EDI, #pdaL3HeadP#	;Get pointer
	MOVW	CX, #1F03h		;Get new level and mask
	JMP	2$.S

;Here to grant level 4 signal

siglvl4:MOVB	AL, #0EFh		;Get mask for clearing request
	MOVL	EDI, #pdaL4HeadP#	;Get pointer
	MOVW	CX, #0F04h		;Get new level and mask
	JMP	2$.S

;Here to grant level 5 signal

siglvl5:MOVB	AL, #0F7h		;Get mask for clearing request
	MOVL	EDI, #pdaL5HeadP#	;Get pointer
	MOVW	CX, #0705h		;Get new level and mask
	JMP	2$.S

;Here to grant level 6 signal

siglvl6:MOVB	AL, #0FBh		;Get mask for clearing request
	MOVL	EDI, #pdaL6HeadP#	;Get pointer
	MOVW	CX, #0306h		;Get new level and mask
	JMP	2$.S

;Here to grant level 7 signal

siglvl7:MOVB	AL, #0FDh		;Get mask for clearing request
	MOVL	EDI, #pdaL7HeadP#	;Get pointer
	MOVW	CX, #0307h		;Get new level and mask

;Here with signal to grant
;	c(AL)  = Mask for clearing request
;	c(CL)  = New signal level
;	c(CH)  = Mask byte for new level
;	c{EDI} = Offset (in PDA) of head pointer for signal

2$:	MOVL	ESI, ES:[EDI]		;Get offset for signal link block
	TESTL	ESI, ESI		;Really have one?
	JE	4$.S			;No!
	MOVL	EDX, [ESI]		;Remove entry from the signal list
	MOVL	ES:[EDI], EDX
	TESTL	EDX, EDX		;Is list empty now?
	JNE	6$.S			;No
	MOVL	ES:pdaxxTP#.B[EDI], #0	;Yes - clear tail pointer
	ANDB	ES:pdaSigReq#, AL	;Clear request bit for level
	JMP	8$.S

4$:	CRASH	NSLB			;[No Signal Link Block]

;Here if signal list is not empty now

6$:	MOVL	slb_prev.B[EDX], #0
8$:	MOVL	EDX, slb_vector.B[ESI]	;Get vector number
sigsch2::
	CMPL	EDX, #200h		;Real mode vector?
	JAE	12$.S			;Yes

;Here with protected mode vector

	TESTB	ES:pdaIdt#+it_type[EDX*8], #87.B ;Is the vector set up?
	JNE	14$.S			;Yes
	JMP	18$.S			;No

;Here with real-mode vector

12$:	TESTB	ES:pdaStatus1#, #P1$DOSSEG|P1$BIOSSEG ;Have a real mode page 0?
	JE	18$.S			;No - ignore this signal
	CMPW	ES:pdaRMPage0#+2-200h*4[EDX*4], #100h ;Yes - is vector set up?
	JB	18$.S			;No - ignore this signal

;Here with usuable vector

14$:	MOVL	ES:pdaSigRegECX#, ECX	;Store registers we need to transfer
	MOVL	ES:pdaSigRegESI#, ESI	;  to task context
	MOVL	ES:pdaSigRegEDX#, EDX
	TESTL	ESI, ESI
	JE	16$.S
	CMPL	slb_grantsub.B[ESI], #0.B ;Do we have a grant subroutine?
	JE	16$.S			;No - go on
	MOVL	EDI, slb_grantEDI.B[ESI] ;Get data value
	CLRL	EAX			;Indicate granting signal (SGF_GRANTED)
	CALLI	slb_grantsub.B[ESI]	;Call the grant subroutine
16$:	MOVL	ES:pdaTss#+tss_EIP, #sigtask ;Change EIP
	MOVL	ES:pdaTss#+tss_CS, CS
	MOVL	ES:pdaTss#+tss_EFR, #200h
	FROMFORK
	IRET				;Switch to task context
	JMP	scheduler#		;Start over next time	

;Here if vector is not set up

18$:	TESTL	ESI, ESI		;Do we have a link block?
	JE	20$.S			;No (must be FPU exception)
	MOVL	EBX, slb_grantsub.B[ESI] ;Yes - get offset of grant subroutine
	MOVL	EDI, slb_grantEDI.B[ESI] ;Get data value
	MOVZBL	ECX, slb_szindx.B[ESI]
	CALL	knlGiveXmb#		;Give up the signal link block
	TESTL	EBX, EBX		;Do we have a grant subroutine?
	JE	20$.S			;No - go on
	MOVB	AL, #SGF_NOVECT		;Yes - indicate signal not granted
	CALLI	EBX			;Call the grant subroutine
20$:	FROMFORK
	JMP	sigchk			;Go see if have another signal
.PAGE
;Here in task context

sigtask:PUSHAL
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHL	#GS_DATA.B
	POPL	DS
	MOVZBL	EAX, SS:pdaSigRegECX#	;Get new level
	MOVL	ESI, SS:pdaSigRegESI#	;Get offset of signal link block
	MOVL	EDX, SS:pdaSigRegEDX#	;Get vector number
	MOVB	BL, SS:pdaSigLvl#	;Get previous signal level
	CMPL	EDX, #200h		;Real mode vector?
	JAE	2$.S			;Yes
	MOVB	BH, SS:pdaIdt#+it_type[EDX*8] ;No - XOS type vector?
	ANDB	BH, #07h
	CMPB	BH, #ITV_XOST
	JBE	4$.S			;Yes
2$:	MOVB	BH, BL			;No - preserve the low 2 bits
	ANDB	BH, #03
	ORB	AL, BH
4$:	MOVB	SS:pdaSigLvl#, AL	;Store new signal level
	MOVB	AL, masktbl#[EAX]	;Get corresponding mask bits
	MOVB	SS:pdaSigMask#, AL	;Store new mask value
sigready::
	MOVB	SS:pdaSigRegECX#, BL	;Save it for later
	CMPL	EDX, #200h		;Real mode vector number?
	JB	8$.S			;No
	TESTB	SS:pdaStatus1#, #P1$DOSSEG ;Yes - does this process have a DOS
					   ;  environment?

	JE	6$.S			;No!
	MOVL	EBX, SS:pdaRMPage0#-200h*4[EDX*4] ;Yes - get vector address
	CLRL	ECX
	JMP	hwvect16.S

6$:	CALL	badusrstk#


;Here if don't have a real mode hardware vector

8$:	MOVB	AL, SS:pdaIdt#+it_type[EDX*8] ;Hardware vector?
	TESTB	AL, #80h
	JE	swvect			;No
					;Yes - fall into hwvect on next page
.PAGE
;Here if have a hardware vector - there are a number of possible combinations
;  of modes as indicated here.  We attempt to emulate the behavior of the raw
;  hardware as closely as possible.  This can not be done in all cases since
;  some of the cases we support are not supported by the raw hardware.

;    Vector is a 16 bit protected mode vector:

;	Interrupt is from a 16 bit protected mode segment (this case is handled
;	  correctly by the hardware, so we just use the standard hardware stack
;	  format):
;		c[{ESP}+4] = Saved FR
;		c[{ESP}+2] = Saved CS
;		c[{ESP}+0] = Saved IP

;	Interrupt is from a 32 bit protected mode segment (this case is
;	  possible with the raw hardware, but does not work very well, we
;	  use a different stack format so it will work for all possible 32
;	  bit addresses):
;		c{{ESP}+14} = Saved EFR
;		c{{ESP}+10} = Saved CS
;		c{{ESP}+6}  = Saved EIP
;		c[{ESP}+4]  = EFR value for return routine
;		c[{ESP}+2]  = Selector of return routine
;		c[{ESP}+0]  = Offset of return routine

;	Interrupt is from a real mode segment (even though this is also a
;	  "normal" case we cannot use a standard hardware stack since the
;	  hardware will not set the VM flag in EFR on an IRET from user mode).
;	  We store a normal hardware interrupt frame with a return address
;	  pointing to an svcSchIRet instruction, followed by a normal hardware
;	  interrupt stack frame which the svcSchIRet will use to actually
;	  return to the interrupted real mode routine.
;		c{[SP]+38} = Saved user GS
;		c{[SP]+34} = Saved user FS
;		c{[SP]+30} = Saved user DS
;		c{[SP]+26} = Saved user ES
;		c{[SP]+22} = Saved user SS
;		c{[SP]+18} = Saved user ESP
;		c{[SP]+14} = Saved user EFR
;		c{[SP]+10} = Saved user CS
;		c{[SP]+6}  = Saved user EIP
;		c[[SP]+4]  = FR value for dismiss routine
;		c[[SP]+2]  = Selector of dismiss routine
;		c[[SP]+0]  = 16-bit offset of dismiss routine

;    Vector is a 32 bit protected mode vector:

;	Interrupt is from a protected mode segment (16 or 32 bit) (this is a
;	  simple "normal" case - we just use the standard hardware stack
;	  format):
;		c{{ESP}+8} = Saved EFR
;		c{{ESP}+4} = Saved CS
;		c{{ESP}+0} = Saved EIP

;	Interrupt is from a real mode segment (even though this is also a
;	  "normal" case we cannot use a standard hardware stack since the
;	  hardware will not set the VM flag in EFR on an IRET from user mode).
;	  We store a normal hardware interrupt frame with a return address
;	  pointing to an svcSchIRet instruction, followed by a normal hardware
;	  interrupt stack frame which the svcSchIRet will use to actually
;	  return to the interrupted real mode routine.
;		c{{ESP}+44} = Saved user GS
;		c{{ESP}+40} = Saved user FS
;		c{{ESP}+36} = Saved user DS
;		c{{ESP}+32} = Saved user ES
;		c{{ESP}+28} = Saved user SS
;		c{{ESP}+24} = Saved user ESP
;		c{{ESP}+20} = Saved user EFR
;		c{{ESP}+16} = Saved user CS
;		c{{ESP}+12} = Saved user EIP
;		c{{ESP}+8}  = EFR value for dismiss routine
;		c{{ESP}+4}  = Selector of dismiss routine
;		c{{ESP}+0}  = 32-bit offset of dismiss routine

;    Vector is a real mode vector

;	Interrupt is from a protected mode segment (16 or 32 bit) (this case
;	  is not possible with the raw hardware).  This is the only case where
;	  information is stored on both the real mode and protected mode stacks.
;		c[[SP]+10] = Saved protected mode interrupt SS
;		c{[SP]+6}  = Saved protected mode interrupt ESP
;		c[[SP]+4]  = FR value for dismiss routine
;		c[[SP]+2]  = Selector of dismiss routine
;		c[[SP]+0]  = 16-bit offset of dismiss routine

;	  We also save the following on the protected mode stack:
;		c{{ESP}+36} = Saved user GS
;		c{{ESP}+32} = Saved user FS
;		c{{ESP}+28} = Saved user DS
;		c{{ESP}+24} = Saved user ES
;		c{{ESP}+20} = Saved user SS
;		c{{ESP}+16} = Saved user ESP
;		c{{ESP}+12} = Saved user EFR
;		c{{ESP}+8}  = Saved user CS
;		c{{ESP}+4}  = Saved user EIP
;		c{{ESP}+0}  = Saved real mode SS:SP

;	Interrupt is from a real mode segment (this is also a simple "normal"
;	  case where we use the standard hardware stack format)
;		c[[SP]+0] = Saved IP
;		c[[SP]+2] = Saved CS
;		c[[SP]+4] = Saved FR

;  All hardware vectors use the process's current stack.  No stack switches
;    are done.

hwvect:	MOVZWL	EBX, SS:pdaIdt#+it_hoffseth[EDX*8] ;Get offset
	SHRL	EBX, #16t
	MOVW	BX, SS:pdaIdt#+it_hoffsetl[EDX*8]
	MOVZWL	ECX, SS:pdaIdt#+it_hsel[EDX*8] ;Get selector
	TESTB	SS:pdaIdt#+it_type[EDX*8], #08h ;Is this a 32-bit vector?
	JNE	hwvect32		;Yes
hwvect16:				;No
	TESTB	SS:pdaURegEFR#+2, #02h	;Is the interrupt from protected mode?
	JNE	h16frmrm		;No

;Here if interrupt is from protected mode

h16frmpm:
	TESTL	ECX, ECX		;Is this a real mode vector?
	JE	hwpm2rm.S		;Yes

;Here if interrupting to protected mode from protected with a 16-bit vector

h16pm2pm:
	LESL	EDI, SS:pdaURegESP#	;Point to his current stack
	MOVZWL	EDI, DI
	SUBL	EDI, #6t.B
	MOVL	EAX, SS:pdaURegEFR#
	ANDB	AH, #~02h		;Store the complement of bit 2 of his
	MOVB	DL, SS:pdaSigRegECX#	;  software interrupt level as the
	SHRB	DL, #1			;  interrupt enable bit in the saved
	NOTB	DL			;  EFR value
	ANDB	DL, #02h
	ORB	AH, DL
	SHLL	EAX, #16t
	MOVW	AX, SS:pdaURegCS#
	IFFCALL	sibdstk
	MOVL	ES:2.B[EDI], EAX	;Store his old FR and CS
	MOVL	EAX, SS:pdaURegEIP#	;Store his old IP
	IFFCALL	sibdstk
	MOVW	ES:[EDI], AX
	MOVW	SS:pdaURegESP, DI
	JMP	sisav4			;Continue

;Here if interrupting to real mode from protected mode

	IFFCALL	sibdstk
hwpm2rm:LESL	EDI, SS:pdaURegESP#	;Point to his current protected mode
	SUBL	EDI, #4t.B
	STD
	PUSHL	#GS_REAL32|03h.B	;  stack
	POPL	GS
	MOVZWL	EAX, SS:pdaURegGS#	;Save the protected mode segment
	IFFCALL	sibdstk			;  register values
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaURegFS#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaURegDS#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaURegES#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	EAX, SS:pdaURegSS#	;Save his protected mode stack
	IFFCALL	sibdstk			;  pointer, both on his stack and
	STOSL	[EDI]			;  as the current protected mode
	IFFCALL	sibdstk			;  stack pointer
	MOVL	GS:dda_dpmicurpSS, EAX
	LEAL	EAX, -16t.B[EDI]
	IFFCALL	sibdstk
	MOVL	GS:dda_dpmicurpESP, EAX
	ADDL	EAX, #40t.B
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	EAX, SS:pdaURegEFR#	;Save his EFR
	ANDB	AH, #~02h		;Store the complement of bit 2 of his
	MOVB	DL, SS:pdaSigRegECX#	;  software interrupt level as the
	SHRB	DL, #1			;  interrupt enable bit in the saved
	NOTB	DL			;  EFR value
	ANDB	DL, #02h
	ORB	AH, DL
	MOVL	EDX, EAX
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	EAX, SS:pdaURegCS#	;Save his CS:EIP
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	EAX, SS:pdaURegEIP#
	IFFCALL	sibdstk
	STOSL	[EDI]
	IFFCALL	sibdstk
	MOVL	EAX, GS:dda_dpmicurrSSSP ;Save his real mode stack pointer
	SUBW	GS:dda_dpmicurrSSSP, #12t.B
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EDI, AX			;Point to his current real mode stack
	SHRL	EAX, #12t
	ANDB	AL, #0F0h
	ADDL	EDI, EAX
	JE	sibdstk			;Fail if don't have a real mode stack
	MOVL	EAX, GS:dda_dpmicurpSS	;Store protected mode stack pointer on
	IFFCALL	sibdstk			;  his real mode stack
	MOVW	GS:-2t.B[EDI], AX
	MOVL	EAX, GS:dda_dpmicurpESP
	IFFCALL	sibdstk
	MOVL	GS:-6t.B[EDI], EAX
	IFFCALL	sibdstk			;Store FR value on his real mode stack
	MOVW	GS:-8t.B[EDI], DX
	IFFCALL	sibdstk
	MOVL	GS:-12t.B[EDI], #0ED000000h+rmpmiret# ;Store return address
	MOVL	SS:pdaTss#+tss_stk0, #pdaXStackV# ;Use his real mode stack
	IFFCALL	sibdstk				  ;  now
	MOVZWL	EAX, GS:dda_dpmicurrSSSP+2
	MOVL	SS:pdaURegSS#, EAX
	IFFCALL	sibdstk
	MOVZWL	EAX, GS:dda_dpmicurrSSSP+0
	MOVL	SS:pdaURegESP#, EAX
	JMP	sisav4			;Continue	

;Here if interrupt is from real mode

h16frmrm:
	TESTL	ECX, ECX		;Is this a real mode vector?
	JNE	h16rm2pm.S		;No

;Here if interrupt is from real mode with a real mode vector

hwrm2rm:MOVZWL	EAX, SS:pdaURegSS#	;Point to his real mode stack
	SHLL	EAX, #4
	MOVZWL	EDI, SS:pdaURegESP#
	LEAL	EDI, -4t.B[EDI+EAX]
	PUSHL	#GS_REAL16.B
	POPL	ES
	STD
	SUBL	SS:pdaURegESP#, #6t.B
	MOVL	EAX, SS:pdaURegEFR#
	ANDB	AH, #~02h		;Store the complement of bit 2 of his
	MOVB	DL, SS:pdaSigRegECX#	;  software interrupt level as the
	SHRB	DL, #1			;  interrupt enable bit in the saved
	NOTB	DL			;  EFR value
	ANDB	DL, #02h
	ORB	AH, DL
	SHLL	EAX, #16t
	MOVW	AX, SS:pdaURegCS#	;Store his old CS:IP
	IFFCALL	sibdstk
	MOVL	ES:[EDI], EAX
	MOVL	EAX, SS:pdaURegEIP#
	IFFCALL	sibdstk
	MOVW	ES:-2t.B[EDI], AX
	JMP	sisav4			;Continue

;Here if interrupt is from real mode with a protected mode vector

h16rm2pm:
	PUSHL	#GS_REAL16.B
	POPL	GS
	IFFCALL	sibdstk
	LESL	EDI, GS:dda_dpmicurpESP	;Point to this protected mode stack
	STD
	MOVL	EAX, SS:pdaURegESP#
	IFFCALL	sibdstk
	MOVL	GS:dda_dpmicurrSSSP+0, EAX
	MOVZWL	EAX, SS:pdaURegSS#
	IFFCALL	sibdstk
	MOVW	GS:dda_dpmicurrSSSP+2, AX
	SUBL	EDI, #32t.B
	MOVL	SS:pdaURegESP#, EDI
	ADDL	EDI, #28t.B
	MOVL	SS:pdaURegSS#, ES
	MOVZWL	EAX, SS:pdaVRegGS#	;Save the real mode segment register
	IFFCALL	sibdstk			;  values
	STOSW	[EDI]
	MOVZWL	EAX, SS:pdaVRegFS#
	IFFCALL	sibdstk
	STOSW	[EDI]
	MOVZWL	EAX, SS:pdaVRegDS#
	IFFCALL	sibdstk
	STOSW	[EDI]
	MOVZWL	EAX, SS:pdaVRegES#
	IFFCALL	sibdstk
	STOSW	[EDI]
	IFFCALL	sibdstk
	MOVZWL	EAX, GS:dda_dpmicurrSSSP+2 ;Save the real mode stack pointer
	IFFCALL	sibdstk
	STOSW	[EDI]
	IFFCALL	sibdstk
	MOVL	EAX, GS:dda_dpmicurrSSSP+0
	IFFCALL	sibdstk
	STOSW	[EDI]
	MOVL	SS:pdaTss#+tss_stk0, #pdaXStackP#
	MOVL	EAX, SS:pdaURegEFR#
	ANDB	AH, #0Dh		;Put his previous interrupt level in
	MOVB	DL, SS:pdaSigRegECX#	;  his EFR
	SHLB	DL, #4
	ORB	AH, DL
	JS	4$.S			;If software interrupts are disabled
	ORB	AH, #02h		;Enabled - set the I bit
4$:	ANDB	AH, #7Fh
	IFFCALL	sibdstk
	STOSL	[EDI]			;Store his old EFR
	MOVZWL	EAX, SS:pdaURegCS#	;Store his old CS
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	EAX, SS:pdaURegEIP#	;Store his old EIP
	IFFCALL	sibdstk
	STOSL	[EDI]
	JMP	sisav4			;Continue
.PAGE
;Here if have 32 bit hardware vector - this is always a protected mode vector

hwvect32:
	TESTB	SS:pdaURegEFR#+2, #02h	;Is the interrupt from protected mode?
	JNE	h32rm2pm.S		;No

;Here if interrupt is from protected mode

h32pm2pm:
	LESL	EDI, SS:pdaURegESP#	;Point to his current stack
	SUBL	EDI, #4t.B
	STD
	MOVL	EAX, SS:pdaURegEFR#
	ANDB	AH, #~02h		;Store the complement of bit 2 of his
	MOVB	DL, SS:pdaSigRegECX#	;  software interrupt level as the
	SHRB	DL, #1			;  interrupt enable bit in the saved
	NOTB	DL			;  EFR value
	ANDB	DL, #02h
	ORB	AH, DL
	IFFCALL	sibdstk
	STOSL	[EDI]			;Store his old EFR
	MOVZWL	EAX, SS:pdaURegCS#	;Store his old CS
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	EAX, SS:pdaURegEIP#	;Store his old EIP
	JMP	8$

;Here if interrupt is from real mode

h32rm2pm:
	PUSHL	#GS_REAL16.B
	POPL	GS
	IFFCALL	sibdstk
	LESL	EDI, GS:dda_dpmicurpESP	;Point to his protected mode stack
	SUBL	EDI, #4t.B
	STD
	MOVZWL	EAX, SS:pdaVRegGS#	;Stack the real mode segment register
	IFFCALL	sibdstk			;  values
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaVRegFS#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaVRegDS#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaVRegES#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaURegSS#	;Save the real mode stack pointer
	IFFCALL	sibdstk
	STOSL	[EDI]
	IFFCALL	sibdstk
	MOVW	GS:dda_dpmicurrSSSP+2, AX
	MOVZWL	EAX, SS:pdaURegESP#
	IFFCALL	sibdstk
	STOSL	[EDI]
	IFFCALL	sibdstk
	MOVW	GS:dda_dpmicurrSSSP+0, AX
	MOVL	EAX, SS:pdaURegEFR#
	ANDB	AH, #0Dh		;Put his previous interrupt level in
	MOVB	DL, SS:pdaSigRegECX#	;  his EFR
	SHLB	DL, #4
	ORB	AH, DL
	JS	6$.S			;If software interrupts are disabled
	ORB	AH, #02h		;Enabled - set the I bit
6$:	ANDB	AH, #7Fh
	IFFCALL	sibdstk
	STOSL	[EDI]			;Stack his old EFR
	MOVZWL	EAX, SS:pdaURegCS#	;Stack his old CS
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	SS:pdaURegESP, EDI
	MOVL	EAX, SS:pdaURegEIP#	;Stack his old EIP
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	SS:pdaTss#+tss_stk0, #pdaXStackP#
	MOVW	SS:pdaURegEFR#+2, #0
	MOVL	SS:pdaURegSS, ES
	MOVL	EAX, SS:pdaURegEFR#
	IFFCALL	sibdstk
	STOSL	[EDI]			;Store his old EFR
	MOVL	EAX, #GS_USERCODE|03h	;Stack CS for dismiss routine
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	EAX, #usriret#		;Stack EIP for dismiss routine
8$:	MOVL	SS:pdaURegESP, EDI
	IFFCALL	sibdstk
	STOSL	[EDI]
	JMP	sisav4			;Continue
.PAGE
;Here if do not have a hardware vector - we have some kind of software
;  vector

swvect:	ANDL	EAX, #07h.B		;Dispatch on the vector type
	JMPIL	swvdsp[EAX*4]

;Software interrupt type dispatch table

	DATA

swvdsp:	.LONG	badvecttype	;	     = 0 - Illegal
	.LONG	xosvect		;ITV_XOSS    = 1 - XOS signal
	.LONG	xosvect		;ITV_XOST    = 2 - XOS trap
	.LONG	dpmi16o		;ITV_DPMI16O = 3 - DPMI 16 bit v0.9 exception
	.LONG	dpmi32o		;ITV_DPMI32O = 4 - DPMI 32 bit v0.9 exception
	.LONG	dpmi16n		;ITV_DPMI16N = 5 - DPMI 16 bit v1.0 exception
	.LONG	dpmi32n		;ITV_DPMI32N = 6 - DPMI 32 bit v1.0 exception
	.LONG	badvecttype	;	     = 7 - Illegal

	CODE

badvecttype:
	CRASH	BSVT			;[Bad Software Vector Type]
.PAGE
;Here if have 16-bit DPMI v0.9 vector.  This vector type is only valid for
;  interrupts from protected to protected mode.  The format of the interrupt
;  stack frame is as follows:
;	c[{ESP}+0]  = Return IP
;	c[{ESP}+2]  = Return CS
;	c[{ESP}+4]  = Error code
;	c[{ESP}+6]  = Saved IP
;	c[{ESP}+8]  = Saved CS
;	c[{ESP}+10] = Saved FR
;	c[{ESP}+12] = Saved SP
;	c[{ESP}+14] = Saved SS
;  If the user stack is not the real mode protected mode stack, the stack is
;  switched to use that stack.  This vector type is intended for use with a
;  DPMI environment only.  It will generally not work in other environments,
;  mainly because of the stack switching done.

$$$=!0
FRM ds_oret  , 4t		;Offset of normal return routine for v0.9 frame
FRM ds_oretrs, 4t		;Offset of restore stack return routine for
				;  v0.9 frame
FRM ds_nret  , 4t		;Offset of normal return routine for v1.0 frame
FRM ds_nretrs, 4t		;Offset of restore stack return routine for
				;  v1.0 frame
FRM ds_frmsz , 4t		;Size of the stack frame
ds_SIZE=!$$$

dpmi16o:TESTB	SS:pdaURegEFR#+2, #2	;Is interrupt from real mode?
	JNE	2$.S			;Yes - fail!
	ENTER	ds_SIZE, 0		;No
	MOVL	ds_frmsz.B[EBP], #16t	;Get stack frame size
	MOVL	ds_oret.B[EBP], #dpmi16oret#
	MOVL	ds_oretrs.B[EBP], #dpmi16oretrs#
	JMP	4$.S			;Continue

2$:	CALL	sibdstk

;Here if have 16-bit DPMI v1.0 vector. The format of the interrupt stack frame
;  is as follows:
;	c[{ESP}+0]  = Return IP
;	c[{ESP}+2]  = Return CS
;	c[{ESP}+4]  = Error code
;	c[{ESP}+6]  = Saved IP
;	c[{ESP}+8]  = Saved CS
;	c[{ESP}+10] = Saved FR
;	c[{ESP}+12] = Saved SP
;	c[{ESP}+14] = Saved SS
;	c[{ESP}+16] = Not used (16 bytes)
;	c[{ESP}+32] = Return IP (same as +0)
;	c[{ESP}+34] = Return CS (same as +2)
;	c{{ESP}+36} = Not used
;	c{{ESP}+40} = Error code
;	c{{ESP}+44} = Saved EIP (same value as +6)
;	c{{ESP}+48} = Saved CS (same as +8)
;	c{{ESP}+52} = Saved EFR (full 32 bit value)
;	c{{ESP}+56} = Saved ESP (same value as +12)
;	c{{ESP}+60} = Saved SS (same as +14)
;	c{{ESP}+64} = Saved ES
;	c{{ESP}+68} = Saved DS
;	c{{ESP}+72} = Saved FS
;	c{{ESP}+76} = Saved GS
;	c{{ESP}+80} = Saved CR2 value
;	c{{ESP}+84} = Saved page table entry
;  If the user stack is not in the real mode protected mode stack page, the
;  stack is switch to use that page.  This vector type is intended for use
;  with a DPMI environment only.  It will generally not work in other
;  environments, mainly because of the stack switching done.

dpmi16n:ENTER	ds_SIZE, 0
	MOVL	ds_frmsz.B[EBP], #88t
	MOVL	ds_oret.B[EBP], #dpmi16nreto#
	MOVL	ds_oretrs.B[EBP], #dpmi16oretrs#
	MOVL	ds_nret.B[EBP], #dpmi16nret#
	MOVL	ds_nretrs.B[EBP], #dpmi16nretrs#
4$:	PUSHL	#GS_REAL16.B
	POPL	GS
	MOVZWL	EAX, SS:pdaURegSS#	;Get current stack pointer
	MOVL	EBX, SS:pdaURegESP#
	IFFCALL	sibdstk			;Currently using the protected mode
	CMPB	GS:dda_dpmilckpsflg, #0	;  locked stack?
	JNE	6$.S			;Yes - continue using it
	MOVL	EAX, ds_oretrs.B[EBP]	;No - use the right return routines
	MOVL	ds_oret.B[EBP], EAX
	MOVL	EAX, ds_nretrs.B[EBP]
	MOVL	ds_nret.B[EBP], EAX
	IFFCALL	sibdstk
	MOVL	EBX, GS:dda_dpmilckpESP	;Switch to the protected mode locked
	IFFCALL	sibdstk			;  stack
	MOVL	EAX, GS:dda_dpmilckpSS
	IFFCALL	sibdstk
	MOVB	GS:dda_dpmilckpsflg, #1
6$:	MOVL	ES, EAX
	SUBL	EBX, ds_frmsz.B[EBP]	;Allocate space for the stack frame
	CMPL	ds_frmsz.B[EBP], #32t.B	;Using 0.9 stack frame?
	JBE	10$.S			;Yes
	MOVL	EAX, ds_nret.B[EBP]	;No - store new format return IP
	IFFCALL	sibdstk
	MOVL	ES:32t[EBX], EAX
	MOVW	ES:34t.B[EBX], #GS_USERCODE|03h ;Store return CS
	CLRL	EAX			;Clear the extra item
	IFFCALL	sibdstk
	MOVL	ES:36t.B[EBX], EAX
	CALL	dpminewframe		;Set up rest of the new frame
10$:	MOVL	EAX, SS:pdaURegESP#	;Store old stack pointer on his new
	IFFCALL	sibdstk			;  stack
	MOVW	ES:12t.B[EBX], AX
	MOVL	SS:pdaURegESP#, EBX
	MOVL	EAX, SS:pdaURegSS#
	IFFCALL	sibdstk
	MOVW	ES:14t.B[EBX], AX
	MOVL	SS:pdaURegSS#, ES
	MOVL	EAX, ds_oret.B[EBP]	;Store return IP
	IFFCALL	sibdstk
	MOVW	ES:[EBX], AX
	IFFCALL	sibdstk
	MOVW	ES:2t.B[EBX], #GS_USERCODE|03h ;Store return SS
	MOVL	EAX, SS:pdaTrapCode#	;Store error code
	IFFCALL	sibdstk
	MOVW	ES:4t.B[EBX], AX
	MOVL	EAX, SS:pdaURegEIP#	;Store saved IP
	IFFCALL	sibdstk
	MOVW	ES:6t.B[EBX], AX
	MOVL	EAX, SS:pdaURegCS#	;Store saved CS
	IFFCALL	sibdstk
	MOVW	ES:8t.B[EBX], AX
	MOVL	EAX, SS:pdaURegEFR#	;Assume interrupts are disabled (this
	ANDB	AH, #~03h		;  also clears TP)
	CMPB	SS:pdaSigLvl#, #4t	;Right?
	JAE	12$.S			;Yes
	ORB	AH, #02h		;No - they are enabled
	IFFCALL	sibdstk
12$:	MOVW	ES:10t.B[EBX], AX
	JMP	dpmio2			;Continue
.PAGE
;Here if have 32-bit DPMI v0.9 vector.  This vector type is only valid for
;  interrupts from protected to protected mode.  The format of the interrupt
;  stack frame is as follows:
;	c{{ESP}+0}  = Return EIP
;	c{{ESP}+4}  = Return CS
;	c{{ESP}+8}  = Error code
;	c{{ESP}+12} = Saved EIP
;	c{{ESP}+16} = Saved CS
;	c{{ESP}+20} = Saved EFR
;	c{{ESP}+24} = Saved ESP
;	c{{ESP}+28} = Saved SS
;  If the user stack is not in the real mode protected mode stack page, the
;  stack is switched to use that page.  This vector type is intended for use
;  with a DPMI environment only.  It will generally not work in other
;  environments, mainly because of the stack switching done.

dpmi32o:TESTB	SS:pdaURegEFR#+2, #2	;Is interrupt from real mode?
	JNE	2$.S			;Yes - fail!
	ENTER	ds_SIZE, 0		;No
	MOVL	ds_frmsz.B[EBP], #32t	;Get stack frame size
	MOVL	ds_oret.B[EBP], #dpmi32oret#
	MOVL	ds_oretrs.B[EBP], #dpmi32oretrs#
	JMP	4$.S			;Continue

2$:	CALL	sibdstk

;Here if have 32-bit DPMI v1.0 vector.  The format of the interrupt stack frame
;  is as follows:
;	c{{ESP}+0}  = Return EIP
;	c{{ESP}+4}  = Return CS
;	c{{ESP}+8}  = Error code
;	c{{ESP}+12} = Saved EIP
;	c{{ESP}+16} = Saved CS
;	c{{ESP}+20} = Saved EFR
;	c{{ESP}+24} = Saved ESP
;	c{{ESP}+28} = Saved SS
;	c{{ESP}+32} = Return EIP (same as +0)
;	c{{ESP}+36} = Return CS (same as +4)
;	c{{ESP}+40} = Error code
;	c{{ESP}+44} = Saved EIP (same as +12)
;	c{{ESP}+48} = Saved CS (same as +16)
;	c{{ESP}+52} = Saved EFR (same as +20)
;	c{{ESP}+56} = Saved ESP (same value as +24)
;	c{{ESP}+60} = Saved SS (same as +28)
;	c{{ESP}+64} = Saved ES
;	c{{ESP}+68} = Saved DS
;	c{{ESP}+72} = Saved FS
;	c{{ESP}+76} = Saved GS
;	c{{ESP}+80} = Saved CR2 value
;	c{{ESP}+84} = Saved page table entry
;  If the user stack is not in the real mode protected mode stack page, the
;  stack is switch to use that page.  This vector type is intended for use
;  with a DPMI environment only.  It will generally not work in other
;  environments, mainly because of the stack switching done.

dpmi32n:ENTER	ds_SIZE, 0
	MOVL	ds_frmsz.B[EBP], #88t
	MOVL	ds_oret.B[EBP], #dpmi32nreto#
	MOVL	ds_oretrs.B[EBP], #dpmi32oretrs#
	MOVL	ds_nret.B[EBP], #dpmi32nret#
	MOVL	ds_nretrs.B[EBP], #dpmi32nretrs#
4$:	PUSHL	#GS_REAL16.B
	POPL	GS
	MOVZWL	EAX, SS:pdaURegSS#	;Get current stack pointer
	MOVL	EBX, SS:pdaURegESP#
	IFFCALL	sibdstk			;Currently using the protected mode
	CMPB	GS:dda_dpmilckpsflg, #0	;  locked stack?
	JNE	6$.S			;Yes - continue using it
	MOVL	EAX, ds_oretrs.B[EBP]	;No - use the right return routines
	MOVL	ds_oret.B[EBP], EAX
	MOVL	EAX, ds_nretrs.B[EBP]
	MOVL	ds_nret.B[EBP], EAX
	IFFCALL	sibdstk
	MOVL	EBX, GS:dda_dpmilckpESP	;Switch to the protected mode locked
	IFFCALL	sibdstk			;  stack
	MOVL	EAX, GS:dda_dpmilckpSS
	IFFCALL	sibdstk
	MOVB	GS:dda_dpmilckpsflg, #1
6$:	MOVL	ES, EAX
	SUBL	EBX, ds_frmsz.B[EBP]	;Allocate space for the stack frame
	CMPL	ds_frmsz.B[EBP], #32t.B	;Using 0.9 stack frame?
	JBE	10$.S			;Yes
	MOVL	EAX, ds_nret.B[EBP]	;No - store new format return EIP
	IFFCALL	sibdstk
	MOVL	ES:32t[EBX], EAX
	IFFCALL	sibdstk
	MOVL	ES:36t.B[EBX], #GS_USERCODE|03h ;Store return CS
	CALL	dpminewframe		;Set up rest of the new frame
10$:	MOVL	EAX, SS:pdaURegESP#	;Store old stack pointer on his new
	IFFCALL	sibdstk			;  stack
	MOVL	ES:24t.B[EBX], EAX
	MOVL	SS:pdaURegESP#, EBX
	MOVL	EAX, SS:pdaURegSS#
	IFFCALL	sibdstk
	MOVL	ES:28t.B[EBX], EAX
	MOVL	SS:pdaURegSS#, ES
	IFFCALL	sibdstk
	MOVL	EAX, ds_oret.B[EBP]	;Store return EIP
	MOVL	ES:[EBX], EAX
	IFFCALL	sibdstk
	MOVL	ES:4t.B[EBX], #GS_USERCODE|03h ;Store return CS
	MOVL	EAX, SS:pdaTrapCode#	;Store error code
	IFFCALL	sibdstk
	MOVL	ES:8t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegEIP#	;Store saved EIP
	IFFCALL	sibdstk
	MOVL	ES:12t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegCS#	;Store saved CS
	IFFCALL	sibdstk
	MOVL	ES:16t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegEFR#	;Assume interrupts are disabled (this
	ANDB	AH, #~03h		;  also clears TP)
	CMPB	SS:pdaSigLvl#, #4t	;Right?
	JAE	12$.S			;Yes
	ORB	AH, #02h		;No - they should be enabled
	IFFCALL	sibdstk
12$:	MOVL	ES:20t.B[EBX], EAX
dpmio2:	LEAVE
	ORB	SS:pdaSigLvl#, #04h	;Disable interrupts
	MOVL	EBX, SS:pdaIdt#+it_soffset[EDX*8] ;Get offset
	MOVZWL	ECX, SS:pdaIdt#+it_ssel[EDX*8] ;Get selector
	JMP	sisav6			;Continue
.PAGE
;Subroutine to set up the new part of the v1.0 stack frame - this is called
;  for both 16 and 32 bit exceptions

dpminewframe:
	MOVL	EAX, SS:pdaTrapCode#	;Store error code
	IFFCALL	sibdstk
	MOVL	ES:40t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegEIP#	;Store saved EIP
	IFFCALL	sibdstk
	MOVL	ES:44t.B[EBX], EAX
	MOVZWL	EAX, SS:pdaURegCS#	;Store saved CS
	IFFCALL	sibdstk
	MOVL	ES:48t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegEFR#	;Assume interrupts are disabled (this
	ANDB	AH, #~03h		;  also clears TP)
	CMPB	SS:pdaSigLvl#, #4t	;Right?
	JAE	6$.S			;Yes
	ORB	AH, #02h		;No - they should be enabled
	IFFCALL	sibdstk
6$:	MOVL	ES:52t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegESP#	;Store old stack pointer on his new
	IFFCALL	sibdstk			;  stack
	MOVL	ES:56t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegSS#
	IFFCALL	sibdstk
	MOVL	ES:60t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegES#	;Save his segment registers on his
	IFFCALL	sibdstk			;  stack
	MOVL	ES:64t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegDS#
	IFFCALL	sibdstk
	MOVL	ES:68t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegFS#
	IFFCALL	sibdstk
	MOVL	ES:72t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegGS#
	IFFCALL	sibdstk
	MOVL	ES:76t.B[EBX], EAX
	MOVL	EAX, SS:pdaURegCR2#	;Store the CR2 value
	IFFCALL	sibdstk
	MOVL	ES:80t.B[EBX], EAX
	SHRL	EAX, #10t		;Get index int the page table
	ANDL	EAX, #0FFFFFFFCh.B
	IFFAULT	14$.S
	MOVZBL	EAX, pgtable[EAX]	;Get page table low order byte
	IFFCALL	sibdstk
8$:	MOVL	ES:84t.B[EBX], EAX
	RET

	FAULTHDR
14$:	CLRL	EAX
	JMP	8$
.PAGE
;Here if have an XOS vector - we can get here for 4 cases:
;	Interrupt of protected mode process with protected mode XOS vector
;	Interrupt of protected mode process with real mode XOS vector
;	  (protected mode stack pointer already saved on the user stack)
;	Interrupt of real mode process with protected mode XOS vector (real
;	  mode stack pointer already saved on the user stack)
;	Interrupt of real mode process with real mode Allegor vector
;  The format of the stack data is the same for all cases, except that the
;    stack pointer is not saved if not switching modes:
;	c{{ESP}+0}  = Saved user GS
;	c{{ESP}+4}  = Saved user FS
;	c{{ESP}+8}  = Saved user ES
;	c{{ESP}+12} = Saved user DS
;	c{{ESP}+16} = Saved user EIP
;	c{{ESP}+20} = Saved user CS (high 16 bits are unused)
;	c{{ESP}+24} = Saved user EFR
;	c[{ESP}+28] = Number of data items on stack (each item is 32 bits)
;	c[{ESP}+30] = Software interrupt number
;	c{{ESP}+32} = First data item
;	c{{ESP}+..} = Saved user ESP (These 2 items are only present if changing
;	c{{ESP}+..} = Saved user SS    between real and protected modes)

xosvect:MOVL	EBX, SS:pdaIdt#+it_soffset[EDX*8] ;Get offset
	MOVZWL	ECX, SS:pdaIdt#+it_ssel[EDX*8] ;Get selector
	STD
	TESTB	SS:pdaURegEFR#+2, #2	;Is interrupt from real mode?
	JNE	xvfrmrm			;Yes
xvfrmpm:TESTL	ECX, ECX		;Protected mode vector?
	JE	xvpm2rm.S		;No

;Here if interrupting from protected mode to protected mode

	IFFCALL	sibdstk
xvpm2pm:LESL	EDI, SS:pdaURegESP#	;Point to his stack
	SUBL	EDI, #4.B
	JMP	knlvt2			;Continue

;Here if interrupting from protected mode to real mode

xvpm2rm:PUSHL	#GS_REAL32|03h.B
	POPL	ES
	IFFCALL	sibdstk
	MOVZWL	EDI, ES:dda_dpmicurrSSSP+2 ;Point to his current real mode stack
	SHLL	EDI, #4t
	IFFCALL	sibdstk
	MOVZWL	EAX, ES:dda_dpmicurrSSSP+0
	ADDL	EDI, EAX
	JE	sibdstk			;Fail if don't have a real mode stack
	SUBL	EDI, #4t.B
	STD
	MOVZWL	EAX, SS:pdaURegSS#	;Save the protected mode stack
	IFFCALL	sibdstk			;  pointer
	STOSL	[EDI]
	IFFCALL	sibdstk
	MOVL	ES:dda_dpmicurpSS, EAX
	MOVL	EAX, SS:pdaURegESP#
	IFFCALL	sibdstk
	STOSL	[EDI]
	IFFCALL	sibdstk
	MOVL	ES:dda_dpmicurpESP, EAX
	IFFCALL	sibdstk
	MOVZWL	EAX, ES:dda_dpmicurrSSSP+0 ;Set up his real mode stack pointer
	SUBL	EAX, #8t.B
	MOVL	SS:pdaURegESP#, EAX
	IFFCALL	sibdstk
	MOVZWL	EAX, ES:dda_dpmicurrSSSP+2
	MOVL	SS:pdaURegSS#, EAX
	MOVL	SS:pdaTss#+tss_stk0, #pdaXStackV#
	JMP	knlvt2			;Continue

;Here if interrupting from real mode

xvfrmrm:TESTL	ECX, ECX		;Protected mode vector?
	JNE	xvrm2pm.S		;Yes

;Here if interrupting from real mode to real mode

xvrm2rm:MOVZWL	EAX, SS:pdaURegSS#	;Point to his current real mode stack
	SHLL	EAX, #4
	MOVZWL	EDI, SS:pdaURegESP#
	LEAL	EDI, -4t.B[EAX+EDI]
	PUSHL	#GS_REAL16.B
	POPL	ES
	JMP	knlvt2.S		;Continue	

;Here interrupting from real mode to protected mode

xvrm2pm:PUSHL	#GS_REAL16.B
	POPL	GS
	IFFCALL	sibdstk
	LESL	EDI, GS:dda_dpmicurpESP	;Point to his protected mode stack
	SUBL	EDI, #4t.B
	STD
	MOVZWL	EAX, SS:pdaURegSS#	;Save the real mode stack pointer
	IFFCALL	sibdstk
	STOSL	[EDI]
	IFFCALL	sibdstk
	MOVW	GS:dda_dpmicurrSSSP+2, AX
	MOVZWL	EAX, SS:pdaURegESP#
	MOVL	SS:pdaURegESP#, EDI
	MOVL	SS:pdaURegSS#, ES
	IFFCALL	sibdstk
	STOSL	[EDI]
	IFFCALL	sibdstk
	MOVW	GS:dda_dpmicurrSSSP+0, AX
	MOVL	SS:pdaTss#+tss_stk0, #pdaXStackP# ;Fall into knlvt2 on next page
.PAGE
;Here with a XOS vector after the user stack has been set up - if we are
;  switching modes the old stack pointer has been saved on the new stack

knlvt2:	STD
	PUSHL	ECX
	CLRL	ECX
	TESTL	ESI, ESI		;Do we have a signal link block?
	JE	4$.S			;No
	MOVB	CL, slb_dcnt.B[ESI]	;Yes - get number of data items
4$:	LEAL	EAX, 32t[ECX*4]		;Adjust his stack pointer
	SUBL	SS:pdaURegESP#, EAX
	MOVL	EDX, ECX
	JREGZ	ECX, 6$
	PUSHL	ESI
	ADDL	ESI, #slb_data.B
	LEAL	ESI, -4.B[ESI+ECX*4]
	IFFCALL	sibdstkpESIECX
	RMOVSL	[EDI], [ESI]		;Copy data items to his stack
	POPL	ESI
6$:	POPL	ECX
	MOVL	EAX, SS:pdaSigRegEDX#	;Put vector number in high 16 bits
	CMPL	EAX, #160h		;Need to correct the value?
	JB	8$.S			;No
	SUBL	EAX, #160h		;Yes - assume low special vector
	CMPL	EAX, #20h.B		;Right?
	JB	8$.S			;Yes
	ADDL	EAX, #70h-20h.B		;No - its a middle special vector
8$:	SHLL	EAX, #16t
	MOVW	AX, DX
	IFFCALL	sibdstk
	STOSL	[EDI]			;Store item count and interrupt number
	MOVL	EAX, SS:pdaURegEFR#
	ANDB	AH, #0Dh		;Put his previous software interrupt
	MOVB	DL, SS:pdaSigRegECX#	;  level in is EFR
	SHLB	DL, #4
	ORB	AH, DL
	JS	12$.S			;If software interrupts are disabled
	ORB	AH, #02h		;Enabled - set the I bit
12$:	ANDB	AH, #7Fh
	IFFCALL	sibdstk
	STOSL	[EDI]			;Store his old EFR
	MOVZWL	EAX, SS:pdaURegCS#	;Store his old CS
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVL	EAX, SS:pdaURegEIP#	;Store his old EIP
	IFFCALL	sibdstk
	STOSL	[EDI]
	TESTB	SS:pdaURegEFR#+2, #02h	;Was interrupt from real mode?
	JNE	14$.S			;Yes
	MOVZWL	EAX, SS:pdaURegDS#	;No - save the protected mode segment
	IFFCALL	sibdstk			;  register values
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaURegES#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaURegFS#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaURegGS#
	IFFCALL	sibdstk
	STOSL	[EDI]
	JMP	sisav4.S

;Here if interrupt was from real mode

14$:	MOVZWL	EAX, SS:pdaVRegDS#	;Save the real mode segment register
	IFFCALL	sibdstk			;  values
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaVRegES#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaVRegFS#
	IFFCALL	sibdstk
	STOSL	[EDI]
	MOVZWL	EAX, SS:pdaVRegGS#
	IFFCALL	sibdstk
	STOSL	[EDI]
sisav4:	TESTL	ECX, ECX		;Is this a real vector?
	JE	16$.S			;Yes - go handle that
sisav6:	MOVL	SS:pdaURegCS#, ECX	;No - this is easy
	MOVL	SS:pdaURegEIP#, EBX
	ORB	SS:pdaURegEFR#+1, #02h	;Make sure EFR is right
	ANDL	SS:pdaURegEFR#, #10EFFh
	JMP	18$.S			;Continue

;Here if have real mode (16-bit) vector

16$:	MOVZWL	EAX, BX			;Get EIP value
	MOVL	SS:pdaURegEIP#, EAX
	SHRL	EBX, #16t		;Get CS value
	MOVL	SS:pdaURegCS#, EBX
	ORL	SS:pdaURegEFR#, #20200h	;Make sure EFR is right
	ANDL	SS:pdaURegEFR#, #30EFFh
18$:	TESTL	ESI, ESI		;Have an interrupt link block?
	JE	20$.S			;No
	MOVZBL	ECX, slb_szindx.B[ESI]	;Yes
	CALL	knlGiveXmb#		;Give it up
20$:	MOVL	ESI, SS:pdaSpndBlk#	;Was this process suspended?
	TESTL	ESI, ESI
	JE	knlTrapDone.S		;No
	MOVB	knlForkLvl#, #FORK_SFORK ;Yes
	CALL	knlWakeRemove#		;Remove wake request
	FROMFORK
	CLRL	EAX
	MOVL	SS:pdaSpndBlk#, EAX
knlTrapDone::
	CLI				;No interrupts now

	ORB	SS:pdaURegEFR#+1, #02	;;;;;;;;;;;;;;;;;

;;;;;;;	TESTB	SS:pdaURegEFR#+1, #02
;;;;;;;	JE	26$.S

	CMPB	knlForkLvl#, #FORK_MAIN
	JNE	24$.S
	MOVB	AL, SS:pdaSigReq#	;Need to schedule now?
	ANDB	AL, SS:pdaSigMask#
	ORB	AL, knlSchedReq#
	IFFCALL	badseg
	POPL	GS
	IFFCALL	badseg
	POPL	FS
	IFFCALL	badseg
	POPL	ES
	IFFCALL	badseg
	POPL	DS
	TESTB	AL, AL
	POPAL
	JNE	22$.S			;If need to schedule here
;;;;;;;	TESTB	9.B[ESP], #01h		;No scheduling now - do we want a trace
					;  trap now?
;;;;;;;	JNE	trctrpx#		;Yes - go do that
	IFFCALL	badusrstk#		;No
	IRET				;Return to user

;Here if need to schedule before returning to the user

22$:
;;;;;;;	TESTB	9.B[ESP], #01h		;Do we want a trace trap now?
;;;;;;;	JNE	trctrpx#		;Yes - go do that
	CALLF	schedule		;No - call the scheduler
	IFFCALL	badusrstk#
	IRET				;Return to user

24$:	CRASH	ATFK			;[AT ForK level]

26$:	CRASH	INTD

;Here if have protection trap when restoring a segment register - set the
;  value for the register to 0 and try again

	FAULTHDR
badseg:	MOVL	12t.B[ESP], #0
	ADDL	ESP, #8t
	RET

;Here if memory trap while storing data on the user stack

	FAULTHDR
sibdstkpESIECX:				;The following code reorders the stack
					;  as follows:
					;  Before: {ESP+0}  = error code 1
					;	   {ESP+4}  = error code 2
					;	   {ESP+8}  = error offset
					;	   {ESP+12} = saved ESI
					;	   {ESP+16} = saved ECX
					;  After: (ESP increased by 8, ESI and
					;	    ECX restored from the stack
					;	   {ESP+0}  = error code 1
					;	   {ESP+4}  = error code 2
					;	   {ESP+8}  = error offset
	POPL	ESI			;Get the code 1 value
	POPL	ECX			;Get the code 2 value
	XCHGL	ESI, [ESP]		;Put code 1 value on stack, get ADDR
					;  value
	XCHGL	ECX, 4.B[ESP]		;Put code 2 value on stack, restore ECX
	XCHGL	ESI, 8.B[ESP]		;Put error offset value on stack,
					;  restore ESI
	FAULTHDR
sibdstk:TESTL	ESI, ESI		;Do we have an interrupt link block?
	JE	30$.S			;No
	MOVZBL	ECX, slb_szindx.B[ESI]	;Yes
	CALL	knlGiveXmb#		;Give it up
30$:	CALL	badusrstk#		;Go kill the process

	DATA

trapfrom::.LONG 0

	CODE
.PAGE
	.SBTTL	systemsig - Routine to handle system level signals

;Routine to handle system level signals

systemsig:
	MOVZBL	EAX, ES:pdaSSigType#	;Get interrupt type bits
	JMPIL	ssigdsp[EAX*4]		;Dispatch on the type

	DATA

ssigdsp:.LONG	havxsig		;	    = 00000000 - Exec signal
	.LONG	fputrap		;SSIG$FPUX  = 00000001 - FPU exception
	.LONG	haltproc	;SSIG$HALT  = 00000010 - Halt process
	.LONG	haltproc	;	    = 00000011
	.LONG	killproc1#	;SSIG$KILL1 = 00000100 - Kill process, step 1
	.LONG	killproc1#	;	    = 00000101
	.LONG	killproc1#	;           = 00000110
	.LONG	killproc1#	;           = 00000111
	.LONG	killproc2#	;SSIG$KILL2 = 00001000 - Kill process, step 2
	.LONG	killproc2#	;	    = 00001001
	.LONG	killproc2#	;	    = 00001010
	.LONG	killproc2#	;	    = 00001011
	.LONG	killproc2#	;	    = 00001100
	.LONG	killproc2#	;	    = 00001101
	.LONG	killproc2#	;	    = 00001110
	.LONG	killproc2#	;	    = 00001111

	CODE
.PAGE
	.SBTTL	havxsig - Exec signal routine

;Exec software interrupt routine

havxsig:MOVL	ESI, ES:pdaL8HeadP#	;Get offset for interrupt link block	
	TESTL	ESI, ESI		;Really have one?
	JNE	2$.S			;Yes
	CRASH	NILB			;[No Interrupt Link Block]

2$:	MOVL	EAX, [ESI]		;Remove entry from interrupt list
	MOVL	ES:pdaL8HeadP#, EAX
	TESTL	EAX, EAX		;Is list empty now?
	JNE	10$.S			;No
	MOVL	ES:pdaL8TailP#, EAX	;Yes - clear tail pointer
	ANDB	ES:pdaSigReq#, #~01	;Clear request bit for level
10$:	MOVL	EAX, slb_vector.B[ESI]	;Get offset of interrupt routine
	MOVL	ES:pdaSigRegESI#, EAX
	MOVL	EAX, slb_data+0.B[ESI]	;Get data items
	MOVL	ES:pdaSigRegEAX#, EAX
	MOVL	EAX, slb_data+4.B[ESI]
	MOVL	ES:pdaSigRegEDI#, EAX
	MOVL	EAX, slb_data+8.B[ESI]
	MOVL	ES:pdaSigRegECX#, EAX
	MOVL	EAX, slb_data+12t.B[ESI]
	MOVL	ES:pdaSigRegEDX#, EAX
	MOVL	ES:pdaTss#+tss_EIP, #sixtask ;Change EIP
	MOVL	ES:pdaTss#+tss_CS, CS
	MOVL	ES:pdaTss#+tss_EFR, #0200h
	FROMFORK
	CMPL	ESI, #xmbbase		;Is this a special QEL?
	JB	12$.S			;Yes - don't give it up
	MOVZBL	ECX, slb_szindx.B[ESI]	;No
	CALL	knlGiveXmb#		;Give up the signal link block
12$:	IRET				;Switch to task context
	JMP	scheduler#		;Start over next time

sixtask::
	PUSHAL
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHL	#GS_DATA.B
	POPL	DS
	MOVL	EAX, SS:pdaSigRegEAX#	;Get data items
	MOVL	EDI, SS:pdaSigRegEDI#
	MOVL	ECX, SS:pdaSigRegECX#
	MOVL	EDX, SS:pdaSigRegEDX#
	MOVL	EBX, SS:pdaSigRegESI#
	MOVL	SS:pdaSigRegESI#, #0
	MOVL	lastsig, EBX
	MOVL	lastsigEDI, EDI
	MOVL	lastsigECX, ECX
	MOVL	lastsigEDX, EDX
	CALLI	EBX			;Call the interrupt routine
	REQUIREMAIN
	JMP	disms4#			;Go return to user

	DATA

lastsig::.LONG	0
lastsigEDI::.LONG 0
lastsigECX::.LONG 0
lastsigEDX::.LONG 0

	CODE
.PAGE
	.SBTTL	fputrap - Routine to handle FPU exceptions

fputrap:ANDB	ES:pdaSSigType#, #~SSIG$FPUX
	JNE	2$.S
	CMPL	ES:pdaL8HeadP#, #0.B
	JNE	2$.S
	ANDB	ES:pdaSigReq#, #~01h
2$:	CLRL	EAX
	MOVL	ES:pdaSigRegESI#, EAX
	MOVB	AL, ES:pdaSigLvl#
	MOVB	AH, ES:pdaSigMask#
	MOVL	ES:pdaSigRegECX#, EAX
	MOVL	EDX, #VECT_PFPUERR	;Assume in protected mode
	TESTB	ES:pdaStatus1#, #P1$DOSSEG ;Do we have a DOS environment?
	JE	10$.S			;No

;Here if have a DOS environment - in this case we ignore FPU exceptions if no
;  vector is set up!

	TESTB	ES:pdaURegEFR#+2, #02h	;Really in protected mode?
	JE	6$.S			;Yes
	MOVB	DH, #VECT_RFPUERR>8t	;No - its in real mode
	CMPW	ES:pdaIdt#+VECT_RFPUERR*8+4, #0.B ;Is this vector set up?
	JNE	6$.S			;Yes - use
	MOVL	EDX, #275h		;No - assume should use INT 75h
	CMPW	ES:pdaRMPage0#+{75h*4}+2, #100h ;Right?
	JAE	6$.S			;Yes
	CMPW	ES:pdaRMPage0#+{02h*4}+2, #100h ;No - does he want the INT 02h
					        ;  interrupt?
	JB	sigchk#			;No - ignore this!
	MOVB	DL, #02h		;Yes - use INT 2
6$:	MOVL	ES:pdaSigRegEDX#, EDX	;Store the vector number
	CLRL	ESI			;Indicate no signal link block
	JMP	sigsch2			;Continue

;Here if don't have a DOS environment - in this case we terminate the process
;  if no FPU vector is set up!

10$:	TESTB	ES:pdaURegEFR#+2, #02h	;Really in protected mode?
	JE	12$.S			;Yes
	MOVB	DH, #VECT_RFPUERR>8t	;No - its in real mode
12$:	CMPW	ES:pdaIdt#+4[EDX*8], #0.B ;Is the vector set up?
	JNE	6$.S			;Yes
	CLTS				;No - clear the FPU exceptions
	FNCLEX
	LEAL	EAX, TC_NOVECT<24t[EDX]	;Get termination code and status
	MOVL	EDI, ES:pdaURegEIP#	;Get data for the parent
	MOVL	EDX, ES:pdaURegCS#
	MOVL	EBP, ES:pdaURegEFR#
	CLRL	ECX
	PUSHL	ES
	CALL	reqkill2#		;Kill this process
	POPL	ES
	JMP	sigchk#
.PAGE
	.SBTTL	haltproc - Routine to halt process

;Routine to halt process

haltproc:
	ANDB	ES:pdaSSigType#, #~SSIG$HALT
	JNE	4$.S
	ANDB	ES:pdaSigReq#, #~01h
4$:	ORB	ES:pdaStatus1#, #P1$HALTED ;Indicate halted
	MOVB	AL, #knlQX_SPND#	;Requeue to the suspend queue
	CALL	knlRequeue#
	FROMFORK
	JMP	getrun#			;Go find someone else to run
.PAGE
	.SBTTL	knlReqXSig - Subroutine to request exec signal

;Subroutine to request exec signal - must be called at fork level
;	c{EBX} = Offset of exec signal routine
;	c{EAX} = First data value
;	c{EDI} = Second data value
;	c{ECX} = Third data value
;	c{EDX} = Fourth data value
;	c[ES]  = Selector of PDA
;	CALL	knlReqXSig
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlReqXSig::
	REQUIREFORK
	CALL	knlGetQel#		;Get a QEL
	JC	4$.S			;If error
	MOVB	slb_szindx.B[ESI], #0
knlReqXSig2::
	MOVL	slb_vector.B[ESI], EBX	;Store routine offset
	MOVB	slb_type.B[ESI], #0
	MOVL	slb_data+0.B[ESI], EAX	;Store data values
	MOVL	slb_data+4.B[ESI], EDI
	MOVL	slb_data+8.B[ESI], ECX
	MOVL	slb_data+12t.B[ESI], EDX
	PUSHL	EBX
	PUSHL	EDI
	MOVL	EBX, #8			;Get interrupt level
	JMP	reqsig3			;Continue

4$:	RET
.PAGE
	.SBTTL	knlReqSignal - Subroutine to request signal

;Subroutine to request signal - must be called from fork level only
;	c{EAX} = Signal vector number
;	c(BL)  = Signal type
;	c{ECX} = Number of 32-bit data items associated with signal
;	c{ESI} = Offset of signal link block
;	c{EDX} = Offset of subroutine to call when signal granted
;	c{EDI} = Value for EDI when grant subroutine is called
;	c[ES]  = Selector for PDA
;	CALL	knlReqSignal
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;  All registers are preserved

knlReqSignal::
	REQUIREFORK
	TESTB	ES:pdaStatus1#, #P1$KILL ;Can we do this?
	JNE	10$.S			;No - give up the link block
	CMPL	EAX, #190h		;Valid non-real mode INT number?
	JAE	4$.S			;No
	CMPL	EAX, #20h.B		;Low vector?
	JAE	6$.S			;No
	ADDL	EAX, #160h		;Yes - fix up the value
	JMP	8$.S

;Here if might be a real mode INT

4$:	CMPL	EAX, #200h
	JB	12$.S
	CMPL	EAX, #300h
	JAE	12$.S

$$$$ss2::INT3

	JMP	8$.S

;Here if non-real mode value

6$:	CMPL	EAX, #70h.B		;Middle vector?
	JB	8$.S			;No
	CMPL	EAX, #80h		;Maybe
	JAE	8$.S			;No
	ADDL	EAX, #180h-70h		;Yes - fix up the value
8$:	MOVL	slb_vector.B[ESI], EAX	;Store vector number
	MOVB	slb_dcnt.B[ESI], CL	;Store number of data items
	MOVB	slb_type.B[ESI], BL	;Store interrupt type
	MOVL	slb_grantsub.B[ESI], EDX ;Store offset of grant subroutine
	MOVL	slb_grantEDI.B[ESI], EDI ;Store data for grant subroutine
	PUSHL	EBX			;No - save registers we need to use
	PUSHL	EDI
	MOVL	EBX, #4			;Assume real interrupt number
	CMPL	EAX, #200h		;Right
	JA	reqsig3.S		;Yes
	MOVZBL	EBX, ES:pdaIdt#+it_type[EAX*8] ;No
	TESTB	BL, #80			;Hardware vector?
	JNE	14$.S			;Yes
	SHRL	EBX, #4t		;No - get interrupt level
	ANDB	BL, #07h		;Is there one?
	JNE	reqsig3.S		;Yes - go on
	POPL	EDI			;No - do nothing!
	POPL	EBX
10$:	MOVZBL	ECX, slb_szindx.B[ESI]
	JMP	knlGiveXmb#

;Here if have bad vector number

12$:	MOVZBL	ECX, slb_szindx.B[ESI]
	CALL	knlGiveXmb#
	JMP	knlBadValue#

;Here if have hardware vector

14$:	MOVB	BL, #4			;Use level 4

;Here with level for interrupt

reqsig3:MOVB	AH, sirtbl[EBX]		;Get request bit
	ORB	ES:pdaSigReq#, AH	;Set request bit for the process
	MOVL	EDI, ES:pdaL1TailP#-4[EBX*4] ;Get tail of list for desired level
	TESTL	EDI, EDI
	JNE	16$.S			;If something in the list
	MOVL	ES:pdaL1HeadP#-4[EBX*4], ESI ;List is empty - store new head
	MOVL	slb_prev.B[ESI], #0	     ;  pointer
	JMP	18$.S

;Here if already have an interrupt(s) entered at this level

16$:	MOVL	[EDI], ESI		;Link to tail of list
	MOVL	slb_prev.B[ESI], EDI
18$:	MOVL	ES:pdaL1TailP#-4[EBX*4], ESI ;Set new tail pointer
	MOVL	[ESI], #0
	POPL	EDI
	CMPB	BL, #7			;Is this a level 7 or 8 interrupt?
	JB	20$.S			;No
	INCL	EBX			;Yes - make it one higher
20$:	CMPB	ES:pdaSigLvl#, BL	;Can we interrupt this process now?
	POPL	EBX
	JAE	24$.S			;No
reqsig4::				;Yes
;;;;;;	MOVL	EAX, ES			;Is interrupt for current process?
;;;;;;	CMPW	knlCurPda, AX
;;;;;;	JE	22$.S			;Yes - just reschedule
	CMPB	ES:pdaQueX#, #knlQX_PQ3# ;No - is it in a run queue now?
	JBE	22$.S			;Yes - nothing more needed
	TESTB	ES:pdaStatus1#, #P1$HALTED ;No - has it been halted?
	JNE	24$.S			;Yes - leave it alone for now
	CALL	knlRRequeue#		;No - requeue the process
22$:	MOVB	knlSchedReq#, #1	;Request scheduling
24$:	CLC				;Make sure C is clear
	RET

;Table of signal request bits

	DATA

sirtbl:	.BYTE	00h	;Level 0
	.BYTE	80h	;Level 1
	.BYTE	40h	;Level 2
	.BYTE	20h	;Level 3
	.BYTE	10h	;Level 4
	.BYTE	08h	;Level 5
	.BYTE	04h	;Level 6
	.BYTE	02h	;Level 7
	.BYTE	01h	;Level 8

	CODE
.PAGE
	.SBTTL	clrsignal - Subroutine to remove all signals for a grant function

;Subroutine to remove all signals for a given grant function
;	c{EAX} = Grant data value
;	c{EDX} = Offset of grant function (0 removes all signals)
;	CALL	clrsignal

$$$=!0
FRM csg_count   , 4t
FRM csg_grantsub, 4t
FRM csg_grantEDI, 4t
csg_SIZE=!$$$

clrsignal::
	REQUIREFORK
	ENTER	csg_SIZE, 0
	MOVL	csg_grantEDI.B[EBP], EAX ;Store argument values
	MOVL	csg_grantsub.B[EBP], EDX
	MOVL	EDI, #pdaL1HeadP#	;Point to head pointer for first list
	MOVL	csg_count.B[EBP], #7	;Initialize count
2$:	PUSHL	SS
	POPL	ES
	PUSHL	EDI			;Save pointer to head pointer
4$:	MOVL	ESI, ES:[EDI]		;Get next request
	TESTL	ESI, ESI
	JE	18$.S			;If no more
6$:	MOVL	EDX, slb_grantsub.B[ESI] ;Get offset of the grant subroutine
	CMPL	csg_grantsub.B[EBP], #0.B ;Are we being selective?
	JE	8$.S			;No
	CMPL	csg_grantsub.B[EBP], EDX ;Yes - want to remove this one?
	JNE	16$.S			;No
	MOVL	EAX, slb_grantEDI.B[ESI] ;Maybe
	CMPL	csg_grantEDI.B[EBP], EAX
	JNE	16$.S			;No
8$:	TESTL	EDX, EDX		;Yes - have a grant subroutine?
	JE	10$.S			;No
	PUSHL	EDI			;Yes
	PUSHL	ES
	PUSHL	ESI
	MOVL	EDI, slb_grantEDI.B[ESI]
	CLRL	EAX
	MOVL	slb_grantsub.B[ESI], EAX
	MOVB	AL, #SGF_ALLCLR		;Indicate clearing all signals
	CALLI	EDX			;Call the grant subroutine
	POPL	ESI
	POPL	ES
	POPL	EDI
10$:	MOVL	EAX, [ESI]		;Get offset of next block
	MOVL	ES:[EDI], EAX		;Unlink this one
	TESTL	EAX, EAX
	JE	14$.S
	CMPL	EDI, #pdaL7HeadP#
	JBE	12$.S
	MOVL	slb_prev.B[EAX], ESI
	JMP	14$

12$:	MOVL	slb_prev.B[EAX], #0
14$:	MOVZBL	ECX, slb_szindx.B[ESI]
	CALL	knlGiveXmb#		;Give up this queue element
	JMP	4$.S

;Here if do not want to remove this request

16$:	MOVL	EDI, ESI		;Advance pointer
	PUSHL	DS
	POPL	ES
	JMP	4$.S			;Continue

;Here at end of the signal list

18$:	MOVL	EAX, EDI
	POPL	EDI
	CMPL	EAX, #pdaL7HeadP#	;Is the list empty now?
	JA	20$.S			;No
	CLRL	EAX			;Yes
20$:	MOVL	SS:pdaxxTP#, EAX	;Update tail pointer
	ADDL	EDI, #4.B
	DECL	csg_count.B[EBP]
	JNE	2$
	LEAVE
	RET

	END
