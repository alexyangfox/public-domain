	.TITLE	IOCS2 - Top level IO routines for Allegro

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD XOSINC:\XMAC\XOSXDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD XOSINC:\XMAC\PCAT.PAR

FORKDEFS=!1

	DATA

	.SBTTL	ioinit - Subroutine to initialize IO routines

	ONCE

;Subroutine to initialize IO routines
;	CALL	ioinit

ioinit::MOVL	EAX, #1024t		;Create the initial DCB ID table
	JMP	setdevlimit

	CODE
.PAGE
	.SBTTL	Common error routines

;Here if illegal byte count for device

knlICnDevGQ::
	CALL	knlGiveQel#
knlICnDevTF::
	TOFORK
	JMP	knlICnDev.S

knlICnDevF::
	FROMFORK
knlICnDev::
	MOVL	EAX, #ER_ICDEV		;Error = Illegal Count for DEVice
	JMP	4$.S

;Here if write protect error

knlWPrErrGQ::
	CALL	knlGiveQel#
	TOFORK
knlWPrErr::
	MOVL	EAX, #ER_WPRER
	JMP	4$.S

;Here if device is busy

knlRtnBusy::
	CLRL	ECX
	MOVL	EAX, #ER_BUSY
	STC
	RET

;Here from device driver dispatch on illegal function for device

knlIFnDevF::				;Here if at fork level
	FROMFORK
	JMP	knlIFnDev.S

knlIFnDevGQ::
	CALL	knlGiveQel#
knlIFnDevTF::
	TOFORK
	JMP	knlIFnDev.S

knlIFnDevTFLv::
	TOFORK
knlIFnDevLv::
	LEAVE
knlIFnDev::
	MOVL	EAX, #ER_IFDEV		;Error = Illegal Function for DEVice
4$:	JMP	6$.S

;Here if no disk unit

knlNoUnitLv::
	LEAVE
knlNoUnit::
	MOVL	EAX, #ER_MDCHG
	CLRL	ECX
	STC
	RET

;Here to return not ready error

knlNotReadyLv::
	LEAVE
knlNotReady::
	MOVL	EAX, #ER_NTRDY
	STC
	RET

;Here if input is not allowed

knlIllInpLv::
	LEAVE
	JMP	knlIllInp.S

knlIllInpGQ::
	CALL	knlGiveQel#
	TOFORK
knlIllInp::
	MOVL	EAX, #ER_NOIN
	JMP	6$.S

;Here if output is not allowed

knlIllOutLv::
	LEAVE
	JMP	knlIllOut.S

knlIllOutGQ::
	CALL	knlGiveQel#
	TOFORK
knlIllOut::
	MOVL	EAX, #ER_NOOUT
	JMP	6$.S

;Here if illegal file or device specification

knlIllSpc::
	MOVL	EAX, #ER_BDSPC
6$:	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	STC
	RET

;Here if hung device (time-out)

knlHungDev::
	MOVL	EAX, #ER_NORSP
	STC
	RET
.PAGE
	.SBTTL	knlMakeDcb - Subroutine to create a static DCB

;Subroutine to create a static DCB - must be called with the exec memory
;  resource
;	c{EBX} = Value for dcb_dsp
;	c{ECX} = Total length for DCB
;	c{EDI} = Offset of device dispatch table
;	CALL	knlMakeDcb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset for DCB

knlMakeDcb::
	PUSHL	EDI			;Save dispatch table offset
	CALL	knlGetXMem#		;Get memory for the DCB
	JC	10$.S
	ADDL	EDI, #dcb_cSIZE		;Point to "start" of the DCB
	POPL	dcb_sdisp.B[EDI]	;Store dispatch table offset
	MOVL	dcb_dsp.B[EDI], EBX	;Store device description bits
	MOVL	dcb_magic.B[EDI], #'DCB*'
	CLRL	EAX
	DECL	EAX
	MOVL	dcb_fnext.B[EDI], EAX	;Indicate not in fork queue
	JMP	knlGetDcbId.S		;Store DCB ID in the DCB and return

;Here if error allocating exec memory

10$:	POPL	EDI			;Remove junk from the stack
	RET				;And return
.PAGE
	.SBTTL	knlGetDcbId - Subroutine to allocate a DCB ID value

;Subroutine to allocate a DCB ID value
;	c{EDI} = Offset of DCB
;	CALL	knlGetDcbId

knlGetDcbId::
	MOVL	ES, knlProcTable#	;Get selector for the null process PDA
	MOVL	EAX, dcbtblfree		;Get entry from the free list
	TESTL	EAX, EAX		;Is the free list empty?
	JE	4$.S			;Yes - fail!
	MOVL	EDX, [EAX]		;Remove this entry from the free list
	BTZL	EDX, #31t
	JNC	10$.S
	MOVL	dcbtblfree, EDX
	MOVL	[EAX], EDI		;Store DCB offset in the table
	SUBL	EAX, #dcbtable		;Change to ID index in high half
	SHLL	EAX, #14t
	MOVW	AX, dcbidseq		;Add the DCB sequence number
	INCL	dcbidseq
	RORL	EAX, #16t
	MOVL	dcb_id.B[EDI], EAX	;Store ID in the DCB
rtncls:	CLC
	RET

;Here if the DCB ID table is full

4$:	MOVL	EAX, #ER_TMDVS
	STC
	RET

10$:	CRASH	BIFL			;[Bad device ID Free List]
.PAGE
;Subroutine to allocate additional DCB ID table space
;	c{EAX} = New desired number of entries
;	CALL	setdevlimit
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setdevlimit::
	CMPL	EAX, #4000h		;Too big?
	JB	2$.S			;No
	MOVL	EAX, #4000h		;Yes - just use maximum
2$:	SUBL	EAX, dcbtblsize		;Is it already this big?
	JLE	rtncls.S		;Yes - nothing needed here
	LEAL	ECX, 3FFh[EAX]		;Get number of additional pages needed
	SHRL	ECX, #10t
	MOVL	EBX, dcbtblsize		;Get base linear address for new pages
	SHLL	EBX, #2t
	ADDL	EBX, #dcbtable+la_data
	CLRL	EDX
	MOVL	EAX, #63h
	CALL	knlGetPages#
	JC	10$.S			;If can't get the pages
	SUBL	knlMemUser#, ECX
	SHLL	ECX, #10t		;Get number of new entries
	TOFORK
	ADDL	dcbtblsize, ECX		;Update the table size
	SUBL	EBX, #la_data		;Change linear address to data segment
					;  offset
	MOVL	EDX, #dcbtblfree	;Find the end of the current free list
4$:	MOVL	EAX, [EDX]
	ANDL	EAX, #7FFFFFFFh
	JE	6$.S
	MOVL	EDX, EAX
	JMP	4$.S

;Here with the end of the free list

6$:	LEAL	EAX, 80000000h[EBX]
	MOVL	[EDX], EAX
	DECL	ECX
8$:	ADDL	EAX, #4.B
	MOVL	[EBX], EAX
	ADDL	EBX, #4.B
	LOOP	ECX, 8$
	MOVL	[EBX], #80000000h
	ANDB	dcbtblfree+3, #7Fh
	FROMFORK
	CLC
10$:	RET
.PAGE
	.SBTTL	knlChkIRqAvl - Subroutine to check for free IRQ

;Subroutine to check for free IRQ
;	c{CL} = Interrupt number, bit 7 set if can be shared with PCI interrupts
;	CALL	knlChkIRqAvl
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;  All registers are preserved except EAX if error

knlChkIRqAvl::
	PUSHL	ECX
	PUSHL	EBX
	MOVB	CH, CL
	ANDB	CL, #7Fh
	CMPB	CL, #15t.B
	JA	10$.S
	MOVL	EBX, firstirqrb
2$:	TESTL	EBX, EBX
	JE	6$.S
	CMPB	irqrb_number.B[EBX], CL
	JE	4$.S
	JG	6$
	MOVL	EBX, [EBX]
	JMP	2$.S

;Here if have an IRQRB for the interrupt - see if it can be shared

4$:	TESTB	irqrb_bits.B[EBX], #IRQRB_SHAREPCI
	JE	10$.S
	TESTB	CH, #80
	JE	10$.S
6$:	POPL	EBX
	POPL	ECX
	RET

;Here if interrupt is not available

10$:	MOVL	EAX, #ER_ININU		;Yes - fail
	STC
	JMP	6$.S
.PAGE
	.SBTTL	knlSetIRq - Subroutine to set IO vector

;Subroutine to set IO vector
;	c{EAX} = Offset of subroutine to set exit link (if sharable)
;	c{EDX} = Offset of name of requestor (in data segment)
;	c{EBX} = Offset of interrupt service routine
;	c{CL}  = Interrupt number (bit 7 set if sharable)
;	c(CH)  = Descriptor type
;	CALL	knlSetIRq
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

;If a device is capable of sharing a PCI interrupt, it must supply the offset
;  of its exit instruction which must be initially "JMP intdonelow" (if a low
;  interrupt) or "JMP intdonehigh" (if a high interrupt).  This instruction
;  MUST be unique, it cannot be in code shared by multiple device units.  The
;  device must not execute any EOI operations (that is done by the intdonexxx
;  routines).  The device must quickly determine if its interrupt is active
;  and immediately execute the exit instruction if not.  The initial interrupt
;  code for a sharable interrupt device MUST be:
;	PUSHAL				;Save registers
;	PUSHL	DS
;	PUSHL	ES
;	PUSHL	FS
;	PUSHL	GS
;	PUSHL	#GS_DATA.B		;Make our data addressable
;	POPL	DS
;  When the device is at the beginning of the interrupt chain, this sequence
;  is executed from the beginning.  When the device is not a the beginning
;  of the interrupt chain, the first instruction executed is the instruction
;  immediately following this sequence.	


$$$=!0
FRM setirq_ecx  , 4t
FRM setirq_exit , 4t
FRM setirq_entry, 4t
FRM setirq_name , 4t
setirq_SIZE=!$$$

knlSetIRq::
	CALL	knlChkIRqAvl		;Make sure vector not in use
	JC	6$.S			;If error
	PUSHL	EDI
	ENTER	setirq_SIZE, 0
	MOVL	setirq_ecx.B[EBP], ECX
	MOVL	setirq_exit.B[EBP], EAX
	MOVL	setirq_entry.B[EBP], EBX
	MOVL	setirq_name.B[EBP], EDX
	ANDB	CL, #7Fh
	MOVL	EDX, #firstirqrb
2$:	MOVL	EBX, [EDX]
	TESTL	EBX, EBX
	JE	8$.S
	CMPB	CL, irqrb_number.B[EBX]
	JLE	8$.S
	MOVL	EDX, EBX
	JMP	2$.S

4$:	LEAVE
	POPL	EDI
6$:	RET

;Here with the position for the IRQRB
;	c{EDX} = Offset of pointer to update

8$:	MOVL	ECX, #irqrb_SIZE	;Allocate space for the IRQRB
	CALL	knlGetXMem#
	JC	4$.S
	MOVL	EAX, setirq_exit.B[EBP]	;Fill it in
	MOVL	irqrb_exit.B[EDI], EAX
	MOVL	EAX, setirq_entry.B[EBP]
	MOVL	irqrb_entry.B[EDI], EAX
	MOVL	EAX, setirq_name.B[EBP]
	MOVL	irqrb_name.B[EDI], EAX
	MOVB	AL, setirq_ecx+0.B[EBP]
	MOVB	AH, AL
	ANDB	AL, #7Fh
	MOVB	irqrb_number.B[EDI], AL
	ANDB	AH, #80h
	MOVB	irqrb_bits.B[EDI], AH
	MOVL	[EDI], EBX		;Link it in to the list
	MOVL	[EDX], EDI
	ADDW	irqtableent#+dct_length, #20t.B
	TESTL	EBX, EBX		;Is this the last IRQRB?
	JE	10$.S			;Yes
	CMPB	AL, irqrb_number.B[EBX]	;No - is the next one for the same
					;  interrupt?
	JNE	10$.S			;No

;Here if need to link this interrupt to an existing shared interrupt

	MOVL	EAX, irqrb_entry.B[EBX]
	ADDL	EAX, #14t-5.B		;Add in the magic offset to the link
	MOVL	EDX, setirq_exit.B[EBP]	;  entry
	SUBL	EAX, EDX
	MOVB	gdtable+GS_CODEALS+5, #DT_RWDATA+PL_0 ;Enable alaised code
	PUSHL	#GS_CODEALS.B			      ;  segment
	POPL	ES
	MOVL	ES:1.B[EDX], EAX
	CLRL	EAX
	MOVL	ES, EAX
	MOVB	gdtable+GS_CODEALS+5, AL ;Disable the allaised code space
10$:	MOVZBL	ECX, irqrb_number.B[EDI] ;Get interrupt number
	SHLL	ECX, #3t
	CLRL	EAX
	MOVB	AH, setirq_ecx+1.B[EBP]	;Get vector type in AH
	MOVL	EBX, setirq_entry.B[EBP] ;Get offset of interrupt routine
	LEAVE
	POPL	EDI
setirqs::
	ADDL	ECX, #pdaIdt#+ID_HBASE	;Get offset of the vector table entry
	PUSHL	ESI
	PUSHL	EDX
	PUSHL	ES
	MOVL	EDX, #-1		;proctable-2 contains GS_SCHPDA
12$:	MOVZWL	ESI, knlProcTable#[EDX*2] ;Get next selector
	CMPL	ESI, #3.B
	JLE	14$.S			;If none
	MOVL	ES, ESI
	CMPL	ES:pdaMagic#, #PDA_MAGIC ;Is it a PDA?
	JNE	14$.S			;No
	PUSHFL				;Yes - save current interrupt state
	CLI				;Make sure no interrupts here
	MOVL	ES:[ECX], EBX		;Store low 16 bits of routine offset
	MOVL	ES:4.B[ECX], EBX	;Store high 16 bits of routine offset
	MOVW	ES:2.B[ECX], CS		;Store selector
	MOVW	ES:4.B[ECX], AX		;Store descriptor type
	POPFL				;Interrupts OK now
14$:	INCL	EDX
	CMPL	EDX, knlProcHigh#	;More processes to check?
	JLE	12$.S
	POPL	ES
	POPL	EDX
	POPL	ESI
	RET				;Finished
.PAGE
	.SBTTL	knlEnableInt - Subroutine to enable interrupt request

;Subroutine to enable interrupt request
;	C(CL) = Interrupt request level
;	CALL	knlEnableInt

knlEnableInt::
	MOVB	CH, CL
	ANDB	CL, #07h
	MOVB	AH, #0FEh
	ROLB	AH, CL
	CMPB	CH, #7			;Low interrupt?
	JBE	4$.S			;Yes
	INB	P_INC2P1		;No - enable high interrupt
	IOPAUSE
	ANDB	AL, AH
	OUTB	P_INC2P1
	MOVB	AH, #0FBh		;And make sure interrupt 2 is enabled
4$:	INB	P_INC1P1
	IOPAUSE
	ANDB	AL, AH
	OUTB	P_INC1P1
	RET
.PAGE
	.SBTTL	knlChkIORegs - Subroutine to check if an IO register block is available

;Subroutine to check if an IO register block is available - Reserved IO
;  register blocks are not checked. Must be called with the exec memory
;  resource to ensure that there are no races in allocating blocks.
;	c{EDX} = Base IO register in block
;	c{ECX} = Highest IO register in block
;	CALL	knlChkIORegs
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlChkIORegs::
	PUSHL	EDI
	MOVL	EDI, firstiorrb
4$:	TESTL	EDI, EDI		;Is there another block?
	JE	10$.S			;No - finished
	CMPW	CX, iorrb_base.B[EDI]	;Above next block?
	JB	8$.S			;Yes - finished
	CMPL	iorrb_name.B[EDI], #0.B ;Reserved block?
	JE	6$.S			;Yes - don't check it
	CMPW	DX, iorrb_top.B[EDI]	;No - is there overlap?
	JBE	16$.S			;Yes - indicate not available
6$:	MOVL	EDI, [EDI]		;No - advance to next block
	JMP	4$.S

;Here if next block is above the requested block - the requested block is
;  available

8$:	CLC
10$:	POPL	EDI
	RET

;Here if there is overlap - indicate not available

12$:	TESTL	ESP, ESP		;Clear Z
	POPL	EDI
	RET

	.SBTTL	knlResIORegs - Subroutine to reserve an IO register block

;Subroutine to reserve an IO register block
;	c{EDX} = Base IO register in block
;	c{ECX} = Highest IO register in block
;	CALL	knlRegIORegs
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlResIORegs::
	PUSHL	EDI
	LEAL	EBX, firstiorrb
14$:	MOVL	EDI, [EBX]
	TESTL	EDI, EDI		;Is there another block?
	JE	18$.S			;No - finished
	CMPW	CX, iorrb_base.B[EDI]	;Above next block?
	JB	18$.S			;Yes - finished
	CMPW	DX, iorrb_top.B[EDI]	;No - is there overlap?
	JBE	16$.S			;Yes - indicate not available
	MOVL	EBX, EDI		;No - advance to next block
	JMP	14$.S

;Here if there is overlap - indicate not available

16$:	MOVL	EAX, #ER_IOINU
	STC
	POPL	EDI
	RET

;Here if next block is above the requested block - the requested block is
;  available

18$:	PUSHL	EDI
	PUSHL	ECX
	MOVL	ECX, #iorrb_SIZE
	CALL	knlGetXMem#
	JC	20$.S
	MOVW	iorrb_base.B[EDI], DX
	POPL	EDX
	MOVW	iorrb_top.B[EDI], DX
	MOVL	iorrb_name.B[EDI], #0
	MOVL	[EBX], EDI
	POPL	[EDI]
	POPL	EDI
	RET

;Here if error allocating memory

20$:	POPL	EDX
	POPL	EDX
	POPL	EDI
	RET
.PAGE
	.SBTTL	knlRegIORegs - Subroutine to register an IO register block

;Subroutine to register an IO register block - Caller must have already
;  determined that the block is available by calling knlChkIORegs.
;  Allocation over reserved blocks is allowed for exact matches.
;	c{EBX} = Offset of name string (bit 31 set if already allocated)
;	c{EDX} = Base IO register in block
;	c{ECX} = Highest IO reigster in block
;	CALL	knlRegIORegs
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EBX} = Allocated offset for name string (bit 31 is set)

knlRegIORegs::
	PUSHL	EDI
	PUSHL	EBX
	LEAL	EBX, firstiorrb
4$:	MOVL	EDI, [EBX]
	TESTL	EDI, EDI		;Is there another block?
	JE	10$.S			;No
	CMPW	CX, iorrb_base.B[EDI]	;Below next block?
	JB	10$.S			;Yes - it goes here
	CMPW	DX, iorrb_top.B[EDI]	;No - is there overlap?
	JBE	6$.S			;Yes - indicate not available
	MOVL	EBX, EDI		;No - advance to next block
	JMP	4$.S

;Here if there is overlap - See if we exactly overlap a reserved block and
;  grab the reserved block if so.

6$:	CMPL	iorrb_name.B[EDI], #0
	JNE	8$.S
	CMPW	DX, iorrb_base.B[EDI]
	JNE	8$.S
	CMPW	CX, iorrb_top.B[EDI]
	JE	12$.S
8$:	MOVL	EAX, #ER_IOINU
	STC
	POPL	EBX
	POPL	EDI
	RET

;Here if next block is above the requested block - This is where the new
;  block goes

10$:	PUSHL	EDI
	PUSHL	ECX
	MOVL	ECX, #iorrb_SIZE
	CALL	knlGetXMem#
	JC	20$.S
	MOVW	iorrb_base.B[EDI], DX
	POPL	EDX
	MOVW	iorrb_top.B[EDI], DX
	MOVL	[EBX], EDI
	POPL	[EDI]
	ADDW	iotableent#+dct_length, #20t.B
12$:	POPL	EBX
	MOVL	EDX, EDI
	BTZL	EBX, #31t
	JC	18$.S
	PUSHL	EBX
	CLRL	ECX
14$:	INCL	ECX
	INCL	EBX
	CMPB	[EBX], #0
	JNE	14$.S
	INCL	ECX
	POPL	EBX
	CALL	knlGetXMem#
	JC	22$.S
	SHRL	ECX, #2t
	PUSHL	EDI
16$:	MOVL	EAX, [EBX]
	MOVL	[EDI], EAX
	ADDL	EBX, #4t.B
	ADDL	EDI, #4t.B
	LOOP	ECX, 16$
	POPL	EBX
18$:	MOVL	iorrb_name.B[EDX], EBX
	BTSL	EBX, #31t
	POPL	EDI
	RET

;Here if error allocating memory

20$:	POPL	EBX
	POPL	EDX
	POPL	EDX
22$:	POPL	EDI
	RET
.PAGE
	.SBTTL	getioregs - Get value for IOTABLE SYSTEM characteristic

;Subroutine to get the value for the IOTABLE SYSTEM device characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	c{ESI}    = Offset of characteristics table entry
;	CALL	getioregs
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

;The value consists of one 20 byte block for each register block. The first
;  16 bytes contain the hardware name associated with the register block.
;  The next 2 bytes contain the base IO register number and the final 2
;  bytes contain the top IO register number. The blocks are ordered by
;  increasing base register values. A null hardware name (16 0 bytes)
;  indicates a reserved block.

getioregs::
	MOVL	EDX, EBX
	MOVL	EDI, firstiorrb
2$:	SUBL	ECX, #20t.B
	JS	10$.S
	CLRL	EAX			;First clear the name field
	IFFAULT	knlRtnAdrEr#
	MOVL	ES:[EBX], EAX
	IFFAULT	knlRtnAdrEr#
	MOVL	ES:12t.B[EBX], EAX
	MOVL	ES:4.B[EBX], EAX
	MOVL	ES:8.B[EBX], EAX
	PUSHL	EBX
	MOVL	ESI, iorrb_name.B[EDI]	;Give him the name
	TESTL	ESI, ESI
	JE	6$.S			;If no name (reserved block)
4$:	MOVB	AL, [ESI]
	CMPB	AL, #0
	JE	6$.S
	MOVB	ES:[EBX], AL
	INCL	ESI
	INCL	EBX
	JMP	4$.S

6$:	POPL	EBX
	MOVL	EAX, iorrb_base.B[EDI]	;Give him the values
	IFFAULT	knlRtnAdrEr#
	MOVL	ES:16t.B[EBX], EAX
	ADDL	EBX, #20t.B
	MOVL	EDI, [EDI]
	TESTL	EDI, EDI
	JNE	2$.S

;Here when finished

10$:	MOVL	ECX, EBX		;Get the amount we stored
	SUBL	ECX, EDX
12$:	RET


setioregs::
	MOVL	EAX, #ER_NIYT
	STC
	RET
.PAGE
	.SBTTL	getirqs - Get value for IRQTABLE SYSTEM characteristic

;Subroutine to get the value for the IRQTABLE SYSTEM device characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	c{ESI}    = Offset of characteristics table entry
;	CALL	getirqs
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

;The value consists of one 20 byte block for each interrupt. The first
;  16 bytes contain the hardware name associated with the interrupt.  The
;  next byte contains the interrupt number.  The next byte contains the
;  description bits.  Only bit 7 is used and is set if the interrupt is
;  sharable.  The remaining 2 bytes are reserved and will always contain 0.

getirqs::
	MOVL	EDX, EBX
	MOVL	EDI, firstirqrb
2$:	SUBL	ECX, #20t.B
	JS	10$.S
	CLRL	EAX			;First clear the name field
	IFFAULT	knlRtnAdrEr#
	MOVL	ES:[EBX], EAX
	IFFAULT	knlRtnAdrEr#
	MOVL	ES:12t.B[EBX], EAX
	MOVL	ES:4.B[EBX], EAX
	MOVL	ES:8.B[EBX], EAX
	PUSHL	EBX
	MOVL	ESI, irqrb_name.B[EDI]	;Give him the name
4$:	MOVB	AL, [ESI]
	CMPB	AL, #0
	JE	6$.S
	MOVB	ES:[EBX], AL
	INCL	ESI
	INCL	EBX
	JMP	4$.S

6$:	POPL	EBX
	CLRL	EAX
	MOVB	AL, irqrb_number.B[EDI]
	MOVB	AH, irqrb_bits.B[EDI]
	IFFAULT	knlRtnAdrEr#
	MOVL	ES:16t.B[EBX], EAX
	ADDL	EBX, #20t.B
	MOVL	EDI, [EDI]
	TESTL	EDI, EDI
	JNE	2$.S

;Here when finished

10$:	MOVL	ECX, EBX		;Get the amount we stored
	SUBL	ECX, EDX
12$:	RET
.PAGE
	.SBTTL	knlGetTrm - Subroutine to get DCB for controlling terminal

;Subroutine to get DCB for controlling terminal
;	CALL	knlGetTrm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset of DCB

knlGetTrm::PUSHL	EBX
	MOVL	EAX, #DH_STDTRM		;Get device descriptor for the terminal
	JMP	4$.S			;Continue

knlQioGetDcb::
	MOVXWL	EAX, iorb_handle.B[ESI]	;Get handle from the IORB
					;Fall into getdcb

	.SBTTL	knlGetDcb - Subroutine to get DCB given device handle

;Subroutine to get DCB given device handle
;	c{EAX} = Device handle
;	CALL	knlGetDcb
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Device command bits (only valid if error is ER_DEVNO)
;	C:clr = Normal
;	  c{EAX} = Device handle (unchanged)
;	  c{ECX} = Device command bits
;	  c{EDI} = Offset of DCB
;  All other registers are preserved

knlGetDcb::
	PUSHL	EBX
	CMPL	EAX, SS:pdaHndlNum#	;Legal device handle?
	JA	10$.S			;No - fail
4$:	MOVL	EBX, EAX		;Yes
	SHLL	EBX, #5t
	JE	10$.S			;0 is not valid
	ADDL	EBX, SS:pdaHndlTbl#	;Get offset of start of table
	MOVL	EDI, SS:[EBX]		;Get offset of the DCB
	CMPL	EDI, #1000h		;Error if not set up yet or if not in
	JL	8$.S			;  use
	MOVL	ECX, dcb_cab.B[EDI]	;Do we have a CAB?
	JREGZ	ECX, 6$			;No
	PUSHL	EAX			;Yes
	MOVW	AX, cab_time.B[ECX]	;Reset its timer
	MOVW	cab_count.B[ECX], AX
	POPL	EAX
6$:	MOVL	ECX, SS:4.B[EBX]	;No - get command bits
	TESTL	ECX, #O$NOQUE|O$OPNCLS	;Opening or closing the device?
	JNE	10$.S			;Yes - this makes it invisible!
	POPL	EBX
	RET

;Here if bad device handle

8$:	MOVL	EAX, #ER_DEVNO		;Assume device is not open
	MOVL	ECX, SS:4.B[EBX]	;Get command bits (will be valid if
					;  error is device not open)
	TESTL	EDI, EDI		;Right?
	JE	10$.S			;No
	CMPL	EDI, #0FFFh		;Maybe
	JNE	12$.S			;Yes
10$:	MOVL	EAX, #ER_BDDVH
12$:	POPL	EBX
	STC
	RET
.PAGE
	.SBTTL	knlXfGetDcb - Subroutine to get DCB given device handle in extended fork context

;Subroutine to get DCB given device handle in extended fork context
;	c{EAX} = Device handle
;	CALL	knlXfGetDcb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Device command bits
;	  c{EDI} = Offset of DCB
;  All other registers are preserved

knlXfGetDcb::
	PUSHL	EBX
	PUSHL	ES
	MOVL	ES, SS:xffPda#
	CMPL	EAX, ES:pdaHndlNum#	;Legal device handle?
	JA	10$.S			;No - go fail
4$:	MOVL	EBX, EAX		;Yes
	SHLL	EBX, #5t
	JE	10$.S			;0 is not valid
	ADDL	EBX, ES:pdaHndlTbl#	;get offset of start of table
	MOVL	EDI, ES:[EBX]		;Get offset of the DCB
	CMPL	EDI, #1000h		;Error if not set up yet or if not in
	JL	8$.S			;  use
	MOVL	ECX, dcb_cab.B[EDI]	;Do we have a CAB?
	JREGZ	ECX, 6$			;No
	PUSHL	EAX
	MOVW	AX, cab_time.B[ECX]	;Yes - reset its timer
	MOVW	cab_count.B[ECX], AX
	POPL	EAX
6$:	MOVL	ECX, ES:4.B[EBX]	;No - get command bits
	TESTL	ECX, #O$NOQUE|O$OPNCLS	;Opening or closing the device?
	JNE	10$.S			;Yes - this makes it invisible!
	POPL	ES
	POPL	EBX
	RET

;Here if bad device handle

8$:	MOVL	EAX, #ER_DEVNO		;Assume device is not open
	TESTL	EDI, EDI		;Right?
	JE	10$.S			;No
	CMPL	EDI, #0FFFh		;Maybe
	JNE	12$.S			;Yes
10$:	MOVL	EAX, #ER_BDDVH
12$:	POPL	ES
	POPL	EBX
	STC
	RET
.PAGE
	.SBTTL	knlGetCab - Subroutine to allocate a CAB

;Subroutine to allocate a CAB
;	CALL	knlGetCab
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ESI} = Offset of CAB allocated

knlGetCab::
	MOVL	EDX, opn_frame1.B[EBP]
	MOVL	ESI, SS:opn_cab.B[EDX]
	TESTL	ESI, ESI
	JNE	ret004.S
	CLRL	ECX
	CALL	knlGetXmb#
	JC	ret004.S
	MOVL	SS:opn_cab.B[EDX], ESI
	CLRL	EAX
	MOVL	cab_dcb.B[ESI], EAX
	MOVL	cab_count.B[ESI], EAX
	MOVL	cab_clsmsg.B[ESI], EAX
	MOVL	cab_clsname.B[ESI], EAX
	DECL	EAX
	MOVL	[ESI], EAX
ret004:	RET
.PAGE
	.SBTTL	knlCheckCab - Subroutine to check for unneeded CAB

;Subroutine to check for unneeded CAB and give it up - called after error
;  storing data into the CAB to see if its still needed
;	c{ESI} = Offset of CAB
;	CALL	knlCheckCab

knlCheckCab::
	MOVZBL	EAX, cab_clsname.B[ESI]	;Is it still needed?
	ORB	AL, cab_clsmsg.B[ESI]
	ORL	EAX, cab_time.B[ESI]
	JNE	ret004.S		;Yes
	CLRL	ECX			;No
	MOVL	EAX, opn_frame1.B[EBP]	;Clear the pointer
	MOVL	SS:opn_cab.B[EAX], ECX
	JMP	knlGiveXmb#		;Give up the block and return
.PAGE
	.SBTTL	xferalldev - Subroutine to transfer all devices to new process

;Subroutine to transfer all of a processe's devices to a new process
;	c[ES]     = Selector for PDA for new process
;	CALL	xferalldev
;	C:set = Error
;	  C{EAX} = Error code
;	C:clr = Normal

xferalldev::
	MOVL	EDI, ES:pdaHndlTbl#	;Get offset of destination handle table
	ADDL	EDI, #mb_data.B
	MOVL	EDX, SS:pdaHndlTbl#	;Get offset of our handle table
	ADDL	EDX, #mb_data.B
	MOVL	ECX, SS:pdaHndlNum#	;Get size of our handle table
	CMPL	ECX, ES:pdaHndlNum#
	JBE	4$.S
	MOVL	ECX, ES:pdaHndlNum#
4$:	MOVL	EAX, SS:[EDX]		;Get entry
	CMPL	EAX, #1000h		;Is this handle in use?
	JBE	6$.S			;No
	BTL	SS:4.B[EDX], #O%NOINH	;Yes - should we transfer it?
	JC	6$.S			;No - skip it
	CMPL	ES:[EDI], #0.B		;Yes - is the destination available?
	JNE	xfdvbh2			;No - fail
	BTSL	EAX, #30t		;Yes - indicate it is being transfered
	MOVL	ES:[EDI], EAX		;Store in destination table
	MOVL	EAX, SS:4t.B[EDX]	;Copy of rest of table entry
	MOVL	ES:4t.B[EDI], EAX
	MOVL	EAX, SS:8t.B[EDX]
	MOVL	ES:8t.B[EDI], EAX
	MOVL	EAX, SS:12t.B[EDX]
	MOVL	ES:12t.B[EDI], EAX
	MOVL	EAX, SS:16t.B[EDX]
	MOVL	ES:16t.B[EDI], EAX
	MOVL	EAX, SS:20t.B[EDX]
	MOVL	ES:20t.B[EDI], EAX
	MOVL	EAX, SS:24t.B[EDX]
	MOVL	ES:24t.B[EDI], EAX
	MOVL	EAX, SS:28t.B[EDX]
	MOVL	ES:28t.B[EDI], EAX
6$:	ADDL	EDX, #32t.B		;Bump pointers
	ADDL	EDI, #32t.B
	LOOP	ECX, 4$			;Continue if more to do
	JMP	xfdvwc2			;Continue with common code
.PAGE
	.SBTTL	xferdev - Subroutine to transfer selected devices to new process

;Subroutine to transfer selected devices to new process using a device list.
;	c{ECX}    = Length of device list (bytes)
;	c{FS:ESI} = Address of device list
;	c[ES]     = Selector for PDA for new process
;	CALL	xferdev
;	C:set = Error
;	  C{EAX} = Error code
;	C:clr = Normal

;The device list contains a series of items, each consisting of 4 longs as
;  follows:
;    Source handle      - Current handle for device, Bit 31 set if should
;			  give up the device after it is transfered, bit 30
;			  set if should transfer ownership of device to child.
;			  Bit 29 is set by the system if device no longer is
;			  available to the calling process.
;    Destination handle - Value for handle for destination process - 0 means
;			  to allocate any available handle in which case this
;			  field is updated to contain the handle allocated.
;    Command bits       - New command bits value - only O$IN and O$OUT can be
;			  changed - all other bits are always taken for the
;			  current command bits (-1 means to use current command
;			  bits).
;    Unused             - Must contain 0.
;  The list is terminated by a long containing -1 or when the byte count runs
;  out.

;This function assumes the device table for the receiving process exists but
;  that the process is not executing.  It first builds a list of DCBs to
;  transfer in the destination device table.  Bits 31 and 30 are copies of
;  bits 31 and 30 from the source handle entry in the device list.  Bit 29
;  is always set to indicate that this device table entry is not fully set
;  up for the process.  Once this list is complete, an exec signal is
;  requested which will execute in the context of the receiving process.
;  This routine starts an extended fork context routine which finishes
;  transfering the devices.  The calling process waits (in an uninterruptable
;  wait) until all devices have been initialized.

$$$=!0
FRM xdv_devlist, 8t		;Address of device list
FRM xdv_devsize, 4t
FRM xdv_count  , 4t
xdv_SIZE=!$$$

ALLOW=!O$IN|O$OUT|O$NORDAH|O$NODFWR ;Allowed device bits
ALLOW=!ALLOW|O$CONTIG|O$CRIT|O$NOREOPEN|O$FNR|O$PARTIAL|O$NOINH

xferdev::
	SHRL	ECX, #4t		;Change count to number of items
	JE	4$.S			;If nothing to do
	ENTER	xdv_SIZE, 0
	MOVL	xdv_devlist+0.B[EBP], ESI ;Save address of the device list
	MOVL	xdv_devlist+4.B[EBP], FS
	MOVL	xdv_devsize.B[EBP], ECX	;Save number of items in list
	MOVL	xdv_count.B[EBP], ECX

;Make a first scan through the device list and allocate handles in the new
;  process.  We also check and make sure we are not trying to transfer the
;  same handle twice.  We will discover here if there are any conflicts in
;  handle values.

	MOVL	EDI, ES:pdaHndlTbl#	;Get offset of destination handle table
	MOVL	EDX, SS:pdaHndlTbl#	;Get offset of our handle table
xfdvlp:	IFFAULT	xfdvae
	MOVL	EBX, FS:[ESI]		;Get source handle
	TESTL	EBX, EBX		;End of list?
	JE	xfdvset			;Yes
	BTZL	EBX, #30t		;No
	BTZL	EBX, #31t		;Want to transfer the handle?
	JNC	10$.S			;No
	PUSHL	ESI			;Yes - scan the rest of the device list
	MOVL	ECX, xdv_count.B[EBP]	;  to see if there is a conflict
2$:	DECL	ECX			;More to check?
	JE	8$.S			;No - no conflict found
	ADDL	ESI, #16t.B		;Yes - bump poiner
	IFFAULT	xfdvae
	MOVL	EAX, FS:[ESI]
	TESTL	EAX, EAX		;End of list?
	JE	8$.S			;Yes
	ANDL	EAX, #3FFFFFFFh		;No
	CMPL	EAX, EBX		;Same handle?
	JNE	2$.S			;No - continue checking
	POPL	ESI			;Yes - fail
	JMP	xfdvbh.S

;Here if nothing to do

4$:	CLC
	RET

;Here if no conflict found when transfering a device

8$:	POPL	ESI
10$:	CMPL	EBX, SS:pdaHndlNum#	;Valid handle?
	JA	xfdvbh.S		;No - fail
	SHLL	EBX, #5
	MOVL	EAX, SS:[EDX+EBX]	;Yes - is it in use?
	CMPL	EAX, #1000h
	JB	xfdvbh.S		;No - fail
	TESTL	SS:4.B[EDX+EBX], #O$NOQUE|O$OPNCLS
	JNE	xfdvbh.S		;Fail if opening or closing the device
	IFFAULT	xfdvae			;OK - handle is available to transfer
					;  or copy
	MOVL	ECX, FS:4t.B[ESI]	;Get destination handle
	TESTL	ECX, ECX		;Is it specified?
	JNS	xfdvdst.S		;Yes - go on
	MOVL	ECX, #DH_FV		;No - allocate one
	LEAL	EAX, DH_FV*32t[EDI]
12$:	CMPL	ES:[EAX], #0.B		;Is this one available?
	JE	xfdvalc.S		;Yes - use it
	INCL	ECX			;No - bump handle
	ADDL	EAX, #32t.B		;Bump pointer
	CMPL	ECX, ES:pdaHndlNum#	;Too big?
	JB	12$.S			;No - continue
xfdvbh:	LEAVE
xfdvbh2:PUSHL	#ER_BDDVH.B		;Yes - fail
	JMP	xfdver.S
.PAGE
;Here if have address error

	FAULTHDR
xfdvae:	LEAVE
	PUSHL	#ER_ADRER.B
xfdver:	MOVL	ECX, ES:pdaHndlNum#	;Get size of the destination table
	ADDL	EDI, #mb_data.B		;Point to first slot in table
	CLRL	EAX
2$:	TESTB	ES:3.B[EDI], #40h	;Is this a new entry?
	JE	4$.S			;No
	STOSL	[EDI]
	STOSL	[EDI]
	STOSL	[EDI]
	STOSL	[EDI]
	STOSL	[EDI]
	STOSL	[EDI]
	STOSL	[EDI]
	STOSL	[EDI]
	JMP	6$.S

4$:	ADDL	EDI, #32t
6$:	LOOP	ECX, 2$
	POPL	EAX
	STC
	RET

;Here if a destination handle was specified

xfdvdst:CMPL	ECX, ES:pdaHndlNum#	;Yes - valid handle?
	JA	xfdvbh.S		;No - fail
	SHLL	ECX, #5t
	JE	xfdvbh.S
	CMPL	ES:[EDI+ECX], #0.B	;Yes - is it in use?
	JE	8$.S			;No - go on
	JMP	xfdvbh.S		;Yes - fail

;Here with a destination handle allocated

xfdvalc:IFFAULT	xfdvae			;Give the caller the destination handle
	MOVL	FS:4.B[ESI], ECX	;  that we allocated
	SHLL	ECX, #5t
	MOVL	EAX, SS:[EDX+EBX]	;Restore the offset of the DCB
8$:	PUSHL	ECX
	IFFAULT	xfdvae
	MOVL	ECX, FS:[ESI]		;Get the high bit
	ANDL	ECX, #080000000h
	ORL	EAX, ECX
	POPL	ECX
	BTSL	EAX, #30t		;Always set bit 30
	MOVL	ES:[EDI+ECX], EAX	;Store the DCB offset + bits
	IFFAULT	xfdvae
	MOVL	EAX, FS:8t.B[ESI]	;Get new command bits
	CMPL	EAX, #-1.B		;Where any given?
	JNE	10$.S			;Yes
	MOVL	EAX, SS:4.B[EDX+EBX]	;No - use current bits
10$:	ANDL	EAX, #ALLOW
	ANDL	ES:4.B[EDI+ECX], #~ALLOW
	ORL	ES:4.B[EDI+ECX], EAX
	MOVL	EAX, SS:16.B[EDX+EBX] 	;Also copy the rooted name field
	MOVL	ES:16.B[EDI+ECX], EAX
	MOVL	EAX, SS:20t.B[EDX+EBX]
	MOVL	ES:20t.B[EDI+ECX], EAX
	MOVL	EAX, SS:24t.B[EDX+EBX]
	MOVL	ES:24t.B[EDI+ECX], EAX
	MOVL	EAX, SS:28t.B[EDX+EBX]
	MOVL	ES:28t.B[EDI+ECX], EAX
	ADDL	ESI, #16t.B		;Bump device list pointer
	DECL	xdv_count.B[EBP]	;More to do?
	JNE	xfdvlp			;Yes - continue
					;No - continue on next page
.PAGE
;Here with the destination handle table set up.  Now we scan the device list
;  again and call the sd_transold entry for all devices we are transferring.
;  This routine also changes ownership of devices if necessary.

	IFFAULT	xfdvae
xfdvset:LFSL	ESI, xdv_devlist.B[EBP]	;Restore address of the device list
2$:	MOVL	EAX, FS:[ESI]		;Get the handle
	TESTL	EAX, EAX		;End of list?
	JE	xfdvwc			;Yes
	ANDL	EAX, #0FFFFFFFh		;No - get the DCB (This can't fail since
	CALL	knlGetDcb		;  we've already checked for everything
	JC	12$			;  that could be wrong!)
	TESTB	FS:3.B[ESI], #80h	;Are we giving up the device?
	JE	4$.S			;No
	TESTB	FS:3.B[ESI], #40h	;Yes - want to change ownership?
	JE	4$.S			;No
	MOVW	DX, dcb_sesproc.B[EDI]	;Yes - do we own it now?
	CMPW	DX, SS:pdaSesProc#
	JNE	4$.S			;No - forget it!
	CMPL	dcb_opencnt.B[EDI], #1.B ;Yes - just open once?
	JNE	4$.S			;No - can't transfer ownership!
	MOVL	EDX, SS:pdaHndlTbl#	;Yes - is it our controlling terminal?
	CMPL	SS:DH_STDTRM*32t[EDX], EDI
	JE	4$.S			;Yes - can't change ownership!
	MOVW	DX, ES:pdaSesProc#	;OK - change ownership
	MOVW	dcb_sesproc.B[EDI], DX
4$:	TESTB	FS:3.B[ESI], #80h	;Are we transfering this device?
	JE	6$.S			;No
	CLRL	EDX			;Yes
	MOVL	EBX, SS:pdaHndlTbl#	;Clear our handle table entry
	SHLL	EAX, #5t
	MOVL	SS:[EBX+EAX], EDX
	MOVL	SS:4.B[EBX+EAX], EDX
	MOVL	SS:8.B[EBX+EAX], EDX
	MOVL	SS:12t.B[EBX+EAX], EDX
	MOVL	EAX, dcb_sdisp.B[EDI]	;Do cleanup for current owner (this
	PUSHL	ES			;  has no error return!)
	PUSHL	FS
	PUSHL	ESI
	CALLI	CS:sd_transold.B[EAX]
	POPL	ESI
	POPL	FS
	POPL	ES
	IFFAULT	6$
	BTSL	FS:[ESI], #29t		;Tell him the device is gone (ignore
	FAULTHDR			;  it if can't change it!)
6$:	ADDL	ESI, #16t.B		;Bump device list pointer
	DECL	xdv_devsize.B[EBP]	;More to do?
	JNE	2$			;Yes - continue

;Here with all of the real work done - now we wait for the child to do its
;  part

xfdvwc:	LEAVE
xfdvwc2:MOVL	EBX, #xferdevrcv
	MOVL	EDX, SS
	MOVL	SS:pdaResponse#, #1
	TOFORK
	CALL	knlReqXSig#
8$:	PUSHL	SS
	POPL	ES
	MOVB	AL, #knlQX_SPND#
	CALL	knlWRequeue#		;Requeue to the suspend queue
	FROMFORK
	CALLF	schedule		;Call the scheduler (this is an
	MOVL	EAX, SS:pdaResponse#	;  uninterruptable wait!)
	TESTL	EAX, EAX
	JG	10$.S
	BTL	EAX, #31t
	RET

10$:	TOFORK
	JMP	8$.S

12$:	CRASH	CNGD			;[Can Not Get DCB]
.PAGE
	.SBTTL	xferdevrvc - Subroutine to finish transfering devices

;Subroutine to finish transfering initial devices.  This subroutine is called
;  as an exec signal routine
;	c{EDX} = Selector for source process PDA
;	CALL	xferdevrcv
;	c{EAX} = Error code:
;		   = 0 = Normal
;		   < 0 = Error (If more than one error, only the one from the
;			 highest handle is reported.  It is assumed that the
;			 process will be killed shortly if there are errors,
;			 so no clean-up is done here.)

xferdevrcv:
	PUSHL	EDX			;Save source PDA selector
	MOVL	SS:pdaResponse#, #1
	CALL	knlGetQel#		;Get an IORB (which we don't really need
	JC	6$.S			;  except that knlXfBegin wants it)
	CLRL	EAX
	MOVL	iorb_parm+0.B[ESI], EAX
	MOVL	iorb_lock+0.B[ESI], EAX
	MOVL	iorb_mlckcnt.B[ESI], EAX
	MOVB	iorb_queue.B[ESI], AL
	MOVL	iorb_finish.B[ESI], #knlXfFinish#
	MOVL	iorb_routine.B[ESI], #xferdev1
	CLRL	EDI
	CALL	knlXfBegin#		;Switch to extended fork context (this
					;  returns at fork level)
4$:	MOVL	EAX, SS:pdaResponse#	;Finished yet?
	TESTL	EAX, EAX
	JLE	8$.S			;Yes
	PUSHL	SS			;No - set up to wait
	POPL	ES
	MOVB	AL, #knlQX_SPND#
	CALL	knlWRequeue#		;Requeue to the suspend queue
	FROMFORK
	CALLF	schedule		;Call the scheduler (this is an
	TOFORK				;  uninterruptable wait!)
	JMP	4$.S

6$:	TOFORK
8$:	POPL	ES
	MOVL	ES:pdaResponse#, EAX
	CALL	knlRRequeue#
	FROMFORK
	RET
.PAGE
;Extended fork context routine to process devices transfered to a new process
;  When get here entries have been placed in the device for each device being
;  transfered.  Bit 30 is set to flag the device as one being transfered.  Bit
;  31 is set to indicate that the parent process is giving up the device.

xferdev1:
	PUSHL	#0.B
	MOVW	ES, SS:xffPda#
	MOVL	EBX, ES:pdaHndlTbl#
	MOVL	ECX, ES:pdaHndlNum#
4$:	ADDL	EBX, #32t.B		;(THIS ASSUMES THAT mb_data < 16t!)
	BTZL	ES:[EBX], #30t		;Is this a new DCB?
	JNC	14$.S			;No - go on
	MOVL	EDI, ES:[EBX]		;Yes
	MOVL	EAX, EBX
	SUBL	EAX, ES:pdaHndlTbl#
	SHRL	EAX, #5t
	MOVW	SS:xffHandle#, AX
	CLRL	EAX
	MOVL	SS:xffOption#, EAX
	PUSHL	ECX
	PUSHL	ES
	PUSHL	EBX
	MOVL	ECX, ES:4.B[EBX]
	MOVL	SS:xffCmd#, ECX
	BTZL	EDI, #31t		;Are we transfering the device?
	MOVL	SS:xffDcb#, EDI
	MOVL	EAX, dcb_sdisp.B[EDI]
	JC	6$.S			;Yes
	INCL	dcb_opencnt.B[EDI]	;No - bump the open count
	CALLI	CS:sd_opena.B[EAX]	;Call the open additional routine
	JNC	8$.S			;OK - continue
	MOVL	12t.B[ESP], EAX		;Error - save error code
	POPL	EBX
	POPL	ES
	DECL	dcb_opencnt.B[EDI]	;Reduce the open count
	CLRL	EAX			;Clear the handle table
	MOVL	ES:[EBX], EAX
	MOVL	ES:4.B[EBX], EAX
	MOVL	ES:8.B[EBX], EAX
	MOVL	ES:12t.B[EBX], EAX
	JMP	10$.S

;Here if transfering the device

6$:	ANDB	ES:3.B[EBX], #7Fh
	CALLI	CS:sd_transnew.B[EAX]	;Call the transfer/new routine (this
8$:	POPL	EBX			;  cannot fail)
	POPL	ES
10$:	POPL	ECX
14$:	DECL	ECX
	JNE	4$
	POPL	ES:pdaResponse#
	JMP	knlRRequeue#
.PAGE
	.SBTTL	resetio - Subroutine to reset IO when terminating process

;Subroutine to reset IO when terminating process - all open devices are closed
;  and all device paths are given up
;	CALL	resetio
;	C:set = Need to wait
;	  c(AL) = Wait queue index
;	C:clr = Finished

resetio::
	CALL	cancelall		;Cancel all pending IO
	JC	8$			;If need to wait
	MOVL	EDX, SS:pdaHndlNum#	;Get number of entries to check
	INCL	EDX
2$:	DECL	EDX
	JE	12$
	MOVL	ECX, EDX
	SHLL	ECX, #5t
	ADDL	ECX, SS:pdaHndlTbl#	;Get offset of the handle table
	MOVL	EDI, SS:[ECX]		;Get next entry in table
	CMPL	EDI, #1000h

;;;;;;; THIS IS WRONG!!!!!!

	JB	2$.S			;If entry is not in use
	BTL	EDI, #30t		;Are we transfering this device?
	JNC	4$.S			;No
	CLRL	EAX			;Yes - just clear the handle table entry
	MOVL	SS:[ECX], EAX
	MOVL	SS:4t.B[ECX], EAX
	MOVL	SS:8t.B[ECX], EAX
	MOVL	SS:12t.B[ECX], EAX
	JMP	2$.S			;Continue

;Here if have a real device table entry

4$:	BTL	SS:4.B[ECX], #O%NOQUE	;Has queueing been disabled?
	JC	6$.S			;Yes - just wait until finished
	FROMFORK			;No
	PUSHL	EDX
	CALL	knlGetQel#		;Get an IORB
	JC	10$.S
	MOVL	EAX, [ESP]		;Set up arguments for the close
	MOVW	iorb_handle.B[ESI], AX
	CLRL	EAX
	MOVL	iorb_mlckcnt.B[ESI], EAX
	MOVL	iorb_parm+0.B[ESI], EAX
	MOVL	iorb_qab+0.B[ESI], EAX
	MOVW	iorb_qab+4.B[ESI], AX
	MOVL	iorb_lock+0.B[ESI], EAX
	MOVW	iorb_func.B[ESI], #QFNC_CLOSE
	MOVL	iorb_option.B[ESI], #C$KILL
	MOVL	iorb_finish.B[ESI], #clsalld
	CALL	close2#			;Close the device (this returns raised
	POPL	EDX			;  to fork level)
	MOVL	EAX, EDX
	SHLL	EAX, #5t
	ADDL	EAX, SS:pdaHndlTbl#
	CMPL	SS:[EAX], #0.B		;Is device closed now?
	JE	2$			;Yes - continue
6$:	MOVL	SS:pdaHndlNum#, EDX	;No - update maximum handle number
	INCL	SS:pdaHndlNum#
	MOVL	EAX, EDX		;Set up to wait (use handle as the
8$:	CALL	knlSetWait#		;  wait index)
	FROMFORK
	MOVB	AL, #knlQX_DW2#
	STC				;Indicate need to wait
	RET

10$:	CRASH	NQEL

;Here with all devices closed

12$:	FROMFORK
	CALL	givepath#		;Give up all paths and return
	CLC
	RET
.PAGE
;Here at fork level when close is finished for resetio

clsalld:MOVL	EAX, EDI		;Get offset of DCB as wait index
	CALL	knlEndWaitAll#		;Wake up all waiters
	JE	4$.S			;If no one waiting
	CMPB	curqx#, #knlQX_PQ1#	;Is current process in PQ1?
	JE	4$.S			;Yes - don't bother scheduling now
	MOVB	knlSchedReq#, #1	;No - reschedule immediately
4$:	JMP	knlXfFinish#
.PAGE
;Subroutine to cancel IO on all currently open devices
;	CALL	cancelall
;	C:set = Need to wait (at fork level)
;	  c{EAX} = Wait index to use
;	C:clr = Finished (at fork level)
;  If the need to wait return is given, the program should wait using the
;    specified wait index and call cancelall again when the wait terminates.
;    The first call will start all devices terminating, following calls
;    simply determine if it is still necessary to wait.

$$$=!0
FRM canio_handle, 4t
FRM canio_waitx , 4t
canio_SIZE=!$$$

cancelall::
	ENTER	canio_SIZE, 0
	MOVL	EAX, SS:pdaHndlNum#	;Get number of entries to check
	MOVL	canio_handle.B[EBP], EAX
	MOVL	canio_waitx.B[EBP], #-1
	TOFORK
2$:	MOVL	ECX, canio_handle.B[EBP]
	SHLL	ECX, #5t
	ADDL	ECX, SS:pdaHndlTbl#	;Get offset of the handle table
	MOVL	EDI, SS:[ECX]		;Get next entry in table
	CMPL	EDI, #0FFFh
	JA	8$.S			;If device is specified for handle
	CMPL	EDI, #0FFEh
	JB	6$.S			;If handle is idle
	JE	4$.S			;If opened and is being aborted
	DECL	SS:0.B[ECX]		;Opening - indicate should be aborted
4$:	MOVL	EAX, canio_handle.B[EBP]
	MOVL	canio_waitx.B[EBP], EAX	;Must wait unit the open is finished
6$:	DECL	canio_handle.B[EBP]	;More to do?
	JNE	2$.S			;Yes - continue
	MOVL	EAX, canio_waitx.B[EBP]	;No - finished
	BTL	EAX, #31t
	CMC
	LEAVE
ret006:	RET

;Here if a device is specified for the handle

8$:	BTL	EDI, #30t		;Is the device being transfered?
	JC	6$.S			;Yes - its not really there!
9$:	TESTB	SS:4+2.B[ECX], #O$NOQUE>16t ;No - has queueing been disabled?
	JE	10$.S			;No - go on
	TESTB	SS:4+2.B[ECX], #O$OPNCLS>16t ;Is it being closed now?
	JNE	14$.S			;Yes - just wait unit it finishes
					;  closing
10$:	MOVL	EDX, canio_handle.B[EBP] ;No
	MOVL	EBX, #dcb_inpframe	;Cancel any current input
	MOVB	CL, #CAN$ALL
	CALL	knlCancelIo#
	MOVL	EDX, canio_handle.B[EBP]
	JNC	12$.S
	MOVL	canio_waitx.B[EBP], EDX
12$:	MOVL	EBX, #dcb_outframe	;Cancel any output
	MOVB	CL, #CAN$ALL
	CALL	knlCancelIo#
	JNC	6$.S
14$:	MOVL	EDX, canio_handle.B[EBP]
	MOVL	canio_waitx.B[EBP], EDX
	JMP	6$.S
.PAGE
	.SBTTL	knlReqFork - Subroutine to request fork service

;Subroutine to request execution of fork routine when interrupts are dismissed
;	c[EDI] = Offset of DCB
;	CALL	knlReqFork
;  EAX is destroyed

knlReqFork::
	PUSHFL
	CLI				;No interrupts at all here
	CMPL	dcb_fnext.B[EDI], #-1.B	;Already have fork request queued?
	JNE	6$.S			;Yes - nothing needed here
	MOVL	EAX, forkreqt		;No - get tail of fork list
	TESTL	EAX, EAX
	JNE	2$.S			;If list not empty
	MOVL	forkreqh, EDI		;Empty - set head pointer
	JMP	4$.S

2$:	MOVL	dcb_fnext.B[EAX], EDI	;Not empty - link to previous
4$:	MOVL	forkreqt, EDI		;Update tail pointer
	MOVL	dcb_fnext.B[EDI], #0
6$:	POPFL				;Allow interrupts
	RET				;Thats all

	.SBTTL	knlDsmFork - Subroutine to dismiss fork routine

;Subroutine to dismiss fork routine - called when main program level has
;  raised to fork level to return to main program level
;	CALL	knlDsmFork
;  All registers are preserved, C is always clear

knlDsmFork::
	CLI				;No interrupts here
	CMPB	knlForkLvl#, #FORK_MFORK ;Really raised to device fork level?
	JE	7$.S			;Yes
	CMPB	knlForkLvl#, #FORK_SFORK ;Maybe
	JNE	8$.S			;No - fail!
7$:	CMPL	forkreqh, #0.B		;Yes - have any device fork requests?
	JNE	10$.S			;Yes
	CMPL	xffreqh#, #0.B		;No - have any extended fork requests?
	JNE	20$			;Yes
	MOVB	knlForkLvl#, #FORK_MAIN	;No - no longer at fork level
	STI				;Allow interrupts again
	RET				;Thats all

;Here if not at fork level

8$:	CRASH	NDFL			;[Not at Device Fork Level]

;Here if have a fork request

10$:	PUSHL	DS			;Save all registers
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHAL
	MOVB	knlForkLvl#, #FORK_DFORK ;Indicate at device fork level
	MOVL	EDI, forkreqh		;Get request from the fork list
12$:	MOVL	EAX, dcb_fnext.B[EDI]
	MOVL	forkreqh, EAX
	TESTL	EAX, EAX
	JNE	14$.S
	MOVL	forkreqt, EAX
14$:	MOVL	dcb_fnext.B[EDI], #-1	;Indicate not queued now
	STI				;Interrupts are OK now

;Start of XFF timing code

	CALL	getdelta#		;Get delta time
	ADDL	SS:pdaRunTime#+0, EAX
	ADCL	SS:pdaRunTime#+4, EDX
	SUBL	SS:pdaRunQTime#, EAX

;End of XFF timing code

	CALLI	dcb_fdisp.B[EDI]	;Call fork routine

;Start of XFF timing code

	CALL	getdelta#		;Get delta time
	ADDL	knlForkTime#+0, EAX
	ADCL	knlForkTime#+4, EDX

;End of XFF timing code

16$:	CLI
	MOVL	EDI, forkreqh		;Get next request
	TESTL	EDI, EDI		;Is there another?
	JNE	12$			;Yes - go handle it
	CMPL	xffreqh#, #0.B		;No - have any extended fork requests?
	JNE	22$.S			;Yes
	MOVB	knlForkLvl#, #FORK_MAIN	;No - no longer at fork level
	STI				;Allow interrupts
	POPAL				;Restore registers
	POPL	GS
	POPL	FS
	POPL	ES
	POPL	DS
ret010:	RET				;And return

;Here with extended fork request

20$:	PUSHL	DS			;Save all registers
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHAL
22$:	STI				;Allow interrupts here
	MOVL	ES, xffreqh#		;Get request from the fork list
	MOVL	EAX, ES:xffReqNext#	;Remove from list
	MOVL	xffreqh#, EAX
	TESTL	EAX, EAX
	JNE	24$.S
	MOVL	xffreqt#, EAX
24$:	MOVL	ES:xffReqNext#, #-1
	MOVB	knlForkLvl#, #FORK_XFF	;Indicate in extended fork context
	CALLFI	ES:xffCallAddr#		;Do task switch to the extended fork
	MOVB	knlForkLvl#, #FORK_DFORK ;Back to device fork level
	JMP	16$.S			;Go check for another device fork
.PAGE
	.SBTTL	knlXffAllow - Subroutine to allow other XFFs to execute

;Subroutine to allow any other XFFs which have been queued to execute - must
;  be called from extended fork context
;	CALL	knlXffAllow
;  EAX and ES may be destroyed, other registers are preserved

knlXffAllow::
	REQUIREXFF
2$:	CMPL	forkreqh, #0.B		;Yes - have any device fork requests?
	JE	8$			;No
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHAL
4$:	CLI				;Yes
	MOVL	EDI, forkreqh		;Get request
	MOVL	EAX, dcb_fnext.B[EDI]	;Remove from fork list
	MOVL	forkreqh, EAX
	TESTL	EAX, EAX
	JNE	6$.S
	MOVL	forkreqt, EAX
6$:	MOVL	dcb_fnext.B[EDI], #-1
	MOVB	knlForkLvl#, #FORK_DFORK
	STI				;Interrupts are OK now

;Start of fork level timing code

	CALL	getdelta#		;Get delta time
	MOVW	FS, SS:xffPda#
	ADDL	FS:pdaXffTime#+0, EAX
	ADCL	FS:pdaXffTime#+4, EDX

;End of fork level timing code

	CALLI	dcb_fdisp.B[EDI]	;Call fork routine
	CMPB	knlForkLvl#, #FORK_DFORK ;Still at device fork level?
	JNE	16$.S			;No!

;Start of fork level timing code

	CALL	getdelta		;Get delta time
	ADDL	knlForkTime#+0, EAX
	ADCL	knlForkTime#+4, EDX

;End of fork level timing code

	MOVB	knlForkLvl#, #FORK_XFF
	CMPL	forkreqh, #0.B
	JNE	4$.S
	POPAL
	POPL	GS
	POPL	FS
	POPL	ES
	POPL	DS

;Here if no (more) device fork requests

8$:	CMPL	xffreqh#, #0.B		;Have any extended fork requests?
	JE	12$.S			;No - finished here
	PUSHL	ES
	PUSHL	EAX
	MOVL	ES, xffreqh#		;Get request from the fork list
	MOVL	EAX, ES:xffReqNext#	;Remove from list
	MOVL	xffreqh#, EAX
	TESTL	EAX, EAX
	JNE	10$.S
	MOVL	xffreqt#, EAX
10$:	MOVL	ES:xffReqNext#, #-1
	CALLFI	ES:xffCallAddr#		;Do task switch to the extended fork
	POPL	EAX
	POPL	ES
	JMP	2$			;Go check for another one

12$:	RET

16$:	CRASH	NAFL
.PAGE
knlIntDoneHigh::
	MOVB	AL, #INT_EOI
	CLI
	OUTB	P_INC2P0
	JMP	1$.S

knlIntDoneLow::
	MOVB	AL, #INT_EOI
	CLI
1$:	OUTB	P_INC1P0

knlIntDoneDiff==!knlIntDoneLow-knlIntDoneHigh

	.SBTTL	knlDismissInt - Common interrupt dismiss routine

;Common routine to dismiss interrupt after checking for scheduler request
;  when get here, all registers must be on the stack and interrupts must
;  be disabled.

knlDismissInt2::
	MOVB	AL, #0Bh		;Going back to main program level?
	OUTB	P_INC1P0
	IOPAUSE
	INB	P_INC1P0
	ORB	AL, knlForkLvl#
	JNE	6$			;No
2$:	CMPL	forkreqh, #0.B		;Yes - have any fork requests now?
	JE	8$			;No
	MOVL	EDI, forkreqh		;Yes - get request
	MOVL	EAX, dcb_fnext.B[EDI]	;Remove from fork list
	MOVL	forkreqh, EAX
	TESTL	EAX, EAX
	JNE	4$.S
	MOVL	forkreqt, #0
4$:	MOVL	dcb_fnext.B[EDI], #-1
	MOVB	knlForkLvl#, #FORK_DFORK
	STI				;Interrupts are OK now

;Start of XFF timing code

	CALL	getdelta		;Get delta time
	MOVL	ES, knlCurPda#
	ADDL	ES:pdaRunTime#+0, EAX
	ADCL	ES:pdaRunTime#+4, EDX
	SUBL	ES:pdaRunQTime#, EAX

;End of XFF timing code

	CALLI	dcb_fdisp.B[EDI]	;Call fork routine
	CMPB	knlForkLvl#, #FORK_DFORK ;Still at device fork level?
	JNE	5$.S			;No!

;Start of XFF timing code

	CALL	getdelta		;Get delta time
	ADDL	knlForkTime#+0, EAX
	ADCL	knlForkTime#+4, EDX

;End of XFF timing code

	CLI
	MOVB	knlForkLvl#, #FORK_MAIN	;Yes - but not any more
	JMP	2$			;Go see if more fork requests

5$:	CRASH	NAFL

;Here if not returning to main program level - just dismiss the interrupt

6$:	POPL	GS
	POPL	FS
	POPL	ES
	POPL	DS
	POPAL
	IRET

;Here if no (more) device fork requests

8$:	CMPL	xffreqh#, #0.B		;Have any extended fork requests?
	JE	disms4.S		;No
	MOVB	knlForkLvl#, #FORK_XFF	;Yes
	STI				;Allow interrupts now
	MOVL	ES, xffreqh#		;Get request from the fork list
	MOVL	EAX, ES:xffReqNext#	;Remove from list
	MOVL	xffreqh#, EAX
	TESTL	EAX, EAX
	JNE	10$.S
	MOVL	xffreqt#, EAX
10$:	MOVL	ES:xffReqNext#, #-1

;Start of XFF timing code

	CALL	getdelta		;Get delta time
	ADDL	SS:pdaRunTime#+0, EAX
	ADCL	SS:pdaRunTime#+4, EDX
	SUBL	SS:pdaRunQTime#, EAX

;End of XFF timing code

	CALLFI	ES:xffCallAddr#		;Do task switch to the extended fork
	CLI
	MOVB	knlForkLvl#, #FORK_MAIN
	JMP	2$			;Go check for another device fork

;Here if no extended fork requests

disms4::CMPB	knlSchedReq#, #0	;Need to schedule now?
	POPL	GS			;Restore registers
	POPL	FS
	POPL	ES
	POPL	DS
	POPAL
	JE	14$.S			;If do not need to schedule
	CMPL	ESP, #pdaURegEIP#	;About to return to user mode?
	JNE	14$.S			;No - can't schedule now
	CALLF	schedule		;Yes - call the scheduler
14$:	PUSHF
	TESTB	1.B[ESP], #40h
	JNE	20$.S
	ADDL	ESP, #4.B
	IRET				;Dismiss interrupt

20$:	CRASH	NEST
.PAGE
	.SBTTL	getunqname - Subroutine to create unique file name

;Subroutine to create unique file name - the number is constructed from a 35
;  bit value.  The high order 10 bits are the low 10 bits of the system date.
;  the low order 25 bits are initialized to 1/2 the number of scheduler ticks
;  since midnite when the system was loaded.  This value is incremented by 1
;  each time it is used.  The first character of the name is always $. The next
;  seven character are generated by encoding this value as 7 base 32 digits
;  (using the digits 0-9 and the letters A-V).
;	c{ES:EDI} = Address of ASCIZ string giving device and path
;	CALL	getunqname
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ES:EDI} = Address of complete file specification

getunqname::
	PUSHL	EDI
	PUSHL	ES
	IFFAULT	10$
	CMPB	ES:[EDI], #0		;Was anything specified?
	JE	4$.S			;No
2$:	INCL	EDI
	IFFAULT	10$
	MOVB	AL, ES:[EDI]		;Get character
	TESTB	AL, AL			;End of string?
	JNE	2$.S			;No - continue
	CMPB	ES:-1.B[EDI], #'\'	;Was character back-slash?
	JE	4$.S
	CMPB	ES:-1.B[EDI], #'/'	;Or a slash?
	JE	4$.S
	MOVB	ES:[EDI], #'\'		;No - add a back-slash
	INCL	EDI
4$:	MOVB	AL, #'$'		;Construct unique file name
	IFFAULT	10$
	STOSB	[EDI]
	MOVL	EDX, fileseqnum#+4
	SHLL	EDX, #22t
	MOVL	ECX, #2t
	CALL	fndigits
	JC	8$.S
	INCL	fileseqnum#+0		;Bump file name sequence number
	MOVL	EDX, fileseqnum#+0
	SHLL	EDX, #7t
	MOVB	CL, #5t
	CALL	fndigits
	JC	8$.S
	IFFAULT	10$
	MOVB	ES:[EDI], #0
8$:	POPL	ES
	POPL	EDI
	RET

	FAULTHDR
10$:	MOVL	EAX, #ER_ADRER
	POPL	ES
	POPL	EDI
	STC
	RET

fndigits:
	ROLL	EDX, #5
	MOVB	AL, DL
	ANDB	AL, #1Fh
	CMPB	AL, #9
	JBE	12$.S
	ADDB	AL, #'A'-'0'-10t
12$:	ADDB	AL, #'0'
	IFFAULT	knlRtnAdrEr#
	STOSB	[EDI]
	LOOP	ECX, fndigits
	RET
.PAGE
	.SBTTL	knlSetName - Subroutine to setup name for search for DCB or SCB

;Subroutine to setup device or segment name for search for DCB for SCB
;	c{ES:EBX} = Address of ASCIZ name string
;	CALL	knlSetName
;	C:clr = Normal
;	  c{ES:EBX}      = Address of start of file specification which
;			     follows device name
;	  c{opn_devname} = Device name (8 bytes)
;	C:set = Error
;	  c{EAX} = Error code

knlSetName::
	MOVL	EDX, #'Z'		;Get default name
setnam2::				;Enter here with different default
					;  name in EDX
	PUSHL	EBX			;Save pointer to file name in case
					;   no device name is given
	LEAL	ESI, opn_devname.B[EBP]	;Point to start of name buffer
	CLRL	EAX
	MOVL	SS:[ESI], EAX		;Clear the device name buffer
	MOVL	SS:4.B[ESI], EAX
	MOVL	SS:8.B[ESI], EAX
	MOVL	SS:12t.B[ESI], EAX
	MOVL	ECX, #16t
	IFFAULT	20$
	CMPB	ES:[EBX], #'_'		;Is first character an underscore?
	JNE	2$.S			;No
	INCL	EBX			;Yes - skip the underscore
	MOVB	AH, #80h		;And get bit for later
2$:	IFFAULT	20$
	MOVB	AL, ES:[EBX]		;Get character
	INCL	EBX
	CMPB	AL, #':'		;Is it the terminator?
	JE	12$.S			;Yes
	TESTB	AL, AL			;No - end of string?
	JE	8$.S			;Yes
	CMPB	AL, #'/'		;No - directory terminator?
	JE	8$.S			;Yes
	CMPB	AL, #'\'
	JE	8$.S
	DECL	ECX			;No - room for more?
	JS	6$.S			;No
	CMPB	AL, #'a'		;Yes - is it lower case?
	JL	4$.S			;No
	SUBB	AL, #20h		;Yes - change to upper case
4$:	MOVB	SS:[ESI], AL		;Store in buffer
	INCL	ESI
	JMP	2$.S			;Continue

;Here if more than 16 characters in the name

6$:	IFFAULT	20$
	MOVB	AL, ES:[EBX]		;Get next character
	INCL	EBX
	CMPB	AL, #':'		;End of device name?
	JE	10$.S			;Yes
	CMPB	AL, #'/'		;Directory terminator?
	JE	8$.S			;Yes
	CMPB	AL, #'\'
	JE	8$.S
	TESTB	AL, AL			;No - end of name?
	JNE	6$.S			;No - continue
8$:	MOVL	opn_devname+0.B[EBP], EDX ;Store default device name (either
	CLRL	EAX			  ;  Z, NET, NDG, or null)
	MOVL	opn_devname+4.B[EBP], EAX
	MOVL	opn_devname+8.B[EBP], EAX
	MOVL	opn_devname+12t.B[EBP], EAX
	POPL	EBX
	RET

;Here with colon when have more than 16 characters in initial atom

10$:	CMPB	ES:[EBX], #':'		;Double colon?
	JE	14$.S			;Yes - this is OK
	POPL	EBX			;No - fail
	MOVL	EAX, #ER_BDSPC
	STC
	RET

;Here with device name terminator when have 16 or fewer characters in initial
;  atom

12$:	CMPB	ES:[EBX], #':'		;Double colon?
	JE	14$.S			;Yes
	POPL	ESI			;No - fix up the stack
	ORB	opn_devname+0.B[EBP], AH ;Set physical name bit if should
	RET				;Finished

;Here if have double colon - this is an implied network access - use NET: as
;  the default name

14$:	TESTL	EDX, EDX		;Want default name?
	JE	8$.S			;No
	MOVL	EDX, #'NET'		;Yes
	JMP	8$.S

;Here if address error

	FAULTHDR
20$:	POPL	EAX
	MOVL	EAX, #ER_ADRER
	STC
	RET
.PAGE
	.SBTTL	copyname - Subroutine to copy name to buffer

;Subroutine to copy name to buffer
;	c{ES:EBX} = Address of name string
;	c{SS:EDI} = Address of buffer
;	CALL	copyname
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

copyname::
	MOVL	ESI, EBX		;Get addresses in right registers
	PUSHL	ES
	POPL	FS
	PUSHL	SS
	POPL	ES
	CLD
	MOVL	ECX, #FILESPCSIZE-2
4$:	IFFAULT	knlRtnAdrEr#
	LODSB	FS:[ESI]		;Get character
	CMPB	AL, #'/'		;Slash?
	JNE	6$.S			;No
	MOVB	AL, #'\'		;Yes - change to back-slash
6$:	STOSB	[EDI]			;Store it in buffer
	TESTB	AL, AL
	JE	ret020.S		;If finished
	LOOP	ECX, 4$
	MOVL	EAX, #ER_BDSPC		;If file specification is too long
	STC
ret020:	RET				;Finished
.PAGE
	.SBTTL	knlNewClass - Subroutine to create new device class

;Subroutine to create new device class
;	c{EAX} = First 4 characters of class name
;	c{EDX} = Last 4 characters of class name
;	c{ECX} = Offset of class characteristics table
;	c{EBX} = Offset of class function dispatch table
;	c{EDI} = Offset of device check routine
;	c{ESI} = Offset of CCB
;	CALL	knlNewClass
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlNewClass::
	PUSHL	ECX
	PUSHL	EDI
	PUSHL	EBX
	PUSHL	EDX
	PUSHL	EAX
	PUSHL	ESI
	CALL	findclass2		;Search for duplicate class
	JC	2$.S
	MOVL	EAX, #ER_CLSAD		;If have duplicate class
	JMP	6$.S

;Here with error return from findclass2

2$:	CMPL	EAX, #ER_NSCLS.B	;Is the error "no such class"?
	JNE	6$.S			;No - fail
	POPL	ESI			;Restore offset of space for the CCB
	MOVL	EAX, knlFirstCcb#	;Link to head of CCB list
	MOVL	knlFirstCcb#, ESI
	MOVL	ccb_next.B[ESI], EAX
	POPL	ccb_name+0.B[ESI]	;Store class name
	POPL	ccb_name+4.B[ESI]
	POPL	ccb_fdsp.B[ESI]		;Store other offsets
	POPL	ccb_dchk.B[ESI]
	POPL	ccb_clschar.B[ESI]
	INCL	numccb#			;Increase number of CCBs in system
	RET

;Here if error

6$:	ADDL	ESP, #24t.B		;Fix up the stack
	STC				;Indicate error
	RET				;Return
.PAGE
	.SBTTL	knlRmvClass - Subroutine to remove device class

;Subroutine to remove device class - this routine simply removes the CCB
;  from its list - IT DOES NOT RECLAIM ANY MEMORY.  It is intended to be
;  mainly used by class drivers which encounter a fatal error during
;  initialization after a class has been installed.  It is also used to
;  remove the once-only devices after start-up is complete.
;	c{ESI} = Offset of CCB
;	CALL	knlRmvClass
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlRmvClass::
	MOVL	EAX, ccb_name.B[ESI]
	MOVL	EDX, #knlFirstCcb#
2$:	MOVL	EBX, [EDX]		;Search for this CCB
4$:	TESTL	EBX, EBX		;Is there another?
	JE	6$.S			;No - fail!
	CMPL	ccb_name.B[EBX], EAX	;Yes - this one?
	JE	8$.S			;Yes
	MOVL	EDX, EBX
	MOVL	EBX, [EBX]		;No - advance to next
	JMP	4$.S

;Here if can't find the requested CCB

6$:	MOVL	EAX, #ER_NSCLS
	STC
	RET

;Here with CCB

8$:	MOVL	EAX, [EBX]		;Unlink it
	MOVL	[EDX], EAX
	CLRL	EAX			;Clear this word to make debugging
	MOVL	[EBX], EAX		;  easier
	DECL	numccb#			;Reduce number of CCBs in system
	RET
.PAGE
	.SBTTL	findclass - Subroutine to find CCB for device class

;Subroutine to find CCB for device class given name of class - must be called
;  with an opn stack frame
;	c{ES:EBX} = Address of class name
;	CALL	findclass
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ESI} = Offset of CCB

findclass::
	CLRL	EDX
	CALL	setnam2			;Set up class name
	JC	10$.S			;If error
	MOVL	EAX, opn_devname+0.B[EBP]
	MOVL	EDX, opn_devname+4.B[EBP]
findclass2:
	MOVL	ESI, knlFirstCcb#	;Get pointer to first CCB
	TESTL	ESI, ESI
	JE	8$.S
4$:	CMPL	ccb_name+0.B[ESI], EAX	;Check name
	JNE	6$.S
	CMPL	ccb_name+4.B[ESI], EDX
	JE	10$.S			;If match on name
6$:	MOVL	ESI, [ESI]		;Advance to next CCB routine
	TESTL	ESI, ESI
	JNE	4$.S			;Continue if more to check
8$:	MOVL	EAX, #ER_NSCLS		;Error = No Such CLaSs
	STC
10$:	RET
.PAGE
	.SBTTL	knlFindDcb - Subroutine to find DCB given device name string

;Subroutine to find DCB given device name string
;	CALL	knlFindDcb
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = 0
;	C:clr = Normal
;	  c{EDI} = Offset of DCB

knlFindDcb::
	MOVL	EBX, opn_frame1.B[EBP]	;Get offset (on stack) of device name
	ADDL	EBX, #opn_devname.B
	ANDB	SS:[EBX], #7Fh
	CMPL	SS:[EBX], #'TRM'	;Is it TRM?
	JNE	4$.S			;No
	MOVW	ES, SS:xffPda#		;Yes
	MOVL	EDI, ES:pdaHndlTbl#	;Get DCB of console device
	MOVL	EDI, ES:DH_STDTRM*32t[EDI]
	TESTL	EDI, EDI		;Do we have one?
	JE	10$.S			;No - say no such device
	RET				;Yes - return it

;Here if device is not TRM

4$:	MOVL	ESI, numccb#		;Get number of CCBs in system
	INCL	ESI			;Plus 1
	SHLL	ESI, #2			;Times 4
	PUSHL	ESI			;Use as maximum number of times to loop
					;  (we need to have a limit since some
					;  device check routines change the
					;  device name and restart the search
					;  by resetting ESI - this could cause
					;  an infinite loop!)
	MOVL	ESI, knlFirstCcb#	;Get pointer to first CCB
6$:	CALLI	ccb_dchk.B[ESI]		;Call the device check routine
	JBE	12$.S			;If error (C set) or if found it (Z set)
	DECL	[ESP]			;Are we looping?
	JE	8$.S			;Yes - fail
	MOVL	ESI, [ESI]		;Advance to next CCB routine
	TESTL	ESI, ESI
	JNE	6$.S			;Continue if more to check
8$:	POPL	EAX			;Fix up the stack
10$:	MOVL	EAX, #ER_NSDEV		;Error = No Such Device
	JMP	14$.S

;Here with device or with error

12$:	POPL	ECX			;Fix up the stack
	JC	14$.S			;If error
	CMPL	dcb_opencnt.B[EDI], #0.B ;Is the device in use now?
	JE	18$.S			;No
	BTL	dcb_dsp.B[EDI], #DS%MLTUSER ;Yes - is it a multi-user device?
	JC	20$.S			;Yes - this is OK
	MOVW	ES, SS:xffPda#		;No
	BTL	ES:pdaActPriv#, #PP%SHAREDEV ;Can we share all devices?
	JC	20$.S			;Yes
	MOVW	AX, dcb_sesproc.B[EDI]	;No - is it in use by this process
	CMPW	ES:pdaSesProc#, AX	;  group?
	JE	20$.S			;Yes
	MOVL	EAX, #ER_DEVIU		;No - error = Device In Use
14$:	CLRL	ECX
	STC
	RET				;Return

;Here if device is not in use

18$:	MOVB	dcb_inpqlmt.B[EDI], #0	;Set input queue limit to default value
	MOVB	dcb_outqlmt.B[EDI], #0	;Set output queue limit to default value
20$:	BTL	dcb_dsp.B[EDI], #DS%SPOOL ;Is this a spooled device?
	JC	22$.S			;Yes
	BTSL	SS:xffCmd#, #O%NOREOPEN ;No - don't allow automatic re-open
	CLRL	ECX			;Clear C and set ECX = 0
	RET

;Here if have spooled device

22$:	MOVW	AX, SS:xffSpoolUnit#	;Set the spool unit number
	MOVW	dcb_sunit.B[EDI], AX
	CLRL	ECX
	RET
.PAGE
;Subroutine to store DCB offset in the handle table
;	c{EDI} = Offset of DCB
;	CALL	knlStoreHndl
;	C:set = Error (handle table unchanged, dcb_opencnt NOT incremented)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ES:EAX} = Address of device table entry
;  EAX, EDX, and ES are changed, other registers are preserved

knlStoreHndl::
	MOVL	EDX, #0FFFh		;Get expected previous contents of
knlStoreHnd2::				;  handle table
	MOVL	SS:xffDcb#, EDI		;Store DCB offset
	MOVW	ES, SS:xffPda#		;Store DCB offset in the handle table
	MOVZWL	EAX, SS:xffHandle#
	SHLL	EAX, #5
	ADDL	EAX, ES:pdaHndlTbl#
	CMPL	ES:[EAX], EDX		;Make sure table is right!
	JNE	10$.S
	MOVL	ES:[EAX], EDI		;OK
	INCL	dcb_opencnt.B[EDI]	;Bump the open count
	RET

;Here if the handle table does not contain the expected value

10$:	CMPL	ES:[EAX], #0FFEh	;Was an open aborted?
	JNE	14$.S			;No
	CMPL	EDI, #0FFFh		;Yes - is this possible?
	JNE	14$.S			;No!!
	ORB	SS:xffStatus1#, #XF1$ABORT ;Yes - indicate aborted so we will do
					   ;  the right thing at knlXfFinish
	MOVL	EAX, #ER_ABORT		;Indicate error
	STC
	RET

14$:	CRASH	BHTE			;[Bad Handle Table Entry]
.PAGE
	.SBTTL	knlPutHex3Nmbr - Subroutine to put ASCII hex number in memory

;Subroutine to put 4 digit ASCII hex number in memory
;	c{EAX} = Value
;	c{EBX} = Offset for first charater
;	CALL	knlPutHex4Nmbr
;	c{EBX} = Offset for character following number
;  All registers except EAX and EBX are preserved

knlPutHex4Nmbr::
	PUSHL	ECX
	MOVL	ECX, #4t
	SHLL	EAX, #16t
2$:	ROLL	EAX, #4t
	PUSHL	EAX
	ANDB	AL, #0Fh
	CMPB	AL, #10t
	JB	4$.S
	ADDB	AL, #'A'-'0'-10t
4$:	ADDB	AL, #'0'		;Make ASCII character
	MOVB	[EBX], AL		;Store it
	INCL	EBX
	POPL	EAX
	LOOP	ECX, 2$
	POPL	ECX
	RET
.PAGE
	.SBTTL	knlPutDecNmbr - Subroutine to put ASCII decimal number in memory

;Subroutine to put ASCII decimal number in memory
;	c{EAX} = Value
;	c{EBX} = Offset for first charater
;	CALL	knlPutDecNmbr
;	c{EBX} = Offset for character following number
;  All registers except EAX and EBX are preserved

knlPutDecNmbr::
	PUSHL	ECX
	MOVL	ECX, #10t
2$:	PUSHL	EDX
	CALL	putnm2
	POPL	EDX
	POPL	ECX
	RET

putnm2:	CLRL	EDX			;Get next digit
	DIVL	ECX
	PUSHL	EDX			;Save it
	TESTL	EAX, EAX		;More?
	JE	4$.S			;No
	CALL	putnm2			;Yes
4$:	POPL	EAX			;Get digit value
	CMPB	AL, #10t
	JB	6$.S
	ADDB	AL, #'A'-'0'-10t
6$:	ADDB	AL, #'0'		;Make ASCII character
	MOVB	[EBX], AL		;Store it
	INCL	EBX
ret026:	RET
.PAGE
	.SBTTL	doopen - Subroutine to do open and related functions

;Subroutine to do open - called by open, delete, and rename
;	c{ES:EBX} = Address of device/file specification
;	c{EDI}    = Offset of subroutine to call for each logical name
;		      definition
;	CALL	doopen
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = 0
;	C:clr = Normal
;	  c{EDI} = Offset of DCB for device
;	  c{ESI} = Offset of device table entry

doopen::MOVL	opn_opendisp.B[EBP], EDI ;Save address of routine for each
					 ;  logical name definition
	CALL	dosnameck#		;Check for special DOS names
	JC	ret026.S		;If error
	JNE	1$.S			;If not a special DOS name
	MOVL	opn_devname+0.B[EBP], EAX ;Special name - store device name
	MOVL	opn_devname+4.B[EBP], EBX
	CLRL	EAX
	MOVL	opn_devname+8.B[EBP], EAX
	MOVL	opn_devname+12t.B[EBP], EAX
	MOVB	opn_namebfr[EBP], AL	;Indicate no file name part
	JMP	2$.S			;Continue

;Here if not special DOS name

1$:	CALL	knlSetName		;Setup device name part
	JC	ret026.S
2$:	CLRL	EAX
	MOVL	SS:xffRtdName#+0, EAX
	MOVL	SS:xffRtdName#+4, EAX
	MOVL	SS:xffRtdName#+8, EAX
	MOVL	SS:xffRtdName#+12t, EAX
	LEAL	EDI, opn_namebfr[EBP]
	CALL	copyname		;Copy file name part to buffer
	JC	ret026.S
	BTL	SS:xffHvValue1#, #IOV1%DIRHNDL ;Want to search open directory?
	JC	4$.S			;Yes
doopen2::				;No
	LEAL	EDX, opn_namebfr[EBP]	;Point to buffer
	MOVL	FS, SS:xffPda#		;Get PDA selector for session process
	MOVZWL	EAX, FS:pdaSesProc#
	MOVW	FS, knlProcTable#[EAX*2]
	LEAL	EBX, opn_devname.B[EBP]	;Get offset of name
	MOVL	ESI, #doopn2		;Get address of routine to finish this
	MOVL	ECX, SS:xffCmd#
	JMP	knlLogNameExpand#	;Expand logical name and do rest of this

;Here if want to search open directory

4$:	MOVL	EAX, opn_dirhndl.B[EBP]	;Get directory handle
	CALL	knlXfGetDcb		;Get the directory DCB
	JC	12$			;If error
	MOVL	SS:xffDcb#, EDI
	BTL	dcb_dsp.B[EDI], #DS%FILE ;Is this a file structured device?
	JNC	8$.S			;No
	TESTB	dcb_sts2.B[EDI], #D2$DIRECT ;Yes - is it a directory?
	JE	10$.S			;No - fail
	CMPW	dcb_outframe.B[EDI], #0.B ;Yes - is it busy?
	JNE	6$.S			;Yes - fail
	MOVW	dcb_outframe.B[EDI], SS	;No - link to our stack frame
	MOVB	SS:xffQueue#, #dcb_outframe
	CALL	knlStoreHndl		;Store DCB offset in the handle table
	JC	14$.S			;If error (open was aborted)
	MOVL	ES:4.B[EAX], #O$OPNCLS	;Indicate device being opened
	MOVL	ECX, opn_dirhndl.B[EBP]	;Get directory handle
	SHLL	ECX, #5t
	ADDL	ECX, ES:pdaHndlTbl#	;Point to its table entry
	MOVL	EDX, ES:16t[ECX]		;Copy rooted name
	MOVL	ES:16t.B[EAX], EDX
	MOVL	EDX, ES:20t[ECX]
	MOVL	ES:20t.B[EAX], EDX
	MOVL	EDX, ES:24t[ECX]
	MOVL	ES:24t.B[EAX], EDX
	MOVL	EDX, ES:28t[ECX]
	MOVL	ES:28t.B[EAX], EDX
	CALL	doopn8			;Do the rest of this
	JC	12$.S			;If error
	LEAL	EDX, opn_namebfr[EBP]	;OK - point to file specification
	JMPIL	opn_opendisp.B[EBP]	;Go to routine for this definition

;Here if directory device is busy

6$:	MOVL	EAX, #ER_BUSY
	JMP	12$.S

;Here if directory device is not a file structured device

8$:	MOVL	EAX, #ER_NTFIL
	JMP	12$.S

;Here if do not have directory open on directory device

10$:	MOVL	EAX, #ER_NTDIR
12$:	CLRL	ECX
	STC
ret030:	RET

;Here if open has been aborted before we got here

14$:	MOVL	EAX, #ER_ABORT
	JMP	12$.S
.PAGE
;Subroutine called from knlLogNameExpand for each device definition
;	c{SS:EBX} = Address of physical device name
;	c{SS:EDX} = Address of extended file path and name
;	CALL	doopn2
;	C:set = Error
;	  c{EAX} = Error
;	C:clr = Normal
;	  c{EDI} = Offset of DCB

doopn2:	MOVL	ECX, opn_frame1.B[EBP]
	MOVL	EAX, SS:[EBX]		;Store physical device name
	MOVL	SS:opn_devname+0.B[ECX], EAX
	MOVL	EAX, SS:4.B[EBX]
	MOVL	SS:opn_devname+4.B[ECX], EAX
	MOVL	EAX, SS:8.B[EBX]
	MOVL	SS:opn_devname+8.B[ECX], EAX
	MOVL	EAX, SS:12t.B[EBX]
	MOVL	SS:opn_devname+12t.B[ECX], EAX
	PUSHL	EDX
	CALL	doopn4			;Do the rest of this
	POPL	EDX
	JC	ret030.S		;If error, return to knlLogNameExpand
	MOVL	ECX, opn_frame1.B[EBP]
	JMPIL	SS:opn_opendisp.B[ECX]	;Otherwise do caller's subroutine

doopn4::CALL	knlFindDcb		;Find a DCB
	JC	8$			;If error
	CALL	knlStoreHndl		;Store DCB offset in the handle table
	JC	doopn10			;If error (aborted open)
	MOVL	ES:4.B[EAX], #O$OPNCLS	;Indicate device being opened
	MOVL	EDX, SS:xffRtdName#+0t	;Copy rooted name to the device table
	MOVL	ES:16t.B[EAX], EDX
	MOVL	EDX, SS:xffRtdName#+4t
	MOVL	ES:20t.B[EAX], EDX
	MOVL	EDX, SS:xffRtdName#+8t
	MOVL	ES:24t.B[EAX], EDX
	MOVL	EDX, SS:xffRtdName#+12t
	MOVL	ES:28t.B[EAX], EDX
	MOVL	EAX, dcb_sdisp.B[EDI]	;Mount the drive
	CALLI	CS:sd_mount.B[EAX]
	JC	12$.S			;If error
	CMPL	dcb_opencnt.B[EDI], #1.B ;Yes - first open?
	JNE	doopn8.S		;No
	MOVL	ES, SS:xffPda#		;Yes
	MOVW	AX, ES:pdaSesProc#	;Store number of group process in
	MOVW	dcb_sesproc.B[EDI], AX	;  the DCB
	MOVB	dcb_sts2.B[EDI], #0	;Clear device dependent bits
	MOVB	dcb_sts1.B[EDI], #0	;And clear the common device status bits
doopn8:	MOVL	EAX, SS:xffPCFilSpc#	;Save start of place to put file
	MOVL	SS:xffPXFilSpc#, EAX	;  specification for user if error
	TESTL	SS:xffPVFilOpt#, #FO$PHYNAME|FO$XOSNAME|FO$VOLNAME|FO$DOSNAME
					;Does he want the device name?
	JE	10$.S			;No
	TESTB	SS:xffHvValue1#+3, #IOV1$DIRHNDL>24t
					;Yes - searching open directory?
	JNE	10$.S			;Yes - no name
	JMP	knlGivUDevName		;No - give the name to him

;Here if open has been aborted before we got here

doopn10::
	CMPL	dcb_opencnt.B[EDI], #0.B ;Anyone else using the device?
	JNE	6$.S			;Yes
	MOVW	dcb_sesproc.B[EDI], #0	;No - its free now
	CALL	knlClearDcb#		;Give up the DCB
6$:	MOVL	EAX, #ER_ABORT
8$:	CLRL	ECX
	STC
10$:	RET

;Here if error after DCB offset stored in the handle table

12$:	MOVL	ESI, #0FFFh		;Give up the DCB but keep the handle
	CALL	knlXfClose8#
	CMPL	EAX, #ER_MDCHG
	JNE	8$.S
	JMP	doopn4
.PAGE
	.SBTTL	knlIopGlbId - Common routine to process IOPAR_GDID parameter

;Common routine to process IOPAR_GLBID parameter for all non-disk, non-network
;  devices - tHe global device is formatted as follows: (low order bytes first)
;	Size     Use
;	  4	File ID (position of file on disk) (0 if not disk)
;	  4	Device ID (offset of UCB or DCB)
;	  4     Node ID (network address) (0 for local device)
;	  4	Network ID (0 for local device)
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopGlbId

	DPARMHDR  GET, DECV
knlIopGlbId::
	CMPL	ECX, #16t		;Is his value large enough?
	JB	knlBadParmS.S		;No - fail
	CLRL	EAX
	IFFAULT	knlRtnAdrEr#
	MOVL	ES:[EBX], EAX
	IFFAULT	knlRtnAdrEr#
	MOVL	ES:12t.B[EBX], EAX
	MOVL	ES:4.B[EBX], EDI	;Store offset of the DCB
	MOVL	ES:8.B[EBX], EAX
	RET

knlBadParmS::
	MOVL	EAX, #ER_PARMS
	STC
	RET
.PAGE
	.SBTTL	knlIopDelay - Common routine to process IOPAR_DELAY parameter

;Common routine to process IOPAR_DELAY parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopDelay

	DPARMHDR  SET, HEXV
knlIopDelay::
	CALL	knlGetParm#		;Get his value
	JC	4$.S			;If error
	MOVL	SS:xffDelay#, EAX	;Store it
	RET

	.SBTTL	knlIopTimeOut - Common routine to process IOPAR_TIMEOUT parameter

;Common routine to process IOPAR_TIMEOUT parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopTimeOut

	DPARMHDR  SET, HEXV
knlIopTimeOut::
	CALL	knlGetParm#		;Get his value
	JC	4$.S			;If error
	MOVL	SS:xffTimeOut#, EAX	;Store it
4$:	RET
.PAGE
	.SBTTL	knlIopDevSts - Common routine to process IOPAR_DEVSTS parameter

;Common routine to process IOPAR_DEVSTS parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopDevSts

	DPARMHDR  GET, HEXV
knlIopDevSts::
	MOVL	EAX, dcb_dsp.B[EDI]	;Get value
	CMPL	ECX, #4.B
	JAE	4$.S
	ANDL	EAX, CS:valmask[ECX*4]
4$:	JMP	knlStrParm4#		;Give it to the user

	.MOD	4
valmask:.LONG	0
	.LONG	0FFh
	.LONG	0FFFFh
	.LONG	0FFFFFFh
.PAGE
	.SBTTL	knlIopUnitNum - Common routine to process IOPAR_UNITNUM parameter

;Common routine to process IOPAR_UNITNUM parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopUnitNum

	DPARMHDR  GET, HEXV
knlIopUnitNum::
	MOVZWL	EAX, dcb_sunit.B[EDI]	;Get secondary unit number
	SHLL	EAX, #16t
	MOVB	AL, dcb_punit.B[EDI]	;Get primary unit number
	JMP	knlStrParm4#
.PAGE
	.SBTTL	knlIopNumOpen - Common routine to process IOPAR_NUMOPEN parameter

;Common routine to process IOPAR_NUMOPEN parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopNumOpen

	DPARMHDR  GET, DECV
knlIopNumOpen::
	MOVL	EAX, dcb_opencnt.B[EDI]
	JMP	knlStrParm4#
.PAGE
	.SBTTL	knlIopIoSts - Common routine to process IOPAR_INPSTS and IOPAR_OUTSTS parameters

;Common routine to process IOPAR_INPSTS and IOPAR_OUTSTS parameters for devices
;  which are always considered ready for IO

knlIopIoSts::
	CLRL	EAX
	INCL	EAX
	JMP	knlStrParm4#
.PAGE
	.SBTTL	knlIopInpQLmt - Common routine to process IOPAR_INPQLMT parameter

;Common routine to process IOPAR_INPQLMT parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopInpQLmt

	DPARMHDR  BOTH, DECV
knlIopInpQLmt::
	BTL	dcb_dsp.B[EDI], #DS%DUPLEX ;Full duplex device?
	JNC	knlBadParmI#		;No - fail
	TESTB	AH, #PAR$SET		;Yes - want to set value?
	JE	4$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm#		;Get his value
	JC	6$.S			;If error
	MOVB	dcb_inpqlmt.B[EDI], AL	;Store new value
	POPL	EAX
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No - finished here
	MOVZBL	EAX, dcb_inpqlmt.B[EDI]	;Yes - get value
	JMP	knlStrParm4#

6$:	POPL	ECX
8$:	RET

	.SBTTL	knlIopOutQLmt - Common routine to process IOPAR_OUTQLMT parameter

;Common routine to process IOPAR_OUTQLMT parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopOutQLmt

	DPARMHDR  BOTH, DECV
knlIopOutQLmt::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	10$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm#		;Get his value
	JC	6$.S			;If error
	MOVB	dcb_outqlmt.B[EDI], AL	;Store new value
	POPL	EAX
10$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No - finished here
	MOVZBL	EAX, dcb_outqlmt.B[EDI]	;Yes - get value
	JMP	knlStrParm4#

	.SBTTL	knlIopBufrLmt - Common routine to process IOPAR_BUFRLMT parameter

;Common routine to process IOPAR_BUFRLMT parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopBufrLmt

	DPARMHDR  BOTH, DECV
knlIopBufrLmt::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	12$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm#		;Get his value
	JC	6$.S			;If error
	MOVB	dcb_bufrlmt.B[EDI], AL	;Store new value
	POPL	EAX
12$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	8$.S			;No - finished here
	MOVZBL	EAX, dcb_bufrlmt.B[EDI]	;Yes - get value
	JMP	knlStrParm4#
.PAGE
	.SBTTL	knlIopFilOptn - Common routine to process IOPAR_FILOPTN parameter

;Common routine to process IOPAR_FILOPTN parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopFilOptn

	DPARMHDR  SET, HEXV
knlIopFilOptn::
	CALL	knlGetParm#		;Get value of parameter
	JC	4$.S			;If error
	MOVL	SS:xffPVFilOpt#, EAX ;Store value
4$:	RET
.PAGE
	.SBTTL	knlIopFilSpec - Common routine to process IOPAR_FILSPEC parameter

;Common routine to process IOPAR_FILSPEC parameter for all devices for open
;  type operations - in this case this parameter specifies a buffer which
;  get a file specfication string as specified by the value set for the
;  IOPAR_FILOPTN parameter
;	c{ES:EBX} = Address of buffer for string
;	c{ECX}    = Length of the buffer
;	c{FS:EDX} = Address of word to receive length of string
;	CALL	knlIopFilSpec

	DPARMHDR  GET, STR
knlIopFilSpec::
	MOVL	SS:xffPPFilSpc#+0, EBX ;Store address of buffer
	MOVL	SS:xffPPFilSpc#+4, ES
	MOVL	SS:xffPLFilSpc#+0, EDX ;Store address of count word
	MOVL	SS:xffPLFilSpc#+4, FS
	MOVL	SS:xffPSFilSpc#, ECX	;Store length of buffer
	CALL	knlXfBufrChk#		;Make sure buffer is still writable (we
	JC	2$.S			;  must do this here even though the
					;  string buffer has already been locked
					;  by ioparmlock because the user may
					;  have changed the pointer since we
					;  locked the buffer to point to a
					;  different place, which may not be
					;  writable! - this area may not be
					;  locked, which will produce erratic
					;  results for the user, but will not
					;  harm the system)
	CLRL	EAX			;Clear the count value
	MOVL	SS:xffPCFilSpc#, EAX
2$:	RET
.PAGE
	.SBTTL	knlIoxFilOptn - Common routine to process IOPAR_FILOPTN parameter

;Common routine to process IOPAR_FILOPTN parameter for data transfer all
;  non-queued devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	knlIopFilOptn

	DPARMHDR  SET, HEXV
knlIoxFilOptn::
	CALL	knlGetParm#		;Get value of parameter
	JC	4$.S			;If error
	CMPB	knlForkLvl#, #FORK_XFF	;In extended fork context?
	JAE	2$.S			;Yes
	MOVL	pvfilopt#, EAX		;No - store value
	CLC
	RET

2$:	MOVL	SS:xffPVFilOpt#, EAX	;Store value
	CLC
4$:	RET
.PAGE
	.SBTTL	knlIoxFilSpec - Common routine to process IOPAR_FILSPEC parameter

;Common routine to process IOPAR_FILSPEC parameter for data transfer type
;  operations - in this case this parameter specifies a buffer which always
;  receives the device name only - only the bits FO$PHYNAME, FO$XOSNAME,
;  FO$DOSNAME, and FO$VOLNAME are used in the value of the IOPAR_FILOPTN
;  parameter
;	c{ES:EBX} = Address of buffer for string
;	c{ECX}    = Length of the buffer
;	c{FS:EDX} = Address of word to receive length of string
;	CALL	knlIoxFilSpec

	DPARMHDR  GET, STR
knlIoxFilSpec::
	PUSHL	EBX
	PUSHL	EDX
	CMPB	knlForkLvl#, #FORK_XFF	;In extended fork context?
	JAE	1$.S			;Yes
	PUSHL	pvfilopt#		;No
	MOVL	ESI, handle#		;Get handle
	PUSHL	SS			;Get PDA selector in right register
	POPL	GS
	JMP	2$.S			;Continue with common code

;Here if in extended fork context

1$:	PUSHL	SS:xffPVFilOpt#		;Get the file specification bits
	MOVZWL	ESI, SS:xffHandle#	;Get handle
	MOVW	GS, SS:xffPda#		;Get selector for PDA
2$:	CMPL	ECX, #12t.B		;Is buffer bigger than we need?
	JB	4$.S			;No
	MOVB	CL, #12t		;Yes
4$:	SUBB	CL, #3t			;Is the buffer big enough?
	JLE	24$			;No
	BTL	[ESP], #FO%XOSNAME	;Want XOS name?
	JC	10$.S			;Yes
	BTL	dcb_dsp.B[EDI], #DS%LCLDISK ;No - is this a disk?
	JNC	10$.S			;No - only have an XOS name
	MOVL	EDX, [EDI]		;Yes - point to UCB
	TESTL	EDX, EDX
	JE	10$.S			;Just to be safe!
	BTL	[ESP], #FO%VOLNAME	;Want volume name?
	JNC	8$.S			;No
	LEAL	ESI, ucb_volname.B[EDX]
	MOVB	AL, #FS_VOLNAME		;Get prefix byte
	CMPB	[ESI], #0		;Yes - do we have a volume name?
	JNE	12$.S			;Yes
8$:	BTL	[ESP], #FO%DOSNAME	;Want DOS name?
	JNC	10$.S			;No
	LEAL	ESI, ucb_dosname.B[EDX]	;Yes
	MOVB	AL, #FS_DOSNAME		;Get prefix byte
	CMPB	[ESI], #0		;Do we have a DOS name?
	JNE	12$.S			;Yes
10$:	LEAL	ESI, dcb_name.B[EDI]
	MOVB	AL, #FS_XOSNAME		;Get prefix byte
12$:	PUSHL	DS
14$:	POPL	GS
	BTL	[ESP], #FO%NOPREFIX	;Want prefix character?
	JC	16$.S			;No
	IFFAULT	22$
	MOVB	ES:[EBX], AL		;Yes - store device name prefix
	INCL	EBX
16$:	MOVB	CH, #16t
18$:	LODSB	GS:[ESI]		;Get device name character
	CMPB	AL, #0			;End of name?
	JE	20$.S			;Yes
	DECB	CL			;No - room for another character?
	JE	24$.S			;No
	IFFAULT	22$
	MOVB	ES:[EBX], AL		;Yes - store character
	INCL	EBX
	DECB	CH
	JNE	18$.S
	IFFAULT	22$
20$:	MOVW	ES:[EBX], #':'		;End it with a colon and a null
	POPL	EAX			;Get rid of options
	POPL	EDX			;Get Address for returned length
	POPL	EAX			;Original Address
	SUBL	EBX, EAX		;Calculate length of string stored
	INCL	EBX
	IFFAULT	knlRtnAdrEr#
	MOVW	FS:[EDX], BX		;Store length
	RET				;Finished

	FAULTHDR
22$:	MOVL	EAX, #ER_ADRER
	JMP	26$.S

24$:	MOVL	EAX, #ER_PARMS
26$:	POPL	EBX			;Get rid of options
	POPL	EDX			;Restore address for returned length
	POPL	EBX			;Restore address for string
	STC
	RET
.PAGE
;Subroutine to give device name to user
;	CALL	knlGivUDevName
;	C:set = Error
;	  c{EAX} = Error code
;	C:clrl = Nornal

knlGivUDevName::
	BTL	SS:xffPVFilOpt#, #FO%XOSNAME ;Does he want the XOS name?
	JC	6$.S			;Yes
	LEAL	ESI, dcb_name.B[EDI]	;Point to device name
	BTL	dcb_dsp.B[EDI], #DS%LCLDISK ;Is this a disk?
	JNC	6$.S			;No
	MOVL	ECX, [EDI]		;Yes - point to UCB
	JREGZ	ECX, 8$			;Just to be safe!
	BTL	SS:xffPVFilOpt#, #FO%DOSNAME ;Want DOS name?
	JNC	4$.S			;No
	LEAL	ESI, ucb_dosname.B[ECX]	;Yes
	MOVB	AL, #FS_DOSNAME
	CMPB	[ESI], #0		;Do we have a disk DOS name?
	JNE	8$.S			;Yes
4$:	BTL	SS:xffPVFilOpt#, #FO%VOLNAME ;Want volume name?
	JNC	6$.S			;No
	LEAL	ESI, ucb_volname.B[ECX]	;Yes
	MOVB	AL, #FS_VOLNAME
	CMPB	ucb_volname.B[ECX], #0	;Do we have a disk volume name?
	JNE	8$.S			;Yes
6$:	LEAL	ESI, dcb_name.B[EDI]
	MOVB	AL, #FS_XOSNAME		;Get prefix byte
8$:	PUSHL	DS
10$:	POPL	FS
	BTL	SS:xffPVFilOpt#, #FO%NOPREFIX ;Want prefix characters?
	JC	12$.S			;No
	CALL	knlGivUChr		;Yes - give him the prefix byte
12$:	MOVL	ECX, #16t		;Copy name to user
14$:	LODSB	FS:[ESI]		;Get character
	CMPB	AL, #0			;End of name?
	JE	knlGivUColon.S		;Yes
	CALL	knlGivUChr
	LOOP	ECX, 14$
knlGivUColon::
	MOVB	AL, #':'		;Put colon after the name
					;Fall into givuchr on next page
.PAGE
	.SBTTL	knlGivUChr - Subroutine to give name character to user

;Subroutine to give name character to user - NOTE: this subroutine does NOT
;  indicate errors - address errors are ignored, full buffer errors cause the
;  last character in the buffer to be replaced with FS_TRUNC but are otherwise
;  ignored!
;	c(AL) = Character
;	CALL	knlGivUChr
;	C:clr = Always
;  All registers are preserved

knlGivUChr::
	PUSHL	EDI
	PUSHL	ES
	PUSHL	ECX
	IFFAULT	2$
	LESL	EDI, SS:xffPPFilSpc#	;Get address of buffer
	MOVL	ECX, SS:xffPCFilSpc#	;Room for more?
	CMPL	ECX, SS:xffPSFilSpc#
	JAE	4$.S			;No
	INCL	SS:xffPCFilSpc#		;Yes
	IFFAULT	2$
	MOVB	ES:[EDI+ECX], AL	;Store character
	FAULTHDR
2$:	CLC
	POPL	ECX
	POPL	ES
	POPL	EDI
	RET

;Here if no more room in the user's buffer

4$:	IFFAULT	2$
	MOVB	ES:-1.B[EDI+ECX], #FS_TRUNC ;Replace last character with special
	JMP	2$.S			    ;  code which indicates truncation

	.SBTTL	knlGivUNum - Subroutine to store decimal value in file specification

;Subroutine to store decimal value in file specification
;	c{EAX} = Value
;	CALL	knlGivUNum
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlGivUNum::
	CLRL	EDX
	DIVL	knlLit10#
	PUSHL	EDX
	TESTL	EAX, EAX
	JE	6$.S
	CALL	knlGivUNum
6$:	POPL	EAX
	ADDB	AL, #'0'
	JMP	knlGivUChr.S
.PAGE
	.SBTTL	knlGivUErr - Subroutine to check for returned name fixup on error

;Subroutine to check for returned name fixup on error
;	CALL	knlGivUErr
;All registers are preserved

knlGivUErr::
	CMPL	EAX, #ER_FILEX.B	;Is the error "file exists"?
	JE	knlGivUFin.S		;Yes
	CMPL	EAX, #ER_FILAD.B	;No - is it "file access denied"?
	JE	knlGivUFin.S		;Yes
	CMPL	EAX, #ER_BUSY.B		;No - is it "file busy"?
	JE	knlGivUFin.S		;Yes
	CMPL	EAX, #ER_FBFER.B	;No - is it "FIB format error"?
	JE	knlGivUFin.S		;Yes
	CMPL	EAX, #ER_FBRER.B	;No - is it "FIB read error"?
	JE	knlGivUFin.S		;Yes
	CMPL	EAX, #ER_FBWER.B	;No - is it "FIB write error"?
	JE	knlGivUFin.S		;Yes
	PUSHL	EAX			;No
	MOVL	EAX, SS:xffPXFilSpc#	;Remove last name given him
	MOVL	SS:xffPCFilSpc#, EAX
	POPL	EAX			;Fall into givufin

	.SBTTL	knlGivUFin - Subroutine to finish up giving user device/file spec

;Subroutine to finish up giving the user the device/file specification
;	CALL	knlGivUFin
;  All registers are preserved

SPEC$=!FO$PHYNAME|FO$XOSNAME|FO$DOSNAME|FO$VOLNAME|FO$NODENAME|FO$NODENUM
SPEC$=!SPEC$|FO$RPHYNAME|FO$XOSNAME|FO$RDOSNAME|FO$RVOLNAME
SPEC$=!SPEC$|FO$PATHNAME|FO$PATHDOS|FO$FILENAME|FO$FILEDOS|FO$ATTR
SPEC$=!SPEC$|FO$VERSION

knlGivUFin::
	TESTL	SS:xffPVFilOpt#, #SPEC$ ;Does he want a file spec returned?
	JE	8$.S			;No - nothing to do here
	PUSHL	EDI
	PUSHL	ES			;Save registers we need
	PUSHL	EAX
	IFFAULT	4$
	LESL	EDI, SS:xffPLFilSpc#	;Point to the size word
	MOVL	EAX, SS:xffPCFilSpc#	;Give him the length of the string
	IFFAULT	4$
	MOVW	ES:[EDI], AX
	CMPL	EAX, SS:xffPSFilSpc#	;Did we fill his buffer?
	JAE	4$.S			;Yes
	IFFAULT	4$
	LESL	EDI, SS:xffPPFilSpc#	;No - point to name string
	IFFAULT	4$
2$:	MOVB	ES:[EDI+EAX], #0	;Put null at end
	FAULTHDR
4$:	CLC
	POPL	EAX
	POPL	ES
	POPL	EDI
8$:	RET
.PAGE
	.SBTTL	knlGiveDymDcb - Subroutine to give up a dynamic DCB

;Subroutine to give up a dynamic DCB
;	c{ECX} = Size index for DCB
;	c{EDI} = Offset of DCB
;	CALL	knlGiveDymDcb
;	C:clr always
;	c{EDI} = 0

knlGiveDymDcb::
	CALL	knlUnlinkDcb		;Unlink the DCB
	PUSHL	ESI
	MOVZWL	EAX, dcb_id.B[EDI]	;Get the DCB ID index
	PUSHL	EAX
	LEAL	ESI, -dcb_cSIZE.B[EDI]	;Get offset of buffer
	CALL	knlGiveXmb#		;Give it up
	CLRL	EDI			;Clear DCB pointer so will fail if we
	POPL	EAX			;  try it use it after its given up!
	POPL	ESI
knlGiveDcbId::
	SHLL	EAX, #2
	ADDL	EAX, #dcbtable
	MOVL	EDX, dcbtblfree		;Put the ID table entry on the free list
	BTSL	EDX, #31t
	MOVL	dcbtblfree, EAX
	MOVL	[EAX], EDX
	RET
.PAGE
	.SBTTL	knlGetDymDcb - Subroutine to allocate a dynamic DCB

;Subroutine to allocate a dynamic DCB
;	c{SS:EBX} = Address of device name (16 bytes)
;	c{EDI}    = Value for dcb_dsp
;	c{ECX}    = Size index for DCB
;	CALL	knlGetDymDcb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDI} = Offset for DCB
;  DCB allocated is cleared

knlGetDymDcb::
	PUSHL	ESI			;Respect ESI here
	MOVL	EDX, ECX
	CALL	knlGetXmb#		;Get an exec memory buffer
	JC	4$.S			;If error
	PUSHL	ECX
	PUSHL	EDI			;Save value for dcb_dsp
	MOVL	EDI, ESI		;Set up to clear the DCB
	PUSHL	DS
	POPL	ES
	MOVL	ECX, clrtbl[ECX*4]	;Get number of longs to clear
	CLD
	CLRL	EAX			;Clear the DCB
	RSTOSL	[EDI]
	LEAL	EDI, dcb_cSIZE.B[ESI]	;Point to "start" of the DCB
	MOVL	EAX, SS:[EBX]		;Store device name
	MOVL	dcb_name+0.B[EDI], EAX
	MOVL	EAX, SS:4.B[EBX]
	MOVL	dcb_name+4.B[EDI], EAX
	MOVL	EAX, SS:8.B[EBX]
	MOVL	dcb_name+8.B[EDI], EAX
	MOVL	EAX, SS:12t.B[EBX]
	MOVL	dcb_name+12t.B[EDI], EAX
	POPL	dcb_dsp.B[EDI]		;Store device description bits
	DECL	dcb_fnext.B[EDI]	;Indicate not in fork queue
	MOVL	dcb_magic.B[EDI], #'DCB*'
	CALL	knlGetDcbId		;Get the DCB ID
	POPL	ECX
	JC	6$.S			;If error (very unlikely!)
4$:	POPL	ESI
	RET

;Here if error getting the DCB ID

6$:	LEAL	ESI, -dcb_cSIZE.B[EDI]	;Give up the buffer
	CALL	knlGiveXmb#
	STC
	POPL	ESI
	RET

	DATA

	.MOD	4
clrtbl:	.LONG	64t/4
	.LONG	128t/4
	.LONG	256t/4
	.LONG	512t/4
	.LONG	1024t/4
	.LONG	2048t/4
	.LONG	4096t/4

	CODE
.PAGE
	.SBTTL	knlLinkDcb - Subroutine to link DCB to a class

;Subroutine to link DCB to a class
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of CCB
;	CALL	knlLinkDcb

knlLinkDcb::
	PUSHL	EBX
	LEAL	ECX, ccb_dcbhead.B[ESI]
	PUSHL	ECX
	MOVB	AL, dcb_punit.B[EDI]
	MOVZWL	EDX, dcb_sunit.B[EDI]
	CMPL	EDX, #0FFFFh		;Want to assign secondary unit number?
	JE	6$.S			;Yes
2$:	MOVL	EBX, [ECX]		;No - scan the list and find the
	TESTL	EBX, EBX		;  position for this one
	JE	30$.S
	CMPB	AL, dcb_punit.B[EBX]
	JB	30$.S
	JA	4$.S
	CMPW	DX, dcb_sunit.B[EBX]
	JB	30$.S
4$:	LEAL	ECX, dcb_next.B[EBX]
	JMP	2$.S

;Here to assign a secondary unit number

6$:	MOVL	EDX, #1
8$:	MOVL	EBX, [ECX]		;First, scan past any unnumbered
	TESTL	EBX, EBX		;  units
	JE	28$.S
	CMPB	AL, dcb_punit.B[EBX]	;Same primary unit?
	JB	28$.S			;No - don't have any for this unit
	JA	10$.S			;No - not there yet
	CMPW	dcb_sunit.B[EBX], #0.B	;Yes - unnumbered unit?
	JNE	14$.S			;No
10$:	LEAL	ECX, dcb_next.B[EBX]	;Unnumbered or lower primary - continue
	JMP	8$.S

12$:	MOVL	EBX, [ECX]
	TESTL	EBX, EBX
	JE	28$.S
	CMPB	AL, dcb_punit.B[EBX]
	JB	28$.S
	JA	20$.S
14$:	CMPW	DX, dcb_sunit.B[EBX]
	JE	16$.S
	DECL	EDX
	CMPW	DX, dcb_sunit.B[EBX]
	JNE	26$.S
16$:	INCL	EDX
	LEAL	ECX, dcb_next.B[EBX]
	JMP	12$.S

20$:	CRASH	BDVL

;Here with an available secondary unit number

26$:	INCL	EDX
28$:	MOVW	dcb_sunit.B[EDI], DX

;Here with position in the list for this DCB

30$:	POPL	EAX
	MOVL	[ECX], EDI		;Link previous DCB to this DCB
	MOVL	dcb_next.B[EDI], EBX
	CMPL	ECX, EAX		;Is this the first one?
	JNE	32$.S			;No
	CLRL	ECX			;Yes - no previous DCB
	JMP	34$.S

32$:	SUBL	ECX, #dcb_next.B	;Point to previous DCB
34$:	MOVL	dcb_prev.B[EDI], ECX	;Link this DCB to the previous one
	TESTL	EBX, EBX		;Is this the last DCB?
	JE	36$.S			;Yes
	MOVL	dcb_prev.B[EBX], EDI	;No - link to next
	JMP	38$.S

36$:	MOVL	ccb_dcbtail.B[ESI], EDI	;Update tail pointer
38$:	MOVL	dcb_ccb.B[EDI], ESI	;Store offset of the CCB in the DCB
	INCL	dcbinuse
	MOVL	EAX, dcbinuse
	CMPL	dcbmax, EAX
	JAE	40$.S
	MOVL	dcbmax, EAX
40$:	CLC
	POPL	EBX
	RET
.PAGE
	.SBTTL	knlUnlinkDcb - Subroutine to remove DCB from its current class

;Subroutine to remove DCB from its current class
;	c{EDI} = Offset of DCB
;	CALL	knlUnlinkDcb
;  ECX is preserved

knlUnlinkDcb::
	CMPL	dcb_opencnt.B[EDI], #0.B ;Is this DCB in use?
	JNE	10$.S			;Yes!
	CMPL	dcb_fnext.B[EDI], #-1.B	;Have a fork request active?
	JNE	12$.S			;Yes
	DECL	dcbinuse		;Reduce count of in use DCBs
	MOVL	EBX, dcb_ccb.B[EDI]	;No - get offset of current CCB
	MOVL	EAX, dcb_prev.B[EDI]	;Get offset of previous DCB
	MOVL	EDX, dcb_next.B[EDI]	;Get next DCB
	TESTL	EAX, EAX		;Have a previous DCB?
	JE	2$.S			;No
	MOVL	dcb_next.B[EAX], EDX	;Yes
	JMP	4$.S

2$:	MOVL	ccb_dcbhead.B[EBX], EDX
4$:	TESTL	EDX, EDX
	JE	6$.S			;If no next DCB
	MOVL	dcb_prev.B[EDX], EAX
	RET

6$:	MOVL	ccb_dcbtail.B[EBX], EAX
	RET

10$:	CRASH	DCBA			;[DCB is Active]

12$:	CRASH	FKRQ			;[have ForK ReQuest]
.PAGE
	.SBTTL	devoas - General once-a-second routine for devices

;General once-a-second routine for devices
;	CALL	devoas

devoas::MOVL	EBX, #firstcab#		;Get first close action block (CAB)
2$:	MOVL	ESI, [EBX]
	TESTL	ESI, ESI
	JE	12$			;If none
4$:	CMPW	cab_count.B[ESI], #0.B	;Is the counter running?
	JE	6$.S			;No - go on
	DECW	cab_count.B[ESI]	;Yes - reduce the timer count
	JE	10$.S			;If it has run out
6$:	MOVL	EBX, ESI		;Advance to next CAB
	JMP	2$.S

;Here if timer has run out on a CAB

10$:	MOVL	EAX, [ESI]		;Remove CAB from the timer list
	MOVL	[EBX], EAX
	MOVL	[ESI], #-1
	PUSHL	EBX
	MOVL	EBX, #devcls
	MOVL	EDI, cab_dcb.B[ESI]
	MOVZWL	EDX, cab_handle.B[ESI]
	MOVW	ES, cab_pda.B[ESI]
	TOFORK
	CALL	knlReqXSig#		;Request exec signal
	FROMFORK
	POPL	EBX
	JMP	2$.S

;Exec interrupt routine to close device which has timed out

devcls:	CALL	knlGetQel#		;Get a QEL
	JC	12$.S			;Forget it if error
	MOVW	iorb_handle.B[ESI], DX	;Set up arguments for the close
	CLRL	EAX
	MOVL	iorb_mlckcnt.B[ESI], EAX
	MOVL	iorb_qab+0.B[ESI], EAX
	MOVW	iorb_qab+4.B[ESI], AX
	MOVL	iorb_parm+0.B[ESI], EAX
	MOVL	iorb_qab+0.B[ESI], EAX
	MOVL	iorb_lock+0.B[ESI], EAX
	MOVL	iorb_option.B[ESI], #C$KEEPHNDL
	MOVL	iorb_finish.B[ESI], #clsalld
	CALL	close2#			;Close the device
	FROMFORK
12$:	RET
.PAGE
	.SBTTL	Data

	DATA

forkreqh::  .LONG  0		;Fork request list head pointer
forkreqt::  .LONG  0		;Fork request list tail pointer
dcbtblfree::.LONG  0
dcbtblsize::.LONG  0
dcbinuse::  .LONG  0
dcbmax::    .LONG  0
dcbidseq:   .LONG  0

firstirqrb: .LONG  irqrb0

irqtbl:
irqrb0:   .LONG  irqrb2		;irqrb_next
          .LONG  sysclk		;irqrb_name
          .BYTE  0		;irqrb_bits
          .BYTE  0t		;irqrb_number
          .BLKB  2t
          .LONG  0		;irqrb_entry
          .LONG  0		;irqrb_exit

irqrb2:   .LONG  irqrb8		;irqrb_next
          .LONG  syscas		;irqrb_name
          .BYTE  0		;irqrb_bits
          .BYTE  2t		;irqrb_number
          .BLKB  2t
          .LONG  0		;irqrb_entry
          .LONG  0		;irqrb_exit

irqrb8:   .LONG  irqrb13	;irqrb_next
          .LONG  sysrtc		;irqrb_name
          .BYTE  0		;irqrb_bits
          .BYTE  8t		;irqrb_number
          .BLKB  2t
          .LONG  0		;irqrb_entry
          .LONG  0		;irqrb_exit

irqrb13:  .LONG  0		;irqrb_next
          .LONG  sysfpu		;irqrb_name
          .BYTE  0		;irqrb_bits
          .BYTE  13t		;irqrb_number
          .BLKB  2t
          .LONG  0		;irqrb_entry
          .LONG  0		;irqrb_exit
irqtblsize==!{{$-irqtbl}/irqrb_SIZE}*20t

firstiorrb::.LONG  ioregblk0

iotbl:
ioregblk0:.LONG  ioregblk1
	  .LONG  sysdma0
	  .WORD  0
	  .WORD  0Fh

ioregblk1:.LONG  ioregblk2
	  .LONG  sysic0
	  .WORD  20h
	  .WORD  21h

ioregblk2:.LONG  ioregblk3
	  .LONG  sysclk
	  .WORD  40h
	  .WORD  43h

ioregblk3:.LONG  ioregblk4
	  .LONG  sysrtc
	  .WORD  70h
	  .WORD  77h

ioregblk4:.LONG  ioregblk5
	  .LONG  sysdmax
	  .WORD  80h
	  .WORD  8Fh

ioregblk5:.LONG  ioregblk6
	  .LONG  sysic1
	  .WORD  0A0h
	  .WORD  0A1h

ioregblk6:.LONG  0
	  .LONG  sysdma1
	  .WORD  0C0h
	  .WORD  0CDh

iotblsize==!{{$-iotbl}/12t}*20t

sysdma0:  .ASCIZ "SYSTEM_DMA0"
sysdma1:  .ASCIZ "SYSTEM_DMA1"
sysdmax:  .ASCIZ "SYSTEM_DMAX"
sysic0:   .ASCIZ "SYSTEM_IC0"
sysic1:   .ASCIZ "SYSTEM_IC1"
sysclk:   .ASCIZ "SYSTEM_Clock"
syscas:   .ASCIZ "SYSTEM_Cascade"
sysrtc:   .ASCIZ "SYSTEM_RTC"
sysfpu:   .ASCIZ "SYSTEM_FPU"
	  .MOD   4
lgllvl::  .BYTE  0		;Level counter for logical name translation

	END
