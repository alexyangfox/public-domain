	.TITLE	IOCS1 - Top level IO routines for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSXDISK.PAR

;Device parameter table for open type operations

	CODE

	.LONG	PARMMAX
knlOpnParms::
	.LONG	opngenparms	;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	opnfilparms	;IOPAR_FILxxx = 01xx - File system IO parameters
	.LONG	opntrmparms	;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	opndskparms	;IOPAR_DSKxxx = 03xx - Disk IO parameters
	.LONG	opntapparms	;IOPAR_TAPxxx = 04xx - Tape IO parameters
	.LONG	opnnetparms	;IOPAR_NETxxx = 05xx - Network IO parameters
	.LONG	0		;IOPAR_IPMxxx = 06xx - IPM IO parameters
	.LONG	opnmsgparms	;IOPAR_MSGxxx = 07xx - Message IO parameters
PARMMAX=!{$-knlOpnParms}/4

	.LONG	PARMGENMAX	;Size of table
opngenparms:
	.LONG	0		;		   = 0000h
	.LONG	knlIopFilOptn#	;IOPAR_FILOPTN     = 0001h
	.LONG	knlIopFilSpec#	;IOPAR_FILSPEC     = 0002h
	.LONG	opndevsts	;IOPAR_DEVSTS      = 0003h
	.LONG	opnunitnum	;IOPAR_UNITNUM     = 0004h
	.LONG	opngblid	;IOPAR_GLBID       = 0005h
	.LONG	0		;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut#	;IOPAR_TIMEOUT     = 0007h
	.LONG	0		;IOPAR_INPSTS      = 0008h
	.LONG	0		;IOPAR_OUTSTS      = 0009h
	.LONG	opninpqlmt	;IOPAR_INPQLMT	   = 000Ah
	.LONG	opnoutqlmt	;IOPAR_OUTQLMT	   = 000Bh
	.LONG	opnvect1	;IOPAR_SIVECT1     = 00Ch
	.LONG	opnvect2	;IOPAR_SIVECT2     = 000Dh
	.LONG	knlIopDummyN#	;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopDummyN#	;IOPAR_NUMOPEN     = 000Fh
	.LONG	opnbufrlmt	;IOPAR_BUFRLMT	   = 0010h

;All generic table entires beyond this point are obsolete

	.LONG	0		;		   = 17.
	.LONG	0		;		   = 18.
	.LONG	0		;		   = 19.
	.LONG	opndirhndl	;IOPAR_DIRHNDL     = 20.
	.LONG	opnbufrlmt	;IOPAR_BUFRLMT	   = 21.
	.LONG	opnsrcattr	;IOPAR_SRCATTR     = 22.
	.LONG	opnfilattr	;IOPAR_FILATTR     = 23.
	.LONG	opndirofs	;IOPAR_DIROFS      = 24.
	.LONG	opnabspos	;IOPAR_ABSPOS	   = 25.
	.LONG	opnrelpos	;IOPAR_RELPOS	   = 26.
	.LONG	opneofpos	;IOPAR_EOFPOS	   = 27.
	.LONG	0		;IOPAR_VBOF	   = 28.
	.LONG	opnlength	;IOPAR_LENGTH      = 29.
	.LONG	opnreqalloc	;IOPAR_REQALLOC    = 30.
	.LONG	opnrqralloc	;IOPAR_RQRALLOC    = 31.
	.LONG	opngrpsize	;IOPAR_GRPSIZE     = 32.
	.LONG	opnadate	;IOPAR_ADATE       = 33.
	.LONG	opncdate	;IOPAR_CDATE       = 34.
	.LONG	opnmdate	;IOPAR_MDATE       = 35.
	.LONG	opnprot		;IOPAR_PROT        = 36.
	.LONG	opnowner	;IOPAR_OWNER       = 37.
	.LONG	0		;                  = 38.
	.LONG	opnsetlock	;IOPAR_SETLOCK	   = 39.
	.LONG	opnclrlock	;IOPAR_CLRLOCK	   = 40.
	.LONG	opnclstime	;IOPAR_CLSTIME     = 41.
	.LONG	opnclsname	;IOPAR_CLSNAME     = 42.
	.LONG	opnclsmsg	;IOPAR_CLSMSG	   = 43.
	.LONG	0		;		   = 44.
	.LONG	0		;		   = 45.
	.LONG	0		;		   = 46.
	.LONG	0		;		   = 47.
	.LONG	0		;		   = 48.
	.LONG	0		;		   = 49.
	.LONG	opngetonly	;IOPAR_NETSUBUMASK = 50.
	.LONG	opnprotocol	;IOPAR_NETPROTOCOL = 51.
	.LONG	opnlclport	;IOPAR_NETLCLPORT  = 52.
	.LONG	0		;IOPAR_NETRMTHWAS  = 53.
	.LONG	0		;IOPAR_NETRMTHWAR  = 54.
	.LONG	opnrmtnetas	;IOPAR_NETRMTNETAS = 55.
	.LONG	opngetonly	;IOPAR_NETRMTNETAR = 56.
	.LONG	opnrmtports	;IOPAR_NETRMTPORTS = 57.
	.LONG	opngetonly	;IOPAR_NETRMTPORTR = 58.
	.LONG	0		;IOPAR_NETDSTNAME  = 59.
	.LONG	0		;IOPAR_NETSMODE    = 60.
	.LONG	0		;IOPAR_NETCMODE    = 61.
	.LONG	0		;		   = 62.
	.LONG	0		;		   = 63.
	.LONG	0		;		   = 64.
	.LONG	0		;IOPAR_IPMRMTPID   = 65.
	.LONG	0		;IOPAR_IPMLCLADDR  = 66.
	.LONG	0		;IOPAR_IPMRMTADDRS = 67.
	.LONG	0		;IOPAR_IPMRMTADDRR = 68.
	.LONG	0		;		   = 69.
	.LONG	0		;		   = 70.
	.LONG	0		;		   = 71.
	.LONG	0		;		   = 72.
	.LONG	0		;		   = 73.
	.LONG	0		;		   = 74.
	.LONG	0		;		   = 75.
	.LONG	knlIopDummyN#	;IOPAR_TRMSINPMODE = 76.
	.LONG	knlIopDummyN#	;IOPAR_TRMCINPMODE = 77.
	.LONG	knlIopDummyN#	;IOPAR_TRMSOUTMODE = 78.
	.LONG	knlIopDummyN#	;IOPAR_TRMCOUTMODE = 79.
	.LONG	knlIopDummyN#	;IOPAR_TRMBFRLIMIT = 80.
	.LONG	knlIopDummyN#	;IOPAR_TRMCLRBUFR  = 81.
	.LONG	knlIopDummyN#	;IOPAR_TRMCURTYPE  = 82.
	.LONG	knlIopDummyN#	;IOPAR_TRMCURPOS   = 83.
	.LONG	knlIopDummyN#	;IOPAR_TRMDISPAGE  = 84.
	.LONG	knlIopDummyN#	;IOPAR_TRMSPSTATUS = 85.
	.LONG	knlIopDummyN#	;IOPAR_TRMSPBREAK  = 86.
	.LONG	knlIopDummyN#	;IOPAR_TRMSPMODEM  = 87.
	.LONG	0		;		   = 88.
	.LONG	0		;		   = 89.
	.LONG	0		;		   = 90.
	.LONG	0		;		   = 91.
	.LONG	0		;		   = 92.
	.LONG	0		;		   = 93.
	.LONG	0		;		   = 94.
	.LONG	0		;		   = 95.
	.LONG	opnfstype	;IOPAR_DSKFSTYPE   = 96.
	.LONG	opnsectsize	;IOPAR_DSKSECTSIZE = 97.
	.LONG	opnclssize	;IOPAR_DSKCLSSIZE  = 98.
	.LONG	opnttlspace	;IOPAR_DSKTTLSPACE = 99.
	.LONG	opnavlspace	;IOPAR_DSKAVLSPACE = 100.
	.LONG	opnnumhead	;IOPAR_DSKNUMHEAD  = 101.
	.LONG	opnnumsect	;IOPAR_DSKNUMSECT  = 102.
	.LONG	opnnumcyln	;IOPAR_DSKNUMCYLN  = 103.
PARMGENMAX=!{$-opngenparms}/4

	.LONG	PARMFILMAX
opnfilparms:
	.LONG	0
	.LONG	opndirhndl	;IOPAR_DIRHNDL     = 0101h
	.LONG	opnsrcattr	;IOPAR_SRCATTR     = 0102h
	.LONG	opnfilattr	;IOPAR_FILATTR     = 0103h
	.LONG	opndirofs	;IOPAR_DIROFS      = 0104h
	.LONG	opnabspos	;IOPAR_ABSPOS	   = 0105h
	.LONG	opnrelpos	;IOPAR_RELPOS	   = 0106h
	.LONG	opneofpos	;IOPAR_EOFPOS	   = 0107h
	.LONG	0		;IOPAR_VBOF	   = 0108h
	.LONG	opnlength	;IOPAR_LENGTH      = 0109h
	.LONG	opnreqalloc	;IOPAR_REQALLOC    = 010Ah
	.LONG	opnrqralloc	;IOPAR_RQRALLOC    = 010Bh
	.LONG	opngrpsize	;IOPAR_GRPSIZE     = 010Ch
	.LONG	opnadate	;IOPAR_ADATE       = 010Dh
	.LONG	opncdate	;IOPAR_CDATE       = 010Eh
	.LONG	opnmdate	;IOPAR_MDATE       = 010Fh
	.LONG	opnprot		;IOPAR_PROT        = 0110h
	.LONG	opnowner	;IOPAR_OWNER       = 0111h
	.LONG	0		;                  = 0112h
	.LONG	opnsetlock	;IOPAR_SETLOCK	   = 0113h
	.LONG	opnclrlock	;IOPAR_CLRLOCK	   = 0114h
	.LONG	opnclstime	;IOPAR_CLSTIME     = 0115h
	.LONG	opnclsname	;IOPAR_CLSNAME     = 0116h
	.LONG	opnclsmsg	;IOPAR_CLSMSG	   = 0117h
	.LONG	opnshrparms	;IOPAR_SHRPARMS    = 0118h
PARMFILMAX=!{$-opnfilparms}/4

	.LONG	PARMDSKMAX
opndskparms:
	.LONG	0
	.LONG	opnfstype	;IOPAR_DSKFSTYPE   = 0201h
	.LONG	opnsectsize	;IOPAR_DSKSECTSIZE = 0202h
	.LONG	opnclssize	;IOPAR_DSKCLSSIZE  = 0203h
	.LONG	opnttlspace	;IOPAR_DSKTTLSPACE = 0204h
	.LONG	opnavlspace	;IOPAR_DSKAVLSPACE = 0205h
	.LONG	opnnumhead	;IOPAR_DSKNUMHEAD  = 0206h
	.LONG	opnnumsect	;IOPAR_DSKNUMSECT  = 0207h
	.LONG	opnnumcyln	;IOPAR_DSKNUMCYLN  = 0208h
PARMDSKMAX=!{$-opndskparms}/4

	.LONG	PARMTAPMAX
opntapparms:
	.LONG	0
PARMTAPMAX=!{$-opntapparms}/4

	.LONG	PARMTRMMAX
opntrmparms:
	.LONG	0
	.LONG	knlIopDummyN#	;IOPAR_TRMSINPMODE = 0401h
	.LONG	knlIopDummyN#	;IOPAR_TRMCINPMODE = 0402h
	.LONG	knlIopDummyN#	;IOPAR_TRMSOUTMODE = 0403h
	.LONG	knlIopDummyN#	;IOPAR_TRMCOUTMODE = 0404h
	.LONG	knlIopDummyN#	;IOPAR_TRMBFRLIMIT = 0405h
	.LONG	knlIopDummyN#	;IOPAR_TRMCLRBUFR  = 0406h
	.LONG	knlIopDummyN#	;IOPAR_TRMCURTYPE  = 0407h
	.LONG	knlIopDummyN#	;IOPAR_TRMCURPOS   = 0408h
	.LONG	knlIopDummyN#	;IOPAR_TRMDISPAGE  = 0409h
	.LONG	knlIopDummyN#	;IOPAR_TRMSPSTATUS = 040Ah
	.LONG	knlIopDummyN#	;IOPAR_TRMSPBREAK  = 040Bh
	.LONG	knlIopDummyN#	;IOPAR_TRMSPMODEM  = 040Ch
PARMTRMMAX=!{$-opntrmparms}/4

	.LONG	PARMNETMAX
opnnetparms:
	.LONG	0
	.LONG	opngetonly	;IOPAR_NETSUBUMASK = 0501h
	.LONG	opnprotocol	;IOPAR_NETPROTOCOL = 0502h
	.LONG	opnlclport	;IOPAR_NETLCLPORT  = 0503h
	.LONG	0		;IOPAR_NETRMTHWAS  = 0504h
	.LONG	0		;IOPAR_NETRMTHWAR  = 0505h
	.LONG	opnrmtnetas	;IOPAR_NETRMTNETAS = 506h
	.LONG	opngetonly	;IOPAR_NETRMTNETAR = 0507h
	.LONG	opnrmtports	;IOPAR_NETRMTPORTS = 0508h
	.LONG	opngetonly	;IOPAR_NETRMTPORTR = 0509h
	.LONG	0		;IOPAR_NETDSTNAME  = 050Ah
	.LONG	0		;IOPAR_NETSMODE    = 050Bh
	.LONG	0		;IOPAR_NETCMODE    = 050Ch
	.LONG	0		;IOPAR_NETRCVWIN   = 050Dh
	.LONG	opngetonly	;IOPAR_NETLCLNETA  = 050Eh
	.LONG	0		;IOPAR_NETKATIME   = 050Fh
	.LONG	opnconlimit	;IOPAR_NETCONLIMIT = 0510h
	.LONG	opnconhndl	;IOPAR_NETCONHNDL  = 0511h
PARMNETMAX=!{$-opnnetparms}/4

	.LONG	PARMSGMAX
opnmsgparms:
	.LONG	0		;		   = 0700h
	.LONG	0		;IOPAR_MSGLCLADDR  = 0701h
	.LONG	opnrmtaddrs	;IOPAR_MSGRMTADDRS = 0702h
	.LONG			;IOPAR_MSGRMTADDRR = 0703h
PARMSGMAX=!{$-opnmsgparms}/4
.PAGE
;File IO parameter table for non-disk devices

	.LONG	NULLFILMAX
knlNullFilParms::
	.LONG	0
	.LONG	0		;IOPAR_DIRHNDL     = 0101h
	.LONG	knlIopNullN#	;IOPAR_SRCATTR     = 0102h
	.LONG	knlIopNullN#	;IOPAR_FILATTR     = 0103h
	.LONG	knlIopNullN#	;IOPAR_DIROFS      = 0104h
	.LONG	knlIopNullN#	;IOPAR_ABSPOS	   = 0105h
	.LONG	knlIopNullN#	;IOPAR_RELPOS	   = 0106h
	.LONG	knlIopNullN#	;IOPAR_EOFPOS	   = 0107h
	.LONG	knlIopNullN#	;IOPAR_VBOF	   = 0108h
	.LONG	knlIopNullN#	;IOPAR_LENGTH      = 0109h
	.LONG	knlIopNullN#	;IOPAR_REQALLOC    = 010Ah
	.LONG	knlIopNullN#	;IOPAR_RQRALLOC    = 010Bh
	.LONG	knlIopNullN#	;IOPAR_GRPSIZE     = 010Ch
	.LONG	knlIopNullN#	;IOPAR_ADATE       = 010Dh
	.LONG	knlIopNullN#	;IOPAR_CDATE       = 010Eh
	.LONG	knlIopNullN#	;IOPAR_MDATE       = 010Fh
	.LONG	knlIopNullN#	;IOPAR_PROT        = 0110h
	.LONG	knlIopNullT#	;IOPAR_OWNER       = 0111h
	.LONG	knlIopNullT#	;                  = 0112h
	.LONG	knlIopNullN#	;IOPAR_SETLOCK	   = 0113h
	.LONG	knlIopNullN#	;IOPAR_CLRLOCK	   = 0114h
	.LONG	0		;IOPAR_CLSTIME     = 0115h
	.LONG	0		;IOPAR_CLSNAME     = 0116h
	.LONG	0		;IOPAR_CLSMSG	   = 0117h
	.LONG	knlIopNullN#	;IOPAR_SHRRETRY    = 0118h
	.LONG	knlIopNullN#	;IOPAR_SHRDELAY    = 0119h
NULLFILMAX=!{$-knlNullFilParms}/4
.PAGE
	.SBTTL	devparmfunc - Get device parameters given name

;Here for the queued IO get device parameters given name function
;	c{ECX}    = Open command bits
;	c{ES:EBX} = Address of file specification
;	c{FS:EDX} = Address of parameter list
;	CALL	devparmfunc
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal (operation started)
;	  c{EAX} = 0

devparmfunc::
	MOVL	iorb_routine.B[ESI], #devparm1
	JMP	opnfnc2.S

	.SBTTL	openfunc - Open file

;Here for the queued IO open function
;	c{ESI} = Offset of IORB
;	CALL	openfunc
;	C:set = Error
;	  c{EAX} = Error code
;	  c{EBX} = Status bits
;	  c{ECX} = Item count
;	  c{EDX} = 7FFFh
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{EBX} = Status bits
;	  c{ECX} = Item count
;	  c{EDX} = Handle

openfunc::
	BTL	iorb_option.B[ESI], #O%REPEAT ;Repeat specified?
	JC	14$			;Yes - fail
	MOVL	iorb_routine.B[ESI], #open1
	BTL	iorb_option.B[ESI], #O%UNQNAME ;Want to create a unique name?
	JNC	opnfnc2.S		;No - continue
	IFFAULT	knlQAdrErr0#
	LESL	EDI, iorb_buffer1.B[ESI] ;Yes - get address of name
	CALL	getunqname#		;Get unique file name
	JC	4$.S			;If error
opnfnc2::
	MOVB	iorb_queue.B[ESI], #0
	MOVL	EBX, #DH_FV
	BTL	iorb_option.B[ESI], #O%FHANDLE ;Want to force a handle?
	JNC	2$.S			;No
	MOVZWL	EBX, iorb_handle.B[ESI]	;Yes - get the desired handle
	BTSL	EBX, #31t		;Indicate forced handle
2$:	CALL	gethandle		;Allocate a device handle
4$:	JC	16$			;If error
	PUSHL	EBX			;Save the handle
	CMPL	iorb_qab+0.B[ESI], #0.B	;Do we have a QAB
	JNE	5$.S			;Yes
	CMPW	iorb_qab+4.B[ESI], #0.B	;Maybe not
	JE	6$.S			;No
5$:	CALL	knlIoQabLock#		;Yes - lock the QAB
	JC	12$.S			;If error
6$:	IFFAULT	10$
	LESL	EBX, iorb_buffer1.B[ESI] ;Get address of name
	CALL	knlIoNameLock#		;Lock memory containing the device/file
	JC	12$.S			;  specification
	CMPB	iorb_func.B[ESI], #QFNC_RENAME ;Rename function?
	JNE	8$.S			;No
	IFFAULT	10$
	LESL	EBX, iorb_buffer2.B[ESI] ;Yes - lock the new name string too
	CALL	knlIoNameLock#
	JC	12$.S
8$:	CALL	knlIoParmLock#
	JC	12$.S
	POPL	EAX
	MOVW	iorb_handle.B[ESI], AX
	MOVB	iorb_queue.B[ESI], #0
	CLRL	EDI
	JMP	knlXfBegin#		;Switch to extended fork context

;Here if address error before the open really gets underway but after a handle
;  has been allocated

	FAULTHDR
10$:	MOVL	EAX, #ER_ADRER
	CALL	knlGiveIorb#

;Here if error return from ioqablock, ionamelock or ioparmlock - IORB has been
;  given up but the handle is still allocated

12$:	POPL	EBX			;Restore handle
	SHLL	EBX, #5			;Calculate offset in handle table
	ADDL	EBX, SS:pdaHndlTbl#
	CMPL	SS:[EBX], #0FFFh	;Is the table correct?
	JNE	20$.S			;No - crash!
	CLRL	EDX			;Yes - clear the table entry
	MOVL	SS:[EBX], EDX
	MOVL	SS:4.B[EBX], EDX
	JMP	18$.S			;Continue

;Here if error before any resources are allocated - still have IORB

14$:	MOVL	EAX, #ER_IFDEV
16$:	CALL	knlGiveQel#
18$:	CALL	knlGivUFin#
	TOFORK
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	MOVL	EDX, #07FFFh
	STC				;Indicate error
	RET				;And return

20$:	CRASH	HNDL
.PAGE
;Here when have a ER_DEVNO error on a spooled device to do automatic re-open

reopen::MOVZWL	EBX, iorb_handle.B[ESI]
	SHLL	EBX, #5t
	ADDL	EBX, SS:pdaHndlTbl#
	MOVL	EAX, SS:4.B[EBX]
	MOVL	iorb_option.B[ESI], EAX
	MOVB	AL, SS:[EBX]		;Preserve the unit number
	MOVB	iorb_count+3.B[ESI], AL
	MOVL	SS:[EBX], #0FFFh	;Indicate handle is being opened
	MOVB	iorb_queue.B[ESI], #dcb_outframe
	MOVL	iorb_routine.B[ESI], #reopen1
	MOVB	iorb_queue.B[ESI], #0
	CLRL	EDI
	JMP	knlXfBegin#		;Switch to extended fork context

;Here in extended fork context to re-open a handle on outblock

reopen1:MOVZBL	EAX, SS:xffCount#+3	;Get unit number
	MOVB	SS:xffCount#+3, #0
	PUSHL	SS:xffCount#		;Save the outblock parameters (note that
	PUSHL	SS:xffBuffer1#+0	;  memory has already been locked for
	PUSHL	SS:xffBuffer1#+4	;  the write)
	PUSHL	SS:xffParm#+0
	PUSHL	SS:xffParm#+4
	PUSHL	SS:xffFunc#-2
	PUSHL	#0.B			;Clear 8 bytes to hold the spooled
	PUSHL	#'SPL'			;  device name
	LEAL	EBX, 3.B[ESP]
	MOVL	SS:xffBuffer1#+0, ESP
	MOVL	SS:xffBuffer1#+4, SS
	CLRL	ECX
4$:	CLRL	EDX			;Convert to digits on the stack
	DIVL	knlLit10#
	PUSHL	EDX
	INCL	ECX
	TESTL	EAX, EAX
	JNE	4$.S
6$:	POPL	EAX			;Get digit
	ADDB	AL, #'0'		;Change to ASCII
	MOVB	SS:[EBX], AL		;Store in name
	INCL	EBX			;Bump pointer
	LOOP	ECX, 6$			;Continue if more digits
	MOVB	SS:[EBX], #':'		;End it with a colon
	MOVL	SS:xffOption#, #O$OUT
	MOVB	SS:xffFunc#, #QFNC_OPEN
	CLRL	EAX
	MOVL	SS:xffParm#+0, EAX
	CALL	open1			;Try to open the spooled device again
	POPL	EDX			;Discard name
	POPL	EDX
	POPL	SS:xffFunc#-2		;Restore function
	POPL	SS:xffParm#+4		;Restore other argument for the write
	POPL	SS:xffParm#+0
	POPL	SS:xffBuffer1#+4
	POPL	SS:xffBuffer1#+0
	POPL	SS:xffCount#
	TESTL	EAX, EAX
	JS	10$.S			;If error on the open
	MOVW	dcb_outframe.B[EDI], SS	;OK - restore link this stack frame
	MOVL	EAX, dcb_sdisp.B[EDI]	;Dispatch to the driver to do the
	JMPIL	CS:sd_outblockq.B[EAX]	;  output

10$:	RET
.PAGE
;Here in extended fork context for open

open1:	MOVL	EBX, #knlOpnParms	;Do initial setup (this also processes
	CALL	knlOpenSetup		;  the open parameters)
2$:	JC	open8			;If error
	LESL	EBX, SS:xffBuffer1#	;Get address of name
	MOVL	EAX, SS:xffOption#	;Get command bits
	MOVL	SS:xffCmd#, EAX
	MOVL	EDI, #openfrk
	CALL	doopen#			;Do the first part of open
	JC	open6			;If error
	MOVL	ESI, opn_cab.B[EBP]	;Do we have a CAB?
	TESTL	ESI, ESI
	JE	opendn			;No
	CMPL	dcb_cab.B[EDI], #0.B	;Does the device already have a CAB?
	JE	10$.S			;No
	MOVL	EDX, dcb_cab.B[EDI]	;Yes - get its offset
	CMPL	cab_time.B[ESI], #0.B	;Do we have a time value?
	JE	4$.S			;No
	CMPL	cab_time.B[EDX], #0.B	;Yes - does the device have a value?
	JNE	4$.S			;Yes - discard ours
	MOVL	EAX, cab_time.B[ESI]	;No - use our value
	MOVL	cab_time.B[EDX], EAX
	MOVL	EAX, cab_pda.B[ESI]
	MOVL	cab_pda.B[EDX], EAX
	MOVL	EAX, firstcab#		;Link the CAB into the timer list
	MOVL	firstcab#, EDX
	MOVL	[EDX], EAX
4$:	CMPB	cab_clsname.B[ESI], #0	;Do we have a close name?
	JE	6$.S			;No
	CMPB	cab_clsname.B[EDX], #0	;Yes - does device have a close name?
	JNE	6$.S			;Yes - discard ours
	MOVL	ECX, #8t
	PUSHL	DS
	POPL	ES
	PUSHL	EDI
	PUSHL	ESI
	ADDL	ESI, #cab_clsname.B
	LEAL	EDI, cab_clsname.B[EDX]
	CLD
	RMOVSL	[EDI], [ESI]
	POPL	ESI
	POPL	EDI
6$:	CMPB	cab_clsmsg.B[ESI], #0	;Do we have a message name?
	JE	opendn.S		;No
	CMPB	cab_clsmsg.B[EDX], #0	;Yes - does device have a message name?
	JNE	opendn.S		;Yes - discard ours
	MOVL	ECX, #8t
	PUSHL	DS
	POPL	ES
	PUSHL	EDI
	PUSHL	ESI
	ADDL	ESI, #cab_clsmsg.B
	LEAL	EDI, cab_clsmsg.B[EDX]
	CLD
	RMOVSL	[EDI], [ESI]
	POPL	ESI
	POPL	EDI
	CALL	knlGiveXmb#
	JMP	opendn.S

;Here if we have a CAB and the device does not

10$:	MOVL	cab_dcb.B[ESI], EDI
	MOVL	dcb_cab.B[EDI], ESI
	CMPL	cab_time.B[ESI], #0.B	;Have a close time value?
	JE	opendn.S		;No
	MOVL	EAX, firstcab#		;Yes - link the CAB into the timer list
	MOVL	firstcab#, ESI
	MOVL	[ESI], EAX
opendn::CALL	knlGivUFin#		;OK - finish up giving him the name
	CLRL	EAX			;Return 0
	MOVL	EDX, SS
	CMPW	dcb_outframe.B[EDI], DX
	JNE	12$.S
	MOVW	dcb_outframe.B[EDI], #0	;Clear link to the stack frame
12$:	MOVXWL	EBX, SS:xffHandle#	;Get the handle
	MOVL	EDX, EBX
	CMPL	EBX, #MAXHNDLS		;OK - have a valid handle?
	JA	16$.S			;No - crash
	MOVW	ES, SS:xffPda#
	SHLL	EBX, #5
	ADDL	EBX, ES:pdaHndlTbl#
	CMPL	ES:[EBX], EDI		;Is the table correct?
	JNE	16$.S			;No - crash!
	MOVL	ESI, SS:xffCmd#		;Get value for command bits
	ANDL	ESI, #0001FFFFh		;Store command bits in the handle table
	MOVL	ES:4.B[EBX], ESI
	MOVL	EBX, #QSTS$DONE		;Get bits for qab_status
	LEAVE
	RET

;Here if handle table is messed up!

16$:	CRASH	HNDL

;Here if error on the open

open6::	CALL	knlGivUFin#
open8::	MOVXWL	EBX, SS:xffHandle#	;Get the handle
	CMPL	EBX, #MAXHNDLS		;OK - have a valid handle?
	JA	16$.S			;No - crash
	MOVW	ES, SS:xffPda#
	SHLL	EBX, #5
	ADDL	EBX, ES:pdaHndlTbl#
	CMPL	ES:[EBX], EDI		;Is the table correct?
	JE	26$.S			;Yes
	CMPL	ES:[EBX], #0FFFh	;Maybe
	JNE	16$.S			;No - crash!
26$:	CLRL	EDX			;Yes - clear the table entry
	MOVL	ES:[EBX], EDX
	MOVL	ES:4.B[EBX], EDX
	MOVL	EDX, #7FFFh		;Return impossible handle value
	MOVL	EBX, #QSTS$DONE		;Get bits for qab_status
	LEAVE
	RET
.PAGE
;Here in extended fork context for devparm

devparm1:
	MOVL	EBX, #knlOpnParms	;Do initial setup (this also processes
	CALL	knlOpenSetup		;  the open parameters)
	JC	open8.S			;If error
	IFFAULT	knlQAdrErr0#
	LESL	EBX, SS:xffBuffer1#	;Get address of name
	MOVL	EAX, SS:xffOption#	;Get command bits
	MOVL	SS:xffCmd#, EAX
	MOVL	EDI, #parm4
parm2:	CALL	doopen#			;Do the first part of the function
	JC	4$.S			;If error
parmdn::CALL	opner2			;OK - give up DCB if need to
	CLRL	EAX			;Return 0
4$:	JMP	open6
.PAGE
;Subroutine called by doopen for each definition of the device name for
;  QFNC_DELETE
;	c{EDI}    = Offset of DCB
;	c{SS:ESI} = Address of expanded name
;	CALL	delete4
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

delete4:MOVL	EBX, #sd_delete
	JMP	4$.S

;Subroutine called by doopen for each definition of the device name for
;  QFNC_PARM
;	c{EDI}    = Offset of DCB
;	c{SS:EDX} = Address of expanded name
;	CALL	parm4
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

parm4::	MOVL	EBX, #sd_parm
	JMP	4$.S

;Subroutine called by doopen for each definition of the device name for
;  QFNC_OPEN
;	c{EDI}    = Offset of DCB
;	c{SS:EDX} = Address of expanded name
;	CALL	openfrk
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

openfrk::
	MOVL	EBX, #sd_open1		;Assume first open
	CMPL	dcb_opencnt.B[EDI], #1.B ;Right?
	JE	4$.S			;Yes
	BTL	SS:xffHvValue1#, #IOV1%DIRHNDL ;Maybe - searching open
						;  directory?
	JC	4$.S			;Yes
	ADDL	EBX, #sd_opena-sd_open1.B ;No - adjust offset
4$:	MOVL	ECX, SS:xffCmd#		;Get command bits
	ADDL	EBX, dcb_sdisp.B[EDI]	;Dispatch to routine for device
	CALLI	CS:[EBX]
	JNC	12$.S			;If OK
opnerr:	CALL	knlGivUErr#
opner2::PUSHL	EAX
	CMPL	dcb_opencnt.B[EDI], #0.B ;Is device in use now?
	JE	14$.S			;No - big problem!
	MOVW	ES, SS:xffPda#		;Yes - get handle
	MOVZWL	EAX, SS:xffHandle#
	SHLL	EAX, #5
	ADDL	EAX, ES:pdaHndlTbl#
	CMPL	ES:[EAX], EDI
	JNE	16$.S
	MOVL	ES:[EAX], #0FFFh	;Indicate slot allocated but not in use
	MOVL	ES:4.B[EAX], #0
	DECL	dcb_opencnt.B[EDI]	;Reduce number of users of device
	JNE	10$.S			;If still in use
	PUSHL	ECX			;Last user
	CALL	knlClearDcb#		;Give up the DCB if need to
	POPL	ECX
10$:	POPL	EAX
	STC				;Indicate error
12$:	RET				;And return

14$:	CRASH	BDOC			;[Bad Device Open Count]

16$:	CRASH	BHTE			;[Bad Handle Table Entry]
.PAGE
	.SBTTL	renamefunc - Rename file

;Here for the queued IO rename file function
;	CALL	renamefunc
;	C:set = Error
;	  c{EAX} = Error code
;	  c{EBX} = QSTS$DONE
;	C:clr = Normal (operation started)
;	  c{EBX} = 0

renamefunc::
	MOVL	iorb_routine.B[ESI], #rename1
	JMP	opnfnc2

rename1:MOVL	EBX, #knlOpnParms
	CALL	knlOpenSetup
	JC	open8
	IFFAULT	knlQAdrErr0#
	LESL	EBX, SS:xffBuffer1#	;Get address of the old name
	MOVL	EAX, SS:xffOption#	;Get command bits
	MOVL	SS:xffCmd#, EAX
	MOVL	EDI, #rename4
	JMP	parm2
.PAGE
	.SBTTL	rename4 - Subroutine called for each logical definition for rename

;Subroutine called for each logical device definition for rename
;	c{EDI}    = Offset of DCB
;	c{SS:EDX} = Address of expanded old name
;	CALL	rename4
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

rename4::
	ENTER	opn_SIZE-4, 2		;Set up a stack frame for use here
	PUSHL	EDX			;Save offset of expanded old name
	PUSHL	EDI			;Save DCB offset
	LESL	EBX, SS:xffBuffer2#
	CLRL	EDX
	CALL	setnam2#		;Set up new name (no default)
	JC	8$.S
	LEAL	EDI, opn_namebfr[EBP]	;Point to our new name buffer
	CALL	copyname#		;Copy the name to the buffer
	JC	8$.S
	CMPL	opn_devname+0.B[EBP], #0.B ;Was a new device given?
	JNE	6$.S			;Yes
	MOVL	EBX, #xffRtdName#	;No - use old device name
	CMPL	SS:[EBX], #0.B
	JNE	4$.S
	MOVL	EBX, opn_frame1.B[EBP]
	ADDL	EBX, #opn_devname.B
4$:	MOVL	EAX, SS:[EBX]
	MOVL	opn_devname+0.B[EBP], EAX
	MOVL	EAX, SS:4.B[EBX]
	MOVL	opn_devname+4.B[EBP], EAX
	MOVL	EAX, SS:8.B[EBX]
	MOVL	opn_devname+8.B[EBP], EAX
	MOVL	EAX, SS:12t.B[EBX]
	MOVL	opn_devname+12t.B[EBP], EAX
6$:	MOVW	FS, SS:xffPda#		;Expand the new device name
	MOVZBL	EAX, FS:pdaSesProc#
	MOVW	FS, knlProcTable#[EAX*2]
	LEAL	EBX, opn_devname.B[EBP]
	MOVL	ECX, #O$CREATE
	MOVL	ESI, #renameexp
	LEAL	EDI, opn_namebfr[EBP]
	MOVL	EDX, EDI
	CALL	knlLogNameExpand#
8$:	JC	14$.S			;If error
	ANDB	opn_devname+0.B[EBP], #07Fh
	POPL	EDI
	POPL	EDX			;Restore offset of old name
	LEAL	ESI, opn_namebfr[EBP]	;Get offset of buffer containing new
					; name
	MOVL	EBX, dcb_sdisp.B[EDI]	;Dispatch to routine for device
	CALLI	CS:sd_rename.B[EBX]
	JC	16$.S			;If error
	LEAVE				;OK
	RET				;Return

;Here if new and old devices are not the same

12$:	MOVL	EAX, #ER_DFDEV
14$:	POPL	EDI
	POPL	EDX
	CLRL	ECX
16$:	LEAVE
	JMP	opnerr

;Subroutine called by knlLogNameExpand to expand the new name - all this does
;  is copy the expanded name back to the original buffer
;	c{SS:EBX} = Address of physical device name
;	c{SS:EDI} = Address of name buffer
;	c{SS:EDX} = Address of expanded name
;	CALL	renameexp

renameexp:
	MOVL	EAX, SS:[EBX]		;Store real device name
	MOVL	opn_devname+0.B[EBP], EAX
	MOVL	EAX, SS:4.B[EBX]
	MOVL	opn_devname+4.B[EBP], EAX
	MOVL	EAX, SS:8.B[EBX]
	MOVL	opn_devname+8.B[EBP], EAX
	MOVL	EAX, SS:12t.B[EBX]
	MOVL	opn_devname+12t.B[EBP], EAX
	PUSHL	SS
	POPL	ES
	MOVL	ESI, EDX
	CLD
20$:	LODSB	SS:[ESI]		;Copy expanded name to our base buffer
	STOSB	[EDI]
	CMPB	AL, #0
	JNE	20$.S
	RET				;Finished
.PAGE
	.SBTTL	deletefunc - Delete file

;Here for the queued IO delete file function
;	CALL	deletefunc
;	C:set = Error
;	  c{EAX} = Error code
;	  c{EBX} = QSTS$DONE
;	C:clr = Normal (operation started)
;	  c{EBX} = 0

deletefunc::				;Clear meaningless bits
	ANDL	iorb_option.B[ESI], #~{O$IN|O$FAILEX|O$CREATE|O$TRUNCA|O$TRUNCW}
	ORB	iorb_option.B[ESI], #O$OUT ;Set bit we must have
	MOVL	iorb_routine.B[ESI], #delete1
	JMP	opnfnc2

delete1:MOVL	EBX, #knlOpnParms
	CALL	knlOpenSetup
	JC	open8
	IFFAULT	knlQAdrErr0#
	LESL	EBX, SS:xffBuffer1#	;Get address of the name
	MOVL	EAX, SS:xffOption#	;Get command bits
	MOVL	SS:xffCmd#, EAX
	MOVL	EDI, #delete4
	JMP	parm2
.PAGE
	.SBTTL	svcIoCancel - Cancel IO for device

;Here for the svcIoCancel SVC - Cancel IO for device
;	struct type_qab qab;	// Address of QAB
;	long   bits;		// Function bits:
;				//  CAN$WAIT  =0x0100 - Wait until complete
;				//  CAN$ALLDEV=0x0080 - Cancel all requests
;				//			  for all open
;				//			  devices (qab arg.
;				//			  is ignored)
;				//  CAN$ALL   =0x0040 - Cancel all requests
;				//			  for handle
;				//  CAN$AFTER =0x0020 - Cancel specified and
;				//			  following requests
;				//  CAN$NOINT =0x0010 - Suppress IO done
;				//			  interrupts
;				//  CAN$OPEN  =0x0004 - Cancel open requests
;				//  CAN$OUTPUT=0x0002 - Cancel output queue
;				//			  requests
;				//  CAN$INPUT =0x0001 - Cancel input queue
;				//			  requests
;	rtn = svcIoCancel(&qab, bits);
;  Value returned is 0 if normal or negative error code if error.  This call
;    can wait for the canceled call(s) to complete but cannot generate an
;    interrupt when all IO has been cancelled.  Normal termination interrupts
;    will be generated for each canceled operation if CAN$NOINT is not set,
;    however.

rsvcIoCancel::
	MOVL	EBP, #pdaArg2#
	CALL	vfixaddr#
	JMP	2$.S

psvcIoCancel::
	SVCENTR	CNTIoCancel#
	ORB	SS:pdaArg1#, #03
2$:	TESTB	SS:pdaArg3#, #CAN$ALLDEV ;Want to cancel IO for all devices?
	JE	4$.S			;No
	CALL	cancelall#		;Yes - do that
	JC	8$.S
	JMP	24$			;If finished

;Here if do not want to cancel all devices

4$:	IFFAULT	knlRtnAdrEr#
	LESL	ESI, SS:pdaArg2#	;Get address of the QAB
	IFFAULT	knlRtnAdrEr#
	MOVL	EDX, ES:qab_handle.B[ESI] ;Get handle
	TOFORK
	CMPL	EDX, SS:pdaHndlNum#	;Legal device handle?
	JAE	12$.S			;No - go fail
6$:	MOVL	EBX, EDX		;Yes
	SHLL	EBX, #5t
	ADDL	EBX, SS:pdaHndlTbl#	;Yes - get offset of start of table
	MOVL	EDI, SS:[EBX]		;Get offset of the DCB
	CMPL	EDI, #0FFEh		;Is it set up yet?
	JL	12$.S			;No - fail
	JE	8$.S			;If open which was already aborted
	CMPL	EDI, #1000h
	JAE	10$.S			;If not first part of open
	MOVB	CL, SS:pdaArg3#	;Get function bits
	TESTB	SS:pdaArg3#, #CAN$OPEN	;First part of open - want to cancel
					;  open?
	JE	24$.S			;No - nothing needed here
	DECL	SS:[EBX]		;Yes - indicate aborted
8$:	JMP	22$.S			;Continue

;Here if not first part of open

10$:	MOVL	ECX, SS:4.B[EBX]	;Normal device - get command bits
	BTL	ECX, #O%NOQUE		;Closing the device?
	JC	12$.S			;Yes - this makes it invisible!
	BTL	ECX, #O%OPNCLS		;Doing second part of open?
	JNC	14$.S			;No - go on
	TESTB	SS:pdaArg3#, #CAN$OPEN	;Yes - want to cancel open?
	JE	24$.S			;No - nothing needed here
	PUSHL	#0.B			;Yes - almost like cancelling output
	JMP	18$.S

;Here if handle is not in use

12$:	FROMFORK
	MOVL	EAX, #ER_BDDVH
	STC
	RET

;Here if device is fully open

14$:	PUSHL	#0.B
	MOVB	CL, SS:pdaArg3#	;Get function bits
	TESTB	CL, #CAN$INPUT		;Want to cancel input?
	JE	16$.S			;No
	MOVL	EBX, #dcb_inpframe	;Yes
	PUSHL	ECX
	PUSHL	EDX
	PUSHL	ESI
	PUSHL	ES
	CALL	knlCancelIo#
	POPL	ES
	POPL	ESI
	POPL	EDX
	POPL	ECX
	JNC	16$.S			;Do we need to wait?
	MOVL	[ESP], EDX		;Yes
16$:	TESTB	CL, #CAN$OUTPUT		;Want to cancel output?
	JE	20$.S			;No
18$:	MOVL	EBX, #dcb_outframe	;Yes
	PUSHL	EDX
	CALL	knlCancelIo#
	POPL	EDX
	JNC	20$.S
	MOVL	[ESP], EDX
20$:	POPL	EAX
	TESTL	EAX, EAX		;Are we finished?
	JE	24$.S			;Yes
22$:	TESTB	SS:pdaArg3#+1, #CAN$WAIT>8 ;No - should we wait?
	JNE	iowait2#		;Yes
24$:	FROMFORK			;No
	CLRL	EAX
ret006:	RET
.PAGE
	.SBTTL	svcIoControl - Queued IO control functions

;Here for the svcIoControl SVC - Queued IO control functions - these
;  functions affect only active queued IO operations - the function will
;  fail with an ER_NACT (device or request not active) error if the indicated
;  request is not active
;	struct type_qab qab;	// Address of QAB
;	long   func;		// Function:
;				//   QIOC_SITO = 1 - Set input timeout
;				//   QIOC_SOTO = 2 - Set output timeout
;	long   data;		// Data value
;	rtn = svcIoControl(&qab, func, data);
;  Value returned is 0 if normal or negative error code if error

rsvcIoControl::
	MOVL	EBP, #pdaArg2#
	CALL	vfixaddr#
	JMP	4$.S

psvcIoControl::
	SVCENTR	CNTIoControl#
	ORB	SS:pdaArg1#, #03
4$:	IFFAULT	knlRtnAdrEr#
	LESL	ESI, SS:pdaArg2#	;Get address of the QAB
	IFFAULT	knlRtnAdrEr#
	MOVL	EAX, ES:qab_handle.B[ESI] ;Get handle
	CALL	knlGetDcb#		;Find the DCB
	JC	ret006.S		;If error
	MOVL	EAX, SS:pdaArg3#	;Get function
	CMPL	EAX, #CANFNCMAX		;Legal function?
	JA	knlBadFunc#		;No - fail
	JMPIL	canfncdsp[EAX*4]	;Yes - dispatch on the function

	DATA

canfncdsp:
	.LONG	knlBadFunc	;	   = 0 - Illegal
	.LONG	qiocsito	;QIOC_SITO = 1 - Set input timeout
	.LONG	qiocsoto	;QIOC_SOTO = 2 - Set output timeout
CANFNCMAX=!{$-canfncdsp}/4-1

	CODE
.PAGE
	.SBTTL	qiocsito - IOC_SITO function

;Here for the IOC_SITO function of the svcIoControl call

qiocsito:
	LEAL	EBX, dcb_inpframe.B[EDI]
	JMP	4$.S

	.SBTTL	qiocsoto - IOC_SOTO function

;Here for the IOC_SOTO function of the svcIoControl call

qiocsoto:
	LEAL	EBX, dcb_outframe.B[EDI]
4$:	CMPW	[EBX], #0.B		;Have a current IO operation?
	JE	14$			;No
	TOFORK				;Yes - raise to fork level
	CMPW	[EBX], #0.B		;Still have an IO operation?
	JE	12$.S			;No
	MOVW	ES, [EBX]		;Yes - get fork frame selector
	MOVL	EAX, SS:pdaArg2#	;Is this the current operation?
	MOVL	ECX, SS:pdaArg1#
	CMPL	ES:xffQab#+0, EAX
	JNE	12$.S			;No
	CMPW	ES:xffQab#+4, CX	;Maybe
	JNE	12$.S			;No
	MOVL	ESI, ES:xffWakeBlk#	;Yes - have a time-out now
	TESTL	ESI, ESI
	JE	6$.S			;No
	CLRL	EAX			;Yes - kill the timer
	MOVL	ES:xffWakeBlk#, EAX
	CALL	knlWakeRemove#
6$:	MOVL	EAX, SS:pdaArg4#	;Get new time-out value
	MOVL	ES:xffTimeOut#, EAX	;Save it in case device needs it
	CMPL	EAX, #-1.B		;Want any limit?
	JE	6$.S			;No
	MULL	knlLitTPD#		;Yes - change to number of ticks
	MOVL	EAX, EDX
	CMPL	EAX, #2.B		;Make sure at least 2
	JA	8$.S
	MOVB	AL, #2
8$:	MOVL	EBX, #xfwdone#
	MOVL	EDI, ES
	CALL	knlWakeRequest#		;Enter the timer request
	JC	10$.S			;If error
	MOVL	ES:xffWakeBlk#, ESI	;OK - save offset of the wake block
	CLRL	EAX			;Finished
10$:	FROMFORK
	RET

;Here if indicated request is not currently active

12$:	FROMFORK
14$:	MOVL	EAX, #ER_NACT
	RET
.PAGE
	.SBTTL	svcIoClear - Clear IO device(s)

;Here for the svcIoClear SVC - Clear IO device(s).  This funcition is
;  provided mainly for the use of the svcIoRun routine to clean up devices
;  when changing programs in the same process.  It ensures that the specified
;  device (or all devices) are not using any resources that may have been
;  given up when the process was reset for the new program.
;	long   handle;		// Device handle, 0 means all devices
;	rtn = svcIoClear(handle);
;  Value returned is 0 if normal or negative error code if error

psvcIoClear::
	SVCENTR	CNTIoClear#
rsvcIoClear::
	MOVL	EAX, SS:pdaArg1#	;Get handle
	TESTL	EAX, EAX
	JE	4$.S			;If want all devices
	CALL	knlGetDcb#		;Get DCB
	JC	2$.S			;If error
	MOVL	ESI, EAX		;OK - get handle in right register
	MOVL	EAX, dcb_sdisp.B[EDI]	;Clear the device
	CALLI	CS:sd_cleardev.B[EAX]
	CLRL	EAX
2$:	RET

;Here to clear all devices

4$:	MOVL	ESI, SS:pdaHndlTbl#	;Point to start of device table
	TESTL	ESI, ESI
	JE	10$.S
	MOVL	ECX, SS:pdaHndlNum#	;Get number of entries to check
6$:	ADDL	ESI, #32t.B		;(THIS ASSUMES THAT mb_data == 16t!)
	MOVL	EDI, SS:[ESI]		;Get next entry in table
	TESTL	EDI, EDI
	JE	8$.S			;If entry is not in use
	PUSHL	ESI			;In use
	PUSHL	ECX
	SUBL	ESI, SS:pdaHndlTbl#	;Calculate handle
	SHRL	ESI, #5
	MOVL	EAX, dcb_sdisp.B[EDI]	;Clear the device
	CALLI	CS:sd_cleardev.B[EAX]
	POPL	ECX
	POPL	ESI
8$:	LOOP	ECX, 6$			;Continue if have more
10$:	CLRL	EAX
	RET
.PAGE
	.SBTTL	svcIoGetHndlMap - Get device handle map

;Here for the svcIoGetHndlMap SVC - Get device handle map - This function
;  stores a bit-map which indicates which device handles are in use.
;	unsigned char *map;	// Address of bit map array
;	long     size;		// Size of bit map array (bytes)
;	rtn = svcIoGetHndlMap(map, size);
;  Value returned is the highest device handle in use if normal or a negative
;    error code if error.  Note that if the bit map array is not big enough
;    to hold bits for all in-use handles, only those that will fit are stored
;    and no error is reported.  This situation can be detected by checking the
;    returned value, which is the highest handle actually in use, not the
;    highest one stored in the bit map.

rsvcIoGetHndlMap::
	MOVL	EBP, #pdaArg2#
	CALL	vfixaddr#
	JMP	2$.S

psvcIoGetHndlMap::
	SVCENTR	CNTIoGetHndlMap#
	ORB	SS:pdaArg1#, #03
2$:	MOVL	ECX, SS:pdaArg3#	;Get size of his array
	CLRL	EAX
	LEAL	EDX, [EAX+ECX*8]	;Get highest handle which will fit in
	IFFAULT	knlRtnAdrEr#		;  his array
	LESL	EDI, SS:pdaArg2#	;Point to his array
	MOVL	EBX, EDI
	CLD
	IFFAULT	knlRtnAdrEr#
	RSTOSB	[EDI]			;Clear his array
	MOVL	ESI, SS:pdaHndlTbl#	;Get offset of the handle table
	ADDL	ESI, #20h.B	
	MOVL	ECX, SS:pdaHndlNum#	;Get maximum handle number
	CLRL	EBP
4$:	CMPL	SS:[ESI], #1000h	;Is this handle in use?
	JBE	6$.S			;No
	LEAL	EAX, 1.B[EBP]		;Yes - remember it
	CMPL	EBP, EDX		;Will it fit in his array?
	JAE	6$.S			;No
	IFFAULT	knlRtnAdrEr#
	BTSL	ES:[EBX], EBP		;Yes - set the bit
6$:	ADDL	ESI, #20h.B		;Advance to next handle
	INCL	EBP
	LOOP	ECX, 4$			;Continue if more to check
ret008:	RET
.PAGE
	.SBTTL	svcIoPorts - Set up IO port access

;Here for the svcIoPorts SVC - Set up IO port access for user programs.
;	long  func;		// Function: 1 = Allow access to port(s)
;				//	     2 = Don't allow access to port(s)
;	long  base;		// Base port number
;	long  num;		// Number of ports
;	rtn = svcIoPorts(func, base, size);
;  Value returned is 0 if normal or a negative error code if error.

psvcIoPorts::
	SVCENTR	CNTIoPorts#
rsvcIoPorts::
	BTL	SS:pdaActPriv#, #PP%PORTIO ;Can he do this?
	JNC	knlPrivFail#		;No - fail
	MOVL	EBX, SS:pdaArg1#	;Yes - get function
	MOVL	EAX, SS:pdaArg2#	;Get base register
	MOVL	ECX, SS:pdaArg3#	;Get number of registers

;Function to set up user mode IO port access
;	c(BL)  = Function: 1 = Allow access, 2 = Dissallow access
;	c{ES:EDI} = Address of port table
;	CALL	knlIoPorts
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlIoPorts::
	IFFAULT	knlRtnAdrEr#
	MOVZWL	ECX, ES:[EDI]
	TESTL	ECX, ECX
	JE	ret008.S
	IFFAULT	knlRtnAdrEr#
	MOVZWL	EAX, ES:2.B[EDI]
	ADDL	EDI, #4t.B
	PUSHL	EDI
	PUSHL	EBX
	CMPL	ECX, #0FFFFh		;Too big?
	JA	2$.S			;Yes
	LEAL	EDX, [EAX+ECX]		;Get highest register to affect + 1
	CMPL	EDX, #0FFFFh+1		;Too big?
2$:	JA	knlBadValue#		;Yes
	CMPB	BL, #1.B		;No - is function "allow access"?
	JNE	10$			;No
	MOVL	EBX, SS:pdaIOBmHdr#	;Yes - get current maximum value
	SUBL	EBX, #mb_data+1.B
	SHLL	EBX, #3t
	CMPL	EDX, EBX		;Need to expand the bitmap?
	JB	6$.S			;No - go on

;Here if we have to expand the IO permission bitmap

	PUSHL	ES
	PUSHL	EAX
	PUSHL	ECX
	PUSHL	EBX			;Remember the current size
	MOVL	ESI, #pdaIOBmHdr#	;Increase the size of the block
	LEAL	ECX, 8+7.B[EDX]
	SHRL	ECX, #3t
	CALL	knlChngPdaMem#
	POPL	ECX
	JC	8$.S
	CALL	setldtpos#		;Update the LDT pointers
	SHRL	ECX, #3t
	INCL	ECX
	LEAL	EDI, pdaIOBitmap#[ECX]
	SUBL	ECX, SS:pdaIOBmHdr#
	NEGL	ECX
	SUBL	ECX, #mb_data.B
	SHRL	ECX, #2t
	PUSHL	SS
	POPL	ES
	CLD
	MOVL	EAX, #-1
	RSTOSL	[EDI]
	MOVL	EAX, SS:pdaTssSel#
	MOVL	ECX, SS:pdaIOBmHdr#
	ADDL	ECX, #pdaIOBitmap#-mb_data-2
	SUBL	ECX, #pdaTss#
	MOVW	gdtable+st_limit[EAX], CX
	POPL	ECX
	POPL	EAX
	POPL	ES

;Here with the IO permission bit map big enough for this request

6$:	BTZL	SS:pdaIOBitmap#, EAX	;Clear a bit in the IO bit-map
	INCL	EAX
	LOOP	ECX, 6$
	JMP	14$.S

;Here if error expanding the bitmap

8$:	POPL	ECX			;Fix up the stack
	POPL	ECX
	POPL	EBX
	POPL	EDI
	RET

;Here if function is not 1

10$:	CMPB	BL, #2.B		;Is function "dis-allow access"?
	JNE	knlBadFunc#		;No - fail
	MOVL	EBX, SS:pdaIOBmHdr#	;Yes - get current maximum value
	SUBL	EBX, #mb_data+1.B
	SHLL	EBX, #3t
	CMPL	EDX, EBX		;Trying to clear more than we have?
	JB	12$.S			;No - go on
	MOVL	ECX, EBX		;Yes - just clear what we have
	SUBL	ECX, EAX
	JLE	14$.S			;If nothing to clear
12$:	BTSL	SS:pdaIOBitmap#, EAX	;Yes - set a bit in the IO bit-map
	INCL	EAX
	LOOP	ECX, 12$
14$:	POPL	EBX
	POPL	EDI
	JMP	knlIoPorts
.PAGE
	.SBTTL	knlOpenSetup - Subroutine to do initial set up for open

;Subroutine to do initial set up for functions which use a reduced opn_ stack
;	c{EBX}    = Offset of standard parameter table
;	CALL	knlOpeXSetup
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;  NOTE: This subroutine creates an opn stack frame on both the error and
;	   normal returns

knlOpeXSetup::
	POPL	EDX			;Get our return address
	ENTER	opn_SIZEr, 1		;Set up the level 1 stack frame
	MOVL	ECX, #opn_SIZEr/4
	JMP	4$.S

;Subroutine to do initial set up for open and related functions
;	c{EBX}    = Offset of standard parameter table
;	CALL	knlOpenSetup
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;  NOTE: This subroutine creates an opn stack frame on both the error and
;	   normal returns

knlOpenSetup::
	REQUIREXFF
	POPL	EDX			;Get our return address
	ENTER	opn_SIZE, 1		;Set up the level 1 stack frame
	MOVL	ECX, #opn_SIZE/4
4$:	PUSHL	EDX			;Put the return address back
	PUSHL	SS			;Clear the stack frame
	POPL	ES
	PUSHL	EDI
	LEAL	EDI, -8t.B[EBP]		;(this allows for a 1 item display)
	CLRL	EAX
	STD
	RSTOSL	[EDI]
	POPL	EDI
	MOVL	SS:xffPLFilSpc#+0, EAX
	MOVL	SS:xffPLFilSpc#+4, EAX
	MOVL	SS:xffPPFilSpc#+0, EAX
	MOVL	SS:xffPPFilSpc#+4, EAX
	MOVL	SS:xffPVFilOpt#, EAX
	MOVL	SS:xffHvValue1#, EAX
	MOVL	SS:xffHvValue2#, EAX
	MOVL	SS:xffNdValue1#, EAX
	MOVL	SS:xffNdValue2#, EAX
	TESTL	EBX, EBX		;Want to process parameters?
	JE	ret010.S		;No - finished now
	CMPL	SS:xffParm#, #0.B	;Yes - have any to process?
	JE	ret010.S		;No
	IFFAULT	knlRtnAdrEr#
	LFSL	EDX, SS:xffParm#	;Yes
	CLRL	ECX
	JMP	knlProcDevParm#		;Process device parameters and return
.PAGE
.SBTTL	opngetonly - Routine for parameter which cannot be set

;Routine for parameter which cannot be set and whose value will be returned
;  later

	DPARMHDR  GET, HEXV
opngetonly:
	CLC
ret010:	RET

.SBTTL	opndevsts - Routine for the IOPAR_DEVSTS parameter

;Routine for IOPAR_DEVSTS parameter - Device status

	DPARMHDR  GET, DECV
opndevsts:
	BTSL	SS:xffNdValue1#, #IOV1%DEVSTS ;Indicate need value
	CLC				;Thats all
	RET

.SBTTL	opnunitnum - Routine for the IOPAR_UNITNUM parameter

;Routine for IOPAR_UNITNUM parameter - Unit number

	DPARMHDR  GET, DECV
opnunitnum:
	BTSL	SS:xffNdValue1#, #IOV1%UNITNUM ;Indicate need value
	CLC				;Thats all
	RET

.SBTTL	opngblid - Routine for the IOPAR_GBLID parameter

;Routine for IOPAR_GBLID parameter - Global ID

	DPARMHDR  GET, DECV
opngblid:
	BTSL	SS:xffNdValue1#, #IOV1%GLBID ;Indicate need value
	CLC				;Thats all
	RET

.SBTTL	opndirhndl - Routine for IOPAR_DIRHNDL parameter

;Routine for IOPAR_DIRHNDL parameter - Directory handle for search

	DPARMHDR  SET, DECV
opndirhndl::
	CALL	knlGetParm#
	JC	ret010.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_dirhndl.B[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%DIRHNDL
	TESTL	EDX, EDX
	JE	knlStrParm4#
	JMP	knlBadParmV#

.SBTTL	opndirofs - Routine for IOPAR_DIROFS parameter

;Routine for IOPAR_DIROFS parameter - Directory offset for directory search

	DPARMHDR  BOTH, DECV
opndirofs::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	2$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm#		;Get value
	JC	8$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_dirofs+0.B[ESI], EAX
	MOVL	SS:opn_dirofs+4.B[ESI], EDX
	POPL	EAX
	BTSL	SS:xffHvValue1#, #IOV1%DIROFS
2$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	10$.S			;No
	BTSL	SS:xffNdValue1#, #IOV1%DIROFS ;Yes
	JMP	clrparm

8$:	POPL	EDX
10$:	RET
.PAGE
.SBTTL	opnabspos - Routine for IOPAR_ABSPOS parameter

;Routine for the IOPAR_ABSPOS parameter - Absolute position in file

	DPARMHDR  BOTH, DECV
opnabspos::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	6$.S			;No
	BTSL	SS:xffHvValue1#, #IOV1%ABSPOS
	ANDL	SS:xffHvValue1#, #~{IOV1$RELPOS|IOV1$EOFPOS}
	JMP	4$.S

.SBTTL	opnrelpos - Routine for IOPAR_RELPOS parameter

;Routine for the IOPAR_RELPOS parameter - Relative position in file

	DPARMHDR  BOTH, DECV
opnrelpos::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	6$.S			;No
	ORL	SS:xffHvValue1#, #IOV1$ABSPOS|IOV1$RELPOS ;Yes
	BTZL	SS:xffHvValue1#, #IOV1%EOFPOS
	JMP	4$.S

.SBTTL	opneofpos - Routine for IOPAR_EOFPOS parameter

;Routine for the IOPAR_EOFPOS parameter - Position in file relative to EOF

	DPARMHDR  BOTH, DECV
opneofpos::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	6$.S			;No
	ORL	SS:xffHvValue1#, #IOV1$ABSPOS|IOV1$EOFPOS ;Yes
	BTZL	SS:xffHvValue1#, #IOV1%RELPOS
4$:	PUSHL	EAX
	CALL	knlGetParm#		;Get value
	JC	8$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_iopos.B[ESI], EAX
	POPL	EAX
	TESTL	EDX, EDX
	JNE	knlBadParmV#
6$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	10$.S			;No
	BTSL	SS:xffNdValue1#, #IOV1%ABSPOS ;Yes
	JMP	clrparm.S

8$:	POPL	EDX
10$:	RET
.PAGE
.SBTTL	opnlength - Routine for IOPAR_LENGTH parameter

;Routine for IOPAR_LENGTH parameter - Written length of file

	DPARMHDR  BOTH, DECV
opnlength::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	PUSHL	EAX
	CALL	knlGetParm#		;Yes - get value
	JC	rtnpedx.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_length.B[ESI], EAX
	POPL	EAX
	TESTL	EDX, EDX
	JNE	knlBadParmV#
	BTSL	SS:xffHvValue1#, #IOV1%LENGTH
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	rtn016.S		;No
	BTSL	SS:xffNdValue1#, #IOV1%LENGTH ;Yes
	JMP	clrparm.S
.PAGE
.SBTTL	opnreqalloc - Routine for IOPAR_REQALLOC parameter

;Routine for IOPAR_REQALLOC parameter - Request file allocation

	DPARMHDR  BOTH, DECV
opnreqalloc::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	PUSHL	EAX
	CALL	knlGetParm#		;Yes - get value
	JC	rtnpedx.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_reqalloc.B[ESI], EAX
	POPL	EAX
	TESTL	EDX, EDX
	JNE	knlBadParmV#
	BTSL	SS:xffHvValue1#, #IOV1%REQALLOC
4$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	rtn016.S		;No
	BTSL	SS:xffNdValue1#, #IOV1%REQALLOC ;Yes
clrparm:CLRL	EAX			;Clear the value
	JMP	knlStrParm4#

rtnpedx:POPL	EDX
rtn016:	RET

.SBTTL	opnrqralloc - Routine for IOPAR_RQRALLOC parameter

;Routine for IOPAR_RQRALLOC parameter - Require file allocation

	DPARMHDR  BOTH, DECV
opnrqralloc::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	12$.S			;No
	PUSHL	EAX			;Yes
	CALL	knlGetParm#		;Get value
	JC	rtnpedx.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_rqralloc.B[ESI], EAX
	POPL	EAX
	TESTL	EDX, EDX
	JNE	knlBadParmV#
	BTSL	SS:xffHvValue1#, #IOV1%RQRALLOC
12$:	TESTB	AH, #PAR$GET		;Want value returned?
	JE	rtn016.S		;No
	BTSL	SS:xffNdValue1#, #IOV1%RQRALLOC ;Yes
	JMP	clrparm.S
.PAGE
.SBTTL	opngrpsize - Routine for IOPAR_GRPSIZE parameter

;Routine for IOPAR_GRPSIZE parameter - Allocation group size

	DPARMHDR  BOTH, DECV
opngrpsize::
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	1$.S			;No
	BTSL	SS:xffNdValue1#, #IOV1%GRPSIZE ;Yes
1$:	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Yes - get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_grpsize.B[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%GRPSIZE
2$:	TESTL	EDX, EDX
3$:	JNE	knlBadParmV#
4$:	RET

.SBTTL	opnprot - Routine for IOPAR_PROT parameter

;Routine for IOPAR_PROT parameter - File protection

	DPARMHDR  BOTH, DECV
opnprot::
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	6$.S			;No
	BTSL	SS:xffNdValue1#, #IOV1%PROT ;Yes
6$:	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_prot.B[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%PROT
	CLC
	RET

.SBTTL	opnsrcattr - Routine for IOPAR_SRCATTR parameter

;Routine for IOPAR_SRCATTR parameter - File attributes for directory search

	DPARMHDR  SET, HEXV
opnsrcattr::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Yes - get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVB	SS:opn_srcattr.B[ESI], AL
	BTSL	SS:xffHvValue1#, #IOV1%SRCATTR
8$:	TESTL	EAX, #0FFFFFF00
	JNE	3$.S
	JMP	2$.S

.SBTTL	opnfilattr - Routine for IOPAR_FILATTR parameter

;Routine for IOPAR_FILATTR parameter - File attributes for file

	DPARMHDR  BOTH, HEXV
opnfilattr::
	TESTB	AH, #PAR$GET		;Want to get value?
	JE	10$.S			;No
	BTSL	SS:xffNdValue1#, #IOV1%FILATTR ;Yes
10$:	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Yes - get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_filattr.B[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%FILATTR
	JMP	8$.S
.PAGE
.SBTTL	opnadate - Routine for IOPAR_ADATE parameter

;Routine for IOPAR_ADATE parameter - Last access date/time

	DPARMHDR  BOTH, HEXV
opnadate::
	MOVL	ESI, opn_frame1.B[EBP]
	ANDB	SS:opn_datefmt.B[ESI], #~DF$DOSADATE ;Assume not DOS format
	CMPL	ECX, #4.B		;Right?
	JA	2$.S			;Yes
	ORB	SS:opn_datefmt.B[ESI], #DF$DOSADATE ;No
2$:	TESTB	AH, #PAR$GET		;Want to get value?
	JE	4$.S			;No
	BTSL	SS:xffNdValue1#, #IOV1%ADATE ;Yes
4$:	TESTB	AH, #PAR$SET		;Want to set value?
	JE	6$.S			;No
	BTSL	SS:xffHvValue1#, #IOV1%ADATE ;Yes
	CALL	knlGetParm#		;Get value
	JC	6$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK - store value for later
	MOVL	SS:opn_adate+0.B[ESI], EAX
	MOVL	SS:opn_adate+4.B[ESI], EDX
	ORL	EAX, EDX		;Really have a value?
	JNE	6$.S			;Yes
	ANDL	SS:xffHvValue1#, #~IOV1$ADATE ;No
6$:	RET

.SBTTL	opncdate - Routine for IOPAR_CDATE

;Routine for IOPAR_CDATE parameter - Creation date/time

	DPARMHDR  BOTH, HEXV
opncdate::
	MOVL	ESI, opn_frame1.B[EBP]
	ANDB	SS:opn_datefmt.B[ESI], #~DF$DOSCDATE ;Assume not DOS format
	CMPL	ECX, #4.B		;Right?
	JA	8$.S			;Yes
	ORB	SS:opn_datefmt.B[ESI], #DF$DOSCDATE ;No
8$:	TESTB	AH, #PAR$GET		;Want to get value?
	JE	10$.S			;No
	BTSL	SS:xffNdValue1#, #IOV1%CDATE ;Yes
10$:	TESTB	AH, #PAR$SET		;Want to set value?
	JE	12$.S			;No
	BTSL	SS:xffHvValue1#, #IOV1%CDATE ;Yes
	CALL	knlGetParm#		;Get value
	JC	12$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK - store value for later
	MOVL	SS:opn_cdate+0.B[ESI], EAX
	MOVL	SS:opn_cdate+4.B[ESI], EDX
	ORL	EAX, EDX		;Really have a value?
	JNE	12$.S			;Yes
	ANDL	SS:xffHvValue1#, #~IOV1$CDATE ;No
12$:	RET

.SBTTL	oopnmdate - Routine for IOPAR_MDATE parameter

;Routine for IOPAR_MDATE parameter - Modify date/time

	DPARMHDR  BOTH, HEXV
opnmdate::
	MOVL	ESI, opn_frame1.B[EBP]
	ANDB	SS:opn_datefmt.B[ESI], #~DF$DOSMDATE ;Assume not DOS format
	CMPL	ECX, #4.B		;Right?
	JA	14$.S			;Yes
	ORB	SS:opn_datefmt.B[ESI], #DF$DOSMDATE ;No
14$:	TESTB	AH, #PAR$GET		;Want to get value?
	JE	16$.S			;No
	BTSL	SS:xffNdValue1#, #IOV1%MDATE ;Yes
16$:	TESTB	AH, #PAR$SET		;Want to set value?
	JE	18$.S			;No
	BTSL	SS:xffHvValue1#, #IOV1%MDATE ;Yes
	CALL	knlGetParm#		;Get value
	JC	18$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK - store value for later
	MOVL	SS:opn_mdate+0.B[ESI], EAX
	MOVL	SS:opn_mdate+4.B[ESI], EDX
	ORL	EAX, EDX		;Really have a value?
	JNE	18$.S			;Yes
	ANDL	SS:xffHvValue1#, #~IOV1$MDATE ;No
18$:	RET
.PAGE
.SBTTL	opnowner - Routine for IOPAR_OWNNER parameter

;Routine for IOPAR_OWNNER parameter - Owner name

	DPARMHDR  BOTH, STR
opnowner::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	6$.S			;No
	MOVL	EDX, opn_frame1.B[EBP]
	ADDL	EDX, #opn_owner
	MOVB	AH, #33t
	IFFAULT	knlRtnAdrEr#
2$:	MOVB	AL, ES:[EBX]
	INCL	EBX
	CMPB	AL, #0
	JE	4$.S
	DECB	AH
	JS	knlBadParmV#
	MOVB	SS:[EDX], AL
	INCL	EDX
	LOOP	ECX, 2$
4$:	MOVB	SS:[EDX], #0
	BTSL	SS:xffHvValue1#, #IOV1%OWNER
6$:	RET
.PAGE
.SBTTL	opnsetlock - Routine for IOPAR_SETLOCK parameter

;Routine for IOPAR_SETLOCK parameter  - Set file lock

	DPARMHDR  SET, DECV
opnsetlock:
	TESTL	SS:xffHvValue1#, #IOV1$SETLOCK|IOV1$CLRLOCK
	JNE	2$.S
	BTSL	SS:xffHvValue1#, #IOV1%SETLOCK
	JMP	4$.S

.SBTTL	opnclrlock - Routine for IOPAR_CLRLOCK parameter

;Routine for IOPAR_CLRLOCK parameter - Clear file lock

	DPARMHDR  SET, DECV
opnclrlock:
	TESTL	SS:xffHvValue1#, #IOV1$SETLOCK|IOV1$CLRLOCK
2$:	JNE	knlBadParmI#
	BTSL	SS:xffHvValue1#, #IOV1%CLRLOCK
4$:	CMPL	ECX, #8t.B		;Is it the right size?
	JNE	knlBadParmS#		;No - fail
	CALL	knlGetParm#		;Yes - get value
	JC	6$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK - store value
	MOVL	SS:opn_lockval+0.B[ESI], EAX
	MOVL	SS:opn_lockval+4.B[ESI], EDX
6$:	RET
.PAGE
.SBTTL	opnclstime - Routine for IOPAR_CLSTIME parameter

;Routine for IOPAR_CLSTIME parameter - Close timer value

	DPARMHDR  SET, DECV
opnclstime:
	CMPB	SS:xffFunc#, #QFNC_OPEN ;Really an open?
	JNE	knlBadParmI#		;No - fail
	CALL	knlGetParm#		;Yes - get his value
	JC	4$.S
	CALL	knlGetCab#		;Get a CAB
	JC	4$.S
	CMPL	cab_time.B[ESI], #0.B	;Already have a close time value?
	JNE	4$.S			;Yes - forget this!
	ADDL	EAX, #XT_SECOND-1	;No - change value to seconds
	CLRL	EDX
	DIVL	litXTSEC#
	TESTL	EAX, #0FFFF0000h
	JNE	knlBadParmV#
	MOVW	cab_time.B[ESI], AX	;Store time value
	MOVW	AX, SS:xffPda#		;Also store our PDA selector
	MOVW	cab_pda.B[ESI], AX
	MOVW	AX, SS:xffHandle#	;Store device handle
	MOVW	cab_handle.B[ESI], AX
4$:	RET
.PAGE
.SBTTL	opnclsname - Routine for IOPAR_CLSNAME parameter

;Here for the IOPAR_CLSNAME parameter for opens

$$$=!0
FRM clss_frame1, 4t
FRM clss_offset, 4t
FRM clss_max   , 4t
clss_SIZE=!$$$

	DPARMHDR  SET, STR
opnclsname:
	MOVL	EAX, #cab_clsname
	MOVL	ECX, #32t
	JMP	2$.S

.SBTTL	opnclsmsg - Routine for IOPAR_CLSMSG parameter

;Here for the IOPAR_CLSNAME parameter for opens

	DPARMHDR  SET, STR
opnclsmsg:
	MOVL	EAX, #cab_clsmsg
	MOVL	ECX, #16t
2$:	CMPB	SS:xffFunc#, #QFNC_OPEN ;Really an open?
	JNE	knlBadParmI#		;No - fail
	ENTER	clss_SIZE, 2
	MOVL	clss_offset.B[EBP], EAX
	MOVL	clss_max.B[EBP], ECX
	PUSHL	EDI			;Get length of the string
	MOVL	EDI, EBX
	CLD
	IFFAULT	12$
	RNSCASB	[EDI]
	POPL	EDI
	NOTL	ECX
	CMPL	ECX, #1.B		;Really have a string?
	JBE	6$.S			;No - nothing needed here
	PUSHL	ECX
	CALL	knlGetCab#		;Yes - get a CAB
	POPL	ECX
	JC	8$.S			;If error
	CMPB	cab_clsname.B[ESI], #0	;Already have a close name?
	JNE	6$.S			;Yes - ignore this
	CMPL	ECX, clss_max.B[EBP]
	JBE	4$.S
	MOVL	ECX, clss_max.B[EBP]
4$:	PUSHL	EDI
	MOVL	EDI, ESI
	ADDL	EDI, clss_offset.B[EBP]
	PUSHL	ES
	POPL	FS
	PUSHL	DS
	POPL	ES
	PUSHL	ESI
	MOVL	ESI, EBX
	CLD
	IFFAULT	10$
	RMOVSB	[EDI], FS:[ESI]		;Copy the close name to the CAB
	POPL	ESI
	POPL	EDI
6$:	CLC
8$:	LEAVE
	RET				;Finished

	FAULTHDR
10$:	POPL	ESI

	FAULTHDR
12$:	POPL	EDI
	JMP	knlRtnAdrErLv#
.PAGE
.SBTTL	opnshrparms - Routine for IOPAR_SHRPARMS parameter

;Routine for IOPAR_SHRPARMS parameter - File sharing parameters

	DPARMHDR  BOTH, DECV
opnshrparms:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_shrparms.B[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%SHRPARMS
	CLC
4$:	RET
.PAGE
.SBTTL	opnprotocol - Routine for IOPAR_PROTOCOL parameter

;Routine for IOPAR_PROTOCOL parameter - Network protocol

	DPARMHDR  BOTH, DECV
opnprotocol::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_protocol[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%PROTOCOL
	CLC
4$:	RET

.SBTTL	opnlclport - Routine for IOPAR_NETLCLPORT parameter

;Routine for IOPAR_NETLCLPORT parameter - Network local port number

	DPARMHDR  BOTH, DECV
opnlclport::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_lclport[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%LCLPORT
	CLC
	RET

.SBTTL	opnrmtports - Routine for IOPAR_NETRMTPORTS parameter

;Routine for IOPAR_NETRMTPORTS parameter - Network remote port number

	DPARMHDR  BOTH, DECV
opnrmtports::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_rmtports[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%RMTPORTS
	CLC
	RET

.SBTTL	opnrmtnetas - Routine for IOPAR_NETRMTNETAS parameter

;Routine for IOPAR_NETRMTNETAS parameter - Network remote network address

	DPARMHDR  BOTH, DECV
opnrmtnetas::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Get value
	JC	4$.S
	MOVL	ESI, opn_frame1.B[EBP]
	MOVL	SS:opn_rmtnetas[ESI], EAX
	BTSL	SS:xffHvValue1#, #IOV1%RMTNETAS
	CLC
	RET
.PAGE
.SBTTL	opnconlimit - Routine for IOPAR_NETCONLIMIT parameter

;Routine for IOPAR_NETCONLIMIT parameter - Incoming connection request queue
;  limit

	DPARMHDR  SET, DECV
opnconlimit:
	CALL	knlGetParm#
	JC	6$.S
	CMPL	EAX, #0FFFFh
	JB	4$.S
	MOVL	EAX, #0FFFFh
4$:	MOVW	opn_conlimit[EBP], AX
	CLC
6$:	RET

.SBTTL	opnconhndl - Routine for IOPAR_NETCONHNDL parameter

;Routine for IOPAR_NETCONHNDL parameter - Handle for incoming connections

	DPARMHDR  SET, DECV
opnconhndl:
	CALL	knlGetParm#
	JC	6$.S
	CMPL	EAX, #0FFFFh
	JA	knlBadValue#
	MOVW	opn_conhndl[EBP], AX
	CLC
	RET
.PAGE
.SBTTL	opnrmtaddrs - Routine for IOPAR_MSGRMTADDRS parameter

;Routine for IOPAR_MSGRMTADDRS parameter - Network remote network address

	DPARMHDR  BOTH, STR
opnrmtaddrs::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	MOVL	ESI, opn_frame1.B[EBP]	     ;Yes - store the necessary stuff
	MOVL	SS:opn_vrmtaddrs+0[ESI], EBX ;  for later
	MOVL	SS:opn_vrmtaddrs+4[ESI], ES
	MOVW	SS:opn_lrmtaddrs[ESI], CX
	MOVL	SS:opn_srmtaddrs+0[ESI], EDX
	MOVL	SS:opn_srmtaddrs+4[ESI], FS
	BTSL	SS:xffHvValue2#, #IOV2%RMTADDRS
	CLC
4$:	RET
.PAGE
.SBTTL	opninpqlmt - Routine to process IOPAR_INPQLMT parameter

;Routine to process IOPAR_INPQLMT parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	opninpqlmt

	DPARMHDR  BOTH, DECV
opninpqlmt::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Yes - get his value
	JC	4$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK
	MOVB	SS:opn_inpqlmt.B[ESI], AL ;Store new value
4$:	RET

.SBTTL	opnoutqlmt - Routine to process IOPAR_OUTQLMT parameter

;Routine to process IOPAR_OUTQLMT parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	opnoutqlmt

	DPARMHDR  BOTH, DECV
opnoutqlmt::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Yes - get his value
	JC	4$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK
	MOVB	SS:opn_outqlmt.B[ESI], AL ;Store new value
	RET

	.SBTTL	opnbufrlmt - Routine to process IOPAR_BUFRLMT parameter

;Routine to process IOPAR_BUFRLMT parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	opnbufrlmt

	DPARMHDR  BOTH, DECV
opnbufrlmt::
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Yes - get his value
	JC	4$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK
	MOVB	SS:opn_bufrlmt.B[ESI], AL ;Store new value
	RET
.PAGE
	.SBTTL	opnvect1 - Routine to process IOPAR_VECT1 parameter

;Routine to process IOPAR_VECT1 parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	opnvect1

	DPARMHDR  BOTH, DECV
opnvect1:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Yes - get his value
	JC	4$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK
	MOVW	SS:opn_vect1num.B[ESI], AX ;Store new value
	MOVW	AX, SS:xffPda#		;Also store our PDA selector
	MOVW	SS:opn_vect1pda.B[ESI], AX
4$:	RET

	.SBTTL	opnvect2 - Routine to process IOPAR_VECT2 parameter

;Routine to process IOPAR_VECT2 parameter for all devices
;	c{ES:EBX} = Address of value
;	c{ECX}    = Length of the value
;	CALL	opnvect2

	DPARMHDR  BOTH, DECV
opnvect2:
	TESTB	AH, #PAR$SET		;Want to set value?
	JE	4$.S			;No
	CALL	knlGetParm#		;Yes - get his value
	JC	4$.S			;If error
	MOVL	ESI, opn_frame1.B[EBP]	;OK
	MOVW	SS:opn_vect2num.B[ESI], AX ;Store new value
	MOVW	AX, SS:xffPda#		;Also store our PDA selector
	MOVW	SS:opn_vect2pda.B[ESI], AX
	ret
.PAGE
.SBTTL	opnfstype - Routine for IOPAR_FSTYPE parameter

;Routine for IOPAR_FSTYPE parameter - File system type

	DPARMHDR GET, DECV
opnfstype:
	BTSL	SS:xffNdValue2#, #IOV2%FSTYPE ;Indicate need value
	CLC
	RET

.SBTTL	opnsectsize - Routine for IOPAR_SECTSIZE parameter

;Routine for IOPAR_SECTSIZE parameter - Sector size

	DPARMHDR GET, DECV
opnsectsize:
	BTSL	SS:xffNdValue2#, #IOV2%SECTSIZE ;Indicate need value
	CLC
	RET

.SBTTL	opnclssize - Routine for IOPAR_CLSSIZE parameter

;Routine for IOPAR_CLSSIZE parameter - Cluster size

	DPARMHDR GET, DECV
opnclssize:
	BTSL	SS:xffNdValue2#, #IOV2%CLSSIZE ;Indicate need value
	CLC
	RET

.SBTTL	opnttlspace - Routine for IOPAR_TTLSPACE parameter

;Routine for IOPAR_TTLSPACE parameter - Total space

	DPARMHDR GET, DECV
opnttlspace:
	BTSL	SS:xffNdValue2#, #IOV2%TTLSPACE ;Indicate need value
	CLC
	RET

.SBTTL	opnavlspace - Routine for IOPAR_AVLSPACE parameter

;Routine for IOPAR_AVLSPACE parameter - Available space

	DPARMHDR GET, DECV
opnavlspace:
	BTSL	SS:xffNdValue2#, #IOV2%AVLSPACE ;Indicate need value
	CLC
	RET

.SBTTL	opnnumhead - Routine for IOPAR_NUMHEAD parameter

;Routine for IOPAR_NUMHEAD parameter - Number of heads

	DPARMHDR GET, DECV
opnnumhead:
	BTSL	SS:xffNdValue2#, #IOV2%NUMHEAD ;Indicate need value
	CLC
	RET

.SBTTL	opnnumsect - Routine for IOPAR_NUMSECT parameter

;Routine for IOPAR_NUMSECT parameter - Number of sectors

	DPARMHDR GET, DECV
opnnumsect:
	BTSL	SS:xffNdValue2#, #IOV2%NUMSECT ;Indicate need value
	CLC
	RET

.SBTTL	opnnumcyln - Routine for IOPAR_NUMCYLN parameter

;Routine for IOPAR_NUMCYLN parameter - Number of cylinders

	DPARMHDR GET, DECV
opnnumcyln:
	BTSL	SS:xffNdValue2#, #IOV2%NUMCYLN ;Indicate need value
	CLC
	RET
.PAGE
;Subroutine to allocate a device handle
;	C{EBX} = Handle value at which to start search (bit 31 set to force use
;		   of specified handle)
;	CALL	knlGetHandle
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EBX} = Handle

gethandle::
	MOVZWL	EBX, BX
	TESTL	EAX, EAX
	JE	4$.S
	CMPB	BH, #0			;Valid starting handle?
	JNE	4$.S			;No - fail
	MOVL	EAX, SS:pdaHndlTbl#	;Is the table big enough?
	MOVL	EAX, SS:[EAX]
	SHRL	EAX, #5t
	CMPL	EBX, EAX
	JB	2$.S			;Yes - go on
	MOVL	ECX, EBX		;No - expand it
	ADDL	ECX, #15t		;Round up to multiple of 16
	ANDL	ECX, #0FFFFFFF0h.B
	PUSHL	EBX
	CALL	exphndltbl
	POPL	EBX
	JC	6$.S
2$:	MOVL	ECX, SS:pdaHndlNum#	;Calculate number to check
	SUBL	ECX, EBX
	INCL	ECX
	SHLL	EBX, #5t		;Point to first slot to check
	ADDL	EBX, SS:pdaHndlTbl#
	ADDL	EBX, #32t.B
	BTZL	EBX, #31t		;Forcing a handle?
	JNC	8$.S			;No
	CMPL	SS:[EBX], #0.B		;Yes - is it in use?
	JE	14$.S			;No - go use it
	CMPL	SS:[EBX], #0FFEh	;Maybe not
	JE	14$.S			;OK
4$:	MOVL	EAX, #ER_BDDVH
	STC
6$:	RET

;Here to search handle table

8$:	CMPL	SS:[EBX], #0.B		;Is this slot in use?
	JE	14$.S			;No - found one!
	ADDL	EBX, #32t.B		;Yes - bump to next
	LOOP	ECX, 8$			;Continue if more to check
	MOVL	ECX, SS:pdaHndlNum#
	CMPL	ECX, #MAXHNDLS		;Can we have some more handles?
	JB	12$.S			;Yes - go on
	MOVL	EAX, #ER_TMDVP		;Error = Too Many DeVices open for
	STC
10$:	RET

;Here if we can expand the handle table

12$:	SUBL	EBX, SS:pdaHndlTbl#	;Calculate handle offset
	PUSHL	EBX
	ADDL	ECX, #16t.B		;Increase number of handles by 16
	CALL	exphndltbl
	POPL	EBX
	JC	10$.S
	ADDL	EBX, SS:pdaHndlTbl#
14$:	MOVL	SS:[EBX], #0FFFh	;Indicate this slot has been allocated
	SUBL	EBX, SS:pdaHndlTbl#	;Calculate handle
	SHRL	EBX, #5
	RET
.PAGE
;Subroutine to expand the handle table
;	c{ECX} = New size
;	CALL	exphndltbl
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

2$:	POPL	ECX
hndlter:POPL	ESI
	FROMFORK			;If error
	STC
	RET

exphndltbl:
	PUSHL	ESI
	PUSHL	ECX
	SHLL	ECX, #5t		;Get new space needed
	ADDL	ECX, #32t-mb_data.B
	MOVL	ESI, SS:pdaHndlTbl#	;Get offset of handle table
	PUSHL	SS:[ESI]		;Save current size
	TOFORK
	CALL	knlChngPdaMem#		;Expand the table
	POPL	EDX
	JC	2$.S
	FROMFORK
	LEAL	EDI, [ESI+EDX]		;Point to start of new space
	PUSHL	SS
	POPL	ES
	MOVL	ECX, SS:[ESI]
	SUBL	ECX, EDX		;Get size of new area
	SHRL	ECX, #2t
	CLD
	CLRL	EAX			;Clear the new space
	RSTOSL	[EDI]
	POPL	ECX
	MOVL	SS:pdaHndlNum#, ECX	;Store new size of the handle table
	POPL	ESI
	CLC
	RET

	END
