	.TITLE	USRDOS1 - XOS user level DOS kernel routines

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTRM.PAR

	USERCODE

;Here when the protected mode DOS routine is finished and we want to set or
;  clear C and no protected mode stack change is needed

rmudonec::
	JC	2$.S
	ANDB	dff_EFR.B[EBP], #~01h
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to real mode

2$:	ORB	dff_EFR.B[EBP], #01h

;Here when the protected mode DOS routine is finished and we do not want to
;  change C and no protected mode stack change is needed

rmudone::
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to real mode

;The routines in this module are implement various DOS INT 21 functions.  They
;  are executed in protected 32 bit user mode.

	.SBTTL	uputchar - INT 29 - DOS fast character output

;Here for INT 29 - DOS fast character output

uputchar::
	PUSHL	#DH_STDTRM.B
	PUSHL	dff_EAX.B[EBP]
	CALLF	svcIoOutSingle#
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	ucoutput - INT 21 function 02 - Character output

;Here for INT 21 function 02 - Character output
;	c(AH) = 02h
;	c(DL) = Output data
;	INT	21h
;	Nothing is returned!

$$$=!0
FRM cout_qab , qab_SIZE
FRM cout_bufr, 4t
cout_SIZE=!$$$

ucoutput::
	SUBL	ESP, #cout_SIZE.B
	MOVB	cout_bufr.B[EBP], DL	;Store character to output
	MOVL	EBX, #1
	CALL	ugetsyshndl2#		;Get XOS handle for standard in
	JC	4$.S			;If error
	MOVL	cout_qab+qab_handle.B[EBP], EAX
	MOVL	cout_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_OUTBLOCK
	CLRL	EAX
	MOVW	cout_qab+qab_vector.B[EBP], AX
	MOVL	cout_qab+qab_parm+0.B[EBP], EAX
	INCL	EAX
	MOVL	cout_qab+qab_count.B[EBP], EAX
	LEAL	EAX, cout_bufr.B[EBP]
	MOVL	cout_qab+qab_buffer1+0.B[EBP], EAX
	MOVL	cout_qab+qab_buffer1+4.B[EBP], SS
	PUSHL	SS
	LEAL	EAX, cout_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
4$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	uainput - INT 21 function 03 - Auxiliary input

;Here for INT 21 function 03 - Auxiliary input
;	c(AH) = 03h
;	INT	21h
;	c(AL) = Input data

$$$=!0
FRM axfr_qab    , qab_SIZE
FRM axfr_doshndl, 4t
FRM axfr_parm   , 20t
FRM axfr_buffer , 4t
axfr_SIZE=!$$$

uainput::
	SUBL	ESP, #axfr_SIZE.B
	MOVL	EBX, #3
	CALL	ugetsyshndl2#		;Get XOS handle for DOS handle 3
	JC	6$.S			;If error
	MOVL	axfr_qab+qab_handle.B[EBP], EAX
	MOVW	uvci_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_INBLOCK
	LEAL	EAX, axfr_buffer.B[EBP]	;Store buffer address
	MOVL	axfr_qab+qab_buffer1+0.B[EBP], EAX
	MOVW	axfr_qab+qab_buffer1+4.B[EBP], SS
	LEAL	EAX, axfr_parm.B[EBP]
	MOVL	axfr_qab+qab_parm+0.B[EBP], EAX
	MOVL	axfr_qab+qab_parm+4.B[EBP], SS
	MOVL	axfr_parm+0t.B[EBP], -
		  #{PAR$SET|REP_HEXV}+{4<8}+{IOPAR_TRMCINPMODE<16t}
	MOVL	axfr_parm+4t.B[EBP], #0FFFFFFFFh
	MOVL	axfr_parm+8t.B[EBP], -
		  #{PAR$SET|REP_HEXV}+{4<8}+{IOPAR_TRMSINPMODE<16t}
	MOVL	axfr_parm+12t.B[EBP], #TIM$XIMAGE
	MOVL	axfr_qab+qab_count.B[EBP], #1
	CLRL	EAX
	MOVW	axfr_qab+qab_vector.B[EBP], AX
	MOVB	axfr_parm+16t.B[EBP], AL
	PUSHL	SS
	LEAL	EAX, axfr_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	6$.S
	ORL	EAX, axfr_qab+qab_error.B[EBP]
	JS	6$.S
	MOVB	AL, axfr_buffer.B[EBP]	;Get character input
4$:	MOVB	dff_EAX.B[EBP], AL	;Give it to him
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if error - return 0FFh

6$:	MOVB	AL, #0FFh
	JMP	4$.S
.PAGE
	.SBTTL	uaoutput - INT 21 function 04 - Auxiliary output

;Here for INT 21 function 04 - Auxiliary output
;	c(AH) = 04h
;	c(DL) = Output data
;	INT	21h
;	Nothing is returned!

uaoutput::
	MOVL	EBX, #3
	JMP	2$.S

	.SBTTL	upoutput - INT 21 function 05 - Printer output

;Here for INT 21 function 05 - Printer output
;	c(AH) = 05h
;	c(DL) = Output data
;	INT	21h
;	Nothing is returned! Errors are NOT reported!!

upoutput::
	MOVL	EBX, #4
2$:	SUBL	ESP, #axfr_SIZE.B
	MOVB	axfr_buffer.B[EBP], DL	;Store character to output
	MOVL	axfr_doshndl.B[EBP], EBX ;Save DOS handle used
	CALL	ugetsyshndl2#		;Get Allegor handle for DOS handle
	JC	6$.S			;If error
	MOVL	axfr_qab+qab_handle.B[EBP], EAX
	MOVW	uvci_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_OUTBLOCK
	LEAL	EAX, axfr_buffer.B[EBP]	;Store buffer address
	MOVL	axfr_qab+qab_buffer1+0.B[EBP], EAX
	MOVW	axfr_qab+qab_buffer1+4.B[EBP], SS
	LEAL	EAX, axfr_parm.B[EBP]
	MOVL	axfr_qab+qab_parm+0.B[EBP], EAX
	MOVL	axfr_qab+qab_parm+4.B[EBP], SS
	MOVL	axfr_parm+0t.B[EBP], -
		  #{PAR$SET|REP_HEXV}+{4<8}+{IOPAR_TRMCOUTMODE<16t}
	MOVL	axfr_parm+4t.B[EBP], #0FFFFFFFFh
	MOVL	axfr_parm+8t.B[EBP], -
		  #{PAR$SET|REP_HEXV}+{4<8}+{IOPAR_TRMSOUTMODE<16t}
	MOVL	axfr_parm+12t.B[EBP], #TOM$IMAGE
	MOVB	axfr_parm+16t.B[EBP], #0
	MOVL	axfr_qab+qab_count.B[EBP], #1
	MOVW	axfr_qab+qab_vector.B[EBP], #0
	PUSHL	SS
	LEAL	EAX, axfr_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
6$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	ucinput - INT 21 function 01 - Character input with echo

;Here for INT 21  function 01 - Character input with echo
;	c(AH) = 01h
;	INT	21h
;	c(AL) = Input character

$$$=!0
FRM uvci_qab , qab_SIZE
FRM uvci_parm, 36t
FRM uvci_bufr, 4t
uvci_SIZE=!$$$

ucinput::
	SUBL	ESP, #uvci_SIZE.B
	MOVL	uvci_parm+12t.B[EBP], -
		  #TIM$PCSCNC|TIM$PC101|TIM$PCDOS|TIM$ECHO|TIM$CHAR
	JMP	2$.S

	.SBTTL	uicinne - INT 21 function 07 - Image character input without echo

;Here for INT 21  function 07 - Image character input without echo
;	c(AH) = 07h
;	INT	21h
;	c(AL) = Input character

uicinne::
	SUBL	ESP, #uvci_SIZE.B
	MOVL	uvci_parm+12t.B[EBP], #TIM$PCSCNC|TIM$PC101|TIM$PCDOS
	MOVL	uvci_parm+16t.B[EBP], -
		  #{PAR$SET|REP_HEXV}+{4<8}+{IOPAR_TRMSINPMODE<16t}
	MOVL	uvci_parm+20t.B[EBP], #TIM$XIMAGE
	MOVB	uvci_parm+24t.B[EBP], #0
	JMP	4$.S

	.SBTTL	ucinne - INT 21 function 08 - Character input without echo

;Here for INT 21  function 08 - Character input without echo
;	c(AH) = 08h
;	INT	21h
;	c(AL) = Input character

ucinne::SUBL	ESP, #uvci_SIZE.B
	MOVL	uvci_parm+12t.B[EBP], #TIM$PCSCNC|TIM$PC101|TIM$PCDOS|TIM$CHAR
2$:	MOVB	uvci_parm+16t.B[EBP], #0
4$:	LEAL	EAX, uvci_parm.B[EBP]
	MOVL	uvci_qab+qab_parm+0.B[EBP], EAX
	MOVL	uvci_qab+qab_parm+4.B[EBP], SS
	MOVL	uvci_parm+0t.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMCINPMODE<16t}
	MOVL	uvci_parm+4t.B[EBP], #0FFFFFFFFh
	MOVL	uvci_parm+8t.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMSINPMODE<16t}
	MOVW	uvci_qab+qab_vector.B[EBP], #0
	MOVW	uvci_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_INBLOCK
	LEAL	EAX, uvci_bufr.B[EBP]
	MOVL	uvci_qab+qab_buffer1+0.B[EBP], EAX
	MOVL	uvci_qab+qab_buffer1+4.B[EBP], SS
	MOVL	uvci_qab+qab_count.B[EBP], #1
	CLRL	EBX
	CALL	ugetsyshndl2#		;Get XOS handle for standard in
	JC	10$.S			;If error
	MOVL	uvci_qab+qab_handle.B[EBP], EAX
	PUSHL	SS
	LEAL	EAX, uvci_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX		;Error?
	JS	10$.S			;Yes
	ORL	EAX, uvci_qab+qab_error.B[EBP] ;Maybe
	JS	10$.S		;Yes
	MOVB	AL, uvci_bufr.B[EBP]	;No
8$:	MOVB	dff_EAX.B[EBP], AL	;Return the character
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if eror on input

10$:	MOVL	dxd_lasterr, EAX	;Save error code
	MOVB	AL, #0FFh
	JMP	8$.S
.PAGE
	.SBTTL	ubinput - INT 21 function 0A - buffered input

;Here for INT 21  function 0A - buffered input
;	c(AH)    = 0Ah
;	c[DS:DX] = Address of buffer
;		     1st byte = Size of buffer (set by caller)
;		     2nd byte = Amount input (set by system)
;		     3rd byte = Start of data buffer
;	INT	21h

$$$=!0
FRM uvbi_qab , qab_SIZE
FRM uvbi_parm, 36t
uvbi_SIZE=!$$$

TIMCLR=!TIM$ANSI7|TIM$ANSI8|TIM$NOCC|TIM$SCNCODE|TIM$SCNALL|TIM$ILFACR
TIMSET=!TIM$PCSCNC|TIM$PC101|TIM$PCDOS

ubinput::
	SUBL	ESP, #uvbi_SIZE.B
	LEAL	EAX, uvbi_parm.B[EBP]
	MOVL	uvbi_qab+qab_parm+0.B[EBP], EAX
	MOVL	uvbi_qab+qab_parm+4.B[EBP], SS
	MOVL	uvbi_parm+0.B[EBP], #{PAR$SET|REP_TEXT}+{4<8}+ -
		  {IOPAR_CLASS<16t}
	MOVL	uvbi_parm+4.B[EBP], #'TRM'
	MOVL	uvbi_parm+8.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMCINPMODE<16t}
	MOVL	uvbi_parm+12t.B[EBP], #TIMCLR
	MOVL	uvbi_parm+16t.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMSINPMODE<16t}
	MOVL	uvbi_parm+20t.B[EBP], #TIMSET
	MOVL	uvbi_parm+24t.B[EBP], #{PAR$SET|REP_DECV}+{1<8}+ -
		  {IOPAR_TRMBFRLIMIT<16t}
	CALL	getDSEDXaddr#		;Get address of buffer
	ADDL	ESI, #2t.B
	MOVL	uvbi_qab+qab_buffer1+0.B[EBP], ESI
	MOVL	uvbi_qab+qab_buffer1+4.B[EBP], FS
	MOVZBL	EAX, FS:-2.B[ESI]	;Get size of the buffer
	MOVW	uvbi_parm+28t.B[EBP], AX
	MOVL	uvbi_qab+qab_count.B[EBP], EAX
	MOVW	uvbi_qab+qab_vector.B[EBP], AX
	MOVW	uvbi_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_INBLOCK
	CLRL	EBX
	CALL	ugetsyshndl2#		;Get XOS handle for standard in
	JC	2$.S			;If error
	MOVL	uvbi_qab+qab_handle.B[EBP], EAX
	PUSHL	SS
	LEAL	EAX, uvbi_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#		;Input the line
	TESTL	EAX, EAX		;Error?
	JS	2$.S			;Yes - say no input
	ORL	EAX, uvbi_qab+qab_error.B[EBP] ;Maybe
	JNS	6$.S			;No
2$:	CMPL	EAX, #ER_PARMV.B	;Yes - did it fail because the device
	JNE	4$.S			;  is not a terminal?
	TESTB	uvbi_parm+0.B[EBP], #PAR$ERROR
	JNE	binput2.S		;Yes
4$:	MOVB	AL, #0			;No - just say no input!
	JMP	8$.S

;Here if no errors on input

6$:	MOVL	EAX, uvbi_qab+qab_amount.B[EBP] ;Get amount input
	DECL	EAX			;Minus one
8$:	MOVB	FS:-1.B[ESI], AL	;Give him the amount input
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
;Here if device is not a terminal - in this case we must do this the hard way
;  and emulate inputting a line from a terminal by doing single character
;  inputs in a loop!

binput2:LEAL	EAX, uvbi_parm.B[EBP]	;Use parameter list as an input buffer
	MOVL	uvbi_qab+qab_buffer1+0.B[EBP], EAX
	MOVL	uvbi_qab+qab_buffer1+4.B[EBP], SS
	CLRL	EAX
	MOVL	uvbi_qab+qab_parm+0.B[EBP], EAX ;No parameter list
	MOVB	ES:-1.B[EDI], AL	;Clear his count
	INCL	EAX			;Input single characters
	MOVL	uvbi_qab+qab_count.B[EBP], EAX
	MOVL	EBX, EDX
4$:	PUSHL	SS
	LEAL	EAX, uvbi_qab.B[EBP]	;Get one character
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	8$.S
	ORL	EAX, uvbi_qab+qab_error.B[EBP]
	JS	8$.S			;If error
	CMPB	uvbi_parm+0.B[EBP], #CR	;Is this a carriage-return chracter?
	JE	4$.S			;Yes - ignore it!
	CMPB	uvbi_parm+0.B[EBP], #LF	;No - is this a line-feed character?
	JE	10$.S			;Yes
	MOVB	AL, ES:-1.B[EDI]	;No - can he take another character?
	INCL	EAX
	CMPB	AL, ES:-2.B[EDI]
	JAE	4$.S			;No - just ignore this one
	MOVB	AL, uvbi_parm+0.B[EBP]	;Yes - give him the character
	MOVB	ES:[EBX], AL
	INCL	EBX			;Bump his pointer
	INCB	ES:-1.B[EDI]		;Bump his count
	JMP	4$.S			;Continue

;Here if error on input - finish it off with a null and give him what we have

8$:	MOVB	ES:[EBX], #0
	JMP	12$.S

;Here with line-feed character

10$:	MOVB	ES:[EBX], #CR		;Put CR at the end of his buffer
12$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	uconio INT 21 function 06 - Direct console IO

;Here for INT 21 function 06 - Direct console IO
;	c(AH) = 06h
;	c(DL) = 0FFh if input request, character to output otherwise
;	INT	21h
;	c(AL) = ASCII character if input request and character is available or
;		  0 if input request and nothing is available (waits until
;		  character is available if console is not a terminal)
;	Nothing is returned if output request!

$$$=!0
FRM uvdio_qab , qab_SIZE
FRM uvdio_parm, 36t
FRM uvdio_bufr, 4t
uvdio_SIZE=!$$$

uconio::SUBL	ESP, #uvdio_SIZE.B
	LEAL	EAX, uvdio_bufr.B[EBP]
	MOVL	uvdio_qab+qab_buffer1+0.B[EBP], EAX
	MOVL	uvdio_qab+qab_buffer1+4.B[EBP], SS
	LEAL	EAX, uvdio_parm.B[EBP]
	MOVL	uvdio_qab+qab_parm+0.B[EBP], EAX
	MOVL	uvdio_qab+qab_parm+4.B[EBP], SS
	CMPB	DL, #0FFh		;Input request?
	JNE	10$			;No - output
	MOVL	uvdio_parm+0t.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMCINPMODE<16t}
	MOVL	uvdio_parm+4t.B[EBP], #0FFFFFFFFh
	MOVL	uvdio_parm+8t.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMSINPMODE<16t}
	MOVL	uvdio_parm+12t.B[EBP], #TIM$PCSCNC|TIM$PC101|TIM$PCDOS
	MOVL	uvdio_parm+16t.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMSINPMODE<16t}
	MOVL	uvdio_parm+20t.B[EBP], #TIM$XIMAGE
	MOVL	uvdio_parm+24t.B[EBP], #{PAR$SET|REP_DECV}+{4<8}+ -
		  {IOPAR_TIMEOUT<16t}
	CLRL	EAX
	MOVL	uvdio_parm+28t.B[EBP], EAX
	MOVB	uvdio_parm+32t.B[EBP], AL
	MOVW	uvdio_qab+qab_vector.B[EBP], AX
	INCL	EAX
	MOVL	uvdio_qab+qab_count.B[EBP], EAX
	MOVW	uvdio_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_INBLOCK
	CLRL	EBX
	CALL	ugetsyshndl2#		;Get XOS handle for standard in
	JC	2$.S			;If error
	MOVL	uvdio_qab+qab_handle.B[EBP], EAX
	PUSHL	SS
	LEAL	EAX, uvdio_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX		;Error?
	JS	2$.S			;Yes
	ORL	EAX, uvdio_qab+qab_error.B[EBP] ;Maybe
	JNS	4$.S			;No
2$:	ORL	dff_EFR.B[EBP], #40h.B	;Set Z to indicate no input
	JMP	12$.S

;Here if have input

4$:	MOVB	AL, uvdio_bufr.B[EBP]
	MOVB	dff_EAX.B[EBP], AL
	ANDL	dff_EFR.B[EBP], #~40h.B	;Clear Z to indicate have input
	JMP	12$.S

;Here if want to do output

10$:	MOVB	uvdio_bufr.B[EBP], DL	;Store character to output
	MOVL	uvdio_parm+0t.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMCOUTMODE<16t}
	MOVL	uvdio_parm+4t.B[EBP], #0FFFFFFFFh
	MOVL	uvdio_parm+8t.B[EBP], #{PAR$SET|REP_HEXV}+{4<8}+ -
		  {IOPAR_TRMSOUTMODE<16t}
	MOVL	uvdio_parm+12t.B[EBP], #TOM$IMAGE
	MOVB	uvdio_parm+16t.B[EBP], #0
	MOVW	uvdio_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_OUTBLOCK
	MOVL	EBX, #1
	MOVL	uvdio_qab+qab_count.B[EBP], EBX
	CALL	ugetsyshndl2#		;Get XOS handle for standard out
	JC	12$.S			;If error
	MOVL	uvdio_qab+qab_handle.B[EBP], EAX
	MOVW	uvdio_qab+qab_vector.B[EBP], #0
	PUSHL	SS
	LEAL	EAX, uvdio_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
12$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	ugtists - INT 21 function 0B - Get console input status

;Here for INT 21 function 0B - Get console input status
;	c(AH) = 0Bh
;	INT	21h
;	c(AL) = Status:
;		  0    = Nothing available
;		  0FFh = At least one character available

ugtists::
	CLRL	EBX			;Use DOS handle 0
	JMP	ioctlgis#		;Continue
.PAGE
	.SBTTL	ucincta - INT 21 function 0C - Clear console type-ahead and input character

;Here for INT 21 function 0C - Clear console type-ahead and input character
;	c(AL) = INT 21 function to do after clearing buffer (01h, 06h, 07h,
;		  08h, or 0Ah)
;	C(AH) = 0Ch
;	INT	21h
;	If called with c(AL) = 0Ah:
;	  Nothing is returned!
;	Otherwise:
;	  c(AL) = Input data

$$$=!0
FRM uvcin_qab , qab_SIZE
FRM uvcin_parm, 36t
FRM uvcin_bufr, 4t
uvcin_SIZE=!$$$

ucincta::
	SUBL	ESP, #uvcin_SIZE.B
	MOVW	uvcin_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_INBLOCK
	CLRL	EBX			;Assume want STDIN
	CMPB	AL, #06			;Right?
	JNE	2$.S			;Yes
	CMPB	DL, #0FFh		;Maybe
	JE	2$.S			;Yes
	INCL	EBX			;No - use STDOUT
2$:	CALL	ugetsyshndl2#		;Get the XOS handle
	JC	citdone.S		;Do nothing if error
	MOVL	uvcin_qab+qab_handle.B[EBP], EAX
	CLRL	EAX
	MOVL	uvcin_qab+qab_buffer1+0.B[EBP], EAX
	MOVL	uvcin_qab+qab_count.B[EBP], EAX
	MOVW	uvcin_qab+qab_vector.B[EBP], AX
	LEAL	EDI, uvcin_parm.B[EBP]
	MOVL	uvcin_qab+qab_parm+0.B[EBP], EDI
	MOVL	uvcin_qab+qab_parm+4.B[EBP], DS
	MOVL	uvcin_parm+0t.B[EBP], -
		  #{PAR$SET|REP_HEXV}|{1<8}|{IOPAR_TRMCLRBUFR<16t}
	MOVL	uvcin_parm+4t.B[EBP], #CB$INPUT|CB$AHEAD
	PUSHL	SS
	LEAL	EAX, uvcin_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	MOVL	ESP, EBP
	MOVZBL	EAX, dff_EAX.B[EBP]	;Get secondary function
	CMPB	AL, #0Ah		;Valid value?
	JA	citdone.S		;No - do nothing else
	JMPIL	CS:cittbl[EAX*4]	;Yes - dispatch to next routine

citdone:POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user


;Dispatch table for secondary function

	.MOD	4
cittbl:	.LONG	citdone		; 0 - Illegal
	.LONG	ucinput		; 1 - Character input with echo
	.LONG	citdone		; 2 - Illegal
	.LONG	citdone		; 3 - Illegal
	.LONG	citdone		; 4 - Illegal
	.LONG	citdone		; 5 - Illegal
	.LONG	uconio		; 6 - Direct console IO
	.LONG	uicinne		; 7 - Unfiltered character input without echo
	.LONG	ucinne		; 8 - Character input without echo
	.LONG	citdone		; 9 - Illegal
	.LONG	ubinput		; A - Buffered keyboard input
.PAGE
	.SBTTL	uoutstr - INT 21 function 09 - Output character string to console display

;Here for INT 21 function 09 - Output character string to console display
;	c(AH) = 09h
;	c[DS:DX] = Address of string to output (string is terminated by $)
;	INT	21h
;	Nothing is returned!

$$$=!0
FRM outs_qab , qab_SIZE
outs_SIZE=!$$$

uoutstr::
	SUBL	ESP, #outs_SIZE.B
	MOVW	outs_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_OUTBLOCK
	MOVL	EBX, #1			;Get STDOUT
	CALL	ugetsyshndl2#
	JC	8$.S			;If error
	MOVL	outs_qab+qab_handle.B[EBP], EAX ;Store XOS handle
	CALL	getDSEDXaddr#		;Get user's buffer address
	MOVL	outs_qab+qab_buffer1+0.B[EBP], ESI ;Store buffer address
	MOVL	outs_qab+qab_buffer1+4.B[EBP], FS
	MOVL	EDI, ESI
	PUSHL	FS
	POPL	ES
	MOVL	ECX, #-1		;Get length of string
	MOVB	AL, #'$'
	CLD
	RNSCASB	[EDI]
	NOTL	ECX
	DECL	ECX
	MOVL	outs_qab+qab_count.B[EBP], ECX
	CLRL	EAX
	MOVL	outs_qab+qab_parm+0.B[EBP], EAX
	MOVW	outs_qab+qab_vector.B[EBP], AX
	PUSHL	SS
	LEAL	EAX, outs_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
8$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	useldisk - INT 21 function 0E - Select disk

;Here for INT 21 function 0E - Select disk
;	c(AH) = 0Eh
;	c(DL) = Drive code (0 = A, 1 = B, etc.)
;	INT	21h
;	c(AL) = Number of logical drives in system (always 25)

$$$=!0
FRM seld_name , 8t		;Name being defined
FRM seld_defin, 4t		;Definition string
seld_SIZE=!$$$

useldisk::
	SUBL	ESP, #seld_SIZE.B
	MOVL	seld_name+0.B[EBP], #'Z:'
	CLRL	EAX
	MOVL	seld_name+4.B[EBP], EAX
	MOVB	AL, dff_EDX.B[EBP]	;Get drive number
	CMPB	AL, #19h		;Is it valid?
	JA	4$.S			;No - just return number of disks
	ADDB	AL, #'A'		;Yes - change to name
	MOVB	AH, #':'
	MOVL	seld_defin.B[EBP], EAX	;Store it
	PUSHL	#8000h
	PUSHL	#0.B
	PUSHL	SS
	LEAL	EAX, seld_name.B[EBP]
	PUSHL	EAX
	PUSHL	SS
	LEAL	EAX, seld_defin.B[EBP]
	PUSHL	EAX
	CALLF	svcIoDefLog#		;Define the logical name
4$:	MOVB	dff_EAX.B[EBP], #25t	;Give him the number of "logical disks"
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	ugtdftd - INT 21 function 19 - Get default disk drive

;Here for INT 21 function 19 - Get default disk drive
;	c(AH) = 19h
;	INT	21
;	c(AL) = Drive code (0=A:, 1=B:, etc.)

$$$=!0
FRM gtdd_buffer, 20t
gtdd_SIZE=!$$$

ugtdftd::
	SUBL	ESP, #gtdd_SIZE.B
	CALL	dosgetdftd
	MOVB	dff_EAX.B[EBP], AL
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Subroutine to index for default disk
;	CALL	dosgetdftd
;	c{EAX} = Disk index

dosgetdftd::
	PUSHL	#TNB$DOSNAME.B
	PUSHL	CS
	PUSHL	#dftname
	PUSHL	SS
	LEAL	EAX, gtdd_buffer.B[EBP]
	PUSHL	EAX
	PUSHL	#20t.B
	CALLF	svcIoTransName#
	TESTL	EAX, EAX
	MOVL	EAX, #'Z'-'A'
	JS	4$.S
	CMPB	gtdd_buffer+1.B[EBP], #':' ;Single character name?
	JNE	4$.S			;No
	MOVB	AL, gtdd_buffer+0.B[EBP] ;Yes - get it
	SUBB	AL, #'A'		;Change to index
4$:	RET

dftname:.ASCIZ	"Z:"
.PAGE
	.SBTTL	ufcbcreate - INT 21 function 16 - Create or truncate file using FCB

;Here for INT 21 function 16 - Create or truncate file using FCB
;	c(AH)    = 16h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0    = Normal
;		  0FFh = Error

$$$=!0
FRM fcbo_qab   , qab_SIZE	;QAB
FRM fcbo_parm  , 64t		;Parameter list buffer
FRM fcbo_name  , 16t		;File name buffer
FRM fcbo_handle, 4		;FCB handle
fcbo_SIZE=!$$$

CRTBITS=!O$COMPAT|O$CREATE|O$TRUNCW|O$USEDOS|O$NOLONG|O$CRIT|O$IN|O$OUT

ufcbcreate::
	SUBL	ESP, #fcbo_SIZE
	MOVL	fcbo_qab+qab_option.B[EBP], #CRTBITS
	JMP	2$.S

	.SBTTL	ufcbopen - INT 21 function 0F - Open file using FCB

;Here for INT 21 function 0F - Open file using FCB
;	c(AH)    = 0Fh
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0    = Normal
;		  0FFh = Error

OPNBITS=!O$CRIT|O$COMPAT|O$USEDOS|O$NOLONG|O$IN|O$OUT

ufcbopen::
	SUBL	ESP, #fcbo_SIZE
	MOVL	fcbo_qab+qab_option.B[EBP], #OPNBITS
2$:	CALL	fcbsetup		;Do initial setup
	JC	10$.S			;If error
	MOVZBL	ECX, dxd_fcbnum		;Get size of the FCB table
	CLRL	EAX			;Initialize index
4$:	INCL	EAX			;Bump index
	CMPB	dxd_fcbtbl[EAX*4], #0FFh ;Is this one free?
	JE	14$			;Yes - go use it
	LOOP	ECX, 4$			;No - continue if more to check
	MOVZBL	EAX, dxd_fcbtbl+fcbh_prev
	CMPB	AL, #0			;None available - scan the list of FCB
	JE	8$.S			;  handles and find the "oldest" one
	CMPB	AL, dxd_fcbnum		;  which has not been written to
	JA	8$.S			;Make sure valid value
	MOVZBL	ECX, dxd_fcbnum		;Get maximum number of entires
	SUBB	CL, dda_lolpfcb		;Minus number protected
6$:	DECL	ECX			;Make sure not too many
	JS	8$.S			;If table corrupted or no unprotected
					;  entries available
	TESTB	dxd_fcbtbl+fcbh_flags[EAX*4], #01h ;Has it been written to?
	JE	12$.S			;No - go steal it!
	MOVB	AL, dxd_fcbtbl+fcbh_prev[EAX*4] ;Yes - get next one
	CMPB	AL, dxd_fcbnum		;Make sure valid value
	JA	8$.S
	CMPB	AL, #0			;Any more?
	JNE	6$.S			;Yes - go check next one
8$:	MOVL	EAX, #ER_TMDVP		;If none we can steal, fail! (also get
10$:	MOVL	dxd_lasterr, EAX	;  here if the table has been corrupted)
	MOVB	dff_EAX.B[EBP], #0FFh
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here with an FCB handle we can steal

12$:	MOVZBL	ECX, dxd_fcbtbl+fcbh_prev[EAX*4] ;Get previous handle
	CMPB	CL, dxd_fcbnum		;Make sure valid value
	JA	6$.S
	MOVZBL	EDX, dxd_fcbtbl+fcbh_next[EAX*4] ;Get next handle
	CMPB	DL, dxd_fcbnum		;Make sure valid value
	JA	6$.S
	MOVB	dxd_fcbtbl+fcbh_next[ECX*4], DL ;Unlink it
	MOVB	dxd_fcbtbl+fcbh_prev[EDX*4], CL
	MOVL	fcbo_handle[EBP], EAX	;Store FCB handle
	MOVZBL	EAX, dxd_fcbtbl+fcbh_handle[EAX*4]
	MOVL	fcbo_qab+qab_handle.B[EBP], EAX
	PUSHL	fcbo_qab+qab_option.B[EBP]
	CLRL	EAX
	MOVL	fcbo_qab+qab_option.B[EBP], EAX
	MOVW	fcbo_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_CLOSE
	PUSHL	SS			;Close the device
	LEAL	EAX, fcbo_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	POPL	fcbo_qab+qab_option.B[EBP]
	JMP	16$.S			;Continue

;Here with a free FCB handle slot found

14$:	MOVL	fcbo_handle[EBP], EAX	;Store FCB handle
16$:	MOVW	fcbo_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_OPEN
	PUSHL	SS
	LEAL	EAX, fcbo_qab.B[EBP]	;Open the file
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX		;OK?
18$:	JS	10$			;No - fail
	ORL	EAX, fcbo_qab+qab_error.B[EBP] ;Maybe
	JS	18$.S			;No
	MOVL	EDX, fcbo_handle[EBP]	;Yes - get FCB handle allocated
	MOVL	EAX, fcbo_qab+qab_handle.B[EBP]   ;Store XOS handle in FCB
	MOVB	dxd_fcbtbl+fcbh_handle[EDX*4], AL ;  handle table
	MOVZBL	EAX, dxd_fcbtbl+fcbh_next ;Link it in
	MOVB	dxd_fcbtbl+fcbh_next[EDX*4], AL
	MOVB	dxd_fcbtbl+fcbh_prev[EDX*4], #0
	MOVB	dxd_fcbtbl+fcbh_next, DL
	MOVB	dxd_fcbtbl+fcbh_prev[EAX*4], DL
	MOVB	fcb_fcbhndl.B[ESI], DL	;Store FCB handle in the FCB
	CMPB	[ESI], #0		;Was a device specified?
	JNE	24$.S			;Yes - go on
	CALL	dosgetdftd		;No - get index for default disk
	INCL	EAX			;Make it 1 based
	MOVB	[ESI], AL		;Store device index in his FCB
24$:	MOVL	fcb_curblock.B[ESI], #800000h ;Store record size (80h) and
					      ;  current block (0)
	MOVL	EAX, fcbo_parm+22t.B[EBP] ;Get the file length
	TESTB	fcbo_parm+9.B[EBP], #A$DIRECT ;Is it a directory?
	JE	26$.S			;No
	CLRL	EAX			;Yes - report length as 0 like DOS
26$:	MOVL	fcb_filesize.B[ESI], EAX ;Give him the file length
	MOVL	EAX, fcbo_parm+14t.B[EBP] ;Get the file date and time
	RORL	EAX, #16t
	MOVL	fcb_filedate.B[ESI], EAX ;Give him the date and time
	CLRL	EAX
	MOVL	fcb_currec.B[ESI], EAX	;Clear record number fields
dosOK0:	MOVB	dff_EAX.B[EBP], #0
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	ufcbclose - INT 21 function 10 - Close file using FCB

;Here for INT 21 function 10 - Close file using FCB
;	c(AH)    = 10h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0    = Normal
;		  0FFh = Error

$$$=!0
FRM fcbc_qab, qab_SIZE
fcbc_SIZE=!$$$

ufcbclose::
	SUBL	ESP, #fcbc_SIZE.B
	MOVZWL	ESI, DX			;Get offset of his FCB
	MOVZWL	EAX, dff_DS.B[EBP]
	SHLL	EAX, #4
	ADDL	ESI, EAX
	MOVZBL	EAX, fcb_fcbhndl.B[ESI]	;Get FCB handle
	CMPB	AL, dxd_fcbnum		;Make sure valid value
	JA	10$.S			;Not much we can do if not valid!
	TESTL	EAX, EAX
	JE	10$.S
	MOVZBL	ECX, dxd_fcbtbl+fcbh_prev[EAX*4] ;Get previous handle
	CMPB	CL, dxd_fcbnum		;Make sure valid value
	JA	6$.S
	MOVZBL	EDX, dxd_fcbtbl+fcbh_next[EAX*4] ;Get next handle
	CMPB	DL, dxd_fcbnum		;Make sure valid value
	JA	6$.S
	MOVB	dxd_fcbtbl+fcbh_next[ECX*4], DL ;Unlink this handle
	MOVB	dxd_fcbtbl+fcbh_prev[EDX*4], CL
6$:	MOVZBL	EAX, dxd_fcbtbl+fcbh_handle[EAX*4] ;Get the XOS handle
	MOVB	dxd_fcbtbl+fcbh_handle[EAX*4], #0FF ;Mark this FCB handle as
						    ;  available
	MOVW	fcbc_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_CLOSE
	MOVL	fcbc_qab+qab_handle.B[EBP], EAX
	CLRL	EAX
	MOVL	fcbc_qab+qab_option.B[EBP], EAX
	MOVL	fcbc_qab+qab_parm+0.B[EBP], EAX
	MOVW	fcbc_qab+qab_vector.B[EBP], AX
	PUSHL	SS
	LEAL	EAX, fcbc_qab.B[EBP]
	PUSHL	EAX			;Close the file
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	12$.S
	ORL	EAX, fcbc_qab+qab_error.B[EBP]
	JS	12$.S
	JMP	dosOK0

;Here if the FCB handle is invalid

10$:	MOVL	EAX, #ER_BDDVH
12$:	MOVL	dxd_lasterr, EAX
	MOVB	dff_EAX.B[EBP], #0FFh
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	ufcbsread - INT 21 function 14 - Sequential read using FCB

;Here for INT 21 function 14 - Sequential read using FCB
;	c(AH)    = 14h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0 = Normal
;		  1 = End of file
;		  2 = Segment wrap
;		  3 = Partial record read at end of file

$$$=!0
FRM fcbx_qab   , qab_SIZE	;QAB
FRM fcbx_parm  , 36t		;Parameter list buffer
fcbx_SIZE=!$$$

ufcbsread::
	SUBL	ESP, #fcbx_SIZE.B
	MOVL	fcbx_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_INBLOCK
	CALL	fcbsioset		;Do initial setup
	CALL	fcbread			;Read the data
	JC	fcbrerr			;If error
fcbsr2:	INCB	fcb_currec.B[ESI]	;Bump record number
	JNS	12$.S			;If still in same block
	MOVB	fcb_currec.B[ESI], #0	;Start next block
	INCW	fcb_curblock.B[ESI]
12$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	ufcbswrite - INT 21 function 15 - Sequential write using FCB

;Here for INT 21 function 15 - Sequential write using FCB
;	c(AH)    = 15h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0 = Normal
;		  1 = Disk full
;		  2 = Segment wrap

ufcbswrite::
	SUBL	ESP, #fcbx_SIZE.B
	MOVL	fcbx_qab+qab_func.B[EBP], -
		  #QFNC$WAIT|QFNC$DIO|QFNC_OUTBLOCK
	CALL	fcbsioset		;Do initial setup
	CALL	fcbwrite
	JNC	fcbsr2.S		;Go finish up if OK
	JMP	fcbxerr			;If error
.PAGE
	.SBTTL	ufcbmread - INT 21 function 27 - Multiple record random read using FCB

;Here for INT 21 function 27 - Multiple record random read using FCB
;	c(AH)    = 27h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0 = Normal
;		  1 = End of file
;		  2 = Segment wrap
;		  3 = Partial record read at end of file
;		  4 = Other IO error
;	c[CX] = Actual number of records read

ufcbmread::
	MOVZWL	ECX, CX			;Get number of records to read
	JMP	2$.S			;Do the transfer

	.SBTTL	ufcbrread - INT 21 function 21 - Random read using FCB

;Here for INT 21 function 21 - Random read using FCB
;	c(AH)    = 21h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0 = Normal
;		  1 = End of file
;		  2 = Segment wrap (address error)
;		  3 = Partial record read at end of file
;		  4 = Other IO error

ufcbrread::
	MOVL	ECX, #1
2$:	SUBL	ESP, #fcbx_SIZE.B
	MOVL	fcbx_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_INBLOCK
	CALL	fcbrioset		;Do initial setup
	CALL	fcbread
	JC	fcbrerr
	MOVL	ECX, EAX
	MOVZWL	EDI, fcb_recsize.B[ESI]	;Get record size
	TESTL	EDI, EDI		;Make sure not 0
	JE	ufcbrdone.S
	LEAL	EAX, -1.B[ECX+EDI]	;See how many records we got
	CLRL	EDX
	DIVL	EDI
	MULL	EDI			;Change back to bytes
	CMPL	EAX, ECX		;Did we get a partial record?
	JE	ufcbrdone.S		;No - finished here
	PUSHL	EAX			;Yes - save amount read rounded up
	LESL	EDI, fcbx_qab+qab_buffer1+0.B[EBP] ;Get first location to zero
	ADDL	EDI, ECX
	SUBL	EAX, ECX		;Get number of bytes to zero
	MOVL	ECX, EAX
	CLRL	EAX
	CLD
	RSTOSB	[EDI]			;Zero the rest of the record
	POPL	ECX
ufcbrdone:
	CMPB	dff_EAX+1.B[EBP], #27h	;Multiple record transfer?
	JB	12$.S			;No
	MOVL	EAX, ECX		;Yes - get number of records transfered
	MOVZWL	ECX, FS:fcb_recsize.B[ESI]
	CLRL	EDX
	DIVL	ECX
	MOVW	dff_ECX.B[EBP], AX	;Return number of records
	ADDL	FS:fcb_ranrec.B[ESI], EAX ;Bump random record number
12$:	CALL	fcbsetrec		;Setup current block and record in FCB
14$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if error on input

fcbrerr:CMPL	EAX, #ER_EOF		;End of file?
	JNE	fcbxerr.S		;No
	MOVB	dff_EAX.B[EBP], #1	;Yes
	JMP	20$.S

fcbxerr:MOVB	dff_EAX.B[EBP], #4
20$:	MOVL	dxd_lasterr, EAX
	JMP	14$.S
.PAGE
	.SBTTL	ufcbmwrite - INT 21 function 28 - Multiple record random write using FCB

;Here for INT 21 function 28 - Multiple record random write using FCB
;	c(AH)    = 28h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0 = Normal
;		  1 = Disk full
;		  2 = Segment wrap
;		  4 = Other IO error
;	c[CX] = Actual number of records written

ufcbmwrite::
	MOVZWL	ECX, CX			;Get number of records to write
	JMP	2$.S			;Do the transfer

	.SBTTL	ufcbrwrite - INT 21 function 22 - Random write using FCB

;Here for INT 21 function 22 - Random write using FCB
;	c(AH)    = 22h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0 = Normal
;		  1 = Disk full
;		  2 = Segment wrap
;		  4 = Other IO error

ufcbrwrite::
	MOVL	ECX, #1.B
2$:	SUBL	ESP, #fcbx_SIZE.B
	MOVL	fcbx_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_OUTBLOCK
	CALL	fcbrioset		;Do initial setup
	CALL	fcbwrite
	JC	fcbxerr
	MOVL	ECX, EAX		;Get count in right register
	JMP	ufcbrdone		;Go finish up
.PAGE
	.SBTTL	ufcbdel - INT 21 function 13 - Delete file using FCB

;Here for INT 21 function 13 - Delete file using FCB
;	c(AH)    = 13h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0    = Normal
;		  0FFh = Error

$$$=!0
FRM fcbd_qab   , qab_SIZE	;QAB
FRM fcbd_parm  , 64t		;Parameter list buffer
FRM fcbd_name  , 16t		;File name buffer
fcbd_SIZE=!$$$

ufcbdel::
	SUBL	ESP, #fcbd_SIZE
	CALL	fcbsetup		;Do initial setup
	MOVL	fcbd_qab+qab_option.B[EBP], #O$CRIT|O$USEDOS|O$NOLONG
	MOVW	fcbd_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_DELETE
	CALL	fcbchkwild		;Check for wild-card characters
	JC	8$.S			;If error
	PUSHL	SS
	LEAL	EAX, fcbd_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue
	TESTL	EAX, EAX
	JS	8$.S			;If error
	ORL	EAX, fcbd_qab+qab_error.B[EBP]
	JS	8$.S
	MOVB	dff_EAX.B[EBP], #0	;OK - indicate success
6$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if error

8$:	MOVB	dff_EAX.B[EBP], #4
	MOVL	dxd_lasterr, EAX
	JMP	6$.S
.PAGE
	.SBTTL	ufcbrename - INT 21 function 17 - Rename file using FCB

;Here for INT 21 function 17 - Rename file using FCB
;	c(AH)    = 17h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0    = Normal
;		  0FFh = Error

;NOTE:	XOS does NOT support rename using wild card characters!

$$$=!0
FRM fcbr_qab   , qab_SIZE	;QAB
FRM fcbr_parm  , 64t		;Parameter list buffer
FRM fcbr_name  , 16t		;File name buffer
FRM fcbr_newn  , 16t		;New file name
fcbr_SIZE=!$$$

ufcbrename::
	SUBL	ESP, #fcbr_SIZE
	CALL	fcbsetup		;Do initial setup
	PUSHL	ESI
	ADDL	ESI, #17t.B		;Point to new name in the FCB
	LEAL	EDI, fcbr_newn[EBP] ;Point to place for new name
	MOVL	fcbr_qab+qab_buffer2+0.B[EBP], EDI
	MOVL	fcbr_qab+qab_buffer2+4.B[EBP], SS
	CALL	fcbset2			;Set up the new name
	POPL	ESI
	JC	8$.S			;If error
	MOVL	fcbr_qab+qab_option.B[EBP], #O$CRIT|O$USEDOS|O$NOLONG
	MOVW	fcbd_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_RENAME
	PUSHL	SS
	LEAL	EAX, fcbd_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue
	TESTL	EAX, EAX
	JS	8$.S			;If error
	ORL	EAX, fcbd_qab+qab_error.B[EBP]
	JS	8$.S
	MOVB	dff_EAX.B[EBP], #0	;OK - indicate success
6$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if error

8$:	MOVB	dff_EAX.B[EBP], #4
	MOVL	dxd_lasterr, EAX
	JMP	6$.S
.PAGE
	.SBTTL	ufcbsffm - INT 21 function 11 - Search for first match using FCB

;Here for INT 21 function 11 - Search for first match using FCB
;	c(AH)    = 11h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0    = Normal
;		  0FFh = Error

$$$=!0
FRM fcbs_qab    , qab_SIZE	;QAB
FRM fcbs_parm   , 64t		;Parameter list buffer
FRM fcbs_name   , 16t		;File name buffer
FRM fcbs_handle , 4		;FCB handle
FRM fcbs_filspec, 16t		;Buffer for returned file specification
fcbs_SIZE=!$$$

ufcbsffm::
	SUBL	ESP, #fcbs_SIZE
	CALL	fcbsetup		;Do initial FCB set up
	CLRL	EAX			;Clear the directory offset
	MOVL	fcb_dirofs.B[ESI], EAX
	JMP	fcbsfm2.S		;Continue
.PAGE
	.SBTTL	ufcbsfnm - INT 21 function 12 - Search for next match using FCB

;Here for INT 21 function 12 - Search for next match using FCB
;	c(AH)    = 12h
;	c[DS:DX] = Address of FCB
;	INT	21h
;	c(AL) = Result code:
;		  0    = Normal
;		  0FFh = Error

ufcbsfnm::
	SUBL	ESP, #fcbs_SIZE
	CALL	fcbsetup		;Do initial FCB set up
fcbsfm2:PUSHL	SS			;Extend the parameter list to include
	POPL	ES			;  the items needed here
	LEAL	EDI, fcbs_parm+26t.B[EBP]
	CLD
	MOVL	EAX, #{PAR$SET|PAR$GET|REP_DECV}|{4<8}|{IOPAR_DIROFS<16t}
	STOSL	[EDI]
	MOVL	EAX, fcb_dirofs.B[ESI]
	STOSL	[EDI]
	MOVL	EAX, #{PAR$SET|REP_HEXV}|{4<8}|{IOPAR_FILOPTN<16t}
	STOSL	[EDI]
	MOVL	EAX, #FO$FILEDOS
	STOSL	[EDI]
	MOVL	EAX, #{PAR$GET|REP_STR}|{IOPAR_FILSPEC<16t}
	STOSL	[EDI]
	LEAL	EAX, fcbs_filspec[EBP]
	STOSL	[EDI]
	MOVL	EAX, SS
	STOSL	[EDI]
	MOVL	EAX, #16t
	STOSL	[EDI]
	CLRL	EAX
	STOSB	[EDI]
	MOVL	fcbs_qab+qab_option.B[EBP], #O$CRIT|O$USEDOS|O$NOLONG
	MOVW	fcbs_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_DEVPARM
	PUSHL	SS
	LEAL	EAX, fcbs_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	2$.S
	ORL	EAX, fcbs_qab+qab_error.B[EBP]
2$:	JS	22$
	MOVL	EAX, fcbs_parm+30t.B[EBP] ;Get returned directory offset
	MOVL	fcb_dirofs.B[ESI], EAX ;Store it in his FCB
	CALL	dosgetdtaa#		;Get address of his DTA
	MOVB	AL, fcbs_parm+9[EBP]	;Give him the attribute byte
	ANDB	AL, #{~A$NORMAL}&0FFh
	CMPB	fcb_fcbtype.B[ESI], #0	;Did he give us an extended FCB?
	JE	4$.S			;No
	MOVB	FS:[EDX], #0FFh		;Yes - make this look like an extended
	ADDL	EDX, #7.B		;  FCB
	MOVB	FS:-1.B[EDX], AL	;Give him the attribute byte in extended
	CLRL	EAX			;  part of the FCB
	MOVL	FS:-6.B[EDX], EAX	;Clear the 5 reserved bytes
	MOVB	FS:-2.B[EDX], AL
4$:	MOVL	EAX, #'    '		;Clear the name and extension fields
	MOVL	FS:fcb_name.B[EDX], EAX
	MOVL	FS:fcb_name+4.B[EDX], EAX
	MOVL	FS:fcb_ext.B[EDX], EAX
	MOVB	AL, [ESI]		;Get the device number from his FCB
	CMPB	AL, #0			;Was a device specified?
	JNE	8$.S			;Yes - go on
	CALL	dosgetdftd		;No - get index for the current disk
	INCL	EAX
	MOVB	[ESI], AL		;Store device index in his FCB
8$:	MOVB	FS:[EDX], AL		;Store disk number in the DTA
	CLRL	EAX			;Clear some unused fields
	MOVL	FS:fcb_curblock.B[EDX], EAX
	LEAL	ESI, fcbs_filspec+1[EBP] ;Get address of file name
	LEAL	EDI, fcb_name.B[EDX]	;Point to place for name
	PUSHL	FS
	POPL	ES
	CMPB	[ESI], #'.'		;Does name start with a period?
	JNE	12$.S			;No
	CMPB	1.B[ESI], #0		;Yes - only a period?
	JLE	10$.S			;Yes
	CMPB	1.B[ESI], #'.'		;No - is second character a period?
	JNE	12$.S			;No - just normal (if funny) name
	CMPB	2.B[ESI], #0		;Yes - is that all?
	JG	12$.S			;No - make the best sense out of it
					;  that we can!
	MOVB	ES:[EDI], #'.'		;Store period
	INCL	EDI
10$:	MOVB	ES:[EDI], #'.'		;Store period
	JMP	18$.S

;Here if name is not . or ..

12$:	MOVL	ECX, #8			;Give him up to 8 name characters
	CALL	copynm			;Copy name part
	JC	22$.S
	JE	15$.S			;If at end of field
14$:	CALL	copynmc			;Get next character
	JNE	14$.S			;Eat the rest of the field!
15$:	CMPL	EAX, #-1.B		;Have extension?
	JNE	18$.S			;No
16$:	LEAL	EDI, FS:fcb_ext.B[EDX]	;Yes - point to place to put extension
	MOVL	ECX, #3			;Use up to 3 characters
	CALL	copynm			;Copy extension
	JC	22$.S
18$:	MOVL	EAX, fcbs_parm+22t.B[EBP] ;Get the file length
	TESTB	fcbo_parm+9.B[EBP], #A$DIRECT ;Is it a directory?
	JE	20$.S			;No
	CLRL	EAX			;Yes - report length as 0 like DOS
20$:	MOVL	FS:fcb_filesize.B[EDX], EAX ;Give him the file length
	MOVL	EAX, fcbs_parm+14t.B[EBP] ;Get the file date and time
	RORL	EAX, #16t
	MOVL	FS:fcb_filedate.B[EDX], EAX ;Give him the date and time
	MOVB	dff_EAX.B[EBP], #0	;Indicate success
21$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if error

22$:	MOVL	dxd_lasterr, EAX
	MOVB	dff_EAX.B[EBP], #0FFh
	JMP	21$.S
.PAGE
;Subroutine to copy returned name or extension to FCB entry
;	c{ESI}    = Offset of returned string
;	c{ES:EDI} = Address of place to put name or extension
;	c{ECX}    = Number of characters allowed
;	CALL	copynm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c(AL) = Stopper character
;	  Z:set = End of field
;	  Z:clr = Not end of field

copynm:	CALL	copynmc			;Get character
	JE	2$.S			;If end of field
	STOSB	[EDI]			;Store character
	LOOP	ECX, copynm		;Continue if room for more
2$:	RET				;No more room

copynmc:CLRL	EAX
	LODSB	[ESI]			;Get character
	CMPB	AL, #FS_ESC		;Image character?
	JNE	14$.S			;No
	LODSB	[ESI]			;Yes
	TESTL	ESP, ESP		;Clear Z
10$:	RET

14$:	CMPB	AL, #'.'		;Period?
	JE	18$.S			;Yes
	TESTB	AL, AL			;End?
	JE	10$.S			;Yes - return 0 with Z set
	CMPB	AL, #0F0h		;Another way to end it
	JB	16$.S			;Not end
	CLRL	EAX			;End - return 0 with Z set
16$:	CLC
	RET

;Here if period - return -1 with Z set

18$:	MOVL	EAX, #-1
	RET
.PAGE
	.SBTTL	ufcbgtfsz - INT 21 function 23 - Get file size using FCB

;Here for INT 21 function 23 - Get file size using FCB
;	c(AH)    = 23h
;	c[DS:DX] = Address of unopened FCB
;	INT	21h
;	c(AL) = Result code:
;		  0    = Normal (random-record field in FCB filled in)
;		  0FFh = Error

ufcbgtfsz::
	SUBL	ESP, #fcbo_SIZE
	MOVW	fcbo_qab+qab_func.B[EBP], #QFNC$WAIT|QFNC$DIO|QFNC_DEVPARM
	CALL	fcbsetup		;Do initial setup
	PUSHL	fcbo_qab+qab_option.B[EBP] ;Get file parameters
	PUSHL	SS
	LEAL	EAX, fcbo_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX		;OK?
	JS	4$.S			;No - fail
	ORL	EAX, fcbo_qab+qab_error.B[EBP]
4$:	JS	fcbxerr
	MOVB	dff_EAX.B[EBP], #0	;Yes
	MOVL	EAX, fcbo_parm+22t.B[EBP] ;Get the file length
	TESTB	fcbo_parm+9.B[EBP], #A$DIRECT ;Is it a directory?
	JE	8$.S			;No
	CLRL	EAX			;Yes - report length as 0 like DOS
8$:	MOVZWL	ECX, fcb_recsize.B[ESI]	;Get record length
	TESTL	ECX, ECX		;Is it 0?
	JNE	10$.S
	INCL	ECX			;Yes - use one
10$:	LEAL	EAX, -1.B[EAX+ECX]	;Round up to records
	CLRL	EDX
	DIVL	ECX
	CMPL	ECX, #64t.B		;Small records?
	JAE	14$.S			;No
	MOVL	fcb_ranrec.B[ESI], EAX	;Yes - give him all 32 bits
	JMP	16$.S

14$:	MOVW	fcb_ranrec.B[ESI], AX	;Large record - give him 24 bits
	SHRL	EAX, #16t
	MOVB	fcb_ranrec+2.B[ESI], AL
16$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	uparse - INT 21 function 29 - Parse filename

;Here for INT 21 function 29 - Parse filename
;	c(AL) = Flags to control parsing
;	c(AH) = 29h
;	c[DS:SI] = Address of text string
;	c[ES:DI] = Address of FCB
;	INT	21h
;	c(AL)    = Result code:
;		     0    = If no wildcard characters encountered
;		     1    = If parsed string contains wildcard characters
;		     0FFh = Invalid drive
;	c[DS:SI] = Address of first character after parsed filename

;Define bits for BH for this routine

BH$DONE =!80h		;Finished with name
BH$IGN  =!40h		;Ignore rest of field
BH$HVEXT=!08h		;Have extension
BH$HVNAM=!04h		;Have file name
BH$HVDEV=!02h		;Have device name

uparse::CALL	getESEDIaddr#		;Get address of the FCB
	MOVL	EDX, ESI
	PUSHL	FS
	POPL	GS
	CALL	getDSESIaddr#		;Get address of text string
	MOVB	BL, dff_EAX+0.B[EBP]	;Get control bits
	PUSHL	ESI
	CALL	dosparse#		;Do the work
	POPL	EDX
	JC	8$.S			;If error
	MOVB	dff_EAX+0.B[EBP], CH	;Give him the wild character flag
	SUBL	ESI, EDX		;Get number of characters used
	ADDW	dff_ESI.B[EBP], SI	;Update his string offset
4$:	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if address error

6$:	MOVL	EAX, #ER_ADRER
8$:	MOVL	dxd_lasterr, EAX
	MOVB	dff_EAX.B[EBP], #0FFh
	JMP	4$.S
.PAGE
	.SBTTL	ugtfdsks - INT 21 function 36 - Get free disk space

;Here for INT 21 function 36 - Get free disk space
;	c(AH) = 36h
;	c(DL) = Drive code
;	INT	21h
;	If specified drive invalid:
;	  c[AX] = 0FFFFh
;	If specified drive valid:
;	  c[AX] = Sectors per cluster
;	  c[BX] = Number of available clusters
;	  c[CX] = Bytes per sector
;	  c[DX] = Clusters per drive

$$$=!0
FRM gfds_qab  , qab_SIZE	;QAB
FRM gfds_name , 16t		;File name buffer
FRM gfds_char , 64t		;Characteristics list buffer
gfds_SIZE=!$$$

ugtfdsks::
	SUBL	ESP, #gfds_SIZE
	CALL	getdinfo
	JC	4$.S
	MOVL	EAX, gfds_char+dski_clusters[EBP] ;Get total space
	MOVW	dff_EDX.B[EBP], AX
	MOVL	EAX, gfds_char+dski_cblksz[EBP] ;Get sector size
	MOVW	dff_ECX.B[EBP], AX
	MOVL	EAX, gfds_char+dski_avail[EBP] ;Get space available
	MOVW	dff_EBX.B[EBP], AX
	MOVL	EAX, gfds_char+dski_clssz.B[EBP] ;Get cluster size
	MOVW	dff_EAX.B[EBP], AX
2$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if error

4$:	MOVL	dxd_lasterr, EAX
	MOVW	dff_EAX.B[EBP], #0FFFF
	JMP	2$.S
.PAGE
	.SBTTL	ugtalcid - INT 21 functions 1B and 1C - Get allocation information for disk

;Here for INT 21 function 1B - Get allocation information for current disk
;	c(AH) = 1Bh
;	INT	21h
;	c(AL)    = Number of sectors per cluster
;	c[DS:BX] = Address of FAT identification byte
;	c[CX]    = Size of physical sector (in bytes)
;	c[DX]    = Number of clusters on drive

$$$=!0
FRM gdai_qab  , qab_SIZE	;QAB
FRM gdai_name , 16t		;File name buffer
FRM gdai_parm , 64t		;Parameter list buffer
gdai_SIZE=!$$$

ugtalcid::
	MOVB	DL, #0
	JMP	2$.S

;Here for INT 21 function 1C - Get allocation information for any disk
;	c(AH) = 1Ch
;	c(DL) = Drive number
;	INT	21h
;	c(AL)    = Number of sectors per cluster
;	c[DS:BX] = Address of FAT identification byte
;	c[CX]    = Size of physical sector (in bytes)
;	c[DX]    = Number of cluster on drive

ugtalcia::
2$:	SUBL	ESP, #gdai_SIZE
	CALL	getdinfo
	JC	12$.S
	MOVL	EAX, gdai_parm+dski_clssz[EBP] ;Get cluster size
	MOVB	dff_EAX.B[EBP], AL	;Store sectors per cluster
	TESTB	dff_EFR+2.B[EBP], #02h	;Called from protected mode?
	JE	4$.S			;Yes
	MOVW	dff_DS.B[EBP], #dda_base>4	      ;No - Store real mode
	MOVW	dff_EBX.B[EBP], #dda_fatmode-dda_base ;  address of FAT mode
	JMP	8$.S				      ;  byte

;Here if called from protected mode to store protected mode address of the FAT
;  mode byte

4$:	MOVW	dff_DS.B[EBP], #GS_REAL16|03h ;Store selector
	MOVL	EAX, #dda_fatmode	;Get offset
	CMPB	dda_dpmitype, #DPMIT_32B ;32-bit client?
	JE	6$.S			;Yes
	MOVW	dff_EBX.B[EBP], AX	;No - just store 16 bits
	JMP	8$.S

;Here if have 32-bit client

6$:	MOVL	dff_EBX.B[EBP], EAX	;Store all 32 bits
8$:	MOVB	AL, gdai_parm+dski_fatmode.B[EBP]
	MOVB	dda_fatmode, AL		;Store FAT mode byte
	MOVL	EAX, gdai_parm+dski_cblksz[EBP] ;Get sector size
	MOVW	dff_ECX.B[EBP], AX	;Store physical sector size
	MOVL	EAX, gdai_parm+dski_clusters[EBP] ;Get total space
	MOVW	dff_EDX.B[EBP], AX	;Store number of clusters on disk
10$:	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Here if error

12$:	MOVL	dxd_lasterr, EAX
	MOVB	dff_EAX.B[EBP], #0FFh
	JMP	10$.S
.PAGE
	.SBTTL	umakepsp26 - INT 21 function 26 - Create program segment prefix

;Here for INT 21 functions 26 - Create program segment prefix - This function
;  implements the DOS version 1 idea of a DOS process.  It does NOT make the
;  new PSP the current PSP and does not increase the open count of the files
;  pointed to by the handle table - It does create a kind of DOS sub-process
;  but only relative to the version 1 system calls!  INT 21h function 4Ch will
;  terminate the actual current DOS sub-process, not the one associated with
;  this PSP.  INT 20h and INT 21h function 0, however, WILL terminate the
;  sub-process associated with the new PSP!
;	c(AH) = 26h
;	c[DX] = Selector for new PSP
;	INT	21h
;	Nothing is returned

;This function is only supported for real mode!

umakepsp26::
	MOVZWL	ESI, dff_CS.B[EBP]	;Get offset of our PSP
	SHLL	ESI, #4
	CALL	copypsp			;Copy the current PSP
	MOVZWL	EAX, psp_hpnt+0.B[EBX]	;Get offset of his current device table
	MOVZWL	ESI, psp_hpnt+2.B[EBX]
	SHLL	ESI, #4
	ADDL	ESI, EAX
	MOVZWL	ECX, psp_hcnt.B[EBX]	;Get size of the device table
	CMPL	ECX, #20t.B		;Make sure not greater than 20
	JB	4$.S
	MOVL	ECX, #20t
4$:	MOVW	psp_hcnt.B[EDX], CX	;Store size in the new PSP
	JREGZ	ECX, 6$			;Just in case
	LEAL	EDI, psp_htable.B[EDX]	;Copy the file table
	RMOVSB	[EDI], [ESI]
6$:	MOVW	psp_hpnt+0.B[EDX], #psp_htable
	MOVL	EAX, EDX		;Store pointer to handle table
	SHRL	EAX, #4
	MOVW	psp_hpnt+2.B[EDX], AX
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
	.SBTTL	INT 21 function 38 - Get or set country

;Here for INT 21 function 38 - Get or set country
;	c(AL)    = New country code (if 0, return current value, if 0FFh, take
;		     extended value from c[BX]
;	c(AH)    = 38h
;	c[BX]    = 16 bit country code if c(AL) = 0FFh
;	c[DS:DX] = Address of buffer for returned information
;	INT	21h
;	C:set = Error
;	  c[AX] = Error code
;	C:clr = Normal
;	  If c(AL) = 0 on call:
;	    c[BX] = Country code
;	    Information buffer is filled in
;	  If c(AL) != 0 on call:
;	    Nothing is returned!

$$$=!0
FRM ccd_char, 16t
ccd_SIZE=!$$$

ucountry::
	SUBL	ESP, #ccd_SIZE.B
	MOVL	ESI, #cntrychars	;Set up our characteristics list
	LEAL	EDI, ccd_char.B[EBP]
	PUSHL	SS
	POPL	ES
	MOVL	ECX, #{CNTRYCSIZE+3}/4
	CLD
	RMOVSL	[EDI], CS:[ESI]
	CALL	getDSEDXaddr#		;Get address of his buffer
	TESTB	dff_EFR+2.B[EBP], #02h	;Called from protected mode
	JNE	2$.S			;No
	CMPB	dda_dpmitype, #DPMIT_32B ;Yes - have 32-bit client?
	JNE	2$.S			;No
	CMPL	EDX, #-1.B		;Yes - check for 32-bit -1
	JMP	4$.S

2$:	CMPW	DX, #-1.B		;Check for 16-bit -1
4$:	JNE	8$.S			;If not setting the value
	XORB	ccd_char+0.B[EBP], #PAR$SET|PAR$GET ;Change to set function
	MOVZBL	EAX, dff_EAX.B[EBP]	;Get new value
	MOVL	ccd_char+10t.B[EBP], EAX
	PUSHL	CS
	PUSHL	#procname#
	PUSHL	SS
	LEAL	EAX, ccd_char.B[EBP]
	PUSHL	EAX
	CALLF	svcIoClsChar#
	TESTL	EAX, EAX
	JNS	18$.S
6$:	JMP	doserr#

;Here if not changing the value

8$:	MOVL	EDI, ESI		;Get address of the user's data buffer
	PUSHL	FS			;  in the right registers
	POPL	ES
	MOVZBL	EAX, dff_EAX+0.B[EBP]	;Get his value
	CMPB	AL, #0FFh		;Have 16 bit value?
	JNE	10$.S			;No
	MOVZWL	EAX, dff_EBX.B[EBP]	;Yes - get it
10$:	TESTL	EAX, EAX		;Want current country?
	JNE	12$.S			;No
	PUSHL	CS			;Yes - get current country code
	PUSHL	#procname#
	PUSHL	SS
	LEAL	EAX, ccd_char.B[EBP]
	PUSHL	EAX
	CALLF	svcIoClsChar#
	MOVL	EAX, ccd_char+10t.B[EBP]
12$:	MOVL	ESI, #counttbl#		;Point to country table
	PUSHL	#GS_VUSERCODE
	POPL	FS
	CLRL	ECX
	MOVB	CL, #COUNTNUM#		;Get number of entries
14$:	CMPW	FS:[ESI], AX		;Is this the one we want?
	JE	16$.S			;Yes
	ADDL	ESI, #COUNTENSZ#.B	;No - bump pointer
	LOOP	ECX, 14$		;Continue if more there
	MOVL	EAX, #ER_VALUE		;This should not be possible!
	JMP	6$.S

;Here with table entry for desired country

16$:	MOVW	SS:pdaURegEBX#+0, AX	;Give him the 16 bit code
	ADDL	ESI, #2.B		;Point to start of data
	MOVL	ECX, #COUNTENSZ#-2	;Get amount to give him
	RMOVSB	[EDI], FS:[ESI]		;Give it to him
18$:	ANDB	dff_EFR.B[EBP], #~01h	;Clear his C
	MOVL	ESP, EBP
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user

;Characteristics list for getting or setting the country code value

	.MOD	4
cntrychars:
	DCHAR	COUNTRY, GET, DECV, 4
	.BYTE	0
CNTRYCSIZE=!$-cntrychars
.PAGE
	.SBTTL	umakechild - INT 21 function 55 - Create DOS child process

;Here for INT 21 function 55 - Create DOS child process - This function
;  implements the DOS version 2+ idea of a DOS process.  It makes the new
;  PSP the current PSP and increases the open count of the files pointed to
;  by the handle table.
;	c(AH) = 55h
;	c[DX] = Selector for new PSP
;	c[SI] = New value for PSP:2
;	INT	21h
;	Nothing is returned

umakechild::
	MOVL	ESI, dda_curpsp		;Get offset of the current PSP
	SHLL	ESI, #4t
	CALL	copypsp			;Copy the current PSP, store vectors
	MOVL	EDI, EDX
	CALL	doscopyhndls		;Copy the DOS handle table
	MOVL	EAX, dff_ESI.B[EBP]	;Store value in PSP:2
	MOVW	psp_msize.B[EDI], AX
	MOVL	EAX, dda_curpsp		;Make this the current PSP
	MOVW	psp_parent.B[EDI], AX
	MOVZWL	EAX, dff_EDX.B[EBP]
	MOVL	dda_curpsp, EAX
	POPAL				;Restore general registers
	CALLF	svcSchDismiss#		;Return to user
.PAGE
;Subroutine to copy the current PSP
;	c{ESI} = Offset of current PSP
;	c[DX]  = Selector for new PSP
;	CALL	copypsp
;	c{EBX} = Offset of current PSP
;	c{EDX} = Offset of new PSP

copypsp:MOVL	EBX, ESI		;Save offset of current PSP
	MOVZWL	EDI, DX			;Get offset for the new PSP
	SHLL	EDI, #4
	MOVL	EDX, EDI
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #100h/4
	CLD
	RMOVSL	[EDI], [ESI]		;Copy the PSP
	MOVW	[EDX], #20CDh		;Put INT 20h at 0 in new PSP
	MOVB	psp_DOScall+0.B[EDX], #9Ah ;Store CALLF 0F01D:0FEF0 in new PSP
	MOVL	psp_DOScall+1.B[EDX], #0FEF0F01Dh
	MOVL	psp_INT21.B[EDX], #0CB21CDh ;Store INT 21h, RETF in new PSP
	MOVL	psp_prevpsp.B[EDX], #0FFFFFFFFh
	MOVL	ESI, #22h*4		;Copy the vectors for INT 22h, INT 23h,
	LEAL	EDI, psp_term.B[EDX]	;  and INT 24h to new PSP
	MOVSL	[EDI], [ESI]
	MOVSL	[EDI], [ESI]
	MOVSL	[EDI], [ESI]
	RET
.PAGE
	.SBTTL	getdinfo - Subroutine to get disk information

;Subroutine to get disk information for INT 21 functions 1B, 1C, and 36
;	CALL	getdinfo
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

getdinfo:
	MOVL	ESI, #dskiparm
	MOVL	ECX, #{DSKICSIZE+3}/4
	CALL	getdparms#
	JC	6$.S
	CMPB	dda_dpmitype, #DPMIT_32B ;32-bit client?
	JE	6$.S			;Yes - no adjustment needed
	BSRL	ECX, gdai_parm+dski_clusters[EBP] ;No - get shift amount
	SUBL	ECX, #15t.B
	JLE	4$.S
	SHLL	gdai_parm+dski_clssz[EBP], CL ;Adjust cluster size
	SHRL	gdai_parm+dski_clusters[EBP], CL ;Adjust number of clusters
	SHRL	gfds_char+dski_avail[EBP], CL ;Adjust space available
4$:	CLC
6$:	RET

	.MOD	4
dskiparm:
	.BYTE	PAR$GET|REP_DECV, 4
	.WORD	IOPAR_DSKTTLSPACE
dski_clusters=!$-dskiparm
	.LONG	0
	.BYTE	PAR$GET|REP_DECV, 4
	.WORD	IOPAR_DSKAVLSPACE
dski_avail=!$-dskiparm
	.LONG	0
	.BYTE	PAR$GET|REP_DECV, 4
	.WORD	IOPAR_DSKCLSSIZE
dski_clssz=!$-dskiparm
	.LONG	0
	.BYTE	PAR$GET|REP_DECV, 4
	.WORD	IOPAR_DSKSECTSIZE
dski_cblksz=!$-dskiparm
	.LONG	0
	.BYTE	PAR$GET|REP_DECV, 1
	.WORD	IOPAR_DSKFSTYPE
dski_fatmode=!$-dskiparm
	.BYTE	0
	.BYTE	0
DSKICSIZE=!$-dskiparm
.PAGE
;Subroutine to copy the DOS handle table to a new PSP - use counts are
;  increased for each handle copied
;	c{EBX} = Offset of current PSP
;	c{EDI} = Offset of new PSP
;	CALL	doscopyhndls

doscopyhndls::
	MOVL	EAX, EDI		;Store pointer to new handle table
	SHLL	EAX, #12t
	MOVB	AL, #18h
	MOVL	psp_hpnt.B[EDI], EAX
	MOVZWL	EAX, psp_hpnt+2.B[EBX]	;Get offset of previous handle table
	SHLL	EAX, #4
	MOVZWL	ESI, psp_hpnt+0.B[EBX]
	ADDL	ESI, EAX
	MOVZWL	EDX, psp_hcnt.B[EBX]	;Get size of previous handle table
	CMPL	EDX, #20t.B		;Is it bigger than we want?
	JB	2$.S			;No
	MOVL	EDX, #20t		;Yes - just use the first 20
2$:	MOVL	ECX, #20t		;Our new table always contains 20 items
	LEAL	EBX, psp_htable.B[EDI]	;Point to our new handle table
4$:	DECL	EDX			;Above top of old table?
	JS	6$.S			;Yes
	MOVZBL	EAX, [ESI]		;No - get handle from previous task
	CMPB	AL, #0FEh		;Is it in use?
	JAE	8$.S			;No - go on
	CMPB	dxd_syshctbl[EAX], #0FEh ;Yes - can we increase its count?
	JAE	6$.S			;No - just skip it!
	INCB	dxd_syshctbl[EAX]	;Yes - do so
	JMP	8$.S			;Continue

;Here if can't use handle for some reason

6$:	MOVB	AL, #0FFh
8$:	MOVB	[EBX], AL		;Store entry in new handle table
	INCL	ESI			;Bump pointers
	INCL	EBX
	LOOP	ECX, 4$			;Continue if more to do
	RET
.PAGE
	.SBTTL	fcbread - Subroutine to do read for FCB read functions

;Subroutine to do read for FCB read functions
;	CALL	fcbread
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Number of bytes read

fcbread:PUSHL	SS
	LEAL	EAX, fcbx_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX		;Error?
	JS	4$.S			;Yes
	ORL	EAX, fcbx_qab+qab_error.B[EBP] ;Maybe
	JS	4$.S			;Yes
	MOVB	dff_EAX.B[EBP], #0	;No - assume complete
	MOVL	EAX, fcbx_qab+qab_amount.B[EBP]
	CMPL	EAX, fcbx_qab+qab_count.B[EBP] ;Right?
	JE	2$.S			;Yes
	MOVB	dff_EAX.B[EBP], #3	;No - indicate partial read
	CLC
2$:	RET

4$:	STC
	RET
.PAGE
	.SBTTL	fcbwrite - Subroutine to do write for FCB read functions

;Subroutine to do write for FCB read functions
;	CALL	fcbwrite
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Number of bytes read

fcbwrite:
	PUSHL	SS			;Write the data
	LEAL	EAX, fcbx_qab.B[EBP]
	PUSHL	EAX
	CALLF	svcIoQueue#
	TESTL	EAX, EAX		;Error?
	JS	4$.S			;Yes
	ORL	EAX, fcbx_qab+qab_error.B[EBP] ;Maybe
	JS	4$.S			;Yes
	MOVB	dff_EAX.B[EBP], #0	;No - indicate all OK
	RET

4$:	STC
	RET
.PAGE
	.SBTTL	fcbsetup - Subroutine to setup name and parameter list from FCB

;Subroutine to setup name and parameter list from FCB for opening file - must be
;  called with fcbo stack frame established (only the first 3 items are used
;  here)
;	CALL	fcbsetup
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{FS:ESI} = Offset of FCB

fcbsetup:
	LEAL	EAX, fcbo_parm[EBP]
	MOVL	fcbo_qab+qab_parm+0.B[EBP], EAX
	MOVL	fcbo_qab+qab_parm+4.B[EBP], SS
	MOVW	fcbo_qab+qab_vector.B[EBP], #0
	MOVL	fcbo_parm+0t.B[EBP], #{PAR$SET|REP_HEXV}|{1<8}|{IOPAR_SRCATTR<16t}
	MOVL	fcbo_parm+5.B[EBP], #{PAR$GET|REP_HEXV}|{1<8}|{IOPAR_FILATTR<16t}
	MOVL	fcbo_parm+10t.B[EBP], #{PAR$GET|REP_HEXV}|{4<8}|{IOPAR_MDATE<16t}
	MOVL	fcbo_parm+18t.B[EBP], #{PAR$GET|REP_DECV}|{4<8}|{IOPAR_LENGTH<16t}
	MOVB	fcbo_parm+26t.B[EBP], #0
	CALL	getDSEDXaddr#		;Get offset of his FCB
	MOVB	AH, #A$NORMAL		;Assume no attributes specified
	CLRL	ECX
	MOVB	AL, FS:[ESI]		;Get disk index
	CMPB	AL, #0FFh		;Is this an extended FCB?
	JNE	4$.S			;No
	MOVB	AH, FS:6.B[ESI]		;Yes - get attribute byte
	INCL	ECX			;Indicate have extended FCB
	CMPB	AH, #A$LABEL
	JE	2$.S
	ORB	AH, #A$NORMAL
2$:	ADDL	ESI, #7.B		;Point to real disk index byte
	MOVB	AL, FS:[ESI]		;Get the real disk index
4$:	MOVB	FS:fcb_fcbattr.B[ESI], AH ;Store attribute byte
	MOVB	FS:fcb_fcbtype.B[ESI], CL ;Store FCB type indication
	MOVB	fcbo_parm+4t.B[EBP], AH
	LEAL	EDI, fcbo_name[EBP]	;Point to place for name
	MOVL	fcbo_qab+qab_buffer1+0.B[EBP], EDI
	MOVL	fcbo_qab+qab_buffer1+4.B[EBP], SS
	PUSHL	SS
	POPL	ES
	CLD
	MOVB	AL, FS:[ESI]		;Get disk number
	TESTB	AL, AL			;Want default disk?
	JE	fcbset2.S		;Yes
	ADDB	AL, #'A'-1		;No - change disk index to letter
	STOSB	[EDI]			;Store it
	MOVB	AL, #':'		;Followed by a colon
	STOSB	[EDI]
fcbset2:PUSHL	ESI
	INCL	ESI			;Point to start of name
	MOVL	ECX, #8			;May be up to 8 characters
	CALL	getnmex			;Get name
	JC	8$.S			;If error
	MOVB	AL, #'.'		;Followed by a period
	STOSB	[EDI]
	MOVL	ESI, [ESP]		;Point to start of extension
	ADDL	ESI, #9.B
	MOVB	CL, #3			;May be up to 3 characters
	CALL	getnmex			;Get extension
8$:	POPL	ESI
	JC	10$.S			;If error
	MOVB	AL, #0			;Followed by a null
	STOSB	[EDI]
10$:	CMPW	fcbo_name[EBP], #'.'	;Was the name completely null?
	JE	fcbsetn.S		;Yes - fail
	CLC				;No - OK
	RET
.PAGE
;Subroutine to get next field for name or extension
;	c{ECX}    = Maximum number of characters to use
;	c{FS:ESI} = Address of start of name or extension
;	c{ES:EDI} = Address of buffer for name
;	CALL	getnmex
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c(AL) = Character

getnmex:PUSHL	EDX
	MOVL	EDX, EDI		;Initialize end pointer
2$:	LODSB	FS:[ESI]		;Get next character from his FCB
	CMPB	AL, #'*'		;Wild characters?
	JE	10$.S			;Yes
	CMPB	AL, #0			;Null?
	JE	6$.S			;Yes
	STOSB	[EDI]			;No - store character in name string
	CMPB	AL, #' '		;No - space?
	JE	4$.S			;Yes
	MOVL	EDX, EDI		;No - update end pointer
4$:	LOOP	ECX, 2$			;Continue if more
	MOVL	EDI, EDX		;Point to actual end of name
	POPL	EDX
	CLC				;Make sure C is clear
	RET				;Finished

;Here if have null in field - this is illegal!

6$:	POPL	EDX
fcbsetn:MOVL	EAX, #ER_BDSPC
	STC
	RET

;Here if have * in field

10$:	MOVB	AL, #'?'		;Fill out the field with ?
	RSTOSB	[EDI]
	POPL	EDX
	RET
.PAGE
	.SBTTL	fcbchkwild - Subroutine to check for wild-card character for FCB

;Subroutine to check for wild-card character for FCB IO operation
;	CALL	fcbchkwild
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal, O$REPEAT set in qab_option if have wild-card character

fcbchkwild:
	PUSHL	ESI
	LEAL	ESI, fcbo_name[EBP]	;Point to name
4$:	LODSB	SS:[ESI]		;Get character
	TESTB	AL, AL			;End?
	JE	8$.S			;Yes - finished
	CMPB	AL, #'?'		;No - wild-card character?
	JE	6$.S			;Yes
	CMPB	AL, #'*'		;Maybe
	JNE	4$.S			;No - continue
6$:	POPL	ESI
	BTSL	fcbo_qab+qab_option.B[EBP], #O%REPEAT ;Set the repeat bit
	CLC
ret004:	RET

;Here if finished

8$:	POPL	ESI
	RET
.PAGE
	.SBTTL	fcbsioset - Subroutine to setup for sequential FCB IO

;Subroutine to setup for sequential FCB IO
;	CALL	fcbsioset
;	c{EBX} = XOS device handle
;	c{ESI} = Offset of FCB

fcbsioset:
	CALL	getDSEDXaddr		;Get offset of his FCB
	CMPB	FS:[ESI], #0FFh		;Extended FCB?
	JNE	2$.S			;No
	ADDL	ESI, #7.B		;Yes - point to device index
2$:	MOVZWL	ECX, FS:fcb_recsize.B[ESI] ;Get record size
	MOVL	fcbx_qab+qab_count.B[EBP], ECX ;Store as amount to transfer
	MOVZWL	EDI, FS:fcb_curblock.B[ESI] ;Get current block
	SHLL	EDI, #7
	MOVZBL	EBX, FS:fcb_currec.B[ESI] ;Get current record
	ADDL	EDI, EBX
	JMP	fcbio2.S		;Continue
.PAGE
	.SBTTL	fcbrioset - Subroutine to setup for random FCB IO

;Subroutine to setup for random FCB IO
;	c{ECX} = Number of records to transfer
;	CALL	fcbrioset
;	c{EDX}    = Offset of FCB

fcbrioset:
	CALL	getDSEDXaddr		;Get offset of his FCB
	CMPB	FS:[ESI], #0FFh		;Extended FCB?
	JNE	2$.S			;No
	ADDL	ESI, #7.B		;Yes - point to device index
2$:	CALL	fcbsetrec		;Setup record number stuff in FCB
	MOVL	EAX, ECX
	MOVZWL	ECX, FS:fcb_recsize.B[ESI] ;Get record size
	IMULL	EAX, ECX		;Calculate amount to transfer
	MOVL	fcbx_qab+qab_count.B[EBP], EAX
fcbio2:	IMULL	ECX, EDI		;Get byte offset in file for IO
	LEAL	EAX, fcbx_parm.B[EBP]	;Set up the parameter list
	MOVL	fcbx_qab+qab_parm+0.B[EBP], EAX
	MOVL	fcbx_qab+qab_parm+4.B[EBP], SS
	PUSHL	SS
	POPL	ES
	MOVL	fcbx_parm+0t.B[EBP], #{PAR$SET|REP_DECV}|{4<8}|{IOPAR_ABSPOS<16t}
	MOVL	fcbx_parm+4t.B[EBP], ECX
	MOVB	fcbx_parm+8t.B[EBP], #0
	CMPL	fcbx_qab+qab_count.B[EBP], #0.B ;Want to truncate file here?
	JNE	4$.S			;No
	CMPB	fcbx_qab+qab_func.B[EBP], #QFNC_OUTBLOCK ;Maybe
	JNE	4$.S			;No
	MOVL	fcbx_parm+8t.B[EBP], #{PAR$SET|REP_DECV}|{4<8}|{IOPAR_LENGTH<16t} ;Yes
	MOVL	fcbx_parm+12t.B[EBP], #-1
	MOVL	fcbx_parm+16t.B[EBP], #0
4$:	MOVW	fcbx_qab+qab_vector.B[EBP], #0
	CALL	dosgetdtaa#		;Get address for IO
	MOVL	fcbx_qab+qab_buffer1+0.B[EBP], EDX
	MOVL	fcbx_qab+qab_buffer1+4.B[EBP], FS
	MOVZBL	EAX, FS:fcb_fcbhndl.B[ESI] ;Get FCB handle
	MOVZBL	EAX, dxd_fcbtbl+fcbh_handle[EAX*4] ;Get XOS handle
	MOVL	fcbx_qab+qab_handle.B[EBP], EAX
	RET				;Thats all
.PAGE
	.SBTTL	fcbsetrec - Subroutine to set record numbers in FCB

;Subroutine to set record numbers in FCB
;	c{FS:ESI} = Address of FCB
;	CALL	fcbsetrec
;	c{EDI} = Random record number

fcbsetrec:
	MOVL	EAX, FS:fcb_ranrec.B[ESI] ;Get random record number
	CMPW	FS:fcb_recsize.B[ESI], #64t.B ;Is the record size less than 64
					      ;  bytes
	JB	2$.S			;Yes
	ANDL	EAX, #0FFFFFFh		;No - just use 24 bits
2$:	MOVL	EDI, EAX		;Save record number
	PUSHL	EDX
	CLRL	EDX
	DIVL	CS:clit128		;Change to block and record in block
	XCHGL	EDX, [ESP]
	MOVW	FS:fcb_curblock.B[ESI], AX ;Store block
	POPL	EAX
	MOVB	FS:fcb_currec.B[ESI], AL ;Store record in block
	RET

	.MOD	4
clit128:.LONG	128t

	END
