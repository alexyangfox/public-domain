	.TITLE	SYSTEM - System level SVC functions for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR

	ONCE

initsystem::
	MOVL	EDI, #syschk		;Install the SYSTEM device class
	CLRL	EBX			;No class functions
	MOVL	EAX, #'SYST'
	MOVL	EDX, #'EM'
	MOVL	ECX, #sysdctbl
	MOVL	ESI, #sysccb
	CALL	knlNewClass#
	MOVL	EDI, #procchk		;Install the PROCESS device class
	CLRL	EBX			;No class functions
	MOVL	EAX, #'PROC'
	MOVL	EDX, #'ESS'
	MOVL	ECX, #procdctbl
	MOVL	ESI, #procccb
	CALL	knlNewClass#
	MOVL	EDI, #sessionchk	;Install the SESSION device class
	CLRL	EBX			;No class functions
	MOVL	EAX, #'SESS'
	MOVL	EDX, #'ION'
	MOVL	ECX, #procdctbl
	MOVL	ESI, #sessionccb
	CALL	knlNewClass#
	MOVL	EDI, #accountchk	;Install the ACCOUNT device class
	CLRL	EBX			;No class functions
	MOVL	EAX, #'ACCO'
	MOVL	EDX, #'UNT'
	MOVL	ECX, #accountdctbl
	MOVL	ESI, #accountccb
	JMP	knlNewClass#

	CODE

accountchk:
sessionchk:
procchk:
syschk:	TESTL	ESP, ESP		;Always return with C:clr, Z:clr
	RET
.PAGE
;Class characteristics tables for the SYSTEM device class

	DATA

	.MOD	4
sysdctbl:
 DCHARBGN  1, knlDCharValCom#
 DCHARENT  SYSNAME , STR  ,  , 32           , msgsysname , knlGetSysStr  , 0              , knlName#
 DCHARENT  XOSVER  , VERN ,  , 4            , msgxosver  , knlGetSysVal  , 0              , knlver#
 DCHARENT  DOSVER  , VERN ,  , 4            , msgdosver  , knlGetSysVal  , 0              , dosver#
 DCHARENT  SERNUM  , DECV ,  , 4            , msgserial  , knlGetSysVal  , 0              , serialnum#
 DCHARENT  FPUTYPE , TEXT ,  , 8            , msgfputype , getfputype    , 0              , 0
 DCHARENT  FPUENB  , TEXT ,  , 8            , msgfpuenb  , getfpusenb    , setfpusenb     , 0
 DCHARENT  PROCTYPE, TEXT ,  , 8            , msgproctype, getproctype   , 0              , 0
 DCHARENT  LOADDATE, DT   ,  , 8            , msgloaddate, getloaddate   , 0              , 0
 DCHARENT  DFLTUSER, STR  ,  , 34           , msgdfltuser, knlGetDfltUser, knlSetDfltUser , knlSysGroup#
 DCHARENT  PROLIMIT, DECV ,  , 4            , msgprolimit, knlGetSysVal  , knlSetSysVLC   , knlProcLimit#
 DCHARENT  PROINUSE, DECV ,  , 4            , msgproinuse, knlGetSysVal  , 0              , knlProcInUse#
 DCHARENT  ALMLIMIT, DECV ,  , 4            , msgalmlimit, knlGetSysVal  , knlSetSysVal   , almlimit#
 DCHARENT  WSLIMIT , DECV ,  , 4            , msgwslimit , getmems       , setmems        , wslimit#
 DCHARENT  TMLIMIT , DECV ,  , 4            , msgtmlimit , getmems       , setmems        , tmlimit#
 DCHARENT  PMLIMIT , DECV ,  , 4            , msgpmlimit , getmems       , setmems        , pmlimit#
 DCHARENT  RMLIMIT , DECV ,  , 4            , msgrmlimit , getmems       , setmems        , rmlimit#
 DCHARENT  OMLIMIT , DECV ,  , 4            , msgomlimit , getmems       , setmems        , omlimit#
 DCHARENT  XFFLIMIT, DECV ,  , 4            , msgxfflimit, knlGetSysVal  , knlSetSysVal   , xfflimit#
 DCHARENT  XFFNUM  , DECV ,  , 4            , msgxffnum  , knlGetSysVal  ,                , xffnum#
 DCHARENT  XFFINUSE, DECV ,  , 4            , msgxffinuse, knlGetSysVal  , 0              , xffinuse#
 DCHARENT  XFFMAX  , DECV ,  , 4            , msgxffmax  , knlGetSysVal  , knlSetSysVLC   , xffmax#
 DCHARENT  SELNUM  , DECV ,  , 4            , msgselnum  , knlGetSysVal  , 0              , gselnum#
 DCHARENT  SELINUSE, DECV ,  , 4            , msgselinuse, knlGetSysVal  , 0              , gselinuse#
 DCHARENT  XMBAVAIL, DECV ,  , 28           , msgxmbavail, knlDcGetLong# , 0              , xmbcnt#
 DCHARENT  XMBAMAX , DECV ,  , 28           , msgxmbamax , knlDcGetLong# , knlDcSetLongRpt, xmbchwm#
 DCHARENT  XMBINUSE, DECV ,  , 28           , msgxmbinuse, knlDcGetLong# , 0              , xmbinuse#
 DCHARENT  XMBMAX  , DECV ,  , 28           , msgxmbmax  , knlDcGetLong# , knlDcSetLongRpt, xmbiuhwm#
 DCHARENT  XMBRESRV, DECV ,  , 4            , msgxmbresrv, knlGetSysVal  , knlSetSysVal   , xmbreserve#
 DCHARENT  DEVLIMIT, DECV ,  , 4            , msgdevlimit, knlGetSysVal  , setdevlimit#   , dcbtblsize#
 DCHARENT  DEVINUSE, DECV ,  , 4            , msgdevinuse, knlGetSysVal  , knlSetSysVal   , dcbinuse#
 DCHARENT  DEVMAX  , DECV ,  , 4            , msgdevmax  , knlGetSysVal  , 0              , dcbmax#
 DCHARENT  V86SIZE , DECV ,  , 4            , msgdossize , getsys4bytp   , setdossize     , pdaDosSize#
 DCHARENT  V86BASE , DECV ,  , 4            , msgdosbase , getsys4bytp   , setdosbase     , pdaDosBase#
 DCHARENT  DOSSIZE , DECV ,  , 4            , msgdossize , getsys4bytp   , setdossize     , pdaDosSize#
 DCHARENT  DOSBASE , DECV ,  , 4            , msgdosbase , getsys4bytp   , setdosbase     , pdaDosBase#
 DCHARENT  COUNTRY , DECV ,  , 4            , msgcountry , knlGetSysVal  , knlSetSysVal   , country#
 DCHARENT  STATE   , HEXV ,  , 4            , msgsstate  , knlGetSysVal  , setsstate      , sysstate#
 DCHARENT  HIGHDMA , HEXV ,  , 4            , msghighdma , knlGetSysVal  , sethighdma     , hidmalmt#
 DCHARENT  TOTALMEM, DECV ,  , 4            , msgttlmem  , getmems       , 0              , knlMemTotal#
 DCHARENT  USERMEM , DECV ,  , 4            , msgusermem , getmems       , 0              , knlMemUser#
 DCHARENT  AVAILMEM, DECV ,  , 4            , msgavailmem, getmems       , 0              , knlMemAvail#
 DCHARENT  INITIAL , TEXT ,  , 4            , msginitial , knlGetSysYN   , knlSetSysYN    , SYSD%INITIAL
 DCHARENT  LOGIN   , TEXT ,  , 4            , msglogin   , knlGetSysYN   , knlSetSysYN    , SYSD%LOGIN
 DCHARENT  KBRESET , TEXT ,  , 4            , msgkbreset , knlGetSysYN   , knlSetSysYN    , SYSD%KBRESET
 DCHARENT  FASTBOOT, TEXT ,  , 4            , msgfastboot, knlGetSysYN   , knlSetSysYN    , SYSD%FASTBOOT
 DCHARENT  DEBUG   , TEXT ,  , 4            , msgdebug   , getdebug      , 0              , 0
 DCHARENT  SPEED   , DECV ,  , 4            , msgspeed   , knlGetSysVal  , 0              , knlDelFactor#
 DCHARENT  INTMUL  , TEXT ,  , 4            , msgintmul  , getprocbug    , 0              , intmulbug#
 DCHARENT  FPUDIV  , TEXT ,  , 4            , msgfpudiv  , getprocbug    , 0              , fpudivbug#
 DCHARENT  REBOOT  , DECV , H, 4            , msgreboot  , knlRtnZero#   , setreboot      , 0
 DCHARENT  CRSHDATA, DATAS, H, pg0_crshSIZE#, msgcrash   , getcrash      , setcrash       , 0
irqtableent::
 DCHARENT  IRQTABLE, DATAS, H, irqtblsize#  , msgirqtable, getirqs#      , 0              , 0
iotableent::
 DCHARENT  IOTABLE , DATAS, H, iotblsize#   , msgiotable , getioregs#    , 0              , 0


;Class characteristics tables for the PROCESS device class

procdctbl:
 DCHARBGN  2, procdcval
 DCHARENT  NAME    , STR  ,  , 12 , msgprocname, getprocname, setprocname, 0
 DCHARENT  NUM     , DECV ,  , 4  , msgprocnum , getpda2byte, setprocnum , pdaPid#+0
 DCHARENT  SEQ     , DECV ,  , 4  , msgprocseq , getpda2byte, setprocseq , pdaPid#+2
 DCHARENT  CONTRM  , TEXT ,  , 16 , msgcontrm  , getcontrm  , setcontrm  , 0
 DCHARENT  USER    , STR  ,  , 36 , msgusername, getusername, setusername, ses_grpname
 DCHARENT  PARENT  , HEXV ,  , 4  , msgparent  , getparent  , 0          , 0
 DCHARENT  FPUENB  , TEXT ,  , 4  , msgfpuenb  , getfpuenb  , setfpuenb  , P1$FPU
 DCHARENT  COUNTRY , DECV ,  , 4  , msgcountry , getpda2byte, setpda2byte, pdaCountry#
 DCHARENT  V86SIZE , DECV ,  , 4  , msgdossize , getpda4bytp, setpdadossz, pdaDosSize#
 DCHARENT  V86BASE , DECV ,  , 4  , msgdosbase , getpda4bytp, setpdadosbs, pdaDosBase#
 DCHARENT  DOSSIZE , DECV ,  , 4  , msgdossize , getpda4bytp, setpdadossz, pdaDosSize#
 DCHARENT  DOSBASE , DECV ,  , 4  , msgdosbase , getpda4bytp, setpdadosbs, pdaDosBase#
 DCHARENT  FILEPROT, STR  ,  , 100, msgfileprot, getfileprot, setfileprot, pdaFileProt#
 DCHARENT  DIRPROT , STR  ,  , 100, msgdirprot , getdirprot , setdirprot , pdaDirProt#
 DCHARENT  SHRRETRY, DECV ,  , 4  , msgshrretry, getpda2byte, setshrretry, pdaShrRetry#
 DCHARENT  SHRDELAY, DECV ,  , 4  , msgshrdelay, getpda2byte, setshrdelay, pdaShrDelay#
 DCHARENT  WSLIMIT , DECV ,  , 4  , msgwslimit , getpdamems , setpdamemsl, pdaWSLimit#
 DCHARENT  TMLIMIT , DECV ,  , 4  , msgtmlimit , getpdamems , setpdamemsl, pdaTMLimit#
 DCHARENT  PMLIMIT , DECV ,  , 4  , msgpmlimit , getpdamems , setpdamemsl, pdaPMLimit#
 DCHARENT  RMLIMIT , DECV ,  , 4  , msgrmlimit , getpdamems , setpdamemsl, pdaRMLimit#
 DCHARENT  OMLIMIT , DECV ,  , 4  , msgomlimit , getpdamems , setpdamemsl, pdaOMLimit#
 DCHARENT  WSALLOW , DECV ,  , 4  , msgwsallow , getpdamems , setpdamemsr, pdaWSAllow#
 DCHARENT  TMALLOW , DECV ,  , 4  , msgtmallow , getpdamems , setpdamemsr, pdaTMAllow#
 DCHARENT  PMALLOW , DECV ,  , 4  , msgpmallow , getpdamems , setpdamemsr, pdaPMAllow#
 DCHARENT  RMALLOW , DECV ,  , 4  , msgrmallow , getpdamems , setpdamemsr, pdaRMAllow#
 DCHARENT  OMALLOW , DECV ,  , 4  , msgomallow , getpdamems , setpdamemsr, pdaOMAllow#
 DCHARENT  WSINUSE , DECV ,  , 4  , msgwsinuse , getpda4bytq, 0          , pdaWSPages#
 DCHARENT  PMINUSE , DECV ,  , 4  , msgpminuse , getpda4bytq, 0          , pdaPMPages#
 DCHARENT  RMINUSE , DECV ,  , 4  , msgrminuse , getpda4bytq, 0          , pdaRMPages#
 DCHARENT  OMINUSE , DECV ,  , 4  , msgominuse , getpda4bytq, 0          , pdaOMPages#
 DCHARENT  LAINUSE , DECV ,  , 4  , msglainuse , getpda4bytp, 0          , pdaLAInUse#
 DCHARENT  LABLKS  , DECV ,  , 4  , msglablks  , getpda4byte, 0          , pdaLABlks#
 DCHARENT  LALARGE , DECV ,  , 4  , msglalarge , getlalarge , 0          , 0
 DCHARENT  PRIVCUR , STR  ,  , 200, msgprivcur , getprivcur , setprivcur , 0
 DCHARENT  PRIVAVL , STR  ,  , 200, msgprivavl , getprivavl , setprivavl , 0
 DCHARENT  PRIVCHK , STR  , H, 200, msgprivchk , getprivcur , setprivchk , 0
 DCHARENT  PRIVVLD , STR  , H, 200, msgprivvld , getprivavl , setprivvld , 0
 DCHARENT  SECTCUR , STR  ,  , 200, msgsectcur , getsectcur , setsectcur , 0
 DCHARENT  SECTAVL , STR  ,  , 200, msgsectavl , getsectavl , setsectavl , 0
 DCHARENT  SECTCHK , STR  , H, 200, msgsectchk , getsectcur , setsectchk , 0

;Class characteristics tables for the ACCOUNT device class

accountdctbl:
 DCHARBGN  3, procdcval
 DCHARENT  NUM     , DECV ,  , 4 , msgprocnum     , getpda2byte, setprocnum , pdaPid#+0
 DCHARENT  SEQ     , DECV ,  , 4 , msgprocseq     , getpda2byte, setprocseq , pdaPid#+2
 DCHARENT  SESSEQ  , DATAS, H, 16, msgsesseq      , getsesseq  , setsesseq  , ses_sesseq
 DCHARENT  ACCESS  , TEXT ,  , 4 , knlDcMsgAccess#, getses4byte, setses4byte, ses_access
 DCHARENT  ACTDEV  , STR  ,  , 16, msgactdev      , getsesstr  , setsesstr  , ses_actdev
 DCHARENT  ACTNODE , DECB ,  , 4 , msgactnode     , getses4byte, setses4byte, ses_actnode
 DCHARENT  ACTPORT , DECV ,  , 4 , msgactport     , getses4byte, setses4byte, ses_actport
 DCHARENT  PORTNAME, STR  ,  , 16, msgportname    , getsesstr  , setsesstr  , ses_portname
 DCHARENT  USERADDR, STR  ,  , 32, msguseraddr    , getsesstr  , setsesstr  , ses_useraddr
 DCHARENT  UPRGVRSN, VERN ,  , 4 , msguprgvrsn    , getses4byte, setses4byte, ses_uprgvrsn
 DCHARENT  BILLING , DATAS, H, 68, 0              , getbilling , setbilling , ses_billcls

	CODE

msgsysname: DCHARINFO  {Name of system}
msgxosver:  DCHARINFO  {XOS version number}
msgdosver:  DCHARINFO  {Default DOS emulator version number}
msgserial:  DCHARINFO  {Kernel serial number}
msgfputype: DCHARINFO  {Math coprocessor (FPU) type}
msgproctype:DCHARINFO  {Processor type}
msgloadtime:DCHARINFO  {Time system loaded}
msgloaddate:DCHARINFO  {Date system loaded}
msgfpuenb:  DCHARINFO  {Math coprocessor (FPU) enabled}
msgcountry: DCHARINFO  {Country code}
msgdfltuser:DCHARINFO  {Default system user}
msgprolimit:DCHARINFO  {Limit of number of processes/shared sections}
msgproinuse:DCHARINFO  {Number of processes/shared sections}
msgalmlimit:DCHARINFO  {Maximum number of alarms per process}
msgwslimit: DCHARINFO  {Working set size limit (KB)}
msgtmlimit: DCHARINFO  {Total user memory limit (KB)}
msgpmlimit: DCHARINFO  {Protected mode memory limit (KB)}
msgrmlimit: DCHARINFO  {Real mode memory limit (KB)}
msgomlimit: DCHARINFO  {Overhead memory limit (KB)}
msgwsallow: DCHARINFO  {Working set size allowed (KB)}
msgtmallow: DCHARINFO  {Total user memory allowed (KB)}
msgpmallow: DCHARINFO  {Protected mode memory allowed (KB)}
msgrmallow: DCHARINFO  {Real mode memory allowed (KB)}
msgomallow: DCHARINFO  {Overhead memory allowed (KB)}
msgxfflimit:DCHARINFO  {Limit of number of extended fork frames}
msgxffnum:  DCHARINFO  {Current number of extended fork frames}
msgxffinuse:DCHARINFO  {Number of in use extended fork frames}
msgxffmax:  DCHARINFO  {Maximum in use extended fork frames}
msgselnum:  DCHARINFO  {Number of global selectors created}
msgselinuse:DCHARINFO  {Number of in use global selectors}
msgxmbavail:DCHARINFO  {Number of available exec buffers}
msgxmbamax: DCHARINFO  {Maximum number of available exec buffers}
msgxmbinuse:DCHARINFO  {Number of in use exec buffers}
msgxmbmax:  DCHARINFO  {Maximum number of in use exec buffers}
msgxmbresrv:DCHARINFO  {Number of reserve exec buffer pages}
msgdevlimit:DCHARINFO  {Maximum allowed number of devices}
msgdevinuse:DCHARINFO  {Number of devices in use}
msgdevmax:  DCHARINFO  {Maximum in use devices}
msgdossize: DCHARINFO  {Default size of DOS image (KB)}
msgdosbase: DCHARINFO  {Base offset for DOS image (KB)}
msgfileprot:DCHARINFO  {Default file protection}
msgdirprot: DCHARINFO  {Default directory protection}
msgshrretry:DCHARINFO  {File sharing retry limit}
msgshrdelay:DCHARINFO  {File sharing retry delay (millisec)}
msgominuse: DCHARINFO  {Overhead memory in use (KB)}
msgpminuse: DCHARINFO  {Protected mode memory in use (KB)}
msgrminuse: DCHARINFO  {Real mode memory in use (KB)}
msgwsinuse: DCHARINFO  {Working set memory in use (KB)}
msglainuse: DCHARINFO  {Linear address pages in use (KB)}
msglablks:  DCHARINFO  {Number of linear address blocks in use}
msglalarge: DCHARINFO  {Largest available linear address block (KB)}
msgsstate:  DCHARINFO  {System state}
msghighdma: DCHARINFO  {Highest physical address for DMA}
msgttlmem:  DCHARINFO  {Total memory in system (in KB)}
msgusermem: DCHARINFO  {User memory in system (in KB)}
msgavailmem:DCHARINFO  {Available memory (in KB)}
msgnumhard: DCHARINFO  {Number of hard disk units in system}
msgnumflpy: DCHARINFO  {Number of floppy disk units in system}
msgnumser:  DCHARINFO  {Number of serial ports in system}
msgnumpar:  DCHARINFO  {Number of parallel ports in system}
msginitial: DCHARINFO  {Run initial command SHELL on startup}
msglogin:   DCHARINFO  {User login required}
msgkbreset: DCHARINFO  {Can reset system from console keyboard}
msgfastboot:DCHARINFO  {Do fast reboot}
msgdebug:   DCHARINFO  {Exec debugger present}
msgspeed:   DCHARINFO  {Processor speed factor}
msgintmul:  DCHARINFO  {Integer multiply error test}
msgfpudiv:  DCHARINFO  {Floating point unit divide error test}
msgreboot:  DCHARINFO  {Reboot system}
msgcrash:   DCHARINFO  {Saved crash data}
msgirqtable:DCHARINFO  {Hardware interrupt usage table}
msgiotable: DCHARINFO  {Hardware IO register usage table}

msgprocname:DCHARINFO  {Process name}
msgprocnum: DCHARINFO  {Process number}
msgprocseq: DCHARINFO  {Sequence number}
msgcontrm:  DCHARINFO  {Controlling terminal}
msgusername:DCHARINFO  {Logged in user name}
msgparent:  DCHARINFO  {Parent process PID}
msgprivcur: DCHARINFO  {Current process privileges}
msgprivavl: DCHARINFO  {Available process privileges}
msgprivchk: DCHARINFO  {Check for current privileges}
msgprivvld: DCHARINFO  {Check for valid privileges}
msgsectcur: DCHARINFO  {Current user sections}
msgsectavl: DCHARINFO  {Available user sections}
msgsectchk: DCHARINFO  {Check for current user sections}

msgsesseq:  DCHARINFO  {Session sequence number}
msgactdev:  DCHARINFO  {Accounting device}
msgactnode: DCHARINFO  {Accounting node}
msgactport: DCHARINFO  {Accounting port}
msgportname:DCHARINFO  {Access port name}
msguseraddr:DCHARINFO  {User address}
msguprgvrsn:DCHARINFO  {User program version}
.PAGE
	.SBTTL	procdcval - Initial get value routine for PROCESS and SESSION classes

;Initial get value routine for PROCESS, SESSION, and ACCOUNT classes
;	c{EDI} = Offset of CCB
;	CALL	procdcval

procdcval:
	CMPL	EDI, #procccb		;Is this for the PROCESS class?
	JE	4$.S			;Yes
	MOVZBL	EAX, SS:pdaSesProc#	;No - use the session process
	MOVZWL	EAX, knlProcTable[EAX*2]
	MOVL	chardata#, EAX
4$:	JMP	knlDCharValCom#
.PAGE
;Subroutine to get value of system characteristic which has a long string value
;	c{EDX}    = Data value
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	knlGetSysStr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

knlGetSysStr::
	MOVL	ESI, EDX		;Get addresses in right registers
	MOVL	EDI, EBX
	CLD
2$:	DECL	ECX
	JLE	knlBadCharV#
	LODSB	[ESI]
	IFFAULT	knlRtnAdrEr#
	STOSB	[EDI]
	CMPB	AL, #0
	JNE	2$.S
	MOVL	ECX, EDI		;Calculate length stored
	SUBL	ECX, EBX
	DECL	ECX			;Minus the null
	RET

;Subroutine to set value of system characteristic which has a long string value
;	c{EDX}    = Data value
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Maximum length of string to store
;	CALL	knlSetSysStr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlSetSysStr::
	MOVL	ESI, EBX
	PUSHL	ES
	POPL	FS
	MOVL	EDI, EDX		;Get addresses in right registers
	PUSHL	DS
	POPL	ES
	CLD
4$:	DECL	ECX			;Have more?
	JNS	6$.S			;Yes
	CLRL	EAX			;No - store final null
	JMP	8$.S

	IFFAULT	knlRtnAdrEr#
6$:	LODSB	FS:[ESI]
8$:	STOSB	[EDI]
	CMPB	AL, #0
	JNE	4$.S
	RET

;Subroutine to get value of characteristics which has a data string value
;	c{EDX}    = Data value
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	c{ESI}    = Offset of characteristics table entry
;	CALL	knlGetSysData
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

knlGetSysData::
	MOVZWL	EAX, dct_length.B[ESI]
	CMPL	ECX, EAX
	JBE	10$.S
	MOVL	ECX, EAX
10$:	MOVL	EDI, EBX
	MOVL	ESI, EDX		;Get addresses in right registers
	CLD
	MOVL	EDX, ECX
	MOVL	EAX, ECX
	CLRL	ECX
	SUBL	ECX, EDI
	ANDL	ECX, #03h
	SUBL	EAX, ECX
	IFFAULT	knlRtnAdrEr#
	RMOVSB	[EDI], [ESI]
	MOVL	ECX, EAX
	SHRL	ECX, #2
	IFFAULT	knlRtnAdrEr#
	RMOVSL	[EDI], [ESI]
	MOVL	ECX, EAX
	ANDL	ECX, #03h
	IFFAULT	knlRtnAdrEr#
	RMOVSB	[EDI], [ESI]
	MOVL	ECX, EDX
	RET

;Subroutine to get value of system characteristic which has a 4 byte value
;	c{EBX} = Data value
;	CALL	knlGetSysVal
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

knlGetSysVal::
	MOVL	EAX, [EBX]		;Get value
	CLRL	EDX
	RET

;Subroutine to set value of system characteristic which has a 4 byte value
;  with limit check - limit value must be stored in the 4 bytes just before
;  the value to be changed - new value must be less than or equal to the
;  limit value
;	c{EAX} = Value to store
;	c{EBX} = Data value
;	CALL	knlGetSysVLC
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlSetSysVLC::
	CMPL	-4.B[EBX], EAX		;Valid value?
	JA	12$.S			;No - fail
					;Yes - fall into setsysv

;Subroutine to set value of system characteristic which has a 4 byte value
;	c{EAX} = Value to store
;	c{EBX} = Data value
;	CALL	knlSetSysVal
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlSetSysVal::
	MOVL	[EBX], EAX		;Set value
	CLC
	RET

;Here if value is out of range

12$:	MOVL	EAX, #ER_CHARV
	STC
	RET
.PAGE
;Subroutine to get value of system characteristic which has a value of "YES"
;  or "NO" and is stored as a bit in knlSysDescp
;	c{EBX} = Bit number
;	CALL	knlGetSysYN
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value ("YES" or "NO")

knlGetSysYN::
	MOVL	EAX, #'NO'		;Assume value is NO
	BTL	knlSysDescp#, EBX	;Right?
	JNC	4$.S			;Yes
	MOVL	EAX, #'YES'		;No - its YES
	CLC
4$:	RET

;Subroutine to set value of system characteristic which has a value of "YES"
;  or "NO" and is stored as a bit in knlSysDescp
;	c{EAX} = New value ("YES" or "NO")
;	c{EBX} = Bit number
;	CALL	knlSetSysYN
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

knlSetSysYN::
	CALL	knlGetYesNo#
	JC	4$.S
	JE	6$.S			;If YES
	BTZL	knlSysDescp#, EBX	;If NO
	CLC
	RET

6$:	BTSL	knlSysDescp#, EBX
	CLC
	RET

;Subroutine to get value of system characteristic which has a 4 byte value
;  which is returned as number of KB and stored as number of bytes
;	c{EBX} = Data value
;	CALL	knlGetSysP
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

knlGetSysP::
	MOVL	EAX, [EBX]		;Get value
	SHRL	EAX, #10t		;Change to number of pages
retclc:	CLC
	RET

;Subroutine to get value of memory size characteristic which has a 4 byte
;  value - value returned is system value times 4
;	c{EBX} = Data value
;	cALL	getmems
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getmems:MOVL	EAX, [EBX]
	CMPL	EAX, #-1.B
	JNE	8$.S
	CLRL	EAX
8$:	SHLL	EAX, #2
	RET

;Subroutine to set value of memory size characteristic which has a 4 byte
;  value - value set is 1/4 the specified value (rounded up)
;	c{EBX} = Data value
;	c{EAX} = Value to store
;	CALL	setmems
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

setmems:ADDL	EAX, #3.B
	SHRL	EAX, #2
	JNE	10$.S
	DECL	EAX
10$:	MOVL	[EBX], EAX
	CLC
	RET
.PAGE
;Subroutine to set value of system characteristic which has a repeated long
;  numeric value - the value specified is stored in each element of the array

knlDcSetLongRpt::
	SHRL	ECX, #2			;Change to number of longs
	PUSHL	DS
	POPL	ES
	MOVL	EDI, EBX
	CLD
	RSTOSL	[EDI]			;Store value
	CLC				;Make sure C is clear
	RET

;Subroutine to set value of generic ACCESS characteristic - This is a 4 byte
;  text characteristic which must be upper case.
;	c{EBX} = Offset of value

knlSetAccess::
	CMPB	[EBX], #0		;Do we have a value now?
	JNE	knlBadCharV#		;Yes - fail!
	MOVL	ECX, #4			;No - make sure name is all upper case
2$:	CMPB	AL, #'a'
	JB	4$.S
	ADDB	AL, #'A'-'a'
4$:	RORL	EAX, #8t
	LOOP	ECX, 2$
	MOVL	[EBX], EAX		;Store new value
	CLC
	RET
.PAGE
;Subroutine to get value of the PROCTYPE SYSTEM characteristic
;	CALL	getproctype
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX,EAX} = Value

getproctype:
	MOVZBL	EAX, proctype#		;Get processor type
	MOVL	EAX, proctbl-4[EAX*4]	;Get corresponding string
	MOVL	EDX, #'X'
	RET

	DATA

proctbl:.LONG	'386S'		;PROC_386SX = 1
	.LONG	'386D'		;PROC_386DX = 2
	.LONG	'486S'		;PROC_486SX = 3
	.LONG	'486D'		;PROC_486DX = 4

	CODE

;Subroutine to get value of the FPUTYPE SYSTEM characteristic
;	CALL	getfputype
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX,EAX} = Value

getfputype:
	MOVZBL	EDX, fputype#		;Get FPU type
	MOVL	EAX, fputtbl+0[EDX*8]	;Get corresponding string
	MOVL	EDX, fputtbl+4[EDX*8]
	RET

	DATA

fputtbl:.LONG	'NONE', 0	;FPU_NONE = 0
	.LONG	'8038', '7'	;FPU_387  = 1
	.LONG	'8048', '7'	;FPU_487  = 2

	CODE

;Subroutine to get value of the FPUENB SYSTEM characteristic
;	CALL	getfpusenb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX,EAX} = Value

getfpusenb:
	MOVZBL	EDX, fpustate#		;Get FPU state
	MOVL	EAX, fpustbl+0[EDX*8]	;Get corresponding string
	MOVL	EDX, fpustbl+4[EDX*8]
	RET

;Subroutine to set value of the FPUENB SYSTEM characteristic
;	CALL	getfpusenb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX,EAX} = Value

setfpusenb:
	MOVL	EBX, #fpustbl
	MOVL	ECX, #2
	CALL	knlGetDcVal1#
	JC	10$.S
	CMPB	AL, #0			;Want to disable it?
	JE	4$.S			;Yes - thats always OK
	CMPB	fputype#, #FPU_NONE	;No - do we have an FPU?
	JE	10$.S			;No - ignore this
4$:	CMPB	fpustate, AL		;Yes - are we changing the state?
	JE	10$.S			;No
	CMPB	AL, #0			;Yes - is it enabled now?
	JNE	6$.S			;No
	FNINIT				;Yes - reset the FPU
6$:	MOVB	fpustate, AL		;Store new state
	MOVL	EDX, CR0		;Update the hardware bits
	ANDB	DL, #~06h
	ORB	DL, fpudata[EAX]
	MOVL	CR0, EDX
	CMPB	AL, #0			;Is the FPU enabled now?
	JE	10$.S			;No
	FNINIT				;Yes - reset it
10$:	RET

	DATA

fpustbl:.LONG	'NO' , 0
	.LONG	'YES', 0

fpudata:.BYTE	04h, 02h

	CODE
.PAGE
;Subroutine to get value of the USER PROCESS characteristic
;	c{EDX}    = Data value (offset of 32 byte block in PDA containing value)
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	getusername
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

getusername:
	PUSHL	EBX
	MOVL	EBX, EDX
	CALL	sesrdpntr
	MOVL	EDX, EBX
	POPL	EBX
	JNC	2$.S
	RET

;Subroutine to get value of the DFLTUSER SYSTEM characteristic
;	c{EDX}    = Data value (offset of 32 byte block containing value)
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	knlGetDfltUser
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

knlGetDfltUser::
	PUSHL	DS
	POPL	FS
2$:	PUSHL	EBX
	PUSHL	EDX
	CALL	getuser
	POPL	EDX
	JC	4$.S
	CMPL	EBX, [ESP]		;Was the group null?
	JE	4$.S			;Yes
	DECL	ECX			;No
	JS	10$.S
	IFFAULT	knlRtnAdrErP1#
	MOVB	ES:[EBX], #'.'
	INCL	EBX
	ADDL	EDX, #16t.B
	CALL	getuser
4$:	POPL	EDX
	JC	8$.S
	DECL	ECX
	JS	6$.S
	IFFAULT	knlRtnAdrEr#
	MOVB	ES:[EBX], #0
6$:	MOVL	ECX, EBX
	SUBL	ECX, EDX
8$:	RET

10$:	POPL	EAX
12$:	JMP	knlBadCharS

getuser:MOVB	AH, #16t
14$:	MOVB	AL, FS:[EDX]
	INCL	EDX
	CMPB	AL, #0
	JE	16$.S
	DECL	ECX
	JS	12$.S
	IFFAULT	knlRtnAdrEr#
	MOVB	ES:[EBX], AL
	INCL	EBX
	DECB	AH
	JNE	14$.S
16$:	RET
.PAGE
;Subroutine to set value of the USER PROCESS characteristic
;	c{EDX}    = Data value (offset of 32 byte block (in PDA) to receive
;		      value)
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	setusername
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

setusername:
	PUSHL	EBX
	MOVL	EBX, EDX
	CALL	sesmdpntr
	MOVL	EDX, EBX
	POPL	EBX
	JNC	2$.S
	RET

;Subroutine to set value of the DFLTUSER SYSTEM characteristic
;	c{EDX}    = Data value (offset of 32 byte block to receive value)
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	knlSetDfltUser
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

knlSetDfltUser::
	PUSHL	DS
	POPL	FS
2$:	TESTL	ECX, ECX
	JNE	4$.S
	MOVL	ECX, #100t
4$:	PUSHL	EBX			;First scan the string to make sure
	PUSHL	EDX			;  it contains only valid characters
	PUSHL	ECX			;  and that each part is not too long
	MOVB	AH, #0
6$:	MOVL	EDX, #16t
	IFFAULT	knlRtnAdrErP3#
8$:	DECL	ECX
	JS	20$.S
	MOVB	AL, ES:[EBX]
	INCL	EBX
	CMPB	AL, #0
	JE	20$.S
	CMPB	AL, #'.'
	JE	18$.S
	CMPB	AL, #'-'
	JE	16$.S
	CMPB	AL, #'_'
	JE	16$.S
	CMPB	AL, #'a'
	JB	10$.S
	CMPB	AL, #'z'
	JA	10$.S
	ADDB	AL, #'A'-'a'
10$:	CMPB	AL, #'A'
	JB	14$.S
	CMPB	AL, #'Z'
	JBE	16$.S
12$:	POPL	ECX
	POPL	EDX
	POPL	EBX
	MOVL	EAX, #ER_CHARV
	STC
	RET

;Here if not letter

14$:	CMPB	AL, #'0'
	JB	16$.S
	CMPB	AL, #'9'
	JA	12$.S
16$:	DECL	EDX
	JNS	8$.S
	JMP	12$.S

;Here if have period

18$:	CMPB	AH, #0
	JNE	12$.S
	MOVB	AH, #1
	JMP	6$.S

;Here at end of string

20$:	POPL	ECX
	POPL	EDX
	POPL	EBX
	CMPB	AH, #0			;Was a group specified?
	JNE	22$.S			;Yes
	MOVL	FS:[EDX], #'USER'	;No - make it USER
	CLRL	EAX
	MOVL	FS:6t.B[EDX], EAX
	MOVL	FS:10t.B[EDX], EAX
	MOVL	FS:14t.B[EDX], EAX
	JMP	24$.S

;Here if a group was specified

22$:	PUSHL	EDX
	CALL	strname
	POPL	EDX
	JC	34$.S
24$:	ADDL	EDX, #16t.B
strname:MOVB	AH, #16t
26$:	DECL	ECX
	JS	30$.S
	MOVB	AL, ES:[EBX]
	INCL	EBX
	CMPB	AL, #0
	JE	30$.S
	CMPB	AL, #'.'
	JE	30$.S
	CMPB	AL, #'a'
	JB	28$.S
	ADDB	AL, #'A'-'a'
28$:	MOVB	FS:[EDX], AL
	INCL	EDX
	DECB	AH
	JMP	26$.S

;Here at end of name

30$:	DECB	AH
	JS	32$.S
	MOVB	FS:[EDX], #0
	INCL	EDX
	JMP	30$.S

32$:	CLC
34$:	RET
.PAGE

getparent:
	CALL	getproc
	MOVZWL	EAX, FS:pdaParProc#
	ORL	EAX, EAX
	JE	4$.S
	MOVW	FS, knlProcTable[EAX*2]
	MOVL	EAX, FS:pdaPid#
4$:	RET
.PAGE
;Subroutine to get value of the LOADDATE SYSTEM characteristic
;	CALL	getloaddate
;	C:clr Always
;	c{EDX,EAX} = Value

getloaddate:
	CLI
	MOVL	ECX, knlSysDate#	;Get current date and time
	MOVL	EBX, knlTickCnt#
	MOVL	EAX, knlTickTtl#	;Get time since loaded
	STI
	MULL	lit3E22E29#
	SHRDL	EAX, EDX, #16t
	SHRL	EDX, #16t
	MOVL	ESI, EAX
	MOVL	EDI, EDX
	MOVL	EAX, EBX
	MULL	lit3E22E29#
	SHRDL	EAX, EDX, #16t
	SHRL	EDX, #16t
	ADDL	EDX, ECX
	SUBL	EAX, ESI
	SBBL	EDX, EDI
	JNC	4$.S
	CLRL	EAX
	CLRL	EDX
4$:	RET
.PAGE
;Subroutine to get value of the DEBUG SYSTEM characteristic
;	CALL	getdebug
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getdebug::
	MOVL	EAX, #'NO'		;Assume debugger not loaded
	MOVL	EDX, #geckodtop#  	;Right?
	CMPL	EDX, #1000h
	JBE	10$.S			;Yes
	MOVL	EAX, #'YES'		;No - its loaded
10$:	RET
.PAGE
;Here for the INTMUL and FPUDIV characteristics - get information about
;  processor bugs

getprocbug:
	MOVL	EAX, #'PASS'		;Assume its OK
	CMPB	[EBX], #0		;Right?
	JE	2$.S			;Yes
	MOVL	EAX, #'FAIL'		;No - assume it failed
	JNS	2$.S			;Right?
	MOVL	EAX, #'N/A'		;No
2$:	RET


;Here for the CRSHDATA characteristic - get saved crash data

getcrash:
	CMPL	ECX, #pg0_crshSIZE#	;Is his array big enough?
	JL	knlBadCharS.S		;No
	MOVL	EDI, EBX		;Yes - get address in right register
	MOVL	ESI, #crshsave
	CLD
	MOVL	ECX, #pg0_crshSIZEo4#
	IFFAULT	knlRtnAdrEr#
	RMOVSL	[EDI], [ESI]		;Give him the data
	MOVL	ECX, #pg0_crshSIZE#	;Return amount
	RET

;Here if his array is too small

knlBadCharS::
	MOVL	EAX, #ER_CHARS		;Get error code
	STC
	RET

;Here for the SSTATE characteristic - set system state value

setsstate:
	CMPW	SS:pdaPid#, #1.B	;Is this process INIT?
	JNE	knlPrivFail#		;No - can't change this one!
	MOVL	sysstate#, EAX		;Yes - store new value
	RET

;Here for the HIDMA characteristic - set DMA high memory address limit

sethighdma:
	MOVL	hidmalmt#, EAX		;Just store what he gave us
	CLC
	RET
.PAGE
;Here for the CRSHDATA characteristic - set saved crash data.  This is used
;  only to change the data logged indicator.  Only the first byte of the
;  data is looked at.  If it is 0, the saved crash data is marked as not
;  logged.  If it is not 0, the saved crash data is marked as logged.

setcrash:
	MOVB	AL, #0			;Assume want to mark it as logged
	IFFAULT	knlRtnAdrEr#
	CMPB	ES:[EBX], #0		;Right?
	JE	4$.S			;Yes
	MOVB	AL, #0F0h		;No
4$:	MOVB	crshsave+3, AL		;Store indicator
	RET

;Here to set the REBOOT characteristic.  This reboots the system is the correct
;  "magic" value is used.

setreboot:
	CMPL	EAX, #57575h		;Right value for "soft" reboot?
	JE	knlReboot#		;Yes - reboot!
	CMPL	EAX, #5757Ah		;Right value for "hard" reboot?
	JE	6$.S			;Yes
	CLC				;No - ignore it
	RET

6$:	JMPIL	knlPhysReset#
.PAGE
	.SBTTL	PROCESS class, get NAME characteristic

;Subroutine to get value of the PROCESS class NAME characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	getprocname
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

getprocname:
	CALL	getproc			;Get selector for PDA for process
	MOVL	ESI, #pdaName#
	MOVL	EDI, EBX
	CLRL	EDX
	CLD
2$:	DECL	ECX
	JLE	knlBadCharV#
	LODSB	FS:[ESI]		;Get character
	IFFAULT	knlRtnAdrEr#
	STOSB	[EDI]			;Store it
	CMPB	AL, #0			;End of name?
	JE	4$.S			;Yes
	INCL	EDX			;No - count the character
	CMPB	DL, #32t		;More?
	JB	2$.S			;Yes
4$:	MOVL	ECX, EDX		;No - get length stored
	RET				;Finished

	.SBTTL	PROCESS class, get 2 byte item from PDA

;Subroutine to get value of a 2 byte item from a PDA
;	c{EBX}    = Offset of value to get
;	CALL	getpda2byte
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value obtained

getpda2byte:
	CALL	getproc
	MOVZWL	EAX, FS:[EBX]
	RET

	.SBTTL	PROCESS class, get 4 byte item from PDA

;Subroutine to get value of a 4 byte item from a PDA
;	c{EBX}    = Offset of value to get
;	CALL	getpda4byte
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value obtained

getpda4byte:
	CALL	getproc
	MOVL	EAX, FS:[EBX]
	RET

getsys4bytp:
	MOVW	FS, knlProcTable+2
	JMP	10$.S

;Subroutine to get value of PDA characteristic which has a 4 byte value
;  which is returned as number of KB and stored as number of bytes
;	c{EBX} = Data value
;	CALL	getpda4bytp
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getpda4bytp:
	CALL	getproc
10$:	MOVL	EAX, FS:[EBX]
	SHRL	EAX, #10t		;Change to KB
	CLC
	RET

;Subroutine to get value of PDA characteristic which has a 4 byte value
;  which is returned as number of KB and stored as number of pages
;	c{EBX} = Data value
;	CALL	getpda4bytq
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getpda4bytq:
	CALL	getproc
	MOVL	EAX, FS:[EBX]
	SHLL	EAX, #2t		;Change to KB
	CLC
	RET
.PAGE
;Subroutine to get value of process memory size characteristic which has a 4
;  byte value - value returned is system value times 4
;	c{EBX} = Data value
;	CALL	getpdamems
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getpdamems:
	CALL	getproc
	MOVL	EAX, FS:[EBX]
	CMPL	EAX, #-1.B
	JNE	4$.S
	CLRL	EAX
4$:	SHLL	EAX, #2
	RET

;Subroutine to set value of process memory size characteristic which has a 4
;  byte value (value set is 1/4 the specified value (rounded up)) - value is
;  checked against the corresponding limit value
;	c{EBX} = Data value
;	c{EAX} = Value to store
;	CALL	setpdameml
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

setpdamemsl:
	LEAL	EDX, 4.B[EBX]		;Check new value against allowed value
	JMP	6$.S			;Continue

;Subroutine to set value of process memory size characteristic which has a 4
;  byte value which can only be reduced (value set is 1/4 the specified value
;  (rounded up))
;	c{EBX} = Data value
;	c{EAX} = Value to store
;	CALL	setpdamemsr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

setpdamemsr:
	MOVL	EDX, EBX		;Check new value against old value
6$:	ADDL	EAX, #3.B		;Change to number of pages (round up)
	SHRL	EAX, #2
	JNE	8$.S			;If not 0
	DECL	EAX			;0 - change to infinity
8$:	CALL	getproc			;Get PDA selector
	CMPL	FS:[EDX], EAX		;Is the new value smaller?
	JB	10$.S			;No - do nothing!
	MOVL	FS:[EBX], EAX		;Yes - update the value
10$:	CLC
	RET
.PAGE
	.SBTTL	PROCESS class, get CONTRM characteristic

;Subroutine to get value of the PROCESS class CONTRM characteristic
;	CALL	getcontrm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX,EAX} = Value obtained

getcontrm:
	CALL	getproc
	MOVL	EAX, FS:pdaHndlTbl#	;Get offset of his handle table
	MOVL	EAX, FS:DH_STDTRM*32t[EAX]
	CMPL	EAX, #1000h
	JB	10$.S
	ADDL	EAX, #dcb_name.B
	CLC
	RET

;Here if do not have a controlling terminal

10$:	CLRL	EAX			;Just return a null name
	RET
.PAGE
	.SBTTL	PROCESS class, get FPUENB characteristic

;Subroutine to get value of the PROCESS class FPUENB characteristic
;	CALL	getfpuenb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getfpuenb:
	CALL	getproc
	MOVL	EAX, #'YES'		;Assume enabled
	TESTB	FS:pdaStatus1#, BL	;Right?
	JNE	4$.S			;Yes
	MOVL	EAX, #'NO'		;No
4$:	RET
.PAGE
	.SBTTL	PROCESS class, get LALARGE characteristic

;Subroutine to get value of the PROCESS class LALARGE characteristic
;	CALL	getlalarge
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getlalarge:
	MOVL	EBP, SS:pdaLATable#
	CLRL	EAX
	MOVL	ECX, #LAH_BOTTOM*16t	;Start with first LAD
2$:	MOVZWL	EBX, lad_next.B[EBP+ECX] ;Get next LAD
	SHLL	EBX, #4t
	JE	6$.S			;If finished
	MOVL	EDX, lad_base.B[EBP+EBX] ;No - get base of next LAD
	SUBL	EDX, lad_base.B[EBP+ECX] ;Minus base of this LAD
	SUBL	EDX, lad_size.B[EBP+ECX] ;Minus size of this LAD
	CMPL	EAX, EDX		;New maximum?
	JA	4$.S			;No
	MOVL	EAX, EDX		;Yes - remember the new maximum
4$:	MOVL	ECX, EBX		;Adance to next block
	JMP	2$.S			;Continue

;Here when finished

6$:	SHRL	EAX, #10t		;Change to KB
	CLC
	RET
.PAGE
	.SBTTL	PROCESS class, get FILEPROT characteristic

;Subroutine to get value of the PROCESS class FILEPROT characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	getfileprot
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

fptbl:	.BYTE	FP$EXEC  , 'X'
	.BYTE	FP$READ  , 'R'
	.BYTE	FP$WRITE , 'W'
	.BYTE	FP$EXTEND, 'E'
	.BYTE	FP$MODIFY, 'M'
	.BYTE	0

fldltrs:.ASCII	'_N'
	.LONG	FP_NETWORK
	.ASCII	' W'
	.LONG	FP_WORLD
	.ASCII	' G'
	.LONG	FP_GROUP
	.ASCII	' O'
	.LONG	FP_OWNER
	.BYTE	0

getfileprot:
	MOVL	EDX, #pdaFileProt#
	MOVL	ESI, #fptbl
	JMP	4$.S

;Subroutine to get value of the PROCESS class DIRPROT characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	getdirprot
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

dptbl:	.BYTE	FP$ACCESS, 'A'
	.BYTE	FP$SEARCH, 'S'
	.BYTE	FP$CREATE, 'C'
	.BYTE	FP$MODIFY, 'M'
	.BYTE	0

getdirprot:
	MOVL	EDX, #pdaDirProt#
	MOVL	ESI, #dptbl
4$:	MOVZBL	EAX, SS:pdaSesProc#
	MOVW	FS, knlProcTable[EAX*2]
	MOVL	EAX, FS:[EDX]

;Subroutine to generate text string from file/directory protection value
;	c{EAX}    = Protection value
;	c{ES:EBX} = Address of buffer
;	c{ECX}    = Size of buffer
;	c{ESI}    = Offset of bit/letter table
;	CALL	knlEncodeFileProt
;	C:set = Error
;	  c{EAX} = Error
;	C:clr = Normal
;	  c{ECX} = Length of string stored

knlEncodeFileProt::
	MOVL	EDI, #fldltrs
	TESTL	ECX, ECX
	JNE	6$.S
	MOVL	ECX, #1000t
6$:	PUSHL	EBX
8$:	PUSHL	EAX
	CLRL	EDX
	DIVL	CS:2.B[EDI]
	MOVL	EDX, EAX
	PUSHL	ESI
	MOVB	AL, CS:[EDI]
	CMPB	AL, #'_'
	JE	10$.S
	CALL	strpchr
	JC	20$.S
10$:	MOVB	AL, CS:1.B[EDI]
	CALL	strpchr
	JC	20$.S
	MOVB	AL, #':'
	CALL	strpchr
	JC	20$.S
	CMPB	DL, #0
	JE	16$.S
12$:	TESTB	CS:[ESI], DL
	JE	14$.S
	MOVB	AL, CS:1.B[ESI]
	CALL	strpchr
	JC	20$.S
14$:	ADDL	ESI, #2.B
	CMPB	CS:[ESI], #0
	JNE	12$.S
	JMP	18$.S

;Here if no bits are set

16$:	MOVB	AL, #'N'
	CALL	strpchr
	JC	20$.S
18$:	POPL	ESI
	POPL	EAX
	ADDL	EDI, #6t
	CMPB	CS:[EDI], #0
	JNE	8$.S
	POPL	EDX
	SUBL	EBX, EDX
	MOVL	ECX, EBX
	RET

;Here if error

20$:	POPL	ESI			;Fix up the stack
	POPL	EDX
	POPL	EDX
	RET
.PAGE
;Subroutine to store characters to indicate access
;	c(AL) = Initial character
;	c(DL) = Protection value
;	c{ESI} = Offset of value table
;	CALL	stracc
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

strpchr:DECL	ECX
	JE	knlBadParmV#
	IFFAULT	knlRtnAdrEr#
	MOVB	ES:[EBX], AL
	INCL	EBX
	CLC
	RET
.PAGE
	.SBTTL	PROCESS class, set FILEPROT characteristic

;Subroutine to set value of the PROCESS class FILEPROT characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	setfileprot
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

setfileprot:
	MOVL	EDX, #fptbl
	MOVZBL	EDX, SS:pdaSesProc#
	MOVW	FS, knlProcTable[EDX*2]
	MOVL	EAX, FS:pdaFileProt#
	CALL	knlParseFileProt
	JC	2$.S
	MOVL	FS:pdaFileProt#, EAX
2$:	RET

	.SBTTL	PROCESS class, set DIRPROT characteristic

;Subroutine to set value of the PROCESS class DIRPROT characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	setdirprot
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

setdirprot:
	MOVL	EDX, #dptbl
	MOVZBL	EDX, SS:pdaSesProc#
	MOVW	FS, knlProcTable[EDX*2]
	MOVL	EAX, FS:pdaDirProt#
	CALL	knlParseFileProt
	JC	4$.S
	MOVL	FS:pdaDirProt#, EAX
4$:	RET
.PAGE
;Subroutine to parse file/directory protection specficiation
;	c{EAX}    = Current protection value
;	c{ES:EBX} = Address of string to parse
;	c{ECX}    = Length of string
;	c{EDX}    = Offset of letter/bit table
;	CALL	knlParseFileProt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = New protection value
;  FS is preserved

$$$=!0
FRM sp_table, 4t
FRM sp_value, 4t
FRM sp_field, 1t
FRM sp_func , 1t
FRM         , 2t
sp_SIZE=!$$$

knlParseFileProt::
	ENTER	sp_SIZE, 0
	MOVL	sp_table.B[EBP], EDX
	MOVL	sp_value.B[EBP], EAX
2$:	CALL	getpchr			;Get character
	JC	10$.S
	JE	9$.S			;If end of string
	JS	4$.S
	CMPB	AL, #' '		;Ignore spaces
	JE	2$.S
	JMP	8$.S

;Here with character followed by a colon

4$:	ANDB	AL, #7Fh
	MOVL	EDI, #fldltrs		;Search the field letter table
6$:	CMPB	CS:1.B[EDI], AL
	JE	12$.S			;If found it
	ADDL	EDI, #6t.B
	CMPB	CS:[EDI], #0		;More to check?
	JNE	6$.S			;Yes - continue
8$:	JMP	knlBadParmVLv#		;No - fail

;Here when completely finished

9$:	MOVL	EAX, sp_value.B[EBP]	;Get value
	CLC
10$:	LEAVE
	RET

;Here with match on field identifier

12$:	MOVL	EAX, sp_value.B[EBP]	;Get value for field to change
	CLRL	EDX
	DIVL	CS:2.B[EDI]
	MOVB	sp_field.B[EBP], AL
	MOVB	sp_func.B[EBP], #0	;Assume replacing the field
14$:	CALL	getpchr			;Get next character
	JC	10$.S
	JE	36$.S
	JS	22$.S
	CMPB	AL, #' '
	JE	36$.S
	CMPB	AL, #'+'
	JNE	16$.S
	MOVB	sp_func.B[EBP], #1	;Indicate adding value
	JMP	14$.S

16$:	CMPB	AL, #'-'
	JNE	18$.S
	MOVB	sp_func.B[EBP], #-1	;Indicate removing value
	JMP	14$.S

;Here if character is not + or -

18$:	CMPB	AL, #'N'
	JE	24$.S
	MOVL	EDX, sp_table.B[EBP]	;Search for the letter
20$:	CMPB	CS:1.B[EDX], AL
	JE	26$.S
	ADDL	EDX, #2.B
	CMPB	CS:[EDX], #0
	JNE	20$.S
22$:	SUBL	EBX, #2.B		;Didn't find it - back up and then
	ADDL	ECX, #2.B		;  process end of field
	JMP	36$.S

;Here if want to clear the field

24$:	MOVB	AL, #0
	JMP	28$.S

;Here with match on character

26$:	MOVB	AL, CS:[EDX]		;Get corresponding value
28$:	CMPB	sp_func.B[EBP], #0
	JG	30$.S			;If adding
	JL	32$.S			;If removing
	MOVB	sp_field.B[EBP], AL	;Replacing
	JMP	34$.S

;Here if adding to the current value

30$:	ORB	sp_field.B[EBP], AL
	JMP	34$.S

;Here if removing from the current value

32$:	NOTB	AL
	ANDB	sp_field.B[EBP], AL
34$:	MOVB	sp_func.B[EBP], #1
	JMP	14$.S

;Here when finished with a field

36$:	MOVL	EDX, #7Fh		;Get mask for field
	IMULL	EDX, CS:2.B[EDI]
	NOTL	EDX
	MOVZBL	EAX, sp_field.B[EBP]	;Position value
	IMULL	EAX, CS:2.B[EDI]
	ANDL	sp_value.B[EBP], EDX	;Merge in new field value
	ORL	sp_value.B[EBP], EAX
	JMP	2$			;Continue
.PAGE
;Subroutine to get next protection character
;	c{ECX}    = Number of character left to get
;	c{ES:EBX} = Address of user string
;	CALL	getpchr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = End of string
;	  Z:clr = Normal
;	    S:set = Colon follows character
;	    c(AL) = Character (ored with 80h if colon follows)

	IFFAULT	knlRtnAdrEr#
getpchr:TESTL	ECX, ECX
	JE	8$.S
	DECL	ECX
	MOVB	AL, ES:[EBX]
	INCL	EBX
	CMPB	AL, #0
	JE	8$.S
	CMPB	AL, #'a'
	JB	4$.S
	ADDB	AL, #'A'-'a'
4$:	TESTL	ECX, ECX
	JE	6$.S
	IFFAULT	knlRtnAdrEr#
	CMPB	ES:[EBX], #':'		;Is the next character a colon?
	JE	10$.S			;Yes
6$:	TESTL	ESP, ESP
8$:	RET

;Here if have a colon following the character

10$:	DECL	ECX			;Eat the colon
	INCL	EBX
	ORB	AL, #80h
	RET
.PAGE
	.SBTTL	PROCESS class, get PRIV characteristic

;Subroutine to get value of the PROCESS class PRIV characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	getpriv
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

getprivcur:
	CALL	getproc			;Get selector for PDA
	MOVL	ESI, #pdaActPriv#	;Point to active privilege bits
	JMP	2$.S

	.SBTTL	PROCESS class, get PRIVAVL characteristic

;Subroutine to get value of the PROCESS class PRIVACL characteristic
;	c{EDX}    = Data value
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	getprivavl
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

$$$=!0
FRM gp_string, 4t
gp_SIZE=!$$$

getprivavl:
	CALL	getproc			;Get selector for PDA
	JC	20$.S
	MOVL	ESI, #pdaAvlPriv#	;Point to privilege available bits
2$:	ENTER	gp_SIZE, 0
	MOVL	gp_string.B[EBP], EBX
	MOVL	EDI, EBX
	MOVL	EDX, ECX
	MOVL	EBX, #privtbl
4$:	MOVL	EAX, 8.B[EBX]		;Get bit number
	TESTL	EAX, EAX		;Is this "NONE"?
	JNS	6$.S			;No
	MOVL	EAX, FS:[ESI]		;Yes - are any bits set?
	ORL	EAX, FS:4.B[ESI]
	JNE	14$.S			;Yes - go on
	JMP	7$.S			;No - give him "NONE"

6$:	BTL	FS:[ESI], EAX		;Is it set?
	JNC	14$.S			;No - go on
7$:	CMPL	gp_string.B[EBP], EDI	;Yes - is this the first one?
	JE	8$.S			;Yes
	MOVB	AL, #'+'		;No - put in a plus
	DECL	EDX
	JLE	22$.S
	IFFAULT	knlRtnAdrErLv#
	STOSB	[EDI]
8$:	PUSHL	EBX
	MOVL	ECX, #8
10$:	MOVB	AL, [EBX]		;Copy privilege name to user's
	INCL	EBX			;  buffer
	CMPB	AL, #0
	JE	12$.S
	DECL	EDX
	JLE	22$.S
	IFFAULT	knlRtnAdrErLv#
	STOSB	[EDI]
	LOOP	ECX, 10$
12$:	POPL	EBX
14$:	ADDL	EBX, #12t.B		;Bump privilege table pointer
	CMPL	[EBX], #0.B		;More in table?
	JNE	4$.S			;Yes - continue
	MOVL	ECX, EDI		;No - calculate length of string
	SUBL	ECX, gp_string.B[EBP]
	CLRL	EAX
	IFFAULT	knlRtnAdrErLv#
	STOSB	[EDI]			;Store final null
	LEAVE
20$:	RET				;Finished

;Here if user's buffer is too small

22$:	MOVL	EAX, #ER_CHARS		;Get error code
	LEAVE
	STC				;Indicate error
	RET
.PAGE
;Subroutine to parse a privlege list
;	c{EDX,EAX} = Current privlege bits
;	c{ES:EBX}  = Address of privlege list
;	CALL	parsepriv
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX,EAX} = Modified privlege bits
;  FS is respected

$$$=!0
FRM pp_bits   , 8t	;Privilege bits
FRM pp_atom   , 8t	;Atom buffer
FRM pp_prefix , 1t	;Prefix character
FRM pp_stopper, 1t	;Stopper character
FRM           , 2t
pp_SIZE=!$$$

parsepriv::
	ENTER	pp_SIZE, 0
	MOVL	pp_bits+0.B[EBP], EAX
	MOVL	pp_bits+4.B[EBP], EDX
	MOVL	ESI, EBX
	PUSHL	ES
	POPL	GS
	IFFAULT	knlRtnAdrErLv#
	LODSB	GS:[ESI]	;Get first character
	CMPB	AL, #'-'	;Incremental specification?
	JE	4$.S		;No
	CMPB	AL, #'+'	;Maybe
	JE	4$.S		;Yes
	CLRL	EAX		;No - clear the bits
	MOVL	pp_bits+0.B[EBP], EAX
	MOVL	pp_bits+4.B[EBP], EAX
	DECL	ESI
4$:	MOVB	pp_prefix.B[EBP], AL ;Store prefix character for atom
	CLRL	EAX		;Clear atom buffer
	MOVL	pp_atom+0.B[EBP], EAX
	MOVL	pp_atom+4.B[EBP], EAX
	LEAL	EDI, pp_atom.B[EBP]
	PUSHL	SS
	POPL	ES
	MOVL	ECX, #8
	IFFAULT	knlRtnAdrErLv#
6$:	LODSB	GS:[ESI]	;Get character
	CMPB	AL, #' '
	JE	6$.S
	CMPB	AL, #HT
	JE	6$.S
8$:	CMPB	AL, #0
	JE	14$.S
	CMPB	AL, #'+'
	JE	14$.S
	CMPB	AL, #'-'
	JE	14$.S
	CMPB	AL, #' '
	JE	10$.S
	CMPB	AL, #HT
	JE	10$.S
	DECL	ECX		;Room for more?
	JS	24$.S		;No
	CMPB	AL, #'a'	;Yes - lower case?
	JB	9$.S		;No
	CMPB	AL, #'z'	;Maybe
	JA	9$.S		;No
	SUBB	AL, #'a'-'A'	;Yes - change to upper case
9$:	STOSB	[EDI]		;Store in atom
	IFFAULT	knlRtnAdrErLv#
	LODSB	GS:[ESI]	;Get next character
	JMP	8$.S		;Continue

;Here at end of atom

	IFFAULT	knlRtnAdrErLv#	;Eat the whitespace
10$:	LODSB	GS:[ESI]
	CMPB	AL, #0
	JE	14$.S
	CMPB	AL, #' '
	JE	10$.S
	CMPB	AL, #HT
	JE	10$.S
14$:	MOVB	pp_stopper.B[EBP], AL	;Store stopper character
	MOVL	EAX, pp_atom+0.B[EBP]	;Get the atom
	MOVL	EDX, pp_atom+4.B[EBP]
	MOVL	ECX, #NUMPRIV		;Set up to search table
	MOVL	EBX, #privtbl
20$:	CMPL	EAX, [EBX]		;This one?
	JNE	22$.S			;No
	CMPL	EDX, 4.B[EBX]		;Maybe
	JE	26$.S			;Yes
22$:	ADDL	EBX, #12t.B		;No - advance to next table entry
	LOOP	ECX, 20$		;Continue if more to check
24$:	MOVL	EAX, #ER_CHARV		;Not there - get error code
	LEAVE
	STC				;Indicate error
	RET

;Here with match on atom name

26$:	MOVL	EAX, 8.B[EBX]		;Get bit number
	TESTL	EAX, EAX		;Is it "NONE"?
	JS	30$.S			;Yes - don't set or clear anything
	CMPB	pp_prefix.B[EBP], #'-'	;No - want to remove privlege?
	JE	28$.S			;Yes
	BTSL	pp_bits.B[EBP], EAX	;No - set the bit for the privlege
	JMP	30$.S

28$:	BTZL	pp_bits.B[EBP], EAX	;Clear the bit for the privlege
30$:	MOVB	AL, pp_stopper.B[EBP]	;Get stopper character
	CMPB	AL, #0			;End of string?
	JNE	4$			;No - continue
	MOVL	EAX, pp_bits+0.B[EBP]	;Yes - get privlege bits
	MOVL	EDX, pp_bits+4.B[EBP]
	LEAVE
	RET
.PAGE
	.SBTTL	Privilege name table

	.MACRO	PP  name
$$$=$
	.ASCII	"name"
	.BLKB	8-{$-$$$}
	.LONG	PP%'name
	.ENDM

PP%NONE=!-1

	DATA

	.MOD	4
privtbl:PP	SYSADMIN	;PP%SYSADMIN = 31 - System administrator
				;		      privileges
	PP	GRPADMIN	;PP%GRPADMIN = 30 - Group administrator
				;		      privileges
	PP	OPER		;PP%OPER     = 29 - Operator privileges
	PP	ANYLOGIN	;PP%ANYLOGIN = 28 - Can do login at any time
	PP	ALLPROC		;PP%ALLPROC  = 27 - May kill or interrupt any
				;		      process
	PP	SYSENV		;PP%SYSENV   = 26 - May change system level
				;		      environment strings
	PP	SESENV		;PP%SESENV   = 25 - May change session level
				;		      environment strings
	PP	SYSLOG		;PP%SYSLOG   = 24 - May change system level
				;		      logical names
	PP	DETACH		;PP%DETACH   = 22 - May detach process
	PP	NEWSES		;PP%NEWSES   = 21 - May create new session
	PP	PORTIO		;PP%PORTIO   = 17 - May directly access IO ports
	PP	SHAREDEV	;PP%SHAREDEV = 16 - May share any device
	PP	ALLIO		;PP%ALLIO    = 15 - May do restricted IO
				;		      operations
	PP	FBYPASS		;PP%FBYPASS  = 14 - Bypass all file access
				;		      checking
	PP	FREADALL	;PP%FREADALL = 13 - Bypass file read access
				;		      checking
	PP	FUSESYS		;PP%FUSESYS  = 12 - Access files using system
				;		      protection
	PP	FSPECIFY	;PP%FSPECIFY = 11 - May specify user for file
				;		      access
	PP	MEMLOCK		;PP%MEMLOCK  = 9  - May lock memory pages in
				;		      place
	PP	NOSWAP		;PP%NOSWAP   = 8  - May lock memory pages in
				;		      memory
	PP	READPHY		;PP%READPHY  = 7  - May read physical memory
	PP	WRITEPHY	;PP%WRITEPHY = 6  - May write physical memory
	PP	READKER		;PP%READKERL = 5  - May read kernel mem.
	PP	WRITEKER	;PP%WRITEKER = 4  - May write kernel mem.
	PP	SCRNSYM		;PP%SCRNSYM  = 1  - May execute screen symbiont
				;		      functions
	PP	LKELOAD		;PP%LKELOAD  = 0  - May execute LKE load
				;		      functions
	PP	NONE
NUMPRIV=!{$-privtbl}/12t
	.LONG	0

	CODE
.PAGE
	.SBTTL	PROCESS class, get SECTAVL characteristic

;Subroutine to get value of the PROCESS class SECTAVL characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	getsectavl
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

getsectavl:
	MOVB	AH, #0h
	JMP	2$.S

	.SBTTL	PROCESS class, get SECTCUR characteristic

;Subroutine to get value of the PROCESS class SECTCUR characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	getsectcur
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

getsectcur:
	MOVB	AH, #1h
2$:	JREGZ	ECX, 4$
	CALL	getproc
	MOVZBL	EDX, FS:pdaSesProc#	;Get selection for the session PDA
	MOVW	GS, knlProcTable#[EDX*2]
	MOVL	ESI, GS:pdaSection#	;Get offset of the section name list
	TESTL	ESI, ESI		;Do we have a list?
	JNE	6$.S			;Yes
	IFFAULT	knlRtnAdrEr#		;No - return a null list
	MOVB	ES:[EBX], #0
4$:	CLRL	ECX
	RET

;Here with a list to return

6$:	MOVL	EDI, EBX		;Remember where the user's buffer starts
	MOVL	EDX, GS:[ESI]		;Get size of the section name list
	SUBL	EDX, #mb_data.B
	ADDL	ESI, #mb_data.B		;Point to first character
8$:	MOVB	AL, GS:[ESI]		;Get first character
	INCL	ESI
	DECL	EDX
	CMPB	AL, #'a'		;Lower case?
	JB	14$.S			;No - always return the entry
	ADDB	AL, #'A'-'a'		;Yes - convert to upper case
	CMPB	AH, #0			;Want only current entries?
	JE	14$.S			;No - return this one
10$:	MOVB	AL, GS:[ESI]		;Yes - skip this name
	INCL	ESI
	DECL	EDX
	TESTB	AL, #80h
	JE	10$.S
	JMP	18$.S

;Here to get next character

12$:	MOVB	AL, GS:[ESI]		;Get character
	INCL	ESI
	DECL	EDX			;Reduce number left
	TESTB	AL, #80			;End of name?
	JNE	16$.S			;Yes
14$:	CALL	gsstore			;No - store character
	JNC	12$.S			;Continue if no error
	JMP	24$.S			;If error storing character

;Here at end of section name

16$:	ANDB	AL, #7Fh		;Remove high bit
	CALL	gsstore			;Store it
	JC	24$.S			;If error
	MOVB	AL, #'+'		;Store separator character
	CALL	gsstore
	JC	24$.S			;If error
18$:	TESTL	EDX, EDX		;Any more to do?
	JE	20$.S			;No
	CMPB	GS:[ESI], #0		;Maybe
	JNE	8$.S			;Yes
20$:	DECL	EBX
	MOVL	ECX, EBX		;Finished - calculate amount stored
	SUBL	ECX, EDI
	JNS	22$.S			;If something stored
	INCL	EBX			;Nothing stored - fix up the pointer
	CLRL	ECX			;  and count
	IFFAULT	knlRtnAdrEr#		;Store final null (this will replace the
22$:	MOVB	ES:[EBX], #0		;  final seperator character stored)
	BTL	EAX, #31t		;Set C if error
	RET

;Here if error storing character

24$:	MOVL	ECX, EBX
	SUBL	ECX, EDI
	BTL	EAX, #31
	RET

;Subroutine to store data for getsection
;	c(AL)     = Value to store
;	c{ES:EBX} = Address
;	c{ECX}    = Space left
;	CALL	gsstore
;	C:set = Error
;	  c{EAX} = Error code (positive means buffer is full)
;	C:clr = Normal

gsstore:SUBL	ECX, #1.B		;Have any space left?
	JLE	26$.S			;No
	IFFAULT	knlRtnAdrEr#
	MOVB	ES:[EBX], AL		;Yes - store character
	INCL	EBX
	RET

;Here if user's buffer is full

26$:	STC
	RET
.PAGE
	.SBTTL	PROCESS class, set NAME characteristic

;Subroutine to set value of the PROCESS class NAME characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	setprocname
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setprocname:
	CALL	getproc			;Get selector for PDA for process
	MOVL	ESI, EBX
	PUSHL	ES
	POPL	GS
	MOVL	EDI, #pdaName#
	PUSHL	FS
	POPL	ES
	TESTL	ECX, ECX		;Name cannot be zero length!
	JE	2$.S
	IFFAULT	knlRtnAdrEr#
	CMPB	GS:[ESI], #0
2$:	JE	knlBadCharV#
	CMPL	ECX, #12t.B
	JB	4$.S
	MOVL	ECX, #32t
4$:	CLRL	EAX
	MOVL	ES:[EDI], EAX
	MOVL	ES:4.B[EDI], EAX
	MOVL	ES:8.B[EDI], EAX
	CLD
	IFFAULT	knlRtnAdrEr#
6$:	LODSB	GS:[ESI]		;Get character
	STOSB	[EDI]			;Store it
	CMPB	AL, #0			;End of name?
	JE	8$.S			;Yes
	LOOP	ECX, 6$			;No - continue if more
	CLRL	EAX
8$:	RET				;Finished
.PAGE
	.SBTTL	PROCESS class, set NUM characteristic

;Subroutine to set value of the PROCESS class NUM characteristic - this is
;  one way of selecting the process for other characteristic values, it does
;  not actually change the process number
;	c{EAX} = Process number
;	CALL	setprocnum
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setprocnum:
	TESTL	EAX, EAX
	JE	6$.S
	JS	8$.S
2$:	CMPL	EAX, #MAXPROCS		;Valid number?
4$:	JAE	knlBadCharV#		;No
	CMPW	knlProcTable#[EAX*2], #3.B ;Yes - is the slot in use?
	JBE	knlBadCharV#		;No
	MOVW	ES, knlProcTable#[EAX*2] ;Yes - get PDA selector
	CMPL	ES:pdaMagic#, #PDA_MAGIC ;Is this really a PDA?
	JNE	knlBadCharV#		;No - not valid here
	MOVL	chardata#, ES		;Yes - remember the PDA selector
	RET				;Thats all

;Here if want the session process

6$:	MOVL	EAX, #pdaSesProc#
	JMP	10$.S

;Here if want the parent process

8$:	MOVL	EAX, #pdaParProc#
10$:	CMPL	chardata#, #0.B
	JE	12$.S
	MOVL	ES, chardata#
	MOVZWL	EAX, ES:[EAX]
	JMP	2$.S

12$:	MOVZWL	EAX, SS:[EAX]
	JMP	2$.S
.PAGE
	.SBTTL	PROCESS class, set CONTRM characteristic

;Subroutine to set value of the PROCESS class CONTRM characteristic - this is
;  one way of selecting the process for other characteristic values - the
;  process with the highest sequence number which has the specified terminal
;  as its controlling terminal is selected
;	CALL	setprocnum
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setcontrm:
	MOVL	EBX, #1			;Start with process 1
	CLRL	ECX			;Clear highest sequence number found
6$:	CMPW	knlProcTable#[EBX*2], #3.B ;Is this slot in use?
	JBE	8$.S			;No
	MOVW	ES, knlProcTable#[EBX*2] ;Yes - get PDA selector for process slot
	CMPL	ES:pdaMagic#, #PDA_MAGIC ;Is this a process?
	JNE	8$.S			;No
	TESTB	ES:pdaStatus1#, #P1$SETUP ;Yes - is it being set up now?
	JNE	8$.S			;Yes - don't look at it
	MOVL	EDI, ES:pdaHndlTbl#	;No - get its handle table offset
	MOVL	EDI, ES:DH_STDTRM*32t[EDI] ;Yes - get offset of DCB for
	CMPL	EDI, #1000h		   ;  controlling terminal
	JB	8$.S			;If none
	TESTL	EDI, #0F0000000h	;Is this device being transfered now?
	JNE	8$.S			;Yes - skip it
	MOVL	EAX, knlDcValue#+0	;Is this the one we want?
	CMPL	dcb_name+0.B[EDI], EAX
	JNE	8$.S			;No
	MOVL	EAX, knlDcValue#+4	;Maybe
	CMPL	dcb_name+4.B[EDI], EAX
	JNE	8$.S			;No
	MOVL	EAX, knlDcValue#+8	;Maybe
	CMPL	dcb_name+8.B[EDI], EAX
	JNE	8$.S			;No
	MOVL	EAX, knlDcValue#+12t	;Maybe
	CMPL	dcb_name+12t.B[EDI], EAX
	JNE	8$.S			;No
	CMPW	CX, ES:pdaPid#+2	;Yes - is the sequence number better?
	JA	8$.S			;No
	MOVW	CX, ES:pdaPid#+2	;Yes - remember this one
	MOVL	ESI, ES
8$:	INCL	EBX			;Bump process number
	CMPL	EBX, knlProcHigh#	;More to look at?
	JBE	6$			;Yes - continue
	TESTL	ECX, ECX		;No - did we find one?
	JE	knlBadCharV#		;No - fail
	MOVL	chardata#, ESI		;Yes - use it
	RET				;Finished

	.SBTTL	PROCESS class, set SEQ characteristic

;Subroutine to set value of the PROCESS class SEQ characteristic - this does
;  not really set it but varifies that the value is correct
;	c[AX] = Process sequence number
;	CALL	setprocseq
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setprocseq:
	CALL	getproc			;Get selector for PDA for process
	CMPW	FS:pdaPid#+2, AX	;Is the value right?
	JNE	knlBadCharV#		;No - fail
	RET				;Yes
.PAGE
	.SBTTL	PROCESS class, set FPUENB characteristic

;Subroutine to set value of the PROCESS class FPUENB characteristic
;	c{EAX} = 'YES' or 'NO'
;	CALL	setfpuenb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setfpuenb:
	CALL	getproc			;Get selector for PDA for process
	CALL	knlGetYesNo#		;Is it 'YES' or 'NO'?
	JC	8$.S			;No
	MOVL	EAX, CR0		;Yes
	JE	2$.S			;If 'YES'
	ANDB	FS:pdaStatus1#, #~P1$FPU ;If 'NO'
	ORB	AL, #04h		;Update the hardware state
	JMP	4$.S

;Here if he said to enable the FPU

2$:	CMPB	fputype#, #FPU_NONE	;Do we have an FPU?
	JE	8$.S			;No - ignore this quietly
	ORB	FS:pdaStatus1#, BL	;Yes - indicate its enabled
	ANDB	AL, #~04h
4$:	MOVL	EDX, FS			;Changing for current process?
	CMPW	knlCurPda#, DX
	JNE	6$.S			;No
	MOVL	CR0, EAX		;Yes - update the hardware state
6$:	CLC
8$:	RET
.PAGE
	.SBTTL	SYSTEM class, set DOSSIZE characteristic

;Here for the DOSSIZE characteristic - set default DOS image size

setdossize:
	MOVW	FS, knlProcTable#+2
	JMP	2$.S

	.SBTTL	PROCESS class, set DOSSIZE characteristic

;Here for the DOSSIZE characteristic - set default DOS image size

setpdadossz:
	CALL	getproc			;Get selector for PDA
2$:	ADDL	EAX, #3.B		;Round up to whole pages
	ANDL	EAX, #0FFFFFFFCh.B
	SHLL	EAX, #10t		;And change to bytes
	MOVL	ECX, FS:pdaDosBase#	;Determine minimum valid value (must
	ADDL	ECX, #64t*1024t		;  have room for at least 64K)
	CMPL	EAX, ECX		;Is value too small?
	JAE	4$.S			;No
	MOVL	EAX, ECX		;Yes - use minimum
4$:	CMPL	EAX, #640t*1024t	;Is value too large?
	JBE	6$.S			;No
	MOVL	EAX, #640t*1024t	;Yes - use maximum
6$:	MOVL	FS:[EBX], EAX		;Store new value
	CLC
	RET

	.SBTTL	SYSTEM class, set DOSBASE characteristic

;Here for the DOSBASE characteristic - set default DOS image base

setdosbase:
	MOVW	FS, knlProcTable#+2
	JMP	10$.S

	.SBTTL	PROCESS class, set DOSBASE characteristic

;Here for the DOSBASE characteristic - set default DOS image base

setpdadosbs:
	CALL	getproc			;Get selector for PDA
10$:	ADDL	EAX, #3.B		;Round up to whole pages
	ANDL	EAX, #0FFFFFFFCh.B
	SHLL	EAX, #10t		;And change to bytes
	CMPL	EAX, #512t*1024t	;Is value too big?
	JB	12$.S			;No
	MOVL	EAX, #512t*1024t	;Yes - use maximum
12$:	CMPL	EAX, #4t*1024t		;Is the value too small?
	JAE	14$.S			;No
	MOVL	EAX, #4t*1024t		;Yes - use minimum
14$:	MOVL	FS:[EBX], EAX		;Store new value
	ADDL	EAX, #64t*1024t		;Calculate new minimum valid size value
	CMPL	FS:pdaDosSize#, EAX	;Is the current size value OK?
	JAE	16$.S			;Yes
	MOVL	FS:pdaDosSize#, EAX	;No - set it to the new minimum
16$:	CLC
	RET
.PAGE
	.SBTTL	PROCESS class, set SHRRETRY characteristic

;Here for the SHRRETRY characteristic - set file sharing retry limit

setshrretry:
	CMPL	EAX, #64t.B		;Too big?
	JBE	setpda2byte.S		;No
	MOVL	EAX, #64t		;Yes - use maximum
	JMP	setpda2byte.S

	.SBTTL	PROCESS class, set SHRDELAY characteristic

;Here for the SHRDELAY characteristic - set file sharing retry delay value

setshrdelay:
	CMPL	EAX, #10t.B		;Too small?
	JA	2$.S			;No
	MOVB	AL, #10t		;Yes - use minimum
2$:	CMPL	EAX, #5000t		;Too big?
	JBE	setpda2byte.S		;No
	MOVL	EAX, #5000t		;Yes - use maximum
					;Fall into setpda2byte

	.SBTTL	setpda2byte - Set 2 byte value for PROCESS characteristic

;Subroutine to set value of process characteristic which has a 2 byte value
;	c{EAX} = Value to store
;	c{EBX} = Data value
;	CALL	setpda2byte
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setpda2byte:
	CALL	getproc
	MOVW	FS:[EBX], AX		;Set value
	CLC
	RET
.PAGE
	.SBTTL	PROCESS class, set PRIVCUR characteristic

;Subroutine to set value of the PROCESS class PRIVCUR characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Maximum length of string to store
;	CALL	setprivcur
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setprivcur:
	CALL	getproc			;Get selector for PDA
	MOVL	EAX, FS:pdaActPriv#+0	;Get active privilege bits
	MOVL	EDX, FS:pdaActPriv#+4
	CALL	parsepriv		;Parse his list
	JC	4$.S			;If error
	ANDL	EAX, FS:pdaAvlPriv#+0	;Remove non-allowed bits
	ANDL	EDX, FS:pdaAvlPriv#+4
	MOVL	FS:pdaActPriv#+0, EAX	;Store new bits
	MOVL	FS:pdaActPriv#+4, EDX
4$:	RET

	.SBTTL	PROCESS class, set PRIVAVL characteristic

;Subroutine to set value of the PROCESS class PRIVACL characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Maximum length of string to store
;	CALL	setprivavl
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setprivavl:
	CALL	getproc			;Get selector for PDA
	MOVL	EAX, FS:pdaAvlPriv#+0	;Get available privilege bits
	MOVL	EDX, FS:pdaAvlPriv#+4
	CALL	parsepriv		;Parse his list
	JC	4$.S			;If error
	ANDL	FS:pdaAvlPriv#+0, EAX	;Store new bits
	ANDL	FS:pdaAvlPriv#+4, EDX
	ANDL	FS:pdaActPriv#+0, EAX	;Also make sure no extra current bits
	ANDL	FS:pdaActPriv#+4, EDX	;  are set
6$:	RET

	.SBTTL	PROCESS class, set PRIVCHK characteristic

;Subroutine to set value of the PROCESS class PRIVCHK characteristic - This
;  characteristic simply verifies that the privileges specified are current
;  privilegs.
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Maximum length of string to store
;	CALL	setprivchk
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setprivchk:
	CALL	getproc			;Get selector for PDA
	CLRL	EAX
	CLRL	EDX
	CALL	parsepriv		;Parse his list
	JC	6$.S
	MOVL	ECX, FS:pdaActPriv#+0
	NOTL	ECX
	ANDL	ECX, EAX
	JNE	10$.S
	MOVL	EAX, FS:pdaActPriv#+4	;  are set
	NOTL	EAX
	ANDL	EAX, EDX
	JE	6$.S
10$:	JMP	knlBadCharV#

	.SBTTL	PROCESS class, set PRIVVLD characteristic

;Subroutine to set value of the PROCESS class PRIVVLD characteristic - This
;  characteristic simply verifies that the privileges specified are valid.
;  Nothing is changed.
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Maximum length of string to store
;	CALL	setprivvld
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setprivvld:
	CALL	getproc			;Get selector for PDA
	CLRL	EAX
	CLRL	EDX
	JMP	parsepriv		;Parse his list
.PAGE
	.SBTTL	PROCESS class, set SECTCUR characteristic

;Subroutine to set value of the PROCESS class SECTCUR characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	setsectcur
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

$$$=!0
FRM sc_name    , 20t		;Section name buffer
FRM sc_begin   , 4t		;Offset of beginning of name
FRM sc_error   , 4t		;Error code
FRM sc_nexttype, 1t		;Type for next name
FRM sc_thistype, 1t		;Type for this name
FRM            , 2t
sc_SIZE=!$$$

setsectcur:
	ENTER	sc_SIZE, 0
	CALL	getproc
	MOVZBL	EAX, FS:pdaSesProc#
	MOVW	GS, knlProcTable#[EAX*2]
	TESTL	ECX, ECX
	JNE	1$.S
	MOVL	ECX, #7FFFFFFFh
1$:	IFFAULT	knlRtnAdrErLv#
	MOVB	AL, ES:[EBX]
	CMPB	AL, #0			;Null list?
	JE	16$			;Yes - go nothing
	CMPB	AL, #'+'		;No - incremental request?
	JE	6$.S			;Yes
	CMPB	AL, #'-'		;Maybe
	JE	6$.S			;Yes
	MOVL	ESI, GS:pdaSection#	;No - point to start of section list
	MOVL	EDX, GS:[ESI]
	ADDL	ESI, #mb_data.B
	SUBL	EDX, #mb_data.B

;Here if request is not incremental - we first scan the list of sections and
;  make them all not current (i.e., we make sure the first character of each
;  is lower case)

2$:	DECL	EDX			;More?
	JS	6$.S			;No
	MOVB	AL, GS:[ESI]		;Get first character of section name
	CMPB	AL, #0			;End?
	JE	6$.S			;Yes
	CMPB	AL, #'a'		;Lower case?
	JAE	4$.S			;Yes
	ADDB	GS:[ESI], #'a'-'A'	;No - make it lower case
4$:	INCL	ESI
	DECL	EDX			;Eat the rest of the name
	TESTB	GS:[ESI], #80
	JE	4$.S
	INCL	ESI
	JMP	2$.S			;Continue with next name

;Here with all items made non-current if necessary

6$:	MOVL	sc_error.B[EBP], #0
	MOVB	sc_thistype.B[EBP], #'+'
8$:	CALL	nextsect		;Get next section name
	JNC	9$.S
	CMPL	EAX, #ER_SCTNA		;Section not available error?
	JNE	16$.S			;No - fail immediately
	MOVL	sc_error.B[EBP], EAX	;Yes - save error and continue
9$:	CMPB	sc_name+0.B[EBP], #0	;Null name?
	JE	14$.S			;Yes
	MOVB	AL, GS:[ESI]		;No - get first character
	CMPB	sc_thistype.B[EBP], #'+' ;Want to add name?
	JNE	10$.S			;No
	CMPB	AL, #'a'		;Yes - lower case?
	JB	12$.S			;No
	ADDB	AL, #'A'-'a'		;Yes - change to upper case
	JMP	12$.S

;Here if want to remove name

10$:	CMPB	AL, #'a'		;Change first character to lower case
	JAE	12$.S
	ADDB	AL, #'a'-'A'
12$:	MOVB	GS:[ESI], AL
14$:	MOVB	AL, sc_nexttype.B[EBP]
	MOVB	sc_thistype.B[EBP], AL
	CMPB	AL, #0
	JNE	8$.S
	MOVL	EAX, sc_error.B[EBP]	;Get error code to return
	BTL	EAX, #31t		;Set C if error
16$:	LEAVE
	RET
.PAGE
	.SBTTL	PROCESS class, set SECTAVL characteristic

;Subroutine to set value of the PROCESS class SECTAVL characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	setsectavl
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

$$$=!0
FRM ss_buffer, 8t		;Address of user's buffer
FRM ss_length, 4t		;Length of user's buffer
FRM ss_number, 4t		;Number of sections specified
FRM ss_size  , 4t		;Size needed for data block
FRM ss_begin , 4t		;Offset of beginning of section name
FRM ss_pda   , 4t		;Selector for session PDA
ss_SIZE=!$$$

setsectavl:
	CALL	getproc
	MOVZBL	EAX, FS:pdaSesProc#
	MOVW	GS, knlProcTable#[EAX*2]
	MOVL	EAX, GS:pdaSesData#
	ADDL	EAX, #ses_grpname.B
	CMPB	GS:[EAX], #0		;Is the user logged in now?
	JE	100$.S			;No - go on
	BTL	SS:pdaActPriv#, #PP%ANYLOGIN ;Yes - can he do this anyway?
	JNC	knlPrivFail#		;No - fail!
100$:	TESTL	ECX, ECX		;OK
	JNE	1$.S
	MOVL	ECX, #7FFFFFFFh
1$:	ENTER	ss_SIZE, 0
	MOVL	ss_pda.B[EBP], GS
	MOVL	ss_buffer+0.B[EBP], EBX
	MOVL	ss_buffer+4.B[EBP], ES
	MOVL	ss_length.B[EBP], ECX
	CLRL	EAX
	MOVL	ss_number.B[EBP], EAX
	MOVL	ss_size.B[EBP], EAX

;First we scan the string and count the number of section names specified and
;  determine that all of the names are valid

2$:	MOVL	ss_begin.B[EBP], EBX	;Save beginning of name
	IFFAULT	knlRtnAdrErLv#
	MOVB	AL, ES:[EBX]		;Get first character
	CMPB	AL, #'a'		;Lower case?
	JB	4$.S			;No
	ADDB	AL, #'A'-'a'		;Yes - change to upper case
4$:	CMPB	AL, #'A'		;Letter?
	JB	16$.S
	CMPB	AL, #'Z'
	JA	18$.S
	IFFAULT	knlRtnAdrErLv#
6$:	MOVB	AL, ES:[EBX]		;Get character
	INCL	EBX
	DECL	ECX
	CMPB	AL, #0			;End of name?
	JE	12$.S			;Yes
	TESTB	AL, #80h		;Maybe - have non-delimiter end?
	JE	10$.S			;No
	ANDB	AL, #7Fh		;Yes
	CMPB	AL, #'+'		;Valid character?
	JE	16$.S			;No
	CMPB	AL, #'-'
	JE	16$.S			;No
	CMPB	AL, #' '
	JBE	16$.S			;No
	LEAL	EDX, 1.B[EBX]		;Yes - get length of name + 1
	ORL	ECX, ECX
	JG	8$.S
	MOVB	AL, #0
	JMP	14$.S			;Continue

8$:	MOVB	AL, ES:[EBX]
	JMP	14$.S

10$:	CMPB	AL, #'+'		;Maybe
	JE	12$.S			;Yes
	CMPB	AL, #'-'		;No - valid character?
	JE	16$.S			;No
	CMPB	AL, #' '		;Maybe
	JBE	16$.S			;No
	ORL	ECX, ECX
	JG	6$.S			;Yes - continue if more there
	MOVB	AL, #0			;End of buffer - fake up final null
	INCL	EBX
12$:	MOVL	EDX, EBX		;Get length of name + 1
14$:	SUBL	EDX, ss_begin.B[EBP]
	CMPL	EDX, #2t.B
16$:	JBE	knlBadCharVLv#		;Error if not at leat 2 characters
	CMPL	EDX, #17t.B
18$:	JA	knlBadCharVLv#		;Also error if longer than 16
	INCL	ss_number.B[EBP]	;OK - count the session name
	DECL	EDX
	ADDL	ss_size.B[EBP], EDX
	CMPB	AL, #0			;End of list?
	JNE	2$.S			;No - continue

;Here with list scanned, now allocate memory and store the list

	MOVL	ESI, GS:pdaSection#	;Do we have a section list defined now?
	TESTL	ESI, ESI
	JE	20$.S			;No
	CLRL	EAX			;Yes - give it up
	MOVL	GS:pdaSection#, EAX
	MOVL	ES, ss_pda.B[EBP]
	CALL	knlGivePdaMemP#
20$:	MOVL	ECX, ss_size.B[EBP]
	MOVL	ES, ss_pda.B[EBP]
	CALL	knlGetPdaMemP#		;Allocate space
	JC	38$.S			;If error
	MOVL	GS, ss_pda.B[EBP]
	MOVL	GS:mb_pnt1.B[ESI], #pdaSection ;Store offset of pointer in block
	MOVL	GS:pdaSection#, ESI	;Store offset of table
	ADDL	ESI, #mb_data.B
	LESL	EBX, ss_buffer.B[EBP]	;Resetore offset of buffer
	MOVL	ECX, ss_length.B[EBP]	;And length of buffer
22$:	MOVB	AL, ES:[EBX]		;Get first character
	INCL	EBX
	CMPB	AL, #'a'		;Force to lower case
	JAE	30$.S
	ADDB	AL, #'a'-'A'
	JMP	30$.S

24$:	MOVB	AL, ES:[EBX]		;Get next character
	INCL	EBX
	DECL	ECX
	CMPB	AL, #0			;End of name?
	JE	32$.S			;Yes
	TESTB	AL, #80h
	JE	28$.S
	ANDB	AL, #7Fh
	CMPB	AL, #'a'		;Make sure upper case
	JB	25$.S
	ADDB	AL, #'A'-'a'
25$:	MOVB	GS:[ESI], AL
	INCL	ESI
	ORL	ECX, ECX
	JG	26$.S
	MOVB	AL, #0
	JMP	32$.S

26$:	MOVB	AL, ES:[EBX]
	JMP	32$.S

28$:	CMPB	AL, #'+'		;Maybe
	JE	32$.S			;Yes
	CMPB	AL, #'a'		;No - make sure upper case
	JB	30$.S
	ADDB	AL, #'A'-'a'
30$:	MOVB	GS:[ESI], AL		;Store character
	INCL	ESI
	ORL	ECX, ECX
	JG	24$.S			;Continue if more there
	MOVB	AL, #0			;End of buffer - fake up final null
32$:	ORB	GS:-1.B[ESI], #80h	;Flag end of name
	CMPB	AL, #0			;End of list?
	JNE	22$.S			;No - continue
34$:	TESTL	ESI, #03h		;Yes - fill out last long with nulls
	JE	36$.S			;  if necessary
	MOVB	GS:[ESI], #0
	INCL	ESI
	JMP	34$.S

36$:	CLRL	EAX			;Return 0
38$:	LEAVE
	RET
.PAGE
	.SBTTL	PROCESS class, set SECTCHK characteristic

;Subroutine to set value of the PROCESS class SECTCHK characteristic
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	CALL	setsectchk
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setsectchk:
	ENTER	sc_SIZE, 0
	CALL	getproc
	MOVZBL	EAX, FS:pdaSesProc#
	MOVW	GS, knlProcTable#[EAX*2]
	TESTL	ECX, ECX
	JNE	2$.S
	MOVL	ECX, #7FFFFFFFh
2$:	CALL	nextsect		;Get next section name
	JC	10$.S			;If error
	CMPB	GS:[ESI], #'a'
	JAE	knlBadCharVLv#
	CMPB	sc_nexttype.B[EBP], #0
	JNE	2$.S
10$:	LEAVE
	RET
.PAGE
;Subroutine to get next section name from the user's list and find it in the
;  definition
;	c{ES:EBX} = Pointer to input buffer
;	c{ECX}    = Number of characters left in input buffer
;	CALL	nextsect
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{sc_begin{ESP}} = Offset of entry in section list
;	  c{ES:EBX} = Updated pointer to input buffer
;	  c{ECX}    = Updated number of characters left in input buffer

nextsect:
	LEAL	ESI, sc_name.B[EBP]	;Point to our name buffer
	MOVL	EDX, #16t		;Get maximum length
	IFFAULT	knlRtnAdrEr#
2$:	MOVB	AL, ES:[EBX]		;Get name character
	INCL	EBX			;Bump pointer
	DECL	ECX
	CMPB	AL, #0			;End of name?
	JE	8$.S			;Yes
	TESTB	AL, #80h		;Maybe
	JNE	6$.S			;Yes
	CMPB	AL, #'+'		;Maybe
	JE	8$.S			;Yes
	CMPB	AL, #'-'		;Maybe
	JE	8$.S			;Yes
	CMPB	AL, #'a'		;No - lower case?
	JB	4$.S			;No
	ADDB	AL, #'A'-'a'		;Yes - change to upper case
4$:	DECL	EDX			;Too long?
	JL	knlBadCharV#		;Yes - fail
	MOVB	SS:[ESI], AL		;No - store in name buffer
	INCL	ESI			;Bump buffer poiner
	ORL	ECX, ECX
	JG	2$.S			;Continue if more in buffer
	MOVB	AL, #0
	JMP	8$.S

;Here if have high order bit set in character - this flags the end of a name
;  without using a delimiter character - we assume a + delimiter

6$:	ANDB	AL, #7Fh		;Store last character
	CMPB	AL, #'a'		;No - lower case?
	JB	7$.S			;No
	ADDB	AL, #'A'-'a'		;Yes - change to upper case
7$:	MOVB	SS:[ESI], AL
	INCL	ESI
	MOVB	AL, #'+'		;Get assumed delimiter
	ORL	ECX, ECX		;End?
	JG	8$.S			;No
	MOVB	AL, #0			;Yes - get right value

;Here at end of name - we now have the name in our name buffer in all upper
;  case

8$:	MOVB	sc_nexttype.B[EBP], AL	;Store type of next item
	MOVB	SS:[ESI], #0		;Store final null
	CMPB	sc_name+0.B[EBP], #0	;Is this a null name?
	JE	18$.S			;Yes
	MOVL	ESI, GS:pdaSection#	;No - point to start of section list
	MOVL	EDX, GS:[ESI]
	ADDL	ESI, #mb_data.B
	SUBL	EDX, #mb_data.B
10$:	LEAL	EDI, sc_name.B[EBP]
	MOVL	sc_begin.B[EBP], ESI
12$:	MOVB	AL, GS:[ESI]		;Get character from list
	INCL	ESI
	DECL	EDX
	TESTB	AL, #80h		;End of name?
	JNE	16$.S			;Yes
	CMPB	AL, #'a'		;No - make sure upper case
	JB	14$.S
	ADDB	AL, #'A'-'a'
14$:	CMPB	SS:[EDI], AL		;Does it match?
	JNE	20$.S			;No
	INCL	EDI			;Yes - continue checking
	JMP	12$.S

;Here with last character in list entry

16$:	ANDB	AL, #7F			;Remove end flag
	CMPB	SS:[EDI], AL		;Does it match?
	JNE	22$.S			;No
	CMPB	SS:1.B[EDI], #0		;Yes - end of user's name?
	JNE	22$.S			;No - no match
	MOVL	ESI, sc_begin.B[EBP]	;Yes - point to start of name
18$:	RET				;Give good return

;Here if not a match - scan to end of list entry

20$:	MOVB	AL, GS:[ESI]
	INCL	ESI
	DECL	EDX
	TESTB	AL, #80h
	JE	20$.S
22$:	TESTL	EDX, EDX
	JE	24$.S
	CMPB	GS:[ESI], #0
	JNE	10$.S
24$:	MOVL	EAX, #ER_SCTNA
	STC
	RET
.PAGE
	.SBTTL	ACCOUNT class, set SESSEQ characteristic

;Subroutine to set ACCOUNT class SESSEQ characteristic
;	c{EDX}    = Data value
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	c{ESI}    = Offset of characteristics table entry
;	CALL	setsesseq
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setsesseq:
	CMPL	ECX, #16t.B		;We must write the whole thing!
	JNE	knlBadCharS
	PUSHL	EBX
	MOVL	EBX, EDX
	CALL	sesmdpntr
	POPL	ESI
	JC	2$.S
	PUSHL	ES
	POPL	GS
	MOVL	EDI, EBX
	PUSHL	FS
	POPL	ES
	CLD
	SHRL	ECX, #2
	IFFAULT	knlRtnAdrEr#
	RMOVSL	[EDI], GS:[ESI]
	CLRL	EAX
2$:	RET

	.SBTTL	ACCOUNT class, get SESSEQ characteristic

;Subroutine to get ACCOUNT class SESSEQ characteristic
;	c{EDX}    = Data value
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	c{ESI}    = Offset of characteristics table entry
;	CALL	getsesseq
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

getsesseq:
	PUSHL	EBX
	MOVL	EBX, EDX
	CALL	sesrdpntr
	POPL	EDI
	JC	2$.S
	MOVL	ESI, EBX
	CLD
	CMPL	ECX, #16t.B
	JBE	4$.S
	MOVL	ECX, #16t
4$:	MOVL	EAX, ECX
	ANDL	EAX, #0FFFFFFFCh.B
	SHRL	ECX, #2
	IFFAULT	knlRtnAdrEr#
	RMOVSL	[EDI], FS:[ESI]
	MOVL	ECX, EAX
	RET
.PAGE
	.SBTTL	ACCOUNT class, set BILLING characteristic

;Subroutine to set ACCOUNT class BILLING characteristic
;	c{EDX}    = Data value
;	c{ES:EBX} = Address of user's data buffer
;	c{ECX}    = Length of the buffer
;	c{ESI}    = Offset of characteristics table entry
;	CALL	setbilling
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

;The data for this characteristic has the following format:
;	Offset  Size   Description
;	  0       1    Billing class
;	  1       1    Number of time intervals (must be between 0 and 3)
;	  2       1    Number of billing levels (must be 8)
;	  3       1    Reserved, must be 0
;	  4       4    Billing key value
;	  8       4    1st time value (fractional days)
;	 12       2    1st interval, level 0 cost (cents/hour)
;	 14       2    1st interval, level 1 cost (cents/hour)
;	 16       2    1st interval, level 2 cost (cents/hour)
;	 18       2    1st interval, level 3 cost (cents/hour)
;	 20       2    1st interval, level 4 cost (cents/hour)
;	 22       2    1st interval, level 5 cost (cents/hour)
;	 24       2    1st interval, level 6 cost (cents/hour)
;	 26       2    1st interval, level 7 cost (cents/hour)
;	 28       4    2nd time value (fractional days)
;	 32       2    2nd interval, level 0 cost (cents/hour)
;	 34       2    2nd interval, level 1 cost (cents/hour)
;	 36       2    2nd interval, level 2 cost (cents/hour)
;	 38       2    2nd interval, level 3 cost (cents/hour)
;	 40       2    2nd interval, level 4 cost (cents/hour)
;	 42       2    2nd interval, level 5 cost (cents/hour)
;	 44       2    2nd interval, level 6 cost (cents/hour)
;	 46       2    2nd interval, level 7 cost (cents/hour)
;	 48       4    3rd time value (fractional days)
;	 52       2    3rd interval, level 0 cost (cents/hour)
;	 54       2    3rd interval, level 1 cost (cents/hour)
;	 56       2    3rd interval, level 2 cost (cents/hour)
;	 58       2    3rd interval, level 3 cost (cents/hour)
;	 60       2    3rd interval, level 4 cost (cents/hour)
;	 62       2    3rd interval, level 5 cost (cents/hour)
;	 64       2    3rd interval, level 6 cost (cents/hour)
;	 66       2    3rd interval, level 7 cost (cents/hour)

;The data buffer must contain at least 68 bytes, unused values must be set
;  to 0.

setbilling:
	CMPL	ECX, #68t.B		;We must write the whole thing!
	JB	knlBadCharS
	PUSHL	EBX
	MOVL	EBX, EDX
	CALL	sesmdpntr		;Get pointer for writing session data
	POPL	ESI
	JC	10$.S			;If error
	PUSHL	ES
	POPL	GS
	PUSHL	FS
	POPL	ES
	IFFAULT	knlRtnAdrEr#
	MOVB	AL, GS:55t.B[ESI]	;Make sure end of buffer is readable
	IFFAULT	knlRtnAdrEr#
	CLD
	LODSL	GS:[ESI]		;Get billing class, number of time
	CMPB	AH, #1			;  intervals, and number of levels
	JB	2$.S			;Must have 0 to 3 intervals
	CMPB	AH, #3
	JA	2$.S
	MOVL	ECX, EAX		;Get number of levels
	SHRL	ECX, #16t
	CMPB	CL, #8t			;For now, it must be 8!
2$:	JNE	knlBadCharV#
	MOVW	ES:[EBX], AX
	LODSL	GS:[ESI]		;Store the billing key value
	MOVL	ES:ses_billkey-ses_billcls.B[EBX], EAX
	CLI
	MOVL	EAX, knlTickCnt#	;Get current date/time in system format
	MOVL	EDX, knlSysDate#	;  and store it as the last billing
	STI				;  date/time
	CALL	knlTick2SysTime#
	MOVL	ES:ses_billtime+0-ses_billcls.B[EBX], EAX
	MOVL	ES:ses_billtime+4-ses_billcls.B[EBX], EDX
	LEAL	EDI, ses_rates1-ses_billcls.B[EBX]
	ADDL	EBX, #ses_atime1-ses_billcls.B
	MOVL	EDX, #3
4$:	LODSL	GS:[ESI]		;Store the time value
	MOVL	ES:[EBX], EAX
	ADDL	EBX, #4t.B
	MOVL	ECX, #8t
6$:	CLRL	EAX
	STOSL	[EDI]
	LODSW	GS:[ESI]
	SHLL	EAX, #16t
	STOSL	[EDI]
	LOOP	ECX, 6$
	DECL	EDX
	JNE	4$.S
	CLRL	EAX			;Return 0
10$:	RET

	.SBTTL	ACCOUNT class, get BILLING characteristic

;Subroutine to get ACCOUNT class BILLING characteristic
;	c{EDX}    = Data value
;	c{ES:EBX} = Address of user's data buffer
;	c{ECX}    = Length of the buffer
;	c{ESI}    = Offset of characteristics table entry
;	CALL	getbilling
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

getbilling:				;This always fails!
	CLRL	ECX
	MOVL	EAX, #ER_CHARF
	STC
	RET
.PAGE
	.SBTTL	ACCOUNT class, set characteristics with 4-byte numeric values

;Subroutine to set ACCOUNT class characteristics with 4-byte numeric values
;	c{EAX} = New value
;	c{EBX} = Offset of value in the accounting data block
;	CALL	setses4byte
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setses4byte:
	CALL	sesmdpntr
	JC	6$.S
	MOVL	FS:[EBX], EAX
6$:	RET

	.SBTTL	ACCOUNT class, get characteristics with 4-byte numeric values

;Subroutine to get ACCOUNT class characteristics with 4-byte numeric values
;	c{EBX} = Offset of value in the accounting data block
;	CALL	setses4byte
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getses4byte:
	CALL	sesrdpntr
	MOVL	EAX, FS:[EBX]
	RET
.PAGE
	.SBTTL	ACCOUNT class, set characteristics with string values

;Subroutine to set ACCOUNT class characteristics with string values
;	c{ES:EBX} = Address of user's string buffer
;	c{ECX}    = Length of the buffer
;	c{EDX}    = Offset of value in the accounting data block
;	CALL	setsesstr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setsesstr:
	MOVZWL	EAX, dct_length.B[ESI]
	CMPL	ECX, EAX
	JBE	2$.S
	MOVL	ECX, EAX
2$:	PUSHL	EBX
	MOVL	EBX, EDX
	CALL	sesmdpntr
	POPL	ESI
	JC	8$.S
	PUSHL	ES
	POPL	GS
	MOVL	EDI, EBX
	PUSHL	FS
	POPL	ES
	CLD
	CLRL	EAX
	PUSHL	ECX
	PUSHL	EDI
	SHRL	ECX, #2
	RSTOSL	[EDI]
	POPL	EDI
	POPL	ECX
	IFFAULT	knlRtnAdrEr#
6$:	LODSB	GS:[ESI]		;Get character
	STOSB	[EDI]			;Store it
	CMPB	AL, #0			;End of name?
	JE	8$.S			;Yes
	LOOP	ECX, 6$			;No - continue if more
	CLRL	EAX
8$:	RET				;Finished

	.SBTTL	ACCOUNT class, get characteristics with string values

;Subroutine to get ACCOUNT class characteristics with string values
;	c{EBX} = Offset of value in the session data block
;	CALL	setsesstr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getsesstr:
	MOVL	EDI, EBX
	MOVL	EBX, EDX
	MOVZWL	EAX, dct_length.B[ESI]
	CMPL	ECX, EAX
	JBE	12$.S
	MOVL	ECX, EAX
12$:	PUSHL	EAX
	CALL	sesrdpntr
	POPL	EDX
	MOVL	ESI, EBX
	CLD
14$:	DECL	ECX
	JLE	knlBadCharV#
	LODSB	FS:[ESI]		;Get character
	IFFAULT	knlRtnAdrEr#
	STOSB	[EDI]			;Store it
	CMPB	AL, #0			;End of name?
	JE	16$.S			;Yes
	INCB	DH			;No - count the character
	CMPB	DH, DL			;More?
	JB	14$.S			;Yes
	DECL	ECX			;No - room for a final null?
	JLE	16$.S			;No
	IFFAULT	knlRtnAdrEr#
	MOVB	ES:[EDI], #0		;Yes
16$:	MOVZBL	ECX, DH			;Get length stored
	RET				;Finished

	.SBTTL	sesmdpntr - Subroutine to get pointer to modify session data

;Subroutine to get pointer to modify session data
;	c{EBX} = Offset of item in session data block
;	CALL	sesmdpntr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{FS:EBX} = Address of item

sesmdpntr:
	CALL	sesrdpntr		;Get address of data item
	CMPB	FS:ses_grpname.B[ESI], #0 ;Is he logged in now?
	JE	20$.S			;No - OK
	BTL	SS:pdaActPriv#, #PP%ANYLOGIN ;Yes - can he do this anyway?
	JNC	knlPrivFail#		;No - fail
	CLC
	RET

	.SBTTL	sesrdpntr - Subroutine to get pointer to read session data

;Subroutine to get pointer to read session data
;	c{EBX} = Offset of item in session data block
;	CALL	sesrdpntr
;	c{FS:EBX} = Address of item
;	c{FS:ESI} = Address of session data block

sesrdpntr:
	CALL	getproc			;Get PDA selector
	MOVZWL	ESI, FS:pdaSesProc#	;Get session process
	MOVW	FS, knlProcTable[ESI*2]	;Get session PDA selector
	MOVL	ESI, FS:pdaSesData#	;Get offset of the session data
	ADDL	EBX, ESI		;Get offset of our item
20$:	RET
.PAGE
	.SBTTL	getproc - Subroutine to get PDA selector for process

;Subroutine to get PDA selector for process
;	CALL	getproc
;	c[FS] = Selector for PDA

getproc:CMPL	chardata#, #0.B		;Was a process specified?
	JNE	2$.S			;Yes - go use it
	PUSHL	SS			;No - use current process
	POPL	FS
	RET

;Here if a process was specified

2$:	MOVL	FS, chardata#		;Get PDA selector
	RET
.PAGE
	.SBTTL	svcSysSetBillLvl SVC to set billing level

;Here for the svcSysSetBillLvl SVC - Set billing level
;	int level;		// New billing level (0 - 7) or -1 to
;				//   initialize billing key value
;	int key;		// Billing key value
;	rtn = svcSysSetBillLvl(level, key);
;  Value returned is 0 if normal or negative error code if error

psvcSysSetBillLvl::
	SVCENTR	CNTSysSetBillLvl#
rsvcSysSetBillLvl::
	MOVZWL	EAX, SS:pdaSesProc#	;Get session process
	MOVW	FS, knlProcTable[EAX*2]	;Get session PDA selector
	MOVL	ESI, FS:pdaSesData#	;Get offset of the session billing data
	ADDL	ESI, #ses_billcls
	MOVL	EAX, SS:pdaArg2#
	ORL	EAX, EAX
	JE	10$.S
	CMPL	FS:ses_billkey-ses_billcls.B[ESI], EAX
	JNE	10$.S
	MOVL	EAX, SS:pdaArg1#	;Get new billing level
	CMPL	EAX, #7.B		;Valid level?
	JA	knlBadValue#		;No - fail
	MOVZBL	EDX, FS:ses_billlvl-ses_billcls.B[ESI] ;Get current level
	CMPB	DL, AL			;Really changing it?
	JE	4$.S			;No - nothing to do here
	MOVB	FS:ses_billlvl-ses_billcls.B[ESI], AL ;OK - store new level
	CLI
	MOVL	EAX, knlTickCnt#	;Get current date/time in system format
	MOVL	EDI, knlSysDate#
	STI
	CALL	knlTick2SysTime#
	MOVL	EBX, EAX
	MOVL	ECX, EDI
	SUBL	EAX, FS:ses_billtime+0-ses_billcls.B[ESI] ;Get incremental value
	SBBL	EDI, FS:ses_billtime+4-ses_billcls.B[ESI]
	ADDL	FS:ses_rates1+0-ses_billcls.B[ESI+EDX*8], EAX ;Add it into the
	ADCW	FS:ses_rates1+4-ses_billcls.B[ESI+EDX*8], DI  ;  total for the
							      ;  previous level
	MOVL	FS:ses_billtime+0-ses_billcls.B[ESI], EBX ;Store new date/time
	MOVL	FS:ses_billtime+4-ses_billcls.B[ESI], ECX
	MOVB	FS:ses_billlvl-ses_billcls.B[ESI], DL ;Store new billing level
4$:	CLRL	EAX
	RET

;Here if the billing key value is wrong - terminate the process!

10$:	MOVL	EAX, #TC_ACCT<24t
	PUSHL	SS
	POPL	ES
	JMP	reqkill0#
.PAGE
	.SBTTL	svcSysLog - SVC to send data to the system log

;Here for the svcSysLog SVC - Send data to the system log
;	char *text;		// Message text
;	long  length;		// Message length
;	rtn = svcSysLog(text, length);
;  Value returned is 0 if normal or negative error code if error

rsvcSysLog::
	MOVL	EBP, #pdaArg2#
	CALL	vfixaddr#
	JMP	2$.S

psvcSysLog::
	SVCENTR	CNTSysLog#
	ORB	SS:pdaArg1#, #03
2$:	MOVL	ECX, SS:pdaArg3#	;Get length of message
	CMPL	ECX, #4.B		;Is it long enough?
	JB	knlBadValue#		;No - fail
	IFFAULT	knlRtnAdrEr#
	LFSL	ESI, SS:pdaArg2#	;Get address of message text
	MOVL	EAX, #MT_SYSLOG+300h	;Get function bytes
	IFFAULT	knlRtnAdrEr#
	CMPL	FS:[ESI], #'roll'	;What to roll the log file?
	JNE	4$.S			;No
	MOVB	AH, #0FFh		;Yes
	IFFAULT	knlRtnAdrEr#
4$:	MOVL	FS:[ESI], EAX		;Store the function bytes
	MOVL	EBX, #syslogdst		;Get address of destination string
	PUSHL	CS
	POPL	ES
	PUSHL	SS:pdaPid#
	PUSHL	#-1.B
	LEAL	EDX, 3.B[ESP]
	PUSHL	SS
	POPL	GS
	TOFORK
	CALL	knlIpmSendMsg#		;Send the message
	FROMFORK
	ADDL	ESP, #8.B		;Fix up the stack
	RET				;Finished

syslogdst:
	.ASCIZ	"SYS^XOSLOG"
.PAGE
	.SBTTL	svcSysGetInfo - SVC to get information about the system

;Here for the svcSysGetInfo SVC - Get information about the system
;	long   func;			// Function
;	long   data;			// Data item
;	struct dcsinfo far *info;	// Address of structure to receive
;					//   data (null means to just return
;					//   number of items)
;	int    size;			// Length of the data area
;	rtn = svcSysGetInfo(func, info, size);
;  Value returned is number of items if normal or negative error code if error

rsvcSysGetInfo::
	MOVL	EBP, #pdaArg4#
	CALL	vfixaddr#
	JMP	2$.S

psvcSysGetInfo::
	SVCENTR	CNTSysGetInfo#
	ORB	SS:pdaArg3#, #03
	IFFAULT	knlRtnAdrEr#
2$:	LESL	EDI, SS:pdaArg4#	;Get address of data block
	MOVL	ECX, SS:pdaArg5#	;Get length of data block
	MOVL	EDX, SS:pdaArg2#	;Get data value
	MOVL	EBX, SS:pdaArg1#	;Get function
	CMPL	EBX, #INFOMAX		;Valid?
	JA	knlBadFunc#
	JMPIL	infodsp[EBX*4]		;Yes - dispatch on function

;Dispatch table for the svcSysGetInfo system call

	DATA

infodsp:.LONG	illfnc		;	  = 0 - Illegal
	.LONG	getlkeinfo#	;GSI_LKE  = 1 - Get LKE information
	.LONG	illfnc		;	  = 2 - Illegal
	.LONG	getdevinfo#	;GSI_DEV  = 3 - Get device information
	.LONG	getxffinfo#	;GSI_XFF  = 4 - Get XFF information
	.LONG	illfnc		;GSI_DCS  = 5 - Get disk cache status information
	.LONG	illfnc		;GSI_TERM = 6 - Get terminal information
INFOMAX=!{$-infodsp}/4 -1

	CODE

illfnc:	MOVL	EAX, #ER_FUNC
	STC
	RET
.PAGE
	.SBTTL	svcScnTrans - SVC to transfer data for screen symbiont

;Here for the svcScnTrans SVC - Transfer data for screen
;	long rtn = svcScnTrns(
;	  long  exectdb,	// Exec offset of terminal TDB
;	  long  func,		// Function bits
;	  long  firstpg,	// First page to transfer
;	  long  numpgs,		// Number of pages to transfer
;	  long *pglist,		// Address of page list array
;	  char *pgbufr);	// Address of page buffer
;  Value returned is raw hardware cursor position (read functions) or 0 (write
;    function) if normal or a negative error code if error

psvcScnTrans::
	SVCENTR	CNTScnTrans#
	ORB	SS:pdaArg5#, #03
	ORB	SS:pdaArg7#, #03
	MOVL	ESI, SS:pdaArg1#	;Get offset of TDB for terminal
	MOVL	EDX, SS:pdaArg2#	;Get function bits
	MOVL	EAX, SS:pdaArg3#	;Get first page
	MOVL	ECX, SS:pdaArg4#	;Get number of pages
	IFFAULT	knlRtnAdrEr#
	LESL	EDI, SS:pdaArg6#	;Get address of page list
	IFFAULT	knlRtnAdrEr#
	LFSL	EBX, SS:pdaArg8#	;Get address of buffer
	MOVL	EBP, tdb_ddisp.B[ESI]	;Dispatch to terminal routine
	JMPIL	CS:tf_sstrans.B[EBP]
.PAGE
	.SBTTL	svcScnMapBufr - SVC to map physical screen buffer for screen symbiont

;Here for the svcScnMapBufr SVC - Map physical screen buffer for screen symbiont
;	long rtn = svcScnMapBufr(
;	  long exectdb,		// Exec offset of terminal TDB
;	  char far *buffer,	// Address for buffer
;	  long size);		// Maximum size for buffer
;  Value returned is size of buffer mapped if normal or negative error code
;    if error

psvcScnMapBufr::
	SVCENTR	CNTScnMapBufr#
	ORB	SS:pdaArg2#, #03
	MOVL	ESI, SS:pdaArg1#	;Get offset of TDB for terminal
	MOVL	EDX, SS:pdaArg3#	;Get address of buffer
	MOVL	EBP, SS:pdaArg2#
	MOVL	ECX, SS:pdaArg4#	;Get maximum size
	MOVL	EAX, tdb_ddisp.B[ESI]	;Dispatch to terminal routine
	JMPIL	CS:tf_ssmapbufr.B[EAX]
.PAGE
	.SBTTL	svcScnMaskWrt - SVC to write screen buffer with masking for screen symbiont

;Here for the svcScnWrite SVC - Write screen buffer with masking for screen
;  symbiont
;	long rtn = svcScnMaskWrt(
;	  long exectdb,		// Exec offset of terminal TDB
;	  long firstpg,		// First page to write
;	  long numpgs,		// Number of pages to write
;	  long width,		// Width of menu (characters)
;	  long height,		// Height of menu (rows)
;	  long offset, 		// Offset in buffer for first visible character
;	  char far *pgbufr);	// Address of page buffer
;  Value returned is 0 if nothing was written, 1 if something was written, or
;    a negative error code if error

psvcScnMaskWrt::
	SVCENTR	CNTScnMaskWrt#
	ORB	SS:pdaArg7#, #03
	MOVL	ESI, SS:pdaArg1#	;Get offset of TDB for terminal
	MOVL	EAX, SS:pdaArg2#	;Get first page
	MOVL	ECX, SS:pdaArg3#	;Get number of pages
	MOVL	EBX, SS:pdaArg5#	;Get menu height
	SHLL	EBX, #16t
	MOVW	BX, SS:pdaArg4#		;Get menu width
	MOVL	EDX, SS:pdaArg6#	;Get offset of first character
	IFFAULT	knlRtnAdrEr#
	LESL	EDI, SS:pdaArg8#	;Get address of buffer
	MOVL	EBP, tdb_ddisp.B[ESI]	;Dispatch to terminal routine
	JMPIL	CS:tf_ssmaskwrt.B[EBP]
.PAGE
	.SBTTL	svcScnUtil - General utilitye SVC for screen symbiont

;Here for the svcScnUtil SVC - General utility SVC for the screen symbiont
;	long rtn = svcScnWake(
;	  long exectdb,		// Exec offset of terminal TDB
;	  long data);		// Data value:
;				//   -1 = Remove cursor from physical screen
;				//    0 = Wake up main program level using TDB
;				//	    offset + 1 as wait index
;				//   >0 = Wake up extended fork frame with this
;				//	    selector
;  Value returned 0 if normal or a negative error code if error

psvcScnUtil::
	SVCENTR	CNTScnUtil#




	MOVL	ESI, SS:pdaArg1#	;Get offset of TDB for terminal
	CMPL	ESI, #1000h
	JA	6$.S
	CALL	knlGetDcbTdb#		;Get DCB and TDB
	JC	4$.S			;If error
	MOVL	EAX, ESI		;Return offset of TDB
4$:	RET

6$:	MOVL	EDX, SS:pdaArg2#	;Get data value
	MOVL	EBP, tdb_ddisp.B[ESI]	;Dispatch to terminal routine
	JMPIL	CS:tf_ssutil.B[EBP]
.PAGE
	.SBTTL	knlSysStrDefine - Define system string

;Subroutine to define a system string
;	c{FS:EBX} = Address of string name (null terminated)
;	c{GS:EDX} = Address of string value
;	c{ECX}    = Length of string value
;	CALL	knlSysStrDefine
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;  Must be called with the exec memory resource

;System strings are stored in the following format:
;   Size    Description
;     4   Offset of next system string definition
;     1   Length of name
;     1   Length of value
;     n   Name
;     m   Value

$$$=!0
FRM ssd_vallen, 4t
FRM ssd_namlen, 4t
ssd_SIZE=!$$$

knlSysStrDefine::
	ENTER	ssd_SIZE, 0
	MOVL	ssd_vallen.B[EBP], ECX
	CALL	sysstrlen		;Get length of the name
	JC	4$.S			;If error
	MOVL	ssd_namlen.B[EBP], EAX
	LEAL	ECX, 6.B[EAX]
	ADDL	ECX, ssd_vallen.B[EBP]	;Get total space needed
	CALL	knlGetXMem#		;Get memory for the definition block
	JC	4$.S			;If error
	MOVL	EAX, EDI
	ADDL	EDI, #6t.B		;First store the name
	MOVL	ESI, EBX
	MOVL	ECX, ssd_namlen.B[EBP]
	MOVB	4.B[EAX], CL
	PUSHL	DS
	POPL	ES
	CLD
	RMOVSB	[EDI], FS:[ESI]
	MOVL	ESI, EDX		;Now store the value
	MOVL	ECX, ssd_vallen.B[EBP]
	MOVB	5.B[EAX], CL
	IFFAULT	knlRtnAdrErLv#
	RMOVSB	[EDI], GS:[ESI]
	MOVL	EDX, sysstrhead		;Link the new definition into the list
	MOVL	[EAX], EDX
	MOVL	sysstrhead, EAX
	CLC
4$:	LEAVE
	RET

	.SBTTL	knlSysStrGet - Get value of system string

;Subroutine to get value of a system string
;	c{FS:EBX} = Address of string name (null terminated)
;	c{GS:EDX} = Address of buffer to receive value
;	c{ECX}    = Length of buffer
;	CALL	knlSysStrGet
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Length of value stored

knlSysStrGet::
	PUSHL	ECX
	CALL	sysstrlen		;Get length of the name
	JC	18$.S
	MOVL	ESI, sysstrhead
10$:	TESTL	ESI, ESI
	JE	14$.S
	CMPB	4.B[ESI], AL		;Is the name length the same?
	JNE	12$.S			;No - go on
	PUSHL	ESI
	ADDL	ESI, #6.B
	MOVL	EDI, EBX
	MOVL	ECX, EAX
	RECMPSB	[EDI], [ESI]
	POPL	ESI
	JE	20$.S
12$:	MOVL	ESI, [ESI]
	JMP	10$.S

;Here if name not found

14$:	MOVL	EAX, #ER_NTDEF
	STC
18$:	POPL	ECX
	RET

;Here with match on string name

20$:	POPL	EBX			;Restore buffer length
	MOVZBL	ECX, 5.B[ESI]		;Get length of the value
	CMPL	ECX, EBX		;Is the buffer big enough?
	JA	22$.S			;No - fail
	LEAL	ESI, 6.B[ESI+EAX]	;Yes - point to the value
	MOVL	EDI, EDX
	PUSHL	GS
	POPL	ES
	PUSHL	ECX
	IFFAULT	knlRtnAdrErP1#
	RMOVSB	[EDI], [ESI]
	POPL	EAX
	CLC
	RET

;Here if value is longer than the buffer

22$:	MOVL	EAX, #ER_RTOBG
	STC
	RET
.PAGE
;Subroutine to get the length of a system string
;	c{FS:EBX} = Address of the string name
;	CALL	sysstrlen
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Length of the name
;	  c[ES]  = Selector for address of name
;	  D bit is clear

sysstrlen:
	MOVL	ECX, #-1
	PUSHL	FS
	POPL	ES
	MOVL	EDI, EBX
	MOVB	AL, #0
	CLD
	IFFAULT	knlRtnAdrEr#
	RNSCASB	[EDI]
	NOTL	ECX
	LEAL	EAX, -1.B[ECX]
	CLC
	RET
.PAGE
	.SBTTL	Data

	DATA

sysstrhead: .LONG  0
sysccb::    .BLKB  ccb_SIZE
procccb::   .BLKB  ccb_SIZE
sessionccb::.BLKB  ccb_SIZE
accountccb::.BLKB  ccb_SIZE

	END
