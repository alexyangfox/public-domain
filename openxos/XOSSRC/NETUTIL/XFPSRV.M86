	.TITLE	XFPSRV - XFP file server for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80386

	.INCLUD	XOSINC:\XMAC\STDIO.PAR
	.INCLUD	XOSINC:\XMAC\CTYPE.PAR
	.INCLUD	XOSINC:\XMAC\PROCARG.PAR
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR

	.STDSEGS

INSTMAX =!31t		;Maximum instance number
CDBBASE =!30000h	;Base offset for first CDB
MAXOPENS=!128t
DFTOPENS=!3t
MAXCONS =!4088t
DFTCONS =!20t

;This program is the XFP file server.  It is initialized as a symbiont with the
;  following command:

;	SYMBIONT XFPSRV UNIT=n LOGLEVEL=l LOGFILE=log
;	  Where:
;		UNIT     = Server unit number (default = 1)
;		LOGLEVEL = Specifies the logging level, default is 3 if LOGFILE
;			   is specified, 0 otherwise
;				0 = No logging
;				1 = Log major events
;				2 = Log all network messages
;		LOGFILE  = Specifies file for log output, if not specified no
;			   log output is generated

;Each copy of XFPSRV running on a system must have a unique unit number.  The
;  actual connections between network RCP devices and the server are made after
;  the server is loaded using the SERVER utility.

;Description of data structures used:

;  The server can support up to 31 server instances.  Each instance is
;  associated with an RCP unit/port number pair and can support up to 4088
;  open files (in theory!).  For each instance an IDB is allocated (at the
;  base of a 16MB address space which is reserved for the IDB and the
;  associated CDBs) and contains all data needed to operate the instance.
;  The IDB includes a table of pointers to each possible CDB.  The size of
;  this table is equal to the maximum number of open files allowed.  CDBs
;  (each of which is 4KB) are only allocated when a file is opened.  Each
;  one is allocated as a separate 1 page msect.

;Memory layout for a single instance (starts on a 16MB boundry, base for
;  unit 1 starts at 16MB):
;    base + 00000000:        IDB
;    base + idb_cdbtbl:      CDB table (first entry is for CDB number 8)
;    base + 00008000:        First CDB
;    base + 00009000:        Second CDB
;    ...

;  Free CDBs are managed using a free list linked through the CDB table.  Each
;  free list entry contains the NUMBER of the next free CDB.  The number is
;  the difference between the CDBs offset and the base of the IDB divided by
;  1000h.  The first CDB thus has a number of 8.

.PAGE
VERSION=!1t		;Version number
EDITNUM=!0t		;Edit number

VECT_MESSAGE=!70t	;Message ready signal
VECT_OPEN   =!71t	;RCP open done signal
VECT_INPUT  =!72t	;RCP input available signal
VECT_OUTPUT =!73t	;RCP output complete signal
VECT_CLOSE  =!74t	;RCP close done signal
VECT_DISK   =!75t	;Disk IO done signal

NUMHNDL   =!4t		;Maximum number of open files per connection
DFLT_OPENS=!3t		;Default number of queued opens
DFLT_CONTS=!30t		;Default number of open connections

BUFRSIZE  =!1600t
PARMSIZE  =!1600t

;Define offsets in the IDBs (Instance Data Blocks)

$$$=!0
BLK idb_msgqab  , qab_SIZE	;IPM message QAB
BLK idb_instance, 4t		;Instance number
BLK idb_numcon  , 4t		;Maximum number of connections
BLK idb_cntcon  , 4t		;Current number of connections
BLK idb_cdbfree , 4t		;Offset of first free CDB
BLK idb_msgbufr , 32t		;IPM message buffer
BLK idb_cdbtbl  , 4t		;CDB offset table

;Define offsets in the CDBs (Connection Data Blocks)

cdb_MSIZE=!48t
$$$=!-cdb_MSIZE
BLK cdb_curhndl , 1t		;Current XFP handle
BLK cdb_cntsize , 1t		;Size of data count in data response message
BLK             , 2t
BLK cdb_parmsize, 4t		;Size of parameter
BLK cdb_parmbits, 4t		;Bits for parameter
BLK cdb_parmend , 4t		;Offset of end of parameter list
BLK cdb_string  , 4t		;Offset for allocating string buffers
BLK cdb_reqtotal, 4t		;Total amount requested
BLK cdb_diskdsp , 4t		;Dispatch for disk io done
BLK cdb_idb     , 4t		;Offset of IDB
BLK cdb_number  , 4t		;CDB number
BLK cdb_rmtnode , 4t		;Network address of remote node
BLK cdb_rmtport , 4t		;Remote port number
BLK cdb_lclport , 4t		;Local port number
BLK cdb_rcpqab  , qab_SIZE	;QAB for RCP IO
.IF NE cdb_rcpqab
	.IRP	q, >cdb_rcpqab
	.ERROR	CDB starting offset is wrong, cdb_rcpqab = q'h
	.ENDR
.ENDC
BLK cdb_diskqab , qab_SIZE	;QAB for disk IO
BLK cdb_hndltbl , NUMHNDL*4	;XFP handle table
BLK cdb_hndlamnt, NUMHNDL*4	;Amount output table
BLK cdb_buffer  , BUFRSIZE	;Data buffer
BLK cdb_parm    , PARMSIZE	;Parameter list buffer
cdb_SIZE=!$$$
.PAGE
	.PSECT	_ODATA_p

kwadd:     .ASCIZ "ADD"
kwremove:  .ASCIZ "REMOVE"
kwstatus:  .ASCIZ "STATUS"
kwdisable: .ASCIZ "DISABLE"
kwenable:  .ASCIZ "ENABLE"
kwnumcon:  .ASCIZ "NUMCON"
kwinstance:.ASCIZ "INSTANCE"
kwins:     .ASCIZ "INS"

cmdword::
	.LONG	kwadd    , 0, 0, srvFncCommand#, cmdadd
	.LONG	kwremove , 0, 0, srvFncCommand#, cmdremove
	.LONG	kwstatus , 0, 0, srvFncCommand#, cmdstatus
	.LONG	kwdisable, 0, 0, srvFncCommand#, cmddisable
	.LONG	kwenable , 0, 0, srvFncCommand#, cmdenable
	.LONG	0

keywordadd:
	.LONG	kwnumcon  , ASF$VALREQ|ASF$NVAL , 0, fncnumcon  , 0
keyword:.LONG	kwinstance, ASF$VALREQ|ASF$NVAL , 0, fncinstance, 0
	.LONG	kwins     , ASF$VALREQ|ASF$NVAL , 0, fncinstance, 0
	.LONG	0
.PAGE
	.SBTTL	Start of program

	.PSECT	_OTEXT_p

setup1::PUSHL	#VECT_MESSAGE.B		;Set the message available vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#msgavail
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$.S
	PUSHL	#VECT_OPEN.B		;Set the open done vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#opendone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$.S
	PUSHL	#VECT_INPUT.B		;Set the input ready vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#inputdone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
4$:	JS	srvVectFailR#
	PUSHL	#VECT_OUTPUT.B		;Set the output complete vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#outputdone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$.S
	PUSHL	#VECT_CLOSE.B		;Set the close done vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#closedone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$.S
	PUSHL	#VECT_DISK.B		;Set the disk IO done vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#diskdone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$.S
	RET

finishcmd::
setup2::RET
.PAGE
	.SBTTL	setupcmd - Subroutine to set up for command processing

;Subroutine to set up for command processing
;	CALL	setupcmd

setupcmd::
	CLRL	EAX
	MOVL	instance, EAX
	RET

message::
	CLRL	EAX
	INCL	EAX
	RET
.PAGE
	.SBTTL	fncnumcon - Function to process the NUMCON keyword

;Function to process the NUMCON keyword - this specifies the maximum number of
;  connections allowed for an ADD command

fncnumcon:
	MOVL	EBX, 4.B[ESP]		;Get offset of the argument data
	MOVL	EAX, argdata_value.B[EBX] ;Get value
	TESTL	EAX, EAX
	JNE	6$.S
	MOVB	AL, #DFTCONS
6$:	CMPL	EAX, #MAXCONS
	JA	8$.S
	MOVL	numcon, EAX		;Store it
rtnone:	CLRL	EAX
	INCL	EAX
	RET

;Here if he wants too many connections

8$:	PUSHL	ESI
	PUSHL	EDI
	MOVL	ESI, #bncmsg
	JMP	12$.S

	.SBTTL	fncinstance - Function to process the INSTANCE keyword

;Function to process the INSTANCE keyword - this specifies the instance number

fncinstance:
	MOVL	EBX, 4.B[ESP]		;Get offset of the argument data
	MOVL	EAX, argdata_value.B[EBX] ;Get value
	TESTL	EAX, EAX
	JE	10$.S
	CMPL	EAX, #INSTMAX.B		;Valid?
	JA	10$.S			;No
	MOVL	instance, EAX		;Yes - store it
	JMP	rtnone.S

;Here if the instance number is not valid

10$:	PUSHL	ESI
	PUSHL	EDI
	MOVL	ESI, #bdimsg
12$:	PUSHL	#0.B
	PUSHL	ESI
	PUSHL	#0.B
	CALL	srvCmdErrorResp#
	ADDL	ESP, #12t.B
	POPL	EDI
	POPL	ESI
	CLRL	EAX
	RET

bncmsg:	.ASCIZ	"Invalid number of connections specified"
bdimsg:	.ASCIZ	"Invalid instance number"
.PAGE
	.SBTTL	cmdadd - Subroutine to process the ADD command

;Subroutine to process the ADD command

cmdadd:	MOVL	EAX, 4t.B[ESP]
	MOVL	cmdpntr, EAX
	MOVB	rcpname, #0
	MOVL	rcpport, #UDPP_XFP
	MOVL	numcon, #DFTCONS
	MOVL	numopen, #DFTOPENS
	PUSHL	#0.B			;No default extension for indirect file
	PUSHL	#0.B			;No next line function
	PUSHL	#srvCmdError#		;Error function
	PUSHL	#0.B			;Function called for non-keyword args
	PUSHL	#keywordadd		;Offset of keyword table
	PUSHL	#0.B			;Offset of option table
	PUSHL	#PAF$INDIRECT|PAF$EATQUOTE ;Flag bits
	PUSHL	#cmdpntr		;Offset of arg string pointer
	CALL	procarg#		;Process arguments
	ADDL	ESP, #32t.B
	TESTL	EAX, EAX
	JE	2$.S
	CALL	requireinst		;Make sure instance was specified
	JC	2$.S
	MOVL	EAX, instance
	BTL	instx, EAX		;Is the instance defined now?
	JNC	4$.S			;No - go on
	SUBL	ESP, #100t.B		;Yes - complain and fail
	MOVL	ESI, ESP
	PUSHL	instance
	PUSHL	#iiufmt
	PUSHL	ESI
	CALL	sprintf#
	PUSHL	#0.B
	PUSHL	ESI
	PUSHL	#0.B
	CALL	srvCmdErrorResp#
	ADDL	ESP, #124t.B
2$:	RET

;Here if specified instance does not now exist

4$:	MOVL	ESI, instance
	SHLL	ESI, #24t
	PUSHL	DS
	PUSHL	ESI
	PUSHL	#PG$READ|PG$WRITE.B
	MOVL	EAX, #idb_SIZE
	IMULL	EDX, numcon, #4.B
	ADDL	EAX, EDX
	PUSHL	EAX
	CALLF	svcMemChange##
	TESTL	EAX, EAX		;Error?
	JNS	6$.S			;No - go on
	SUBL	ESP, #100t.B		;Yes - complain and fail
	MOVL	ESI, ESP
	PUSHL	instance
	PUSHL	#nmifmt
err2:	PUSHL	ESI
	CALL	sprintf#
	PUSHL	#0.B
	PUSHL	ESI
	PUSHL	#0.B
	CALL	srvCmdErrorResp#
	ADDL	ESP, #124t.B
	RET

;Here with memory allocated for the instance

6$:	MOVL	EAX, instance		;Indicate instance exists
	BTSL	instx, EAX
	MOVL	idb_instance.B[ESI], EAX ;Store the instance number
	MOVL	ECX, numcon		;Store maximum number of connections
	MOVL	idb_numcon.B[ESI], ECX
	LEAL	EBX, idb_cdbtbl.B[ESI]	;Set up the CDB free list
	MOVL	EAX, #8t
	MOVL	idb_cdbfree.B[ESI], EAX
	DECL	ECX
	JE	10$.S
8$:	INCL	EAX
	MOVL	[EBX], EAX
	ADDL	EBX, #4.B
	LOOP	ECX, 8$
10$:	SUBL	ESP, #32t.B
	MOVL	EDI, ESP
	PUSHL	idb_instance.B[ESI]	;Build the incoming connection IPM
	PUSHL	srvUnitNum#		;  device name
	PUSHL	#ipmnfmt
	PUSHL	EDI
	CALL	sprintf#
	PUSHL	#O$IN|O$OUT.B		;Open the message device
	PUSHL	DS
	PUSHL	EDI
	PUSHL	#0.B
	PUSHL	#0.B
	CALLF	svcIoOpen##
	ADDL	ESP, #48t.B
	ORL	EAX, EAX
	JNS	14$.S
	MOVL	ESI, #opmdmsg
12$:	PUSHL	#0.B
	PUSHL	ESI
	PUSHL	EAX
	CALL	srvCmdErrorResp#
	ADDL	ESP, #12t.B
	RET

;Here with the serial port message device open

14$:	MOVL	idb_msgqab+qab_handle.B[ESI], EAX
	MOVL	idb_msgqab+qab_func.B[ESI], #QFNC_INBLOCK
	MOVL	idb_msgqab+qab_vector.B[ESI], #VECT_MESSAGE
	MOVL	idb_msgqab+qab_count.B[ESI], #32t
	LEAL	EAX, idb_msgbufr.B[ESI]
	MOVL	idb_msgqab+qab_buffer1+0.B[ESI], EAX
	MOVL	idb_msgqab+qab_buffer1+4.B[ESI], DS
	PUSHL	DS
	PUSHL	ESI
	CALLF	svcIoQueue##
	ORL	EAX, EAX
	JNS	16$.S
	MOVL	ESI, inmdmsg
	JMP	12$.S

;Here with initial input queued for the message device

$$$$done::
16$:	SUBL	ESP, #100t.B
	MOVL	EDI, ESP
	PUSHL	idb_instance.B[ESI]
	PUSHL	#okfmt
	PUSHL	EDI
	CALL	sprintf#
	PUSHL	EDI
	CALL	srvCmdResponse#
	ADDL	ESP, #116t.B
	RET

iiufmt:	.ASCIZ	"Instance %d already exists"
nmifmt:	.ASCIZ	"Cannot allocate memory for instance %d"
opmdmsg:.ASCIZ  "Error opening incoming connection message device"
inmdmsg:.ASCII  "Error queueing initial input for incoming connection message"
	.ASCIZ	" device"
ipmnfmt:.ASCIZ	"IPM:SYS^XFPSRV^%d^%d"
okfmt:	.ASCIZ	{MT_FINALMSG}"XFPSRV: Instance %d created"

	.MOD	4
opnparms:
	.BYTE	PAR$GET|REP_HEXV, 4
	.WORD	IOPAR_NETLCLPORT
opn_lclport=!$-opnparms
	.LONG	0
	.BYTE	PAR$GET|REP_HEXV, 4
	.WORD	IOPAR_NETRMTNETAR
opn_rmtnode=!$-opnparms
	.LONG	0
	.BYTE	PAR$GET|REP_HEXV, 2
	.WORD	IOPAR_NETRMTPORTR
opn_rmtport=!$-opnparms
	.WORD	0
	.BYTE	0
OPNPSIZE=!$-opnparms
.PAGE
	.SBTTL	cmdremove - Subroutine to process the REMOVE command

;Subroutine to process the REMOVE command

cmdremove:
	CALL	requireinst
	JC	10$.S
	PUSHL	#rmvmsg
	CALL	srvCmdResponse#
	ADDL	ESP, #4t.B
10$:	RET

rmvmsg:	.ASCIZ	{MT_FINALERR}"? XFPSRV: REMOVE command not implemented yet!"
.PAGE
	.SBTTL	cmdstatus - Subroutine to process the STATUS command

;Subroutine to process the STATUS command

cmdstatus:
	MOVL	EDI, #stsmsg
	JMP	srvCmdResponse#

stsmsg:	.ASCIZ	{MT_FINALERR}"? XFPSRV: STATUS command not implemented yet!"
.PAGE
	.SBTTL	cmdenable - Subroutine to process the ENABLE command

;Subroutine to process the ENABLE command

cmdenable:
	CALL	requireinst
	JC	10$.S
	PUSHL	#enbmsg
	CALL	srvCmdResponse#
	ADDL	ESP, #4t.B
10$:	RET

enbmsg:	.ASCIZ	{MT_FINALERR}"? XFPSRV: ENABLE command not implemented yet!"
.PAGE
	.SBTTL	cmddisenable - Subroutine to process the DISABLE command

;Subroutine to process the DISABLE command

cmddisable:
	CALL	requireinst
	JC	10$.S
	PUSHL	#dismsg
	CALL	srvCmdResponse#
	ADDL	ESP, #4t.B
10$:	RET

dismsg:	.ASCIZ	{MT_FINALERR}"? XFPSRV: DISABLE command not implemented yet!"
.PAGE
	.SBTTL	requireinst

requireinst:
	CMPL	instance, #0.B
	JNE	4$.S
	PUSHL	#noinmsg
	CALL	srvCmdResponse#
	ADDL	ESP, #4t.B
	STC
4$:	RET

noinmsg:.ASCIZ	{MT_FINALERR}"? XFPSRV: No instance specified"

	.SBTTL	End of command processing
.PAGE
	.SBTTL	qinput - Subroutine to queue RCP input

;Subroutine to queue RCP input
;	c{EDI} = Offset of CDB
;	c{ESI} = Offset of SDB
;	CALL	qinput

qinput:	MOVW	cdb_rcpqab+qab_func.B[EDI], #QFNC_INBLOCK ;Set up the QAB
	MOVL	cdb_rcpqab+qab_count.B[EDI], #BUFRSIZE
	MOVL	cdb_rcpqab+qab_vector.B[EDI], #VECT_INPUT
	LEAL	EAX, cdb_buffer[EDI]
	MOVL	cdb_rcpqab+qab_buffer1+0.B[EDI], EAX
	PUSHL	DS			;Queue an input
	PUSHL	EDI
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	4$.S			;If error
	RET				;Thats all

;Here if error queueing input

4$:	PUSHL	#qinmsg
	PUSHL	EAX
	CALL	srvLogSysLog#
	ADDL	ESP, #8t.B
	RET
.PAGE
	.SBTTL	msgavail - Signal routine for IPM message available

;Signal routine for IPM message available

msgavail:
	PUSHAL
	MOVL	ESI, 64t.B[ESP]		;Get offset of the IDB
	TESTB	idb_msgqab+qab_status+1.B[ESI], #QSTS$DONE>8t
	JE	msgdsm
msgloop:CMPB	idb_msgbufr+0.B[ESI], #MT_TERMDATA ;Is the message type right?
	JNE	2$.S			;No - ignore it!
	MOVL	EAX, idb_msgqab+qab_amount.B[ESI] ;Get message length
	CMPL	EAX, #20t.B		;Is it reasonable?
	JA	2$.S			;No
	MOVW	idb_msgbufr.B[ESI+EAX], #':' ;Yes - fix up the device name
	CMPB	idb_msgbufr+1.B[ESI], #31h ;Is this an RCP connection?
	JNE	2$.S			;No
	MOVL	ECX, idb_cdbfree.B[ESI]	;Yes - get a free CDB slot
	TESTL	ECX, ECX
	JNE	4$.S			;Go if have one available
	PUSHL	#nocdbsmsg
	PUSHL	#0.B
	CALL	srvLogSysLog#
	ADDL	ESP, #8t.B
2$:	JMP	msgfin

;Here with an available CDB slot

4$:	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	6$.S			;No
	PUSHL	ECX			;Yes
	LEAL	EAX, idb_msgbufr+4.B[ESI]
	PUSHL	EAX
	PUSHL	ECX
	PUSHL	#confmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #16t.b
	POPL	ECX
6$:	MOVL	EBX, ECX
	SHLL	EBX, #12t		;Get offset of the CDB
	ADDL	EBX, ESI
	PUSHL	DS			;Allocate memory for the CDB
	PUSHL	EBX
	PUSHL	#PG$WRITE|PG$READ
	PUSHL	#cdb_SIZE
	CALLF	svcMemChange#
	TESTL	EAX, EAX
	JNS	8$.S			;If OK
	PUSHL	#nomcdbmsg
	CALL	srvLogSysLog#
	POPL	EAX
	JMP	msgfin

;Here with memory allocated for the CDB

8$:	MOVL	EAX, idb_cdbtbl-8*4.B[ESI+ECX*4] ;Remove CDB from the free list
	MOVL	idb_cdbfree.B[ESI], EAX
	ADDL	EBX, #cdb_MSIZE.B
	MOVL	idb_cdbtbl-8*4.B[ESI+ECX*4], EBX
	MOVL	cdb_number.B[EBX], ECX	;Store index
	MOVL	cdb_idb.B[EBX], ESI	;Store offset of the IDB
	MOVL	cdb_rcpqab+qab_buffer1+4.B[EBX], DS
	MOVL	cdb_rcpqab+qab_func.B[EBX], #QFNC_OPEN
	MOVW	cdb_rcpqab+qab_vector.B[EBX], #VECT_OPEN
	MOVL	cdb_rcpqab+qab_option.B[EBX], #O$IN|O$OUT
	LEAL	EAX, idb_msgbufr+4.B[ESI]
	MOVL	cdb_rcpqab+qab_buffer1+0.B[EBX], EAX
	MOVL	cdb_rcpqab+qab_buffer1+4.B[EBX], DS
	LEAL	EDI, cdb_parm[EBX]
	MOVL	cdb_rcpqab+qab_parm+0.B[EBX], EDI
	MOVL	cdb_rcpqab+qab_parm+4.B[EBX], DS
	PUSHL	ESI			;Set up the parameter list
	MOVL	ESI, #opnparms
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #{OPNPSIZE+3}/4
	CLD
	RMOVSL	[EDI], [ESI]
	POPL	ESI
	PUSHL	DS			;Queue the open
	PUSHL	EBX
	CALLF	svcIoQueue##
	TESTL	EAX, EAX
	JNS	msgfin			;If OK

	HLT		;IF ERROR!!!


msgfin:	MOVW	idb_msgqab+qab_vector.B[ESI], #0 ;Queue another message input
	PUSHL	DS
	PUSHL	ESI
	CALLF	svcIoQueue##
	ORL	EAX, EAX
	JS	10$.S
	MOVW	idb_msgqab+qab_vector.B[ESI], #VECT_MESSAGE
	TESTB	idb_msgqab+qab_status+1.B[ESI], #QSTS$DONE>8t
	JNE	msgloop
msgdsm:	POPAL				;Restore registers
	CALLF	svcSchDismiss##		;And dismiss

;Here if error queueing message input

10$:	HLT
.PAGE
	.SBTTL	opendone - Signal routine for RCP open complete

;Signal routine for RCP open complete

opendone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t.B[ESP]		;Get offset of the CDB
	CMPL	cdb_rcpqab+qab_error.B[EDI], #0.B ;Error on the open?
	JS	6$.S			;Yes
	CLRL	EAX			;No
	MOVL	cdb_rcpqab+qab_parm+0.B[EDI], EAX
	MOVZWL	EAX, cdb_parm+opn_lclport[EDI] ;Store local port number
	MOVL	cdb_lclport.B[EDI], EAX
	MOVZWL	EAX, cdb_parm+opn_rmtport[EDI] ;Store remote port number
	MOVL	cdb_rmtport.B[EDI], EAX
	MOVL	EAX, cdb_parm+opn_rmtnode[EDI] ;And store remote IP address
	MOVL	cdb_rmtnode.B[EDI], EAX
	MOVL	cdb_diskqab+qab_buffer1+4.B[EDI], DS
	MOVL	cdb_diskqab+qab_buffer2+4.B[EDI], DS
	MOVL	cdb_diskqab+qab_parm+4.B[EDI], DS
	MOVL	cdb_diskqab+qab_vector.B[EDI], #VECT_DISK
	CALL	qinput			;Queue an input for this connection
	POPAL				;Restore registers
	CALLF	svcSchDismiss#		;And dismiss

;Here if error on the RCP open

6$:	PUSHL	#opnemsg2
	PUSHL	cdb_rcpqab+qab_error.B[EDI]
	CALL	srvLogSysLog#
	ADDL	ESP, #8t.B
	JMP	givecdb
.PAGE
	.SBTTL	inputdone - Software interrupt routine for RCP input complete

;Software interrupt routine for RCP input complete

inputdone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t.B[ESP]		;Get offset of the CDB
	TESTB	cdb_rcpqab+qab_status+1.B[EDI], #QSTS$DONE>8 ;Really finished?
	JE	6$.S			;No - false alarm!
2$:	CMPL	cdb_rcpqab+qab_error.B[EDI], #0.B ;Yes - any errors?
	JS	rcperr			;Yes
	CMPB	srvDebugLevel#, #2
	JB	4$.S
	MOVL	EBX, #strrcpi
	MOVL	EDX, #tablei
	MOVL	ECX, cdb_rcpqab+qab_amount.B[EDI]
	CALL	logmsg
4$:	SUBL	cdb_rcpqab+qab_amount.B[EDI], #2t.B
	JS	proterr.S
	LEAL	ESI, cdb_buffer+2[EDI]
	MOVB	AL, -1.B[ESI]		;Get the channel number
	ANDL	EAX, #0Fh.B
	DECL	EAX
	JS	proterr.S
	CMPB	AL, #NUMHNDL		;Valid value?
	JAE	proterr.S		;No - fail
	MOVB	cdb_curhndl.B[EDI], AL	;Yes - remember the handle
	MOVL	EAX, cdb_hndltbl.B[EDI+EAX*4] ;Get XOS handle
	MOVL	cdb_diskqab+qab_handle.B[EDI], EAX
	MOVZBL	EAX, -2.B[ESI]		;Get the function value
	ANDB	AL, #0Fh
	JMPIL	cmddsp[EAX*4]		;Dispatch on the function

6$:	POPAL
	CALLF	svcSchDismiss#

	.MOD	4
cmddsp:	.LONG	proterr		;	      = 0  - Illegal
	.LONG	msgopen		;XFPF_OPEN    = 1  - Open
	.LONG	msgdevparm	;XFPF_PARM    = 2  - Parmeter function
	.LONG	msgclose	;XFPF_CLOSE   = 3  - Close
	.LONG	msgcommit	;XFPF_COMMIT  = 4  - Commit data to file
	.LONG	msgdelete	;XFPF_DELETE  = 5  - Delete file
	.LONG	msgrename	;XFPF_RENAME  = 6  - Rename file
	.LONG	proterr		;	      = 7  - Illegal
	.LONG	msgdata		;XFPF_DATA    = 8  - Data message
	.LONG	msgdatareq	;XFPF_DATAREQ = 9  - Data request
	.LONG	proterr		;	      = 10 - Illegal
	.LONG	proterr		;	      = 11 - Illegal
	.LONG	proterr		;	      = 12 - Illegal
	.LONG	proterr		;	      = 13 - Illegal
	.LONG	proterr		;	      = 14 - Illegal
	.LONG	proterr		;	      = 15 - Illegal

proterr:MOVL	EAX, #ER_NPERR
	JMP	sererr
.PAGE
;Here on fatal protocol error

faterr:	MOVL	EAX, #ER_NPERR
	JMP	rcper2.S

;Here if error on input - all errors reported here indicate a serious problem
;  with the network connection - an ER_NCCLR error is the normal indication
;  of the other end clearing the connection

rcperr:	MOVL	EAX, cdb_rcpqab+qab_error.B[EDI]
rcper2:	CMPL	EAX, #ER_NCCLR		;Normal clearing?
	JE	clrcon.S		;Yes - go on
	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	clrcon.S		;No
	PUSHL	cdb_rcpqab+qab_handle.B[EDI]
	PUSHL	EAX
	PUSHL	cdb_number.B[EDI]
	PUSHL	#rerfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #20t.B
clrcon:	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	2$.S			;No
	PUSHL	cdb_rcpqab+qab_handle.B[EDI]
	PUSHL	EAX
	PUSHL	cdb_number.B[EDI]
	PUSHL	#clrfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #20t.B
2$:	MOVL	cdb_rcpqab+qab_func.B[EDI], #QFNC_CLOSE ;Close the RCP device
	CLRL	EAX
	MOVL	cdb_rcpqab+qab_option.B[EDI], EAX
	MOVL	cdb_rcpqab+qab_parm.B[EDI], EAX
	MOVB	cdb_rcpqab+qab_vector.B[EDI], #VECT_CLOSE
	PUSHL	DS
	PUSHL	EDI
	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	3$.S			;No
	PUSHL	cdb_rcpqab+qab_handle.B[EDI]
	PUSHL	EAX
	PUSHL	cdb_number.B[EDI]
	PUSHL	#cbgfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #20t.B
3$:	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	6$.S			;If error
4$:	POPAL				;OK - restore registers
	CALLF	svcSchDismiss#		;And dismiss

;Here with error while clearing the RCP connection

6$:
;;;;;;;;CODE GOES HERE TO LOG THE ERROR!!!

;;;;;;;	JMP	14$

	JMP	8$			;Forget the RCP close, go close any
					;  open devices

;RCP close done software interrupt routine

closedone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t.B[ESP]		;Get offset of the CDB
	TESTB	cdb_rcpqab+qab_status+1.B[EDI], #QSTS$DONE>8 ;Really finished?
	JE	4$.S			;No - false alarm!
	CMPB	srvDebugLevel#, #2
	JB	7$.S
	PUSHL	cdb_rcpqab+qab_handle.B[EDI]
	PUSHL	EAX
	PUSHL	cdb_number.B[EDI]
	PUSHL	#cdnfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #20t.B
7$:	CMPL	cdb_rcpqab+qab_error.B[EDI], #0.B ;Yes - any errors?
	JS	6$.S			;Yes
8$:	CLRL	EAX
10$:	CMPL	cdb_hndltbl.B[EDI+EAX*4], #0.B ;This handle in use?
	JNE	14$.S			;Yes
	INCL	EAX			;No - bump handle index
	CMPL	EAX, #NUMHNDL		;Finished?
	JB	10$.S			;No - continue
givecdb:MOVL	ESI, cdb_idb.B[EDI]	;Yes
	MOVL	ECX, cdb_number.B[EDI]	;Put this slot on the free list
	MOVL	EAX, idb_cdbfree.B[ESI]
	MOVL	idb_cdbtbl-8*4.B[ESI+ECX*4], EAX
	MOVL	idb_cdbfree.B[ESI], ECX
	SUBL	EDI, #cdb_MSIZE.B	;Give up our CDB
	PUSHL	DS
	PUSHL	EDI
	PUSHL	#PG$WRITE|PG$READ
	PUSHL	#0.B
	CALLF	svcMemChange#
	POPAL				;Finished here
	CALLF	svcSchDismiss#

;Here with a handle which is in use

14$:	MOVL	EDX, cdb_hndltbl.B[EDI+EAX*4] ;Get XOS handle
	MOVL	cdb_diskqab+qab_handle.B[EDI], EDX ;Store it
	MOVL	cdb_hndltbl.B[EDI+EAX*4], #0 ;Clear the handle table entry
	MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_CLOSE
	CLRL	EAX
	MOVL	cdb_diskqab+qab_option.B[EDI], EAX
	MOVL	cdb_diskqab+qab_parm.B[EDI], EAX
	MOVL	cdb_diskdsp.B[EDI], #8$	;Set dispatch for disk done
	JMP	dodisk			;Continue
.PAGE
;Here for the XFPF_DATA function - Data

msgdata:TESTB	cdb_buffer+1[EDI], #20h	;Have any parameters?
	JE	2$.S			;No
	CALL	getvalue		;Yes - get length of data area
	JC	6$.S
	SUBL	cdb_rcpqab+qab_amount.B[EDI], EAX ;Get length of parameter area
	JNS	4$.S
	JMP	proterr
2$:	CLRL	EAX
	XCHGL	EAX, cdb_rcpqab+qab_amount.B[EDI]
4$:	MOVL	cdb_diskqab+qab_count.B[EDI], EAX
	MOVL	cdb_diskqab+qab_buffer1.B[EDI], ESI ;Store data buffer offset
	ADDL	ESI, EAX		;Point to the parameters (if any)
	CALL	setupparms		;Set up the parameter list
6$:	JC	sererr
8$:	MOVL	cdb_diskdsp.B[EDI], #outputrdy ;Set dispatch for disk done
	MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_OUTBLOCK ;Store function
	JMP	dodisk			;Continue
.PAGE
;Here when disk output is complete

outputrdy:
	MOVL	EAX, cdb_diskqab+qab_amount.B[EDI] ;Get amount
	MOVZBL	EBX, cdb_curhndl.B[EDI]
	ADDL	cdb_hndlamnt.B[EDI+EBX*4], EAX ;Add in to amount for handle
	CMPL	cdb_diskqab+qab_error.B[EDI], #0.B ;Error?
	JL	2$.S			;Yes
	CMPL	cdb_diskqab+qab_count.B[EDI], EAX ;Was it all output?
	JNE	4$.S			;No - return error
	TESTB	cdb_buffer+1[EDI], #10h	;Yes - need a response?
	JE	outputdon2		;No
2$:	MOVL	EAX, cdb_hndlamnt.B[EDI+EBX*4] ;Yes - get total amount output
	MOVL	cdb_diskqab+qab_amount.B[EDI], EAX ;Store for reply
	CLRL	EAX			;Clear the amount
	MOVL	cdb_hndlamnt.B[EDI+EBX*4], EAX
	CALL	setresp			;Set up the response
	JNC	sndresp			;Send it
	JMP	clrcon			;Clear connection if error

;Here if output was incomplete

4$:	MOVL	cdb_diskqab+qab_error.B[EDI], #ER_INCMO
	JMP	2$.S
.PAGE
;Here for the XFPF_DATAREQ function - Data request

msgdatareq:
	CALL	getvalue		;Get count value
	JC	sererr
	MOVL	cdb_reqtotal.B[EDI], EAX ;Store total amount wanted
	MOVZBL	EBX, cdb_curhndl.B[EDI]
	MOVL	cdb_hndlamnt.B[EDI+EBX*4], #0
	CALL	setupparms		;Set up the parameter list
	JC	sererr
datreq2:MOVL	EAX, cdb_reqtotal.B[EDI] ;Get amount wanted
	CMPL	EAX, #1024t		;Too big?
	JBE	2$.S			;No
	MOVL	EAX, #1024t		;Yes
2$:	SUBL	cdb_reqtotal.B[EDI], EAX ;Reduce amount to get
	CLRL	ECX
	CMPL	cdb_diskqab+qab_parm.B[EDI], #0.B ;Have any parameters?
	JE	4$.S			;No
	CALL	getvalsize		;Yes - allow space for the count
4$:	MOVB	cdb_cntsize.B[EDI], CL	;Store count size
	LEAL	EBX, cdb_buffer+6[EDI+ECX] ;Get offset of the data buffer
	MOVL	cdb_diskqab+qab_buffer1.B[EDI], EBX ;Store buffer offset
	MOVL	cdb_diskqab+qab_count.B[EDI], EAX ;Store byte count
	MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_INBLOCK ;Store function
	MOVL	cdb_diskdsp.B[EDI], #inputrdy ;Set dispatch for disk done
	JMP	dodisk			;Continue
.PAGE
;Here when disk input is done

inputrdy:
	LEAL	EBX, cdb_buffer+4[EDI]	;Point to start of header (assume no
					;  error)
	LEAL	ESI, 2.B[EBX]		;Point to first byte after header
	MOVL	EAX, cdb_diskqab+qab_amount.B[EDI] ;Get amount of data read
	MOVZBL	ECX, cdb_curhndl.B[EDI]
	ADDL	cdb_hndlamnt.B[EDI+ECX*4], EAX ;Add in to amount for handle
	LEAL	EDX, 1.B[ECX]		;Assume not finished
	CMPL	cdb_reqtotal.B[EDI], #0.B ;Right?
	JE	2$.S			;No
	CMPL	EAX, cdb_diskqab+qab_count.B[EDI] ;Maybe - got all we wanted?
	JE	4$.S			;Yes
1$:	MOVL	cdb_reqtotal.B[EDI], #0.B ;No - finished
2$:	ORB	DL, #10h		;Indicate finished
4$:	CMPL	cdb_diskqab+qab_error.B[EDI], #0.B ;Error?
	JNS	6$.S			;No
	CMPL	cdb_diskqab+qab_error.B[EDI], #ER_EOF.B ;End of file?
	JNE	5$.S			;No
	CMPL	cdb_hndlamnt.B[EDI+ECX*4], #0.B ;Yes - did we get anything?
	JE	5$.S			;No - report the error
	MOVL	cdb_diskqab+qab_error.B[EDI], #0 ;Yes - not really an error!
	JMP	1$.S

;Here with error other than EOF

5$:	ORB	DL, #80h		;Indicate error
	SUBL	EBX, #4t.B		;Allow room for error code
	MOVL	ECX, cdb_diskqab+qab_error.B[EDI] ;Store error code
	XCHGB	CL, CH
	RORL	ECX, #16t
	XCHGB	CL, CH
	MOVL	2.B[EBX], ECX
6$:	MOVB	[EBX], #XFPF_DATARESP	;Store function
	MOVB	1.B[EBX], DL		;Store bits
	CMPL	cdb_diskqab+qab_parm.B[EDI], #0.B ;Have any parameters?
	JE	10$.S			;No
	ORB	1.B[EBX], #20h		;Yes - fix up the header
	MOVZBL	ECX, cdb_cntsize.B[EDI]	;Get size for the count
	JMPIL	cntdsp-4[ECX*4]

	.MOD	4
cntdsp:	.LONG	cnt1
	.LONG	cnt2
	.LONG	cnt3
	.LONG	cnt4

;Here if have a 1 byte count

cnt1:	MOVB	[ESI], AL
	INCL	ESI
	JMP	10$.S

;Here if have a 2 byte count

cnt2:	ORB	AH, #80h
	XCHGB	AL, AH
	MOVW	[ESI], AX
	ADDL	ESI, #2t.B
	JMP	10$.S

;Here if have a 3 byte count

cnt3:	XCHGB	AL, AH
	RORL	EAX, #16t
	MOVB	AH, AL
	SHRL	EAX, #8t
	ORB	AL, #0C0h
	MOVL	[ESI], EAX
	ADDL	ESI, #3t.B

;Here if have a 4 byte count

cnt4:	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	ORB	AL, #0E0h
	MOVL	[ESI], EAX
	ADDL	ESI, #4t.B
10$:	ADDL	ESI, cdb_diskqab+qab_amount.B[EDI] ;Point to first byte after
	CLRL	EAX				   ;  the data we just read
	MOVL	cdb_rcpqab+qab_parm+0.B[EDI], EAX
	CMPL	cdb_diskqab+qab_parm+0.B[EDI], #0.B ;Have any parameters?
	JE	12$.S			;No - go on
	PUSHL	EBX			;Yes
	CALL	storeparms		;Store parameters in the message
	POPL	EBX
	JC	sererr			;If error
	CLRL	EAX			;Only process parameters once
	MOVL	cdb_diskqab+qab_parm.B[EDI], EAX
12$:	SUBL	ESI, EBX		;OK - calculate length of the response
	MOVL	cdb_rcpqab+qab_count.B[EDI], ESI ;Store it in the QAB	CLRL	EAX
	JMP	sndres2			;Send the response
.PAGE
;Here for the XFPF_COMMIT function - Commit data to file

msgcommit:
	CALL	setupparms		;Set up the parameter list
	JC	sererr			;If error
	MOVL	cdb_diskdsp.B[EDI], #commitrdy ;Set dispatch for disk done
	MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_COMMIT ;Store function
	JMP	dodisk			;Continue
.PAGE
;Here when commit function is complete

commitrdy:
	CMPL	cdb_diskqab+qab_error.B[EDI], #0.B ;Error?
	JL	4$.S			;Yes
	CLRL	EAX			;OK - amount is always 0
	MOVL	cdb_diskqab+qab_amount.B[EDI], EAX ;Store for reply
4$:	JMP	closerdy		;Continue
.PAGE
;Here for the XFPF_OPEN function - Open file

msgopen:MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_OPEN
	CALL	opensetup		;Do first part of this
	JC	sererr
	MOVL	cdb_diskdsp.B[EDI], #openrdy ;Set dispatch for disk done
	JMP	dodisk

;Here if have a serious error.  This code generates an error message without
;  parameters with an item count of 0.  Generally, this is used when we detect
;  an error with the format of an input message or if some internal resource
;  is not available.
;	c{EAX} = Error code

sererr:	MOVL	cdb_buffer+0[EDI], #XFPF_RESPONSE+9000h
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	cdb_buffer+3[EDI], EAX
	MOVL	cdb_rcpqab+qab_count.B[EDI], #7t
	CLRL	EAX
	MOVL	cdb_rcpqab+qab_parm+0.B[EDI], EAX
	JMP	sndresp
.PAGE
;Here when the open is finished

openrdy:CMPL	cdb_diskqab+qab_error.B[EDI], #0.B ;Error?
	JL	2$.S			;Yes
	MOVL	EAX, cdb_diskqab+qab_handle.B[EDI] ;No - store XOS handle
	MOVZBL	EBX, cdb_curhndl.B[EDI]		   ;  in the XFP handle table
	MOVB	cdb_hndltbl.B[EDI+EBX*4], AL
	CLRL	EAX			;Clear amount output
	MOVL	cdb_hndlamnt.B[EDI+EBX*4], EAX
2$:	CALL	setresp			;Set up the response message
	JC	sererr
sndresp:LEAL	EBX, cdb_buffer[EDI]
sndres2:MOVL	cdb_rcpqab+qab_buffer1+0.B[EDI], EBX
	MOVW	cdb_rcpqab+qab_func.B[EDI], #QFNC_OUTBLOCK
	MOVB	cdb_rcpqab+qab_vector.B[EDI], #VECT_OUTPUT
	CLRL	EAX
	MOVL	cdb_rcpqab+qab_parm+0.B[EDI], EAX
	CMPB	srvDebugLevel#, #2
	JB	4$.S
	MOVL	EBX, #strrcpo
	MOVL	EDX, #tableo
	MOVL	ECX, cdb_rcpqab+qab_count.B[EDI]
	CALL	logmsg
4$:	PUSHL	DS			;Start output
	PUSHL	EDI
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	clrcon			;If error, just quietly clear the
					;  conection
	POPAL				;Restore registers
	CALLF	svcSchDismiss#		;And dismiss
.PAGE
;Here for the XFPF_DEVPARM function - Device parameter function

msgdevparm:
	MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_DEVPARM
devparm2:
	CALL	opensetup		;Do first part of this
	JC	sererr
	MOVL	cdb_diskdsp.B[EDI], #devparmrdy ;Set dispatch for disk done
dodisk:	PUSHL	DS
	LEAL	EAX, cdb_diskqab.B[EDI]
	PUSHL	EAX
	CALLF	svcIoQueue#		;Do the function
	TESTL	EAX, EAX
	JS	sererr			;If error
	POPAL
	CALLF	svcSchDismiss#		;Dismiss the interrupt
.PAGE
;Here if a devparm function has just finished

devparmrdy:
	CALL	setresp			;Set up the response message
	JNC	sndresp			;If OK
	JMP	sererr
.PAGE
;Here for the XFPF_CLOSE function - Close

msgclose:
	SUBL	cdb_rcpqab+qab_amount.B[EDI], #4.B ;Must have at least 4 bytes
	JS	4$.S
	MOVL	EAX, [ESI]		;Get the command bits
	ADDL	ESI, #4t.B
	XCHGB	AL, AH			;Fix up the byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	cdb_diskqab+qab_option.B[EDI], EAX
	CALL	setupparms		;Set up the parameter list
	JC	4$.S
	MOVL	cdb_diskdsp.B[EDI], #closerdy ;Set dispatch for disk done
2$:	MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_CLOSE
	JMP	dodisk.S		;Continue

;Here if packet is too short to contain the close command bits or if have
;  error setting up the parameter list - close the file anyway but report
;  the error

4$:	CLRL	EAX
	MOVL	cdb_diskqab+qab_option.B[EDI], EAX
	MOVL	cdb_diskqab+qab_parm+0.B[EDI], EAX
	MOVL	cdb_diskdsp.B[EDI], #closeerr
	JMP	2$.S

;Here when the close function is done if had problem setting up the parameter
;  list

closeerr:
	MOVL	EAX, #ER_NPERR
	MOVL	cdb_diskqab+qab_error.B[EDI], EAX

;Here when the close function is done

closerdy:
	CLRL	EAX			;Clear input request amount
	MOVL	cdb_reqtotal.B[EDI], EAX
	MOVZBL	EDX, cdb_curhndl.B[EDI]
	MOVL	cdb_hndltbl.B[EDI+EDX*4], EAX
	CALL	setresp			;Set up the response
	JNC	sndresp			;Send it
	JMP	clrcon			;Clear connection if error
.PAGE
;Here for the XFPF_DELETE function - Delete file

msgdelete:
	MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_DELETE
	JMP	devparm2
.PAGE
;Here for the XFPF_RENAME function - Rename file

msgrename:
	MOVW	cdb_diskqab+qab_func.B[EDI], #QFNC_RENAME
	JMP	devparm2
.PAGE
	.SBTTL	opensetup - Subroutine to do set up for open type functions

;Subroutine to do set up for open type functions
;	CALL	opensetup
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

opensetup:
	SUBL	cdb_rcpqab+qab_amount.B[EDI], #4.B ;Must have at least 4 bytes
	JS	12$
	MOVL	EAX, [ESI]		;Get the command bits
	ADDL	ESI, #4t.B
	XCHGB	AL, AH			;Fix up the byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	cdb_diskqab+qab_option.B[EDI], EAX
	CALL	getname			;Get offset of name string
	JC	10$.S
	MOVL	cdb_diskqab+qab_buffer1+0.B[EDI], EDX ;Store offset of name
	CMPB	cdb_diskqab+qab_func.B[EDI], #QFNC_RENAME ;Rename?
	JNE	2$.S			;No
	PUSHL	ESI
	CALL	getname			;Get offset of new name
	POPL	EBX
	JC	10$.S
	MOVL	cdb_diskqab+qab_buffer2+0.B[EDI], EDX ;Store offset of name
	MOVB	[EBX], #0		;Store null to terminate name
2$:	PUSHL	ESI			;Save offset of byte after name
	CALL	setupparms		;Set up the parameter list
	POPL	EBX
	JC	10$.S			;If error
	MOVB	[EBX], #0		;Store null to terminate name
	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	8$.S			;No
	CMPB	cdb_diskqab+qab_func.B[EDI], #QFNC_RENAME
	JE	4$.S
	PUSHL	cdb_diskqab+qab_buffer1.B[EDI]
	PUSHL	#namfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #12t
	CLC
	RET

4$:	PUSHL	cdb_diskqab+qab_buffer2.B[EDI]
	PUSHL	cdb_diskqab+qab_buffer1.B[EDI]
	PUSHL	#renfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #16t
8$:	CLC
10$:	RET

12$:	MOVL	EAX, #ER_NPERR
	STC
	RET

namfmt:	.ASCIZ	"nam: %s"{LF}
renfmt:	.ASCIZ	"nam: %s %s"{LF}

;Subroutine to get offset of name string
;	c{ESI} = Pointer to message data
;	CALL	getname
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX} = Offset of name string
;	  c{ESI} = Pointer to first byte after name string

getname:CALL	getvalue		;Get length of file specification
	JC	14$.S			;If error
	SUBL	cdb_rcpqab+qab_amount.B[EDI], EAX
	JS	12$.S
	MOVL	EDX, ESI		;Save offset of name
	ADDL	ESI, EAX		;Point to next byte past name
14$:	RET
.PAGE
	.SBTTL	getvalue - Subroutine to get variable length value from the input packet

;Subroutine to get variable length value from the input packet
;	CALL	getvalue
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getvalue:
	DECL	cdb_rcpqab+qab_amount.B[EDI]
	JS	4$.S
	MOVZBL	EAX, [ESI]
	INCL	ESI
	BTZL	EAX, #7t
	JNC	2$.S
	DECL	cdb_rcpqab+qab_amount.B[EDI]
	JS	4$.S
	MOVB	AH, AL
	MOVB	AL, [ESI]
	INCL	ESI
	BTZL	EAX, #14t
	JNC	2$.S
	DECL	cdb_rcpqab+qab_amount.B[EDI]
	JS	4$.S
	SHLL	EAX, #8t
	MOVB	AL, [ESI]
	INCL	ESI
	BTZL	EAX, #21t
	JNC	2$.S
	DECL	cdb_rcpqab+qab_amount.B[EDI]
	JS	4$.S
	SHLL	EAX, #8t
	MOVB	AL, [ESI]
	INCL	ESI
	CLC
2$:	RET

;Here if don't have enough data in the packet

4$:	MOVL	EAX, #ER_NPERR
	STC
ret010:	RET

	.SBTTL	putvalue - Subroutine to store variable length value in output packet

;Subroutine to store variable length value in output packet
;	c{EAX} = Value to store
;	CALL	putvalue

putvalue:
	CMPL	EAX, #7Fh.B		;Will it fit in 1 byte?
	JA	6$.S			;No
	MOVB	[ESI], AL		;Yes
	INCL	ESI
	RET

;Here if value will not fit in 1 byte

6$:	TESTL	EAX, #0FFFFC000h	;Will it fit in 2 bytes?
	JNE	8$.S			;No
	ORB	AH, #80h		;Yes
	JMP	10$.S

;Here if value will not fit in 2 bytes

8$:	TESTL	EAX, #0FF700000h	;Will it fit in 3 bytes?
	JNE	12$.S			;No
	RORL	EAX, #16t		;Yes
	ORB	AL, #0C0h
	MOVB	[ESI], AL
	INCL	ESI
	RORL	EAX, #16t
10$:	XCHGB	AL, AH
	MOVW	[ESI], AX
	ADDL	ESI, #2t.B
	RET

;Here if value will not fit in 3 bytes

12$:	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	ORB	AL, #0E0h
	MOVL	[ESI], EAX
	ADDL	ESI, #4t.B
	RET
.PAGE
;Subroutine to get number of bytes required for a variable length value
;	c{EAX} = Value
;	c{ECX} = Current size value
;	CALL	getvalsize
;	c{ECX} = Updated size value

getvalsize:
	INCL	ECX			;Assume 1 byte will do
	CMPL	EAX, #7Fh		;Right?
	JBE	2$.S			;Yes
	INCL	ECX			;No
	TESTL	EAX, #0FFFFC000h	;Will 2 bytes do?
	JE	2$.S			;Yes
	INCL	ECX			;No
	TESTL	EAX, #0FF700000h	;Will 3 bytes do?
	JE	2$.S			;Yes
	INCL	ECX			;No
2$:	RET
.PAGE
	.SBTTL	setupparms - Subroutine to set up a parameter list

;Subroutine to set up a parameter list for an IO call given the received
;  XFP parameter list.
;	c{ESI} = Offset of the first parameter byte
;	CALL	setupparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setupparms:
	CLRL	EAX
	MOVL	cdb_diskqab+qab_parm+0.B[EDI], EAX ;Assume no parameters
	CMPL	cdb_rcpqab+qab_amount.B[EDI], EAX ;Have any parameters?
	JE	ret010.S		;No
	MOVL	EAX, ESI			  ;Yes - store offset of end of
	ADDL	EAX, cdb_rcpqab+qab_amount.B[EDI] ;  the parameter list
	MOVL	cdb_parmend.B[EDI], EAX
	LEAL	EBX, cdb_parm[EDI]	;Point to place for XOS parameters
	MOVL	cdb_diskqab+qab_parm+0.B[EDI], EBX
	LEAL	EAX, cdb_parm+PARMSIZE[EDI] ;Store pointer for strings
	MOVL	cdb_string.B[EDI], EAX
2$:	CLRL	EAX
	MOVB	AL, [ESI]		;Get parameter index
	INCL	ESI
	CMPB	AL, #PARMMAX
	JA	snperr
	MOVZWL	EDX, xfp2xos[EAX*2]	;Translate to the XOS parameter
	TESTL	EDX, EDX		;  value
	JE	snperr
	MOVB	CL, xfp2rep[EAX]	;Get the parameter representation
	MOVB	AL, [ESI]		;Get bits and first part of count
	INCL	ESI
	MOVB	cdb_parmbits.B[EDI], AL	;Save bits
	ANDB	cdb_parmbits.B[EDI], #0C0h
	ANDB	AL, #1Fh
	TESTB	AL, #10h		;Need the second count byte?
	JE	4$.S			;No
	ANDB	AL, #0Fh
	MOVB	AH, AL			;Yes
	MOVB	AL, [ESI]
	INCL	ESI
4$:	CMPL	EAX, #1024t		;Is the parameter too long?
	JBE	6$.S			;No
	MOVL	EAX, #1024t		;Yes - just use maximum length
6$:	MOVL	cdb_parmsize.B[EDI], EAX ;Save parmeter length
	CMPW	DX, #IOPAR_DIRHNDL	;Is this the directory handle parameter?
	JE	dirhndl			;Yes - go handle that
	ORB	CL, cdb_parmbits.B[EDI]	;Merge in the bits
	MOVB	cdb_parmbits.B[EDI], CL
	MOVB	[EBX], CL		;Store it
	INCL	EBX
	XORB	CL, #REP_STR		;Does it have a string value?
	TESTB	CL, #0Fh
	JE	26$.S			;Yes - go handle that
	MOVB	AL, cdb_parmsize.B[EDI] ;No - store size
	MOVB	[EBX], AL
	INCL	EBX
	MOVW	[EBX], DX		;Store parameter index
	ADDL	EBX, #2.B
	TESTB	cdb_parmbits.B[EDI], #PAR$SET ;Are we setting the value?
	JNE	10$.S			;Yes - this is harder!
	ADDL	EBX, cdb_parmsize.B[EDI] ;No - just skip the space for the value
	JMP	setupnx.S

;Here if need to store a value for the parameter

10$:	MOVZBL	EAX, cdb_parmbits.B[EDI]
	ANDB	AL, #0Fh
	MOVL	ECX, cdb_parmsize.B[EDI]
	BTL	valmask, EAX		;Should we invert the byte order?
	JNC	22$.S			;No
	ADDL	EBX, ECX		;Yes
	CMPL	EBX, cdb_string.B[EDI]	;Too big?
	JAE	23$.S			;Yes - fail
	PUSHL	EBX
20$:	MOVB	AL, [ESI]		;Get a value byte
	INCL	ESI
	DECL	EBX
	MOVB	[EBX], AL		;Store it
	LOOP	ECX, 20$
	POPL	EBX
	JMP	setupnx.S

;Here if to not need to invert byte order for the value

22$:	LEAL	EAX, [EBX+ECX]		;Make sure not too big
	CMPL	EAX, cdb_string.B[EDI]
23$:	JAE	snperr.S		;Too big - fail
24$:	MOVB	AL, [ESI]
	INCL	ESI
	MOVB	[EBX], AL
	INCL	EBX
	LOOP	ECX, 24$
	JMP	setupnx.S

;Here if have a string value

26$:	MOVB	[EBX], #0FFh		;Store parameter "size"
	INCL	EBX
	MOVW	[EBX], DX		;Store parameter index
	ADDL	EBX, #2.B
	MOVL	ECX, cdb_parmsize.B[EDI] ;Get string length
	SUBL	cdb_string.B[EDI], ECX
	MOVL	EDX, cdb_string.B[EDI]
	CMPL	EBX, EDX		;Too big?
	JAE	snperr.S		;Yes - fail
	MOVL	[EBX], EDX		;No - store address of string buffer
	MOVL	4.B[EBX], DS
	TESTB	cdb_parmbits.B[EDI], #PAR$SET ;Are we setting the value?
	JE	28$.S			;No
	SHLL	ECX, #16t		 ;Yes - store size in string length
	ORL	ECX, cdb_parmsize.B[EDI] ;  field too
28$:	MOVL	8.B[EBX], ECX	
	ADDL	EBX, #12t.B
	TESTB	cdb_parmbits.B[EDI], #PAR$SET ;Are we setting the value?
	JE	setupnx.S		;No - finished here
	MOVZWL	ECX, CX			;Yes - copy the value to the string
	PUSHL	EDI
	MOVL	EDI, EDX
	CLD
	RMOVSB	[EDI], [ESI]
	POPL	EDI
setupnx:CMPL	EBX, cdb_string.B[EDI]	;Too big?
	JAE	snperr.S		;Yes - fail
	CMPL	ESI, cdb_parmend.B[EDI]	;At end of the list?
	JB	2$			;No - continue
	MOVB	[EBX], #0		;Finished - put a 0 at the end	
	CLC
	RET

;Here for serious protocol error

snperr:	MOVL	EAX, #ER_NPERR
	STC
	RET
.PAGE
;Here for the XFPAR_DIRHNDL parameter

dirhndl:CMPL	EAX, #1			;Is the length one byte?
	JNE	4$.S			;No - fail
	MOVB	AL, [ESI]		;Yes - get the value byte
	INCL	ESI
	DECL	EAX
	JS	4$.S			;Cannot be 0
	CMPL	EAX, #NUMHNDL.B		;Valid value?
	JAE	4$.S			;No - fail
	MOVL	EAX, cdb_hndltbl.B[EDI+EAX*4] ;Yes - get XOS handle
	TESTL	EAX, EAX		;Is it open?
	JE	4$.S			;No - fail
	MOVL	[EBX], #{PAR$SET|REP_DECV}+{4<8}+{IOPAR_DIRHNDL<16t}
	MOVL	4.B[EBX], EAX
	ADDL	EBX, #8.B
	JMP	setupnx.S		;Continue

;Here if error

4$:	MOVL	EAX, #ER_PARMV
	STC
	RET
.PAGE
	.PSECT	_DATA_p

	.MACRO	XFPAR
  XX 0   , 0			;		= 0.   - Illegal
  XX HEXV, IOPAR_FILOPTN	;XFPAR_FILOPTN  = 1.   - File option bits
  XX STR , IOPAR_FILSPEC	;XFPAR_FILSPEC  = 2.   - File spec. string
  XX HEXV, IOPAR_DEVSTS		;XFPAR_DEVSTS   = 3.   - Device status
  XX HEXV, IOPAR_UNITNUM	;XFPAR_UNITNUM  = 4.   - Unit number
  XX HEXV, IOPAR_GLBID		;XFPAR_GLBID    = 5.   - Global device ID
  XX 0   , 0			;		= 6.   - Illegal
  XX HEXV, IOPAR_TIMEOUT	;XFPAR_TIMEOUT  = 7.   - Illegal
  XX HEXV, IOPAR_INPSTS		;XFPAR_INPSTS   = 8.   - Illegal
  XX HEXV, IOPAR_OUTSTS		;XFPAR_OUTSTS   = 9.   - Illegal
  XX 0   , 0			;		= 10.  - Illegal
  XX 0   , 0			;		= 11.  - Illegal
  XX HEXV, IOPAR_DIRHNDL	;XFPAR_DIRHNDL  = 12.  - Dir. handle for srch
  XX 0   , 0			;		= 13.  - Illegal
  XX HEXV, IOPAR_SRCATTR	;XFPAR_SRCATTR  = 14.  - File attr. for srch
  XX HEXV, IOPAR_FILATTR	;XFPAR_FILATTR  = 15.  - File attr.
  XX HEXV, IOPAR_DIROFS		;XFPAR_DIROFS   = 16.  - Dir. offset for srch
  XX HEXV, IOPAR_ABSPOS		;XFPAR_ABSPOS   = 17.  - Absolute pos. in file
  XX HEXV, IOPAR_RELPOS		;XFPAR_RELPOS   = 18.  - Relative pos. in file
  XX HEXV, IOPAR_EOFPOS		;XFPAR_EOFPOS   = 19.  - Position rel. to EOF
  XX 0   , 0			;		= 20.  - Illegal
  XX HEXV, IOPAR_LENGTH		;XFPAR_LENGTH   = 21.  - Written length of file
  XX HEXV, IOPAR_REQALLOC	;XFPAR_REQALLOC = 22.  - Request allocation
  XX HEXV, IOPAR_RQRALLOC	;XFPAR_RQRALLOC = 23.  - Require allocation
  XX HEXV, IOPAR_GRPSIZE	;XFPAR_GRPSIZE  = 24.  - Allocation group size
  XX HEXV, IOPAR_ADATE		;XFPAR_ADATE    = 25.  - Last access date/time
  XX HEXV, IOPAR_CDATE		;XFPAR_CDATE    = 26.  - Creation date/time
  XX HEXV, IOPAR_MDATE		;XFPAR_MDATE    = 27.  - Modify date/time
  XX HEXV, IOPAR_PROT		;XFPAR_PROT     = 28.  - File protection
  XX STR , IOPAR_OWNER		;XFPAR_OWNNAME  = 29.  - Owner
  XX 0   , 0			;		= 30.  - Illegal
  XX HEXV, IOPAR_SETLOCK	;XFPAR_SETLOCK  = 31.  - Set file lock
  XX HEXV, IOPAR_CLRLOCK	;XFPAR_CLRLOCK  = 32.  - Clear file lock
  XX HEXV, IOPAR_SHRPARMS 	;XFPAR_SHRPARMS = 33.  - File sharing parameters
  XX 0   , 0		 	;		= 34.  - Illegal
  XX 0   , 0		 	;		= 35.  - Illegal
  XX 0   , 0		 	;		= 36.  - Illegal
  XX 0   , 0		 	;		= 37.  - Illegal
  XX 0   , 0		 	;		= 38.  - Illegal
  XX 0   , 0		 	;		= 39.  - Illegal
  XX 0   , 0		 	;		= 40.  - Illegal
  XX 0   , 0		 	;		= 41.  - Illegal
  XX 0   , 0		 	;		= 42.  - Illegal
  XX 0   , 0		 	;		= 43.  - Illegal
  XX 0   , 0		 	;		= 44.  - Illegal
  XX 0   , 0		 	;		= 45.  - Illegal
  XX 0   , 0		 	;		= 46.  - Illegal
  XX 0   , 0		 	;		= 47.  - Illegal
  XX 0   , 0		 	;		= 48.  - Illegal
  XX 0   , 0		 	;		= 49.  - Illegal
  XX 0   , 0		 	;		= 50.  - Illegal
  XX 0   , 0		 	;		= 51.  - Illegal
  XX 0   , 0		 	;		= 52.  - Illegal
  XX 0   , 0		 	;		= 53.  - Illegal
  XX 0   , 0		 	;		= 54.  - Illegal
  XX 0   , 0		 	;		= 55.  - Illegal
  XX 0   , 0		 	;		= 56.  - Illegal
  XX 0   , 0		 	;		= 57.  - Illegal
  XX 0   , 0		 	;		= 58.  - Illegal
  XX 0   , 0		 	;		= 59.  - Illegal
  XX 0   , 0		 	;		= 60.  - Illegal
  XX 0   , 0		 	;		= 61.  - Illegal
  XX 0   , 0		 	;		= 62.  - Illegal
  XX 0   , 0		 	;		= 63.  - Illegal
  XX 0   , 0		 	;		= 64.  - Illegal
  XX 0   , 0		 	;		= 65.  - Illegal
  XX 0   , 0		 	;		= 66.  - Illegal
  XX 0   , 0		 	;		= 67.  - Illegal
  XX 0   , 0		 	;		= 68.  - Illegal
  XX 0   , 0		 	;		= 69.  - Illegal
  XX 0   , 0		 	;		= 70.  - Illegal
  XX 0   , 0		 	;		= 71.  - Illegal
  XX 0   , 0		 	;		= 72.  - Illegal
  XX 0   , 0		 	;		= 73.  - Illegal
  XX 0   , 0		 	;		= 74.  - Illegal
  XX 0   , 0		 	;		= 75.  - Illegal
  XX 0   , 0		 	;		= 76.  - Illegal
  XX 0   , 0		 	;		= 77.  - Illegal
  XX 0   , 0		 	;		= 78.  - Illegal
  XX 0   , 0		 	;		= 79.  - Illegal
  XX 0   , 0		 	;		= 80.  - Illegal
  XX 0   , 0		 	;		= 81.  - Illegal
  XX 0   , 0		 	;		= 82.  - Illegal
  XX 0   , 0		 	;		= 83.  - Illegal
  XX 0   , 0		 	;		= 84.  - Illegal
  XX 0   , 0		 	;		= 85.  - Illegal
  XX 0   , 0		 	;		= 86.  - Illegal
  XX 0   , 0		 	;		= 87.  - Illegal
  XX 0   , 0		 	;		= 88.  - Illegal
  XX 0   , 0		 	;		= 89.  - Illegal
  XX 0   , 0		 	;		= 90.  - Illegal
  XX 0   , 0		 	;		= 91.  - Illegal
  XX 0   , 0		 	;		= 92.  - Illegal
  XX 0   , 0		 	;		= 93.  - Illegal
  XX 0   , 0		 	;		= 94.  - Illegal
  XX 0   , 0		 	;		= 95.  - Illegal
  XX HEXV, IOPAR_DSKFSTYPE	;XFPAR_FSTYPE   = 96.  - File system type
  XX HEXV, IOPAR_DSKSECTSIZE	;XFPAR_SECTSIZE = 97.  - Sector size
  XX HEXV, IOPAR_DSKCLSSIZE 	;XFPAR_CLSSIZE  = 98.  - Cluster size
  XX HEXV, IOPAR_DSKTTLSPACE	;XFPAR_TTLSPACE = 99.  - Total space
  XX HEXV, IOPAR_DSKAVLSPACE	;XFPAR_AVLSPACE = 100. - Available space
  XX HEXV, IOPAR_DSKNUMHEAD 	;XFPAR_NUMHEAD  = 101. - Number of heads
  XX HEXV, IOPAR_DSKNUMSECT 	;XFPAR_NUMSECT  = 102. - Number of sectors
  XX HEXV, IOPAR_DSKNUMCYLN 	;XFPAR_NUMCYLN  = 103. - Number of cylinders
	.ENDM

	.MACRO	XX type, parm
	.WORD	parm
	.ENDM

	.MOD	4
xfp2xos:XFPAR
PARMMAX=!$-xfp2xos-1

	.MACRO	XX type, parm
.IF NE parm
	.BYTE	REP_'type	
.IFF
	.BYTE	0
.ENDC
	.ENDM

xfp2rep:XFPAR

	.MOD	4
xos2xfp:
	.LONG	xos2xfpgen	;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	xos2xfpfil	;IOPAR_FILxxx = 01xx - File system IO parameters
	.LONG	0		;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	xos2xfpdsk	;IOPAR_DSKxxx = 03xx - Disk IO parameters
XOSMAX=!{$-xos2xfp}/4


	.BYTE	XOSGENMAX
xos2xfpgen:
	.BYTE	0		;		   = 0000h
	.BYTE	XFPAR_FILOPTN	;IOPAR_FILOPTN     = 0001h
	.BYTE	XFPAR_FILSPEC	;IOPAR_FILSPEC     = 0002h
	.BYTE	XFPAR_DEVSTS	;IOPAR_DEVSTS      = 0003h
	.BYTE	XFPAR_UNITNUM	;IOPAR_UNITNUM     = 0004h
	.BYTE	XFPAR_GLBID	;IOPAR_GLBID       = 0005h
	.BYTE	0		;IOPAR_DELAY       = 0006h
	.BYTE	0		;IOPAR_TIMEOUT     = 0007h
	.BYTE	0		;IOPAR_INPSTS      = 0008h
	.BYTE	0		;IOPAR_OUTSTS      = 0009h
	.BYTE	0		;IOPAR_INPQLMT     = 000Ah
	.BYTE	0		;IOPAR_OUTQLMT     = 000Bh
	.BYTE	0		;IOPAR_SIGVECT1    = 000Ch
	.BYTE	0		;IOPAR_SIGVECT2    = 000Dh
	.BYTE	0		;IOPAR_SIGDATA     = 000Eh
	.BYTE	0		;IOPAR_NUMOPEN     = 000Fh
	.BYTE	0		;IOPAR_BUFRLMT	   = 0010h
XOSGENMAX=!{$-xos2xfpgen}

	.BYTE	XOSFILMAX
xos2xfpfil:
	.BYTE	0		;		   = 0100h
	.BYTE	XFPAR_DIRHNDL	;IOPAR_DIRHNDL     = 0101h
	.BYTE	XFPAR_SRCATTR	;IOPAR_SRCATTR     = 0102h
	.BYTE	XFPAR_FILATTR	;IOPAR_FILATTR     = 0103h
	.BYTE	XFPAR_DIROFS	;IOPAR_DIROFS      = 0104h
	.BYTE	XFPAR_ABSPOS	;IOPAR_ABSPOS      = 0105h
	.BYTE	XFPAR_RELPOS	;IOPAR_RELPOS      = 0106h
	.BYTE	XFPAR_EOFPOS	;IOPAR_EOFPOS      = 0107h
	.BYTE	0		;		   = 0108h
	.BYTE	XFPAR_LENGTH	;IOPAR_LENGTH      = 0109h
	.BYTE	XFPAR_REQALLOC	;IOPAR_REQALLOC    = 010Ah
	.BYTE	XFPAR_RQRALLOC	;IOPAR_RQRALLOC    = 010Bh
	.BYTE	XFPAR_GRPSIZE	;IOPAR_GRPSIZE     = 010Ch
	.BYTE	XFPAR_ADATE	;IOPAR_ADATE       = 010Dh
	.BYTE	XFPAR_CDATE	;IOPAR_CDATE       = 010Eh
	.BYTE	XFPAR_MDATE	;IOPAR_MDATE       = 010Fh
	.BYTE	XFPAR_PROT	;IOPAR_PROT        = 0110h
	.BYTE	XFPAR_OWNER	;IOPAR_OWNNAME     = 0111h
	.BYTE	0		;		   = 0112h
	.BYTE	XFPAR_SETLOCK	;IOPAR_SETLOCK     = 0113h
	.BYTE	XFPAR_CLRLOCK	;IOPAR_CLRLOCK     = 0114h
	.BYTE	0		;IOPAR_CLSTIME     = 0115h
	.BYTE	0		;IOPAR_CLSNAME     = 0116h
	.BYTE	0		;IOPAR_CLSMSG      = 0117h
	.BYTE	XFPAR_SHRPARMS	;IOPAR_SHRPARMS    = 0118h
XOSFILMAX=!{$-xos2xfpfil}

	.BYTE	XOSDSKMAX
xos2xfpdsk:
	.BYTE	0		;		   = 0300h
	.BYTE	XFPAR_FSTYPE	;IOPAR_DSKFSTYPE   = 0301h
	.BYTE	XFPAR_SECTSIZE	;IOPAR_DSKSECTSIZE = 0302h
	.BYTE	XFPAR_CLSSIZE	;IOPAR_DSKCLSSIZE  = 0303h
	.BYTE	XFPAR_TTLSPACE	;IOPAR_DSKTTLSPACE = 0304h
	.BYTE	XFPAR_AVLSPACE	;IOPAR_DSKAVLSPACE = 0305h
	.BYTE	XFPAR_NUMHEAD	;IOPAR_DSKNUMHEAD  = 0306h
	.BYTE	XFPAR_NUMSECT	;IOPAR_DSKNUMSECT  = 0307h
	.BYTE	XFPAR_NUMCYLN	;IOPAR_DSKNUMCYLN  = 0308h
XOSDSKMAX=!{$-xos2xfpdsk}

BITS=!{1<REP_DECV}+{1<REP_HEXV}+{1<REP_OCTV}+{1<REP_BINV}+{1<REP_VERN}
BITS=!BITS+{1<REP_TIME}+{1<REP_DATE}+{1<REP_DT}

	.MOD	4
valmask:.LONG	BITS

	.PSECT	_TEXT_p
.PAGE
	.SBTTL	outputdone - Software interrupt routine for RCP output complete

;Software interrupt routine for RCP output complete - all this routine does
;  is queue another RCP input

outputdone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t.B[ESP]		;Get offset of the CDB
	CMPL	cdb_rcpqab+qab_error.B[EDI], #0.B ;Error on output?
	JS	rcperr			;Yes
	CMPL	cdb_reqtotal.B[EDI], #0.B ;No - need to finish an input request?
	JNE	datreq2			;Yes
outputdon2:
	CALL	qinput
	POPAL				;Restore registers
	CALLF	svcSchDismiss#		;And dismiss
.PAGE
	.SBTTL	diskdone - Software interrupt routine for disk IO complete

;Subroutine software interrupt routine for disk IO complete

diskdone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t.B[ESP]		;Get offset of the CDB
	SUBL	EDI, #cdb_diskqab.B
	JMPIL	cdb_diskdsp.B[EDI]	;Dispatch on the current state
.PAGE
	.SBTTL	setresp - Subroutine to set up the response message

;Subroutine to set up the response message
;	CALL	setresp
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setresp:LEAL	ESI, cdb_buffer+2[EDI]
	MOVB	-2t.B[ESI], #XFPF_RESPONSE ;Assume OK
	MOVL	EAX, cdb_diskqab+qab_amount.B[EDI]
	MOVB	DL, cdb_curhndl.B[EDI]	;Get XFP channel number
	INCL	EDX
	BTZL	EAX, #31t		;Continued response?
	JC	2$.S			;Yes
	ORB	DL, #10h		;No - set final bit
2$:	MOVB	-1.B[ESI], DL
	CMPL	cdb_diskqab+qab_error.B[EDI], #0.B ;Did this work?
	JGE	4$.S			;Yes
	ORB	-1.B[ESI], #80h		;No
	MOVL	ECX, cdb_diskqab+qab_error.B[EDI] ;Get error code
	XCHGB	CL, CH			;Fix up the byte order
	RORL	ECX, #16t
	XCHGB	CL, CH
	MOVL	[ESI], ECX		;Store it in the message
	ADDL	ESI, #4.B
4$:	CALL	putvalue		;Store item count
	CLRL	EAX
	MOVL	cdb_rcpqab+qab_parm+0.B[EDI], EAX
	CMPL	cdb_diskqab+qab_parm+0.B[EDI], #0.B ;Have any parameters?
	JE	6$.S			;No - go on
	CALL	storeparms		;Yes - store parameters in the response
	JC	ret020.S		;If error
6$:	LEAL	EAX, cdb_buffer[EDI] ;Calculate length of the response
	MOVL	cdb_rcpqab+qab_buffer1+0.B[EDI], EAX
	SUBL	ESI, EAX
	MOVL	cdb_rcpqab+qab_count.B[EDI], ESI ;Store it in the QAB
ret020:	RET
.PAGE
	.SBTTL	storeparms - Subroutine to store parameters into the reply

;Subroutine to store parameters into the reply message
;	c{ESI} = Pointer to reply message
;	CALL	storeparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

storeparms:
	MOVL	EBX, cdb_diskqab+qab_parm+0.B[EDI]
	MOVL	cdb_rcpqab+qab_parm+0.B[EDI], EAX
4$:	MOVB	AL, [EBX]		;Get bits and representation
	TESTB	AL, AL			;Finished?
	JE	ret020.S		;Yes
	MOVZBL	EDX, 3.B[EBX]		;No - get parameter page number
	CMPL	EDX, #XOSMAX
	JAE	65$.S
	MOVL	EDX, xos2xfp[EDX*4]
	MOVZBL	ECX, 2.B[EBX]
	CMPB	CL, -1.B[EDX]
	JAE	65$.S
	MOVB	DL, [EDX+ECX]		;Get XFP value
	MOVB	[ESI], DL		;Store index in response
	MOVB	AH, AL
	ANDB	AH, #0Fh
	CMPB	AH, #REP_STR		;Is it a string?
	JE	20$.S			;Yes
	MOVZBL	ECX, 1.B[EBX]		;No - get length
	TESTB	AL, #PAR$GET		;Getting the value?
	JNE	6$.S			;Yes - always return it
	TESTB	AL, #PAR$ERROR		;No - error indicated?
	JE	7$.S			;No - skip this parameter
6$:	CALL	strlength		;Store it
	TESTB	AL, #PAR$ERROR		;Error indicated?
	JE	8$.S			;No
	ADDL	EBX, ECX		;Yes - skip the value
	JMP	4$.S			;Continue

65$:	MOVL	EAX, #ER_NPERR
	STC
	RET

;Here if want to skip this parameter

7$:	LEAL	EBX, 4.B[EBX+ECX]
	JMP	4$.S

;Here to store parameter

8$:	JREGZ	ECX, 4$
	MOVZBL	EAX, AH
	BTL	valmask, EAX		;Should we invert the byte order?
	JNC	12$.S			;No
	ADDL	ESI, ECX		;Yes

;CHECK LIMITS HERE

	PUSHL	ESI
10$:	MOVB	AL, [EBX]		;Get a value byte
	INCL	EBX
	DECL	ESI
	MOVB	[ESI], AL		;Store it
	LOOP	ECX, 10$
	POPL	ESI
	JMP	4$.S

;Here if to not need to invert byte order for the value

12$:

;CHECK LIMITS HERE

14$:	MOVB	AL, [EBX]
	INCL	EBX
	MOVB	[ESI], AL
	INCL	ESI
	LOOP	ECX, 14$
	JMP	4$.S

;Here if have string value

20$:	TESTB	AL, #PAR$GET		;Getting the value?
	JNE	22$.S			;Yes - always return it
	TESTB	AL, #PAR$ERROR		;No - error indicated?
	JE	26$.S			;No - skip this parameter
22$:	MOVZWL	ECX, 14t.B[EBX]		;Get length of the string returned
	CALL	strlength		;Store it
	TESTB	AL, #PAR$ERROR		;Error indicated?
	JNE	24$.S			;Yes - skip the value
	PUSHL	EDI
	MOVL	EDI, ESI
	MOVL	ESI, [EBX]		;Get offset of the string buffer
	CLD
	RMOVSB	[EDI], [ESI]		;Copy string to response
	MOVL	ESI, EDI
	POPL	EDI
24$:	ADDL	EBX, #12t.B		;Bump pointer
	JMP	4$			;Continue

26$:	ADDL	EBX, #16t.B
	JMP	4$
.PAGE
;	c(AL)  = Representation and bits
;	c{EBX} = Offset of parameter header byte
;	c{ECX} = Length of value
;	c{ESI} = Pointer to index value in response
;	CALL	strlength
;	c{EBX} = Updated pointer
;	c{ECX} = Amount to store
;	c{ESI} = Updated pointer

strlength:
	ANDB	AL, #0E0h
	TESTB	AL, #PAR$ERROR		;Error indicated?
	JNE	10$.S			;Yes
	CMPL	ECX, #0Fh.B
	JA	6$.S
	ORB	AL, CL
	MOVB	1.B[ESI], AL
	JMP	8$.S

6$:	ORB	AL, CH
	ORB	AL, #10h
	MOVB	1.B[ESI], AL
	MOVB	2.B[ESI], CL
	INCL	ESI
8$:	ADDL	ESI, #2.B
	ADDL	EBX, #4.B
	RET

;Here if error indicated

10$:	MOVB	1.B[ESI], AL
	JMP	8$.S
.PAGE
;Subroutine to log a message
;	c{EBX} = Offset of initial string
;	c{ECX} = Number of bytes
;	c{EDX} = Offset of function table
;	CALL	logmsg

$$$=!0
FRM log_size  , 4t
FRM log_table , 4t
FRM log_count , 4t
FRM log_begin , 4t
FRM log_buffer, 200t
log_SIZE=!$$$

logmsg:	PUSHL	ESI
	ENTER	log_SIZE
	MOVL	log_table.B[EBP], EDX
	LEAL	ESI, log_buffer[EBP]
	MOVL	log_size.B[EBP], ECX
	PUSHL	ECX
	PUSHL	cdb_number.B[EDI]
	PUSHL	EBX
	PUSHL	#log1fmt
	PUSHL	ESI
	CALL	sprintf#
	ADDL	ESP, #20t.B
	ADDL	ESI, EAX
	MOVL	EBX, log_table.B[EBP]	;Restore offset of function table
	MOVL	EAX, cdb_rcpqab+qab_buffer1.B[EDI]
	MOVB	AL, [EAX]		;Get function value
	ANDL	EAX, #0Fh.B
	MOVL	EDX, [EBX+EAX*8]
	MOVL	[ESI], EDX
	MOVL	EAX, 4.B[EBX+EAX*8]
	MOVL	4.B[ESI], EAX
	ADDL	ESI, #8t.B
	JMP	4$.S

;Here if function not in the table

2$:	PUSHL	EAX
	PUSHL	#log2fmt
	PUSHL	ESI
	CALL	sprintf#
	ADDL	ESP, #12t.B
	ADDL	ESI, EAX
4$:

;;; CODE HERE TO DISPLAY MESSAGE FLAGS

	MOVW	[ESI], #LF
	PUSHL	srvDebugStream#
	LEAL	EAX, log_buffer[EBP]
	PUSHL	EAX
	CALL	fputs#
	ADDL	ESP, #8t.B
	CMPL	log_size.B[EBP], #0.B	;Have 0 length message?
	JE	12$.S			;Yes - finished
	CMPB	srvDebugLevel#, #2	;Want short form?
	JA	6$.S			;No
	CMPL	log_size.B[EBP], #16t.B	;Yes - is message too long?
	JBE	6$.S			;No
	MOVL	log_size.B[EBP], #16t	;Yes - only display 16 bytes
6$:	MOVL	EBX, cdb_rcpqab+qab_buffer1.B[EDI] ;Point to the buffer
8$:	MOVL	log_begin.B[EBP], EBX
	PUSHL	EBX
	LEAL	ESI, log_buffer[EBP]
	PUSHL	#strnl
	PUSHL	ESI
	CALL	strmov#
	ADDL	ESP, #8t.B
	MOVL	ESI, EAX
	POPL	EBX
	MOVB	log_count.B[EBP], #0
10$:	MOVZBL	EAX, [EBX]
	INCL	EBX
	PUSHL	EBX
	PUSHL	EAX
	PUSHL	#log3fmt
	PUSHL	ESI
	CALL	sprintf#
	ADDL	ESP, #12t.B
	ADDL	ESI, EAX
	POPL	EBX
	INCL	log_count.B[EBP]	;Count the item
	DECL	log_size.B[EBP]		;More to display?
	JE	12$.S			;No
	CMPB	log_count.B[EBP], #16t	;Yes - need new line?
	JB	10$.S			;No
12$:	LEAL	ECX, log_buffer+62t[EBP] ;Fill current line with spaces to the
14$:	CMPL	ESI, ECX		 ;  position for the text part
	JAE	16$.S
	MOVB	[ESI], #' '
	INCL	ESI
	JMP	14$.S

16$:	MOVL	EBX, log_begin.B[EBP]
	CLRL	ECX
18$:	MOVB	AL, [EBX]
	INCL	EBX
	CMPB	AL, #' '
	JB	20$.S
	CMPB	AL, #0FFh
	JNE	22$.S
20$:	MOVB	AL, #'.'
22$:	MOVB	[ESI], AL
	INCL	ESI
	INCL	ECX
	CMPB	CL, log_count.B[EBP]
	JB	18$.S
	MOVW	[ESI], #LF
	PUSHL	EBX
	PUSHL	srvDebugStream#
	LEAL	EAX, log_buffer[EBP]
	PUSHL	EAX
	CALL	fputs#
	ADDL	ESP, #8t.B
	POPL	EBX
	CMPL	log_size.B[EBP], #0.B
	JNE	8$
	LEAVE
	POPL	ESI
	RET

log1fmt:.ASCIZ	"%s%2d%6d "
log2fmt:.ASCIZ	"%7d"
log3fmt:.ASCIZ	" %02.2X"
.PAGE
	.SBTTL	Data

	.PSECT	_DATA_p

prgname:: .ASCIZ "XFPSRV"
srvname:: .ASCIZ "XFPServer"

rcperrmsg:.ASCIZ "Cannot open RCP device"
opnemsg2: .ASCIZ "Error opening pending RCP device"
opnemsg:  .ASCIZ "Error queueing open"
qinmsg:	  .ASCIZ "Error queueing RCP input"
nomcdbmsg:.ASCIZ "Cannot allocate memory for CDB"
nocdbsmsg:.ASCIZ "Too many files open"

confmt:	.ASCIZ	"CON:%2d %s"{LF}
rerfmt:	.ASCIZ	"ERR:%2d %X %d"{LF}
clrfmt:	.ASCIZ	"CLR:%2d %X %d"{LF}
cbgfmt:	.ASCIZ	"CBG:%2d %X %d"{LF}
cdnfmt:	.ASCIZ	"CDN:%2d %X %d"{LF}


strrcpi: .ASCIZ	"INP:"
strrcpo: .ASCIZ	"OUT:"




strnl:	 .ASCIZ "         "

	 .MOD	4
version::.LONG	VERSION
editnum::.LONG	EDITNUM
numcon:  .LONG	0
numopen: .LONG 	0
rcpport: .LONG	0
instance:.LONG	0
cmdpntr: .LONG	0, 0

instx:	.LONG	0		;Instance existance bit table

	.MOD	4
tablei:	.ASCII	"0       "	; 0
	.ASCII	"OPEN    "	; 1 - Open file
	.ASCII	"PARM    "	; 2 - Parameter function
	.ASCII	"CLOSE   "	; 3 - Close file
	.ASCII	"COMMIT  "	; 4 - Commit data
	.ASCII	"DELETE  "	; 5 - Delete file
	.ASCII	"RENAME  "	; 6 - Rename file
	.ASCII	"7       "	; 7
	.ASCII	"DATA    "	; 8 - Data
	.ASCII	"DATAREQ "	; 9 - Data request
	.ASCII	"10      "	;10
	.ASCII	"11      "	;11
	.ASCII	"12      "	;12
	.ASCII	"13      "	;13
	.ASCII 	"14      "	;14
	.ASCII	"15      "	;15


	.MOD	4
tableo:	.ASCII	"0       "	; 0
	.ASCII	"RESPONSE"	; 1 - Normal response
	.ASCII	"ERROR   "	; 2 - Error response
	.ASCII	"3       "	; 3
	.ASCII	"4       "	; 4
	.ASCII	"5       "	; 5
	.ASCII	"6       "	; 6
	.ASCII	"7       "	; 7
	.ASCII	"DATA    "	; 8 - Data
	.ASCII	"DATARESP"	; 9 - Data response
	.ASCII	"10      "	;10
	.ASCII	"11      "	;11
	.ASCII	"12      "	;12
	.ASCII	"13      "	;13
	.ASCII	"14      "	;14
	.ASCII	"15      "	;15

	  .MOD   4
notoparm: .BYTE  PAR$SET|REP_DECV, 4 ;Parameters for IO without timeout
	  .WORD  IOPAR_TIMEOUT
	  .LONG  -1
	  .BYTE  0

cnomsg:   .ASCIZ "Cannot open RCP device"

rcpname:  .BLKB  12t
rcpspec:  .BLKB  16t

notrcpmsg:.ASCIZ "Device is not an IR (RCP) class device"

	  .MOD   4


phyname:  .BLKB  32t

	  .MOD   4
openparms:.BYTE	 PAR$GET|REP_TEXT, 8 ;Parameters for initial check of RCP
	  .WORD	 IOPAR_CLASS	     ;   device
devclass: .BLKB  8t
	  .BYTE  PAR$SET|REP_HEXV, 4
	  .WORD	 IOPAR_FILOPTN
	  .LONG  FO$XOSNAME
	  .BYTE  PAR$GET|REP_STR, 0
	  .WORD  IOPAR_FILSPEC
	  .LONG  phyname
	  .LONG  !phyname
	  .WORD  12t
phylength:.WORD  0
	  .BYTE  0
