	.SBTTL	Parameter file XOSX.PAR

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

;-------------------------------------------------------------------------------
;
;  XOSX.PAR - Kernel-mode include file for general parameters
;
;  Edit history:
;  -------------
;  18Apr95 (fpj) - Added edit history block.
;
;-------------------------------------------------------------------------------

.IF NDF DEFINES
	.NLIST
	.INCLUD	XOSINC:\XMAC\DEFINES.PAR
	.LIST
.ENDC
	.PARM

$$BUGRING =!2		;Set to size of debug data ring in KB, 0 disables
			;  debug data logging
$$MEMDEBUG=!0		;Set non-zero to include memory allocation debug code

XSTKSZ      =!1024t	;Common exec mode stack size
DIRLVL      =!7t	;Maximum number of nested directories
MAXPROCS    =!1023t	;Absolute maximum number of processes plus shared
			;  sections in system
MAXSEGS     =!4096t	;Absolute maximum number of local segments per process
MAXCONVS    =!18t	;Absolute maximum number of virtual screens per console
MAXHNDLS    =!4064t	;Absolute maximum number of device handles per process
MAXXFFS     =!15360t	;Absolute maximum number of extended fork frames in
			;  system
MSECTMAX    =!0FFFF000h	;Maximum offset in an msect
MAXXFER     =!2097152t	;Maximum amount to transfer in single IO operation
pda_TSIZE   =!40000h	;Total space availabe for each PDA
pda_SHIFT   =!18t	;2**pda_SHIFT = pda_tSIZE
qe_SIZE     =!64t	;Length of a queue element
TICKSPERSEC =!50t	;Number of clock ticks per second
TICKSPERDAY =!4320109t	;Number of clock ticks per day
DOSTSPERDAY =!1573040t	;Number of DOS ticks per day
MSPERTICK   =!20t	;Milleseconds per tick
FDPERTICK   =!994t	;Fractional days per clock tick
PDA_MAGIC   =!22558811h	;Magic number used to identify PDAs
SDA_MAGIC   =!55221144h	;Magic number used to identify SDAs
XFF_MAGIC   =!5254F0F3h	;Magic number used to identify extended fork stack
			;  frames
XMF_MAGIC   =!0A55A5AA5h;Magic number used to identify free exec memory buffers
WKB_MAGIC   =!2CC7AB4Dh	;Magic number used to identify wake blocks
CB_SYSMAGIC =!5A5322C3h	;Magic number used to identify disk system cache blocks
CB_DATAMAGIC=!5A5322CCh	;Magic number used to identify disk data cache blocks
XMBMAX      =!6t		;Maximum size index for exec memory buffers
DATASEGBASE =!1000h	;Base offset for exec data segment

;Define bits for sysdescp

SYSD$INITIAL =!40000000h	;Run initial SHELL on TRM0S1
  SYSD%INITIAL =!30t
SYSD$LOGIN   =!20000000h	;System requires user login
  SYSD%LOGIN   =!29t
SYSD$KBRESET =!10000000h	;Can reset from console keyboard (ctl-alt-DEL)
  SYSD%KBRESET =!28t
SYSD$FPU     =!08000000h	;FPU is enabled
  SYSD%COPROC  =!27t
SYSD$FASTBOOT=!04000000h	;Should do fast boot
  SYSD%FASTBOOT=!26t

;Define values for proctype (processor type)

PROC_386SX=!1t
PROC_386DX=!2t
PROC_486SX=!3t
PROC_486DX=!4t

;Define values for fputype (FPU type)

FPU_NONE=!0t
FPU_387 =!1t
FPU_487 =!2t

;Define values stored in knlForkLvl

FORK_MAIN =!0t			;Main program level
FORK_MFORK=!1t			;Main program level raised to fork level
FORK_SFORK=!2t			;Scheduler context raised to fork level
FORK_DFORK=!3t			;Device fork level
FORK_XFF  =!4t			;Extended fork context

;Define descriptor types

DT_LDT    =!82h			;Local descritor table selector
DT_TASK   =!85h			;Task gate
DT_ITSS   =!89h			;Idle task state selector
DT_BTSS   =!8Bh			;Busy task state selector
DT_CALL   =!8Ch			;Call gate
DT_INT    =!8Eh			;Interrupt gate
DT_TRAP   =!8Fh			;Trap gate
DT_NXOCODE=!99h			;Normal execute only code segment
DT_NXRCODE=!9Bh			;Normal execute/read code segment
DT_CXOCODE=!9Dh			;Conforming execute only code segment
DT_CXRCODE=!9Fh			;Conforming execute/read code segment
DT_RODATA =!91h			;Read only data segment
DT_RWDATA =!93h			;Read/write data segment
DT_STACK  =!97h			;Stack segment

;Define descriptor class values

DC_BG=!00h			;Segment limit has byte ganularity
DC_PG=!80h			;Segment limit has page ganularity
DC_16=!00h			;16 bit segment
DC_32=!40h			;32 bit segment

;Define privilege levels for descriptors

PL_0   =!00h
PL_1   =!20h
PL_2   =!40h
PL_3   =!60h

;Define global segment selectors (selectors marked with * are user level)

GS_IDT      =!0008h		;  IDT data segment (only used by debugger)
GS_GDT      =!0010h		;  GDT data segment (only used by debugger)
GS_DATA     =!0018h		;  XOS data segment
GS_CODE     =!0020h		;  XOS code segment
GS_TEMP     =!0028h
GS_CODEALS  =!0030h		;  XOS code segment allias as data segment
				;    (used for loading code for LKEs)
GS_USERLA   =!0038h		;  Maps entire user linear address space
GS_BIOSDATA =!0040h		;* Maps DOS environment BIOS data (Some DPMI
				;    programs count on this!)
GS_DISPLAY  =!0048h		;  Display screen buffer
GS_REAL16   =!0050h		;* Segment which maps the real mode segment as
				;    a 16-bit data segment
GS_REAL32   =!0058h		;* Segment which maps the real mode segment as
				;    a 32-bit data segment
GS_16CODE   =!0060h		;  Allocatable space for 16-bit protected mode
				;    code
GS_BIOSCODE =!0068h		;  BIOS code at C000:0000 as a 16-bit protected
				;    mode segment
GS_SCHPDA   =!0070h		;  Scheduler task PDA selector
GS_SCHTSS   =!0078h		;  Scheduler task TSS selector
GS_ERRSTK   =!0080h		;  Stack and double exception error stack
				;    selector
GS_STKERRTSS=!0088h		;  Stack error handler task TSS selector
GS_DBLERRTSS=!0090h		;  Double exception error handler task TSS
				;    selector
GS_USERCODE =!00A0h		;* Global user code segment
GS_USERJUNK =!00A8h		;* Global user scratch data segment
GS_VUSERCODE=!00B0h		;* Global virtual-86 mode user segment
GS_VDOSDATA =!00B8h		;  Segment which maps the DOS data area
GS_EXPORT   =!00C0h		;  Exported symbol table

GS_GECKOCODE=!00E0h		;  GECKO code segment
GS_GECKODATA=!00E8h		;  GECKO data and symbol table segment
GS_GECKOTEMP=!00F0h
				;  Selectors 0100 through 04F8 are used for
				;    call gates and are defined in XOSSVCDF.PAR
GS_FSVC     =!0100h		;* First selector used as call gate for SVCs
GS_LSVC     =!0600h
GS_AVAIL    =!0600h		;  First selector available for allocation

schedule    =GS_SCHTSS:0	;Call gate address for calling the scheuler

;Define offsets in the segment descriptor tables (pdaLdt)

$$$=!0
BLK st_limit , 2t		;Limit value (low order 16 bits)
BLK st_base  , 3t		;Base address (low order 24 bits)
BLK st_atrb  , 1t		;Attribute byte
BLK st_limith, 0		;(low 4 bits) Limit value (high order 4 bits)
BLK st_class , 1t		;(high 4 bits) Class bits
BLK st_baseh , 1t		;Base address (high order 8 bits)

;Define offsets in the linear address data blocks

$$$=!0
BLK lad_next  , 2t		;Index of next LAD
BLK lad_prev  , 2t		;Index of previous LAD
BLK lad_type  , 1t		;Area type
BLK lad_status, 1t		;Status bits
BLK lad_task  , 2t		;DOS task ID (0 if not associated with a DOS
				;  task)
BLK lad_base  , 4t		;Base address of this area
BLK lad_size  , 4t		;Size of this area (bytes)
lad_SIZE=!$$$

;Define fixed LAD handles

LAH_BOTTOM=!1t			;Bottom of linear address space
LAH_MIDDLE=!2t			;Middle of linear address space (reserved area)
LAH_TOP   =!3t			;Top of available linear address space
LAH_FIRST =!4t			;First available handle

;Define values for lad_type

LAT_RES =!0t			;Reserved or unallocated area
LAT_XOS =!1t			;XOS segment
LAT_RM  =!2t			;Real mode segment
LAT_DPMI=!3t			;DMPI linear address allocation
LAT_EMS =!4t			;EMS segment

;Define offsets in the segment data tables (pointed to by pdaSegTbl) - Note
;  that the first item is overloaded.  A value of 0 indicates an unlinked
;  segment with no msects allocated.  A non-0 value less than 10000h specifies
;  the PDA for the segment linked to this segment (selector is in sd_lnks),
;  which implies that the segment is linked to a dynamic exec segment (which
;  means that no MDBs can be associated with the segment).  A value greater
;  than 10000h is the offset of the first MDB for the segment.

$$$=!0
BLK sd_lnkpda, 0t		;Selector of PDA for linked segment selector
BLK sd_fmdb  , 3t		;Offset of first MDB
BLK sd_kind  , 1t		;Segment kind
BLK sd_lad   , 2t		;LAD handle
BLK sd_lnksel, 2t		;Linked segment selector (0 means segment not
				;  in use, self means none linked)

;Define values for sd_kind

SK_FREE =!0t			;Free segment
SK_DPMIS=!1t			;DPMI static segment (high 6 bits contain DPMI
				;  client number)
SK_DPMIA=!2t			;DPMI allocated segment (high 6 bits contain
				;  DPMI client number)
SK_DPMID=!3t			;DPMI DOS memory segment (high 6 bits contain
				;  DPMI client number
SK_USER =!4t			;XOS user segment
SK_EXEC =!8t			;XOS exec segment or user segment linked to
				;  exec segment

;Define offsets in the task state segments (TSS)

$$$=!0
BLK tss_link  , 4t		;Back link to previous TSS
BLK tss_stk0  , 8t		;Virtual address for level 0 stack
BLK tss_stk1  , 8t		;Virtual address for level 1 stack
BLK tss_stk2  , 8t		;Virtual address for level 2 stack
BLK tss_CR3   , 4t		;CR3 value
BLK tss_EIP   , 4t		;Saved EIP
BLK tss_EFR   , 4t		;Saved EFR
BLK tss_EAX   , 4t		;Saved EAX
BLK tss_ECX   , 4t		;Saved ECX
BLK tss_EDX   , 4t		;Saved EDX
BLK tss_EBX   , 4t		;Saved EBX
BLK tss_ESP   , 4t		;Saved ESP
BLK tss_EBP   , 4t		;Saved EBP
BLK tss_ESI   , 4t		;Saved ESI
BLK tss_EDI   , 4t		;Saved EDI
BLK tss_ES    , 4t		;Saved ES
BLK tss_CS    , 4t		;Saved CS
BLK tss_SS    , 4t		;Saved SS
BLK tss_DS    , 4t		;Saved DS
BLK tss_FS    , 4t		;Saved FS
BLK tss_GS    , 4t		;Saved GS
BLK tss_LDT   , 4t		;LDT register value for task
BLK tss_debugt, 2t		;Debug trap bit
BLK tss_bmofs , 2t		;IO bit map offset

;Define interrupt descriptor offsets

ID_DIVERR =!0000h		;Divide error
ID_DEBUG  =!0008h		;Debug trap
ID_NMI    =!0010h		;Non-maskable interrupt
ID_BRKPNT =!0018h		;Breakpoint
ID_INTO   =!0020h		;INTO instruction trap
ID_BOUND  =!0028h		;BOUND instruction trap
ID_ILLINS =!0030h		;Illegal instruction trap
ID_FPUNAVL=!0038h		;Processor extension not available trap
ID_DBLEXP =!0040h		;Double exception
ID_FPUSOVR=!0048h		;Processor extension segment overrun
ID_ITSS   =!0050h		;Invalid task state segment
ID_SEGNP  =!0058h		;Segment not present
ID_STKERR =!0060h		;Stack overflow
ID_PROT   =!0068h		;Memory protection error
ID_PAGEFLT=!0070h		;Page fault

ID_FPUERR =!0080h		;Floating point error
ID_ALNCHK =!0088h		;Alignment check

ID_CRASH  =!00F8h		;Fatal system error call

ID_HBASE  =!0380h		;First hardware interrupt 
ID_TIMER0 =!0380h		;IRQ 0  - Timer 0 interrupt
ID_KEYBRD =!0388h		;IRQ 1  - Keyboard interrupt
ID_CASCADE=!0390h		;IRQ 2  - Not used
ID_SPORT2 =!0398h		;IRQ 3  - Serial port 2 interrupt
ID_SPORT1 =!03A0h		;IRQ 4  - Serial port 1 interrupt
ID_PPORT2 =!03A8h		;IRQ 5  - Parallel port 2 interrupt
ID_FDISK  =!03B0h		;IRQ 6  - Floppy disk controller interrupt
ID_PPORT1 =!03B8h		;IRQ 7  - Parallel port 1 interrupt
ID_RTC    =!03C0h		;IRQ 8  - Real time clock interrupt
ID_IRQ9   =!03C8h		;IRQ 9  - Not assigned
ID_IRQ10  =!03D0h		;IRQ 10 - Not assigned
ID_IRQ11  =!03D8h		;IRQ 11 - Not assigned
ID_IRQ12  =!03E0h		;IRQ 12 - Not assigned
ID_FPUINT =!03E8h		;IRQ 13 - FPU interrupt
ID_HDISK  =!03F0h		;IRQ 14 - Hard disk controller interrupt
ID_IRQ15  =!03F8h		;IRQ 15 - Not assigned

;Define offsets in the interrupt table entry (this table is used for both
;  hardware and software interrupts)

$$$=!0
BLK it_soffset , 0t	;32 bit offset value for software vector
BLK it_hoffsetl, 2t	;Low 16 bits of offset value for hardware vector
BLK it_hsel    , 2t	;Selector value for hardware vector
BLK it_count   , 1t	;Software vector count (0 for hardware interrupt)
BLK it_type    , 1t	;Type and other bits (if hardware format (bit 7 set)
			;  contains P and DPL, if software format (bit 7 clear)
			;  contains signal level (3 bits), remote enable (1
			;  bit), and vector type (3 bits))
BLK it_ssel    , 0t	;Selector value for software vector
BLK it_hoffseth, 2t	;High 16 bits of offset value for hardware vector

;Define values for it_type for software interrupts (bit 4 of it_type = 0)

ITV_XOSS   =!1t		;XOS signal
ITV_XOST   =!2t		;XOS trap
ITV_DPMI16O=!3t		;DPMI 16 bit v0.9 CPU exception
ITV_DPMI32O=!4t		;DPMI 32 bit v0.9 CPU exception
ITV_DPMI16N=!5t		;DPMI 16 bit v1.0 CPU exception
ITV_DPMI32N=!6t		;DPMI 32 bit v1.0 CPU exception

;Define indexes for each part of the internal interrupt table

ITO_PINT   =!0h		;Protected mode INTs
ITO_PEXCEPT=!100h	;Protected mode processor exceptions
ITO_REXCEPT=!120h	;Real mode processor exceptions
ITO_XOSINTS=!140h	;XOS signals
ITO_PINTLS =!160h	;Protected mode low special INTs
ITO_PINTMS =!180h	;Protected mode middle special INTs

;Define offsets in the IO register registration block (IORRB)

$$$=!0
BLK iorrb_next, 4t	;Offset of next IORRB
BLK iorrb_name, 4t	;Offset of name of device
BLK iorrb_base, 2t	;Base IO register in block
BLK iorrb_top , 2t	;Top IO register in block
iorrb_SIZE=!$$$

;Define offsets in the interrupt request registeration block (IRQRB)

$$$=!0
BLK irqrb_next  , 4t	;Offset of next IRQRB
BLK irqrb_name  , 4t	;Offset of name of device
BLK irqrb_bits  , 1t	;Bits
BLK irqrb_number, 1t	;Interrupt number
BLK             , 2t
BLK irqrb_entry , 4t	;Entry offset
BLK irqrb_exit  , 4t	;Offset of subroutine to store exit link
irqrb_SIZE=!$$$

;Define bits for irqrb_bits

IRQRB_SHAREPCI=!80h	;Interrupt is a sharable PCI interrupt


;Define bits for the first process status byte (pdaStatus1)

P1$DOSSEG =!80h		;Process has real mode DOS environment set up
P1$BIOSSEG=!40h		;Process has real mode BIOS environment set up
P1$NOCDS  =!20h		;No child died signal
P1$SETUP  =!10h		;Process is in set up mode
P1$HALTED =!08h		;Process has been halted
P1$FPU    =!04h		;FPU is enabled
P1$PQ1R   =!02h		;Process should be requeued to PQ1
P1$KILL   =!01h		;Process is being killed

;Define bits for the second process status byte (pdaStatus2)

P2$KILLS  =!80h		;Final scheduler clean-up has been done
P2$XFRDEV =!04h		;Waiting for child process to receive devices
P2$DVFUNC =!01h		;Doing device function (svcIoDevFunc)

;Define bits for the third process status byte (pdaStatus3)

P3$ACSENV=!02h		;Process can access its parent's environment
P3$CHGENV=!01h		;Process can change its parent's environment

;Define process privilege bits stored in pdaPriv (since there are 64
;  possible bits, only the bit number definitions are used)

PP%SYSADMIN=!31t	;System administrator privileges
PP%GRPADMIN=!30t	;Group administrator privileges
PP%OPER    =!29t	;Operator privileges
PP%ANYLOGIN=!28t	;Can set logged in values at any time
PP%ALLPROC =!27t	;May kill or interrupt any process
PP%SYSENV  =!26t	;May change system level environment strings
PP%SESENV  =!25t	;May change session level environment strings
PP%SYSLOG  =!24t	;May change system level logical names

PP%DETACH  =!22t	;May detach process
PP%NEWSES  =!21t	;May create new session

PP%PORTIO  =!17t	;May directly access IO ports
PP%SHAREDEV=!16t	;May share any device
PP%ALLIO   =!15t	;May do restricted IO operations
PP%FBYPASS =!14t	;Bypass all file access checking
PP%FREADALL=!13t	;Bypass file read access checking
PP%FUSESYS =!12t	;Access files using system protection
PP%FSPECIFY=!11t	;Can specify user name for file access

PP%MEMLOCK =!9t		;Can lock memory pages in place
PP%NOSWAP  =!8t		;Can lock memory pages in memory
PP%READPHY =!7t		;Can read physical memory
PP%WRITEPHY=!6t		;Can write physical memory
PP%READKER =!5t		;Can read kernel memory
PP%WRITEKER=!4t		;Can write kernel memory

PP%SCRNSYM =!1t		;Can execute screen symbiont functions
PP%LKELOAD =!0t		;Can execute LKE load functions

;Define bits for the system level signal type byte (pdaSSigType)

SSIG$KILL2=!08h		;Kill process, step 2
SSIG$KILL1=!04h		;Kill process, step 1
SSIG$HALT =!02h		;Halt process
SSIG$FPUX =!01h		;FPU exception

;Define values for the wait index type (stored in high 4 bits of the 32 bit
;  wait index)

WX_XOFS=!00000000h	;Value is an exec data segment offset
WX_UOFS=!10000000h	;Value is a user offset
WX_GSEL=!20000000h	;Value is a global segment selector

;Define bits for the virtual DOS mode interrupt status register (pdaRMISts)

IS$READY =!80h		;Simulated interrupt controller ready for interrupt
IS$RIS   =!40h		;Read ISR next

;Define offsets in the stack frame for DOS user mode functions. This stack
;  frame is generated before calling all protected user mode INT 10, INT 21,
;  and INT 31 function routines.

dff_arg =!72t			;First pushed user argument
dff_SS  =!68t			;Caller's SS value
dff_ESP =!64t			;Caller's ESP value
dff_x   =!60t			;Vector number and signal item count (always 0)
dff_EFR =!56t			;Caller's EFR value
dff_CS  =!52t			;Caller's CS value
dff_EIP =!48t			;Caller's EIP value
dff_DS  =!44t			;Caller's DS value
dff_ES  =!40t			;Caller's ES value
dff_FS  =!36t			;Caller's FS value
dff_GS  =!32t			;Caller's GS value
dff_EAX =!28t			;Caller's EAX value
dff_ECX =!24t			;Caller's ECX value
dff_EDX =!20t			;Caller's EDX value
dff_EBX =!16t			;Caller's EBX value
dff_EBP =!8t			;Caller's EBP value
dff_ESI =!4t			;Caller's ESI value
dff_EDI =!0t			;Caller's EDI value

;Define offsets in the system code segment

oocode    =!100000h		;Once-only code msect

;Define offsets in the system data segment

oocdbuffer=!003E0000h		;Once-only console display screen buffer
oorddata  =!00400000h		;Once-only RAM-disk data area
oocddata  =!00400800h		;Once-only console display data area
oordfile  =!00401000h		;Once-Only RAM-disk file area
spacetop  =!0079D000h		;Starting offset for allocating address space
voidmem   =!0079D000h		;Single page which is never used
crshpage  =!0079E000h		;Offset of crash data page
pagezero  =!0079F000h		;Offset of place in data segment where physical
				;  page 0 is mapped
  crshdata  =!pagezero+0A00h	;  Place to put crash data on page 0
  crshsave  =!pagezero+0B80h	;  Place to save old crash data on page 0
symtable  =!007A0000h		;Exported symbol table
dcbtable  =!007B0000h		;DCB table
gdtable   =!007C0000h		;Global descriptor table
ramaccess =!007D0000h		;Address space for mapping physical memory
				;  during allocation and swapping
dsprom    =!007E0000h		;Physical display adapter ROM (0C0000) mapping
biosrom   =!007F0000h		;Physical BIOS ROM mapping
xmbbase   =!00800000h		;Exec page pool
graphdisp =!04000000h		;Graphics mode display buffers
cbbase    =!08000000h		;Disk cache buffers
pgtable   =!0BC00000h		;Base of page table
datasegtop=!0C000000h		;Top of data segment

debugdspb =!00100000h		;Offset of debug display save buffer in debug
				;  data segment

;Define offsets in page zero used by the bootstrap and crash save stuff

pg0_ic1mask=!800h		;Place to save interrupt mask for first
				;  interrupt controller
pg0_ic2mask=!801h		;Place to save interrupt mask for second
				;  interrupt controller

;Define linear address and values

la_system   =!0E0000000h	;Lowest system linear address
la_pda      =!0E0000000h	;PDAs
la_xfork    =!0F0000000h	;Extended fork context stack frames
  la_xforkSIZE=!3C00000h
la_textdisp =!0F3C00000h
la_debugc   =!0F3C40000h	;Debugger code segment
la_debugd   =!0F3C80000h	;Debugger data segment
la_code     =!0F3E00000h	;System code segment
la_oocode   =!la_code+oocode	;Once-only code
la_usercode =!0F3FF0000h	;Protected mode user code segment
la_vusercode=!0F3FFC000h	;Virutal-86 mode user code segment
la_data     =!0F4000000h	;System data segment
la_oorddata =!la_data+oorddata	;Once-only RAM-disk
la_void     =!la_data+voidmem	;Area (at least 1 page) which is never used
la_crshpage =!la_data+crshpage	;Crash data page
la_pagezero =!la_data+pagezero	;Page zero
la_symtable =!la_data+symtable	;Exported symbol table
la_gdtable  =!la_data+gdtable	;Global descriptor table
la_ramaccess=!la_data+ramaccess	;Address space for mapping physical memory
la_dsprom   =!la_data+dsprom	;EGA ROMs
la_biosrom  =!la_data+biosrom	;BIOS ROMs
la_xmbbase  =!la_data+xmbbase	;Exec page pool
la_graphdisp=!la_data+graphdisp	;Console display buffers
la_cbbase   =!la_data+cbbase	;Disk cache buffers
la_pgtable  =!la_data+pgtable	;Page tables

xpagelist =!pgtable+{la_xmbbase>10t} ;Offset of base of exec page free list

;Define offsets in the stack frame used for open functions
;  WARNING:  Several routines depend on the order of these definitions to
;            reuse some of this stack space!!  Do not change these definitions
;            without making sure that nothing is counting on the order.

$$$=!0
FRM opn_frame1   , 4t		;Pointer to level 1 frame (this frame)
FRM opn_devname  , 16t		;Device name buffer
FRM opn_stkdata  , 0		;Start of general stack area that can be used
				;  by routines which use the open stack which
				;  do not do parameter processing
FRM opn_opendisp , 4t		;Dispatch for doopen
FRM opn_cab      , 4t		;Offset of close action block (CAB)
FRM opn_vect1num , 2t
FRM opn_vect1pda , 2t
FRM opn_vect2num , 2t
FRM opn_vect2pda , 2t
FRM opn_dirofs   , 0t		;Value of IOPAR_DIROFS
FRM opn_length   , 4t		;Value of IOPAR_LENGTH
FRM opn_conlimit , 2t		;Value of IOPAR_NETCONLIMIT
FRM opn_conhndl  , 2t		;Value of IOPAR_NETCONHNDL
FRM opn_dirhndl  , 0t		;Value of IOPAR_DIRHNDL
FRM opn_iopos    , 4t		;Value of IOPAR_ABSPOS, IOPAR_RELPOS, or
				;  IOPAR_EOFPOS
FRM opn_reqalloc , 4t		;Value of IOPAR_REQALLOC
FRM opn_rqralloc , 4t		;Value of IOPAR_RQRALLOC
FRM opn_grpsize  , 4t		;Value of IOPAR_GRPSIZE
FRM opn_prot     , 4t		;Value of IOPAR_PROT
FRM opn_lockval  , 8t		;Value of IOPAR_SETLOCK or IOPAR_CLRLOCK
FRM opn_shrparms , 4t		;Value of IOPAR_SHRPARMS
FRM opn_avlspace , 4t		;Value of IOPAR_AVLSPACE
FRM opn_ttlspace , 4t		;Value of IOPAR_TTLSPACE
FRM opn_clssize  , 1t		;Value of IOPAR_CLSSIZE
FRM opn_fstype   , 1t		;Value of IOPAR_FSTYPE
FRM opn_sectsize , 2t		;Value of IOPAR_SECTSIZE
FRM opn_numsect  , 2t		;Value of IOPAR_NUMSECT
FRM opn_numhead  , 2t		;Value of IOPAR_NUMHEAD
FRM opn_numcyln  , 2t		;Value of IOPAR_NUMCYLN
FRM              , 2t
FRM opn_filattr  , 1t		;Value of IOPAR_FILATTR
FRM opn_srcattr  , 1t		;Value of IOPAR_SRCATTR
FRM opn_curattr  , 1t		;Current file attribute bits
FRM opn_datefmt  , 1t		;Date format bits
FRM opn_adate    , 8t		;Value of IOPAR_ADATE
FRM opn_cdate    , 8t		;Value of IOPAR_CDATE
FRM opn_mdate    , 8t		;Value of IOPAR_MDATE
FRM opn_inpqlmt  , 1t		;Value of IOPAR_INPQLMT
FRM opn_outqlmt  , 1t		;Value of IOPAR_OUTQLMT
FRM opn_bufrlmt  , 1t		;Value of IOPAR_BUFRLMT
FRM              , 1t
FRM opn_protocol , 4t		;Value of IOPAR_NETPROTOCOL (network only)
FRM opn_lclport  , 4t		;Value of IOPAR_NETLCLPORT (network only)
FRM opn_rmtports , 4t		;Value of IOPAR_NETRMTPORTS (network only)
FRM opn_rmtnetas , 4t		;Value of IOPAR_NETRMTNETAS (network only)
FRM opn_katime   , 4t		;Value of IOPAR_NETKATIME (network only)
FRM opn_lrmtaddrs, 2t		;Length of IOPAR_NETRMTADDRS string
FRM opn_vrmtaddrs, 6t		;Pointer to IOPAR_NETRMTADDRS string
FRM              , 2t		;
FRM opn_srmtaddrs, 6t		;Pointer to IOPAR_NETRMTADDRS size value
FRM opn_owner    , 36t		;Value of IOPAR_OWNER
FRM opn_acsgrp   , 16t
FRM opn_acsown   , 16t
opn_SIZEr=!$$$-4
FRM opn_namebfr  , FILESPCSIZE+4;File specification buffer
opn_SIZE=!$$$-4

;Define values for opn_datefmt

DF$DOSADATE=!04			;Access date is in DOS format
DF$DOSCDATE=!02			;Creatation date is in DOS format
DF$DOSMDATE=!01			;Modify date is in DOS format

;Define bits for xffHvValue1 and xffNdValue1

IOV1$DIROFS  =!80000000h	;Have/need value for IOPAR_DIROFS
  IOV1%DIROFS  =!31t
IOV1$LENGTH  =!40000000h	;Have/need value for IOPAR_LENGTH
  IOV1%LENGTH  =!30t
IOV1$DIRHNDL =!20000000h	;Have/need value for IOPAR_DIRHNDL
  IOV1%DIRHNDL =!29t
IOV1$RENAME  =!10000000h	;Processing second name for rename
  IOV1%RENAME  =!28t
IOV1$REQALLOC=!08000000h	;Have/need value for IOPAR_REQALLOC
  IOV1%REQALLOC=!27t
IOV1$RQRALLOC=!04000000h	;Have/need value for IOPAR_RQRALLOC
  IOV1%RQRALLOC=!26t

IOV1$GRPSIZE =!01000000h	;Have/need value for IOPAR_GRPSIZE
  IOV1%GRPSIZE =!24t
IOV1$ADATE   =!00800000h	;Have/need value for IOPAR_ADATE
  IOV1%ADATE   =!23t
IOV1$CDATE   =!00400000h	;Have/need value for IOPAR_CDATE
  IOV1%CDATE   =!22t
IOV1$MDATE   =!00200000h	;Have/need value for IOPAR_MDATE
  IOV1%MDATE   =!21t
IOV1$PROT    =!00100000h	;Have/need value for IOPAR_PROT
  IOV1%PROT    =!20t
IOV1$OWNER   =!00080000h	;Have/need value for IOPAR_OWNER
  IOV1%OWNER   =!19t
IOV1$USER    =!00040000h	;Have/need value for IOPAR_USER
  IOV1%USER    =!18t
IOV1$FILATTR =!00020000h	;Have/need value for IOPAR_FILATTR
  IOV1%FILATTR =!17t
IOV1$SRCATTR =!00010000h	;Have/need value for IOPAR_SRCATTR
  IOV1%SRCATTR =!16t
IOV1$DEVSTS  =!00008000h	;Need value for IOPAR_DEVSTS
  IOV1%DEVSTS  =!15t
IOV1$UNITNUM =!00004000h	;Need value for IOPAR_UNITNUM
  IOV1%UNITNUM =!14t
IOV1$GLBID   =!00002000h	;Need value for IOPAR_GLBID
  IOV1%GLBID   =!13t
IOV1$ABSPOS  =!00001000h	;Have/need value for IOPAR_ABSPOS
  IOV1%ABSPOS  =!12t
IOV1$RELPOS  =!00000800h	;Have/need value for IOPAR_RELPOS
  IOV1%RELPOS  =!11t
IOV1$EOFPOS  =!00000400h	;Have/need value for IOPAR_EOFPOS
  IOV1%EOFPOS  =!10t
IOV1$FILOPTN =!00000200h	;Have/need value for IOPAR_FILOPTN
  IOV1%FILOPTN =!9t
IOV1$FILSPEC =!00000100h	;Have/need value for IOPAR_FILSPEC
  IOV1%FILSPEC =!8t
IOV1$PROTOCOL=!00000080h	;Have/need value for IOPAR_PROTOCOL
  IOV1%PROTOCOL =!7t
IOV1$LCLPORT =!00000040h	;Have/need value for IOPAR_NETLCLPORT
  IOV1%LCLPORT =!6t
IOV1$RMTPORTS=!00000020h	;Have/need value for IOPAR_NETRMTPORTS
  IOV1%RMTPORTS=!5t
IOV1$RMTNETAS=!00000010h	;Have/need value for IOPAR_NETRMTNETAS
  IOV1%RMTNETAS=!4t
IOV1$ACSNETWK=!00000008h	;Have/need value for IOPAR_ACSNETWK
  IOV1%ACSNETWK=!3t
IOV1$SHRPARMS=!00000004h	;Have/need value for IOPAR_SHRPARMS
  IOV1%SHRPARMS=!2t
IOV1$SETLOCK =!00000002h	;Have/need value for IOPAR_SETLOCK
  IOV1%SETLOCK =!1t
IOV1$CLRLOCK =!00000001h	;Have/need value for IOPAR_CLRLOCK
  IOV1%CLRLOCK =!0t

;Define bits for xffHvValue2 and xffNdValue2

IOV2$FSTYPE  =!80000000h	;Need value for IOPAR_FSTYPE
  IOV2%FSTYPE  =!31t
IOV2$SECTSIZE=!40000000h	;Need value for IOPAR_SECTSIZE
  IOV2%SECTSIZE=!30t
IOV2$CLSSIZE =!20000000h	;Need value for IOPAR_CLSSIZE
  IOV2%CLSSIZE =!29t
IOV2$TTLSPACE=!10000000h	;Need value for IOPAR_TTLSIZE
  IOV2%TTLSPACE=!28t
IOV2$AVLSPACE=!08000000h	;Need value for IOPAR_AVLSIZE
  IOV2%AVLSPACE=!27t
IOV2$NUMHEAD =!04000000h	;Need value for IOPAR_NUMHEAD
  IOV2%NUMHEAD =!26t
IOV2$NUMSECT =!02000000h	;Need value for IOPAR_NUMSECT
  IOV2%NUMSECT =!25t
IOV2$NUMCYLN =!01000000h	;Need value for IOPAR_NUMCYLN
  IOV2%NUMCYLN =!24t
IOV2$RMTADDRS=!00800000h	;Need value for IOPAR_MSGRMTADDRS
  IOV2%RMTADDRS=!23t

;Define common offsets in the DCBs

dcb_cSIZE=!58h
$$$=!-dcb_cSIZE
BLK dcb_ccb     , 4t	;Offset of CCB for device class
BLK dcb_prev    , 4t	;Offset of previous DCB in class
BLK dcb_next    , 4t	;Offset of next DCB in class
BLK dcb_id      , 4t	;Device ID
BLK dcb_dsp     , 4t	;Device description bits
BLK dcb_devchar , 4t	;Offset of device characteristics table
BLK dcb_inpframe, 2t	;Selector for input extended fork frame (WARNING: must
			;  be far enough into the DCB so clearing it after a
			;  dynamic DCB has been given up will not do any harm!)
BLK dcb_inpqlmt , 1t	;Input queue limit
BLK dcb_bufrlmt , 1t	;Buffer limit
BLK dcb_outframe, 2t	;Selector for output extended fork frame
BLK dcb_outqlmt , 1t	;Output queue limit
BLK dcb_waitque , 1t	;Wait queue to use
BLK dcb_sts1    , 1t	;First device status byte (Device independent)
BLK dcb_sts2    , 1t	;Second device status byte (device independent)
BLK dcb_sts3    , 1t	;Third device status byte (device dependent)
BLK             , 1t
BLK dcb_sesproc , 2t	;Number of senior process in session which owns device
BLK             , 2t
BLK dcb_cab     , 4t	;Offset of close action data block (CAB)
BLK dcb_type    , 4t	;Device type (4 characters)
BLK dcb_name    , 16t	;Name of device (8 characters)
BLK dcb_sdisp   , 4t	;Offset of SVC function dispatch table
BLK dcb_opencnt , 4t	;Number of times device has been opened
BLK dcb_dmachnl , 1t	;DMA channel number
BLK dcb_punit   , 1t	;Primary unit number
BLK dcb_sunit   , 2t	;Secondary unit number
BLK dcb_fdisp   , 4t	;Offset of fork routine
BLK dcb_fnext   , 4t	;Offset of next DCB in fork request list or DMA wait
			;  list
BLK dcb_magic   , 4t	;DCB magic number = 'DCB'
BLK dcb_devbgn  , 0t	;Beginning of device dependent part of DCB
.IF NE dcb_devbgn
	.IRP	q, >dcb_devbgn
	.ERROR	DCB starting offset is wrong, dcb_devbgn = q'h
	.ENDR
.ENDC

;Define offsets in the close action block (CAB)

$$$=!0
BLK cab_next   , 4t	;Offset of next CAB in the close timer chain
BLK cab_dcb    , 4t	;Offset of DCB
BLK cab_pda    , 2t	;Selector for PDA for close timer request
BLK cab_handle , 2t	;Handle for close timer request
BLK cab_count  , 2t	;Close timer counter
BLK cab_time   , 2t	;Close timer time value
BLK cab_clsname, 32t	;Close name string
BLK cab_clsmsg , 16t	;Destination name for message on close

;Define offsets in the IO Request Block (IORB)

$$$=!0
BLK iorb_next   , 4t	;Offset of next IORB for device
BLK iorb_routine, 4t	;Offset of extended fork context routine
BLK iorb_finish , 4t	;Offset of termination routine
BLK iorb_bgncopy, 0	;First item to copy to the XFF
BLK iorb_mlckcnt, 4t	;Number of memory pages locked
BLK iorb_qab    , 6t	;Address of user's QAB
BLK iorb_queue  , 1t	;Offset of dcb_inpframe or dcb_outframe relative to DCB
BLK iorb_sts1   , 1t	;Status bits
BLK iorb_buffer1, 6t	;Address of user's first buffer
BLK iorb_pda    , 2t	;Selector for PDA for process doing IO
BLK iorb_buffer2, 6t	;Address of user's second buffer
BLK iorb_func   , 2t	;Function bits
BLK iorb_parm   , 6t	;Address of user's parameter list
BLK iorb_handle , 2t	;Device handle
BLK iorb_lock   , 8t	;Memory lock table entry or table pointer
BLK iorb_option , 4t	;Options or command
BLK iorb_count  , 4t	;Buffer 1 size
iorb_NUMCOPY=!{$$$-iorb_bgncopy}/4 ;Number of longs to copy to the XFF

;Define bits in xffStatus1

XF1$CANCEL=!80h		;IO has been canceled
XF1$ABORT =!40h		;IO has been aborted
XF1$CLOSE =!20h		;Close done
XF1$NOINT =!10h		;Suppress IO done interrupt
XF1$SPOOL =!02h		;Opening spooled device (set to indicate to file driver
			;  that should used spooled bits for dcb_dsp)
XF1$CLASS =!01h		;IOPAR_CLASS specified

;Define offsets in a class control block (CCB)

$$$=!0
BLK ccb_next   , 4t	;Offset of next CCB
BLK ccb_name   , 16t	;Name of this class (16 characters)
BLK ccb_dcbhead, 4t	;Offset of first DCB for class
BLK ccb_dcbtail, 4t	;Offset of last DCB for class
BLK ccb_dchk   , 4t	;Offset of device check routine
BLK ccb_fdsp   , 4t	;Offset of class function dispatch table
BLK ccb_clschar, 4t	;Offset of class characteristics table
ccb_SIZE =!$$$

;Define offsets in a free exec memory buffer

$$$=!0
BLK xmf_magic, 4t	;Magic number
BLK xmf_size , 4t	;Size of free buffer
BLK xmf_next , 4t	;Offset of next free buffer
BLK xmf_prev , 4t	;Offset of previous free buffer

;Define offsets in a per-process memory block

$$$=!0
BLK mb_size , 4t	;Size of this block (in bytes)
BLK mb_next , 4t	;Offset of next block
BLK mb_pnt1 , 4t	;Offset of first pointer to this block
BLK mb_pnt2 , 4t	;Offset of second pointer to this block
BLK mb_data , 0		;First data item in block

;Define offsets in an event cluster definition block

$$$=!0
BLK ec_size   , 4t	;Size of this block
BLK ec_next   , 4t	;Offset of next block
BLK ec_pnt1   , 4t	;Offset of pointer to this block
BLK           , 4t	;Reserved
BLK ec_name   , 12t	;Name of event cluster
BLK ec_max    , 4t	;Maximum event number for cluster
BLK ec_baseint, 4t	;Base interrupt for cluster
BLK ec_reserve, 4t	;Reserve bits
BLK ec_events , 0t	;First event table entry

;Define offsets in the session data block (stored in the session level PDA)

$$$=!mb_data
BLK ses_sesseq  , 16t	;Session sequence number
BLK ses_grpname , 16t	;Group name
BLK ses_usrname , 16t	;User name
BLK ses_actdev  , 16t	;Name of accounting device
BLK ses_access  , 4t	;Access class name
BLK ses_actnode , 4t	;Accounting node
BLK ses_actport , 4t	;Accounting port
BLK ses_uprgvrsn, 4t	;User program version number
BLK ses_portname, 16t	;Acces port name
BLK ses_useraddr, 32t	;User address
BLK ses_billtime, 8t	;Last date/time billing time added in
BLK ses_billcls , 1t	;Billing class
BLK ses_numper  , 1t	;Number of time periods in use
BLK ses_billlvl , 1t	;Current billing level
BLK             , 1t
BLK ses_billkey , 4t	;Billing key value
BLK ses_atime1  , 4t	;First accounting time break
BLK ses_atime2  , 4t	;Second accounting time break
BLK ses_atime3  , 4t	;Third accounting time break
BLK ses_rates1  , 64t	;First rate values
BLK ses_rates2  , 64t	;Second rate values
BLK ses_rates3  , 64t	;Third rate values
ses_SIZE=!$$$

;Define offsets in an msect data block (MDB)

$$$=!0
BLK mdb_next   , 4t	;Offset of next MDB for same segment
BLK mdb_label  , 4t	;Label = MDB*
BLK mdb_base   , 4t	;Offset of start of this msect within its segment
BLK mdb_size   , 4t	;Size of this msect (in memory pages)
BLK mdb_la     , 4t	;Linear address for msect
BLK mdb_pda    , 2t	;Selector of PDA
BLK mdb_devtype, 1t	;Type of device which has this msect mapped
BLK mdb_sts    , 1t	;Status bits
BLK mdb_remove , 4t	;Offset of subroutine to call when removing msect
BLK mdb_segnext, 0	;Offset of next MDB for shared section
BLK mdb_devnext, 4t	;Next MDB mapped for same device
BLK mdb_segsda , 0	;Selector for SDA for shared segment
BLK mdb_devpnt , 4t	;Offset of data block for device which has this msect
			;  mapped
BLK mdb_lockcnt, 4t	;Number of locked pages in the section (shared sections
			;  only)
BLK mdb_fault  , 4t	;Offset of subroutine to call on page faults
BLK mdb_mod    , 4t	;Modulus for LAD allocation (must be power of two)
BLK mdb_lad    , 4t	;LAD handle (only used for DPMI msects)
BLK mdb_tasknum, 1t	;DOS task number associated with msect
BLK            , 3t

;Define bits for mdb_sts

MSS$FIXED   =!40h	;Fixed size msect
MSS$NODEALOC=!20h	;Do not deallocate pages

;Define XMB size indexes

XMBX_64  =!0t
XMBX_128 =!1t
XMBX_256 =!2t
XMBX_512 =!3t
XMBX_1024=!4t
XMBX_2048=!5t
XMBX_4096=!6t

;Define values for the type field in a page map entry when the P bit (bit 0)
;  is clear (bits 2-5)

PT_VIRT =!1t		;Virtually allocated page (bits 5-31 contain offset of
			;  MDB for msect)
PT_SWAP =!2t		;Swapped out page
PT_DISP =!3t		;Unmapped display page (bits 5-31 contain offset of
			;  TDB for terminal)
PT_BLOCK=!4t		;Blocked display page (bits 5-31 contain offset of
			;  MDB for msect)

;Define values for the type field in the memory page table entry.  The use of
;  these values is described in MEMORY1.M86

MT_FREE =!0t		;Unallocated page
MT_SYS  =!1t		;System page
MT_PDIR =!2t		;Page directory page
MT_PTBL =!3t		;Page table page
MT_PDA  =!6t		;Process data area (PDA) page
MT_SDA  =!7t		;Shared section data area (SDA) page
MT_PLOCK=!8t		;Private locked user page
MT_SLOCK=!9t		;Shared locked user page
MT_PNSWP=!10t		;Private non-swapable user page
MT_SNSWP=!11t		;Shared non-swapable user page
MT_PUSER=!12t		;Private user page
MT_SUSER=!13t		;Shared user page

;Define offsets in a once-a-second routine block

$$$=!0
BLK os_next , 4		;Offset of next once-a-second routine block
BLK os_disp , 4		;Offset of this once-a-second routine
os_SIZE=!$$$

;Define offsets in a logical name definition block

$$$=!0
BLK ln_size  , 4	;Size of this block (in bytes)
BLK ln_next  , 4	;Offset of next logical name block
BLK ln_pntr  , 4	;Offset of pointer to this block
BLK          , 4	;Not used (reserved for second pointer)
BLK ln_num   , 1	;Number of definitions for logical name
BLK ln_flags , 1	;Flag bits
BLK ln_path  , 2	;Offset of path string relative to start of block
BLK ln_log   , 16t	;Logical name
BLK ln_def   , 16t	;Defined name
BLK ln_exsize, 1	;Exact length of extended part of definition (in bytes)
BLK ln_exdef , 0	;First byte of extended part of definition

;Define values for ln_flags

LNF$SUBST =!40h		;Substitued name
LNF$ROOTED=!20h		;Rooted name

;Define offset in a environment string definition block

$$$=!0
BLK eb_size  , 4	;Size of this block (in bytes)
BLK eb_next  , 4	;Offset of next logical name block
BLK eb_pntr  , 4	;Offset of pointer to this block
BLK          , 4	;Not used (reserved for second pointer)
BLK eb_length, 4	;Length of name string (in longs)
BLK eb_string, 0	;First byte in name string (followed by definition
			;  at next long boundry)

;Define bits for dcb_sts1

D1$NOINH  =!80h		;Do not give device to child process
  D1%NOINH  =!7t
D1$HUNG   =!40h		;Device has timed out
  D1%HUNG   =!6t
D1$OUTACT =!02h		;Output is active on device
  D1%OUTACT =1t
D1$INPACT =!01h		;Input is active on device
  D1%INPACT =0t

;Define common bits for dcb_sts2

D2$DIRECT  =!80h	;Directory open on device
  D2%DIRECT  =!7t
D2$COMMIT  =!40h	;Data should be committed when operation is complete
  D2%COMMIT  =!6t
D2$REPEAT  =!20h	;Repeated operation in progress
  D2%REPEAT  =!5t
D2$SINGLE  =!10h	;Do single sector transfers
  D2%SINGLE  =!4t
D2$MODIFIED=!08h	;Device media has been modified
  D2%MODIFIED=!3t

;Define offsets in the entry for the table which specifies device
;  characteristics names and values for the svcIoDevChar system call
;	s = Used in standard table entry
;	i = Used in indirect table entry
;	h = Used in linked table head entry
;	e = Used in linked table element entry

dct_descript=!0t	;(1) s  e Argument description byte
dct_flags   =!1t	;(1) sihe Flag bits
dct_length  =!2t	;(2) s  e Value length
dct_name    =!4t	;(8) s  e Characterisitc name
dct_indtable=!4t	;(4)  i   Offset of indirect table
dct_lnkgethd=!4t	;(4)   h  Offset of routine to get first linked element
dct_lnkfind =!8t	;(4)   h  Offset of linked entry find routine
dct_setsub  =!12t	;(4) s  e Offset of routine to set value
dct_getsub  =!16t	;(4) s  e Offset of routine to get value
dct_data    =!20t	;(4) s  e Data value
dct_infopnt =!24t	;(4) s  e Offset of information string
dct_SIZE    =!28t	;Size of standard indirect and linked head table entry
dct_lnknext =!28t	;(4)    e Offset of next linked element
dct_lnkdone =!32t	;(4)    e Offset of linked entry done routine
dct_lnkSIZE =!36t	;Minimum size of linked element entry

;Define values for dct_flags

DCTF$LNKELMT=!08h	;Linked element entry
DCTF$LNKHEAD=!04h	;Linked head entry
DCTF$INDIR  =!02h	;Indirect entry
DCTF$HIDDEN =!01h	;Value is hidden

;Define offsets in the block which specifies device parameters for the
;  procdevparm subroutine

dpa_argdsp  =!0t	;(1) Argument description byte
dpa_argindex=!1t	;(1) Argument index
dpa_getset  =!2t	;(1) Mask for get and set bits
			;(1) Not used
dpa_sub     =!4t	;(4) Offset of subroutine for parameter
dpa_SIZE    =!8t

;Define offsets in the block which specifies device parameters for the
;  scandevparm subroutine

dps_argindex=!0t	;(1) Argument index
			;(3) Not used
dps_sub     =!4t	;(4) Offset of subroutine for parameter
dps_SIZE    =!8t

;Define offsets for the wake data block

$$$=!0
BLK wkb_magic   , 4t	;Magic number
BLK wkb_next    , 4t	;Offset of next wake block in wake list
BLK wkb_prev    , 4t	;Offset of previous wake block in wake list
BLK wkb_cnt     , 4t	;Wake count
BLK wkb_disp    , 4t	;Dispatch offset
BLK wkb_EDI     , 4t	;Value of EDI
BLK wkb_remove  , 4t	;Offset of subroutine to call when removing wake block
BLK wkb_pnext   , 4t	;Offset of next wake block for same PDA
BLK wkb_pprev   , 4t	;Offset of previous wake block for same PDA
BLK wkb_handle  , 4t	;Wake handle
BLK wkb_vector  , 2t	;Vector number
BLK wkb_sigcnt  , 1t	;Number of pending signal requests
BLK             , 1t
BLK wkb_interval, 4t	;Interval value
BLK wkb_sigdata , 4t	;Signal data value
wkb_SIZE=!$$$		;Size of the wake block

;Define offsets for the signal link block

$$$=!0
BLK slb_next    , 4t	;Offset of next signal link block for this level
BLK slb_prev    , 4t	;Offset of previous signal link block for this level
BLK slb_vector  , 4t	;Vector number (user) or offset (exec)
BLK slb_dcnt    , 1t	;Data count
BLK slb_type    , 1t	;Interrupt type
BLK slb_szindx  , 1t	;Size index for this block
BLK             , 1t	;Not used
BLK slb_grantsub, 4t	;Offset of grant subroutine
BLK slb_grantEDI, 4t	;Value for EDI for grant subroutine
BLK slb_data    , 32t	;Data items (up to 8)
slb_SIZE=!$$$

;Define values for the slb_type byte

SIGT_NORMAL=!1t		;Normal software interrupt
SIGT_CC    =!2t		;Cntl-C software interrupt

;Define function values passed to the signal grant subroutine in AL

SGF_GRANTED=!0t		;Signal granted
SGF_CLEARED=!1t		;Signal ignored because cleared
SGF_NOVECT =!2t		;Signal ignored because no vector
SGF_ALLCLR =!3t		;All signals cleared

;Define offsets for the DOS INT 2F function blocks

$$$=!0
BLK int2F_next , 4t	;Offset of next INT 2F function block
BLK int2F_value, 4t	;Function value
BLK int2F_mask , 4t	;Value mask
BLK int2F_func , 4t	;Offset of function routine
int2F_SIZE=!$$$

;Define offsets for the knlExecReal register block

$$$=!0
BLK xrr_EAX, 4t
BLK xrr_ECX, 4t
BLK xrr_EDX, 4t
BLK xrr_EBX, 4t
BLK xrr_EBP, 4t
BLK xrr_ESI, 4t
BLK xrr_EDI, 4t
BLK xrr_EFR, 4t
BLK xrr_DS , 4t
BLK xrr_ES , 4t
BLK xrr_FS , 4t
BLK xrr_GS , 4t
xrr_SIZE=!$$$

;Define offsets for the SVC function dispatch tables
;  - = Returns error code in EAX only
;  + = Returns queued IO transfer status in EAX, EBX, and ECX
;  * = Returns full queued IO status in EAX, EBX, ECX, and EDX
;  F = Called in extended fork context
;  M = Called at main program level
;  B = May be called either in extended fork context or at main program level

$$$=!0
BLK sd_mount     , 4t	;F- Mount
BLK sd_cleardev  , 4t	;M- Clear device
BLK sd_cleardcb  , 4t	;M- Clear DCB
BLK sd_commit    , 4t	;F- Commit data to disk
BLK sd_transold  , 4t	;M- Transfer device - old user clean up
BLK sd_transnew  , 4t	;F- Transfer device - new user set up
BLK sd_opena     , 4t	;B- Open additional
BLK sd_open1     , 4t	;F- Open device/file
BLK sd_parm      , 4t	;F- Get/set device parameters
BLK sd_delete    , 4t	;M* Delete file
BLK sd_rename    , 4t	;M* Rename file
BLK sd_inblock   , 4t	;M+ Input block
BLK sd_outblock  , 4t	;M+ Output block
BLK sd_outblockq , 4t	;F+ Output block in extended fork context
BLK sd_outstring , 4t	;M+ Output string
BLK sd_getiosts  , 4t	;M- Get input available/output ready status
BLK sd_special   , 4t	;M+ Special device function
BLK sd_close     , 4t	;F+ Close file
BLK sd_label     , 4t	;M+ Device label functions
BLK sd_commitfunc, 4t	;M+ Commit function
BLK sd_devinfo   , 4t	;M- Return detailed device information

;Define offsets for the disk function dispatch tables

BLK dd_vfychg    , 4t	;Verify changed disk
BLK dd_opennorm  , 4t	;Open device
BLK dd_opendir   , 4t	;Open device using open directory
BLK dd_rename    , 4t	;Rename file
BLK dd_close     , 4t	;Close file
BLK dd_openparms , 4t	;Offset of IO parameter table for open
BLK dd_setpath   , 4t	;Set up path data
BLK dd_chkpath   , 4t	;Check path data
BLK dd_clrpath   , 4t	;Clear path data
BLK dd_gtrtprot  , 4t	;Get root directory protection
BLK dd_strtprot  , 4t	;Set root directory protection

;Define offsets in the LKE header (this is the first 48 bytes of the code
;  msect of an LKE)

$$$=!0
BLK lke_next    , 4t	;Offset (in code segment) of next LKE
BLK lke_symtblos, 4t	;Offset (in data segment) of symbol table for LKE
BLK lke_symtblsz, 4t	;Size of the symbol table
BLK lke_dataos  , 4t	;Offset (in data segment) of start of data area for LKE
BLK lke_datasz  , 4t	;Size of the data area for LKE (excluding symbol table)
BLK lke_codesz  , 4t	;Size of the code area for LKE (includes this header)
BLK lke_fcdadef , 4t	;Offset (in data segment) of first common data area
			;  definition for LKE
BLK lke_level   , 4t	;LKE compatibility level
BLK lke_version , 4t	;LKE version number
BLK lke_type    , 1t	;LKE type
BLK             , 3t	;Reserved
BLK lke_name    , 16t	;LKE name

;Define commonly used macros

	.MACRO	DATA
	.SEG	data_s, 32BIT, SELECT=GS_DATA, DATA, READ, WRITE
	.MSECT	data_m, data_s, ADDR=DATASEGBASE
	.PSECT	data_p, data_m, MOD=4
	.ENDM

	.MACRO	CODE
	.SEG	code_s, 32BIT, SELECT=GS_CODE, CODE
	.MSECT	code_m, code_s, ADDR=1000h
	.PSECT	code_p, code_m, MOD=4
	.ENDM

	.MACRO	USERCODE
	.SEG	usercode_s, 32BIT, SELECT=GS_USERCODE, CODE
	.MSECT	usercode_m, usercode_s, ADDR=1000h
	.PSECT	usercode_p, usercode_m, MOD=4
	.ENDM

	.MACRO	VUSERCODE
	.SEG	vusercode_s, 16BIT, SELECT=GS_VUSERCODE, CODE
	.MSECT	vusercode_m, vusercode_s, ADDR=0
	.PSECT	vusercode_p, vusercode_m, MOD=1000h
	.ENDM

	.MACRO	ONCE
	.SEG	once_s,  32BIT, SELECT=GS_CODE, CODE
	.MSECT	once_m,  once_s, ADDR=oocode
	.PSECT	oncep_p, once_m, MOD=4
	.ENDM

	.MACRO	INITSUB  label
	.SEG	once_s, 32BIT, SELECT=GS_CODE, CODE
	.MSECT	once_m, once_s, ADDR=oocode
	.PSECT	init_p, once_m, MOD=4
	CALL	label
	.PSECT	oncep_p, once_m, MOD=4
	.ENDM

	.MACRO	END
	DATA
	.MOD	4
	CODE
	.MOD	4
.IF NDF $$LKE
	USERCODE
	.MOD	4
.ENDC
	.ENDM

.IF NE $$BUGRING
	.MACRO	& BUGRING  code, value1, value2
	PUSHL	#'code'
	PUSHL	value1
	PUSHL	value2
	CALL	knlBugLog#
	.ENDM
.IFF
	.MACRO	BUGRING  code, value1, value2
	.ENDM
.ENDC

	.MACRO	& CRASH  code
	.NLIST
	INT	31t
	.LONG	'code'
	.LIST
	.ENDM

	.MACRO	IFFAULT  addr
	.NLIST
	.BYTE	0A9h
	.LONG	addr
	.LIST
	.ENDM

	.MACRO	IFFCALL  addr
	.NLIST
	.BYTE	3Dh
	.LONG	addr
	.LIST
	.ENDM

	.MACRO	FAULTHDR
	.NLIST
	.BYTE	90h
	.LIST
	.ENDM

	.MACRO	FAULTHDRX
	.NLIST
	.BYTE	0FEh
	.LIST
	.ENDM

	.MACRO	IBTL  addr, index, bit
.IF NB {index}
	BTL	{addr}+{{bit}/32t}*4[index], #{bit}&1Fh
.IFF
	BTL	{addr}+{{bit}/32t}*4, #{bit}&1Fh
.ENDC
	.ENDM

	.MACRO	IBTZL  addr, index, bit
.IF NB {index}
	BTZL	{addr}+{{bit}/32t}*4[index], #{bit}&1Fh
.IFF
	BTZL	{addr}+{{bit}/32t}*4, #{bit}&1Fh
.ENDC
	.ENDM

	.MACRO	IBTSL  addr, index, bit
.IF NB {index}
	BTSL	{addr}+{{bit}/32t}*4[index], #{bit}&1Fh
.IFF
	BTSL	{addr}+{{bit}/32t}*4, #{bit}&1Fh
.ENDC
	.ENDM

	.MACRO	TOFORK  addr
	.NLIST
	CMPB	knlForkLvl#, #FORK_MAIN
.IF NB {addr}
	JNE	addr
.IFF
	JE	$+8.S
	CRASH	TOFK
.ENDC
	MOVB	knlForkLvl#, #FORK_MFORK
	.LIST
	.ENDM

	.MACRO	FROMFORK
	.NLIST
.IF NDF FORKDEFS .EXTERN knlDsmFork
	CALL	knlDsmFork
	.LIST
	.ENDM

	.MACRO	REQUIREFORK
	.NLIST
	CMPB	knlForkLvl#, #FORK_MAIN
	JNE	$+8.S
	CRASH	NAFK
	.LIST
	.ENDM

	.MACRO	REQUIREMAIN
	.NLIST
	CMPB	knlForkLvl#, #FORK_MAIN
	JE	$+8.S
	CRASH	ATFK
	.LIST
	.ENDM

	.MACRO	REQUIREXFF
	.NLIST
	CMPB	knlForkLvl#, #FORK_XFF
	JNE	$+15t.S
	CMPL	SS:xffMagic#, #XFF_MAGIC
	JE	$+8.S
	CRASH	NAXF
	.LIST
	.ENDM

	.MACRO	UNIMOP  a1, a2, a3, a4
	MOVL	ECX, #{a1}+{a2}*100h+{a3}*10000h+{a4}*1000000h
	CALL	knlUnimOp#
	.ENDM

	.MACRO	SVCENTR  argcnt
	.NLIST
	PUSHAL
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHFL
	POPL	SS:pdaXRegEFR#
	PUSHL	#GS_DATA.B
	POPL	DS
	MOVB	SS:pdaArgCnt#, #argcnt
	PUSHL	#svcfin#
	.LIST
	.ENDM

	.MACRO	INTENTR
	.NLIST
	PUSHAL
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	MOVL	EAX, #GS_DATA
	MOVL	DS, EAX
	.LIST
	.ENDM

	.MACRO	& DEVCHAR  hdr, size, name
	.BYTE	hdr, size
$$$=$
	.ASCII	'name'
$=$$$+8
	.ENDM

	.MACRO	DCHARBGN num, resetsub
	.NLIST
$$$dcx=!num
	.IRP	q, >$$$dcx
	.LONG	$$$dcanum''q, 0, 0
	.LONG	resetsub
$$$dcanum''q =!0
	.ENDR
	.LIST
	.ENDM

	.MACRO	DCHARENT name, rep, flags, size, info, get, set, data
	.NLIST
	.BYTE	REP_'rep
.IF IDN {flags}{H}
	.BYTE	DCTF$HIDDEN
.IFF
	.BYTE	0
.ENDC
	.RADIX	10t
	.WORD	size
	.RADIX	16t
$$$=!$
	.ASCII	"name"
$=$$$+8
	.LONG	set, get, data, info
	.IRP	q, >$$$dcx
$$$dcanum''q=!$$$dcanum''q+1
	.ENDR
	.LIST
	.ENDM

	.MACRO	DCHARI table
	.NLIST
	.BYTE	0
.IF IDN {flags}{H}
	.BYTE	DCTF$INDIR|DCTF$HIDDEN
.IFF
	.BYTE	DCTF$INDIR
.ENDC
	.WORD	0
	.LONG	table, 0, 0, 0, 0, 0
	.IRP	q, >$$$dcx
$$$dcanum''q=!$$$dcanum''q+1
	.ENDR
	.LIST
	.ENDM

	.MACRO	DCHARH label, gethead, find
	.NLIST
label:	.BYTE	0
.IF IDN {flags}{H}
	.BYTE	DCTF$LNKHEAD|DCTF$HIDDEN
.IFF
	.BYTE	DCTF$LNKHEAD
.ENDC
	.WORD	0
	.LONG	gethead, find, 0, 0, 0, 0
	.IRP	q, >$$$dcx
$$$dcanum''q=!$$$dcanum''q+1
	.ENDR
	.LIST
	.ENDM

	.MACRO	DCHARINFO  text
	.NLIST
$$$=!0
	.IRPC	qq, {text}
   $$$=!$$$+1
	.ENDR
	.BYTE	$$$
	.ASCII	"text"
	.LIST
	.ENDM

	.MACRO	DPARMHDR  oper, rep
	.NLIST
$$$=!-1
.IF IDN {oper}{BOTH} $$$=!0
.IF IDN {oper}{GET}  $$$=!PAR$SET
.IF IDN {oper}{SET}  $$$=!PAR$GET
.IF EQ $$$+1   .ERROR  Illegal value for first parameter for DPARMHDR macro
	.BYTE	$$$|REP_'rep
	.LIST
	.ENDM

	.MACRO	XMBINDEX  label, size
	.NLIST
label=!0
.IF GT size-64t
 label=!1
 .IF GT size-128t
  label=!2
  .IF GT size-256t
   label=!3
   .IF GT size-512t
    label=!4
    .IF GT size-1024t
     label=!5
     .IF GT size-2048t
      label=!6
     .ENDC
    .ENDC
   .ENDC
  .ENDC
 .ENDC
.ENDC
	.LIST
	.ENDM

	.MACRO	IOPAUSE
	PUSH%	%AX
	INB	61h
	POP%	%AX
	.ENDM

	.MACRO	A2IOP  value
.IF GT value
 .IF EQ value-1
	INCL	EDX
 .IFF
  .IF LT value-128t
	ADDL	EDX, #value.B
  .IFF
	ADDL	EDX, #value
  .ENDC
 .ENDC
.ENDC
.IF LT value
 .IF EQ value+1
	DECL	EDX
 .IFF
  .IF GE value+128t
	ADDL	EDX, #value.B
  .IFF
	ADDL	EDX, #value
  .ENDC
 .ENDC
.ENDC
	.ENDM

