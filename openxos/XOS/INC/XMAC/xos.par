	.SBTTL	Parameter file XOS.PAR

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

;-------------------------------------------------------------------------------
;
;  XOS.PAR - User-mode include file for general parameters
;
;  Edit history:
;  -------------
;  18Apr95 (fpj) - Added edit history block.
;
;-------------------------------------------------------------------------------


	.NLBEX
.IF NDF DEFINES
	.NLIST
	.INCLUD	XOSINC:\XMAC\DEFINES.PAR
	.LIST
.ENDC
	.PARM

;Define general limit values

FILESPCSIZE=!256t	;Maximum length of a device or file specification

;Define some ASCII characters

EOT=!04h		;End of text
BEL=!07h		;Bell
BSP=!08h		;Backspace
HT =!09h		;Horizontal tab
LF =!0Ah		;Line feed
VT =!0Bh		;Vertical tab
FF =!0Ch		;Form feed
CR =!0Dh		;Carrage return
SFO=!0Eh		;Shift out
SFI=!0Fh		;Shift in
XON=!11h		;XON (^Q)
XOF=!13h		;XOF (^S)
SYN=!16h		;Sync
SUB=!1Ah		;SUB (used as EOF flag in files)
ESC=!1Bh		;ESC
SPA=!20h		;Space
LA =!3Ch		;Left angle
RA =!3Eh		;Right angle
LB =!7Bh		;Left brace
RB =!7Dh		;Right brace
DEL=!7Fh		;Delete (Rub-out)

;Define global selectors which user programs can use

GS_REAL16  =!53h	;Real mode "segment" as a 16 bit data segment
GS_REAL32  =!5Bh	;Real mode "segment" as a 32 bit data segment
GS_USERCODE=!00A0h	;Global user code segment
GS_VDOSDATA=!00B8h	;Segment which maps the DOS data area

;Define offset in the real mode data area

rmda_base =!0EC000h
rmda_stack=!0ECFE0h	;Real mode stack
rmda_rmESP=!0ECFF0h	;Current real mode stack pointer
rmda_rmSS =!0ECFF4h
rmda_pmESP=!0ECFF8h	;Current protedted mode stack pointer
rmda_pmSS =!0ECFFCh

;Define segment types and associated bits

ST$TOP      =!80000000h	;Search backwards to allocate segment

ST_32RODATA =!1t	;32 bit read only data segment
ST_32RWDATA =!2t	;32 bit read/write data segment
ST_32STACK  =!3t	;32 bit stack segment
ST_32NXOCODE=!4t	;32 bit execute only normal code segment
ST_32NXRCODE=!5t	;32 bit execute/read normal code segment
ST_32CXOCODE=!6t	;32 bit execute only conformable code segment
ST_32CXRCODE=!7t	;32 bit execute/read conformable code segment
ST_16RODATA =!9t	;16 bit read only data segment
ST_16RWDATA =!10t	;16 bit read/write data segment
ST_16STACK  =!11t	;16 bit stack segment
ST_16NXOCODE=!12t	;16 bit execute only normal code segment
ST_16NXRCODE=!13t	;16 bit execute/read normal code segment
ST_16CXOCODE=!14t	;16 bit execute only conformable code segment
ST_16CXRCODE=!15t	;16 bit execute/read conformable code segment
ST_MAX      =!15t

;Define page type bits

PG$DNCVIR =!10h		;Do not change virtual status (PG$VIRTUAL is ignored)
  PG%DNCVIR =!4t
PG$VIRTUAL=!08h		;Virtual page
  PG%VIRTUAL=!3t
PG$EXECUTE=!04h		;Executable page (not supported)
  PG%EXECUTE=!2t
PG$WRITE  =!02h		;Writable page
  PG%WRITE  =!1t
PG$READ   =!01h		;Readable (always set)
  PG%READ   =!0t

;Define termination codes (positive values indicate process has been stopped,
;  negative values indicate process has been killed)

TC_EXIT   =!1t		;Normal exit
TC_KILL   =!2t		;Killed
TC_PIPE   =!3t		;No input available from pipe
TC_NOVECT =!4t		;No user vector setup for condition
TC_BDUSTK =!5t		;Bad user stack address
TC_NOMEM  =!6t		;No memory available
TC_UNIMOP =!7t		;Unimplemented operation
TC_RUNFAIL=!8t		;RUN failure
TC_SUBTSK =!11t		;Sub-task error
TC_MEMCRPD=!12t		;DOS memory allocation data corrupted
TC_DPMI   =!13t		;Fatal DPMI error
TC_NODOS  =!14t		;DOS environment not set up
TC_DOSBADE=!15t		;Invalid error code returned for DOS function
TC_ACCT   =!16t		;Accounting violation

;Define software interrupt numbers

;Vectors 000h through 0FFh are protected mode INTs

;Vectors 100h through 11Fh are protected mode processor traps

VECT_PDIVERR =!100h	;Divide error
VECT_PDEBUG  =!101h	;Debug trap
VECT_PNMI    =!102h	;Non-maskable interrupt
VECT_PBRKPNT =!103h	;Breakpoint
VECT_PINTO   =!104h	;INTO instruction trap
VECT_PBOUND  =!105h	;BOUND instruction trap
VECT_PILLINS =!106h	;Illegal instruction trap
VECT_PFPPNAVL=!107h	;Floating pointer processor not available trap
VECT_PDBLEXP =!108h	;Double exception
VECT_PFPPSOVR=!109h	;Floating point processor segment overrun
VECT_PITSS   =!10Ah	;Invalid task state segment
VECT_PSEGNP  =!10Bh	;Segment not present
VECT_PSTKERR =!10Ch	;Stack error
VECT_PPROT   =!10Dh	;Memory protection error
VECT_PPAGEFLT=!10Eh	;Page fault

VECT_PFPUERR =!110h	;Floating point processor error
VECT_PALNCHK =!111h	;Alignment check

;Vectors 120h through 13Fh are real mode processor traps

VECT_RDIVERR =!120h	;Divide error
VECT_RDEBUG  =!121h	;Debug trap
VECT_RNMI    =!122h	;Non-maskable interrupt
VECT_RBRKPNT =!123h	;Breakpoint
VECT_RINTO   =!124h	;INTO instruction trap
VECT_RBOUND  =!125h	;BOUND instruction trap
VECT_RILLINS =!126h	;Illegal instruction trap
VECT_RFPPNAVL=!127h	;Processor extension not available trap
VECT_RDBLEXP =!128h	;Double exception
VECT_RFPPSOVR=!129h	;Processor extension segment overrun
VECT_RITSS   =!12Ah	;Invalid task state segment
VECT_RSEGNP  =!12Bh	;Segment not present
VECT_RSTKERR =!12Ch	;Stack error
VECT_RPROT   =!12Dh	;Memory protection error
VECT_RPAGEFLT=!12Eh	;Page fault

VECT_RFPUERR =!130h	;Floating point error
VECT_RALNCHK =!131h	;Alignment check

;Vectors 140h through 15Fh are XOS traps

VECT_EXIT    =!140h	;Process termination trap
VECT_CHILD   =!141h	;Child died
VECT_CNTC    =!142h	;Control C
VECT_CNTP    =!143h	;Control P
VECT_HNGUP   =!144h	;Controlling terminal hung up

;Vectors 160h through 1FFh are reserved

;Vectors 200h through 2FFh are real mode INTs

;Define vector type values

VT_NONE   =!0t		;None
VT_XOSS   =!1t		;XOS signal vector
VT_XOST   =!2t		;XOS trap vector
VT_HWS16  =!3t		;16-bit hardware signal vector
VT_HWS32  =!4t		;32-bit hardware signal vector
VT_HWT16  =!5t		;16-bit hardware trap vector
VT_HWT32  =!6t		;32-bit hardware trap vector
VT_DPMI16O=!7t		;DPMI v0.9 16-bit CPU exception vector
VT_DPMI32O=!8t		;DPMI v0.9 32-bit CPU exception vector
VT_DPMI16N=!9t		;DPMI v1.0 16-bit CPU exception vector
VT_DPMI32N=!10t		;DPMI v1.0 32-bit CPU exception vector

;Define offsets in the buffer filled in by the UF_GTCFG svcUtility function

cf_totmem=!0t		;(4) Total memory in system (pages)
cf_avlmem=!4t		;(4) Available memory in system (pages)
cf_hrddsk=!8t		;(2) Number of hard disk units
cf_flpdsk=!10t		;(2) Number of floppy disk units
cf_serprt=!12t		;(2) Number of serial ports
cf_parprt=!14t		;(2) Number of parallel ports
cf_SIZE  =!16t

;Define standard device handles

DH_STDIN =!1t		;Standard input device
DH_STDOUT=!2t		;Standard output device
DH_STDERR=!3t		;Standard error output device
DH_STDPRN=!4t		;Standard listing output device
DH_STDTRM=!5t		;Controlling terminal for session (cannot be redirected)
DH_FV    =!6t		;First variable device handle

;Define offsets in the block which specifies a device characteristics value

dcv_type   =!0t		;(1) Description byte
dcv_vallen =!1t		;(1) Length of value field
dcv_name   =!2t		;(8) Name
dcv_infopnt=!10t	;(8) Address of information buffer
dcv_ibfrlen=!18t	;(2) Size of the information buffer
dcv_istrlen=!20t	;(2) Length of the information string
			;Note:  Following offsets are defined assuming that no
			;	information pointer is present - if there is an
			;	information pointer, add 12t to each offset
dcv_value  =!10t	;(8) Numeric value or address of string value buffer
dcv_vbfrlen=!18t	;(2) Size of the string value buffer
dcv_vstrlen=!20t	;(2) Length of the returned string value
dcv_SIZE   =!22t	;Total size of a long string value entry

;Define offsets in the block which specifies an add unit characteristics value

aucv_type  =!0t		;(1) Description byte
aucv_name  =!1t		;(7) Name
aucv_value =!8t		;(8) Numeric value or address of string value buffer
aucv_valsz =!16t	;(2) Size of the string value buffer
aucv_vallen=!18t	;(2) Length of the returned string value

;Define offsets in the queued IO functions argument block

qab_func   =!0t		;(2) Function
qab_status =!2t		;(2) Returned status
qab_error  =!4t		;(4) Error code (returned by all functions)
qab_amount =!8t		;(4) Amount transfered or items processed
qab_handle =!12t	;(4) Device handle (returned by open, used by all
			;      others)
qab_vector =!16t	;(2) Vector for interrupt
qab_level  =!18t	;(1) Signal level for direct IO wait (if QFNC$LEVEL set)
qab_prevlvl=!19t	;(1) Previous signal level (internal XOS use only)
qab_option =!20t	;(4) Options or command
qab_count  =!24t	;(4) Count for transfer
qab_buffer1=!28t	;(8) Address of first data buffer
qab_buffer2=!36t	;(8) Address of second data buffer
qab_parm   =!44t	;(8) Address of parameter area
qab_SIZE   =!52t

;Define values for qab_func for the svcIoQueue system service

QFNC$WAIT     =!8000h	;Wait until function is complete
  QFNC%WAIT     =!15t
QFNC$DIO      =!4000h	;Direct IO (not queued)
  QFNC%DIO      =!14t
QFNC$LEVEL    =!2000h	;Set signal level from qab_level when waiting for direct
  QFNC%LEVEL    =!13t	;  IO
QFNC$CONT     =!1000h	;Continued operation (internal use only, should never
  QFNC%CONT     =!12t	;  be set by the user)
QFNC$INTD     =!0800h	;Interrupt data (output functions only, exact meaning
  QFNC%INTD     =!11t	;  is device dependent)
QFNC$OOBD     =!0400h	;Out-of-band data (exact meaning is device dependent)
  QFNC%OOBD     =!10t
QFNC$POLL     =!0200h	;Poll (output functions for half-duplex devices only)
  QFNC%POLL     =!9t

QFNC_OPEN     =!1t	;Open device/file
QFNC_DEVPARM  =!2t	;Device parameter function

QFNC_DEVCHAR  =!4t	;Device characteristics
QFNC_DELETE   =!5t	;Delete file
QFNC_RENAME   =!6t	;Rename file

QFNC_PATH     =!8t	;Path functions
QFNC_CLASSFUNC=!9t	;Class functions

QFNC_INBLOCK  =!12t	;Input block

QFNC_OUTBLOCK =!14t	;Output block
QFNC_OUTSTRING=!15t	;Output string

QFNC_TRMFUNC  =!17t	;Terminal functions

QFNC_SPECIAL  =!19t	;Special device functions
QFNC_LABEL    =!20t	;Get device label
QFNC_COMMIT   =!21t	;Commit data
QFNC_CLOSE    =!22t	;Close file

;Define values for qab_func for the svcIoRun system service

RFNC$WAIT     =!8000h	;Wait until function is complete
  RFNC%WAIT     =!15t
RFNC_RUN      =!1t	;Run program
RFNC_LOAD     =!2t	;Load overlay

;Define bits used in qab_status

QSTS$DONE  =!8000h	;Operation is complete
  QSTS%DONE  =!15t
QSTS$ACTIVE=!4000h	;Operation is active
  QSTS%ACTIVE=!14t
QSTS$WAIT  =!2000h	;Should wait for device (XOS internal use)
  QSTS%WAIT  =!13t
QSTS$REDO  =!1000h	;Operation should be re-done (XOS internal use)
  QSTS%REDO  =!12t
QSTS$FINAL =!0020h	;Final input
  QSTS%FINAL =!5t
QSTS$INTD  =!0010h	;Interrupt input data
  QSTS%INTD  =!4t
QSTS$OOBD  =!0008h	;Out-of-band input data
  QSTS%OOBD  =!3t
QSTS$CANCEL=!0004h	;Operation canceled before started
  QSTS%CANCEL=!2t
QSTS$ABORT =!0002h	;Operation aborted
  QSTS%ABORT =!1t
QSTS$TRUNC =!0001h	;Data truncated
  QSTS%TRUNC =!0t

;Each parameter consists of a two byte header followed by a 0 to 32 byte value

;Define values for the first parameter header byte - this byte specifies the
;  format of the parameter value and also contains the system's error
;  indication - these values also apply for the first device characteristics
;  header byte

PAR$SET    =!80h	;Set (use) value of this parameter
PAR$GET    =!40h	;Get (return) value of this parameter
			;  Both PAR$SET and PAR$GET clear indicates the end
			;  of the parameter list
PAR$ERROR  =!20h	;Error in this parameter
PAR$INFO   =!10h	;Return parameter information
PAR$REP    =!0Fh	;Value representation
  REP_DECV   =!1t	;  Decimal value
  REP_HEXV   =!2t	;  Hex value
  REP_OCTV   =!3t	;  Octal value
  REP_BINV   =!4t	;  Binary value
  REP_DECB   =!5t	;  Decimal bytes
  REP_HEXB   =!6t	;  Hex bytes
  REP_OCTB   =!7t	;  Octal bytes
  REP_VERN   =!8t	;  Version number
  REP_TIME   =!9t	;  Time value
  REP_DATE   =!10t	;  Date value
  REP_DT     =!11t	;  Date/time value
  REP_DATAB  =!12t	;  Data bytes
  REP_DATAS  =!13t	;  Data string
  REP_TEXT   =!14t	;  Text bytes
  REP_STR    =!15t	;  String value

;The second header byte specifies the length of the value in the parameter list
;  in bytes - a value of 0FFh initicates a long string value (8 byte pointer
;  followed by 2 byte buffer length and 2 byte string length - buffer length is
;  used by system, string length field set by system if IOPAR$GET specified

SIZE_LNGSTR=!0FFh	;Long string value

;Define values for the 3rd and 4th parameter header bytes - these byte specify
;  the parameter being set or obtained - values below 8000h are common to all
;  devices, values above 128t are device dependent and may only be used
;  following a IOPAR_CLASS parameter with PAR$SET set which specifies the
;  actual device class (this is intended to make sure that the intended
;  function is really done!)

IOPAR_GENBASE    =!0000h
IOPAR_FILOPTN    =!0001h	; s4  File option bits
IOPAR_FILSPEC    =!0002h	;g S  File specification string
IOPAR_DEVSTS     =!0003h	;g 4  Device status
IOPAR_UNITNUM    =!0004h	;g 4  Unit number
IOPAR_GLBID      =!0005h	;g 16 Global device ID
IOPAR_DELAY      =!0006h	; s4  IO delay value (fractional days)
IOPAR_TIMEOUT    =!0007h	; s4  IO time-out value (fractional days)
IOPAR_INPSTS     =!0008h	;g 1  Device input ready status
IOPAR_OUTSTS     =!0009h	;g 1  Device output ready status
IOPAR_INPQLMT    =!000Ah	;gs1  Input queue limit
IOPAR_OUTQLMT    =!000Bh	;gs1  Output queue limit
IOPAR_SIGVECT1   =!000Ch	;gs1  First signal vector
IOPAR_SIGVECT2   =!000Dh	;gs1  Second signal vector
IOPAR_SIGDATA    =!000Eh	;gs4  Signal data
IOPAR_NUMOPEN    =!000Fh	;g 2  Number of times device is open
IOPAR_BUFRLMT    =!0010h	;gs2  Internal buffering limit

;Define file system IO parameters

IOPAR_FILBASE    =!0100h
IOPAR_DIRHNDL    =!0101h	; s2  Directory handle for search
IOPAR_SRCATTR    =!0102h	; s2  File attributes for search
IOPAR_FILATTR    =!0103h	;gs2  File attributes
IOPAR_DIROFS     =!0104h	;gs4  Directory offset for search
IOPAR_ABSPOS     =!0105h	;gs4  Absolute pos. in file
IOPAR_RELPOS     =!0106h	;gs4  Relative pos. in file (returns abs.)
IOPAR_EOFPOS     =!0107h	;gs4  Pos. in file rel. to EOF (returns abs.)
IOPAR_VBOF       =!0108h	;gs4  Virtual beginning of file position
IOPAR_LENGTH     =!0109h	;gs4  Written length of file (bytes)
IOPAR_REQALLOC   =!010Ah	;gs4  Request file space allocation (bytes)
IOPAR_RQRALLOC   =!010Bh	;gs4  Require file space allocation (bytes)
IOPAR_GRPSIZE    =!010Ch	;gs4  Allocation group size (bytes)
IOPAR_ADATE      =!010Dh	;gs8  Last access date/time
IOPAR_CDATE      =!010Eh	;gs8  Creation date/time
IOPAR_MDATE      =!010Fh	;gs8  Modify date/time
IOPAR_PROT       =!0110h	;gs4  File protection
IOPAR_OWNER      =!0111h	;gsS  Owner name
IOPAR_USER       =!0112h	;gsS  User name for access
IOPAR_SETLOCK    =!0113h	;gs8  Set file lock
IOPAR_CLRLOCK    =!0114h	;gs8  Clear file lock
IOPAR_CLSTIME    =!0115h	;gs4  Close time value
IOPAR_CLSNAME    =!0116h	; sS  Close name
IOPAR_CLSMSG     =!0117h	; s16 Close message destination
IOPAR_SHRPARMS   =!0118h	;gs4  DOS file sharing parameter values
IOPAR_ACSNETWK   =!0119h	; s0  Use network access field

;Define terminal IO parameters

IOPAR_TRMBASE    =!0200h
IOPAR_TRMSINPMODE=!0201h	;gs4  Set input modes
IOPAR_TRMCINPMODE=!0202h	;gs4  Clear input modes
IOPAR_TRMSOUTMODE=!0203h	;gs4  Set output modes
IOPAR_TRMCOUTMODE=!0204h	;gs4  Clear output modes
IOPAR_TRMBFRLIMIT=!0205h	; s4  Input buffer limit value
IOPAR_TRMCLRBUFR =!0206h	; s1  Clear buffer(s)
IOPAR_TRMCURTYPE =!0207h	;gs2  Cursor type
IOPAR_TRMCURPOS  =!0208h	;gs4  Cursor position
IOPAR_TRMDISPAGE =!0209h	;gs1  Display page
IOPAR_TRMSPSTATUS=!020Ah	;g 2  Serial port status
IOPAR_TRMSPBREAK =!020Bh	;gs1  Break control
IOPAR_TRMSPMODEM =!020Ch	; s1  Modem control
IOPAR_TRMSETDFC  =!020Dh
IOPAR_TRMCLRDFC  =!020Eh
IOPAR_TRMLSTDFC  =!020Fh
IOPAR_TRMALLDFC  =!0210h
IOPAR_TRMCCVECT  =!0211h	;gs2  Control-C signal vector
IOPAR_TRMCCDATA  =!0212h	;gs2  Control-C signal data
IOPAR_TRMCPVECT  =!0213h	;gs2  Control-P signal vector
IOPAR_TRMCPDATA  =!0214h	;gs2  Control-P signal data
IOPAR_TRMHUVECT  =!0215h	;gs2  Hang-up signal vector
IOPAR_TRMHUDATA  =!0216h	;gs2  Hang-up signal data

;Define disk IO parameters

IOPAR_DSKBASE    =!0300h
IOPAR_DSKFSTYPE  =!0301h	;g 1  File system type
IOPAR_DSKSECTSIZE=!0302h	;g 2  Sector size
IOPAR_DSKCLSSIZE =!0303h	;g 1  Cluster size
IOPAR_DSKTTLSPACE=!0304h	;g 4  Total space (in clusters)
IOPAR_DSKAVLSPACE=!0305h	;g 4  Available space (in clusters)
IOPAR_DSKNUMHEAD =!0306h	;g 1  Number of heads
IOPAR_DSKNUMSECT =!0307h	;g 1  Number of sectors
IOPAR_DSKNUMCYLN =!0308h	;g 1  Number of cylinders
IOPAR_DSKBLOCK   =!0309h	;g 4  Get last disk block accessed

;Define tape IO parameters

IOPAR_TAPBASE    =!0400h
IOPAR_TAPRECMIN  =!0401h	;g 4  Minimum record length
IOPAR_TAPRECMAX  =!0402h	;g 4  Maximum record length
IOPAR_TAPRECLEN  =!0403h	;gs4  Current fixed record length
IOPAR_TAPDENSITY =!0404h	;gs4  Tape density
IOPAR_TAPGAPLEN  =!0405h	;gs1  Gap length
IOPAR_TAPBFRMODE =!0406h	;gs1  Buffering mode

;Define network IO parameters

IOPAR_NETBASE    =!0500h
IOPAR_NETSUBUMASK=!0501h	;g 4  Sub-unit bit mask
IOPAR_NETPROTOCOL=!0502h	;gs2  Protocol
IOPAR_NETLCLPORT =!0503h	;gs2  Local port number
IOPAR_NETRMTHWAS =!0504h	;gs8  Remote hardware address (send)
IOPAR_NETRMTHWAR =!0505h	;g 8  Remote hardware address (receive)
IOPAR_NETRMTNETAS=!0506h	;gs4  Remote network address (send)
IOPAR_NETRMTNETAR=!0507h	;g 4  Remote network address (receive)
IOPAR_NETRMTPORTS=!0508h	;gs2  Remote port number (send)
IOPAR_NETRMTPORTR=!0509h	;g 2  Remote port number (receive)
IOPAR_NETDSTNAME =!050Ah	;gsS  Destination name
IOPAR_NETSMODE   =!050Bh	;gs4  Set network mode bits
IOPAR_NETCMODE   =!050Ch	;gs4  Clear network mode bits
IOPAR_NETRCVWIN  =!050Dh	;gs4  Receive window size
IOPAR_NETLCLNETA =!050Eh	;g 4  Local network address
IOPAR_NETKATIME  =!050Fh	;gs1  Keep-alive time interval (seconds)
IOPAR_NETCONLIMIT=!0510h	;gs4  Incoming connection queue limit
IOPAR_NETCONHNDL =!0511h	;gs4  Incoming connection handle

;Define IPM IO parameters

IOPAR_IPMBASE    =!0600h
IOPAR_IPMRMTPID  =!0601h	;g 4  IPM remote PID

;Define message IO parameters

IOPAR_MSGBASE    =!0700h
IOPAR_MSGLCLADDR =!0701h	;g S  Message local address
IOPAR_MSGRMTADDRS=!0702h	;gsS  Message remote address (send)
IOPAR_MSGRMTADDRR=!0703h	;g S  Message remote address (receive)

;Define RUN function IO parameters

IOPAR_RUNBASE    =!1000h
IOPAR_RUNCMDTAIL =!1001h	; sS  Command tail (argument list)
IOPAR_RUNDEVLIST =!1002h	; sS  Device list
IOPAR_RUNENVLIST =!1003h	; sS  Additional environment data
IOPAR_RUNDEBUGBFR=!1004h	;g S  Buffer for debug data
IOPAR_RUNADDRESS =!1005h	;gs8  Load address
IOPAR_RUNRELOCVAL=!1006h	;gs4  Relocation value
IOPAR_RUNFCB1    =!1007h	; sS  First DOS FCB
IOPAR_RUNFCB2    =!1008h	; sS  Second DOS FCB
IOPAR_RUNACTPRIV =!1009h	; sS  Active privileges for child
IOPAR_RUNAVLPRIV =!100Ah	; sS  Available privileges for child

IOPAR_RUNWSLIMIT =!100Ch	; s4  Working set size limit for child
IOPAR_RUNWSALLOW =!100Dh	; s4  Working set size allowed for child
IOPAR_RUNTMLIMIT =!100Eh	; s4  Total user memory limit for child
IOPAR_RUNTMALLOW =!100Fh	; s4  Total user memory allowed for child
IOPAR_RUNPMLIMIT =!1010h	; s4  Protected mode memory limit for child
IOPAR_RUNPMALLOW =!1011h	; s4  Protected mode memory allowed for child
IOPAR_RUNRMLIMIT =!1012h	; s4  Real mode memory limit for child
IOPAR_RUNRMALLOW =!1013h	; s4  real mode memory allowed for child
IOPAR_RUNOMLIMIT =!1014h	; s4  Overhead memory limit for child
IOPAR_RUNOMALLOW =!1015h	; s4  Overhead memory allowed for child

IOPAR_CLASS      =!8000h	;gs4  Device class

;Define bits in the IOPAR_CLRBUFR value

CB$OUTPUT =!40h		;Clear output buffer
CB$INPUT  =!20h		;Clear current input buffer
CB$AHEAD  =!10h		;Clear type-ahead buffer

;Define bits in the IOPAR_FILOPTN value

FO$NOPREFIX=!80000000h	;Do not return prefix codes
  FO%NOPREFIX=!31t
FO$PHYNAME =!00800000h	;Return physical device name even if rooted logical
  FO%PHYNAME =!23t	;  given
FO$DOSNAME =!00400000h	;Return DOS disk name
  FO%DOSNAME =!22t
FO$VOLNAME =!00200000h	;Return disk volume name 
  FO%VOLNAME =!21t
FO$XOSNAME =!00100000h	;Return XOS device name
  FO%XOSNAME =!20t
FO$NODENUM =!00080000h	;Return node number
  FO%NODENUM =!19t
FO$NODENAME=!00040000h	;Return network node name
  FO%NODENAME=!18t
FO$NODEPORT=!00020000h	;Return node port number
  FO%NODEPORT=!17t
FO$RPHYNAME=!00008000h	;Return remote physical device name even if rooted
  FO%RPHYNAME=!15t	;  remote logical referenced
FO$RDOSNAME=!00004000h	;Return remote DOS disk name
  FO%RDOSNAME=!14t
FO$RVOLNAME=!00002000h	;Return remote disk volume name
  FO%RVOLNAME=!13t
FO$RXOSNAME=!00001000h	;Return remote XOS device name
  FO%RXOSNAME=!12t
FO$PATHNAME=!00000800h	;Return file path
  FO%PATHNAME=!11t
FO$PATHDOS =!00000400h	;Return file path as short name (DOS 8x3 name)
  FO%PATHDOS =!10t
FO$FILENAME=!00000200h	;Return file name
  FO%FILENAME=!9t
FO$FILEDOS =!00000100h	;Return short file name (DOS 8x3 name)
  FO%FILEDOS =!8t
FO$VERSION =!00000080h	;Return file version number
  FO%VERSION =!7t
FO$ATTR    =!00000040h	;Return file attribute byte
  FO%ATTR    =!6t

;Define values for the prefix bytes in the IOPAR_FILSPEC string

FS_MIN      =!0E0h	;Minimum special value
FS_DOSNAME  =!0E1h	;DOS disk name is next
FS_VOLNAME  =!0E2h	;Disk volume name is next
FS_XOSNAME  =!0E3h	;XOS device name is next
FS_NODENUM  =!0E4h	;Network remote node number is next
FS_NODENAME =!0E5h	;Network remote node name is next
FS_NODEPORT =!0E6h	;Network remote port number is next
FS_RDOSNAME =!0E9h	;Remote DOS disk name is next
FS_RVOLNAME =!0EAh	;Remote disk volume name is next
FS_RXOSNAME =!0EBh	;Remote XOS disk name is next
FS_PATHNAME =!0F0h	;Path is next
FS_PATHDOS  =!0F1h	;Short path name (DOS 8x3 name)
FS_FILENAME =!0F2h	;File name is next
FS_FILEDOS  =!0F3h	;Short file name (DOS 8x3 name)
FS_VERSION  =!0F4h	;File version number is next
FS_ATTR     =!0F5h	;File attribute byte is next
FS_NPATHNAME=!0F8h	;Path for new specification is next (rename)
FS_NPATHDOS =!0F9h	;Short path for new specification (DOS 8x3 names)
FS_NFILENAME=!0FAh	;New file name is next (includes extension) (rename)
FS_NFILEDOS =!0FBh	;New short file name (DOS 8x3 name) (rename)
FS_NVERSION =!0FCh	;New file version number is next (rename)
FS_TRUNC    =!0FEh	;Entry has been truncated
FS_ESC      =!0FFh	;Escape

;Define bits for the IOPAR_DEVSTS device parameter value (these bits are stored
;  in dcb_dsp) 

DS$CASESEN=!00080000h	;File names are case sensitive
  DS%CASESEN=!19t
DS$ALIAS  =!00040000h	;File structure supports DOS 8x3 file name aliases
  DS%ALIAS  =!18t
DS$NAMEEXT=!00020000h	;File structure uses name.ext format
  DS%NAMEEXT=!17t
DS$LCLDISK=!00010000h	;Device is a local disk
  DS%LCLDISK=!16t
DS$SPOOL  =!00008000h	;Device is spooled
  DS%SPOOL  =!15t
DS$CONTROL=!00004000h	;Device is controlling terminal for session
  DS%CONTROL=!14t
DS$NOABORT=!00002000h	;Device cannot be aborted
  DS%NOABORT=!13t
DS$UNBFRD =!00001000h	;Device should be unbuffered
  DS%UNBFRD =!12t
DS$DUPLEX =!00000800h	;Device is full duplex (simultanious input and output)
  DS%DUPLEX =!11t
DS$MAPPED =!00000400h	;Memory mapped device
  DS%MAPPED =!10t
DS$MLTUSER=!00000200h	;Multi-user device (any process can open device, even
  DS%MLTUSER=!9t	;  if device is already open)
DS$REMOTE =!00000100h	;Device is remote
  DS%REMOTE =!8t
DS$FILE   =!00000080h	;Device is file structured
  DS%FILE   =!7t
DS$SODIR  =!00000040h	;Device supports search open directory operation
  DS%SODIR  =!6t
DS$PHYS   =!00000020h	;Physical device
  DS%PHYS   =!5t
DS$REMOVE =!00000010h	;Removeable media device
  DS%REMOVE =!4t
DS$DOUT   =!00000008h	;Device can do direct output
  DS%OUT    =!3t
DS$DIN    =!00000004h	;Device can do direct input
  DS%IN     =!2t
DS$QOUT   =!00000002h	;Device can do queued output
  DS%QOUT   =!1t
DS$QIN    =!00000001h	;Device can do queued input
  DS%QIN    =!0t

;Define bits for the IOPAR_USTS device parameter value

US$CHNGD=!8000h		;Disk media has been changed
  US%DCHG =!15t
US$MOUNT=!4000h		;Disk is mounted
  US%MOUNT=!14t
US$VALID=!2000h		;Disk contains valid data
  US%VALID=!13t
US$NOTF =!1000h		;Disk is not file structured
  US%NOTF =!12t
US$MEDIA=!0800h		;Media type is specified
  US%SNGLD=!11t
US$RECAL=!0400h		;Need to recalabrate
  US%SNGLD=!10t
US$HFTRK=!0200h		;Have 48 tpi disk in 96 tpi drive
  US%HFTRK=!9t
US$MOTON=!0100h		;Motor is on (floppy disk only)
  US%MOTON=!8t
US$TKDEN=!00C0h		;Track density
  TD_48TPI=!0t		;  48 tpi (also all hard disks)
  TD_96TPI=!1t		;  96 tpi
US$DBLS =!0020h		;Disk is double sided (floppy only)
  U2%DBLS =!2t
US$M8H  =!0020h		;Disk has more than 8 heads (hard disk only)
  U2%M8H  =!2t
US$DEN  =!0018h		;Data density
  DN_SD   =!0t		;  Single density (also all hard disks)
  DN_DD   =!1t		;  Double density
  DN_HD   =!2t		;  High density
US$RSIZE=!0007h		;Record size
  RS_UNKWN=!0t		;  Unknown
  RS_128  =!1t		;  128 byte records
  RS_256  =!2t		;  256 byte records
  RS_512  =!3t		;  512 byte records
  RS_1024 =!4t		;  1024 byte records

;Define functions for QFNC_DEVCHAR (stored in qab_option)

DCF_SIZE  =!1t		;Return size of complete characteristics array without
			;  info pointers
DCF_SIZEIP=!2t		;Return size of complete characteristics array with
			;  info pointers
DCF_ALL   =!3t		;Return name and type of all characteristics without
			;  info pointers
DCF_ALLIP =!4t		;Return name and type of all characteristics with info
			;  pointers
DCF_TYPE  =!5t		;Obtain type of single characteristic without info
			;  pointer
DCF_TYPEIP=!6t		;Obtain type of single characteristic with info pointer
DCF_VALUES=!7t		;Get or set characteristics values

;Define functions for QFNC_CLASSFUNC (stored in qab_option)

CF_SIZE   =!1t		;Return size of complete characteristics array without
			;  info pointers
CF_SIZEIP =!2t		;Return size of complete characteristics array with
			;  info pointers
CF_ALL    =!3t		;Return name and type of all characteristics without
			;  info pointers
CF_ALLIP  =!4t		;Return name and type of all characteristics with info
			;  pointers
CF_TYPE   =!5t		;Obtain type of single characteristic without info
			;  pointers
CF_TYPEIP =!6t		;Obtain type of single characteristic with info pointers
CF_VALUES =!7t		;Get or set characteristics values
CF_ADDUNIT=!8t		;Add unit
CF_PUNITS =!9t		;Get names of physical units
CF_AUNITS =!10t		;Get names of active units
CF_DEVSRCH=!11t		;Search for device given name

;Define command bits for qab_option for svcIoRun

R$SAMEPROC =!80000000h	;Use same process
  R%SAMEPROC =!31t
R$CHILDTERM=!40000000h	;Function is not complete until child process terminates
  R%CHILDTERM=!30t
R$SESSION  =!04000000h	;Create new session for child process
  R%SESSION  =!26t
R$DEBUG    =!02000000h	;Do debug load of program into same process
  R%DEBUG    =!25t
R$CPYENV   =!00800000h	;Copy current enviroment to new process
  R%CPYENV   =!23t
R$ACSENV   =!00400000h	;Allow new process to access this process's enviroment
  R%ACSENV   =!22t
R$CHGENV   =!00200000h	;Allow new process to change this process's enviroment
  R%CHGENV   =!21t
R$ALLDEV   =!00080000h	;Pass all devices to new process (device list is
  R%ALLDEV   =!19t	;  ignored)
R$CPYPTH   =!00040000h	;Copy default paths to new process
  R%CPYPTH   =!18t
R$CHGPTH   =!00020000h	;Allow new process to change this process's default
  R%CHGPTH   =!17t	;  paths
R$DOSEXEC  =!00000001h	;DOS EXEC function (XOS internal use only)
  R%DOSEXEC  =!0t

;Define offsets in the argument data msect

arg_filofs =!0t		;File specification offset
arg_fillen =!4t		;File specification length
arg_cmdofs =!8t		;Command data offset
arg_cmdlen =!12t	;Command data length
arg_filspec=!16t	;File specification

;Define offset in the spawn function argument block (SAB)

sab_func   =!0t 	;(2) Function
sab_status =!2t		;(2) Returned status
sab_error  =!4t		;(4) Returned error code
sab_pid    =!8t		;(4) Returned PID
sab_type   =!12t	;(1) Returned process type
			;(3) Reserved, must be 0
sab_vector =!16t	;(2) Vector number
sab_numseg =!18t	;(1) Number of segments to give to new process
			;(1) Reserved, must be 0
sab_option =!20t	;(4) Option bits
sab_name   =!24t	;(8) Address of name for new process
sab_EIP    =!32t	;(4) Initial EIP value for new process
sab_CS     =!36t	;(4) Initial CS value for new process
sab_EFR    =!40t	;(4) Initial EFR value for new process
sab_ESP    =!44t	;(4) Initial ESP value for new process
sab_SS     =!48t	;(4) Initial SS value for new process
sab_EAX    =!52t	;(4) Initial EAX value for new process
sab_EDI    =!56t	;(4) Initial EDI value for new process
sab_parm   =!60t	;(8) Address of parameter list
sab_srcsel =!68t	;(4) Selector for first segment to give to new process
sab_dstsel =!72t	;(4) Selector for first destination segment
sab_SIZE   =!76t

;Define values for sab_func

SFNC$WAIT  =!8000h	;Wait until function is complete
  SFNC%WAIT  =!15t
SFNC_CHILD =!1t		;Create child process

;Define values for sab_option

S$SESSION=!04000000h	;Create new session for child process
  S%SESSION=!26t
S$ALLDEV =!00080000h	;Pass all devices to new process (device list is
  S%ALLDEV =!19t	;  ignored)
S$SETUP  =!00000200h	;Place child process in set up mode
  S%SETUP  =!9t
S$NOCDS  =!00000100h	;Child process should not produce child died signal
  S%NOCDS  =!8t
S$EVENT  =!000000FFh	;Event number for termination (used if either S$SETUP
			;  or S$NOCDI is set)

;Define argument bits for svcIoCancel

CAN$WAIT  =!0100h	;Wait until finished
CAN$ALLDEV=!0080h	;Cancel all requests for all devices
CAN$ALL   =!0040h	;Cancel all requests for handle
CAN$AFTER =!0020h	;Cancel specified request and all following requests
CAN$NOINT =!0010h	;Suppress IO done interrupts
CAN$OPEN  =!0004h	;Cancel open request
CAN$OUTPUT=!0002h	;Cancel output queue requests
CAN$INPUT =!0001h	;Cancel input queue requests

;Define function bits for svcIoTransName

TNB$NOFINALBS=!20h	;Suppress final \ in directory names
TNB$SEMICOLON=!10h	;Use semi-colon instead of comma to seperate names
TNB$FLAG     =!08h	;Insert flag character before device names
TNB$VOLNAME  =!04h	;Return volume name if available
TNB$DOSNAME  =!02h	;Return DOS disk name if available
TNB$ALLDEF   =!01h	;Return all definitions

;Define protection set values

FP_NETWORK=!01000000h	;(N) Network users
FP_WORLD  =!00010000h	;(W) Local users not part of the owner's group (world)
FP_GROUP  =!00000100h	;(G) Members of the owner's group
FP_OWNER  =!00000001h	;(O) Owner of the file

;Define file protection bit values

FP$EXEC  =!10h		;(X) File is executable
FP$READ  =!08h		;(R) File is readable
FP$EXTEND=!04h		;(E) File can be extended
FP$WRITE =!02h		;(W) File is writable
FP$MODIFY=!01h		;(M) File attributes can be modified

;Define directory protection bit values

FP$ACCESS=!10h		;(A) Files in directory can be accessed
FP$SEARCH=!08h		;(S) Directory can be searched
FP$CREATE=!02h		;(C) Files can be created in directory
FP$MODIFY=!01h		;(M) Directory attributes can be modified

;Define function values for the svcMemDescSet call

SDF_BASE  =!1t		;Set segment base linear address
SDF_LIMIT =!2t		;Set segment limit
SDF_ACCESS=!3t		;Set access bits

;Define standard message types (this value is stored in the first byte of a
;  standard system message)

;Values 1 - 15 are reserved for general response messages

MT_INTRMDMSG=!1t	;Intermediate normal response
MT_INTRMDWRN=!2t	;Intermediate warning response
MT_INTRMDERR=!3t	;Intermediate error response
MT_INTRMDSTS=!4t	;Intermediate status (temp) response
MT_FINALMSG =!5t	;Final normal response
MT_FINALWRN =!6t	;Final warning response
MT_FINALERR =!7t	;Final error response

;Values 16 - 31 are reserved for requests to INIT

MT_SYMBREQ  =!16t	;Request to run symbiont
MT_TERMREQ  =!17t	;Request to change terminal state
MT_SYSLOG   =!18t	;Data for system log
MT_USERFILE =!19t
MT_TERMDATA =!20t	;Data from idle terminal

;Values 32 - 47 are reserved for requests to general servers

MT_SRVCMD   =!32t
MT_IPSDNS   =!40t	;Message to the IPS DNS server/resolver

;Values 48 - 63 are reserved for requests to or from the screen symbiont

MT_SSSTATUS =!48t	;Screen status report
MT_SSPAGEFLT=!49t	;Display page page fault
MT_SSREGPRG =!51t	;Register program to handle screen switching
MT_SSACTION =!52t	;Action request from program
MT_SSREPORT =!53t	;Report to program
MT_SSALMCHAR=!63t	;Alarm window character

;Values 64 - 79 are reserved for requests to the error logging symbiont

;Values 80 - 97 are reserved for requests to unspool symbionts

MT_UNSPLREADY=!80t	;File is ready to unspool
MT_UNSPLCMD  =!81t	;Command

;Values 88 - 95 are reserved for communications related requests

MT_NETLINK   =!88t	;Network link has changed state

;Values 96 - 99 are reserved for accounting and session control functions

MT_ACT      =!96t	;System accounting message
MT_UDF      =!97t	;UDF access requests (to or from UDFSRV)
MT_RELOGREQ =!98t	;Relogin request
MT_CRDTCARD =!99t	;Credit card requests (to or from CRDTSRV)

;Values 100 - 127 are reserved for additional system functions

;Values 128-255 are available for user defined functions

;Define command bits for qab_command for open type functions (note: The high
;  order 13 bits describe open actions, they are not saved once the device is
;  open.  The low order 19 bits are saved and describe how the device is used
;  while open.)

;The following 13 bits are not stored in the handle table - they are only used
;  when the device is initially opened

O$REPEAT  =!80000000h	;Repeated operation
  O%REPEAT  =!31t
O$REQFILE =!40000000h	;Require file structured device
  O%REQFILE =!30t
O$NOMOUNT =!20000000h	;Do not mount device if not mounted (ignored if O$RAW
  O%NOMOUNT =!29t	;  or O$PHYS not also set)
O$ODF     =!10000000h	;Open directory as file
  O%ODF     =!28t
O$FAILEX  =!08000000h	;Fail if file exists (has no efect if file does not
  O%FAILEX  =!27t	;  exist)
O$CREATE  =!04000000h	;Create new file if file does not exist (has no effect
  O%CREATE  =!26t	;  if file exists)
O$TRUNCA  =!02000000h	;Truncate existing file allocated length (has no effect
  O%TRUNCA  =!25t	;  if file does not exist)
O$TRUNCW  =!01000000h	;Truncate existing file written length (has no effect
  O%TRUNCW  =!24t	;  if file does not exist)
O$APPEND  =!00800000h	;Append to file
  O%APPEND  =!23t
O$FHANDLE =!00400000h	;Force handle (uses value of qab_handle to specify
  O%FHANDLE =!22t	;  handle, fails if handle not free)
O$UNQNAME =!00200000h	;Create unique name for file
  O%UNQNAME =!21t
O$USEDOS  =!00100000h	;Use DOS name when searching for directory/file
  O%USEDOS  =!20t
O$NOLONG  =!00080000h	;Do not use long name when searching for directory/file
  O%NOLONG  =!19t

;The following 2 bits are used internally by XOS and are stored in the
;  handle table

O$NOQUE   =!00040000h	;IO queueing is disabled
  O%NOQUE   =!18t
O$OPNCLS  =!00020000h	;Open or close is in progress (close if O$NOQUE is
  O%OPNCLS  =!17t	;  also set)

;The following bits are stored in the handle table and effect the operation
;  of a device for as long as it is open

O$NORDAH  =!00010000h	;Do not read ahead (do single sector transfers)
  O%NORDAH  =!16t
O$NODFWR  =!00008000h	;Do not defer writes
  O%NODFWR  =!15t
O$CONTIG  =!00004000h	;File allocation must be contiguous
  O%CONTIG  =!14t
O$CRIT    =!00002000h	;Do critical error processing
  O%CRIT    =!13t
O$FAPPEND =!00001000h	;Force append
  O%FAPPEND =!12t
O$NOREOPEN=!00000800h	;Do not re-open spooled device after close time-out
  O%NOREOPEN=!11t
O$PHYS    =!00000400h	;Physical IO (exact meaning depends on device!)
  O%PHYS    =!10t
O$RAW     =!00000200h	;Raw IO (exact meaning depends on device!)
  O%RAW     =!9t
O$FNR     =!00000100h	;Fail if device is not ready
  O%FNR     =!8t
O$PARTIAL =!00000080h	;Accept partial input
  O%PARTIAL =!7t
O$NOINH   =!00000040h	;Device cannot be passed to child
  O%NOINH   =!6t
O$XWRITE  =!00000020h	;Exclusive write access
  O%XWRITE  =!5t
O$XREAD   =!00000010h	;Exclusive read access
  O%XREAD   =!4t
O$COMPAT  =!00000008h	;DOS compatibility mode access
  O%COMPAT  =!3t

O$OUT     =!00000002h	;Output is allowed
  O%OUT     =!1t
O$IN      =!00000001h	;Input is allowed
  O%IN      =!0t

;Define file attribute bits

A$NORMAL=!80h		;Normal file
A$ARCH  =!20h		;Archive bit (set if file has been modified)
A$DIRECT=!10h		;Directory
A$LABEL =!08h		;Volume label
A$SYSTEM=!04h		;System file
A$HIDDEN=!02h		;Hidden file
A$RDONLY=!01h		;Read only file

;Define option bits for the close SVC

C$RESET   =!80000000h	;Reset file/device/connection
  C%RESET   =!31t
C$KILL    =!40000000h	;Kill file/device/connection
  C%KILL    =!30t
C$KEEPHNDL=!10000000h	;Keep handle
  C%KEEPHNDL=!28t
C$ONCEONLY=!00008000h	;Final once-only close
  C%ONCEONLY=!15t
C$DELETE  =!00000008h	;Delete file being closed
  C%DELETE  =!3t
C$NODEAL  =!00000001h	;Do not deallocate extra space in file
  C%NODEAL  =!0t

;Define bits for the svcSysFindEnv and svcSysDefEnv system calls

FES$SYSTEM =!0C000h	;Search system level
FES$SESSION=!08000h	;Specify search level relative to session
FES$PROCESS=!04000h	;Specify search level relative to process

;Define bits for the svcIoFndLog and svcIoDefLog system calls

FLN$SYSTEM =!0C000h	;Search system level
FLN$SESSION=!08000h	;Specify search level relative to session
FLN$PROCESS=!04000h	;Specify search level relative to process

TLN$SUBST  =!40000000h	;Substituted name
TLN$ROOTED =!20000000h	;Rooted name

;Define offsets in the structure used by the critical region system calls

$$$=!0
BLK lck_bits   , 1t	;Flag bits
BLK            , 1t	;Reserved
BLK lck_signal , 2t	;Signal number
BLK lck_timeout, 4t	;Time-out value
BLK lck_head   , 4t	;First process waiting
BLK lck_tail   , 4t	;Last process waiting

;Define bits for lck_bits

LCK$BUSY =!01h		;Critical region is busy
  LCK%BUSY = !0t


;Define macro to define the version number

	.MACRO	.VERS	NAME,V,E
	.RADIX	10t
	.IRP	$V,\V
	.IRP	$E,\E
	.ASCII	"'NAME - Version $V''.'''$E"
	.ENDR
	.ENDR
	.RADIX	16t
	.ENDM

;Define macro which generates first 10 bytes for a device characteristics table
;  entry

	.MACRO	DCHAR  name, func, rep, size
$$$=!-1
.IF IDN {func}{BOTH} $$$=!PAR$SET|PAR$GET
.IF IDN {func}{GET}  $$$=!PAR$GET
.IF IDN {func}{SET}  $$$=!PAR$SET
.IF EQ $$$+1   .ERROR  Illegal value for function for DCHAR macro

	.BYTE	$$$|REP_'rep
.IF IDN {size}{LNG}
	.BYTE	SIZE_LNGSTR
.IFF
	.BYTE	size
.ENDC
$$$=$
	.ASCII	"name"
$=$$$+8
	.ENDM
