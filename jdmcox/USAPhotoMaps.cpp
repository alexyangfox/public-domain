/*
C source code compiled with Microsoft's Visual C/C++ 6.0 (with the Feb 2003 MSDN library of API's)
http://jdmcox.com/USAPhotoMaps.rc
http://jdmcox.com/resource.h
http://jdmcox.com/ijl15.dll
http://jdmcox.com/ijl15.zip
http://jdmcox.com/zlib.zip

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
case WM_CREATE:
case WM_USER4:
case WM_USER3:
case WM_USER2:
case WM_USER:
case WM_COMMAND:
case ID_STOPPOSITIONING:
case ID_STOPDOWNLOADING:
case ID_FILE_DOWNLOADMAPDATA_FILLSCREEN:
case ID_FILE_DOWNLOADMAPDATA_1METERPIXELPHOTOS:
case ID_FILE_DOWNLOADMAPDATA_ENTERLATLON:
case ID_FILE_SHOWELEVATIONSQUARES:
case ID_FILE_CONVERTELEVATIONDATA:
case ID_FILE_DOWNLOADMAPDATA_TIGERSTREETS:
case ID_FILES_OPENMAPFILE:
case ID_FILES_NEWMAPFILE:
case ID_FILE_BOUNDARYFORBIGJPEG:
case ID_FILE_TERRAFETCHER_REGION:
case ID_FILES_PRINT:
case ID_FILE_RUNSTREETSTRIPS:
case ID_FILE_IMPORT_IMPORTSTPUSHPINS:
case ID_FILE_IMPORT_IMPORTFORERUNNERLOGBOOK:
case ID_FILE_IMPORT_IMPORTGPXTRACKS:
case ID_FILE_IMPORT_GEOCACHINGLOCFILES:
case ID_FILE_EXPORTTRACKSTOGPX:
case ID_FILE_EXPORT:
case ID_FILES_CLOSE:
case ID_VIEW_LATITUDELONGITUDE_DEGREES:
case ID_VIEW_MAPTYPE_PHOTO:
case ID_VIEW_BRIGHTNESS_BRIGHTER:
case ID_VIEW_GRID:
case ID_VIEW_CONTOURS:
case ID_VIEW_SHOWUSGSLANDMARKS:
case ID_VIEW_SHOWWAYPOINTNAMES:
case ID_VIEW_TIGERLINES_INTERSTATES:
case ID_VIEW_MAPOFUSA:
case ID_VIEW_BIGJPEG:
case ID_VIEW_OPTIONS_EVERYTHINGELSE:
case ID_GOTO_ADDRESS:
case ID_GOTO_TOWNSHIP:
case ID_GOTO_USGSLANDMARK:
case ID_GOTO_TIGERSTREET:
case ID_GOTO_LATLON:
case ID_ZOOM_1METERPIXEL:
case ID_TEXT_SHOWALL:
case ID_TEXT_LISTALL:
case ID_TEXT_ENTER:
case ID_ROUTE_SHOW:
case ID_ROUTE_CREATE:
case ID_ROUTETOTRACKS:
case ID_GPS_ROUTE_APPENDTOTRACKS:
case ID_WAYPOINTS_SHOW:
case ID_WAYPOINTS_OPENFILE:
case ID_GPS_HELP:
case ID_GPS_COMMPORT:
case ID_GPS_WAYPOINTS_UPLOAD:
case ID_GPS_WAYPOINTS_DOWNLOAD:
case ID_GPS_TRACKS_UPLOAD:
case ID_GPS_TRACKS_DOWNLOAD:
case ID_GPS_TRACKS_SHOW:
case ID_GPS_TRACKS_COMBINE:
case ID_GPS_ROUTES_SEND:
case ID_GPS_ROUTES_RECEIVE:
case ID_GPS_LOCATION_COPYPOSITION01CSVTOTRACKFORMAT:
case ID_GPS_LOCATION_DISPLAYPOSITION01CSV:
case ID_GPS_LOCATION_SHOWLOCATIONSPACEBAR:
case ID_APRS_RECEIVED_DATA:
case ID_APPROACHCONTROL_SANFRANCISCO:
case ID_HELP_PHOTOMAPHELP:
case ID_HELP_HTTP:
case ID_HELP_CHECKFORNEWERVERSION:
case ID_HELP_GETDATEOFPHOTOTOPO:
case ID_HELP_TIGERDATA:
case ID_HELP_TIGERCOUNTIES:
case ID_HELP_ABOUTPHOTOMAP:
case WM_USER_COMM:
case GOT_LAST_DLE:
case WM_MOUSEMOVE:
case WM_LBUTTONDOWN:
case WM_RBUTTONUP:
case WM_LBUTTONUP:
case WM_RBUTTONDOWN:
case WM_KEYUP:
case WM_KEYDOWN:
case VK_RIGHT:
case WM_PAINT:
case WM_CLOSE:
*/
#include <WinSock2.h>//put ws2_32.lib in Project/Settings/Link
#include <Windows.h>
#include <mmsystem.h>// for timeSetEvent add winmm.lib to Project -Settings -Link
#include <commctrl.h>//put comctl32.lib in Project/Settings/Link
#include "SetupAPI.h"//put setupapi.lib in Project/Settings/Link
#include <wininet.h>//put wininet.lib in Project/Settings/Link
#include <math.h>//for sqrt, etc
#include <stdio.h>//for sprintf
#include <process.h>//for _beginthreadex & select "multithreading" in Settings: C/C++ Category: Code Generation
#include "ijl.h"//put ijl15.lib in Project/Settings/Link
#include "zlib.h"//put zlib.lib and zdll.lib in Project/Settings/Link and zlib.dll and zlib1.dll in WINDOWS/System32
#include "zconf.h"
#include <wingdi.h>//put gdi32.lib and msimg32.lib in Project/Settings/Link
//#include "mmsystem.h"//for PlaySound - put winmm.lib in Project/Settings/Link
#include <devguid.h>
#include "resource.h"
//#include <malloc.h>//for _msize
#include <ddraw.h>//? and put ddraw.lib and dxguid.lib in Project/Settings/Link
// and use Microsoft DirectX 9.0 (February 2005) and point to it in Tools/Options/Directories

#define PI 3.141592653589793
#define MAX_TILE_SIZE 26000
#define MAX_IMAGE_SIZE 200*200*3
#define TOTAL_LOCS 5000
#define MAX_PTR 14400
#define AREA_SIZE 50
#define IDENT_COUNT 7
#define HUNDRED_MILES 100000
#define UP 1
#define DOWN 2
#define LEFT 3
#define RIGHT 4
#define WM_USER_COMM WM_USER + 1
#define	WM_USER2 WM_USER_COMM + 1
#define WM_USER3 WM_USER2 + 1
#define WM_USER4 WM_USER3 + 1
#define WM_USER6 WM_USER4 + 1
#define WM_USB WM_USER6 + 1
#define WM_USER8 WM_USB + 1
#define WM_APRS_COMM WM_USER8 + 1
#define WM_APRS_IS_COMM WM_APRS_COMM + 1
#define WM_APRS_SERVER WM_APRS_IS_COMM + 1
#define LINE_TO 213
#define EDIT 321
#define OK 211
#define EXIT 123
#define DELEET 312
#define URL_LINK 331
#define HELP 111
#define DEG 333
#define DEGMIN 112
#define DEGMINSEC 113
#define ITSUTM 221
#define ITSUSNG 332
#define DLE 16
#define ETX 3
#define ACK 6
#define NAK 21
#define GOT_FIRST_DLE 1
#define GOT_PID 2
#define GOT_DATASIZE 3
#define GOT_DATA 4
#define GOT_CHECKSUM 5
#define GOT_LAST_DLE 6
#define GOT_ETX 7
#define RECORDS 27
#define XFER_CMPLT 12
#define PVT_DATA 51
#define ROUTE_HEADER 29
#define ROUTE_DATA 30
#define ROUTE_LINK 98
#define TRACKHEADER 99
#define TRACK 34
#define WAYPOINT 35
#define ROUTEHEADER 29
#define ROUTE 30
#define ROUTELINK 98
#define NOBUTTON 99
#define LBUTTON 100
#define RBUTTON 101
#define MENU 102
#define FROMCOMM 60
#define WAYPOINT_SIZE 150
#define FROM_L 7123
#define FROM_T 7124
#define FROM_R 7125
#define FROM_B 7126
#define FROM_TL 7127
#define FROM_BL 7128
#define FROM_TR 7129
#define FROM_BR 7130
#define MAX_TEXT 60
#define GREEN 0xFF00
#define RED 0xFF
#define YELLOW 0xFFFF
#define WHITE 0xFFFFFF
#define LIGHTGRAY 0xE0E0E0
#define GETWAYPOINTS 601
#define GETTRACKS 602
#define SENDWAYPOINTS 603
#define SENDINGROUTES 606
#define BEGINRECORDS8 9001
#define BEGINRECORDS9 9002
#define SENDTRACKS 9004
#define STARTPVT 9005
#define SENDROUTE 9006
#define RECEIVEROUTE 9007
#define TAB 9
#define MEGABYTE 1024*1024
#define MILLION 1000000
#define HUNDREDTHOUSAND 100000
#define TENTHOUSAND 10000
#define THOUSAND 1000
#define HUNDRED 100
#define TEN 10
#define PHOTO 1
#define TOPO 2
#define URBANAREA 3
#define TRACKSDOWNLOAD 1
#define POSITION 2
#define WAYPOINTSDOWNLOAD 3
#define IOCTL_GARMIN_USB_BULK_OUT_PACKET_SIZE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x851, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GARMIN_USB_INTERRUPT_IN CTL_CODE(FILE_DEVICE_UNKNOWN, 0x850, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define USB_MAX_BUFFER_SIZE 4096
#define USB_INTERRUPT_DATA_SIZE 64
#define PACKETSIZE 200
#define GLL 1
#define GGA 2
#define RMC 3
#define MAX_DEMS 2000
#define ELEVBUF2SIZE 4*1024*1024
#define TIGERS 750000
#define MAXPTIGERS 100
#define MAXNAMEPTRS 16000
#define BUFSIZE 11000
#define SMALLBUFSIZE 50000
#define MAXAPRS 25600
#define FULL 1
#define HALF 2
#define QUARTER 3
#define EIGHTH 4
#define PORTRAIT 1
#define LANDSCAPE 2
#define GETSETPAPERORIENT 30
#define APRSFRAME 1
#define TYPE 2
#define ADDRESS 3
#define ADDEND 4
#define CONTROL 5
#define PROTOCOL 6
#define INFO 7
#define KISSEND 0
#define FEND 0xC0
#define FESC 0xDB
#define TFEND 0xDC
#define TFESC 0xDD
#define PRIMARY 1
#define SECONDARY 2
#define OVERLAY 3
#define BITMAPFILEHEADER_SIZE 14
#define XBITMAP 20
#define YBITMAP 20
#define HOMEINDEX 0
#define GPSINDEX 1
#define OBJECTINDEX 2
#define TRANSMITHOME 1
#define TRANSMITGPS 2
#define TRANSMITNONE 3
#define LOG108 log(1.08)
#define MAXOBJECTS 65
#define GRAVITY 9.80665 // meters / (second squared)
#define TIMER_RESOLUTION 1
#define MAXPLANES 25
#define MYWEBPAGESIZE 15000
//#define onetime0

//char Bug[] = "Bug.txt";

char Version[] = "Version 2.79\r\n\r\nMay 7, 2012\r\n\r\nby Doug Cox\r\n";

BOOL debug = FALSE, approachcontrol = FALSE;

//BOOL autodownload = TRUE;

int PacketSize;
BOOL dontcleanup = FALSE, ClearStationsFlag = FALSE;
char ToInternet[256];
char IgateInsert[] = ",qAR,";
char Quit[] = "QUIT\n";
char IgateErrorCaption[] = "Igate Error";

//COMMANDS: Hxxx Axxx Sxxx T (heading, altitude, speed, tower) then Enter
int AirportUTMEasting, AirportUTMNorthing, PlaneRadius = 7, AtPlane, command, existingIAS, finalIAS, existingTAS, existingAlt, finalAlt;
int RateOfDescent, RateOfSlowing, HeadingChange, CircleX, CircleY, CircleX2, CircleY2, MetersPerPixel, SpotX, SpotY, xUTM, yUTM, ThirtyMiles;
int cmd, Centerline, DownwindAlt, DownwindIAS, TAS, GlideSlopeAlt, GlideSlopeIntercept;
double d1, d2, PI2, PIdiv2, heading, iHeading, radians, radianheading, TurnRadius, dThirtyMiles, hypotenuse, downwindOffsetHeading;
double BankAngle = 25.0, TwentyfiveDegreeBank, MetersPerSec, Meters, xMeters, yMeters, SecondsPerCircle, dCenterline, GlideSlope, dDistance;
char NewPlane[] = " Left-click on a location for an arriving airplane ";
char CenterLine[] = " Right-click on a runway approach end for an extended centerline ";
char Heading[6];
char ApproachAltitude[6];
char Airspeed[6];
char Command[16];
char tempPlane[8];
char centerline[8];
char downwindAlt[8];
char downwindIAS[8];
char gs[8];
char fieldelev[8];
BOOL planecommand = FALSE, showdata = TRUE, righturn, rightdownwind, passedzero, fromuser3 = FALSE;
HWND hwndEdit2, hwndEdit3, hwndEdit4, hwndEdit5;
SIZE Size;

int maxRows, maxCols;
char *lpPart[1] = {NULL};//weird, but from Microsoft
int xTopLeft, xBottomRight, yTopLeft, yBottomRight;
int time = 0, prevtime, LastBeacon, LastCourse, firstposX, LastX, LastPosition;
int sbSpeed, sbCourse, sbBeacon, sbSlowSpeed = 10, sbSlowBeacon = 180, sbHighSpeed = 50, sbHighBeacon = 180, sbTurnTime = 10, sbAngle = 35, sbConstant = 0;
double speed, ndist, edist;
char SlowSpeedSB[12];// = "10";
char SlowBeaconSB[12];// = "180";
char HighSpeedSB[12];// = "50";
char HighBeaconSB[12];// = "180";
char TurnTimeSB[12];// = "10";
char AngleSB[4];// = "35";
char ConstantSB[12];// = "0";
char current_course[10], current_speed[10];
BOOL smartbeaconing = FALSE, testingsmartbeaconing = FALSE, gotfirstpos, compressit = FALSE;

DWORD bilrows, bilcols;
int Northest = 0, Eastest = 0x0FFFFFFF, Southest = 0x0FFFFFFF, Westest = 0;
int WminusEx30, NminusS;
int UTMNbilBuf[2048][2048];
int UTMEbilBuf[2048][2048];
int UTMN30Buf[2048*2048];
int UTME30Buf[2048*2048];
WORD UTMElevBuf[2048*2048];
int nw, sw, se, ne, nwN, nwE, swN, swE, neN, neE, seN, seE;
int elevN, elevW, elevS, elevE, elevNS, elevEW, elev;

int kPtr, kaddr, addr, isaprslinebeg, linebeg, linend, saveBaud, aprsi = 0, aprsin = 0, Aprsi = 0, CurrentAprsi, APRSBaud = 0, wx, MaxText, toHwndComm, SP, DC, SE, Speed, Course;
int dataloc, aprsISbeg, aprsISend, APRSHelpSize, symbolindex, homesymbolindex = -1, gpssymbolindex = -1, transmitto = TRANSMITNONE, KissLen, blanklen;
int symbolrow, symbolcol, FilterLen = 0, stationPtr, msgPtr, NumOfStations, staptr, smallest, stationlinebeg, stationIndex, xIndex, yIndex;
int ObjectX, ObjectY, objectPtr, ObjectPtr, ObjectUTMN, ObjectUTME, ObjectUTMZ, objectindex, ObjectToMove = -1;
int APRSUTMEasting, APRSUTMNorthing, symbol, DestBegin, DestEnd, LastGPSEasting = 0, LastGPSNorthing = 0, lat1, lon1;
unsigned int uTimerID = NULL;
//double radius, Meters;
//double POWER[10] = {0, 1, 4, 9, 16, 25, 36, 49, 64, 81};
//double HEIGHT[10] = {10,20,40,80,160,320,640,1280,2560,5120};
//double GAIN;
WORD hash;
WORD serverPort = 1448;
BYTE ach, SymbolTable, GPtype;
DWORD hAPRSThread, hAPRSThread2, hAPRSThread3, TacticalFileSize;
double Lat1, Lon1, LatMin, LonMin, beginE, endE, beginN, endN;
BOOL aprs = FALSE, ataprs = FALSE, tnc = FALSE, inaprs = FALSE, kiss = FALSE, gotfesc, dontshow, shutitdown = FALSE, Message = FALSE, transmitted = FALSE, showline = FALSE;
BOOL weatherlessposition = FALSE, gotcr = FALSE, aprsimulate, gotpos = FALSE, firsttx, showlist = 0x11000000, goodmessage = FALSE, usetactical = FALSE, gotrackname;
BOOL mycallnotfound, homelatlonnotfound, transmittonotfound, homesymbolnotfound, gpssymbolnotfound, destinationnotfound, commentnotfound, beaconnotfound, sbnotfound, compressnotfound;
BOOL markobject = FALSE, fromstationinfo = FALSE, gotsymbol = FALSE, atobj = FALSE, sendit = FALSE, itsobject = FALSE, frommessage = FALSE, fromobject = FALSE;
BOOL gettinginternet = FALSE, gettingreceived = FALSE, gettingsaved = FALSE, fromctrli = FALSE, compressed = TRUE, itslive = TRUE, sendmyloc = FALSE, fromindex;
BOOL okay = FALSE, igate = FALSE;
char StationsInfo[] = "Stations Info             ";
char QRZ[32] = "http://www.QRZ.com/db/";
char Tactical[] = "TacticalCalls.txt";
char TacticalCalls[1024];
char Compressed[13];
char Overlay[2];
char ObjectName[32];
char ObjectsDta[] = "Objects.dta";
char Object[] = "'s Object";
char CircleRadius[12];
TCHAR tchBuffer[32];
char APRStime[5];
char Stations[10240];
char StationsTitle[] = "000 Stations";
char Call[20];
char AprsLine[128];
int Ptrs[1000];
int PtrsCopy[1000];
char Msg[10240];
char MsgTo[10];
char SendMsg[68];
char LAT1[4], LON1[4], LAT2[4], LON2[4];
BYTE hashMyCall[10] = "\0";
char Filter[128];// = "user NOCALL";//NOCALL pass -1 vers usaphotomaps 278 filter a/39/-123/36/-120\n";
char Filter1[] = "user NOCALL";
char Filter2[] = " pass ";
char Filter3[] = " vers usaphotomaps 278";
char Filter4[] = " filter a/";
char MyLoc[128];// = "KI6NLA>APZUSA,TCPIP*:=3724.44N/12206.98W-USAPhotoMaps\n";
char InternetUNPROTO[] = ">APZUSA,TCPIP*:";
char Filter5[] = " -p/CW";
//char APRSBufferTxt[] = "APRS log01.txt";
char APRSBufferTxt[16] = "\0";
//char APRSlog[] = "APRS log01.dta";
char APRSlog[16] = "\0";
char APRStxt[MAX_PATH];// = "APRS log34.txt";
//char FINDU[] = "C:\\Program Files\\Internet Explorer\\iexplore.exe ";
char APRSComm[] = "\\\\.\\COM  ";
char APRSHelp[] = "APRSHelp.txt";
char *pAPRSHelp;
char NoAPRSFile[] = "Couldn't find APRSHelp.txt";
char Tier2Server[24];// = "missouri.aprs2.net";
char aprs2net[] = ".aprs2.net";
char missouri[] = "missouri";
char montana[] = "montana";
char nebraska[] = "nebraska";
char southwest[] = "southwest";
char socal[] = "socal";
char midwest[] = "midwest";
char central[] = "central";
char aprswest[] = "aprswest";
char newengland[] = "newengland";
char westtn[] = "westtn";
char Simultaneously[] = "Internet data,\nPrevious data,\nand Received data\ncan only be selected exclusively.";
unsigned char APRSRegValue[] = "COM  ";
char Findu[512];
BYTE aprsBuf[MEGABYTE];;
char APRSCommPort[3] = "\0\0";
char Symbol[20];
char MyCall[10] = "\0";
char HomeLatLon[24];//3724.44N/12206.98W
char GPSLatLon[19];//3724.44N/12206.98W
char HomeSymbol[20] = "\0";
char GPSSymbol[20] = "\0";
char Destination[32];
char Comment[32];
char CourseSpeed[8];
char Beacon[12] = "\0";
char Kiss[128];
char MYCALL[17] = "MYCALL";//KI6NLA
char UNPROTO[44] = "UNPROTO";
char FirstDest[] = " APZUSA VIA ";
char BTEXT[68] = "BTEXT";//3724.44N/12206.98W-jdmcox@jdmcox.com
char MESSAGE[68] = "BTEXT :";
char OBJECT[68] = "BTEXT ;";
char Ack[28] = "BTEXT :";
char BEACON[17] = "BEACON EVERY 0";
char Shutdown[] = "BEACON EVERY 0";
char BeaconEvery1[] = "BEACON EVERY 1";
char Blank1[32];
char ShowList1[256] = "\0";
char ShowList2[256] = "\0";
char ShowList3[256] = "WX\r\n";
char ShowList4[256] = "Digi\r\n";
char ShowList5[256] = "\0";
char ShowList6[256] = "\0";
char saveRegValue1;
char saveRegValue2;
char GetZipCode[] = "http://jdmcox.com/ZipCode.dta";
char ZipCode[] = "ZipCode.dta";
char Dest[10];
char Addr[10];
char Nmea[100];
char KissPos[256];
char aprsTemp[4];
char aprsWindSpeed[4];
char aprsGust[4];
char aprsWindDir[4];
char aprsHumidity[4];
char wind[] = "  wind ";
char NoDescript[] = "No Descript";
char SecretIP[24];// = "192.168.1.100:1448";
//char ServerIP[24];
char CallsignError[] = "An FCC callsign is required to transmit.";

struct {
	int UTMEasting;
	int UTMNorthing;
	int x;
	int y;

	int UTME1; // for trails
	int UTMN1;
	int UTME2;
	int UTMN2;
	int UTME3;
	int UTMN3;
	int UTME4;
	int UTMN4;
	int UTME5;
	int UTMN5;
	int UTME6;
	int UTMN6;

	int IAS;
	int TAS;
	int heading;
	int altitude;
	int newIAS;
	int newHeading;
	int newAltitude;
	double radianheading;
	double newRadianheading;
	double RadiansPerSecond;
	BYTE Turn;
} Plane[MAXPLANES];
int plane;

struct {
	int UTME1;
	int UTME2;
	int UTMN1;
	int UTMN2;
	int GSE;
	int GSN;
	int GSInterceptAlt;
}Line[10];
int lines;

struct
{
	int UTMN;
	int UTME;
	int UTMZ;
	COLORREF CircleColor;
	DOUBLE CircleRadius;
	char Name[32];
	char Time[8];
	char Comment[44];
	char SymbolType;
	BYTE Symbol;
	BYTE itsmiles;
	BYTE intense;
	BYTE extra;
} Objects[MAXOBJECTS]; // 65, was 25

struct
{
	int UTMN;
	int UTME;
	int UTMZ;
	WORD Time;
	char Call[10];
	char DescOrWx[24];
	char Status[49];
	char SymbolType;
	char Symbol;
	char RedDot;
} Aprs[MAXAPRS];

HANDLE hAPRSFile = NULL, hAPRSComm;
HWND hwndAPRSDlg, hwndComm = NULL, hwndAPRS, hwndListDlg, hwndCtrlC, hwndMyCall, hwndDestination, hwndBtext, hwndBeacon, hwndStationInfoDlg, hwndSymbolDlg, hwndEditObjectDlg;
HWND hwndSend, hwndEdit1, hwndStartKISS, hwndStopKISS, hwndMessageDlg = NULL, hwndMessage, hwndObject, hwndTranslate, hwndStationsDlg, hwndTacticalDlg, hwndInfoButton;
TIME_ZONE_INFORMATION tzi;
RECT editRect, rcBitmap;
HDC hdcSymMem = 0, hdcSymMem1, hdcSymMem2;
LPMEASUREITEMSTRUCT lpmis;
LPDRAWITEMSTRUCT lpdis;
TEXTMETRIC tm;

struct {
	char symbol;
	char Primary[15];
	char Secondary[16];
	char PrimaryGPS[3];
	char SecondaryGPS[3];
} APRSSymbols[95] = {
'!',"Police Stn","Emergency","BB","OB",
'"',"No Symbol","No Symbol","BC","OC",
'#',"Digi","Digi No.","BD","OD",
'$',"Phone","Bank","BE","OE",
'%',"DX Cluster","No Symbol","BF","OF",
'&',"HF Gateway", "Gateway No.","BG","OG",
'\'',"Plane","Crash site","BH","OH",
'(',"Mob Sat Stn","Cloudy","BI","OI",
')',"WheelChair","MEO","BJ","OJ",
'*',"Snowmobile","Snow","BK","OK",
'+',"Red Cross","Church","BL","OL",
',',"Boy Scout","Girl Scout","BM","OM",
'-',"Home","Home (HF)","BN","ON",
'.',"X","UnknownPos","BO","OO",
'/',"Red Dot","Destination","BP","OP",
'0',"Circle (0)","Circle No.","P0","A0",
'1',"Circle (1)","No Symbol","P1","A1",
'2',"Circle (2)","No Symbol","P2","A2",
'3',"Circle (3)","No Symbol","P3","A3",
'4',"Circle (4)","No Symbol","P4","A4",
'5',"Circle (5)","No Symbol","P5","A5",
'6',"Circle (6)","No Symbol","P6","A6",
'7',"Circle (7)","No Symbol","P7","A7",
'8',"Circle (8)","No Symbol","P8","A8",
'9',"Circle (9)","Petrol Stn","P9","A9",
':',"Fire","Hail","MR","NR",
';',"Campground","Park","MS","NS",
'<',"Motorcycle","Gale F1","MT","NT",
'=',"Rail Eng.","No Symbol","MU","NU",
'>',"Car","Car No.","MV","NV",
'?',"File svr","Info Kiosk","MW","NW",
'@',"HC Future","Hurricane","MX","NX",
'A',"Aid Stn.","Box No.","PA","AA",
'B',"BBS","Snow blwng","PB","AB",
'C',"Canoe","Coast Guard","PC","AC",
'D',"No Symbol","Drizzle","PD","AD",
'E',"Eyeball","Smoke","PE","AE",
'F',"Tractor","Fr'ze Rain","PF","AF",
'G',"Grid Squ.","Snow Shwr","PG","AG",
'H',"Hotel","Haze","PH","AH",
'I',"Tcp/ip","Rain Shwr","PI","AI",
'J',"No Symbol","Lightning","PJ","AJ",
'K',"School","Kenwood","PK","AK",
'L',"Usr Log-ON","Lighthouse","PL","AL",
'M',"MacAPRS","No Symbol","PM","AM",
'N',"NTS Stn","Nav Buoy","PN","AN",
'O',"Balloon","Rocket","PO","AO",
'P',"Police","Parking","PP","AP",
'Q',"TBD","Quake","PQ","AQ",
'R',"Rec Veh'le","Restaurant","PR","AR",
'S',"Shuttle","Sat/Pacsat","PS","AS",
'T',"SSTV","T'storm","PT","AT",
'U',"Bus","Sunny","PU","AU",
'V',"ATV","VORTAC","PV","AV",
'W',"WX Service","WXS No.","PW","AW",
'X',"Helo","Pharmacy","PX","AX",
'Y',"Yacht","No Symbol","PY","AY",
'Z',"WinAPRS","No Symbol","PZ","AZ",
'[',"Jogger","Wall Cloud","HS","DS",
'\\',"Triangle","No Symbol","HT","DT",
']',"PBBS","No Symbol","HU","DU",
'^',"Plane lrge","Plane No.","HV","DV",
'_',"WX Station","WX Stn No.","HW","DW",
'`',"Dish Ant.","Rain","HX","DX",
'a',"Ambulance","Diamond No.","LA","SA",
'b',"Bike","Dust blwng","LB","SB",
'c',"ICP","CivDef No.","LC","SC",
'd',"Fire Station","DX Spot","LD","SD",
'e',"Horse","Sleet","LE","SE",
'f',"Fire Truck","Funnel Cld","LF","SF",
'g',"Glider","Gale","LG","SG",
'h',"Hospital","HAM store","LH","SH",
'i',"IOTA","Blk Box No.","LI","SI",
'j',"Jeep","WorkZone","LJ","SJ",
'k',"Truck","SUV","LK","SK",
'l',"Laptop","Area Locns","LL","SL",
'm',"Mic-E Rptr","Milepost","LM","SM",
'n',"Node","Triang No.","LN","SN",
'o',"EOC","Circle sm","LO","SO",
'p',"Rover","Part Cloud","LP","SP",
'q',"Grid squ.","No Symbol","LQ","SQ",
'r',"Antenna","Restrooms","LR","SR",
's',"Power Boat","Boat No.","LS","SS",
't',"Truck Stop","Tornado","LT","ST",
'u',"Truck 18wh","Truck No.","LU","SU",
'v',"Van","Van No.","LV","SV",
'w',"Water Stn","Flooding","LW","SW",
'x',"XAPRS","No Symbol","LX","SX",
'y',"Yagi","Sky Warn","LY","SY",
'z',"Shelter","Shelter No.","LZ","SZ",
'{',"No Symbol","Fog","J1","Q1",
'|',"TNC Stream Sw","TNC Stream SW","J2","Q2",
'}',"No Symbol","No Symbol","J3","Q3",
'~',"TNC Stream Sw","TNC Stream SW","J4","Q4",
'\1',"","""",""};

int BigWidth, BigHeight, BigTop, BigLeft, xBigLoc, yBigLoc;

char PrinterName[64];
DWORD PrinterNameLen = 64;
DWORD dwSizeNeeded, dwNumItems, dwItem, dwNeeded;
HANDLE hPrinter;
LPPRINTER_INFO_5 lpInfo;
LPDEVMODE pDevMode;

char *ExploristBuf;
char Explorist[] = "I'm still waiting for help from any eXplorist owner!\n\njdmcox@jdmcox.com";
char Routine[] = "Routine not finished!";

//char ATDI[] = "\
//The lat/lon, as well as the\nelevation data website address,\nis now in the Windows Clipboard.";

char CommPort[3];

char GPX[MAX_PATH];
char FullGPX[MAX_PATH];
char csv[] = "csv";
char xml[] = "xml";
char txt[] = "txt";
char gpx[] = "gpx";
char gz[] = "gz";

char FullGeocaching[MAX_PATH];
char Geocaching[MAX_PATH];

//BOOL waypointedited;

struct {
	char name[48];
	WORD begin;
	WORD end;
}Photo[100];
int P;
int Width, Height, Resolution;
BYTE *PhotoBuf;
BYTE *photo_pixel_buf;
char PhotoName[48] = "Photos\\";
char Photos[] = "Photo";
POINTS points;
HWND hwndDescEdit, hwndPhoto;

char StreetName[50];
BOOL first = FALSE, show = FALSE;
HWND hwndStreet = NULL, hwndShowButton, hwndStreetEdit;
HDC hdcShowButton, hdcStreetEdit;


BYTE *Pixels;
char Big[] = " Press Esc to exit    Use the Arrow keys (or hold the left button down and move the mouse) to pan a large image";
char FullJpgFile[MAX_PATH];
char JpgFile[MAX_PATH];
BOOL showjpeg = FALSE;
HWND hwndBig;

int Radius;
char Cdata[] = "<![CDATA[";
char CdataEnd[] = "]]>";

char Region[] = "Region=4\r\nFormat=UTM\r\nzz xxxxxx yyyyyyy\r\nzz xxxxxx yyyyyyy\r\nzz xxxxxx yyyyyyy\r\nzz xxxxxx yyyyyyy\r\n";
char TerraFetcherRegion[] = "TerraFetcherRegion.txt";
char Path1[] = "Path=";
char Path2[] = "\r\nWidth=800\r\nFormat=UTM\r\n";
char TerraFetcherPath[] = "TerraFetcherPath.txt";

struct
{
	int x;
	int y;
	int z;
} CurLandmark[100];
int cl, NormalOrientation;
BOOL showinglandmarks;

char ElevationFile[MAX_PATH];// = "NED_46542986.bil";
char ShortElevationFile[MAX_PATH];
char ElevationDir[] = "Elevation";
char NewElevFile[MAX_PATH] = "Elevation\\"; 
int Lams, TotalLams, Xmodifier, Ymodifier, Dots, USAIndex, USAxPos, USAyPos;
char *USABuf;//to hold Texas.txt, etc
POINT Dot[2000];
POINT *pUSA;//to hold screen offsets
int DotUSAIndex[2000];
char DotUSAName[500][25];
char USA[] = "  Press Esc - or click on a Map Location dot";
//char USA[] = "  The United States of America";
char UnzipUSA[] = "unzip.exe -n StateOutlines.zip";
double *LambertX, *LambertY;
double Xlambert, Ylambert, ScreenModifier;
BOOL usamap = FALSE, notfromusa = TRUE, usatext = FALSE, maximized = TRUE;
int Zone1600[10] = {165,295,445,585,725,865,1025,1165,1315,1485};//1600
int Zone1280[10] = {110,235,355,470,580,700,815,935,1060,1190};//1280
int Zone1152[10] = {100,210,320,425,525,625,735,840,950,1070};//1152
int Zone1024[10] = {95,185,285,375,470,560,655,755,855,955};//1024
int Zone800[10] = {90,140,215,290,360,435,510,585,665,740};//800
int *pZone;
char ZoneNum[3] = "10";
int Lon1600x[9] = {3,206,416,629,847,1058, 1268,1475,1568};
int Lon1600y[9] = {974,1016,1043,1055,1053,1035,1005,960,538};
int Lon1280x[9] = {2,165,331,500,674,842,1011,1175,1248};
int Lon1280y[9] = {780,810,832,842,840,827,802,765,419};
int Lon1152x[9] = {0,145,295,450,604,758,907,1059,1123};
int Lon1152y[9] = {702,733,752,760,760,748,723,691,378};
int Lon1024x[9] = {0,130,264,402,538,675,805,939,995};
int Lon1024y[9] = {625,649,666,670,670,662,642,613,337};
char Lons[] = "120\260114\260108\260102\260 96\260 90\260 84\260 78\260 72\260";
int *pLonx, *pLony;
HWND hwndUSA;
HRGN hRgn;

#ifdef onetime0
BOOL onetime1, onetime2, onetime3;
#endif

int Spaces2Move = 0;
BOOL directdraw;
RECT rect1, rect2, rect3, rect4;
HDC hdcBack, hdcBack2;
LPDIRECTDRAW7 lpDD7;
DDSURFACEDESC2 ddsd;
LPDIRECTDRAWSURFACE7 lpDDSPrimary, lpDDSBack, lpDDSBack2;

int xbeg, ybeg;
//int xPosOld, xbegOld = -1, yPosOld, ybegOld;
BOOL cachenotfull = TRUE;
BOOL right, top;
BOOL getarea = FALSE;

int proxy = 0;
int ProxyUserLen, ProxyPassLen;
char ProxyUserName[50];
char ProxyPassword[50];

char CheckforUpdate[] = "http://jdmcox.com//";
char NewerVersion[] = "A newer version is available";
char NewerDate[] = "This version with a newer date is available";
char SameVersion[] = "Still the same version";

WSADATA wsaData;
WSADATA IgatewsaData;
SOCKET s, s2, s3, sListen, sAccept;
struct sockaddr_in dest, saServer;
struct hostent *he;

char Fips[6];
char CountyFromLatLon1[] = "http://nationalatlas.gov/servlet/com.esri.esrimap.Esrimap?Name=VBAtlas&cmd=Identify&ClickX=";
char CountyFromLatLon2[] = "&ClickY=";
char CountyFromLatLon3[] = "&bgoff=T&visLayers=Counties,States";
int tUTMEasting, tUTMNorthing, tUTMZone;
BYTE *tempBuffer;
int gotX, gotY;
int NamePtrs[MAXPTIGERS][MAXNAMEPTRS];
char *NamePtr1, *NamePtr2;
int Bigx, np, gotit, pts, pname, HighestFeatureType;
int  TigerAngle, CountySize, County;
int RowBegin, point, TigerPointE, TigerPointN, TigerPointA, Angle1, Angle2;
ULONG tiger;
DWORD TigerPtr;
DWORD NumofPolys, NameBegin, NameLen, pNameBeginLatLon, FeatureType;
DWORD PolyPtrs[TIGERS/2];
DWORD IndexSize, TigerSize, namesize;
DWORD TigerNameSize[MAXPTIGERS];
char SmallBuf[SMALLBUFSIZE];
char SmallBuf2[1024];
char *pCounties;
int *TigerUTM;
int *pTiger[MAXPTIGERS];
char *pTigerNames[MAXPTIGERS], *Buf1, *pTigerIndex, *pTigerBoundaries;
char ZippedTiger[MAX_PATH];
char TigerState[2];
char SmallBufDta[] = "SmallBuf.dta";
char Tiger[] = "TIGER/Line data";
char TigerCounties[] = "TigerCounties.txt";
char TigerDir[] = "TigerData";
char OldTigerZip[] = ".\\TigerData\\TGRxxxxx.zip";
char TigerZip[] = "TGRxxxxx.zip";
char TigerData[] =    "TGRxxxxx";
char TigerMet[] =     "TGRxxxxx.MET";
char TigerRecord1[] = "TGRxxxxx.RT1";
char TigerRecord2[] = "TGRxxxxx.RT2";
char TigerDta[] =   "TigerData\\TGR?????_??_1.dta";
char TigerName[] =  "TigerData\\TGR?????_??_2.dta";
char TigerIndex[] = "TigerData\\Boundaries_XX.txt";
char TigerBounds[] = "xxxxx:                                                                          ";
char GetTigerZip[] = "http://www2.census.gov/geo/tiger/tiger2006se/VA/TGRxxxxx.ZIP";
char Unzip[] = "unzip.exe -n TGRxxxxx.zip TGRxxxxx.MET TGRxxxxx.RT1 TGRxxxxx.RT2";
char Downloading[] = "Downloading";
char Downloaded[] =	 " 12,456,890 bytes of 123456";
char Converting[] =  "Converting";
char Converted[] =   "12,456,890 of 12,456,890 bytes ";
char GetUnzip[] = "http://jdmcox.com/unzip.exe";
char unzipFile[] = "unzip.exe";
BOOL gotstreet = FALSE, streetflag = FALSE, accepted, downloaded, notcancelled = TRUE, downloadingstreets = FALSE, froms = FALSE, showit;
//POINT pt[TIGERS];//for PolyPolyline
POINT *pt;
HANDLE hNameFile, hIndexFile, hSmallFile, hFindFile, hMutex;
HWND hwndTiger, hwndCounties;
RECT tigerRect;

char CmdLine[255];
char RunPgmGpx[255];
char runpgm[] = "\\GSAK.gpx";
BOOL gsak = FALSE;
char FileOut[25];
char Find[101];
int HelpSize, GPSHelpSize, TigerHelpSize, CountyHelpSize, FindSize, NextFind, Lines, ScreenLines, LastLineFromChar, BigJpegDataSize;
HWND hwndGPS, hwndHelp, CurrentHelp, hwndTigerHelp, hwndElevationHelp, hwndApproachHelp;
HANDLE hFind;
char Q[] = "   (the same as pressing the Q key)";
BOOL Reply = FALSE;
BOOL simulate = FALSE, savebuf = TRUE;
BOOL showposition = FALSE;
WORD *MyDem;
int TarSize;
char WaypointsPath[MAX_PATH];
BOOL downloaderror, gotem, firstbad;
char FirstLetter[2];
char SelectedUSGSLoc[100];
char GetConus[] = "http://jdmcox.com/CONUS.LAS";

char comment[50];
char name[50];
char SerialRouteLink[] = "\x10\x62\x15\x03\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x92\x10\x03";
char RouteLink[] = "\3\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0";
DWORD dwBytesWrit, USGSfileSize;
char BulkDta[] = "Bulk.dta";
BYTE BulkBuf[USB_MAX_BUFFER_SIZE];
BYTE Bulk[10000];
int ReadPtr, LastError;
char Temp[] = "dwBytesRead =       ";
char Temp2[] = " Last Error =       ";
BOOL xfercmplt;
char NotRoute[] = "That's not a route file.";
int ArrayIndex;
unsigned char *RowBufs;
DWORD Col, ColPtr;
HANDLE aThreads[100];//presuming open threads is < 100

int ZoomandBelow = 2;
char NewUSNG[20];

char PhotoZoom1[] = "&1 Meter/pixel";
char PhotoZoom2[] = "Zoomed to &2 Meters/pixel";
char PhotoZoom4[] = "Zoomed to &4 Meters/pixel";
char PhotoZoom8[] = "&Zoomed to 8 Meters/pixel";
char PhotoZoomBig8[] = "&8 Meters/pixel";
char PhotoZoom16[] = "Zoomed to &16 Meters/pixel";
char PhotoZoom32[] = "Zoomed to &32 Meters/pixel";
char PhotoZoom64[] = "Zoomed to &64 Meters/pixel";
char TopoZoom1[] = "&4 Meters/pixel";
char TopoZoom2[] = "Zoomed to &8 Meters/pixel";
char TopoZoom4[] = "Zoomed to &16 Meters/pixel";
char TopoZoom8[] = "Zoomed to &32 Meters/pixel";
char TopoZoomBig8[] = "&64 Meters/pixel";
char TopoZoom16[] = "Zoomed to &128 Meters/pixel";
char TopoZoom32[] = "Zoomed to &256 Meters/pixel";
char TopoZoom64[] = "Zoomed to &512 Meters/pixel";
char UrbanZoom1[] = "1/&4 Meter/pixel";
char UrbanZoom2[] = "&Zoomed to 1/2 Meters/pixel";
char UrbanZoom4[] = "Zoomed to &1 Meters/pixel";
char UrbanZoom8[] = "Zoomed to &2 Meters/pixel";
char UrbanZoomBig8[] = "4 &Meters/pixel";
char UrbanZoom16[] = "Zoomed to 8 Meters/pixel";
char UrbanZoom32[] = "Zoomed to 16 Meters/pixel";
char UrbanZoom64[] = "Zoomed to 32 Meters/pixel";

char Accept[] = "Accept: */*\r\n\r\n";
unsigned char *pBuf;
unsigned char *ConusLatData, *ConusLonData, *PrviLatData, *PrviLonData, *LatData, *LonData, *pDemIniBuf, *HawaiiLatData, *HawaiiLonData, *AlaskaLatData, *AlaskaLonData;
char DemFileName[50];
char DemIni[200];
char ConusLas[] = "CONUS.LAS";
char ConusLos[] = "CONUS.LOS";
char PrviLas[] = "Prvi.las";
char PrviLos[] = "Prvi.los";
char HawaiiLas[] = "hawaii.las";
char HawaiiLos[] = "hawaii.los";
char AlaskaLas[] = "alaska.las";
char AlaskaLos[] = "alaska.los";
int GotoEasting, GotoNorthing;
char *AddrBuf;
char Address[100];
char xCity[100];
char State[20];
char ZIP[10];
BOOL gotaddr, gotcity, gotzip;
//http://nmviewogc.cr.usgs.gov/tnm/FindAddress?street=&city=&state=&zipcode=94306&Cmd=Zoom+to+Address
//http://nmviewogc.cr.usgs.gov/tnm/FindAddress.jsp   nm_web1@usgs.gov
char Address0[] = "http://viewer.nationalmap.gov/viewer is the newest";
char Address1[250] = "http://nmviewogc.cr.usgs.gov/tnm/FindAddress?street=";
//3292+Tea+Rose+Dr
char Address2[] = "&city=";
//El+Dorado+Hills
char Address3[] = "&state=";
//CA
char Address4[] = "&zipcode=";
//95762
char Address5[] = "&Cmd=Zoom+to+Address";

int saveRowOffset, saveColOffset, saveZoom, savePixelsPerTile, saveMetersPerTile, saveImageSize, saveTilesDown, saveTilesAcross, colAddr, tempyLoc, tempxLoc;
//char ElevInfo[] = "Move the cursor to the middle of a grid area with no elevation showing, and press the left mouse button to put the lat/lon for that area (as well as the elevation data's website address) into the Windows Clipboard.\r\n\r\n\Then go to that website and paste the latitude and longitude into their boxes.\r\n\r\n\Close this Window to exit this mode.";
char *ElevBuf;
BYTE *ElevBuf2;
HWND hwndElevation;
HINTERNET hInternet, hConnectHandle, hResourceHandle;

BOOL fromgotocity = FALSE;
int qm, CityUTMEasting, CityUTMNorthing;
HWND hwndState, hwndCity;
HANDLE hStateFile;
char City[100];
int StateIndex, CityIndex, NumOfPtrs;
char *USGSBuf = NULL;
char *StateBuf;
char States[][3] = {"  ","AK","AL","AR","AZ","CA","CO","CT","DC","DE","FL","GA","HI","IA","ID","IL","IN","KS","KY","LA","MA","MD","ME","MI","MN","MO","MS","MT","NC","ND","NE","NH","NJ","NM","NV","NY","OH","OK","OR","PA","PR","RI","SC","SD","TN","TX","UT","VA","VI","VT","WA","WI","WV","WY"};
char USGSFile[MAX_PATH];
char PtrFile[MAX_PATH];
char StatesPath[] = "\\States\\??.txt";
char ZonePath[] = "\\States\\??.dta";
char PtrPath[] = "\\States\\??.ptr";
char USGSData[100];
int WaypointToMove = -1;

struct Ptr10 {
	int UTMN;
	int UTME;
	DWORD ptr;
} *PtrBuf;

typedef struct {
	int col;
	unsigned char *RowBufs;
	char URLName[80];
} THREADPARAMS;
THREADPARAMS tp;
int RowBufSize[2900];

struct _Pvt
{
	float alt;//12
	float epe;//16
	float eph;//20
	float epv;//24
	double tow;//30
	double lat;//38
	double lon;//46
	float lon_vel;//54
	float lat_vel;//58
	float alt_vel;//62
	float msl_hght;//66
	int grmn_days;//72
	WORD leap_sec;//70
	WORD fix;//28
} Pvt;//64 bytes

BYTE *FromUSBBuf = NULL;
int PrevTnum;
int Param, *pParam = &Param;
int Packets;
int USBptr, PacketPtr;
UINT PvtBegin = 0xFFFFFFFF - 76;
BYTE USBBuf[USB_INTERRUPT_DATA_SIZE];
DWORD hDeviceThread = NULL, hReadFileThread = NULL;
DWORD dwBytesToSend, dwBytesReceived, dwBytesReturned;
char Buf2[300];
char Numero[4];
BOOL hevent0set, gotFD, gotFF, getprotocol;
//Packet format:
//0 Packet type (0=transport, 0x14=Garmin)
//4 (WORD) Packet ID
//8 (DWORD) Data Size
//12+ Data
BYTE Packet[PACKETSIZE];
HANDLE hUSBFile, hEvent0, hEvent1, hEvent2, hEvent3, hUSGSFile, hPtrFile;
HANDLE hUSB;
//HANDLE hDeviceFile;
OVERLAPPED ol, ol2, ol3, APRSol;
HDEVINFO DevInfo;
SP_DEVINFO_DATA DevInfoData = {sizeof(SP_DEVINFO_DATA)};
SP_DEVICE_INTERFACE_DATA InterfaceData;
PSP_DEVICE_INTERFACE_DETAIL_DATA DevDetailData = 0;

int MapType = PHOTO;

char Index[MAX_PATH] = "C:\\Program Files\\Internet Explorer\\iexplore.exe http:\\\\jdmcox.com\\";
char TerraServer[MAX_PATH] = "C:\\Program Files\\Internet Explorer\\iexplore.exe ";
char DownloadErr[MAX_PATH] = "C:\\Program Files\\Internet Explorer\\iexplore.exe file:///";
char URLink[] = "C:\\Program Files\\Internet Explorer\\iexplore.exe http://www.geocaching.com/seek/cache_details.aspx?wp=GCM8JR";
char DownloadErr2[] = "\\DownloadError.htm";
char SDTS[] = "http://www.atdi-us.com/SDTS_DL_b.htm";
//char SDTS[200] = "http://www.atdi-us.com/sdts.exe?csys=1DMS&lat=";
//char SDTSMiddle[] = "&lon=";
//char SDTSEnd[] = "&submit=Get+Data";
//char SDTSdata[200] = "http://www.atdi-us.com/S/SDTS/1663222.dem.sdts.tar.gz";
char ShortSDTSfilename[100];
char SDTSfilename[MAX_PATH];
//http://www.atdi-us.com/sdts.exe?csys=1DMS&lat=37.14&lon=-122.04&submit=Get+Data
int GifBufSize;
BYTE *GifBuf;
BYTE pixel_buf[MAX_IMAGE_SIZE];
BYTE ColorTable[256];

char AsciiTotal[6] = "17142";
char BigWaypointFile[] = "Waypoint file is bigger than 1,000,000 bytes!";
char BigJpegFilename[50] = "eXXXXXXnYYYYYYYzZZp.txt";
char BigJpegData[50];
int i, v, w, x, y, z, X1, Y1, X2, Y2;
char TrackName[MAX_PATH];
char PreTracks[] = "Track,UTM Zone,UTM Northing,UTM Easting,UTC Hour,Min,Sec,Month,Date,Year,Alt(Meters)\r\n";
char Noo[] = "New,";
char PseudoTrack[] = ",00,00,00,,,,0\r\n";
char PositionHeader[] = ",UTM Zone,UTM Northing,UTM Easting,UTC Hour,Min,Sec,Month,Date,Year,Altitude,HorizEPE,VertEPE,Speed\r\n";
char PositionCsv[] ="Position??.csv";
int HorizPoint[20][20], VertPoint[20][20];
int OneMeterTilesDown, OneMeterTilesAcross, OneMeterTileSize, xFraction, yFraction;
int p1MeterSize;
BYTE *p1Meter;
DWORD *p1MeterX, *p1MeterY;
BOOL missing1meter = FALSE, onepressed = FALSE;

int currentpoint;
char OutsideUSA[] = "\r\nis outside the U.S.A.";
HWND hwndButton, hwndButton2, hwndButton3, hwndInstr, hwndEdit = NULL;

char TrackEdit[] = "\
When the mouse pointer is over a track point:\r\n\
\r\n\
Press and hold the Right mouse button to move that point.\r\n\
  or\r\n\
Press and hold the Left mouse button \
to draw a new segment line from a point \
with no next segment line (at the end of an entire Segment).\r\n\
  or\r\n\
Press the Delete key to delete the next segment line from that point.\r\n\
  or\r\n\
Click the Left mouse button on a point \
that's not the end of an entire Segment  \
and not part of the first entire Segment to \
open a window for selecting a color \
for that entire Segment. See GPS -Help for more on this.\r\n\
\r\n\
If a track point is moved over the next \
track point, it will be deleted, and that \
next track point will be attached to the \
previous track point.\r\n\
\r\n\
If you add, delete or move a track point, \
the elevations in USAPhotoMaps will be \
saved, replacing the GPS altitudes.";
//Magellan Meridian
char Ma[] = "Default";
char Mb[] = "Box";
char Mc[] = "House";
char Md[] = "Aerial";
char Me[] = "Airport";
char Mf[] = "Amusement";
char Mg[] = "ATM";
char Mh[] = "Auto Repair";
char Mi[] = "Boating";
char Mj[] = "Camping";
char Mk[] = "Exit Ramp";
char Ml[] = "First Aid";
char Mm[] = "Fixed Nav Aid";
char Mn[] = "Floating Buoy";
char Mo[] = "Fuel";
char Mp[] = "Garden";
char Mq[] = "Golf";
char Mr[] = "Hotel";
char Ms[] = "Hunt/Fish";
char Mt[] = "Large City";
char Mu[] = "Lighthouse";
char Mv[] = "Major City";
char Mw[] = "Marina";
char Mx[] = "Medium City";
char My[] = "Museum";
char Mz[] = "Obstruction";
char aa[] = "Park";
char ab[] = "Resort";
char ac[] = "Restaurant";
char ad[] = "Rock";
char ae[] = "Scuba";
char af[] = "RV Service";
char ag[] = "Shooting";
char ah[] = "Sightseeing";
char ai[] = "Small City";
char aj[] = "Sounding";
char ak[] = "Sports Arena";
char al[] = "Tourist Info";
char am[] = "Truck Service";
char an[] = "Winery";
char ao[] = "Wreck";
char ap[] = "Zoo";
//Magellan 315
char Xa[] = "Default";
char Xb[] = "Box";
char Xc[] = "Red Buoy";
char Xd[] = "Green Buoy";
char Xe[] = "Anchor";
char Xf[] = "Rocks";
char Xg[] = "Red Day";
char Xh[] = "Green Day";
char Xi[] = "Bell";
char Xj[] = "Danger";
char Xk[] = "Diver Down";
char Xl[] = "Fish";
char Xm[] = "House";
char Xn[] = "Mark";
char Xo[] = "Car";
char Xp[] = "Tent";
char Xq[] = "Boat";
char Xr[] = "Food";
char Xs[] = "Fuel";
char Xt[] = "Tree";
//Garmin
char G0[] = "Anchor";
char G1[] = "Bell";
char G2[] = "Diamond (Green)";
char G3[] = "Diamond (Red)";
char G4[] = "Diver Down (Striped Flag)";
char G5[] = "diver down (Code Flag A)";
char G6[] = "Bank";
char G7[] = "Fishing Area";
char G8[] = "Gas Station";
char G9[] = "Horn";
char G10[] = "Residence";
char G11[] = "Restaurant";
char G12[] = "Light";
char G13[] = "Bar";
char G14[] = "Danger Area";
char G15[] = "Square (Green)";
char G16[] = "Square (Red)";
char G17[] = "Bouy";
char G18[] = "Waypoint";
char G19[] = "Shipwreak";
char G20[] = "Invisible";
char G21[] = "Man Overboard";
char G22[] = "Bouy (Amber)";
char G23[] = "Bouy (Black)";
char G24[] = "Bouy (Blue)";
char G25[] = "Bouy (Green)";
char G26[] = "Bouy (Green/Red)";
char G27[] = "Bouy (Green/White)";
char G28[] = "Bouy (Orange)";
char G29[] = "Bouy (Red)";
char G30[] = "Bouy (Red/Green)";
char G31[] = "Bouy (Red/White)";
char G32[] = "Bouy (Violet)";
char G33[] = "Bouy (White)";
char G34[] = "Bouy (White/Green)";
char G35[] = "Bouy (White/Red)";
char G36[] = "Dot";
char G37[] = "Radio Beacon";
char G150[] = "Boat Ramp";
char G151[] = "Campground";
char G152[] = "Restroom";
char G153[] = "Shower";
char G154[] = "Drinking Water";
char G155[] = "Telephone";
char G156[] = "Medical Facility";
char G157[] = "Information";
char G158[] = "Parking Area";
char G159[] = "Park";
char G160[] = "Picnic Area";
char G161[] = "Scenic Area";
char G162[] = "Skiing Area";
char G163[] = "Swimming Area";
char G164[] = "Dam";
char G165[] = "Controlled Area";
char G166[] = "Danger Area";
char G167[] = "Restricted Area";
char G168[] = "Invisible";
char G169[] = "Ball Park";
char G170[] = "Car";
char G171[] = "Hunting Area";
char G172[] = "Shopping Center";
char G173[] = "Hotel";
char G174[] = "Mine";
char G175[] = "Trail Head";
char G176[] = "Truck Stop";
char G177[] = "User Exit";
char G178[] = "Civil";
char G179[] = "Circle X";
char G8192[] = "Interstate Hwy";
char G8193[] = "US Hwy";
char G8194[] = "State Hwy";
char G8195[] = "Mile Marker";
char G8196[] = "TracBack Point";
char G8197[] = "Golf Course";
char G8198[] = "City (Small)";
char G8199[] = "City (Medium)";
char G8200[] = "City (Large)";
char G8201[] = "Intl Frwy";
char G8202[] = "Intl National Frwy";
char G8203[] = "Capitol City";
char G8204[] = "Amusement Park";
char G8205[] = "Bowling";
char G8206[] = "Car Rental";
char G8207[] = "Car Repair";
char G8208[] = "Fast Food";
char G8209[] = "Fitness Center";
char G8210[] = "Movie Theater";
char G8211[] = "Museum";
char G8212[] = "Pharmacy";
char G8213[] = "Pizza";
char G8214[] = "Post Office";
char G8215[] = "RV Park";
char G8216[] = "School";
char G8217[] = "Stadium";
char G8218[] = "Deptartment Store";
char G8219[] = "Zoo";
char G8220[] = "Convenience Store";
char G8221[] = "Live Theater";
char G8222[] = "Ramp Intersection";
char G8223[] = "Street Intersection";
char G8224[] = "?";
char G8225[] = "?";
char G8226[] = "Scales";
char G8227[] = "Toll Booth";
char G8228[] = "Summit";
char G8229[] = "Exit Without Services";
char G8230[] = "Geographic Place Name, Man-Made";
char G8231[] = "Geographic Place Name, Water";
char G8232[] = "Geographic Place Name, Land";
char G8233[] = "Bridge";
char G8234[] = "Building";
char G8235[] = "Cemetary";
char G8236[] = "Church";
char G8237[] = "Civil Location";
char G8238[] = "Crossing";
char G8239[] = "Ghost Town";
char G8240[] = "Levee";
char G8241[] = "Military";
char G8242[] = "Oil Field";
char G8243[] = "Tunnel";
char G8244[] = "Beach";
char G8245[] = "Forest";
char G8246[] = "Summit";
char G8247[] = "Large Ramp Intersection";
char G8248[] = "Large Exit Without Services";
char G8249[] = "Police";
char G8250[] = "Gambling";
char G8251[] = "Snow Skiing";
char G8252[] = "Ice Skating";
char G8253[] = "Tow Truck";
char G8254[] = "Border";

char G16384[] = "Airport";
char G16385[] = "Intersection";
char G16386[] = "NDB";
char G16387[] = "VOR";
char G16388[] = "Heliport";
char G16389[] = "Private Field";
char G16390[] = "Soft Field";
char G16391[] = "Tall Tower";
char G16392[] = "Short Tower";
char G16393[] = "Glider Area";
char G16394[] = "Ultralight Area";
char G16395[] = "Parachute Area";
char G16396[] = "VOR/TACAN";
char G16397[] = "VOR-DME";
char G16398[] = "Initial Approach";
char G16399[] = "Localizer Outer Marker";
char G16400[] = "MAP";
char G16401[] = "TACAN";
char G16402[] = "Seaplane Base";

char tempLatLon[400];
BOOL atwaypoint = FALSE, movewaypoint = FALSE, fromlineto = FALSE;
char Togps[] = "ToGPS.txt";
char ToGarmin[] = "ToGPS.dta";
unsigned char ToGPS[50000];
int tgcount;
char Contourson[] = "&Contours On     C";
char Contoursoff[] = "&Contours Off    C";
char tempBuf[20];
char *pIdentLoc;
char tempNewLoc[10000];
char tempLatLonUTM[50] = "\0";

//MENUITEMINFO mii;
char *tempDta;
int tempPtr[2902];
int pointer;

int FadeIncrement = 0;
BOOL fade = FALSE, wastopo = FALSE;
char *pURLName;

char USAPhotoMapsKey[] = "USAPhotoMaps.dta";
char Key[] = "\0\0\0\0\0\0\0";
char Begging[] = "\r\nIf you find this program useful or enjoyable,\r\n\
I would REALLY appreciate a donation.\r\n\
\r\n\
If you email me that the check's in the mail,\r\n\
I'll email you a very small data file\r\n\
to put in the USAPhotoMaps folder\r\n\
so this message won't appear again.\r\n\
\r\n\
(or click on the PayPal icon at jdmcox.com)\r\n\
\r\n\
jdmcox@jdmcox.com\r\n\
Doug Cox\r\n\
140 Monroe Dr\r\n\
Palo Alto, CA 94306";

char Streets[MAX_PATH] = "C:\\Program Files\\Microsoft Streets & Trips\\Streets.exe";
char Streets2[MAX_PATH] = "C:\\Program Files\\Microsoft Streets & Trips\\";
char Streets3[] = "C:\\Program Files\\Microsoft Streets and Trips\\Streets.exe";
char Streets4[] = "C:\\Program Files\\Microsoft Streets and Trips\\";
//					0  1  2  3  4  5  6  7  8  9 10 11 12 13
BYTE ZoomTable[] = {0, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 2, 2, 2};
//					   1  2  4  8  8 16 32 64  4  8 16 32 64128256
COLORREF WaypointColor = 0x00FF00, TrackColor = 0xC08000, RouteColor = 0xFFFFFF, PositionColor = 0xFFFF00, TextColor = 0x00FFFF, APRSColor = 0xFF, TigerColor = 0xFF;
COLORREF StartColor = 0x00FF00, EndColor = 0x0FF, TrackSegmentColor;

DWORD ExitCode;
STARTUPINFO si;
PROCESS_INFORMATION pi;
char PushPins[MAX_PATH];
char ScreenFile[] = "Screen01.jpg";
char ShowNameComment[] = "ShowNameComment=YES\r\n";
char DontShowNameComment[] = "ShowNameComment=NO\r\n";
char ShowDescription[] = "ShowDescription=YES\r\n";
char Deg[] = "LatLonUTM=DEG\r\n";
char Min[] = "LatLonUTM=MIN\r\n";
char Sec[] = "LatLonUTM=SEC\r\n";
char Utm[] = "LatLonUTM=UTM\r\n";
char Usng[] = "LatLonUTM=USNG\r\n";
char Zoom1[] = "ZoomLevel=1\r\n";
char Zoom2[] = "ZoomLevel=2\r\n";
char Zoom3[] = "ZoomLevel=3\r\n";
char Zoom4[] = "ZoomLevel=4\r\n";
char Zoom5[] = "ZoomLevel=5\r\n";
char Zoom6[] = "ZoomLevel=6\r\n";
char Zoom7[] = "ZoomLevel=7\r\n";
char Zoom8[] = "ZoomLevel=8\r\n";
char DoShowNearest[] = "ShowLatlon=YES\r\n";
char DontShowNearest[] = "ShowLatlon=NO\r\n";
char DoShowName[] = "ShowName=YES\r\n";
char DontShowName[] = "ShowName=NO\r\n";
char DoSortbyName[] = "SortbyName=YES\r\n";
char DontSortbyName[] = "SortbyName=NO\r\n";
char ZoomTo8Meters[] = "ZoomTo8Meters=YES\r\n";
char DontZoomTo8Meters[] = "ZoomTo8Meters=NO\r\n";
char Topo[] = "Topo=YES\r\n";
char NotTopo[] = "Topo=NO\r\n";
char UrbanColor[] = "Topo=QQ\r\n";
char OpenAtClosing[] = "OpenAtClosing=YES\r\n";
char DontOpenAtClosing[] = "OpenAtClosing=NO\r\n";
char FadeIncr[] = "FadeIncrement=00\r\n";
char Spaces2[] = "Spaces2Move=0\r\n";
char WaypointColour[] = "WaypointColor=0x00FF00\r\n";
char RouteColour[] = "RouteColor=0xFFFFFF\r\n";
char TrackColour[] = "TrackColor=0xC08000\r\n";
char PositionColour[] = "PositionColor=0xFFFF00\r\n";
char TextColour[] = "TextColor=0x00FFFF\r\n";
char APRSColour[] = "APRSColor=0x0000FF\r\n";
char TigerColour[] = "TigerColor=0x0000FF\r\n";
char Meter1PhotoDot[] = "1MeterPhotoWaypointDot=4\r\n";
char Meter2PhotoDot[] = "2MeterPhotoWaypointDot=3\r\n";
char Meter4PhotoDot[] = "4MeterPhotoWaypointDot=3\r\n";
char Meter8PhotoDot[] = "8MeterPhotoWaypointDot=3\r\n";
char Meter16PhotoDot[] = "16MeterPhotoWaypointDot=3\r\n";
char Meter32PhotoDot[] = "32MeterPhotoWaypointDot=3\r\n";
char Meter64PhotoDot[] = "64MeterPhotoWaypointDot=3\r\n";
char Meter4TopoDot[] = "4MeterTopoWaypointDot=6\r\n";
char Meter8TopoDot[] = "8MeterTopoWaypointDot=4\r\n";
char Meter16TopoDot[] = "16MeterTopoWaypointDot=3\r\n";
char Meter32TopoDot[] = "32MeterTopoWaypointDot=3\r\n";
char Meter64TopoDot[] = "64MeterTopoWaypointDot=3\r\n";
char Meter128TopoDot[] = "128MeterTopoWaypointDot=3\r\n";
char Meter256TopoDot[] = "256MeterTopoWaypointDot=3\r\n";
char Meter512TopoDot[] = "512MeterTopoWaypointDot=3\r\n";
char Meter14UrbanDot[] = "14MeterUrbanWaypointDot=6\r\n";
char Meter12UrbanDot[] = "12MeterUrbanWaypointDot=6\r\n";
char Meter1LineWidth[] = "1MeterLineWidth=3\r\n";
char Meter2LineWidth[] = "2MeterLineWidth=2\r\n";
char Meter4LineWidth[] = "4MeterLineWidth=2\r\n";
char Meter8LineWidth[] = "8MeterLineWidth=2\r\n";
char Meter16LineWidth[] = "16MeterLineWidth=2\r\n";
char Meter32LineWidth[] = "32MeterLineWidth=1\r\n";
char Meter64LineWidth[] = "64MeterLineWidth=1\r\n";
char Meter4TopoLine[] = "4MeterTopoLine=2\r\n";
char Meter8TopoLine[] = "8MeterTopoLine=2\r\n";
char Meter16TopoLine[] = "16MeterTopoLine=2\r\n";
char Meter32TopoLine[] = "32MeterTopoLine=2\r\n";
char Meter64TopoLine[] = "64MeterTopoLine=2\r\n";
char Meter128TopoLine[] = "128MeterTopoLine=2\r\n";
char Meter256TopoLine[] = "256MeterTopoLine=2\r\n";
char PhotoDot1[] = "4", PhotoDot2[] = "4", PhotoDot4[] = "4", PhotoDot8[] = "4", PhotoDot16[] = "4", PhotoDot32[] = "4", PhotoDot64[] = "4";
char TopoDot4[] = "6", TopoDot8[] = "4", TopoDot16[] = "3", TopoDot32[] = "3", TopoDot64[] = "3", TopoDot128[] = "3", TopoDot256[] = "3", TopoDot512[] = "3";
char UrbanDot14[] = "6", UrbanDot12[] = "6";
char LineWidth1[] = "2", LineWidth2[] = "2", LineWidth4[] = "2", LineWidth8[] = "2", LineWidth16[] = "2", LineWidth32[] = "2", LineWidth64[] = "2";
char TopoLine4[] = "4", TopoLine8[] = "4", TopoLine16[] = "4", TopoLine32[] = "4", TopoLine64[] = "2", TopoLine128[] = "2", TopoLine256[] = "2";
char ShowText[] = "ShowText=YES\r\n";
char DontShowText[] = "ShowText=NO \r\n";
char APRSBAUD[] = "APRSBaud=";
char APRSCOM[] = "APRSCommPort=";
char APRSMyCall[] = "MyCall=";
char APRSHomeLatLon[] = "HomeLatLon=";//3724.44N/12206.98W
char APRSTransmitTo[] = "TransmitTo=";
char None[] = "NONE";
char Home[] = "HOME";
char GPS[] = "GPS ";
char APRSHomeSymbol[] = "HomeSymbol=";
char APRSGPSSymbol[] = "GPSSymbol=";
char APRSDestination[] = "Destination=";
char APRSComment[] = "Comment=";
char APRSBeacon[] = "BEACON=";
char SBSlowSpeed[] = "SBSlowSpeed=";
char SBSlowBeacon[] = "SBSlowBeacon=";
char SBHighSpeed[] = "SBHighSpeed=";
char SBHighBeacon[] = "SBHighBeacon=";
char SBTurnTime[] = "SBTurnTime=";
char SBAngle[] = "SBAngle=";
char SBConstant[] = "SBConstant=";
char SB[] = "SmartBeaconing=YES\r\n";
char Compressit[] = "Compressit=YES\r\n";
char USAPMini[] = "USAPM.ini";
char *pUSAPMbufIn;
char USAPMbufOut[100];
char *pRoutes, *prs;
char Raut[300];
char RouteDist[10];
char Acres[20];
int prevDist[TOTAL_LOCS];
int prefInMouseLoc, prefInZoom, prefInLatlon;
int prefOutMouseLoc, prefOutZoom, prefOutLatlon, prefOutName;
int sign, decPos, trackUTMZone, offset, nearest;
double routeDist, d, xleg, yleg, legsquared;
double totalRouteDist[MAX_PTR];
double Easting, Northing;

char IniBAK[] = "USAPhotoMapsBAK.ini";
char ProgName[] = "USAPhotoMaps";
char USAPhotoMapsIni[] = "USAPhotoMaps.ini";
			   //0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
char UTM[] =    "USAPhotoMaps        UTM: Easting xxx,xxx Northing x,xxx,xxx Zone xx   Zoom:  1 meter /pixel   Elev: xxxx'  Photo      ";
char USNG[] =   "USAPhotoMaps        USNG:                                             Zoom:  1 meter /pixel   Elev: xxxx'  Photo      ";
char LatLon[] = "USAPhotoMaps           N                   W                          Zoom:  1 meter /pixel   Elev: xxxx'  Photo      ";
char Nearest[]= "USAPhotoMaps                                                          Zoom:  1 meter /pixel";
char RowName[] ="USAPhotoMaps              Row Name: zZZy                 ";

char Registry[] = "Couldn't open the Registry!";
char Instruct[] = "USAPhotoMaps.txt";
char ElevationHelp[] = "ElevationHelp.txt";
char ApproachControlHelp[] = "ApproachControl.txt";
char AdvancedApproachControlHelp[] = "AdvancedApproachControl.txt";
char NoHelpFile[] = "Couldn't find USAPhotoMaps.txt";
//char ElevationLocs[] = "ElevationLocs.txt";
//char NoElevationLocs[] = "Couldn't find ElevationLocs.txt";
char USAPhotoMapsData[] = "USAPhotoMapsData";
char BIGPhotoMapsData[] = "BigPhotoMapsData";
char pointerFileName[] = "USAPhotoMapsData\\z00y00000.xxx";
char fileName[] = "USAPhotoMapsData\\z00y00000.xxx";//row data file
char cachName[] = "USAPhotoMapsData\\z00y00000.xxx";//row data file
char TigerHelp[] = "Tiger.txt";

int West, North, East, South, remainder;
int lSquare, rSquare, tSquare, bSquare;
int MetersPerTile = 200;
int PadBytes;
char CurrentDir[MAX_PATH];
char CurrentTrackDir[MAX_PATH];
WORD DType;
char *ptrToAscii;

typedef struct {
	BOOL timing;
	BOOL garmintiming;
	BOOL nmeatiming;
	BOOL gotprotocol;
	HWND hwnd;
	int time;
} TIMERFLAGS;
TIMERFLAGS TimerFlags;
int fromFlag = NOBUTTON;
char Oops[] = "Oops";
int garminflag = 0;

unsigned char ReceivedPID, ReceivedDataSize, ReceivedData[0xFF];
char fileName0, fileName1, fileName2;
char PreError[] = "The ChangeZone error\noccurred when called from ";
char Error[300];
int Baud;
unsigned long hThread, hDownloadThread, hDownloadStatesThread, hDownloadUTMThread, hUSBThread = 0, hHTTPThread, hCacheThread;
int SizeOfDP;
char DownloadProgress[40] = "000000 of       ";
int Pointers[2902], oldPointers[2902], oldNumOfPointers;
int FirstOffset, PointerOffset, NumOfPointers;
int rowOffset, colOffset, TopRowOffset, TilesAcross, oldTilesAcross, TilesDown, oldTilesDown;
int row, col;
unsigned int big_buf_size, big_jpeg_size;
void *big_buf;//points to big un-jpeged data
void *big_jpeg_buf;//points to big jpeg data

char PrintInfo[] = "Select Landscape Orientation\nin Print Preferences";
PRINTDLG pd;
DOCINFO di = { sizeof(DOCINFO), "USAPM", NULL, NULL, 0 };
POINT Polypoints[1000];//for Polyline
int xcon, ycon;
int num, tnum;
int ScreenElev[41<<6];//[41][64];
int highest, lowest;
int xCon, yCon, xConMax, yConMax, Diff, TotalDiff, topleftrow, topleftcol;
int llElev, lrElev, urElev, tl, bl, tr, br, mid, contour, diff;
char New[40<<6];//2560
WORD *DemData[500];
int Associated[500];
COLORREF color, colorDiff;
int *pDem, WaypointProt;
int Noffset, Eoffset, ElevOffset, IdentOffset, LocOffset, SymOffset;
char NewProtocol[] = "Email jdmcox@jdmcox.com\nand tell him the new\nwaypoint protocol is    ";
char ElevIni[] = "Elev.ini";
char DemName[MAX_PATH];
char *pDemIni;
int NumOfDems, ScreenDems, DemNameBegin, ElevRow, ElevCol, ElevRowCounter, ElevColCounter;
char CourierNew[] = "Courier New";
char ComicSansMS[] = "Comic Sans MS";
char Sanserif[] = "Microsoft Sans Serif";
char Arial[] = "Arial";
//char Roman[] = "Roman";
//char Fixedsys[] = "Fixedsys";
//char System[] = "System";
LOGFONT lf, lf2, lf3, lf4, lf5, lf6;
HFONT hFont, hFont2;
BOOL showElev = FALSE, reliefShading = FALSE;
struct DEMS {
	int Zone;
	int North;
	int West;
	int South;
	int East;
	int Rows;
	int Cols;
//	double Lat;
//	double Lon;
	char Name[17];
	char Meas;
} Dem[MAX_DEMS];

unsigned char FirstIni[] = "*Washington,DC&X=1613&Y=21532&Z=18\r\n";
char Area[AREA_SIZE];//Map Location
char myLat[20] = "38.889447";// = "18.468";
char myLon[20] = "77.044418";// = "66.121";
static char NewLocations[MAX_PATH];//e.g."PuertoRico.xml"
static char NewLocationsFullPath[MAX_PATH];//e.g."C://My Documents//USAPhotoMaps//PuertoRico.xml"
			         //01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
char URLName[] = "http://msrmaps.com/tile.ashx?t=1&s=10&x=2890&y=20702&z=10";//http:
char TopoURLName[] = "http://msrmaps.com/tile.ashx?t=2&s=12&x=936&y=5435&z=10    ";//4,348,672 750,348
char ColorURLName[] = "http://msrmaps.com/tile.ashx?t=4&s=                          ";
//tile.ashx?t=4&s=8&x=11327&y=105600&z=10
//char URL[] = "\r\nhttp://msrmaps.com/GetImageArea.ashx?t=4&s=                                                    ";
//                                                                   10&lon=-77.444444&lat=38.888888&w=1024&h=768";
//                012345678901234567890123456789012345678901234567890123456789
char GetDate[] = "http://msrmaps.com/ImageInfo.aspx?T=1&S=14&Z=10&X=180&Y=1295";

char GPSHelp[] = "GPSHelp.txt";
char GPStxt[] = "GPS.txt";
char GPSdta[] = "GPS.dta";
char USBdta[] = "USB.dta";
char Tracks[MAX_PATH];
char FullTracks[MAX_PATH];
char Waypoints[MAX_PATH];
char WaypointsFullPath[MAX_PATH];
char Routes[MAX_PATH];
char FullRoutes[MAX_PATH];
char NoGPSFile[] = "Couldn't find GPSHelp.txt";
char ZoneName[] = "10y";
char Ptr[] = ".ptr\0";
char Dta[] = ".dta\0";
char X[8], Y[8], Z[3];
int BeginX, BeginY, UTMZone, tempUTMZone, tempUTMN, tempUTME, BigBeginX, BigBeginY, beginX, beginY, endX, endY;
int MapWidth, MapHeight;
int iBuf, xBuf, UTMEasting = 0, UTMNorthing = 0, ScreenLeft, ScreenTop, ScreenRight, ScreenBottom;
int InsertLoc, EmptyLoc, ChosenLoc, LineEnd = -1, Response, DotX, DotY, DotX2, DotY2, DotRadius, xLoc, yLoc, lButtonDotX, lButtonDotY;
int LastWay, MouseLoc = DEG, IniNumber, fileSize, fileSize2, fileSizeWx, dataFileSize, DEMfileSize, DLECount;
int cxChar, cyChar, cxScreen, cyScreen, TitleAndMenu, Frame, xFrame = 0;
char Counter[] = "GPS";
char PreCounting[10];
char Counting[13] = "0000 of 0000";
char PostCounting[10];
char Up[] =        "Sending  ";
char Down[] =      "Receiving";
char Way[] =       "Waypoints";
char Track[] =     "Tracks   ";
char Routetxt[] =  "Points   ";
char Number[6];
char USADta[] = "USA.not";
char TextDta[MAX_PATH];//e.g."Text.not";
char Not[] = ".not\0";
char Xml[] = ".xml\0";
char TextBuf[MAX_TEXT];
int xBeg, yBeg, TextBufSize, UTMCenterX, UTMCenterY, centerX, centerY, distance, LineRight, xPos, yPos, SavePosX, SavePosY;
int HorizCenter, VertCenter;
int Units, MapUnits, BaudUnits, count;
unsigned char TileBuf[MAX_TILE_SIZE];
unsigned char Buf[50000];
int PrevMetersPerTile = 0, PrevPixelsPerTile;

char LatLonUTM[600];
char GARMIN[] = "GARMIN";
char NMEA[] =   "NMEA  ";
char USB[] =	"USB   ";
char EXPL[] =   "eXplor";
char eXploristDir[] = "eXplorist";
char *pProtocol;
char LocBuf[100];
char IdentBuf[100];
char DescBuf[10000];
unsigned char Waypoint[WAYPOINT_SIZE];
signed int semicircleN, semicircleE;
unsigned char checksum, c, c2;
int LocNum, index, ProtocolCheck1, ProtocolCheck2, ProtocolCheck3;
signed char Increment = 0;
char *pHelp, *pGPSHelp, *pFind, *pTigerHelp, *pElevationHelp, *pApproachHelp;
unsigned char *pIniBuf, *pIniBuf2;
int Zoom = 1, zoom;
int PixelsPerTile = 200;
int ImageSize = MAX_IMAGE_SIZE;
double Lat, Lon, LatRad, LonRad, degrees, minutes, seconds, tempLat, tempLon, lat, lon, dElev;
double rad2deg = 180.0/PI, deg2rad = PI/180.0;
double semicircle2deg = 180.0 / 2147483648.0;
double semicircle2rad = PI / 2147483648.0;
double deg2semicircle = 2147483648.0 / 180.0;
double a0 = 6378137;//Equatorial Radius for WGS-84 datum
double ECC_SQUARED = 0.006694379990;//Eccentricity Squared for WGS-84 datum
double eccPrimeSquared = ECC_SQUARED/(1-ECC_SQUARED);
double k0 = 0.9996;
double A, B, Angle;
UINT idThread, idThread2, idThread22, idThread3, idThread4, idThread5, idThread6, idThread7, idThread8, idThread9, idThread10, idThread11, idThread12, idThread13, idThread14, idThread15, idThread16, idThread17;
DWORD RegKeyResult, RegValueSize = 21, RegValue2Size = MAX_PATH, RegType = REG_SZ;
DWORD dwBytesRead, dwBytesWritten;
char NewComm[] = "\\\\.\\COM  ";
unsigned char RegValue2[MAX_PATH];
unsigned char RegValue[] = "COM0 NMEA   x       ";//0 is Comm Port, x is Garmin type, ' ' is baud
unsigned char OrigRegValue[] = "COM0 NMEA   x       ";//0 is Comm Port, x is Garmin type, ' ' is baud
char SelectCommPort[] = "Select a Comm Port first.";
char SubKey[] = "Software\\USAPhotoMaps";
PHKEY RegKeyHandle;
BOOL brandnew = FALSE, autoLoc = FALSE, goodcomm = FALSE, showingtracks = FALSE, showlatlon = TRUE, deletestring, itsfull, makewaypoint = FALSE;
BOOL sendingStop = FALSE, newLoc = FALSE, newText = FALSE, itsmagellan = 0, itsgarmin, itsusb, suspendedthread = FALSE, showname = FALSE, newelev = FALSE;
BOOL fromOpen = FALSE, fromTracks = FALSE, fromGoTo = FALSE, gota100, gota300, gotd, d300 = TRUE, d301, d302, d310, d201, d210, showtext = TRUE, fillscreen = TRUE;
BOOL downloading = FALSE, downloadflg, sendingWaypoints = FALSE, gettingroute = FALSE, sendingrouteheader = FALSE, sendingroute, sendingroutelink;
BOOL drawing = FALSE, controldown = FALSE, showingroute = FALSE, inutmzone, gotzero, sockets, editingtracks = FALSE, sendingtrackheader = FALSE;
BOOL gotway, gotname, gotcmt, gotdescr, gotelev, gotsym, enteringtext = FALSE, nomessages, feet, zoom1to8 = FALSE, USBdownloading = FALSE, showingdata = FALSE, showingtrackdata;
BOOL sortbyname = FALSE, fromwaypoints = FALSE, itspstip, foroute = FALSE, gotroute = FALSE, sendroutewaypoints = FALSE, USBdownloadflg;
BOOL ctrlnotused = TRUE, onetime, gridon = FALSE, contourson = FALSE, trackcolors, fromgoto, internetconnect, gotblanktile, fromposition = FALSE;
BOOL gotelevini, itsmeridian = FALSE, gotver, goodread, newmin, onewaypoint = FALSE, openatclosing = TRUE, veryfirstime = TRUE, firstlbutton, firstrbutton;
BOOL grid75 = FALSE, shownamecomment = FALSE, showdescription = FALSE, itsnetstumbler, bigjpeg = FALSE, buttondown = FALSE, gettingtracks = FALSE, onemeter = FALSE;
BOOL itsx = FALSE, fromusbtracks = FALSE, copyit, itswpt, getelev = FALSE, distancemeasure = FALSE, notfromroute = TRUE, terrafetcher = FALSE, fromconvertloctoxml = FALSE;
BOOL savetracks, mousewheel = FALSE, counteropen = FALSE, itsexplorist, notthere;
int numofTracks, TrackNum, TrackSize, magflag = 0, waypointinini, showstreets = FALSE, saveshowstreets, showstreetnames = FALSE, onepositiondot = FALSE;
char DirName[MAX_PATH];
								  //DLE PID SIZE DATA   CHKSUM DLE ETX
unsigned char Pid_Product_Rqst[] ="\x10\xFE\x02\x00\x00\x00\x10\x03";// to get Pid_Product_Data
unsigned char StartPVTPacket[] =  "\x10\x0A\x02\x31\x00\xC3\x10\x03";
unsigned char StopPVTPacket[] =   "\x10\x0A\x02\x32\x00\xC2\x10\x03";
unsigned char SendWaypoints[] =   "\x10\x0A\x02\x07\x00\xED\x10\x03";
unsigned char SendTracks[] =	  "\x10\x0A\x02\x06\x00\xEE\x10\x03";
unsigned char SendRoutes[] =	  "\x10\x0A\x02\x04\x00\xF0\x10\x03";
unsigned char BeginRecords[] =	  "\x10\x1B\x02\x06\x00\xDD\x10\x03";//x06 for sending 6 records
unsigned char BeginRecords2[] =   "\x10\x1B\x02\x10\x10\x00\xD3\x10\x03";//x10 for sending 16 records
unsigned char EndRecords[] =	  "\x10\x0C\x02\x07\x00\xEB\x10\x03";//x07 for SendWaypoints type
unsigned char ACKPacket[] =	      "\x10\x06\x02\x00\x00\x00\x10\x03";
//unsigned char ACKPacket2[] =	  "\x10\x06\x02\x00\x00\x00\x10\x10\x03";//if checksum is 0x10
unsigned char SendTrack[82];//82 is max NMEA length
unsigned char SendRouteHeader[50];
//unsigned char SendMagellanHANDON[] = "$PMGNCMD,HANDON*70\x0D\x0A";
unsigned char SendMagellanHANDOFF[] = "$PMGNCMD,HANDOFF*3E\x0D\x0A";
//unsigned char SendMagellanTON[] = "$PMGNCMD,TON*27\0x0D\x0A";//doesn't work
//unsigned char SendMagellanTOFF[] = "$PMGNCMD,TOFF*69\0x0D\x0A";//doesn't work
//unsigned char SendMagellanChecksum[] = "$PMGNCSM,hh*hh\x0D\x0A";
unsigned char GetMagellanVersion[] = "$PMGNCMD,VERSION*28\x0D\x0A";
unsigned char GetMagellanWaypoints[] = "$PMGNCMD,WAYPOINT*71\x0D\x0A";
//unsigned char GetMagellanTracks[] = "$PMGNCMD,TRACK*3D\x0D\x0A";
unsigned char GetMagellanTracks[] = "$PMGNCMD,TRACK,2*23\x0D\x0A";
unsigned char GetMagellanRoute[] = "$PMGNCMD,ROUTE*2B\x0D\x0A";
unsigned char SendEnd[] = "$PMGNCMD,END*3D\x0D\x0A";
unsigned char SendMagWaypoints[100];
char Wpl[] = "$PMGNWPL,";

struct Posishun{
	int UTMZ;
	int UTMN;
	int UTME;
	int Alt;
	int HorizEpe;
	int VertEpe;
	float Velocity;
	WORD Course;
//	float RateOfClimb;
	BYTE Hour;
	BYTE Min;
	BYTE Sec;
	BYTE Month;
	BYTE Date;
	BYTE Year;
//	BYTE New;
//	BYTE Filler;
}
Position[14400];//4 hours

int pos = 0;
BOOL newposition;
int LineType, Time;
BOOL posflag = TRUE;
char Posit[] = "Position Data will be displayed here when you move the cursor over a position dot.";
HWND hwndPosit;

struct TRAC {
	signed int NUTM;
	signed int EUTM;
	unsigned int time;
	float alt;
	double dist;
	COLORREF color;
	unsigned char newtrk;
	unsigned char year;//year - 2000
} *trak;

char Trac[] = "Track Data will be displayed here when you move the cursor over a track point.";
HWND hwndTrack;

struct {
	int NUTM;
	int EUTM;
	unsigned int time;
} oldTrack;

char MeridianFullName[MAX_PATH];
char MeridianName[MAX_PATH];
int trackcommas, firsttrack;
unsigned int hour, minute, second;
unsigned int Month, Day, Year;
unsigned char *pTrackBuf;
char OldTrackHead[] = "Track,UTM Zone,UTM Northing,UTM Easting,Month,Date,Hour,Min,Sec,Alt (Meters)\r\n";
char TrackHead[] = "Track,UTM Zone,UTM Northing,UTM Easting,Hour,Min,Sec,Month,Date,Year,Altitude\r\n";
unsigned char Trackid[100];

struct _SYSTEMTIME st, *lpSystemTime = &st;
struct _FILETIME ft, *lpFileTime= &ft;
LARGE_INTEGER li;
__int64 quad;

struct newloc {
	int NUTM;
	int EUTM;
	int UTMZone;
	int size;
	char *pWaypoints;//pointer to waypoint data in WaypointArray
	char *Ident;//pointer to name
	char *Location;//pointer to cmt
	char *Description;//pointer to desc
	char *Elev;//pointer to ele
	char *Sym;//pointer to sym
} NewLoc[TOTAL_LOCS];

char *WaypointArray;
char *tempWayArray;
int NumOfWaypoints, WaypointSize, MaxWaySize, SendWaypointSize, firstx, size;
char WaypointLimit[] = "The waypoint size limit has been reached.\nClose and re-open USAPhotoMaps to edit\nor add more waypoints.";
char Ident[100];
char Location[100];
char Description[10000];
char Combined[100];
char BigJpegCombined[] = "Create eXXXXXXnYYYYYYYzZZx.jpg\n  from eXXXXXXnYYYYYYYzZZx.txt\n(modified on mm/dd/yyyy at hh:mm)?";
char Elev[30];
char Sym[30];
char WashingtonXML[] = "Washington,DC.xml";
char Top[] = "\
<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>\r\n\
<gpx version=\"1.0\" creator=\"USAPhotoMaps - http://jdmcox.com\"\r\n\
 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\
 xmlns=\"http://www.topografix.com/GPX/1/0\"\r\n\
 xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0\r\n\
 http://www.topografix.com/GPX/1/0/gpx.xsd\">\r\n";
char WashingtonWaypoint[] = "<wpt lat=\"38.889329\" lon=\"-77.046525\">\r\n<cmt>Washington</cmt>\r\n</wpt>\r\n</gpx>\r\n";

int temp, tempNUTM, tempEUTM, temp2UTMZone, longest;
char TheKey[] = "d9sa82";//no key";
char *tempWaypoints, *tempIdent, *tempLoc, *tempDesc, *tempElev, *tempSym;
char Bottom[] = "</gpx>\r\n";
char Name[] = "<name>";
char EndName[] = "</name>\r\n";//<cmt>";
char Cmt[] = "<cmt>";
char CmtEnd[] = "</cmt>\r\n";
char Desc[] = "<desc>";
char DescEnd[] = "</desc>\r\n";
char WptEnd[] = "</wpt>\r\n";
UINT u;
float f, Velocity;
double eleM;
HWND hwnd, hwndCounter;

struct Text {//80 bytes
	int NUTM;
	int EUTM;
	int angle;//the double Angle is converted to a long before use
	char text[MAX_TEXT];
	struct Text *next;
	int Zoom;
} *cur, *prev, *next, *new_node, *head, *chosen, *savedHead;

struct {
	int Z;
	int N;
	int E;
	char Ident[52];
} RouteWay[TOTAL_LOCS];
int routeway;

struct Route {
	int UTMZone;
	int NUTM;
	int EUTM;
} *pRoute, *pr;
int ptr;
int pixelptr;

struct {
	int Z;
	int N;
	int E;
} Root[50][300];
int RouteNum, RouteSize[300], rte, RoutePoint;
int totalroutelines, routeline, numofRoutes;
char RouteName[3];
char RouteComment[300][21];
char Nums[500][7];
char Num[] = "ZZZZZZ";
char Rute[] = "$PMGNRTE,";
char SendRoute[82];

char TerraFetcherInfo[] = "\
Move the mouse cursor to a corner of the area\n\
you want to create a TerraFetcher Region file for,\n\
press and hold the left mouse button,\n\
and move the mouse to the\n\
diagonally opposite corner of that area,\n\
(use the Arrow keys to get an area larger than the screen)\n\
and then release the mouse button.";


char BigJpegInfo[] = "\
Move the mouse cursor to a corner of the area\n\
you want to create a BIG jpeg file of,\n\
press and hold the left mouse button,\n\
and move the mouse to the diagonally opposite\n\
corner of that area,\n\
(use the Arrow keys to get an area larger than the screen)\n\
and then release the mouse button.";

char SendingRoute[] = "\
Before you send a route to your GPS,\n\
all routes and waypoints in your GPS\n\
should be saved to an SD card or to\n\
USAPhotoMaps or another program,\n\
because your GPS could over-write them.\n\
\n\
The waypoints for the route are named\n\
\"1\" thru the number of them.";

char CreateRoute[] = "\
Click the left mouse button to make a point.\n\
Move the mouse pointer to make a line.\n\
Click again to continue the route.\n\
Press Ctrl-Z to delete last point.\n\
Double-click or press Escape when finished.";

CRITICAL_SECTION cs;
DCB dcb, dcb2;
WIN32_FIND_DATA fd;
BITMAPINFOHEADER bmih, *pbmih = &bmih, bmih2, *pbmih2 = &bmih2, bmih3, *pbmih3 = &bmih3, bmih4, *pbmih4 = &bmih4, bmih5, *pbmih5 = &bmih5;
BITMAPINFO bmi, *pbmi = &bmi, bmi2, *pbmi2 = &bmi2, bmi3, *pbmi3 = &bmi3, bmi4, *pbmi4 = &bmi4, bmi5, *pbmi5 = &bmi5;
JPEG_CORE_PROPERTIES jcprops;
IJLERR jerr;
HANDLE hGZFile, hFile, hFile2, hFile3, hFile4, hPosFile = INVALID_HANDLE_VALUE, hComm, hEventExit, hEvent, hTimerEvent, hUSBEvent, hThreadEvent, hTigerEvent, hTigerReturn, hCacheOk, hCacheEvent, hAPRSEvent, hAPRSISEvent;
PAINTSTRUCT ps, ps2;
RECT rect, counterRect, posRect, socketsRect;
HKEY hRegKey, hRegKey2;
HDC hdc, hdcMem, hdcMem2 = NULL, hdcMem3 = NULL, hdcGrayMem, hdcBlackMem, hdcPrn, hdcButton, hdcMap;
HBITMAP hBitmap, hBitmap2, hBitmap3, hPrnBitmap, hGrayBitmap, hRedBitmap, hSymbolBitmap = NULL;
HBRUSH hBrush, hPositionBrush, hRedBrush, hWaypointBrush, hStartBrush, hEndBrush, hRadiationBrush, hAPRSBrush, hBlankBrush;
HPEN hPen, hRoutePen, hTrackPen, hAPRSPen, hRedPen, hWhitePen, hBlackPen;
HINSTANCE hInst;
HMENU hMenu, hMenu2, hMenu3, hMenu4, hMenu5;
COMMPROP cp, cp2;
COMMTIMEOUTS cto, APRScto;
OPENFILENAME ofn, ofn2, ofn3, ofn4, ofn5, ofn6, ofn7;
HCURSOR hCursor, hDrawingCursor, hWaitingCursor;
HGDIOBJ hObject, hObject2, hCircleBrush, hOldBrush, hOldPen;
HINTERNET hOpen;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK InstructProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK CounterProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK TigerCountProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK PosProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK TrackProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK StreetProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK StreetEditProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ElevationProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK BigProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK USAProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK DescEditProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK PhotoProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK EditListProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK EditInfoListProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK SymbolChartProc(HWND, UINT, WPARAM, LPARAM);
WNDPROC pEditProc, pPosProc, pTrackProc, pElevProc, pStreetProc, pStreetEditProc, pCommProc, pEdit1Proc, pEdit2Proc, pDescEditProc, pStaticProc, pEditListProc, pInfoListProc;
UINT WINAPI DownloadThread(void*);
UINT WINAPI DownloadStatesThread(void*);
UINT WINAPI DownloadStateOutlineThread(void*);
UINT WINAPI DownloadUTMThread(void*);
UINT WINAPI CommThread(void*);
UINT WINAPI TigerCommThread(void*);
UINT WINAPI TigerThread(void* pParam);
UINT WINAPI TimerThread(void*);
UINT WINAPI USBThread(void* pParam);
UINT WINAPI URLThread(void*);
UINT WINAPI FillCacheThread(void*);
UINT WINAPI APRSCommThread(void*);
UINT WINAPI aprsISthread(void*);
UINT WINAPI aprsISthread2(void*);
int CALLBACK GetLocationProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK CheckLocationProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK CheckTextProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK EditLocationProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK WelcomeProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK OpenProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK FindUSGSProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK GotoProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK GotoUSNGProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK GetLatLonProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK GetTextProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK EditTextProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK PreferencesProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK ColorsProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK DotProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK LineWidthProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK LatLonProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK TrackColorsProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
int CALLBACK GetFilenameProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK USGSProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK AddressProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK FindProc(HWND, UINT, WPARAM, LPARAM);
int CALLBACK DescriptionProc(HWND hBeg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK CommPortProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK LineProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
void Convert_TileBuf_hdcMem(unsigned char*, unsigned int);
void LatLontoUTM(void);
void UTMtoLatLon(void);
void GetLatLon(void);
void LatorLon(int, int);
void GetUTM(int North, int West);
void GetUSNG(int North, int West);
void ShowDistance(int, int, int);
void ShowNearest(int);
void RedDot(HWND hwnd);
void PrepWaypoint(void);
int PrepMagellanWaypoint(void);
void PrepRoute(void);
int PrepTrack(void);
void ClearLine(void);
void GetURLName(void);
void GetTopoURLName(void);
void GetColorURLName(void);
BOOL GetXYZfromIniBuf(void);
void GetCommHandle(void);
void GetCommHandle2(void);
void IncCount(void);
void IncNumber(void);
void SetRegKey(int);
void SetRegKey2(char*, int);
void SaveLocs(void);
void SaveText(void);
void MenuChecks(void);
void ShowZoom(void);
void DoZoom(void);
int PutSemicircles(int);
void GetContour(void);
BOOL PrepBox(int);
void GPSockets(void);
void DrawLineTo(int, int);
void DrawLine2(int, int, int);
void InitializeOpenFileNameLogFont(HWND);
//void SendChecksum(void);
void FillWaypointArray(int);
int FillListBox(HWND);
int ReadTracks(int);
void WriteTracks(HANDLE, int);
void ChangeZone(int xUTMZone, int from);
void ShowError(int);
void CheckRadio(HWND hwndDlg, int red, int green, int blue);
int AsciiToHex(int);
void GetRandomNum(void);
DWORD PrepSendRoute(void);
void ShowDownloadProgress(int);
BOOL CheckFormat(int);
void XMLError(int);
void ShowTopo(void);
void ShowPhoto(void);
void ShowUrbanArea(void);
void GetRowName(int, int);
void GetDotRadius(void);
void GetPointerElev(int);
void ChangeBaud(void);
void ShowWaypointData(int, int);
void ConvertoMeridian(DWORD);
void GetMagSym(int x);
void GetSym(int);
int GarminSym(void);
void ChangeUSAPhotoMapsIni(void);
void ChangeUSAPMIni(void);
void SaveTracks(void);
void FillZoomTable(void);
void WriteDots(HANDLE hFile);
void WriteLineWidth(HANDLE);
void GetElevData(void);
void GridSeventyFive(void);
void store_pixel(int index);
int decodeLZW(void);
DWORD CreateTileBuf(unsigned char*, unsigned int);
int CheckIniProc(unsigned char*, DWORD, int);
void ShowPosition(void);
void SendPacket(DWORD dwBytesToSend);
void SaveDownloadedTracks(void);
void SaveDownloadedWaypoints(void);
void SignalUSBStop(void);
void ShowPackets(void);
void GetDems(void);
void SavePosition(void);
void GetFileName(void);
void CreateTracks(void);
void UncheckZoom(void);
BOOL GetUSGSData(void);
//DWORD ConvertSDTSData(void);
//int ReadLatLonData(void);
//int Subroutine(void);
//void ConvertLatLon(void);
BOOL GetDownloadedData(void);
void FindIt(void);
int BigJpeg(void);
void SavenameCommentProc(void);
void SaveDescriptionProc(void);
//void PreGetTigerData(void);
void GetTigerIndex(void);
int CALLBACK MapLocationProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK GetTigerProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
void FreepTiger(void);
void Uncheck(void);
int LatLontoLambertAzimuthal(double, double);
void GetCountyFromLatLon(void);
void InitDirectDraw(void);
void GetStateBorders(void);
int GetXY(void);
void ShowDistanceAngle(void);
void ModifyZoom(void);
void EditWaypoint(void);
void EndRoute(void);
void ConvertLocToXML(char *tempBuf, char *tempBuf2, int x, DWORD fileSize);
void SendMagRoutes(void);
//void GetExploristDir(void);
int GetExploristWaypoints(int);
void FillTrackFromNMEA(void);
LRESULT CALLBACK CommProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK Edit2Proc(HWND, UINT, WPARAM, LPARAM);
void GetAPRS(void);
void GetAPRSLL(void);
void GetAPRSLatLon(int);
void GetAPRSLatLon2(int);
void GetTNCLatLon(void);
void MicE(int);
void GetWX(int);
void GetAPRSlogFile(void);
void GetAPRSlogFile2(void);
int Uncompress(int);
void FillDescOrWx(int);
void SaveAPRSlog(void);
void SaveAPRSlogAsText(void);
void ParseAPRS(int);
void GetAPRSCommHandle(void);
int CALLBACK APRSCommPortProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ChangeAPRSBaud(int);
int CALLBACK APRSProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
DWORD AddtoUSAPMini(char*);
void FillMYCALLUNPROTOBTEXTKISS(void);
void ConvertoGPSLatLon(void);
int CALLBACK ExcludeSymbolsCallsProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK ExcludeTracksProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK APRSEditProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
void GetKiss(void);
void InitializeAPRSComm(void);
HDC ReadBmpFile(char *FileName);
void ShowIcon(int x);
int CALLBACK MessageProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK EditMessageProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK EditObjectProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK StationsProc(HWND hwndStationsDlg, UINT message, WPARAM wParam, LPARAM lParam);
void SortStations(HWND hwndList);
int CALLBACK StationInfoProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK GetObjectProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK SymbolsProc(HWND hwndListDlg, UINT message, WPARAM wParam, LPARAM lParam);
void LoadObjects(void);
void StationInfo(int x);
int CALLBACK TacticalProc(HWND hwndTacticalDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK APRSServerProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK SecretIPProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK CircleProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
//int CALLBACK LocalServerProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int GetInitString(void);
DWORD ConvertBILData(void);
int CALLBACK SmartBeaconingProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
void GetCourse(int x);
BOOL SmartBeacon(int x);
void GetSpeed(int x);
void LookForIgateMessages(void);
DWORD Atoi(char*);
void ApproachControl(void);
int CALLBACK NewPlaneProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK CenterlineProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK CommandProc(HWND, UINT, WPARAM, LPARAM);
MSG msg;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
	WNDCLASS     wndclass;

	hInst = hInstance;

	wndclass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	wndclass.lpfnWndProc   = WndProc;
	wndclass.cbClsExtra    = 0;
	wndclass.cbWndExtra    = 0;
	wndclass.hInstance     = hInstance;
	wndclass.hIcon         = LoadIcon (hInstance, MAKEINTRESOURCE (IDI_ICON1));
	wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH)CreateSolidBrush(LIGHTGRAY);//(HBRUSH)(COLOR_MENU+1);//GetStockObject(LTGRAY_BRUSH);
	wndclass.lpszMenuName  = "USAPHOTOMAPS";
	wndclass.lpszClassName = ProgName;

	if (!RegisterClass (&wndclass))
		return 0;

	wndclass.lpfnWndProc = InstructProc;
	wndclass.hIcon = NULL;
	wndclass.lpszClassName = Instruct;
	RegisterClass(&wndclass);

	wndclass.lpfnWndProc = CounterProc;
	wndclass.hIcon = NULL;
	wndclass.lpszClassName = Counter;
	RegisterClass(&wndclass);

	wndclass.lpfnWndProc = TigerCountProc;
	wndclass.hIcon = NULL;
	wndclass.lpszClassName = Tiger;
	RegisterClass(&wndclass);

	wndclass.lpfnWndProc = USAProc;
	wndclass.hIcon = NULL;
	wndclass.lpszClassName = USA;
	RegisterClass(&wndclass);

	wndclass.lpfnWndProc = BigProc;
	wndclass.hIcon = NULL;
	wndclass.lpszClassName = Big;
	RegisterClass(&wndclass);

	wndclass.lpfnWndProc = PhotoProc;
	wndclass.hIcon = NULL;
	wndclass.lpszClassName = Photos;
	RegisterClass(&wndclass);

	if (szCmdLine[0] != 0)
	{
		for (x = 0, y = 0; szCmdLine[x] != 0; x++)
			if (szCmdLine[x] != '"')
				CmdLine[y++] = szCmdLine[x];
		CmdLine[y] = 0;
	}
	if ((szCmdLine[0] == '-') && (szCmdLine[1] != 0))
	{
		USAPhotoMapsData[0] = szCmdLine[1];
		USAPhotoMapsData[1] = ':';
		USAPhotoMapsData[2] = '\\';
		pointerFileName[0] = szCmdLine[1];
		pointerFileName[1] = ':';
		pointerFileName[2] = '\\';
		fileName[0] = szCmdLine[1];
		fileName[1] = ':';
		fileName[2] = '\\';
	}

	hwnd = CreateWindow(ProgName, ProgName,
		WS_OVERLAPPEDWINDOW,
//		WS_OVERLAPPED|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_THICKFRAME,
		0, 0, 640, 480,
		NULL, NULL, hInstance, NULL);

	iCmdShow = SW_SHOWMAXIMIZED;//Petzold, p.59
	ShowWindow (hwnd, iCmdShow);
	UpdateWindow (hwnd);

	while (GetMessage (&msg, NULL, 0, 0))
	{
		TranslateMessage (&msg);
		DispatchMessage (&msg);
	}
	return msg.wParam;
}

int compareIdent(void const *x, void const *y)
{
	int w, z;
	BOOL xIdent, yIdent;

	if (((((struct newloc*)x)->Ident) != 0) && ((((struct newloc*)y)->Ident) != 0))
	{
		for (w = 0; ((struct newloc*)x)->Ident[w] != '<'; w++)
			;
		((struct newloc*)x)->Ident[w] = 0;//change "</cmt>" to "\0/cmt>"
		for (w = 0; ((struct newloc*)y)->Ident[w] != '<'; w++)
			;
		((struct newloc*)y)->Ident[w] = 0;//change "</cmt>" to "\0/cmt>"
		z = _stricmp(((struct newloc*)x)->Ident, ((struct newloc*)y)->Ident);
		for (w = 0; ((struct newloc*)x)->Ident[w] != 0; w++)
			;
		((struct newloc*)x)->Ident[w] = '<';//change "\0/cmt>" to "</cmt>"
		for (w = 0; ((struct newloc*)y)->Ident[w] != 0; w++)
			;
		((struct newloc*)y)->Ident[w] = '<';//change "\0/cmt>" to "</cmt>"
		return z;
	}
	else
	{
		if ((((struct newloc*)x)->Ident) == 0)
		{
			xIdent = FALSE;
			for (w = 0; ((struct newloc*)x)->Location[w] != '<'; w++)
				;
			((struct newloc*)x)->Location[w] = 0;//change "</cmt>" to "\0/cmt>"
		}
		else
		{
			xIdent = TRUE;
			for (w = 0; ((struct newloc*)x)->Ident[w] != '<'; w++)
				;
			((struct newloc*)x)->Ident[w] = 0;//change "</cmt>" to "\0/cmt>"
		}
		if ((((struct newloc*)y)->Ident) == 0)
		{
			yIdent = FALSE;
			for (w = 0; ((struct newloc*)y)->Location[w] != '<'; w++)
				;
			((struct newloc*)y)->Location[w] = 0;//change "</cmt>" to "\0/cmt>"
		}
		else
		{
			yIdent = TRUE;
			for (w = 0; ((struct newloc*)y)->Ident[w] != '<'; w++)
				;
			((struct newloc*)y)->Ident[w] = 0;//change "/cmt>" to "<\0/cmt>"
		}

		//now strcmp & put '<' back
		if ((xIdent == TRUE) && (yIdent == FALSE))
 		{
			z = _stricmp(((struct newloc*)x)->Ident, ((struct newloc*)y)->Location);
			for (w = 0; ((struct newloc*)x)->Ident[w] != 0; w++)
				;
			((struct newloc*)x)->Ident[w] = '<';//change "\0/cmt>" to "</cmt>"
			for (w = 0; ((struct newloc*)y)->Location[w] != 0; w++)
				;
			((struct newloc*)y)->Location[w] = '<';//change "\0/cmt>" to "</cmt>"
		}
		else if ((xIdent == FALSE) && (yIdent == TRUE))
		{
			z = _stricmp(((struct newloc*)x)->Location, ((struct newloc*)y)->Ident);
			for (w = 0; ((struct newloc*)x)->Location[w] != 0; w++)
				;
			((struct newloc*)x)->Location[w] = '<';//change "\0/cmt>" to "</cmt>"
			for (w = 0; ((struct newloc*)y)->Ident[w] != 0; w++)
				;
			((struct newloc*)y)->Ident[w] = '<';//change "\0/cmt>" to "</cmt>"
		}
		else if ((xIdent == FALSE) && (yIdent == FALSE))
		{
			z = _stricmp(((struct newloc*)x)->Location, ((struct newloc*)y)->Location);
			for (w = 0; ((struct newloc*)x)->Location[w] != 0; w++)
				;
			((struct newloc*)x)->Location[w] = '<';//change "\0/cmt>" to "</cmt>"
			for (w = 0; ((struct newloc*)y)->Location[w] != 0; w++)
				;
			((struct newloc*)y)->Location[w] = '<';//change "\0/cmt>" to "</cmt>"
		}
		return z;
	}
}

int compareLoc(void const *x, void const *y)
{
	int w, z;
	BOOL xLoc, yLoc;

	if (((((struct newloc*) x)->Location) != 0) && ((((struct newloc*) y)->Location) != 0))
	{
		for (w = 0; ((struct newloc*)x)->Location[w] != '<'; w++)
			;
		((struct newloc*)x)->Location[w] = 0;//change "</cmt>" to "\0/cmt>"
		for (w = 0; ((struct newloc*)y)->Location[w] != '<'; w++)
			;
		((struct newloc*)y)->Location[w] = 0;//change "</cmt>" to "\0/cmt>"
		z = _stricmp(((struct newloc*) x)->Location, ((struct newloc*) y)->Location);
		for (w = 0; ((struct newloc*)x)->Location[w] != 0; w++)
			;
		((struct newloc*)x)->Location[w] = '<';//change "\0/cmt>" to "</cmt>"
		for (w = 0; ((struct newloc*)y)->Location[w] != 0; w++)
			;
		((struct newloc*)y)->Location[w] = '<';//change "\0/cmt>" to "</cmt>"
		return z;
	}

	else//compare a Location with an Ident
	{
		if ((((struct newloc*)x)->Location) == 0)
		{
			xLoc = FALSE;
			for (w = 0; ((struct newloc*)x)->Ident[w] != '<'; w++)
				;
			((struct newloc*)x)->Ident[w] = 0;//change "</cmt>" to "\0/cmt>"
		}
		else
		{
			xLoc = TRUE;
			for (w = 0; ((struct newloc*)x)->Location[w] != '<'; w++)
				;
			((struct newloc*)x)->Location[w] = 0;//change "</cmt>" to "\0/cmt>"
		}
		if ((((struct newloc*)y)->Location) == 0)
		{
			yLoc = FALSE;
			for (w = 0; ((struct newloc*)y)->Ident[w] != '<'; w++)
				;
			((struct newloc*)y)->Ident[w] = 0;//change "</cmt>" to "\0/cmt>"
		}
		else
		{
			yLoc = TRUE;
			for (w = 0; ((struct newloc*)y)->Location[w] != '<'; w++)
				;
			((struct newloc*)y)->Location[w] = 0;//change "/cmt>" to "<\0/cmt>"
		}

		//now strcmp & put '<' back
		if ((xLoc == TRUE) && (yLoc == FALSE))
 		{
			z = _stricmp(((struct newloc*)x)->Location, ((struct newloc*)y)->Ident);
			for (w = 0; ((struct newloc*)x)->Location[w] != 0; w++)
				;
			((struct newloc*)x)->Location[w] = '<';//change "\0/cmt>" to "</cmt>"
			for (w = 0; ((struct newloc*)y)->Ident[w] != 0; w++)
				;
			((struct newloc*)y)->Ident[w] = '<';//change "\0/cmt>" to "</cmt>"
		}
		else if ((xLoc == FALSE) && (yLoc == TRUE))
		{
			z = _stricmp(((struct newloc*)x)->Ident, ((struct newloc*)y)->Location);
			for (w = 0; ((struct newloc*)x)->Ident[w] != 0; w++)
				;
			((struct newloc*)x)->Ident[w] = '<';//change "\0/cmt>" to "</cmt>"
			for (w = 0; ((struct newloc*)y)->Location[w] != 0; w++)
				;
			((struct newloc*)y)->Location[w] = '<';//change "\0/cmt>" to "</cmt>"
		}
		else if ((xLoc == FALSE) && (yLoc == FALSE))
		{
			z = _stricmp(((struct newloc*)x)->Ident, ((struct newloc*)y)->Ident);
			for (w = 0; ((struct newloc*)x)->Ident[w] != 0; w++)
				;
			((struct newloc*)x)->Ident[w] = '<';//change "\0/cmt>" to "</cmt>"
			for (w = 0; ((struct newloc*)y)->Ident[w] != 0; w++)
				;
			((struct newloc*)y)->Ident[w] = '<';//change "\0/cmt>" to "</cmt>"
		}
	}
	return z;
}

void SubSubProc(int y)
{
	for (x = 0; Photo[x].name[0] != 0; x++)
	{
		if ((Photo[x].begin <= y) && (Photo[x].end >= y))
		{//clicked on a photo in \Photos
			for (y = 0, z = 7; Photo[x].name[y] != 0; y++, z++)
				PhotoName[z] = Photo[x].name[y];
			PhotoName[z] = 0;
			hFile = CreateFile(PhotoName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
			fileSize = GetFileSize(hFile, NULL);
			if (fileSize)
			{
				PhotoBuf = (BYTE*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
				ReadFile(hFile, PhotoBuf, fileSize, &dwBytesRead, NULL) ;
				if ((PhotoBuf[0] != 0xFF) || (PhotoBuf[1] != 0xD8) || (PhotoBuf[2] != 0xFF))
				{//if not a jpeg file
					VirtualFree(PhotoBuf, 0, MEM_RELEASE);
					CloseHandle(hFile);
					MessageBox(hwnd, "That's not a jpeg file.", ERROR, MB_OK);
					return;
				}
				if (photo_pixel_buf != NULL)
				{
					DestroyWindow(hwndPhoto);
				}

				jerr = ijlInit (&jcprops);//use Intel's ijl15.dll to convert JPEG files
				jcprops.JPGBytes = PhotoBuf;//source
				jcprops.JPGSizeBytes = fileSize;
				jcprops.JPGFile = NULL;
				jerr = ijlRead(&jcprops, IJL_JBUFF_READPARAMS);
				Width = jcprops.JPGWidth;
				Height = jcprops.JPGHeight;
				if (((rect.right-10) > Width) && ((rect.bottom-20) > Height))
					Resolution = FULL;
				else if (((rect.right-10) > Width/2) && ((rect.bottom-20) > Height/2))
				{
					Resolution = HALF;
					Width /= 2;
					Height /= 2;
				}
				else if (((rect.right-10) > Width/4) && ((rect.bottom-20) > Height/4))
				{
					Resolution = QUARTER;
					Width /= 4;
					Height /= 4;
				}
				else if (((rect.right-10) > Width/8) && ((rect.bottom-20) > Height/8))
				{
					Resolution = EIGHTH;
					Width /= 8;
					Height /= 8;
				}
				jcprops.DIBWidth = Width;
				jcprops.DIBHeight = Height;
				PadBytes = IJL_DIB_PAD_BYTES(Width, 3);
				jcprops.DIBPadBytes = PadBytes;
				photo_pixel_buf = (BYTE*)VirtualAlloc(NULL, ((Width + jcprops.DIBPadBytes) * Height * 3), MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
				jcprops.DIBBytes = photo_pixel_buf;//destination
				jcprops.DIBChannels = 3;
				jcprops.DIBColor = IJL_BGR;
				if (Resolution == FULL)
					jerr = ijlRead (&jcprops, IJL_JBUFF_READWHOLEIMAGE);
				else if (Resolution == HALF)
					jerr = ijlRead (&jcprops, IJL_JBUFF_READONEHALF);
				else if (Resolution == QUARTER)
					jerr = ijlRead (&jcprops, IJL_JBUFF_READONEQUARTER);
				else if (Resolution == EIGHTH)
					jerr = ijlRead (&jcprops, IJL_JBUFF_READONEEIGHTH);
				ijlFree(&jcprops);
				VirtualFree(PhotoBuf, 0, MEM_RELEASE);

				hMenu2 = CreateMenu();//to override parent menu bar
				x = Width+(Frame*2);
				y = Height+GetSystemMetrics(SM_CYCAPTION)+Frame;
				hwndPhoto = CreateWindow(Photos, NULL,
					WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
					cxScreen-x, TitleAndMenu+Frame, x, y,
					hwndDescEdit, hMenu2, hInst, NULL);
				SetWindowText(hwndPhoto, PhotoName);
			}
			CloseHandle(hFile);
			break;
		}
	}
}

void CALLBACK TimerFunc(UINT uID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2)
{
	PostMessage(hwnd, WM_USER3, 0, 0);
}

//sub-class procedure
LRESULT CALLBACK DescEditProc(HWND hwnd2, UINT message, WPARAM wParam, LPARAM lParam)
{
	int y;

	if (message == WM_MOUSEMOVE)
		points = MAKEPOINTS(lParam);
	else if ((message == WM_KEYDOWN) && (wParam == VK_RETURN))
	{
		y = SendMessage(hwndDescEdit, EM_LINEINDEX, -1, 0);//0-based line number of cursor
		SubSubProc(y);
	}
	else if (message == WM_LBUTTONDOWN)
	{
		y = SendMessage(hwndDescEdit, EM_CHARFROMPOS, 0, MAKELPARAM(points.x, points.y));
		y &= 0xFFFF;//use low-word only for zero-based index from beginning of Description
		SubSubProc(y);
	}
	return CallWindowProc(pDescEditProc, hwnd2, message, wParam, lParam);
}

//sub-class procedure
LRESULT CALLBACK EditProc(HWND hwnd2, UINT message, WPARAM wParam, LPARAM lParam)
{
	CurrentHelp = GetParent(hwnd2);
	if (message == WM_KEYDOWN)
	{
		if ((wParam == VK_ESCAPE))
		{
			if ((CurrentHelp == hwndHelp) && (pHelp != NULL))
			{
				free(pHelp);
				pHelp = NULL;
			}
			else if ((CurrentHelp == hwndGPS) && (pGPSHelp != NULL))
			{
				free(pGPSHelp);
				pGPSHelp = NULL;
			}
			else if ((CurrentHelp == hwndTigerHelp) && (pTigerHelp != NULL))
			{
				free(pTigerHelp);
				pTigerHelp = NULL;
			}
			else if ((CurrentHelp == hwndCounties) && (pCounties != NULL))
			{
				free(pCounties);
				pCounties = NULL;
			}
			else if ((CurrentHelp == hwndElevationHelp) && (pElevationHelp != NULL))
			{
				free(pElevationHelp);
				pElevationHelp = NULL;
			}
			SendMessage(CurrentHelp, WM_CLOSE, wParam, lParam);
		}
		else if ((wParam == VK_DELETE) && (editingtracks))
			SendMessage(hwnd, WM_KEYDOWN, VK_DELETE, 0);
		if (!editingtracks)
		{
			if (wParam == 'F')
			{
				SendMessage(hwndInstr, WM_VSCROLL, SB_TOP, 0);
				if (CurrentHelp == hwndHelp)
				{
					pFind = pHelp;
					FindSize = HelpSize;
				}
				else if (CurrentHelp == hwndGPS)
				{
					pFind = pGPSHelp;
					FindSize = GPSHelpSize;
				}
				else if (CurrentHelp == hwndTigerHelp)
				{
					pFind = pTigerHelp;
					FindSize = TigerHelpSize;
				}
				else if (CurrentHelp == hwndAPRS)
				{
					pFind = pAPRSHelp;
					FindSize = APRSHelpSize;
				}
				NextFind = 0;
				DialogBox(hInst, "FIND", NULL, FindProc);
			}
			else if ((wParam == VK_F3) && (NextFind != 0))
			/////////
				FindIt();
			/////////
		}
	}
	else if (message == WM_DESTROY)
	{
		if ((CurrentHelp == hwndHelp) && (pHelp != NULL))
		{
			free(pHelp);
			pHelp = NULL;
		}
		else if ((CurrentHelp == hwndGPS) && (pGPSHelp != NULL))
		{
			free(pGPSHelp);
			pGPSHelp = NULL;
		}
	}
	return CallWindowProc(pEditProc, hwnd2, message, wParam, lParam);
}

//sub-class procedure
LRESULT CALLBACK CommProc(HWND hwnd3, UINT message, WPARAM wParam, LPARAM lParam)
{

	if ((firsttx) && (message == WM_KEYDOWN) && (wParam == VK_RETURN))
		InitializeAPRSComm();
	else if ((message == WM_CHAR) && (lParam != 8))//bell
	{
		toHwndComm++;
		if (toHwndComm == MaxText)
		{
			MessageBeep(MB_OK);
			toHwndComm = 0;
			SendMessage(hwndComm, EM_SETSEL, 0, -1);
			SendMessage(hwndComm, WM_CLEAR, 0, 0);
		}
		if (lParam != 0)
		{//if not from WM_APRS_COMM (it's user input)
			BYTE ch = (BYTE)wParam;
			WriteFile(hAPRSComm, &ch, 1, &dwBytesWritten, NULL);
			return 0;//don't show char
		}
	}
	else if ((message == WM_KEYDOWN) && (wParam == VK_ESCAPE))
		DestroyWindow(hwndAPRSDlg);
	else if (message == WM_DESTROY)
		hwndComm = NULL;
	return CallWindowProc(pCommProc, hwnd3, message, wParam, lParam);
}

//sub-class procedure
LRESULT CALLBACK Edit2Proc(HWND hwnd3, UINT message, WPARAM wParam, LPARAM lParam)
{
	if ((message == WM_KEYDOWN) && (wParam == VK_RETURN))
	{
		blanklen = GetDlgItemText(hwndAPRSDlg, IDC_EDIT2, Blank1, 32);
		WriteFile(hAPRSComm, Blank1, blanklen, &dwBytesWritten, NULL);
		WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
	}
	return CallWindowProc(pEdit2Proc, hwnd3, message, wParam, lParam);
}

//sub-class procedure
LRESULT CALLBACK PosProc(HWND hwnd3, UINT message, WPARAM wParam, LPARAM lParam)
{
	if ((message == WM_KEYDOWN) && (wParam == VK_ESCAPE))
		DestroyWindow(hwndPosit);

	else if (message == WM_DESTROY)
	{
		pos = 0;//to stop showing position dots - or tracks
		fromposition = FALSE;
		InvalidateRect(hwnd, &rect, FALSE);
		posflag = TRUE;
	}
	return CallWindowProc(pPosProc, hwnd3, message, wParam, lParam);
}

//sub-class procedure
LRESULT CALLBACK StreetProc(HWND hwnd3, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_COMMAND:
		if ((HWND)(LPARAM)lParam == hwndShowButton)
		{
			if (show)
			{
				if (GetWindowText(hwndStreetEdit, StreetName, 50) != 0)
				{
					show = FALSE;
					SendMessage(hwndShowButton, WM_SETTEXT, 0, (LPARAM)"Hide This Street Name");
					for (x = 0; StreetName[x] != 0; x++)
						if (StreetName[x] != ' ')
							StreetName[x] &= 0xDF;//make uppercase
				}
			}
			else
 			{
				show = TRUE;
				SendMessage(hwndShowButton, WM_SETTEXT, 0, (LPARAM)"Display a Street Name");
			}
			SetFocus(hwnd);
			InvalidateRect(hwnd, &rect, FALSE);
			UpdateWindow(hwnd);
			return 0;
		}
	}
	return CallWindowProc(pStreetProc, hwnd3, message, wParam, lParam);
}

//sub-class procedure
LRESULT CALLBACK StreetEditProc(HWND hwnd2, UINT message, WPARAM wParam, LPARAM lParam)
{
	if (message == WM_KEYDOWN)
	{
		if (wParam == VK_RETURN)
		{
			SendMessage(hwndStreet, WM_COMMAND, 0, (LPARAM)hwndShowButton);
		}
		else if (wParam == VK_ESCAPE)
		{
			SetFocus(hwnd);
		}
	}
	return CallWindowProc(pStreetEditProc, hwnd2, message, wParam, lParam);
}

//sub-class procedure
LRESULT CALLBACK TrackProc(HWND hwnd3, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_COMMAND:
		if ((autoLoc == FALSE) && (showingtracks))
		{
			if ((HWND)(LPARAM)lParam == hwndButton)
			{//"Edit Track" or "Stop Editing"
				if (editingtracks == FALSE)
				{
					editingtracks = TRUE;
					SendMessage(hwndButton, WM_SETTEXT, 0, (LPARAM)"Stop &Editing");
					firstlbutton = firstrbutton = TRUE;

					hwndButton3 = CreateWindow("BUTTON", "&Help",
						WS_CHILD | WS_VISIBLE,
						0, 160, 50, 25,
						hwndTrack, (HMENU)92, hInst, NULL);
					hdcButton = GetDC(hwndButton3);
					hFont = CreateFontIndirect (&lf2);
					SelectObject(hdcButton, hFont);
					ReleaseDC(hwndButton3, hdcButton);
					SendMessage(hwndButton3, WM_SETFONT, (UINT)hFont, TRUE);
				}
				else
				{
					editingtracks = FALSE;
					SendMessage(hwndButton, WM_SETTEXT, 0, (LPARAM)"&Edit Tracks");
					DestroyWindow(hwndButton3);
					hwndButton3 = NULL;
				}
				InvalidateRect(hwnd, &rect, FALSE);
				SetFocus(hwnd);
			}
			else if ((HWND)(LPARAM)lParam == hwndButton2)
			{//"Goto &Beginning of Tracks"
				if (trackUTMZone == UTMZone)// || (trackUTMZone < 10))//x < 10 in old Track.dta format
				{
					BeginY = trak[0].NUTM / MetersPerTile;
					BeginX = trak[0].EUTM / MetersPerTile;
					_itoa(BeginX, X, 10);
					_itoa(BeginY, Y, 10);
					Z[0] = (UTMZone / 10) + '0';
					Z[1] = (UTMZone % 10) + '0';
					rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
					colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
					SendMessage(hwnd, WM_USER, 0, 0);
				}
				else if (trackUTMZone != 0)
				{
					UTMNorthing = trak[0].NUTM;
					UTMEasting = trak[0].EUTM;
					UTMZone = trak[0].time >> 26;//UTMZone in new Track.dta format
					ChangeZone(trackUTMZone, 1);//hwndButton2
					BeginY = UTMNorthing / MetersPerTile;
					BeginX = UTMEasting / MetersPerTile;
					_itoa(BeginX, X, 10);
					_itoa(BeginY, Y, 10);
					Z[0] = (UTMZone / 10) + '0';
					Z[1] = (UTMZone % 10) + '0';
					fromOpen = TRUE;
					Waypoints[0] = 0;
					SendMessage(hwnd, WM_USER4, 0, 0);
				}//end of else
				else
					MessageBox(hwnd, "Can't.\nUTM zone isn't in track data.", ERROR, MB_OK);
//???GetElevData();
				InvalidateRect(hwnd, &rect, FALSE);
				SetFocus(hwnd);
			}
			else if ((hwndButton3 != 0) && ((HWND)(LPARAM)lParam == hwndButton3))
			{//"Help"
				hMenu2 = CreateMenu();//to override parent menu bar
				y = __min(cyChar*35, cyScreen-TitleAndMenu);
				hwndEdit = CreateWindow(Instruct, "Edit Tracks",
					WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
					Frame, TitleAndMenu+(GetSystemMetrics(SM_CYCAPTION)), 350, y,
					hwndTrack, hMenu2, hInst, NULL);
				SetWindowText(hwndInstr, TrackEdit);
				SetFocus(hwndInstr);
			}
			return 0;
		}
		break;

	case WM_DESTROY:
		SendMessage(hwndButton, WM_CLOSE, 0, 0);
		SendMessage(hwndButton2, WM_CLOSE, 0, 0);
		SendMessage(hwndButton3, WM_CLOSE, 0, 0);
		SendMessage(hwndEdit, WM_CLOSE, 0, 0);
		showingtracks = FALSE;
		if (trak != NULL)
		{
			InvalidateRect(hwnd, &rect, FALSE);
			free(trak);
			trak = NULL;
		}
		break;
	}
	return CallWindowProc(pTrackProc, hwnd3, message, wParam, lParam);
}

//sub-class procedure
LRESULT CALLBACK ElevationProc(HWND hwnd3, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_DESTROY:
		getelev = FALSE;
		grid75 = FALSE;
		CheckMenuItem(hMenu, ID_FILE_SHOWELEVATIONSQUARES, MF_UNCHECKED);
		InvalidateRect(hwnd, &rect, FALSE);
		break;
	}
	return CallWindowProc(pElevProc, hwnd3, message, wParam, lParam);
}

LRESULT CALLBACK EditListProc(HWND hwnd2, UINT message, WPARAM wParam, LPARAM lParam)
{
	if ((message == WM_KEYDOWN) && (wParam == VK_RETURN))
		SendMessage(hwndStationsDlg, WM_COMMAND, (WPARAM)((LBN_DBLCLK<<16)|IDC_LIST1), 0);
	else if ((message == WM_KEYDOWN) && (wParam == VK_DELETE))
		SendMessage(hwndStationsDlg, WM_COMMAND, (WPARAM)(VK_DELETE), 0);
//	else if ((message == WM_KEYDOWN) && (wParam == VK_ESCAPE))
//		SendMessage(hwndStationsDlg, WM_COMMAND, (WPARAM)IDCANCEL, 0);
	return CallWindowProc(pEditListProc, hwnd2, message, wParam, lParam);
}

LRESULT CALLBACK EditInfoListProc(HWND hwnd2, UINT message, WPARAM wParam, LPARAM lParam)
{
	if ((message == WM_KEYDOWN) && (wParam == VK_RETURN))
		SendMessage(hwndStationInfoDlg, WM_COMMAND, (WPARAM)((LBN_DBLCLK<<16)|IDC_LIST1), 0);
	return CallWindowProc(pInfoListProc, hwnd2, message, wParam, lParam);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	static int BadSend;
	int idistX, idistY, tempMouseLoc;
	double distX, distY;
	static unsigned char *pRecords = &ReceivedData[0];//, *pTime = &ReceivedData[8];
	static WORD Records;
	static int GarminFlag = GOT_ETX;
	static char BadWaypoint[] = "Waypoint wasn't received";
	//static char BadCommPort[] = "The Comm Port doesn't seem to be valid";
	static char FullArray[] = "The Locations array is full";
	static BOOL nofile = FALSE, gotaDLE = FALSE, commas, qpressed;
	static BOOL flag = FALSE;
	static unsigned char *GrayArray;
	static int timeDiff, wParameter;
	static unsigned int uiTimer;
	static char PhotosDownloaded[] = " rows filled in.";
	static char CheckingConnection[] = "STANDBY (FOR UP TO 40 SECONDS)...  WINDOWS IS CHECKING INTERNET CONNECTION...";
	static DWORD TickCount, TickCount2;
	static int iLatLon = -1, Four;
	static int GotoX, GotoY, xCenter, yCenter;
	char ch;

	switch (message)
	{
	case WM_USER3: // approach control
		MetersPerPixel = MetersPerTile/PixelsPerTile;
		BitBlt(hdcMem3, 0, 0, rect.right, rect.bottom, hdcMem, 0, 0, SRCCOPY);
		SetBkMode(hdcMem3, TRANSPARENT);

		d1 = dThirtyMiles / (double)MetersPerPixel;
		__asm fld d1 // round a double up or down
		__asm fistp ThirtyMiles // to an integer
		CircleX = (AirportUTMEasting - ScreenLeft) / MetersPerPixel;
		CircleY = (ScreenTop - AirportUTMNorthing) / MetersPerPixel;
		hWhitePen = CreatePen(PS_SOLID, 1, 0xFFFFFF);
		hBlackPen = CreatePen(PS_SOLID, 1, 0);
		hObject = SelectObject(hdcMem3, hWhitePen);
		hBlankBrush = (HBRUSH)GetStockObject(NULL_BRUSH);
		hOldBrush = SelectObject(hdcMem3, hBlankBrush);
		Ellipse(hdcMem3, CircleX - ThirtyMiles, CircleY - ThirtyMiles, CircleX + ThirtyMiles, CircleY + ThirtyMiles);
		SelectObject(hdcMem3, hOldBrush);
		DeleteObject(hBlankBrush);
		hWaypointBrush = CreateSolidBrush(WaypointColor);
		hOldBrush = SelectObject(hdcMem3, hWaypointBrush);
		if (dCenterline != 370.0)
		{
			GetDotRadius(); // for glide slope temp waypoint
			SetTextColor(hdcMem3, 0xFFFFFF);
			for (z = 0; z < lines; z++)
			{
				SelectObject(hdcMem3, hWhitePen);
				x = (Line[z].UTME1 - ScreenLeft) / MetersPerPixel;
				y = (ScreenTop - Line[z].UTMN1) / MetersPerPixel;
				MoveToEx(hdcMem3, x, y, NULL);
				x = (Line[z].UTME2 - ScreenLeft) / MetersPerPixel;
				y = (ScreenTop - Line[z].UTMN2) / MetersPerPixel;
				LineTo(hdcMem3, x, y);
				if (Line[z].GSE)
				{
					SelectObject(hdcMem3, hBlackPen);
					x = (Line[z].GSE - ScreenLeft) / MetersPerPixel;
					y = (ScreenTop - Line[z].GSN) / MetersPerPixel;
					Ellipse(hdcMem3, x-DotRadius, y-DotRadius, x+DotRadius, y+DotRadius);
					_itoa(Line[z].GSInterceptAlt, tempPlane, 10);
					w = lstrlen(tempPlane);
					tempPlane[w] = '\'';
					w++;
					TextOut(hdcMem3, x, y, tempPlane, w);
				}
			}
		}
		SelectObject(hdcMem3, hObject);
		DeleteObject(hBlackPen);
		DeleteObject(hWhitePen);
// show waypoints
		for (x = 0; NewLoc[x].EUTM != 0; x++)
		{
			if ((UTMZone == NewLoc[x].UTMZone) && (NewLoc[x].EUTM > ScreenLeft) && (NewLoc[x].EUTM < ScreenRight)
				&& (NewLoc[x].NUTM < ScreenTop) && (NewLoc[x].NUTM > ScreenBottom))
			{
				DotX = (NewLoc[x].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
				DotY = (ScreenTop - NewLoc[x].NUTM) * PixelsPerTile / MetersPerTile;
				Ellipse(hdcMem3, DotX-DotRadius, DotY-DotRadius, DotX+DotRadius, DotY+DotRadius);
				if ((shownamecomment) && ((MapType == PHOTO) || (MapType == URBANAREA) || (Zoom < 5)))
				{
					char wp[50];

					for (y = 0; y < NewLoc[x].size; y++)
					{//<name> <cmt> <desc>
						if (((sortbyname == TRUE)
						 && (NewLoc[x].pWaypoints[y] == 'm')
						 && (NewLoc[x].pWaypoints[y+2] == '>')
						 && (NewLoc[x].pWaypoints[y-1] == 'a')
						 && (NewLoc[x].pWaypoints[y+1] == 'e')
						 && (NewLoc[x].pWaypoints[y-3] == '<'))

						 || (((sortbyname == FALSE)
						 && ((NewLoc[x].pWaypoints[y] == 'm')
						 && (NewLoc[x].pWaypoints[y+2] == '>')
						 && (NewLoc[x].pWaypoints[y+1] == 't')
						 && (NewLoc[x].pWaypoints[y-2] == '<'))
						 || ((NewLoc[x].pWaypoints[y] == 's')
						 && (NewLoc[x].pWaypoints[y+2] == '>')
						 && (NewLoc[x].pWaypoints[y-1] == 'e')
						 && (NewLoc[x].pWaypoints[y+1] == 'c')
						 && (NewLoc[x].pWaypoints[y-3] == '<')))))
						{
							y += 3;//to name or comment
							for (z = 0; (z < 50) && (NewLoc[x].pWaypoints[y] != '<'); y++, z++)
								wp[z] = NewLoc[x].pWaypoints[y];
							if (MapType != TOPO)
							{
								SetBkMode(hdcMem3, TRANSPARENT);
								SetTextColor(hdcMem3, WHITE);
							}
							TextOut(hdcMem3, DotX + 10, DotY - 10, wp, z);
							break;
						}
					}
				}
			}
		}
		SelectObject(hdcMem3, hOldBrush);
		DeleteObject(hWaypointBrush);

		if (distancemeasure)
		{
			hPen = CreatePen(PS_SOLID, 1, 0xFFFFFF);
			hObject = SelectObject(hdcMem3, hPen);
			MoveToEx(hdcMem3, xBeg, yBeg, NULL);
			LineTo(hdcMem3, xPos, yPos);
			SelectObject(hdcMem3, hObject);
			DeleteObject(hPen);
			fromuser3 = TRUE;
			ShowDistanceAngle();
			fromuser3 = FALSE;
		}

		hRedBrush = CreateSolidBrush(RED);
		for (x = 0; x < plane; x++)
		{ // show airplanes
			if (Plane[x].heading == 0)
				Plane[x].heading = 360;
			CircleY = (ScreenTop - AirportUTMNorthing) / MetersPerPixel;
			Plane[x].UTME6 = Plane[x].UTME5;
			Plane[x].UTMN6 = Plane[x].UTMN5;
			Plane[x].UTME5 = Plane[x].UTME4;
			Plane[x].UTMN5 = Plane[x].UTMN4;
			Plane[x].UTME4 = Plane[x].UTME3;
			Plane[x].UTMN4 = Plane[x].UTMN3;
			Plane[x].UTME3 = Plane[x].UTME2;
			Plane[x].UTMN3 = Plane[x].UTMN2;
			Plane[x].UTME2 = Plane[x].UTME1;
			Plane[x].UTMN2 = Plane[x].UTMN1;
			Plane[x].UTME1 = Plane[x].UTMEasting;
			Plane[x].UTMN1 = Plane[x].UTMNorthing;
////////////////////////////////////////////////
			if (Plane[x].Turn == 'R')
			{
				Plane[x].radianheading += Plane[x].RadiansPerSecond;
				if (Plane[x].radianheading <= Plane[x].newRadianheading)
					Plane[x].heading = (int)(Plane[x].radianheading * rad2deg);
				else
				{
					Plane[x].radianheading = Plane[x].newRadianheading;
					if (Plane[x].radianheading > PI2)
						Plane[x].radianheading -= PI2;
					Plane[x].heading = Plane[x].newHeading;
					Plane[x].Turn = 0; // done
				}
				if (Plane[x].heading > 360)
					Plane[x].heading -= 360;
			}
			else if (Plane[x].Turn == 'L')
			{
				Plane[x].radianheading -= Plane[x].RadiansPerSecond;
				if (Plane[x].radianheading >= Plane[x].newRadianheading)
					Plane[x].heading = (int)(Plane[x].radianheading * rad2deg);
				else
				{
					Plane[x].radianheading = Plane[x].newRadianheading;
					if (Plane[x].radianheading <= 0)
						Plane[x].radianheading += PI2;
					Plane[x].heading = Plane[x].newHeading;
					Plane[x].Turn = 0; // done
				}
				if (Plane[x].heading < 0)
					Plane[x].heading += 360;
			}
////////////////////////////////////////////////
			if ((Plane[x].IAS > Plane[x].newIAS) && (Plane[x].altitude == Plane[x].newAltitude))
			{
				Plane[x].IAS -= 2;
				if (Plane[x].IAS < Plane[x].newIAS)
					Plane[x].IAS = Plane[x].newIAS;
			}
			else if ((Plane[x].IAS < Plane[x].newIAS) && (Plane[x].altitude == Plane[x].newAltitude))
			{
				Plane[x].IAS += 2;
				if (Plane[x].IAS > Plane[x].newIAS)
					Plane[x].IAS = Plane[x].newIAS;
			}
			if (Plane[x].altitude > Plane[x].newAltitude)
			{
				Plane[x].altitude -= 34;
				if (Plane[x].altitude < Plane[x].newAltitude)
					Plane[x].altitude = Plane[x].newAltitude;
			}
			else if (Plane[x].altitude < Plane[x].newAltitude)
			{
				Plane[x].altitude += 34;
				if (Plane[x].altitude > Plane[x].newAltitude)
					Plane[x].altitude = Plane[x].newAltitude;
			}

			Plane[x].TAS = Plane[x].IAS + (Plane[x].IAS * Plane[x].altitude / 50000);
			Meters = Plane[x].TAS * MetersPerSec;
			xMeters = Meters * sin(Plane[x].radianheading);
			yMeters = Meters * cos(Plane[x].radianheading);
			__asm fld xMeters // round a double up or down
			__asm fistp y // to an integer
			Plane[x].UTMEasting += y;
			__asm fld yMeters // round a double up or down
			__asm fistp y // to an integer
			Plane[x].UTMNorthing += y;
			Plane[x].x = (Plane[x].UTMEasting - ScreenLeft) / (MetersPerPixel);
			Plane[x].y = (ScreenTop - Plane[x].UTMNorthing) / (MetersPerPixel);
			hOldBrush = SelectObject(hdcMem3, hRedBrush);
			Ellipse(hdcMem3, Plane[x].x - PlaneRadius,Plane[x].y - PlaneRadius, Plane[x].x + PlaneRadius, Plane[x].y + PlaneRadius);

			z = (Plane[x].UTME2 - ScreenLeft) / (MetersPerPixel); // z is x coordinate
			y = (ScreenTop - Plane[x].UTMN2) / (MetersPerPixel);
			SelectObject(hdcMem3, hRedBrush);
			Ellipse(hdcMem3, z - 3,y - 3, z + 3, y + 3);
			z = (Plane[x].UTME3 - ScreenLeft) / (MetersPerPixel);
			y = (ScreenTop - Plane[x].UTMN3) / (MetersPerPixel);
			SelectObject(hdcMem3, hRedBrush);
			Ellipse(hdcMem3, z - 3,y - 3, z + 3, y + 3);
			SelectObject(hdcMem3, hOldBrush);
			z = (Plane[x].UTME4 - ScreenLeft) / (MetersPerPixel);
			y = (ScreenTop - Plane[x].UTMN4) / (MetersPerPixel);
			SelectObject(hdcMem3, hRedBrush);
			Ellipse(hdcMem3, z - 3,y - 3, z + 3, y + 3);
			z = (Plane[x].UTME5 - ScreenLeft) / (MetersPerPixel);
			y = (ScreenTop - Plane[x].UTMN5) / (MetersPerPixel);
			SelectObject(hdcMem3, hRedBrush);
			Ellipse(hdcMem3, z - 3,y - 3, z + 3, y + 3);
			z = (Plane[x].UTME6 - ScreenLeft) / (MetersPerPixel);
			y = (ScreenTop - Plane[x].UTMN6) / (MetersPerPixel);
			SelectObject(hdcMem3, hRedBrush);
			Ellipse(hdcMem3, z - 3,y - 3, z + 3, y + 3);

			if ((planecommand) && (x == AtPlane))
			{
				TextOut(hdcMem3, Plane[x].x-10, Plane[x].y-40, Command, lstrlen(Command));
				TurnRadius = Plane[x].TAS * Plane[x].TAS * TwentyfiveDegreeBank; // in meters
				hBlankBrush = (HBRUSH)GetStockObject(NULL_BRUSH);
				hObject = SelectObject(hdcMem3, hBlankBrush);
				for (cmd = 0; cmd < command; cmd++)
				{ 
					if (Command[cmd] == 'H') {
						TextOut(hdcMem3, Plane[x].x-100, Plane[x].y+10, " Use the commands L or R instead ", 33);
						break;
					}
					if ((Command[cmd] == 'R') || (Command[cmd] == 'L'))
					{ // draw turn circles from TurnRadius and Plane[x].heading
						d1 = Plane[x].radianheading;
						d2 = TurnRadius/MetersPerPixel;
						CircleX = Plane[x].x + (int)((d2) * cos(d1));
						CircleY = Plane[x].y + (int)((d2) * sin(d1));
						CircleX2 = Plane[x].x - (int)((d2) * cos(d1));
						CircleY2 = Plane[x].y - (int)((d2) * sin(d1));
					}
					if (Command[cmd] == 'R')
					{
						hRedPen = CreatePen(PS_SOLID, 1, 0xF0);
						hOldPen = SelectObject(hdcMem3, hRedPen);
						SelectObject(hdcMem3, hBlankBrush);
						Ellipse(hdcMem3, CircleX - (DWORD)d2, CircleY - (DWORD)d2, CircleX + (DWORD)d2, CircleY + (DWORD)d2);
						SelectObject(hdcMem3, hOldPen);
						DeleteObject(hRedPen);
						break;
					}
					if (Command[cmd] == 'L')
					{
						hRedPen = CreatePen(PS_SOLID, 1, 0xF0);
						hOldPen = SelectObject(hdcMem3, hRedPen);
						SelectObject(hdcMem3, hBlankBrush);
						Ellipse(hdcMem3, CircleX2 - (DWORD)d2, CircleY2 - (DWORD)d2, CircleX2 + (DWORD)d2, CircleY2 + (DWORD)d2);
						SelectObject(hdcMem3, hOldPen);
						DeleteObject(hRedPen);
						break;
					}
					if ((Command[cmd] == 'A') && (Command[cmd+1] != 0))
					{
						finalAlt = Atoi(&Command[cmd+1]);
						if (finalAlt < 1000) // 2 or 200 20 or 2000 200 or 20000
							finalAlt *= 100;
						d1 = sin(Plane[x].radianheading);
						d2 = cos(Plane[x].radianheading);
						xUTM = Plane[x].UTMEasting;
						yUTM = Plane[x].UTMNorthing;
						for (existingAlt = Plane[x].altitude; existingAlt > finalAlt; existingAlt -= 34)
						{
							existingTAS = Plane[x].IAS + (Plane[x].IAS * existingAlt / 50000);
							Meters = (double)existingTAS * MetersPerSec;
							xMeters = Meters * d1;
							yMeters = Meters * d2;
							__asm fld xMeters // round a double up or down
							__asm fistp z // to an integer
							xUTM += z;
							__asm fld yMeters // round a double up or down
							__asm fistp z // to an integer
							yUTM += z;
						}
						SpotX = (xUTM - ScreenLeft) / MetersPerPixel;
						SpotY = (ScreenTop - yUTM) / MetersPerPixel;
						hRedPen = CreatePen(PS_SOLID, 1, 0xF0);
						hOldPen = SelectObject(hdcMem3, hRedPen);
						MoveToEx(hdcMem3, Plane[x].x, Plane[x].y, NULL);
						LineTo(hdcMem3, SpotX, SpotY);
						SelectObject(hdcMem3, hOldPen);
						DeleteObject(hRedPen);
						break;
					}
					if ((Command[cmd] == 'S') && (Command[cmd+1] != 0))
					{
						finalIAS = Atoi(&Command[cmd+1]);
						existingIAS = Plane[x].IAS;
						d1 = sin(Plane[x].radianheading);
						d2 = cos(Plane[x].radianheading);
						xUTM = Plane[x].UTMEasting;
						yUTM = Plane[x].UTMNorthing;
						for ( ; existingIAS >= finalIAS; existingIAS -= 2)
						{
							existingTAS = existingIAS + (existingIAS * Plane[x].altitude / 50000);
							Meters = (double)existingTAS * MetersPerSec;
							xMeters = Meters * d1;
							yMeters = Meters * d2;
							__asm fld xMeters // round a double up or down
							__asm fistp z // to an integer
							xUTM += z;
							__asm fld yMeters // round a double up or down
							__asm fistp z // to an integer
							yUTM += z;
						}
						SpotX = (xUTM - ScreenLeft) / MetersPerPixel;
						SpotY = (ScreenTop - yUTM) / MetersPerPixel;
						hRedPen = CreatePen(PS_SOLID, 1, 0xF0);
						hOldPen = SelectObject(hdcMem3, hRedPen);
						MoveToEx(hdcMem3, Plane[x].x, Plane[x].y, NULL);
						LineTo(hdcMem3, SpotX, SpotY);
						SelectObject(hdcMem3, hOldPen);
						DeleteObject(hRedPen);
						break;
					}
				}
				SelectObject(hdcMem3, hObject);
				DeleteObject(hBlankBrush);
			}
			if (showdata)
			{
				if ((Plane[x].heading == Plane[x].newHeading) || (x == AtPlane))
				{
					_itoa(Plane[x].heading, tempPlane, 10);
					SetTextColor(hdcMem3, 0xFFFFFF);
				}
				else
				{
					_itoa(Plane[x].newHeading, tempPlane, 10);
					SetTextColor(hdcMem3, 0x00FFFF);
				}
				for (y = 0; tempPlane[y] != 0; y++)
					;
				tempPlane[y] = '';
				TextOut(hdcMem3, Plane[x].x-(Size.cx*4), Plane[x].y-8, tempPlane, y+1);

				if ((Plane[x].altitude == Plane[x].newAltitude) || (x == AtPlane))
				{
					_itoa(Plane[x].altitude, tempPlane, 10);
					SetTextColor(hdcMem3, 0xFFFFFF);
				}
				else
				{
					_itoa(Plane[x].newAltitude, tempPlane, 10);
					SetTextColor(hdcMem3, 0x00FFFF);
				}
				for (y = 0; tempPlane[y] != 0; y++)
					;
				tempPlane[y++] = '\'';
				TextOut(hdcMem3, Plane[x].x-(Size.cx*2), Plane[x].y-20, tempPlane, y);

				if ((Plane[x].IAS == Plane[x].newIAS) || (x == AtPlane))
				{
					SetTextColor(hdcMem3, 0xFFFFFF);
					_itoa(Plane[x].IAS, tempPlane, 10);
				}
				else
				{
					SetTextColor(hdcMem3, 0x00FFFF);
					_itoa(Plane[x].newIAS, tempPlane, 10);
				}
				tempPlane[3] = ' ';
				tempPlane[4] = 'k';
				tempPlane[5] = 't';
				tempPlane[6] = 's';
				TextOut(hdcMem3, Plane[x].x+10, Plane[x].y-8, tempPlane, 7);
			}
		}
		DeleteObject(hRedBrush);
		hdc = GetDC(hwnd);
		BitBlt(hdc, 0, 0, rect.right, rect.bottom, hdcMem3, 0, 0, SRCCOPY);
		ReleaseDC(hwnd, hdc);
		break;

	case WM_SIZE:
		GetClientRect(hwnd, &rect);
		LineRight = (rect.right / 200) * 200;//right edge of photos (for Line To)
		return 0;

	case WM_CREATE:
/*{
	double Float[2];

	Float[0] = 1.234567890;
	hFile = CreateFile("Float.dta", GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
	WriteFile(hFile, (double*)&Float[0], 8, &dwBytesWritten, NULL);
	CloseHandle(hFile);
	hFile = CreateFile("Float.dta", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	ReadFile(hFile, (double*)&Float[1], 8, &dwBytesRead, NULL);
	CloseHandle(hFile);
b = ~(6+2+99) + 1;//214
tan(3.0 * deg2rad) = 1500' / d
d = 1500 / tan(3.0 * deg2rad); // 28,621.7 ft
d1 = d * 0.3048; // 8,723.8956936293380 meters
d2 = d1 / 1852.0; // 4.71 nautical miles
}*/
		GlideSlope = tan(3.0 * deg2rad); // altitude / distance out
		PI2 = PI * 2.0;
		PIdiv2 = PI / 2.0;
//		dThirtyMiles = 5280.0 * 30.0 * 0.3048; //  482,80.32 meters
		dThirtyMiles = 1852.0 * 30.0; // 30 nautical miles in meters (55,560)
		MetersPerSec = 1852.0 / 3600.0; // 1 knot = 0.51444444 meters/sec
		TwentyfiveDegreeBank = (MetersPerSec * MetersPerSec) / (GRAVITY * tan(BankAngle * PI / 180.0));
		if ((CmdLine[0] != 0) && (CmdLine[0] != '-') && (INVALID_HANDLE_VALUE != FindFirstFile(CmdLine, &fd)))
		{//if called from GSAK
			if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, SubKey, &hRegKey2))
			{
				if (ERROR_SUCCESS == RegQueryValueEx(hRegKey2, "Install_Dir", NULL, &RegType, RegValue2, &RegValue2Size))
				{
					gsak = TRUE;
					SetCurrentDirectory((char*)RegValue2);
					for (x = 0, y = 0;RegValue2[y] != 0; x++, y++)
						RunPgmGpx[x] = RegValue2[y];
					for (y = 0; runpgm[y] != 0; x++, y++)
						RunPgmGpx[x] = runpgm[y];
					RunPgmGpx[x++] = 0;
					if (0 == CopyFile(CmdLine, RunPgmGpx, FALSE))
					{
						gsak = FALSE;
						MessageBox(hwnd, "Couldn't copy waypoint file from GSAK.", ERROR, MB_OK);
					}
				}
				RegCloseKey(hRegKey2);
			}
		}
		else
		{
			hMutex = CreateMutex(NULL, 0, "USAPhotoMaps");
			if (ERROR_ALREADY_EXISTS == GetLastError())
			{//don't open more than one instance
				SendMessage(hwnd, WM_DESTROY, 0, 0);
				return 0;
			}
			else
				CloseHandle(hMutex);//new May 3, 2007
		}
		hCursor = LoadCursor(NULL, IDC_ARROW);
		hWaitingCursor = LoadCursor(NULL, IDC_WAIT);
		hDrawingCursor = LoadCursor(NULL, IDC_HAND);
		NumOfDems = 0;
		fileName0 = fileName[0];
		fileName1 = fileName[1];
		fileName2 = fileName[2];
		pointerFileName[0] = fileName0;
		pointerFileName[1] = fileName1;
		pointerFileName[2] = fileName2;

		for (x = 0; x < MAXPTIGERS; x++)
		{
			pTiger[x] = NULL;
			pTigerNames[x] = NULL;
		}
		for (x = 0; x < 256; x++)
		{
			ShowList5[x] = 0;
			ShowList6[x] = 0;
		}
		photo_pixel_buf = NULL;
		Pixels = NULL;
		pUSA = NULL;
		pts = pname = 0;
		trak = NULL;
		WaypointsPath[0] = 0;
		pRoute = pr = NULL;
		pRoutes = prs = NULL;
		pTrackBuf = NULL;
		hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{//get USAPM.ini data
			if (fileSize = GetFileSize(hFile, NULL))
			{
				pUSAPMbufIn = (char*)malloc(fileSize);
				ReadFile(hFile, pUSAPMbufIn, fileSize, &dwBytesRead, NULL);

				for (x = 0; x < (int)fileSize; x++)
				{
					if (pUSAPMbufIn[x] == '=')
					{
						if ((pUSAPMbufIn[x-1] == 'g') && (pUSAPMbufIn[x-7] == 'C'))
							openatclosing = (pUSAPMbufIn[x+1] == 'Y')? TRUE : FALSE;
						else if ((pUSAPMbufIn[x-7] == 'C') && (pUSAPMbufIn[x-11] == 'N') && (pUSAPMbufIn[x-15] == 'S'))
							shownamecomment = (pUSAPMbufIn[x+1] == 'Y')? TRUE : FALSE;
						else if ((pUSAPMbufIn[x-11] == 'D') && (pUSAPMbufIn[x-15] == 'S'))
							showdescription = (pUSAPMbufIn[x+1] == 'Y')? TRUE : FALSE;
						else if ((pUSAPMbufIn[x-1] == 't') && (pUSAPMbufIn[x-16] == 'P'))
						{//1MeterPhotoWaypointDot=4;
							switch (pUSAPMbufIn[x-22])
							{
							case '1':
								PhotoDot1[0] = pUSAPMbufIn[x+1];
								break;
							case '2':
								if (pUSAPMbufIn[x-23] != '3')
									PhotoDot2[0] = pUSAPMbufIn[x+1];
								else
									PhotoDot32[0] = pUSAPMbufIn[x+1];
								break;
							case '4':
								if (pUSAPMbufIn[x-23] != '6')
									PhotoDot4[0] = pUSAPMbufIn[x+1];
								else
									PhotoDot64[0] = pUSAPMbufIn[x+1];
								break;
							case '6':
								if (pUSAPMbufIn[x-23] != '1')
									PhotoDot1[0] = pUSAPMbufIn[x+1];
								else
									PhotoDot16[0] = pUSAPMbufIn[x+1];
								break;
							case '8':
								PhotoDot8[0] = pUSAPMbufIn[x+1];
								break;
							}
						}
						else if ((pUSAPMbufIn[x-1] == 't') && (pUSAPMbufIn[x-15] == 'T'))
						{//4MeterTopoWaypointDot=4;
							switch (pUSAPMbufIn[x-21])
							{
							case '2':
								if (pUSAPMbufIn[x-22] == '3')
									TopoDot32[0] = pUSAPMbufIn[x+1];
								else if (pUSAPMbufIn[x-22] == '1')
									TopoDot512[0] = pUSAPMbufIn[x+1];
								break;
							case '4':
								if (pUSAPMbufIn[x-22] != '6')
									TopoDot4[0] = pUSAPMbufIn[x+1];
								else
									TopoDot64[0] = pUSAPMbufIn[x+1];
								break;
							case '6':
								if (pUSAPMbufIn[x-22] == '1')
									TopoDot16[0] = pUSAPMbufIn[x+1];
								else if (pUSAPMbufIn[x-22] == '5')
									TopoDot256[0] = pUSAPMbufIn[x+1];
								break;
							case '8':
								if (pUSAPMbufIn[x-22] != '2')
 									TopoDot8[0] = pUSAPMbufIn[x+1];
								else
									TopoDot128[0] = pUSAPMbufIn[x+1];
								break;
							}
						}
						else if ((pUSAPMbufIn[x-1] == 't') && (pUSAPMbufIn[x-16] == 'U'))
						{//14MeterUrbanWaypointDot=6
							switch (pUSAPMbufIn[x-22])
							{
							case '4':
								if (pUSAPMbufIn[x-23] == '1')
									UrbanDot14[0] = pUSAPMbufIn[x+1];
								break;
							case '2':
								if (pUSAPMbufIn[x-23] == '1')
									UrbanDot12[0] = pUSAPMbufIn[x+1];
								break;
							}
						}

						else if ((pUSAPMbufIn[x] == '=') && (pUSAPMbufIn[x-5] == 'W'))//Width=
						{//2MeterLineWidth=4; or 32MeterLineWidth=4;
							if ((pUSAPMbufIn[x-15] == '1') && (pUSAPMbufIn[x-9] == 'L'))
								LineWidth1[0] = pUSAPMbufIn[x+1];
							else if ((pUSAPMbufIn[x-15] == '2') && (pUSAPMbufIn[x-9] == 'L'))
							{
								if (pUSAPMbufIn[x-16] != '3')
									LineWidth2[0] = pUSAPMbufIn[x+1];
								else
									LineWidth32[0] = pUSAPMbufIn[x+1];
							}
							else if ((pUSAPMbufIn[x-15] == '4') && (pUSAPMbufIn[x-9] == 'L'))
							{
								if (pUSAPMbufIn[x-16] == '6')
									LineWidth64[0] = pUSAPMbufIn[x+1];
								else
									LineWidth4[0] = pUSAPMbufIn[x+1];
							}
							else if ((pUSAPMbufIn[x-15] == '8') && (pUSAPMbufIn[x-9] == 'L'))
								LineWidth8[0] = pUSAPMbufIn[x+1];
							else if ((pUSAPMbufIn[x-15] == '6') && (pUSAPMbufIn[x-9] == 'L'))
								LineWidth16[0] = pUSAPMbufIn[x+1];
						}
						else if ((pUSAPMbufIn[x] == '=') && (pUSAPMbufIn[x-4] == 'L'))
						{//4MeterTopoLine=
							if (pUSAPMbufIn[x-8] == 'T')
							{
								if (pUSAPMbufIn[x-14] == '4')
								{
									if (pUSAPMbufIn[x-15] != '6')
										TopoLine4[0] = pUSAPMbufIn[x+1];
									else if (pUSAPMbufIn[x-15] == '6')
										TopoLine64[0] = pUSAPMbufIn[x+1];
								}
								else if (pUSAPMbufIn[x-14] == '8')
								{
									if (pUSAPMbufIn[x-15] != '2')
										TopoLine8[0] = pUSAPMbufIn[x+1];
									else if (pUSAPMbufIn[x-15] == '2')
										TopoLine128[0] = pUSAPMbufIn[x+1];
								}
								else if (pUSAPMbufIn[x-14] == '6')
								{
									if (pUSAPMbufIn[x-15] != '5')
										TopoLine16[0] = pUSAPMbufIn[x+1];
									else if (pUSAPMbufIn[x-15] == '5')
										TopoLine256[0] = pUSAPMbufIn[x+1];
								}
								else if (pUSAPMbufIn[x-14] == '2')
									TopoLine32[0] = pUSAPMbufIn[x+1];
							}
						}

						else if ((pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x-7] == '8'))
							zoom1to8 = TRUE;//ZoomTo8Meters=Y
						else if ((pUSAPMbufIn[x+1] == 'N') && (pUSAPMbufIn[x-7] == '8'))
							zoom1to8 = FALSE;//ZoomTo8Meters=N
						else if ((pUSAPMbufIn[x+1] == '0') && (pUSAPMbufIn[x-7] == 'n'))
							WaypointColor = AsciiToHex(x);//WaypointColor=
						else if ((pUSAPMbufIn[x+1] == '0') && (pUSAPMbufIn[x-6] == 'e'))
							RouteColor = AsciiToHex(x);//RouteColor=
						else if ((pUSAPMbufIn[x+1] == '0') && (pUSAPMbufIn[x-6] == 'k'))
							TrackColor = AsciiToHex(x);//TrackColor=
						else if ((pUSAPMbufIn[x+1] == '0') && (pUSAPMbufIn[x-6] == 'n'))
							PositionColor = AsciiToHex(x);//PositionColor=
						else if ((pUSAPMbufIn[x+1] == '0') && (pUSAPMbufIn[x-7] == 'x'))
							TextColor = AsciiToHex(x);//TextColor=0x80FF00
						else if ((pUSAPMbufIn[x+1] == '0') && (pUSAPMbufIn[x-7] == 'R'))
							APRSColor = AsciiToHex(x);//APRSColor=0x0000FF
						else if ((pUSAPMbufIn[x+1] == '0') && (pUSAPMbufIn[x-7] == 'e') && (pUSAPMbufIn[x-6] == 'r'))
							TigerColor = AsciiToHex(x);//TigerColor=0x0000FF

						else if ((pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x-1] == 'n'))
							showlatlon = TRUE;//ShowLatlon=YES
						else if ((pUSAPMbufIn[x+1] =='N') && (pUSAPMbufIn[x-1] == 'n'))
							showlatlon = FALSE;//ShowLatlon=NO

						else if ((pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x-5] == 'y'))
							sortbyname = TRUE;//SortbyName=YES
						else if ((pUSAPMbufIn[x+1] =='N') && (pUSAPMbufIn[x-5] == 'y'))
							sortbyname = FALSE;//SortbyName=NO

						else if ((pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x-5] == 'w'))
							showname = TRUE;//ShowName=YES
						else if ((pUSAPMbufIn[x+1] =='N') && (pUSAPMbufIn[x-5] == 'w'))
							showname = FALSE;//ShowName=NO

						else if ((pUSAPMbufIn[x-1] == 'M') && (pUSAPMbufIn[x+1] == 'D'))
							MouseLoc = DEG;
						else if ((pUSAPMbufIn[x-1] == 'M') && (pUSAPMbufIn[x+1] == 'M'))
							MouseLoc = DEGMIN;
						else if ((pUSAPMbufIn[x-1] == 'M') && (pUSAPMbufIn[x+1] == 'S'))
							MouseLoc = DEGMINSEC;
						else if ((pUSAPMbufIn[x-1] == 'M') && (pUSAPMbufIn[x+2] == 'T'))
							MouseLoc = ITSUTM;
						else if ((pUSAPMbufIn[x-1] == 'M') && (pUSAPMbufIn[x+2] == 'S'))
							MouseLoc = ITSUSNG;

						else if ((pUSAPMbufIn[x-9] == 'I') && ((pUSAPMbufIn[x+1] != '0') || (pUSAPMbufIn[x+2] != '0')))
						{//FadeIncrement=00
							FadeIncrement = atoi(&pUSAPMbufIn[x+1]);// - '0') * 10) + (pUSAPMbufIn[x+2] - '0') % 10))
						}
						else if ((pUSAPMbufIn[x-1] == 'l') && (pUSAPMbufIn[x-9] == 'Z'))
						{//ZoomLevel=
							if (pUSAPMbufIn[x+1] == '1')
							{
								Zoom = 1;
								PixelsPerTile = 200;//200 meters per 200 pixels
							}
							else if (pUSAPMbufIn[x+1] == '2')
							{
								Zoom = 2;
								PixelsPerTile = 100;//200 meters per 100 pixels
							}
							else if (pUSAPMbufIn[x+1] == '3')
							{
								Zoom = 3;
								PixelsPerTile = 50;//200 meters per 50 pixels
							}
							else if (pUSAPMbufIn[x+1] == '4')
							{//8 meters/pixel zoom1to8 == TRUE
								Zoom = 4;
								PixelsPerTile = 25;//200 meters per 25 pixels
							}
							else if (pUSAPMbufIn[x+1] == '5')
							{//8 meters/pixel zoom1to8 == FALSE
								Zoom = 5;
								PixelsPerTile = 200;
								MetersPerTile = 1600;
							}
							else if (pUSAPMbufIn[x+1] == '6')
							{
								Zoom = 6;
								PixelsPerTile = 100;
								MetersPerTile = 1600;
							}
							else if (pUSAPMbufIn[x+1] == '7')
							{
								Zoom = 7;
								PixelsPerTile = 50;
								MetersPerTile = 1600;
							}
							else if (pUSAPMbufIn[x+1] == '8')
							{
								Zoom = 8;
								PixelsPerTile = 25;
								MetersPerTile = 1600;
							}
						}
						else if ((pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x-4] == 'T'))
						{//Topo=YES
							MapType = TOPO;
							if (Zoom == 1)
							{
								PixelsPerTile = 200;
								MetersPerTile = 800;
							}
							else if (Zoom == 2)
							{
								PixelsPerTile = 100;
								MetersPerTile = 800;
							}
							else if (Zoom == 3)
							{
								PixelsPerTile = 50;
								MetersPerTile = 800;
							}
							else if (Zoom == 4)
							{
								PixelsPerTile = 25;
								MetersPerTile = 800;
							}
							if (Zoom == 5)
							{
								PixelsPerTile = 200;
								MetersPerTile = 12800;
							}
							else if (Zoom == 6)
							{
								PixelsPerTile = 100;
								MetersPerTile = 12800;
							}
							else if (Zoom == 7)
							{
								PixelsPerTile = 50;
								MetersPerTile = 12800;
							}
							else if (Zoom == 8)
							{
								PixelsPerTile = 25;
								MetersPerTile = 12800;
							}
							ShowTopo();
						}
						else if ((pUSAPMbufIn[x+1] == 'Q') && (pUSAPMbufIn[x-4] == 'T'))
						{//QQ
							MapType = URBANAREA;
							if (Zoom == 1)
							{
								PixelsPerTile = 200;
								MetersPerTile = 50;
							}
							else if (Zoom == 2)
							{
								PixelsPerTile = 100;
								MetersPerTile = 50;
							}
							else if (Zoom == 3)
							{
								PixelsPerTile = 50;
								MetersPerTile = 50;
							}
							else if (Zoom == 4)
							{
								PixelsPerTile = 25;
								MetersPerTile = 50;
							}
							else if (Zoom == 5)
							{
								PixelsPerTile = 200;
								MetersPerTile = 800;
							}
							else if (Zoom == 6)
							{
								PixelsPerTile = 100;
								MetersPerTile = 800;
							}
							else if (Zoom == 7)
							{
								PixelsPerTile = 50;
								MetersPerTile = 800;
							}
							else if (Zoom == 8)
							{
								PixelsPerTile = 25;
								MetersPerTile = 800;
							}
							ShowUrbanArea();
						}
						else if ((pUSAPMbufIn[x-4] == 'P') && (pUSAPMbufIn[x-13] == 'W'))
						{//WaypointsPath=
							for (y = 0, z = x+1; (pUSAPMbufIn[z] != '\r') && (z < fileSize); y++, z++)
								WaypointsPath[y] = pUSAPMbufIn[z];
							WaypointsPath[y] = 0;
						}
						else if ((pUSAPMbufIn[x-4] == 'N') && (pUSAPMbufIn[x-8] == 'U'))
						{//UserName=
							for (y = 0, z = x+1; (pUSAPMbufIn[z] != '\r') && (z < fileSize); y++, z++)
								ProxyUserName[y] = pUSAPMbufIn[z];
							ProxyUserName[y] = 0;
							ProxyUserLen = z;
							proxy++;
						}
						else if ((pUSAPMbufIn[x-8] == 'P') && (pUSAPMbufIn[x-7] == 'a') && (pUSAPMbufIn[x-6] == 's') && (pUSAPMbufIn[x-5] == 's'))
						{//Password=
							for (y = 0, z = x+1; (pUSAPMbufIn[z] != '\r') && (z < fileSize); y++, z++)
								ProxyPassword[y] = pUSAPMbufIn[z];
							ProxyPassword[y] = 0;
							ProxyPassLen = z;
							proxy++;
						}
						else if ((pUSAPMbufIn[x-2] == 'v') && (pUSAPMbufIn[x-3] == 'i'))//Drive=
						{
							Streets[0] = pUSAPMbufIn[x+1];
							Streets2[0] = pUSAPMbufIn[x+1];
							Streets3[0] = pUSAPMbufIn[x+1];
							Streets4[0] = pUSAPMbufIn[x+1];
						}
						if ((pUSAPMbufIn[x-1] == 'T') && (pUSAPMbufIn[x-2] == '&') && (pUSAPMbufIn[x-3] == 'S'))//S&T=
						{
							for (y = 0, z = x+1; (pUSAPMbufIn[z] != '\r') && z < (fileSize); y++, z++)
							{
								Streets[y] = pUSAPMbufIn[z];
								Streets2[y] = pUSAPMbufIn[z];
							}
							Streets[y] = 0;
							for (y-- ; Streets2[y] != '\\'; y--)
								;
							y++;
							Streets2[y] = 0;
						}
						else if ((pUSAPMbufIn[x-1] == 'e') && (pUSAPMbufIn[x-5] == '2'))
						{
							Spaces2Move = pUSAPMbufIn[x+1] - '0';
						}
						else if ((pUSAPMbufIn[x-1] == 't') && (pUSAPMbufIn[x-11] == 'P') && (pUSAPMbufIn[x-14] == 'O') && (pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x+2] == 'E'))
						{//OnePositionDot
							onepositiondot = TRUE;
						}
						else if ((pUSAPMbufIn[x-1] == 't') && (pUSAPMbufIn[x-4] == 'T') && (pUSAPMbufIn[x-8] == 'S'))
							showtext = (pUSAPMbufIn[x+1] == 'Y') ? TRUE : FALSE;
						else if ((pUSAPMbufIn[x-1] == 't') && (pUSAPMbufIn[x-4] == 'P') && (pUSAPMbufIn[x-8] == 'C') && (pUSAPMbufIn[x-12] == 'A'))
						{//APRSCommPort=1
							APRSCommPort[0] = pUSAPMbufIn[x+1];
							if (pUSAPMbufIn[x+2] != '\r')
								APRSCommPort[1] = pUSAPMbufIn[x+2];
						}
						else if ((pUSAPMbufIn[x-1] == 'd') && (pUSAPMbufIn[x-8] == 'A') && (pUSAPMbufIn[x-4] == 'B'))
						{//APRSBaud=4800
							APRSBaud = atoi(&pUSAPMbufIn[x+1]);
						}
						else if ((pUSAPMbufIn[x-6] == 'M') && (pUSAPMbufIn[x-5] == 'y') && (pUSAPMbufIn[x-4] == 'C') && (pUSAPMbufIn[x-3] == 'a'))
						{//MyCall=
							for (y = x+1, z = 0; (y < (int)fileSize) && (pUSAPMbufIn[y] != '\r'); y++, z++)
								MyCall[z] = pUSAPMbufIn[y];
							MyCall[z] = 0;
						}
						else if ((pUSAPMbufIn[x-10] == 'H') && (pUSAPMbufIn[x-9] == 'o') && (pUSAPMbufIn[x-6] == 'L') && (pUSAPMbufIn[x-5] == 'a'))
						{//HomeLatLon=
							for (y = x+1, z = 0; (y < (int)fileSize) && (pUSAPMbufIn[y] != '\r'); y++, z++)
								HomeLatLon[z] = pUSAPMbufIn[y];
							HomeLatLon[z] = 0;
						}
						else if ((pUSAPMbufIn[x-10] == 'T') && (pUSAPMbufIn[x-9] == 'r') && (pUSAPMbufIn[x-4] == 'i') && (pUSAPMbufIn[x-3] == 't'))
						{//TransmitTo=
							if (pUSAPMbufIn[x+1] == 'H')
								transmitto = TRANSMITHOME;
							else if (pUSAPMbufIn[x+1] == 'G')
								transmitto = TRANSMITGPS;
							else if (pUSAPMbufIn[x+1] == 'N')
								transmitto = TRANSMITNONE;
						}
						else if ((pUSAPMbufIn[x-10] == 'H') && (pUSAPMbufIn[x-6] == 'S') && (pUSAPMbufIn[x-5] == 'y') && (pUSAPMbufIn[x-4] == 'm'))
						{//HomeSymbol=
							for (y = x+1, z = 0; (y < (int)fileSize) && (pUSAPMbufIn[y] != '\r'); y++, z++)
								HomeSymbol[z] = pUSAPMbufIn[y];
							HomeSymbol[z] = 0;
							if (HomeSymbol[0] == '/')
							{
								for (y = 0; y < 94; y++)
								{
									for (w = 0, z = 1; HomeSymbol[z] != 0; w++, z++)
										if (HomeSymbol[z] != APRSSymbols[y].Primary[w])
											break;
									if (HomeSymbol[z] == 0)
									{//found it
										homesymbolindex = y;
										break;
									}
								}
							}
							else
							{
								for (y = 0; y < 94; y++)
								{
									for (w = 0, z = 1; HomeSymbol[z] != 0; w++, z++)
										if (HomeSymbol[z] != APRSSymbols[y].Secondary[w])
											break;
									if (HomeSymbol[z] == 0)
									{//found it
										homesymbolindex = y;
										break;
									}
								}
							}
						}
						else if ((pUSAPMbufIn[x-9] == 'G') && (pUSAPMbufIn[x-8] == 'P') && (pUSAPMbufIn[x-7] == 'S') && (pUSAPMbufIn[x-6] == 'S'))
						{//GPSSymbol=
							for (y = x+1, z = 0; (y < (int)fileSize) && (pUSAPMbufIn[y] != '\r'); y++, z++)
								GPSSymbol[z] = pUSAPMbufIn[y];
							GPSSymbol[z] = 0;
							for (y = 0; y < 94; y++)
							{
								if (GPSSymbol[0] == '/')
								{
									for (w = 0, z = 1; GPSSymbol[z] != 0; w++, z++)
										if (GPSSymbol[z] != APRSSymbols[y].Primary[w])
											break;
								}
								else
								{
									for (w = 0, z = 1; GPSSymbol[z] != 0; w++, z++)
										if (GPSSymbol[z] != APRSSymbols[y].Secondary[w])
											break;
								}
								if (GPSSymbol[z] == 0)
								{
									gpssymbolindex = y;
									break;
								}
							}
						}
						else if ((pUSAPMbufIn[x-11] == 'D') && (pUSAPMbufIn[x-10] == 'e') && (pUSAPMbufIn[x-5] == 'a') && (pUSAPMbufIn[x-4] == 't'))
						{//Destination=
							for (y = x+1, z = 0; (y < (int)fileSize) && (pUSAPMbufIn[y] != '\r'); y++, z++)
								Destination[z] = pUSAPMbufIn[y];
							Destination[z] = 0;
						}
						else if ((pUSAPMbufIn[x-8] == '\n') && (pUSAPMbufIn[x-7] == 'C') && (pUSAPMbufIn[x-6] == 'o') && (pUSAPMbufIn[x-2] == 'n') && (pUSAPMbufIn[x-1] == 't'))
						{//Comment=
							for (y = x+1, z = 0; (y < (int)fileSize) && (pUSAPMbufIn[y] != '\r'); y++, z++)
								Comment[z] = pUSAPMbufIn[y];
							Comment[z] = 0;
						}
						else if ((pUSAPMbufIn[x-6] == 'B') && (pUSAPMbufIn[x-5] == 'E') && (pUSAPMbufIn[x-4] == 'A'))
						{//BEACON=
							for (y = x+1, z = 0; (y < (int)fileSize) && (pUSAPMbufIn[y] != '\r'); y++, z++)
								Beacon[z] = pUSAPMbufIn[y];
							Beacon[z] = 0;
						}
//						else if ((pUSAPMbufIn[x-1] == 'S') && (pUSAPMbufIn[x-4] == 'K') && (pUSAPMbufIn[x-3] == 'I') && (pUSAPMbufIn[x-2] == 'S'))
//						{//KISS=YES
//							if ((pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x+2] == 'E'))
//								kiss = TRUE;
//						}
						else if ((pUSAPMbufIn[x-11] == 'S') && (pUSAPMbufIn[x-10] == 'B') && (pUSAPMbufIn[x-9] == 'S') && (pUSAPMbufIn[x-5] == 'S'))
						{//SBSlowSpeed=
							sbSlowSpeed = atoi(&pUSAPMbufIn[x+1]);
						}
						else if ((pUSAPMbufIn[x-12] == 'S') && (pUSAPMbufIn[x-11] == 'B') && (pUSAPMbufIn[x-10] == 'S') && (pUSAPMbufIn[x-6] == 'B'))
						{//SBSlowBeacon=
							sbSlowBeacon = atoi(&pUSAPMbufIn[x+1]);
						}
						else if ((pUSAPMbufIn[x-11] == 'S') && (pUSAPMbufIn[x-10] == 'B') && (pUSAPMbufIn[x-9] == 'H') && (pUSAPMbufIn[x-5] == 'S'))
						{//SBHighSpeed=
							sbHighSpeed = atoi(&pUSAPMbufIn[x+1]);
						}
						else if ((pUSAPMbufIn[x-12] == 'S') && (pUSAPMbufIn[x-11] == 'B') && (pUSAPMbufIn[x-10] == 'H') && (pUSAPMbufIn[x-6] == 'B'))
						{//SBHighBeacon=
							sbHighBeacon = atoi(&pUSAPMbufIn[x+1]);
						}
						else if ((pUSAPMbufIn[x-10] == 'S') && (pUSAPMbufIn[x-9] == 'B') && (pUSAPMbufIn[x-8] == 'T') && (pUSAPMbufIn[x-4] == 'T'))
						{//SBTurnTime=
							sbTurnTime = atoi(&pUSAPMbufIn[x+1]);
						}
						else if ((pUSAPMbufIn[x-7] == 'S') && (pUSAPMbufIn[x-6] == 'B') && (pUSAPMbufIn[x-5] == 'A'))
						{//SBAngle=
							sbAngle = atoi(&pUSAPMbufIn[x+1]);
						}
						else if ((pUSAPMbufIn[x-10] == 'S') && (pUSAPMbufIn[x-9] == 'B') && (pUSAPMbufIn[x-8] == 'C'))
						{//SBConstant=
							sbConstant = atoi(&pUSAPMbufIn[x+1]);
						}
						else if ((pUSAPMbufIn[x-9] == 'B') && (pUSAPMbufIn[x-14] == 'S'))
						{//SmartBeaconing=
							if ((pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x+2] == 'E'))
								smartbeaconing = TRUE;
						}
						else if ((pUSAPMbufIn[x-10] == 'C') && (pUSAPMbufIn[x-9] == 'o') && (pUSAPMbufIn[x-8] == 'm') && (pUSAPMbufIn[x-7] == 'p'))
						{//Compressit=
							if ((pUSAPMbufIn[x+1] == 'Y') && (pUSAPMbufIn[x+2] == 'E'))
								compressit = TRUE;
						}
					}//endof if (pUSAPMbufIn[x] == '=')
				}
				free(pUSAPMbufIn);
				pUSAPMbufIn = NULL;
				FillZoomTable();
			}
			CloseHandle(hFile);
		}
//		else
//		{//create USAPM.ini
//		}
		hFile = CreateFile(USAPhotoMapsKey, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			ReadFile(hFile, Key, 6, &dwBytesRead, NULL);
			CloseHandle (hFile);
		}
		prefInMouseLoc = MouseLoc;
		prefInZoom = Zoom;
		prefInLatlon = showlatlon;

		GetCurrentDirectory(255, CurrentDir);
		strcpy(CurrentTrackDir, CurrentDir);
		strcat(CurrentTrackDir, "\\");
		if ((INVALID_HANDLE_VALUE != FindFirstFile("Tracks", &fd)) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			strcat(CurrentTrackDir, "Tracks\\");

		xBeg = -1;
		TimerFlags.timing = FALSE;
		TimerFlags.garmintiming = FALSE;
		TimerFlags.nmeatiming = FALSE;
		TimerFlags.gotprotocol = TRUE;
		TimerFlags.hwnd = hwnd;

		InitializeCriticalSection(&cs);
		hEventExit = CreateEvent(NULL, TRUE, FALSE, NULL);
		hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);//manual-reset, initialized non-signaled
		hTimerEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		hUSBEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		hTigerEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		hTigerReturn = CreateEvent(NULL, TRUE, FALSE, NULL);
		hCacheEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		hCacheOk = CreateEvent(NULL, TRUE, FALSE, NULL);
		hAPRSEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		hAPRSISEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		hThread = 0;
		hAPRSThread = 0;
		if (MouseLoc == DEG)
			Units = ID_VIEW_LATITUDELONGITUDE_DEGREES;
		else if (MouseLoc == DEGMIN)
			Units = ID_VIEW_LATITUDELONGITUDE_DEGREESMINUTES;
		else if (MouseLoc == DEGMINSEC)
			Units = ID_VIEW_LATITUDELONGITUDE_DEGREESMINUTESSECONDS;
		else if (MouseLoc == ITSUTM)
			Units = ID_VIEW_LATLON_UTM;
		else if (MouseLoc == ITSUSNG)
			Units = ID_VIEW_LATLON_USNG;
		hMenu = GetMenu(hwnd);
		if (shownamecomment)
			CheckMenuItem(hMenu, ID_VIEW_SHOWWAYPOINTNAMES, MF_CHECKED);
		ModifyZoom();
		CheckMenuItem(hMenu, MapUnits, MF_CHECKED);
//		if (kiss)
//			CheckMenuItem(hMenu, ID_APRS_TRANSLATEKISSDATA, MF_CHECKED);
		ShowZoom();
		DrawMenuBar(hwnd);

		if ((hFile = FindFirstFile(USAPhotoMapsData, &fd)) == INVALID_HANDLE_VALUE)
			CreateDirectory(USAPhotoMapsData, NULL);
		if ((hFile = FindFirstFile(BIGPhotoMapsData, &fd)) == INVALID_HANDLE_VALUE)
			CreateDirectory(BIGPhotoMapsData, NULL);
		FindClose(hFile);

		if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, SubKey, &hRegKey))
			RegQueryValueEx(hRegKey, "", NULL, &RegType, RegValue, &RegValueSize);
		RegCloseKey(hRegKey);
		if (RegValueSize != 21)
		{//if it was changed by a previous bug in USAPhotoMaps
			RegValueSize = 21;
			for (x = 0; x < 21; x++)
				RegValue[x] = OrigRegValue[x];
		}

		switch (RegValue[14])
		{
		case '8':
			if (RegValue[13] == '4')
			{
				BaudUnits = ID_GPS_BAUD_4800;
				Baud = 4800;
			}
			else if (RegValue[13] == '3')
			{
				BaudUnits = ID_GPS_BAUD_38400;
				Baud = 38400;
			}
			break;
		case '9':
			BaudUnits = ID_GPS_BAUD_19200;
			Baud = 19200;
			break;
		case '7':
			BaudUnits = ID_GPS_BAUD_57600;
			Baud = 57600;
			break;
		case '1':
			BaudUnits = ID_GPS_BAUD_115200;
			Baud = 115200;
			break;
		default:
			BaudUnits = ID_GPS_BAUD_9600;
			Baud = 9600;
			break;
		}
		MenuChecks();

		switch (APRSBaud)
		{
		case 4800:
			CheckMenuItem(hMenu, ID_APRS_BAUD_4800, MF_CHECKED);
			break;
		case 9600:
			CheckMenuItem(hMenu, ID_APRS_BAUD_9600, MF_CHECKED);
			break;
		case 19200:
			CheckMenuItem(hMenu, ID_APRS_BAUD_19200, MF_CHECKED);
			break;
		case 38400:
			CheckMenuItem(hMenu, ID_APRS_BAUD_38400, MF_CHECKED);
			break;
		case 57600:
			CheckMenuItem(hMenu, ID_APRS_BAUD_57600, MF_CHECKED);
			break;
		case 115200:
			CheckMenuItem(hMenu, ID_APRS_BAUD_115200, MF_CHECKED);
			break;
		}

		hComm = INVALID_HANDLE_VALUE;
		hAPRSComm = INVALID_HANDLE_VALUE;
		Noffset = 6;
		Eoffset = 10;
		IdentOffset = 0;
		LocOffset = 18;
		SymOffset = 0;
		WaypointProt = 103;//flag

		iBuf = 0;
		Buf[iBuf] = 0;

		if (SystemParametersInfo(SPI_GETWORKAREA, 0, &rect, 0))
		{
			cxScreen = rect.right;
			cyScreen = rect.bottom;
		}
		else
		{
			cxScreen = GetSystemMetrics(SM_CXFULLSCREEN);
			cyScreen = GetSystemMetrics(SM_CYFULLSCREEN);
		}
		Frame = GetSystemMetrics(SM_CXSIZEFRAME);
		TitleAndMenu = GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYMENU);
		cxChar = LOWORD(GetDialogBaseUnits());
		cyChar = HIWORD(GetDialogBaseUnits());
		TilesAcross = ((cxScreen-(Frame*2)) / PixelsPerTile) + 1;
		TilesDown = ((cyScreen-((Frame*2)+TitleAndMenu)) / PixelsPerTile) + 1;
		InitializeOpenFileNameLogFont(hwnd);

//create hdcGrayMem to draw blank tiles gray
		lSquare = ((cxScreen / 2) / 200) * 200;
		rSquare = lSquare + 200;
		tSquare = ((cyScreen / 2) / 200) * 200;
		bSquare = tSquare + 200;
 		hdc = GetDC (hwnd);
		hdcGrayMem = CreateCompatibleDC (hdc);//not deleted until WM_CLOSE or zooming
		hGrayBitmap = CreateCompatibleBitmap (hdc, 200, 200);//ditto
		ReleaseDC(hwnd, hdc);
		SelectObject(hdcGrayMem, hGrayBitmap);
		bmih.biSize = sizeof(BITMAPINFOHEADER);
		bmih.biWidth = 200;
		bmih.biHeight = -200;// - for right-side-up picture
		bmih.biPlanes = 1;
		bmih.biBitCount = 24;
		bmih.biCompression = BI_RGB;
		bmih.biSizeImage = ImageSize;
		bmi.bmiHeader = *pbmih;
		GrayArray = (unsigned char*) malloc(120000);
		for (x = 0; x < 120000; x++)
			GrayArray[x] = 0xC0;//gray
		for (x = 0; x < 600; x++)
			GrayArray[x] = 0;//black
		for (x = 0; x < 120000; x += 600)
		{
			GrayArray[x] = 0;
			GrayArray[x+1] = 0;
			GrayArray[x+2] = 0;
		}
		SetDIBits(hdcGrayMem, hGrayBitmap, 0, 200, GrayArray, pbmi, DIB_RGB_COLORS);
		free(GrayArray);

//create hdcBlackMem to draw blank tiles black
		lSquare = ((cxScreen / 2) / 200) * 200;
		rSquare = lSquare + 200;
		tSquare = ((cyScreen / 2) / 200) * 200;
		bSquare = tSquare + 200;
 		hdc = GetDC (hwnd);
		hdcBlackMem = CreateCompatibleDC (hdc);//not deleted until WM_CLOSE or zooming
		hRedBitmap = CreateCompatibleBitmap (hdc, 200, 200);//ditto
		ReleaseDC(hwnd, hdc);
		SelectObject(hdcBlackMem, hRedBitmap);
		bmih.biSize = sizeof(BITMAPINFOHEADER);
		bmih.biWidth = 200;
		bmih.biHeight = -200;// - for right-side-up picture
		bmih.biPlanes = 1;
		bmih.biBitCount = 24;
		bmih.biCompression = BI_RGB;
		bmih.biSizeImage = ImageSize;
		bmi.bmiHeader = *pbmih;
		GrayArray = (unsigned char*) malloc(120000);
		for (x = 0; x < 120000; x++)
			GrayArray[x] = 0;//black
		for (x = 0; x < 600; x++)
			GrayArray[x] = 0;//black
		for (x = 0; x < 120000; x += 600)
		{
			GrayArray[x] = 0;
			GrayArray[x+1] = 0;
			GrayArray[x+2] = 0;
		}
		SetDIBits(hdcBlackMem, hRedBitmap, 0, 200, GrayArray, pbmi, DIB_RGB_COLORS);
		free(GrayArray);

//get USAPhotoMapsIni data
		hFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			fileSize = GetFileSize(hFile, NULL);
			if (fileSize > 22)
			{
				pIniBuf = (unsigned char*) malloc(fileSize);//fileSize+2
				ReadFile(hFile, pIniBuf, fileSize, &dwBytesRead, NULL);
				CloseHandle(hFile);
				if (FALSE == GetXYZfromIniBuf())//get Area, X, Y, Z, BeginX, BeginY, UTMZone (UTMNorthing/UTMEasting come from WM_MOUSEMOVE
				{
					free(pIniBuf);
					DestroyWindow(hwnd);
					return 0;
				}
				free(pIniBuf);

				pTigerIndex = NULL;
				GetTigerIndex();
			}
			else
			{
				CloseHandle (hFile);
				MessageBox(hwnd, "USAPhotoMaps.ini is empty.\nDeleting it...", ERROR, MB_OK);
				DeleteFile(USAPhotoMapsIni);
				openatclosing = FALSE;
				SendMessage(hwnd, WM_CLOSE, 0, 0);
				return 0;
			}
		}
		else
		{
			brandnew = TRUE;//for WM_PAINT
			fileSize = sizeof(FirstIni)-1;
			pIniBuf = FirstIni;
			if (FALSE == GetXYZfromIniBuf())
			{
				DestroyWindow(hwnd);
				return 0;
			}
			hFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, FirstIni, fileSize, &dwBytesWritten, NULL);
			CloseHandle(hFile);
			hFile = CreateFile(WashingtonXML, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, Top, sizeof(Top)-1, &dwBytesWritten, NULL);
			WriteFile(hFile, WashingtonWaypoint, sizeof(WashingtonWaypoint)-1, &dwBytesWritten, NULL);
			CloseHandle(hFile);
		}
		Waypoints[0] = 0;

//////////////////////////////////////////////////////////
		GetDems();
//////////////////////////////////////////////////////////
	if (gsak)
	{
		static char BadFile[] = "is not a good file.";

		hFile3 = CreateFile(RunPgmGpx, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
		if (hFile3 != INVALID_HANDLE_VALUE)
		{
			if (fileSize = GetFileSize(hFile3, NULL))
			{
				fromOpen = TRUE;
				for (y = 0; RunPgmGpx[y] != 0; y++)
					WaypointsFullPath[y] = RunPgmGpx[y];
				WaypointsFullPath[y] = 0;
				for (x = 0, y = 1; runpgm[y] != 0; x++, y++)
					Waypoints[x] = runpgm[y];
				Waypoints[x] = 0;
			}
			else
				MessageBox(hwnd, BadFile, RunPgmGpx, MB_OK);
			CloseHandle(hFile3);
		}
		else
			MessageBox(hwnd, BadFile, RunPgmGpx, MB_OK);
	}

	case WM_USER4://falling thru or called by Open File or New Map or Open Waypoint
		for (x = 0; Area[x] != 0; x++)
		{
			TextDta[x] = Area[x];
			NewLocations[x] = Area[x];
		}
		for (y = 0; y < 5; x++, y++)
		{
			TextDta[x] = Not[y];
			NewLocations[x] = Xml[y];
		}
		if (Waypoints[0] != 0)//if from ID_WAYPOINTS_OPENFILE or waypoint is in a different UTM zone
		{
			strcpy(NewLocations, Waypoints);
			strcpy(NewLocationsFullPath, WaypointsFullPath);
		}
		else if (WaypointsPath[0] != 0)
		{
			for (x = 0; WaypointsPath[x] != 0; x++)
				NewLocationsFullPath[x] = WaypointsPath[x];
			for (y = 0; NewLocations[y] != 0; x++, y++)
				NewLocationsFullPath[x] = NewLocations[y];
			NewLocationsFullPath[x] = 0;
		}
		else
			NewLocationsFullPath[0] = 0;
 		for (x = 0; (x < 20) && (Area[x] != 0); x++)
		{
			UTM[x] = Area[x];
			LatLon[x] = Area[x];
			USNG[x] = Area[x];
		}
		for ( ; x < 20; x++)
		{
			UTM[x] = ' ';
			LatLon[x] = ' ';
			USNG[x] = ' ';
		}

		WaypointArray = NULL;
		tempWayArray = NULL;
		if (NewLocationsFullPath[0] == 0)
		{
			hFile = CreateFile(NewLocations, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
			GetFullPathName(NewLocations, MAX_PATH, NewLocationsFullPath, lpPart);//Windows concatenates current dir and NewLocations
		}
		else
			hFile = CreateFile(NewLocationsFullPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
		if ((hFile) != INVALID_HANDLE_VALUE)
		{
			if (fileSize = GetFileSize(hFile, NULL))
			{
				tempWayArray = (char*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
				if (tempWayArray == NULL)
				{
					CloseHandle(hFile);
					MessageBox(hwnd, "Not enough memory for waypoints.", ERROR, MB_OK);
					SendMessage(hwnd, WM_CLOSE, 0, 0);
					return 0;
				}
				ReadFile(hFile, tempWayArray, fileSize, &dwBytesRead, NULL);
				CloseHandle(hFile);

				for (y = 0; y < (int)fileSize; y++)
				{
					if ((tempWayArray[y] == '<') && (tempWayArray[y+1] == 'w') && (tempWayArray[y+2] == 'p') && (tempWayArray[y+3] == 't'))
						break;//to ignore header stuff
				}
				if (y == (int)fileSize)
				{
					VirtualFree(tempWayArray, 0, MEM_RELEASE);
					goto nowaypoints;
				}

				copyit = itswpt = gotway = FALSE;
				NumOfWaypoints = 0;
				for (x = 0, y = 0; x < (int)fileSize; x++)
				{
					if ((x > 5) && (tempWayArray[x-1] == '>') && (tempWayArray[x-5] == '/') && (tempWayArray[x-4] == 'w') && (tempWayArray[x-3] == 'p') && (tempWayArray[x-2] == 't'))
					{//</wpt>
						gotway = FALSE;
						copyit = FALSE;
					}
					if (copyit == FALSE)
					{
						if (tempWayArray[x] == '<')
						{
							if ((tempWayArray[x+1] == 'w') && (tempWayArray[x+2] == 'p') && (tempWayArray[x+3] == 't'))
							{//<wpt>
								gotway = TRUE;
								itswpt = TRUE;
								copyit = TRUE;
								tempWayArray[y++] = '\r';
								tempWayArray[y++] = '\n';
								tempWayArray[y++] = tempWayArray[x];
								NumOfWaypoints++;
							}
							else if ((tempWayArray[x+1] == '/') && (tempWayArray[x+2] == 'w') && (tempWayArray[x+3] == 'p') && (tempWayArray[x+4] == 't'))
							{
								copyit = TRUE;
								tempWayArray[y++] = '\r';
								tempWayArray[y++] = '\n';
								tempWayArray[y++] = tempWayArray[x];
							}
							else if (gotway)
							{
								if (((tempWayArray[x+1] == 'n') && (tempWayArray[x+2] == 'a') && (tempWayArray[x+3] == 'm'))
								 || ((tempWayArray[x+1] == 'd') && (tempWayArray[x+2] == 'e') && (tempWayArray[x+3] == 's'))
								 || ((tempWayArray[x+1] == 'c') && (tempWayArray[x+2] == 'm') && (tempWayArray[x+3] == 't'))
								 || ((tempWayArray[x+1] == 's') && (tempWayArray[x+2] == 'y') && (tempWayArray[x+3] == 'm'))
								 || ((tempWayArray[x+1] == 'e') && (tempWayArray[x+2] == 'l') && (tempWayArray[x+3] == 'e')))
								{
									copyit = TRUE;
									tempWayArray[y++] = '\r';
									tempWayArray[y++] = '\n';
									tempWayArray[y++] = tempWayArray[x];
								}
							}
						}
					}
					else//if (copyit)
					{
						if ((x > 5) && (tempWayArray[x-1] == '>'))
						{
							if (itswpt)
							{
								itswpt = FALSE;
								copyit = FALSE;
							}
							else if (((tempWayArray[x-5] == '/') && (tempWayArray[x-4] == 'c') && (tempWayArray[x-3] == 'm') && (tempWayArray[x-2] == 't'))
							 || ((tempWayArray[x-5] == '/') && (tempWayArray[x-4] == 's') && (tempWayArray[x-3] == 'y') && (tempWayArray[x-2] == 'm'))
							 || ((tempWayArray[x-5] == '/') && (tempWayArray[x-4] == 'e') && (tempWayArray[x-3] == 'l') && (tempWayArray[x-2] == 'e'))
							 || ((tempWayArray[x-6] == '/') && (tempWayArray[x-4] == 'a') && (tempWayArray[x-3] == 'm') && (tempWayArray[x-2] == 'e'))
							 || ((tempWayArray[x-6] == '/') && (tempWayArray[x-4] == 'e') && (tempWayArray[x-3] == 's') && (tempWayArray[x-2] == 'c'))
							 || ((tempWayArray[x-5] == '/') && (tempWayArray[x-4] == 'w') && (tempWayArray[x-3] == 'p') && (tempWayArray[x-2] == 't')))
							{
								copyit = FALSE;
							}
							else
								tempWayArray[y++] = tempWayArray[x];
						}
						else
							tempWayArray[y++] = tempWayArray[x];
					}
				}//end of for (x = 0

				tempWayArray[y++] = '\r';
				tempWayArray[y++] = '\n';
				tempWayArray[y] = 0;
				fileSize = y;

				MaxWaySize = fileSize+100000;
				WaypointArray = (char*)calloc(1, MaxWaySize);//leave room for 100 new waypoints of 1,000 bytes each
				if (WaypointArray == NULL)
				{
					VirtualFree(tempWayArray, 0, MEM_RELEASE);
					MessageBox(hwnd, "Not enough memory for waypoints.", ERROR, MB_OK);
					SendMessage(hwnd, WM_CLOSE, 0, 0);
					return 0;
				}
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
				for (y = 0; y < (int)fileSize; y++)
				{
					if ((tempWayArray[y] == '<') && (tempWayArray[y+1] == 'w') && (tempWayArray[y+2] == 'p') && (tempWayArray[y+3] == 't'))
						break;//to ignore header stuff
				}
//get rid of CDATA stuff & check format
				gotway = gotelev = gotname = gotcmt = gotdescr = gotsym = FALSE;
				for (x = 0; y < (int)fileSize; x++, y++)
				{
					if (tempWayArray[y] == '<')
					{//check for correct format
						if (CheckFormat(y) == FALSE)
						{//if bad format
							MessageBox(hwnd, Error, ERROR, MB_OK);//Error from CheckFormat
						}
					}
					else if (tempWayArray[y] == '>')
					{//check if at end of <name> or <cmt> or <desc>
						WaypointArray[x] = tempWayArray[y];
						if (tempWayArray[y+1] != '<')
						{//if it's not empty
							x++;
							y++;
						}
						else if (tempWayArray[y+2] == '!')
						{//if it's CDATA stuff
							x++;
							y++;
						}
						if (((tempWayArray[y-6] == '<') && (tempWayArray[y-5] == 'n') && (tempWayArray[y-4] == 'a'))
						 || ((tempWayArray[y-5] == '<') && (tempWayArray[y-4] == 'c') && (tempWayArray[y-3] == 'm'))
						 || ((tempWayArray[y-6] == '<') && (tempWayArray[y-5] == 'd') && (tempWayArray[y-4] == 'e')))
						{//lines that could have CDATA
							if ((tempWayArray[y] == '<')
							 && (tempWayArray[y+1] == '!')
							 && (tempWayArray[y+2] == '['))
							{//<![CDATA[ is there
								y += 9;//past <![CDATA[
								for ( ; (tempWayArray[y] != ']') || (tempWayArray[y+1] != ']') || (tempWayArray[y+2] != '>'); x++, y++)
									WaypointArray[x] = tempWayArray[y];
								y += 2;//(almost) past ]]>
								x--;
								continue;
							}
						}
					}
					WaypointArray[x] = tempWayArray[y];
				}//end of for (x = 0; y < (int)fileSize; x++, y++)
				VirtualFree(tempWayArray, 0, MEM_RELEASE);
				tempWayArray = NULL;

				WaypointArray[x] = 0;
				WaypointSize = x;
//put data into NewLoc structure
				for (x = 0; x < TOTAL_LOCS; x++)//was x < NumOfWaypoints
				{
					NewLoc[x].NUTM = 0;
					NewLoc[x].EUTM = 0;
					NewLoc[x].UTMZone = 0;
					NewLoc[x].pWaypoints = NULL;//pointer to waypoint data in WaypointArray
 					NewLoc[x].Ident = NULL;//pointer to name
					NewLoc[x].Location = NULL;//pointer to cmt
					NewLoc[x].Description = NULL;//pointer to desc
					NewLoc[x].Elev = NULL;//pointer to ele
					NewLoc[x].Sym = NULL;//pointer to sym
					NewLoc[x].size = 0;
					prevDist[x] = HUNDRED_MILES;
				}
//				prevDist[x] = HUNDRED_MILES;
				for (x = 0, z = 0; (x < WaypointSize) && (z < (TOTAL_LOCS-1)); x++)
				{
					if ((WaypointArray[x] == '<')
					 && (WaypointArray[x+1] == 'w')
					 && (WaypointArray[x+2] == 'p')
					 && (WaypointArray[x+3] == 't'))
					{
						firstx = x;
						for ( ; (x < WaypointSize) && (WaypointArray[x] != '"'); x++)
							;
						x++;//to Latitude
						Lat = atof(&WaypointArray[x]);
						for ( ; (x < WaypointSize) && (WaypointArray[x] != '='); x++)
							;
						x += 2;//to Longitude
						Lon = atof(&WaypointArray[x]);
						LatRad = Lat*deg2rad;
						LonRad = Lon*deg2rad;
						LatLontoUTM();
						NewLoc[z].EUTM = UTMEasting;
						NewLoc[z].NUTM = UTMNorthing;
						NewLoc[z].UTMZone = UTMZone;
						NewLoc[z].pWaypoints = &WaypointArray[firstx];

						while (x < WaypointSize)
						{
							for (x++; (x < WaypointSize) && (WaypointArray[x] != '<'); x++)
									;
							if ((WaypointArray[x+1] == 'e')
							 && (WaypointArray[x+2] == 'l')
							 && (WaypointArray[x+3] == 'e')
							 && (WaypointArray[x+4] == '>'))
							{//<ele>
								x += 5;//to elev
								NewLoc[z].Elev = WaypointArray + x;
							}
							else if ((WaypointArray[x+1] == 'n')
							 && (WaypointArray[x+2] == 'a')
							 && (WaypointArray[x+3] == 'm')
							 && (WaypointArray[x+4] == 'e')
							 && (WaypointArray[x+5] == '>'))
							{//<name>
								x += 6;//to name
								NewLoc[z].Ident = WaypointArray + x;
							}
							else if ((WaypointArray[x+1] == 'c')
							 && (WaypointArray[x+2] == 'm')
							 && (WaypointArray[x+3] == 't')
							 && (WaypointArray[x+4] == '>'))
							{//<cmt>
								x += 5;//to comment
								NewLoc[z].Location = WaypointArray + x;
							}
							else if ((WaypointArray[x+1] == 'd')
							 && (WaypointArray[x+2] == 'e')
							 && (WaypointArray[x+3] == 's')
							 && (WaypointArray[x+4] == 'c'))
							{//<desc>
								x += 6;//to description
								if ((WaypointArray[x] != 0) && (WaypointArray[x] != '<'))
									NewLoc[z].Description = WaypointArray + x;
							}
							else if ((WaypointArray[x+1] == 's')
							 && (WaypointArray[x+2] == 'y')
							 && (WaypointArray[x+3] == 'm'))
							{//<sym>
								x += 5;//to symbol
								NewLoc[z].Sym = WaypointArray + x;
							}
							else if ((WaypointArray[x+1] == '/')
							 && (WaypointArray[x+2] == 'w')
							 && (WaypointArray[x+3] == 'p')
							 && (WaypointArray[x+4] == 't')
							 && (WaypointArray[x+5] == '>'))
							{
								x += 7;//to 0x0A
								NewLoc[z].size = x - firstx + 1;
								if ((NewLoc[z].Location == NULL) && (NewLoc[z].Ident == NULL))
								{
									x = sprintf(Error, "Waypoint %i doesn't have\na Name or Comment!\nUse Notepad to add one\n(in %s).", z+1, NewLocations);
									MessageBox(hwnd, Error, NULL, MB_OK);
									openatclosing = FALSE;
									SendMessage(hwnd, WM_CLOSE, 0, 0);
									return 0;
								}
								z++;
								break;
							}
						}//end of while (x < WaypointSize)
					}//end of if ((WaypointArray[x] == '<')
					else if ((WaypointArray[x] == '<')
					 && (WaypointArray[x+1] == '/')
					 && (WaypointArray[x+2] == 'g')
					 && (WaypointArray[x+3] == 'p')
					 && (WaypointArray[x+4] == 'x'))
						break;//</gpx>
				}//end of for (x = 0, z = 0; x < WaypointSize; x++)

				NewLoc[z].NUTM = 0;
				NewLoc[z].EUTM = 0;
				NewLoc[z].UTMZone = 0;
				NewLoc[z].pWaypoints = NULL;//pointer to waypoint data in WaypointArray
 				NewLoc[z].Ident = NULL;//pointer to name
				NewLoc[z].Location = NULL;//pointer to cmt
				NewLoc[z].Description = NULL;//pointer to desc
				NewLoc[z].Elev = NULL;//pointer to ele
				NewLoc[z].Sym = NULL;//pointer to sym
				NewLoc[z].size = 0;
				EmptyLoc = z;
				
				if (z > 2)
				{
					if (sortbyname)
						qsort(NewLoc, z, sizeof(NewLoc[0]), compareIdent);
					else
						qsort(NewLoc, z, sizeof(NewLoc[0]), compareLoc);
				}
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
			}//end of if (fileSize
			else
			{
				CloseHandle(hFile);
				MessageBox(hwnd, "is 0 bytes in size.\nDelete it and try again", NewLocations, MB_OK);
				openatclosing = FALSE;
				SendMessage(hwnd, WM_CLOSE, 0, 0);
				return 0;
			}
		}//end of if ((hFile = CreateFile(NewLocations,

		else
		{
//			if (NewLocationsFullPath[0])
//				MessageBox(hwnd, "doesn't exist.\nIt'll be created when you make the first waypoint\nin this Map Location.", NewLocationsFullPath, MB_OK);
			for (x = 0; x < TOTAL_LOCS; x++)
			{
				NewLoc[x].NUTM = 0;
				NewLoc[x].EUTM = 0;
				NewLoc[x].UTMZone = 0;
				NewLoc[x].pWaypoints = NULL;//pointer to waypoint data in WaypointArray
 				NewLoc[x].Ident = NULL;//pointer to name
				NewLoc[x].Location = NULL;//pointer to cmt
				NewLoc[x].Description = NULL;//pointer to desc
				NewLoc[x].Elev = NULL;//pointer to ele
				NewLoc[x].Sym = NULL;//pointer to sym
				NewLoc[x].size = 0;
				prevDist[x] = HUNDRED_MILES;
			}
			EmptyLoc = 0;
			MaxWaySize = 100000;
			WaypointArray = (char*)calloc(1, MaxWaySize);//leave room for 100 new waypoints of 1,000 bytes each
			if (WaypointArray == NULL)
			{
				MessageBox(hwnd, "Not enough memory for waypoints.", ERROR, MB_OK);
				SendMessage(hwnd, WM_CLOSE, 0, 0);
				return 0;
			}
		}

nowaypoints:
		head = new_node = NULL;
		if ((hFile = CreateFile(TextDta, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
		{
			if (fileSize = GetFileSize(hFile, NULL))
			{
				z = sizeof(struct Text);
				y = fileSize / z;
				for (x = 0; x < y; x++)
				{
					cur = (struct Text*) malloc(z);
					if (x != 0)
						prev->next = cur;
					else
						head = cur;
					ReadFile(hFile, cur, z, &dwBytesRead, NULL);
					prev = cur;
					cur->next = NULL;
				}
			}
			CloseHandle(hFile);
		}

		rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
		colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
		//FALL THRU...

	case WM_USER2://called when zooming
		MapWidth = TilesAcross * PixelsPerTile;
		MapHeight = TilesDown * PixelsPerTile;
		if (PixelsPerTile == 50)
			ImageSize = 7600;//2 pad bytes
		else if (PixelsPerTile == 25)
			ImageSize = 1900;//1 pad byte
		else
			ImageSize = 3 * PixelsPerTile * PixelsPerTile;
		GetDotRadius();

		bmih.biSize = sizeof(BITMAPINFOHEADER);
		bmih.biWidth = PixelsPerTile;
		bmih.biHeight = -PixelsPerTile;// - for right-side-up picture
		bmih.biPlanes = 1;
		bmih.biBitCount = 24;
		bmih.biCompression = BI_RGB;
		bmih.biSizeImage = ImageSize;
		bmi.bmiHeader = *pbmih;
		DeleteDC (hdcMem);
		DeleteObject (hBitmap);
		hdc = GetDC (hwnd);
		hdcMem = CreateCompatibleDC (hdc);//not deleted until WM_CLOSE or zooming
		hBitmap = CreateCompatibleBitmap (hdc, MapWidth, MapHeight);//ditto
		ReleaseDC(hwnd, hdc);
		SelectObject (hdcMem, hBitmap);

		hdcSymMem1 = ReadBmpFile("mysymb.bmp");
		hdcSymMem2 = ReadBmpFile("mysymb2.bmp");

		//FALL THRU..
	case WM_USER://do full-screen draw of images
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) return 0;
		if ((Zoom <= 4) && (MapType == PHOTO))
		{
			fileName[0] = fileName0;
			fileName[1] = fileName1;
			fileName[2] = fileName2;
			fileName[17] = 'z';
			pointerFileName[0] = fileName0;
			pointerFileName[1] = fileName1;
			pointerFileName[2] = fileName2;
			pointerFileName[17] = 'z';
		}
		else if (Zoom >= 5)
		{
			fileName[0] = 'B';
			fileName[1] = 'i';
			fileName[2] = 'g';
			if (MapType == PHOTO)
				fileName[17] = 'z';
			else if (MapType == TOPO)
				fileName[17] = 't';
			else
				fileName[17] = 'c';
			pointerFileName[0] = 'B';
			pointerFileName[1] = 'i';
			pointerFileName[2] = 'g';
			if (MapType == PHOTO)
				pointerFileName[17] = 'z';
			else if (MapType == TOPO)
				pointerFileName[17] = 't';
			else
				pointerFileName[17] = 'c';
		}
		else if (MapType == TOPO)
		{
			fileName[0] = fileName0;
			fileName[1] = fileName1;
			fileName[2] = fileName2;
			fileName[17] = 'a';//to identify topo map data
			pointerFileName[0] = fileName0;
			pointerFileName[1] = fileName1;
			pointerFileName[2] = fileName2;
			pointerFileName[17] = 'a';
		}
		else if (MapType == URBANAREA)
		{
			fileName[0] = fileName0;
			fileName[1] = fileName1;
			fileName[2] = fileName2;
			fileName[17] = 'u';//to identify urban area data
			pointerFileName[0] = fileName0;
			pointerFileName[1] = fileName1;
			pointerFileName[2] = fileName2;
			pointerFileName[17] = 'u';
		}

		yLoc = PixelsPerTile * (TilesDown-1);//bottom of screen
		maxRows = rowOffset + TilesDown;
		maxCols = colOffset + TilesAcross;
		ZoneName[0] = Z[0];
		ZoneName[1] = Z[1];

		for (row = rowOffset; row < maxRows; row++)
		{//start at the bottom of the screen
			for (x = 0, z = 18; x < 3; x++, z++)
			{
				fileName[z] = ZoneName[x];
				pointerFileName[z] = ZoneName[x];
			}
			Y[0] = ((row / 1000) + '0');
//			Y[1] = (((row % 1000) / 100) + '0');
//			Y[2] = (((row % 100) / 10) + '0');
//			Y[3] = ((row % 10) + '0');
			_itoa(row, Y, 10);
			for (x = 0; Y[x] != 0; x++, z++)
			{
				pointerFileName[z] = Y[x];
				fileName[z] = Y[x];
			}
			for (x = 0; x < 5; x++, z++)
			{
				pointerFileName[z] = Ptr[x];
				fileName[z] = Dta[x];
			}
			hFile = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				hFile2 = CreateFile(pointerFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				fileSize = GetFileSize(hFile2, NULL);
				ReadFile(hFile2, Pointers, fileSize, &dwBytesRead, NULL);
				CloseHandle(hFile2);
				FirstOffset = Pointers[0];
				NumOfPointers = Pointers[1];
				Pointers[1] = 0;

				for (xLoc = 0, col = colOffset; col < maxCols; xLoc += PixelsPerTile, col++)
				{
					PointerOffset = col - FirstOffset;
					if ((PointerOffset >= 0) && (PointerOffset < NumOfPointers))
					{
						fileSize = Pointers[PointerOffset+2] - Pointers[PointerOffset+1];
						if (fileSize > 1)
						{
							SetFilePointer(hFile, Pointers[PointerOffset+1], NULL, FILE_BEGIN);
							ReadFile(hFile, TileBuf, fileSize, &dwBytesRead, NULL);
							if ((TileBuf[0] == 0xFF) && (TileBuf[1] == 0xD8) && (TileBuf[6] == 'J') && (TileBuf[7] == 'F'))
								Convert_TileBuf_hdcMem(NULL, 0xFFFFFFFF);
							else
								BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcBlackMem, 0, 0, SRCCOPY);
						}
						else
							BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
					}
					else
						BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
				}//end of for (col =
				ElevColCounter = 0;
				CloseHandle(hFile);
			}
			else for (xLoc = 0, col = colOffset; col < maxCols; xLoc += PixelsPerTile, col++)
			{
				BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
			}
			yLoc -= PixelsPerTile;
		}//end of for (row =

//		if (autodownload)
//			SendMessage(hwnd, WM_COMMAND, ID_FILE_DOWNLOADMAPDATA_FILLSCREEN, 0);

		if ((fromOpen) || (fromTracks) || (fromGoTo))
		{
			fromOpen = fromTracks = fromGoTo = FALSE;
 			InvalidateRect(hwnd, &rect, FALSE);
			UpdateWindow(hwnd);
			SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
		}
		cachenotfull = TRUE;
		return 0;
//end of case WM_CREATE



//////////////////////////////////////////////////////////////////////////////////////
	case WM_COMMAND:
		wParameter = LOWORD(wParam);
		switch (wParameter)
		{
		case ID_STOPPOSITIONING:
			if (autoLoc)
			{
				showposition = FALSE;
				if (fromFlag == NOBUTTON)
				{
					if (itsgarmin)
					{
						fromFlag = MENU;//slightly trick - to come back here after stop is sent to Garmin routine
						sendingStop = TRUE;
						for (x = 0; x < 8; x++, tgcount++)
							ToGPS[tgcount] = StopPVTPacket[x];
						if (tgcount > 49900) tgcount = 0;
						WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
						return 0;//slightly trick
					}
					else if (itsusb == FALSE)
					{
						SetEvent(hEventExit);
					}
					else if (hUSBThread != 0)
					{
						SignalUSBStop();
					}
				}
				showposition = FALSE;
				fromFlag = NOBUTTON;//for returning from Garmin comm routine
				autoLoc = FALSE;
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				if (UTMEasting != 0)
				{
					InvalidateRect(hwnd, &rect, FALSE);
					UpdateWindow(hwnd);
				}
			}
			break;

		case ID_STOPDOWNLOADING:
			EnterCriticalSection(&cs); downloading = FALSE; USBdownloading = FALSE; LeaveCriticalSection(&cs);
			if (hDownloadThread != 0)
			{
				ResetEvent(hEvent);//unsignal it
				if (WAIT_TIMEOUT == WaitForSingleObject(hEvent, 1000))//wait for it to be closed
				{
					TerminateThread((HANDLE)hDownloadThread, 1);
					MessageBeep(MB_OK);
					CloseHandle ((HANDLE)hDownloadThread);
					hDownloadThread = 0;
					DestroyMenu(hMenu5);
					hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
					SetMenu(hwnd, hMenu);
					MenuChecks();
				}
				if (fillscreen == FALSE)
				{
					Zoom = saveZoom;
					rowOffset = saveRowOffset;
					colOffset = saveColOffset;
					TilesDown = saveTilesDown;
					TilesAcross = saveTilesAcross;
					if ((fileName[0] != 'B') && (fileName[1] != 'i') && (fileName[2] != 'g'))
					{
						fileName[0] = fileName0;
						fileName[1] = fileName1;
						fileName[2] = fileName2;
						pointerFileName[0] = fileName0;
						pointerFileName[1] = fileName1;
						pointerFileName[2] = fileName2;
					}
					SendMessage(hwnd, WM_CLOSE, 0, 0);
				}
			}
			break;

		case ID_FILE_DOWNLOADMAPDATA_FILLSCREEN:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
//fillscrn:
			if (bigjpeg)
				break;
			if (newLoc)
				SaveLocs();
			if (newText)
				SaveText();
			fillscreen = TRUE;
			hDownloadThread = _beginthreadex(NULL, 0, DownloadThread, hwnd, 0, &idThread2);
			break;
/*
		case ID_FILE_DOWNLOADMAPDATA_1METERPIXELPHOTOS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if ((MapType != PHOTO) || (Zoom < 5))
				goto fillscrn;
			beginX = ScreenLeft / 200;
			beginY = ScreenTop / 200;
			endX = ScreenRight / 200;
			endY = ScreenBottom / 200;
			fileName[0] = 'U';
			fileName[1] = 'S';
			fileName[2] = 'A';
			saveZoom = Zoom;
			Zoom = 1;
			onemeter = TRUE;
			Response = 1;
			//FALL THRU...
		case ID_FILE_DOWNLOADMAPDATA_ENTERLATLON:
			if (bigjpeg)
				break;
			if (onemeter == FALSE)
			{
				EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
				saveZoom = Zoom;
				Response = DialogBox(hInst, "GETLATLON", hwnd, GetLatLonProc);
			}
			else
				onemeter = FALSE;
			if (Response !=	EXIT)
			{
				if (newLoc)
					SaveLocs();
				if (newText)
					SaveText();
				_itoa((beginY-endY), AsciiTotal, 10);// * (endX-beginX)
				for (x = 0, y = 10; AsciiTotal[x] != 0; x++, y++)
					DownloadProgress[y] = AsciiTotal[x];
				for (z = 0; z < x; z++)
					DownloadProgress[5-z] = '0';
				for (x = 0; PhotosDownloaded[x] != 0; x++, y++)
					DownloadProgress[y] = PhotosDownloaded[x];
				DownloadProgress[y] = 0;
				SizeOfDP = y;
				hdc = GetDC(hwnd);
				FillRect(hdc, &rect, (HBRUSH)CreateSolidBrush(LIGHTGRAY));
				SetBkColor(hdc, LIGHTGRAY);
				x = (cxScreen/2) - (32*cxChar);
				y = cyScreen/2;
				TextOut(hdc, (cxScreen/2) - (32*cxChar), cyScreen/2, DownloadProgress, SizeOfDP);
				TextOut(hdc, x, y + (cyChar*2), "USAPhotoMaps will close when all photos are downloaded.", 55);
				TextOut(hdc, x, y + (cyChar*3), "If a photo already exists in USAPhotoMaps, it's not downloaded.", 63);
				ReleaseDC(hwnd, hdc);
				fillscreen = FALSE;
				hDownloadThread = _beginthreadex(NULL, 0, DownloadThread, hwnd, 0, &idThread2);
			}
			break;
*/
		case ID_GOTO_ADDRESS:
			MessageBox(hwnd, "USGS doesn't do this anymore\n(in a format that I can use).", "Go To Address", MB_OK);
/*
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			Response = DialogBox(hInst, "ADDRESS", hwnd, AddressProc);//address is put into Address1
			if (Response != EXIT)
			{
				int good = 0;

				SetCursor(hWaitingCursor);
				AddrBuf = (char*)malloc(50000);
				hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
				if (hInternet = InternetOpenUrl(hOpen, Address1, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
				{
					for (fileSize = 0; (goodread = InternetReadFile(hInternet, AddrBuf, 50000, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
						;
					InternetCloseHandle(hInternet);
					if (fileSize > 50000)
						MessageBox(hwnd, "Website sent too much data!", ERROR, MB_OK);
					else if ((goodread) && (dwBytesRead == 0))
					{
						tempLat = Lat;
						tempLon = Lon;
						tempUTMZone = UTMZone;
						tempUTMN = UTMNorthing;
						tempUTME = UTMEasting;
						for (x = 0; x < (int)fileSize; x++)
						{
							if ((AddrBuf[x] == 'y') && (AddrBuf[x+2] == '='))
							{
								good++;
								x += 4;
								Lat = atof(&AddrBuf[x]);
								break;
							}
						}
						for (x = 0; x < (int)fileSize; x++)
						{
							if ((AddrBuf[x] == 'x') && (AddrBuf[x+2] == '='))
							{
								good++;
								x += 4;
								Lon = atof(&AddrBuf[x]);
								break;
							}
						}
					}
				}
				InternetCloseHandle(hOpen);
				free(AddrBuf);
				SetCursor(hCursor);
				if (good == 2)
				{
					if (gotaddr)
						for (x = 0; Address[x] != 0; x++)
							City[x] = Address[x];
					else if (gotcity)
						for (x = 0; xCity[x] != 0; x++)
							City[x] = xCity[x];
					else if (gotzip)
						for (x = 0; ZIP[x] != 0; x++)
							City[x] = ZIP[x];
					City[x] = 0;
					goto asdf2;
				}
				else
				{
					Lat = tempLat;
					Lon = tempLon;
					MessageBox(hwnd, "Either the USGS website couldn't find it,\nor their website is down:\nhttp://nmviewogc.cr.usgs.gov/tnm/FindAddress.jsp", Oops, MB_OK);
				}
			}
*/
			break;

		case ID_GOTO_TOWNSHIP://Populated Place
			tempUTMZone = UTMZone;
			for (x = 0; CurrentDir[x] != 0; x++)
				USGSFile[x] = CurrentDir[x];
			for (y = 0; StatesPath[y] != 0; x++, y++)
				USGSFile[x] = StatesPath[y];
			USGSFile[x] = 0;
			if (INVALID_HANDLE_VALUE != FindFirstFile(USGSFile, &fd))
			{
				for (x = 0; USGSFile[x] != '?'; x++)
					;
				qm = x;
				if (DialogBox(hInst, "USGS", hwnd, USGSProc))
				{
					tempLat = Lat;
					tempLon = Lon;

					tempUTMZone = UTMZone;
					tempUTMN = UTMNorthing;
					tempUTME = UTMEasting;
					for (x = 0; City[x] != '@'; x++)
						;
					City[x++] = 0;
					Lat = strtod(&City[x], NULL);
					for ( ; City[x] != '-'; x++)
						;
					Lon = strtod(&City[x], NULL);
//asdf2:			LatRad = Lat * deg2rad;
					LatRad = Lat * deg2rad;
					LonRad = Lon * deg2rad;
					LatLontoUTM();
asdf3:				CityUTMEasting = UTMEasting;
					CityUTMNorthing = UTMNorthing;
					if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
					{
						sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
						MessageBox(hwnd, Error, "Error 1", MB_OK);
						Lat = tempLat;
						Lon = tempLon;
						UTMZone = tempUTMZone;
						UTMNorthing = tempUTMN;
						UTMEasting = tempUTME;
						break;
					}
					if (tempUTMZone != UTMZone)
						ChangeZone(UTMZone, 0);
					BeginX = UTMEasting / MetersPerTile;
					BeginY = UTMNorthing / MetersPerTile;
					_itoa(BeginX, X, 10);
					_itoa(BeginY, Y, 10);
					Z[0] = (UTMZone / 10) + '0';
					Z[1] = (UTMZone % 10) + '0';
					if (tempUTMZone != UTMZone)
					{
						Waypoints[0] = 0;
						SendMessage(hwnd, WM_USER4, 0, 0);
					}
					veryfirstime = TRUE;
					rowOffset = BeginY - (TilesDown / 2);//bottom edge of screen
					colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of screen

					GotoEasting = UTMEasting;
					GotoNorthing = UTMNorthing;
					fromOpen = TRUE;
					SendMessage(hwnd, WM_USER, 0, 0);//was WM_USER2
					UTMEasting = GotoEasting;
					UTMNorthing = GotoNorthing;
					UTMtoLatLon();//because WM_USER6 already has cursor location lat/lon
					lButtonDotX = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
					lButtonDotY = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
					fromgoto = FALSE;//TRUE;
					fromgotocity = TRUE;//to put name on screen
					SendMessage(hwnd, WM_USER6, 0, 0);
				}
			}
			else
			{
				if (IDOK == MessageBox(hwnd, "Do you want to download 1.9 MBytes of\nPopulated Place data from jdmcox.com?", "FIRST", MB_OKCANCEL))
					hDownloadStatesThread = _beginthreadex(NULL, 0, DownloadStatesThread, hwnd, 0, &idThread10);
			}
			break;

		case ID_GOTO_USGSLANDMARK:
			showinglandmarks = FALSE;
			if (USGSBuf != NULL)
			{
				VirtualFree(USGSBuf, 0, MEM_RELEASE);
				VirtualFree(PtrBuf, 0, MEM_RELEASE);
				USGSBuf = NULL;
				showinglandmarks = TRUE;
			}
			if (GetUSGSData())
			{
				IniNumber = -1;//re-initialize it
				if (DialogBox(hInst, "FINDUSGS", hwnd, FindUSGSProc))
				{
					tempLat = Lat;
					tempLon = Lon;
					tempUTMZone = UTMZone;
					tempUTMN = UTMNorthing;
					tempUTME = UTMEasting;
					for (x = 0; SelectedUSGSLoc[x] != 0; x++)
						;
					x -= 14;
					UTMEasting = (((SelectedUSGSLoc[x] - '0') * 100000)
								+ ((SelectedUSGSLoc[x+1] - '0') * 10000)
								+ ((SelectedUSGSLoc[x+2] - '0') * 1000)
								+ ((SelectedUSGSLoc[x+3] - '0') * 100)
								+ ((SelectedUSGSLoc[x+4] - '0') * 10)
								+ (SelectedUSGSLoc[x+5] - '0'));
					UTMNorthing = (((SelectedUSGSLoc[x+7] - '0') * 1000000)
								 + ((SelectedUSGSLoc[x+8] - '0') * 100000)
								 + ((SelectedUSGSLoc[x+9] - '0') * 10000)
								 + ((SelectedUSGSLoc[x+10] - '0') * 1000)
								 + ((SelectedUSGSLoc[x+11] - '0') * 100)
								 + ((SelectedUSGSLoc[x+12] - '0') * 10)
								 + (SelectedUSGSLoc[x+13] - '0'));
					UTMtoLatLon();
					if (showinglandmarks == FALSE)
					{
						VirtualFree(USGSBuf, 0, MEM_RELEASE);
						VirtualFree(PtrBuf, 0, MEM_RELEASE);
						USGSBuf = NULL;//to not show landmarks
					}
					for (x = 0; SelectedUSGSLoc[x] != 0; x++)
						;
					SelectedUSGSLoc[x-15] = 0;//don't copy UTM Easting and Northing
					strcpy(City, SelectedUSGSLoc);
					goto asdf3;
				}
			}
			break;

		case ID_FILES_OPENMAPFILE:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			grid75 = FALSE;
			CheckMenuItem(hMenu, ID_FILE_SHOWELEVATIONSQUARES, MF_UNCHECKED);
			wastopo = FALSE;
			veryfirstime = TRUE;
			CheckMenuItem(hMenu, ID_APRS_RECEIVEINTERNETDATA, MF_UNCHECKED);
			aprs = tnc = FALSE;
			if (openatclosing)
			{
				ChangeUSAPhotoMapsIni();
				ChangeUSAPMIni();
			}
			hFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				if (fileSize = GetFileSize(hFile, NULL))
				{
					Waypoints[0] = 0;//don't use it again
					pIniBuf = (unsigned char*) malloc(fileSize+3);
					pIniBuf2 = pIniBuf;//for OpenProc
					ReadFile(hFile, pIniBuf, fileSize, &dwBytesRead, NULL);
					CloseHandle(hFile);	
					pIniBuf[fileSize] = 0;//for OpenProc
					deletestring = FALSE;

					if (notfromusa)
					{
						IniNumber = -1;
						Response = DialogBox(hInst, "OPEN", hwnd, OpenProc);
						pIniBuf = pIniBuf2;//re-initialize after OpenProc
					}
					else
					{
						notfromusa = TRUE;
						Response = TRUE;
					}

					if ((Response != EXIT) && (IniNumber != -1))
					{
						if (deletestring == FALSE)
						{
							if (newLoc)
								SaveLocs();
							if (newText)
								SaveText();
							for (x = 0; (pIniBuf[x] != '*') && (x < (int)fileSize); x++)
								;
							for (z = 0, y = 0; (y < (int)fileSize); y++)
							{
								if (pIniBuf[y-1] == '\n')//end of line
 									z++;
								if (z == IniNumber)//from OpenProc
									break;//pIniBuf[y] now points to chosen name
							}
							if (x != y)
							{//if not at current MapName
								if (x > y)
									for ( ; x > y; x--)
										pIniBuf[x] = pIniBuf[x-1];
								else				
								{
									for ( ; x < y; x++)
										pIniBuf[x] = pIniBuf[x+1];
									x--;
								}
								pIniBuf[x] = '*';//at new current map name
								x = CheckIniProc(pIniBuf, fileSize, 1);//ID_FILES_OPENMAPFILE
								if (x == (int)fileSize)
								{
									hFile2 = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
									WriteFile(hFile2, pIniBuf, fileSize, &dwBytesWritten, NULL);
									CloseHandle(hFile2);
									if (FALSE == GetXYZfromIniBuf())
									{//should never get here
										free(pIniBuf2);
										MessageBox(hwnd, Buf2, ERROR, MB_OK);
										openatclosing = FALSE;
										SendMessage(hwnd, WM_CLOSE, 0, 0);
										return 0;
									}
								}
								else
								{
									free(pIniBuf2);
									MessageBox(hwnd, Buf2, ERROR, MB_OK);
									openatclosing = FALSE;
									SendMessage(hwnd, WM_CLOSE, 0, 0);
									return 0;
								}
								if (USGSBuf != NULL)
								{
									VirtualFree(USGSBuf, 0, MEM_RELEASE);
									VirtualFree(PtrBuf, 0, MEM_RELEASE);
									USGSBuf = NULL;
									GetUSGSData();
								}
								GetTigerIndex();
								SetCursor(hWaitingCursor);
								fromOpen = TRUE;
								Waypoints[0] = 0;
								SendMessage(hwnd, WM_USER4, 0, 0);
								SetCursor(hCursor);
							}//end of if (x != y)
						}//end of if (deletestring == FALSE)

						else//if (deletestring)
						{
							deletestring = FALSE;
							for (z = 0, y = 0; (y < (int)fileSize); y++)
							{
								if (pIniBuf[y-1] == '\x0A')//end of line
 									z++;
								if (z == IniNumber)//from OpenProc
									break;//pIniBuf[y] now points to chosen name
							}
							if (pIniBuf[y] == '*')
								MessageBox(hwnd, "You can't delete the current Map Location", Oops, MB_OK);
							else if (y != fileSize)
							{
								for (x = y; (pIniBuf[x] != '\n') && (x < (int)fileSize); x++)
									;
								x++;//at beginning of next line (or end)
								if (x == fileSize)
								{//at last line
									if (pIniBuf[y] == '*')
									{
										for (x = y-2; (pIniBuf[x] != '\n') && (x < 0); x--)
											;
										if (x > 0)
										{
											x++;//to beginning of line
											for (y = x+1; (pIniBuf[y-1] != '\n') && (y < (int)fileSize); y++)
												pIniBuf[y] = pIniBuf[y-1];
										}
										else
										{//if only one line
											DeleteFile(USAPhotoMapsIni);
											free(pIniBuf);
											return 0;
										}
									}
									pIniBuf[y] = 0;
									fileSize = y;
								}
								else
								{
									if (pIniBuf[y] == '*')
										y++;
									for ( ; x < (int)fileSize; x++, y++)
										pIniBuf[y] = pIniBuf[x];
									pIniBuf[y] = 0;
									fileSize = y;
								}
								hFile2 = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
								WriteFile(hFile2, pIniBuf, fileSize, &dwBytesWritten, NULL);
								CloseHandle(hFile2);
							}
						}
					}
					free(pIniBuf2);
				}
				else
					CloseHandle(hFile);
			}
			break;

		case ID_FILES_NEWMAPFILE:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			grid75 = FALSE;
			CheckMenuItem(hMenu, ID_FILE_SHOWELEVATIONSQUARES, MF_UNCHECKED);
			wastopo = FALSE;
			veryfirstime = TRUE;
			sprintf(myLat, "%f", Lat);
			sprintf(myLon, "%f", Lon);
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			UTMNorthing = ScreenTop - (((rect.bottom / 2) * MetersPerTile) / PixelsPerTile);
			UTMEasting = ScreenLeft + (((rect.right / 2) * MetersPerTile) / PixelsPerTile);
			UTMtoLatLon();

			Response = DialogBox(hInst, "WELCOME", NULL, WelcomeProc);

			if (Response != EXIT)
			{
				if (newLoc)
					SaveLocs();
				if (newText)
					SaveText();
				for (row = 0; row < TilesDown; row++)
					for (col = 0; col < TilesAcross; col++)
						BitBlt(hdcMem, row, col, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
				fromOpen = TRUE;
				Waypoints[0] = 0;
				SendMessage(hwnd, WM_USER4, 0, 0);

//				if (autodownload)
//					SendMessage(hwnd, WM_COMMAND, ID_FILE_DOWNLOADMAPDATA_FILLSCREEN, 0);
			}
			else
			{
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
			}
			break;

		case ID_FILE_EXPORT://Copy to 'Screen01.jpg'
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			itsfull = FALSE;
			PadBytes = IJL_DIB_PAD_BYTES(rect.right, 3);
			big_buf_size = (rect.right + PadBytes) * rect.bottom * 3;
			big_jpeg_size = big_buf_size / 5;
			bmih2.biSize = sizeof(BITMAPINFOHEADER);
			bmih2.biWidth = rect.right;
			bmih2.biHeight = -(rect.bottom);// - for right-side-up picture
			bmih2.biPlanes = 1;
			bmih2.biBitCount = 24;
			bmih2.biCompression = BI_RGB;
			bmih2.biSizeImage = big_buf_size;
			bmi2.bmiHeader = bmih2;

			big_buf = VirtualAlloc(NULL, big_buf_size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			hdc = GetDC(hwnd);
			hdcMem2 = CreateCompatibleDC(hdc);//not deleted until WM_CLOSE or zooming
			hBitmap2 = CreateCompatibleBitmap(hdc, rect.right, rect.bottom);//ditto
			SelectObject(hdcMem2, hBitmap2);
			BitBlt(hdcMem2, 0, 0, rect.right, rect.bottom, hdc, 0, 0, SRCCOPY);
			GetDIBits(hdcMem2, hBitmap2, 0, rect.bottom-1, big_buf, &bmi2, DIB_RGB_COLORS);
			ReleaseDC(hwnd, hdc);
			DeleteDC (hdcMem2);
			DeleteObject (hBitmap2);

			big_jpeg_buf = VirtualAlloc(NULL, big_jpeg_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
			ijlInit(&jcprops);//use Intel's ijl15.dll to convert JPEG files
			jcprops.JPGWidth = rect.right;
			jcprops.JPGHeight = rect.bottom;
			jcprops.JPGBytes = (unsigned char*)big_jpeg_buf;//output
			jcprops.JPGSizeBytes = big_jpeg_size;//estimate
			jcprops.JPGFile = NULL;
			jcprops.JPGChannels = 3;
			jcprops.JPGColor = IJL_YCBCR;
			jcprops.JPGSubsampling = IJL_411;//4:1:1 subsampling
			jcprops.jquality = 75;//90;//"high" image quality
			jcprops.DIBWidth = rect.right;
			jcprops.DIBHeight = rect.bottom;
			jcprops.DIBPadBytes = PadBytes;
			jcprops.DIBBytes = (unsigned char*)big_buf;//input
			ijlWrite(&jcprops, IJL_JBUFF_WRITEWHOLEIMAGE);
			fileSize = jcprops.JPGSizeBytes;//re-computed by ijl15.dll
			ijlFree(&jcprops);

			hFile = FindFirstFile("Screen??.jpg", &fd);
			if (hFile != INVALID_HANDLE_VALUE)
			{//found it
				ScreenFile[6] = '0';
				ScreenFile[7] = '1';
				while (TRUE)
				{
					FindClose(hFile);
					hFile = FindFirstFile(ScreenFile, &fd);
					if (hFile == INVALID_HANDLE_VALUE)
						break;
					ScreenFile[7]++;
					if (ScreenFile[7] > '9')
					{
						if (ScreenFile[6] != '9')
						{
							ScreenFile[7] = '0';
							ScreenFile[6]++;
						}
						else
						{
							itsfull = TRUE;
							FindClose(hFile);
							MessageBox(hwnd, "Move your 99 ScreenXX.jpg files\nto another folder\nso you can start over.", "", MB_OK);
							break;
						}
					}
				}
			}

			if (itsfull == FALSE)
			{
				hFile = CreateFile(ScreenFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, big_jpeg_buf, fileSize, &dwBytesWritten, NULL);
				CloseHandle(hFile);
			}
			VirtualFree(big_jpeg_buf, 0, MEM_RELEASE);
			VirtualFree(big_buf, 0, MEM_RELEASE);
			break;

		case ID_FILE_BOUNDARYFORBIGJPEG:
			if (!bigjpeg)
			{
				if (IDOK == MessageBox(hwnd, BigJpegInfo, "Create a BIG jpeg file", MB_OKCANCEL))
					bigjpeg = TRUE;
			}
			break;

		case ID_FILE_TERRAFETCHER_REGION:
			if (!terrafetcher)
			{
				if (IDOK == MessageBox(hwnd, TerraFetcherInfo, "Get a Region for TerraFetcher", MB_OKCANCEL))
					terrafetcher = TRUE;
			}
			break;

		case ID_FILE_TERRAFETCHER_PATH:
			if (IDOK == MessageBox(hwnd, "TerraFetcherPath.txt", "Copy a Route to", MB_OKCANCEL))
			{
getroute2:		if (GetOpenFileName(&ofn3))
				{
					if (INVALID_HANDLE_VALUE != (hFile = CreateFile(FullRoutes, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL)))
					{
						if (fileSize = GetFileSize(hFile, NULL))
						{
							char asdf[10];
							char *Buffer, *Buffer2;

							Buffer = (char*)malloc(fileSize);
							Buffer2 = (char*)malloc(fileSize+50);
							ReadFile(hFile, Buffer, fileSize, &dwBytesRead, NULL);
							CloseHandle(hFile);
							if ((Buffer[0] < '0') || (Buffer[0] > '9') || (Buffer[2] != ',') || (Buffer[17] != '\r'))
							{
								MessageBox(hwnd, "That's not a route file.\nTry again.", NULL, MB_OK);
								goto getroute2;
							}
							x = y = 0;
							Buffer2[y++] = ';';
							for ( ; Routes[x] != 0; x++, y++)
								Buffer2[y] = Routes[x];
							Buffer2[y++] = '\r';
							Buffer2[y++] = '\n';
							for (x = 0; x < 5; x++, y++)
								Buffer2[y] = Path1[x];
							for (x = 0, z = 0; x < fileSize; x++)
							{
								if (Buffer[x] == '\n')
									z++;
							}
							_itoa(z, asdf, 10);
							for (x = 0; asdf[x] != 0; x++, y++)
								Buffer2[y] = asdf[x];
							for (x = 0; x < 25; x++, y++)
								Buffer2[y] = Path2[x];
							for (v = 0, x = 0; v < z; v++)
							{
								Buffer2[y++] = Buffer[x++];
								Buffer2[y++] = Buffer[x++];
								Buffer2[y++] = ' ';
								x += 9;//to Northing
								for (w = 0; w < 6; w++, x++, y++)
									Buffer2[y] = Buffer[x];
								Buffer2[y++] = ' ';
								x -= 14;//back to Easting
								for (w = 0; w < 7; w++, x++, y++)
									Buffer2[y] = Buffer[x];
								Buffer2[y++] = '\r';
								Buffer2[y++] = '\n';
								x += 9;//to next line
							}
							hFile2 = CreateFile(TerraFetcherPath, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
							WriteFile(hFile2, Buffer2, y, &dwBytesWritten, NULL);
							CloseHandle(hFile2);
							free(Buffer2);
							free(Buffer);
							MessageBox(hwnd, "has been written...", "TerraFetcherPath.txt", MB_OK);
						}
						else
							CloseHandle(hFile);
					}
				}
			}
			break;

		case ID_FILE_SHOWELEVATIONSQUARES:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_FILE_SHOWELEVATIONSQUARES, MF_BYCOMMAND))
			{
				if (grid75 == FALSE)
				{
					CheckMenuItem(hMenu, ID_FILE_SHOWELEVATIONSQUARES, MF_CHECKED);
					grid75 = TRUE;
					InvalidateRect(hwnd, &rect, FALSE);
//						PrevMetersPerTile = MetersPerTile;
//						PrevPixelsPerTile = PixelsPerTile;
//						MetersPerTile = 1600;
//						UncheckZoom();
//						Zoom = 8;
//						PixelsPerTile = 25;
//						ShowZoom();
//						DoZoom();
//						hwndElevation = CreateWindow("EDIT", "Get Elevation Data",
//							WS_CHILD | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | ES_MULTILINE,
//							0, 0, 300, 240,
//							hwnd, (HMENU)168, hInst, NULL);
//						pElevProc = (WNDPROC)SetWindowLong(hwndElevation, GWL_WNDPROC, (LONG)ElevationProc);//sub-class for WM_DESTROYWINDOW
//						SendMessage(hwndElevation, EM_SETREADONLY, 1, 0);
//						SetWindowText(hwndElevation, ElevInfo);
//						getelev = TRUE;//for WM_LBUTTONDOWN
					if (autoLoc == FALSE)
					{
						pElevationHelp = NULL;
						hFile = CreateFile(ElevationHelp, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
						if (hFile != INVALID_HANDLE_VALUE)
						{
							if (HelpSize = GetFileSize(hFile, NULL))
							{
								pElevationHelp = (char *) malloc(HelpSize+1);
								if (pElevationHelp == NULL)
									MessageBox(hwnd, "OHOH", "", MB_OK);
								pElevationHelp[HelpSize] = 0;
								ReadFile(hFile, pElevationHelp, HelpSize, &dwBytesRead, NULL);

								hMenu2 = CreateMenu();//to override parent menu bar
								hwndElevationHelp = CreateWindow(Instruct, ElevationHelp,
									WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
									0, TitleAndMenu, (cxScreen/2 + 320)-(cxScreen/2-320), 580,
									NULL, hMenu2, hInst, NULL);
								SetWindowText(hwndInstr, pElevationHelp);
								SetFocus(hwndInstr);
							}
							CloseHandle (hFile);
						}
						else
							MessageBox(hwnd, ElevationHelp, "Couldn't find", MB_OK);
					}
				}
			}
			else
			{
				CheckMenuItem(hMenu, ID_FILE_SHOWELEVATIONSQUARES, MF_UNCHECKED);
				grid75 = FALSE;
				InvalidateRect(hwnd, &rect, FALSE);
			}
			break;

		case ID_FILE_CONVERTELEVATIONDATA:
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			/////////////////////////////
//			ExitCode = ConvertSDTSData();
			ExitCode = ConvertBILData();
			/////////////////////////////
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
			if (ExitCode == 0)
			{
				GetDems();
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			}
			break;

		case ID_FILE_DOWNLOADMAPDATA_TIGERSTREETS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (downloadingstreets)
				break;
			if (froms)
				froms = FALSE;
			else
			{//put lat/lon in center of screen
				froms = FALSE;
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
				UTMNorthing = ScreenBottom + ((TilesDown*MetersPerTile) / 2);
				UTMEasting = ScreenLeft + ((TilesAcross*MetersPerTile) / 2);
				UTMtoLatLon();
				LatLontoUTM();
				if (UTMZone != tempUTMZone)
				{//if it went into another UTM zone
					Lat = tempLat;
					Lon = tempLon;
					UTMZone = tempUTMZone;
					UTMNorthing = tempUTMN;
					UTMEasting = tempUTME;
				}
			}
			//////////////////////
			GetCountyFromLatLon();
			//////////////////////
			hFile = CreateFile(TigerCounties, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				if (CountySize = GetFileSize(hFile, NULL))
				{
					pCounties = (char*)malloc(CountySize);
					ReadFile(hFile, pCounties, CountySize, &dwBytesRead, NULL);
					CloseHandle(hFile);
					hFile = NULL;
					County = -1;//flag
					if (DialogBox(hInst, "TIGER", hwnd, GetTigerProc))
					{
						if (County != -1)
						{
							for (x = 0, y = 0; x < CountySize; x++)
							{
								if (pCounties[x] == 0)
								{
									if (y != County)
										y++;
									else
									{//"http://www2.census.gov/geo/tiger/tiger2006se/VA/TGRxxxxx.ZIP";
										for (y = 21, z = x-11; z < x-5; y++, z++)
											Downloaded[y] = pCounties[z];
										GetTigerZip[51] = pCounties[x-5];
										TigerZip[3] = pCounties[x-5];
										OldTigerZip[15] = pCounties[x-5];
										GetTigerZip[52] = pCounties[x-4];
										TigerZip[4] = pCounties[x-4];
										OldTigerZip[16] = pCounties[x-4];
										GetTigerZip[53] = pCounties[x-3];
										TigerZip[5] = pCounties[x-3];
										OldTigerZip[17] = pCounties[x-3];
										GetTigerZip[54] = pCounties[x-2];
										TigerZip[6] = pCounties[x-2];
										OldTigerZip[18] = pCounties[x-2];
										GetTigerZip[55] = pCounties[x-1];
										TigerZip[7] = pCounties[x-1];
										OldTigerZip[19] = pCounties[x-1];
										for ( ; (pCounties[x] != '\n') && (x != 0); x--)
											;
										if (x != 0)
											x++;//to beginning of line
										GetTigerZip[45] = pCounties[x];//state
										GetTigerZip[46] = pCounties[x+1];
										break;
									}
								}
							}
							downloaded = FALSE;
							notcancelled = TRUE;

//							if (INVALID_HANDLE_VALUE != FindFirstFile(OldTigerZip, &fd))
							hFile2 = CreateFile(OldTigerZip, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
							if (hFile2 != INVALID_HANDLE_VALUE)
							{
								ReadFile(hFile2, Error, 2, &dwBytesRead, NULL);
								CloseHandle(hFile2);
								if ((Error[0] != 'P') && (Error[1] != 'K'))
									DeleteFile(OldTigerZip);
								else
								{
									x = MessageBox(hwnd, "You already have the .zip file for that County.\nContinue?\n(press No to just re-convert the data)", TigerZip, MB_YESNOCANCEL);
									if (IDNO == x)
									{
										CopyFile(OldTigerZip, TigerZip, TRUE);
										hThread = _beginthreadex(NULL, 0, TigerThread, NULL, 0, &idThread);
										Sleep(500);
										free(pCounties);
										pCounties = NULL;
										break;
									}
									else if (IDCANCEL == x)
									{
										free(pCounties);
										pCounties = NULL;
										break;
									}
								}
							}
							hwndTiger = CreateWindow(Tiger, TigerZip,
								WS_CHILD | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
								(cxScreen/2)-(16*cxChar), (cyScreen/2)-((8*cyChar)/2), 30*cxChar, 9*cyChar,
								hwnd, (HMENU)176, hInst, NULL);
							GetClientRect(hwndTiger, &tigerRect);
							InvalidateRect(hwnd, &rect, FALSE);
							ResetEvent(hTigerEvent);
							ResetEvent(hTigerReturn);
							hThread = _beginthreadex(NULL, 0, TigerCommThread, NULL, 0, &idThread);
							Sleep(500);
						}
					}//end of if (DialogBox(
					if (pCounties != NULL)
					{
						free(pCounties);
						pCounties = NULL;
					}
				}
				if (hFile != NULL)
					CloseHandle(hFile);
			}
			else
				MessageBox(hwnd, "Couldn't find TigerCounties.txt\nDownload the full version\nof USAPhotoMaps to get it.", ERROR, MB_OK);
			break;

		case ID_FILES_PRINT:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			GetClientRect(hwnd, &rect);
			hdc = GetDC(hwnd);
			BitBlt(hdcMem, 0, 0, rect.right, rect.bottom, hdc, 0, 0, SRCCOPY);
			ReleaseDC(hwnd, hdc);
//			MessageBox(hwnd, PrintInfo, "Printing Note", MB_OK);

			EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 5, NULL, 0, &dwSizeNeeded, &dwNumItems);//get printer name for OpenPrinter
			lpInfo = (LPPRINTER_INFO_5)malloc(dwSizeNeeded);
			EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 5, (LPBYTE)lpInfo, dwSizeNeeded, &dwSizeNeeded, &dwNumItems);
			PrinterName[0] = 0;
			if (GetDefaultPrinter(PrinterName, &PrinterNameLen))
			{//show possible default printer first
				if (PrinterName[0] != 0)
				{
					if (IDYES == MessageBox(hwnd, PrinterName, "Use this printer?", MB_YESNO))
						goto skip;	
				}
			}
			for ( dwItem = 0; dwItem < dwNumItems; dwItem++ )
			{
				if (strcmp(lpInfo[dwItem].pPrinterName, PrinterName))
				{
					if (IDYES == MessageBox(hwnd, lpInfo[dwItem].pPrinterName, "Use this printer?", MB_YESNO))
					{
						strcpy(PrinterName, lpInfo[dwItem].pPrinterName);
						break;	
					}
				}
			}
skip:		free(lpInfo);
			if (dwItem == dwNumItems)
				break;//nothing chosen;
			OpenPrinter(PrinterName, &hPrinter, NULL);//get hPrinter for DocumentProperties
			dwNeeded = DocumentProperties(hwnd, hPrinter, PrinterName, NULL, NULL, 0);//get DEVMODE size
			pDevMode = (LPDEVMODE)malloc(dwNeeded);
			DocumentProperties(hwnd, hPrinter, PrinterName, pDevMode, NULL, DM_OUT_BUFFER);//get DEVMODE info
			pDevMode->dmOrientation = DMORIENT_LANDSCAPE;
			DocumentProperties(hwnd, hPrinter, PrinterName, pDevMode, pDevMode, DM_IN_BUFFER|DM_OUT_BUFFER);//integrate landscape selection
			ClosePrinter(hPrinter);

//			pd.lStructSize = sizeof(PRINTDLG);
//			pd.hwndOwner   = hwnd;
//			pd.hDevMode    = NULL;
//			pd.hDevNames   = NULL;
//			pd.Flags       = PD_NOPAGENUMS|PD_NOSELECTION|PD_HIDEPRINTTOFILE|PD_RETURNDC;
//			pd.nCopies     = 1;
//			pd.nFromPage   = 0;
//			pd.nToPage     = 0;
//			if (PrintDlg(&pd))
			{
				HDC hDC = CreateDC("WINSPOOL", PrinterName, NULL, pDevMode);

				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				hdcPrn = CreateCompatibleDC(hDC);
				hPrnBitmap = CreateCompatibleBitmap(hDC, rect.right, rect.bottom);
				hObject = SelectObject(hdcPrn, hPrnBitmap);
				BitBlt(hdcPrn, 0, 0, rect.right, rect.bottom, hdcMem, 0, 0, SRCCOPY);
				w = GetDeviceCaps(hDC, PHYSICALWIDTH);//PHYSICALWIDTH = dpi * 11.0 in Landscape Mode
				z = GetDeviceCaps(hDC, PHYSICALHEIGHT);//PHYSICALHEIGHT = dpi * 8.5 in Landscape Mode
//				if (w > z)
				{//10500 = 10.5" * 1000 & 85 = 8.5 * 10 & 110 = 11.0 * 10 & "/25)*25" rounds down to nearest 25
					x = (((((z * 10500)/85) / rect.right) / 25) * 25);
					y = (((((w * 10500)/110) / rect.right) / 25) * 25);
					if (StartDoc(hDC, &di) > 0)
					{
						if (StartPage(hDC) > 0)
						{//the /100 is there because of the previous w/(8.5*10) and the 10.5*1000
							SetStretchBltMode(hDC, HALFTONE);
							StretchBlt(hDC, 0, 0, (rect.right * x)/100, (rect.bottom * y)/100, hdcPrn, 0, 0, rect.right, rect.bottom, SRCCOPY);
							if (EndPage(hDC) > 0)
								EndDoc(hDC);
						}
					}
				}
//				else
//					MessageBox(hwnd, "You forgot to select Landscape Mode", NULL, MB_OK);
				SelectObject(hdcPrn, hObject);
				DeleteDC(hdcPrn);
				DeleteDC(hDC);
				DeleteObject(hPrnBitmap);

				free(pDevMode);
			}
			break;

		case ID_VIEW_OPTIONS_COLORS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			DialogBox(hInst, "COLORS", hwnd, ColorsProc);
			break;

		case ID_VIEW_OPTIONS_WAYPOINTPOSITIONDOTS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (DialogBox(hInst, "WAYPOINTDOTS", hwnd, DotProc))
				InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_OPTIONS_ROUTETRACKLINEWIDTH:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			DialogBox(hInst, "LINEWIDTH", hwnd, LineWidthProc);
			break;

		case ID_VIEW_OPTIONS_EVERYTHINGELSE:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			DialogBox(hInst, "PREFERENCES", hwnd, PreferencesProc);
			break;

		case ID_FILE_RUNSTREETSTRIPS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (FALSE == CreateProcess(Streets, NULL, NULL, NULL, FALSE, 0, NULL, Streets2, &si, &pi))
			{
				if (FALSE == CreateProcess(Streets3, NULL, NULL, NULL, FALSE, 0, NULL, Streets4, &si, &pi))
					MessageBox(hwnd, "Unable to run C:\\Program Files\\Microsoft Streets and Trips\\Streets.exe", NULL, MB_OK);
			}
			break;

		case ID_FILE_IMPORT_IMPORTSTPUSHPINS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (FALSE != GetOpenFileName(&ofn4))
			{
				#define MAXPUSHPINS 500
				#define CENTERDIST 0.087890630//I got this by trial-and-error
				#define SAVANNAH 78.002930//a 0 error longitude
				int ppnum, numofpushpins, pushpins[MAXPUSHPINS], begin;
				BYTE meridian;
//				BYTE buf[1024];
				BYTE *buf;
				char name[MAXPUSHPINS][51];
				char comment[MAXPUSHPINS][51];
				unsigned char namestrlen[MAXPUSHPINS], commentstrlen[MAXPUSHPINS];
				double radians, lat[MAXPUSHPINS], lon[MAXPUSHPINS];
				double psplon, disttopsplon, closerightcenter, closeleftcenter, integerpart;
				BOOL firstime = TRUE;

				hFile3 = CreateFile(PushPins, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile3 != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile3, NULL))
					{//if it's not a new file
						buf = (BYTE*)malloc(fileSize);
						ReadFile(hFile3, buf, fileSize, &dwBytesRead, NULL);
						CloseHandle(hFile3);
						numofpushpins = *(int*) &buf[12];
						if (numofpushpins > MAXPUSHPINS)
							numofpushpins = MAXPUSHPINS;
						x = 32;//first pushpin offset
						for (ppnum = 0; ppnum < numofpushpins; ppnum++)
						{
							pushpins[ppnum] = *(int*) &buf[x];
							x += 4;
							meridian = buf[x];
							x++;
							radians = *(double*) &buf[x];
							lat[ppnum] = (radians * 180.0) / PI;
							x += 8;
							radians = *(double*) &buf[x];
							lon[ppnum] = (radians * 180.0) / PI;
							if (meridian == 3)//west of 90th meridian
								lon[ppnum] = ((radians * 180.0) / PI) - 180.0;
							else if (meridian == 2)//east of 90th meridian
							{//correct for Microsoft's built-in error
								psplon = ((radians * 180.0) / PI);
								if (psplon > SAVANNAH)
								{//if west of it
									disttopsplon = psplon - SAVANNAH;
									modf((disttopsplon / CENTERDIST), &integerpart);
									closerightcenter = SAVANNAH + (integerpart * CENTERDIST);
									closeleftcenter = closerightcenter + CENTERDIST;
								}
								else
								{//if east of it
									disttopsplon = SAVANNAH - psplon;
									modf((disttopsplon / CENTERDIST), &integerpart);
									closeleftcenter = SAVANNAH - (integerpart * CENTERDIST);
									closerightcenter = closeleftcenter - CENTERDIST;
								}
								if ((psplon - closerightcenter) < (closeleftcenter - psplon))
									lon[ppnum] = -(closerightcenter - (psplon - closerightcenter));
								else
									lon[ppnum] = -(closeleftcenter + (closeleftcenter - psplon));
							}
							else
							{
								free(buf);
								MessageBox(hwnd, "USAPhotoMaps doesn't work\non that side of the world.", ERROR, MB_OK);
								return 0;
							}
							x += 16;
							namestrlen[ppnum] = buf[x++];
							begin = x;
							for (y = 0; (y < 50) && (y < (int)namestrlen[ppnum]); x += 2, y++)
							{
								name[ppnum][y] = buf[x];
							}
							name[ppnum][y] = 0;
							x = begin + (namestrlen[ppnum] * 2);
							if (buf[x] == 0)
								x++;
							commentstrlen[ppnum] = buf[x++];
							begin = x;
							for (y = 0; (y < 50) && (y < (int)commentstrlen[ppnum]); x += 2, y++)
							{
								comment[ppnum][y] = buf[x];
							}
							comment[ppnum][y] = 0;
							x = begin + (commentstrlen[ppnum] * 2);
							if ((buf[x] == 0) && (buf[x+4] == 0))
								x++;
						}//end of for (ppnum = 0;
						free(buf);

						tempLat = Lat;
						tempLon = Lon;
						tempUTMZone = UTMZone;
						tempUTMN = UTMNorthing;
						tempUTME = UTMEasting;
						
						for (x = 0; x < TOTAL_LOCS; x++)
							if (NewLoc[x].EUTM == 0)
								break;
						EmptyLoc = x;
						InsertLoc = x;
						for (ppnum = 0; ppnum < numofpushpins; ppnum++)
						{
							Lat = lat[ppnum];
							Lon = lon[ppnum];
							LatRad = Lat * deg2rad;
							LonRad = Lon * deg2rad;
							LatLontoUTM();
							if (UTMZone == tempUTMZone)
							{
								if ((commentstrlen[ppnum] == 0) && (namestrlen[ppnum] == 0))
									continue;
								if (commentstrlen[ppnum] != 0)
								{
									strcpy(Location, comment[ppnum]);
									if ((sortbyname == FALSE) || (namestrlen[ppnum] == 0))
									{
										for (x = 0; x < EmptyLoc; x++)
										{
											if (NewLoc[x].Location != 0)
											{
												if (_stricmp(NewLoc[x].Location, Location) > 0)
												{
													InsertLoc = x;
													EmptyLoc++;
													for (x = EmptyLoc; x > InsertLoc; x--)
														NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
													break;
												}
											}
										}
									}
								}
								else
									Location[0] = 0;
								if (namestrlen[ppnum] != 0)
								{
									strcpy(Ident, name[ppnum]);
									if ((sortbyname) || (commentstrlen[ppnum] == 0))
									{
										for (x = 0; x < EmptyLoc; x++)
										{
											if (NewLoc[x].Ident != 0)
											{
												if (_stricmp(NewLoc[x].Ident, Ident) > 0)
												{
													InsertLoc = x;
													EmptyLoc++;
													for (x = EmptyLoc; x > InsertLoc; x--)
														NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
													break;
												}
											}
										}
									}
								}
								else
									Ident[0] = 0;
								if (x == EmptyLoc)
								{
									InsertLoc = x;
									EmptyLoc++;
								}
								NewLoc[InsertLoc].EUTM = UTMEasting;
								NewLoc[InsertLoc].NUTM = UTMNorthing;
								NewLoc[InsertLoc].UTMZone = UTMZone;
///--->
								FillWaypointArray(InsertLoc);//Lat & Lon are already known
///--->
								InsertLoc++;
//								sprintf(Error, "%s\n(GPS) Name: %s\nhas been added to the current waypoint file.", Location, Ident);
//								MessageBox(hwnd, Error, "New Waypoint", MB_OK);
							}
							else
							{
								if (firstime)
								{
									firstime = FALSE;
									sprintf(Error, "Before you can make a waypoint of this PushPin,\nyou'll need to select View -Go To Lat/Lon\nand enter: %f and %f\n\nor select File -Map Location,\nand open a map in UTM zone %i", Lat, Lon, UTMZone);
									MessageBox(hwnd, Error, "", MB_OK);
								}
							}
						}//end of for (ppnum = 0;
						Lat = tempLat;
						Lon = tempLon;
						UTMZone = tempUTMZone;
						UTMNorthing = tempUTMN;
						UTMEasting = tempUTME;
						InvalidateRect(hwnd, &rect, FALSE);
						if (firstime)
							MessageBox(hwnd, "Done", "", MB_OK);
					}
				}
			}
			break;

		case ID_FILE_IMPORT_IMPORTFORERUNNERLOGBOOK:
			ofn2.lpstrFilter = "xml\0""*.xml\0""hst\0""*.hst\0""tcx\0""*.tcx\0""gpx\0""*.gpx\0\0";
			if (FALSE != GetOpenFileName(&ofn2))
			{
				HANDLE hFile = CreateFile(WaypointsFullPath, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile, NULL))
					{
						int TotalTracks = 0;
						char Hour, Minute, Second;
						char *pBuf;
						float Altitude;
						BOOL gotrackpoint, nolat, nolon, noalt, notime;
						HANDLE hXFile;

						pBuf = (char*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
						ReadFile(hFile, pBuf, fileSize, &dwBytesRead, NULL);

						ofn.lpstrInitialDir = CurrentTrackDir;
						if (FALSE != GetSaveFileName(&ofn))
						{
							InvalidateRect(hwnd, &rect, FALSE);
							UpdateWindow(hwnd);
							tempLat = Lat;
							tempLon = Lon;
							tempUTMZone = UTMZone;
							tempUTMN = UTMNorthing;
							tempUTME = UTMEasting;
							tnum = 0;
							SetCursor(hWaitingCursor);

							for (x = 0; x < 9; x++)
								PreCounting[x] = Down[x];
							for (x = 0; x < 4; x++)
								Counting[x] = '0';
							for (x = 5; x < 12; x++)
								Counting[x] = ' ';
							for (x = 0; x < 9; x++)
								PostCounting[x] = Track[x];
							hwndCounter = CreateWindow(Counter, NULL,
									WS_CHILD | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
									(cxScreen/2)-75, (cyScreen/2)-((8*cyChar)/2), 150, 8*cyChar,
									hwnd, (HMENU)159, hInst, NULL);
							GetClientRect(hwndCounter, &counterRect);
							if (trak != NULL)
							{
								free(trak);
								trak = NULL;
							}
							numofTracks = 14400;
							trak = (struct TRAC*) calloc(1, (numofTracks+100) * sizeof(struct TRAC));
/*
          <Trackpoint>
            <Time>2005-07-17T16:34:37Z</Time>
            <Position>
              <LatitudeDegrees>39.205441</LatitudeDegrees>
              <LongitudeDegrees>-120.204699</LongitudeDegrees>
              <AltitudeMeters>1870.863037</AltitudeMeters>
            </Position>
          </Trackpoint>
*/
							for (x = 0; x < (int)fileSize; x++)
							{
								if ((pBuf[x] == '<')
								 && (pBuf[x+1] == 'T')
								 && (pBuf[x+2] == 'r')
								 && (pBuf[x+3] == 'a')
								 && (pBuf[x+4] == 'c')
								 && (pBuf[x+5] == 'k')
								 && (pBuf[x+6] == 'p')
								 && (pBuf[x+11] == '>'))
								{//<Trackpoint>
									gotrackpoint = TRUE;
									notime = TRUE;
									nolat = nolon = noalt = TRUE;
									x += 12;
								}
								else if ((notime)
									 && (pBuf[x] == '<')
									 && (pBuf[x+1] == 'T')
									 && (pBuf[x+2] == 'i')
									 && (pBuf[x+3] == 'm')
									 && (pBuf[x+4] == 'e')
									 && (pBuf[x+5] == '>'))
								{//<Time>
									notime = FALSE;
									x += 8;
									Year = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
									x += 3;
									Month = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
									x += 3;
									Day = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
									x += 3;
									Hour = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
									x += 3;
									Minute = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
									x += 3;
									Second = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
									x += 3;
									trak[tnum].time = (UTMZone << 26) | (Month << 22) | (Day << 17) | (Hour << 12) | (Minute << 6) | Second;
									trak[tnum].year = Year;
								}
								else if ((pBuf[x] == '<')
									 && (pBuf[x+1] == 'P')
									 && (pBuf[x+2] == 'o')
									 && (pBuf[x+3] == 's')
									 && (pBuf[x+9] == '>'))
								{//<Position>
									x += 10;
									for ( ; (x < (int)fileSize) && (nolat); x++)
									{
										if ((pBuf[x] == '<')
										 && (pBuf[x+1] == 'L')
										 && (pBuf[x+2] == 'a')
										 && (pBuf[x+3] == 't'))
										{
											for (x += 4; pBuf[x] != '>'; x++)
												;
											x++;
											Lat = atof(&pBuf[x]);
											nolat = FALSE;
											for ( ; (pBuf[x] < (int)fileSize) && (nolon); x++)
											{
												if ((pBuf[x] == '<')
												 && (pBuf[x+1] == 'L')
												 && (pBuf[x+2] == 'o')
												 && (pBuf[x+3] == 'n'))
												{
													for (x += 4; pBuf[x] != '>'; x++)
														;
													x++;
													Lon = atof(&pBuf[x]);
													nolon = FALSE;
													for ( ; (x < (int)fileSize) && (noalt); x++)//was pBuf[x] < (int)fileSize
													{
														if ((pBuf[x] == '<')
														 && (pBuf[x+1] == 'A')
														 && (pBuf[x+2] == 'l')
														 && (pBuf[x+3] == 't'))
														{
															for (x += 4; pBuf[x] != '>'; x++)
																;
															x++;
															Altitude = (float)atof(&pBuf[x]);
															noalt = FALSE;

															LatRad = Lat*deg2rad;
															LonRad = Lon*deg2rad;
															LatLontoUTM();
															if (gotrackpoint)
															{
																gotrackpoint = FALSE;
															}
															else
																trak[tnum].newtrk = 0;
															trak[tnum].NUTM = UTMNorthing;
															trak[tnum].EUTM = UTMEasting;
														}
													}
												}
											}
										}
									}
								}//end of Position
								else if ((pBuf[x] == '<')
								 && (pBuf[x+1] == '/')
								 && (pBuf[x+2] == 'T')
								 && (pBuf[x+3] == 'r')
								 && (pBuf[x+4] == 'a')
								 && (pBuf[x+5] == 'c')
								 && (pBuf[x+6] == 'k')
								 && (pBuf[x+7] == 'p')
								 && (pBuf[x+12] == '>'))
								{
									trak[tnum].alt = Altitude;
									tnum++;
									remainder = tnum % 10000;
									if (tnum < 10000)
										IncCount();
									if (tnum == numofTracks)
									{
										tnum = 0;
										TotalTracks = numofTracks;
									}
								}
								else if ((pBuf[x] == '<')
									 && (pBuf[x+1] == 'R')
									 && (pBuf[x+2] == 'u')
									 && (pBuf[x+3] == 'n')
									 && (pBuf[x+4] == '>'))
								{//<Run>
									trak[tnum].newtrk = 1;
								}
							}//end of for (x = 0; x < (int)fileSize; x++)
							SendMessage(hwndCounter, WM_CLOSE, 0, 0);
							SetCursor(hCursor);
						}//end of if (FALSE != GetSaveFileName(&ofn))
						ofn.lpstrInitialDir = CurrentDir;
						VirtualFree(pBuf, 0, MEM_RELEASE);
						hXFile = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
						fileSize = sizeof(trak[0]);
						trak[tnum].time = 0;
						WriteFile(hXFile, TrackHead, strlen(TrackHead), &dwBytesWritten, NULL);
						if (TotalTracks == 0)
							TotalTracks = tnum;
						for (y = 0; y < TotalTracks; y++)
							WriteTracks(hXFile, y);
						CloseHandle(hXFile);
						fromTracks = TRUE;
						Lat = tempLat;
						Lon = tempLon;
						UTMZone = tempUTMZone;
						UTMNorthing = tempUTMN;
						UTMEasting = tempUTME;
MessageBox(hwnd, "...has been created as track data.\n\nSelect GPS -Tracks -Display to display it.", "Forerunner Logbook data", MB_OK);
						SendMessage(hwnd, WM_USER, 0, 0);
					}
					CloseHandle(hFile);
				}
			}
			break;
/*
<trk>
<name>xyz</name>
<trkseg>
<trkpt lat="42.323" lon="-71.20453">
<time>2002-02-10T21:01:29.250Z</time>
<ele>1206.2</ele>
</trkpt>
</trkseg>
</trk>
*/
		case ID_FILE_IMPORT_IMPORTGPXTRACKS:
			ofn2.lpstrFilter = "*.gpx\0""*.gpx\0\0";
			if (FALSE != GetOpenFileName(&ofn2))
			{
				HANDLE hFile = CreateFile(WaypointsFullPath, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile, NULL))
					{
						DWORD mysteriousbug;

						int TrackNameSize;
						char TrackName[MAX_PATH];
						char BigArray[1024];
						char Hour, Minute, Second;
						char *pBuf;
						float ele;
						BOOL gottrk, trackbeg, trkptrend = TRUE;
						HANDLE hXFile;

						pBuf = (char*)malloc(fileSize);
						ReadFile(hFile, pBuf, fileSize, &dwBytesRead, NULL);

						tempLat = Lat;
						tempLon = Lon;
						tempUTMZone = UTMZone;
						tempUTMN = UTMNorthing;
						tempUTME = UTMEasting;
						tnum = 0;
						gottrk = gotrackname = trackbeg = FALSE;

						if (trak != NULL)
						{
							free(trak);
							trak = NULL;
						}
						numofTracks = 14400;
						trak = (struct TRAC*) calloc(1, (numofTracks+100) * sizeof(struct TRAC));

						for (x = 0; x < (int)fileSize; x++)
						{//BIG LOOP
							if ((pBuf[x] == '<')
							 && (pBuf[x+1] == 't')
							 && (pBuf[x+2] == 'r')
							 && (pBuf[x+3] == 'k')
							 && (pBuf[x+4] == '>'))
							{
								x += 4;
								gottrk = TRUE;
							}
							else if ((pBuf[x] == '<')
							 && (pBuf[x+1] == '/')
							 && (pBuf[x+2] == 't')
							 && (pBuf[x+3] == 'r')
							 && (pBuf[x+4] == 'k')
							 && (pBuf[x+5] == '>'))
							{
								x += 5;
								mysteriousbug = x;
								gottrk = FALSE;
								ofn.lpstrInitialDir = CurrentTrackDir;
								SetCurrentDirectory(CurrentTrackDir);
								if (gotrackname)
								{
									gotrackname = FALSE;
									hXFile = CreateFile(TrackName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_NEW, 0, NULL);
									if (INVALID_HANDLE_VALUE != hXFile)
									{//if file doesn't exist (CREATE_NEW gives this result)
										WriteFile(hXFile, TrackHead, strlen(TrackHead), &dwBytesWritten, NULL);
										for (y = 0; y < tnum; y++)
											WriteTracks(hXFile, y);
										CloseHandle(hXFile);
										MessageBox(hwnd, TrackName, "Track file written:", MB_OK);
									}
									else
									{//if file already exists
										if (TrackNameSize < 86)//just in case
										{
											sprintf(BigArray, "%s already exists.\nGive it a new name in the following\nFile Dialog Box (or select that name\nagain to overwrite it).", TrackName);
											MessageBox(hwnd, BigArray, "Info", MB_OK);
										}
										if (GetSaveFileName(&ofn))
										{
											hXFile = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
											WriteFile(hXFile, TrackHead, strlen(TrackHead), &dwBytesWritten, NULL);
											for (y = 0; y < tnum; y++)
												WriteTracks(hXFile, y);
											CloseHandle(hXFile);
											MessageBox(hwnd, Tracks, "Track file written:", MB_OK);
										}
									}
								}
								else
								{//no filename in gpx file
									if (GetSaveFileName(&ofn))
									{
										hXFile = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
										WriteFile(hXFile, TrackHead, strlen(TrackHead), &dwBytesWritten, NULL);
										for (y = 0; y < tnum; y++)
											WriteTracks(hXFile, y);
										CloseHandle(hXFile);
										MessageBox(hwnd, Tracks, "Track file written:", MB_OK);
									}
								}
								tnum = 0;
								SetCurrentDirectory(CurrentDir);
								ofn.lpstrInitialDir = CurrentDir;
								x = mysteriousbug;
							}

							else if ((gottrk)
							 && (pBuf[x] == '<')
							 && (pBuf[x+1] == 'n')
							 && (pBuf[x+2] == 'a')
							 && (pBuf[x+3] == 'm')
							 && (pBuf[x+4] == 'e')
							 && (pBuf[x+5] == '>'))
							{
								x += 6;
								gotrackname = TRUE;
								if ((pBuf[x] == '<') && (pBuf[x+1] == '/'))
								{//if it's empty
									continue;
								}
								else if ((pBuf[x] == '<') && (pBuf[x+1] == '!') && (pBuf[x+2] == '['))
								{//if it's <name><![CDATA[DAN & CARMEN]]></name>
									x += 9;//to name
									for (z = 0; (z < 100) && ((pBuf[x] != ']') || (pBuf[x+1] != ']') || (pBuf[x+2] != '>')); x++, z++)
									{//can't use < > : " / \  |
										if ((pBuf[x] == '<') || (pBuf[x] == '>') || (pBuf[x] == ':') || (pBuf[x] == '\"') || (pBuf[x] == '/') || (pBuf[x] == '\\') || (pBuf[x] == '|') || (pBuf[x] == '*') || (pBuf[x] == '?'))
											pBuf[x] = ' ';
										TrackName[z] = pBuf[x];
									}
									x += 3;
								}
								else
									for (z = 0; (z < 100) && (pBuf[x] != '<') && (pBuf[x+1] != '/'); x++, z++)
										TrackName[z] = pBuf[x];
								TrackName[z++] = '.';
								TrackName[z++] = 'c';
								TrackName[z++] = 's';
								TrackName[z++] = 'v';
								TrackName[z] = 0;
								TrackNameSize = z;
								x += 6;//past </name
							}
							else if ((gottrk)
							 && (pBuf[x] == '<')
							 && (pBuf[x+1] == 't')
							 && (pBuf[x+2] == 'r')
							 && (pBuf[x+3] == 'k')
							 && (pBuf[x+4] == 's')
							 && (pBuf[x+5] == 'e')
							 && (pBuf[x+6] == 'g')
							 && (pBuf[x+7] == '>'))
							{
								x += 7;
								trackbeg = TRUE;//to put 'New'
							}
							else if ((gottrk)
							 && (pBuf[x] == '<')
							 && (pBuf[x+1] == 't')
							 && (pBuf[x+2] == 'r')
							 && (pBuf[x+3] == 'k')
							 && (pBuf[x+4] == 'p')
							 && (pBuf[x+5] == 't'))
							{
								trkptrend = FALSE;
								Month = Day = Hour = Minute = Second = 0;
								ele = 0.0;
								for ( ; (x < (int)fileSize) && (pBuf[x] != '"'); x++)
									;
								x++;
								Lat = atof(&pBuf[x]);
								for ( ; (x < (int)fileSize) && (pBuf[x] != '"'); x++)
									;
								x++;
								for ( ; (x < (int)fileSize) && (pBuf[x] != '"'); x++)
									;
								x++;
								Lon = atof(&pBuf[x]);
								for ( ; (x < (int)fileSize) && (pBuf[x] != '"'); x++)
									;
								x++;// to '/>' or ...
							}
							else if ((gottrk)
							 && (pBuf[x] == '<')
							 && (pBuf[x+1] == 'e')
							 && (pBuf[x+2] == 'l')
							 && (pBuf[x+3] == 'e')
							 && (pBuf[x+4] == '>'))
							{
								x += 5;//4;
								ele = (float)atof(&pBuf[x]);
								for ( ; (x < (int)fileSize) && (pBuf[x] != '>'); x++)
									;
							}
							else if ((gottrk)
							 && (pBuf[x] == '<')
							 && (pBuf[x+1] == 't')
							 && (pBuf[x+2] == 'i')
							 && (pBuf[x+3] == 'm')
							 && (pBuf[x+4] == 'e')
							 && (pBuf[x+5] == '>'))
							{
								x += 8;//04-04-07T22:04:01Z</Time>
								Year = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
								x += 3;
								Month = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
								x += 3;
								Day = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
								x += 3;
								Hour = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
								x += 3;
								Minute = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
								x += 3;
								Second = ((pBuf[x] - '0') * 10) + (pBuf[x+1] - '0');
								x += 3;
								for ( ; (x < (int)fileSize) && (pBuf[x] != '>'); x++)
									;
							}
							else if (((gottrk)
							 && (pBuf[x] == '<')
							 && (pBuf[x+1] == '/')
							 && (pBuf[x+2] == 't')
							 && (pBuf[x+3] == 'r')
							 && (pBuf[x+4] == 'k')
							 && (pBuf[x+5] == 'p')
							 && (pBuf[x+6] == 't')
							 && (pBuf[x+7] == '>'))
							 || ((gottrk) && (trkptrend == FALSE) && (pBuf[x] == '>') && (pBuf[x-1] == '/')))
							{
								LatRad = Lat*deg2rad;
								LonRad = Lon*deg2rad;
								LatLontoUTM();
								if (trackbeg)
								{
									trackbeg = FALSE;
									trak[tnum].newtrk = 1;
								}
								else
									trak[tnum].newtrk = 0;
								trak[tnum].NUTM = UTMNorthing;
								trak[tnum].EUTM = UTMEasting;
								trak[tnum].time = (UTMZone << 26) | (Month << 22) | (Day << 17) | (Hour << 12) | (Minute << 6) | Second;
								trak[tnum].year = Year;
								trak[tnum].alt = ele;
								tnum++;
								if (tnum > numofTracks)
									tnum = numofTracks;
							}
						}//end of for (x = 0;
						free(pBuf);
						fromTracks = TRUE;
						Lat = tempLat;
						Lon = tempLon;
						UTMZone = tempUTMZone;
						UTMNorthing = tempUTMN;
						UTMEasting = tempUTME;
						SendMessage(hwnd, WM_USER, 0, 0);
					}
					CloseHandle(hFile);
				}
			}
			break;

		case ID_FILE_IMPORT_GEOCACHINGLOCFILES:
			ofn.lpstrFilter       = " *.loc\0""*.loc\0\0";
			ofn.lpstrFile         = FullGeocaching;
			ofn.lpstrFileTitle    = Geocaching;
			if (GetOpenFileName(&ofn))
			{
				for (x = 0; FullGeocaching[x] != 0; x++)
					;
				x -= 3;
				FullGeocaching[x++] = 'l';//just in case a .gpx file was clicked on
				FullGeocaching[x++] = 'o';
				FullGeocaching[x] = 'c';
				ofn2.lpstrFilter = "*.xml\0""*.xml\0\0";
				if (FALSE != GetSaveFileName(&ofn2))
				{
					char *tempBuf, *tempBuf2;
					HANDLE hFile = CreateFile(FullGeocaching, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile != INVALID_HANDLE_VALUE)
					{
						if (fileSize = GetFileSize(hFile, NULL))
						{
							tempBuf = (char*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
							ReadFile(hFile, tempBuf, fileSize, &dwBytesRead, NULL);
							CloseHandle(hFile);
							if (newLoc)
								SaveLocs();
							if (newText)
								SaveText();
							if (INVALID_HANDLE_VALUE == FindFirstFile(WaypointsFullPath, &fd))//from ofn2
							{
								tempBuf2 = (char*)VirtualAlloc(NULL, (fileSize*2)+sizeof(Top), MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
								for (x = 0; Top[x] != 0; x++)
									tempBuf2[x] = Top[x];
								ConvertLocToXML(tempBuf, tempBuf2, x, fileSize);
								VirtualFree(tempBuf2, 0, MEM_RELEASE);
							}
							else
							{
								hFile = CreateFile(WaypointsFullPath, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
								if (hFile != INVALID_HANDLE_VALUE)
								{
									if (fileSize2 = GetFileSize(hFile, NULL))
									{
										tempBuf2 = (char*)VirtualAlloc(NULL, (fileSize*2)+fileSize2, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
										ReadFile(hFile, tempBuf2, fileSize2, &dwBytesRead, NULL);
										CloseHandle(hFile);
										for (x = fileSize2; tempBuf2[x] != '<'; x--)
											;
										ConvertLocToXML(tempBuf, tempBuf2, x, fileSize);
										VirtualFree(tempBuf2, 0, MEM_RELEASE);
									}
								}
								else
									CloseHandle(hFile);
							}
							VirtualFree(tempBuf, 0, MEM_RELEASE);
						}
						else
							CloseHandle(hFile);
					}
				}
			}
			ofn.lpstrFile         = FullTracks;
			ofn.lpstrFileTitle    = Tracks;
			ofn.lpstrFilter       = " *.csv\0*.csv\0\0";
			break;

		case ID_FILE_EXPORTTRACKSTOGPX:
			ofn.lpstrInitialDir = CurrentTrackDir;
			if (GetOpenFileName(&ofn))
			{
				strcpy(GPX, Tracks);
				strcpy(FullGPX, FullTracks);
				x = ofn.nFileExtension;
				FullGPX[x++] = 'g';
				FullGPX[x++] = 'p';
				FullGPX[x] = 'x';
				ofn.lpstrFilter       = " *.gpx\0*.gpx\0\0";
				ofn.lpstrFile         = FullGPX;
				ofn.lpstrFileTitle    = GPX;
				ofn.Flags             = OFN_HIDEREADONLY|OFN_NOCHANGEDIR|OFN_CREATEPROMPT;
				ofn.lpstrDefExt       = gpx;
				if (GetSaveFileName(&ofn))
				{
					hFile = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (INVALID_HANDLE_VALUE != hFile)
					{
						if (fileSize = GetFileSize(hFile, NULL))
						{
							DWORD DateTime;
							char TrackName[100];
							char TrackPoint[150];
							char NameBegin[] = "<trk><name>";
							char NameEnd[] = "</name>\r\n";
							char TrackSeg[] = "<trkseg>\r\n";
							char TrackSegEnd[] = "</trkseg>\r\n";
							char TrackPoint1[] = "<trkpt lat=\"";
							char TrackPoint2[] = "\" lon=\"";
							char TrackPoint3[] = "\"><ele>";
							char TrackPoint4[] = "</ele><time>20xx-xx-xxTxx:xx:xxZ</time></trkpt>\r\n";
							char TrackPoint5[] = "</trkseg>\r\n</trk>\r\n</gpx>\r\n";

							pTrackBuf = (unsigned char*)malloc(fileSize);
							ReadFile(hFile, pTrackBuf, fileSize, &dwBytesRead, NULL);
							numofTracks = ReadTracks(fileSize);//put tracks in trak
							free(pTrackBuf);
							pTrackBuf = NULL;
							CloseHandle(hFile);
//write gpx format file
							hFile2 = CreateFile(FullGPX, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
							WriteFile(hFile2, Top, sizeof(Top)-1, &dwBytesWritten, NULL);
							for (x = 0, y = 0; NameBegin[x] != 0; x++, y++)
								TrackName[y] = NameBegin[x];
							for (x = 0; GPX[x] != '.'; x++, y++)
								TrackName[y] = GPX[x];
							for (x = 0; NameEnd[x] != 0; x++, y++)
								TrackName[y] = NameEnd[x];
							WriteFile(hFile2, TrackName, y, &dwBytesWritten, NULL);
							for (z = 0; z < numofTracks; z++)
							{
								UTMNorthing = trak[z].NUTM;
								UTMEasting = trak[z].EUTM;
								UTMZone = (int)trak[z].time >> 26;
								UTMtoLatLon();
								y = 0;
								if ((trak[z].newtrk != 0) || (z == 0))
								{
									if (z != 0)
										for (x = 0; TrackSegEnd[x] != 0; x++, y++)
											TrackPoint[y] = TrackSegEnd[x];
									for (x = 0; TrackSeg[x] != 0; x++, y++)
										TrackPoint[y] = TrackSeg[x];
								}
								for (x = 0; TrackPoint1[x] != 0; x++, y++)
									TrackPoint[y] = TrackPoint1[x];
								y += sprintf(&TrackPoint[y], "%.6f", Lat);
								for (x = 0; TrackPoint2[x] != 0; x++, y++)
									TrackPoint[y] = TrackPoint2[x];
								y += sprintf(&TrackPoint[y], "%.6f", Lon);
								for (x = 0; TrackPoint3[x] != 0; x++, y++)
									TrackPoint[y] = TrackPoint3[x];
								y += sprintf(&TrackPoint[y], "%.1f", trak[z].alt * 0.3048);//convert feet to meters
								DateTime = trak[z].time;
								TrackPoint4[29] = (char)((DateTime & 0x3F) / 10) + '0';//seconds
								TrackPoint4[30] = (char)((DateTime & 0x3F) % 10) + '0';
								TrackPoint4[26] = (char)(((DateTime >> 6) & 0x3F) / 10) + '0';//minutes
								TrackPoint4[27] = (char)(((DateTime >> 6) & 0x3F) % 10) + '0';
								TrackPoint4[23] = (char)(((DateTime >> 12) & 0x1F) / 10) + '0';//hours
								TrackPoint4[24] = (char)(((DateTime >> 12) & 0x1F) % 10) + '0';
								TrackPoint4[20] = (char)(((DateTime >> 17) & 0x1F) / 10) + '0';//day
								TrackPoint4[21] = (char)(((DateTime >> 17) & 0x1F) % 10) + '0';
								TrackPoint4[17] = (char)(((DateTime >> 22) & 0x0F) / 10) + '0';//month
								TrackPoint4[18] = (char)(((DateTime >> 22) & 0x0F) % 10) + '0';
								TrackPoint4[14] = (char)(trak[z].year / 10) + '0';//year
								TrackPoint4[15] = (char)(trak[z].year % 10) + '0';
								if (trak[z].year == 0)
								{
									TrackPoint4[12] = '0';
									TrackPoint4[13] = '0';
								}
								for (x = 0; TrackPoint4[x] != 0; x++, y++)
									TrackPoint[y] = TrackPoint4[x];
								if (z == (numofTracks-1))
									for (x = 0; TrackPoint5[x] != 0; x++, y++)
										TrackPoint[y] = TrackPoint5[x];
								WriteFile(hFile2, TrackPoint, y, &dwBytesWritten, NULL);
							}
							CloseHandle(hFile2);
							MessageBox(hwnd, "Done", "", MB_OK);
						}
						else
							CloseHandle(hFile);
					}
				}	
				ofn.lpstrFilter       = " *.csv\0*.csv\0\0";
				ofn.lpstrFile         = FullTracks;
				ofn.lpstrFileTitle    = Tracks;
				ofn.Flags             = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
				ofn.lpstrDefExt       = csv;
			}
			ofn.lpstrInitialDir   = CurrentDir;
			break;

		case ID_FILES_CLOSE:
			SendMessage(hwnd, WM_CLOSE, 0, 0);
			break;

		case ID_VIEW_LATITUDELONGITUDE_DEGREES:
			MouseLoc = DEG;
			ClearLine();
			CheckMenuItem (hMenu, Units, MF_UNCHECKED);
			Units = wParameter ;
			CheckMenuItem (hMenu, Units, MF_CHECKED);
			break;

		case ID_VIEW_LATITUDELONGITUDE_DEGREESMINUTES:
			MouseLoc = DEGMIN;
			ClearLine();
			CheckMenuItem (hMenu, Units, MF_UNCHECKED) ;
			Units = wParameter ;
			CheckMenuItem (hMenu, Units, MF_CHECKED) ;
			break;

		case ID_VIEW_LATITUDELONGITUDE_DEGREESMINUTESSECONDS:
			MouseLoc = DEGMINSEC;
			ClearLine();
			CheckMenuItem (hMenu, Units, MF_UNCHECKED) ;
			Units = wParameter ;
			CheckMenuItem (hMenu, Units, MF_CHECKED) ;
			break;

		case ID_VIEW_LATLON_UTM:
			MouseLoc = ITSUTM;
			ClearLine();
			CheckMenuItem (hMenu, Units, MF_UNCHECKED) ;
			Units = wParameter ;
			CheckMenuItem (hMenu, Units, MF_CHECKED) ;
			break;

		case ID_VIEW_LATLON_USNG:
			MouseLoc = ITSUSNG;
			ClearLine();
			CheckMenuItem (hMenu, Units, MF_UNCHECKED) ;
			Units = wParameter ;
			CheckMenuItem (hMenu, Units, MF_CHECKED) ;
			break;

		case ID_VIEW_MAPTYPE_PHOTO:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (MapType == PHOTO)
				break;
			wastopo = TRUE;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			ModifyMenu(hMenu, ID_ZOOM_1METERPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_1METERPIXEL, PhotoZoom1);
			ModifyMenu(hMenu, ID_ZOOM_2METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_2METERSPIXEL, PhotoZoom2);
			ModifyMenu(hMenu, ID_ZOOM_4METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_4METERSPIXEL, PhotoZoom4);
			ModifyMenu(hMenu, ID_ZOOM_8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_8METERSPIXEL, PhotoZoom8);
			ModifyMenu(hMenu, ID_ZOOM_BIG8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_BIG8METERSPIXEL, PhotoZoomBig8);
			ModifyMenu(hMenu, ID_ZOOM_16METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_16METERSPIXEL, PhotoZoom16);
			ModifyMenu(hMenu, ID_ZOOM_32METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_32METERSPIXEL, PhotoZoom32);
			ModifyMenu(hMenu, ID_ZOOM_64METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_64METERSPIXEL, PhotoZoom64);
			if (MapType == TOPO)
			{
				CheckMenuItem(hMenu, ID_VIEW_MAPTYPE_TOPO, MF_UNCHECKED);
				MapType = PHOTO;
				MapUnits = ID_VIEW_MAPTYPE_PHOTO;
				CheckMenuItem(hMenu, MapUnits, MF_CHECKED);
				if (Zoom == 1)
				{//4 meters/pixel
					if (FadeIncrement)
						fade = TRUE;
					MetersPerTile = 200;
					UncheckZoom();
					Zoom = 3;
					PixelsPerTile = 50;
				}
				else if (Zoom == 2)
				{//8 meters/pixel
					if (zoom1to8)
					{
						MetersPerTile = 200;
						UncheckZoom();
						Zoom = 4;
						PixelsPerTile = 25;
					}
					else
					{
						MetersPerTile = 1600;
						UncheckZoom();
						Zoom = 5;
						PixelsPerTile = 200;
					}
				}
				else if (Zoom == 3)
				{
					MetersPerTile = 1600;
					UncheckZoom();
					Zoom = 6;
					PixelsPerTile = 100;
				}
				else if (Zoom == 4)
				{
					MetersPerTile = 1600;
					UncheckZoom();
					Zoom = 7;
					PixelsPerTile = 50;
				}
				else if (Zoom = 5)
				{
					MetersPerTile = 1600;
					UncheckZoom();
					Zoom = 8;
					PixelsPerTile = 25;
				}
			}
			else//if (MapType == URBANAREA)
			{
				CheckMenuItem(hMenu, ID_VIEW_MAPTYPE_COLOR, MF_UNCHECKED);
				MapType = PHOTO;
				MapUnits = ID_VIEW_MAPTYPE_PHOTO;
				CheckMenuItem(hMenu, MapUnits, MF_CHECKED);
				if (Zoom <= 3)
				{
					UncheckZoom();
					Zoom = 1;
					PixelsPerTile = 200;
					MetersPerTile = 200;
				}
				else if (Zoom == 4)
				{
					UncheckZoom();
					Zoom = 2;
					PixelsPerTile = 100;
					MetersPerTile = 200;
				}
				else if (Zoom == 5)
				{
					UncheckZoom();
					Zoom = 3;
					PixelsPerTile = 50;
					MetersPerTile = 200;
				}
				else if (Zoom == 6)
				{
					if (zoom1to8)
					{
						UncheckZoom();
						Zoom = 4;
						PixelsPerTile = 25;
						MetersPerTile = 200;
					}
					else
					{
						Zoom = 5;
						PixelsPerTile = 200;
						MetersPerTile = 1600;
					}
					UncheckZoom();
				}
				else if (Zoom == 7)
				{
					UncheckZoom();
					Zoom = 6;
					PixelsPerTile = 100;
					MetersPerTile = 1600;
				}
				else if (Zoom == 8)
				{
					UncheckZoom();
					Zoom = 7;
					PixelsPerTile = 50;
					MetersPerTile = 1600;
				}
			}
			ShowZoom();
			DoZoom();
			ShowPhoto();
			break;

//ModifyMenu(hMenu, MenuID, MF_BYCOMMAND|MF_STRING, MenuID, Empty);
		case ID_VIEW_MAPTYPE_TOPO:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (MapType == TOPO)
				break;
//			grid75 = FALSE;
//			CheckMenuItem(hMenu, ID_FILE_SHOWELEVATIONSQUARES, MF_UNCHECKED);
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			ModifyMenu(hMenu, ID_ZOOM_1METERPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_1METERPIXEL, TopoZoom1);
			ModifyMenu(hMenu, ID_ZOOM_2METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_2METERSPIXEL, TopoZoom2);
			ModifyMenu(hMenu, ID_ZOOM_4METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_4METERSPIXEL, TopoZoom4);
			ModifyMenu(hMenu, ID_ZOOM_8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_8METERSPIXEL, TopoZoom8);
			ModifyMenu(hMenu, ID_ZOOM_BIG8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_BIG8METERSPIXEL, TopoZoomBig8);
			ModifyMenu(hMenu, ID_ZOOM_16METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_16METERSPIXEL, TopoZoom16);
			ModifyMenu(hMenu, ID_ZOOM_32METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_32METERSPIXEL, TopoZoom32);
			ModifyMenu(hMenu, ID_ZOOM_64METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_64METERSPIXEL, TopoZoom64);
			if (MapType == PHOTO)
			{
				CheckMenuItem(hMenu, ID_VIEW_MAPTYPE_PHOTO, MF_UNCHECKED);
				if ((Zoom == 1) || (Zoom == 2) || (Zoom == 3))
				{
					if ((FadeIncrement) && (wastopo))
						fade = TRUE;
					UncheckZoom();
					Zoom = 1;
					PixelsPerTile = 200;
					MetersPerTile = 800;
				}
				else if ((Zoom == 4) || (Zoom == 5))
				{
					UncheckZoom();
					Zoom = 2;
					PixelsPerTile = 100;
					MetersPerTile = 800;
				}
				else if (Zoom == 6)
				{
					UncheckZoom();
					Zoom = 3;
					PixelsPerTile = 50;
					MetersPerTile = 800;
				}
				else if (Zoom == 7)
				{
					UncheckZoom();
					Zoom = 4;
					PixelsPerTile = 25;
					MetersPerTile = 800;
				}
				else if (Zoom == 8)
				{
					UncheckZoom();
					Zoom = 5;
					PixelsPerTile = 200;
					MetersPerTile = 12800;
				}
			}
			else//if (MapType == URBANAREA)
			{
				CheckMenuItem(hMenu, ID_VIEW_MAPTYPE_COLOR, MF_UNCHECKED);
				UncheckZoom();
				if (Zoom <= 5)
				{
					Zoom = 1;
					PixelsPerTile = 200;
				}
				else if (Zoom == 6)
				{
					Zoom = 2;
					PixelsPerTile = 100;
				}
				else if (Zoom == 7)
				{
					Zoom = 3;
					PixelsPerTile = 50;
				}
				else if (Zoom == 8)
				{
					Zoom = 4;
					PixelsPerTile = 25;
				}
				MetersPerTile = 800;
			}
			MapType = TOPO;
			MapUnits = ID_VIEW_MAPTYPE_TOPO;
			CheckMenuItem(hMenu, MapUnits, MF_CHECKED);
			ShowZoom();
			DoZoom();
			ShowTopo();
			break;

//ModifyMenu(hMenu, MenuID, MF_BYCOMMAND|MF_STRING, MenuID, Empty);
		case ID_VIEW_MAPTYPE_COLOR:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (MapType == URBANAREA)
				break;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
//			grid75 = FALSE;
//			CheckMenuItem(hMenu, ID_FILE_SHOWELEVATIONSQUARES, MF_UNCHECKED);
			wastopo = FALSE;
			ModifyMenu(hMenu, ID_ZOOM_1METERPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_1METERPIXEL, UrbanZoom1);
			ModifyMenu(hMenu, ID_ZOOM_2METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_2METERSPIXEL, UrbanZoom2);
			ModifyMenu(hMenu, ID_ZOOM_4METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_4METERSPIXEL, UrbanZoom4);
			ModifyMenu(hMenu, ID_ZOOM_8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_8METERSPIXEL, UrbanZoom8);
			ModifyMenu(hMenu, ID_ZOOM_BIG8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_BIG8METERSPIXEL, UrbanZoomBig8);
			ModifyMenu(hMenu, ID_ZOOM_16METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_16METERSPIXEL, UrbanZoom16);
			ModifyMenu(hMenu, ID_ZOOM_32METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_32METERSPIXEL, UrbanZoom32);
			ModifyMenu(hMenu, ID_ZOOM_64METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_64METERSPIXEL, UrbanZoom64);
			if (MapType == PHOTO)
			{
				CheckMenuItem(hMenu, ID_VIEW_MAPTYPE_PHOTO, MF_UNCHECKED);
				if (Zoom == 1)
				{
					UncheckZoom();
					Zoom = 3;
					PixelsPerTile = 50;
					MetersPerTile = 50;
				}
				else if (Zoom == 2)
				{
					UncheckZoom();
					Zoom = 4;
					PixelsPerTile = 25;
					MetersPerTile = 50;
				}
				else if (Zoom == 3)
				{
					UncheckZoom();
					Zoom = 5;
					PixelsPerTile = 200;
					MetersPerTile = 800;
				}
				else if ((Zoom == 4) || (Zoom == 5))
				{
					UncheckZoom();
					Zoom = 6;
					PixelsPerTile = 100;
					MetersPerTile = 800;
				}
				else if (Zoom == 6)
				{
					UncheckZoom();
					Zoom = 7;
					PixelsPerTile = 50;
					MetersPerTile = 800;
				}
				else if ((Zoom == 7) || (Zoom == 8))
				{
					UncheckZoom();
					Zoom = 8;
					PixelsPerTile = 25;
					MetersPerTile = 800;
				}
			}
			else//if (MapType == TOPO)
			{
				CheckMenuItem(hMenu, ID_VIEW_MAPTYPE_TOPO, MF_UNCHECKED);
				UncheckZoom();
				if (Zoom == 1)
				{
					Zoom = 5;
					PixelsPerTile = 200;
					MetersPerTile = 800;
				}
				else if (Zoom == 2)
				{
					Zoom = 6;
					PixelsPerTile = 100;
					MetersPerTile = 800;
				}
				else if (Zoom == 3)
				{
					Zoom = 7;
					PixelsPerTile = 50;
					MetersPerTile = 800;
				}
				else if (Zoom >= 4)
				{
					Zoom = 8;
					PixelsPerTile = 25;
					MetersPerTile = 800;
				}
			}
			MapType = URBANAREA;
			MapUnits = ID_VIEW_MAPTYPE_COLOR;
			CheckMenuItem(hMenu, MapUnits, MF_CHECKED);
			ShowZoom();
			DoZoom();
			ShowUrbanArea();
			break;

		case ID_GOTO_LATLON:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (MouseLoc == ITSUSNG)
			{
				if (DialogBox(hInst, "GOTOUSNG", hwnd, GotoUSNGProc) != EXIT)
					goto gotothere;
			}
			else
			if (DialogBox(hInst, "GOTO", hwnd, GotoProc) != EXIT)
			{
				ChangeZone(UTMZone, 5);//GoToProc
				BeginX = UTMEasting / MetersPerTile;
				BeginY = UTMNorthing / MetersPerTile;
				_itoa(BeginX, X, 10);
				_itoa(BeginY, Y, 10);
				Z[0] = (UTMZone / 10) + '0';
				Z[1] = (UTMZone % 10) + '0';
				Waypoints[0] = 0;
				if (tempUTMZone != UTMZone)
					SendMessage(hwnd, WM_USER4, 0, 0);
gotothere:
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;

				wastopo = FALSE;
				veryfirstime = TRUE;
				rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
				colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
				SetCursor(hWaitingCursor);
				fromOpen = TRUE;
				SendMessage(hwnd, WM_USER, 0, 0);//was WM_USER2
				SetCursor(hCursor);

				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;

				lButtonDotX = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
				lButtonDotY = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
				fromgoto = TRUE;
				SendMessage(hwnd, WM_USER6, 0, 0);
			}
			break;

		case ID_VIEW_BRIGHTNESS_BRIGHTER:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (Increment != 60)
				Increment += 10;
			SendMessage(hwnd, WM_USER, 0, 0);
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_BRIGHTNESS_DARKER:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (Increment != -60)
				Increment -= 10;
			SendMessage(hwnd, WM_USER, 0, 0);
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_BRIGHTNESS_DEFAULT:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			Increment = 0;
			SendMessage(hwnd, WM_USER, 0, 0);
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_GRID:
			if (gridon)
			{
				gridon = FALSE;
				CheckMenuItem(hMenu, ID_VIEW_GRID, MF_UNCHECKED);
			}
			else
			{
				gridon = TRUE;
				CheckMenuItem(hMenu, ID_VIEW_GRID, MF_CHECKED);
			}
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_CONTOURS:
			SendMessage(hwnd, WM_KEYDOWN, (WPARAM)'C', 0);
			break;

		case ID_VIEW_SHOWUSGSLANDMARKS:
			if (USGSBuf == NULL)
			{
				GetUSGSData();
			}
			else
			{
				CheckMenuItem(hMenu, ID_VIEW_SHOWUSGSLANDMARKS, MF_UNCHECKED);
				VirtualFree(USGSBuf, 0, MEM_RELEASE);
				VirtualFree(PtrBuf, 0, MEM_RELEASE);
				USGSBuf = NULL;
			}
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_SHOWWAYPOINTNAMES:
			if (shownamecomment)
			{
				shownamecomment = FALSE;
				CheckMenuItem(hMenu, ID_VIEW_SHOWWAYPOINTNAMES, MF_UNCHECKED);
			}
			else
			{
				shownamecomment = TRUE;
				CheckMenuItem(hMenu, ID_VIEW_SHOWWAYPOINTNAMES, MF_CHECKED);
			}
			SavenameCommentProc();
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_TIGERLINES_INTERSTATES:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			Uncheck();
			if (hwndStreet != NULL)
			{
				DestroyWindow(hwndStreet);
				hwndStreet = NULL;
			}
			if (HighestFeatureType == 19)
			{
				HighestFeatureType = 0;
				showstreets = FALSE;
				FreepTiger();
//				DestroyWindow(hwndStreet);
			}
			else
			{
				first = TRUE;
				showstreets = TRUE;
				HighestFeatureType = 19;
				CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_INTERSTATES, MF_CHECKED);
				pt = (POINT*)VirtualAlloc(NULL, 750000*8, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			}
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_TIGERLINES_HIGHWAYS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			Uncheck();
			if (hwndStreet != NULL)
			{
				DestroyWindow(hwndStreet);
				hwndStreet = NULL;
			}
			if (HighestFeatureType == 39)
			{
				HighestFeatureType = 0;
				showstreets = FALSE;
				FreepTiger();
			}
			else
			{
				first = TRUE;
				showstreets = TRUE;
				HighestFeatureType = 39;
				CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_HIGHWAYS, MF_CHECKED);
				pt = (POINT*)VirtualAlloc(NULL, 750000*8, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			}
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_TIGERLINES_LOCALSTREETS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			Uncheck();
			if (hwndStreet != NULL)
			{
				DestroyWindow(hwndStreet);
				hwndStreet = NULL;
			}
			if (HighestFeatureType == 49)
			{
				HighestFeatureType = 0;
				showstreets = FALSE;
				FreepTiger();
			}
			else
			{
				first = TRUE;
				showstreets = TRUE;
				HighestFeatureType = 49;
				CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_LOCALSTREETS, MF_CHECKED);
				pt = (POINT*)VirtualAlloc(NULL, 750000*8, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			}
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_TIGERLINES_TRAILS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			Uncheck();
			if (hwndStreet != NULL)
			{
				DestroyWindow(hwndStreet);
				hwndStreet = NULL;
			}
			if (HighestFeatureType == 59)
			{
				HighestFeatureType = 0;
				showstreets = FALSE;
				FreepTiger();
			}
			else
			{
				first = TRUE;
				showstreets = TRUE;
				HighestFeatureType = 59;
				CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_TRAILS, MF_CHECKED);
				pt = (POINT*)VirtualAlloc(NULL, 750000*8, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			}
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_TIGERLINES_EVERYTHING:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			Uncheck();
			if (hwndStreet != NULL)
			{
				DestroyWindow(hwndStreet);
				hwndStreet = NULL;
			}
			if (HighestFeatureType == 0xFF)
			{
				HighestFeatureType = 0;
				showstreets = FALSE;
				FreepTiger();
			}
			else
			{
				first = TRUE;
				showstreets = TRUE;
				HighestFeatureType = 0xFF;
				CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_EVERYTHING, MF_CHECKED);
				pt = (POINT*)VirtualAlloc(NULL, 750000*8, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			}
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_VIEW_MAPOFUSA:
			if ((FALSE == usamap) && (maximized))
			{
				if (INVALID_HANDLE_VALUE != FindFirstFile("StateOutlines\\*.txt", &fd))
				{
					usamap = TRUE;
					USAIndex = -1;
					DestroyMenu(hMenu);
					hMenu4 = LoadMenu(hInst, "PRESSESC");
					SetMenu(hwnd, hMenu4);
					hwndUSA = CreateWindow(USA, NULL,
						WS_CHILD | WS_VISIBLE,
						0, 0, rect.right, rect.bottom,
						hwnd, (HMENU)543, hInst, NULL);
				}
				else
 				{
					if (IDOK == MessageBox(hwnd, "Do you want to download 939 KBytes of\nState Outline data from jdmcox.com?", "FIRST", MB_OKCANCEL))
						hDownloadStatesThread = _beginthreadex(NULL, 0, DownloadStateOutlineThread, hwnd, 0, &idThread10);
					else
						InvalidateRect(hwnd, &rect, FALSE);
				}
			}
			break;

		case ID_VIEW_BIGJPEG:
			if (Pixels == NULL)
			{
				if (GetOpenFileName(&ofn6))
				{
					if (INVALID_HANDLE_VALUE != FindFirstFile(ofn6.lpstrFile, &fd))
					{
						DestroyMenu(hMenu);
						hMenu4 = LoadMenu(hInst, "PRESSESC");
						SetMenu(hwnd, hMenu4);
						hwndBig = CreateWindow(Big, NULL,//BigProc
							WS_CHILD | WS_VISIBLE,
							0, 0, rect.right, rect.bottom,
							hwnd, (HMENU)345, hInst, NULL);
					}
				}
			}
			break;

		case ID_APRS_HELP:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (autoLoc == FALSE)
			{
				pAPRSHelp = NULL;
				hFile = CreateFile(APRSHelp, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					if (APRSHelpSize = GetFileSize(hFile, NULL))
					{
						pAPRSHelp = (char *) malloc(APRSHelpSize+1);
						if (pAPRSHelp == NULL)
							MessageBox(hwnd, "OHOH", "", MB_OK);
						pAPRSHelp[APRSHelpSize] = 0;
						ReadFile(hFile, pAPRSHelp, APRSHelpSize, &dwBytesRead, NULL);

						hMenu3 = CreateMenu();//to override parent menu bar
						hwndAPRS = CreateWindow(Instruct, "APRSHelp.txt",
							WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
							cxScreen/2-320, TitleAndMenu, (cxScreen/2 + 320)-(cxScreen/2-320), cyScreen-(cyChar*3),
							NULL, hMenu3, hInst, NULL);
						SetWindowText(hwndInstr, pAPRSHelp);
						SetFocus(hwndInstr);
					}
					CloseHandle (hFile);
				}
				else
					MessageBox(hwnd, NoAPRSFile, NULL, MB_OK);
			}
			break;

		//send "KI6NLA>APZUSA,TCPIP*:3724.44N/12206.98W-USAPhotoMaps"
		case ID_APRS_INTERNETNETWORK_TRANSMITLOCATION:
			if (transmitto == TRANSMITNONE)
			{
				MessageBox(hwnd, "Select Send Home or GPS Location\nin Setup to Transmit Location.", "", MB_OK);
				break;
			}
			if ((transmitto == TRANSMITGPS) && (pos == 0))
			{
				MessageBox(hwnd, "No GPS position has been received yet.", "", MB_OK);
				break;
			}
			x = GetInitString();
			Filter[x++] = '\n';
			Filter[x] = 0;
			FilterLen = x;//strlen(Filter);
			if ((MyCall[0]) && (_stricmp(MyCall, "NOCALL")))
			{
				if (transmitto == TRANSMITHOME)
					FillMYCALLUNPROTOBTEXTKISS();
				for (x = 0; MyCall[x] != '\0'; x++)
					MyLoc[x] = MyCall[x];
				for (y = 0; InternetUNPROTO[y] != '\0'; x++, y++)
					MyLoc[x] = InternetUNPROTO[y];
				for (y = 6; BTEXT[y] != '\0'; x++, y++)
					MyLoc[x] = BTEXT[y];
				MyLoc[x++] = '\n';
				MyLoc[x] = 0;
				sendmyloc = TRUE;
				if (DialogBox(hInst, "APRSSERVER", hwnd, APRSServerProc))
					//**********************
					hAPRSThread2 = _beginthreadex(NULL, 0, aprsISthread2, hwnd, 0, &idThread16);
					//**********************
			}
			else
				MessageBox(hwnd, CallsignError, ERROR, MB_OK);
			break;

		case ID_APRS_INTERNETNETWORK_ACTASANIGATE:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ACTASANIGATE, MF_BYCOMMAND))
			{
				if (IDNO == MessageBox(hwnd, "Are you familiar with the consequences\nof sending to the Internet everything\nyour transceiver receives?\n\n(read APRS -HELP)", "Serve as I-Gate", MB_YESNO|MB_DEFBUTTON2))
					break;
				sendmyloc = TRUE;
				if (DialogBox(hInst, "APRSSERVER", hwnd, APRSServerProc))
				{
					x = GetInitString();
					Filter[x++] = '\n';
					Filter[x] = 0;
					FilterLen = x;
					CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ACTASANIGATE, MF_CHECKED);
					if (IgatewsaData.szSystemStatus[0] == '\0')
						WSAStartup(0x0202, &IgatewsaData);
					else
						dontcleanup = TRUE;
					if (INVALID_SOCKET == (s3 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)))
					{
						sprintf(Error, "Bad socket(%ld)\nLine %ld", WSAGetLastError(), __LINE__);
						SendMessage(hwnd, WM_COMMAND, ID_APRS_INTERNETNETWORK_ACTASANIGATE, 0);
						MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
						break;
					}
					if (NULL == (he = gethostbyname(Tier2Server)))
					{
						closesocket(s3);
						sprintf(Error, "Bad host(%ld)", WSAGetLastError());
						SendMessage(hwnd, WM_COMMAND, ID_APRS_INTERNETNETWORK_ACTASANIGATE, 0);
						MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
						break;
					}
					else
					{
						memcpy(&dest.sin_addr, he->h_addr_list[0], he->h_length);
						dest.sin_family = he->h_addrtype;
						dest.sin_port = htons(14580);// 10152 for concord.aprs.net
					}

					if (SOCKET_ERROR == connect(s3, (struct sockaddr*)&dest, sizeof(SOCKADDR)))
					{
						sprintf(Error, "Connect error %ld\n(line %d)", WSAGetLastError(), __LINE__);
						SendMessage(hwnd, WM_COMMAND, ID_APRS_INTERNETNETWORK_ACTASANIGATE, 0);
						MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
						break;
					}
					else
					{
						PacketSize = recv(s3, SmallBuf2, 1024, 0);
						if ((PacketSize == 0) || (SOCKET_ERROR == PacketSize))
						{
							sprintf(Error, "Bad initial receive %ld\n(line %d)", WSAGetLastError(), __LINE__);
							SendMessage(hwnd, WM_COMMAND, ID_APRS_INTERNETNETWORK_ACTASANIGATE, 0);
							MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
							break;
						}
						if (FilterLen)
						{
							if (SOCKET_ERROR == send(s3, Filter, FilterLen, 0))
							{
								sprintf(Error, "Send error %ld\n(line %d)", WSAGetLastError(), __LINE__);
								SendMessage(hwnd, WM_COMMAND, ID_APRS_INTERNETNETWORK_ACTASANIGATE, 0);
								MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
								break;
							}
						}
						PacketSize = recv(s3, SmallBuf2, 1024, 0);
						if ((PacketSize == 0) || (SOCKET_ERROR == PacketSize))
						{
							sprintf(Error, "Receive error %ld\n(line %d)", WSAGetLastError(), __LINE__);
							MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
							break;
						}
					}
					igate = TRUE;
				}
			}
			else
			{
				CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ACTASANIGATE, MF_UNCHECKED);
				MessageBox(hwnd, "Closing connection", "Igate", MB_OK);
				if (s3 != INVALID_SOCKET){
					closesocket(s3);
					s3 = INVALID_SOCKET;
				}
				if (!dontcleanup)
				{
					WSACleanup();
					IgatewsaData.szSystemStatus[0] = '\0';
					dontcleanup = TRUE;
				}
				if (igate)
					igate = FALSE;
			}
			break;

		case ID_APRS_RECEIVEINTERNETDATA:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_RECEIVEINTERNETDATA, MF_BYCOMMAND))
			{
				if ((gettingsaved) || (gettingreceived))
				{
					MessageBox(hwnd, Simultaneously, "Sorry...", MB_OK);
					break;
				}
//				if (aprs == FALSE)
				{
					gettinginternet = TRUE;
					CheckMenuItem(hMenu, ID_APRS_RECEIVEINTERNETDATA, MF_CHECKED);
					aprsISend = 0;
					isaprslinebeg = -1;

					tempLat = Lat;
					tempLon = Lon;
					tempUTMZone = UTMZone;
					tempUTMN = UTMNorthing;
					tempUTME = UTMEasting;
					UTMNorthing = ScreenTop;
					UTMEasting = ScreenLeft;
					UTMtoLatLon();
					modf(Lat, &Lat1);
					lat1 = (int)Lat1+1;
					_itoa(lat1, LAT1, 10);
					modf(Lon, &Lon1);
					lon1 = (int)Lon1-1;
					_itoa(lon1, LON1, 10);
					UTMNorthing = ScreenBottom;
					UTMEasting = ScreenRight;
					UTMtoLatLon();
					modf(Lat, &Lat1);
					lat1 = (int)Lat1;
					_itoa(lat1, LAT2, 10);
					modf(Lon, &Lon1);
					lon1 = (int)Lon1;
					_itoa(lon1, LON2, 10);
					Lat = tempLat;
					Lon = tempLon;
					UTMZone = tempUTMZone;
					UTMNorthing = tempUTMN;
					UTMEasting = tempUTME;

					x = GetInitString();
					for (y = 0; Filter4[y] != 0; x++, y++)
						Filter[x] = Filter4[y];
					for (y = 0; LAT1[y] != 0; y++, x++)
						Filter[x] = LAT1[y];
					Filter[x++] = '/';
					for (y = 0; LON1[y] != 0; y++, x++)
						Filter[x] = LON1[y];
					Filter[x++] = '/';
					for (y = 0; LAT2[y] != 0; y++, x++)
						Filter[x] = LAT2[y];
					Filter[x++] = '/';
					for (y = 0; LON2[y] != 0; y++, x++)
						Filter[x] = LON2[y];
					for (y = 0; Filter5[y] != 0; y++, x++)
						Filter[x] = Filter5[y];
					Filter[x++] = '\n';
					Filter[x] = 0;
					FilterLen = x;
					sendmyloc = FALSE;
//inaprs = TRUE;
					if (DialogBox(hInst, "APRSSERVER", hwnd, APRSServerProc))
					{
						//**********************
						ResetEvent(hAPRSISEvent);
						hAPRSThread = _beginthreadex(NULL, 0, aprsISthread, hwnd, 0, &idThread15);
						Sleep(500);
						//**********************
					}
					else
						goto nointernet;
				}
			}
			else
			{
nointernet:		gettinginternet = FALSE;
				CheckMenuItem(hMenu, ID_APRS_RECEIVEINTERNETDATA, MF_UNCHECKED);
				SetEvent(hAPRSISEvent);//close APRSISthread

				if ((aprsi) && (aprsimulate == FALSE))
				{
					SaveAPRSlog();
					SaveAPRSlogAsText();
				}
				aprsi = Aprsi = aprs = 0;//FALSE
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
			}
			break;

		case ID_APRS_INTERNETNETWORK_ENTERIPADDRESSMANUALLY:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ENTERIPADDRESSMANUALLY, MF_BYCOMMAND))
			{
				if (DialogBox(hInst, "SECRETIP", hwnd, SecretIPProc))
				{
					CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ENTERIPADDRESSMANUALLY, MF_CHECKED);
					aprsISend = 0;
					isaprslinebeg = -1;
					linend = -3;
					fromctrli = TRUE;
					ResetEvent(hAPRSISEvent);
					hAPRSThread = _beginthreadex(NULL, 0, aprsISthread, hwnd, 0, &idThread15);
					Sleep(500);
				}
			}
			else
			{
				CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ENTERIPADDRESSMANUALLY, MF_UNCHECKED);
				SetEvent(hAPRSISEvent);//close APRSISthread
			}
			break;

		case ID_APRS_INTERNETNETWORK_ACTASSERVER:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ACTASSERVER, MF_BYCOMMAND))
			{
				if (0 == WSAStartup(0x0202, &wsaData))
				{
					sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
					if (sListen != INVALID_SOCKET)
					{
						if (0 == WSAAsyncSelect(sListen, hwnd, WM_APRS_SERVER, FD_ACCEPT|FD_READ|FD_WRITE))
						{
							saServer.sin_family = AF_INET;
							saServer.sin_port = htons(serverPort);
							saServer.sin_addr.s_addr = INADDR_ANY;
							if (0 == bind(sListen, (LPSOCKADDR)&saServer, sizeof(struct sockaddr)))
							{
								if (0 == listen(sListen, SOMAXCONN))
								{
									CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ACTASSERVER, MF_CHECKED);
									MessageBox(hwnd, "Accepting connections on port 1448.", "", MB_OK);
								}
								else
									MessageBox(hwnd, "Error 5", ERROR, MB_OK);
							}
						}
						else MessageBox(hwnd, "Error 3", ERROR, MB_OK);
					}
					else MessageBox(hwnd, "Error 2", ERROR, MB_OK);
				}
				else MessageBox(hwnd, "Error 1", ERROR, MB_OK);
			}
			else
			{
				WSACleanup();
				CheckMenuItem(hMenu, ID_APRS_INTERNETNETWORK_ACTASSERVER, MF_UNCHECKED);
			}
			break;


		case ID_APRS_SAVED_DATA:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_SAVED_DATA, MF_BYCOMMAND))
			{
				if ((gettinginternet) || (gettingreceived))
				{
					MessageBox(hwnd, Simultaneously, "Sorry...", MB_OK);
					break;
				}
				CheckMenuItem(hMenu, ID_APRS_SAVED_DATA, MF_CHECKED);
				gettingsaved = aprsimulate = TRUE;
				goto aprs;
			}
			else
			{
				gettingsaved = aprsimulate = FALSE;
				CheckMenuItem(hMenu, ID_APRS_SAVED_DATA, MF_UNCHECKED);
				DestroyWindow(hwndStationsDlg);
				hwndStationsDlg = NULL;
				DestroyWindow(hwndStationInfoDlg);
				hwndStationInfoDlg = NULL;
				DestroyWindow(hwndMessageDlg);
				hwndMessageDlg = NULL;
				aprsi = Aprsi = aprs = 0;//FALSE
				InvalidateRect(hwnd, &rect, FALSE);
			}
			break;

//		case ID_APRS_SHOWRANGECIRCLE:
//			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_SHOWRANGECIRCLE, MF_BYCOMMAND))
//			{
//				CheckMenuItem(hMenu, ID_APRS_SHOWRANGECIRCLE, MF_CHECKED);
//				showrangecircles = TRUE;
//			}
//			else
//			{
//				CheckMenuItem(hMenu, ID_APRS_SHOWRANGECIRCLE, MF_UNCHECKED);
//				showrangecircles = FALSE;
//			}
//			InvalidateRect(hwnd, &rect, FALSE);
//			break;

		case ID_APRS_EXCLUDEINCLUDELISTS_CALLSIGNS:
			if (DialogBox(hInst, "EXCLUDESYMBOLSCALLS", hwnd, ExcludeSymbolsCallsProc))
				InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_APRS_EXCLUDEINCLUDELISTS_TRACKS:
			if (DialogBox(hInst, "EXCLUDETRACKS", hwnd, ExcludeTracksProc))
				InvalidateRect(hwnd, &rect, FALSE);
			break;

		case APRSCOMMPORT:
			if (DialogBox(hInst, "COMMPORT", hwnd, APRSCommPortProc))
			{
				int aprscommportlen;
				char *pUSAPMbuf;

				hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					fileSize = GetFileSize(hFile, NULL);
					pUSAPMbuf = (char*)malloc(fileSize);
					ReadFile(hFile, pUSAPMbuf, fileSize, &dwBytesRead, NULL);
					for (x = 0; x < (int)fileSize; x++)
					{//APRSCommPort=1
						if (pUSAPMbuf[x] == '=')
						{
							if ((pUSAPMbuf[x-1] == 't') && (pUSAPMbuf[x-4] == 'P') && (pUSAPMbuf[x-8] == 'C') && (pUSAPMbuf[x-12] == 'A'))
							{//found "APRSCommPort=1\r\n"
								CloseHandle(hFile);
								hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
								WriteFile(hFile, pUSAPMbuf, x+1, &dwBytesWritten, NULL);
								if (APRSCommPort[1]) aprscommportlen = 2; else aprscommportlen = 1;
								WriteFile(hFile, APRSCommPort, aprscommportlen, &dwBytesWritten, NULL);
								for (y = x+1; (y < fileSize) && (pUSAPMbuf[y] != '\r'); y++)
									;
								WriteFile(hFile, &pUSAPMbuf[y], fileSize-y, &dwBytesWritten, NULL);
/*
								if (APRSCommPort[1] == 0)
								{//new port number is 1 byte
									if (pUSAPMbuf[x+2] == '\r')//old port number was 1 byte
									{
										pUSAPMbuf[x+1] = APRSCommPort[0];
										WriteFile(hFile, pUSAPMbuf, fileSize, &dwBytesWritten, NULL);
									}
									else
									{//old port number was 2 bytes
										WriteFile(hFile, pUSAPMbuf, x+1, &dwBytesWritten, NULL);
										WriteFile(hFile, &APRSCommPort[0], 1, &dwBytesWritten, NULL);
										WriteFile(hFile, &pUSAPMbuf[x+3], fileSize-x-3, &dwBytesWritten, NULL);
									}
								}
								else//if (APRSCommPort[1] != 0)
								{//new port number is 2 bytes
									if (pUSAPMbuf[x+2] != '\r')
									{//old port number was 2 bytes
										*(WORD*)&pUSAPMbuf[x+1] = *(WORD*)&APRSCommPort[0];
										WriteFile(hFile, pUSAPMbuf, fileSize, &dwBytesWritten, NULL);
									}
									else
									{//old port number was 1 byte
										WriteFile(hFile, pUSAPMbuf, x+1, &dwBytesWritten, NULL);
										WriteFile(hFile, &APRSCommPort[0], 2, &dwBytesWritten, NULL);
										WriteFile(hFile, &pUSAPMbuf[x+2], fileSize-x-2, &dwBytesWritten, NULL);
									}
								}
*/
								CloseHandle(hFile);
								break;
							}
						}
					}
					if (x == fileSize)//not found
					{
						WriteFile(hFile, APRSCOM, 13, &dwBytesWritten, NULL);
						if (APRSCommPort[1] == 0) x = 1; else x = 2;
						WriteFile(hFile, APRSCommPort, x, &dwBytesWritten, NULL);
						WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);
						CloseHandle(hFile);
					}
					free(pUSAPMbuf);
				}
			}
			break;

		case ID_APRS_BAUD_4800:
			APRSBaud = 4800;
			ChangeAPRSBaud(ID_APRS_BAUD_4800);
			break;

		case ID_APRS_BAUD_9600:
			APRSBaud = 9600;
			ChangeAPRSBaud(ID_APRS_BAUD_9600);
			break;

		case ID_APRS_BAUD_19200:
			APRSBaud = 19200;
			ChangeAPRSBaud(ID_APRS_BAUD_19200);
			break;

		case ID_APRS_BAUD_38400:
			APRSBaud = 38400;
			ChangeAPRSBaud(ID_APRS_BAUD_38400);
			break;

		case ID_APRS_BAUD_57600:
			APRSBaud = 57600;
			ChangeAPRSBaud(ID_APRS_BAUD_57600);
			break;

		case ID_APRS_BAUD_115200:
			APRSBaud = 115200;
			ChangeAPRSBaud(ID_APRS_BAUD_115200);
			break;
/*
		case ID_APRS_TRANSLATEKISSDATA:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_TRANSLATEKISSDATA, MF_BYCOMMAND))
			{
				CheckMenuItem(hMenu, ID_APRS_TRANSLATEKISSDATA, MF_CHECKED);
				kiss = TRUE;
				FillMYCALLUNPROTOBTEXTKISS();
				if ((inaprs) && (transmitto != TRANSMITNONE))
				{
					WriteFile(hAPRSComm, Kiss, KissLen, &dwBytesWritten, NULL);
					WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
				}
			}
			else
			{
				CheckMenuItem(hMenu, ID_APRS_TRANSLATEKISSDATA, MF_UNCHECKED);
				kiss = FALSE;
			}
			break;
*/

		case ID_APRS_SETUPCOMM_SERVERIPPORT:
//			DialogBox(hInst, "SERVER", hwnd, LocalServerProc);
			MessageBox(hwnd, "This is no longer necessary.\nWhen -Act as a Server is selected,\nthe port will be 1448.", "", MB_OK);
			break;

		case ID_APRS_RECEIVED_DATA:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_RECEIVED_DATA, MF_BYCOMMAND))
			{
				if ((gettinginternet) || (gettingsaved))
				{
					MessageBox(hwnd, Simultaneously, "Sorry...", MB_OK);
					break;
				}
				gettingreceived = TRUE;
				aprsimulate = FALSE;
			}
aprs:		if (inaprs == FALSE)
			{
				msgPtr = 0;
				stationPtr = 0;
				for (x = 0; x < 10240; x += 4)
					*(DWORD*)&Stations[x] = 0;
				NumOfStations = 0;
				if ((debug == FALSE) && (aprsimulate))
				{//normal method - read .dta file instead of .txt file
					ofn5.lpstrFilter = " APRS log??.dta\0""APRS log??.dta\0\0";
					ofn5.lpstrFile = APRStxt;//full filename
					ofn5.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
					ofn5.lpstrTitle = NULL;//title bar
					ofn5.lpstrDefExt = NULL;
					if (GetOpenFileName(&ofn5))
					{
						int Aprsize;

						hAPRSFile = CreateFile(APRStxt, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
						Aprsi = GetFileSize(hAPRSFile, NULL);
							Aprsize = 100;
						Aprsi /= Aprsize;
						for (x = 0, y = 0; x < Aprsi; x++)
						{
							ReadFile(hAPRSFile, &Aprs[x], Aprsize, &dwBytesRead, NULL);
							for (w = 0; w < x; w++)
							{
								for (z = 0; Aprs[x].Call[z] != 0; z++)
									if (Aprs[w].Call[z] != Aprs[x].Call[z])
										break;
								if ((Aprs[w].Call[z] == 0) && (Aprs[x].Call[z] == 0))
									break;//found station
							}
							if (w == x)
							{
								for (z = 0; (Aprs[x].Call[z] != 0) && (y < 10240); y++, z++)
									Stations[y] = Aprs[x].Call[z];
/*//don't show time here if saved data
								Stations[y++] = TAB;
								Stations[y++] = (Aprs[x].Time / 1000) + '0';
								Stations[y++] = ((Aprs[x].Time % 1000) / 100) + '0';
								Stations[y++] = ':';
								Stations[y++] = ((Aprs[x].Time % 100) / 10) + '0';
								Stations[y++] = (Aprs[x].Time % 10) + '0';
								Stations[y++] = ':';
								Stations[y++] = '0';
								Stations[y++] = '0';
								Stations[y++] = 'z';
*/
								if (y < 10240)
								{
									Stations[y++] = 0;
									NumOfStations++;
								}
							}
						}
						stationPtr = y;
						CloseHandle(hAPRSFile);
						aprs = TRUE;
					}
					else
					{
						CheckMenuItem(hMenu, ID_APRS_SAVED_DATA, MF_UNCHECKED);
						gettingsaved = aprsimulate = FALSE;
						aprsi = Aprsi = aprs = 0;//FALSE
					}
					InvalidateRect(hwnd, &rect, FALSE);
					break;//done
				}
				if ((aprsimulate) || ((APRSBaud != 0) && (APRSCommPort[0] != 0)))
				{
					if (aprsimulate == FALSE)
						inaprs = TRUE;
					aprsi = Aprsi = 0;
					aprs = FALSE;
//					tnc = TRUE;
					toHwndComm = 0;
					for (y = 0; y < MAXAPRS; y++)
					{//initialize
						Aprs[y].UTMN = 0;
						Aprs[y].DescOrWx[0] = 0;
						Aprs[y].Status[0] = 0;
						Aprs[y].RedDot = 0;
					}
					if (kiss)
					{//initialize:
						kPtr = KISSEND;
						gotfesc = FALSE;
					}

					if (!aprsimulate)
					{
						tnc = TRUE;
						CheckMenuItem(hMenu, ID_APRS_RECEIVED_DATA, MF_CHECKED);
						if (hAPRSComm != INVALID_HANDLE_VALUE)
						{//just in case
							CloseHandle(hAPRSComm);
							hAPRSComm = INVALID_HANDLE_VALUE;
						}
						if (!aprsimulate)
							GetAPRSCommHandle();
						FillMYCALLUNPROTOBTEXTKISS();
//						hwndAPRSDlg = CreateDialog(hInst, "APRSEDIT", hwnd, APRSEditProc);
						firsttx = TRUE;

						ResetEvent(hAPRSEvent);
						//**********************
						hAPRSThread = _beginthreadex(NULL, 0, APRSCommThread, NULL, 0, &idThread14);
						Sleep(500);
						//**********************
					}
					else//if (aprsimulate) - for debugging
					{
						ofn5.lpstrFilter = " APRS log??.txt\0""APRS log??.txt\0\0";
						ofn5.lpstrFile = APRStxt;//full filename
						ofn5.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
						ofn5.lpstrTitle = NULL;//title bar
						ofn5.lpstrDefExt = NULL;
						if (GetOpenFileName(&ofn5))
						{
							ResetEvent(hAPRSEvent);
							hAPRSThread = _beginthreadex(NULL, 0, APRSCommThread, NULL, 0, &idThread14);
							Sleep(500);
						}
					}
				}
				else
				{
					MessageBox(hwnd, "TNC Baud and/or\nComm Port to TNC\nisn't set.", ERROR, MB_OK);
					CheckMenuItem(hMenu, ID_APRS_RECEIVED_DATA, MF_UNCHECKED);
					inaprs = FALSE;
				}
			}
			else//if (inaprs)
			{
				gettingreceived = FALSE;
				CheckMenuItem(hMenu, ID_APRS_RECEIVED_DATA, MF_UNCHECKED);
				DestroyWindow(hwndAPRSDlg);
				hwndAPRSDlg = NULL;
				DestroyWindow(hwndStationsDlg);
				hwndStationsDlg = NULL;
				DestroyWindow(hwndStationInfoDlg);
				hwndStationInfoDlg = NULL;
				DestroyWindow(hwndMessageDlg);
				hwndMessageDlg = NULL;
				if (hAPRSThread)
				{
					if (kiss)
					{//first get out of KISS
//						SendMessage(hwnd, WM_COMMAND, ID_APRS_TRANSLATEKISSDATA, 0);
//						CheckMenuItem(hMenu, ID_APRS_TRANSLATEKISSDATA, MF_UNCHECKED);
						WriteFile(hAPRSComm, "\xC0\xFF\xC0", 3, &dwBytesWritten, NULL);
						WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
					}
					WriteFile(hAPRSComm, Shutdown, 14, &dwBytesWritten, NULL);
					WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
					shutitdown = TRUE;
					break;//doesn't shut it down if no radio
				}
				tnc = inaprs = 0;
				if ((!gettinginternet) && (!gettingsaved))
				{
					aprsi = Aprsi = aprs = 0;//FALSE
					InvalidateRect(hwnd, &rect, FALSE);
				}
			}
			break;

		case ID_APRS_TRANSMISSIONS:
			if (inaprs)
			{
				if (hwndComm)
					DestroyWindow(hwndAPRSDlg);
				FillMYCALLUNPROTOBTEXTKISS();
				hwndAPRSDlg = CreateDialog(hInst, "APRSEDIT", hwnd, APRSEditProc);
			}
			break;

		case ID_APRS_POSITION_SETUP:
			if (DialogBox(hInst, "APRS", hwnd, APRSProc))
			{
				hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{//get USAPM.ini data
					if (fileSize = GetFileSize(hFile, NULL))
					{
						pUSAPMbufIn = (char*)malloc(fileSize+1000);
						ReadFile(hFile, pUSAPMbufIn, fileSize, &dwBytesRead, NULL);
						CloseHandle(hFile);
						mycallnotfound = homelatlonnotfound = transmittonotfound = homesymbolnotfound = gpssymbolnotfound = destinationnotfound = commentnotfound = beaconnotfound = sbnotfound = compressnotfound = TRUE;
						for (x = 0; x < (int)fileSize; x++)
						{
							if (pUSAPMbufIn[x] == '=')
							{
								if ((pUSAPMbufIn[x-6] == 'M') && (pUSAPMbufIn[x-5] == 'y') && (pUSAPMbufIn[x-4] == 'C') && (pUSAPMbufIn[x-3] == 'a'))
								{//MyCall=
									if (mycallnotfound)
									{
										mycallnotfound = FALSE;
										fileSize = AddtoUSAPMini(MyCall);
									}
								}
								if ((pUSAPMbufIn[x-10] == 'H') && (pUSAPMbufIn[x-9] == 'o') && (pUSAPMbufIn[x-6] == 'L') && (pUSAPMbufIn[x-5] == 'a'))
								{//HomeLatLon=
									if (HomeLatLon[0] && (homelatlonnotfound))
									{
										homelatlonnotfound = FALSE;
										fileSize = AddtoUSAPMini(HomeLatLon);
									}
								}
								if ((pUSAPMbufIn[x-10] == 'T') && (pUSAPMbufIn[x-9] == 'r') && (pUSAPMbufIn[x-4] == 'i') && (pUSAPMbufIn[x-3] == 't'))
								{//TransmitTo=
									if (transmittonotfound)
									{
										transmittonotfound = FALSE;
										if (transmitto == TRANSMITHOME)
											fileSize = AddtoUSAPMini(Home);
										else if (transmitto == TRANSMITGPS)
											fileSize = AddtoUSAPMini(GPS);
										else if (transmitto == TRANSMITNONE)
											fileSize = AddtoUSAPMini(None);
									}
								}
								if ((pUSAPMbufIn[x-10] == 'H') && (pUSAPMbufIn[x-6] == 'S') && (pUSAPMbufIn[x-5] == 'y') && (pUSAPMbufIn[x-4] == 'm'))
								{//"HomeSymbol="
									if (HomeSymbol[0] && (homesymbolnotfound))
									{
										homesymbolnotfound = FALSE;
										fileSize = AddtoUSAPMini(HomeSymbol);
									}
								}
								if ((pUSAPMbufIn[x-9] == 'G') && (pUSAPMbufIn[x-8] == 'P') && (pUSAPMbufIn[x-7] == 'S') && (pUSAPMbufIn[x-6] == 'S'))
								{//"GPSSymbol="
									if (GPSSymbol[0] && (gpssymbolnotfound))
									{
										gpssymbolnotfound = FALSE;
										fileSize = AddtoUSAPMini(GPSSymbol);
									}
								}
								if ((pUSAPMbufIn[x-11] == 'D') && (pUSAPMbufIn[x-10] == 'e') && (pUSAPMbufIn[x-5] == 'a') && (pUSAPMbufIn[x-4] == 't'))
								{//"Destination="
									if (Destination[0] && (destinationnotfound))
									{
										destinationnotfound = FALSE;
										fileSize = AddtoUSAPMini(Destination);
									}
								}
								if ((pUSAPMbufIn[x-8] == '\n') && (pUSAPMbufIn[x-7] == 'C') && (pUSAPMbufIn[x-6] == 'o') && (pUSAPMbufIn[x-2] == 'n') && (pUSAPMbufIn[x-1] == 't'))
								{//"Comment="
									if (Comment[0] && (commentnotfound))
									{
										commentnotfound = FALSE;
										fileSize = AddtoUSAPMini(Comment);
									}
								}
								if ((pUSAPMbufIn[x-6] == 'B') && (pUSAPMbufIn[x-5] == 'E') && (pUSAPMbufIn[x-4] == 'A'))
								{//"BEACON="
									if (Beacon[0] && (beaconnotfound))
									{
										beaconnotfound = FALSE;
										fileSize = AddtoUSAPMini(Beacon);
									}
								}
								if ((pUSAPMbufIn[x-9] == 'B') && (pUSAPMbufIn[x-14] == 'S'))
								{//"SmartBeaconing="
									sbnotfound = FALSE;
									if (smartbeaconing)
									{
										pUSAPMbufIn[x+1] = 'Y';
										pUSAPMbufIn[x+2] = 'E';
										pUSAPMbufIn[x+3] = 'S';
									}
									else
									{
										pUSAPMbufIn[x+1] = 'N';
										pUSAPMbufIn[x+2] = 'O';
										pUSAPMbufIn[x+3] = ' ';
									}
								}
								if ((pUSAPMbufIn[x-10] == 'C') && (pUSAPMbufIn[x-9] == 'o') && (pUSAPMbufIn[x-8] == 'm') && (pUSAPMbufIn[x-7] == 'p'))
								{//"Compressit="
									compressnotfound = FALSE;
									if (compressit)
									{
										pUSAPMbufIn[x+1] = 'Y';
										pUSAPMbufIn[x+2] = 'E';
										pUSAPMbufIn[x+3] = 'S';
									}
									else
									{
										pUSAPMbufIn[x+1] = 'N';
										pUSAPMbufIn[x+2] = 'O';
										pUSAPMbufIn[x+3] = ' ';
									}
								}
							}
						}
						if (mycallnotfound)
						{
							for (x = fileSize, y = 0; APRSMyCall[y] != 0; x++, y++)
								pUSAPMbufIn[x] = APRSMyCall[y];
							for (y = 0; MyCall[y] != 0; x++, y++)
								pUSAPMbufIn[x] = MyCall[y];
							pUSAPMbufIn[x++] = '\r';
							pUSAPMbufIn[x++] = '\n';
							fileSize = x;
						}
						if ((HomeLatLon[0]) && (homelatlonnotfound))
						{
							for (x = fileSize, y = 0; APRSHomeLatLon[y] != 0; x++, y++)
								pUSAPMbufIn[x] = APRSHomeLatLon[y];
							for (y = 0; HomeLatLon[y] != 0; x++, y++)
								pUSAPMbufIn[x] = HomeLatLon[y];
							pUSAPMbufIn[x++] = '\r';
							pUSAPMbufIn[x++] = '\n';
							fileSize = x;
						}
						if (transmittonotfound)
						{
							for (x = fileSize, y = 0; APRSTransmitTo[y] != 0; x++, y++)
								pUSAPMbufIn[x] = APRSTransmitTo[y];
							if (transmitto == TRANSMITHOME)
								for (y = 0; Home[y] != 0; x++, y++)
									pUSAPMbufIn[x] = Home[y];
							else if (transmitto == TRANSMITGPS)
								for (y = 0; GPS[y] != 0; x++, y++)
									pUSAPMbufIn[x] = GPS[y];
							else if (transmitto == TRANSMITNONE)
								for (y = 0; GPS[y] != 0; x++, y++)
									pUSAPMbufIn[x] = None[y];
							pUSAPMbufIn[x++] = '\r';
							pUSAPMbufIn[x++] = '\n';
							fileSize = x;
						}
						if ((HomeSymbol[0]) && (homesymbolnotfound))
						{
							for (x = fileSize, y = 0; APRSHomeSymbol[y] != 0; x++, y++)
								pUSAPMbufIn[x] = APRSHomeSymbol[y];
							for (y = 0; HomeSymbol[y] != 0; x++, y++)
								pUSAPMbufIn[x] = HomeSymbol[y];
							pUSAPMbufIn[x++] = '\r';
							pUSAPMbufIn[x++] = '\n';
							fileSize = x;
						}
						if ((GPSSymbol[0]) && (gpssymbolnotfound))
						{
							for (x = fileSize, y = 0; APRSGPSSymbol[y] != 0; x++, y++)
								pUSAPMbufIn[x] = APRSGPSSymbol[y];
							for (y = 0; GPSSymbol[y] != 0; x++, y++)
								pUSAPMbufIn[x] = GPSSymbol[y];
							pUSAPMbufIn[x++] = '\r';
							pUSAPMbufIn[x++] = '\n';
							fileSize = x;
						}
						if ((Destination[0]) && (destinationnotfound))
						{
							for (x = fileSize, y = 0; APRSDestination[y] != 0; x++, y++)
								pUSAPMbufIn[x] = APRSDestination[y];
							for (y = 0; Destination[y] != 0; x++, y++)
								pUSAPMbufIn[x] = Destination[y];
							pUSAPMbufIn[x++] = '\r';
							pUSAPMbufIn[x++] = '\n';
							fileSize = x;
						}
						if ((Comment[0]) && (commentnotfound))
						{
							for (x = fileSize, y = 0; APRSComment[y] != 0; x++, y++)
								pUSAPMbufIn[x] = APRSComment[y];
							for (y = 0; Comment[y] != 0; x++, y++)
								pUSAPMbufIn[x] = Comment[y];
							pUSAPMbufIn[x++] = '\r';
							pUSAPMbufIn[x++] = '\n';
							fileSize = x;
						}
						if ((Beacon[0]) && (beaconnotfound))
						{
							for (x = fileSize, y = 0; APRSBeacon[y] != 0; x++, y++)
								pUSAPMbufIn[x] = APRSBeacon[y];
							for (y = 0; Beacon[y] != 0; x++, y++)
								pUSAPMbufIn[x] = Beacon[y];
							pUSAPMbufIn[x++] = '\r';
							pUSAPMbufIn[x++] = '\n';
							fileSize = x;
						}
						if (sbnotfound)
						{
							for (x = fileSize, y = 0; SB[y] != 0; x++, y++)
								pUSAPMbufIn[x] = SB[y];
							fileSize = x;
							if (smartbeaconing == FALSE)
							{
								pUSAPMbufIn[x-5] = 'N';
								pUSAPMbufIn[x-4] = 'O';
								pUSAPMbufIn[x-3] = ' ';
							}
						}
						if (compressnotfound)
						{
							for (x = fileSize, y = 0; Compressit[y] != 0; x++, y++)
								pUSAPMbufIn[x] = Compressit[y];
							fileSize = x;
							if (compressit == FALSE)
							{
								pUSAPMbufIn[x-5] = 'N';
								pUSAPMbufIn[x-4] = 'O';
								pUSAPMbufIn[x-3] = ' ';
							}
						}
						if (MyCall[0] || HomeLatLon[0] || HomeSymbol[0] || GPSSymbol[0] || Destination[0] || Comment[0])
						{
							hFile2 = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
							WriteFile(hFile2, pUSAPMbufIn, fileSize, &dwBytesWritten, NULL);
							CloseHandle(hFile2);
						}
						if (pUSAPMbufIn)
						{
							free(pUSAPMbufIn);
							pUSAPMbufIn = NULL;
						}
					}
				}
			}
			break;

		case ID_APRS_OBJECTS_MARKOBJECT:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_OBJECTS_MARKOBJECT, MF_BYCOMMAND))
			{
				if (IDOK == MessageBox(hwnd, "Click on the desired object location on the map.", "", MB_OKCANCEL))
				{ 
					CheckMenuItem(hMenu, ID_APRS_OBJECTS_MARKOBJECT, MF_CHECKED);
					markobject = TRUE;
				}
			}
			else
			{
				CheckMenuItem(hMenu, ID_APRS_OBJECTS_MARKOBJECT, MF_UNCHECKED);
				markobject = FALSE;
			}
			break;

		case ID_APRS_OBJECTS_EDITOBJECT:
			if (objectPtr == 0)
				LoadObjects();
			DialogBox(hInst, "EDITOBJECTS", hwnd, EditObjectProc);
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_APRS_OBJECTS_SHOWOBJECTS:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_OBJECTS_SHOWOBJECTS, MF_BYCOMMAND))
			{
				if (objectPtr == 0)
					LoadObjects();
				if (objectPtr)
				{
					CheckMenuItem(hMenu, ID_APRS_OBJECTS_SHOWOBJECTS, MF_CHECKED);
					gotsymbol = TRUE;
					InvalidateRect(hwnd, &rect, FALSE);
				}
			}
			else
			{
				CheckMenuItem(hMenu, ID_APRS_OBJECTS_SHOWOBJECTS, MF_UNCHECKED);
				gotsymbol = FALSE;
				InvalidateRect(hwnd, &rect, FALSE);
			}
			break;

		case ID_APRS_STATIONS:
			hwndStationsDlg = CreateDialog(hInst, "STATIONS", hwnd, StationsProc);
			break;

		case ID_APRS_EDITMESSAGE:
			if (DialogBox(hInst, "EDITMESSAGE", hwnd, EditMessageProc))
				goodmessage = TRUE;
			break;

		case ID_APRS_SHOWMESSAGES:
			hwndMessageDlg = CreateDialog(hInst, "MESSAGE", hwnd, MessageProc);
			break;

		case ID_APRS_TACTICALCALLSIGNS:
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_APRS_TACTICALCALLSIGNS, MF_BYCOMMAND))
			{
				CheckMenuItem(hMenu, ID_APRS_TACTICALCALLSIGNS, MF_CHECKED);
				usetactical = TRUE;
				TacticalFileSize = 0;
				if (INVALID_HANDLE_VALUE != (hFile = CreateFile(Tactical, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)))
				{
					if (TacticalFileSize = GetFileSize(hFile, NULL))
						ReadFile(hFile, TacticalCalls, TacticalFileSize, &dwBytesRead, NULL) ;
					CloseHandle(hFile);
				}
				hwndTacticalDlg = CreateDialog(hInst, "TACTICAL", hwnd, TacticalProc);
				InvalidateRect(hwnd, &rect, FALSE);
			}
			else
			{
				CheckMenuItem(hMenu, ID_APRS_TACTICALCALLSIGNS, MF_UNCHECKED);
				usetactical = FALSE;
				SendMessage(hwndTacticalDlg, WM_COMMAND, IDOK, 0);
				InvalidateRect(hwnd, &rect, FALSE);
			}
			break;

		case ID_ZOOM_OUT:
			SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_PRIOR, 0);
			break;

		case ID_ZOOM_IN:
			SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_NEXT, 0);
			break;

		case ID_ZOOM_1METERPIXEL:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if (Zoom != 1)
			{
				UncheckZoom();
				Zoom = 1;
				PixelsPerTile = 200;
				if (MapType == PHOTO)
					MetersPerTile = 200;
				else if (MapType == TOPO)
					MetersPerTile = 800;
				else if (MapType == URBANAREA)
					MetersPerTile = 50;
				ShowZoom();
				DoZoom();
			}
			break;
		case ID_ZOOM_2METERSPIXEL:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if (Zoom != 2)
			{
				UncheckZoom();
				Zoom = 2;
				PixelsPerTile = 100;
				if (MapType == PHOTO)
					MetersPerTile = 200;
				else if (MapType == TOPO)
					MetersPerTile = 800;
				else if (MapType == URBANAREA)
					MetersPerTile = 50;
				ShowZoom();
				DoZoom();
			}
			break;
		case ID_ZOOM_4METERSPIXEL:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if (Zoom != 3)
			{
				UncheckZoom();
				Zoom = 3;
				PixelsPerTile = 50;
				if (MapType == PHOTO)
					MetersPerTile = 200;
				else if (MapType == TOPO)
					MetersPerTile = 800;
				else if (MapType == URBANAREA)
					MetersPerTile = 50;
				ShowZoom();
				DoZoom();
			}
			break;
		case ID_ZOOM_8METERSPIXEL://zoomed from 1 MeterPerPixel
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if (Zoom != 4)
			{
				UncheckZoom();
				Zoom = 4;
				PixelsPerTile = 25;
				if (MapType == PHOTO)
					MetersPerTile = 200;
				else if (MapType == TOPO)
					MetersPerTile = 800;
				else if (MapType == URBANAREA)
					MetersPerTile = 25;
				ShowZoom();
				DoZoom();
			}
			break;
		case ID_ZOOM_BIG8METERSPIXEL://8 MetersPerPixel
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if (Zoom != 5)
			{
				UncheckZoom();
				Zoom = 5;
				PixelsPerTile = 200;
				if (MapType == PHOTO)
					MetersPerTile = 1600;
				else if (MapType == TOPO)
					MetersPerTile = 12800;
				else if (MapType == URBANAREA)
					MetersPerTile = 800;
				ShowZoom();
				DoZoom();
			}
			break;
		case ID_ZOOM_16METERSPIXEL:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if (Zoom != 6)
			{
				UncheckZoom();
				Zoom = 6;
				PixelsPerTile = 100;
				if (MapType == PHOTO)
					MetersPerTile = 1600;
				else if (MapType == TOPO)
					MetersPerTile = 12800;
				else//if (MapType == URBANAREA)
					MetersPerTile = 800;
				ShowZoom();
				DoZoom();
			}
			break;
		case ID_ZOOM_32METERSPIXEL:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if (Zoom != 7)
			{
				UncheckZoom();
				Zoom = 7;
				PixelsPerTile = 50;
				if (MapType == PHOTO)
					MetersPerTile = 1600;
				else if (MapType == TOPO)
					MetersPerTile = 12800;
				else//if (MapType == URBANAREA)
					MetersPerTile = 800;
				ShowZoom();
				DoZoom();
			}
			break;

		case ID_ZOOM_64METERSPIXEL:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (Zoom != 8)
			{
				PrevMetersPerTile = MetersPerTile;
				PrevPixelsPerTile = PixelsPerTile;
				UncheckZoom();
				Zoom = 8;
				PixelsPerTile = 25;
				if (MapType == PHOTO)
					MetersPerTile = 1600;
				else if (MapType == TOPO)
					MetersPerTile = 12800;
				else//if (MapType == PHOTO)
					MetersPerTile = 800;
				ShowZoom();
				DoZoom();
			}
			break;

		case ID_SCROLL:
			MessageBox(hwnd, "Up Arrow key scrolls up,\nDown Arrow key scrolls down,\nLeft Arrow key scrolls left,\nRight Arrow key scrolls right.\n\
\n\
Mousewheel scrolls up and down.\nMousewheel with the Ctrl key down\nscrolls left and right.\n\
\n\
If you press Ctrl-Insert, ANY\nMessage Box will be copied\nto the Windows Clipboard.", "Scrolling", MB_OK);
			break;

		case ID_TEXT_SHOWALL:
			{
				if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_TEXT_SHOWALL, MF_BYCOMMAND))
				{
					CheckMenuItem(hMenu, ID_TEXT_SHOWALL, MF_CHECKED);
					showtext = TRUE;//for WM_PAINT
				}
				else
				{
					CheckMenuItem(hMenu, ID_TEXT_SHOWALL, MF_UNCHECKED);
					showtext = FALSE;
				}
				InvalidateRect(hwnd, &rect, FALSE);
			}
			break;

		case ID_TEXT_LISTALL:
			if ((autoLoc) && (fromFlag == NOBUTTON))
			{
				fromFlag = RBUTTON;
				if (itsgarmin)
				{
					sendingStop = TRUE;
					WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = StopPVTPacket[y];
					if (tgcount > 49900) tgcount = 0;
					return 0;//ACK will call this routine again
				}
				else if (itsusb == FALSE)
				{
					autoLoc = FALSE;
					SetEvent(hEventExit);
				}
				else if (hUSBThread != 0)//if (itsusb)
				{
					SignalUSBStop();
				}
			}
			if (fromFlag != NOBUTTON)
			{
				showposition = FALSE;
				fromFlag = NOBUTTON;
				//autoLoc comes later...
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				RedDot(hwnd);
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			}
//get closest text (to highlight)
			if (yPos > 2)
			{//if not at Menu bar
				centerX = xPos;//rect.right >> 1;
				centerY = yPos;//rect.bottom >> 1;
			}
			else
			{
				centerX = rect.right >> 1;
				centerY = rect.bottom >> 1;
			}
			UTMCenterX = (centerX * MetersPerTile/PixelsPerTile) + ScreenLeft;
			UTMCenterY = ScreenTop - (centerY * MetersPerTile/PixelsPerTile);
			B = 10000000000.0;//large number
			index = -1;//flag
			for (x = 0, cur = head; cur != NULL; cur = cur->next, x++)
			{
				idistX = UTMCenterX - cur->EUTM;
				if (idistX < 1)
					idistX = -(idistX);
				idistY = UTMCenterY - cur->NUTM;
				if (idistY < 1)
					idistY = -(idistY);
				distX = (double) idistX;
				distY = (double) idistY;
				A = (int) sqrt((distX*distX) + (distY*distY));
				if (A < B)
				{
					B = A;
					index = x;
					chosen = cur;
				}
			}

			Response = DialogBox(hInst, "WAYPOINTS", hwnd, CheckTextProc);

			if (Response == EXIT)
			{
				InvalidateRect(hwnd, &rect, FALSE);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			}

			else if (Response == EDIT)
			{
				DialogBox(hInst, "GETTEXT", hwnd, EditTextProc);
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			}

			else if (Response == LINE_TO)
			{
				hdc = GetDC(hwnd);
				hPen = CreatePen(PS_SOLID, 0, 0xF0);
				hObject = SelectObject(hdc, hPen);
				MoveToEx(hdc, centerX, centerY, NULL);
				DrawLineTo(chosen->NUTM, chosen->EUTM);
				SelectObject(hdc, hObject);
				ReleaseDC(hwnd, hdc);
				DeleteObject(hPen);
			}

			else if (Response == DELEET)
			{
				if (head != NULL)
				{
					if (chosen != head)
					{
						for (cur = head; (cur->next != chosen) && (cur != NULL); cur = cur->next)
							;
						cur->next = chosen->next;
						free(chosen);
						chosen = cur;
					}
					else
					{
						head = chosen->next;
						free(chosen);
					}
					newText = TRUE;
				}
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			}

			else//GoTo
			{
				rowOffset = ((chosen->NUTM / MetersPerTile) - (TilesDown/2));//center it
				colOffset = ((chosen->EUTM / MetersPerTile) - ((TilesAcross-1)/2));//center it
				SendMessage(hwnd, WM_USER, 0, 0);
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			}
			autoLoc = FALSE;
			break;

		case ID_TEXT_ENTER:
			MessageBox(hwnd, "Hold the Shift key down\nwhile moving the mouse", "Entering Text", MB_OK);
			break;

		case ID_ROUTE_SHOW:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_ROUTE_SHOW, MF_BYCOMMAND))
			{
getroute:		if (FALSE != GetOpenFileName(&ofn3))
				{
					hFile3 = NULL;
					x = ofn3.nFileExtension;
					if  (((FullRoutes[x] & 0xDF) != 'T') && ((FullRoutes[x+1] & 0xDF) != 'X') && ((FullRoutes[x+2] & 0xDF) != 'T'))
						goto getroute;//if it's not a .txt file
					pr = NULL;
					showingroute = FALSE;
					hFile3 = CreateFile(FullRoutes, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile3 != INVALID_HANDLE_VALUE)
					{
						if (fileSize = GetFileSize(hFile3, NULL))
						{
							BOOL samezone;

							Acres[0] = 0;
//							pRoute = (struct Route*) malloc(MAX_PTR * sizeof(struct Route));
							pRoute = (struct Route*)VirtualAlloc(NULL, (fileSize/19)*12, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
							pr = pRoute;
//							pRoutes = (char*) malloc(fileSize);
							pRoutes = (char*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
							prs = pRoutes;
							ReadFile(hFile3, pRoutes, fileSize, &dwBytesRead, NULL);
							if ((pRoutes[2] != ',') || (pRoutes[0] < '0') || (pRoutes[0] > '2'))
							{//if not 10,4280273,607830
								MessageBox(hwnd, "That's not a route file.", NULL, MB_OK);
								CloseHandle(hFile3);
//								free(prs);
								VirtualFree(prs, 0, MEM_RELEASE);
								prs = NULL;
//								free(pr);
								VirtualFree(pr, 0, MEM_RELEASE);
								pr = NULL;
								return 0;
							}
							for (x = 0, y = 0; x < (int)fileSize; y++)
							{//"10,4140653,578149\r\n"
								for (z = 0; pRoutes[x] != ','; x++)
									z = (z * 10) + (pRoutes[x] - '0');
								pRoute[y].UTMZone = z;
								x++;//past ','
								for (z = 0; pRoutes[x] != ','; x++)
									z = (z * 10) + (pRoutes[x] - '0');
								pRoute[y].NUTM = z;
								x++;//past ','
								for (z = 0; (pRoutes[x] != '\r') && (x < (int)fileSize); x++)
									z = (z * 10) + (pRoutes[x] - '0');
								pRoute[y].EUTM = z;
								x += 2;//past \r\n
								if ((pRoute[y].NUTM < 1975000) || (pRoute[y].NUTM > 7925000) || (pRoute[y].EUTM < 150000) || (pRoute[y].EUTM > 999999) || (pRoute[y].UTMZone > 20) || (pRoute[y].UTMZone < 3))
								{
									z = sprintf(Error, "Line %i's coordinates are outside the USA", y+1);
									MessageBox(hwnd, Error, Routes, MB_OK);
									CloseHandle(hFile3);
									hFile3 = NULL;
//									free(prs);
									VirtualFree(prs, 0, MEM_RELEASE);
									prs = NULL;
//									free(pr);
									VirtualFree(pr, 0, MEM_RELEASE);
									pr = NULL;
									return 0;
								}
							}
							if (y <= 1)
							{
								MessageBox(hwnd, "There was only 0 or 1 point in that route", ERROR, MB_OK);
								CloseHandle(hFile3);
								hFile3 = NULL;
//								free(prs);
								VirtualFree(prs, 0, MEM_RELEASE);
								prs = NULL;
//								free(pr);
								VirtualFree(pr, 0, MEM_RELEASE);
								pr = NULL;
								return 0;
							}
							numofRoutes = y;
							y--;//to last route point

							if ((pRoute[0].UTMZone == pRoute[y].UTMZone)
							 && (pRoute[0].NUTM == pRoute[y].NUTM)
							 && (pRoute[0].EUTM == pRoute[y].EUTM))
							{//if a polygon
								int i, j;
								double acres, area = 0, n0, e0, n1, e1;

								for (i = 0; i < y; i++)
								{
									j = (i + 1) % y;
									e0 = (double)pRoute[i].EUTM;
									n0 = (double)pRoute[i].NUTM;
									e1 = (double)pRoute[j].EUTM;
									n1 = (double)pRoute[j].NUTM;
									area += e0 * n1;//pRoute[i].EUTM * pRoute[j].NUTM;
									area -= n0 * e1;//pRoute[i].NUTM * pRoute[j].EUTM;
								}
								area /= 2.0;
								if (area < 0)
									area = -area;
								acres = area * 0.00024710538146716533;
								sprintf(Acres, "%.6f", acres);
								//acres = area / 4046.856422;
								//1 foot = 0.3048 meters
								//1 acre = 4046.856422 square meters
								//10000 square meters = 0.24710538146716533 acres
							}
							showingroute = TRUE;
							CheckMenuItem(hMenu, ID_ROUTE_SHOW, MF_CHECKED);
							if (pRoute[0].UTMZone == UTMZone)
							{
								BeginY = pRoute[0].NUTM / MetersPerTile;
								BeginX = pRoute[0].EUTM / MetersPerTile;
								rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
								colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
								fromOpen = TRUE;
								SendMessage(hwnd, WM_USER, 0, 0);
							}
							else
							{
								UTMNorthing = pRoute[0].NUTM;
								UTMEasting = pRoute[0].EUTM;
								UTMZone = pRoute[0].UTMZone;
								notfromroute = FALSE;
								ChangeZone(UTMZone, 2);//show route
								notfromroute = TRUE;
								BeginX = UTMEasting / MetersPerTile;
								BeginY = UTMNorthing / MetersPerTile;
								_itoa(BeginX, X, 10);
								_itoa(BeginY, Y, 10);
								Z[0] = (UTMZone / 10) + '0';
								Z[1] = (UTMZone % 10) + '0';
								fromOpen = TRUE;
								Waypoints[0] = 0;
								SendMessage(hwnd, WM_USER4, 0, 0);
							}
							samezone = TRUE;
							for (d = 0.0, z = 1; z < numofRoutes; z++)
							{
								if (pRoute[z].UTMZone == pRoute[z-1].UTMZone)
								{
									v = pRoute[z].EUTM;
									w = pRoute[z-1].EUTM;
									if (v > w)
										xleg = v - w;
									else
										xleg = w - v;
									v = pRoute[z].NUTM;
									w = pRoute[z-1].NUTM;
									if (v > w)
										yleg = v - w;
									else
										yleg = w - v;
									legsquared = xleg*xleg;
									legsquared += yleg*yleg;
									d += sqrt(legsquared);
								}
								else
								{
									samezone = FALSE;
									CloseHandle(hFile3);
									hFile3 = NULL;
									break;
								}
							}
							if (samezone)
							{
								if (d < 304.8)//1,000 ft
								{
									d /= 0.3048;//convert to feet
									feet = TRUE;
								}
								else
								{
									d *= 0.000621371;//convert to miles
									feet = FALSE;
								}
								x = sprintf(RouteDist, "%.2f", d);
								if (feet)
									sprintf(&RouteDist[x], " feet");
								else
									sprintf(&RouteDist[x], " miles");
								MessageBox(hwnd, RouteDist, "Route Length:", MB_OK);
								if (Acres[0] != 0)
									MessageBox(hwnd, Acres, "Acres:", MB_OK);
							}
						}//end of if (fileSize
						if (hFile3 != NULL)
							CloseHandle(hFile3);
					}//end of if (hFile3
				}//end of GetOpenFileName
			}//end of if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_ROUTE_SHOW, MF_BYCOMMAND))
			else
			{
				if (pr != NULL)
				{
//					free(pr);
					VirtualFree(pr, 0, MEM_RELEASE);
					pr = NULL;
				}
				if (prs != NULL)
				{
					VirtualFree(prs, 0, MEM_RELEASE);
					prs = NULL;
				}
				CheckMenuItem(hMenu, ID_ROUTE_SHOW, MF_UNCHECKED);
				showingroute = FALSE;
				InvalidateRect(hwnd, &rect, FALSE);
			}
			break;

		case ID_ROUTE_CREATE:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (drawing == FALSE)
			{
				drawing = TRUE;//to create the route
				routeDist = 0.0;
				for (x = 0; x < MAX_PTR; x++)
					totalRouteDist[x] = 0.0;
//				pRoute = (struct Route*) malloc(MAX_PTR * sizeof(struct Route));
				pRoute = (struct Route*)VirtualAlloc(NULL, MAX_PTR * sizeof(struct Route), MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
				pr = pRoute;
				ptr = 0;
				RoutePoint = 0;
				if (0 != _stricmp(Key, TheKey))//if not paid for
					MessageBox(hwnd, CreateRoute, "Create a Route", MB_OK);
			}
			break;

		case ID_ROUTETOTRACKS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (FALSE != GetOpenFileName(&ofn3))
			{
				char *pIn, *pOut;
				pIn = pOut = NULL;
				hFile3 = CreateFile(ofn3.lpstrFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile3 != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile3, NULL))
					{
						pIn = (char*)malloc(fileSize);
						ReadFile(hFile3, pIn, fileSize, &dwBytesRead, NULL);
					}
					CloseHandle(hFile3);
					if ((pIn[2] != ',') && (pIn[10] != ',') && (pIn[17] != '\r'))
					{
						MessageBox(hwnd, "That doesn't seem to be a route file.", ERROR, MB_OK);
						if (pIn != NULL)
							free(pIn);
						return 0;
					}
//					for (x = 0; (ofn3.lpstrFile[x] != '.') && (ofn3.lpstrFile[x] != 0); x++)
//						TrackName[x] = ofn3.lpstrFile[x];
					for (x = 0, y = 0; CurrentTrackDir[y] != 0; x++, y++)
						TrackName[x] = CurrentTrackDir[y];
					for (y = 0; (ofn3.lpstrFile[y] != '.') && (ofn3.lpstrFile[y] != 0); x++, y++)
						TrackName[x] = ofn3.lpstrFileTitle[y];
					TrackName[x++] = '.';
					TrackName[x++] = 'c';
					TrackName[x++] = 's';
					TrackName[x++] = 'v';
					TrackName[x] = 0;
					hFile = FindFirstFile(TrackName, &fd);
					if (hFile != INVALID_HANDLE_VALUE)
					{//if file already exists
						FindClose(hFile);
						ofn.Flags |= OFN_OVERWRITEPROMPT;
						ofn.lpstrInitialDir = CurrentTrackDir;
						if (FALSE != GetSaveFileName(&ofn))
						{//get a new TrackName
							for (x = 0; ofn.lpstrFile[x] != 0; x++)
								TrackName[x] = ofn.lpstrFile[x];
							TrackName[x] = 0;
							ofn.Flags &= OFN_OVERWRITEPROMPT;
						}
						else
						{
							ofn.Flags &= OFN_OVERWRITEPROMPT;
							if (pIn != NULL)
								free(pIn);
							return 0;
						}
						ofn.lpstrInitialDir = CurrentDir;
					}
					pOut = (char*)malloc(fileSize*20);
					for (y = 0; PreTracks[y] != 0; y++)
						pOut[y] = PreTracks[y];
					pOut[y++] = ',';
					for (x = 0; (x < (int)fileSize); x++)
					{
						if (pIn[x] == '\r')
						{
							for (z = 0; PseudoTrack[z] != 0; z++)
								pOut[y++] = PseudoTrack[z];
							x += 2;//past \r\n
							if (x >= (int)fileSize)
								break;
 							pOut[y++] = ',';
						}
						pOut[y++] = pIn[x];
					}
					hFile3 = CreateFile(TrackName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
					if (hFile3 != INVALID_HANDLE_VALUE)
					{
						WriteFile(hFile3, pOut, y, &dwBytesWritten, NULL);
						CloseHandle(hFile3);
						MessageBox(hwnd, TrackName, "Created track file:", MB_OK);
					}
					if (pIn != NULL)
						free(pIn);
					if (pOut != NULL)
						free(pOut);
				}
			}
			break;

		case ID_GPS_ROUTE_APPENDTOTRACKS:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (FALSE != GetOpenFileName(&ofn3))
			{
				char *pIn, *pOut;
				pIn = pOut = NULL;
				hFile3 = CreateFile(ofn3.lpstrFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile3 != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile3, NULL))
					{
						pIn = (char*)malloc(fileSize);
						ReadFile(hFile3, pIn, fileSize, &dwBytesRead, NULL);
					}
					CloseHandle(hFile3);
					if ((pIn[2] != ',') && (pIn[10] != ',') && (pIn[17] != '\r'))
					{
						MessageBox(hwnd, "That doesn't seem to be a route file.", ERROR, MB_OK);
						if (pIn != NULL)
							free(pIn);
						return 0;
					}
					pOut = (char*)malloc(fileSize*20);
					for (y = 0; Noo[y] != 0; y++)
						pOut[y] = Noo[y];
					for (x = 0; (x < (int)fileSize); x++)
					{
						if (pIn[x] == '\r')
						{
							for (z = 0; PseudoTrack[z] != 0; z++)
								pOut[y++] = PseudoTrack[z];
							x += 2;//past \r\n
							if (x >= (int)fileSize)
								break;
 							pOut[y++] = ',';
						}
						pOut[y++] = pIn[x];
					}
					ofn.lpstrTitle = "Append To";
					ofn.lpstrInitialDir   = CurrentTrackDir;
					if (FALSE != GetSaveFileName(&ofn))
					{
						hFile3 = CreateFile(ofn.lpstrFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
						if (hFile3 != INVALID_HANDLE_VALUE)
						{
							SetFilePointer(hFile3, 0, NULL, FILE_END);
							WriteFile(hFile3, pOut, y, &dwBytesWritten, NULL);
							CloseHandle(hFile3);
							MessageBox(hwnd, ofn.lpstrFile, "Appended to track file:", MB_OK);
						}
					}
					ofn.lpstrInitialDir   = CurrentDir;
					ofn.lpstrTitle = NULL;
					if (pIn != NULL)
						free(pIn);
					if (pOut != NULL)
						free(pOut);
				}
			}
			break;

		case ID_WAYPOINTS_SHOW:
			SendMessage(hwnd, WM_RBUTTONDOWN, 0, 0);
			break;

		case ID_WAYPOINTS_OPENFILE:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			ofn2.lpstrFilter = "xml\0""*.xml\0""gpx\0""*.gpx\0\0";
			if (WaypointsPath[0] != 0)
				ofn2.lpstrInitialDir = WaypointsPath;
			if ((fromconvertloctoxml) || (GetOpenFileName(&ofn2)))//WaypointsFullPath filled here
			{
//				char FullPath[MAX_PATH];

				fromconvertloctoxml = FALSE;
				if (((WaypointsFullPath[ofn2.nFileExtension] & 0xDF) != 'X') && ((WaypointsFullPath[ofn2.nFileExtension+1] & 0xDF) != 'M') && ((WaypointsFullPath[ofn2.nFileExtension+2] & 0xDF) != 'L'))
				{
					if (((WaypointsFullPath[ofn2.nFileExtension] & 0xDF) != 'G') && ((WaypointsFullPath[ofn2.nFileExtension+1] & 0xDF) != 'P') && ((WaypointsFullPath[ofn2.nFileExtension+2] & 0xDF) != 'X'))
					{
						MessageBox(hwnd, "That's not an xml or gps file", ERROR, MB_OK);
						break;
					}
				}
//				for (x = 0; CurrentDir[x] != 0; x++)
//					FullPath[x] = CurrentDir[x];
//				FullPath[x++] = '\\';
//				for (y = 0; Waypoints[y] != 0; x++, y++)
//					FullPath[x] = Waypoints[y];
//				FullPath[x] = 0;

				hFile3 = CreateFile(WaypointsFullPath, GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, NULL);//Waypoints
				if (hFile3 != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile3, NULL))
					{//if it's not a new file
						CloseHandle(hFile3);
						if (newLoc)
							SaveLocs();
						if (newText)
							SaveText();
						fromOpen = TRUE;
						BeginY = rowOffset + (TilesDown/2);
						BeginX = colOffset + ((TilesAcross-1)/2);
						SendMessage(hwnd, WM_USER4, 0, 0);//load waypoints
						SendMessage(hwnd, WM_RBUTTONDOWN, 0, 0);//show waypoint list
						if (newLoc)
							SaveLocs();
						if (newText)
							SaveText();
					}//end of if (fileSize)
					else//if it's a new file
					{
						strcpy(NewLocationsFullPath, WaypointsFullPath);
						strcpy(NewLocations, Waypoints);
						CloseHandle(hFile3);
						if (WaypointArray != NULL)
							free(WaypointArray);
						WaypointArray = (char*)calloc(1,100000);
						WaypointSize = 0;
						for (x = 0; x < TOTAL_LOCS; x++)
						{
							NewLoc[x].NUTM = 0;
							NewLoc[x].EUTM = 0;
							NewLoc[x].UTMZone = 0;
							NewLoc[x].pWaypoints = NULL;//pointer to waypoint data in WaypointArray
 							NewLoc[x].Ident = NULL;//pointer to name
							NewLoc[x].Location = NULL;//pointer to cmt
							NewLoc[x].Description = NULL;//pointer to desc
							NewLoc[x].Elev = NULL;//pointer to ele
							NewLoc[x].Sym = NULL;//pointer to sym
							NewLoc[x].size = 0;
							prevDist[x] = HUNDRED_MILES;
						}
						EmptyLoc = 0;
						newLoc = TRUE;//to delete possible empty file in SaveLocs
					}
				}
				else
					MessageBox(hwnd, "isn't a waypoint file!", WaypointsFullPath, MB_OK);
			}
			ofn2.lpstrInitialDir = CurrentDir;
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_GPS_HELP:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (autoLoc == FALSE)
			{
				pGPSHelp = NULL;
				hFile = CreateFile(GPSHelp, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					if (GPSHelpSize = GetFileSize(hFile, NULL))
					{
						pGPSHelp = (char *) malloc(GPSHelpSize+1);
						if (pGPSHelp == NULL)
							MessageBox(hwnd, "OHOH", "", MB_OK);
						pGPSHelp[GPSHelpSize] = 0;
						ReadFile(hFile, pGPSHelp, GPSHelpSize, &dwBytesRead, NULL);

						hMenu3 = CreateMenu();//to override parent menu bar
						hwndGPS = CreateWindow(Instruct, "GPSHelp.txt",
							WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
							cxScreen/2-320, TitleAndMenu, (cxScreen/2 + 320)-(cxScreen/2-320), cyScreen-(cyChar*3),
							NULL, hMenu3, hInst, NULL);
						SetWindowText(hwndInstr, pGPSHelp);
						SetFocus(hwndInstr);
					}
					CloseHandle (hFile);
				}
				else
					MessageBox(hwnd, NoGPSFile, NULL, MB_OK);
			}
			break;

		case ID_GPS_COMMPORT:
			NewComm[7] = RegValue[3];
			NewComm[8] = RegValue[4];
			if (DialogBox(hInst, "COMMPORT", hwnd, CommPortProc))
			{
				NewComm[7] = CommPort[0];
				NewComm[8] = CommPort[1];
				if (((NewComm[7] == '0') || (NewComm[7] == ' ')) && ((NewComm[1] >= '0') && NewComm[1] <= '9'))
				{//change "05" or " 5" to "5"
					NewComm[7] = NewComm[8];
					NewComm[8] = 0;
				}
			}
			SetRegKey(wParameter);
			break;

		case ID_GPS_PROTOCOL_GARMIN:
			itsgarmin = TRUE;
			itsusb = FALSE;
			itsexplorist = FALSE;
			ProtocolCheck1 = ID_GPS_PROTOCOL_ANYGPS;
			ProtocolCheck2 = ID_GPS_PROTOCOL_GARMINUSB;
			ProtocolCheck3 = ID_GPS_PROTOCOL_MAGELLANEXPLORIST;
			SetRegKey2(GARMIN, wParameter);
			break;

		case ID_GPS_PROTOCOL_ANYGPS://NMEA
			itsgarmin = FALSE;
			itsusb = FALSE;
			itsexplorist = FALSE;
			ProtocolCheck1 = ID_GPS_PROTOCOL_GARMIN;
			ProtocolCheck2 = ID_GPS_PROTOCOL_GARMINUSB;
			ProtocolCheck3 = ID_GPS_PROTOCOL_MAGELLANEXPLORIST;
			SetRegKey2(NMEA, wParameter);
			break;

		case ID_GPS_PROTOCOL_GARMINUSB://USB
			itsusb = TRUE;
			itsgarmin = FALSE;
			itsexplorist = FALSE;
			ProtocolCheck1 = ID_GPS_PROTOCOL_GARMIN;
			ProtocolCheck2 = ID_GPS_PROTOCOL_ANYGPS;
			ProtocolCheck3 = ID_GPS_PROTOCOL_MAGELLANEXPLORIST;
			SetRegKey2(USB, wParameter);
			break;

		case ID_GPS_PROTOCOL_MAGELLANEXPLORIST:
			itsgarmin = FALSE;
			itsusb = FALSE;
			itsexplorist = TRUE;
			ProtocolCheck1 = ID_GPS_PROTOCOL_GARMIN;
			ProtocolCheck2 = ID_GPS_PROTOCOL_ANYGPS;
			ProtocolCheck3 = ID_GPS_PROTOCOL_GARMINUSB;
			SetRegKey2(EXPL, wParameter);
			break;

		case ID_GPS_BAUD_4800:
			Baud = 4800;
			BaudUnits = ID_GPS_BAUD_4800;
			ChangeBaud();
			break;

		case ID_GPS_BAUD_9600:
			Baud = 9600;
			BaudUnits = ID_GPS_BAUD_9600;
			ChangeBaud();
			break;

		case ID_GPS_BAUD_19200:
			Baud = 19200;
			BaudUnits = ID_GPS_BAUD_19200;
			ChangeBaud();
			break;

		case ID_GPS_BAUD_38400:
			Baud = 38400;
			BaudUnits = ID_GPS_BAUD_38400;
			ChangeBaud();
			break;

		case ID_GPS_BAUD_57600:
			Baud = 57600;
			BaudUnits = ID_GPS_BAUD_57600;
			ChangeBaud();
			break;

		case ID_GPS_BAUD_115200:
			Baud = 115200;
			BaudUnits = ID_GPS_BAUD_115200;
			ChangeBaud();
			break;


		case ID_GPS_WAYPOINTS_UPLOAD:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			BadSend = 0;
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			for (LastWay = 0; LastWay < TOTAL_LOCS; LastWay++)
				if (NewLoc[LastWay].EUTM == 0)
					break;
			EmptyLoc = LastWay;
			if (onewaypoint)
				LastWay = 1;
			if (itsexplorist)
			{
				ofn5.lpstrFilter = " *.*\0""*.*\0\0";
				ofn5.lpstrFile = MeridianFullName;//full filename
				ofn5.lpstrFileTitle = MeridianName;//short filename
				ofn5.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR|OFN_CREATEPROMPT|OFN_OVERWRITEPROMPT;
				ofn5.lpstrTitle = NULL;//title bar
				ofn5.lpstrDefExt = NULL;
				if (FALSE != GetSaveFileName(&ofn5))
				{
					hFile = CreateFile(MeridianFullName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
					for (LocNum = 0; LocNum < EmptyLoc; LocNum++)
					{
						x = PrepMagellanWaypoint();
						WriteFile(hFile, &SendMagWaypoints, x, &dwBytesWritten, NULL);
					}
					WriteFile(hFile, &SendEnd, sizeof(SendEnd)-1, &dwBytesWritten, NULL);
					CloseHandle(hFile);
					MessageBox(hwnd, "hs been written in eXplorist format.", MeridianName, MB_OK);
				}
				break;
			}
			if (itsusb)
			{
				if (hUSBThread == 0)
				{
					FromUSBBuf = (BYTE*)VirtualAlloc(NULL, 1000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					*pParam = SENDWAYPOINTS;
					hUSBThread = _beginthreadex(NULL, 0, USBThread, pParam, 0, &idThread4);
				}
				else
					MessageBox(hwnd, "USB Thread is still running...", NULL, MB_OK);
				break;
			}
			BeginRecords[3] = LastWay;//number of records
			if (LastWay != 16)//if not 0x10 (DLE char)
				BeginRecords[5] = ~(27 + 2 + LastWay) + 1;//checksum (needs extra DLE if LastWay == -45)
			else
				BeginRecords2[6] = ~(27 + 2 + LastWay) + 1;//checksum (needs extra DLE if LastWay == -45)
			remainder = LastWay % 10000;
			Counting[8] = (remainder / 1000) + '0';
			Counting[9] = ((remainder % 1000) / 100) + '0';
			Counting[10] = ((remainder % 100) / 10) + '0';
			Counting[11] = (remainder % 10) + '0';
			if (RegValue[3] == '0')
			{
				MessageBox(hwnd, SelectCommPort, NULL, MB_OK);
				break;
			}
			GetCommHandle();
			if (hComm != INVALID_HANDLE_VALUE)
			{
				ResetEvent(hEventExit);
				hThread = _beginthreadex(NULL, 0, CommThread, NULL, 0, &idThread);
				Sleep(500);
				autoLoc = FALSE;
				for (x = 0; x < 9; x++)
					PreCounting[x] = Up[x];
				for (x = 0; x < 4; x++)
					Counting[x] = '0';
				for (x = 0; x < 9; x++)
					PostCounting[x] = Way[x];
				LocNum = 0;
				if (itsgarmin)
				{
					sendingWaypoints = TRUE;
					GarminFlag = GOT_ETX;
					TimerFlags.timing = TRUE;
					TimerFlags.garmintiming = TRUE;
					TimerFlags.gotprotocol = FALSE;
					TimerFlags.time = 3000;
					ResetEvent(hTimerEvent);
					_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
					Sleep(500);
					if (LastWay != 16)
						garminflag = BEGINRECORDS8;
					else
						garminflag = BEGINRECORDS9;
					tgcount = 0;
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = Pid_Product_Rqst[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &Pid_Product_Rqst, 8, &dwBytesWritten, NULL);
				}
				else//Magellan
				{
					magflag = SENDWAYPOINTS;
					TimerFlags.nmeatiming = TRUE;
					TimerFlags.gotprotocol = TRUE;
					TimerFlags.time = 6000;//was 5000 July 27, 2005
					ResetEvent(hTimerEvent);
					_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
					gotver = FALSE;
					ResetEvent(hEvent);//unsignal it
					tgcount = 0;
					for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
						ToGPS[tgcount] = GetMagellanVersion[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
					if ((gotver == FALSE) && (WaitForSingleObject(hEvent, 2000) == WAIT_TIMEOUT))//it will exit after 2 seconds or if signalled
					{
						for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
							ToGPS[tgcount] = GetMagellanVersion[x];
						if (tgcount > 49900) tgcount = 0;
						WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
					}
				}
			}
//			else
//				MessageBox(hwnd, BadCommPort, NULL, MB_OK);
			break;

		case ID_GPS_WAYPOINTS_DOWNLOAD:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			for (x = 0; x < TOTAL_LOCS; x++)
				if (NewLoc[x].EUTM == 0)
					break;
//			if (GetKeyState(VK_CONTROL) < 0)
//				simulate = TRUE;			
			EmptyLoc = x;
			if (itsexplorist)
			{
				ofn5.lpstrFilter = " *.*\0""*.*\0\0";
				ofn5.lpstrFile = MeridianFullName;//full filename
				ofn5.lpstrFileTitle = MeridianName;//short filename
				ofn5.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR|OFN_CREATEPROMPT|OFN_OVERWRITEPROMPT;
				ofn5.lpstrTitle = NULL;//title bar
				ofn5.lpstrDefExt = NULL;
				if (GetOpenFileName(&ofn5))
				{
					hFile = CreateFile(MeridianFullName, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
					if (hFile != INVALID_HANDLE_VALUE)
					{
						fileSize = GetFileSize(hFile, NULL);
						ExploristBuf = (char*)malloc(fileSize);
						ReadFile(hFile, ExploristBuf, fileSize, &dwBytesRead, NULL);
						CloseHandle(hFile);

						for (i = 0; i < fileSize; )
						{
							i = GetExploristWaypoints(i);
						}
						free(ExploristBuf);
					}
					InvalidateRect(hwnd, &rect, FALSE);
					MessageBox(hwnd, "has been copied into the existing waypoint file.", MeridianName, MB_OK);
				}
				break;
			}
			if (itsusb)
			{
				if (hUSBThread == 0)
				{
					FromUSBBuf = (BYTE*)VirtualAlloc(NULL, 1000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					*pParam = GETWAYPOINTS;
					hUSBThread = _beginthreadex(NULL, 0, USBThread, pParam, 0, &idThread4);
				}
				else
					MessageBox(hwnd, "USB Thread is still running...", NULL, MB_OK);
				break;
			}
			if (sortbyname)
				qsort(NewLoc, EmptyLoc, sizeof(NewLoc[0]), compareIdent);
			else
				qsort(NewLoc, EmptyLoc, sizeof(NewLoc[0]), compareLoc);
			if (RegValue[3] == '0')
			{
				MessageBox(hwnd, SelectCommPort, NULL, MB_OK);
				break;
			}
			if (EmptyLoc < TOTAL_LOCS)
				GetCommHandle();
			if ((EmptyLoc < TOTAL_LOCS) && (hComm != INVALID_HANDLE_VALUE))
			{
				autoLoc = FALSE;
				ResetEvent(hEventExit);
				hThread = _beginthreadex(NULL, 0, CommThread, NULL, 0, &idThread);
				Sleep(500);
				if (itsgarmin)
				{
					TimerFlags.timing = TRUE;
					TimerFlags.garmintiming = TRUE;
					TimerFlags.gotprotocol = FALSE;
					TimerFlags.time = 3000;
					for (x = 0; x < 9; x++)
						PreCounting[x] = Down[x];
					for (x = 0; x < 4; x++)
						Counting[x] = '0';
					for (x = 8; x < 12; x++)
						Counting[x] = ' ';//don't know how many waypoints...
					for (x = 0; x < 9; x++)
						PostCounting[x] = Way[x];
					GarminFlag = GOT_ETX;
					ResetEvent(hTimerEvent);
					_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
					garminflag = SENDWAYPOINTS;
					tgcount = 0;
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = Pid_Product_Rqst[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &Pid_Product_Rqst, 8, &dwBytesWritten, NULL);
				}
				else
				{//Magellan
					Number[0] = ' ';
					for (y = 1; y < 5; y++)
						Number[y] = '0';
					Number[5] = ' ';
					xCenter = (rect.right/2) - (cxChar*4);
					yCenter = rect.bottom/2;
					magflag = GETWAYPOINTS;
					TimerFlags.nmeatiming = TRUE;
					TimerFlags.gotprotocol = TRUE;
					TimerFlags.time = 5000;
					ResetEvent(hTimerEvent);
					_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
					gotver = FALSE;
					ResetEvent(hEvent);//unsignal it
					tgcount = 0;
					for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
						ToGPS[tgcount] = GetMagellanVersion[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
					if ((gotver == FALSE) && (WaitForSingleObject(hEvent, 2000) == WAIT_TIMEOUT))//it will exit after 1 second or if signalled
					{
						for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
							ToGPS[tgcount] = GetMagellanVersion[x];
						if (tgcount > 49900) tgcount = 0;
						WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
					}
				}
			}
			else if (EmptyLoc == TOTAL_LOCS)
				MessageBox(hwnd, FullArray, "Can't do it:", MB_OK);
//			else if (hComm == INVALID_HANDLE_VALUE)
//				MessageBox(hwnd, BadCommPort, NULL, MB_OK);
			break;

		case ID_GPS_TRACKS_UPLOAD:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			if (trak != NULL)
			{
				free(trak);
				trak = NULL;
			}
			numofTracks = 14400;
			trak = (struct TRAC*) calloc(1, (numofTracks+100) * sizeof(struct TRAC));
			FullTracks[0] = 0;
			ofn.lpstrInitialDir = CurrentTrackDir;
			if (itsusb)
			{
				if (hUSBThread == 0)
				{
					FromUSBBuf = (BYTE*)VirtualAlloc(NULL, 1000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					*pParam = SENDTRACKS;
 					hUSBThread = _beginthreadex(NULL, 0, USBThread, pParam, 0, &idThread4);
				}
				else
					MessageBox(hwnd, "USB Thread is still running...", NULL, MB_OK);
				break;
			}
			if (FALSE != GetOpenFileName(&ofn))
			{
				hFile3 = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile3 != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile3, NULL))
					{
						sendingWaypoints = FALSE;
						ReadFile(hFile3, Trackid, 100, &dwBytesRead, NULL);
						SetFilePointer(hFile3, 0, 0, FILE_BEGIN);
						if ((Trackid[0] == 'T') && (Trackid[1] == 'r') && (Trackid[2] == 'a') && (Trackid[3] == 'c'))
						{
							for (x = 0, trackcommas = 0; (Trackid[x] != '\r') && (x < 100); x++)
								if (Trackid[x] == ',')
									trackcommas++;
							firsttrack = x+2;
							pTrackBuf = (unsigned char*)malloc(fileSize);
							ReadFile(hFile3, pTrackBuf, fileSize, &dwBytesRead, NULL);
							if (itsgarmin == FALSE)
							{
								ofn5.lpstrFilter = " *.*\0""*.*\0\0";
								ofn5.lpstrFile = MeridianFullName;//full filename
								ofn5.lpstrFileTitle = MeridianName;//short filename
								ofn5.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR|OFN_CREATEPROMPT|OFN_OVERWRITEPROMPT;
								ofn5.lpstrTitle = NULL;//title bar
								ofn5.lpstrDefExt = NULL;
								if (FALSE != GetSaveFileName(&ofn5))
								{
									ConvertoMeridian(fileSize);//or eXplorist
									if (itsexplorist)
										MessageBox(hwnd, "has been written in eXplorist format.", MeridianName, MB_OK);
									else
										MessageBox(hwnd, "File written in Meridian SD Card format.", " Done!", MB_OK);
								}
								free(pTrackBuf);
								pTrackBuf = NULL;
								break;
							}
							else//(itsgarmin)
							{
								numofTracks = ReadTracks(fileSize);
								free(pTrackBuf);
								pTrackBuf = NULL;
							}
						}
						else
						{
							numofTracks = fileSize / 12;//original format
							for (x = 0; x < numofTracks; x++)
								ReadFile(hFile3, &trak[x], 12, &dwBytesRead, NULL);
						}
					}
					CloseHandle(hFile3);
					BeginRecords[3] = numofTracks;
					if (numofTracks != 16)//if not 0x10 (DLE char)
						BeginRecords[5] = ~(27 + 2 + numofTracks) + 1;
					else
						BeginRecords2[6] = ~(27 + 2 + numofTracks) + 1;
					remainder = numofTracks % 10000;
					Counting[8] = (remainder / 1000) + '0';
					Counting[9] = ((remainder % 1000) / 100) + '0';
					Counting[10] = ((remainder % 100) / 10) + '0';
					Counting[11] = (remainder % 10) + '0';
					if (RegValue[3] == '0')
					{
						MessageBox(hwnd, SelectCommPort, NULL, MB_OK);
						break;
					}
					GetCommHandle();//if Comm not set to no
					if (hComm != INVALID_HANDLE_VALUE)
					{
						ResetEvent(hEventExit);
						hThread = _beginthreadex(NULL, 0, CommThread, NULL, 0, &idThread);
						Sleep(500);
						autoLoc = FALSE;
						for (x = 0; x < 9; x++)
							PreCounting[x] = Up[x];
						for (x = 0; x < 4; x++)
							Counting[x] = '0';
						for (x = 0; x < 9; x++)
							PostCounting[x] = Track[x];
						if (itsgarmin)
						{
							TimerFlags.timing = TRUE;
							TimerFlags.garmintiming = TRUE;
							TimerFlags.gotprotocol = FALSE;
							TimerFlags.time = 3000;
							ResetEvent(hTimerEvent);
							GarminFlag = GOT_ETX;
							_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
							sendingtrackheader = TRUE;
							d301 = d302 = d310 = FALSE;
							TrackNum = 0;
							if (numofTracks != 16)
								garminflag = BEGINRECORDS8;
							else
								garminflag = BEGINRECORDS9;
							tgcount = 0;
							for (x = 0; x < 8; x++, tgcount++)
								ToGPS[tgcount] = Pid_Product_Rqst[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &Pid_Product_Rqst, 8, &dwBytesWritten, NULL);
						}
					}
//					else
//						MessageBox(hwnd, BadCommPort, NULL, MB_OK);
				}
			}
			ofn.lpstrInitialDir = CurrentDir;
			break;

		case ID_GPS_TRACKS_DOWNLOAD:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
//			if (GetKeyState(VK_CONTROL) < 0)
//				simulate = TRUE;			
			if (trak != NULL)
			{
				free(trak);
				trak = NULL;
			}
			numofTracks = 14400;
			trak = (struct TRAC*) calloc(1, (numofTracks+100) * sizeof(struct TRAC));
			if (itsexplorist)
			{
				ofn5.lpstrFilter = " *.*\0""*.*\0\0";
				ofn5.lpstrFile = MeridianFullName;//full filename
				ofn5.lpstrFileTitle = MeridianName;//short filename
				ofn5.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR|OFN_CREATEPROMPT|OFN_OVERWRITEPROMPT;
				ofn5.lpstrTitle = NULL;//title bar
				ofn5.lpstrDefExt = NULL;
				if (GetOpenFileName(&ofn5))
				{
					hFile = CreateFile(MeridianFullName, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
					if (hFile != INVALID_HANDLE_VALUE)
					{
						fileSize = GetFileSize(hFile, NULL);
						ExploristBuf = (char*)malloc(fileSize);
						ReadFile(hFile, ExploristBuf, fileSize, &dwBytesRead, NULL);
						CloseHandle(hFile);

						//$PMGNTRK,1759.049,N,06637.161,W,00009,M,194354.07,A,,261202*62
						tempLat = Lat;
						tempLon = Lon;
						tempUTMZone = UTMZone;
						tempUTMN = UTMNorthing;
						tempUTME = UTMEasting;
						tnum = 0;
						for (i = 0; i < fileSize; )
						{
							if ((ExploristBuf[i] != '$')
								|| (ExploristBuf[i+1] != 'P')
								|| (ExploristBuf[i+2] != 'M')
								|| (ExploristBuf[i+5] != 'T')
								|| (ExploristBuf[i+6] != 'R')
								|| (ExploristBuf[i+7] != 'K'))
							{
								for ( ; (i < fileSize) && (ExploristBuf[i] != '\n'); i++)
									;
								i++;
								continue;
							}
							for (x = 0, i += 9; (i < fileSize) && (ExploristBuf[i] != '\r'); i++, x++)
								tempLatLon[x] = ExploristBuf[i];
							i += 2;
							Lat = ((double)((tempLatLon[0] - '0') * 10) + (tempLatLon[1] - '0'))
							 + ((atof(&tempLatLon[2])) / 60.0);
							for (x = 0; (tempLatLon[x] != 'N') && (x < 100); x++)
								;
							if (x >= 100)
								return 0;//just in case
							x += 2;//to Longitude
							Lon = -((double)((tempLatLon[x] - '0') * 100)
							 + ((tempLatLon[x+1] - '0') * 10)
							 + (tempLatLon[x+2] - '0')
							 + ((atof(&tempLatLon[x+3])) / 60.0));
							if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
								continue;
							else
							{
								LatRad = Lat*deg2rad;
								LonRad = Lon*deg2rad;
								LatLontoUTM();//get UTMEasting & UTMNorthing
							}

							FillTrackFromNMEA();
						}
						free(ExploristBuf);
						if (FALSE != GetSaveFileName(&ofn))
						{
							HANDLE hXFile = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
							fileSize = sizeof(trak[0]);
							trak[tnum].time = 0;
							WriteFile(hXFile, TrackHead, strlen(TrackHead), &dwBytesWritten, NULL);
							trackcommas = 10;
							for (y = 0; y < tnum; y++)
								WriteTracks(hXFile, y);
							CloseHandle(hXFile);
						}
						Lat = tempLat;
						Lon = tempLon;
						UTMZone = tempUTMZone;
						UTMNorthing = tempUTMN;
						UTMEasting = tempUTME;
					}
					InvalidateRect(hwnd, &rect, FALSE);
					sprintf(Error, "has been copied into %s", Tracks);
					MessageBox(hwnd, Error, MeridianName, MB_OK);
				}
				break;
			}
			if (itsusb)
			{
				if (hUSBThread == 0)
				{
					FromUSBBuf = (BYTE*)VirtualAlloc(NULL, 1000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					*pParam = GETTRACKS;
 					hUSBThread = _beginthreadex(NULL, 0, USBThread, pParam, 0, &idThread4);
				}
				else
					MessageBox(hwnd, "USB Thread is still running...", NULL, MB_OK);
				break;
			}
			if (RegValue[3] == '0')
			{
				MessageBox(hwnd, SelectCommPort, NULL, MB_OK);
				break;
			}
			GetCommHandle();//if Comm not set to no
			if (hComm != INVALID_HANDLE_VALUE)
			{
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
				FullTracks[0] = 0;
				ofn.lpstrInitialDir   = CurrentTrackDir;
				if (FALSE != GetSaveFileName(&ofn))//fills in FullTracks with full filename
				{
					autoLoc = FALSE;
					tnum = 0;
					ResetEvent(hEventExit);
					hThread = _beginthreadex(NULL, 0, CommThread, NULL, 0, &idThread);
					Sleep(500);

					if (itsgarmin)
					{
						for (x = 0; x < 9; x++)
							PreCounting[x] = Down[x];
						for (x = 0; x < 4; x++)
							Counting[x] = '0';
						for (x = 8; x < 12; x++)
							Counting[x] = ' ';//don't know how many tracks...
						for (x = 0; x < 9; x++)
							PostCounting[x] = Track[x];
						TimerFlags.timing = TRUE;
						TimerFlags.garmintiming = TRUE;
						TimerFlags.gotprotocol = FALSE;
						TimerFlags.time = 3000;
						ResetEvent(hTimerEvent);
						_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
						GarminFlag = GOT_ETX;
						garminflag = SENDTRACKS;
						d301 = d302 = d310 = FALSE;
						tgcount = 0;
						for (x = 0; x < 8; x++, tgcount++)
							ToGPS[tgcount] = Pid_Product_Rqst[x];
						WriteFile(hComm, &Pid_Product_Rqst, 8, &dwBytesWritten, NULL);
					}
					else
					{
						Number[0] = ' ';
						for (y = 1; y < 5; y++)
							Number[y] = '0';
						Number[5] = ' ';
						xCenter = (rect.right/2) - (cxChar*4);
						yCenter = rect.bottom/2;
						TimerFlags.nmeatiming = TRUE;
						TimerFlags.gotprotocol = TRUE;
						TimerFlags.time = 5000;
						ResetEvent(hTimerEvent);
						_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
						magflag = GETTRACKS;
						inutmzone = FALSE;
						gotver = FALSE;
						ResetEvent(hEvent);//unsignal it
						tgcount = 0;
						for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
							ToGPS[tgcount] = GetMagellanVersion[x];
						WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
						if ((gotver == FALSE) && (WaitForSingleObject(hEvent, 2000) == WAIT_TIMEOUT))//it will exit after 1 second or if signalled
						{
							for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
								ToGPS[tgcount] = GetMagellanVersion[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
						}
					}
				}
				ofn.lpstrInitialDir   = CurrentDir;
			}
//			else if (hComm == INVALID_HANDLE_VALUE)
//				MessageBox(hwnd, BadCommPort, NULL, MB_OK);
			break;

		case ID_GPS_TRACKS_SHOW:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (autoLoc)
				break;
			if (showingtracks)
			{
				MessageBox(hwnd, "Close the current Tracks window first.", "", MB_OK);
				break;
			}
			FullTracks[0] = 0;
			ofn.lpstrInitialDir = CurrentTrackDir;
tryagain:if (FALSE != GetOpenFileName(&ofn))
			{
				char ch = ofn.lpstrFile[ofn.nFileExtension];
				char ch1 = ofn.lpstrFile[ofn.nFileExtension+1];
				char ch2 = ofn.lpstrFile[ofn.nFileExtension+2];
				BOOL itsokay = FALSE;

				if (((ch & 0xDF) == 'C') && ((ch1 & 0xDF) == 'S') && ((ch2 & 0xDF) == 'V'))
					itsokay = TRUE;
				else if (((ch & 0xDF) == 'T') && ((ch1 & 0xDF) == 'R') && ((ch2 & 0xDF) == 'C'))
					itsokay = TRUE;
				else if (((ch & 0xDF) == 'D') && ((ch1 & 0xDF) == 'T') && ((ch2 & 0xDF) == 'A'))
					itsokay = TRUE;
				if (itsokay == FALSE)
					goto tryagain;
				hFile3 = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile3 != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile3, NULL))
					{
						ReadFile(hFile3, Trackid, 100, &dwBytesRead, NULL);
						SetFilePointer(hFile3, 0, 0, FILE_BEGIN);
						if ((Trackid[0] == 'T') && (Trackid[1] == 'r') && (Trackid[2] == 'a') && (Trackid[3] == 'c'))
						{
							for (x = 0, trackcommas = 0; (Trackid[x] != '\r') && (x < 100); x++)
								if (Trackid[x] == ',')
									trackcommas++;
							pTrackBuf = (unsigned char*)malloc(fileSize);
							ReadFile(hFile3, pTrackBuf, fileSize, &dwBytesRead, NULL);
							CloseHandle(hFile3);
							numofTracks = ReadTracks(fileSize);
							free(pTrackBuf);
							pTrackBuf = NULL;
						}
						else
						{
							if (fileSize % 12)
								numofTracks = 0;//to exit if it's not an old track file
							else
								numofTracks = fileSize / 12;//original format
							for (x = 0; x < numofTracks; x++)
							{
								ReadFile(hFile3, &oldTrack, 12, &dwBytesRead, NULL);
								trak[x].NUTM = oldTrack.NUTM;
								trak[x].EUTM = oldTrack.EUTM;
								trak[x].time = oldTrack.time;
								trak[x].alt = 0;
								trak[x].newtrk = 0;
								trak[x].color = 0;
								trak[x].year = 0;
							}
							CloseHandle(hFile3);
						}
						if (numofTracks > 1)
						{
							trak[numofTracks].time = 0;//in case the 0 isn't at the end
							trackUTMZone = trak[0].time >> 26;//UTMZone in new Track.dta format
							showingtracks = TRUE;
							fromTracks = TRUE;
							editingtracks = FALSE;
							///////////////
//							CreateTracks();
							fromusbtracks = TRUE;
							///////////////
						}
						else
							MessageBox(hwnd, "That track file is empty.\nOr it's not a track file.", ERROR, MB_OK);
					}//end of if (fileSize
					else
						CloseHandle(hFile3);
				}//end of if (hFile3
			}//end of if (FALSE != GetOpenFileName(&ofn))
			ofn.lpstrInitialDir = CurrentDir;
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case ID_GPS_TRACKS_COMBINE:
			ofn.lpstrInitialDir = CurrentTrackDir;
			ofn.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR|OFN_ALLOWMULTISELECT|OFN_EXPLORER;
			ofn.lpstrTitle = ">>>Select All the Files to Combine<<<";
			ch = FullTracks[0];
			FullTracks[0] = 0;
			if (GetOpenFileName(&ofn))
			{
				int t, CombinedSize = 0;
				char tempTrackFilename[MAX_PATH];
				char *CombinedTracks, *tempTracks;

				for (z = 0; CurrentTrackDir[z] != 0; z++)
					tempTrackFilename[z] = CurrentTrackDir[z];
				for (y = ofn.nFileOffset; ofn.lpstrFile[y] != 0; y++)
				{
					for (x = y; ofn.lpstrFile[y] != 0; y++)
						;
					for (w = z; x < y; x++, w++)
						tempTrackFilename[w] = ofn.lpstrFile[x];
					tempTrackFilename[w] = 0;
					FindFirstFile(tempTrackFilename, &fd);
					CombinedSize += fd.nFileSizeLow;
				}
//				CombinedTracks = (char*)malloc(CombinedSize);
				CombinedTracks = (char*)VirtualAlloc(NULL, CombinedSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
				for (v = 0; PreTracks[v] != 0; v++)
					CombinedTracks[v] = PreTracks[v];//first line of track file
				for (y = ofn.nFileOffset; ofn.lpstrFile[y]; y++)
				{
					for (x = y; ofn.lpstrFile[y] != 0; y++)
						;
					for (w = z; x < y; x++, w++)
						tempTrackFilename[w] = ofn.lpstrFile[x];
					tempTrackFilename[w] = 0;
					hFile = CreateFile(tempTrackFilename, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile != INVALID_HANDLE_VALUE)
					{
						if (fileSize = GetFileSize(hFile, NULL))
						{
							tempTracks = (char*)malloc(fileSize);
							ReadFile(hFile, tempTracks, fileSize, &dwBytesRead, NULL);
							for (t = 0; (t < fileSize) && (tempTracks[t] != '\n'); t++)
								;
							t++;//to beginning of second line
							if (tempTracks[t] == ',')//no New at beginning
							{
								CombinedTracks[v++] = 'N';
								CombinedTracks[v++] = 'e';
								CombinedTracks[v++] = 'w';
							}
							for ( ; t < fileSize; t++, v++)
								CombinedTracks[v] = tempTracks[t];
							free(tempTracks);
						}
						CloseHandle(hFile);
					}
				}
				ofn.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
				ofn.lpstrTitle = ">>>Save Combined Track File As<<<";
				FullTracks[0] = ch;
				if (GetSaveFileName(&ofn))
				{
					hFile = CreateFile(ofn.lpstrFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
					WriteFile(hFile, CombinedTracks, v, &dwBytesWritten, NULL);
					CloseHandle(hFile);
				}
//				free(CombinedTracks);
				VirtualFree(CombinedTracks, 0, MEM_RELEASE);
				ofn.lpstrTitle = NULL;
			}
			else
			{
				x = CommDlgExtendedError();//see CdErr.h for codes
				MessageBox(hwnd, "The total length of file names\nexceeded the Windows\nfile name buffer size.", ERROR, MB_OK);
				FullTracks[0] = ch;
				ofn.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
				ofn.lpstrTitle = NULL;
			}
			break;

		case ID_GPS_ROUTES_SEND:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (itsexplorist)
			{
//				SendMagRoutes();
				MessageBox(hwnd, Explorist, Routine, MB_OK);
				break;
			}
			if (itsusb)
			{
				if (hUSBThread == 0)
				{
					FromUSBBuf = (BYTE*)VirtualAlloc(NULL, 1000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					*pParam = SENDROUTE;
					hUSBThread = _beginthreadex(NULL, 0, USBThread, pParam, 0, &idThread4);
				}
				else
					MessageBox(hwnd, "USB Thread is still running...", NULL, MB_OK);
				break;
			}
			sendingrouteheader = TRUE;
			sendingroutelink = FALSE;
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			d201 = TRUE;
			d210 = FALSE;
			if (FALSE != GetOpenFileName(&ofn3))
			{
				hFile3 = CreateFile(FullRoutes, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile3 != INVALID_HANDLE_VALUE)
				{
					if (fileSize = GetFileSize(hFile3, NULL))
					{
						ReadFile(hFile3, Trackid, 100, &dwBytesRead, NULL);
						SetFilePointer(hFile3, 0, 0, FILE_BEGIN);
						if ((Trackid[2] == ',') && (Trackid[10] == ',') && (Trackid[17] == '\r'))
						{
							pRoutes = (char*)malloc(fileSize);
							ReadFile(hFile3, pRoutes, fileSize, &dwBytesRead, NULL);
							for (x = 0, y = 0; (y < (int)fileSize) && (x < TOTAL_LOCS); x++)
							{
								Root[0][x].Z = ((pRoutes[y] - '0') * 10) + (pRoutes[y+1] - '0');
								y += 3;//past ,
								Root[0][x].N = (((pRoutes[y] - '0') * MILLION)
								 + ((pRoutes[y+1] - '0') * HUNDREDTHOUSAND)
								 + ((pRoutes[y+2] - '0') * TENTHOUSAND)
								 + ((pRoutes[y+3] - '0') * THOUSAND)
								 + ((pRoutes[y+4] - '0') * HUNDRED)
								 + ((pRoutes[y+5] - '0') * TEN)
								 + (pRoutes[y+6] - '0'));
								y += 8;//past ,
								Root[0][x].E = (((pRoutes[y] - '0') * HUNDREDTHOUSAND)
								 + ((pRoutes[y+1] - '0') * TENTHOUSAND)
								 + ((pRoutes[y+2] - '0') * THOUSAND)
								 + ((pRoutes[y+3] - '0') * HUNDRED)
								 + ((pRoutes[y+4] - '0') * TEN)
								 + (pRoutes[y+5] - '0'));
								y += 8;//to next line
							}
							Root[0][x].Z = 0;
							numofRoutes = x;
							free(pRoutes);
						}
						else
						{
							MessageBox(hwnd, NotRoute, NULL, MB_OK);
							CloseHandle(hFile3);
							return 0;
						}
					}
					CloseHandle(hFile3);
					if (RegValue[3] == '0')
					{
						MessageBox(hwnd, SelectCommPort, NULL, MB_OK);
						break;
					}
					GetCommHandle();
					if (hComm != INVALID_HANDLE_VALUE)
					{
						ResetEvent(hEventExit);
						hThread = _beginthreadex(NULL, 0, CommThread, NULL, 0, &idThread);
						Sleep(500);
						for (x = 0; x < 9; x++)
							PreCounting[x] = Up[x];
						for (x = 0; x < 4; x++)
							Counting[x] = '0';
						for (x = 0; x < 9; x++)
							PostCounting[x] = Routetxt[x];
						remainder = numofRoutes % 10000;
						Counting[8] = (remainder / 1000) + '0';
						Counting[9] = ((remainder % 1000) / 100) + '0';
						Counting[10] = ((remainder % 100) / 10) + '0';
						Counting[11] = (remainder % 10) + '0';
						autoLoc = FALSE;
						TrackNum = 0;//borrowing TrackNum
						LocNum = 0;//for NewLoc[]
						if (itsgarmin)
						{
							BeginRecords[3] = numofRoutes+1;//+ Route Header
							if ((numofRoutes+1) != 16)//if not 0x10 (DLE char)
								BeginRecords[5] = ~(27 + 2 + (numofRoutes+1)) + 1;
							else
								BeginRecords2[6] = ~(27 + 2 + (numofRoutes+1)) + 1;
							GarminFlag = GOT_ETX;
							TimerFlags.timing = TRUE;
							TimerFlags.garmintiming = TRUE;
							TimerFlags.gotprotocol = FALSE;
							TimerFlags.time = 3000;
							ResetEvent(hTimerEvent);
							_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
							if (EmptyLoc != 16)
								garminflag = BEGINRECORDS8;
							else
								garminflag = BEGINRECORDS9;
							tgcount = 0;
							for (x = 0; x < 8; x++, tgcount++)
								ToGPS[tgcount] = Pid_Product_Rqst[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &Pid_Product_Rqst, 8, &dwBytesWritten, NULL);
						}
						else
						{//send routes to magellan
							if (IDOK != MessageBox(hwnd, SendingRoute, "Sending a Route", MB_OKCANCEL))
								break;
							if (numofRoutes > 30)//max for Magellan
								MessageBox(hwnd, "Multiple routes will be created\n(30 waypoints per route).", "", MB_OK);
							Number[0] = ' ';//initialize waypoint count
							for (y = 1; y < 5; y++)
								Number[y] = '0';
							Number[5] = ' ';
							xCenter = (rect.right/2) - (cxChar*4);
							yCenter = rect.bottom/2;

							for (y = 0; y < numofRoutes; y++)
							{
								if ((y+1) < 10)
								{
									Nums[y][0] = (y+1) + '0';
									Nums[y][1] = '<';
									Nums[y][2] = 0;
								}
								else if ((y+1) < 100)
								{
									Nums[y][0] = ((y+1) / 10) + '0';
									Nums[y][1] = ((y+1) % 10) + '0';
									Nums[y][2] = '<';
									Nums[y][3] = 0;
								}
								else//y+1 < 1000
								{
									Nums[y][0] = ((y+1) / 100) + '0';
									Nums[y][1] = (((y+1) % 100) / 10) + '0';
									Nums[y][2] = ((y+1) % 10) + '0';
									Nums[y][3] = '<';
									Nums[y][4] = 0;
								}
							}

							for (x = 0; x < TOTAL_LOCS; x++)
							{
								NewLoc[x].NUTM = 0;
								NewLoc[x].EUTM = 0;
								NewLoc[x].UTMZone = 0;
								NewLoc[x].pWaypoints = NULL;//pointer to waypoint data in WaypointArray
 								NewLoc[x].Ident = NULL;//pointer to name
								NewLoc[x].Location = NULL;//pointer to cmt
								NewLoc[x].Description = NULL;//pointer to desc
								NewLoc[x].Elev = NULL;//pointer to ele
								NewLoc[x].Sym = NULL;//pointer to sym
								NewLoc[x].size = 0;
								prevDist[x] = HUNDRED_MILES;
							}
							for (x = 0; x < numofRoutes; x++)
							{
								NewLoc[x].NUTM = Root[0][x].N;
								NewLoc[x].EUTM = Root[0][x].E;
								NewLoc[x].UTMZone = Root[0][x].Z;
								NewLoc[x].Ident = Nums[x];
								NewLoc[x].Sym = Mx;//medium city
							}
							EmptyLoc = numofRoutes;
							LocNum = 0;

							magflag = SENDWAYPOINTS;
							sendroutewaypoints = TRUE;
							TimerFlags.nmeatiming = TRUE;
							TimerFlags.gotprotocol = TRUE;
							TimerFlags.time = 5000;
							ResetEvent(hTimerEvent);
							_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
							gotver = FALSE;
							tgcount = 0;
							for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
								ToGPS[tgcount] = GetMagellanVersion[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
							ResetEvent(hEvent);//unsignal it
//							if ((gotver == FALSE) && (WaitForSingleObject(hEvent, 2000) == WAIT_TIMEOUT))//it will exit after 2 seconds or if signalled
//							{
//								for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
//									ToGPS[tgcount] = GetMagellanVersion[x];
//								if (tgcount > 49900) tgcount = 0;
//								WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
//							}
						}
					}
				}
			}
			break;

		case ID_GPS_ROUTES_RECEIVE:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (GetKeyState(VK_CONTROL) < 0)
				y = TRUE;			
			if (itsexplorist)
			{
				MessageBox(hwnd, Explorist, Routine, MB_OK);
				break;
			}
			if (itsusb)
			{
				if (hUSBThread == 0)
				{
					FromUSBBuf = (BYTE*)VirtualAlloc(NULL, 1000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					*pParam = RECEIVEROUTE;
 					hUSBThread = _beginthreadex(NULL, 0, USBThread, pParam, 0, &idThread4);
				}
				else
					MessageBox(hwnd, "USB Thread is still running...", NULL, MB_OK);
				break;
			}
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;

			if (RegValue[3] == '0')
			{
				MessageBox(hwnd, SelectCommPort, NULL, MB_OK);
				break;
			}
			GetCommHandle();
			if (hComm != INVALID_HANDLE_VALUE)
			{
				autoLoc = FALSE;
				ResetEvent(hEventExit);
				hThread = _beginthreadex(NULL, 0, CommThread, NULL, 0, &idThread);
				Sleep(500);
				RouteNum = -1;//will increment to 0
				rte = 0;
				gettingroute = TRUE;
				d201 = TRUE;
				d210 = FALSE;
				for (x = 0; x < 9; x++)
					PreCounting[x] = Down[x];
				for (x = 0; x < 4; x++)
					Counting[x] = '0';
				for (x = 8; x < 12; x++)
					Counting[x] = ' ';//don't know how many tracks...
				for (x = 0; x < 9; x++)
					PostCounting[x] = Routetxt[x];
				if (itsgarmin)
				{
					TimerFlags.timing = TRUE;
					TimerFlags.garmintiming = TRUE;
					TimerFlags.gotprotocol = FALSE;
					TimerFlags.time = 3000;
					ResetEvent(hTimerEvent);
					_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
					GarminFlag = GOT_ETX;
					garminflag = RECEIVEROUTE;
					tgcount = 0;
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = Pid_Product_Rqst[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &Pid_Product_Rqst, 8, &dwBytesWritten, NULL);
				}
				else
				{//receive Magellan Routes (first receive waypoints)
					foroute = TRUE;
					gotroute = FALSE;
					routeway = 0;
					autoLoc = FALSE;
					Number[0] = ' ';
					for (y = 1; y < 5; y++)
						Number[y] = '0';
					Number[5] = ' ';
					xCenter = (rect.right/2) - (cxChar*4);
					yCenter = rect.bottom/2;
					magflag = GETWAYPOINTS;
					TimerFlags.nmeatiming = TRUE;
					TimerFlags.gotprotocol = TRUE;
					TimerFlags.time = 5000;
					ResetEvent(hTimerEvent);
					_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
					gotver = FALSE;
					ResetEvent(hEvent);//unsignal it
					tgcount = 0;
					for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
						ToGPS[tgcount] = GetMagellanVersion[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
					if ((gotver == FALSE) && (WaitForSingleObject(hEvent, 2000) == WAIT_TIMEOUT))//it will exit after 1 second or if signalled
					{
						for (x = 0; GetMagellanVersion[x] != 0; x++, tgcount++)
							ToGPS[tgcount] = GetMagellanVersion[x];
						if (tgcount > 49900) tgcount = 0;
						WriteFile(hComm, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
					}
				}
			}
			break;

		case ID_GPS_LOCATION_COPYPOSITION01CSVTOTRACKFORMAT:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (posflag == FALSE)
				break;
			ofn5.lpstrFilter       = " Position??.csv\0""Position*.csv\0\0";
			ofn5.lpstrFileTitle    = PositionCsv;
			ofn5.lpstrFile         = NULL;
			ofn5.Flags             = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
			ofn5.lpstrTitle        = NULL;
			ofn5.lpstrDefExt       = "csv";
			if (GetOpenFileName(&ofn5))//fill in PositionCsv
			{
				int x, y, commas;
				DWORD fileSize;
				HANDLE hFile;
				hFile = CreateFile(PositionCsv, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					fileSize = GetFileSize(hFile, NULL);
					if (fileSize > sizeof(PositionHeader)+1)
					{
						char *posn = (char*)malloc(fileSize);
						char *trk = (char*)malloc(fileSize);

						ReadFile(hFile, posn, fileSize, &dwBytesRead, NULL);
						for (x = 0, y = 0; PreTracks[x] != 0; x++, y++)
							trk[y] = PreTracks[x];
						for (y = 0; (posn[y] != '\n') && (y < (int)fileSize); y++)
							;
 						y++;//go past the first line
						if (posn[y] == 'N')//new format
						{
							commas = 0;
							for ( ; (y < (int)fileSize); x++, y++)
							{
								if (posn[y] == ',')
									commas++;
								if (commas == 10)
								{
									commas = 0;
									for ( ; (posn[y] != '\r') && (y < (int)fileSize); y++)
										;//skip to end of line
								}
								trk[x] = posn[y];
							}
							ofn5.lpstrFilter = " *.csv\0""*.csv\0\0";
							ofn5.lpstrFile = FullTracks;
							ofn5.lpstrFileTitle = Tracks;
							ofn5.lpstrInitialDir = CurrentTrackDir;
							if (FALSE != GetSaveFileName(&ofn5))
							{
								hFile2 = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
								WriteFile(hFile2, trk, x, &dwBytesWritten, NULL);
								CloseHandle(hFile2);
							}
							ofn5.lpstrInitialDir = CurrentDir;
						}
						else
							MessageBox(hwnd, "This only works with\nthe new position format,\nwhich adds a comma-separated\nfield at the beginning of each line\nwhich is either 'New' or blank.", "Sorry", MB_OK);
						free(trk);
						free(posn);
					}
					CloseHandle(hFile);
				}
			}
			break;

		case ID_GPS_LOCATION_DISPLAYPOSITION01CSV://display what's in Position01.csv
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (posflag == FALSE)
				break;
			ofn5.lpstrFilter       = " Position??.csv\0""Position*.csv\0\0";
			ofn5.lpstrFileTitle    = PositionCsv;
			ofn5.lpstrFile         = NULL;
			ofn5.Flags             = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
			ofn5.lpstrTitle        = NULL;
			ofn5.lpstrDefExt       = "csv";
			if (GetOpenFileName(&ofn5))//fill in PositionCsv
			{
				int x, y, xUTMZone;
				DWORD fileSize;
				HANDLE hFile;
				hFile = CreateFile(PositionCsv, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					fileSize = GetFileSize(hFile, NULL);
					if (fileSize > sizeof(PositionHeader)+1)
					{
						int Begin;
						char *Pos = NULL;

						if (pos)
						{
							SavePosition();
						}
						Pos = (char*)malloc(fileSize);
						ReadFile(hFile, Pos, fileSize, &dwBytesRead, NULL);
						for (y = 0; (Pos[y] != '\n') && (y < (int)fileSize); y++)
							;
 						y++;//go past the first line
						Begin = y;
						for (x = y; x < (int)fileSize; x++)
						{//check for wrong characters
							if (((Pos[x] >= '0') && (Pos[x] <= '9')) || (Pos[x] == '\r') || (Pos[x] == '\n') || (Pos[x] == ',') || (Pos[x] == '.') || (Pos[x] == '-') || (Pos[x] == 'N') || (Pos[x] == 'e') || (Pos[x] == 'w'))
								continue;
							else
								break;
						}
						if (x != (int)fileSize)
						{
							sprintf(Error, "%c found in %s", Pos[x], PositionCsv);
							MessageBox(hwnd, Error, ERROR, MB_OK);
							break;
						}

						for (pos = 0; (y < (int)fileSize) && (pos < 14400); pos++)
						{
							if (Pos[Begin] == 'N')
							{//if new format
								for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
									;
								y++;//past New, or ,
							}
							Position[pos].UTMZ = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].UTMN = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].UTME = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].Hour = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].Min = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].Sec = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].Month = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].Date = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].Year = atoi(&Pos[y]) - 2000;
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].Alt = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].HorizEpe = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].VertEpe = atoi(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (Pos[y] != ',') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							if (Pos[y-1] == '\n')
								continue;
							Position[pos].Velocity = (float)atof(&Pos[y]);
							for ( ; (Pos[y] != '\n') && (y < (int)fileSize); y++)
								;
							if (y == (int)fileSize)
								break;
							y++;
							Position[pos].Course = 0xFFFF;
						}//end of for (
						free(Pos);
					}//end of if (fileSize ==
					else
					{
						CloseHandle(hFile);
						MessageBox(hwnd, "File is empty.\n Deleting it.", ERROR, MB_OK);
						DeleteFile(PositionCsv);
						break;
					}
					CloseHandle(hFile);
//{
//	int savePos = pos;
//	compressit = FALSE;
//	for (pos = 0; pos < savePos; pos++)
//		ConvertoGPSLatLon();
//	pos = savePos;
//}
					for (x = 0; (x < pos) && ((Position[x].UTMN == 0)); x++)// && (Position[x].UTME == 0) && (Position[x].UTMZ == 0)
						;
					BeginY = Position[x].UTMN / MetersPerTile;
					BeginX = Position[x].UTME / MetersPerTile;
					_itoa(BeginX, X, 10);
					_itoa(BeginY, Y, 10);
					Z[0] = (UTMZone / 10) + '0';
					Z[1] = (UTMZone % 10) + '0';
					rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
					colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
					xUTMZone = Position[x].UTMZ;
					if (xUTMZone == UTMZone)
					{
						SendMessage(hwnd, WM_USER, 0, 0);
					}
					else
					{
						UTMNorthing = Position[x].UTMN;
						UTMEasting = Position[x].UTME;
						ChangeZone(xUTMZone, 6);//show position
						_itoa(BeginX, X, 10);
						_itoa(BeginY, Y, 10);
						Z[0] = (UTMZone / 10) + '0';
						Z[1] = (UTMZone % 10) + '0';
						Waypoints[0] = 0;
						SendMessage(hwnd, WM_USER4, 0, 0);
					}
					posflag = FALSE;
					if (testingsmartbeaconing == FALSE)
					{
						hwndPosit = CreateWindow("EDIT", PositionCsv,
							WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | ES_MULTILINE,
							0, 0, 200, 200,
							hwnd, hMenu2, hInst, NULL);//(HMENU)178
						pPosProc = (WNDPROC)SetWindowLong(hwndPosit, GWL_WNDPROC, (LONG)PosProc);//sub-class for WM_DESTROYWINDOW
						SetWindowText(hwndPosit, Posit);
						SendMessage(hwndPosit, EM_SETREADONLY, 1, 0);
						fromposition = TRUE;//so WM_MOUSEMOVE will show info
					}
					InvalidateRect(hwnd, &rect, FALSE);
				}//end of if (hFile !=
			}
			break;

		case ID_GPS_LOCATION_SHOWLOCATIONSPACEBAR:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (GetKeyState(VK_CONTROL) < 0)
				simulate = TRUE;			
			SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_SPACE, 0);
			break;

		case ID_GPS_POSITION_DRAWALINEFROMPOSITIONTOAWAYPOINT:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (yPos > TitleAndMenu)//2
			{
				centerX = xPos;
				centerY = yPos;
			}
			else
			{
				centerX = rect.right >> 1;
				centerY = rect.bottom >> 1;
			}
			UTMCenterX = (centerX * MetersPerTile/PixelsPerTile) + ScreenLeft;
			UTMCenterY = ScreenTop - (centerY * MetersPerTile/PixelsPerTile);
			B = 10000000000.0;//large number
			index = -1;//flag
			for (x = 0; x < TOTAL_LOCS; x++)
			{
				if (NewLoc[x].EUTM == 0)
					break;
				if (NewLoc[x].UTMZone != UTMZone)
					continue;
				idistX = UTMCenterX - NewLoc[x].EUTM;
				if (idistX < 1)
					idistX = -(idistX);
				idistY = UTMCenterY - NewLoc[x].NUTM;
				if (idistY < 1)
					idistY = -(idistY);
				distX = (double) idistX;
				distY = (double) idistY;
				A = (int) sqrt((distX*distX) + (distY*distY));
				if (A < B)
				{
					B = A;
					index = x;
				}
			}
			/////////
			if (DialogBox(hInst, "SHOWLINE", hwnd, LineProc))
				showline = TRUE;
			else
				showline = FALSE;
			/////////
			break;

		case ID_APPROACHCONTROL_HELP:
			pApproachHelp = NULL;
			hFile = CreateFile(ApproachControlHelp, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				if (HelpSize = GetFileSize(hFile, NULL))
				{
					pApproachHelp = (char*)malloc(HelpSize+1);
					if (pApproachHelp == NULL)
						MessageBox(hwnd, "OHOH", "", MB_OK);
					pApproachHelp[HelpSize] = 0;
					ReadFile(hFile, pApproachHelp, HelpSize, &dwBytesRead, NULL);

					hMenu2 = CreateMenu();//to override parent menu bar
					hwndApproachHelp = CreateWindow(Instruct, ApproachControlHelp,
						WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
						0, TitleAndMenu, (cxScreen/2 + 320)-(cxScreen/2-320), 630,
						NULL, hMenu2, hInst, NULL);
					SetWindowText(hwndInstr, pApproachHelp);
					SetFocus(hwndInstr);
					free(pApproachHelp);
				}
				CloseHandle (hFile);
			}
			else
				MessageBox(hwnd, ApproachControlHelp, "Couldn't find", MB_OK);
			break;

		case ID_APPROACHCONTROL_ADVANCEDHELP:
			pApproachHelp = NULL;
			hFile = CreateFile(AdvancedApproachControlHelp, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				if (HelpSize = GetFileSize(hFile, NULL))
				{
					pApproachHelp = (char*)malloc(HelpSize+1);
					if (pApproachHelp == NULL)
						MessageBox(hwnd, "OHOH", "", MB_OK);
					pApproachHelp[HelpSize] = 0;
					ReadFile(hFile, pApproachHelp, HelpSize, &dwBytesRead, NULL);

					hMenu2 = CreateMenu();//to override parent menu bar
					hwndApproachHelp = CreateWindow(Instruct, AdvancedApproachControlHelp,
						WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
						0, TitleAndMenu, (cxScreen/2 + 320)-(cxScreen/2-320), 420,
						NULL, hMenu2, hInst, NULL);
					SetWindowText(hwndInstr, pApproachHelp);
					SetFocus(hwndInstr);
					free(pApproachHelp);
				}
				CloseHandle (hFile);
			}
			else
				MessageBox(hwnd, AdvancedApproachControlHelp, "Couldn't find", MB_OK);
			break;

		case ID_APPROACHCONTROL_ATLANTA:
			if (uTimerID == NULL)
			{
				UTMZone = 16;
				UTMEasting = 738700;
				UTMNorthing = 3725300;
				ApproachControl();
			}
			break;

		case ID_APPROACHCONTROL_CHICAGO:
			if (uTimerID == NULL)
			{
				UTMZone = 16;
				UTMEasting = 425200;
				UTMNorthing = 4648000;
				ApproachControl();
			}
			break;

		case ID_APPROACHCONTROL_DENVER:
			if (uTimerID == NULL)
			{
				UTMZone = 13;
				UTMEasting = 510000;
				UTMNorthing = 4402000;
				ApproachControl();
			}
			break;

		case ID_APPROACHCONTROL_NEWYORK:
			if (uTimerID == NULL)
			{
				UTMZone = 18;
				UTMEasting = 602480;
				UTMNorthing = 4500300;
				ApproachControl();
			}
			break;

		case ID_APPROACHCONTROL_SALTLAKECITY:
			if (uTimerID == NULL)
			{
				UTMZone = 12;
				UTMEasting = 416900;
				UTMNorthing = 4515900;
				ApproachControl();
			}
			break;

		case ID_APPROACHCONTROL_SANFRANCISCO:
			if (uTimerID == NULL)
			{
				UTMZone = 10;
				UTMEasting = 554240;
				UTMNorthing = 4163800;
				ApproachControl();
			}
			break;

		case ID_HELP_PHOTOMAPHELP:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_F1, 0);
			break;

		case ID_HELP_HTTP:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			WinExec(Index, SW_SHOW);
			break;

		case ID_HELP_CHECKFORNEWERVERSION:
			hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
			if (hInternet = InternetOpenUrl(hOpen, CheckforUpdate, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
			{
				char *MyWebPage;
				MyWebPage = (char*)calloc(1, MYWEBPAGESIZE);//shouldn't get any bigger than this
				for (fileSize = 0; (goodread = InternetReadFile(hInternet, MyWebPage, MYWEBPAGESIZE, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
					;
				InternetCloseHandle(hInternet);
				if ((goodread) && (dwBytesRead == 0))
				{
					for (x = 0; x < fileSize; x++)
					{
						if ((MyWebPage[x] == '>') && (MyWebPage[x+1] == 'F') && (MyWebPage[x+8] == 's') && (MyWebPage[x+9] == 't') && (MyWebPage[x+10] == 'a'))
						{
							x += 30;//to version number
							y = 8;//version number
							for (z = 0; z < 4; x++, y++, z++)
								if (MyWebPage[x] != Version[y])
									break;
							if (z != 4)
								MessageBox(hwnd, NewerVersion, ProgName, MB_OK);
							else
							{
								for (x = 0; x < fileSize; x++)
								{
									if ((MyWebPage[x] == '>') && (MyWebPage[x+1] == 'W') && (MyWebPage[x+8] == 'N') && (MyWebPage[x+9] == 'e') && (MyWebPage[x+10] == 'w'))
									{
										x += 18;//to date
										for (y = 0; Version[y] != '\r'; y++)
											;
										y += 4;//to date
										for (z = 0; z < 11; x++, y++, z++)//November 30
											if (MyWebPage[x] != Version[y])
												break;
										if (z != 11)
											MessageBox(hwnd, NewerDate, ProgName, MB_OK);
										else
											MessageBox(hwnd, SameVersion, ProgName, MB_OK);
										break;
									}
								}
							}
							break;
						}
					}
//					HANDLE hFile = CreateFile(MyWebPage, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
//					WriteFile(hFile, MyWebPage, fileSize, &dwBytesWritten, NULL);
//					CloseHandle(hFile);
				}
				free(MyWebPage);
			}
			InternetCloseHandle(hOpen);
			break;

		case ID_HELP_GETDATEOFPHOTOTOPO:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
//				w = 54;//just after S=
				w = 40;//just after S=
				if (MapType == PHOTO)
				{
//					GetDate[50] = '1';//T=
					GetDate[36] = '1';//T=
					GetDate[w++] = '1';
					if (Zoom < 5)
						GetDate[w++] = '0';
					else
						GetDate[w++] = '3';
				}
				else if (MapType == TOPO)
				{
//					GetDate[50] = '2';
					GetDate[36] = '2';
					GetDate[w++] = '1';
					GetDate[w++] = '2';
				}
				else//if (MapType == URBANAREA)
				{
//					GetDate[50] = '4';
					GetDate[36] = '4';
					GetDate[w++] = '8';
				}
				GetDate[w++] = '&';
				GetDate[w++] = 'Z';
				GetDate[w++] = '=';
				GetDate[w++] = Z[0];
				GetDate[w++] = Z[1];
				GetDate[w++] = '&';
				GetDate[w++] = 'X';
				GetDate[w++] = '=';
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
				if (yPos < 100)
				{//if Alt-H D not used
					UTMNorthing = ScreenTop - (((rect.bottom / 2) * MetersPerTile) / PixelsPerTile);
					UTMEasting = ScreenLeft + (((rect.right / 2) * MetersPerTile) / PixelsPerTile);
				}
				if ((MapType == PHOTO) && (Zoom < 5))
					w += sprintf(&GetDate[w], "%i", UTMEasting / 200);
				else if ((MapType == PHOTO) && (Zoom >= 5))
					w += sprintf(&GetDate[w], "%i", UTMEasting / 1600);
				else if (MapType == TOPO)
					w += sprintf(&GetDate[w], "%i", UTMEasting / 800);
				else if (MapType == URBANAREA)
					w += sprintf(&GetDate[w], "%i", UTMEasting / 50);
				GetDate[w++] = '&';
				GetDate[w++] = 'Y';
				GetDate[w++] = '=';
				if ((MapType == PHOTO) && (Zoom < 5))
					w += sprintf(&GetDate[w], "%i", UTMNorthing / 200);
				else if ((MapType == PHOTO) && (Zoom >= 5))
					w += sprintf(&GetDate[w], "%i", UTMNorthing / 1600);
				else if (MapType == TOPO)
					w += sprintf(&GetDate[w], "%i", UTMNorthing / 800);
				else if (MapType == URBANAREA)
					w += sprintf(&GetDate[w], "%i", UTMNorthing / 50);
				GetDate[w] = 0;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				for (x = 48, y = 0; GetDate[y] != 0; x++, y++)
					TerraServer[x] = GetDate[y];
				TerraServer[x] = 0;
				if (WinExec(TerraServer, SW_SHOW) <= 31)
					DialogBox(hInst, "SHOWLATLON", hwnd, LatLonProc);
			break;

		case ID_HELP_TIGERDATA:
			if (autoLoc == FALSE)
			{
				pHelp = NULL;
				hFile = CreateFile(TigerHelp, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					if (TigerHelpSize = GetFileSize(hFile, NULL))
					{
						pTigerHelp = (char*)malloc(TigerHelpSize+1);
						if (pTigerHelp == NULL)
							MessageBox(hwnd, "OHOH", "", MB_OK);
						pTigerHelp[TigerHelpSize] = 0;
						ReadFile(hFile, pTigerHelp, TigerHelpSize, &dwBytesRead, NULL);

						hMenu2 = CreateMenu();//to override parent menu bar
						hwndTigerHelp = CreateWindow(Instruct, Tiger,
							WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
							cxScreen/2-320, TitleAndMenu, (cxScreen/2 + 320)-(cxScreen/2-320), cyScreen-(cyChar*3),
							NULL, hMenu2, hInst, NULL);
						SetWindowText(hwndInstr, pTigerHelp);
						SetFocus(hwndInstr);
					}
					CloseHandle(hFile);
				}
				else
					MessageBox(hwnd, NoHelpFile, NULL, MB_OK);
			}
			break;
/*
		case ID_HELP_TIGERCOUNTIES:
			if (autoLoc == FALSE)
			{
				TigerIndex[21] = (UTMZone / 10) + '0';
				TigerIndex[22] = (UTMZone % 10) + '0';
				pHelp = NULL;
				hFile = CreateFile(TigerIndex, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					if (CountyHelpSize = GetFileSize(hFile, NULL))
					{
						pCounties = (char *) malloc(CountyHelpSize+1);
						if (pCounties == NULL)
							MessageBox(hwnd, "OHOH", "", MB_OK);
						pCounties[CountyHelpSize] = 0;
						ReadFile(hFile, pCounties, CountyHelpSize, &dwBytesRead, NULL);

						hMenu2 = CreateMenu();//to override parent menu bar
						hwndCounties = CreateWindow(Instruct, TigerIndex,
							WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
							cxScreen/2-320, TitleAndMenu, (cxScreen/2 + 320)-(cxScreen/2-320), cyScreen-(cyChar*3),
							NULL, hMenu2, hInst, NULL);
						SetWindowText(hwndInstr, pCounties);
						SetFocus(hwndInstr);
					}
					CloseHandle (hFile);
				}
//				else
//					MessageBox(hwnd, TigerIndex, "Couldn't find", MB_OK);
//				if (pCounties != NULL)
//					free(pCounties);
			}
			return 0;
*/
		case ID_HELP_ABOUTPHOTOMAP:
			EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
			if (autoLoc == FALSE)
				MessageBox(hwnd, Version, " USAPhotoMaps ", MB_OK);
			break;
		}
		return 0;


	case WM_USER8:
		CloseHandle((HANDLE)hThread);
		hThread = NULL;
		if (tiger)
		{
			tiger = 0;
			hSmallFile = CreateFile(SmallBufDta, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			fileSize = GetFileSize(hSmallFile, NULL);
			tempBuffer = (BYTE*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			ReadFile(hSmallFile, tempBuffer, fileSize, &dwBytesRead, NULL);
			CloseHandle(hSmallFile);
			for (x = 0; x < (int)fileSize; x++)
			{
				if ((tempBuffer[x] == '\r') && (tempBuffer[x+1] == '\n') && (tempBuffer[x+2] == '\r') && (tempBuffer[x+3] == '\n'))
				{
					x += 4;//hopefully to zipped data
					if ((tempBuffer[x] == 'P') && (tempBuffer[x+1] == 'K') && (x < (int)fileSize))
					{
						hFile = CreateFile(TigerZip, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
						WriteFile(hFile, &tempBuffer[x], fileSize-x, &dwBytesWritten, NULL);
						CloseHandle(hFile);
						DeleteFile(SmallBufDta);
						tiger = 1;
					}
					break;
				}
			}
			VirtualFree(tempBuffer, 0, MEM_RELEASE);
			///////////////
			if (tiger)
			{
				hThread = _beginthreadex(NULL, 0, TigerThread, NULL, 0, &idThread);
				Sleep(500);
			}
			///////////////
		}
		return 0;


	case WM_APRS_SERVER:
		switch (LOWORD(lParam))
		{
		case FD_ACCEPT:
			sAccept = accept(sListen, NULL, NULL);
			if (INVALID_SOCKET == sAccept)
			{
				MessageBox(NULL, "Error 6", ERROR, MB_OK);
				return 0;
			}
			break;

		case FD_WRITE:
			okay = TRUE;
			break;

		case FD_READ:
			send(sAccept, (char*)&aprsBuf[linebeg], linend-linebeg+1, 0);
			break;
		}
		return 0;


	case WM_APRS_IS_COMM:
		//************
		aprsISbeg = aprsISend;
		aprsISend = (int)lParam;
		//************
		for (aprsi = aprsISbeg; aprsi < aprsISend; aprsi++)
		{
//			if ((hwndComm) && (kiss == FALSE) && (aprsBuf[aprsi] != '\r'))
//				SendDlgItemMessage(hwndAPRSDlg, IDC_EDIT1, WM_CHAR, aprsBuf[aprsi], 0);
			if (aprsBuf[aprsi] == '\n')
			{
				if (isaprslinebeg != -1)
				{
					x = isaprslinebeg;
					isaprslinebeg = linend+3;
					linend = aprsi-2;
					for (z = 0; (z < 10) && (aprsBuf[x] != '>') && (x < linend); x++, z++)
						Addr[z] = aprsBuf[x];
					Addr[z] = 0;
					if (x < linend)
					{
						for (x++, y = 0; (aprsBuf[x] != ':') && (x < linend); x++, y++)
							if (y < 6)
								Dest[y] = aprsBuf[x];//for Mic-E
						if (x < linend)
						{
							x++;
							ParseAPRS(x);
						}
					}
				}
				else
					isaprslinebeg = aprsi+1;
			}
		}
		return 0;


	case WM_APRS_COMM:
		//************
		aprsBuf[aprsi] = (char)lParam;
		//************
		if ((hwndComm) && (kiss == FALSE) && (aprsBuf[aprsi] != '\r'))
			SendDlgItemMessage(hwndAPRSDlg, IDC_EDIT1, WM_CHAR, aprsBuf[aprsi], 0);
		if (shutitdown)
		{
			if ((aprsBuf[aprsi] == ':')
			 && (aprsBuf[aprsi-1] == 'd')
			 && (aprsBuf[aprsi-2] == 'm')
			 && (aprsBuf[aprsi-3] == 'c'))
			{
				shutitdown = FALSE;
				kiss = FALSE;
				SetEvent(hAPRSEvent);//close APRSCommThread
				aprsi++;
				SaveAPRSlog();
				SaveAPRSlogAsText();
				if (hwndComm != NULL)
				{
					DestroyWindow(hwndAPRSDlg);
					hwndAPRSDlg = NULL;
				}
				tnc = inaprs = 0;
				if ((!gettinginternet) && (!gettingsaved))
					aprsi = Aprsi = aprs = 0;//FALSE
				InvalidateRect(hwnd, &rect, FALSE);
				return 0;
			}
		}

		if (gotcr)
		{
			if ((lParam != '\r') && (lParam != '\n'))
				gotcr = FALSE;
			else
			{
				if (aprsimulate)
					SetEvent(hAPRSEvent);
				return 0;
			}
		}
		if ((kiss == FALSE) && (aprsBuf[aprsi] == '\n'))
		{//maybe at end of line
			gotcr = TRUE;
			if (aprsBuf[aprsi-1] == ':')
			{//an oddity
				aprsi--;//to write over odd \n
				goto notaprs;
			}
			if ((aprsBuf[aprsi-2] == ':') && (aprsBuf[aprsi-3] == '>'))//": <UI>\r\n"
			{//not the end of the line
				x = aprsi-4;
				if (aprsBuf[x] == '>')
					x--;
				if (aprsBuf[x] == 'I')
					x--;
				if (aprsBuf[x] == 'U')
					x--;
				if (aprsBuf[x] == '<')
					x--;
				if (aprsBuf[x] == '<')
					x--;
				if (aprsBuf[x] == ' ')
					x--;
				aprsi = x;
			}
			else if ((aprsBuf[aprsi-2] == 'F') && (aprsBuf[aprsi-4] == 'O') && (aprsBuf[aprsi-12] == 'M') && (aprsBuf[aprsi-8] == 'T'))
			{//MONITOR OFF\r\n
				aprsi -= 12;//over-write it
			}
			else
			{
				linend = aprsi;
				for (x = aprsi-1; x >= 0; x--)
				{
					if ((aprsBuf[x] == '\n') || (x == 0))
					{
						if (x)
							x++;
						break;
					}
				}
				if ((aprsBuf[x] == 'c') && (aprsBuf[x+1] == 'm') && (aprsBuf[x+2] == 'd') && (aprsBuf[x+3] == ':'))
					x += 4;
				if (aprsBuf[x] == '\r')
					x++;
				if (aprsBuf[x] == '\n')
					x++;
				linebeg = x;
fdsa:			for (z = 0; (z < 10) && (aprsBuf[x] != '>') && (x < linend); x++, z++)
					Addr[z] = aprsBuf[x];
				Addr[z] = 0;
				if (transmitted)
				{
					for (z = 0; Addr[z] != '\0'; z++)
						if (Addr[z] != MyCall[z])
							break;
					if ((Addr[z] == '\0') && (MyCall[z] == '\0'))
					{
						transmitted = FALSE;
						WriteFile(hAPRSComm, BTEXT, strlen(BTEXT), &dwBytesWritten, NULL);
						WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
						Sleep(500);
						WriteFile(hAPRSComm, BEACON, lstrlen(BEACON), &dwBytesWritten, NULL);
						WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
					}
				}
				if (x < linend)
				{
					for (x++, y = 0; (aprsBuf[x] != ':') && (x < linend); x++, y++)
						if (y < 6)
							Dest[y] = aprsBuf[x];//for Mic-E
					if (x < linend)
					{
						x++;
						if (aprsBuf[x] == '}')//third-party
						{
							x++;
							goto fdsa;
						}
						else
						{
							if (okay)
								PostMessage(hwnd, WM_APRS_SERVER, 0, (LPARAM)FD_READ);
							if ((igate) && (aprsBuf[x] != '?'))//no queries
							{
								for (y = x-1, z = 0; y > linebeg; y--)
								{
									if ((aprsBuf[y] == 'P') && (aprsBuf[y-1] == 'I') && (aprsBuf[y-2] == 'P') && (aprsBuf[y-3] == 'C') && (aprsBuf[y-4] == 'T'))
									{//TCPIP
										break;
									}
								}
								if (y == linebeg)
								{
									for (z = 0; (z < 250) && (aprsBuf[y] != ':') && (aprsBuf[y] != '\r'); y++, z++)
									{
										ToInternet[z] = aprsBuf[y];
									}
									if (aprsBuf[y] == ':')
									{//insert ,qAR,<call sign> and send it to the Internet
										for (w = 0; (z < 250) && (IgateInsert[w] != 0); w++, z++)
											ToInternet[z] = IgateInsert[w];
										for (w = 0; (z < 250) && (MyCall[w] != 0) && (MyCall[w] != '-'); w++, z++)
											ToInternet[z] = MyCall[w];
										for ( ; (z < 250) && (aprsBuf[y] != '\r'); y++, z++)
											ToInternet[z] = aprsBuf[y];
										if (z < 250)
										{
											ToInternet[z++] = '\r';
											ToInternet[z++] = '\n';
											ToInternet[z] = 0;
											if(s3 != INVALID_SOCKET)
											{
												if (SOCKET_ERROR == send(s3, ToInternet, strlen(ToInternet), 0))
												{
													igate = FALSE;
													sprintf(Error, "Send error %ld\n(line %d)", WSAGetLastError(), __LINE__);
													SendMessage(hwnd, WM_COMMAND, ID_APRS_INTERNETNETWORK_ACTASANIGATE, 0);
													MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
												}
												else LookForIgateMessages();
											}
											else
											{
												igate = FALSE;
												sprintf(Error, "Invalid socket\n(line %ld)", __LINE__);
												MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
											}
										}
									}
								}
							}
							ParseAPRS(x);
						}
					}
				}
			}
		}

/*KISS Frame begins with 0xC0 & Type Indicator (usually 0)
(APRS AX.25 format)
Flag 1 byte 0x7E - this is removed
(addresses are shifted 1 bit left, and all but the last byte have 0 at the least significant bit)
Control Field (UI) 1 byte 0x03
Protocol ID 1 byte 0xF0 (no layer 3 protocol)
Information Field 1-256 bytes
Frame Check Sequence 2 bytes - this is removed
KISS Frame ends with 0xC0
to end KISS, send alt-192 -255 -192
 */
		else if (kiss)
		{
			ach = aprsBuf[aprsi];
			if (gotfesc)
			{
				gotfesc = FALSE;
				if (ach == TFEND)
					ach = FEND;//0xC0
				else if (ach == TFESC)
					ach = FESC;
			}	
			else if (ach == FESC)
				gotfesc = TRUE;
			else if ((kPtr == KISSEND) && (ach == FEND))
			{
				kPtr = APRSFRAME;
				kaddr = 0;
				for (x = 0; x < 10; x++)
				{
					Addr[x] = 0;
					Dest[x] = 0;
				}
			}
			else if (kPtr == APRSFRAME)
				kPtr = TYPE;
			else if (kPtr == TYPE)
			{
				kPtr = ADDRESS;
				ach >>= 1;
				aprsBuf[aprsi] >>= 1;
				SendDlgItemMessage(hwndAPRSDlg, IDC_EDIT1, WM_CHAR, ach, 0);
				Dest[kaddr] = ach;//for Mic-E
				kaddr++;
			}
			else if (kPtr == ADDRESS)
			{
				if ((ach & 1) == 1)
					kPtr = ADDEND;
				ach >>= 1;
				aprsBuf[aprsi] >>= 1;
				SendDlgItemMessage(hwndAPRSDlg, IDC_EDIT1, WM_CHAR, ach, 0);
				if (kaddr < 6)
					Dest[kaddr] = ach;//for Mic-E
				if (kaddr == 7)
					addr = 0;
				if ((kaddr >= 7) && (kaddr <= 12))
				{
					if (ach != ' ')
						Addr[addr++] = ach;
					else 
						Addr[addr] = 0;
				}
				else if (kaddr == 13)
				{
					if ((ach >= 'q') && (ach <= '\x7F'))
					{
						ach -= 0x70;
						Addr[addr++] = '-';
						if (ach <= 9)
							Addr[addr++] = ach + '0';
						else
						{
							Addr[addr++] = (ach/10) + '0';
							Addr[addr++] = (ach%10) + '0';
						}
					}
					else if ((ach >= '1') && (ach <= '9'))
					{
						Addr[addr++] = '-';
						Addr[addr++] = ach;
					}
					else
						Addr[addr] = 0;
				}
				kaddr++;
			}
			else if (kPtr == ADDEND)
			{
				kPtr = CONTROL;
				if (ach != 3)
					goto notaprs;
			}
			else if (kPtr == CONTROL)
			{
				kPtr = PROTOCOL;
				if (ach != 0xF0)
					goto notaprs;
			}
			else if (kPtr == PROTOCOL)
			{
				kPtr = INFO;
				dataloc = aprsi;
			}
			else if (kPtr == INFO)
			{
				x = aprsi;
				if (ach == 0xC0)
				{//end of received data
					kPtr = KISSEND;
					aprsBuf[aprsi++] = '\r';//to make it work with routines that look for \r or \n
					SendDlgItemMessage(hwndAPRSDlg, IDC_EDIT1, WM_CHAR, '\r', 0);
					aprsBuf[aprsi++] = '\n';
					SendDlgItemMessage(hwndAPRSDlg, IDC_EDIT1, WM_CHAR, '\n', 0);
					ParseAPRS(dataloc);
				}
				else
				{
					aprsBuf[x++] = ach;
					SendDlgItemMessage(hwndAPRSDlg, IDC_EDIT1, WM_CHAR, ach, 0);
				}
			}
		}
notaprs:
		if (aprsi > 16300 && gotcr)
			SaveAPRSlogAsText();
		else
			aprsi++;
		if (Aprsi >= MAXAPRS-2)
			SaveAPRSlog();
		if (aprsimulate)
			SetEvent(hAPRSEvent);
		return 0;


	case WM_USER_COMM://called if GPS is on, connected, etc
		goodcomm = TRUE;
		Buf[iBuf] = (unsigned char)lParam;
		if (itsgarmin == FALSE)//using NMEA protocol
		{
			if (iLatLon != -1)//GPS is sending waypoints or tracks or position
			{
				if (iLatLon > 400)
				{
					iLatLon = -1;
					MessageBox(hwnd, "possible bug...", NULL, MB_OK);
					return 0;
				}
				if ((char)lParam != 0x0D)
				{
					tempLatLon[iLatLon++] = (char)lParam;//fill up tempLatLon & increment iLatLon until 0x0D
				}
				else//((char)lParam == 0x0D) got a line (tempLatLon is complete)
				{
					TimerFlags.nmeatiming = FALSE;
					tempLatLon[iLatLon] = 0;
					iLatLon = -1;
					if (tempLatLon[0] == ',')
					{//no data
						Lat = 0;
						Lon = 0;
						iBuf++;
						if (iBuf == 50000)
							iBuf = 0;
//						MessageBox(hwnd, "No data", "", MB_OK);
						return 0;
					}
					else
					{
						Lat = ((double)((tempLatLon[0] - '0') * 10) + (tempLatLon[1] - '0'))
						 + ((atof(&tempLatLon[2])) / 60.0);
						for (x = 0; (tempLatLon[x] != 'N') && (x < 100); x++)
							;
						if (x >= 100)
						{
							MessageBox(hwnd, "Line is over 100 chars", "", MB_OK);
							return 0;//just in case
						}
						x += 2;//to Longitude
						Lon = -((double)((tempLatLon[x] - '0') * 100)
						 + ((tempLatLon[x+1] - '0') * 10)
						 + (tempLatLon[x+2] - '0')
						 + ((atof(&tempLatLon[x+3])) / 60.0));
//						if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))//WM_LBUTTONDOWN
//							return 0;
//						else
						{
							LatRad = Lat*deg2rad;
							LonRad = Lon*deg2rad;
							LatLontoUTM();//get UTMEasting & UTMNorthing
						}
					}

					if (itsmagellan == 1)//receiving waypoints
					{//$PMGNWPL,1827.026,N,06604.448,W,0000017,M,BUS STOP,BUS STOP,x*5D
						if ((foroute))
						{
							RouteWay[routeway].Z = UTMZone;
							RouteWay[routeway].N = UTMNorthing;
							RouteWay[routeway].E = UTMEasting;
							//goto waypoint ident/name
							for (x = 0; (tempLatLon[x] != 'W') && (x < 100); x++)
								;
							x += 2;//to elevation
							for (z = 0; (tempLatLon[x] != ',') && (x < 100); x++, z++)
								;
							x++;//to either 'F,' or 'M,' or 'MYHOUSE'
							if (tempLatLon[x+1] == ',')
								x += 2;//to waypoint name
							for (y = 0; tempLatLon[x] != ','; x++, y++)
								RouteWay[routeway].Ident[y] = tempLatLon[x];
							RouteWay[routeway].Ident[y] = 0;
							if (0 != strcmp(RouteWay[routeway].Ident, RouteWay[routeway-1].Ident))
								routeway++;
						}
						else//if (tempUTMZone == UTMZone)
						{//$PMGNWPL,llll.lll,N,lllll.lll,W,aaaa,F,c----c,c---c,c--c,xx*hh<CR><LF>
							for (x = 0; (tempLatLon[x] != 'W') && (x < 100); x++)
								;
							x += 2;//to elevation
							for (z = 0; (tempLatLon[x] != ',') && (x < 100); x++, z++)
								Elev[z] = tempLatLon[x];
							Elev[z] = 0;
							x++;//to either 'F,' or 'M,' or 'MYHOUSE'
							if (tempLatLon[x] == 'F')
							{
								eleM = atoi(Elev) * 0.3048;//convert to meters
								sprintf(Elev, "%.4f", eleM);//& put it back in Elev
							}
							for (z = 0; Elev[z] != 0; z++)
								if (Elev[z] != '0')
									break;
							if (Elev[z] == 0)
								Elev[0] = 0;//don't bother with all 0's
							if (tempLatLon[x+1] == ',')
								x += 2;//to waypoint name
							IdentOffset = x;
							//get ident/name
							for (x = 0; (tempLatLon[IdentOffset+x] != ',') && (tempLatLon[IdentOffset+x] != '*'); x++)
								Ident[x] = tempLatLon[IdentOffset+x];
							Ident[x] = 0;
							//get location/comment
							x += IdentOffset;
							Location[0] = 0;
							if (tempLatLon[x] == ',')//if it's not '*'
							{
								x++;//to possible comment
								LocOffset = x;
								if (tempLatLon[x] != ',')//if it's not empty
								{
									for (z = 0; (tempLatLon[LocOffset+z] != ',') && (tempLatLon[LocOffset+z] != '*'); z++)
										Location[z] = tempLatLon[LocOffset+z];
									Location[z] = 0;
								}
								x = LocOffset + z;
							}
							Sym[0] = 0;
							if (tempLatLon[x] == ',')
							{//not '*'
								GetMagSym(x);
							}
							for (x = 0; x < EmptyLoc; x++)
							{//check for duplicate & ignore it
								if (NewLoc[x].Ident != NULL)
								{
									for (y = 0; (NewLoc[x].Ident[y] == Ident[y]) && (Ident[y] != 0); y++)
										;
									if (((NewLoc[x].Ident[y] == '<') || (NewLoc[x].Ident[y] == ' ')) && (Ident[y] == 0))
										goto magellanexit;
								}
							}
							for (x = 0; x < EmptyLoc; x++)
							{
								if ((NewLoc[x].Location != NULL) && (strcmp(NewLoc[x].Location, Location) > 0))
								{
									InsertLoc = x;
									EmptyLoc++;
									for (x = EmptyLoc; x > InsertLoc; x--)
										NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
									break;
								}
							}
							if (x == EmptyLoc)
							{
								InsertLoc = x;
								EmptyLoc++;
							}
							NewLoc[InsertLoc].EUTM = UTMEasting;
							NewLoc[InsertLoc].NUTM = UTMNorthing;
							NewLoc[InsertLoc].UTMZone = UTMZone;
///--->
							FillWaypointArray(InsertLoc);
///--->
						}//end of if(tempUTMZone == UTMZone)
magellanexit:			IncNumber();
						hdc = GetDC(hwnd);
						TextOut(hdc, xCenter, yCenter, Number, 6);//count
						ReleaseDC(hwnd, hdc);
//						SendChecksum();//need TempiBuf
					}//end of if (itsmagellan == 1)

					else if (itsmagellan == 2)//receiving tracks
					{//$PMGNTRK,1759.049,N,06637.161,W,00009,M,194354.07,A,,261202*62
					 //$PMGNTRK,4004.464,N,07500.488,W,alt,MorF,time,A*31

						FillTrackFromNMEA();

						IncNumber();
						hdc = GetDC(hwnd);
						TextOut(hdc, xCenter, yCenter, Number, 6);
						ReleaseDC(hwnd, hdc);
//						SendChecksum();
					}

					else//if (itsmagellan == 0)//receiving position
					{
						Position[pos].Alt = 0;
						Position[pos].Velocity = 0;
						Position[pos].Month = 0;
						Position[pos].Date = 0;
						Position[pos].Year = 0;
						Position[pos].HorizEpe = 0;
						Position[pos].VertEpe = 0;
//						Position[pos].New = 0;
						if (LineType != GLL)
						{
							if (newposition == FALSE)
								pos--;
							for (x = 0, y = 0; tempLatLon[x] != 0; x++)
							{
								if (tempLatLon[x] == ',')
								{
									x++;
									y++;
									if ((y == 4) && (LineType == RMC) && (tempLatLon[x] != ','))
									{
										Position[pos].Velocity = (float)(atof(&tempLatLon[x]) * 1.150779448);//to convert knots to miles/hour
										Velocity = Position[pos].Velocity;
									}
									else if ((y == 6) && (LineType == RMC))
									{
											if (tempLatLon[x] != ',')
											{
												Position[pos].Date = ((tempLatLon[x] - '0') * 10) + (tempLatLon[x+1] - '0');
												Position[pos].Month = ((tempLatLon[x+2] - '0') * 10) + (tempLatLon[x+3] - '0');
												Position[pos].Year = ((tempLatLon[x+4] - '0') * 10) + (tempLatLon[x+5] - '0');
											}
											break;
									}
									else if ((y == 7) && (LineType == GGA))
									{
										if (tempLatLon[x] != ',')
											Position[pos].Alt = (int)(atof(&tempLatLon[x+1]) / 0.3048);//in feet;
										break;
									}
								}
							}
						}
						if (newposition)
							ShowPosition();// get Position[pos].UTMZ .UTMN. and .UTME
						else
							pos++;

					}//end of else//if (itsmagellan == 0)//receiving position
				}//end of else got it all
			}//end of if (iLatLon != -1)
//*************************************************************
/*
GLL,4916.45,N,12311.12,W,225444,A
	4916.46,N    Latitude 49 deg. 16.45 min. North
	12311.12,W   Longitude 123 deg. 11.12 min. West
	225444       Fix taken at 22:54:44 UTC
	A            Data valid
//        0        1 2         3 4 5  6   7
GGA,123519,4807.038,N,01131.324,E,1,08,0.9,545.4,M,46.9,M, , *42
	123519       Fix taken at 12:35:19 UTC
	4807.038,N   Latitude 48 deg 07.038' N
	01131.324,E  Longitude 11 deg 31.324' E
	1            Fix quality: 0 = invalid 1 = GPS fix 2 = DGPS fix
	08           Number of satellites being tracked
	0.9          Horizontal dilution of position
	545.4,M      Altitude, Metres, above mean sea level
	46.9,M       Height of geoid (mean sea level) above WGS84 ellipsoid
	(empty field) time in seconds since last DGPS update
	(empty field) DGPS station ID number
//          0       1 2        3 4     5     6
RMC,225446,A,4916.45,N,12311.12,W,000.5,054.7,191194,020.3,E*68
	225446       Time of fix 22:54:46 UTC
	A            A = Valid position, V = not valid
	4916.45,N    Latitude 49 deg. 16.45 min. North
	12311.12,W   Longitude 123 deg. 11.12 min. West
	000.5        Speed over ground, Knots
	054.7        Course Made Good, degrees true
	191194       UTC Date of fix, 19 November 1994
	020.3,E      Magnetic variation, 20.3 deg. East
// 0       1 2        3 4
WPL,4917.16,N,12310.64,W,003*65
*/
			else if (showposition)
			{
				if (Buf[iBuf-6] == '$')
				{
					if ((LineType <= 1) && (Buf[iBuf-3] == 'G') && (Buf[iBuf-2] == 'L') && (Buf[iBuf-1] == 'L'))
					{//GLL - don't bother about commas, you're already at comma before Latitude
						LineType = GLL;
						itsmagellan = 0;
						iLatLon = 0;//flag & initialize
//						TimerFlags.nmeatiming = FALSE;
					}
					else if ((Buf[iBuf-3] == 'G') && (Buf[iBuf-2] == 'G') && (Buf[iBuf-1] == 'A'))
					{//$GPGGA,184526,3724.456,N,12206.978,W,1,04,2.1,23.7,M,-28.4,M,,*4A
					 //$GPGGA,045310,3443.1675,N,11609.7312,W,0,0,0.00,583,M,,,,*1C
						LineType = GGA;
						commas = 1;
						Time = iBuf+1;
					}
					else if ((Buf[iBuf-3] == 'R') && (Buf[iBuf-2] == 'M') && (Buf[iBuf-1] == 'C'))
					{//$GPRMC,164825,V,3428.480298,N,09133.261421,W,000.00,0.0,080304,2.6,E*4C
					 //UTC time, warning, lat, lon, speed, true course, date (daymonyear), mag var, east or west
						LineType = RMC;
						commas = 0;
						Time = iBuf+1;
					}
//					else if ((Buf[iBuf-3] == 'W') && (Buf[iBuf-2] == 'P') && (Buf[iBuf-1] == 'L'))
//					{//&GPWPL,4917.16,N,12310.64,W,003*65
//						LineType = WPL;
//						itsmagellan = 0;
//						commas = 0;
//					}
				}
				else if ((Buf[iBuf] == ',') && (commas != 0xFF))
				{
					commas++;
					if (commas == 2)
					{//next char will be beginning of latitude
						newposition = TRUE;
						if (Buf[Time] != ',')
						{
							Position[pos].Hour = ((Buf[Time] - '0') * 10) + (Buf[Time+1] - '0');
							Position[pos].Min = ((Buf[Time+2] - '0') * 10) + (Buf[Time+3] - '0');
							Position[pos].Sec = ((Buf[Time+4] - '0') * 10) + (Buf[Time+5] - '0');
							if ((Position[pos].Sec == Position[pos-1].Sec) && (Position[pos].Min == Position[pos-1].Min) && (Position[pos].Hour == Position[pos-1].Hour))
								newposition = FALSE;
						}
						else
						{
							Position[pos].Hour = 0;
							Position[pos].Min = 0;
							Position[pos].Sec = 0;
						}
						commas = 0xFF;
						itsmagellan = 0;
						iLatLon = 0;//flag & initialize
						TimerFlags.nmeatiming = FALSE;
					}
				}
			}
//if MAGELLAN:
			else if ((Buf[iBuf-8] == '$') && (Buf[iBuf-3] == 'W') && (Buf[iBuf-2] == 'P') && (Buf[iBuf-1] == 'L'))
			{//$PMGNWPL,llll.lll,N,lllll.lll,W,aaaa,F,c----c,c---c,c--c,xx*hh<CR><LF>
//				TempiBuf = iBuf - 7;//for checksum
				itsmagellan = 1;
				iLatLon = 0;
			}
			else if ((Buf[iBuf-8] == '$') && (Buf[iBuf-3] == 'T') && (Buf[iBuf-2] == 'R') && (Buf[iBuf-1] == 'K'))
			{//$PMGNTRK
//				TempiBuf = iBuf - 7;//for checksum
				itsmagellan = 2;
				iLatLon = 0;
			}

			else if (Buf[iBuf] == '\n')
			{//got end of line
				for (xBuf = iBuf; (Buf[xBuf] != '$') && (Buf[xBuf] != 0); xBuf--)
					;//go to beginning of line
				if (Buf[xBuf] != 0)
				{//now see what's on the line
					if ((Buf[xBuf+5] == 'R') && (Buf[xBuf+6] == 'T') && (Buf[xBuf+7] == 'E'))
					{//$PMGNRTE,5,1,c,01,1,a,2*32
//						TempiBuf = xBuf+1;//for checksum
						for (x = xBuf, y = 0; Buf[x] != '*'; x++)
						{
							if ((y == 3) && (Buf[x] == ',') && (Buf[x-1] != 'c'))
							{//if it's a message instead of a list of routes
								y = 0;
								break;
							}
							if (Buf[x] == ',')
								y++;
							if (y >= 5)//at waypoint name (or maybe symbol)
							{
								x++;//past ','

								z = x;//beginning of ident/name
								if ((Buf[x] < 'a') || (Buf[x] > 'z'))
								{//not a symbol
									for ( ; (Buf[x] != ',') && (Buf[x] != '*'); x++)
										;//RouteWay[y].Ident[z]
									ch = Buf[x];//save it
									Buf[x] = 0;//to end string
									for (w = 0; w < routeway; w++)
									{
										if ((RouteWay[w].Ident[0] != 0)
										 && (0 == strcmp((char*)&Buf[z], RouteWay[w].Ident)))
										{//got UTM from name
											Root[0][rte].N = RouteWay[w].N;
											Root[0][rte].E = RouteWay[w].E;
											Root[0][rte].Z = RouteWay[w].Z;
											rte++;
											RouteWay[w].Ident[0] = 0;//to not use it again
											break;
										}
									}
									Buf[x] = ch;
									x--;//because it will be incremented before anything else
								}
								if (Buf[x] == '*')
									break;//done with line
							}//end of if (y >= 5)
						}
						gotroute = TRUE;
						IncNumber();
						hdc = GetDC(hwnd);
						TextOut(hdc, xCenter, yCenter, Number, 6);
						ReleaseDC(hwnd, hdc);
//						SendChecksum();
					}
//////////////////////////////////////////////////////////////////////////////////////////////////
//					else if ((Buf[xBuf+9] == 'U') &&  (Buf[xBuf+10] == 'N') &&  (Buf[xBuf+11] == 'A'))
//					{//$PMGNCMD,UNABLE*63
//						x=1;
//					}
					else if ((Buf[xBuf+5] == 'V') && (Buf[xBuf+6] == 'E') && (Buf[xBuf+7] == 'R'))
					{//$PMGNVER,024,REV 3.15,GPS 315/320*7A
						gotver = TRUE;
						SetEvent(hEvent);//signal it
 						TimerFlags.nmeatiming = FALSE;//un-commented out July 28, 2005
						if (magflag != 0)
						{
							for (x = 0; SendMagellanHANDOFF[x] != 0; x++, tgcount++)
								ToGPS[tgcount] = SendMagellanHANDOFF[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &SendMagellanHANDOFF, sizeof(SendMagellanHANDOFF)-1, &dwBytesWritten, NULL);
							Sleep(50);
						}
						if ((Buf[xBuf+10] == '3') && (Buf[xBuf+11] != '1'))
							itsmeridian = TRUE;
						else
							itsmeridian = FALSE;
//						WriteFile(hComm, &SendMagellanTON, sizeof(SendMagellanTON)-1, &dwBytesWritten, NULL);
//						Sleep(50);
						if (magflag == GETWAYPOINTS)
						{
							magflag = 0;
							for (x = 0; GetMagellanWaypoints[x] != 0; x++, tgcount++)
								ToGPS[tgcount] = GetMagellanWaypoints[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &GetMagellanWaypoints, sizeof(GetMagellanWaypoints)-1, &dwBytesWritten, NULL);
							Sleep(50);
						}

						else if (magflag == SENDWAYPOINTS)
						{
							magflag = 0;
							if (onewaypoint)
							{
								onewaypoint = FALSE;
								LocNum = ChosenLoc;
								x = PrepMagellanWaypoint();
								WriteFile(hComm, &SendMagWaypoints, x, &dwBytesWritten, NULL);
								for (x = 0; SendMagWaypoints[x] != 0; x++, tgcount++)
									ToGPS[tgcount] = SendMagWaypoints[x];
								if (tgcount > 49900) tgcount = 0;
								LocNum = EmptyLoc;
//								Sleep(50);
								MessageBox(hwnd, "Sent", "Waypoint", MB_OK);
							}
							else if (LocNum < EmptyLoc)
							{
							hwndCounter = CreateWindow(Counter, Counter,
									WS_CHILD | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
									(cxScreen/2)-75, (cyScreen/2)-((8*cyChar)/2), 150, 8*cyChar,
									hwnd, (HMENU)159, hInst, NULL);
							GetClientRect(hwndCounter, &counterRect);
							}
							while (LocNum < EmptyLoc)//send another one
							{
								x = PrepMagellanWaypoint();
								IncCount();
								LocNum++;
								WriteFile(hComm, &SendMagWaypoints, x, &dwBytesWritten, NULL);
								for (x = 0; SendMagWaypoints[x] != 0; x++, tgcount++)
									ToGPS[tgcount] = SendMagWaypoints[x];
								if (tgcount > 49900) tgcount = 0;
								Sleep(50);
							}
							for (x = 0; SendEnd[x] != 0; x++, tgcount++)
								ToGPS[tgcount] = SendEnd[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &SendEnd, sizeof(SendEnd)-1, &dwBytesWritten, NULL);
							Sleep(50);

							if (sendroutewaypoints)
							{//if last waypoint sent & sending waypoints for route
								sendroutewaypoints = FALSE;
								LocNum = 0;
								RouteName[0] = '0';
								RouteName[1] = '1';
								do
								{//send multiple routes for more than 30 waypoints
									routeline = 1;
									if (RouteName[1] > '9')
									{
										RouteName[1] = '0';
										RouteName[0]++;
									}
									if (numofRoutes < 30)
									{
										totalroutelines = (numofRoutes / 3);
										if (numofRoutes % 3)
											totalroutelines++;
									}
									else
										totalroutelines = 10;//for 30 waypoints
									while (routeline <= totalroutelines)
									{
										y = PrepSendRoute();
										for (x = 0; SendRoute[x] != 0; x++, tgcount++)
											ToGPS[tgcount] = SendRoute[x];
										if (tgcount > 49900) tgcount = 0;
										WriteFile(hComm, &SendRoute, y, &dwBytesWritten, NULL);
										Sleep(50);
										//$PMGNRTE,2,1,c,01,1,2,3,4*xx<CR><LF>
									}
									for (x = 0; SendEnd[x] != 0; x++, tgcount++)
										ToGPS[tgcount] = SendEnd[x];
									if (tgcount > 49900) tgcount = 0;
									WriteFile(hComm, &SendEnd, sizeof(SendEnd)-1, &dwBytesWritten, NULL);
									Sleep(50);
								}
								while (numofRoutes);
							}
							SendMessage(hwndCounter, WM_CLOSE, 0, 0);
						}

						else if (magflag == GETTRACKS)
						{
							magflag = 0;
							for (x = 0; GetMagellanTracks[x] != 0; x++, tgcount++)
								ToGPS[tgcount] = GetMagellanTracks[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &GetMagellanTracks, sizeof(GetMagellanTracks)-1, &dwBytesWritten, NULL);
							Sleep(50);
						}
					}
					else if ((Buf[xBuf+9] == 'E') && (Buf[xBuf+10] == 'N') && (Buf[xBuf+11] == 'D'))
					{//$PMGNCMD,END*3D (finished getting waypoints, tracks, or routes)
						MessageBeep(MB_OK);
//						TempiBuf = xBuf+1;
//						SendChecksum();
						if (itsmagellan == 2)
						{//receiving tracks
							itsmagellan = 0;
							hFile = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
							fileSize = sizeof(trak[0]);
							trak[tnum].time = 0;
							WriteFile(hFile, TrackHead, strlen(TrackHead), &dwBytesWritten, NULL);
							Sleep(50);
							for (y = 0; y < tnum; y++)
								WriteTracks(hFile, y);
							CloseHandle(hFile);
							if (inutmzone)
							{
								BeginY = trak[0].NUTM / MetersPerTile;
								BeginX = trak[0].EUTM / MetersPerTile;
								rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
								colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
//								showingtracks = TRUE;
//								fromTracks = TRUE;
//								editingtracks = FALSE;
//								CreateTracks();
							}
							else
							{
								Lat = tempLat;
								Lon = tempLon;
								UTMZone = tempUTMZone;
								UTMNorthing = tempUTMN;
								UTMEasting = tempUTME;
							}
							SetEvent(hEventExit);
							showingtracks = TRUE;
							fromTracks = TRUE;
							editingtracks = FALSE;
//							CreateTracks();
							fromusbtracks = TRUE;
							trackUTMZone = trak[0].time >> 26;//UTMZone in new Track.dta format
							SendMessage(hwnd, WM_USER, 0, 0);
						}

						if (foroute)
						{
							foroute = FALSE;
							rte = 0;//for Root[rte]
							Number[0] = ' ';
							for (y = 1; y < 5; y++)
								Number[y] = '0';
							Number[5] = ' ';
							xCenter = (rect.right/2) - (cxChar*4);
							yCenter = rect.bottom/2;
							for (x = 0; GetMagellanRoute[x] != 0; x++, tgcount++)
								ToGPS[tgcount] = GetMagellanRoute[x];
							if (tgcount > 49900) tgcount = 0;
							WriteFile(hComm, &GetMagellanRoute, sizeof(GetMagellanRoute)-1, &dwBytesWritten, NULL);
							Sleep(50);
						}
						else if (gotroute)
						{
							if (0 != GetSaveFileName(&ofn3))
							{
								hFile = CreateFile(FullRoutes, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
								for (z = 0; z < rte; z++)
								{
									y = 0;
									Raut[y++] = (Root[0][z].Z / 10) + '0';
									Raut[y++] = (Root[0][z].Z % 10) + '0';
									Raut[y++] = ',';
									_itoa(Root[0][z].N, RouteDist, 10);
									for (x = 0; RouteDist[x] != 0; x++, y++)
										Raut[y] = RouteDist[x];
									Raut[y++] = ',';
									_itoa(Root[0][z].E, RouteDist, 10);
									for (x = 0; RouteDist[x] != 0; x++, y++)
										Raut[y] = RouteDist[x];
									Raut[y++] = '\r';
									Raut[y++] = '\n';
									WriteFile(hFile, Raut, y, &dwBytesWritten, NULL);
									Sleep(50);
								}
								CloseHandle(hFile);
							}
						}
						magflag = 0;
						InvalidateRect(hwnd, &rect, FALSE);
					}
				}//end of if (Buf[xBuf] != 0)
			}//end of else if ((Buf[iBuf-1] == '\x0A') && (iBuf != 0))
		}//end of NMEA

//*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		else//if (itsgarmin) - DLE, PacketID, DataSize, Data, Checksum, DLE, ETX
		{
			TimerFlags.timing = FALSE;
			switch (GarminFlag)
			{
			case GOT_ETX://3
				if (Buf[iBuf] == DLE)
					GarminFlag = GOT_FIRST_DLE;
				break;
			case GOT_FIRST_DLE://16 or 0x10
				ReceivedPID = Buf[iBuf];
				if (ReceivedPID == ETX)
				{//could happen on first input
					GarminFlag = GOT_ETX;
					break;
				}
				GarminFlag = GOT_PID;
				break;
			case GOT_PID:
				if ((Buf[iBuf] == DLE) && (gotaDLE == FALSE))
				{
					gotaDLE = TRUE;
					break;//ignore first DLE
				}
				if (gotaDLE == TRUE)
					gotaDLE = FALSE;
				ReceivedDataSize = Buf[iBuf];
				i = 0;
				for (x = 0; x < 0xFF; x++)
					ReceivedData[x] = 0;
				GarminFlag = GOT_DATASIZE;
				break;
			case GOT_DATASIZE:
				if (ReceivedDataSize == 0)
				{
					GarminFlag = GOT_DATA;
					break;
				}
				if ((Buf[iBuf] == DLE) && (gotaDLE == FALSE))
				{
					gotaDLE = TRUE;
					break;//ignore first DLE
				}
				if (gotaDLE == TRUE)
					gotaDLE = FALSE;
				ReceivedData[i++] = Buf[iBuf];
				if (i == ReceivedDataSize)
					GarminFlag = GOT_DATA;
				break;
			case GOT_DATA:
				if ((Buf[iBuf] == DLE) && (gotaDLE == FALSE))
				{
					gotaDLE = TRUE;
					break;//ignore first DLE
				}
				if (gotaDLE == TRUE)
					gotaDLE = FALSE;
				GarminFlag = GOT_CHECKSUM;
				break;
			case GOT_CHECKSUM:
				GarminFlag = GOT_LAST_DLE;
if (ReceivedPID == XFER_CMPLT)
	goto aaa;
				break;
			case GOT_LAST_DLE:
aaa:
				GarminFlag = GOT_ETX;
				TimerFlags.garmintiming = FALSE;

				if (ReceivedPID == ROUTE_LINK)
				{
					ACKPacket[3] = ReceivedPID;
					ACKPacket[5] = ~(ACK + 2 + ReceivedPID) + 1;//checksum
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = ACKPacket[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);
				}

				else if (ReceivedPID == ROUTE_HEADER)
				{
					RouteNum++;
					rte = 0;
					if (d201)
					{
						for (x = 0; (ReceivedData[x+1] != 0) && (x < 20); x++)
							RouteComment[RouteNum][x] = ReceivedData[x+1];
					}
					else
					{
						for (x = 0; ReceivedData[x] != 0; x++)
							RouteComment[RouteNum][x] = ReceivedData[x];
					}
					RouteComment[RouteNum][x] = 0;
					ACKPacket[3] = ReceivedPID;
					ACKPacket[5] = ~(ACK + 2 + ReceivedPID) + 1;//checksum
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = ACKPacket[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);
				}

				else if (ReceivedPID == ROUTE_DATA)
				{
					semicircleN = *(signed int*)&ReceivedData[Noffset];
					semicircleE = *(signed int*)&ReceivedData[Eoffset];
					Lat = (double) (semicircleN * semicircle2deg);
					Lon = (double) (semicircleE * semicircle2deg);
					LatRad = (double) (semicircleN * semicircle2rad);
					LonRad = (double) (semicircleE * semicircle2rad);
					LatLontoUTM();
					Root[RouteNum][rte].Z = UTMZone;
					Root[RouteNum][rte].N = UTMNorthing;
					Root[RouteNum][rte].E = UTMEasting;
					rte++;
					RouteSize[RouteNum] = rte;
					IncCount();
					ACKPacket[3] = ReceivedPID;
					ACKPacket[5] = ~(ACK + 2 + ReceivedPID) + 1;//checksum (needs extra DLE if ReceivedPID == -24)
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = ACKPacket[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);//acknowledge everything else
				}

				else if (ReceivedPID == PVT_DATA)//receiving position
				{
					Pvt.alt = *(float*)&ReceivedData[0];
					Pvt.epe = *(float*)&ReceivedData[4];
					Pvt.eph = *(float*)&ReceivedData[8];
					Pvt.epv = *(float*)&ReceivedData[12];
					Pvt.fix = *(WORD*)&ReceivedData[16];
					Pvt.tow = *(double*)&ReceivedData[18];
					Pvt.lat = *(double*)&ReceivedData[26];//radians
					Pvt.lon = *(double*)&ReceivedData[34];//radians
					Pvt.lon_vel = *(float*)&ReceivedData[42];
					Pvt.lat_vel = *(float*)&ReceivedData[46];
					Pvt.alt_vel = *(float*)&ReceivedData[50];
					Pvt.msl_hght = *(float*)&ReceivedData[54];
					Pvt.leap_sec = *(WORD*)&ReceivedData[58];
					Pvt.grmn_days = *(UINT*)&ReceivedData[60];
					if ((Pvt.lat != 0.0) && (Pvt.lon != 0.0))
						ShowPosition();
					else
						MessageBox(hwnd, "Lat or Lon is 0", ERROR, MB_OK);
				}//end of if (ReceivedPID == PVT_DATA)

				else if (ReceivedPID == ACK)
				{
					switch (fromFlag)
					{
					case MENU:
						SendMessage(hwnd, WM_COMMAND, ID_STOPPOSITIONING, 0);
						break;//slightly trick
					case LBUTTON:
						lParam = lButtonDotX + (lButtonDotY << 16);//just send it back to itself in the right format
						SendMessage(hwnd, WM_LBUTTONDOWN, 0, lParam);
						break;
					case RBUTTON:
						SendMessage(hwnd, WM_RBUTTONDOWN, 0, 0);
						break;
					case UP:
						SendMessage(hwnd, WM_KEYDOWN, VK_UP, 0);
						break;
					case DOWN:
						SendMessage(hwnd, WM_KEYDOWN, VK_DOWN, 0);
						break;
					case LEFT:
						SendMessage(hwnd, WM_KEYDOWN, VK_LEFT, 0);
						break;
					case RIGHT:
						SendMessage(hwnd, WM_KEYDOWN, VK_RIGHT, 0);
						break;
					}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
					if ((ReceivedData[0] == 0x0A) && (sendingStop))//STOP SENDING!
					{
						sendingStop = FALSE;
						SetEvent(hEventExit);
					}
////////////////////////////////////////////////////////////////////////////////////////////////////////////

					else if ((ReceivedData[0] == RECORDS)
					 || (ReceivedData[0] == WAYPOINT)
					 || (ReceivedData[0] == TRACK)
					 || (ReceivedData[0] == ROUTEHEADER)
					 || (ReceivedData[0] == ROUTE)
					 || (ReceivedData[0] == ROUTELINK)
					 || (ReceivedData[0] == TRACKHEADER))
					{
						if (ReceivedData[0] == RECORDS)
						{
							if (counteropen)
							{
								SendMessage(hwndCounter, WM_CLOSE, 0, 0);
								counteropen = FALSE;
							}
							hwndCounter = CreateWindow(Counter, Counter,
								WS_CHILD | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
								(cxScreen/2)-75, (cyScreen/2)-((8*cyChar)/2), 150, 8*cyChar,
								hwnd, (HMENU)149, hInst, NULL);
							GetClientRect(hwndCounter, &counterRect);
							counteropen = TRUE;
						}
						if (sendingWaypoints)
						{//sending waypoints
							if (onewaypoint)
							{
								onewaypoint = FALSE;
								LocNum = ChosenLoc;
								PrepWaypoint();
								WriteFile(hComm, &Waypoint, SendWaypointSize, &dwBytesWritten, NULL);
								for (x = 0; x < SendWaypointSize; x++, tgcount++)
									ToGPS[tgcount] = Waypoint[x];
								if (tgcount > 49900) tgcount = 0;
								LocNum = EmptyLoc;
							}
							else if (LocNum < EmptyLoc)//send another one
							{
									IncCount();
									PrepWaypoint();
									LocNum++;
									WriteFile(hComm, &Waypoint, SendWaypointSize, &dwBytesWritten, NULL);
									for (x = 0; x < SendWaypointSize; x++, tgcount++)
										ToGPS[tgcount] = Waypoint[x];
									if (tgcount > 49900) tgcount = 0;
							}
							else
							{
								WriteFile(hComm, &EndRecords, 8, &dwBytesWritten, NULL);
								for (x = 0; x < 8; x++, tgcount++)
									ToGPS[tgcount] = EndRecords[x];
								if (tgcount > 49900) tgcount = 0;
								sendingWaypoints = FALSE;
								SendMessage(hwndCounter, WM_CLOSE, 0, 0);
							}
						}

						else if (sendingrouteheader)
						{
							sendingrouteheader = FALSE;
							sendingroute = TRUE;
							x = 0;
							SendRouteHeader[x++] = DLE;
							SendRouteHeader[x++] = ROUTEHEADER;
							SendRouteHeader[x++] = 21;//data size
							if (d201)
							{
								SendRouteHeader[x++] = 3;//route number
								gotzero = FALSE;
								for (y = 0; y < 20; y++)
								{
									if (Routes[y] == '.')
										Routes[y] = 0;
									if (Routes[y] == 0)
										gotzero = TRUE;
									if (gotzero == TRUE)
										SendRouteHeader[x++] = ' ';
									else
									{
										c = Routes[y];
										if ((c >= 'a') && (c <= 'z'))
											c &= 0xDF;//make uppercase
										SendRouteHeader[x++] = c;
									}
								}
							}
							else//if d202
							{
								for (y = 0; (Routes[y] != '.') && (Routes[y] != 0); y++)
								{
									if ((Routes[y] >= 'a') && (Routes[y] <= 'z'))
										SendRouteHeader[x++] = Routes[y] & 0xDF;//make uppercase
									else
										SendRouteHeader[x++] = Routes[y];
								}
								SendRouteHeader[x++] = 0;
								SendRouteHeader[2] = x-3;//data size
							}
							checksum = 0;
							for (z = 1; z < x; z++)
							{
								if (SendRouteHeader[z] == DLE)
									z++;//ignore first DLE
								checksum += SendRouteHeader[z];
							}
							SendRouteHeader[x++] = ~(checksum) + 1;
							if (SendRouteHeader[y-1] == DLE)
								SendRouteHeader[y++] = DLE;
							SendRouteHeader[x++] = DLE;
							SendRouteHeader[x++] = ETX;
							WriteFile(hComm, &SendRouteHeader, x, &dwBytesWritten, NULL);
							for (y = 0; y < x; y++, tgcount++)
								ToGPS[tgcount] = SendRouteHeader[y];
							if (tgcount > 49900) tgcount = 0;
						}

						else if (sendingroutelink)
						{//must be before else if (sendingroute)
							sendingroutelink = FALSE;
							WriteFile(hComm, &SerialRouteLink, 27, &dwBytesWritten, NULL);
							for (y = 0; y < 27; y++, tgcount++)
								ToGPS[tgcount] = SerialRouteLink[y];
							if (tgcount > 49900) tgcount = 0;
						}

						else if (sendingroute)
						{
							if (TrackNum < numofRoutes)//borrowing TrackNum
							{
								if (d210)
									sendingroutelink = TRUE;
								IncCount();
								GetRandomNum();
								PrepRoute();
								TrackNum++;
								WriteFile(hComm, &Waypoint, SendWaypointSize, &dwBytesWritten, NULL);
								for (y = 0; y < SendWaypointSize; y++, tgcount++)
									ToGPS[tgcount] = Waypoint[y];
								if (tgcount > 49900) tgcount = 0;
							}
							else
							{
								sendingroute = FALSE;
								WriteFile(hComm, &EndRecords, 8, &dwBytesWritten, NULL);
								for (y = 0; y < 8; y++, tgcount++)
									ToGPS[tgcount] = EndRecords[y];
								if (tgcount > 49900) tgcount = 0;
								SendMessage(hwndCounter, WM_CLOSE, 0, 0);
							}
						}

						else if (sendingtrackheader)
						{
							BYTE Trackheader[100];

							sendingtrackheader = FALSE;
							y = 0;
							Trackheader[y++] = DLE;
							Trackheader[y++] = TRACKHEADER;
							for (x = 0; (Tracks[x] != '.') && (Tracks[x] != 0); x++)
								;
							Trackheader[y++] = x+3;
							if (x+3 == DLE)
								Trackheader[y++] = x+3;
							Trackheader[y++] = 1;//display on screen
							Trackheader[y++] = 0xFF;//default color
							for (x = 0; (Tracks[x] != '.') && (Tracks[x] != 0); x++, y++)
								Trackheader[y] = Tracks[x];
							Trackheader[y++] = 0;
							checksum = 0;
							for (z = 1; z < y; z++)
							{
								if (Trackheader[z] == DLE)
									z++;//ignore first DLE
								checksum += Trackheader[z];
							}
							Trackheader[y++] = ~(checksum) + 1;
							if (Trackheader[y-1] == DLE)
								Trackheader[y++] = DLE;
							Trackheader[y++] = DLE;
							Trackheader[y++] = ETX;
							WriteFile(hComm, &Trackheader, y, &dwBytesWritten, NULL);
							for (x = 0; x < y; x++, tgcount++)
								ToGPS[tgcount] = Trackheader[x];
							if (tgcount > 49900) tgcount = 0;
						}

						else//if sending tracks
						{
							if (TrackNum < numofTracks)
							{
								IncCount();
								TrackSize = PrepTrack();
								WriteFile(hComm, &SendTrack, TrackSize, &dwBytesWritten, NULL);
								for (y = 0; y < TrackSize; y++, tgcount++)
									ToGPS[tgcount] = SendTrack[y];
								if (tgcount > 49900) tgcount = 0;
								TrackNum++;
							}
							else
							{
								WriteFile(hComm, &EndRecords, 8, &dwBytesWritten, NULL);
								for (y = 0; y < 8; y++, tgcount++)
									ToGPS[tgcount] = EndRecords[y];
								if (tgcount > 49900) tgcount = 0;
								SendMessage(hwndCounter, WM_CLOSE, 0, 0);
							}
						}
					}
					else if (ReceivedData[0] == XFER_CMPLT)//GPS acknowledges my EndRecords (XFER_CMPLT) message
					{
						sendingStop = FALSE;//to stop Comm Thread when GPS acknowledges
						if (showposition)
							WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
						for (y = 0; y < 8; y++, tgcount++)
							ToGPS[tgcount] = StopPVTPacket[y];
						if (tgcount > 49900) tgcount = 0;
						SendMessage(hwndCounter, WM_CLOSE, 0, 0);
						SetEvent(hEventExit);
					}
				}//end of if (ReceivedPID == ACK)

				else if (ReceivedPID == NAK)
				{
					if (sendingWaypoints)
					{
						MessageBeep(MB_OK);
						hdc = GetDC(hwnd);
						TextOut(hdc, 0, BadSend*cyChar, BadWaypoint, sizeof(BadWaypoint)-1);
						ReleaseDC(hwnd, hdc);
						BadSend++;
						if (LocNum < EmptyLoc)//send another one
						{
							PrepWaypoint();
							LocNum++;
							WriteFile(hComm, &Waypoint, SendWaypointSize, &dwBytesWritten, NULL);
							for (y = 0; y < SendWaypointSize; y++, tgcount++)
								ToGPS[tgcount] = Waypoint[y];
							if (tgcount > 49900) tgcount = 0;
						}
						else
						{
							WriteFile(hComm, &EndRecords, 8, &dwBytesWritten, NULL);
							for (y = 0; y < 8; y++, tgcount++)
								ToGPS[tgcount] = EndRecords[y];
							if (tgcount > 49900) tgcount = 0;
							sendingWaypoints = FALSE;
						}
					}
					else
					{
						MessageBox(hwnd, "Got a NAK!\nAborting transfer!", ERROR, MB_OK);
						return 0;
					}
				}

				else if (ReceivedPID == RECORDS)
				{
					Records = *(WORD*)pRecords;
					remainder = Records % 10000;
					Counting[8] = (remainder / 1000) + '0';
					Counting[9] = ((remainder % 1000) / 100) + '0';
					Counting[10] = ((remainder % 100) / 10) + '0';
					Counting[11] = (remainder % 10) + '0';
					if (counteropen)
					{
						SendMessage(hwndCounter, WM_CLOSE, 0, 0);
						counteropen = FALSE;
					}
					hwndCounter = CreateWindow(Counter, Counter,
						WS_CHILD | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
						(cxScreen/2)-75, (cyScreen/2)-((8*cyChar)/2), 150, 8*cyChar,
						hwnd, (HMENU)159, hInst, NULL);
					GetClientRect(hwndCounter, &counterRect);
					counteropen = TRUE;

					ACKPacket[3] = ReceivedPID;
					ACKPacket[5] = ~(ACK + 2 + ReceivedPID) + 1;//checksum (needs extra DLE if ReceivedPID == -24)
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);//acknowledge everything else
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = ACKPacket[y];
					if (tgcount > 49900) tgcount = 0;
				}
				else if ((ReceivedPID == TRACK) && (tnum < numofTracks) && (d300 || d301 || d302))//TRACK_SIZE
				{//receiving tracks
					trak[tnum].NUTM = *(int*)&ReceivedData[0];
					trak[tnum].EUTM = *(int*)&ReceivedData[4];
					trak[tnum].time = *(unsigned int*)&ReceivedData[8];
					if (d301)
					{
//						f = *(float*)&ReceivedData[12];
//						if (f != 1.00000e+025)
						if (*(UINT*)&ReceivedData[12] != 0x69045951)
						{
							f = *(float*)&ReceivedData[12];
							f /= (float)0.3048;//convert meters to feet
							trak[tnum].alt = f;
						}
						else
							trak[tnum].alt = 0.0;
						trak[tnum].newtrk = *(unsigned char*)&ReceivedData[20];
					}
					else if (d302)
					{
//						f = *(float*)&ReceivedData[12];
//						if (f != 1.0e25)
						if (*(UINT*)&ReceivedData[12] != 0x69045951)
						{
							f = *(float*)&ReceivedData[12];
							f /= (float)0.3048;//convert meters to feet
							trak[tnum].alt = f;
						}
						else
							trak[tnum].alt = 0.0;
						trak[tnum].newtrk = *(unsigned char*)&ReceivedData[24];
					}
					else if (d300)//this needs to be last since it can also be true
						trak[tnum].newtrk = *(unsigned char*)&ReceivedData[12];

					tnum++;
					gettingtracks = TRUE;
					IncCount();
					ACKPacket[3] = ReceivedPID;
					ACKPacket[5] = ~(ACK + 2 + ReceivedPID) + 1;//~(6+2+34) + 1 = 214
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);//acknowledge everything else
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = ACKPacket[y];
					if (tgcount > 49900) tgcount = 0;
				}

				else if (ReceivedPID == XFER_CMPLT)
				{
					sendingStop = FALSE;
					SendMessage(hwndCounter, WM_CLOSE, 0, 0);
					SetEvent(hEventExit);

					if (gettingtracks)
						SaveDownloadedTracks();

					else if (gettingroute)
					{
						gettingroute = FALSE;
						for (w = 0; w <= RouteNum; w++)
						{
							rte = RouteSize[w];
							if (RouteComment[w][0] != 0)
							{
								for (z = 0; RouteComment[RouteNum][z] != 0; z++)
									FullRoutes[z] = RouteComment[w][z];
								FullRoutes[z] = 0;
							}
							if (FALSE != GetSaveFileName(&ofn3))
							{
								hFile = CreateFile(FullRoutes, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
								for (z = 0; z < rte; z++)
								{
									y = 0;
									Raut[y++] = (Root[w][z].Z / 10) + '0';
									Raut[y++] = (Root[w][z].Z % 10) + '0';
									Raut[y++] = ',';
									_itoa(Root[w][z].N, RouteDist, 10);
									for (x = 0; RouteDist[x] != 0; x++, y++)
										Raut[y] = RouteDist[x];
									Raut[y++] = ',';
									_itoa(Root[w][z].E, RouteDist, 10);
									for (x = 0; RouteDist[x] != 0; x++, y++)
										Raut[y] = RouteDist[x];
									Raut[y++] = '\r';
									Raut[y++] = '\n';
									WriteFile(hFile, Raut, y, &dwBytesWritten, NULL);
								}
								CloseHandle(hFile);
							}
						}
					}

					Lat = tempLat;
					Lon = tempLon;
					UTMZone = tempUTMZone;
					UTMNorthing = tempUTMN;
					UTMEasting = tempUTME;
					InvalidateRect(hwnd, &rect, FALSE);
					UpdateWindow(hwnd);
				}//end of ReceivedPID == XFER_CMPLT

				else if (ReceivedPID == 0xFF)
				{//Pid_Product_Data
					TimerFlags.gotprotocol = TRUE;
					d201 = TRUE;
					d301 = d302 = d310 = FALSE;
					ACKPacket[3] = ReceivedPID;
					ACKPacket[5] = ~(ACK + 2 + ReceivedPID) + 1;
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);//acknowledge everything else
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = ACKPacket[y];
					if (tgcount > 49900) tgcount = 0;
					if ((ReceivedData[0] <= 41) && (ReceivedData[1] == 0))//GPS 45
						goto spaghetti;
				}
//looking for: "A\x64 Dsomething" (ReceivedPID = 253 0xFD)
				else if (ReceivedPID == 0xFD)//Pid_Protocol_Array, sent right after Pid_Product_Data (0xFF)
				{
					TimerFlags.gotprotocol = TRUE;
//					gota100 = FALSE;
					gotd = FALSE;
					for (x = 0; x < ReceivedDataSize; x++)
					{
						if (ReceivedData[x] == 'D')
							gotd = TRUE;
						else if (gotd)
						{
							gotd = FALSE;
							DType = *(WORD*)&ReceivedData[x];
							switch (DType)
							{
							case 100:
							case 101:
							case 102:
								Noffset = 6;
								Eoffset = 10;
								IdentOffset = 0;
								LocOffset = 18;
								SymOffset = 0;
								WaypointProt = 104;
								break;
							case 103:
								Noffset = 6;
								Eoffset = 10;
								IdentOffset = 0;
								LocOffset = 18;
								SymOffset = 58;
								WaypointProt = 103;
								break;
							case 104:
								Noffset = 6;
								Eoffset = 10;
								IdentOffset = 0;
								LocOffset = 18;
								SymOffset = 62;
								WaypointProt = 104;
								break;
							case 107:
								Noffset = 6;
								Eoffset = 10;
								IdentOffset = 0;
								LocOffset = 18;
								SymOffset = 58;
								WaypointProt = 104;
								break;
							case 108:
								Noffset = 24;
								Eoffset = 28;
								ElevOffset = 32;
								IdentOffset = 48;
								SymOffset = 4;
								WaypointProt = 108;
								break;
							case 109:
								Noffset = 24;
								Eoffset = 28;
								ElevOffset = 32;
								IdentOffset = 52;
								SymOffset = 4;
								WaypointProt = 109;
								break;
							case 110:
								Noffset = 24;
								Eoffset = 28;
								ElevOffset = 32;
								IdentOffset = 62;
								SymOffset = 4;
								WaypointProt = 110;
								break;
							case 151:
							case 152:
							case 154://add support for this?
							case 155://ditto
								MessageBox(hwnd, "Sorry, doesn't support older Garmin aviation GPS's.\nLet me know if you wish it did.", NULL, MB_OK);
								openatclosing = FALSE;
								SendMessage(hwnd, WM_CLOSE, 0, 0);
								return 0;
							case 201:
								d201 = TRUE;
								break;
							case 202:
								d201 = FALSE;
								break;
							case 210:
								d210 = TRUE;
								break;
							case 300:
								d300 = TRUE;
								break;
							case 301:
								d301 = TRUE;
								break;
							case 302:
								d302 = TRUE;
								break;
							case 310:
								d310 = TRUE;
								break;
							}//end of switch
						}//end of else if (gotd)
					}//end of for
spaghetti:
					if (garminflag == BEGINRECORDS8)
					{
						if ((sendingrouteheader) && (d201 == FALSE))//if d202
						{
							BeginRecords[3] = (numofRoutes*2)+1;//Route Link after each waypoint
							if (((numofRoutes*2)+1) != 16)//if not 0x10 (DLE char)
							{
								BeginRecords[5] = ~(27 + 2 + ((numofRoutes*2)+1)) + 1;
								WriteFile(hComm, &BeginRecords, 8, &dwBytesWritten, NULL);
							}
							else
							{
								BeginRecords2[6] = ~(27 + 2 + ((numofRoutes*2)+1)) + 1;
								WriteFile(hComm, &BeginRecords2, 9, &dwBytesWritten, NULL);
							}
						}
						else if ((sendingtrackheader) && (d310 == TRUE))
						{
							BeginRecords[3] = numofTracks;//+ 1
							BeginRecords[5] = ~(27 + 2 + numofTracks) + 1;
							WriteFile(hComm, &BeginRecords, 8, &dwBytesWritten, NULL);
						}
						else
							WriteFile(hComm, &BeginRecords, 8, &dwBytesWritten, NULL);
						for (x = 0; x < 8; x++, tgcount++)
							ToGPS[tgcount] = BeginRecords[x];
						if (tgcount > 49900) tgcount = 0;
					}
					else if (garminflag == BEGINRECORDS9)
					{
						if ((sendingrouteheader) && (d201 == FALSE))//if d202
						{
							BeginRecords2[3] = numofRoutes * 2;//+ Route Header + Route Links
							BeginRecords2[6] = ~(27 + 2 + (numofRoutes*2)) + 1;
						}
						else if ((sendingtrackheader) && (d310 == TRUE))
						{
							BeginRecords2[3] = numofTracks;
							BeginRecords2[6] = ~(27 + 2 + numofTracks) + 1;
						}
						WriteFile(hComm, &BeginRecords2, 9, &dwBytesWritten, NULL);
						for (x = 0; x < 9; x++, tgcount++)
							ToGPS[tgcount] = BeginRecords2[x];
						if (tgcount > 49900) tgcount = 0;
					}
					else if (garminflag == SENDWAYPOINTS)
					{
						WriteFile(hComm, &SendWaypoints, 8, &dwBytesWritten, NULL);
						for (x = 0; x < 8; x++, tgcount++)
							ToGPS[tgcount] = SendWaypoints[x];
						if (tgcount > 49900) tgcount = 0;
					}
					else if (garminflag == SENDTRACKS)
					{
						WriteFile(hComm, &SendTracks, 8, &dwBytesWritten, NULL);
						for (x = 0; x < 8; x++, tgcount++)
							ToGPS[tgcount] = SendTracks[x];
						if (tgcount > 49900) tgcount = 0;
					}
					else if (garminflag == RECEIVEROUTE)
					{
						WriteFile(hComm, &SendRoutes, 8, &dwBytesWritten, NULL);
						for (x = 0; x < 8; x++, tgcount++)
							ToGPS[tgcount] = SendRoutes[x];
						if (tgcount > 49900) tgcount = 0;
					}
					else if (garminflag == STARTPVT)
					{
						WriteFile(hComm, &StartPVTPacket, 8, &dwBytesWritten, NULL);
						for (x = 0; x < 8; x++, tgcount++)
							ToGPS[tgcount] = StartPVTPacket[x];
						if (tgcount > 49900) tgcount = 0;
					}
				}//end of if (ReceivedPID == 0xFD)

				else if (ReceivedPID == WAYPOINT)
				{//receiving waypoints
					if ((ReceivedPID == WAYPOINT) && (EmptyLoc < TOTAL_LOCS))
					{
						SaveDownloadedWaypoints();
					}
					IncCount();
					ACKPacket[3] = ReceivedPID;
					ACKPacket[5] = ~(ACK + 2 + ReceivedPID) + 1;
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);//acknowledge everything else
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = ACKPacket[y];
					if (tgcount > 49900) tgcount = 0;
				}//end of else if (ReceivedPID == WAYPOINT)

				else // if (ReceivedPID == anything else)
				{
					IncCount();
					ACKPacket[3] = ReceivedPID;
					ACKPacket[5] = ~(ACK + 2 + ReceivedPID) + 1;
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);//acknowledge everything else
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = ACKPacket[y];
					if (tgcount > 49900) tgcount = 0;
				}
			}//end of switch (GarminFlag)
		}//end of else if garmin
//temp xxxx
//htempFile = CreateFile(GPSdta, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
//SetFilePointer(htempFile, 0, NULL, FILE_END);
//WriteFile(htempFile, &Buf[iBuf], 1, &dwBytesWritten, NULL);
//FlushFileBuffers(htempFile);
//CloseHandle(htempFile);
//
		iBuf++;
		if (iBuf == 50000)
			iBuf = 0;
		return 0;


	case WM_USB:
		ShowPosition();
		return 0;


	case 0x020A://WM_MOUSEWHEEL
		if ((Zoom == 1) && (USGSBuf != NULL))
		{
			if (wParam & 0x080000000)
				x = -100;
			else
				x = 100;
			lf5.lfEscapement += x;
			lf5.lfOrientation += x;
			InvalidateRect(hwnd, &rect, FALSE);
		}
		else
		{
			if (LOWORD(wParam) == MK_CONTROL)
			{
				mousewheel = TRUE;
				if (wParam & 0x080000000)
					SendMessage(hwnd, WM_KEYDOWN, VK_RIGHT, 0);
				else
					SendMessage(hwnd, WM_KEYDOWN, VK_LEFT, 0);
			}
			else
			{
				if (wParam & 0x080000000)
					SendMessage(hwnd, WM_KEYDOWN, VK_DOWN, 0);
				else
					SendMessage(hwnd, WM_KEYDOWN, VK_UP, 0);
			}
		}
		return 0;

	case WM_MOUSEMOVE:
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
		xPos = LOWORD(lParam);
		yPos = HIWORD(lParam);
		if (xPos >= (rect.right))
			break;//to keep from showing bad lat/lon
		if (approachcontrol)
		{
			AtPlane = -1;
			for (z = 0; Plane[z].UTMEasting != 0; z++)
			{
				if ((Plane[z].x-PlaneRadius < xPos) && (Plane[z].x+PlaneRadius > xPos)
				 && ((Plane[z].y-PlaneRadius < yPos) && (Plane[z].y+PlaneRadius > yPos)))
				{
					AtPlane = z;
					break;
				}
			}
			if (AtPlane == -1)
				planecommand = FALSE;
				for (z = 0; z < command; z++)
					Command[z] = 0;
		}
		if (drawing == FALSE)
		{
			if (wParam == MK_SHIFT)
			{//if Shift key is down
				enteringtext = TRUE;
//				xbegOld = -1;
				if (xBeg == -1)
				{
					xBeg = xPos;
					yBeg = yPos;
				}
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
			}
			else if ((wParam == MK_CONTROL) && (simulate == FALSE) && (mousewheel == FALSE))// && (inaprs == FALSE) && (aprs == FALSE))
			{//if Ctrl key is down
				distancemeasure = TRUE;
				if (xBeg == -1)
				{
					xBeg = xPos;
					yBeg = yPos;
					totalRouteDist[0] = 0.0;//trick for ShowDistanceAngle
					ptr = 1;
				}
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
			}
		}

		if (((showstreets) && (gotstreet == FALSE)) && ((((MapType == PHOTO) && (Zoom <= 3)) || ((MapType == URBANAREA) && (Zoom <= 5))) || ((MapType == TOPO) && (Zoom == 1))))
		{
			hdc = GetDC(hwnd);
			if (hdcMem3 == NULL)
			{
				hdcMem3 = CreateCompatibleDC(hdc);
				hBitmap3 = CreateCompatibleBitmap(hdc, rect.right, rect.bottom);
				hObject = SelectObject(hdcMem3, hBitmap3);
			}
			x = BitBlt(hdcMem3, 0, 0, rect.right, rect.bottom, hdc, 0, 0, SRCCOPY);
			ReleaseDC(hwnd, hdc);

			for (w = 0; w < pname; w++)
			{
				NamePtr1 = NamePtr2 = NULL;
				z = 0x0FFFFFFF;
				for (x = 0; NamePtrs[w][x] != -1; x += 3)
				{//get street name closest to UTMNorthing & UTMEasting
 					if (xPos > NamePtrs[w][x])
						y = xPos - NamePtrs[w][x];
					else
						y = NamePtrs[w][x] - xPos;
					if (yPos > NamePtrs[w][x+1])
						y += yPos - NamePtrs[w][x+1];
					else
						y += NamePtrs[w][x+1] - yPos;
					if (y < z)
					{
						z = y;
						if (y < 10)
						{
							streetflag = FALSE;
							y = NamePtrs[w][x+2];
							if (TigerNameSize[w] < (DWORD)y)
								continue;//something went wrong...
							TigerPointA = *(int*)&pTigerNames[w][y];//Angle
							if (TigerPointA & 0x80000000)
							{
								TigerPointA &= 0x7FFFFFFF;
								streetflag = TRUE;
							}
							y += 4;//to name
							for (z = y; pTigerNames[w][z] != 0; z++);
								;
							lf4.lfEscapement = lf4.lfOrientation = TigerPointA;
							hFont = CreateFontIndirect (&lf4);
							hdc = GetDC(hwnd);
							hObject = SelectObject (hdc, hFont);
							if (MapType != TOPO)
							{
								SetBkMode(hdc, TRANSPARENT);
								SetTextColor(hdc, TextColor);//0x90FF00
							}
							if (streetflag)
								SetTextAlign(hdc, TA_RIGHT|TA_BASELINE);
							else
								SetTextAlign(hdc, TA_LEFT|TA_BASELINE);
							if (NamePtr1 == NULL)
							{
								NamePtr1 = &pTigerNames[w][y];
								TextOut(hdc, NamePtrs[w][x], NamePtrs[w][x+1], NamePtr1, z-y);
								Angle1 = TigerPointA;
								Angle1 /= 10;//because of a previous misunderstanding
								if (streetflag)
									Angle1 |= 0x80000000;
							}
							else if (NamePtr2 == NULL)
							{
								NamePtr2 = &pTigerNames[w][y];
								TextOut(hdc, NamePtrs[w][x], NamePtrs[w][x+1], NamePtr2, z-y);
								Angle2 = TigerPointA;
								Angle2 /= 10;
								if (streetflag)
									Angle2 |= 0x80000000;
							}
							SelectObject(hdc, hObject);
							DeleteObject(hFont);
							ReleaseDC(hwnd, hdc);
							gotX = NamePtrs[w][x];//xPos;
							gotY = NamePtrs[w][x+1];//yPos;
							gotstreet = TRUE;
							z = 0x0FFFFFFF;
						}
					}
				}//end of for (x = 0;
				if (gotstreet)
					break;//out of for (w = 0;
			}//end of for (w = 0;
		}//end of if ((showstreets)

		if (((bigjpeg) && (buttondown)) || ((terrafetcher) && (buttondown)))
		{
			x = (X1 - ScreenLeft) * PixelsPerTile / MetersPerTile;
			y = (ScreenTop - Y1) * PixelsPerTile / MetersPerTile;
			hdc = GetDC(hwnd);
			BitBlt(hdc, 0, 0, MapWidth, MapHeight, hdcMem, 0, 0, SRCCOPY);
			hPen = CreatePen(PS_SOLID, 1, 0xFFFFFF);
			SelectObject(hdc, hPen);
			MoveToEx(hdc, x, y, NULL);
			LineTo(hdc, x, yPos);
			LineTo(hdc, xPos, yPos);
			LineTo(hdc, xPos, y);
			LineTo(hdc, x, y);
			DeleteObject(hPen);
			ReleaseDC(hwnd, hdc);
		}
		else if (drawing)
		{
			if (xBeg == -1)
			{
				xBeg = xPos;
				yBeg = yPos;
			}
			SetCursor(hDrawingCursor);//have to do this every time !?!
			InvalidateRect(hwnd, &rect, FALSE);
		}
		else if (fromposition)
		{
			char PositionData[200];

			if (showingdata)
			{//only show this again after showing position data
				showingdata = FALSE;
				SetWindowText(hwndPosit, Posit);
			}
			Radius = DotRadius*MetersPerTile/PixelsPerTile;
			for (x = 0; x < pos; x++)
			{//position
				if ((Position[x].UTME < UTMEasting+Radius) && (Position[x].UTME > UTMEasting-Radius)
				 && (Position[x].UTMN < UTMNorthing+Radius) && (Position[x].UTMN > UTMNorthing-Radius))
				{	
					char TimeDate[] = "09/24/2004 18:34:12Z";
					char Alt[] = "Altitude  ";
					char Horepe[] = "HorizEPE  ";
					char Vertepe[] = "VertEPE  ";
					char Speed[] = "Speed  ";

					for (y = 0, z = 0; PositionCsv[z] != 0; y++, z++)
						PositionData[y] = PositionCsv[z];
					PositionData[y++] = '\r';
					PositionData[y++] = '\n';
					PositionData[y++] = '\r';
					PositionData[y++] = '\n';

					TimeDate[0] = (Position[x].Month / 10) + '0';
					TimeDate[1] = (Position[x].Month % 10) + '0';
					TimeDate[3] = (Position[x].Date / 10) + '0';
					TimeDate[4] = (Position[x].Date % 10) + '0';
					TimeDate[8] = (Position[x].Year / 10) + '0';
					TimeDate[9] = (Position[x].Year % 10) + '0';
					TimeDate[11] = (Position[x].Hour / 10) + '0';
					TimeDate[12] = (Position[x].Hour % 10) + '0';
					TimeDate[14] = (Position[x].Min / 10) + '0';
					TimeDate[15] = (Position[x].Min % 10) + '0';
					TimeDate[17] = (Position[x].Sec / 10) + '0';
					TimeDate[18] = (Position[x].Sec % 10) + '0';
					for (z = 0; TimeDate[z] != 0; y++, z++)
						PositionData[y] = TimeDate[z];
					PositionData[y++] = '\r';
					PositionData[y++] = '\n';

					if (Position[x].Alt != 0)
					{
						for (z = 0; Alt[z] != 0; y++, z++)
							PositionData[y] = Alt[z];
						_itoa(Position[x].Alt, &PositionData[y], 10);
						for ( ; PositionData[y] != 0; y++)
							;
						PositionData[y++] = '\r';
						PositionData[y++] = '\n';
					}

					if (Position[x].HorizEpe != 0)
					{
						for (z = 0; Horepe[z] != 0; y++, z++)
							PositionData[y] = Horepe[z];
						_itoa(Position[x].HorizEpe, &PositionData[y], 10);
						for ( ; PositionData[y] != 0; y++)
							;
						PositionData[y++] = '\r';
						PositionData[y++] = '\n';

						for (z = 0; Vertepe[z] != 0; y++, z++)
							PositionData[y] = Vertepe[z];
						_itoa(Position[x].VertEpe, &PositionData[y], 10);
						for ( ; PositionData[y] != 0; y++)
							;
						PositionData[y++] = '\r';
						PositionData[y++] = '\n';
					}

					if (Position[x].Velocity != 0)
					{
						for (z = 0; Speed[z] != 0; y++, z++)
							PositionData[y] = Speed[z];
						z = sprintf(&PositionData[y], "%.2f", Position[x].Velocity);
						y += z;
					}

					if (x)
					{
						GetCourse(x);
						z = (int)Angle;
						PositionData[y++] = '\r';
						PositionData[y++] = '\n';
						_itoa(z, &PositionData[y], 10);
						for ( ; PositionData[y] != 0; y++)
							;
						PositionData[y++] = '\xB0';
					}
					PositionData[y] = 0;
					SetWindowText(hwndPosit, PositionData);
					showingdata = TRUE;
					break;
				}
			}
		}

		if ((objectPtr) && (gotsymbol))
		{
			APRSUTMEasting = ScreenLeft + (xPos * MetersPerTile/PixelsPerTile);
			APRSUTMNorthing = ScreenTop - (yPos * MetersPerTile/PixelsPerTile);
			Radius = 8*MetersPerTile/PixelsPerTile;
			for (x = 0; x < objectPtr; x++)
			{
				if ((Objects[x].UTMZ == UTMZone) && (Objects[x].UTME < APRSUTMEasting+Radius) && (Objects[x].UTME > APRSUTMEasting-Radius)
				 && (Objects[x].UTMN < APRSUTMNorthing+Radius) && (Objects[x].UTMN > APRSUTMNorthing-Radius))
				{
					if (atobj)
						break;
					atobj = TRUE;
					DotX = (Objects[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
					DotY = (ScreenTop - Objects[x].UTMN) * PixelsPerTile / MetersPerTile;
					hdc = GetDC(hwnd);
					if (MapType != TOPO)
					{
						SetBkMode(hdc, TRANSPARENT);
						SetTextColor(hdc, WHITE);
					}
					if (Objects[x].Comment[0])
						TextOut(hdc, DotX+10, DotY+5, Objects[x].Comment, strlen(Objects[x].Comment));
					if (Objects[x].Time[0])
						TextOut(hdc, DotX+10, DotY+20, Objects[x].Time, 7);
					ReleaseDC(hwnd, hdc);
					break;
				}
			}
			if ((atobj) && (x == objectPtr))
			{
				atobj = FALSE;
				InvalidateRect(hwnd, &rect, FALSE);
			}
		}

		if (aprs)
		{
			APRSUTMEasting = ScreenLeft + (xPos * MetersPerTile/PixelsPerTile);
			APRSUTMNorthing = ScreenTop - (yPos * MetersPerTile/PixelsPerTile);
			Radius = 8*MetersPerTile/PixelsPerTile;
			for (x = Aprsi-1; x != -1; x--)//go backwards to get latest one
			{
				if ((Aprs[x].UTMZ == UTMZone) && (Aprs[x].UTME < APRSUTMEasting+Radius) && (Aprs[x].UTME > APRSUTMEasting-Radius)
				 && (Aprs[x].UTMN < APRSUTMNorthing+Radius) && (Aprs[x].UTMN > APRSUTMNorthing-Radius))
				{
					if (Aprs[x].DescOrWx[0] != 0)
					{//if it's not a WX station position with nothing else
						if (ataprs)
							break;
						ataprs = TRUE;
						CurrentAprsi = x;
						DotX = (Aprs[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
						DotY = (ScreenTop - Aprs[x].UTMN) * PixelsPerTile / MetersPerTile;
						hdc = GetDC(hwnd);
						if (MapType != TOPO)
						{
							SetBkMode(hdc, TRANSPARENT);
							SetTextColor(hdc, WHITE);
						}
						if (Aprs[x].RedDot)
							TextOut(hdc, DotX+10, DotY-10, Aprs[x].Call, strlen(Aprs[x].Call));
						if (Aprs[x].Time)
						{
							APRStime[0] = (Aprs[x].Time / 1000) + '0';
							APRStime[1] = ((Aprs[x].Time % 1000) / 100) + '0';
							APRStime[2] = ((Aprs[x].Time % 100) / 10) + '0';
							APRStime[3] = (Aprs[x].Time % 10) + '0';
							APRStime[4] = 'z';
							TextOut(hdc, DotX+10, DotY+5, APRStime, 5);
						}
						if (Aprs[x].DescOrWx[0] != 0)
							TextOut(hdc, DotX+10, DotY+20, Aprs[x].DescOrWx, lstrlen(Aprs[x].DescOrWx));
						if (Aprs[x].Status[0])
							TextOut(hdc, DotX+10, DotY+35, Aprs[x].Status, lstrlen(Aprs[x].Status));
						ReleaseDC(hwnd, hdc);
						break;
					}
				}
			}
			if ((ataprs) && (x == -1))//(Aprs[x].UTMN == 0))
			{
				ataprs = FALSE;
				InvalidateRect(hwnd, &rect, FALSE);
			}
		}
//////
		if ((shownamecomment == FALSE) || ((MapType == TOPO) && (Zoom >= 5)))
		{
			int xUTMEasting, yUTMNorthing;

			xUTMEasting = ScreenLeft + (xPos * MetersPerTile/PixelsPerTile);
			yUTMNorthing = ScreenTop - (yPos * MetersPerTile/PixelsPerTile);
			Radius = DotRadius*MetersPerTile/PixelsPerTile;
			for (x = 0; NewLoc[x].EUTM != 0; x++)
			{//waypoints
				if ((NewLoc[x].EUTM < xUTMEasting+Radius) && (NewLoc[x].EUTM > xUTMEasting-Radius)
				 && (NewLoc[x].NUTM < yUTMNorthing+Radius) && (NewLoc[x].NUTM > yUTMNorthing-Radius))
				{
					if (atwaypoint)
						break;
					atwaypoint = TRUE;
					for (y = 0; y < NewLoc[x].size; y++)
					{
						if (sortbyname)
						{//<name>
							if ((NewLoc[x].pWaypoints[y-3] == '<') && (NewLoc[x].pWaypoints[y-1] == 'a') && (NewLoc[x].pWaypoints[y] == 'm') && (NewLoc[x].pWaypoints[y+1] == 'e') && (NewLoc[x].pWaypoints[y+2] == '>'))
							{
								ShowWaypointData(x, y);
								goto breakout;
							}
						}
						else
						{//<cmt>
							if ((NewLoc[x].pWaypoints[y-2] == '<') && (NewLoc[x].pWaypoints[y] == 'm') && (NewLoc[x].pWaypoints[y+1] == 't') && (NewLoc[x].pWaypoints[y+2] == '>'))
							{
								ShowWaypointData(x, y);
								goto breakout;
							}
						}
					}
				}
			}
breakout:	if ((atwaypoint) && (NewLoc[x].EUTM == 0))
			{
				atwaypoint = FALSE;
				if (fromlineto)
					fromlineto = FALSE;
				else
				{
					InvalidateRect(hwnd, &rect, FALSE);
					UpdateWindow(hwnd);
				}
			}
		}
		else if ((shownamecomment) && (showdescription) && (drawing == FALSE))
		{
			int xUTMEasting, yUTMNorthing;

			xUTMEasting = ScreenLeft + (xPos * MetersPerTile/PixelsPerTile);
			yUTMNorthing = ScreenTop - (yPos * MetersPerTile/PixelsPerTile);
			Radius = DotRadius*MetersPerTile/PixelsPerTile;
			for (x = 0; NewLoc[x].EUTM != 0; x++)
			{//waypoints
				if ((NewLoc[x].EUTM < xUTMEasting+Radius) && (NewLoc[x].EUTM > xUTMEasting-Radius)
				 && (NewLoc[x].NUTM < yUTMNorthing+Radius) && (NewLoc[x].NUTM > yUTMNorthing-Radius))
				{
					if (NewLoc[x].Description != NULL)
					{
						for (y = 0; NewLoc[x].Description[y] != '<'; y++)
							Description[y] = NewLoc[x].Description[y];
						Description[y] = 0;
						Location[0] = 0;
						Ident[0] = 0;
						if ((sortbyname == FALSE) && (NewLoc[x].Location != NULL))
						{
							for (y = 0; NewLoc[x].Location[y] != '<'; y++)
								Location[y] = NewLoc[x].Location[y];
							Location[y] = 0;
						}
						else if ((sortbyname) && (NewLoc[x].Ident != NULL))
						{
							for (y = 0; NewLoc[x].Ident[y] != '<'; y++)
								Ident[y] = NewLoc[x].Ident[y];
							Ident[y] = 0;
						}
						DialogBox(hInst, "DESCRIPTION", hwnd, DescriptionProc);
					}
				}
			}
		}
//////
		if ((autoLoc == FALSE) && (qpressed == FALSE))
		{//the usual situation
			UTMEasting = ScreenLeft + ((xPos*MetersPerTile)/PixelsPerTile);
			UTMNorthing = ScreenTop - ((yPos*MetersPerTile)/PixelsPerTile);

			if ((editingtracks) && (currentpoint != -1))
			{
				if ((wParam == MK_RBUTTON) && (firstrbutton == FALSE))//WM_MOUSEMOVE
				{//while editing tracks and moving mouse with right button down
					trak[currentpoint].EUTM = UTMEasting;
					trak[currentpoint].NUTM = UTMNorthing;
					InvalidateRect(hwnd, &rect, FALSE);
				}
				else if ((wParam == MK_LBUTTON) && (firstlbutton == FALSE))
				{//while editing tracks and moving mouse with left button down
					trak[currentpoint+1].EUTM = UTMEasting;
					trak[currentpoint+1].NUTM = UTMNorthing;
					InvalidateRect(hwnd, &rect, FALSE);
				}
			}
			else if ((wParam == MK_LBUTTON) && (WaypointToMove != -1) && (ObjectToMove == -1) && (drawing == FALSE))
			{//move waypoint
				UTMEasting = ScreenLeft + ((xPos*MetersPerTile)/PixelsPerTile);
				UTMNorthing = ScreenTop - ((yPos*MetersPerTile)/PixelsPerTile);
				NewLoc[WaypointToMove].NUTM = UTMNorthing;
				NewLoc[WaypointToMove].EUTM = UTMEasting;
				InvalidateRect(hwnd, &rect, FALSE);
			}
			else if (objectPtr)
			{
				if ((wParam == MK_LBUTTON) && (ObjectToMove != -1))
				{//move object
					UTMEasting = ScreenLeft + ((xPos*MetersPerTile)/PixelsPerTile);
					UTMNorthing = ScreenTop - ((yPos*MetersPerTile)/PixelsPerTile);
					Objects[ObjectToMove].UTMN = UTMNorthing;
					Objects[ObjectToMove].UTME = UTMEasting;
					InvalidateRect(hwnd, &rect, FALSE);
				}
			}

			UTMtoLatLon();

			if (veryfirstime)
			{
				veryfirstime = FALSE;
				if (gotelevini)
					GetElevData();
			}

			if ((MouseLoc == DEG) || (MouseLoc == DEGMIN) || (MouseLoc == DEGMINSEC))
			{
				GetLatLon();
				SetWindowText(hwnd, LatLon);
			}
			else if (MouseLoc == ITSUTM)
			{
				West = ScreenLeft + (xPos*MetersPerTile/PixelsPerTile);
				North = ScreenTop - (yPos*MetersPerTile/PixelsPerTile);
				GetUTM(North, West);
				SetWindowText(hwnd, UTM);
			}
			else if (MouseLoc == ITSUSNG)
			{
				West = ScreenLeft + (xPos*MetersPerTile/PixelsPerTile);
				North = ScreenTop - (yPos*MetersPerTile/PixelsPerTile);
				GetUSNG(North, West);
				SetWindowText(hwnd, USNG);
			}
		}
		else if ((autoLoc == FALSE) && (qpressed == TRUE))
		{
			North = (ScreenTop - (yPos*MetersPerTile/PixelsPerTile)) / MetersPerTile;
			West = (ScreenLeft + (xPos*MetersPerTile/PixelsPerTile)) / MetersPerTile;
			GetRowName(North, West);
			SetWindowText(hwnd, RowName);
		}
		if (showingtracks)//WM_MOUSEMOVE
		{
			if (showingtrackdata)
			{//only show this again after showing position data
				showingtrackdata = FALSE;
				SetWindowText(hwndTrack, Trac);
			}
			for (x = 0; trak[x].time != 0; x++)
			{
				if ((trak[x].EUTM < UTMEasting+(6*MetersPerTile/PixelsPerTile)) && (trak[x].EUTM > UTMEasting-(6*MetersPerTile/PixelsPerTile))
				 && (trak[x].NUTM < UTMNorthing+(6*MetersPerTile/PixelsPerTile)) && (trak[x].NUTM > UTMNorthing-(6*MetersPerTile/PixelsPerTile)))
				{
					int i = 0;
					char Track[100] = "  :  :  Z\r\n";

					time = 0;
					ch = (trak[x].time >> 12) & 0x1F;
					time = ch * 3600;
					Track[i++] = (ch / 10) + '0';//hour
					Track[i++] = (ch % 10) + '0';
					i++;
					ch = (trak[x].time >> 6) & 0x3F;
					time += ch * 60;
					Track[i++] = (ch / 10) + '0';//minute
					Track[i++] = (ch % 10) + '0';
					i++;
					ch = trak[x].time & 0x3F;
					time += ch;
					Track[i++] = (ch / 10) + '0';//second
					Track[i++] = (ch % 10) + '0';
					i = 11;
					if (x)
					{
						prevtime = ((trak[x-1].time >> 12) & 0x1F) * 3600;
						prevtime += ((trak[x-1].time >> 6) & 0x3F) * 60;
						prevtime += trak[x-1].time & 0x3F;
						ndist = abs(trak[x].NUTM - trak[x-1].NUTM);
						edist = abs(trak[x].EUTM - trak[x-1].EUTM);
						if (time - prevtime)
						{
							speed = (sqrt(ndist*ndist + edist*edist)) / (time - prevtime);//meters/sec
							speed *= 2.2369363;//mph
						}
						else
							speed = 0.0;
 						i += sprintf(&Track[i], "%.1f mph\r\n", speed);
					}
					i += sprintf(&Track[i], "%.2f miles from beginning of segment", trak[x].dist / 1609.344);
					if (trak[x].alt)
						i += sprintf(&Track[i], "\r\n%.0f'", trak[x].alt);
					i += sprintf(&Track[i], "\r\n(line #%i in the .csv file)", x+2);
					showingtrackdata = TRUE;
					SetWindowText(hwndTrack, Track);
					break;
				}
			}
		}//end of if (showingtracks)

		if ((gotstreet) && ((xPos > (gotX+10)) || (yPos > (gotY+10)) || (xPos < (gotX-10)) || (yPos < (gotY-10))))
		{//if mouse moved away from street name
			gotstreet = FALSE;
			hdc = GetDC(hwnd);
			BitBlt(hdc, 0, 0, rect.right, rect.bottom, hdcMem3, 0, 0, SRCCOPY);
			if (hdcMem3 != NULL)
			{
				SelectObject(hdc, hObject);
				DeleteDC(hdcMem3);
				DeleteObject(hBitmap3);
				hdcMem3 = NULL;
			}
			ReleaseDC(hwnd, hdc);
//			InvalidateRect(hwnd, &rect, FALSE);
		}
		return 0;

	case WM_LBUTTONDBLCLK:
		if ((drawing) && (ptr > 1))
			EndRoute();
		return 0;

//new waypoint or drawing route or editing tracks or moving a waypoint or clicking on Map Location dot on USA map
// or new airplane in ApproachControl
	case WM_LBUTTONDOWN:
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
		if ((autoLoc) && (fromFlag == NOBUTTON))
			break;
		lButtonDotX = LOWORD(lParam);
		lButtonDotY = HIWORD(lParam);
		distancemeasure = FALSE;
		if ((approachcontrol) && (wParam != MK_CONTROL))
		{
			if (AtPlane == -1)
			{
				tempUTME = ScreenLeft + ((LOWORD(lParam) * MetersPerTile) / PixelsPerTile);
				tempUTMN = ScreenTop - ((HIWORD(lParam) * MetersPerTile) / PixelsPerTile);
				if (DialogBox(hInst, "AIRPLANE", hwnd, NewPlaneProc))
				{
					if (hdcMem3 == NULL)
					{
						hdc = GetDC(hwnd);
						hdcMem3 = CreateCompatibleDC(hdc);
						hBitmap3 = CreateCompatibleBitmap(hdc, rect.right, rect.bottom);
						hObject = SelectObject(hdcMem3, hBitmap3);
						ReleaseDC(hwnd, hdc);
						SetBkMode(hdcMem3, TRANSPARENT);
						SetTextColor(hdcMem3, 0xFFFFFF);
						GetTextExtentPoint32(hdcMem3, "5", 1, &Size);
					}
					BitBlt(hdcMem3, 0, 0, rect.right, rect.bottom, hdcMem, 0, 0, SRCCOPY);
					Plane[plane].UTMEasting = tempUTME;
					Plane[plane].UTMNorthing = tempUTMN;
					Plane[plane].x = (Plane[plane].UTMEasting - ScreenLeft) / (MetersPerTile/PixelsPerTile);
					Plane[plane].y = (ScreenTop - Plane[plane].UTMNorthing) / (MetersPerTile/PixelsPerTile);
					Plane[plane].heading = (int)iHeading;
					if (Plane[plane].heading == 0)
						Plane[plane].heading = 360;
					Plane[plane].altitude = Atoi((char*)ApproachAltitude);
					Plane[plane].IAS = Atoi((char*)Airspeed);
					Plane[plane].radianheading = radianheading;
					Plane[plane].newHeading = (int)iHeading;
					if (Plane[plane].newHeading == 0)
						Plane[plane].newHeading = 360;
					Plane[plane].newAltitude = Atoi((char*)ApproachAltitude);
					Plane[plane].newIAS = Atoi((char*)Airspeed);
					Plane[plane].newRadianheading = radianheading;
					hRedBrush = CreateSolidBrush(RED);
					hOldBrush = SelectObject(hdcMem3, hRedBrush);
					Ellipse(hdcMem3, Plane[plane].x - PlaneRadius, Plane[plane].y - PlaneRadius, Plane[plane].x + PlaneRadius, Plane[plane].y + PlaneRadius);
					hdc = GetDC(hwnd);
					BitBlt(hdc, 0, 0, rect.right, rect.bottom, hdcMem3, 0, 0, SRCCOPY);
					ReleaseDC(hwnd, hdc);
					SelectObject(hdcMem3, hOldBrush);
					DeleteObject(hRedBrush);
					plane++;
					if (plane == MAXPLANES)
						MessageBox(hwnd, "MAXPLANES = 25", ERROR, MB_OK);
					if (uTimerID == NULL)
					{
						uTimerID = timeSetEvent(1000, TIMER_RESOLUTION, TimerFunc, 0, TIME_PERIODIC);
					}
				}
			}
			else // if (AtPlane != -1)
			{
				planecommand = TRUE;
				for (x = 0; x < 16; x++)
					Command[x] = 0;
				command = 0;
			}
			break;
		}
		if (getelev)
		{
			SendMessage(hwnd, WM_KEYDOWN, (WPARAM)'X', 0);
			break;
		}
		else if ((bigjpeg) || (terrafetcher))
		{
			buttondown = TRUE;
			X1 = ScreenLeft + ((LOWORD(lParam) * MetersPerTile) / PixelsPerTile);
			Y1 = ScreenTop - ((HIWORD(lParam) * MetersPerTile) / PixelsPerTile);
			break;
		}
		else if (editingtracks)
		{
			trackcolors = FALSE;
			if (firstlbutton)
			{
				firstlbutton = FALSE;
				currentpoint = -1;
				for (x = 0; trak[x].time != 0; x++)
				{
					if ((trak[x].EUTM < UTMEasting+(6*MetersPerTile/PixelsPerTile)) && (trak[x].EUTM > UTMEasting-(6*MetersPerTile/PixelsPerTile))
					 && (trak[x].NUTM < UTMNorthing+(6*MetersPerTile/PixelsPerTile)) && (trak[x].NUTM > UTMNorthing-(6*MetersPerTile/PixelsPerTile)))
					{
						currentpoint = x;//it's at a point
						break;
					}
				}
				if (currentpoint != -1)
				{//at track point
					if ((trak[currentpoint+1].newtrk == 0) && (trak[currentpoint+1].time != 0))
					{//it's not at a point at the end of a segment - so it's to make a segment color
						trackcolors = TRUE;
						for (y = currentpoint;(trak[y].newtrk == 0) && (y > 0); y--)
							;//go to beginning of segment
						if (y > 0)
						{//if there's a 'New' or color number at the beginning
							if (trak[y].color != 0)//if color is already there
								TrackSegmentColor = trak[y].color;
							else
								TrackSegmentColor = TrackColor;//default track color
							if (DialogBox(hInst, "TRACKCOLORS", hwnd, TrackColorsProc))
								SaveTracks();
						}
						else
							TrackSegmentColor = TrackColor;
						currentpoint = -1;//for another routine
					}
					else//if adding a segment or possibly combining segments
					{
						for ( ; trak[x].time != 0; x++)
							;
						x++;
						for ( ; x > currentpoint; x--)
							trak[x] = trak[x-1];//make room for point added when mouse button released (with UTM info from mousemove)
					}
				}
			}
			return 0;
		}
		else if ((showstreets) && (gotstreet))
		{
			if (((MapType == PHOTO) && (Zoom <= 2)) || ((MapType == URBANAREA) && (Zoom <= 4)) || ((MapType == TOPO) && (Zoom == 1)))
			{
				xBeg = gotX;
				yBeg = gotY;
				DialogBox(hInst, "GETTEXT", hwnd, GetTextProc);
				xBeg = -1;
				return 0;
			}
		}
		//check to see if an existing waypoint has been left-clicked on
		Radius = DotRadius*MetersPerTile/PixelsPerTile;
		WaypointToMove = -1;
		for (z = 0; NewLoc[z].EUTM != 0; z++)
		{//waypoints
			if ((NewLoc[z].EUTM < UTMEasting+Radius) && (NewLoc[z].EUTM > UTMEasting-Radius)
			 && (NewLoc[z].NUTM < UTMNorthing+Radius) && (NewLoc[z].NUTM > UTMNorthing-Radius))
			{
				WaypointToMove = z;
				break;
			}
		}
		if (objectPtr)
		{
			Radius = 8*MetersPerTile/PixelsPerTile;
			ObjectToMove = -1;
			for (z = 0; z < objectPtr; z++)
			{//objects
				if ((Objects[z].UTME < UTMEasting+Radius) && (Objects[z].UTME > UTMEasting-Radius)
				 && (Objects[z].UTMN < UTMNorthing+Radius) && (Objects[z].UTMN > UTMNorthing-Radius))
				{
					ObjectToMove = z;
					break;
				}
			}
		}
		//fall thru...

	case WM_USER6:
//		waypointedited = FALSE;
		if (drawing)
		{
			RoutePoint++;
			totalRouteDist[ptr] = routeDist;
			if (showingroute == FALSE)
			{
				showingroute = TRUE;
				CheckMenuItem(hMenu, ID_ROUTE_SHOW, MF_CHECKED);
			}
			if (WaypointToMove == -1)
			{
				x = ScreenLeft + (LOWORD(lParam)*MetersPerTile/PixelsPerTile);
				y = ScreenTop - (HIWORD(lParam)*MetersPerTile/PixelsPerTile);
			}
			else//if (WaypointToMove != -1)
			{
				if ((WaypointSize + 1000) < MaxWaySize)
				{
					ChosenLoc = WaypointToMove;
					Location[0] = Ident[0] = Description[0] = 0;
					if (NewLoc[ChosenLoc].Location != NULL)
						for (z = 0; NewLoc[ChosenLoc].Location[z] != '<'; z++)
							Location[z] = NewLoc[ChosenLoc].Location[z];
					if (NewLoc[ChosenLoc].Ident != NULL)
						for (z = 0; NewLoc[ChosenLoc].Ident[z] != '<'; z++)
							Ident[z] = NewLoc[ChosenLoc].Ident[z];
					if (NewLoc[ChosenLoc].Description != NULL)
						for (z = 0; NewLoc[ChosenLoc].Description[z] != '<'; z++)
							Description[z] = NewLoc[ChosenLoc].Description[z];
					Response = DialogBox(hInst, "LOCATIONDESC", hwnd, EditLocationProc);
					if (Response != EXIT)
						EditWaypoint();
//					waypointedited = TRUE;
				}
				x = NewLoc[WaypointToMove].EUTM;
				y = NewLoc[WaypointToMove].NUTM;
				WaypointToMove = -1;
			}
			if ((ptr == 0) || ((pRoute[ptr-1].NUTM != y) || (pRoute[ptr-1].EUTM != x)))
			{//don't duplicate previous point
				pRoute[ptr].UTMZone = UTMZone;
				pRoute[ptr].NUTM = y;
				pRoute[ptr].EUTM = x;
				Radius = DotRadius*MetersPerTile/PixelsPerTile;
				for (z = 0; NewLoc[z].EUTM != 0; z++)
				{//check for route point near a waypoint & move it to waypoint if it is	
					if ((NewLoc[z].UTMZone == UTMZone) && (NewLoc[z].EUTM < x+Radius) && (NewLoc[z].EUTM > x-Radius)
					 && (NewLoc[z].NUTM < y+Radius) && (NewLoc[z].NUTM > y-Radius))
					{
						MessageBeep(MB_OK);
						pRoute[ptr].NUTM = NewLoc[z].NUTM;
						pRoute[ptr].EUTM = NewLoc[z].EUTM;
						break;
					}
				}
				if (ptr < MAX_PTR)
					ptr++;
			}
		}

		else if ((WaypointToMove == -1) && (ObjectToMove == -1) && (enteringtext == FALSE) && (Pixels == NULL))//else  && (waypointedited == FALSE)
		{//new waypoint
			if ((WaypointSize + 1000) > MaxWaySize)
			{
				MessageBox(hwnd, WaypointLimit, "Sorry...", MB_OK);
				return 0;
			}
			if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))//WM_LBUTTONDOWN
			{
				sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
				MessageBox(hwnd, Error, "Error 3", MB_OK);
				return 0;
			}
			if (NewLoc[TOTAL_LOCS-1].EUTM != 0)
			{
				MessageBox(hwnd, FullArray, NULL, MB_OK);
				return 0;
			}
			if ((autoLoc) && (fromFlag == NOBUTTON))
			{
				fromFlag = LBUTTON;
				if (itsgarmin)
				{
					sendingStop = TRUE;
					WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = StopPVTPacket[y];
					if (tgcount > 49900) tgcount = 0;
					return 0;//ACK will call this routine again
				}
				else if (itsusb == FALSE)
				{
					autoLoc = FALSE;
					SetEvent(hEventExit);
				}
				else if (hUSBThread != 0)//if (itsusb)
				{
					SignalUSBStop();
				}
			}
			if (fromFlag != NOBUTTON)
			{
				showposition = FALSE;
				fromFlag = NOBUTTON;
				autoLoc = FALSE;
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				RedDot(hwnd);
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			}

			hdc = GetDC(hwnd);
			hWaypointBrush = CreateSolidBrush(WaypointColor);
			hObject = SelectObject(hdc, hWaypointBrush);
			DotX = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
			DotY = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
			Ellipse(hdc, DotX-DotRadius, DotY-DotRadius, DotX+DotRadius, DotY+DotRadius);
//			Ellipse(hdc, lButtonDotX-DotRadius, lButtonDotY-DotRadius, lButtonDotX+DotRadius, lButtonDotY+DotRadius);
			SelectObject(hdc, hObject);
			DeleteObject(hWaypointBrush);
			ReleaseDC(hwnd, hdc);

			Response = EXIT;
			if (fromgoto == FALSE)
			{
				int oldUTMZone = UTMZone;
				UTMtoLatLon();
				LatRad = Lat * deg2rad;
				LonRad = Lon * deg2rad;
				LatLontoUTM();
				if (oldUTMZone != UTMZone)
				{
					ChangeZone(UTMZone, 8);//left button down
					MessageBox(hwnd, "New UTM zone", "", MB_OK);
					BeginY = UTMNorthing / MetersPerTile;
					BeginX = UTMEasting / MetersPerTile;
					_itoa(BeginX, X, 10);
					_itoa(BeginY, Y, 10);
					Z[0] = (UTMZone / 10) + '0';
					Z[1] = (UTMZone % 10) + '0';
					Waypoints[0] = 0;
					fromOpen = TRUE;
					SendMessage(hwnd, WM_USER4, 0, 0);
					return 0;
				}
			}
			else
				fromgoto = FALSE;

			if (markobject)
			{
				ObjectUTMN = UTMNorthing;
				ObjectUTME = UTMEasting;
				ObjectUTMZ = UTMZone;
				Response = DialogBox(hInst, "OBJECT", hwnd, GetObjectProc);
				if (Response != EXIT)
					CheckMenuItem(hMenu, ID_APRS_OBJECTS_SHOWOBJECTS, MF_CHECKED);
				CheckMenuItem(hMenu, ID_APRS_OBJECTS_MARKOBJECT, MF_UNCHECKED);
				markobject = FALSE;
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
				return 0;
			}

			if (fromstationinfo == FALSE)//else
				Response = DialogBox(hInst, "LOCATION", hwnd, GetLocationProc);
			if (Response == EXIT)
			{
				if (markobject)
				{
					CheckMenuItem(hMenu, ID_APRS_OBJECTS_MARKOBJECT, MF_UNCHECKED);
					markobject = FALSE;
				}
				InvalidateRect(hwnd, &rect, FALSE);
				UpdateWindow(hwnd);
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
				return 0;
			}
			strcpy(Location, LocBuf);
			strcpy(Ident, IdentBuf);

			GetLatLon();//get tl (elevation)
			for (x = 0; x < TOTAL_LOCS; x++)
				if (NewLoc[x].EUTM == 0)
					break;
			EmptyLoc = x;
			for (x = 0; x < EmptyLoc; x++)
			{
				if (sortbyname == FALSE)
				{
					if ((NewLoc[x].Location != NULL) && (NewLoc[x].Location != 0))
					{
						for (y = 0; (NewLoc[x].Location[y] != '<') || (NewLoc[x].Location[y+1] != '/'); y++)
							tempNewLoc[y] = NewLoc[x].Location[y];
					}
					else
					{
						for (y = 0; (NewLoc[x].Ident[y] != '<') || (NewLoc[x].Ident[y+1] != '/'); y++)
							tempNewLoc[y] = NewLoc[x].Ident[y];
					}
					tempNewLoc[y] = 0;//this is why tempNewLoc is used
					if (_stricmp(tempNewLoc, Location) > 0)
					{
						InsertLoc = x;
						EmptyLoc++;
						for (x = EmptyLoc; x > InsertLoc; x--)
							NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
						break;
					}
				}
				else//if (sortbyname)
				{
					if (NewLoc[x].Ident != 0)
					{
						for (y = 0; (NewLoc[x].Ident[y] != '<') || (NewLoc[x].Ident[y+1] != '/'); y++)
							tempNewLoc[y] = NewLoc[x].Ident[y];
					}
					else
					{
						for (y = 0; (NewLoc[x].Location[y] != '<') || (NewLoc[x].Location[y+1] != '/'); y++)
							tempNewLoc[y] = NewLoc[x].Location[y];
					}
					tempNewLoc[y] = 0;//this is why tempNewLoc is used
					if (Ident[0] != 0)
						pIdentLoc = Ident;
					else
						pIdentLoc = Location;
					if (_stricmp(tempNewLoc, pIdentLoc) > 0)
					{
						InsertLoc = x;
							EmptyLoc++;
						for (x = EmptyLoc; x > InsertLoc; x--)
							NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
						break;
					}
				}
			}
			if (x == EmptyLoc)
			{
				InsertLoc = x;
				EmptyLoc++;
			}
			tempLat = Lat;
			tempLon = Lon;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			tempUTMZone = UTMZone;
			LatRad = Lat * deg2rad;
			LonRad = Lon * deg2rad;
			LatLontoUTM();
			NewLoc[InsertLoc].EUTM = UTMEasting;
			NewLoc[InsertLoc].NUTM = UTMNorthing;
			NewLoc[InsertLoc].UTMZone = UTMZone;
			Lat = tempLat;
			Lon = tempLon;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
			UTMZone = tempUTMZone;
			if (tl != 0)
			{
				eleM = tl * 0.3048;//convert to meters
				sprintf(Elev, "%.4f", eleM);
			}
			Sym[0] = 0;
///--->
			FillWaypointArray(InsertLoc);//Lat & Lon are already known
///--->
		}//end of else if ((WaypointToMove == -1) &&
		if ((WaypointToMove == -1) && (enteringtext == FALSE))
			InvalidateRect(hwnd, &rect, FALSE);
		return 0;



	case WM_RBUTTONUP:
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
		if (editingtracks)
		{
			firstlbutton = firstrbutton = TRUE;
			if ((currentpoint != -1) && (trak[currentpoint+1].time != 0))
			{
				x = abs(trak[currentpoint].NUTM - trak[currentpoint+1].NUTM);
				y = abs(trak[currentpoint].EUTM - trak[currentpoint+1].EUTM);
				if ((x < 6*MetersPerTile/PixelsPerTile) && (y < 6*MetersPerTile/PixelsPerTile))
				{//if the point was moved over the next point
					trak[currentpoint+1].newtrk = 0;
					for (x = currentpoint; trak[x].time != 0; x++)
						trak[x] = trak[x+1];//move trak data back
				}
			}
//			else
//			{//not combining segments
//				trak[currentpoint+1].time = UTMZone << 26;
//				trak[currentpoint+1].year = 0;
//			}
			SaveTracks();
			InvalidateRect(hwnd, &rect, FALSE);
		}
		return 0;

	case WM_LBUTTONUP:
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
		if (WaypointToMove != -1)
		{//NewLoc[WaypointToMove].pWaypoints = <wpt lat="37.399269" lon="-122.107250">
			int saveX;

			for (x = 0; NewLoc[WaypointToMove].pWaypoints[x] != '"'; x++)
				;
			x++;//to lat
			saveX = x;
			for ( ; NewLoc[WaypointToMove].pWaypoints[x] != '"'; x++)
				;
			count = x - saveX - 1;
			ptrToAscii = _ecvt(Lat, count, &decPos, &sign);
 			for (x = saveX, y = 0 ; y < decPos; x++, y++)
				NewLoc[WaypointToMove].pWaypoints[x] = ptrToAscii[y];
			NewLoc[WaypointToMove].pWaypoints[x++] = '.';
			for ( ; y < count; x++, y++)
				NewLoc[WaypointToMove].pWaypoints[x] = ptrToAscii[y];
			x++;//past ending " of lat=
			for ( ; NewLoc[WaypointToMove].pWaypoints[x] != '"'; x++)
				;//go to longitude
			x += 2;//past " and -
			saveX = x;
			for ( ; NewLoc[WaypointToMove].pWaypoints[x] != '"'; x++)
				;
			count = x - saveX - 1;
			ptrToAscii = _ecvt(Lon, count, &decPos, &sign);
 			for (x = saveX, y = 0 ; y < decPos; x++, y++)
				NewLoc[WaypointToMove].pWaypoints[x] = ptrToAscii[y];
			NewLoc[WaypointToMove].pWaypoints[x++] = '.';
			for ( ; y < count; x++, y++)
				NewLoc[WaypointToMove].pWaypoints[x] = ptrToAscii[y];
			WaypointToMove = -1;
			newLoc = TRUE;
		}
		if ((editingtracks) && (trackcolors == FALSE))
		{
			firstlbutton = firstrbutton = TRUE;
			if ((currentpoint != -1) && (trak[currentpoint+2].time != 0))
			{
				x = abs(trak[currentpoint+1].NUTM - trak[currentpoint+2].NUTM);
				y = abs(trak[currentpoint+1].EUTM - trak[currentpoint+2].EUTM);
				if ((x < 6*MetersPerTile/PixelsPerTile) && (y < 6*MetersPerTile/PixelsPerTile))
				{//if the new point is over an existing point
					trak[currentpoint+2].newtrk = 0;
					for (x = currentpoint+1; trak[x].time != 0; x++)
						trak[x] = trak[x+1];//move trak data back
				}
			}
			else
			{//not combining segments
				trak[currentpoint+1].time = UTMZone << 26;
				trak[currentpoint+1].year = 0;
			}
			SaveTracks();
			InvalidateRect(hwnd, &rect, FALSE);
		}

		else if ((terrafetcher) && (buttondown))
		{
			terrafetcher = FALSE;
			buttondown = FALSE;
			X2 = ScreenLeft + ((LOWORD(lParam) * MetersPerTile) / PixelsPerTile);
			Y2 = ScreenTop - ((HIWORD(lParam) * MetersPerTile) / PixelsPerTile);
			if ((abs(X2 - X1) > 3) && abs(Y2 - Y1) > 3)
			{
				char asdf[8];

				if (Y1 > Y2)
				{
					yTopLeft = Y1;
					yBottomRight = Y2;
				}
				else
				{
					yTopLeft = Y2;
					yBottomRight = Y1;
				}
				if (X1 < X2)
				{
					xTopLeft = X1;
					xBottomRight = X2;
				}
				else
				{
					xTopLeft = X2;
					xBottomRight = X1;
				}
//							  10		 20			30			40		  50		  60		70			80		  90
//				   01234567 8 90123456789 0 123456789012345678 9 012345678901234567 8 901234567890123456 7 890123456789012345 6 7
//char Region[] = "Region=4\r\nFormat=UTM\r\nzz xxxxxx yyyyyyy\r\nzz xxxxxx yyyyyyy\r\nzz xxxxxx yyyyyyy\r\nzz xxxxxx yyyyyyy\r\n";
//											 top left			  top right  		   bottom right			bottom left
				Region[22] = Region[41] = Region[60] = Region[79] = (UTMZone / 10) + '0';
				Region[23] = Region[42] = Region[61] = Region[80] = (UTMZone % 10) + '0';
				_itoa(xTopLeft, asdf, 10);
				for (x = 0, y = 25; asdf[x] != 0; x++, y++)
					Region[y] = asdf[x];
				for (x = 0, y = 82; asdf[x] != 0; x++, y++)
					Region[y] = asdf[x];
				_itoa(yTopLeft, asdf, 10);
				for (x = 0, y = 32; asdf[x] != 0; x++, y++)
					Region[y] = asdf[x];
				for (x = 0, y = 51; asdf[x] != 0; x++, y++)
					Region[y] = asdf[x];
				_itoa(yBottomRight, asdf, 10);
				for (x = 0, y = 70; asdf[x] != 0; x++, y++)
					Region[y] = asdf[x];
				for (x = 0, y = 89; asdf[x] != 0; x++, y++)
					Region[y] = asdf[x];
				_itoa(xBottomRight, asdf, 10);
				for (x = 0, y = 44; asdf[x] != 0; x++, y++)
					Region[y] = asdf[x];
				for (x = 0, y = 63; asdf[x] != 0; x++, y++)
					Region[y] = asdf[x];
			}
			hFile = CreateFile(TerraFetcherRegion, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);//ger
			WriteFile(hFile, Region, 100, &dwBytesWritten, NULL);
			CloseHandle(hFile);
			hdc = GetDC(hwnd);
			BitBlt(hdc, 0, 0, MapWidth, MapHeight, hdcMem, 0, 0, SRCCOPY);
			ReleaseDC(hwnd, hdc);
			MessageBox(hwnd, "'TerraFetcherRegion.txt' has been\nwritten to the USAPhotoMaps folder.", "TerraFetcher Region", MB_OK);
		}

		else if ((bigjpeg) && (buttondown))
		{
			X2 = ScreenLeft + ((LOWORD(lParam) * MetersPerTile) / PixelsPerTile);
			Y2 = ScreenTop - ((HIWORD(lParam) * MetersPerTile) / PixelsPerTile);
			if ((abs(X2 - X1) > 3) && abs(Y2 - Y1) > 3)
			{
				if (Y1 > Y2)
				{
					yTopLeft = Y1;
					yBottomRight = Y2;
				}
				else
				{
					yTopLeft = Y2;
					yBottomRight = Y1;
				}
				if (X1 < X2)
				{
					xTopLeft = X1;
					xBottomRight = X2;
				}
				else
				{
					xTopLeft = X2;
					xBottomRight = X1;
				}
				w = 1; z = 0;
				xTopLeft = (xTopLeft / MetersPerTile) * MetersPerTile;
				_itoa(xTopLeft, X, 10);
				for (x = 0; X[x] != 0; x++, w++, z++)
				{
					BigJpegFilename[w] = X[x];
					BigJpegData[z] = X[x];
				}
				w++;
				BigJpegData[z++] = '\r';
				BigJpegData[z++] = '\n';

				xBottomRight = ((xBottomRight / MetersPerTile) * MetersPerTile) + MetersPerTile;
				_itoa(xBottomRight, X, 10);
				for (x = 0; X[x] != 0; x++, z++)
					BigJpegData[z] = X[x];
				BigJpegData[z++] = '\r';
				BigJpegData[z++] = '\n';


				yTopLeft = ((yTopLeft / MetersPerTile) * MetersPerTile) + MetersPerTile;
				_itoa(yTopLeft, Y, 10);
				for (x = 0; Y[x] != 0; x++, w++, z++)
				{
					BigJpegFilename[w] = Y[x];
					BigJpegData[z] = Y[x];
				}
				w++;
				BigJpegData[z++] = '\r';
				BigJpegData[z++] = '\n';
				BigJpegFilename[w++] = Z[0];
				BigJpegFilename[w++] = Z[1];
				if (MetersPerTile == 1600)
					BigJpegFilename[w] = 'b';
				else if (MetersPerTile == 800)
				{
					if (MapType == TOPO)
						BigJpegFilename[w] = 't';
					else
						BigJpegFilename[w] = 'c';
				}
				else if (MetersPerTile == 200)
					BigJpegFilename[w] = 'p';
				else if (MetersPerTile == 12800)
					BigJpegFilename[w] = 'T';
				else//if (MetersPerTile == 50)
					BigJpegFilename[w] = 'u';
				w++;

				yBottomRight = ((yBottomRight / MetersPerTile) * MetersPerTile);
				_itoa(yBottomRight, Y, 10);
				for (x = 0; Y[x] != 0; x++, z++)
					BigJpegData[z] = Y[x];
				BigJpegData[z++] = '\r';
				BigJpegData[z++] = '\n';
				BigJpegDataSize = z;

//				hdc = GetDC(hwnd);
//				BitBlt(hdc, 0, 0, MapWidth, MapHeight, hdcMem, 0, 0, SRCCOPY);
//				ReleaseDC(hwnd, hdc);

				buttondown = FALSE;
				BigJpeg();
			}
		}
		else if (ObjectToMove != -1)
		{
			hFile = CreateFile(ObjectsDta, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, Objects, objectPtr*120, &dwBytesWritten, NULL);
			CloseHandle(hFile);
		}
		return 0;

//show menu for waypoints with a listbox & GoTo & LineTo & Edit & Delete & Exit buttons
	case WM_RBUTTONDOWN:
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
//		if (ataprs)
//		{
//			hdc = GetDC(hwnd);
//			DotX = (Aprs[CurrentAprsi].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
//			DotY = (ScreenTop - Aprs[CurrentAprsi].UTMN) * PixelsPerTile / MetersPerTile;
//			TextOut(hdc, DotX+10, DotY+30, Aprs[CurrentAprsi].Status, strlen(Aprs[CurrentAprsi].Status));
//			ReleaseDC(hwnd, hdc);
//			break;
//		}
		if (approachcontrol)
		{ // for runway centerline extension and downwind leg
			xPos = LOWORD(lParam); // horizontal position of cursor 
			yPos = HIWORD(lParam); // vertical position of cursor 

			if (DialogBox(hInst, "CENTERLINE", hwnd, CenterlineProc))
			{
				Line[lines].UTME1 = ScreenLeft + (xPos * MetersPerTile / PixelsPerTile);
				Line[lines].UTMN1 = ScreenTop - (yPos * MetersPerTile / PixelsPerTile);
				hypotenuse = 20.0 * 5280 * 0.3048; // 20 mile final
				d1 = hypotenuse * sin(dCenterline * deg2rad);
				d2 = hypotenuse * cos(dCenterline * deg2rad);
				__asm fld d1 // round a double up or down
				__asm fistp x // to an integer
				__asm fld d2 // round a double up or down
				__asm fistp y // to an integer
				Line[lines].UTME2 = Line[lines].UTME1 + x;
				Line[lines].UTMN2 = Line[lines].UTMN1 + y;
				if (GlideSlopeAlt)
				{
					dDistance = (double)GlideSlopeAlt * 0.3048 / GlideSlope; // meters
					d1 = dDistance * sin(dCenterline * deg2rad);
					d2 = dDistance * cos(dCenterline * deg2rad);
					__asm fld d1 // round a double up or down
					__asm fistp x // to an integer
					__asm fld d2 // round a double up or down
					__asm fistp y // to an integer
					Line[lines].GSE = Line[lines].UTME1 + x;
					Line[lines].GSN = Line[lines].UTMN1 + y;
					Line[lines].GSInterceptAlt = GlideSlopeIntercept;
				}
				else
				{
					Line[lines].GSE = 0;
					Line[lines].GSN = 0;
				}
				lines++;

				if ((DownwindAlt) && (DownwindIAS))
				{
					TAS = DownwindIAS + (DownwindIAS * DownwindAlt / 50000);
					TurnRadius = TAS * TAS * TwentyfiveDegreeBank; // in meters
					hypotenuse = TurnRadius * 2.0;
					if (rightdownwind)
					{
						downwindOffsetHeading = dCenterline - 90.0;
						if (downwindOffsetHeading > dCenterline)
							downwindOffsetHeading -= 360.0;
					}
					else
					{
						downwindOffsetHeading = dCenterline + 90.0;
						if (downwindOffsetHeading > 360.0)
							downwindOffsetHeading -= 360.0;
					}
					d1 = hypotenuse * sin(downwindOffsetHeading * deg2rad);
					d2 = hypotenuse * cos(downwindOffsetHeading * deg2rad);
					__asm fld d1 // round a double up or down
					__asm fistp x // to an integer
					__asm fld d2 // round a double up or down
					__asm fistp y // to an integer
					Line[lines].UTME1 = Line[lines-1].UTME1 + x;
					Line[lines].UTMN1 = Line[lines-1].UTMN1 + y;
					Line[lines].UTME2 = Line[lines-1].UTME2 + x;
					Line[lines].UTMN2 = Line[lines-1].UTMN2 + y;
					lines++;
				}
				InvalidateRect(hwnd, &rect, TRUE);
			}
			break;
		}
		distancemeasure = FALSE;
		if (enteringtext)
			break;
		if (editingtracks)
		{
			if (firstrbutton)
			{
				firstrbutton = FALSE;
				currentpoint = -1;
				for (x = 0; trak[x].time != 0; x++)
				{
					if ((trak[x].EUTM < UTMEasting+(6*MetersPerTile/PixelsPerTile)) && (trak[x].EUTM > UTMEasting-(6*MetersPerTile/PixelsPerTile))
					 && (trak[x].NUTM < UTMNorthing+(6*MetersPerTile/PixelsPerTile)) && (trak[x].NUTM > UTMNorthing-(6*MetersPerTile/PixelsPerTile)))
					{
						currentpoint = x;
						break;
					}
				}
			}
			return 0;
		}

//		if (aprs)
//		{
//			char FindUwx[512] = "C:\\Program Files\\Internet Explorer\\iexplore.exe http://www.findu.com/cgi-bin/wxpage.cgi?call=cw8983&last=24&radar=byx";
//			if (CurrentAprsi != -1)
//			{
//				WinExec(FindUwx, SW_SHOW);
//				return 0;
//			}
//		}

		SavePosX = xPos;
		SavePosY = yPos;
		if ((autoLoc) && (fromFlag == NOBUTTON))
			break;
		if (fromFlag != NOBUTTON)
		{
			showposition = FALSE;
			fromFlag = NOBUTTON;
			//autoLoc comes later...
			DestroyMenu(hMenu4);
			hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
			SetMenu(hwnd, hMenu);
			MenuChecks();
			RedDot(hwnd);
			InvalidateRect(hwnd, &rect, FALSE);
			UpdateWindow(hwnd);
			SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
		}

//get closest waypoint (to highlight)
		if (yPos > TitleAndMenu)//2
		{
			centerX = SavePosX;
			centerY = SavePosY;
		}
		else
		{
			centerX = rect.right >> 1;
			centerY = rect.bottom >> 1;
		}
		UTMCenterX = (centerX * MetersPerTile/PixelsPerTile) + ScreenLeft;
		UTMCenterY = ScreenTop - (centerY * MetersPerTile/PixelsPerTile);
waypoints:
		B = 10000000000.0;//large number
		index = -1;//flag
		for (x = 0; x < TOTAL_LOCS; x++)
		{
			if (NewLoc[x].EUTM == 0)
				break;
			if (NewLoc[x].UTMZone != UTMZone)
				continue;
			idistX = UTMCenterX - NewLoc[x].EUTM;
			if (idistX < 1)
				idistX = -(idistX);
			idistY = UTMCenterY - NewLoc[x].NUTM;
			if (idistY < 1)
				idistY = -(idistY);
			distX = (double) idistX;
			distY = (double) idistY;
			A = (int) sqrt((distX*distX) + (distY*distY));
			if (A < B)
			{
				B = A;
				index = x;
			}
		}
/////////<<<<<<<
		Response = DialogBox(hInst, "WAYPOINTS", hwnd, CheckLocationProc);
////////<<<<<<<<
		if (Response == EXIT)
		{
			InvalidateRect(hwnd, &rect, FALSE);
			SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
		}

		else if (Response == EDIT)
		{
			if ((WaypointSize + 1000) > MaxWaySize)
			{
				MessageBox(hwnd, WaypointLimit, "Sorry...", MB_OK);
				goto waypoints;
			}

			Location[0] = Ident[0] = Description[0] = 0;
			if (NewLoc[ChosenLoc].Location != NULL)
				for (x = 0; NewLoc[ChosenLoc].Location[x] != '<'; x++)
					Location[x] = NewLoc[ChosenLoc].Location[x];
			if (NewLoc[ChosenLoc].Ident != NULL)
				for (x = 0; NewLoc[ChosenLoc].Ident[x] != '<'; x++)
					Ident[x] = NewLoc[ChosenLoc].Ident[x];
			if (NewLoc[ChosenLoc].Description != NULL)
				for (x = 0; NewLoc[ChosenLoc].Description[x] != '<'; x++)
					Description[x] = NewLoc[ChosenLoc].Description[x];

			Response = DialogBox(hInst, "LOCATIONDESC", hwnd, EditLocationProc);
			if (Response != EXIT)
				EditWaypoint();
			InvalidateRect(hwnd, &rect, FALSE);
			UpdateWindow(hwnd);
			SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			goto waypoints;
		}//end of if (Response == EDIT)

		else if (Response == LINE_TO)
		{
			if (NewLoc[ChosenLoc].UTMZone == UTMZone)
			{
				fromlineto = TRUE;
				hdc = GetDC(hwnd);
				hPen = CreatePen(PS_SOLID, 0, 0xF0);//red
				hObject = SelectObject(hdc, hPen);
				MoveToEx(hdc, centerX, centerY, NULL);
				DrawLineTo(NewLoc[ChosenLoc].NUTM, NewLoc[ChosenLoc].EUTM);
				SelectObject(hdc, hObject);
				ReleaseDC(hwnd, hdc);
				DeleteObject(hPen);
			}
			else
				MessageBox(hwnd, "Sorry, that waypoint isn't in this UTM zone", ERROR, MB_OK);
		}

		else if (Response == DELEET)
		{
			for (x = ChosenLoc; x < (TOTAL_LOCS-1); x++)
				NewLoc[x] = NewLoc[x+1];
			NewLoc[x].EUTM = 0;
			NewLoc[x].NUTM = 0;
			NewLoc[x].UTMZone = 0;
			NewLoc[x].pWaypoints = NULL;
			NewLoc[x].Ident = NULL;
			NewLoc[x].Location = NULL;
			NewLoc[x].Description = NULL;
			NewLoc[x].Elev = NULL;
			NewLoc[x].Sym = NULL;
			NewLoc[x].size = 0;
			EmptyLoc--;
			newLoc = TRUE;
			InvalidateRect(hwnd, &rect, FALSE);
			UpdateWindow(hwnd);
			SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			goto waypoints;
		}

		else if (Response == URL_LINK)
		{
			if ((NewLoc[ChosenLoc].Ident) && (NewLoc[ChosenLoc]. Ident[0] == 'G') && (NewLoc[ChosenLoc]. Ident[1] == 'C'))
			{
				for (x = 0; NewLoc[ChosenLoc].Ident[x] != '<'; x++)
					URLink[x + 101] = NewLoc[ChosenLoc].Ident[x];
				WinExec(URLink, SW_SHOW);
			}
		}

		else//GoTo
		{
//test lat/lon
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			UTMNorthing = NewLoc[ChosenLoc].NUTM;
			UTMEasting = NewLoc[ChosenLoc].EUTM;
			UTMZone = NewLoc[ChosenLoc].UTMZone;
			UTMtoLatLon();
			if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))//WM_RBUTTONDOWN
			{//outside range
				sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
				MessageBox(hwnd, Error, "Error 11", MB_OK);
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				return 0;
			}
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
//done with test
//			grid75 = FALSE;
			wastopo = FALSE;
			if (NewLoc[ChosenLoc].UTMZone == UTMZone)
			{
				rowOffset = ((NewLoc[ChosenLoc].NUTM / MetersPerTile) - (TilesDown/2));//center it
				colOffset = ((NewLoc[ChosenLoc].EUTM / MetersPerTile) - ((TilesAcross-1)/2));//center it
				SetCursor(hWaitingCursor);
				if (gotelevini)
					GetElevData();
				fromGoTo = TRUE;
				SendMessage(hwnd, WM_USER, 0, 0);
				SetCursor(hCursor);
			}
			else
			{
				int GotoEasting, GotoNorthing;
//this part is from GotoProc
				UTMNorthing = NewLoc[ChosenLoc].NUTM;
				UTMEasting = NewLoc[ChosenLoc].EUTM;
				UTMZone = NewLoc[ChosenLoc].UTMZone;
				UTMtoLatLon();
				ChangeZone(UTMZone, 4);//right button down
				BeginX = UTMEasting / MetersPerTile;
				BeginY = UTMNorthing / MetersPerTile;
				_itoa(BeginX, X, 10);
				_itoa(BeginY, Y, 10);
				Z[0] = (UTMZone / 10) + '0';
				Z[1] = (UTMZone % 10) + '0';

				if (tempUTMZone != UTMZone)
				{
					for (x = 0; Area[x] != 0; x++)
						Waypoints[x] = Area[x];
					for (y = 0; y < 5; x++, y++)
						Waypoints[x] = Xml[y];
					if (WaypointsPath[0] != 0)
					{
						for (y = 0; WaypointsPath[y] != 0; y++)
							WaypointsFullPath[y] = WaypointsPath[y];
						for (z = 0; Waypoints[z] != 0; y++, z++)
							WaypointsFullPath[y] = Waypoints[z];
						WaypointsFullPath[y] = 0;
						strcpy(NewLocationsFullPath, WaypointsFullPath);
					}
/*
					if ((0 == strcmp(Waypoints, WaypointsFullPath)) && (0 != strcmp(Waypoints, NewLocations)) && (IDYES == MessageBox(hwnd, "Do you want to switch to the waypoint list in that UTM zone?", "This waypoint is in another UTM zone", MB_YESNO)))
					{

						if (NewLoc[ChosenLoc].Location != 0)
						{
							for (x = 0; (NewLoc[ChosenLoc].Location[x] != '<'); x++)
								comment[x] = NewLoc[ChosenLoc].Location[x];//comment
							comment[x] = 0;
						}
						if (NewLoc[ChosenLoc].Ident != 0)
						{
							for (x = 0; (NewLoc[ChosenLoc].Ident[x] != '<'); x++)
								name[x] = NewLoc[ChosenLoc].Ident[x];//name
							name[x] = 0;
						}
						SendMessage(hwnd, WM_USER4, 0, 0);
					}
					else
*/
					{
						comment[0] = 0;
						name[0] = 0;
						for (x = 0; NewLocations[x] != 0; x++)
							Waypoints[x] = NewLocations[x];
						Waypoints[x] = 0;
//						for (x = 0; Area[x] != 0; x++)
//						{
//							TextDta[x] = Area[x];
//							NewLocations[x] = Area[x];
//						}
//						for (y = 0; y < 5; x++, y++)
//						{
//							TextDta[x] = Not[y];
//							NewLocations[x] = Xml[y];
//						}
//						if (Waypoints[0] != 0)//if from ID_WAYPOINTS_OPENFILE
//						{
//							for (x = 0; Waypoints[x] != 0; x++)
//								NewLocations[x] = Waypoints[x];
//							NewLocations[x] = 0;
//						}
						for (x = 0; (x < 20) && (Area[x] != 0); x++)
						{
							UTM[x] = Area[x];
							LatLon[x] = Area[x];
							USNG[x] = Area[x];
						}
						for ( ; x < 20; x++)
						{
							UTM[x] = ' ';
							LatLon[x] = ' ';
							USNG[x] = ' ';
						}
					}
				}
//this part is from ID_VIEW_GOTO
				GotoEasting = UTMEasting;
				GotoNorthing = UTMNorthing;
				veryfirstime = TRUE;
				rowOffset = BeginY - (TilesDown / 2);
				colOffset = BeginX - ((TilesAcross-1) / 2);
				SetCursor(hWaitingCursor);
				fromOpen = TRUE;
				SendMessage(hwnd, WM_USER, 0, 0);
				SetCursor(hCursor);
				UTMEasting = GotoEasting;
				UTMNorthing = GotoNorthing;
				UTMtoLatLon();//because WM_USER6 already has cursor location lat/lon
				if ((name[0] != 0) || (comment[0] != 0))
				{
					lButtonDotX = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
					lButtonDotY = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
					fromgoto = TRUE;
					SendMessage(hwnd, WM_USER6, 0, 0);
				}
			}
		}
		autoLoc = FALSE;
		return 0;


	case WM_KEYUP:
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
		if (wParam == VK_SHIFT)
			enteringtext = FALSE;
		if (wParam == VK_CONTROL)
		{
			distancemeasure = FALSE;
			mousewheel = FALSE;
//			xPosOld = xPos;
//			xbegOld = xbeg;
//			yPosOld = yPos;
//			ybegOld = ybeg;
		}
		if ((wParam == '1') && (onepressed))
		{
			onepressed = missing1meter = FALSE;
			InvalidateRect(hwnd, &rect, FALSE);
		}
		else if (drawing == FALSE)
		{
			if ((wParam == VK_SHIFT) && (xBeg != -1))
			{//finished drawing line for text entry
				Angle = 370.0;//initialized as a flag
				if ((yPos == yBeg) && (xPos > xBeg))//level
					Angle = 0.0;
				else if ((xPos == xBeg) && (yPos < yBeg))//straight up
					Angle = 90.0;
				else if ((xPos > xBeg) && (yPos < yBeg))
				{//angled up
					A = (double)(yBeg - yPos) / (double)(xPos - xBeg);
					Angle = (rad2deg * atan(A));
				}
				else if ((xPos > xBeg) && (yPos > yBeg))
				{//angled down
					A = (double)(xPos - xBeg) / (double)(yPos - yBeg);
					Angle = (rad2deg * atan(A)) + 270.0;
				}
				Response = DialogBox(hInst, "GETTEXT", hwnd, GetTextProc);
				InvalidateRect(hwnd, &rect, FALSE);
			}
		}
		if ((wParam == VK_SHIFT) || (wParam == VK_CONTROL))
			xBeg = -1;
		break;

	case WM_CHAR:
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
		if ((wParam == '+') || (wParam == '='))
			goto in;
		else if (wParam == '-')
			goto out;
//		else if (wParam == '~')
//		{//secret IP address:port
//			if (DialogBox(hInst, "SECRETIP", hwnd, SecretIPProc))
//			{
//				fromctrli = TRUE;
//				ResetEvent(hAPRSEvent);
//				hAPRSThread = _beginthreadex(NULL, 0, aprsISthread, hwnd, 0, &idThread15);
//				Sleep(500);
//			}
//		}
		return 0;

	case WM_KEYDOWN:
		EnterCriticalSection(&cs); downloadflg = downloading; LeaveCriticalSection(&cs); if (downloadflg == TRUE) break;
		if (wParam == VK_RETURN)
		{
			if ((approachcontrol) && (planecommand))
			{
				planecommand = FALSE;
				Plane[AtPlane].TAS = Plane[AtPlane].IAS + (Plane[AtPlane].IAS * Plane[AtPlane].altitude / 50000);
				TurnRadius = Plane[AtPlane].TAS * Plane[AtPlane].TAS * TwentyfiveDegreeBank; // in meters
				SecondsPerCircle = (PI * 2.0 * TurnRadius) / (Plane[AtPlane].TAS * MetersPerSec); // dist = rate x time
				Plane[AtPlane].RadiansPerSecond = PI * 2.0 / SecondsPerCircle;
				for (x = 0; x < command; x++)
				{ 
					if ((Command[x] == 'R') || (Command[x] == 'L')) {
						Plane[AtPlane].newHeading = Atoi(&Command[x+1]);
						Plane[AtPlane].newRadianheading = Plane[AtPlane].newHeading * deg2rad;
						Plane[AtPlane].Turn = Command[x];
					}
					if ((Command[x] == 'R') && (Plane[AtPlane].newHeading <= Plane[AtPlane].heading))
						Plane[AtPlane].newRadianheading += PI2;
					else if ((Command[x] == 'L') && (Plane[AtPlane].newRadianheading >= Plane[AtPlane].radianheading))
						Plane[AtPlane].newRadianheading -= PI2;

					if (Command[x] == 'A')
					{
						Plane[AtPlane].newAltitude = Atoi(&Command[x+1]);
						if (Plane[AtPlane].newAltitude < 1000) // 2 or 200 20 or 2000 200 or 20000
							Plane[AtPlane].newAltitude *= 100;
					}
					if (Command[x] == 'S')
						Plane[AtPlane].newIAS = Atoi(&Command[x+1]);
					if (Command[x] == 'T') // Tower
					{
						for (y = AtPlane; y < plane; y++)
							Plane[y] = Plane[y+1]; // remove Plane[AtPlane]
						plane--;
						AtPlane = -1;
					}
				}
			}
			else
				SendMessage(hwnd, WM_RBUTTONDOWN, 0, 0);
			break;
		}

		else if ((approachcontrol) && (!planecommand) && (wParam == VK_SPACE))
		{
			if (showdata) showdata = FALSE;
			else showdata = TRUE;
			break;
		}

		else if (wParam == VK_ESCAPE)
		{
			if (approachcontrol)
			{
				if (IDYES == MessageBox(hwnd, "Exit Approach Control?", "Approach Control", MB_YESNO|MB_DEFBUTTON2))
				{
					approachcontrol = FALSE;
					plane = 0;
					timeKillEvent(uTimerID);
					timeEndPeriod(TIMER_RESOLUTION);
					uTimerID = NULL;
					DeleteObject(hRedBrush);
					for (x = 0; x < 20; x++)
						Plane[x].UTMEasting = 0;
					InvalidateRect(hwnd, &rect, FALSE);
				}
				break;
			}
			xBeg = -1;
//			xbegOld = -1;
			Northest = 0;
			Eastest = 0x0FFFFFFF;
			Southest = 0x0FFFFFFF;
			Westest = 0;
			if (usamap)
			{
				usamap = FALSE;
				free(pUSA);
				pUSA = NULL;
				DestroyWindow(hwndUSA);
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
				if (notfromusa == FALSE)//to move to new Map Location
					SendMessage(hwnd, WM_COMMAND, ID_FILES_OPENMAPFILE, 0);
			}
			else if ((Pixels != NULL) || (showjpeg))
			{
				showjpeg = FALSE;
				if (Pixels != NULL)
					VirtualFree(Pixels, 0, MEM_RELEASE);
				Pixels = NULL;
				DestroyWindow(hwndBig);//will return 0 if (showjpeg)
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			}
			else if ((drawing) && (ptr > 1))
				EndRoute();
			else
				InvalidateRect(hwnd, &rect, FALSE);//for distancemeasure
			break;
		}

		if ((planecommand) && (command < 15))
		{
			if (wParam == VK_BACK)
			{
				command--;
				Command[command] = 0;
			}
			else if (wParam != VK_SPACE)
			{
				Command[command++] = wParam;
				hdc = GetDC(hwnd);
				SetBkMode(hdc, TRANSPARENT);
				SetTextColor(hdc, 0xFFFFFF);
				TextOut(hdc, Plane[AtPlane].x-10, Plane[AtPlane].y-40, Command, lstrlen(Command));
				SetTextColor(hdc, 0);
				SetBkMode(hdc, OPAQUE);
				ReleaseDC(hwnd, hdc);
			}
			break;
		}
		if (Pixels)//View -Show Jpeg
		{//from BigProc
			DWORD thirtytwo = 0;
			if (wParam != VK_ESCAPE)
			{
				if (wParam == VK_RIGHT)
				{
					for ( ; 0x7FFF & GetAsyncKeyState(VK_RIGHT); )
					{
						if (xBigLoc < (BigWidth - rect.right - 32))
							xBigLoc += 32;
						InvalidateRect(hwndBig, &rect, FALSE);
					}
				}
				if (wParam == VK_LEFT)
				{
					for ( ; 0x7FFF & GetAsyncKeyState(VK_LEFT); )
					{
						if (xBigLoc >= 32)
							xBigLoc -= 32;
						InvalidateRect(hwndBig, &rect, FALSE);
					}
				}
				if (wParam == VK_UP)
				{
					for ( ; 0x7FFF & GetAsyncKeyState(VK_UP); )
					{
						if (yBigLoc >= 50)
							yBigLoc -= 50;
						InvalidateRect(hwndBig, &rect, FALSE);
					}
				}
				if (wParam == VK_DOWN)
				{
					for ( ; 0x7FFF & GetAsyncKeyState(VK_DOWN); )
					{
						if (yBigLoc < (BigHeight - rect.bottom - 32))
							yBigLoc += 32;
						InvalidateRect(hwndBig, &rect, FALSE);
					}
				}
				return 0;//don't do anything else
			}
		}
		if (qpressed)
		{
			qpressed = FALSE;
			SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
		}

		switch (wParam)
		{
//			if (aprs)
//			{
//				int f, g;
//				for (f = 0, g = 0; FINDU[f] != 0; f++, g++)
//					Findu[g] = FINDU[f];
//				for (f = 0; Error[f] != 0; f++, g++)
//					Findu[g] = Error[f];
//				Findu[g] = 0;
//				WinExec(Findu, SW_SHOW);
//			}
//			break;

//		case 'Y':
//			if (GetKeyState(VK_CONTROL) < 0)
//			{
//				downloaded = FALSE;
//				notcancelled = TRUE;
//				hThread = _beginthreadex(NULL, 0, TigerThread, NULL, 0, &idThread);
//				Sleep(500);
//			}
//			break;
		case 'J':
			SendMessage(hwnd, WM_COMMAND, ID_VIEW_BIGJPEG, 0);
			break;

		case 'M':
			SendMessage(hwnd, WM_COMMAND, ID_VIEW_MAPOFUSA, 0);
			break;

		case '1':
			if ((Zoom >= 5) && (MapType == PHOTO))
			{				
				int MetersPerPixel;

				if (onepressed == TRUE)
					break;
				onepressed = TRUE;
				missing1meter = TRUE;
				SetCursor(hWaitingCursor);
				OneMeterTilesDown = TilesDown * 8;
				OneMeterTilesAcross = TilesAcross * 8;
				OneMeterTileSize = PixelsPerTile / 8;//3.125, 6.25, 12.5, 25
				if (OneMeterTileSize != 25)
					OneMeterTileSize++;
				p1MeterSize = OneMeterTilesAcross*OneMeterTilesDown;
				p1Meter = (BYTE*)malloc(p1MeterSize);
				p1MeterX = (DWORD*)calloc(1, OneMeterTilesAcross*sizeof(DWORD));
				p1MeterY = (DWORD*)calloc(1, OneMeterTilesDown*sizeof(DWORD));
				for (x = 0; x < p1MeterSize; x++)
					p1Meter[x] = 0;
				MetersPerPixel = MetersPerTile/PixelsPerTile;
				xFraction = yFraction = w = y = 0;
				if (MetersPerPixel == 8)
				{//25 PixelsPerTile
					for ( ; w < OneMeterTilesDown; w++)
					{
						for (v = 0, x = 0; v < OneMeterTilesAcross; v++)
						{
							x += 25;
							p1MeterX[v] = x;
						}
						y += 25;
						p1MeterY[w] = y;
					}
				}
				else if (MetersPerPixel == 16)
				{//12.5 PixelsPerTile
					for ( ; w < OneMeterTilesDown; w++)
					{
						for (v = 0, x = 0; v < OneMeterTilesAcross; v++)
						{
							x += 12;
							if (xFraction == 1)
							{
								x++;
								xFraction = 0;
							}
							else
								xFraction++;
							p1MeterX[v] = x;
						}
						y += 12;
						if (yFraction == 1)
						{
							y++;
							yFraction = 0;
						}
						else
							yFraction++;
						p1MeterY[w] = y;
					}
				}
				else if (MetersPerPixel == 32)
				{//6.25 PixelsPerTile
					for ( ; w < OneMeterTilesDown; w++)
					{
						for (v = 0, x = 0; v < OneMeterTilesAcross; v++)
						{
							x += 6;
							if (xFraction == 3)
							{
								x++;
								xFraction = 0;
							}
							else
								xFraction++;
							p1MeterX[v] = x;
						}
						y += 6;
						if (yFraction == 3)
						{
							y++;
							yFraction = 0;
						}
						else
							yFraction++;
						p1MeterY[w] = y;
					}
				}
				else if (MetersPerPixel == 64)
				{//3.125 PixelsPerTile
					for ( ; w < OneMeterTilesDown; w++)
					{
						for (v = 0, x = 0; v < OneMeterTilesAcross; v++)
						{
							x += 3;
							if (xFraction == 7)
							{
								x++;
								xFraction = 0;
							}
							else
								xFraction++;
							p1MeterX[v] = x;
						}
						y += 3;
						if (yFraction == 7)
						{
							y++;
							yFraction = 0;
						}
						else
							yFraction++;
						p1MeterY[w] = y;
					}
				}
				North = (ScreenTop - 200) / 200;
 				West = ScreenLeft / 200;
				pointerFileName[0] = 'U';
				pointerFileName[1] = 'S';
				pointerFileName[2] = 'A';
				for (w = 0; w < OneMeterTilesDown; w++, North--)
				{
					GetRowName(North, West);
					for (x = 36, y = 17; RowName[x] != ' '; x++, y++)
						pointerFileName[y] = RowName[x];
					pointerFileName[y++] = '.';
					pointerFileName[y++] = 'p';
					pointerFileName[y++] = 't';
					pointerFileName[y++] = 'r';
					pointerFileName[y] = 0;
					hFile4 = CreateFile(pointerFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile4 != INVALID_HANDLE_VALUE)
					{
						if (fileSize = GetFileSize(hFile4, NULL))
						{
							ReadFile(hFile4, Pointers, fileSize, &dwBytesRead, NULL);
							NumOfPointers = Pointers[1];
							Pointers[1] = 0;
							for (v = 0; v < OneMeterTilesAcross; v++)
							{
								if ((West+v) < (Pointers[0]))
									p1Meter[(w*OneMeterTilesAcross)+v] = 1;
								else if (((West+v) < (Pointers[0] + NumOfPointers)))// && (y <= NumOfPointers))
								{
									if (Pointers[(West+v)-Pointers[0]+1] == Pointers[(West+v)-Pointers[0]+2])
										p1Meter[(w*OneMeterTilesAcross)+v] = 1;
								}
								else// if ((West+v) >= (Pointers[0] + NumOfPointers))
									p1Meter[(w*OneMeterTilesAcross)+v] = 1;
							}
							CloseHandle(hFile4);
						}
					}	
					else
					{//if no row data
						for (v = 0; v < OneMeterTilesAcross; v++)
							p1Meter[(w*OneMeterTilesAcross)+v] = 1;
					}
				}
				pointerFileName[0] = 'B';
				pointerFileName[1] = 'i';
				pointerFileName[2] = 'g';
				SetCursor(hCursor);
				InvalidateRect(hwnd, &rect, FALSE);
			}
			break;

		case 'H':
			if (showingtracks)
				SendMessage(hwndTrack, WM_COMMAND, 0, (LPARAM)hwndButton3);
			else
				SendMessage(hwnd, WM_COMMAND, ID_VIEW_TIGERLINES_HIGHWAYS, 0);
			break;

		case 'R':
			SendMessage(hwnd, WM_COMMAND, ID_VIEW_TIGERLINES_LOCALSTREETS, 0);
			break;

		case 'E':
			if (showingtracks)
				SendMessage(hwndTrack, WM_COMMAND, 0, (LPARAM)hwndButton);
			else
				SendMessage(hwnd, WM_COMMAND, ID_FILE_DOWNLOADELEVATIONDATA, 0);
			break;

		case 'S':
			if (autoLoc)
				SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_STOPPOSITIONING, 0);
			else
			{
				froms = TRUE;
				SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_FILE_DOWNLOADMAPDATA_TIGERSTREETS, 0);
			}
			break;

		case 'B':
			if (showingtracks)
				SendMessage(hwndTrack, WM_COMMAND, 0, (LPARAM)hwndButton2);
			else
				SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_VIEW_BRIGHTNESS_BRIGHTER, 0);
			break;

		case 'D':
			SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_VIEW_BRIGHTNESS_DARKER, 0);
			break;

		case 'W':
			SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_VIEW_SHOWWAYPOINTNAMES, 0);
			break;

		case VK_DELETE://to delete photo at mouse pointer
			if (yPos == 0)
				break;
			else if ((GetKeyState(VK_SHIFT) < 0) && (editingtracks == FALSE))
			{
				if (IDYES == MessageBox(hwnd, "Delete the entire row of data\nthat the cursor is on?", "DELETE", MB_YESNO))
				{
					GetFileName();
					if (FindFirstFile(fileName, &fd))
					{
						DeleteFile(fileName);
						DeleteFile(pointerFileName);
						fromOpen = TRUE;
						SendMessage(hwnd, WM_USER, 0, 0);
						break;
					}
				}
				else
					break;
			}

			if (editingtracks)
			{
				currentpoint = -1;
				for (x = 0; trak[x].time != 0; x++)
				{
					if ((trak[x].EUTM < UTMEasting+(6*MetersPerTile/PixelsPerTile)) && (trak[x].EUTM > UTMEasting-(6*MetersPerTile/PixelsPerTile))
					 && (trak[x].NUTM < UTMNorthing+(6*MetersPerTile/PixelsPerTile)) && (trak[x].NUTM > UTMNorthing-(6*MetersPerTile/PixelsPerTile)))
					{
						currentpoint = x;
						break;
					}
				}
				if (currentpoint != -1)
				{
					if ((trak[currentpoint].newtrk != 0) || (currentpoint == 0))
					{
						for (x = currentpoint; trak[x].time != 0; x++)
							trak[x] = trak[x+1];
						if (trak[currentpoint].time != 0)
							trak[currentpoint].newtrk = 1;
					}
					else if (trak[currentpoint+2].newtrk == 1)
					{
						for (x = currentpoint+1; trak[x].time != 0; x++)
							trak[x] = trak[x+1];
					}
					else if (trak[currentpoint+2].time != 0)
						trak[currentpoint+1].newtrk = 1;
					else
					{
						trak[currentpoint+1].EUTM = 0;
						trak[currentpoint+1].NUTM = 0;
						trak[currentpoint+1].time = 0;
						trak[currentpoint+1].newtrk = 0;
					}
					SaveTracks();
					InvalidateRect(hwnd, &rect, FALSE);
				}
				return 0;
			}//end of if (editingtracks)

			GetFileName();
			FillMemory(tempPtr, sizeof(tempPtr), 0);
			hFile = CreateFile(fileName, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				dataFileSize = GetFileSize(hFile, NULL);
				if (dataFileSize)
				{
					tempDta = (char*)malloc(dataFileSize);
					ReadFile(hFile, tempDta, dataFileSize, &dwBytesRead, NULL);
				}
				else
				{
					CloseHandle(hFile);
					return 0;
				}
				CloseHandle(hFile);
			}
			else
				return 0;
			hFile = CreateFile(pointerFileName, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				fileSize = GetFileSize(hFile, NULL);
				if (fileSize)
					ReadFile(hFile, tempPtr, fileSize, &dwBytesRead, NULL);
				else
				{
					free(tempDta);
					CloseHandle(hFile);
					return 0;
				}
				CloseHandle(hFile);
			}
			else
			{
				free(tempDta);
				return 0;
			}//num	addr	size
//	8	 C744	8,705
//  9	 E945	8,701
// 10	10B42	8,171
// 11	12B2D	8,554
// 12	14C97	8,247
// 13	16CCE	8,479
// 14	18DED
//after writing over 8, it becomes
//  8	 C744	0
//  9	 C744	8,701
// 10	 E941	8,171
// 11	1092C	8,554
// 12	12A96	8,247
// 13	14ACD	8,479
// 14	16BEC
			if (0 == (GetKeyState(VK_CONTROL) & 0x80000000))
			{//if Ctrl key not down
				MessageBox(hwnd, "Hold the Ctrl key down\nwhile pressing the Delete key.\n\n\
Holding the Shift key down\nwhile pressing the Delete key\ndeletes the whole row.", "Delete", MB_OK);
				free(tempDta);
				break;
			}
			x = West / MetersPerTile;
			if ((x < tempPtr[0]) || (x >= (tempPtr[0] + tempPtr[1])))
			{
				free(tempDta);
				break;//not in file
			}
			pointer = x - tempPtr[0] + 1;
			NumOfPointers = tempPtr[1];
			tempPtr[1] = 0;//now it's first offset
			if (x == tempPtr[0])
			{//first image
				fileSize -= 4;
				tempPtr[0] = x+1;
				NumOfPointers--;
				w = tempPtr[pointer];
				z = tempPtr[pointer+1];
				v = tempPtr[pointer+2];
				while (pointer < (NumOfPointers+1))
				{
					if (v != 0)
					{
						size = v - z;
						for (x = 0; x < size; w++, x++, z++)
							tempDta[w] = tempDta[z];
					}
					pointer++;
					tempPtr[pointer] = tempPtr[pointer-1] + size;
					z = tempPtr[pointer+1];
					v = tempPtr[pointer+2];
				}
			}
			else if (x == tempPtr[0] + tempPtr[1] - 1)
			{//last image
				fileSize -= 4;
				w = tempPtr[NumOfPointers];
				NumOfPointers--;
			}
			else
			{//not first or last image
				w = tempPtr[pointer];
				z = tempPtr[pointer+1];
				v = tempPtr[pointer+2];
				tempPtr[pointer+1] = tempPtr[pointer];
				while (pointer < (NumOfPointers+1))
				{
					y = w;
					if (v != 0)
					{
						size = v - z;
						for (x = 0; x < size; w++, x++, z++)
							tempDta[w] = tempDta[z];
					}
					pointer++;
					tempPtr[pointer] = y;
					z = tempPtr[pointer+1];
					v = tempPtr[pointer+2];
				}
			}
			tempPtr[1] = NumOfPointers;
			hFile = CreateFile(fileName, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, tempDta, w, &dwBytesWritten, NULL);
			FlushFileBuffers(hFile);
			CloseHandle(hFile);
			free(tempDta);
			hFile = CreateFile(pointerFileName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, tempPtr, fileSize, &dwBytesWritten, NULL);
			FlushFileBuffers(hFile);
			CloseHandle(hFile);
			SendMessage(hwnd, WM_USER, 0, 0);
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case 'T':
			SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_VIEW_MAPTYPE_TOPO, 0);
			break;

		case 'P':
			SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_VIEW_MAPTYPE_PHOTO, 0);
			break;

		case 'U'://Urban Areas
			SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_VIEW_MAPTYPE_COLOR, 0);
			break;

		case 'L'://USGS Landmarks
			SendMessage(hwnd, WM_COMMAND, (WPARAM)ID_VIEW_SHOWUSGSLANDMARKS, 0);
			break;

		case 'F':
			SendMessage(hwnd, WM_COMMAND, ID_FILE_DOWNLOADMAPDATA_FILLSCREEN, 0);
			break;

//		case '7':
//			if (grid75 == FALSE)
//			{
//				grid75 = TRUE;
//			}
//			else
//			{
//				grid75 = FALSE;
//			}
//			InvalidateRect(hwnd, &rect, FALSE);
//			break;

		case 'X':
			if (autoLoc)
				break;
			for (x = 0; x < 600; x++)
				LatLonUTM[x] = 0;
//			if (grid75 == FALSE)
			{//draw a temporary orange X
				hdc = GetDC(hwnd);
				hPen = CreatePen(PS_SOLID, 2, 0x80FF);
				hObject = SelectObject(hdc, hPen);
				MoveToEx(hdc, xPos-5, yPos-5, NULL);
				LineTo(hdc, xPos+5, yPos+5);
				MoveToEx(hdc, xPos-5, yPos+5, NULL);
				LineTo(hdc, xPos+5, yPos-5);
				SelectObject(hdc, hObject);
				DeleteObject(hPen);
				ReleaseDC(hwnd, hdc);
				itsx = TRUE;
			}
			tempMouseLoc = MouseLoc;
			MouseLoc = DEG;
			GetLatLon();
			for (x = 0, y = 23; x < 38; x++, y++)
				LatLonUTM[x] = LatLon[y];
			LatLonUTM[x++] = '\r';
			LatLonUTM[x++] = '\n';

			MouseLoc = DEGMIN;
			GetLatLon();
			for (z = 0, y = 23; z < 38; x++, y++, z++)
				LatLonUTM[x] = LatLon[y];
			w = 0;
			LatLonUTM[x++] = '\r';
			LatLonUTM[x++] = '\n';
			//01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
//LatLon[] = "USAPhotoMaps           N 34d 30.555        W  122' 25.555       Zoom: 1 meter /pixel   Elev:       ";
			z = 25;//tempLatLonUTM is used if grid75
			tempLatLonUTM[w++] = LatLon[z++];//degrees
			tempLatLonUTM[w++] = LatLon[z++];
			tempLatLonUTM[w++] = '.';
			z += 2;//to minutes
			if (LatLon[z+1] == '.')
				tempLatLonUTM[w++] = '0';
			tempLatLonUTM[w++] = LatLon[z++];//first minute digit
			if (LatLon[z] != '.')
				tempLatLonUTM[w++] = LatLon[z];
			z += 16;

			tempLatLonUTM[w++] = ' ';
			tempLatLonUTM[w++] = '-';

			tempLatLonUTM[w++] = LatLon[z++];//minutes
			tempLatLonUTM[w++] = LatLon[z++];
			if (LatLon[z] != '\xB0')//degree
				tempLatLonUTM[w++] = LatLon[z++];
			z += 2;
			tempLatLonUTM[w++] = '.';
			if (LatLon[z+1] == '.')
				tempLatLonUTM[w++] = '0';
			tempLatLonUTM[w++] = LatLon[z++];
			if (LatLon[z] != '.')
				tempLatLonUTM[w++] = LatLon[z++];
/*
			if (grid75)
			{
				HGLOBAL hGlobal;
				PTSTR pGlobal;
				tempLatLonUTM[w++] = ' ';
				for (x = 0; SDTS[x] != 0; w++, x++)
					tempLatLonUTM[w] = SDTS[x];
				tempLatLonUTM[w] = 0;
//THE FOLLOWING CAUSES DEBUG TO EXIT TO INT3 (puts the lat/lon in special format in the clipboard)
				hGlobal = GlobalAlloc(GHND|GMEM_SHARE, w+1);
				pGlobal = (char*)GlobalLock(hGlobal);
				lstrcpy(pGlobal, tempLatLonUTM);
				GlobalUnlock(hGlobal);
				OpenClipboard(NULL);
				EmptyClipboard();
				SetClipboardData(CF_TEXT, hGlobal);
				CloseClipboard();

				MessageBox(hwnd, ATDI, "Done", MB_OK);
			}//end of if (grid75)
			else//not grid75
*/
			{
				char Zone[] = " Zone xx";
				tempLatLonUTM[w] = 0;
				MouseLoc = DEGMINSEC;
				GetLatLon();
				for (z = 0, y = 23; z < 38; x++, y++, z++)
					LatLonUTM[x] = LatLon[y];
				LatLonUTM[x++] = '\r';
				LatLonUTM[x++] = '\n';

				GetUTM(UTMNorthing, UTMEasting);
				for (z = 0, y = 25; z < 35; x++, y++, z++)
					LatLonUTM[x] = UTM[y];
				Zone[6] = Z[0];
				Zone[7] = Z[1];
				for (z = 0; Zone[z] != 0; z++)
					LatLonUTM[x++] = Zone[z];
				LatLonUTM[x++] = '\r';
				LatLonUTM[x++] = '\n';

				North = (ScreenTop - (yPos*MetersPerTile/PixelsPerTile)) / MetersPerTile;
				West = (ScreenLeft + (xPos*MetersPerTile/PixelsPerTile)) / MetersPerTile;
				GetRowName(North, West);
				for (z = 36; z < 52; x++, z++)
					LatLonUTM[x] = RowName[z];
				for (w = 0; Q[w] != 0; w++, x++)
					LatLonUTM[x] = Q[w];
				LatLonUTM[x++] = '\r';
				LatLonUTM[x++] = '\n';
				LatLonUTM[x++] = '\r';
				LatLonUTM[x++] = '\n';
//				for (z = 0; z < w; x++, z++)
//					LatLonUTM[x] = tempLatLonUTM[z];
//now get http:// line
//get photo/topo dates from http://msrmaps.com/ImageInfo.aspx?T=1&S=14&Z=10&X=180&Y=1295
//<span id="PgImg_PrintDate" class="pldte">2/19/1995</span>
//CHANGE TO CTRL-D TO GET PHOTO/TOPO DATE AT CURSOR
				w = 54;//just after S=
//				z = 53;//just after s=
//				tz = 99;//just after s=
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
				UTMNorthing = ScreenTop - (((rect.bottom / 2) * MetersPerTile) / PixelsPerTile);
				UTMEasting = ScreenLeft + (((rect.right / 2) * MetersPerTile) / PixelsPerTile);
				UTMtoLatLon();
				count = 9;
				ptrToAscii = _ecvt(Lon, count, &decPos, &sign);
				count = 8;
				ptrToAscii = _ecvt(Lat, count, &decPos, &sign);
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				MouseLoc = tempMouseLoc;
				DialogBox(hInst, "SHOWLATLON", hwnd, LatLonProc);
				itsx = FALSE;
				InvalidateRect(hwnd, &rect, FALSE);
			}//end of else (!grid75)
			break;
		case 'Z':
			if (drawing)
			{//Ctrl-Z
				x = GetKeyState(VK_CONTROL);
				if ((x < 0) && (ptr > 1))
				{//delete last point
					ptr--;
					InvalidateRect(hwnd, &rect, FALSE);
				}
				else if (ptr == 1)
				{
					SendMessage(hwnd, WM_LBUTTONDBLCLK, 0, 0);
				}
			}
			break;

		case 'Q':
			qpressed = TRUE;
			SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
			break;

		case 'C':
			if (gotelevini == FALSE)
				MessageBox(hwnd, "There is no elevation data (no Elev.ini file).\nSelect File -Download Elevation Data\n(and read Help -Using).", Oops, MB_OK);
			else
			{
				if (contourson)
				{
					contourson = FALSE;
//					ModifyMenu(hMenu, ID_VIEW_CONTOURS, MF_BYCOMMAND|MF_STRING, ID_VIEW_CONTOURS, Contourson);
//					DrawMenuBar(hwnd);
					CheckMenuItem(hMenu, ID_VIEW_CONTOURS, MF_UNCHECKED);
				}
				else
				{
					contourson = TRUE;
//					ModifyMenu(hMenu, ID_VIEW_CONTOURS, MF_BYCOMMAND|MF_STRING, ID_VIEW_CONTOURS, Contoursoff);
//					DrawMenuBar(hwnd);
					CheckMenuItem(hMenu, ID_VIEW_CONTOURS, MF_CHECKED);
				}
				if (showElev)
					showElev = FALSE;
				else
					showElev = TRUE;
				InvalidateRect(hwnd, &rect, FALSE);
			}
			break;

		case VK_F1:
			if (autoLoc == FALSE)
			{
				pHelp = NULL;
				hFile = CreateFile(Instruct, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					if (HelpSize = GetFileSize(hFile, NULL))
					{
						pHelp = (char *) malloc(HelpSize+1);
						if (pHelp == NULL)
							MessageBox(hwnd, "OHOH", "", MB_OK);
						pHelp[HelpSize] = 0;
						ReadFile(hFile, pHelp, HelpSize, &dwBytesRead, NULL);

						hMenu2 = CreateMenu();//to override parent menu bar
						hwndHelp = CreateWindow(Instruct, Instruct,
							WS_POPUP | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
							cxScreen/2-320, TitleAndMenu, (cxScreen/2 + 320)-(cxScreen/2-320), cyScreen-(cyChar*3),
							NULL, hMenu2, hInst, NULL);
						SetWindowText(hwndInstr, pHelp);
						SetFocus(hwndInstr);
					}
					CloseHandle (hFile);
				}
				else
					MessageBox(hwnd, NoHelpFile, NULL, MB_OK);
//				if (pHelp != NULL)
//					free(pHelp);
			}
			return 0;

		case VK_PRIOR://zoom out
out:
			if (distancemeasure)
			{
				distancemeasure = FALSE;
//				xBeg = xbegOld = -1;
			}		
			if (GetKeyState(VK_CONTROL) < 0)
				ctrlnotused = FALSE;
			else
				ctrlnotused = TRUE;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if ((MapType == TOPO) && (Zoom < 8))
			{
				UncheckZoom();
				Zoom++;
				if (Zoom == 5)
				{//64 meters/pixel
					PixelsPerTile = 200;
					MetersPerTile = 12800;
				}
				else
					PixelsPerTile >>= 1;
				ShowZoom();
				DoZoom();
			}
			else if ((MapType == PHOTO) && (Zoom < 8))
			{
				if (Zoom == 3)
				{
					if (zoom1to8)
					{
						UncheckZoom();
						Zoom = 4;
						PixelsPerTile = 25;
					}
					else
					{
						UncheckZoom();
						Zoom = 5;
						PixelsPerTile = 200;
					}
				}
				else if (Zoom == 4)
				{
					UncheckZoom();
					Zoom = 5;
					PixelsPerTile = 200;
				}
				else
				{
					UncheckZoom();
					Zoom++;
					PixelsPerTile >>= 1;
				}
				if (Zoom <= 4)
					MetersPerTile = 200;
				else
					MetersPerTile = 1600;
				ShowZoom();
				DoZoom();
			}
			else if ((MapType == URBANAREA) && (Zoom < 8))
			{
				UncheckZoom();
				Zoom++;
				if (Zoom == 5)
				{
					PixelsPerTile = 200;
					MetersPerTile = 800;
				}
				else
					PixelsPerTile >>= 1;
				ShowZoom();
				DoZoom();
			}
			return 0;

		case VK_NEXT://zoom in
in:
			if (distancemeasure)
			{
				distancemeasure = FALSE;
//				xBeg = xbegOld = -1;
			}		
			if (GetKeyState(VK_CONTROL) < 0)
				ctrlnotused = FALSE;
			else
				ctrlnotused = TRUE;
			PrevMetersPerTile = MetersPerTile;
			PrevPixelsPerTile = PixelsPerTile;
			if ((MapType == TOPO) && (Zoom > 1))
			{
				UncheckZoom();
				Zoom--;
				if (Zoom == 4)
				{//32 meters/pixel
					PixelsPerTile = 25;
					MetersPerTile = 800;
				}
				else
					PixelsPerTile <<= 1;
				ShowZoom();
				DoZoom();
				break;
			}
			else if (MapType == PHOTO)
			{
				if (Zoom == 5)
				{
					if (zoom1to8)
					{
						UncheckZoom();
						Zoom = 4;
						PixelsPerTile = 25;
					}
					else
					{
						UncheckZoom();
						Zoom = 3;
						PixelsPerTile = 50;
					}
					MetersPerTile = 200;
					ShowZoom();
					DoZoom();
				}
				else if (Zoom != 1)
				{
					UncheckZoom();
					Zoom--;
					PixelsPerTile <<= 1;
					if (Zoom <= 4)
						MetersPerTile = 200;
					else
						MetersPerTile = 1600;
					ShowZoom();
					DoZoom();
				}
			}
			else if ((MapType == URBANAREA) && (Zoom > 1))
			{
				UncheckZoom();
				Zoom--;
				if (Zoom == 4)
				{
					PixelsPerTile = 25;
					MetersPerTile = 50;
				}
				else
					PixelsPerTile <<= 1;
				ShowZoom();
				DoZoom();
			}
			return 0;

		case VK_UP:
			if (distancemeasure)
			{
				yBeg += PixelsPerTile;
//				xbegOld = -1;
			}
			wastopo = FALSE;
			directdraw = FALSE;
			zoom = Zoom;
			if (zoom >= 5)
				zoom -= 5;
			if ((Spaces2Move != 0) && (zoom <= 2) && (0 == (GetKeyState(VK_CONTROL) & 0x80000000)))
				InitDirectDraw();

			if ((lParam != FROMCOMM) && (autoLoc) && (fromFlag == NOBUTTON))
			{
				fromFlag = UP;
				if (itsgarmin)
				{
					sendingStop = TRUE;
					WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = StopPVTPacket[y];
					if (tgcount > 49900) tgcount = 0;
					return 0;//ACK will call this routine again
				}
				else if (itsusb == FALSE)
				{
					autoLoc = FALSE;
					SetEvent(hEventExit);
				}
				else if (hUSBThread != 0)//if (itsusb)
				{
					SignalUSBStop();
				}
			}
			if (fromFlag != NOBUTTON)
			{
				showposition = FALSE;
				fromFlag = NOBUTTON;
				autoLoc = FALSE;
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				RedDot(hwnd);
			}
			BitBlt(hdcMem, 0, PixelsPerTile, PixelsPerTile*TilesAcross, PixelsPerTile*(TilesDown-1), hdcMem, 0, 0, SRCCOPY);
			maxCols = TilesAcross + colOffset;
			yLoc = 0;
			ZoneName[0] = Z[0];
			ZoneName[1] = Z[1];
			_itoa(rowOffset + TilesDown, Y, 10);
			for (x = 0, z = 18; x < 3; x++, z++)
			{
				fileName[z] = ZoneName[x];
				pointerFileName[z] = ZoneName[x];
			}
			for (x = 0; Y[x] != 0; x++, z++)
			{
				pointerFileName[z] = Y[x];
				fileName[z] = Y[x];
			}
			for (x = 0; x < 5; x++, z++)
			{
				pointerFileName[z] = Ptr[x];
				fileName[z] = Dta[x];
			}
			hFile = CreateFile (fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				hFile2 = CreateFile(pointerFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				fileSize = GetFileSize(hFile2, NULL);
				ReadFile(hFile2, Pointers, fileSize, &dwBytesRead, NULL);
				CloseHandle (hFile2);
				FirstOffset = Pointers[0];
				NumOfPointers = Pointers[1];
				Pointers[1] = 0;
				for (xLoc = 0, col = colOffset; col < maxCols; xLoc += PixelsPerTile, col++)
				{
					PointerOffset = col - FirstOffset;
					if ((PointerOffset >= 0) && (PointerOffset < NumOfPointers))
					{
						fileSize = Pointers[PointerOffset+2] - Pointers[PointerOffset+1];
						if (fileSize > 1)
						{
							SetFilePointer(hFile, Pointers[PointerOffset+1], NULL, FILE_BEGIN);
							ReadFile(hFile, TileBuf, fileSize, &dwBytesRead, NULL);
							if ((TileBuf[6] == 'J') && (TileBuf[7] == 'F'))
								Convert_TileBuf_hdcMem(NULL, 0xFFFFFFFF);
							else
								BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcBlackMem, 0, 0, SRCCOPY);
						}
						else
							BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
					}
					else
						BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
				}
				CloseHandle (hFile);
			}
			else
				for (xLoc = 0, col = colOffset; col < maxCols; xLoc += PixelsPerTile, col++)
					BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
			rowOffset++;
//			if (lParam != FROMCOMM)
			{
				if (gotelevini)
					GetElevData();
				if (directdraw)
				{//VK_UP
					rect1.left = rect.left+xFrame; rect1.top = rect.top+TitleAndMenu+xFrame; rect1.right = rect.right-xFrame; rect1.bottom = rect.bottom-xFrame;
					rect2.left = rect.left+xFrame; rect2.top = rect.top+TitleAndMenu+xFrame; rect2.right = rect.right-xFrame; rect2.bottom = rect.bottom-xFrame;
					GetClientRect(hwnd, &rect);
					rect3.left = rect.left; rect3.top = rect.top+PixelsPerTile; rect3.right = rect.right; rect3.bottom = rect.top+PixelsPerTile+Spaces2Move;
					rect4.left = rect2.left; rect4.top = rect2.top; rect4.right = rect2.right; rect4.bottom = rect2.top+Spaces2Move;
					if (DD_OK == lpDDSBack2->GetDC(&hdcBack2))
					{
						if (BitBlt(hdcBack2, 0, 0, MapWidth, MapHeight, hdcMem, 0, 0, SRCCOPY))//the new screen
						{
							if (DD_OK == lpDDSBack2->ReleaseDC(hdcBack2))
							{
								for (x = 0; x < PixelsPerTile; x += Spaces2Move)
								{
									rect1.bottom -= Spaces2Move;
									rect2.top += Spaces2Move;
									rect3.top -= Spaces2Move;
									rect4.bottom += Spaces2Move;
									if (DD_OK == lpDDSPrimary->Blt(&rect2, lpDDSBack, &rect1, DDBLT_WAIT, NULL))//move screen
										lpDDSPrimary->Blt(&rect4, lpDDSBack2, &rect3, DDBLT_WAIT, NULL);//the top edge
								}
							}
						}
					}
					if (lpDDSBack2 != NULL) {lpDDSBack2->Release(); lpDDSBack2 = NULL;}
					if (lpDDSBack != NULL) {lpDDSBack->Release(); lpDDSBack = NULL;}
					if (lpDDSPrimary != NULL) {lpDDSPrimary->Release(); lpDDSPrimary = NULL;}
					if (lpDD7 != NULL) {lpDD7->Release(); lpDD7 = NULL;}
					directdraw = FALSE;
				}
//				else//Tiger streets need the following
				{
					InvalidateRect(hwnd, &rect, FALSE);
					UpdateWindow(hwnd);
				}
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar

//				if (autodownload)
//					SendMessage(hwnd, WM_COMMAND, ID_FILE_DOWNLOADMAPDATA_FILLSCREEN, 0);
			}
			cachenotfull = TRUE;
			break;

		case VK_DOWN:
//			xbegOld = -1;
			wastopo = FALSE;
			if (distancemeasure)
			{
				yBeg -= PixelsPerTile;
//				xbegOld = -1;
			}
			directdraw = FALSE;
			zoom = Zoom;
			if (zoom >= 5)
				zoom -= 5;
			if ((Spaces2Move != 0) && (zoom <= 2) && (0 == (GetKeyState(VK_CONTROL) & 0x80000000)))
				InitDirectDraw();

			if ((lParam != FROMCOMM) && (autoLoc) && (fromFlag == NOBUTTON))
			{
				fromFlag = DOWN;
				if (itsgarmin)
				{
					sendingStop = TRUE;
					WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = StopPVTPacket[y];
					if (tgcount > 49900) tgcount = 0;
					return 0;//ACK will call this routine again
				}
				else if (itsusb == FALSE)
				{
					autoLoc = FALSE;
					SetEvent(hEventExit);
				}
				else if (hUSBThread != 0)//if (itsusb)
				{
					SignalUSBStop();
				}
			}
			if (fromFlag != NOBUTTON)
			{
				showposition = FALSE;
				fromFlag = NOBUTTON;
				autoLoc = FALSE;
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				RedDot(hwnd);
			}
			BitBlt(hdcMem, 0, 0, PixelsPerTile*TilesAcross, PixelsPerTile*(TilesDown-1), hdcMem, 0, PixelsPerTile, SRCCOPY);
			rowOffset--;
			maxCols = TilesAcross + colOffset;
			yLoc = PixelsPerTile * (TilesDown-1);
			ZoneName[0] = Z[0];
			ZoneName[1] = Z[1];
			_itoa(rowOffset, Y, 10);
			for (x = 0, z = 18; x < 3; x++, z++)
			{
				fileName[z] = ZoneName[x];
				pointerFileName[z] = ZoneName[x];
			}
			for (x = 0; Y[x] != 0; x++, z++)
			{
				pointerFileName[z] = Y[x];
				fileName[z] = Y[x];
			}
			for (x = 0; x < 5; x++, z++)
			{
				pointerFileName[z] = Ptr[x];
				fileName[z] = Dta[x];
			}
			hFile = CreateFile (fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				hFile2 = CreateFile(pointerFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				fileSize = GetFileSize(hFile2, NULL);
				ReadFile(hFile2, Pointers, fileSize, &dwBytesRead, NULL);
				CloseHandle (hFile2);
				FirstOffset = Pointers[0];
				NumOfPointers = Pointers[1];
				Pointers[1] = 0;
				for (xLoc = 0, col = colOffset; col < maxCols; xLoc += PixelsPerTile, col++)
				{
					PointerOffset = col - FirstOffset;
					if ((PointerOffset >= 0) && (PointerOffset < NumOfPointers))
					{
						fileSize = Pointers[PointerOffset+2] - Pointers[PointerOffset+1];
						if (fileSize > 1)
						{
							SetFilePointer(hFile, Pointers[PointerOffset+1], NULL, FILE_BEGIN);
							ReadFile(hFile, TileBuf, fileSize, &dwBytesRead, NULL);
							if ((TileBuf[6] == 'J') && (TileBuf[7] == 'F'))
								Convert_TileBuf_hdcMem(NULL, 0xFFFFFFFF);
							else
								BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcBlackMem, 0, 0, SRCCOPY);
						}
						else
							BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
					}
					else
						BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
				}
				CloseHandle (hFile);
			}
			else
				for (xLoc = 0, col = colOffset; col < maxCols; xLoc += PixelsPerTile, col++)
					BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
//			if (lParam != FROMCOMM)
			{
				if (gotelevini)
					GetElevData();
				if (directdraw)
				{//VK_DOWN
					rect1.left = rect.left+xFrame; rect1.top = rect.top+TitleAndMenu+xFrame; rect1.right = rect.right-xFrame; rect1.bottom = rect.bottom-xFrame;
					rect2.left = rect.left+xFrame; rect2.top = rect.top+TitleAndMenu+xFrame; rect2.right = rect.right-xFrame; rect2.bottom = rect.bottom-xFrame;
					GetClientRect(hwnd, &rect);
					rect3.left = rect.left; rect3.top = rect.bottom-PixelsPerTile; rect3.right = rect.right; rect3.bottom = rect.bottom-PixelsPerTile+Spaces2Move;
					rect4.left = rect2.left; rect4.top = rect2.bottom-Spaces2Move; rect4.right = rect2.right; rect4.bottom = rect2.bottom;
					if (DD_OK == lpDDSBack2->GetDC(&hdcBack2))
					{
						if (BitBlt(hdcBack2, 0, 0, MapWidth, MapHeight, hdcMem, 0, 0, SRCCOPY))//the new screen
						{
							if (DD_OK == lpDDSBack2->ReleaseDC(hdcBack2))
							{
								for (x = 0; x < PixelsPerTile; x += Spaces2Move)
								{
									rect1.top += Spaces2Move;
									rect2.bottom -= Spaces2Move;
									rect3.bottom += Spaces2Move;
									rect4.top -= Spaces2Move;
									if (DD_OK == lpDDSPrimary->Blt(&rect2, lpDDSBack, &rect1, DDBLT_WAIT, NULL))
										lpDDSPrimary->Blt(&rect4, lpDDSBack2, &rect3, DDBLT_WAIT, NULL);//the right edge
								}
							}
						}
					}
					if (lpDDSBack2 != NULL) {lpDDSBack2->Release(); lpDDSBack2 = NULL;}
					if (lpDDSBack != NULL) {lpDDSBack->Release(); lpDDSBack = NULL;}
					if (lpDDSPrimary != NULL) {lpDDSPrimary->Release(); lpDDSPrimary = NULL;}
					if (lpDD7 != NULL) {lpDD7->Release(); lpDD7 = NULL;}
					directdraw = FALSE;
				}
//				else//Tiger streets need the following
				{
					InvalidateRect(hwnd, &rect, FALSE);
					UpdateWindow(hwnd);
				}
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar

//				if (autodownload)
//					SendMessage(hwnd, WM_COMMAND, ID_FILE_DOWNLOADMAPDATA_FILLSCREEN, 0);
			}
			cachenotfull = TRUE;
			break;

		case VK_LEFT:
			ResetEvent(hCacheEvent);
//			xbegOld = -1;
			wastopo = FALSE;
			if (distancemeasure)
			{
				xBeg += PixelsPerTile;
//				xbegOld = -1;
			}
			directdraw = FALSE;
			zoom = Zoom;
			if (zoom >= 5)
				zoom -= 5;
			if ((Spaces2Move != 0) && (zoom <= 2) && (0 == (GetKeyState(VK_CONTROL) & 0x80000000)))
				InitDirectDraw();

			{//check for new UTM zone & go there if it is
				int oldUTMZone = UTMZone;
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
				UTMtoLatLon();
				LatRad = Lat * deg2rad;
				LonRad = Lon * deg2rad;
				LatLontoUTM();
				if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))//Left or Right Arrow key
				{//outside range
					sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
					MessageBox(hwnd, Error, "Error 4", MB_OK);
				}
				else if (oldUTMZone > UTMZone)
				{
					ChangeZone(UTMZone, 9);//left or right arrow key
//					MessageBox(hwnd, "New UTM zone", "", MB_OK);
					BeginY = UTMNorthing / MetersPerTile;
					BeginX = UTMEasting / MetersPerTile;
					_itoa(BeginX, X, 10);
					_itoa(BeginY, Y, 10);
					Z[0] = (UTMZone / 10) + '0';
					Z[1] = (UTMZone % 10) + '0';
					Waypoints[0] = 0;
					fromOpen = TRUE;
					SendMessage(hwnd, WM_USER4, 0, 0);
					return 0;
				}		
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
			}
			if ((lParam != FROMCOMM) && (autoLoc) && (fromFlag == NOBUTTON))
			{
				fromFlag = LEFT;
				if (itsgarmin)
				{
					sendingStop = TRUE;
					WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = StopPVTPacket[y];
					if (tgcount > 49900) tgcount = 0;
					return 0;//ACK will call this routine again
				}
				else if (itsusb == FALSE)
				{
					autoLoc = FALSE;
					SetEvent(hEventExit);
				}
				else if (hUSBThread != 0)//if (itsusb)
				{
					SignalUSBStop();
				}
			}
			if (fromFlag != NOBUTTON)
			{
				showposition = FALSE;
				fromFlag = NOBUTTON;
				autoLoc = FALSE;
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				RedDot(hwnd);
			}
			BitBlt(hdcMem, PixelsPerTile, 0, PixelsPerTile*(TilesAcross-1), PixelsPerTile*TilesDown, hdcMem, 0, 0, SRCCOPY);
			colOffset--;
			xLoc = 0;
			yLoc = PixelsPerTile * (TilesDown-1);
			maxRows = TilesDown + rowOffset;
			ZoneName[0] = Z[0];
			ZoneName[1] = Z[1];
			for (row = rowOffset; row < maxRows; row++)
			{
				_itoa(row, Y, 10);
				for (x = 0, z = 18; x < 3; x++, z++)
				{
					fileName[z] = ZoneName[x];
					pointerFileName[z] = ZoneName[x];
				}
				for (x = 0; Y[x] != 0; x++, z++)
				{
					pointerFileName[z] = Y[x];
					fileName[z] = Y[x];
				}
				for (x = 0; x < 5; x++, z++)
				{
					pointerFileName[z] = Ptr[x];
					fileName[z] = Dta[x];
				}
				hFile = CreateFile (fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					hFile2 = CreateFile(pointerFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
					fileSize = GetFileSize(hFile2, NULL);
					ReadFile(hFile2, Pointers, fileSize, &dwBytesRead, NULL);
					CloseHandle(hFile2);
					FirstOffset = Pointers[0];
					NumOfPointers = Pointers[1];
					Pointers[1] = 0;
					PointerOffset = colOffset - FirstOffset;
					if ((PointerOffset >= 0) && (PointerOffset < NumOfPointers))
					{
						fileSize = Pointers[PointerOffset+2] - Pointers[PointerOffset+1];
						if (fileSize > 1)
						{
							SetFilePointer(hFile, Pointers[PointerOffset+1], NULL, FILE_BEGIN);
							ReadFile(hFile, TileBuf, fileSize, &dwBytesRead, NULL);
							if ((TileBuf[6] == 'J') && (TileBuf[7] == 'F'))
								Convert_TileBuf_hdcMem(NULL, 0xFFFFFFFF);
							else
								BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcBlackMem, 0, 0, SRCCOPY);
						}
						else
							BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
					}
					else
						BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
					CloseHandle (hFile);
				}
				else
					BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
				yLoc -= PixelsPerTile;
			}//end of for (row =
//			if (lParam != FROMCOMM)
			{
				if (gotelevini)
					GetElevData();
				if (directdraw)
				{//VK_LEFT
					rect1.left = rect.left+xFrame; rect1.top = rect.top+TitleAndMenu+xFrame; rect1.right = rect.right-xFrame; rect1.bottom = rect.bottom-xFrame;
					rect2.left = rect.left+xFrame; rect2.top = rect.top+TitleAndMenu+xFrame; rect2.right = rect.right-xFrame; rect2.bottom = rect.bottom-xFrame;
					rect3.left = rect.left+PixelsPerTile; rect3.top = rect.top; rect3.right = rect.left+PixelsPerTile+Spaces2Move; rect3.bottom = rect.bottom-TitleAndMenu-(xFrame*2);
					rect4.left = rect2.left; rect4.top = rect2.top; rect4.right = rect2.left+Spaces2Move; rect4.bottom = rect2.bottom;
					if (DD_OK == lpDDSBack2->GetDC(&hdcBack2))
					{
						if (BitBlt(hdcBack2, 0, 0, MapWidth, MapHeight, hdcMem, 0, 0, SRCCOPY))//the new screen
						{
							if (DD_OK == lpDDSBack2->ReleaseDC(hdcBack2))
							{
								for (x = 0; x < PixelsPerTile; x += Spaces2Move)
								{
									rect1.right -= Spaces2Move;
									rect2.left += Spaces2Move;
									rect3.left -= Spaces2Move;
									rect4.right += Spaces2Move;
									if (DD_OK == lpDDSPrimary->Blt(&rect2, lpDDSBack, &rect1, DDBLT_WAIT, NULL))
										lpDDSPrimary->Blt(&rect4, lpDDSBack2, &rect3, DDBLT_WAIT, NULL);//the right edge
								}
							}
						}
					}
					if (lpDDSBack2 != NULL) {lpDDSBack2->Release(); lpDDSBack2 = NULL;}
					if (lpDDSBack != NULL) {lpDDSBack->Release(); lpDDSBack = NULL;}
					if (lpDDSPrimary != NULL) {lpDDSPrimary->Release(); lpDDSPrimary = NULL;}
					if (lpDD7 != NULL) {lpDD7->Release(); lpDD7 = NULL;}
					directdraw = FALSE;
				}
//				else//Tiger streets need the following
				{
					InvalidateRect(hwnd, &rect, FALSE);
					UpdateWindow(hwnd);
				}
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar

//				if (autodownload)
//					SendMessage(hwnd, WM_COMMAND, ID_FILE_DOWNLOADMAPDATA_FILLSCREEN, 0);
			}
			if (cachenotfull)
			{
				cachenotfull = FALSE;
				*pParam = rowOffset;
				hCacheThread = _beginthreadex(NULL, 0, FillCacheThread, pParam, 0, &idThread13);
				for (x = 0; fileName[x] != 0; x++)
					cachName[x] = fileName[x];
				ResetEvent(hCacheOk);
				WaitForSingleObject(hCacheOk, 1000);//wait for it to get started
			}
			SetEvent(hCacheEvent);
			break;

		case VK_RIGHT:
			directdraw = FALSE;
			zoom = Zoom;
			if (zoom >= 5)
				zoom -= 5;
			if ((Spaces2Move != 0) && (zoom <= 2) && (0 == (GetKeyState(VK_CONTROL) & 0x80000000)))
				InitDirectDraw();
			ResetEvent(hCacheEvent);
			wastopo = FALSE;
			if (distancemeasure)
			{
				xBeg -= PixelsPerTile;
//				xbegOld = -1;
			}
			{//check for new UTM zone & go there if it is
				int oldUTMZone = UTMZone;
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
				UTMtoLatLon();
				LatRad = Lat * deg2rad;
				LonRad = Lon * deg2rad;
				LatLontoUTM();
				if (Lon > -60.0)
				{//outside range
					sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
					MessageBox(hwnd, Error, "Error 5", MB_OK);
				}
				else if (oldUTMZone < UTMZone)
				{
					ChangeZone(UTMZone, 9);//left or right arrow key
//					MessageBox(hwnd, "New UTM zone", "", MB_OK);
					BeginY = UTMNorthing / MetersPerTile;
					BeginX = UTMEasting / MetersPerTile;
					_itoa(BeginX, X, 10);
					_itoa(BeginY, Y, 10);
					Z[0] = (UTMZone / 10) + '0';
					Z[1] = (UTMZone % 10) + '0';
					Waypoints[0] = 0;
					fromOpen = TRUE;
					SendMessage(hwnd, WM_USER4, 0, 0);
					return 0;
				}
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
			}
			if ((lParam != FROMCOMM) && (autoLoc) && (fromFlag == NOBUTTON))
			{
				fromFlag = RIGHT;
				if (itsgarmin)
				{
					sendingStop = TRUE;
					WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
					for (y = 0; y < 8; y++, tgcount++)
						ToGPS[tgcount] = StopPVTPacket[y];
					if (tgcount > 49900) tgcount = 0;
					return 0;//ACK will call this routine again
				}
				else if (itsusb == FALSE)
				{
					autoLoc = FALSE;
					SetEvent(hEventExit);
				}
				else if (hUSBThread != 0)//if (itsusb)
				{
					SignalUSBStop();
				}
			}
			if (fromFlag != NOBUTTON)
			{
				showposition = FALSE;
				fromFlag = NOBUTTON;
				autoLoc = FALSE;
				DestroyMenu(hMenu4);
				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
				SetMenu(hwnd, hMenu);
				MenuChecks();
				RedDot(hwnd);
			}
			BitBlt(hdcMem, 0, 0, PixelsPerTile*(TilesAcross-1), PixelsPerTile*TilesDown, hdcMem, PixelsPerTile, 0, SRCCOPY);
			xLoc = PixelsPerTile * (TilesAcross-1);
			yLoc = PixelsPerTile * (TilesDown-1);
			maxRows = TilesDown + rowOffset;
			ZoneName[0] = Z[0];
			ZoneName[1] = Z[1];
			for (row = rowOffset; row < maxRows; row++)
			{
				_itoa(row, Y, 10);
				for (x = 0, z = 18; x < 3; x++, z++)
				{
					fileName[z] = ZoneName[x];
					pointerFileName[z] = ZoneName[x];
				}
				for (x = 0; Y[x] != 0; x++, z++)
				{
					pointerFileName[z] = Y[x];
					fileName[z] = Y[x];
				}
				for (x = 0; x < 5; x++, z++)
				{
					pointerFileName[z] = Ptr[x];
					fileName[z] = Dta[x];
				}
				hFile = CreateFile (fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					hFile2 = CreateFile(pointerFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
					fileSize = GetFileSize(hFile2, NULL);
					ReadFile(hFile2, Pointers, fileSize, &dwBytesRead, NULL);
					CloseHandle(hFile2);
					FirstOffset = Pointers[0];
					NumOfPointers = Pointers[1];
					Pointers[1] = 0;
					PointerOffset = (colOffset+TilesAcross) - FirstOffset;
					if ((PointerOffset >= 0) && (PointerOffset < NumOfPointers))
					{
						fileSize = Pointers[PointerOffset+2] - Pointers[PointerOffset+1];
						if (fileSize > 1)
						{
							SetFilePointer(hFile, Pointers[PointerOffset+1], NULL, FILE_BEGIN);
							ReadFile(hFile, TileBuf, fileSize, &dwBytesRead, NULL);
							CloseHandle(hFile);
							hFile = INVALID_HANDLE_VALUE;
							if ((TileBuf[6] == 'J') && (TileBuf[7] == 'F'))
								Convert_TileBuf_hdcMem(NULL, 0xFFFFFFFF);
							else
								BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcBlackMem, 0, 0, SRCCOPY);
						}
						else
							BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
					}
					else
						BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
					CloseHandle(hFile);
				}
				else
					BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcGrayMem, 0, 0, SRCCOPY);
				yLoc -= PixelsPerTile;
			}
			colOffset++;
//			if (lParam != FROMCOMM)
			{
				if (gotelevini)
					GetElevData();
				if (directdraw)
				{//VK_RIGHT
					rect1.left = rect.left+xFrame; rect1.top = rect.top+TitleAndMenu+xFrame; rect1.right = rect.right-xFrame; rect1.bottom = rect.bottom-xFrame;
					rect2.left = rect.left+xFrame; rect2.top = rect.top+TitleAndMenu+xFrame; rect2.right = rect.right-xFrame; rect2.bottom = rect.bottom-xFrame;
					rect3.left = rect1.right-xFrame-PixelsPerTile-Spaces2Move; rect3.top = rect.top; rect3.right = rect1.right-xFrame-PixelsPerTile; rect3.bottom = rect.bottom-TitleAndMenu-(xFrame*2);
					rect4.left = rect2.right-Spaces2Move; rect4.top = rect2.top; rect4.right = rect2.right; rect4.bottom = rect2.bottom;
					if (DD_OK == lpDDSBack2->GetDC(&hdcBack2))
					{
						if (BitBlt(hdcBack2, 0, 0, MapWidth, MapHeight, hdcMem, 0, 0, SRCCOPY))//the new screen
						{
							if (DD_OK == lpDDSBack2->ReleaseDC(hdcBack2))
							{
								for (x = 0; x < PixelsPerTile; x += Spaces2Move)
								{
									rect1.left += Spaces2Move;
									rect2.right -= Spaces2Move;
									rect3.right += Spaces2Move;
									rect4.left -= Spaces2Move;
									if (DD_OK == lpDDSPrimary->Blt(&rect2, lpDDSBack, &rect1, DDBLT_WAIT, NULL))
										lpDDSPrimary->Blt(&rect4, lpDDSBack2, &rect3, DDBLT_WAIT, NULL);//the right edge
								}
							}
						}
					}
					if (lpDDSBack2 != NULL) {lpDDSBack2->Release(); lpDDSBack2 = NULL;}
					if (lpDDSBack != NULL) {lpDDSBack->Release(); lpDDSBack = NULL;}
					if (lpDDSPrimary != NULL) {lpDDSPrimary->Release(); lpDDSPrimary = NULL;}
					if (lpDD7 != NULL) {lpDD7->Release(); lpDD7 = NULL;}
					directdraw = FALSE;
				}
//				else//Tiger streets need the following
				{
					InvalidateRect(hwnd, &rect, FALSE);
					UpdateWindow(hwnd);
				}
				SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar

//				if (autodownload)
//					SendMessage(hwnd, WM_COMMAND, ID_FILE_DOWNLOADMAPDATA_FILLSCREEN, 0);
			}
			if (cachenotfull)
			{
				cachenotfull = FALSE;
				*pParam = rowOffset;
				hCacheThread = _beginthreadex(NULL, 0, FillCacheThread, pParam, 0, &idThread13);
				for (x = 0; fileName[x] != 0; x++)
					cachName[x] = fileName[x];
				ResetEvent(hCacheOk);
				WaitForSingleObject(hCacheOk, 1000);
			}
			SetEvent(hCacheEvent);
			break;

		case VK_SPACE:
			if (GetKeyState(VK_CONTROL) < 0)
				simulate = TRUE;			
			if (fromposition == TRUE)
				break;//can't show position if viewing old position data
			if (autoLoc == FALSE)
				autoLoc = TRUE;
			else if (fromFlag == NOBUTTON)
			{//mark waypoint at last position
				makewaypoint = TRUE;
				break;//already showing position
			}
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			showposition = nomessages = TRUE;
			makewaypoint = FALSE;

			fromFlag = NOBUTTON;
			if (itsusb)
			{
				if (hUSBThread == 0)
				{
					FromUSBBuf = (BYTE*)VirtualAlloc(NULL, 1000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					*pParam = STARTPVT;
					hUSBThread = _beginthreadex(NULL, 0, USBThread, pParam, 0, &idThread4);
				}
				else
				{
					MessageBox(hwnd, "USB Thread is still running...", NULL, MB_OK);
					break;
				}
			}

			else
			{
				if (simulate == FALSE)
				{
					if (RegValue[3] == '0')
					{
						MessageBox(hwnd, SelectCommPort, NULL, MB_OK);
						break;
					}
					GetCommHandle();
					if (hComm == INVALID_HANDLE_VALUE)
					{
//						MessageBox(hwnd, BadCommPort, NULL, MB_OK);
						break;
					}
				}
				ResetEvent(hEventExit);
				hThread = _beginthreadex(NULL, 0, CommThread, NULL, 0, &idThread);
				Sleep(500);
				if (itsgarmin)
				{
					GarminFlag = GOT_ETX;
					TimerFlags.garmintiming = TRUE;
					TimerFlags.timing = TRUE;
					TimerFlags.gotprotocol = FALSE;
					TimerFlags.time = 2000;
					ResetEvent(hTimerEvent);
					_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
					garminflag = STARTPVT;
					tgcount = 0;
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = Pid_Product_Rqst[x];
					if (tgcount > 49900) tgcount = 0;
					WriteFile(hComm, &Pid_Product_Rqst, 8, &dwBytesWritten, NULL);
				}
				else//NMEA
				{
					newposition = FALSE;
					iLatLon = -1;
					LineType = 0;
					commas = 0xFF;
					TimerFlags.nmeatiming = TRUE;
					TimerFlags.gotprotocol = TRUE;
					TimerFlags.time = 7000;
					ResetEvent(hTimerEvent);
					_beginthreadex(NULL, 0, TimerThread, &TimerFlags, 0, &idThread3);
					suspendedthread = FALSE;
				}
			}//end of else

			if ((PositionCsv[8] == '?') && (PositionCsv[9] == '?'))
			{
				hFile = FindFirstFile(PositionCsv, &fd);
				PositionCsv[8] = '0';
				PositionCsv[9] = '1';
				if (hFile != INVALID_HANDLE_VALUE)
				{
					while (TRUE)
					{
						FindClose(hFile);
						hFile = FindFirstFile(PositionCsv, &fd);
						if (hFile == INVALID_HANDLE_VALUE)
							break;
						PositionCsv[9]++;
						if (PositionCsv[9] > '9')
						{
							if (PositionCsv[8] != '9')
							{
								PositionCsv[9] = '0';
								PositionCsv[8]++;
							}
							else
							{
								PositionCsv[8] = 'Z';
								PositionCsv[9] = 'Z';
								MessageBox(hwnd, "This data will be put in PositionZZ.csv.\n\nYou need to do some file housekeeping...", "There are 99 Position??.csv files!", MB_OK);
								break;
							}
						}
					}
				}
			}
			DestroyMenu(hMenu);
			hMenu4 = LoadMenu(hInst, "STOPPOSITIONING");
			SetMenu(hwnd, hMenu4);
			UTMEasting = 0;//flag
		}
		return 0;


	case WM_PAINT:
		if ((usamap) || (showjpeg))
			break;
		if (FALSE == fillscreen)
			break;
		gotstreet = FALSE;
		if ((!approachcontrol) && (hdcMem3 != NULL))
		{
			SelectObject(hdc, hObject);
			DeleteDC(hdcMem3);
			DeleteObject(hBitmap3);
			hdcMem3 = NULL;
		}
		GetClientRect(hwnd, &rect);
		//*************************
		hdc = BeginPaint(hwnd, &ps);
		BitBlt(hdc, 0, 0, MapWidth, MapHeight, hdcMem, 0, 0, SRCCOPY);
		ScreenLeft = colOffset*MetersPerTile;
		ScreenRight	= ScreenLeft + (TilesAcross*MetersPerTile);
		ScreenBottom = rowOffset*MetersPerTile;
		ScreenTop = ScreenBottom + (TilesDown*MetersPerTile);
		//*************************
		if (approachcontrol)
		{
			MetersPerPixel = MetersPerTile/PixelsPerTile;
			d = dThirtyMiles / (double)MetersPerPixel;
			__asm fld d // round a double up or down
			__asm fistp ThirtyMiles // to an integer
			CircleX = (AirportUTMEasting - ScreenLeft) / MetersPerPixel;
			CircleY = (ScreenTop - AirportUTMNorthing) / MetersPerPixel;
			hWhitePen = CreatePen(PS_SOLID, 1, 0xFFFFFF);
			hBlackPen = CreatePen(PS_SOLID, 1, 0);
			hObject = SelectObject(hdc, hWhitePen);
			hBlankBrush = (HBRUSH)GetStockObject(NULL_BRUSH);
			hOldBrush = SelectObject(hdc, hBlankBrush);
			Ellipse(hdc, CircleX - ThirtyMiles, CircleY - ThirtyMiles, CircleX + ThirtyMiles, CircleY + ThirtyMiles);
			SelectObject(hdc, hOldBrush);
			DeleteObject(hBlankBrush);
			if (dCenterline != 370.0)
			{
				hWaypointBrush = CreateSolidBrush(WaypointColor);
				hOldBrush = SelectObject(hdc, hWaypointBrush);
				GetDotRadius(); // for glide slope temp waypoint
				for (z = 0; z < lines; z++)
				{
					SelectObject(hdc, hWhitePen);
					x = (Line[z].UTME1 - ScreenLeft) / MetersPerPixel;
					y = (ScreenTop - Line[z].UTMN1) / MetersPerPixel;
					MoveToEx(hdc, x, y, NULL);
					x = (Line[z].UTME2 - ScreenLeft) / MetersPerPixel;
					y = (ScreenTop - Line[z].UTMN2) / MetersPerPixel;
					LineTo(hdc, x, y);
					if (Line[z].GSE)
					{
						SelectObject(hdc, hBlackPen);
						x = (Line[z].GSE - ScreenLeft) / MetersPerPixel;
						y = (ScreenTop - Line[z].GSN) / MetersPerPixel;
						Ellipse(hdc, x-DotRadius, y-DotRadius, x+DotRadius, y+DotRadius);
						_itoa(Line[z].GSInterceptAlt, tempPlane, 10);
						w = lstrlen(tempPlane);
						tempPlane[w] = '\'';
						w++;
						SetBkMode(hdc, TRANSPARENT);
						SetTextColor(hdc, 0xFFFFFF);
						TextOut(hdc, x, y, tempPlane, w);
						SetBkMode(hdc, OPAQUE);
						SetTextColor(hdc, 0);
					}
				}
				SelectObject(hdc, hOldBrush);
				DeleteObject(hWaypointBrush);
			}
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
		}

		if (brandnew)
		{
			brandnew = FALSE;
			SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_F1, 0);
//			MessageBox(hwnd, "Press F (a shortcut key) to fill the screen\nwith aerial photos from msrmaps.com\n(it won't work if you have a firewall)\n\nThen read Help -Using!", "First-time (only) message", MB_OK);
		}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		if ((showstreets) && (pTigerIndex != NULL))
		{
			int x1, y1;

//			if (MapType == TOPO)
//				TigerColor = 0xFF;
//			else
//				TigerColor = 0x80FF;

			SetCursor(hWaitingCursor);
			for (x = 0; x < pts; x++)
			{
				if (pTiger != NULL)
				{
					free(pTiger[x]);
					pTiger[x] = NULL;
				}
			}
			for (x = 0; x < pname; x++)
			{
				if (pTigerNames != NULL)
				{
					free(pTigerNames[x]);
					pTigerNames[x] = NULL;
					TigerNameSize[x] = 0;
				}
			}
			pts = pname = 0;
			TigerSize = namesize = 0;
			for (y = 0; y < MAXPTIGERS; y++)
			{
				for (x = 0; x < MAXNAMEPTRS; x++)
					NamePtrs[y][x] = -1;
			}
			for (Bigx = 0; Bigx < (int)IndexSize; Bigx += 21)
			{
				West = Bigx+5;
				North = Bigx+9;
				East = Bigx+13;
				South = Bigx+17;
				gotit = 0;
				if ((((*(int*)&pTigerIndex[West] < ScreenRight) && (*(int*)&pTigerIndex[West] > ScreenLeft))
				 || ((*(int*)&pTigerIndex[East] < ScreenRight) && (*(int*)&pTigerIndex[East] > ScreenLeft)))
				 && (((*(int*)&pTigerIndex[North] < ScreenTop) && (*(int*)&pTigerIndex[North] > ScreenBottom))
				 || ((*(int*)&pTigerIndex[South] < ScreenTop) && (*(int*)&pTigerIndex[South] > ScreenBottom))))
				gotit = 1;
				else if ((((*(int*)&pTigerIndex[West] < ScreenLeft) && (*(int*)&pTigerIndex[East] > ScreenLeft))
				 || ((*(int*)&pTigerIndex[West] < ScreenRight) && (*(int*)&pTigerIndex[East] > ScreenRight)))
				 && (((*(int*)&pTigerIndex[North] < ScreenTop) && (*(int*)&pTigerIndex[South] > ScreenBottom))))
				gotit = 2;
				else if ((((*(int*)&pTigerIndex[North] > ScreenBottom) && (*(int*)&pTigerIndex[North] < ScreenTop))
				 || ((*(int*)&pTigerIndex[South] > ScreenBottom) && (*(int*)&pTigerIndex[South] < ScreenTop)))
				 && (((*(int*)&pTigerIndex[West] > ScreenLeft) && (*(int*)&pTigerIndex[East] < ScreenRight))))
				gotit = 3;
				else if ((((*(int*)&pTigerIndex[North] > ScreenBottom) && (*(int*)&pTigerIndex[North] < ScreenTop))
				 || ((*(int*)&pTigerIndex[South] > ScreenBottom) && (*(int*)&pTigerIndex[South] < ScreenTop)))
				 && (((*(int*)&pTigerIndex[West] < ScreenLeft) && (*(int*)&pTigerIndex[East] > ScreenRight))))
				gotit = 4;
				else if ((((*(int*)&pTigerIndex[West] > ScreenLeft) && (*(int*)&pTigerIndex[West] < ScreenRight))
				 || ((*(int*)&pTigerIndex[East] > ScreenLeft) && (*(int*)&pTigerIndex[East] < ScreenRight)))
				 && (((*(int*)&pTigerIndex[North] > ScreenTop) && (*(int*)&pTigerIndex[South] < ScreenBottom))))
				gotit = 5;
				else if ((*(int*)&pTigerIndex[West] < ScreenLeft) && (*(int*)&pTigerIndex[East] > ScreenRight)
				 && (*(int*)&pTigerIndex[North] > ScreenTop) && (*(int*)&pTigerIndex[South] < ScreenBottom))
				gotit = 6;
				if (gotit)
				{//if part of the file is on-screen
					for (y = 13, z = Bigx; z < Bigx+5; y++, z++)
					{
						TigerDta[y] = pTigerIndex[z];
						TigerName[y] = pTigerIndex[z];
					}
					TigerDta[19] = Z[0];
					TigerDta[20] = Z[1];
					TigerName[19] = Z[0];
					TigerName[20] = Z[1];
					TigerSize = 0;
					hFile = CreateFile(TigerDta, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile != INVALID_HANDLE_VALUE)
					{
						if (TigerSize = GetFileSize(hFile, NULL))
						{
							pTiger[pts] = (int*)malloc(TigerSize);
							ReadFile(hFile, pTiger[pts], TigerSize, &dwBytesRead, NULL);
							TigerSize /= 4;//because it's an integer array
						}
						CloseHandle(hFile);
					}
					hNameFile = CreateFile(TigerName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (hNameFile != INVALID_HANDLE_VALUE)
					{
						if (TigerNameSize[pname] = GetFileSize(hNameFile, NULL))
						{
							pTigerNames[pname] = (char*)malloc(TigerNameSize[pname]);
							ReadFile(hNameFile, pTigerNames[pname], TigerNameSize[pname], &dwBytesRead, NULL);
						}
						CloseHandle(hNameFile);
					}

					if (TigerSize)
					{
						point = NumofPolys = RowBegin = 0;

						for (x = 0; x < (int)TigerSize; x++)
						{//big loop
							showit = FALSE;
							if (HighestFeatureType >= ((pTiger[pts][RowBegin] >> 20) & 0x00000FFF))
							{
								showit = TRUE;
								TigerPointE = pTiger[pts][x] & 0x000FFFFF;
								pt[point].x = (TigerPointE - ScreenLeft) * PixelsPerTile / MetersPerTile;
							}
							x++;
							TigerPointN = pTiger[pts][x];
							if (TigerPointN & 0x80000000)
							{//if hi-bit set
								TigerPointN &= 0x7FFFFFFF;//clear it
								if (showit)
								{
									PolyPtrs[NumofPolys] = (x+1-RowBegin)/2;
									NumofPolys++;
								}
								RowBegin = x+1;
							}
							if (showit)
							{
								pt[point].y = (ScreenTop - TigerPointN) * PixelsPerTile / MetersPerTile;
//show every point
//								x1 = pt[point].x;
//								y1 = pt[point].y;
//								Ellipse(hdc, x1-3, y1-3, x1+3, y1+3);
//
								point++;
							}
						}//end of for (x = 0;

						if (point >= TIGERS)
						{
							MessageBox(hwnd, "point >= TIGERS", ERROR, MB_OK);
							break;
						}
						hPen = CreatePen(PS_SOLID, 1, TigerColor);
						hObject = SelectObject(hdc, hPen);
						////////////
						PolyPolyline(hdc, pt, PolyPtrs, NumofPolys);
						////////////
						SelectObject(hdc, hObject);
						DeleteObject(hPen);

						if (((MapType == PHOTO) && (Zoom <= 3)) || ((MapType == URBANAREA) && (Zoom <= 5)) || ((MapType == TOPO) && (Zoom == 1)))
						{
							np = 0;
							for (x = 0; x < (int)TigerNameSize[pname]; x++)
							{
								//if (((pTigerNames[pname][x] == 'A') && (pTigerNames[pname][x+1] <= '3')) || ((pTigerNames[pname][x+1] == '4') && (pTigerNames[pname][x+2] == '1')))//feature type (roads only)
								if (((pTigerNames[pname][x] == 'A') || (pTigerNames[pname][x] == 'P'))
								 && (((HighestFeatureType == 19) && (pTigerNames[pname][x+1] == '1'))
								 || ((HighestFeatureType == 39) && (pTigerNames[pname][x+1] <= '3'))
								 || ((HighestFeatureType == 49) && (pTigerNames[pname][x+1] <= '4'))
								 || ((HighestFeatureType == 59) && (pTigerNames[pname][x+1] <= '5'))
								 || ((HighestFeatureType == 0xFF) && (pTigerNames[pname][x+1] <= '9'))))
								{
									x += 3;
									TigerPointE = *(int*)&pTigerNames[pname][x];
									x += 4;
									TigerPointN = *(int*)&pTigerNames[pname][x];
									x += 4;//pointing to angle
									if ((TigerPointE > ScreenLeft) && (TigerPointE < ScreenRight)
										&& (TigerPointN < ScreenTop) && (TigerPointN > ScreenBottom))
									{
										x1 = (TigerPointE - ScreenLeft) * PixelsPerTile / MetersPerTile;
										y1 = (ScreenTop - TigerPointN) * PixelsPerTile / MetersPerTile;
										NamePtrs[pname][np++] = x1;
										NamePtrs[pname][np++] = y1;
										NamePtrs[pname][np++] = x;
										if (np >= MAXNAMEPTRS)
										{
											char asdf[10];
											_itoa(np, asdf, 10);
											MessageBox(hwnd, asdf, "np equals", MB_OK);
											break;
										}
										Ellipse(hdc, x1-3, y1-3, x1+3, y1+3);
										for (x += 4; (pTigerNames[pname][x] != 0) && (x < (int)TigerNameSize[pname]); x++)
											;
									}
									else
										for (x += 4; (pTigerNames[pname][x] != 0) && (x < (int)TigerNameSize[pname]); x++)
											;
								}
								else
									for (x += 15; (pTigerNames[pname][x] != 0) && (x < (int)TigerNameSize[pname]); x++)
										;
							}//end of for (x = 0;
						}//end of if (((MapType ==
					}//end of if (TigerSize)
					pts++;
					if (pts >= MAXPTIGERS)
					{
						MessageBox(hwnd, "pts >= MAXPTIGERS", ERROR, MB_OK);
						break;
					}
					pname++;
					if (pname >= MAXPTIGERS)
					{
						MessageBox(hwnd, "pname >= MAXPTIGERS", ERROR, MB_OK);
						break;
					}
				}//end of if (gotit)
			}//end of for (Bigx = 0;

//if (gotpoint == FALSE)
//{
//	gotpoint = TRUE;
//	sprintf(Error, "pt array size: %i", point);
//	MessageBox(hwnd, Error, "", MB_OK);
//}

			if ((StreetName[0] != 0) && (!show))
			{
				for (y = 0; y < pname; y++)
				{//show instances of StreetName
					for (x = 15; x < (int)TigerNameSize[y]; )
					{
						for (z = x; pTigerNames[y][z] != 0; z++)
						{
							if ((pTigerNames[y][z] & 0xDF) == StreetName[0])
							{
								for (w = 0; (StreetName[w] != 0); w++, z++)
								{
									ch = pTigerNames[y][z];
									if (ch != ' ')
										ch &= 0xDF;
									if (ch != StreetName[w])
										break;
								}
								if (StreetName[w] == 0)
								{
									DotX = (*(int*)&pTigerNames[y][x-12] - ScreenLeft) * PixelsPerTile / MetersPerTile;
									DotY = (ScreenTop - *(int*)&pTigerNames[y][x-8]) * PixelsPerTile / MetersPerTile;
									TigerPointA = *(int*)&pTigerNames[y][x-4];//Angle
									if (TigerPointA & 0x80000000)
									{
										TigerPointA &= 0x7FFFFFFF;
										streetflag = TRUE;
									}
									lf4.lfEscapement = lf4.lfOrientation = TigerPointA;
									hFont = CreateFontIndirect (&lf4);
									hObject = SelectObject (hdc, hFont);
									if (MapType != TOPO)
									{
										SetBkMode(hdc, TRANSPARENT);
										SetTextColor(hdc, TextColor);
									}
									if (streetflag)
										SetTextAlign(hdc, TA_RIGHT|TA_BASELINE);
									else
										SetTextAlign(hdc, TA_LEFT|TA_BASELINE);
									for (z = x; pTigerNames[y][z] != 0; z++);
										;
									TextOut(hdc, DotX, DotY, &pTigerNames[y][x], z-x);
									SelectObject(hdc, hObject);
									DeleteObject(hFont);
								}
							}
						}
						for ( ; pTigerNames[y][x] != 0; x++)
							;//go to end of name
						x += 16;//to next name
					}
				}
			}
			if (first)
			{//weird but necessary
				first = FALSE;
				show = TRUE;
				for (x = 0; x < 50; x++)
					StreetName[x] = 0;
				hwndStreet = CreateWindow("STATIC", NULL,
					WS_CHILD | WS_VISIBLE | WS_THICKFRAME,
					0, 0, 320, 35,
					hwnd, (HMENU)188, hInst, NULL);
				pStreetProc = (WNDPROC)SetWindowLong(hwndStreet, GWL_WNDPROC, (LONG)StreetProc);
				hwndShowButton = CreateWindow("BUTTON", "Display a Street Name",
					WS_CHILD | WS_VISIBLE,
					5, 3, 150, 21,
					hwndStreet, (HMENU)192, hInst, NULL);
				hdcShowButton = GetDC(hwndShowButton);
				hFont = CreateFontIndirect (&lf2);
				SelectObject(hdcShowButton, hFont);
				ReleaseDC(hwndShowButton, hdcShowButton);
				SendMessage(hwndShowButton, WM_SETFONT, (UINT)hFont, TRUE);
				hwndStreetEdit = CreateWindow("EDIT", NULL,
					WS_CHILD | WS_VISIBLE | WS_BORDER,
					160, 5, 150, 18,
					hwndStreet, (HMENU)193, hInst, NULL);
				pStreetEditProc = (WNDPROC)SetWindowLong(hwndStreetEdit, GWL_WNDPROC, (LONG)StreetEditProc);
				SendMessage(hwndStreetEdit, EM_LIMITTEXT, (WPARAM)49, 0);
				hdcStreetEdit = GetDC(hwndStreetEdit);
				hFont = CreateFontIndirect (&lf2);
				SelectObject(hdcStreetEdit, hFont);
				ReleaseDC(hwndStreetEdit, hdcStreetEdit);
				SendMessage(hwndStreetEdit, WM_SETFONT, (UINT)hFont, TRUE);
			}
			SetCursor(hCursor);
		}//end of if (showstreets)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		if (itsx)
		{
			hPen = CreatePen(PS_SOLID, 2, 0x80FF);
			hObject = SelectObject(hdc, hPen);
			MoveToEx(hdc, xPos-5, yPos-5, NULL);
			LineTo(hdc, xPos+5, yPos+5);
			MoveToEx(hdc, xPos-5, yPos+5, NULL);
			LineTo(hdc, xPos+5, yPos-5);
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
		}

		if (missing1meter)
		{
			int x = 0;
			RECT rectXY;
			HBRUSH hGreyBrush;

			missing1meter = FALSE;
			rectXY.top = 0;
			rectXY.bottom = rectXY.top + OneMeterTileSize;
			hGreyBrush = CreateSolidBrush(LIGHTGRAY);
			hObject = SelectObject(hdc, hGreyBrush);
			for (w = 0; w < OneMeterTilesDown; w++)
			{
				rectXY.left = 0;
				rectXY.right = rectXY.left + OneMeterTileSize;
				for (v = 0; v < OneMeterTilesAcross; v++)
				{
					if (p1Meter[(w*OneMeterTilesAcross)+v] == 1)
						FillRect(hdc, &rectXY, hGreyBrush);
					rectXY.left = p1MeterX[v];
					rectXY.right = rectXY.left + OneMeterTileSize;//OneMeterTileSize = PixelsPerTile / 8;
				}
				rectXY.top = p1MeterY[w];
				rectXY.bottom = rectXY.top + OneMeterTileSize;
			}
			SelectObject(hdc, hObject);
			DeleteObject(hGreyBrush);
			free(p1MeterX);
			free(p1MeterY);
			free(p1Meter);
			SetCursor(hCursor);
			SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
		}

		if (grid75)
		{
			GridSeventyFive();
			hPen = CreatePen(PS_SOLID, 1, 0x80FF);
			hObject = SelectObject(hdc, hPen);
			hBrush = CreateSolidBrush(0x80FF);
			hObject2 = SelectObject(hdc, hBrush);
			for (y = 0; HorizPoint[y+1][0] != 0; y++)
			{
				for (x = 0; VertPoint[y][x+1] != 0; x++)
				{
					DotX = VertPoint[y][x];
					DotY = HorizPoint[y][x];
					Ellipse(hdc, DotX-3, DotY-3, DotX+3, DotY+3);
					MoveToEx(hdc, VertPoint[y][x], HorizPoint[y][x], NULL);
					LineTo(hdc, VertPoint[y][x+1], HorizPoint[y][x+1]);
				}
			}
			SelectObject(hdc, hObject2);
			DeleteObject(hBrush);
			for (y = 0; HorizPoint[y+1][0] != 0; y++)
			{
				for (x = 0; VertPoint[y][x+1] != 0; x++)
				{
					MoveToEx(hdc, VertPoint[y][x], HorizPoint[y][x], NULL);
					LineTo(hdc, VertPoint[y+1][x], HorizPoint[y+1][x]);
				}
			}
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
		}

		if (((gridon) && ((MapType == TOPO) || (MapType == PHOTO) || (MapType == URBANAREA) && Zoom > 1)))
		{
			int first;
			
			if (MapType == TOPO)
			{
				color = 0;
				x = 2;
			}
			else
			{
				color = YELLOW;
				x = 1;
			}
			hPen = CreatePen(PS_SOLID, x, color);
			hObject = SelectObject(hdc, hPen);
			first = ((MetersPerTile*250/PixelsPerTile) - (ScreenLeft % (MetersPerTile*250/PixelsPerTile))) * PixelsPerTile / MetersPerTile;
			for (x = first; x < rect.right; x += 250)
			{
				MoveToEx(hdc, x, 0, NULL);
				LineTo(hdc, x, rect.bottom);
				z = ScreenLeft + (x * MetersPerTile / PixelsPerTile);
				_itoa(z, tempBuf, 10);
				TextOut(hdc, x-30, 0, tempBuf, 6);
			}
			first = (ScreenTop % (MetersPerTile*250/PixelsPerTile)) * PixelsPerTile / MetersPerTile;
			for (x = first; x < rect.bottom; x += 250)
			{
				MoveToEx(hdc, 0, x, NULL);
				LineTo(hdc, rect.right, x);
				z = ScreenTop - (x * MetersPerTile / PixelsPerTile);
				_itoa(z, tempBuf, 10);
				TextOut(hdc, 0, x-10, tempBuf, 7);
			}
			for (x = 25; x < rect.bottom; x += 25)
			{
				MoveToEx(hdc, 0, x, NULL);
				LineTo(hdc, 10, x);
			}
			for (x = 25; x < rect.bottom; x += 25)
			{
				MoveToEx(hdc, rect.right, x, NULL);
				LineTo(hdc, rect.right-10 , x);
			}

			for (x = 25; x < rect.right; x += 25)
			{
				MoveToEx(hdc, x, 0, NULL);
				LineTo(hdc, x, 10);
			}
			for (x = 25; x < rect.right; x += 25)
			{
				MoveToEx(hdc, x, rect.bottom, NULL);
				LineTo(hdc, x, rect.bottom-10);
			}
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
		}

		if (getarea)//TOPO at Zoom >= 64
		{
			int radius;

			hStartBrush = CreateSolidBrush(RED);
			hObject = SelectObject(hdc, hStartBrush);
			hPen = CreatePen(PS_NULL, 1, 0);
			hObject2 = SelectObject(hdc, hPen);
			z = PixelsPerTile/8;//200 PixelsPerTile at Zoom = 64 for TOPO
			radius = 8 - Zoom;
			for (x = z; x < rect.right; x += z)
			{
				for (y = z; y < rect.bottom; y += z)
					Ellipse(hdc, x-radius, y-radius, x+radius, y+radius);
			}	
			SelectObject(hdc, hObject2);
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
			DeleteObject(hStartBrush);
		}

		if (showElev)
		{
			if (((MapType == PHOTO) && (MetersPerTile/PixelsPerTile) <= 32) || ((MapType == URBANAREA) && (Zoom >= 3)))
			{
				if (lowest == 0x8002)
					lowest = highest;
				color = 0x80C000;
				diff = (20 * MetersPerTile) / PixelsPerTile;//elevation in feet between contour lines
				x = (highest - lowest) / diff;
				if (x == 0)
					x = 1;
				colorDiff = 0xFF / x;
				for (contour = ((lowest / diff) * diff) + diff; contour < highest; contour += diff, color += colorDiff)
				{
					for (x = 0; x < 2560; x++)
						New[x] = 1;//initialize to TRUE
					hPen = CreatePen(PS_SOLID, 2, color);
					hObject = SelectObject(hdc, hPen);
					for (yCon = 0; yCon < yConMax; yCon++)
					{
						for (xCon = 0; xCon < xConMax; xCon++)
						{
//							Xcon[0] = (xCon / 10)+'0';
//							Xcon[1] = (xCon % 10)+'0';
//							TextOut(hdc, col+(xCon*30), row+(yCon*30), Xcon, 2);
							z = (yCon<<6)+xCon;
							if (New[z])//it's made FALSE in PrepBox
							{
								tl = ScreenElev[z];
								tr = ScreenElev[z+1];
								bl = ScreenElev[z+64];
								br = ScreenElev[z+65];
								if ((tl != 0x8002) && (tr != 0x8002) && (bl != 0x8002) && (br != 0x8002))
								{
									if (((tl <= contour) && (bl >= contour))
									 || ((tl >= contour) && (bl <= contour))
									 || ((tl <= contour) && (tr >= contour))
									 || ((tl >= contour) && (tr <= contour))
									 || ((tr <= contour) && (br >= contour))
									 || ((tr >= contour) && (br <= contour)))
									{
										GetContour();
									}
								}
							}
						}
					}
					SelectObject(hdc, hObject);
					DeleteObject(hPen);
				}
			}
		}

		if (distancemeasure)
		{
			xbeg = xBeg;
			ybeg = yBeg;
			ShowDistanceAngle();
		}

		if (showingroute)//if (drawing)
		{
			int x1, x2, y1, y2;
			x = Zoom;
			if (MapType == TOPO)
			{
				x += 8;
//				color = YELLOW;
			}
//			else
				color = RouteColor;
			hRoutePen = CreatePen(PS_SOLID, ZoomTable[x], color);
			hObject = SelectObject(hdc, hRoutePen);
			if (drawing)
			{
				numofRoutes = ptr;
				if (ptr != 0)
				{
					char RteNum[10];

					DotX = (pRoute[ptr-1].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
					DotY = (ScreenTop - pRoute[ptr-1].NUTM) * PixelsPerTile / MetersPerTile;
					MoveToEx(hdc, DotX, DotY, NULL);
					LineTo(hdc, xPos, yPos);

					_itoa(RoutePoint, RteNum, 10);
					SetBkMode(hdc, TRANSPARENT);
					SetTextColor(hdc, 0xFFFFFF);
					TextOut(hdc, 0, 0, RteNum, strlen(RteNum));
					SetBkMode(hdc, OPAQUE);
					SetTextColor(hdc, 0);

					xbeg = DotX;
					ybeg = DotY;
					ShowDistanceAngle();
				}
			}
			for (x = 0; x < (numofRoutes-1); x++)
			{
				if (pRoute[x].UTMZone == pRoute[x+1].UTMZone)
				{
					x1 = (pRoute[x].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
					y1 = (ScreenTop - pRoute[x].NUTM) * PixelsPerTile / MetersPerTile;
					MoveToEx(hdc, x1, y1, NULL);
					x2 = (pRoute[x+1].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
					y2 = (ScreenTop - pRoute[x+1].NUTM) * PixelsPerTile / MetersPerTile;
					LineTo(hdc, x2, y2);
				}
			}
			SelectObject(hdc, hObject);
			DeleteObject(hRoutePen);
		}

		hWaypointBrush = CreateSolidBrush(WaypointColor);
		hObject = SelectObject(hdc, hWaypointBrush);
		itsnetstumbler = FALSE;

		if (Northest)
		{
			for (y = 0; y < (int)bilrows; y++)
			{
				for (x = 0; x < (int)bilcols; x++)
				{
					DotX = (UTMEbilBuf[y][x] - ScreenLeft) * PixelsPerTile / MetersPerTile;
					DotY = (ScreenTop - UTMNbilBuf[y][x]) * PixelsPerTile / MetersPerTile;
					Ellipse(hdc, DotX-2, DotY-2, DotX+2, DotY+2);
//					d = (double)bilBuf[x + (y*451)] / 0.3048;
//					z = (int)d;
//					asdf[0] = (z / 1000) + '0';
//					asdf[1] = ((z % 1000) / 100) + '0';
//					asdf[2] = ((z % 100) / 10) + '0';
//					asdf[3] = (z % 10) + '0';
//					TextOut(hdc, DotX+3, DotY, asdf, 4);
				}
			}
/*
			for (y = ScreenTop-Northest; y < (ScreenTop-Southest); y += 30)
			{
				if (0 == (y & 0x80000000))
				{//not negative (high bit is 0)
					for (x = Eastest-ScreenLeft; x < (Westest-ScreenLeft); x += 30)
					{
						DotX = x * PixelsPerTile / MetersPerTile;
						DotY = y * PixelsPerTile / MetersPerTile;
						hRedBrush = CreateSolidBrush(RED);
						hObject = SelectObject(hdc, hRedBrush);
						Ellipse(hdc, DotX-2, DotY-2, DotX+2, DotY+2);
						SelectObject(hdc, hObject);
						DeleteObject(hRedBrush);
					}
				}
			}
*/
			SendMessage(hwnd, WM_KEYDOWN, VK_ESCAPE, 0);
			return 0;
		}

		for (x = 0; NewLoc[x].EUTM != 0; x++)
		{//waypoints
			if ((UTMZone == NewLoc[x].UTMZone) && (NewLoc[x].EUTM > ScreenLeft) && (NewLoc[x].EUTM < ScreenRight)
				&& (NewLoc[x].NUTM < ScreenTop) && (NewLoc[x].NUTM > ScreenBottom))
			{
				if ((NewLoc[x].Location != NULL) && (NewLoc[x].Location[0] == '0') && (NewLoc[x].Location[1] == '0') && (NewLoc[x].Location[12] == ' '))
				{//if NetStumbler data
					for (y = 0; NewLoc[x].Location[y] != '<'; y++)
					{
						if ((y == 12) && (NewLoc[x].Location[y] != ' '))
							break;
						if ((y > 12) && (NewLoc[x].Location[y-2] == 'w') && (NewLoc[x].Location[y-1] == 'e') && (NewLoc[x].Location[y] == 'p'))
						{
							itsnetstumbler = TRUE;
							SelectObject(hdc, hObject);
							DeleteObject(hWaypointBrush);
							hWaypointBrush = CreateSolidBrush(0xFF);
							hObject = SelectObject(hdc, hWaypointBrush);
						}
					}
				}
				DotX = (NewLoc[x].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
				DotY = (ScreenTop - NewLoc[x].NUTM) * PixelsPerTile / MetersPerTile;
				Ellipse(hdc, DotX-DotRadius, DotY-DotRadius, DotX+DotRadius, DotY+DotRadius);

				if (itsnetstumbler)
				{
					SelectObject(hdc, hObject);
					DeleteObject(hWaypointBrush);
					hWaypointBrush = CreateSolidBrush(WaypointColor);
					hObject = SelectObject(hdc, hWaypointBrush);
				}
				if ((shownamecomment) && ((MapType == PHOTO) || (MapType == URBANAREA) || (Zoom < 5)))
				{
					char wp[50];

					for (y = 0; y < NewLoc[x].size; y++)
					{//<name> <cmt> <desc>
						if (((sortbyname == TRUE)
						 && (NewLoc[x].pWaypoints[y] == 'm')
						 && (NewLoc[x].pWaypoints[y+2] == '>')
						 && (NewLoc[x].pWaypoints[y-1] == 'a')
						 && (NewLoc[x].pWaypoints[y+1] == 'e')
						 && (NewLoc[x].pWaypoints[y-3] == '<'))

						 || (((sortbyname == FALSE)
						 && ((NewLoc[x].pWaypoints[y] == 'm')
						 && (NewLoc[x].pWaypoints[y+2] == '>')
						 && (NewLoc[x].pWaypoints[y+1] == 't')
						 && (NewLoc[x].pWaypoints[y-2] == '<'))
						 || ((NewLoc[x].pWaypoints[y] == 's')
						 && (NewLoc[x].pWaypoints[y+2] == '>')
						 && (NewLoc[x].pWaypoints[y-1] == 'e')
						 && (NewLoc[x].pWaypoints[y+1] == 'c')
						 && (NewLoc[x].pWaypoints[y-3] == '<')))))
						{
							y += 3;//to name or comment
							for (z = 0; (z < 50) && (NewLoc[x].pWaypoints[y] != '<'); y++, z++)
								wp[z] = NewLoc[x].pWaypoints[y];
							if (MapType != TOPO)
							{
								SetBkMode(hdc, TRANSPARENT);
								SetTextColor(hdc, WHITE);
							}
							TextOut(hdc, DotX + 10, DotY - 10, wp, z);
							break;
						}
					}
				}
			}
		}
		SelectObject(hdc, hObject);
		DeleteObject(hWaypointBrush);

		if (showtext)
		{
			BOOL flag;

			SetGraphicsMode(hdc, GM_COMPATIBLE);//GM_ADVANCED
			SetBkMode(hdc, TRANSPARENT);
			SetTextAlign(hdc, TA_LEFT|TA_BASELINE);
			SetTextColor(hdc, TextColor);//0x90FF00
			zoom = Zoom;
			if (MapType == TOPO)
				zoom *= 2;
			if ((MapType == URBANAREA) && (Zoom > 2))
				zoom = Zoom - 2;
			for (cur = head, prev = NULL; cur != NULL; prev = cur, cur = cur->next)
			{
				if ((zoom <= cur->Zoom) || ((zoom <= 2) && (cur->Zoom == 0)))
				{
					if ((cur->EUTM > ScreenLeft) && (cur->EUTM < ScreenRight)
						&& (cur->NUTM < ScreenTop) && (cur->NUTM > ScreenBottom))
					{
						flag = FALSE;
						TigerAngle = cur->angle;
						if (TigerAngle & 0x80000000)
						{
							TigerAngle &= 0x7FFFFFFF;
							flag = TRUE;
						}
						lf4.lfEscapement = lf4.lfOrientation = TigerAngle * 10;
						hFont = CreateFontIndirect (&lf4);
						hObject = SelectObject (hdc, hFont);
						x = (cur->EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
						y = (ScreenTop - cur->NUTM) * PixelsPerTile / MetersPerTile;
						for (z = 0; cur->text[z] != 0; z++)
							;
						if (flag)
							SetTextAlign(hdc, TA_RIGHT|TA_BASELINE);
						else
							SetTextAlign(hdc, TA_LEFT|TA_BASELINE);
						TextOut(hdc, x, y, cur->text, z);
						SelectObject(hdc, hObject);
						DeleteObject(hFont);
					}
				}
			}
			SetTextAlign(hdc, TA_LEFT|TA_TOP);
		}

		if (showingtracks)//WM_PAINT
		{
			int x1, x2, y1, y2;
			int prevSegmentN, prevSegmentE, prevSegmentX;
			int ZoomIndex = Zoom;

			if (MapType == TOPO)
				ZoomIndex += 8;
			if (editingtracks)
				hTrackPen = CreatePen(PS_SOLID, 2, TrackColor);//0xC08000
			else
				hTrackPen = CreatePen(PS_SOLID, ZoomTable[ZoomIndex], TrackColor);//0xB08000 blue
			hObject = SelectObject(hdc, hTrackPen);
			prevSegmentN = trak[0].NUTM;
			prevSegmentE = trak[0].EUTM;
			prevSegmentX = 0;
			for (x = 0; trak[x+1].time != 0; x++)
			{
				if ((DWORD)UTMZone == trak[x].time >> 26)//(int)//UTMZone in new Track.dta format
				{
					if (trak[x].newtrk != 0)
					{
						SelectObject(hdc, hObject);
						DeleteObject(hTrackPen);
						if (trak[x].color != 0)
						{
							TrackSegmentColor = trak[x].color;
							if (editingtracks)
								hTrackPen = CreatePen(PS_SOLID, 2, TrackSegmentColor);
							else
								hTrackPen = CreatePen(PS_SOLID, ZoomTable[ZoomIndex], TrackSegmentColor);
						}
						else
						{
							if (editingtracks)
								hTrackPen = CreatePen(PS_SOLID, 2, TrackColor);//0xC08000
							else
								hTrackPen = CreatePen(PS_SOLID, ZoomTable[ZoomIndex], TrackColor);//0xB08000 blue
						}
						hObject = SelectObject(hdc, hTrackPen);
					}

					if (editingtracks)
					{
						if ((x == 0) || (trak[x].newtrk != 0))
						{
							hStartBrush = CreateSolidBrush(StartColor);
							hObject = SelectObject(hdc, hStartBrush);
							hPen = CreatePen(PS_NULL, 1, 0);
							hObject2 = SelectObject(hdc, hPen);
							DotX = (trak[x].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
							DotY = (ScreenTop - trak[x].NUTM) * PixelsPerTile / MetersPerTile;
							Ellipse(hdc, DotX-6, DotY-6, DotX+6, DotY+6);
							SelectObject(hdc, hObject2);
							SelectObject(hdc, hObject);
							DeleteObject(hPen);
							DeleteObject(hStartBrush);
						}
					}
					if (trak[x+1].newtrk == 0)
					{
						y = trak[x].time >> 26;//UTMZone in new Track.dta format
						z = trak[x+1].time >> 26;//UTMZone in new Track.dta format
						if (y == z)
						{//if next trak dot is in same UTM zone
							if (editingtracks)
							{
								DotX = (trak[x+1].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
								DotY = (ScreenTop - trak[x+1].NUTM) * PixelsPerTile / MetersPerTile;
								Ellipse(hdc, DotX-6, DotY-6, DotX+6, DotY+6);
							}
							x1 = (trak[x].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
							y1 = (ScreenTop - trak[x].NUTM) * PixelsPerTile / MetersPerTile;
							MoveToEx(hdc, x1, y1, NULL);
							x2 = (trak[x+1].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
							y2 = (ScreenTop - trak[x+1].NUTM) * PixelsPerTile / MetersPerTile;
							LineTo(hdc, x2, y2);
						}
					}
					else if ((editingtracks) && (trak[x+1].newtrk != 0))
					{
						hEndBrush = CreateSolidBrush(EndColor);
						hObject = SelectObject(hdc, hEndBrush);
						DotX = (trak[x].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
						DotY = (ScreenTop - trak[x].NUTM) * PixelsPerTile / MetersPerTile;
						Ellipse(hdc, DotX-6, DotY-6, DotX+6, DotY+6);
						SelectObject(hdc, hObject);
						DeleteObject(hEndBrush);
					}
					if (trak[x].newtrk != 0)
					{
						prevSegmentN = trak[x].NUTM;
						prevSegmentE = trak[x].EUTM;
						prevSegmentX = x;
					}
				}
			}//end of for (x = 0;
			if ((editingtracks) && (UTMZone == (int)trak[x].time >> 26))
			{//at end of all tracks
				hEndBrush = CreateSolidBrush(EndColor);
				hObject = SelectObject(hdc, hEndBrush);
				DotX = (trak[x].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
				DotY = (ScreenTop - trak[x].NUTM) * PixelsPerTile / MetersPerTile;
				Ellipse(hdc, DotX-6, DotY-6, DotX+6, DotY+6);
				SelectObject(hdc, hObject);
				DeleteObject(hEndBrush);
			}
			SelectObject(hdc, hObject);
			DeleteObject(hTrackPen);
		}

		if (fromOpen)
		{//show View -Goto Lat/Lon dot
			DotX = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
			DotY = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
			hPositionBrush = CreateSolidBrush(PositionColor);//0xFFFF00
			hObject = SelectObject(hdc, hPositionBrush);
			Ellipse(hdc, DotX-6, DotY-6, DotX+6, DotY+6);
			SelectObject(hdc, hObject);
			DeleteObject(hPositionBrush);
		}

		if ((xBeg != -1) && (drawing == FALSE))
		{//draw line for entering text or showing distance measure
			if (distancemeasure)
			{
				if (MapType == TOPO)
					color = YELLOW;
				else
					color = WHITE;
				hPen = CreatePen(PS_SOLID, 1, color);
			}
			else
				hPen = CreatePen(PS_SOLID, 1, 0xFFFFFF);
			hObject = SelectObject(hdc, hPen);
			MoveToEx(hdc, xBeg, yBeg, NULL);
			LineTo(hdc, xPos, yPos);
//			if (xbegOld != -1)
//			{//previous distancemeasure line
//				MoveToEx(hdc, xbegOld, ybegOld, NULL);
//				LineTo(hdc, xPosOld, yPosOld);
//			}
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
		}

		if (pos)
		{//got a GPS position
			if (showline)
			{
				hPen = CreatePen(PS_SOLID, 2, 0x80FF);
				hObject = SelectObject(hdc, hPen);
				x = (Position[pos].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
				y = (ScreenTop - Position[pos].UTMN) * PixelsPerTile/ MetersPerTile;
				MoveToEx(hdc, x, y, NULL);
				x = (NewLoc[LineEnd].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile;
				y = (ScreenTop - NewLoc[LineEnd].NUTM) * PixelsPerTile/ MetersPerTile;
				LineTo(hdc, x, y);
				SelectObject(hdc, hObject);
				DeleteObject(hPen);
			}
//			time = (Position[pos].Hour*3600)+(Position[pos].Min*60)+(Position[pos].Sec);
//			prevtime = (Position[pos-1].Hour*3600)+(Position[pos-1].Min*60)+(Position[pos-1].Sec);
//			ndist = abs(Position[pos].UTMN - Position[pos-1].UTMN);
//			edist = abs(Position[pos].UTME - Position[pos-1].UTME);
//			if (prevtime > time)//passing midnight
//				prevtime -= (24*3600);
//			if (time - prevtime)
//			{
//				d = (sqrt(ndist*ndist + edist*edist)) / (time - prevtime);//meters/sec
//				d *= 2.2369363;//mph
//			}
//			else
//				d = 0.0;
			if (Velocity >= 10) // don't show less than 10 mph
			{
				hFont = CreateFontIndirect (&lf6);
				hObject = SelectObject (hdc, hFont);
				z = sprintf(Error, "%.0f", Velocity);
				TextOut(hdc, 0, 0, Error, z);
				SelectObject(hdc, hObject);
			}
			hAPRSBrush = CreateSolidBrush(APRSColor);//0x0000FF
//			hAPRSPen = CreatePen(PS_SOLID, 0, 0xF0);
			hPositionBrush = CreateSolidBrush(PositionColor);//0xFFFF00
			hObject = SelectObject(hdc, hPositionBrush);
			hPen = CreatePen(PS_NULL, 1, 0);
			hObject2 = SelectObject(hdc, hPen);
			if ((onepositiondot == FALSE) || (fromposition) || (testingsmartbeaconing))
			{
				for (x = 0; x < pos; x++)
				{
//					if ((Position[x].UTMZ == (int)UTMZone)
//					 && (Position[x].UTME > ScreenLeft) && (Position[x].UTME < ScreenRight)
//					 && (Position[x].UTMN < ScreenTop) && (Position[x].UTMN > ScreenBottom))
					{
						DotX = (Position[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
						DotY = (ScreenTop - Position[x].UTMN) * PixelsPerTile / MetersPerTile;
						Ellipse(hdc, DotX-DotRadius, DotY-DotRadius, DotX+DotRadius, DotY+DotRadius);

						if (testingsmartbeaconing)
						{
							if (SmartBeacon(x))
							{
//the commented out lines sometimes make a line to an incorrect DotX2 & DotY2
								SelectObject(hdc, hAPRSBrush);
								Ellipse(hdc, DotX-(DotRadius+1), DotY-(DotRadius+1), DotX+(DotRadius+1), DotY+(DotRadius+1));
								SelectObject(hdc, hPositionBrush);
//								SelectObject(hdc, hAPRSPen);
//								DotX2 = (Position[LastPosition].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
//								DotY2 = (ScreenTop - Position[LastPosition].UTMN) * PixelsPerTile / MetersPerTile;
//								MoveToEx(hdc, DotX, DotY, NULL);
//								LineTo(hdc, DotX2, DotY2);
//								SelectObject(hdc, hPen);
							}
						}
					}
				}
			}
			else
 			{
				DotX = (Position[pos].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
				DotY = (ScreenTop - Position[pos].UTMN) * PixelsPerTile / MetersPerTile;
				Ellipse(hdc, DotX-DotRadius, DotY-DotRadius, DotX+DotRadius, DotY+DotRadius);
//the following sometimes make a line to an incorrect DotX2 & DotY2
//				DotX2 = (Position[pos-1].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
//				DotY2 = (ScreenTop - Position[pos-1].UTMN) * PixelsPerTile / MetersPerTile;
//				SelectObject(hdc, hObject2);
//				DeleteObject(hPen);
//				hPen = CreatePen(PS_SOLID, 1, PositionColor);
//				hObject2 = SelectObject(hdc, hPen);
//				MoveToEx(hdc, DotX, DotY, NULL);
//				LineTo(hdc, DotX2, DotY2);
			}
			SelectObject(hdc, hObject2);
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
			DeleteObject(hPositionBrush);
			DeleteObject(hAPRSBrush);

			if (makewaypoint)
			{
				hWaypointBrush = CreateSolidBrush(WaypointColor);
				hObject = SelectObject(hdc, hWaypointBrush);
				DotX = (Position[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
				DotY = (ScreenTop - Position[x].UTMN) * PixelsPerTile/ MetersPerTile;
				Ellipse(hdc, DotX-DotRadius, DotY-DotRadius, DotX+DotRadius, DotY+DotRadius);
				SelectObject(hdc, hObject);
				DeleteObject(hWaypointBrush);
			}
		}//end of if (pos)

		if (fromusbtracks)
		{//weird but necessary
			fromusbtracks = FALSE;
			fromTracks = TRUE;
			showingtracks = TRUE;
			editingtracks = FALSE;
			CreateTracks();
		}

		if (USGSBuf != NULL)
		{
			BOOL plusninty = FALSE;

			if (MapType != TOPO)
			{
				SetBkMode(hdc, TRANSPARENT);
				SetTextColor(hdc, 0x00FFFF);
				SetTextAlign(hdc, TA_TOP|TA_LEFT);
			}
			if (Zoom == 1)
				for (x = 0; x < 100; x++)
				{
					CurLandmark[x].x = 0;
					CurLandmark[x].z = 0;
				}
			for (x = 0; x < NumOfPtrs; x++)
			{
				if ((PtrBuf[x].UTMN < ScreenTop) && (PtrBuf[x].UTMN > ScreenBottom) && (PtrBuf[x].UTME > ScreenLeft) && (PtrBuf[x].UTME < ScreenRight))
				{
					y = (ScreenTop - PtrBuf[x].UTMN) * PixelsPerTile / MetersPerTile;
					z = (PtrBuf[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
					v = PtrBuf[x].ptr;
					for (w = 0; USGSBuf[v] != 0; v++, w++)
						USGSData[w] = USGSBuf[v];
					USGSData[w] = 0;
					if (Zoom == 1)
					{
						for (cl = 0; (CurLandmark[cl].x != 0) && (cl < 100); cl++)
						{
							if ((z == CurLandmark[cl].x) && (y == CurLandmark[cl].y))
							{
								NormalOrientation = lf5.lfOrientation;
								lf5.lfEscapement += 450*((CurLandmark[cl].z)+1);
								lf5.lfOrientation += 450*((CurLandmark[cl].z)+1);
								plusninty = TRUE;
								break;
							}
						}
						if (plusninty == FALSE)
						{
							CurLandmark[cl].x = z;
							CurLandmark[cl].y = y;
						}
						else
							CurLandmark[cl].z++;//location duplication marker
					}
					hFont = CreateFontIndirect (&lf5);
					hObject = SelectObject (hdc, hFont);
					TextOut(hdc, z, y, USGSData, w);
					SelectObject(hdc, hObject);
					DeleteObject(hFont);
					if (plusninty)
					{
						plusninty = FALSE;
						lf5.lfEscapement = NormalOrientation;
						lf5.lfOrientation = NormalOrientation;
					}
				}
			}
		}

		if ((objectPtr) && (gotsymbol))
		{
			for (x = 0; x < objectPtr; x++)
			{
				if (Objects[x].UTMZ == UTMZone)
				{
					DotX = (Objects[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
					DotY = (ScreenTop - Objects[x].UTMN) * PixelsPerTile / MetersPerTile;
					SetBkColor(hdc, LIGHTGRAY);
					TextOut(hdc, DotX+10, DotY-7, Objects[x].Name, strlen(Objects[x].Name));
					if (hdcSymMem1)
					{
						y = Objects[x].Symbol;
						symbolcol = y % 16;
						symbolrow = y / 16;
						if (Objects[x].SymbolType == '/')
							z = TransparentBlt(hdc, DotX-10, DotY-10, 20, 20, hdcSymMem1, (21*symbolcol)+1, (21*symbolrow)+1, 20, 20, 0xFFFFFF);
						else
						{
							y -= 94;
							symbolcol = y % 16;
							symbolrow = y / 16;
							z = TransparentBlt(hdc, DotX-10, DotY-10, 20, 20, hdcSymMem2, (21*symbolcol)+1, (21*symbolrow)+1, 20, 20, 0xFFFFFF);
							if (Objects[x].SymbolType != '\\')
							{
								SetBkMode(hdc, TRANSPARENT);
								SetTextColor(hdc, 0xFFFFFF);
								TextOut(hdc, DotX-5, DotY-8, &Objects[x].SymbolType, 1);
								SetTextColor(hdc, 0);
								SetBkMode(hdc, OPAQUE);
							}
						}
					}
					if (Objects[x].CircleRadius)
					{
						double Meters;

						if (Objects[x].itsmiles)
							Meters = (Objects[x].CircleRadius * 5280.0 * 0.3048);
						else
							Meters = Objects[x].CircleRadius * 0.3048;
						Radius = (int)(Meters * PixelsPerTile / MetersPerTile);
						hPen = CreatePen(PS_SOLID, 2, Objects[x].CircleColor);
						hObject = SelectObject(hdc, hPen);
						DotX = (Objects[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
						DotY = (ScreenTop - Objects[x].UTMN) * PixelsPerTile / MetersPerTile;
						MoveToEx(hdc, DotX+Radius, DotY, NULL);
						AngleArc(hdc, DotX, DotY, Radius, 0.0, 360.0);
						SelectObject(hdc, hObject);
						DeleteObject(hPen);
					}
				}
			}
		}

		if ((aprs) || (tnc))
		{
			centerX = rect.right >> 1;
			centerY = rect.bottom >> 1;

			hPen = CreatePen(PS_SOLID, 1, WHITE);
			hObject = SelectObject(hdc, hPen);
			MoveToEx(hdc, centerX-200, centerY, NULL);
			LineTo(hdc, centerX+200, centerY);
			MoveToEx(hdc, centerX, centerY-200, NULL);
			LineTo(hdc, centerX, centerY+200);
			SelectObject(hdc, hObject);
			DeleteObject(hPen);

			hAPRSBrush = CreateSolidBrush(APRSColor);//0x0000FF
			hObject = SelectObject(hdc, hAPRSBrush);
			for (x = 0; x < Aprsi; x++)
			{
//				if ((Aprs[x].UTMZ == UTMZone) && (Aprs[x].UTME > ScreenLeft) && (Aprs[x].UTME < ScreenRight)
//				 && (Aprs[x].UTMN < ScreenTop) && (Aprs[x].UTMN > ScreenBottom))
				if (Aprs[x].UTMZ == UTMZone)
				{
					if (showlist & 0x01000000)
					{
						if (Aprs[x].DescOrWx[0] != 0)
						{
							ShowIcon(x);
						}
					}
					else
					{
						if ((showlist & 0x00000001) && (ShowList1[0]) && (Aprs[x].Call[0] != 0))
						{//show ONLY callsign(s)
							char *ptr = Aprs[x].Call;
							for (y = 0; ShowList1[y] != 0; )
							{
								for (z = 0; ; y++, z++)
									if (ShowList1[y] != ptr[z])
										break;
								if ((ShowList1[y] == 0) || (ShowList1[y] == '\r'))
								{
									ShowIcon(x);
								}
								for ( ;(ShowList1[y] != 0) && (ShowList1[y] != '\n'); y++)
									;//go to next line
								if (ShowList1[y] == '\n')
									y++;
							}
						}
						if ((showlist & 0x00000010) && (ShowList2[0]) && (Aprs[x].Call[0] != 0))
						{//DON'T show callsign(s)
							char *ptr = Aprs[x].Call;
							dontshow = FALSE;
							for (y = 0; ShowList2[y] != 0; )
							{
								for (z = 0; ; y++, z++)
									if (ShowList2[y] != ptr[z])
										break;
								if ((ShowList2[y] == 0) || (ShowList2[y] == '\r'))
									dontshow = TRUE;
								for ( ;(ShowList2[y] != 0) && (ShowList2[y] != '\n'); y++)
									;//go to next line
								if (ShowList2[y] == '\n')
									y++;
							}
							if (dontshow == FALSE)
							{//not equal
								ShowIcon(x);
							}
						}
						if ((showlist & 0x00000100) && (ShowList3[0]) && (Aprs[x].DescOrWx[0] != 0))
						{//show ONLY symbol type
							for (y = 0; ShowList3[y] != 0; )
							{
								for (z = 0; ; y++, z++)
									if (ShowList3[y] != Aprs[x].DescOrWx[z])
										break;
								if ((ShowList3[y] == 0) || (ShowList3[y] == '\r'))
								{
									ShowIcon(x);
								}
								for ( ;(ShowList3[y] != 0) && (ShowList3[y] != '\n'); y++)
									;//go to next line
								if (ShowList3[y] == '\n')
									y++;
							}
						}
						if ((showlist & 0x00001000) && (ShowList4[0]) && (Aprs[x].DescOrWx[0] != 0))
						{//DON'T show symbol type
							dontshow = FALSE;
							for (y = 0; ShowList4[y] != 0; )
							{
								for (z = 0; ; y++, z++)
									if (ShowList4[y] != Aprs[x].DescOrWx[z])
										break;
								if ((ShowList4[y] == 0) || (ShowList4[y] == '\r'))
									dontshow = TRUE;
								for ( ;(ShowList4[y] != 0) && (ShowList4[y] != '\n'); y++)
									;//go to next line
								if (ShowList4[y] == '\n')
									y++;
							}
							if (dontshow == FALSE)
							{//not equal
								ShowIcon(x);
							}
						}
					}
				}
			}
			SelectObject(hdc, hObject);
			DeleteObject(hAPRSBrush);
		}

		if (gsak)
		{
			gsak = FALSE;
			SendMessage(hwnd, WM_RBUTTONDOWN, 0, 0);
		}
		EndPaint (hwnd, &ps);
		return 0;


	case WM_CLOSE:
//		CloseHandle(hDeviceFile);
		if (uTimerID)
		{
			timeKillEvent(uTimerID);
			timeEndPeriod(TIMER_RESOLUTION);
			uTimerID = NULL;
			DeleteObject(hRedBrush);
		}
		if (aprsi)
		{
			if (aprsimulate == FALSE)
			{
				SaveAPRSlog();
				SaveAPRSlogAsText();
				if (hAPRSThread)
				{
					if (kiss)
					{
						WriteFile(hAPRSComm, "\xC0\xFF\xC0", 3, &dwBytesWritten, NULL);
						WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
					}
					WriteFile(hAPRSComm, Shutdown, 14, &dwBytesWritten, NULL);
					WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
					SetEvent(hAPRSEvent);//close APRSCommThread
					SetEvent(hAPRSISEvent);//close aprsISthread
				}
			}
		}
		for (x = 0; x < MAXPTIGERS; x++)
		{
			if (pTiger[x] != NULL)
				free(pTiger[x]);
			if (pTigerNames[x] != NULL)
				free(pTigerNames[x]);
		}
		if (pUSA != NULL)
		{
			free(pUSA);
		}
		if (pTigerIndex != NULL)
		{
			free(pTigerIndex);
			pTigerIndex = NULL;
		}
		if (trak != NULL)
		{
			free(trak);
			trak = NULL;
		}
//		if (fillscreen == FALSE)
//		{
//			if (INVALID_HANDLE_VALUE != FindFirstFile("*.wav", &fd))
//				x = PlaySound(fd.cFileName, NULL, SND_FILENAME);
//			else
//				MessageBeep(MB_ICONASTERISK);
//		}
		if (ScreenDems != 0)
		{
			for (x = 0; x < ScreenDems; x++)
				free(DemData[x]);
		}
		if ((savebuf) && (Buf[0] != 0))
		{
			if ((autoLoc) && (itsgarmin))
			{
				sendingStop = TRUE;
				WriteFile(hComm, &StopPVTPacket, 8, &dwBytesWritten, NULL);
				for (x = 0; x < 8; x++, tgcount++)
					ToGPS[tgcount] = StopPVTPacket[x];
				if (tgcount > 49900) tgcount = 0;
			}
			itsgarmin = FALSE;
			for (x = 0; x < iBuf; x++)
			{
				if (Buf[x] == DLE)
				{
					itsgarmin = TRUE;
					break;
				}
			}
			if (itsgarmin)
			{
				hFile = CreateFile(ToGarmin, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, ToGPS, tgcount, &dwBytesWritten, NULL);
				CloseHandle(hFile);
				hFile = CreateFile(GPSdta, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			}
			else if (itsusb == FALSE)
			{
				hFile = CreateFile(Togps, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, ToGPS, tgcount, &dwBytesWritten, NULL);
				CloseHandle(hFile);

				hFile = CreateFile(GPStxt, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			}
			WriteFile(hFile, Buf, iBuf, &dwBytesWritten, NULL);
			CloseHandle(hFile);
		}
		if (hThread != 0)
		{
			if ((Buf[0] != 0) && (itsgarmin) && (savebuf))
			{
				GetCommHandle();
				if (hComm != INVALID_HANDLE_VALUE)
				{
					WriteFile(hComm, &ACKPacket, 8, &dwBytesWritten, NULL);//so CommThread won't be stuck at ReadFile
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = ACKPacket[x];
					if (tgcount > 49900) tgcount = 0;
				}
			}
			SetEvent(hEventExit);
			if (WAIT_TIMEOUT == WaitForSingleObject((HANDLE)hThread, 1000))//wait for it to be closed
			{
				TerminateThread((HANDLE)hThread, 1);
				MessageBeep(MB_OK);
			}
			CloseHandle((HANDLE)hThread);
		}
		if (hComm != INVALID_HANDLE_VALUE)
			CloseHandle(hComm);
		if (hdcMem2)
		{
			DeleteDC(hdcMem2);
			DeleteObject(hBitmap2);
		}
		if (hdcMem3)
		{
			DeleteDC(hdcMem3);
			DeleteObject(hBitmap3);
		}
		DeleteDC (hdcMem);
		DeleteDC (hdcGrayMem);
		DeleteObject (hBitmap);
		DeleteObject (hGrayBitmap);
		if (hSymbolBitmap)
			DeleteObject(hSymbolBitmap);
		if (newLoc)
			SaveLocs();
		if (newText)
			SaveText();
		if (openatclosing)
		{
			ChangeUSAPhotoMapsIni();
			ChangeUSAPMIni();
		}
		else if (INVALID_HANDLE_VALUE == FindFirstFile("USAPM.ini", &fd))
			ChangeUSAPMIni();
		if (hUSBThread != 0)
		{
			TerminateThread((HANDLE)hUSBThread, 1);
			MessageBeep(MB_OK);
			CloseHandle((HANDLE)hUSBThread);
			VirtualFree(FromUSBBuf, 0, MEM_RELEASE);
		}
		if (WaypointArray != NULL)
			free(WaypointArray);
		if (USGSBuf != NULL)
		{
			VirtualFree(USGSBuf, 0, MEM_RELEASE);
			VirtualFree(PtrBuf, 0, MEM_RELEASE);
		}
//		DeleteCriticalSection(&cs);
		DestroyWindow(hwnd);
		return 0;

	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	}
	return DefWindowProc (hwnd, message, wParam, lParam);
}












//SUBROUTINES********************************************************************************************************************************












UINT WINAPI CommThread(void* pParam)
{
	int x;
	BYTE ch;
	BYTE *tempBuf;
	DWORD fileSize2, dwBytesRead2, time;
	HANDLE hFile2;

	if (simulate)
	{//if the Ctrl key is down
		simulate = FALSE;
		savebuf = FALSE;
		time = 100;
		if (itsgarmin)
			hFile2 = CreateFile(GPSdta, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		else
			hFile2 = CreateFile(GPStxt, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile2 != INVALID_HANDLE_VALUE)
		{
			if (fileSize2 = GetFileSize(hFile2, NULL))
			{
				tempBuf = (BYTE*)malloc(fileSize2);
				ReadFile(hFile2, tempBuf, fileSize2, &dwBytesRead2, NULL);
				CloseHandle (hFile2);

				for (x = 0; x < (int)fileSize2; x++)
				{
					PostMessage(hwnd, WM_USER_COMM, 0, (LPARAM)tempBuf[x]);
					if ((itsgarmin == FALSE) && (tempBuf[x] == '\n'))
						Sleep(time);
					else if ((tempBuf[x] == DLE) && (tempBuf[x-1] == ETX) && (tempBuf[x-2] == DLE))
						Sleep(time);
				}
				free(tempBuf);
			}
//			MessageBox(hwnd, "Done", "", MB_OK);
		}
		else if (itsgarmin)
			MessageBox(hwnd, "Couldn't find 'GPS.dta'", NULL, MB_OK);
		else//if (!itsgarmin)
			MessageBox(hwnd, "Couldn't find 'GPS.txt'", NULL, MB_OK);
	}
	else
	{
		savebuf = TRUE;
		PurgeComm(hComm, PURGE_RXCLEAR|PURGE_TXCLEAR);
		while (WaitForSingleObject(hEventExit, 0) != WAIT_OBJECT_0)
		{
			ReadFile(hComm, &ch, 1, &dwBytesRead2, NULL);
			if (dwBytesRead2)
				PostMessage(hwnd, WM_USER_COMM, 0, (LPARAM)ch);
		}

		if (hComm != INVALID_HANDLE_VALUE)
		{
			CloseHandle(hComm);
			hComm = INVALID_HANDLE_VALUE;
		}
	}
	if (pos)
	{
		SavePosition();
	}
	pos = 0;//for simulate??
	CloseHandle((HANDLE)hThread);
	hThread = 0;
	InvalidateRect(hwnd, &rect, FALSE);
	return 0;
}

UINT WINAPI APRSCommThread(void* pParam)
{
	int x;
	BYTE ch;
	BYTE *tempBuf;
	DWORD fileSize2, dwBytesRead2;
	HANDLE hFile2;

	if (aprsimulate)
	{
		savebuf = FALSE;
		hFile2 = CreateFile(APRStxt, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile2 != INVALID_HANDLE_VALUE)
		{
			if (fileSize2 = GetFileSize(hFile2, NULL))
			{
				tempBuf = (BYTE*)malloc(fileSize2);
				ReadFile(hFile2, tempBuf, fileSize2, &dwBytesRead2, NULL);
				CloseHandle (hFile2);

				for (x = 0; x < (int)fileSize2; x++)
				{
					PostMessage(hwnd, WM_APRS_COMM, 0, (LPARAM)tempBuf[x]);
					if (WaitForSingleObject(hAPRSEvent, 1000) == WAIT_OBJECT_0)
						ResetEvent(hAPRSEvent);
				}
				free(tempBuf);
			}
		}
	}
	else
	{
		savebuf = TRUE;

		PurgeComm(hComm, PURGE_RXCLEAR|PURGE_TXCLEAR);
		while (WaitForSingleObject(hAPRSEvent, 0) != WAIT_OBJECT_0)
		{
			ReadFile(hAPRSComm, &ch, 1, &dwBytesRead2, NULL);
			if (dwBytesRead2)
			{
				PostMessage(hwnd, WM_APRS_COMM, 0, (LPARAM)ch);
			}
		}

		if (hAPRSComm != INVALID_HANDLE_VALUE)
		{
			CloseHandle(hAPRSComm);
			hAPRSComm = INVALID_HANDLE_VALUE;
		}
	}
	CloseHandle((HANDLE)hAPRSThread);
	hAPRSThread = 0;
	if (aprsimulate)
		InvalidateRect(hwnd, &rect, FALSE);
	return 0;
}

//01234567890123456789
//COM1 USB    x9600   |
void GetCommHandle(void)
{
	if (hComm == INVALID_HANDLE_VALUE)
	{
		NewComm[7] = RegValue[3];
		NewComm[8] = RegValue[4];
		if (NewComm[8] == ' ')
			NewComm[8] = 0;
		hComm = CreateFile(NewComm, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hComm != INVALID_HANDLE_VALUE)
		{
			GetCommState(hComm, &dcb);//to fill dcb with default values
			dcb.BaudRate = Baud;
			dcb.ByteSize = 8;
			dcb.Parity = NOPARITY;
			dcb.StopBits = ONESTOPBIT;

			dcb.EofChar = 26;
			dcb.ErrorChar = 0;
			dcb.EvtChar = 0;
			dcb.fAbortOnError = FALSE;
			dcb.fBinary = TRUE;
			dcb.fDsrSensitivity = FALSE;
			dcb.fDtrControl = DTR_CONTROL_ENABLE;
			dcb.fErrorChar = FALSE;
			dcb.fInX = FALSE;
			dcb.fNull = FALSE;
			dcb.fOutX = FALSE;
			dcb.fOutxCtsFlow = FALSE;
			dcb.fOutxDsrFlow = FALSE;
			dcb.fParity = FALSE;
			dcb.fRtsControl = RTS_CONTROL_ENABLE;
			dcb.fTXContinueOnXoff = FALSE;//TRUE;
			dcb.XoffChar = 19;
			dcb.XoffLim = 512;
			dcb.XonChar = 17;
			dcb.XonLim = 2048;

			if (0 == SetCommState(hComm, &dcb))
			{
				x = GetLastError();
				MessageBox(hwnd, "SetCommState didn't work.", ERROR, MB_OK);
			}
			GetCommProperties(hComm, &cp);
			if (cp.dwProvCapabilities & PCF_INTTIMEOUTS)
			{
				cto.ReadIntervalTimeout = MAXDWORD;
				cto.ReadTotalTimeoutConstant = 10;
				cto.ReadTotalTimeoutMultiplier = MAXDWORD;
				SetCommTimeouts(hComm, &cto);
			}
		}
		else
		{
			x = GetLastError();
 			MessageBox(hwnd, "Couldn't open comm port!", ERROR, MB_OK);
			fromFlag = MENU;
		}
	}
}

void GetAPRSCommHandle(void)
{
	if (hAPRSComm == INVALID_HANDLE_VALUE)
	{
		APRSComm[7] = APRSCommPort[0];
		APRSComm[8] = APRSCommPort[1];
		hAPRSComm = CreateFile(APRSComm, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hAPRSComm != INVALID_HANDLE_VALUE)
		{
			GetCommState(hAPRSComm, &dcb2);//to fill dcb2 with default values
			dcb2.BaudRate = APRSBaud;
			dcb2.ByteSize = 8;
			dcb2.Parity = NOPARITY;
			dcb2.StopBits = ONESTOPBIT;

			dcb2.EofChar = 26;
			dcb2.ErrorChar = 0;
			dcb2.EvtChar = 0;
			dcb2.fAbortOnError = FALSE;
			dcb2.fBinary = TRUE;
			dcb2.fDsrSensitivity = FALSE;
			dcb2.fDtrControl = DTR_CONTROL_ENABLE;
			dcb2.fErrorChar = FALSE;
			dcb2.fInX = FALSE;
			dcb2.fNull = FALSE;
			dcb2.fOutX = FALSE;
			dcb2.fOutxCtsFlow = FALSE;
			dcb2.fOutxDsrFlow = FALSE;
			dcb2.fParity = FALSE;
			dcb2.fRtsControl = RTS_CONTROL_ENABLE;
			dcb2.fTXContinueOnXoff = FALSE;//TRUE;
			dcb2.XoffChar = 19;
			dcb2.XoffLim = 512;
			dcb2.XonChar = 17;
			dcb2.XonLim = 2048;

			if (0 == SetCommState(hAPRSComm, &dcb2))
			{
				x = GetLastError();
				MessageBox(hwnd, "SetCommState didn't work.", ERROR, MB_OK);
			}
			GetCommProperties(hAPRSComm, &cp);
			if (cp.dwProvCapabilities & PCF_INTTIMEOUTS)
			{
				APRScto.ReadIntervalTimeout = MAXDWORD;
				APRScto.ReadTotalTimeoutConstant = 10;
				APRScto.ReadTotalTimeoutMultiplier = MAXDWORD;
				SetCommTimeouts(hAPRSComm, &APRScto);
			}
		}
		else
 			MessageBox(hwnd, "Couldn't open APRS comm port!", ERROR, MB_OK);
	}
}

void GetPointerElev(int w)
{
	int x, y, xrem, yrem, yLeft, yRight, xTop, xBottom;

	xrem = (UTMEasting - Dem[w].West) % 30;
	yrem = (Dem[w].North - UTMNorthing) % 30;
	if (tl <= llElev)
		yLeft = tl + ((llElev - tl) * yrem) / 30;
	else
		yLeft = tl - ((tl - llElev) * yrem) / 30;
	if (urElev <= lrElev)
		yRight = urElev + ((lrElev - urElev) * yrem) / 30;
	else
		yRight = urElev - ((urElev - lrElev) * yrem) / 30;
	if (tl <= urElev)
		xTop = tl + ((urElev - tl) * xrem) / 30;
	else
		xTop = tl - ((tl - urElev) * xrem) / 30;
	if (llElev <= lrElev)
		xBottom = llElev + ((lrElev - llElev) * xrem) / 30;
	else
		xBottom = llElev - ((llElev - lrElev) * xrem) / 30;

	if (yLeft <= yRight)
		y = yLeft + ((yRight - yLeft) * xrem) / 30;//xrem is slightly trick
	else
		y = yLeft - ((yLeft - yRight) * xrem) / 30;
	if (xTop <= xBottom)
		x = xTop + ((xBottom - xTop) * yrem) / 30;
	else
		x = xTop - ((xTop - xBottom) * yrem) / 30;
	if (x <= y)
		tl = x + ((y - x) >> 1);
	else
		tl = x - ((x - y) >> 1);
}

void LatorLon(int x, int z)
{
	int y, w;

	ptrToAscii = _ecvt(degrees, count, &decPos, &sign);
	for (y = 0; y < decPos; x++, y++)
		LatLon[x] = ptrToAscii[y];

	if (MouseLoc == DEG)
	{
		LatLon[x++] = '.';
		for ( ; y < decPos+6; x++, y++)
			LatLon[x] = ptrToAscii[y];
	}
	else
		minutes = modf(degrees, &degrees) * 60.0;
	LatLon[x++] = '\xB0';//degree

	if (MouseLoc == DEGMIN)
	{
		LatLon[x++] = ' ';
		ptrToAscii = _ecvt(minutes, count, &decPos, &sign);
		if (decPos <= 0)//decimal is to left of number
		{
			LatLon[x++] = '0';
			LatLon[x++] = '.';
			for (y = 0; y > decPos; x++, y--)
				LatLon[x] = '0';
			for (w = y+4, y = 0; y < w; x++, y++)
				LatLon[x] = ptrToAscii[y];
		}
		else
		{
			for (y = 0; y < decPos; x++, y++)
				LatLon[x] = ptrToAscii[y];
			LatLon[x++] = '.';
			for ( ; y < decPos+4; x++, y++)
				LatLon[x] = ptrToAscii[y];
		}
		LatLon[x++] = '\'';
	}

	else if (MouseLoc == DEGMINSEC)
	{
		LatLon[x++] = ' ';
		ptrToAscii = _ecvt(minutes, count, &decPos, &sign);
		if (abs((int)minutes) < 1)
			LatLon[x++] = '0';
		else
			for (y = 0; y < decPos; x++, y++)
				LatLon[x] = ptrToAscii[y];
		LatLon[x++] = '\'';
		seconds = modf(minutes, &minutes) * 60.0;
		LatLon[x++] = ' ';
		ptrToAscii = _ecvt(seconds, count, &decPos, &sign);
		if (decPos <= 0)
		{
			LatLon[x++] = '0';
			LatLon[x++] = '.';
			for (y = 0; y > decPos; x++, y--)
				LatLon[x] = '0';
			for (w = y+2, y = 0; y < w; x++, y++)
				LatLon[x] = ptrToAscii[y];
		}
		else
		{
			for (y = 0; y < decPos; x++, y++)
				LatLon[x] = ptrToAscii[y];
			LatLon[x++] = '.';
			for ( ; y < decPos+2; x++, y++)
				LatLon[x] = ptrToAscii[y];
		}
		LatLon[x++] = '\"';
	}
	for ( ; x < z; x++)
		LatLon[x] = ' ';
}

void GetLatLon(void)
{
	int w, x, y, z;

	x = 25;
	z = 40;
	degrees = Lat;
	count = 8;
	LatorLon(x, z);
	x = 46;
	z = 62;
	degrees = Lon;
	count = 9;
	LatorLon(x, z);

	LatLon[99] = ' ';
	LatLon[100] = ' ';
	LatLon[101] = ' ';
	LatLon[102] = ' ';
	LatLon[103] = ' ';
	LatLon[104] = ' ';

	tl = 0;
	for (z = 0; z < ScreenDems; z++)
	{
		w = Associated[z];
		if ((UTMZone == Dem[w].Zone) && (UTMNorthing <= Dem[w].North) && (UTMNorthing > Dem[w].South) && (UTMEasting >= Dem[w].West) && (UTMEasting < Dem[w].East))
		{
			x = (UTMEasting - Dem[w].West) / 30;
			y = (Dem[w].North - UTMNorthing) / 30;
			tl = DemData[z][(y*Dem[w].Cols)+x];
			llElev = DemData[z][((y+1)*Dem[w].Cols)+x];
			lrElev = DemData[z][((y+1)*Dem[w].Cols)+x+1];
			urElev = DemData[z][((y)*Dem[w].Cols)+x+1];
			
			if ((tl != 0x8002) && (llElev != 0x8002) && (lrElev != 0x8002) && (urElev != 0x8002))
			{
				GetPointerElev(w);
				if (Dem[w].Meas == 'M')//in "METERS"
				{
					dElev = (double)tl / 0.3048;
					tl = (int)dElev;
				}
				if (tl > 9999)
					LatLon[99] = ((tl % 100000) / 10000) + '0';
				LatLon[100] = ((tl % 10000) / 1000) + '0';
				LatLon[101] = ((tl % 1000) / 100) + '0';
				LatLon[102] = ((tl % 100) / 10) + '0';
				LatLon[103] = (tl % 10) + '0';
				LatLon[104] = '\'';
			}
		}
	}
}

//char UTM[] = "USAPhotoMaps        UTM: Easting xxx,xxx Northing x,xxx,xxx Zone xx   Zoom:  1 meter /pixel   Elev: xxxx'";
			  //0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
void GetUTM(int North, int West)
{
	int x, y, remainder, Million = 1000000, HundredThousand = 100000, TenThousand = 10000, Thousand = 1000, Hundred = 100, Ten = 10;

	remainder = North % Million;
	UTM[50] = (North / Million) + '0';
	UTM[52] = (remainder / HundredThousand) + '0';
	UTM[53] = ((remainder % HundredThousand) / TenThousand) + '0';
	UTM[54] = ((remainder % TenThousand) / Thousand) + '0';
	UTM[56] = ((remainder % Thousand) / 100) + '0';
	UTM[57] = ((remainder % Hundred) / Ten) + '0';
	UTM[58] = (remainder % Ten) + '0';

	remainder = West % Million;
	UTM[33] = (remainder / HundredThousand) + '0';
	UTM[34] = ((remainder % HundredThousand) / 10000) + '0';
	UTM[35] = ((remainder % TenThousand) / 1000) + '0';
	UTM[37] = ((remainder % Thousand) / 100) + '0';
	UTM[38] = ((remainder % Hundred) / 10) + '0';
	UTM[39] = (remainder % Ten) + '0';

	UTM[65] = Z[0];
	UTM[66] = Z[1];

	UTM[99] = ' ';
	UTM[100] = ' ';
	UTM[101] = ' ';
	UTM[102] = ' ';
	UTM[103] = ' ';
	UTM[104] = ' ';

	tl = 0;
	for (z = 0; z < ScreenDems; z++)
	{
		w = Associated[z];
		if ((UTMZone == Dem[w].Zone) && (North <= Dem[w].North) && (North > Dem[w].South) && (West >= Dem[w].West) && (West < Dem[w].East))
		{
			x = (West - Dem[w].West) / 30;
			y = (Dem[w].North - North) / 30;
			tl = DemData[z][(y*Dem[w].Cols)+x];
			llElev = DemData[z][((y+1)*Dem[w].Cols)+x];
			lrElev = DemData[z][((y+1)*Dem[w].Cols)+x+1];
			urElev = DemData[z][((y)*Dem[w].Cols)+x+1];
			
			if ((tl != 0x8002) && (llElev != 0x8002) && (lrElev != 0x8002) && (urElev != 0x8002))
			{
				GetPointerElev(w);
				if (Dem[w].Meas == 'M')//in "METERS"
				{
					dElev = (double)tl / 0.3048;
					tl = (int)dElev;
				}
				if (tl > 9999)
					UTM[99] = ((tl % 100000) / 10000) + '0';
				UTM[100] = ((tl % 10000) / 1000) + '0';
				UTM[101] = ((tl % 1000) / 100) + '0';
				UTM[102] = ((tl % 100) / 10) + '0';
				UTM[103] = (tl % 10) + '0';
				UTM[104] = '\'';
			}
		}
	}

}

void GetUSNG(int North, int West)
{//char USNG[] =   "USAPhotoMaps       USNG:                                              Zoom: 1 meter /pixel   Elev: xxxx'  Photo      ";
	int lat = (int)Lat;
	int utme, utmn, Eoffset, Noffset;
	char Ealphabet[] = "ABCDEFGHJKLMNPQRSTUVWXYZABCDEFGHJKLMNPQRSTUVWXYZ";
	char Nalphabet[] = "ABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUV";

	USNG[26] = Z[0];
	USNG[27] = Z[1];
	if ((lat >= 16) && (lat < 24))
		USNG[28] = 'Q';
	else if ((lat >= 24) && (lat < 32))
		USNG[28] = 'R';
	else if ((lat >= 32) && (lat < 40))
		USNG[28] = 'S';
	else if ((lat >= 40) && (lat < 48))
		USNG[28] = 'T';
	else if ((lat >= 48) && (lat < 56))
		USNG[28] = 'U';
	else if ((lat >= 56) && (lat < 64))
		USNG[28] = 'V';
	else if ((lat >= 64) && (lat < 72))
		USNG[28] = 'W';

	switch (UTMZone % 6)
	{
	case 0:
		Eoffset = 16;//S
		Noffset = 5;//F
		break;
	case 1:
		Eoffset = 0;//A
		Noffset = 0;//A
		break;
	case 2:
		Eoffset = 8;//J
		Noffset = 5;//F
		break;
	case 3:
		Eoffset = 16;//S
		Noffset = 0;//A
		break;
	case 4:
		Eoffset = 0;//A
		Noffset = 5;//F
		break;
	case 5:
		Eoffset = 8;//J
		Noffset = 0;//A
		break;
	}
	utmn = North / HUNDREDTHOUSAND;
	utme = West / HUNDREDTHOUSAND;
	USNG[30] = Ealphabet[Eoffset+(utme-1)];
	USNG[31] = Nalphabet[Noffset+utmn];

	remainder = West % MILLION;
	USNG[33] = ((remainder % HUNDREDTHOUSAND) / 10000) + '0';
	USNG[34] = ((remainder % TENTHOUSAND) / 1000) + '0';
	USNG[35] = ((remainder % THOUSAND) / 100) + '0';
	USNG[36] = ((remainder % 100) / 10) + '0';
	USNG[37] = (remainder % 10) + '0';
	remainder = North % MILLION;
	USNG[39] = ((remainder % HUNDREDTHOUSAND) / TENTHOUSAND) + '0';
	USNG[40] = ((remainder % TENTHOUSAND) / THOUSAND) + '0';
	USNG[41] = ((remainder % THOUSAND) / 100) + '0';
	USNG[42] = ((remainder % 100) / 10) + '0';
	USNG[43] = (remainder % 10) + '0';

	USNG[99] = ' ';
	USNG[100] = ' ';
	USNG[101] = ' ';
	USNG[102] = ' ';
	USNG[103] = ' ';
	USNG[104] = ' ';

	tl = 0;
	for (z = 0; z < ScreenDems; z++)
	{
		w = Associated[z];
		if ((UTMZone == Dem[w].Zone) && (North <= Dem[w].North) && (North > Dem[w].South) && (West >= Dem[w].West) && (West < Dem[w].East))
		{
			x = (West - Dem[w].West) / 30;
			y = (Dem[w].North - North) / 30;
			tl = DemData[z][(y*Dem[w].Cols)+x];
			llElev = DemData[z][((y+1)*Dem[w].Cols)+x];
			lrElev = DemData[z][((y+1)*Dem[w].Cols)+x+1];
			urElev = DemData[z][((y)*Dem[w].Cols)+x+1];
			
			if ((tl != 0x8002) && (llElev != 0x8002) && (lrElev != 0x8002) && (urElev != 0x8002))
			{
				GetPointerElev(w);
				if (Dem[w].Meas == 'M')//in "METERS"
				{
					dElev = (double)tl / 0.3048;
					tl = (int)dElev;
				}
				if (tl > 9999)
					USNG[99] = ((tl % 100000) / 10000) + '0';
				USNG[100] = ((tl % 10000) / 1000) + '0';
				USNG[101] = ((tl % 1000) / 100) + '0';
				USNG[102] = ((tl % 100) / 10) + '0';
				USNG[103] = (tl % 10) + '0';
				USNG[104] = '\'';
			}
		}
	}
}

int CALLBACK GetLocationProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{//new waypoint
	static HWND hwndLocation, hwndIdent;
	RECT dlgRect;
	int dlgWidth, dlgHeight, Xloc, Yloc, number = 0;

	switch (message)
	{
	case WM_INITDIALOG:
		GetWindowRect(hwndDlg, &dlgRect);
		dlgWidth = dlgRect.right-dlgRect.left;
		dlgHeight = dlgRect.bottom-dlgRect.top;
		if (lButtonDotX > (cxScreen - (dlgWidth + 10)))
			Xloc = lButtonDotX - (dlgWidth + 10);
		else
			Xloc = lButtonDotX + 10;
		if (lButtonDotY > (rect.bottom - (dlgHeight - 50)))
			Yloc = lButtonDotY - (dlgHeight - 50);
		else
			Yloc = lButtonDotY;
		MoveWindow(hwndDlg, Xloc, Yloc, dlgWidth, dlgHeight, TRUE);
		hwndLocation = GetDlgItem(hwndDlg, IDC_EDIT1);
		SendMessage(hwndLocation, EM_LIMITTEXT, (WPARAM)100, 0);
		hwndIdent = GetDlgItem(hwndDlg, IDC_EDIT2);
		SendMessage(hwndIdent, EM_LIMITTEXT, (WPARAM)100, 0);
		SetFocus(hwndLocation);
		if (comment[0] != 0)
		{
			SetWindowText(hwndLocation, comment);
			comment[0] = 0;
		}
		if (name[0] != 0)
		{
			SetWindowText(hwndIdent, name);
			name[0] = 0;
		}
		if (fromgotocity)
		{
			fromgotocity = FALSE;
			SetWindowText(hwndLocation, City);
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (GetWindowText(hwndLocation, LocBuf, 100) == 0)
				break;
			GetWindowText(hwndIdent, IdentBuf, 21);//NEW 6 JULY 2006
			newLoc = TRUE;
			EndDialog (hwndDlg, 0);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

int CALLBACK CheckLocationProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{//waypoints
	int x, y;
	int Tabs[1];
	char Way2[] = "   0 Waypoints  -                                 ";
	static HWND hwndList, hwndCheck1, hwndCheck2;
	HDC hdcList;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndList = GetDlgItem(hwndDlg, IDC_LIST1);
		hdcList = GetDC(hwndList);
		hFont = CreateFontIndirect (&lf2);
		SelectObject(hdcList, hFont);
		ReleaseDC(hwndList, hdcList);
		SendMessage(hwndList, WM_SETFONT, (UINT)hFont, TRUE);
		x = FillListBox(hwndDlg);
		Tabs[0] = (longest+1) * 11 / 2;//empirically arrived at
		SendMessage(hwndList, LB_SETTABSTOPS, (WPARAM)1, (LPARAM)&Tabs);
		if (sortbyname)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
		else	
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);

		if (x > 999) Way2[0] = (x / 1000) + '0';
		else Way2[0] = ' ';
		if (x > 99) Way2[1] = ((x % 1000) / 100)+ '0';
		else Way2[1] = ' ';
		if (x > 9) Way2[2] = ((x % 100) / 10) + '0';
		else Way2[2] = ' ';
		if (x > 0) Way2[3] = (x % 10) + '0';
		else Way2[3] = ' ';
		if (x == 0)
			Way2[3] = '0';
		if (x == 1)
			Way2[13] = ' ';
		else
			Way2[13] = 's';
		if (Waypoints[0] == 0)
			for (x = 0, y = 19; (NewLocations[x] != 0) && (y < 50); x++, y++)
				Way2[y] = NewLocations[x];
		else
			for (x = 0, y = 19; (Waypoints[x] != 0) && (y < 50); x++, y++)
				Way2[y] = Waypoints[x];
		SetWindowText(hwndDlg, Way2);

		hwndCheck1 = GetDlgItem(hwndDlg, IDC_CHECK1);
		if (shownamecomment)
			CheckDlgButton (hwndDlg, IDC_CHECK1, BST_CHECKED);
		hwndCheck2 = GetDlgItem(hwndDlg, IDC_CHECK2);
		if (shownamecomment == FALSE)
			showdescription = FALSE;
		else if (showdescription)
			CheckDlgButton (hwndDlg, IDC_CHECK2, BST_CHECKED);
		SetFocus(hwndList);
		if (index != -1)
			SendMessage(hwndList, LB_SETCURSEL, (WPARAM)index, 0);
		ChosenLoc = index;
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_CHECK1:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK1))
			{
				shownamecomment = TRUE;
				CheckMenuItem(hMenu, ID_VIEW_SHOWWAYPOINTNAMES, MF_CHECKED);
			}
			else
			{
				shownamecomment = FALSE;
				showdescription = FALSE;
				CheckDlgButton (hwndDlg, IDC_CHECK2, BST_UNCHECKED);
				CheckMenuItem(hMenu, ID_VIEW_SHOWWAYPOINTNAMES, MF_UNCHECKED);
				SaveDescriptionProc();
			}
			SavenameCommentProc();
			break;

		case IDC_CHECK2:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK2))
			{
				showdescription = TRUE;
				shownamecomment = TRUE;
				CheckDlgButton (hwndDlg, IDC_CHECK1, BST_CHECKED);
				CheckMenuItem(hMenu, ID_VIEW_SHOWWAYPOINTNAMES, MF_CHECKED);
				SavenameCommentProc();
			}
			else
			{
				showdescription = FALSE;
			}
			SaveDescriptionProc();
			break;

		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_DBLCLK)
			{//GoTo
				if (ChosenLoc != -1)
				{
					EndDialog (hwndDlg, 0);
					return TRUE;
				}
			}
			else if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				ChosenLoc = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
				if (NewLoc[ChosenLoc].EUTM == 0)
					ChosenLoc = -1;
			}
			break;

		case IDC_BUTTON1://Edit
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, EDIT);
				return EDIT;
			}
			break;

		case IDC_BUTTON2://Delete
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, DELEET);
				return DELEET;
 			}
			break;

		case IDC_BUTTON3://Line To
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, LINE_TO);
				return LINE_TO;
			}
			break;

		case IDC_BUTTON4://URL Link
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, URL_LINK);
				return URL_LINK;
			}
			break;

		case IDC_RADIO1://Sort by Name
			if (index != -1)
			{
				for (x = 0; x < NewLoc[index].size; x++)
					tempNewLoc[x] = NewLoc[index].pWaypoints[x];
				tempNewLoc[x] = 0;//this is why tempNewLoc is used
				qsort(NewLoc, EmptyLoc, sizeof(NewLoc[0]), compareIdent);
				for (y = 0; y < EmptyLoc; y++)
				{
					for (x = 0; (NewLoc[y].pWaypoints[x] == tempNewLoc[x]) && (x < NewLoc[y].size); x++)
						;
					if (x == NewLoc[y].size)
					{
						index = y;
						break;
					}
				}
				SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
				FillListBox(hwndDlg);
				SendMessage(hwndList, LB_SETCURSEL, (WPARAM)index, 0);//hilight closest waypoint
				ChosenLoc = index;
				SetFocus(hwndList);
				sortbyname = TRUE;
				CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
			}
			break;

		case IDC_RADIO2://Sort by Comment
			if (index != -1)
			{
				for (x = 0; x < NewLoc[index].size; x++)
					tempNewLoc[x] = NewLoc[index].pWaypoints[x];
				tempNewLoc[x] = 0;//this is why tempNewLoc is used
				qsort(NewLoc, EmptyLoc, sizeof(NewLoc[0]), compareLoc);
				for (y = 0; y < EmptyLoc; y++)
				{
					for (x = 0; (NewLoc[y].pWaypoints[x] == tempNewLoc[x]) && (x < NewLoc[y].size); x++)
						;
					if (x == NewLoc[y].size)
					{
						index = y;
						break;
					}
				}
				SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
				FillListBox(hwndDlg);
				SendMessage(hwndList, LB_SETCURSEL, (WPARAM)index, 0);//hilight closest waypoint
				ChosenLoc = index;
				SetFocus(hwndList);
				sortbyname = FALSE;
				CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
			}
			break;

		case IDC_TOGPS:
			onewaypoint = TRUE;
			SendMessage(hwnd, WM_COMMAND, ID_GPS_WAYPOINTS_UPLOAD, 0);
			break;

		case IDOK://GoTo
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, 0);
				return TRUE;
			}
			break;

		case IDCANCEL://Exit
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

int CALLBACK CheckTextProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x;

	switch (message)
	{
	case WM_INITDIALOG:
		for (cur = head; cur != NULL; cur = cur->next)
			SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)cur->text);
		SetWindowText(hwndDlg, "Text Entries");
		SetFocus(GetDlgItem(hwndDlg, IDC_LIST1));
		SendMessage(GetDlgItem(hwndDlg, IDC_LIST1), LB_SETCURSEL, (WPARAM)index, 0);
		ChosenLoc = index;
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				ChosenLoc = SendMessage(GetDlgItem(hwndDlg, IDC_LIST1), LB_GETCURSEL, 0, 0);
				for (x = 0, cur = head; x < ChosenLoc; x++, cur = cur->next)
					;
				chosen = cur;
				break;
			}
			else if (HIWORD (wParam) == LBN_DBLCLK)
			{
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else
				break;

		case IDC_BUTTON1://Edit
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, EDIT);
				return EDIT;
			}
			else
				break;

		case IDC_BUTTON2://Delete
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, DELEET);
				return DELEET;
 			}
			else break;

		case IDC_BUTTON3://Line To
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, LINE_TO);
				return LINE_TO;
			}
			else break;

		case IDOK://GoTo
			if (ChosenLoc != -1)
			{
				EndDialog (hwndDlg, 0);
				return TRUE;
			}

		case IDCANCEL://Exit
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

int CALLBACK EditLocationProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, y;
	char LatLon[16];
	static HWND hwndLocation, hwndLocation2, hwndLocation3, hwndLat, hwndLon;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndLocation = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndLocation2 = GetDlgItem(hwndDlg, IDC_EDIT2);
		hwndLocation3 = GetDlgItem(hwndDlg, IDC_EDIT3);
		hwndLat = GetDlgItem(hwndDlg, IDC_EDIT4);
		hwndLon = GetDlgItem(hwndDlg, IDC_EDIT5);
		//the following is so 6 digits are guaranteed to fit in IDC_EDIT2
		lf.lfHeight = -13;
		lf.lfWeight = 400;
		lf.lfEscapement = lf.lfOrientation = 0;
		hFont = CreateFontIndirect (&lf);
		SelectObject (hdc, hFont);
		SendMessage(hwndLocation, WM_SETFONT, (UINT)hFont, TRUE);
		SendMessage(hwndLocation2, WM_SETFONT, (UINT)hFont, TRUE);
		hFont2 = CreateFontIndirect (&lf3);
		SelectObject (hdc, hFont2);
		SendMessage(hwndLocation3, WM_SETFONT, (UINT)hFont2, TRUE);
		SendMessage(hwndLocation, EM_LIMITTEXT, (WPARAM)100, 0);
		SendMessage(hwndLocation2, EM_LIMITTEXT, (WPARAM)100, 0);
		SendMessage(hwndLocation3, EM_LIMITTEXT, (WPARAM)10000, 0);
		if (NewLoc[ChosenLoc].Location != NULL)
		{
			for (y = 0; (NewLoc[ChosenLoc].Location[y] != 0) && (NewLoc[ChosenLoc].Location[y] != '<'); y++)
				Location[y] = NewLoc[ChosenLoc].Location[y];
			Location[y] = 0;
			SetWindowText(hwndLocation, Location);
		}
		if (NewLoc[ChosenLoc].Ident != NULL)
		{
			for (x = 0; (NewLoc[ChosenLoc].Ident[x] != 0) && (NewLoc[ChosenLoc].Ident[x] != '<'); x++)
				Ident[x] = NewLoc[ChosenLoc].Ident[x];
			Ident[x] = 0;
			SetWindowText(hwndLocation2, Ident);
		}
		if (NewLoc[ChosenLoc].Description != NULL)
		{
			for (x = 0; (NewLoc[ChosenLoc].Description[x] != 0) && (NewLoc[ChosenLoc].Description[x] != '<'); x++)
				Description[x] = NewLoc[ChosenLoc].Description[x];
			Description[x] = 0;
			SetWindowText(hwndLocation3, Description);
		}

		for (x = 10, y = 0; NewLoc[ChosenLoc].pWaypoints[x] != '"'; x++, y++)
			LatLon[y] = NewLoc[ChosenLoc].pWaypoints[x];
		LatLon[y] = 0;
		SetWindowText(hwndLat, LatLon);
		x += 7;
		for (y = 0; NewLoc[ChosenLoc].pWaypoints[x] != '"'; x++, y++)
			LatLon[y] = NewLoc[ChosenLoc].pWaypoints[x];
		LatLon[y] = 0;
		SetWindowText(hwndLon, LatLon);
		SetFocus(hwndLocation);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (GetWindowText(hwndLocation, LocBuf, 100) == 0)
			{
				if (GetWindowText(hwndLocation3, DescBuf, 10000) == 0)
					break;//one of the two have to be there
			}
			else
				GetWindowText(hwndLocation3, DescBuf, 10000);
			GetWindowText(hwndLocation2, IdentBuf, 21);//NEW 6 JUL 2006
/*
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			if (GetWindowText(hwndLat, Error, 300))
				Lat = atof(Error);
			if (GetWindowText(hwndLon, Error, 300))
				Lon = atof(Error);
			LatRad = Lat * deg2rad;
			LonRad = Lon * deg2rad;
			LatLontoUTM();
			if ((NewLoc[ChosenLoc].NUTM != UTMNorthing) || (NewLoc[ChosenLoc].EUTM != UTMEasting))
			{
				NewLoc[ChosenLoc].NUTM = UTMNorthing;
				NewLoc[ChosenLoc].EUTM = UTMEasting;
				NewLoc[ChosenLoc].UTMZone = UTMZone;
				newLoc = TRUE;
			}
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
*/
			EndDialog (hwndDlg, 0);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

int CALLBACK AddressProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, y, z, gotenough = 0;
	static HWND hwndAddress, hwndCity, hwndState, hwndZIP;

	switch (message)
	{
	case WM_INITDIALOG:
		gotaddr = gotcity = gotzip = 0;
		hwndAddress = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndCity = GetDlgItem(hwndDlg, IDC_EDIT2);
		hwndState = GetDlgItem(hwndDlg, IDC_EDIT3);
		hwndZIP = GetDlgItem(hwndDlg, IDC_EDIT4);
		SetFocus(hwndAddress);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			x = 52;
			z = GetWindowText(hwndAddress, Address, 100);
			if ((z != 0) && (z < 100))
			{
				gotaddr = TRUE;
				for (y = 0; Address[y] != 0; x++, y++)
					Address1[x] = Address[y];
			}
			for (y = 0; Address2[y] != 0; x++, y++)
				Address1[x] = Address2[y];

			z = GetWindowText(hwndCity, xCity, 100);
			if ((z != 0) && (z < 100))
			{
				if (gotaddr == FALSE)
					gotcity = TRUE;
				for (y = 0; xCity[y] != 0; x++, y++)
					Address1[x] = xCity[y];
				gotenough = 1;
			}
			for (y = 0; Address3[y] != 0; x++, y++)
				Address1[x] = Address3[y];

			z = GetWindowText(hwndState, State, 20);
			if ((z != 0) && (z < 20))
			{
				for (y = 0; State[y] != 0; x++, y++)
					Address1[x] = State[y];
				gotenough += 1;
			}
			for (y = 0; Address4[y] != 0; x++, y++)
				Address1[x] = Address4[y];

			z = GetWindowText(hwndZIP, ZIP, 10);
			if ((z != 0) && (z < 10))
			{
				if ((gotcity == FALSE) && (gotaddr == FALSE))
					gotzip = TRUE;
				for (y = 0; ZIP[y] != 0; x++, y++)
					Address1[x] = ZIP[y];
				gotenough = 2;
			}
			for (y = 0; Address5[y] != 0; x++, y++)
				Address1[x] = Address5[y];

			if (gotenough == 2)
			{
				for (x = 0; Address1[x] != 0; x++)
					if (Address1[x] == ' ')
						Address1[x] = '+';
			}
			EndDialog (hwndDlg, 0);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

void SetRegKey(int wParameter)
{
	int x;
	if ((autoLoc == FALSE) && ((NewComm[7] != RegValue[3]) || (NewComm[8] != RegValue[4])) && (goodcomm == FALSE))//don't change after comm port open & used
	{
		RegValue[3] = NewComm[7];
		RegValue[4] = NewComm[8];
		if (RegValue[4] == 0)
			RegValue[4] = ' ';
		if (itsgarmin)
			pProtocol = GARMIN;
		else if (itsusb)
			pProtocol = USB;
		else if (itsexplorist)
			pProtocol = EXPL;
		else
			pProtocol = NMEA;
		for (x = 0; x < 6; x++)
			RegValue[x+5] = pProtocol[x];
		if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, SubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRegKey, &RegKeyResult))
		{
			RegSetValueEx(hRegKey, NULL, 0, REG_SZ, RegValue, RegValueSize);
			RegFlushKey(hRegKey);
			RegCloseKey(hRegKey);
		}
		else
			MessageBox(hwnd, Registry, ERROR, MB_OK);
	}
	else if (goodcomm)
		MessageBox(hwnd, "You can't change the comm port after it's been used successfully.\nClose the program and reopen it to change the comm port.", "", MB_OK);
}

void SetRegKey2(char *Prot, int wParameter)
{
	int x;
	CheckMenuItem (hMenu, ProtocolCheck1, MF_UNCHECKED);
	CheckMenuItem (hMenu, ProtocolCheck2, MF_UNCHECKED);
	CheckMenuItem (hMenu, ProtocolCheck3, MF_UNCHECKED);
	ProtocolCheck1 = wParameter;
	CheckMenuItem (hMenu, ProtocolCheck1, MF_CHECKED);
	RegValueSize = 21;//in case it was previously just 'COM1'
	for (x = 0; x < 6; x++)
		RegValue[x+5] = Prot[x];
	if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, SubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRegKey, &RegKeyResult))
	{
		RegSetValueEx(hRegKey, NULL, 0, REG_SZ, RegValue, RegValueSize);
		RegFlushKey(hRegKey);
		RegCloseKey(hRegKey);
	}
	else
		MessageBox(hwnd, Registry, ERROR, MB_OK);
}

void ShowDistance(int distance, int x, int y)
{
	char dist[5];
	int remainder;

	if (distance < 10)//1.0 miles
	{
		dist[0] = '0';
		dist[1] = '.';
		dist[2] = distance + '0';
		TextOut(hdc, x, y, dist, 3);
	}
	else if (distance < 100)
	{
		dist[0] = (distance / 10) + '0';
		dist[1] = '.';
		dist[2] = (distance % 10) + '0';
		TextOut(hdc, x, y, dist, 3);
	}
	else if (distance < 1000)
	{
		remainder = distance % 100;
		dist[0] = (distance / 100) + '0';
		dist[1] = ((remainder % 100) / 10) + '0';
		dist[2] = '.';
		dist[3] = (remainder % 10) + '0';
		TextOut(hdc, x, y, dist, 4);
	}
	else if (distance < 10000)
	{
		remainder = distance % 1000;
		dist[0] = (distance / 1000) + '0';
		dist[1] = ((remainder % 1000) / 100) + '0';
		dist[2] = ((remainder % 100) / 10) + '0';
		dist[3] = '.';
		dist[4] = (remainder % 10) + '0';
		TextOut(hdc, x, y, dist, 5);
	}
}

void ShowNearest(int nearest)
{
	int x, y, remainder;

	nearest /= 100;
	if (nearest < 10)
	{
		Nearest[20] = ' ';
		Nearest[21] = '0';
		Nearest[22] = '.';
		Nearest[23] = nearest + '0';
	}
	else if (nearest < 100)
	{
		Nearest[20] = ' ';
		Nearest[21] = (nearest / 10) + '0';
		Nearest[22] = '.';
		Nearest[23] = (nearest % 10) + '0';
	}
	else if (nearest < 1000)
	{
		remainder = nearest % 100;
		Nearest[20] = (nearest / 100) + '0';
		Nearest[21] = (remainder / 10) + '0';
		Nearest[22] = '.';
		Nearest[23] = (remainder % 10) + '0';
	}
	Nearest[26] = 't';
	Nearest[27] = 'o';
	if ((showname == FALSE) && (NewLoc[ChosenLoc].Location != NULL))
	{
		for (x = 0, y = 30; NewLoc[ChosenLoc].Location[x] != '<'; x++, y++)
		{
			if (NewLoc[ChosenLoc].Location[x] != 0)
				Nearest[y] = NewLoc[ChosenLoc].Location[x];
			else Nearest[y] = ' ';
		}
	}
	else if ((showname == TRUE) && (NewLoc[ChosenLoc].Ident != NULL))
	{
		for (x = 0, y = 30; NewLoc[ChosenLoc].Ident[x] != '<'; x++, y++)
		{
			if (NewLoc[ChosenLoc].Ident[x] != 0)
				Nearest[y] = NewLoc[ChosenLoc].Ident[x];
			else Nearest[y] = ' ';
		}
	}
	else
		for (y = 0; y < 30; y++)
			Nearest[y] = ' ';
	for ( ; y < 63; y++)
		Nearest[y] = ' ';
}

//from http://www.gpsy.com/gpsinfo/geotoutm/index.html
void LatLontoUTM(void)
{
	int UTMZoneMinusOne;
	double LongTemp, LongOrigin, LongOriginRad, N, T, C, A, M;

//Make sure the longitude is between -180.00 .. 179.9
	LongTemp = (Lon + 180) - (int)((Lon + 180) / 360) * 360 - 180; // -180.00 .. 179.9;
	UTMZoneMinusOne = (int)((LongTemp + 180) / 6);
	UTMZone = UTMZoneMinusOne + 1;
	LongOrigin = (UTMZoneMinusOne) * 6 - 180 + 3;  //+3 puts origin in middle of zone
	LongOriginRad = LongOrigin * deg2rad;

	N = a0/sqrt(1-ECC_SQUARED*sin(LatRad)*sin(LatRad));
	T = tan(LatRad)*tan(LatRad);
	C = eccPrimeSquared*cos(LatRad)*cos(LatRad);
	A = cos(LatRad)*(LonRad-LongOriginRad);
	M = a0*((1	- ECC_SQUARED/4		- 3*ECC_SQUARED*ECC_SQUARED/64	- 5*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/256)*LatRad
 				- (3*ECC_SQUARED/8	+ 3*ECC_SQUARED*ECC_SQUARED/32	+ 45*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/1024)*sin(2*LatRad)
 									+ (15*ECC_SQUARED*ECC_SQUARED/256 + 45*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/1024)*sin(4*LatRad)
 									- (35*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/3072)*sin(6*LatRad));
	
	Easting = (k0*N*(A+(1-T+C)*A*A*A/6
					+ (5-18*T+T*T+72*C-58*eccPrimeSquared)*A*A*A*A*A/120)
					+ 500000.0);
	Northing = (k0*(M+N*tan(LatRad)*(A*A/2+(5-T+9*C+4*C*C)*A*A*A*A/24
				 + (61-58*T+T*T+600*C-330*eccPrimeSquared)*A*A*A*A*A*A/720)));
	UTMEasting = (int)Easting;
	if (modf(Easting, &N) >= 0.500)
		UTMEasting += 1;
	UTMNorthing = (int)Northing;
	if (modf(Northing, &N) >= 0.500)
		UTMNorthing += 1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////

//from http://www.gpsy.com/gpsinfo/geotoutm/index.html
void UTMtoLatLon(void)
{
	double N1, T1, C1, R1, D, M, LongOrigin, mu, phi1, phi1Rad;
	double e1 = (1-sqrt(1-ECC_SQUARED))/(1+sqrt(1-ECC_SQUARED));

	LongOrigin = (UTMZone - 1)*6 - 180 + 3;  //+3 puts origin in middle of zone
	M = UTMNorthing / k0;
	mu = M/(a0*(1-ECC_SQUARED/4-3*ECC_SQUARED*ECC_SQUARED/64-5*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/256));
	phi1Rad = mu	+ (3*e1/2-27*e1*e1*e1/32)*sin(2*mu)
 					+ (21*e1*e1/16-55*e1*e1*e1*e1/32)*sin(4*mu)
					+(151*e1*e1*e1/96)*sin(6*mu);
	phi1 = phi1Rad*rad2deg;
	N1 = a0/sqrt(1-ECC_SQUARED*sin(phi1Rad)*sin(phi1Rad));
	T1 = tan(phi1Rad)*tan(phi1Rad);
	C1 = eccPrimeSquared*cos(phi1Rad)*cos(phi1Rad);
	R1 = a0*(1-ECC_SQUARED)/pow(1-ECC_SQUARED*sin(phi1Rad)*sin(phi1Rad), 1.5);
	D = (UTMEasting - 500000.0)/(N1*k0);//remove 500,000 meter offset for longitude

	Lat = phi1Rad - (N1*tan(phi1Rad)/R1)*(D*D/2-(5+3*T1+10*C1-4*C1*C1-9*eccPrimeSquared)*D*D*D*D/24
					+(61+90*T1+298*C1+45*T1*T1-252*eccPrimeSquared-3*C1*C1)*D*D*D*D*D*D/720);
	Lat = Lat * rad2deg;

	Lon = (D-(1+2*T1+C1)*D*D*D/6+(5-2*C1+28*T1-3*C1*C1+8*eccPrimeSquared+24*T1*T1)
					*D*D*D*D*D/120)/cos(phi1Rad);
	Lon = LongOrigin + Lon * rad2deg;
}

void RedDot(HWND hwnd)
{
	DotX = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
	DotY = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
	hRedBrush = CreateSolidBrush(RED);
	hObject = SelectObject(hdcMem, hRedBrush);
	Ellipse(hdcMem, DotX-DotRadius, DotY-DotRadius, DotX+DotRadius, DotY+DotRadius);
	SelectObject(hdc, hObject);
	DeleteObject(hRedBrush);
}

int PrepTrack(void)
{
	int x, z;
	float Unknown = (float)1.0e25;//"\x51\x59\x04\x69";

	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;
	x = 0;
	trak[0].newtrk = 1;//for concatenated tracks
	if (itsusb == FALSE)
	{
		DLECount = 0;//for extra DLE's
		SendTrack[x++] = DLE;
		SendTrack[x++] = TRACK;
		SendTrack[x++] = 13;//this is changed below!!
	}
	UTMNorthing = trak[TrackNum].NUTM;
	UTMEasting = trak[TrackNum].EUTM;
	if (trak[TrackNum].time >= 0x10000000 )//if new format
		UTMZone = trak[TrackNum].time >> 26;
	UTMtoLatLon();
	semicircleN = (int)(Lat * deg2semicircle);
	semicircleE = (int)(Lon * deg2semicircle);
	for (z = 0; z < 4; z++, x++)
	{
		SendTrack[x] = semicircleN & 0xFF;
		semicircleN >>= 8;
		if ((SendTrack[x] == DLE) && (itsusb == FALSE))
		{
			DLECount++;
			x++;
			SendTrack[x] = DLE;
		}
	}
	for (z = 0; z < 4; x++, z++)
	{
		SendTrack[x] = semicircleE & 0xFF;
		semicircleE >>= 8;
		if ((SendTrack[x] == DLE) && (itsusb == FALSE))
		{
			DLECount++;
			x++;
			SendTrack[x] = DLE;
		}
	}
	for (z = 0; z < 4; z++, x++)
		SendTrack[x] = 0;//time
	if ((d301) || (302))
	{
		*(float*)&SendTrack[x] = Unknown;
		x += 4;
		*(float*)&SendTrack[x] = Unknown;
		x += 4;
	}
	if (d302)
	{
		*(float*)&SendTrack[x] = Unknown;
		x += 4;
	}
	SendTrack[x++] = trak[TrackNum].newtrk;

	if (itsusb == FALSE)
	{
		SendTrack[2] = x-3-DLECount;
		checksum = 0;
		for (z = 1; z < x; z++)
		{
			if ((SendTrack[z] == DLE) && (itsusb == FALSE))
				z++;//ignore first DLE
				checksum += SendTrack[z];
		}
		SendTrack[x++] = ~(checksum) + 1;
		if (SendTrack[x-1] == DLE)
			SendTrack[x++] = DLE;
		SendTrack[x++] = DLE;
		SendTrack[x++] = ETX;
	}
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
	return x;
}

int PutSemicircles(int x)
{
	int z;
	if (sendingroute)
	{
		UTMEasting = Root[0][TrackNum].E;
		UTMNorthing = Root[0][TrackNum].N;
		UTMZone = Root[0][TrackNum].Z;
	}
	else
	{
		UTMEasting = NewLoc[LocNum].EUTM;
		UTMNorthing = NewLoc[LocNum].NUTM;
		UTMZone = NewLoc[LocNum].UTMZone;
	}
	UTMtoLatLon();

	semicircleN = (int) (Lat / semicircle2deg);
	semicircleE = (int) (Lon / semicircle2deg);
	for (z = 0; z < 4; z++, x++)
	{
		Waypoint[x] = semicircleN & 0xFF;
		if ((Waypoint[x] == DLE) && (itsusb == FALSE))
		{
			DLECount++;
			x++;
			Waypoint[x] = DLE;
		}
		semicircleN >>= 8;
	}
	for (z = 0; z < 4; z++, x++)
	{
		Waypoint[x] = semicircleE & 0xFF;
		if ((Waypoint[x] == DLE) && (itsusb == FALSE))
		{
			DLECount++;
			x++;
			Waypoint[x] = DLE;
		}
		semicircleE >>= 8;
	}
	return x;
}

void PrepWaypoint(void)
{//108: waypoint class, color, display options, attribute
	static unsigned char FirstPart[] =	"\x00\xFF\x00\x60";
//109: data type, waypoint class, color, attribute
	static unsigned char FirstPart2[] = "\x01\x00\x1F\x70";
	static unsigned char Subclass[] = "\x00\x00\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
	static unsigned char SecondPart[] = "\x51\x59\x04\x69";//unknown alt/depth/prox dist
	int x, z;
	unsigned char ch;
	union {
		float Float;
		int Int;
	} elev;
	DLECount = 0;//for extra DLE's
	for (x = 0; x < WAYPOINT_SIZE; x++)
		Waypoint[x] = 0;
	x = 0;
	if (itsusb == FALSE)
	{
		Waypoint[x++] = DLE;
		Waypoint[x++] = WAYPOINT;
		Waypoint[x++] = 0x41;//this is changed below!!
	}
	if (WaypointProt == 108)
	{
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = FirstPart[z];
		if (NewLoc[LocNum].Sym == NULL)
		{
			Waypoint[x++] = 18;//symbol type
			Waypoint[x++] = 0;
		}
		else
		{
			for (z = 0; NewLoc[LocNum].Sym[z] != '<'; z++)
				Sym[z] = NewLoc[LocNum].Sym[z];
			Sym[z] = 0;
			z = GarminSym();//convert 'waypoint' to 18 or whatever
			if (z < 8192)//0x2000
			{
				Waypoint[x++] = z;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
				Waypoint[x++] = 0;
			}
			else if (z <= 8254)
			{
				Waypoint[x++] = 0x20;
				Waypoint[x++] = 0x2000 - z;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
			}
			else if (z <= 16402)
			{
				Waypoint[x++] = 0x40;
				Waypoint[x++] = 0x4000 - z;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
			}
		}
		for (z = 0; z < 18; x++, z++)
			Waypoint[x] = Subclass[z];

		x = PutSemicircles(x);

		if (NewLoc[LocNum].Elev == NULL)
			for (z = 0; z < 4; x++, z++)
				Waypoint[x] = SecondPart[z];//(float)alt
		else
		{
			for (z = 0; NewLoc[LocNum].Elev[z] != '<'; z++)
				Elev[z] = NewLoc[LocNum].Elev[z];
			Elev[z] = 0;
			elev.Float = (float)atof(Elev);
			Waypoint[x++] = elev.Int & 0xFF;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
			Waypoint[x++] = (elev.Int & 0xFF00) >> 8;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
			Waypoint[x++] = (elev.Int & 0xFF0000) >> 16;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
			Waypoint[x++] = (elev.Int & 0xFF000000) >> 24;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
		}
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = SecondPart[z];//(float)depth
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = SecondPart[z];//(float)prox dist
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = ' ';//unknown state & country code
		if ((NewLoc[LocNum].Ident != NULL) && (NewLoc[LocNum].Ident[0] != 0))
		{//send (GPS) name
			for (z = 0; (NewLoc[LocNum].Ident[z] != '<') || (NewLoc[LocNum].Ident[z+1] != '/'); x++, z++)
			{
				ch = NewLoc[LocNum].Ident[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				Waypoint[x] = ch;
			}
		}
		else
		{
			for (z = 0; (NewLoc[LocNum].Location[z] != '<') || (NewLoc[LocNum].Location[z+1] != '/'); x++, z++)
			{
				ch = NewLoc[LocNum].Location[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				Waypoint[x] = ch;
			}
		}
		Waypoint[x++] = 0;
		if ((NewLoc[LocNum].Location != NULL) && (NewLoc[LocNum].Location[0] != 0))
		{//send cmt
			for (z = 0; (NewLoc[LocNum].Location[z] != '<') || (NewLoc[LocNum].Location[z+1] != '/'); x++, z++)
			{
				ch = NewLoc[LocNum].Location[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				Waypoint[x] = ch;
			}
		}
		Waypoint[x++] = 0;
		Waypoint[x++] = 0;//facility
		Waypoint[x++] = 0;//city
		Waypoint[x++] = 0;//addr
		Waypoint[x++] = 0;//cross road
	}

	else if ((WaypointProt == 109) || (WaypointProt == 110))
	{
		if (WaypointProt == 110)
			FirstPart2[3] = 0x80;
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = FirstPart2[z];
		if (NewLoc[LocNum].Sym == NULL)
		{
			Waypoint[x++] = 18;//symbol type
			Waypoint[x++] = 0;
		}
		else
		{
			for (z = 0; NewLoc[LocNum].Sym[z] != '<'; z++)
				Sym[z] = NewLoc[LocNum].Sym[z];
			Sym[z] = 0;
			z = GarminSym();//convert 'waypoint' to 18 or whatever
			if (z < 8192)//0x2000
			{
				Waypoint[x++] = z;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
				Waypoint[x++] = 0;
			}
			else if (z <= 8254)
			{
				Waypoint[x++] = 0x20;
				Waypoint[x++] = 0x2000 - z;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
			}
			else if (z <= 16402)
			{
				Waypoint[x++] = 0x40;
				Waypoint[x++] = 0x4000 - z;
				if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
				{
					Waypoint[x++] = DLE;
					DLECount++;
				}
			}
		}
		for (z = 0; z < 18; x++, z++)
			Waypoint[x] = Subclass[z];
		x = PutSemicircles(x);
		if (NewLoc[LocNum].Elev == NULL)
			for (z = 0; z < 4; x++, z++)
				Waypoint[x] = SecondPart[z];//(float)alt
		else
		{
			for (z = 0; NewLoc[LocNum].Elev[z] != '<'; z++)
				Elev[z] = NewLoc[LocNum].Elev[z];
			Elev[z] = 0;
			elev.Float = (float)atof(Elev);
			Waypoint[x++] = elev.Int & 0xFF;
			if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
			{
				Waypoint[x++] = DLE;
				DLECount++;
			}
			Waypoint[x++] = (elev.Int & 0xFF00) >> 8;
			if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
			{
				Waypoint[x++] = DLE;
				DLECount++;
			}
			Waypoint[x++] = (elev.Int & 0xFF0000) >> 16;
			if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
			{
				Waypoint[x++] = DLE;
				DLECount++;
			}
			Waypoint[x++] = (elev.Int & 0xFF000000) >> 24;
			if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
			{
				Waypoint[x++] = DLE;
				DLECount++;
			}
		}
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = SecondPart[z];//(float)depth
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = SecondPart[z];//(float)prox dist
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = ' ';//state & cc
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = '\xFF';//ete
		if (WaypointProt == 110)
		{
			for (z = 0; z < 4; x++, z++)
				Waypoint[x] = SecondPart[z];//temp
			for (z = 0; z < 4; x++, z++)
				Waypoint[x] = 0xFF;//time
			Waypoint[x++] = 0;//wpt_cat
			Waypoint[x++] = 0;//wpt_cat
		}
		if ((NewLoc[LocNum].Ident != NULL) && (NewLoc[LocNum].Ident[0] != 0))
		{//send (GPS) name
			for (z = 0; (NewLoc[LocNum].Ident[z] != '<') || (NewLoc[LocNum].Ident[z+1] != '/'); x++, z++)
			{
				ch = NewLoc[LocNum].Ident[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				Waypoint[x] = ch;
			}
		}
		else
		{
			for (z = 0; (NewLoc[LocNum].Location[z] != '<') || (NewLoc[LocNum].Location[z+1] != '/'); x++, z++)
			{
				ch = NewLoc[LocNum].Location[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				Waypoint[x] = ch;
			}
		}
		Waypoint[x++] = 0;
		if ((NewLoc[LocNum].Location != NULL) && (NewLoc[LocNum].Location[0] != 0))
		{//send cmt
			for (z = 0; (NewLoc[LocNum].Location[z] != '<') || (NewLoc[LocNum].Location[z+1] != '/'); x++, z++)
			{
				ch = NewLoc[LocNum].Location[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				Waypoint[x] = ch;
			}
		}
		Waypoint[x++] = 0;
		Waypoint[x++] = 0;
		Waypoint[x++] = 0;
		Waypoint[x++] = 0;
		Waypoint[x++] = 0;
	}

	else//all others
	{
//		for (z = 0; NewLoc[LocNum].Elev[z] != '<'; z++)
//			Elev[z] = NewLoc[LocNum].Elev[z];
//		Elev[z] = 0;
//		elev.Float = (float)atof(Elev);
//		z = elev.Int;
		z = 0;
		if ((NewLoc[LocNum].Ident != NULL) && (NewLoc[LocNum].Ident[0] != 0))
		{
			for ( ; (z < 6) && ((NewLoc[LocNum].Ident[z] != '<') || (NewLoc[LocNum].Ident[z+1] != '/')); z++, x++)
			{
				ch = NewLoc[LocNum].Ident[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				if ((ch == ' ') || (ch == '-') || ((ch >= 'A') && (ch <= 'Z')) || ((ch >= '0') && (ch <= '9')))
					Waypoint[x] = ch;
			}
		}
		else if ((NewLoc[LocNum].Location != NULL) && (NewLoc[LocNum].Location[0] != 0))
			for ( ; (z < 6) && ((NewLoc[LocNum].Location[z] != '<') || (NewLoc[LocNum].Location[z+1] != '/')); z++, x++)
			{
				ch = NewLoc[LocNum].Location[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				if ((ch == ' ') || (ch == '-') || ((ch >= 'A') && (ch <= 'Z')) || ((ch >= '0') && (ch <= '9')))
					Waypoint[x] = ch;
			}
		for ( ; z < 6; z++, x++)
			Waypoint[x] = ' ';

		x = PutSemicircles(x);//Lat/Lon

		for (z = 0; z < 4; z++, x++)
			Waypoint[x] = 0;//unused
		z = 0;
		if ((NewLoc[LocNum].Location != NULL) && (NewLoc[LocNum].Location[0] != 0))
			for ( ; (NewLoc[LocNum].Location[z] != '<') || (NewLoc[LocNum].Location[z+1] != '/'); z++, x++)
			{
				ch = NewLoc[LocNum].Location[z];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				Waypoint[x] = ch;
			}
		if ((WaypointProt == 104) || (WaypointProt == 103))
		{
			for ( ; z < 40; z++, x++)
				Waypoint[x] = ' ';
			if (WaypointProt == 104)
				for (z = 0; z < 4; z++, x++)
					Waypoint[x] = 0;//proximity distance, whatever that is
			if (NewLoc[LocNum].Sym == NULL)
			{
				Waypoint[x++] = 18;//symbol type
				if (WaypointProt == 104)
					Waypoint[x++] = 0;
			}
			else if (WaypointProt != 104)
				Waypoint[x++] = 18;
			else
			{
				for (z = 0; NewLoc[LocNum].Sym[z] != '<'; z++)
					Sym[z] = NewLoc[LocNum].Sym[z];
				Sym[z] = 0;
				z = GarminSym();//convert 'waypoint' to 18 or whatever
				if (z < 8192)//0x2000
				{
					Waypoint[x++] = z;
					if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
					{
						Waypoint[x++] = DLE;
						DLECount++;
					}
					Waypoint[x++] = 0;
				}
				else if (z <= 8254)
				{
					Waypoint[x++] = 0x20;
					Waypoint[x++] = 0x2000 - z;
					if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
					{
						Waypoint[x++] = DLE;
						DLECount++;
					}
				}
				else if (z <= 16402)
				{
					Waypoint[x++] = 0x40;
					Waypoint[x++] = 0x4000 - z;
					if ((Waypoint[x-1] == DLE) && (itsusb == FALSE))
					{
						Waypoint[x++] = DLE;
						DLECount++;
					}
				}
			}
			Waypoint[x++] = 3;//show symbol & ident (display option)
		}
	}
	if (itsusb == FALSE)
	{
		Waypoint[2] = x-3-DLECount;
		checksum = 0;
		for (z = 1; z < x; z++)
		{
			if (Waypoint[z] == DLE)
				z++;//ignore first DLE
			checksum += Waypoint[z];
		}
		Waypoint[x++] = ~(checksum) + 1;
		if (Waypoint[x-1] == DLE)
			Waypoint[x++] = DLE;
		Waypoint[x++] = DLE;
		Waypoint[x++] = ETX;
	}
	SendWaypointSize = x;//end of PrepWaypoint
}

void PrepRoute(void)
{//108: waypoint class, color, display options, attribute, waypoint symbol(2), subclass(18)
	static unsigned char FirstPart[] =  "\x00\xFF\x00\x60\x12\x00\x00\x00\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
//109: data type, waypoint class, color, attribute, waypoint symbol(2), subclass(18)
	static unsigned char FirstPart2[] = "\x01\x00\x1F\x70\x12\x00\x00\x00\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
	static unsigned char SecondPart[] = "\x51\x59\x04\x69";//unknown alt/depth/prox dist
	int x, y, z;
	char ch;
	BOOL gotit = FALSE;

	DLECount = 0;//for extra DLE's
	for (x = 0; x < WAYPOINT_SIZE; x++)
		Waypoint[x] = 0;
	x = 0;
	if (itsusb == FALSE)
	{
		Waypoint[x++] = DLE;
		Waypoint[x++] = ROUTE;
		Waypoint[x++] = 0x41;//this is changed below!!
	}
	if (WaypointProt >= 108)
	{
		if (WaypointProt == 108)
			for (z = 0; z < 24; x++, z++)
				Waypoint[x] = FirstPart[z];
		else if (WaypointProt >= 109)
			for (z = 0; z < 24; x++, z++)
				Waypoint[x] = FirstPart2[z];

		x = PutSemicircles(x);

		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = SecondPart[z];//(float)alt
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = SecondPart[z];//(float)depth
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = SecondPart[z];//(float)prox dist
		for (z = 0; z < 4; x++, z++)
			Waypoint[x] = ' ';//unknown state & country code
		if (WaypointProt >= 109)
			for (z = 0; z < 4; x++, z++)
				Waypoint[x] = '\xFF';
		if (WaypointProt == 110)
		{
			for (z = 0; z < 4; x++, z++)
				Waypoint[x] = SecondPart[z];//(float)temp
			for (z = 0; z < 4; x++, z++)
				Waypoint[x] = '\xFF';//(longword)time
			for (z = 0; z < 2; x++, z++)
				Waypoint[x] = 0;//(int)wpt_cat
		}
		Radius = DotRadius*MetersPerTile/PixelsPerTile;
		for (z = 0; NewLoc[z].EUTM != 0; z++)
		{
			if ((UTMZone == NewLoc[z].UTMZone)
			 && (UTMEasting < (NewLoc[z].EUTM + Radius))
			 && (UTMEasting > (NewLoc[z].EUTM - Radius))
			 && (UTMNorthing < (NewLoc[z].NUTM + Radius))
			 && (UTMNorthing > (NewLoc[z].NUTM - Radius)))
			{
				gotit = TRUE;
				break;
			}
		}
		if ((gotit == FALSE) || (NewLoc[z].Ident == NULL) || (NewLoc[z].Ident[0] == 0))
		{
			for (y = 0; y < 6; y++, x++)
				Waypoint[x] = Num[y];//ident
		}
		else//if ((NewLoc[z].Ident != NULL) && (NewLoc[z].Ident[0] != 0))
		{
			for (y = 0; ((NewLoc[z].Ident[y] != '<') || (NewLoc[z].Ident[y+1] != '/')); x++, y++)
			{
				ch = NewLoc[z].Ident[y];
				if ((ch >= 'a') && (ch <= 'z'))
					ch &= 0xDF;//make uppercase
				if ((ch == ' ') || (ch == '-') || ((ch >= 'A') && (ch <= 'Z')) || ((ch >= '0') && (ch <= '9')))
					Waypoint[x] = ch;
			}
		}
		Waypoint[x++] = 0;
		Waypoint[x++] = 0;//Comment
		Waypoint[x++] = 0;//Facility
		Waypoint[x++] = 0;//City
		Waypoint[x++] = 0;//Address
		Waypoint[x++] = 0;//Cross-road
	}
	else if (WaypointProt != 0)
	{
		for (z = 0; z < 6; z++, x++)
			Waypoint[x] = Num[z];//ident

		x = PutSemicircles(x);//Lat/Lon

		for (z = 0; z < 4; z++, x++)
			Waypoint[x] = 0;//unused
		for ( ; z < 40; z++, x++)
			Waypoint[x] = ' ';
		if (WaypointProt == 104)
			for (z = 0; z < 4; z++, x++)
				Waypoint[x] = 0;//proximity distance, whatever that is
		Waypoint[x++] = 18;//symbol
		if (WaypointProt == 104)
			Waypoint[x++] = 0;//second part of symbol
		Waypoint[x++] = 3;//dspl
	}
	if (itsusb == FALSE)
	{
		Waypoint[2] = x-3-DLECount;
		checksum = 0;
		for (z = 1; z < x; z++)
		{
			if (Waypoint[z] == DLE)
				z++;//ignore first DLE
			checksum += Waypoint[z];
		}
		Waypoint[x++] = ~(checksum) + 1;
		if (Waypoint[x-1] == DLE)
			Waypoint[x++] = DLE;
		Waypoint[x++] = DLE;
		Waypoint[x++] = ETX;
	}
	SendWaypointSize = x;
}

void Convert_TileBuf_hdcMem(unsigned char *RowBufs, unsigned int col)
{
	int x;
	HDC hdcMem2;
	HBITMAP hBitmap2;
	BOOL badread = FALSE;

	ijlInit(&jcprops);//use Intel's ijl15.dll to convert JPEG files
	if (RowBufs != NULL)
	{
		jcprops.JPGBytes = &RowBufs[col];
		if (*(int*)&RowBufs[col] != 0xE0FFD8FF)//at beginning of a jpeg file
			badread = TRUE;
	}
	else
		jcprops.JPGBytes = TileBuf;
	jcprops.JPGSizeBytes = MAX_TILE_SIZE;
	jcprops.JPGFile = NULL;
	jcprops.JPGChannels = 3;
	ijlRead(&jcprops, IJL_JBUFF_READPARAMS);
	jcprops.DIBWidth= PixelsPerTile;
	jcprops.DIBHeight = PixelsPerTile;
	jcprops.DIBPadBytes = IJL_DIB_PAD_BYTES(PixelsPerTile, 3);
	jcprops.DIBChannels = 3;
	jcprops.DIBColor = IJL_BGR;
	jcprops.DIBBytes = pixel_buf;
	if ((Zoom == 1) || (Zoom == 5))
	{
		if (IJL_OK != ijlRead(&jcprops, IJL_JBUFF_READWHOLEIMAGE))
			badread = TRUE;
	}
	else if ((Zoom == 2) || (Zoom == 6))
	{
		if (IJL_OK != ijlRead(&jcprops, IJL_JBUFF_READONEHALF))
			badread = TRUE;
	}
	else if ((Zoom == 3) || (Zoom == 7))
	{
		if (IJL_OK != ijlRead(&jcprops, IJL_JBUFF_READONEQUARTER))
			badread = TRUE;
	}
	else if (((Zoom == 4)) || (Zoom == 8))
	{
		if (IJL_OK != ijlRead(&jcprops, IJL_JBUFF_READONEEIGHTH))
			badread = TRUE;
	}

	if (badread == FALSE)
	{
		if (Increment > 0)
		{
			for (x = 0; x < 120000; x++)
			{
				if ((pixel_buf[x] + Increment) < 0xFF)
					pixel_buf[x] += Increment;
				else
					pixel_buf[x] = 0xFF;
			}
		}
		else if (Increment < 0)
		{
			for (x = 0; x < 120000; x++)
			{
				if ((pixel_buf[x] + Increment) > 0)
					pixel_buf[x] += Increment;
				else
					pixel_buf[x] = 0;
			}
		}
		hdcMem2 = CreateCompatibleDC (hdcMem);
		hBitmap2 = CreateDIBitmap (hdcMem, pbmih, CBM_INIT, pixel_buf, pbmi, 0);
		SelectObject (hdcMem2, hBitmap2);
		BitBlt (hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcMem2, 0, 0, SRCCOPY);
		DeleteDC (hdcMem2);
		DeleteObject (hBitmap2);
	}
	else//if (badread)
		BitBlt(hdcMem, xLoc, yLoc, PixelsPerTile, PixelsPerTile, hdcBlackMem, 0, 0, SRCCOPY);
	ijlFree(&jcprops);
}

void ClearLine(void)
{
	int x;
	for (x = 25; x < 40; x++)
		LatLon[x] = ' ';
	for (x = 45; x < 62; x++)
		LatLon[x] = ' ';
}

int CALLBACK WelcomeProc(HWND hwndWelcome, UINT message, WPARAM wParam, LPARAM lParam)
{
	HANDLE hWelcomeFile;
	static HWND hwndArea, hwndLatDeg, hwndLatMin, hwndLatSec, hwndLonDeg, hwndLonMin, hwndLonSec, hwndUTMN, hwndUTMW, hwndZone;
	DWORD fileSize2;
	int x, y, sizeofFirstIni;
	char HTTP[] = "http://msrmaps.com/";
	char UTMN[11];
	char UTMW[11];
	char LatDegrees[11];
	char LonDegrees[11];
	char NegLonDegrees[] = "-000000000\x0";
	char Minutes[11];
	char Seconds[11];
	char FirstIni[80];
	unsigned char IniBuf[10000];
	double Deg, Min, Sec;
	BOOL badchar;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndLatDeg = GetDlgItem(hwndWelcome, IDC_EDIT1);
		hwndLatMin = GetDlgItem(hwndWelcome, IDC_EDIT2);
		hwndLatSec = GetDlgItem(hwndWelcome, IDC_EDIT3);
		hwndLonDeg = GetDlgItem(hwndWelcome, IDC_EDIT4);
		hwndLonMin = GetDlgItem(hwndWelcome, IDC_EDIT5);
		hwndLonSec = GetDlgItem(hwndWelcome, IDC_EDIT6);
//		hwndHTTP = GetDlgItem(hwndWelcome, IDC_EDIT7);
		hwndArea = GetDlgItem(hwndWelcome, IDC_EDIT8);
		hwndUTMW = GetDlgItem(hwndWelcome, IDC_EDIT9);
		hwndUTMN = GetDlgItem(hwndWelcome, IDC_EDIT10);
		hwndZone = GetDlgItem(hwndWelcome, IDC_EDIT11);
//		SetWindowText(hwndHTTP, HTTP);
//		SendMessage(hwndHTTP, EM_SETREADONLY, 1, 0);
		SetWindowText(hwndArea, Area);
		SetWindowText(hwndLatDeg, myLat);
		SetWindowText(hwndLonDeg, myLon);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			for (x = 0; x < AREA_SIZE; x++)
				Area[x] = 0;
			y = GetWindowText(hwndArea, Area, AREA_SIZE);
			if (y == 0)
				break;
			badchar = FALSE;
			for (x = 0; x < y; x++)
			{
				if ((Area[x] == '<') || (Area[x] == '>') || (Area[x] == ':') || (Area[x] == '"') || (Area[x] == '/') || (Area[x] == '\\') || (Area[x] == '*') || (Area[x] == '?'))
				{
					MessageBox(hwndWelcome, "Don't use < > : \" / \\ * ? |", ERROR, MB_OK);
					SetFocus(hwndArea);
					badchar = TRUE;
					break;
				}
			}
			if (badchar)
				break;
			if ((GetWindowText(hwndUTMN, UTMN, 11) == 0) || (GetWindowText(hwndUTMW, UTMW, 11) == 0) || (GetWindowText(hwndZone, Z, 3) == 0))
			{
				if (GetWindowText(hwndLatDeg, LatDegrees, 11) == 0)
					break;
				if (GetWindowText(hwndLonDeg, LonDegrees, 11) == 0)
					break;
				for (x = 0, y = 0; x < 11; x++)
				{
					if ((LonDegrees[x] == '-') || (LonDegrees[x] == ' '))
						continue;
					NegLonDegrees[y++] = LonDegrees[x];
				}
				GetWindowText(hwndLatMin, Minutes, 11);
				GetWindowText(hwndLatSec, Seconds, 11);
				Deg = strtod(LatDegrees, NULL);
				Min = strtod(Minutes, NULL);
				Sec = strtod(Seconds, NULL);
				Min += (Sec / 60.0);
				Lat = Deg + (Min / 60.0);
				GetWindowText(hwndLonMin, Minutes, 11);
				GetWindowText(hwndLonSec, Seconds, 11);

				Deg = strtod(NegLonDegrees, NULL);
				Min = strtod(Minutes, NULL);
				Sec = strtod(Seconds, NULL);
				Min += (Sec / 60.0);
				Lon = -(Deg + (Min / 60.0));
				LatRad = Lat * deg2rad;
				LonRad = Lon * deg2rad;
				LatLontoUTM();
				Z[0] = (UTMZone / 10) + '0';
				Z[1] = (UTMZone % 10) + '0';
			}
			else
			{//UTM
				for (x = 0; x < 11; x++)
					if (UTMN[x] == ',')
						for (y = x; y < 11; y++)
							UTMN[y] = UTMN[y+1];//get rid of commas
				for (x = 0; x < 11; x++)
					if (UTMW[x] == ',')
						for (y = x; y < 11; y++)
							UTMW[y] = UTMW[y+1];//get rid of commas
				UTMNorthing = atoi(UTMN);
				UTMEasting = atoi(UTMW);
				if (Z[1] == 0)
				{
					Z[1] = Z[0];
					Z[0] = '0';
				}
				UTMZone = atoi(Z);
				UTMtoLatLon();
			}
			if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))//WelcomeProc
			{//outside range
				sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
				MessageBox(hwnd, Error, "Error 6", MB_OK);
				EndDialog (hwndWelcome, EXIT);
				return EXIT;
			}
			FirstIni[0] = '*';
			for (x = 1, y = 0 ; Area[y] != 0; x++, y++)
				FirstIni[x] = Area[y];
			z = UTMEasting / 200;
			if ((UTMEasting % 200) > 100)
				z += 1;//round up
			y = UTMNorthing / 200;
			if ((UTMNorthing % 200) > 100)
				y += 1;//round up
			FirstIni[x++] = '&';
			FirstIni[x++] = 'X';
			FirstIni[x++] = '=';
			FirstIni[x++] = (z / 1000) + '0';
 			FirstIni[x++] = ((z % 1000) / 100) + '0';
 			FirstIni[x++] = ((z % 100) / 10) + '0';
 			FirstIni[x++] = (z % 10) + '0';
 			FirstIni[x++] = '&';
			FirstIni[x++] = 'Y';
			FirstIni[x++] = '=';
			FirstIni[x++] = ((y % 100000) / 10000) + '0';
 			FirstIni[x++] = ((y % 10000) / 1000) + '0';
 			FirstIni[x++] = ((y % 1000) / 100) + '0';
 			FirstIni[x++] = ((y % 100) / 10) + '0';
 			FirstIni[x++] = (y % 10) + '0';
 			FirstIni[x++] = '&';
			FirstIni[x++] = 'Z';
			FirstIni[x++] = '=';
			FirstIni[x++] = (UTMZone / 10) + '0';//zone
			FirstIni[x++] = (UTMZone % 10) + '0';//zone
			FirstIni[x++] = '\r';
			FirstIni[x++] = '\n';
			FirstIni[x] = 0;
			sizeofFirstIni = x;

			BeginX = UTMEasting / MetersPerTile;
			if ((UTMEasting % (MetersPerTile)) > (MetersPerTile/2))
				BeginX += 1;//round up
			BeginY = UTMNorthing / MetersPerTile;
			if ((UTMNorthing % (MetersPerTile)) > (MetersPerTile/2))
				BeginY += 1;//round up
//			BeginX += Zoom;//round up
//			BeginY += Zoom;//round up
//			if (Zoom >= 5)
//			{
//				BeginX--;
//				BeginY--;
//			}

			_itoa(BeginX, X, 10);
			_itoa(BeginY, Y, 10);
			GetURLName();

			hWelcomeFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hWelcomeFile != INVALID_HANDLE_VALUE)
			{
				if (fileSize2 = GetFileSize(hWelcomeFile, NULL))
				{
					if (fileSize2 > sizeof(IniBuf))
					{//just in case
						EndDialog (hwndWelcome, EXIT);
						return EXIT;
					}
					ReadFile(hWelcomeFile, IniBuf, fileSize2, &dwBytesRead, NULL);
					for (x = 0; (IniBuf[x] != '*') && (x < (int)fileSize2); x++)
						;
					for ( ; x < (int)fileSize2; x++)//write over the '*'
						IniBuf[x] = IniBuf[x+1];
					fileSize = x-1;//because of the erased '*'
					//insert it in alphabetical order
					for (x = 0; x < fileSize; x++/*to beginning of next line*/)
					{
						if (FirstIni[1] <= IniBuf[x])
						{
							if (FirstIni[1] < IniBuf[x])
								break;
							if (FirstIni[1] == IniBuf[x])
							{
								if (FirstIni[2] < IniBuf[x+1])
									break;
								if (FirstIni[2] == IniBuf[x+1])
								{
									if (FirstIni[3] < IniBuf[x+2])
										break;
									if (FirstIni[3] == IniBuf[x+2])
									{
										if (FirstIni[4] < IniBuf[x+3])
											break;
									}
								}
							}
						}
						for ( ; IniBuf[x] != 0x0A; x++)
							;
					}
					if (x < fileSize)
						MoveMemory(&IniBuf[x+sizeofFirstIni], &IniBuf[x], fileSize-x);
					for (y = 0; FirstIni[y-1] != '\x0A'; x++, y++)
						IniBuf[x] = FirstIni[y];
					SetFilePointer(hWelcomeFile, 0, NULL, FILE_BEGIN);
					fileSize += sizeofFirstIni;

					x = CheckIniProc(IniBuf, fileSize, 2);//WelcomeProc
					if (x != (int)fileSize)
					{
						CloseHandle(hWelcomeFile);
						MessageBox(hwnd, Buf2, ERROR, MB_OK);
 						EndDialog (hwndWelcome, EXIT);
						openatclosing = FALSE;
						return EXIT;
					}
				}
			}
			else
			{
				for (x = 0; FirstIni[x-1] != '\x0A'; x++)
					IniBuf[x] = FirstIni[x];
				fileSize = x;
				hWelcomeFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			}
			WriteFile(hWelcomeFile, IniBuf, fileSize, &dwBytesWritten, NULL);
			CloseHandle(hWelcomeFile);

			EndDialog (hwndWelcome, 0);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndWelcome, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

//  					01234567890123456789012345678901234567890123456789012345678901234567890123456
//char TopoURLName[] = "http://msrmaps.com/tile.ashx?t=2&s=12&x=936&y=5435&z=10    ";//4,348,672 750,348
void GetTopoURLName(void)
{
	int x, y;

	if (Zoom >=5)
//		TopoURLName[44] = '6';//&s=16
		TopoURLName[36] = '6';//&s=16
	else
//		TopoURLName[44] = '2';//&s=16
		TopoURLName[36] = '2';//&s=16
	for (x = 0; X[x] != 0; x++)
//		TopoURLName[x+48] = X[x];
		TopoURLName[x+40] = X[x];
//	x += 48;
	x += 40;
	TopoURLName[x++] = '&';
	TopoURLName[x++] = 'y';
	TopoURLName[x++] = '=';
	for (y = 0; Y[y] != 0; x++, y++)
		TopoURLName[x] = Y[y];
	TopoURLName[x++] = '&';
	TopoURLName[x++] = 'z';
	TopoURLName[x++] = '=';
	TopoURLName[x] = (UTMZone/10) + '0';
	if (TopoURLName[x] !='0')
		x++;
	TopoURLName[x++] = (UTMZone%10) + '0';
	TopoURLName[x] = 0;
}

//  			    01234567890123456789012345678901234567890123456789012345678901234567890123456
//char URLName[] = "http://msrmaps.com/tile.ashx?t=1&s=10&x=2890&y=20702&z=10";
void GetURLName(void)
{
	int x, y;
	if (Zoom >= 5)
		URLName[36] = '3';//&s=13 for 8 meters/pixel
	else
		URLName[36] = '0';//&s=10 for 1 meter/pixel
	for (x = 0; X[x] != 0; x++)
		URLName[x+40] = X[x];
	x += 40;
	URLName[x++] = '&';
	URLName[x++] = 'y';
	URLName[x++] = '=';
	for (y = 0; Y[y] != 0; x++, y++)
		URLName[x] = Y[y];
	URLName[x++] = '&';
	URLName[x++] = 'z';
	URLName[x++] = '=';
	URLName[x] = (UTMZone/10) + '0';
	if (URLName[x] !='0')
		x++;
	URLName[x++] = (UTMZone%10) + '0';
	URLName[x] = 0;
}

//Urban Areas: PixelsPerTile = 200; MetersPerPixel = 0.25; MetersPerTile = 50;
//or:          PixelsPerTile = 100; MetersPerPixel = 0.50; MetersPerTile = 50;
//or:          PixelsPerTile = 50; MetersPerPixel = 1; MetersPerTile = 50;
//or:          PixelsPerTile = 25; MetersPerPixel = 2; MetersPerTile = 50;
//4 meters/pixel (x & y = UTM/800) urban area: tile.ashx?t=4&s=12&x=719&y=5181&z=10"
//MetersPerTile = 800 (stays constant)
//PixelsPerTile = 200
//  			         01234567890123456789012345678901234567890123456789012345678901234567890123456
//char ColorURLName[] = "http://msrmaps.com/tile.ashx?t=4&s=                          ";
//tile.ashx?t=4&s=8&x=11327&y=105600&z=10
//tile.ashx?t=4&s=10&x=2831&y=26400&z=10    &x=11308&y=105586
//tile.ashx?t=4&s=13&x=353&y=3300&z=10
//tile.ashx?t=4&s=14&x=176&y=1650&z=10
void GetColorURLName(void)
{
//	int x = 43, y;
	int x = 35, y;

	if (Zoom <= 4)
		ColorURLName[x++] = '8';
	else
	{
		ColorURLName[x++] = '1';
		ColorURLName[x++] = '2';
	}
	ColorURLName[x++] = '&';
	ColorURLName[x++] = 'x';
	ColorURLName[x++] = '=';
	for (y = 0; X[y] != 0; x++, y++)
		ColorURLName[x] = X[y];
	ColorURLName[x++] = '&';
	ColorURLName[x++] = 'y';
	ColorURLName[x++] = '=';
	for (y = 0; Y[y] != 0; x++, y++)
		ColorURLName[x] = Y[y];
	ColorURLName[x++] = '&';
	ColorURLName[x++] = 'z';
	ColorURLName[x++] = '=';
	if (UTMZone >= 10)
		ColorURLName[x++] = (UTMZone/10) + '0';
	ColorURLName[x++] = (UTMZone%10) + '0';
	ColorURLName[x] = 0;
}

LRESULT CALLBACK InstructProc(HWND hwndInstruct, UINT message, WPARAM wParam, LPARAM lParam)
{
	RECT rect;

	switch(message)
	{
	case WM_CREATE:
		GetClientRect(hwndInstruct, &rect);
		hwndInstr = CreateWindow("EDIT", NULL,
			WS_CHILD | WS_VISIBLE  | WS_VSCROLL | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL,
			0, 0, rect.right, rect.bottom,
			hwndInstruct, (HMENU)214, hInst, NULL);
		SendMessage(hwndInstr, EM_SETREADONLY, 1, 0);
		pEditProc = (WNDPROC)SetWindowLong(hwndInstr, GWL_WNDPROC, (LONG)EditProc);
		rect.left += 10;
		rect.right -=25;
		rect.top = cyChar;
		SendMessage(hwndInstr, EM_SETRECTNP, 0, (LPARAM)(LPRECT)&rect);
		return 0;
	}
	return DefWindowProc(hwndInstruct, message, wParam, lParam);
}

int CALLBACK OpenProc(HWND hwndOpen, UINT message, WPARAM wParam, LPARAM lParam)
{
	char OpenList[100];
	char *pOpenList, *pOpen;
	static HWND hwndList;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndList = GetDlgItem(hwndOpen, IDC_LIST1);
		while (*pIniBuf != 0)
		{
			pOpenList = OpenList;
			pOpen = OpenList;
			while ((*pIniBuf != '&') && (*pIniBuf != 0))
				*pOpenList++ = *pIniBuf++;
			while ((*pIniBuf != '\r') && (*pIniBuf != 0))
				pIniBuf++;
			if (*pIniBuf == 0)
				break;
			*pOpenList++ = ' ';
			*pOpenList++ = '(';
			pIniBuf--;
			pIniBuf--;
			*pOpenList++ = *pIniBuf++;
			*pOpenList++ = *pIniBuf++;
			*pOpenList++ = ')';
			*pOpenList = 0;
			SendDlgItemMessage(hwndOpen, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)pOpen);
			while ((*pIniBuf != '\n') && (*pIniBuf != 0))
				pIniBuf++;
			if (*pIniBuf != 0)
				pIniBuf++;//to beginning of next line or 0
		}
		SetFocus(hwndList);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				IniNumber = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
				break;
			}
			else if (HIWORD (wParam) == LBN_DBLCLK)
			{
				EndDialog (hwndOpen, TRUE);
				return TRUE;
			}
			else
				break;

		case IDC_BUTTON1:
			if ((deletestring == FALSE) && (IniNumber != -1))
			{
				if (IDOK == MessageBox(hwndOpen, "", "Delete Map Location?", MB_OKCANCEL))
				{
					deletestring = TRUE;
//					SendMessage(hwndList, LB_DELETESTRING, IniNumber, 0);
					EndDialog (hwndOpen, 0);
					return TRUE;
				}
			}
			break;

		case IDOK:
			if (IniNumber == -1)
				break;
			EndDialog (hwndOpen, 0);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndOpen, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

BOOL GetXYZfromIniBuf(void)
{
	int x, y, xbegin, tempBeginX, tempBeginY;
	char tempBuf[20];
	HANDLE hFile;

	for (x = 0; x < AREA_SIZE; x++)
		Area[x] = 0;
	for (x = 0; x < 8; x++)
	{
		X[x] = 0;
		Y[x] = 0;
	}

	x = CheckIniProc(pIniBuf, fileSize, 3);//GetXYZfromIniBuf
	if (x != (int)fileSize)
	{
		MessageBox(hwnd, Buf2, ERROR, MB_OK);
		return FALSE;
	}

	for (x = 0; (pIniBuf[x] != '*') && (x < (int) fileSize); x++)
		;
	if (x < (int) fileSize)
	{
		x++;
		for (y = 0; ((pIniBuf[x] != '&') || (pIniBuf[x+1] != 'X') || (pIniBuf[x+2] != '=')) && (x < (int) fileSize); x++, y++)
			Area[y] = pIniBuf[x];//map name
		x += 3;
		xbegin = x;
		for (y = 0; (pIniBuf[x] != '&') && (x < (int) fileSize); x++, y++)
			X[y] = pIniBuf[x];
		x += 3;
		for (y = 0; (pIniBuf[x] != '&') && (x < (int) fileSize); x++, y++)
			Y[y] = pIniBuf[x];
		x += 3;
		Z[0] = pIniBuf[x++];
		Z[1] = pIniBuf[x];
		BeginX = atoi(X);
		BeginY = atoi(Y);
		UTMZone = atoi(Z);
		if (BeginX < 900)
		{//if from a version that made X & Y 8 times smaller, e.g. *BayArea&X=474&Y=2694&Z=10
//BeginX 900 thru 4000
//BeginY 9900 thru 396500
//BeginZ 03 thru 19
//			if (BeginY
 			tempBeginX = BeginX * 8;
			_itoa(tempBeginX, tempBuf, 10);
			for (x = xbegin, y = 0; tempBuf[y] != 0; x++, y++)
				pIniBuf[x] = tempBuf[y];
			pIniBuf[x++] = '&';
			pIniBuf[x++] = 'Y';
			pIniBuf[x++] = '=';
			tempBeginY = BeginY * 8;
			_itoa(tempBeginY, tempBuf, 10);
			for (y = 0; tempBuf[y] != 0; x++, y++)
				pIniBuf[x] = tempBuf[y];
			pIniBuf[x++] = '&';
			pIniBuf[x++] = 'Z';
			pIniBuf[x++] = '=';
			pIniBuf[x++] = Z[0];
			pIniBuf[x++] = Z[1];
			pIniBuf[x++] = '\r';
			pIniBuf[x++] = '\n';
			x = CheckIniProc(pIniBuf, fileSize, 4);//GetXYZfromIniBuf
			if (x == (int)fileSize)
			{
				hFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, pIniBuf, fileSize, &dwBytesWritten, NULL);
				CloseHandle(hFile);
			}
			else
			{
				MessageBox(hwnd, Buf2, ERROR, MB_OK);
				return FALSE;
			}
		}
		BeginX *= 200;//UTMEasting
		BeginX /= MetersPerTile;
		BeginY *= 200;//UTMNorthing
		BeginY /= MetersPerTile;
/*		if (MetersPerTile == 1600)
		{
			BeginX /= 8;
			BeginY /= 8;
		}
		else if (MetersPerTile == 800)
		{
			BeginX /= 4;
			BeginY /= 4;
		}
		else if (MetersPerTile == 50)
		{
			BeginX *= 4;
			BeginY *= 4;
		}*/
		_itoa(BeginX, X, 10);
		_itoa(BeginY, Y, 10);
		return TRUE;
	}
	else
	{
		MessageBox(hwnd, "You need to put an * (asterisk) at the\nbeginning of a line in USAPhotoMaps.ini", NULL, MB_OK);
		return FALSE;
	}
}

int CALLBACK GotoUSNGProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int BeginningOffset, Eoffset, Noffset;
	char LatZone;
	char northing[6];
	char easting[6];
	char Letters[2];
	char Ealphabet[] = "ABCDEFGHJKLMNPQRSTUVWXYZABCDEFGHJKLMNPQRSTUVWXYZ";
	char Nalphabet[] = "ABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUV";
	static HWND hwndEdit;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit = GetDlgItem(hwndDlg, IDC_EDIT1);
		for (x = 0, y = 26; y < 44; x++, y++)
			NewUSNG[x] = USNG[y];
		NewUSNG[x] = 0;
		SetWindowText(hwndEdit, NewUSNG);
		SendMessage(hwndEdit, EM_SETSEL, 0, -1);
		SetFocus(hwndEdit);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{//10S EK 12345 12345
		case IDOK:
//get desired UTM from NewUSNG
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			GetWindowText(hwndEdit, NewUSNG, 20);
			if ((NewUSNG[0] <= '9') && (NewUSNG[1] >= '0'))
				UTMZone = (NewUSNG[0]) - '0';
			else
				break;
			if ((NewUSNG[1] <= '9') && (NewUSNG[1] >= '0'))
			{
				UTMZone *= 10;
				UTMZone += NewUSNG[1] - '0';
				x = 2;
			}
			else
				x = 1;			
			if (((NewUSNG[x] & 0xDF) >= 'A') && ((NewUSNG[x] & 0xDF) <= 'Z'))
				LatZone = NewUSNG[x++];
			else
				break;
			while (NewUSNG[x] == ' ') { x++; }
			Letters[0] = NewUSNG[x++];
			Letters[1] = NewUSNG[x++];
			while (NewUSNG[x] == ' ') { x++; }
			z = x;//at beginning of easting coordinate
			for (y = 0; NewUSNG[x] != 0; x++)
			{
				if (NewUSNG[x] != ' ')
					y++;
			}
			y >>= 1;// / 2
			for (x = z, z = 0; z < y; x++, z++)
				easting[z] = NewUSNG[x];
			if (y < 5)
			{
				easting[z++] = '0';
				if (y < 4)
				{
					easting[z++] = '0';
					if (y < 3)
						easting[z++] = '0';
				}
			}
			easting[z] = 0;
			while (NewUSNG[x] == ' ') { x++; }
			for (z = 0; z < y; x++, z++)
				northing[z] = NewUSNG[x];
			if (y < 5)
			{
				northing[z++] = '0';
				if (y < 4)
				{
					northing[z++] = '0';
					if (y < 3)
						northing[z++] = '0';
				}
			}
			northing[z] = 0;

			switch (UTMZone % 6)
			{
			case 0:
				Eoffset = 16;//S
				Noffset = 5;//F
				break;
			case 1:
				Eoffset = 0;//A
				Noffset = 0;//A
				break;
			case 2:
				Eoffset = 8;//J
				Noffset = 5;//F
				break;
			case 3:
				Eoffset = 16;//S
				Noffset = 0;//A
				break;
			case 4:
				Eoffset = 0;//A
				Noffset = 5;//F
				break;
			case 5:
				Eoffset = 8;//J
				Noffset = 0;//A
				break;
			default:
				MessageBox(hwnd, "UTM zone isn't in the USA", ERROR, MB_OK);
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				return EXIT;
			}
			switch (LatZone)
			{
			case 'Q'://Lat >= 16 UTMNorthing >= 1,769,896 or 17 hundred thousand above equator
				BeginningOffset = 17;
				break;
			case 'R'://Lat >= 24 UTMNorthing >= 2,654,427 or 26...
				BeginningOffset = 26;
				break;
			case 'S'://Lat >= 32 3,542,183 35
				BeginningOffset = 35;
				break;
			case 'T'://Lat >= 40 4,428,236 44
				BeginningOffset = 44;
				break;
			case 'U'://Lat >= 48 5,316,785 53
				BeginningOffset = 53;
				break;
			case 'V'://Lat >= 56 6,206,531 62
				BeginningOffset = 62;
				break;
			case 'W'://Lat >= 64 7,097,398 70
				BeginningOffset = 70;
				break;
			default:
				MessageBox(hwnd, "The first letter doesn't indicate inside the USA", ERROR, MB_OK);
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				return EXIT;
			}
//	char Ealphabet[] = "ABCDEFGHJKLMNPQRSTUVWXYZABCDEFGHJKLMNPQRSTUVWXYZ";
//	char Nalphabet[] = "ABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUVABCDEFGHJKLMNPQRSTUV";
			UTMEasting = atoi(easting);
			UTMNorthing = atoi(northing);

			for (x = Eoffset, y = 100000; (Ealphabet[x] != Letters[0]) && (x < 48); x++, y += 100000)
				;
			if (y > 1000000)
			{
				MessageBox(hwnd, "The first of the two letters isn't right.", ERROR, MB_OK);
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				return EXIT;
			}
			UTMEasting += y;
			for (x = Noffset+BeginningOffset, y = 0; (Nalphabet[x] != Letters[1]) && (x < 100); x++, y++)
				;
			if (y > 10)
			{
				MessageBox(hwnd, "The second of the two letters isn't right.", ERROR, MB_OK);
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				return EXIT;
			}
			BeginningOffset += y;
			UTMNorthing += BeginningOffset*100000;
			UTMtoLatLon();
			if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
			{
				sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
				MessageBox(hwnd, Error, "Error 7", MB_OK);
				return EXIT;
			}
			ChangeZone(UTMZone, 3);//GoToUSNGProc
			BeginX = UTMEasting / MetersPerTile;
			BeginY = UTMNorthing / MetersPerTile;
			_itoa(BeginX, X, 10);
			_itoa(BeginY, Y, 10);
			Z[0] = (UTMZone / 10) + '0';
			Z[1] = (UTMZone % 10) + '0';
			Waypoints[0] = 0;
			if (tempUTMZone != UTMZone)
				SendMessage(hwnd, WM_USER4, 0, 0);
			EndDialog (hwndDlg, 0);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

int CALLBACK GotoProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndLatDeg, hwndLatMin, hwndLatSec, hwndLonDeg, hwndLonMin, hwndLonSec, hwndUTMN, hwndUTME, hwndUTMZ;
	int x, y;
	char LatDegrees[11];
	char LonDegrees[11];
	char UTMN[11];
	char UTME[11];
	char UTMZ[3];
	static char NegLonDegrees[] = "-000000000\x0";
	char Minutes[11];
	char Seconds[11];
	double Deg, Min, Sec;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndLatDeg = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndLatMin = GetDlgItem(hwndDlg, IDC_EDIT2);
		hwndLatSec = GetDlgItem(hwndDlg, IDC_EDIT3);
		hwndLonDeg = GetDlgItem(hwndDlg, IDC_EDIT4);
		hwndLonMin = GetDlgItem(hwndDlg, IDC_EDIT5);
		hwndLonSec = GetDlgItem(hwndDlg, IDC_EDIT6);
		hwndUTME = GetDlgItem(hwndDlg, IDC_EDIT7);
		hwndUTMN = GetDlgItem(hwndDlg, IDC_EDIT8);
		hwndUTMZ = GetDlgItem(hwndDlg, IDC_EDIT9);
		SetFocus(hwndLatDeg);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			if ((GetWindowText(hwndUTMN, UTMN, 11) == 0) || (GetWindowText(hwndUTME, UTME, 11) == 0))
			{
				if (GetWindowText(hwndLatDeg, LatDegrees, 11) == 0)
					break;
				if (GetWindowText(hwndLonDeg, LonDegrees, 11) == 0)
					break;
				for (x = 0, y = 0; x < 11; x++)
				{
					if ((LonDegrees[x] == '-') || (LonDegrees[x] == ' '))
						continue;
					NegLonDegrees[y++] = LonDegrees[x];
				}
				GetWindowText(hwndLatMin, Minutes, 11);
				GetWindowText(hwndLatSec, Seconds, 11);
				Deg = strtod(LatDegrees, NULL);
				Min = strtod(Minutes, NULL);
				Sec = strtod(Seconds, NULL);
				Min += (Sec / 60.0);
				Lat = Deg + (Min / 60.0);

				GetWindowText(hwndLonMin, Minutes, 11);
				GetWindowText(hwndLonSec, Seconds, 11);
				Deg = strtod(NegLonDegrees, NULL);
				Min = strtod(Minutes, NULL);
				Sec = strtod(Seconds, NULL);
				Min += (Sec / 60.0);
				Lon = -(Deg + (Min / 60.0));

				LatRad = Lat * deg2rad;
				LonRad = Lon * deg2rad;
				LatLontoUTM();
			}
			else//UTM
			{
				for (x = 0; x < 11; x++)
				{
					if (UTMN[x] == ',')
						for (y = x; y < 11; y++)
							UTMN[y] = UTMN[y+1];//get rid of commas
				}
				for (x = 0; x < 11; x++)
				{
					if (UTME[x] == ',')
						for (y = x; y < 11; y++)
							UTME[y] = UTME[y+1];//get rid of commas
				}
				UTMNorthing = atoi(UTMN);
				UTMEasting = atoi(UTME);
				if (0 != GetWindowText(hwndUTMZ, UTMZ, 3))
					UTMZone = atoi(UTMZ);
				UTMtoLatLon();
				LatRad = Lat * deg2rad;
				LonRad = Lon * deg2rad;
				LatLontoUTM();//have to do it the hard way to see if it's in the same Zone
			}
			if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))//GotoProc
			{//outside range
				sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
				MessageBox(hwnd, Error, "Error 8", MB_OK);
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				break;
			}
			EndDialog (hwndDlg, 0);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

void IncNumber(void)
{
	Number[4]++;
	if (Number[4] > '9')
	{
		Number[4] = '0';
		Number[3]++;
		if (Number[3] > '9')
		{
			Number[3] = '0';
			Number[2]++;
			if (Number[2] > '9')
			{
				Number[2] = '0';
				Number[1]++;
			}
		}
	}
}

void IncCount(void)
{
	Counting[3]++;
	if (Counting[3] > '9')
	{
		Counting[3] = '0';
		Counting[2]++;
		if (Counting[2] > '9')
		{
			Counting[2] = '0';
			Counting[1]++;
			if (Counting[1] > '9')
			{
				Counting[1] = '0';
				Counting[0]++;
			}
		}
	}
	InvalidateRect(hwndCounter, &counterRect, FALSE);
	UpdateWindow(hwndCounter);
}

LRESULT CALLBACK CounterProc(HWND hwndCounter, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x;
	static char AbortTransfer[] =  "\x10\x0A\x02\x00\x00\xF4\x10\x03";
	static HWND hwndCancel;
	HDC hdcCounter;
	PAINTSTRUCT ps;

	switch (message)
	{
	case WM_CREATE:
		SetFocus(hwndCounter);//for the Esc, below
		hwndCancel = CreateWindow("BUTTON", "Cancel",
			WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
			cxChar*3, cyChar*4, cxChar*8, (cyChar*3)/2,
			hwndCounter, (HMENU)169, hInst, NULL);
		return 0;

	case WM_KEYDOWN:
		if (wParam == VK_ESCAPE)
			SendMessage(hwndCounter, WM_COMMAND, 0, (LPARAM)hwndCancel);
		return 0;

	case WM_COMMAND:
		if (lParam == (long)hwndCancel)//if cancel button pressed
		{
			if (itsgarmin)
			{
				sendingStop = TRUE;
				WriteFile(hComm, &AbortTransfer, 8, &dwBytesWritten, NULL);
				for (x = 0; x < 8; x++, tgcount++)
					ToGPS[tgcount] = AbortTransfer[x];
				if (tgcount > 49900) tgcount = 0;
				sendingWaypoints = FALSE;
			}
			else
			{
				magflag = 0;
				SendMessage(hwndCounter, WM_CLOSE, 0, 0);
			}
		}
		return 0;

	case WM_PAINT:
		hdcCounter = BeginPaint(hwndCounter, &ps);
		SetBkColor(hdcCounter, LIGHTGRAY);
		TextOut(hdcCounter, cxChar*2, 0, PreCounting, 9);
		TextOut(hdcCounter, cxChar*2, cyChar, Counting, 12);
		TextOut(hdcCounter, cxChar*2, cyChar*2, PostCounting, 9);
		EndPaint(hwndCounter, &ps);
		return 0;
	}
	return DefWindowProc(hwndCounter, message, wParam, lParam);
}

void SaveText(void)
{
	static DWORD size;

	newText = FALSE;
	if (head != NULL)
	{
		if (usatext)
		{
			usatext = FALSE;
			hFile = CreateFile(USADta, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		}
		else
			hFile = CreateFile(TextDta, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		cur = head;
		size = sizeof(*cur);
		while (cur != NULL)
		{
			next = cur->next;
			cur->next = NULL;//could hold extra info if necessary
			WriteFile(hFile, cur, size, &dwBytesWritten, NULL);
			free(cur);
			cur = next;
		}
		CloseHandle(hFile);
	}
	else//if all entries deleted
		DeleteFile(TextDta);
}

//<wpt lat="21.03777611" lon="-86.781314906">
//<ele>1234</ele>
//<name>C&H</name>
//<cmt>CANCUN HOTEL ROOM</cmt>
//<desc>CANCUN&HOTEL ROOM</desc>
//<sym>dot</sym>
//</wpt>
void SaveLocs(void)
{
	int w, x, y, z;
	char tempWay[6000];
	char WayBAK[MAX_PATH];
	char GPX[] = "GPX.bak";
	BOOL gotend, gotname;
	HANDLE hWayFile;

	hWayFile = FindFirstFile(NewLocationsFullPath, &fd);
	if (fd.nFileSizeLow != 0)
	{
		for (x = 0; (NewLocationsFullPath[x] != 0) && (NewLocationsFullPath[x] != '.'); x++)
			WayBAK[x] = NewLocationsFullPath[x];
		if ((NewLocationsFullPath[x+1] & 0xDF) == 'G')
		{
			for (y = 0; GPX[y] != 0; x++, y++)
				WayBAK[x] = GPX[y];
			WayBAK[x] = 0;
			if (CopyFile(NewLocationsFullPath, WayBAK, TRUE))
			{//only if a .bak file didn't exist
				sprintf(Error, "(the original waypoint file) was copied to:\n\n%s\n\nand then rewritten.", WayBAK);
				MessageBox(hwnd, Error, NewLocationsFullPath, MB_OK);
			}
		}
	}
	FindClose(hWayFile);

	newLoc = FALSE;
	if ((NewLoc[0].EUTM == 0) && (NewLoc[0].pWaypoints == NULL))
	{//if deleted down to 0 waypoints
		DeleteFile(NewLocationsFullPath);
	}
	else
	{
		if (NewLocationsFullPath[0] == 0)
		{
			hWayFile = CreateFile(NewLocations, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			GetFullPathName(NewLocations, MAX_PATH, NewLocationsFullPath, lpPart);//Windows concatenates current dir and NewLocations
		}
		else
			hWayFile = CreateFile(NewLocationsFullPath, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
MessageBox(hwnd, NewLocationsFullPath, "Written:", MB_OK);
		WriteFile(hWayFile, &Top, sizeof(Top)-1, &dwBytesWritten, NULL);
		for (x = 0; (NewLoc[x].EUTM != 0) || (NewLoc[x].pWaypoints != NULL); x++)
		{
			for (w = 0; w < 6000; w++)
				tempWay[w] = 0;
			gotend = TRUE;
			gotname = FALSE;
			for (w = 0, y = 0; y < NewLoc[x].size; w++, y++)
			{//go through this NewLoc
				if ((NewLoc[x].pWaypoints[y] == '<')
				 && (NewLoc[x].pWaypoints[y+1] == 'w')
				 && (NewLoc[x].pWaypoints[y+2] == 'p')
				 && (NewLoc[x].pWaypoints[y+3] == 't'))
				 {
					if (gotend == FALSE)
					{
						sprintf(Error, "Waypoint %i in %s didn't have </wpt> at the end", x+1, NewLocationsFullPath);
						MessageBox(hwnd, Error, NULL, MB_OK);
					}
					else
						gotend = FALSE;
				 }
				if (NewLoc[x].pWaypoints[y] == '>')
				{//check for <name> <cmt> <descr> & possibly add Cdata stuff
					if (((NewLoc[x].pWaypoints[y-5] == '<')
					  && (NewLoc[x].pWaypoints[y-4] == 'n')
					  && (NewLoc[x].pWaypoints[y-3] == 'a')
					  && (NewLoc[x].pWaypoints[y-2] == 'm')
					  && (NewLoc[x].pWaypoints[y-1] == 'e'))
					 || ((NewLoc[x].pWaypoints[y-4] == '<')
					  && (NewLoc[x].pWaypoints[y-3] == 'c')
					  && (NewLoc[x].pWaypoints[y-2] == 'm')
					  && (NewLoc[x].pWaypoints[y-1] == 't'))
					 || ((NewLoc[x].pWaypoints[y-5] == '<')
					  && (NewLoc[x].pWaypoints[y-4] == 'd')
					  && (NewLoc[x].pWaypoints[y-3] == 'e')
					  && (NewLoc[x].pWaypoints[y-2] == 's')
					  && (NewLoc[x].pWaypoints[y-1] == 'c')))
					{
						gotname = TRUE;
						tempWay[w] = NewLoc[x].pWaypoints[y];
						for (z = y+1; (NewLoc[x].pWaypoints[z] != '<') || (NewLoc[x].pWaypoints[z+1] != '/'); z++)
						{
							if ((NewLoc[x].pWaypoints[z] == '<')
							 || (NewLoc[x].pWaypoints[z] == '>')
							 || (NewLoc[x].pWaypoints[z] == '[')
							 || (NewLoc[x].pWaypoints[z] == ']')
							 || (NewLoc[x].pWaypoints[z] == '&'))
							{//illegal characters
								for (w++, z = 0; z < 9; w++, z++)
									tempWay[w] = Cdata[z];//<![CDATA[
								for (y++ ; NewLoc[x].pWaypoints[y] != '<'; w++, y++)
									tempWay[w] = NewLoc[x].pWaypoints[y];
								for (z = 0; z < 3; w++, z++)
									tempWay[w] = CdataEnd[z];//]]>
								w--;
								y--;
								break;
							}
						}
					}
					else if ((NewLoc[x].pWaypoints[y-5] == '<')
					 && (NewLoc[x].pWaypoints[y-4] == '/')
					 && (NewLoc[x].pWaypoints[y-3] == 'w')
					 && (NewLoc[x].pWaypoints[y-2] == 'p')
					 && (NewLoc[x].pWaypoints[y-1] == 't'))
					{
						if (gotname)
						{
							gotend = TRUE;
							tempWay[w++] = NewLoc[x].pWaypoints[y++];//'>'
							tempWay[w++] = NewLoc[x].pWaypoints[y++];//'\r'
							tempWay[w++] = NewLoc[x].pWaypoints[y++];//'\n'
						}
						else
						{
							sprintf(Error, "Waypoint %i in %s had neither a name,\ncomment, or description.", x+1, NewLocationsFullPath);
							MessageBox(hwnd, Error, NULL, MB_OK);
						}
						break;
					}
					else
						tempWay[w] = NewLoc[x].pWaypoints[y];
				}//end of if (NewLoc[x].pWaypoints[y] == '>')
				else
					tempWay[w] = NewLoc[x].pWaypoints[y];
			}//end of for (w = 0
			WriteFile(hWayFile, tempWay, w, &dwBytesWritten, NULL);
		}//end of for (x = 0
		WriteFile(hWayFile, &Bottom, sizeof(Bottom)-1, &dwBytesWritten, NULL);
		CloseHandle(hWayFile);
	}
}

int CALLBACK GetLatLonProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndNLatDeg, hwndNLatMin, hwndNLatSec, hwndWLonDeg, hwndWLonMin, hwndWLonSec;
	static HWND hwndSLatDeg, hwndSLatMin, hwndSLatSec, hwndELonDeg, hwndELonMin, hwndELonSec;
	int x, LeftZone;
	char NDegrees[11];
	char NMinutes[11];
	char NSeconds[11];
	char WDegrees[11];
	char WMinutes[11];
	char WSeconds[11];
	char SDegrees[11];
	char SMinutes[11];
	char SSeconds[11];
	char EDegrees[11];
	char EMinutes[11];
	char ESeconds[11];
	static char NegWDegrees[12];// = "-000000000\x0";
	static char NegEDegrees[12];// = "-000000000\x0";
	double Deg, Min, Sec;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndNLatDeg = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndWLonDeg = GetDlgItem(hwndDlg, IDC_EDIT2);
		hwndSLatDeg = GetDlgItem(hwndDlg, IDC_EDIT3);
		hwndELonDeg = GetDlgItem(hwndDlg, IDC_EDIT4);
		hwndNLatMin = GetDlgItem(hwndDlg, IDC_EDIT5);
		hwndWLonMin = GetDlgItem(hwndDlg, IDC_EDIT6);
		hwndSLatMin = GetDlgItem(hwndDlg, IDC_EDIT7);
		hwndELonMin = GetDlgItem(hwndDlg, IDC_EDIT8);
		hwndNLatSec = GetDlgItem(hwndDlg, IDC_EDIT9);
		hwndWLonSec = GetDlgItem(hwndDlg, IDC_EDIT10);
		hwndSLatSec = GetDlgItem(hwndDlg, IDC_EDIT11);
		hwndELonSec = GetDlgItem(hwndDlg, IDC_EDIT12);
		SetFocus(hwndNLatDeg);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			if (GetWindowText(hwndNLatDeg, NDegrees, 11) == 0)
				break;
			if (GetWindowText(hwndWLonDeg, WDegrees, 11) == 0)
				break;
			if (GetWindowText(hwndSLatDeg, SDegrees, 11) == 0)
				break;
			if (GetWindowText(hwndELonDeg, EDegrees, 11) == 0)
				break;
			NegWDegrees[0] = '-';
			for (x = 0; x < 11; x++)
				NegWDegrees[x+1] = WDegrees[x];
			NegWDegrees[11] = 0;
			NegEDegrees[0] = '-';
			for (x = 0; x < 11; x++)
				NegEDegrees[11] = EDegrees[x];
			NegEDegrees[x+1] = 0;
			GetWindowText(hwndNLatMin, NMinutes, 11);
			GetWindowText(hwndNLatSec, NSeconds, 11);
			GetWindowText(hwndWLonMin, WMinutes, 11);
			GetWindowText(hwndWLonSec, WSeconds, 11);
			GetWindowText(hwndSLatMin, SMinutes, 11);
			GetWindowText(hwndSLatSec, SSeconds, 11);
			GetWindowText(hwndELonMin, EMinutes, 11);
			GetWindowText(hwndELonSec, ESeconds, 11);

//get top left lat/lon
			Deg = strtod(NDegrees, NULL);
			Min = strtod(NMinutes, NULL);
			Sec = strtod(NSeconds, NULL);
			Min += (Sec / 60.0);
			Lat = Deg + (Min / 60.0);

			Deg = strtod(NegWDegrees, NULL);
			Min = strtod(WMinutes, NULL);
			Sec = strtod(WSeconds, NULL);
			Min += (Sec / 60.0);
			Lon = Deg - (Min / 60.0);//minus because Deg is minus

			LatRad = Lat * deg2rad;
			LonRad = Lon * deg2rad;
			LatLontoUTM();
			LeftZone = UTMZone;//for comparison, below
			beginX = UTMEasting / MetersPerTile;
			beginY = UTMNorthing / MetersPerTile;
			_itoa(beginX, X, 10);
			_itoa(beginY, Y, 10);
			Z[0] = (UTMZone / 10) + '0';
			Z[1] = (UTMZone % 10) + '0';
			

//do it again for bottom right
			Deg = strtod(SDegrees, NULL);
			Min = strtod(SMinutes, NULL);
			Sec = strtod(SSeconds, NULL);
			Min += (Sec / 60.0);
			Lat = Deg + (Min / 60.0);

			Deg = strtod(NegEDegrees, NULL);
			Min = strtod(EMinutes, NULL);
			Sec = strtod(ESeconds, NULL);
			Min += (Sec / 60.0);
			Lon = Deg - (Min / 60.0);//minus because Deg is minus

			if ((Lon == -60.0) || (Lon == -66.0) || (Lon == -72.0) || (Lon == -78.0) || (Lon == -84.0) || (Lon == -90.0) || (Lon == -96.0) || (Lon == -102.0) || (Lon == -108.0) || (Lon == -114.0) || (Lon == -120.0) || (Lon == -126.0) || (Lon == -132.0) || (Lon == -138.0) || (Lon == -144.0) || (Lon == -150.0) || (Lon == -156.0) || (Lon == -162.0) || (Lon == -168.0))
				Lon -= 0.000001;//keep it in same UTM zone
			LatRad = Lat * deg2rad;
			LonRad = Lon * deg2rad;
			LatLontoUTM();
			endX = UTMEasting / MetersPerTile;
			endY = UTMNorthing / MetersPerTile;

			if ((UTMZone != tempUTMZone) || (UTMZone != LeftZone))
			{
				if (UTMZone != tempUTMZone)
				{//see if that zone is in USAPhotoMaps.ini
					BOOL gotzone = FALSE;
					hFile = CreateFile(USAPhotoMapsIni, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile != INVALID_HANDLE_VALUE)
					{
						fileSize = GetFileSize(hFile, NULL);
						pIniBuf = (unsigned char*)malloc(fileSize+2);
						ReadFile(hFile, pIniBuf, fileSize, &dwBytesRead, NULL);
						CloseHandle(hFile);
						for (x = 0; x < (int)fileSize; x++)
						{
							if (pIniBuf[x] == '\r')
							{//looking for &Z=11
								if ((pIniBuf[x-5] == '&') && (pIniBuf[x-4] == 'Z') && (pIniBuf[x-3] == '='))
								{
									if (UTMZone == ((pIniBuf[x-2] - '0') * 10) + (pIniBuf[x-1] - '0'))
									{
										gotzone = TRUE;
										break;
									}
								}
							}
						}
						free(pIniBuf);
					}
					if (gotzone == FALSE)
						MessageBox(hwndDlg, "Before you download these photos,\nyou have to select View -Goto\nand go to the area they're in.", "", MB_OK);
				}
				else
					MessageBox(hwndDlg, "The ending longitude isn't\nin the same UTM zone as\nthe beginning longitude.", "", MB_OK);
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				BeginX = UTMEasting / MetersPerTile;
				BeginY = UTMNorthing / MetersPerTile;
				_itoa(BeginX, X, 10);
				_itoa(BeginY, Y, 10);
				break;
			}

			else if ((beginX >= endX) || (endY >= beginY) || ((endX - beginX) > 2900))//580 kilometers or 360 miles
			{
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				UTMtoLatLon();
				BeginX = UTMEasting / MetersPerTile;
				BeginY = UTMNorthing / MetersPerTile;
				_itoa(BeginX, X, 10);
				_itoa(BeginY, Y, 10);
				Z[0] = (UTMZone / 10) + '0';
				Z[1] = (UTMZone % 10) + '0';
				if ((endX - beginX) > 2900)
					MessageBox(hwndDlg, "That's too wide", NULL, MB_OK);
				else
					MessageBox(hwndDlg, "Left is less than right,\nor top is less than bottom", Oops, MB_OK);
				break;
			}
			EndDialog (hwndDlg, 0);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

void ModifyZoom(void)
{
	if (MapType == PHOTO)
		MapUnits = ID_VIEW_MAPTYPE_PHOTO;
	else if (MapType == TOPO)
	{
		MapUnits = ID_VIEW_MAPTYPE_TOPO;
		ModifyMenu(hMenu, ID_ZOOM_1METERPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_1METERPIXEL, TopoZoom1);
		ModifyMenu(hMenu, ID_ZOOM_2METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_2METERSPIXEL, TopoZoom2);
		ModifyMenu(hMenu, ID_ZOOM_4METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_4METERSPIXEL, TopoZoom4);
		ModifyMenu(hMenu, ID_ZOOM_8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_8METERSPIXEL, TopoZoom8);
		ModifyMenu(hMenu, ID_ZOOM_BIG8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_BIG8METERSPIXEL, TopoZoomBig8);
		ModifyMenu(hMenu, ID_ZOOM_16METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_16METERSPIXEL, TopoZoom16);
		ModifyMenu(hMenu, ID_ZOOM_32METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_32METERSPIXEL, TopoZoom32);
		ModifyMenu(hMenu, ID_ZOOM_64METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_64METERSPIXEL, TopoZoom64);
	}
	else//if (MapType == URBANAREA)
	{
		MapUnits = ID_VIEW_MAPTYPE_COLOR;
		ModifyMenu(hMenu, ID_ZOOM_1METERPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_1METERPIXEL, UrbanZoom1);
		ModifyMenu(hMenu, ID_ZOOM_2METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_2METERSPIXEL, UrbanZoom2);
		ModifyMenu(hMenu, ID_ZOOM_4METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_4METERSPIXEL, UrbanZoom4);
		ModifyMenu(hMenu, ID_ZOOM_8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_8METERSPIXEL, UrbanZoom8);
		ModifyMenu(hMenu, ID_ZOOM_BIG8METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_BIG8METERSPIXEL, UrbanZoomBig8);
		ModifyMenu(hMenu, ID_ZOOM_16METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_16METERSPIXEL, UrbanZoom16);
		ModifyMenu(hMenu, ID_ZOOM_32METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_32METERSPIXEL, UrbanZoom32);
		ModifyMenu(hMenu, ID_ZOOM_64METERSPIXEL, MF_BYCOMMAND|MF_STRING, ID_ZOOM_64METERSPIXEL, UrbanZoom64);
	}
}

void MenuChecks(void)
{
	CheckMenuItem(hMenu, Units, MF_CHECKED);
	CheckMenuItem(hMenu, MapUnits, MF_CHECKED);
	CheckMenuItem (hMenu, BaudUnits, MF_CHECKED);
	if (contourson)
		CheckMenuItem(hMenu, ID_VIEW_CONTOURS, MF_CHECKED);
	if (gridon)
		CheckMenuItem(hMenu, ID_VIEW_GRID, MF_CHECKED);
	if (USGSBuf != NULL)
		CheckMenuItem(hMenu, ID_VIEW_SHOWUSGSLANDMARKS, MF_CHECKED);
	if (shownamecomment)
		CheckMenuItem(hMenu, ID_VIEW_SHOWWAYPOINTNAMES, MF_CHECKED);
	if (showtext)
		CheckMenuItem(hMenu, ID_TEXT_SHOWALL, MF_CHECKED);
	if (showingroute)
		CheckMenuItem(hMenu, ID_ROUTE_SHOW, MF_CHECKED);
	if (inaprs)
		CheckMenuItem(hMenu, ID_APRS_RECEIVED_DATA, MF_CHECKED);
	if (usetactical)
		CheckMenuItem(hMenu, ID_APRS_TACTICALCALLSIGNS, MF_CHECKED);
	if (RegValue[5] == 'N')//NMEA
	{
		ProtocolCheck1 = ID_GPS_PROTOCOL_ANYGPS;
		CheckMenuItem (hMenu, ID_GPS_PROTOCOL_ANYGPS, MF_CHECKED);
		itsgarmin = FALSE;
		itsusb = FALSE;
	}
	else if (RegValue[5] == 'G')//GARMIN
	{
		ProtocolCheck1 = ID_GPS_PROTOCOL_GARMIN;
		CheckMenuItem (hMenu, ID_GPS_PROTOCOL_GARMIN, MF_CHECKED);
		itsgarmin = TRUE;
		itsusb = FALSE;
		itsexplorist = FALSE;
	}
	else if (RegValue[5] == 'U')//USB
	{
		ProtocolCheck1 = ID_GPS_PROTOCOL_GARMINUSB;
		CheckMenuItem (hMenu, ID_GPS_PROTOCOL_GARMINUSB, MF_CHECKED);
		itsgarmin = FALSE;
		itsexplorist = FALSE;
		itsusb = TRUE;
	}
	else//if EXPL
	{
		ProtocolCheck1 = ID_GPS_PROTOCOL_MAGELLANEXPLORIST;
		CheckMenuItem (hMenu, ID_GPS_PROTOCOL_MAGELLANEXPLORIST, MF_CHECKED);
		itsgarmin = FALSE;
		itsusb = FALSE;
		itsexplorist = TRUE;
	}
	ModifyZoom();
}

void CheckZoom(void)
{
	UINT param;

	switch (Zoom)
	{
	case 1:
		param = ID_ZOOM_1METERPIXEL;
		break;
	case 2:
		param = ID_ZOOM_2METERSPIXEL;
		break;
	case 3:
		param = ID_ZOOM_4METERSPIXEL;
		break;
	case 4:
		param = ID_ZOOM_8METERSPIXEL;
		break;
	case 5:
		param = ID_ZOOM_BIG8METERSPIXEL;
		break;
	case 6:
		param = ID_ZOOM_16METERSPIXEL;
		break;
	case 7:
		param = ID_ZOOM_32METERSPIXEL;
		break;
	case 8:
		param = ID_ZOOM_64METERSPIXEL;
		break;
	}
	CheckMenuItem(hMenu, param, MF_CHECKED);
}

//Zoom: 1 meter /pixel";1 2 4 8 16 32 64
void ShowZoom(void)
{
	int x, y;

	if ((drawing) && (ptr > 0))
	{
		BeginY = pRoute[ptr-1].NUTM / MetersPerTile;
		BeginX = pRoute[ptr-1].EUTM / MetersPerTile;
		rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
		colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
	}

	if (MapType != URBANAREA)
	{
		x = MetersPerTile/PixelsPerTile;
		if (x > 99)
		{
			y = x / 100;
			LatLon[75] = y + '0';
			Nearest[75] = y + '0';
			UTM[75] = y + '0';
			USNG[75] = y + '0';
			x = x % 100;
		}
		else
		{
			LatLon[75] = ' ';
			Nearest[75] = ' ';
			UTM[75] = ' ';
			USNG[75] = ' ';
		}
		y = x / 10;
		if (y != 0)
		{
			LatLon[76] = y + '0';
			Nearest[76] = y + '0';
			UTM[76] = y + '0';
			USNG[76] = y + '0';
		}
		else
		{
			LatLon[76] = ' ';
			Nearest[76] = ' ';
			UTM[76] = ' ';
			USNG[76] = ' ';
		}
		LatLon[77] = (x % 10) + '0';
		Nearest[77] = (x % 10) + '0';
		UTM[77] = (x % 10) + '0';
		USNG[77] = (x % 10) + '0';
		LatLon[78] = ' ';
		Nearest[78] = ' ';
		UTM[78] = ' ';
		USNG[78] = ' ';
	}
	else//if (MapType == URBANAREA)
	{
		if (MetersPerTile >= PixelsPerTile)
		{
			x = MetersPerTile/PixelsPerTile;
			y = x / 10;
			if (y != 0)
			{
				LatLon[76] = y + '0';
				Nearest[76] = y + '0';
				UTM[76] = y + '0';
				USNG[76] = y + '0';
			}
			else
			{
				LatLon[76] = ' ';
				Nearest[76] = ' ';
				UTM[76] = ' ';
				USNG[76] = ' ';
			}
			LatLon[77] = (x % 10) + '0';
			Nearest[77] = (x % 10) + '0';
			UTM[77] = (x % 10) + '0';
			USNG[77] = (x % 10) + '0';
			LatLon[78] = ' ';
			Nearest[78] = ' ';
			UTM[78] = ' ';
			USNG[78] = ' ';
		}
		else if (PixelsPerTile == (MetersPerTile*2))
		{
			LatLon[76] = '.';
			LatLon[77] = '5';
			LatLon[78] = ' ';
			Nearest[76] = '.';
			Nearest[77] = '5';
			Nearest[78] = ' ';
			UTM[76] = '.';
			UTM[77] = '5';
			UTM[78] = ' ';
			USNG[76] = '.';
			USNG[77] = '5';
			USNG[78] = ' ';
		}
		else if (PixelsPerTile == (MetersPerTile*4))
		{
			LatLon[76] = '.';
			LatLon[77] = '2';
			LatLon[78] = '5';
			Nearest[76] = '.';
			Nearest[77] = '2';
			Nearest[78] = '5';
			UTM[76] = '.';
			UTM[77] = '2';
			UTM[78] = '5';
			USNG[76] = '.';
			USNG[77] = '2';
			USNG[78] = '5';
		}

	}
	if (((Zoom == 1) && (MapType == PHOTO)) || ((Zoom == 3) && (MapType == URBANAREA)))
	{
		LatLon[84] = ' ';
		Nearest[84] = ' ';
		UTM[84] = ' ';
		USNG[84] = ' ';
	}
	else
	{
		LatLon[84] = 's';
		Nearest[84] = 's';
		UTM[84] = 's';
		USNG[84] = 's';
	}
	CheckZoom();
}

void DoZoom(void)
{
	int x, y;
	unsigned int bufsize;
	void *prevX, *nextX, *mixedX;
	unsigned char *prev, *next, *mixed;

	TilesAcross = (rect.right / PixelsPerTile) + 1;
	TilesDown = (rect.bottom / PixelsPerTile) + 1;
	if (ctrlnotused)
	{
		HorizCenter = ScreenLeft + ((rect.right * PrevMetersPerTile) / (2 * PrevPixelsPerTile));
		VertCenter = ScreenTop - ((rect.bottom * PrevMetersPerTile) / (2 * PrevPixelsPerTile));
	}
	else
	{
		ctrlnotused = TRUE;
		HorizCenter = ScreenLeft + ((xPos * PrevMetersPerTile) / PrevPixelsPerTile);
		VertCenter = ScreenTop - ((yPos * PrevMetersPerTile) / PrevPixelsPerTile);
	}
	x = HorizCenter / MetersPerTile;
	y = VertCenter / MetersPerTile;
	colOffset = x - ((TilesAcross-1)/2);
	rowOffset = y - (TilesDown/2);
	if (fade)
	{
		bmih3.biSize = sizeof(BITMAPINFOHEADER);
		bmih3.biWidth = rect.right;
		bmih3.biHeight = -rect.bottom;// - for right-side-up picture
		bmih3.biPlanes = 1;
		bmih3.biBitCount = 24;
		bmih3.biCompression = BI_RGB;
		bmih3.biSizeImage = 0;
		bmi3.bmiHeader = *pbmih3;
		PadBytes = IJL_DIB_PAD_BYTES(rect.right, 3);
		bufsize = (rect.right + PadBytes) * rect.bottom * 3;
		prevX = VirtualAlloc(NULL, bufsize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		prev = (unsigned char*)prevX;
		GetDIBits(hdcMem, hBitmap, 0, rect.bottom, prev, &bmi3, DIB_RGB_COLORS);//put current bitmap into big_buf2
	}
	//////////////////////////////////
	SendMessage(hwnd, WM_USER2, 0, 0);
	//////////////////////////////////
	if (fade)
	{
		char Fading[] = "Hit any key 25 times to increment fading.\n(or hold it down)\n\nPress Esc or Cancel to exit incremental fading.";
		double a, b;

		fade = FALSE;
		if (IDOK == MessageBox(hwnd, Fading, "Fading", MB_OKCANCEL|MB_DEFBUTTON2))
		{
			hdc = GetDC(hwnd);
			hdcMem2 = CreateCompatibleDC(hdc);
			hBitmap2 = CreateCompatibleBitmap(hdc, MapWidth, MapHeight);
			SelectObject(hdcMem2, hBitmap2);
			nextX = VirtualAlloc(NULL, bufsize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
			next = (unsigned char*)nextX;
			mixedX = VirtualAlloc(NULL, bufsize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
			mixed = (unsigned char*)mixedX;
			GetDIBits(hdcMem, hBitmap, 0, rect.bottom, next, &bmi3, DIB_RGB_COLORS);//put new bitmap into big_buf
			FadeIncrement = 10;
			for (x = 0; x < 250; x += FadeIncrement)
			{
				for (u = 0; u < bufsize; u += 3)
				{
					a = x/255.0;//Microsoft's AlphaBlend
					b = 1.0 - a;
					mixed[u] = (BYTE)(((double)next[u] * a) + ((double)prev[u] * b));
					mixed[u+1] = (BYTE)(((double)next[u+1] * a) + ((double)prev[u+1] * b));
					mixed[u+2] = (BYTE)(((double)next[u+2] * a) + ((double)prev[u+2] * b));
				}	
 				SetDIBits(hdcMem2, hBitmap2, 0, rect.bottom, mixed, &bmi3, DIB_RGB_COLORS);
				BitBlt(hdc, 0, 0, rect.right, rect.bottom, hdcMem2, 0, 0, SRCCOPY);
				GetMessage(&msg, hwnd, WM_KEYDOWN, WM_KEYDOWN);
				if (msg.wParam == VK_ESCAPE)
					break;
			}
			VirtualFree(mixed, 0, MEM_RELEASE);
			VirtualFree(next, 0, MEM_RELEASE);
			VirtualFree(prev, 0, MEM_RELEASE);
			DeleteDC(hdcMem2);
			DeleteObject(hBitmap2);
			hdcMem2 = NULL;
			ReleaseDC(hwnd, hdc);
		}
	}
	if (gotelevini)
		GetElevData();
	InvalidateRect(hwnd, &rect, FALSE);
	UpdateWindow(hwnd);
	SendMessage(hwnd, WM_MOUSEMOVE, 0, xPos + (yPos << 16));//to update Lat/Lon of Pointer on Title Bar
}

BOOL PrepBox(int z)
{
	int x, high, low;
//	if ((xcon == 2) && (ycon == 2))
//		x=1;
	New[z] = FALSE;
	tl = ScreenElev[z];
	bl = ScreenElev[z+64];
	tr = ScreenElev[z+1];
	br = ScreenElev[z+65];
	high = tl;
	low = tl;
	if (bl > high)
		high = bl;
	if (bl < low)
		low = bl;
	if (tr > high)
		high = tr;
	if (tr < low)
		low = tr;
	if (br > high)
		high = br;
	if (br < low)
		low = br;
	if ((high - low) < 2)
		return FALSE;//no flat-land contours
//	if ((tl == 0) || (bl == 0) || (tr == 0) || (br == 0))
	if ((tl == 0x8002) || (bl == 0x8002) || (tr == 0x8002) || (br == 0x8002))
	{//if at 0x8002
		if (num)
			Polyline(hdc, Polypoints, num);//draw contour line
		return FALSE;
	}
	x = tl + bl + tr + br;
	mid = x / 4;
	x %= 4;
	if (x >= 2)
		mid++;//round up
//	Polyline(hdc, Polypoints, num);//draw contour line
	return TRUE;
}
// tl+-------------------+tr
//   | \               / |
//   |   \           /   |
//   |     \       /     |
//   |       \   /       |
//   |        mid        |
//   |       /   \       |
//   |     /       \     |
//   |   /           \   |
//   | /               \ |
// bl+-------------------+br

void GetContour(void)
{
	static int w, x, y, z, from, offset;

	FillMemory(Polypoints, sizeof(Polypoints), 0);
	num = 0;
	xcon = xCon;
	ycon = yCon;
	x = (xcon*30)+topleftcol;
	y = (ycon*30)+topleftrow;
	z = (ycon<<6)+xcon;
	if (PrepBox(z) == FALSE)
		return;//if box is semi-level or at 0x8002
	if (tl == contour)//entry point
	{
		Polypoints[num].x = x; Polypoints[num].y = y; num++;//to draw the line thru it
		eleviscontour:
		from = FROM_TL;
		if (mid == contour)
		{
			middleiscontour:
			Polypoints[num].x = x+15; Polypoints[num].y = y+15; num++;
			if (br == contour)//exit point
			{
				loweright:
				Polypoints[num].x = x+30; Polypoints[num].y = y+30;
				if (((y+30) >= rect.bottom) || ((x+30) >= rect.right))
				{
					Polyline(hdc, Polypoints, num+1);//draw contour line
					return;
				}
				for (w = 0; w < num; w++)
				{
					if ((Polypoints[w].x == Polypoints[num].x) && (Polypoints[w].y == Polypoints[num].y))
					{
						Polyline(hdc, Polypoints, num+1);//draw contour line
						return;
					}
				}
				num++;
				w = z+65;
				if (
				  (FALSE == ((ScreenElev[w+65] > contour) && (ScreenElev[w+64] > contour) && (ScreenElev[w+1] > contour)))
				 && (FALSE == ((ScreenElev[w+65] < contour) && (ScreenElev[w+64] < contour) && (ScreenElev[w+1] < contour))))
				{//if not a dead-end
					ycon++;	xcon++; x += 30; y += 30;
					z = w;
					if (PrepBox(z))
						goto eleviscontour;//looking at top left of this box
					else return;
				}
				w = z+64;
				if (
				  (FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+64] > contour) && (ScreenElev[w+65] > contour)))
				 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+64] < contour) && (ScreenElev[w+65] < contour)))
				 && (from != FROM_BL))
				{//if not a dead-end
					ycon++; y += 30;
					z = w;
					if (PrepBox(z))
						goto elev3iscontour;//looking at top right of this box
					else return;
				}
				w = z+1;
				if (
				  (FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+1] > contour) && (ScreenElev[w+65] > contour)))
				 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+1] < contour) && (ScreenElev[w+65] < contour)))
				 && (from != FROM_TR))
				{//if not a dead-end
					xcon++; x+= 30;
					z++;
					if (PrepBox(z))
						goto elev2iscontour;//looking at bottom left of this box
					else return;
				}
			}
			else if (bl == contour)//exit point
				goto lowerleft;
			else if (tr == contour)//exit point
				goto topright;
			else if ((bl > contour) && (br < contour))//exit point
			{
				offset = ((bl-contour)*30)/(bl-br);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto bottomside;
			}
			else if ((br > contour) && (bl < contour))//exit point
			{
				offset = 30-(((br-contour)*30)/(br-bl));
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				bottomside:
				Polypoints[num].y = y+30;
				if ((y+30) >= rect.bottom)
				{
					Polyline(hdc, Polypoints, num+1);
					return;
				}
				for (w = 0; w < num; w++)
				{
					if ((Polypoints[w].x == Polypoints[num].x) && (Polypoints[w].y == Polypoints[num].y))
					{
						Polyline(hdc, Polypoints, num+1);
						return;
					}
				}
				num++;
				ycon++; y += 30;
				z += 64;
				if (PrepBox(z))
					goto topiscontour;
				else return;
			}
			else if ((tr > contour) && (br < contour))//exit point
			{
				offset = ((tr-contour)*30)/(tr-br);
				Polypoints[num].y = y+offset;
				goto rightside;
			}
			else if ((br > contour) && (tr < contour))//exit point
			{
				offset = 30-((br-contour)*30)/(br-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				rightside:
				Polypoints[num].x = x+30;
				if ((x+30) >= rect.right)
				{
					Polyline(hdc, Polypoints, num+1);//draw contour line
					return;
				}
				for (w = 0; w < num; w++)
				{
					if ((Polypoints[w].x == Polypoints[num].x) && (Polypoints[w].y == Polypoints[num].y))
					{
						Polyline(hdc, Polypoints, num+1);//draw contour line
						return;
					}
				}
				num++;
				xcon++; x += 30;
				z++;
				if (PrepBox(z))
					goto leftiscontour;//looking at top left of this box
				else return;
			}
			else if ((from == FROM_T) && (tl > contour) && (bl < contour))
			{
				offset = ((tl-contour)*30)/(tl-bl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto leftside;
			}
			else if ((from == FROM_T) && (bl > contour) && (tl < contour))
			{
				offset = 30-((bl-contour)*30)/(bl-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto leftside;
			}
			else if ((from == FROM_L) && (tl > contour) && (tr < contour))
			{
				offset = ((tl-contour)*30)/(tl-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
			else if ((from == FROM_L) && (tr > contour) && (tl < contour))
			{
				offset = 30-((tr-contour)*30)/(tr-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
		}//end of if (mid == contour)
		else if (bl == contour)//exit point
		{
			lowerleft:
			Polypoints[num].x = x; Polypoints[num].y = y+30;
			if (((y+30) >= rect.bottom) || (x == topleftcol))
			{
				Polyline(hdc, Polypoints, num+1);
				return;
			}
			for (w = 0; w < num; w++)
			{
				if ((Polypoints[w].x == Polypoints[num].x) && (Polypoints[w].y == Polypoints[num].y))
				{
					Polyline(hdc, Polypoints, num+1);
					return;
				}
			}
			num++;
			w = z+64;
			if ((FALSE == ((ScreenElev[w+64] > contour) && (ScreenElev[w+1] > contour) && (ScreenElev[w+65] > contour)))
			 && (FALSE == ((ScreenElev[w+64] < contour) && (ScreenElev[w+1] < contour) && (ScreenElev[w+65] < contour)))
			 && (from != FROM_BR))
			{//if not a dead-end
				ycon++; y += 30;
				z = w;
				if (PrepBox(z))
					goto eleviscontour;//looking at top left of this box
				else return;
			}
			w = z+63;
			if ((FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+64] > contour) && (ScreenElev[w+65] > contour)))
			 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+64] < contour) && (ScreenElev[w+65] < contour))))
			{//if not a dead-end
				ycon++; y += 30;
				xcon--; x -= 30;
				z = w;
				if (PrepBox(z))
					goto elev3iscontour;//looking at top left of this box
				else return;
			}
			w = z-1;
			if (
			  (FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+64] > contour) && (ScreenElev[w+1] > contour)))
			 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+64] < contour) && (ScreenElev[w+1] < contour)))
			 && (from != FROM_TL))
			{
				xcon--; x -= 30;
				z--;
				if (PrepBox(z))
					goto elev4iscontour;//looking at top left of this box
				else return;
			}
		}
		else if (tr == contour)//exit point
		{
			topright:
			Polypoints[num].x = x+30; Polypoints[num].y = y;
			if (((x+30) >= rect.right) || ((y == topleftrow) && (from != FROM_TL)))
			{
				Polyline(hdc, Polypoints, num+1);
				return;
			}
			for (w = 0; w < num; w++)
			{
				if ((Polypoints[w].x == Polypoints[num].x) && (Polypoints[w].y == Polypoints[num].y))
				{
					Polyline(hdc, Polypoints, num+1);
					return;
				}
			}
			num++;
			w = z-63;
			if ((FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+1] > contour) && (ScreenElev[w+65] > contour)))
			 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+1] < contour) && (ScreenElev[w+65] < contour))))
			{//if not a dead-end
				ycon--; y -= 30;
				xcon++; x += 30;
				z = w;
				if (PrepBox(z))
					goto elev2iscontour;
				else return;
			}
			w = z+1;
			if ((FALSE == ((ScreenElev[w+1] > contour) && (ScreenElev[w+64] > contour) && (ScreenElev[w+65] > contour)))
			 && (FALSE == ((ScreenElev[w+1] < contour) && (ScreenElev[w+64] < contour) && (ScreenElev[w+65] < contour)))
			 && (from != FROM_BR))
			{//if not a dead-end
				xcon++; x += 30;
				z = w;
				if (PrepBox(z))
					goto eleviscontour;
				else return;
			}
			w = z-64;
			if ((FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+64] > contour) && (ScreenElev[w+1] > contour)))
			 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+64] < contour) && (ScreenElev[w+1] < contour)))
			 && (from != FROM_TL))
			{//if not a dead-end
				ycon--; y -= 30;
				z = w;
				if (PrepBox(z))
					goto elev4iscontour;
				else return;
			}
		}
		else if ((bl > contour) && (mid < contour))
			goto I0;
		else if ((mid > contour) && (bl < contour))
			goto I1;
		else if ((tr > contour) && (mid < contour))
			goto A1;
		else if ((mid > contour) && (tr < contour))
			goto A2;
	}//end of if (tl == contour)
/////////////////////////////////////////////////////////////////////////////////////////
	else if (bl == contour)//entry point
	{
		Polypoints[num].x = x; Polypoints[num].y = y+30; num++;
		elev2iscontour:
		from = FROM_BL;
		if (mid == contour)
		{
			Polypoints[num].x = x+15; Polypoints[num].y = y+15; num++;
			if (br == contour)//exit point
				goto loweright;
			else if (tr == contour)
				goto topright;
			else if (tl == contour)
				goto topleft;
			else if (br == contour)
				goto loweright;
			else if ((tl > contour) && (tr < contour))//exit point
			{
				offset = ((tl-contour)*30)/(tl-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
			else if ((tr > contour) && (tl < contour))//exit point
			{
				offset = 30-((tr-contour)*30)/(tr-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
			else if ((tr > contour) && (br < contour))//exit point
			{
				offset = ((tr-contour)*30)/(tr-br);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto rightside;
			}
			else if ((br > contour) && (tr < contour))//exit point
			{
				offset = 30-((br-contour)*30)/(br-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto rightside;
			}
		}
		if (br == contour)
			goto loweright;
		else if ((tl > contour) && (mid < contour))
		{
G10:		offset = ((tl-contour)*15)/(tl-mid);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+offset; Polypoints[num].y = y+offset; num++;
			goto G1;
		}
		else if ((mid > contour) && (tl < contour))
		{
G11:		offset = ((mid-contour)*15)/(mid-tl);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+15-offset; Polypoints[num].y = y+15-offset; num++;
G1:			if (tr == contour)
				goto topright;
			else if ((tl > contour) && (tr < contour))//exit point
			{
				offset = ((tl-contour)*30)/(tl-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
			else if ((tr > contour) && (tl < contour))//exit point
				goto D2;
			else if ((tr > contour) && (mid < contour))
				goto A1;
			else if ((mid > contour) && (tr < contour))
				goto A2;
		}
		if ((br > contour) && (mid < contour))
		{
E0:			offset = ((br-contour)*15)/(br-mid);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+30-offset; Polypoints[num].y = y+30-offset; num++;
			goto E1;
		}
		else if ((mid > contour) && (br < contour))
		{
E2:			offset = ((mid-contour)*15)/(mid-br);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+15+offset; Polypoints[num].y = y+15+offset; num++;
E1:			if (tr == contour)
				goto topright;
			else if ((tr > contour) && (br < contour))//exit point
			{
				offset = ((tr-contour)*30)/(tr-br);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto rightside;
			}
			else if ((br > contour) && (tr < contour))//exit point
			{
				offset = ((br-contour)*30)/(br-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+30-offset;
				goto rightside;
			}
			else if ((tr > contour) && (mid < contour))
				goto F0;
			else if ((mid > contour) && (tr < contour))
				goto F2;
  		}
		else if (tl == contour)
			goto topleft;
	}//end of if (bl == contour)

	else if (tr == contour)//entry point
	{
		Polypoints[num].x = x+30; Polypoints[num].y = y; num++;
		elev3iscontour:
		from = FROM_TR;
		if (mid == contour)
		{
			Polypoints[num].x = x+15; Polypoints[num].y = y+15; num++;
			if (bl == contour)
				goto lowerleft;
			else if (br == contour)
				goto loweright;
			else if ((tl > contour) && (bl < contour))
			{
				offset = ((tl-contour)*30)/(tl-bl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto leftside;
			}
			else if ((bl > contour) && (tl < contour))
			{
				offset = 30-((bl-contour)*30)/(bl-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto leftside;
			}
			else if ((bl > contour) && (br < contour))
			{
				offset = (((bl-contour)*30)/(bl-br));
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto bottomside;
			}
			else if ((br > contour) && (bl < contour))
			{
				offset = (((br-contour)*30)/(br-bl));
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+30-offset;
				goto bottomside;
			}
		}
		if (tl == contour)//exit point
			goto topleft;
		if (br == contour)//exit point
			goto loweright;
		if ((tl > contour) && (mid < contour))
			goto H0;
		else if ((mid > contour) && (tl < contour))
			goto H2;
		if ((br > contour) && (mid < contour))
			goto J0;
		else if ((mid > contour) && (br < contour))
			goto J2;
	}//end of if (tr == contour)

	else if (br == contour)//entry point
	{
		Polypoints[num].x = x+30; Polypoints[num].y = y+30; num++;
		elev4iscontour:
		from = FROM_BR;
		if (mid == contour)
		{
			if (tl == contour)//exit point
				goto topleft;
			else if ((tl > contour) && (bl < contour))//exit point
			{
				offset = ((tl-contour)*30)/(tl-bl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto leftside;
			}
			else if ((bl > contour) && (tl < contour))//exit point
			{
				offset =  ((bl-contour)*30)/(bl-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+30-offset;
				goto leftside;
			}
			else if ((tl > contour) && (tr < contour))//exit point
			{
				offset =  ((tl-contour)*30)/(tl-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
			else if ((tr > contour) && (tl < contour))//exit point
			{
				offset =  30-((tr-contour)*30)/(tr-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
		}
		if (bl == contour)//exit point
			goto lowerleft;
		if (tr == contour)//exit point
			goto topright;
		else if ((bl > contour) && (mid < contour))
			goto T0;
		else if ((mid > contour) && (bl < contour))
			goto T2;
		else if ((tr > contour) && (mid < contour))
			goto F0;
		else if ((mid > contour) && (tr < contour))
			goto F2;
	}//end of if (br == contour)

	else if ((tl > contour) && (tr < contour))//entry point
	{
		from = 0;
		offset = ((tl-contour)*30)/(tl-tr);
		if (offset == 0) offset = 1;
		Polypoints[num].x = x+offset;
		goto W1;
	}
	else if ((tr > contour) && (tl < contour))//entry point
	{
		offset = ((tr-contour)*30)/(tr-tl);
		if (offset == 0) offset = 1;
		Polypoints[num].x = x+30-offset;
W1:		Polypoints[num].y = y;
		num++;
		topiscontour:
		from = FROM_T;
		if (mid == contour)
			goto middleiscontour;
		else if ((tl > contour) && (mid < contour))
		{
H0:			offset = ((tl-contour)*15)/(tl-mid);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+offset; Polypoints[num].y = y+offset; num++;
			goto H1;
		}
		else if ((mid > contour) && (tl < contour))
		{
H2:			offset = ((mid-contour)*15)/(mid-tl);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+15-offset; Polypoints[num].y = y+15-offset; num++;
H1:			if ((tl > contour) && (bl < contour))
			{
				offset = ((tl-contour)*30)/(tl-bl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto leftside;
			}
			else if ((bl > contour) && (tl < contour))
			{
				offset = ((bl-contour)*30)/(bl-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+30-offset;
				goto leftside;
			}
			else if (bl == contour)
				goto lowerleft;
			else if ((bl > contour) && (mid < contour))
				goto I0;
			else if ((mid > contour) && (bl < contour))
				goto I1;
		}
		else if ((tr > contour) && (mid < contour))
		{
A1:			offset = ((tr-contour)*15)/(tr-mid);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+30-offset; Polypoints[num].y = y+offset; num++;
			goto A3;
		}
		else if ((mid > contour) && (tr < contour))
		{
A2:			offset = ((mid-contour)*15)/(mid-tr);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+15+offset; Polypoints[num].y = y+15-offset; num++;
A3:			if (br == contour)
				goto loweright;
			else if ((tr > contour) && (br < contour))//exit point
			{
				Polypoints[num].y = y+((tr-contour)*30)/(tr-br);
				goto rightside;
			}
			else if ((br > contour) && (tr < contour))
			{
				offset = ((br-contour)*30)/(br-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+30-offset;
				goto rightside;
			}
			else if ((mid > contour) && (br < contour))
			{
				offset = ((mid-contour)*15)/(mid-br);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+15+offset; Polypoints[num].y = y+15+offset; num++;
				goto S1;
			}
			else if ((br > contour) && (mid < contour))
			{
				offset = ((br-contour)*15)/(br-mid);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+30-offset; Polypoints[num].y = y+30-offset; num++;
S1:				if ((bl > contour) && (br < contour))
				{
					offset = (((bl-contour)*30)/(bl-br));
					if (offset == 0) offset = 1;
					Polypoints[num].x = x+offset;
					goto bottomside;
				}
				else if ((br > contour) && (bl < contour))
				{
					offset = (((br-contour)*30)/(br-bl));
					if (offset == 0) offset = 1;
					Polypoints[num].x = x+30-offset;
					goto bottomside;
				}
				else if (bl == contour)
					goto lowerleft;
				else if ((bl > contour) && (mid < contour))
				{
T0:					offset = ((bl-contour)*15)/(bl-mid);
					if (offset == 0) offset = 1;
					Polypoints[num].x = x+offset; Polypoints[num].y = y+30-offset; num++;
					goto T1;
				}
				else if ((mid > contour) && (bl < contour))
				{
T2:					offset = ((mid-contour)*15)/(mid-bl);
					if (offset == 0) offset = 1;
					Polypoints[num].x = x+15-offset; Polypoints[num].y = y+15+offset; num++;
T1:					if ((tl > contour) && (bl < contour))
					{
						offset = ((tl-contour)*30)/(tl-bl);
						if (offset == 0) offset = 1;
						Polypoints[num].y = y+offset;
						goto leftside;
					}
					else if ((bl > contour) && (tl < contour))//exit point
					{
						offset =  ((bl-contour)*30)/(bl-tl);
						if (offset == 0) offset = 1;
						Polypoints[num].y = y+30-offset;
leftside:
						Polypoints[num].x = x;
						if (x == topleftcol)
						{
							Polyline(hdc, Polypoints, num+1);//draw contour line
							return;
						}
						for (w = 0; w < num; w++)
						{
							if ((Polypoints[w].x == Polypoints[num].x) && (Polypoints[w].y == Polypoints[num].y))
							{
								Polyline(hdc, Polypoints, num+1);//draw contour line
								return;
							}
						}
						num++;
//						if (New[z-1])
						{
							xcon--; x -= 30;
							z--;
							if (PrepBox(z))
								goto rightiscontour;
							else return;
						}
//						else
//							return;
					}
				}
			}
		}
	}//end of if ((tl > contour) && tr < contour)//entry point

	else if ((tl > contour) && (bl < contour))//entry point
	{
		offset = ((tl-contour)*30)/(tl-bl);
		if (offset == 0) offset = 1;
		Polypoints[num].x = x; Polypoints[num].y = y+offset; num++;
		goto leftiscontour;
	}
	else if ((bl > contour) && (tl < contour))//entry point
	{
		offset = ((bl-contour)*30)/(bl-tl);
		if (offset == 0) offset = 1;
		Polypoints[num].x = x; Polypoints[num].y = y+30-offset; num++;
		leftiscontour:
		from = FROM_L;
 		if (mid == contour)
			goto middleiscontour;
		else if ((tl > contour) && (mid < contour))
			goto G10;
		else if ((mid > contour) && (tl < contour))
			goto G11;
		else if ((bl > contour) && (mid < contour))
		{
I0:			offset = ((bl-contour)*15)/(bl-mid);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+offset; Polypoints[num].y = y+30-offset; num++;
			goto I2;
		}
		else if ((mid > contour) && (bl < contour))
		{
I1:			offset = ((mid-contour)*15)/(mid-bl);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+15-offset; Polypoints[num].y = y+15+offset; num++;
I2:			if (br == contour)
				goto loweright;
			else if ((bl > contour) && (br < contour))
			{
				offset = (((bl-contour)*30)/(bl-br));
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto bottomside;
			}
			else if ((br > contour) && (bl < contour))
			{
				offset = (((br-contour)*30)/(br-bl));
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+30-offset;
				goto bottomside;
			}
			else if ((br > contour) && (mid < contour))
				goto E0;
			else if ((mid > contour) && (br < contour))
				goto E2;
		}
	}//end of if ((tl > contour) && bl < contour)//entry point

	else if ((tr > contour) && br < contour)//entry point
	{
		offset = ((tr-contour)*30)/(tr-br);
		if (offset == 0) offset = 1;
		Polypoints[num].y = y+offset;
		goto B1;
	}
	else if ((br > contour) && (tr < contour))//entry point
	{
		offset = ((br-contour)*30)/(br-tr);
		if (offset == 0) offset = 1;
		Polypoints[num].y = y+30-offset;
B1:		Polypoints[num].x = x+30;
		num++;
		rightiscontour:
		from = FROM_R;
		if (mid == contour)
		{
			Polypoints[num].x = x+15; Polypoints[num].y = y+15; num++;
			if ((tl > contour) && (bl < contour))
			{
				offset = ((tl-contour)*30)/(tl-bl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+offset;
				goto leftside;
			}
			else if ((bl > contour) && (tl < contour))
			{
				offset = ((bl-contour)*30)/(bl-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].y = y+30-offset;
				goto leftside;
			}
			else if ((tl > contour) && (tr < contour))//exit point
			{
				offset = ((tl-contour)*30)/(tl-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
			else if ((tr > contour) && (tl < contour))//exit point
			{
D2:				offset = ((tr-contour)*30)/(tr-tl);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+30-offset;
				topside:
				Polypoints[num].y = y;
				if (y == topleftrow)
				{
					Polyline(hdc, Polypoints, num+1);//draw contour line
					return;
				}
				for (w = 0; w < num; w++)
				{
					if ((Polypoints[w].x == Polypoints[num].x) && (Polypoints[w].y == Polypoints[num].y))
					{
						Polyline(hdc, Polypoints, num+1);//draw contour line
						return;
					}
				}
				num++;
				ycon--; y -= 30;
				z -= 64;
				if (PrepBox(z) == FALSE)
					return;
				//bottomiscontour:
				from = FROM_B;
				if (mid == contour)
				{
					Polypoints[num].x = x+15; Polypoints[num].y = y+15; num++;
					if (tl == contour)
						goto topleft;
					else if (tr == contour)
						goto topright;
					else if ((tl > contour) && (tr < contour))//exit point
					{
						offset = ((tl-contour)*30)/(tl-tr);
						if (offset == 0) offset = 1;
						Polypoints[num].x = x+offset;
						goto topside;
					}
					else if ((tr > contour) && (tl < contour))//exit point
					{
						offset = ((tr-contour)*30)/(tr-tl);
						if (offset == 0) offset = 1;
						Polypoints[num].x = x+30-offset;
						goto topside;
					}
					else if ((tl > contour) && (bl < contour))//exit point
					{
						offset = ((tl-contour)*30)/(tl-bl);
						if (offset == 0) offset = 1;
						Polypoints[num].y = y+offset;
						goto leftside;
					}
					else if ((bl > contour) && (tl < contour))//exit point
					{
						offset = ((bl-contour)*30)/(bl-tl);
						if (offset == 0) offset = 1;
						Polypoints[num].y = y+30-offset;
						goto leftside;
					}
					else if ((tr > contour) && (br < contour))//exit point
					{
						offset = ((tr-contour)*30)/(tr-br);
						if (offset == 0) offset = 1;
						Polypoints[num].y = y+offset;
						goto rightside;
					}
					else if ((br > contour) && (tr < contour))//exit point
					{
						offset = ((br-contour)*30)/(br-tr);
						if (offset == 0) offset = 1;
						Polypoints[num].y = y+30-offset;
						goto rightside;
					}
				}
				else if ((bl > contour) && (mid < contour))
				{
					offset = ((bl-contour)*15)/(bl-mid);
					if (offset == 0) offset = 1;
					Polypoints[num].x = x+offset; Polypoints[num].y = y+30-offset; num++;
					goto P1;
				}
				else if ((mid > contour) && (bl < contour))
				{
					offset = ((mid-contour)*15)/(mid-bl);
					if (offset == 0) offset = 1;
					Polypoints[num].x = x+15-offset; Polypoints[num].y = y+15+offset; num++;
P1:					if ((tl > contour) && (bl < contour))
					{
						Polypoints[num].y = y+((tl-contour)*30)/(tl-bl);
						goto leftside;
					}
					else if ((bl > contour) && (tl < contour))//exit point
					{
						Polypoints[num].y = y+30-((bl-contour)*30)/(bl-tl);
						goto leftside;
					}
					else if (tl == contour)
						goto topleft;
					else if ((tl > contour) && (mid < contour))
						goto G10;
					else if ((mid > contour) && (tl < contour))
						goto G11;
				}
				else if ((br > contour) && (mid < contour))
					goto E0;
				else if ((mid > contour) && (br < contour))
					goto E2;
			}
			else if ((bl > contour) && (br < contour))//exit point
			{
				offset = (((bl-contour)*30)/(bl-br));
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto bottomside;
			}
			else if ((br > contour) && (bl < contour))//exit point
			{
				offset = (((br-contour)*30)/(br-bl));
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+30-offset;
				goto bottomside;
			}
			else if (tl == contour)//exit point
			{
				topleft:
				Polypoints[num].x = x; Polypoints[num].y = y;
				if ((x == topleftcol) || (y == topleftrow))
				{
					Polyline(hdc, Polypoints, num+1);//draw contour line
					return;
				}
				for (w = 0; w < num; w++)
				{
					if ((Polypoints[w].x == Polypoints[num].x) && (Polypoints[w].y == Polypoints[num].y))
					{
						Polyline(hdc, Polypoints, num+1);//draw contour line
						return;
					}
				}
				num++;
				w = z-65;
				if ((FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+1] > contour) && (ScreenElev[w+64] > contour)))
				 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+1] < contour) && (ScreenElev[w+64] < contour))))
				{//if not a dead-end
					ycon--; y -= 30;
					xcon--; x -= 30;
					z = w;
					if (PrepBox(z))
						goto elev4iscontour;
					else return;
				}
				w = z-1;
				if ((FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+64] > contour) && (ScreenElev[w+65] > contour)))
				 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+64] < contour) && (ScreenElev[w+65] < contour)))
				 && (from != FROM_BL))
				{
					xcon--; x -= 30;
					z--;
					if (PrepBox(z))
						goto elev4iscontour;
					else return;
				}
				w = z-64;
				if ((FALSE == ((ScreenElev[w] > contour) && (ScreenElev[w+1] > contour) && (ScreenElev[w+65] > contour)))
				 && (FALSE == ((ScreenElev[w] < contour) && (ScreenElev[w+1] < contour) && (ScreenElev[w+65] < contour)))
				 && (from != FROM_TR))
				{//if not a dead-end
					ycon--; y -= 30;
					z = w;
					if (PrepBox(z))
						goto elev3iscontour;
					else return;
				}
			}
			else if (bl == contour)//exit point
				goto lowerleft;
		}
		else if ((tr > contour) && (mid < contour))
		{
F0:			offset = ((tr-contour)*15)/(tr-mid);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+30-offset; Polypoints[num].y = y+offset; num++;
			goto F1;
		}
		else if ((mid > contour) && (tr < contour))
		{
F2:			offset = ((mid-contour)*15)/(mid-tr);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+15+offset; Polypoints[num].y = y+15-offset; num++;
F1:			if (tl == contour)
				goto topleft;
			else if ((tl > contour) && (tr < contour))
			{
				offset =  ((tl-contour)*30)/(tl-tr);
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+offset;
				goto topside;
			}
			else if ((tr > contour) && (tl < contour))
				goto D2;
			else if ((tl > contour) && (mid < contour))
				goto H0;
			else if ((mid > contour) && (tl < contour))
				goto H2;
		}
		else if ((br > contour) && (mid < contour))
		{
J0:			offset = ((br-contour)*15)/(br-mid);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+30-offset; Polypoints[num].y = y+30-offset; num++;
			goto J1;
		}
		else if ((mid > contour) && (br < contour))
		{
J2:			offset = ((mid-contour)*15)/(mid-br);
			if (offset == 0) offset = 1;
			Polypoints[num].x = x+15+offset; Polypoints[num].y = y+15+offset; num++;
J1:			if (bl == contour)
				goto lowerleft;
			else if ((bl > contour) && (br < contour))
			{
				offset =  (((bl-contour)*30)/(bl-br));
				if (offset == 0)
					offset = 1;
				Polypoints[num].x = x+offset;
				goto bottomside;
			}
			else if ((br > contour) && (bl < contour))
			{
				offset =  (((br-contour)*30)/(br-bl));
				if (offset == 0) offset = 1;
				Polypoints[num].x = x+30-offset;
				goto bottomside;
			}
			else if ((bl > contour) && (mid < contour))
				goto T0;
			else if ((mid > contour) && (bl < contour))
				goto T2;
		}
	}//end of if ((tr > contour) && br < contour)//entry point
}//end of GetContour



int CALLBACK GetFilenameProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetFocus(hwndText);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			TextBufSize = GetWindowText(hwndText, Tracks, MAX_TEXT);
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK GetTextProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, y, z;
	static HWND hwndText;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
		SendMessage(hwndText, EM_LIMITTEXT, (WPARAM)MAX_TEXT, 0);
		SetFocus(hwndText);
		if (gotstreet)
		{
			if (NamePtr2 == NULL)
			{
//				Angle = (double)Angle1 / 10.0;
				SetWindowText(hwndText, NamePtr1);
			}
			else
			{
				x = MessageBox(hwnd, "Select YES to save this one\nor NO to save the other one", NamePtr1, MB_YESNOCANCEL);
				if (IDYES == x)
				{
//					Angle = (double)Angle1 / 10.0;
					SetWindowText(hwndText, NamePtr1);
					NamePtr2 = NULL;//flag
				}
				else if (IDNO == x)
				{
//					Angle = (double)Angle2 / 10.0;
					SetWindowText(hwndText, NamePtr2);
				}
				else
				{
					EndDialog (hwndDlg, FALSE);
					return FALSE;
				}
			}
		}
		TextBufSize = 0;//in case it's cancelled
		if (MapType == TOPO)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO6, IDC_RADIO5);
		else
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO6, IDC_RADIO6);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_RADIO1:
			ZoomandBelow = 8;
			break;
		case IDC_RADIO2:
			ZoomandBelow = 7;
			break;
		case IDC_RADIO3:
			ZoomandBelow = 6;
			break;
		case IDC_RADIO4:
			ZoomandBelow = 5;
			break;
		case IDC_RADIO5:
			ZoomandBelow = 3;
			break;
		case IDC_RADIO6:
			ZoomandBelow = 2;
			break;

		case IDOK:
			CheckMenuItem(hMenu, ID_TEXT_SHOWALL, MF_CHECKED);
			TextBufSize = GetWindowText(hwndText, TextBuf, MAX_TEXT);
			if (TextBufSize == 0)
				break;
			new_node = (struct Text*) calloc(1, sizeof(struct Text));
			strcpy(new_node->text, TextBuf);
			if (usamap)
			{
				new_node->Zoom = ZoomandBelow;
 				new_node->NUTM = yBeg;
				new_node->EUTM = xBeg;
			}
			else
			{
				new_node->Zoom = ZoomandBelow;
 				new_node->NUTM = ScreenTop - (yBeg*MetersPerTile/PixelsPerTile);
				new_node->EUTM = ScreenLeft + (xBeg*MetersPerTile/PixelsPerTile);
			}
			if (gotstreet)
			{
				if (NamePtr2 == NULL)
					new_node->angle = Angle1;
				else
					new_node->angle = Angle2;
			}
			else
				new_node->angle = (int)Angle;

			for (cur = head, prev = NULL; cur != NULL; prev = cur, cur = cur->next)
			{
				for (x = 0; new_node->text[x] != 0; x++)
				{
					y = 0xFFFFFFDF & new_node->text[x];//make 'a' into 'A'
					z = 0xFFFFFFDF & cur->text[x];
					if (y > z)
						break;
					if (y < z)
						goto sorted;
				}
				if (new_node->text[x] == 0)//they're equal
				{
					if (new_node->NUTM > cur->NUTM)
						break;//if further north
					else if ((new_node->NUTM == cur->NUTM) && (new_node->EUTM < cur->EUTM))//if further west
						break;
				}
			}
sorted:		new_node->next = cur;
			if (prev != NULL)
				prev->next = new_node;
			else
				head = new_node;
			newText = TRUE;
			if (MF_UNCHECKED == CheckMenuItem(hMenu, ID_TEXT_SHOWALL, MF_BYCOMMAND))
				CheckMenuItem(hMenu, ID_TEXT_SHOWALL, MF_CHECKED);
			if (usamap)
				usatext = TRUE;
			else
				showtext = TRUE;
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK EditTextProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
//		lf.lfHeight = -15;
//		lf.lfWeight = 400;
//		lf.lfEscapement = lf.lfOrientation = 0;
//		hFont = CreateFontIndirect (&lf);
//		SelectObject (hdc, hFont);
		SetWindowText(hwndText, chosen->text);
//		SendMessage(hwndText, WM_SETFONT, (UINT)hFont, TRUE);
		SendMessage(hwndText, EM_LIMITTEXT, (WPARAM)MAX_TEXT, 0);
		SetFocus(hwndDlg);
		TextBufSize = 0;//in case it's cancelled
		ZoomandBelow = chosen->Zoom;
		switch (ZoomandBelow)
		{
		case 0:
		case 2:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO6, IDC_RADIO6);
			break;		
		case 3:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO6, IDC_RADIO5);
			break;		
		case 5:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO6, IDC_RADIO4);
			break;		
		case 6:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO6, IDC_RADIO3);
			break;		
		case 7:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO6, IDC_RADIO2);
			break;		
		case 8:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO6, IDC_RADIO1);
			break;		
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_RADIO1:
			ZoomandBelow = 8;
			break;
		case IDC_RADIO2:
			ZoomandBelow = 7;
			break;
		case IDC_RADIO3:
			ZoomandBelow = 6;
			break;
		case IDC_RADIO4:
			ZoomandBelow = 5;
			break;
		case IDC_RADIO5:
			ZoomandBelow = 3;
			break;
		case IDC_RADIO6:
			ZoomandBelow = 2;
			break;

		case IDOK:
			TextBufSize = GetWindowText(hwndText, TextBuf, MAX_TEXT);
			if (TextBufSize == 0)
				break;
			strcpy(chosen->text, TextBuf);
			chosen->Zoom = ZoomandBelow;
			newText = TRUE;
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK LineProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int Tabs[1];
	static HWND hwndList;
	HDC hdcList;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndList = GetDlgItem(hwndDlg, IDC_LIST1);
		hdcList = GetDC(hwndList);
		hFont = CreateFontIndirect (&lf2);
		SelectObject(hdcList, hFont);
		ReleaseDC(hwndList, hdcList);
		SendMessage(hwndList, WM_SETFONT, (UINT)hFont, TRUE);
		x = FillListBox(hwndDlg);
		Tabs[0] = (longest+1) * 11 / 2;//empirically arrived at
		SendMessage(hwndList, LB_SETTABSTOPS, (WPARAM)1, (LPARAM)&Tabs);
		if (index != -1)
			SendMessage(hwndList, LB_SETCURSEL, (WPARAM)index, 0);
		LineEnd = index;
		SetFocus(hwndList);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_DBLCLK)
			{//GoTo
				if (ChosenLoc != -1)
				{
					EndDialog (hwndDlg, 0);
					return TRUE;
				}
			}
			else if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				LineEnd = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
				if (NewLoc[LineEnd].EUTM == 0)
					LineEnd = -1;
			}
			break;

		case IDOK:
			if (LineEnd != -1)
			{
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			break;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

void GetCities(void)
{
	SendMessage(hwndCity, LB_RESETCONTENT, 0, 0);
	if (StateIndex)
	{
		USGSFile[qm] = States[StateIndex][0];
		USGSFile[qm+1] = States[StateIndex][1];
		hStateFile = CreateFile(USGSFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hStateFile != INVALID_HANDLE_VALUE)
		{
			fileSize = GetFileSize(hStateFile, NULL);
			if (fileSize)
			{
				StateBuf = (char*)malloc(fileSize);
				ReadFile(hStateFile, StateBuf, fileSize, &dwBytesRead, NULL);
				for (y = 0; y < fileSize; y += 2)
				{
					z = y;
					for ( ; StateBuf[y] != '\r'; y++)
						;
					StateBuf[y] = 0;
					SendMessage(hwndCity, LB_ADDSTRING, 0, (LPARAM)&StateBuf[z]);
				}
				free(StateBuf);
			}
			CloseHandle(hStateFile);
		}
		else
		{
			if (IDOK == MessageBox(hwnd, "Do you want to download 1.9 MBytes of\nPopulated Place data from jdmcox.com?", "FIRST", MB_OKCANCEL))
				hDownloadStatesThread = _beginthreadex(NULL, 0, DownloadStatesThread, hwnd, 0, &idThread10);
		}
	}
}

int CALLBACK USGSProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
		hwndState = GetDlgItem(hwndDlg, IDC_LIST1);
		hwndCity = GetDlgItem(hwndDlg, IDC_LIST2);
		for (x = 0; x < 54; x++)
			SendMessage(hwndState, LB_ADDSTRING, 0, (LPARAM)States[x]);
		SetFocus(hwndState);
		SendMessage(hwndState, LB_SETCURSEL, 0, 0);
		CityIndex = -1;
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_SELCHANGE)
				StateIndex = SendMessage(hwndState, LB_GETCURSEL, 0, 0);
			else if (HIWORD (wParam) == LBN_DBLCLK)
				GetCities();
			break;

		case IDC_LIST2:
			if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				CityIndex = SendMessage(hwndCity, LB_GETCURSEL, 0, 0);
				SendMessage(hwndCity, LB_GETTEXT, (WPARAM)CityIndex, (LPARAM)City);
			}
			else if (HIWORD (wParam) == LBN_DBLCLK)
			{
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			break;

		case IDOK:
			if (hwndState == GetFocus())
			{
				GetCities();
			}
			else if (CityIndex != -1)
			{
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			break;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

//d = 3960 * acos(sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(abs(lon2 - lon1)));//(lat1 = deg * deg2rad)
void DrawLineTo(int Nutm, int Eutm)
{
	int x, y, z;
//knowing that 2 similar legs of overlapping triangles are proportional to each other...
	if ((Eutm > UTMCenterX) && (UTMCenterY > Nutm))
	{//bottom right
		x = Eutm - UTMCenterX;
		if (x == 0) x = 1;
		y = UTMCenterY - Nutm;
		if (y == 0) y = 1;
		z = centerX + ((rect.bottom - centerY) * x) / y;
		A = x*0.00621371192;//10 * miles/meter
		B = y*0.00621371192;
		distance = (int) sqrt(A*A + B*B);
		if (z < LineRight)
		{
			LineTo(hdc, z, rect.bottom);
			ShowDistance(distance, z-5, rect.bottom-30);
		}
		else
		{//right lower
			z = centerY + (LineRight-centerX)*y/x;
			LineTo(hdc, LineRight, z);
			ShowDistance(distance, LineRight-35, z);
		}
		if (y < x)
			d = 90.0 + atan((double)y / (double)x) * rad2deg;
		else
			d = 180.0 - atan((double)x / (double)y) * rad2deg;
	}
	else if ((UTMCenterX > Eutm) && (UTMCenterY > Nutm))
	{//bottom left
		x = UTMCenterX - Eutm;
		if (x == 0) x = 1;
		y = UTMCenterY - Nutm;
		if (y == 0) y = 1;
		z = centerX - ((rect.bottom-centerY)*x)/y;
		A = x*0.00621371192;//10 * miles/meter
		B = y*0.00621371192;
		distance = (int) sqrt(A*A + B*B);
		if (z > 0)
		{
			LineTo(hdc, z, rect.bottom);
			ShowDistance(distance, z-5, rect.bottom-30);
		}
		else
		{//left lower
			z = centerY + centerX*y/x;
			LineTo(hdc, 0, z);
			ShowDistance(distance, 0, z);
		}
		if (x < y)
			d = 180.0 + atan((double)x / (double)y) * rad2deg;
		else
			d = 270.0 - atan((double)y / (double)x) * rad2deg;
	}
	else if ((UTMCenterX > Eutm) && (Nutm >= UTMCenterY))
	{//top left
		x = UTMCenterX - Eutm;
		if (x == 0) x = 1;
		y = Nutm - UTMCenterY;
		if (y == 0) y = 1;
		z = centerX - (centerY*x)/y;
		A = x*0.00621371192;//10 * miles/meter
		B = y*0.00621371192;
		distance = (int) sqrt(A*A + B*B);
		if (z > 0)
		{
			LineTo(hdc, z, rect.top);
			ShowDistance(distance, z, rect.top);
		}
		else
		{//left upper
			z = centerY - (centerX*y)/x;
			LineTo(hdc, 0, z);
			ShowDistance(distance, 0, z);
		}
		if (y < x)
			d = 270.0 + atan((double)y / (double)x) * rad2deg;
		else
			d = 360.0 - atan((double)x / (double)y) * rad2deg;
	}
	else if ((Eutm > UTMCenterX) && (Nutm >= UTMCenterY))
	{//top right
		x = Eutm - UTMCenterX;
		if (x == 0) x = 1;
		y = Nutm - UTMCenterY;
		if (y == 0) y = 1;
		z = centerX + (centerY*x)/y;
		A = x*0.00621371192;//10 * miles/meter
		B = y*0.00621371192;
		distance = (int) sqrt(A*A + B*B);
		if (z < LineRight)
		{
			LineTo(hdc, z, rect.top);
			ShowDistance(distance, z-30, rect.top);
		}
		else
		{//right upper
			z = centerY - ((LineRight-centerX)*y)/x;
			LineTo(hdc, LineRight, z);
			ShowDistance(distance, LineRight-35, z);
		}
		if (x < y)
			d = atan((double)x / (double)y) * rad2deg;
		else
			d = 90.0 - atan((double)y / (double)x) * rad2deg;
	}
	x = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
	y = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
	z = sprintf(RouteDist, "    %.1f deg ", d);
	TextOut(hdc, x, y, RouteDist, z);
}

void DrawLine2(int X, int Nutm, int Eutm)
{
	int x, y, z;
//knowing that 2 similar legs of overlapping triangles are proportional to each other...
	if ((Eutm > pRoute[X].EUTM) && (pRoute[X].NUTM > Nutm))
	{//bottom right
		x = Eutm - pRoute[X].EUTM;
		if (x == 0) x = 1;
		y = pRoute[X].NUTM - Nutm;
		if (y == 0) y = 1;
		z = DotX + ((rect.bottom - DotY) * x) / y;
		if (z < LineRight) LineTo(hdc, z, rect.bottom);
		else
		{//right lower
			z = DotY + (rect.right-DotX) * y / x;
			LineTo(hdc, rect.right, z);
		}
	}
	else if ((pRoute[X].EUTM > Eutm) && (pRoute[X].NUTM > Nutm))
	{//bottom left
		x = pRoute[X].EUTM - Eutm;
		if (x == 0) x = 1;
		y = pRoute[X].NUTM - Nutm;
		if (y == 0) y = 1;
		z = DotX - ((rect.bottom-DotY) * x) / y;
		if (z > 0) LineTo(hdc, z, rect.bottom);
		else
		{//left lower
			z = DotY + DotX * y / x;
			LineTo(hdc, 0, z);
		}
	}
	else if ((pRoute[X].EUTM > Eutm) && (Nutm >= pRoute[X].NUTM))
	{//top left
		x = pRoute[X].EUTM - Eutm;
		if (x == 0) x = 1;
		y = Nutm - pRoute[X].NUTM;
		if (y == 0) y = 1;
		z = DotX - (DotY * x) / y;
		if (z > 0) LineTo(hdc, z, rect.top);
		else
		{//left upper
			z = DotY - (DotX * y) / x;
			LineTo(hdc, 0, z);
		}
	}
	else if ((Eutm > pRoute[X].EUTM) && (Nutm >= pRoute[X].NUTM))
	{//top right
		x = Eutm - pRoute[X].EUTM;
		if (x == 0) x = 1;
		y = Nutm - pRoute[X].NUTM;
		if (y == 0) y = 1;
		z = DotX + (DotY * x) / y;
		if (z < LineRight) LineTo(hdc, z, rect.top);
		else
		{//right upper
			z = DotY - ((rect.right-DotX) * y) / x;
			LineTo(hdc, rect.right, z);
		}
	}
}

void InitializeOpenFileNameLogFont(HWND hwnd)
{
	int x;

	ofn.lStructSize       = sizeof(OPENFILENAME);
	ofn.hwndOwner         = hwnd;
	ofn.hInstance         = NULL;
	ofn.lpstrFilter       = " *.csv\0*.csv\0\0";
	ofn.lpstrFile         = FullTracks;
	ofn.lpstrFileTitle    = Tracks;
	ofn.Flags             = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
	ofn.lpstrTitle        = NULL;
	ofn.lpstrDefExt       = csv;
	ofn.nMaxFile          = MAX_PATH;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter    = 0;
	ofn.nFilterIndex      = 0;
	ofn.nMaxFileTitle     = MAX_PATH;
	ofn.lpstrInitialDir   = CurrentDir;
	ofn.nFileOffset       = 0;
	ofn.nFileExtension    = 0;
	ofn.lCustData         = 0;
	ofn.lpfnHook          = NULL;
	ofn.lpTemplateName    = NULL;

	ofn2.lStructSize       = sizeof (OPENFILENAME) ;
	ofn2.hwndOwner         = hwnd ;
	ofn2.hInstance         = NULL ;
	ofn2.lpstrCustomFilter = NULL ;
	ofn2.nMaxCustFilter    = 0 ;
	ofn2.nFilterIndex      = 0 ;
	ofn2.lpstrFile         = WaypointsFullPath;
	ofn2.nMaxFile          = MAX_PATH ;
	ofn2.lpstrFileTitle    = Waypoints ;
	ofn2.nMaxFileTitle     = MAX_PATH ;
	ofn2.lpstrInitialDir   = CurrentDir;
	ofn2.lpstrTitle        = NULL ;
	ofn2.Flags             = OFN_HIDEREADONLY | OFN_NOCHANGEDIR | OFN_CREATEPROMPT;
	ofn2.nFileOffset       = 0 ;
	ofn2.nFileExtension    = 0 ;
	ofn2.lpstrDefExt       = xml ;
	ofn2.lCustData         = 0L ;
	ofn2.lpfnHook          = NULL ;
	ofn2.lpTemplateName    = NULL ;

	ofn3.lStructSize       = sizeof(OPENFILENAME);
	ofn3.hwndOwner         = hwnd;
	ofn3.hInstance         = NULL;
	ofn3.lpstrFilter       = " *.txt\0*.txt\0\0";
	ofn3.lpstrCustomFilter = NULL;//" *.txt\0*.txt\0";
	ofn3.nMaxCustFilter    = 0;//40
	ofn3.nFilterIndex      = 0;
	ofn3.lpstrFile         = FullRoutes;
	ofn3.nMaxFile          = MAX_PATH;
	ofn3.lpstrFileTitle    = Routes;
	ofn3.nMaxFileTitle     = MAX_PATH;
	ofn3.lpstrInitialDir   = CurrentDir;
	ofn3.lpstrTitle        = "Route Files";
	ofn3.Flags             = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
	ofn3.nFileOffset       = 0;
	ofn3.nFileExtension    = 0;
	ofn3.lpstrDefExt       = txt;
	ofn3.lCustData         = 0;
	ofn3.lpfnHook          = NULL;
	ofn3.lpTemplateName    = NULL;

	ofn4.lStructSize       = sizeof (OPENFILENAME) ;
	ofn4.hwndOwner         = hwnd ;
	ofn4.hInstance         = NULL ;
	ofn4.lpstrFilter       = " *.psp\0""*.psp\0\0";
	ofn4.lpstrCustomFilter = NULL ;
	ofn4.nMaxCustFilter    = 0 ;
	ofn4.nFilterIndex      = 0 ;
	ofn4.lpstrFile         = PushPins;
	ofn4.nMaxFile          = MAX_PATH ;
	ofn4.lpstrFileTitle    = NULL;
	ofn4.nMaxFileTitle     = MAX_PATH ;
	ofn4.lpstrInitialDir   = CurrentDir;
	ofn4.lpstrTitle        = "Import Streets & Trips .psp file";
	ofn4.Flags             = OFN_HIDEREADONLY | OFN_NOCHANGEDIR | OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT;
	ofn4.nFileOffset       = 0 ;
	ofn4.nFileExtension    = 0 ;
	ofn4.lpstrDefExt       = 0 ;
	ofn4.lCustData         = 0L ;
	ofn4.lpfnHook          = NULL ;
	ofn4.lpTemplateName    = NULL ;

	ofn5.lStructSize       = sizeof (OPENFILENAME) ;
	ofn5.hwndOwner         = hwnd ;
	ofn5.hInstance         = NULL ;
	ofn5.lpstrCustomFilter = NULL ;
	ofn5.nMaxCustFilter    = 0 ;
	ofn5.nFilterIndex      = 0 ;
	ofn5.nMaxFile          = MAX_PATH ;
	ofn5.nMaxFileTitle     = MAX_PATH ;
	ofn5.lpstrInitialDir   = CurrentDir;
	ofn5.nFileOffset       = 0 ;
	ofn5.nFileExtension    = 0 ;
	ofn5.lCustData         = 0L ;
	ofn5.lpfnHook          = NULL ;
	ofn5.lpTemplateName    = NULL ;

	ofn6.lStructSize       = sizeof(OPENFILENAME);
	ofn6.lpstrFilter       = " *.jpg\0*.jpg\0\0";
	ofn6.lpstrCustomFilter = NULL;
	ofn6.lpstrFile         = FullJpgFile;
	ofn6.lpstrFileTitle    = JpgFile;
	ofn6.Flags             = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
	ofn6.lpstrTitle        = NULL;
	ofn6.lpstrDefExt       = "jpg";
	ofn6.hwndOwner         = hwnd;
	ofn6.hInstance         = NULL;
	ofn6.nMaxFile          = MAX_PATH;
	ofn6.nMaxCustFilter    = 0;
	ofn6.nFilterIndex      = 0;
	ofn6.nMaxFileTitle     = MAX_PATH;
	ofn6.lpstrInitialDir   = CurrentDir;
	ofn6.nFileOffset       = 0;
	ofn6.nFileExtension    = 0;
	ofn6.lCustData         = 0;
	ofn6.lpfnHook          = NULL;
	ofn6.lpTemplateName    = NULL;

	ofn7.lStructSize       = sizeof(OPENFILENAME);
	ofn7.hwndOwner         = hwnd;
	ofn7.hInstance         = NULL;
	ofn7.lpstrFilter       = " *.gz\0*.gz\0\0";
	ofn7.lpstrFile         = SDTSfilename;
	ofn7.lpstrFileTitle    = ShortSDTSfilename;
	ofn7.Flags             = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
	ofn7.lpstrTitle        = NULL;
	ofn7.lpstrDefExt       = gz;
	ofn7.nMaxFile          = MAX_PATH;
	ofn7.lpstrCustomFilter = NULL;
	ofn7.nMaxCustFilter    = 0;
	ofn7.nFilterIndex      = 0;
	ofn7.nMaxFileTitle     = MAX_PATH;
	ofn7.lpstrInitialDir   = NULL;
	ofn7.nFileOffset       = 0;
	ofn7.nFileExtension    = 0;
	ofn7.lCustData         = 0;
	ofn7.lpfnHook          = NULL;
	ofn7.lpTemplateName    = NULL;

	lf.lfHeight = -17;
	lf.lfWeight = 400;
	lf.lfItalic = 0;
	lf.lfUnderline = 0;
	lf.lfStrikeOut = 0;
	lf.lfCharSet = 0;
	lf.lfOutPrecision = 1;
	lf.lfClipPrecision = 2;
	lf.lfQuality = 1;
	lf.lfPitchAndFamily = 0x31;
	for (x = 0; CourierNew[x] != 0; x++)
		lf.lfFaceName[x] = CourierNew[x];
	lf.lfFaceName[x] = 0;

	lf2.lfHeight = -13;
	lf2.lfWeight = 400;
	lf2.lfItalic = 0;
	lf2.lfUnderline = 0;
	lf2.lfStrikeOut = 0;
	lf2.lfCharSet = 0;
	lf2.lfOutPrecision = 1;
	lf2.lfClipPrecision = 2;
	lf2.lfQuality = 1;
	lf2.lfPitchAndFamily = 0x22;
	for (x = 0; Sanserif[x] != 0; x++)
		lf2.lfFaceName[x] = Sanserif[x];
	lf2.lfFaceName[x] = 0;

	lf3.lfHeight = -15;
	lf3.lfWeight = 400;
	lf3.lfItalic = 0;
	lf3.lfUnderline = 0;
	lf3.lfStrikeOut = 0;
	lf3.lfCharSet = 0;
	lf3.lfOutPrecision = 3;
	lf3.lfClipPrecision = 2;
	lf3.lfQuality = 1;
	lf3.lfPitchAndFamily = 0x42;
	for (x = 0; ComicSansMS[x] != 0; x++)
		lf3.lfFaceName[x] = ComicSansMS[x];
	lf3.lfFaceName[x] = 0;

	lf4.lfHeight = -17;
	lf4.lfWeight = 400;
	lf4.lfItalic = 0;
	lf4.lfUnderline = 0;
	lf4.lfStrikeOut = 0;
	lf4.lfCharSet = 0;
	lf4.lfOutPrecision = 3;
	lf4.lfClipPrecision = 2;
	lf4.lfQuality = 1;
	lf4.lfPitchAndFamily = 0x22;
	for (x = 0; Arial[x] != 0; x++)
		lf4.lfFaceName[x] = Arial[x];
	lf4.lfFaceName[x] = 0;

	lf5.lfHeight = -17;
	lf5.lfWeight = 400;
	lf5.lfItalic = 0;
	lf5.lfUnderline = 0;
	lf5.lfStrikeOut = 0;
	lf5.lfCharSet = 0;
	lf5.lfOutPrecision = 3;
	lf5.lfClipPrecision = 2;
	lf5.lfQuality = 1;
	lf5.lfPitchAndFamily = 0x22;
	for (x = 0; Arial[x] != 0; x++)
		lf5.lfFaceName[x] = Arial[x];
	lf5.lfFaceName[x] = 0;

	lf6.lfHeight = -48;
	lf6.lfWeight = 700;
	lf6.lfItalic = 0;
	lf6.lfUnderline = 0;
	lf6.lfStrikeOut = 0;
	lf6.lfCharSet = 0;
	lf6.lfOutPrecision = 3;
	lf6.lfClipPrecision = 2;
	lf6.lfQuality = 1;
	lf6.lfPitchAndFamily = 0x22;
	for (x = 0; Arial[x] != 0; x++)
		lf6.lfFaceName[x] = Arial[x];
	lf6.lfFaceName[x] = 0;
}



UINT WINAPI TimerThread(void* pParam)
{
	TIMERFLAGS tf = *(TIMERFLAGS*)pParam;

	if (WaitForSingleObject(hTimerEvent, tf.time) == WAIT_TIMEOUT)
	{
		if (TimerFlags.timing || TimerFlags.garmintiming || TimerFlags.nmeatiming || (FALSE == TimerFlags.gotprotocol))
		{
			fromFlag = NOBUTTON;//for returning from Garmin comm routine
//			if (autoLoc)
//			{
//				autoLoc = FALSE;
//				DestroyMenu(hMenu4);
//				hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
//				SetMenu(tf.hwnd, hMenu);
//				MenuChecks(tf.hwnd);
//			}
			if (TimerFlags.timing)
				MessageBox(tf.hwnd, "Your Garmin GPS seems to be off\n(or not connected)\nor Baud isn't set to 9600", Oops, MB_OK);
			else if (TimerFlags.garmintiming)
				MessageBox(tf.hwnd, "Your Garmin GPS doesn't seem to be\nset to GARMIN Interface Format\n(or Baud isn't set to 9600).\nSome data got thru, but\nit wasn't in the correct format.", Oops, MB_OK);
			else if (TimerFlags.nmeatiming)
			{
//				WriteFile(hComm, &SendMagellanHANDOFF, sizeof(SendMagellanHANDOFF)-1, &dwBytesWritten, NULL);
				MessageBox(tf.hwnd, "\
Your GPS seems to be off, or not connected,\n\
\n\
or your Garmin isn't set to NMEA Interface,\n\
or you're trying to send or receive waypoints,\n\
routes, or tracks to a Garmin using the NMEA Interface\n\
\n\
or your GPS's BAUD doesn't match this program's BAUD\n\
\n\
or your Magellan's NMEA is set wrong,\n\
or your Magellan just isn't ready,\n\
and you should try again...\
", Oops, MB_OK);
			}
			else if (TimerFlags.gotprotocol == FALSE)//has to be last
			{//for old Garmins
				TimerFlags.gotprotocol = TRUE;
				Noffset = 6;
				Eoffset = 10;
				IdentOffset = 0;
				LocOffset = 18;
				if (garminflag == BEGINRECORDS8)
				{
					WriteFile(hComm, &BeginRecords, 8, &dwBytesWritten, NULL);
					for (x = 0; x < 8; x++, tgcount++)
						ToGPS[tgcount] = BeginRecords[x];
					if (tgcount > 49900) tgcount = 0;
				}
				else if (garminflag == BEGINRECORDS9)
				{
					WriteFile(hComm, &BeginRecords2, 9, &dwBytesWritten, NULL);
					for (x = 0; x < 9; x++, tgcount++)
						ToGPS[tgcount] = BeginRecords2[x];
					if (tgcount > 49900) tgcount = 0;
				}
//				else if (garminflag == SENDWAYPOINTS)
//					WriteFile(hComm, &SendWaypoints, 8, &dwBytesWritten, NULL);
				else if (garminflag == SENDTRACKS)
					WriteFile(hComm, &SendTracks, 8, &dwBytesWritten, NULL);
				else if (garminflag == STARTPVT)
					WriteFile(hComm, &StartPVTPacket, 8, &dwBytesWritten, NULL);
				return 0;//continue with comm
			}
			TimerFlags.timing = TimerFlags.garmintiming = TimerFlags.nmeatiming = FALSE;
			SendMessage(hwnd, WM_COMMAND, ID_STOPPOSITIONING, 0);
			return 0;
		}
	}
	return 0;
}

UINT CALLBACK DownloadThread(void*)
{
	static unsigned long hURLThread;
	static int Pointers[2902];
	unsigned char *FileBuf;
	BOOL itsblank;
	static HANDLE hFile, hFile2;
//	HINTERNET hConnectHandle, hResourceHandle;

	EnterCriticalSection(&cs); downloading = TRUE; LeaveCriticalSection(&cs);
	hThreadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);//manual-reset, initialized non-signaled
	onetime = FALSE;
	downloaderror = FALSE;
	firstbad = TRUE;
#ifdef onetime0
	onetime1 = onetime2 = onetime3 = FALSE;
#endif
	internetconnect = gotblanktile = FALSE;
	if ((fileName[0] != 'B') && (fileName[1] != 'i') && (fileName[2] != 'g'))
	{
		fileName[0] = 'U';
		fileName[1] = 'S';
		fileName[2] = 'A';
		pointerFileName[0] = 'U';
		pointerFileName[1] = 'S';
		pointerFileName[2] = 'A';
	}
	tempyLoc = yLoc;
	tempxLoc = xLoc;
	DestroyMenu(hMenu);
	hMenu5 = LoadMenu(hInst, "STOPDOWNLOADING");
	SetMenu(hwnd, hMenu5);

	hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if (proxy == 2)
	{
		hConnectHandle = InternetConnect(hOpen, "msrmaps.com", INTERNET_INVALID_PORT_NUMBER, NULL, NULL, INTERNET_SERVICE_HTTP,0,0);
		hResourceHandle = HttpOpenRequest(hConnectHandle, "HEAD", "/", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
		InternetSetOption(hOpen, INTERNET_OPTION_PROXY_USERNAME, ProxyUserName, ProxyUserLen);
		InternetSetOption(hOpen, INTERNET_OPTION_PROXY_USERNAME, ProxyPassword, ProxyPassLen);
		HttpSendRequest(hResourceHandle, NULL, 0, NULL, 0);
		InternetCloseHandle(hResourceHandle);
		InternetCloseHandle(hConnectHandle);
	}
	yLoc = PixelsPerTile * (TilesDown-1);//bottom of screen
	ZoneName[0] = Z[0];
	ZoneName[1] = Z[1];
	saveRowOffset = rowOffset;
	saveColOffset = colOffset;
	saveTilesDown = TilesDown;
	saveTilesAcross = TilesAcross;

//	if (TilesAcross > 64)
//		TilesAcross = 64;//because on my screen the max is 65
	if (fillscreen == FALSE)
	{
		openatclosing = FALSE;//don't save a possibly screwed-up .ini file (BeginX, etc, are wrong)
		ShowCursor(FALSE);//hides it
		rowOffset = endY;
		colOffset = beginX;
		TilesDown = beginY-endY;
		TilesAcross = endX-beginX;
	}
	RowBufs = (unsigned char*)VirtualAlloc(NULL, TilesAcross*MAX_TILE_SIZE, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

	for (y = rowOffset; y < (rowOffset + TilesDown); y++)//rowOffset is BOTTOM of screen & y goes UP
	{
		_itoa(y, Y, 10);//put y in Y
		for (x = 0, z = 18; x < 3; x++, z++)
		{
			fileName[z] = ZoneName[x];
			pointerFileName[z] = ZoneName[x];
		}
		for (x = 0; Y[x] != 0; x++, z++)
		{
			pointerFileName[z] = Y[x];
 			fileName[z] = Y[x];
		}
		for (x = 0; x < 5; x++, z++)
		{
			pointerFileName[z] = Ptr[x];
			fileName[z] = Dta[x];
		}
		for (z = 0; z < 2902; z++)
			Pointers[z] = 0;//initialize
//put all previous map data in Pointers & FileBufs
		FileBuf = NULL;
		if (((hFile2 = CreateFile(pointerFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
		 && (fileSize = GetFileSize(hFile2, NULL)))
		{
			ReadFile(hFile2, Pointers, fileSize, &dwBytesRead, NULL);
			CloseHandle (hFile2);
			hFile = CreateFile(fileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
			fileSize = GetFileSize(hFile, NULL);
			FileBuf = (unsigned char*) malloc(fileSize);
			ReadFile(hFile, FileBuf, fileSize, &dwBytesRead, NULL);
			CloseHandle (hFile);
		}
		else
		{
			Pointers[0] = colOffset;
			Pointers[1] = 0;
			CloseHandle (hFile2);
		}
		NumOfPointers = Pointers[1];
		Pointers[1] = 0;//offset of first data file
//make a row's worth of threads and when they have all downloaded their data, save the row
		index = 0;
		for (col = 0, x = colOffset; col < TilesAcross; col++, x++)//colOffset is left side of screen //MAXIMUM_WAIT_OBJECTS = 64
		{
			RowBufSize[col] = 0;
			RowBufs[(col*MAX_TILE_SIZE)] = 0;
			RowBufs[(col*MAX_TILE_SIZE)+6] = 0;
			RowBufs[(col*MAX_TILE_SIZE)+7] = 0;
			_itoa(x, X, 10);//put x in X
			if (MapType == PHOTO)
			{
				pURLName = URLName;
				GetURLName();
			}
			else if (MapType == TOPO)
			{
				pURLName = TopoURLName;
				GetTopoURLName();
			}
			else if (MapType == URBANAREA)
			{
				pURLName = ColorURLName;
				GetColorURLName();
			}
//copy on-screen FileBuf data to RowBufs
			itsblank = TRUE;
			if (NumOfPointers != 0)//if there's a Pointers file
			{
				PointerOffset = x - Pointers[0];
				if ((PointerOffset >= 0)
				 && (PointerOffset < (NumOfPointers))// - 1
				 && (Pointers[PointerOffset+1] != Pointers[PointerOffset+2]))
				{//if Pointers data is on-screen
					int JpegOffset = col*MAX_TILE_SIZE;

					RowBufSize[col] = Pointers[PointerOffset+2] - Pointers[PointerOffset+1];
					if (RowBufSize[col] > MAX_TILE_SIZE)
						MessageBox(hwnd, "bug", ERROR, MB_OK);//theoretically impossible
					colAddr = Pointers[PointerOffset+1];
					for (z = 0; z < RowBufSize[col]; z++)
						RowBufs[JpegOffset + z] = FileBuf[colAddr+z];
					itsblank = FALSE;//Tile already exists
				}
			}
			//or get new photos & put them in RowBufs & show them
			if (itsblank == TRUE)
			{
				gotblanktile = TRUE;
#ifdef onetime0
				if (onetime1 == FALSE)
				{
					onetime1 = TRUE;
					MessageBox(hwnd, "So far so good...", "", MB_OK);
				}
#endif
				tp.col = col;
				for (z = 0; pURLName[z] != 0; z++)
					tp.URLName[z] = pURLName[z];
				tp.URLName[z] = 0;
				tp.RowBufs = &RowBufs[col*MAX_TILE_SIZE];
				///////////////////////////
				hURLThread = _beginthreadex(NULL, 0, URLThread, &tp, 0, &idThread6);
				///////////////////////////
				aThreads[index++] = (HANDLE)hURLThread;
				if (WAIT_OBJECT_0 == WaitForSingleObject(hThreadEvent, 1000))
					ResetEvent(hThreadEvent);
				else
				{
					MessageBox(hwnd, "Thread Error...", ERROR, MB_OK);
					EnterCriticalSection(&cs); downloading = FALSE; LeaveCriticalSection(&cs);
					goto prexit;
 				}
			}//end of if (itsblank == TRUE)
			if (index > 20)
			{
				if (FALSE == GetDownloadedData())//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
					goto prexit;
			}
		}//end of for (col =

		if (FALSE == GetDownloadedData())//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
			goto prexit;
		if (fillscreen == FALSE)
		{
			ShowDownloadProgress(5);
			hdc = GetDC(hwnd);
			SetBkColor(hdc, LIGHTGRAY);
			TextOut(hdc, (cxScreen/2) - (32*cxChar), cyScreen/2, DownloadProgress, SizeOfDP);
			ReleaseDC(hwnd, hdc);
		}		
//***************************************************************************************************
prexit:	EnterCriticalSection(&cs);
		downloadflg = downloading;
		LeaveCriticalSection(&cs);
		if (downloadflg)
		{
			oldNumOfPointers = NumOfPointers;
			if (colOffset > Pointers[0])
				x = (colOffset + TilesAcross) - Pointers[0];
			else
				x = (Pointers[0] + NumOfPointers) - colOffset;

			if (NumOfPointers == 0)
			{//new data file
				for (z = 0; z < col; z++)
					if (RowBufSize[z] != 0)
						break;
				if (z == col)
					goto hell;//don't write empty file
			}
			if (x <= 2900)
			{
				for (x = 0; x < 2902; x++)
					oldPointers[x] = Pointers[x];
				hFile = CreateFile(fileName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
//write-to-file everything to the left of screen
				x = 0;
				if ((Pointers[0] < colOffset) && (NumOfPointers != 0))//if old data is to left of new data
				{
					for ( ; (Pointers[0] + x) < colOffset; x++)
					{
						if (x >= NumOfPointers)
							Pointers[x+2] = Pointers[x+1];//blanks
						else
							WriteFile(hFile, &FileBuf[Pointers[x+1]], Pointers[x+2]-Pointers[x+1], &dwBytesWritten, NULL);
					}
				}
//write-to-file everything on screen
				for (z = 0; z < TilesAcross; z++)
				{
					if (RowBufSize[z] != 0)
					{
						if (*(int*)&RowBufs[z*MAX_TILE_SIZE] == 0xE0FFD8FF)//at beginning of a jpeg file
							WriteFile(hFile, &RowBufs[z*MAX_TILE_SIZE], RowBufSize[z], &dwBytesWritten, NULL);
						else
							RowBufSize[z] = 0;
					}
					Pointers[x+z+2] = Pointers[x+z+1] + RowBufSize[z];
				}
				z += x;
				NumOfPointers = z;
//write-to-file everything to the right of screen
				x = colOffset + TilesAcross - oldPointers[0];//x starts at end of screen (as a negative number)
				for ( ; (colOffset + z) < Pointers[0]; x++, z++)
				{
					Pointers[z+2] = Pointers[z+1];//blanks
					NumOfPointers++;
				}
				for ( ; x < oldNumOfPointers; x++, z++)
				{
					WriteFile(hFile, &FileBuf[oldPointers[x+1]], oldPointers[x+2]-oldPointers[x+1], &dwBytesWritten, NULL);
					Pointers[z+2] = Pointers[z+1] + (oldPointers[x+2] - oldPointers[x+1]);
					NumOfPointers++;
				}
				FlushFileBuffers(hFile);
				CloseHandle(hFile);
				if (Pointers[0] > colOffset)
					Pointers[0] = colOffset;
//write-to-file Pointers
				Pointers[1] = NumOfPointers;
				hFile2 = CreateFile(pointerFileName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile2, Pointers, (NumOfPointers+2)<<2, &dwBytesWritten, NULL);
				FlushFileBuffers(hFile2);
				CloseHandle(hFile2);
			}//end of if (NumOfPointers <= 2900)
			else
			{
				sprintf(tempLatLon, "Can't save it.\n%s\nwould contain a left-most photo or topo image\nthat would be over 2,900 tile-widths from the right-most one.\n\n\
Tile widths are 200 meters for 1 thru 4 meter/pixel photos,\n800 meters for topo images,\n1600 meters for 8 thru 64 meter/pixel photos,\nand 50 meters for urban area photos.", fileName);
				MessageBox(NULL, tempLatLon, NULL, MB_OK);
			}
hell:		if (FileBuf != NULL)
				free(FileBuf);
			yLoc -= PixelsPerTile;
		}//end of if (downloadflg == FALSE)
		else//downloadflg == FALSE
			break;
	}//end of for (y =
	
	CloseHandle(hThreadEvent);
	SetEvent(hEvent);//signal it
	VirtualFree(RowBufs, 0, MEM_RELEASE);
	DestroyMenu(hMenu5);
	hMenu = LoadMenu(hInst, "USAPHOTOMAPS");
	SetMenu(hwnd, hMenu);
	MenuChecks();
	InternetCloseHandle(hOpen);
	rowOffset = saveRowOffset;
	colOffset = saveColOffset;
	TilesDown = saveTilesDown;
	TilesAcross = saveTilesAcross;
	yLoc = tempyLoc;
	xLoc = tempxLoc;
	EnterCriticalSection(&cs); downloading = FALSE; LeaveCriticalSection(&cs);
	if ((fileName[0] != 'B') && (fileName[1] != 'i') && (fileName[2] != 'g'))
	{
		fileName[0] = fileName0;
		fileName[1] = fileName1;
		fileName[2] = fileName2;
		pointerFileName[0] = fileName0;
		pointerFileName[1] = fileName1;
		pointerFileName[2] = fileName2;
	}
	if (fillscreen == FALSE)
	{
		Zoom = saveZoom;
		SendMessage(hwnd, WM_CLOSE, 0, 0);
	}
	else
		InvalidateRect(hwnd, &rect, FALSE);
	hDownloadThread = 0;
	if ((internetconnect == FALSE) && (gotblanktile == TRUE))
		MessageBox(hwnd, "http://msrmaps.com/", "Couldn't connect to", MB_OK);
	else if (downloaderror)
	{
		GetCurrentDirectory(MAX_PATH, CurrentDir);
		for (x = 56, y = 0; CurrentDir[y] != 0; x++, y++)
			DownloadErr[x] = CurrentDir[y];
		for ( y = 0; DownloadErr2[y] != 0; x++, y++)
			DownloadErr[x] = DownloadErr2[y];
		DownloadErr[x] = 0;
		if (31 >= WinExec(DownloadErr, SW_SHOW))//if Internet Explorer had a problem with it
			MessageBox(hwnd, "(read DownloadError.htm)", NULL, MB_OK);
	}
	return 0;
}


/*
void SendChecksum(void)
{//$PMGNCSM,hh*hh\r\n
	int x;

	for (checksum = 0, x = TempiBuf; Buf[x] != '*'; x++)
		checksum ^= Buf[x];
	x = checksum >> 4;
	SendMagellanChecksum[9] = (char)(x > 9) ? x + 0x37 : x + 0x30;
	x = checksum & 0x0F;
	SendMagellanChecksum[10] = (char)(x > 9) ? x + 0x37 : x + 0x30;

	for (checksum = 0, x = 1; SendMagellanChecksum[x] != '*'; x++)
		checksum ^= SendMagellanChecksum[x];
	x = checksum >> 4;
	SendMagellanChecksum[12] = (char)(x > 9) ? x + 0x37 : x + 0x30;
	x = checksum & 0x0F;
	SendMagellanChecksum[13] = (char)(x > 9) ? x + 0x37 : x + 0x30;

	WriteFile(hComm, &SendMagellanChecksum, 16, &dwBytesWritten, NULL);
}
*/

int PrepMagellanWaypoint(void)
{
	int x, y;
	char ch;

	for (x = 0; x < 100; x++)
		SendMagWaypoints[x] = 0;
	for (x = 0; Wpl[x] != 0; x++)
		SendMagWaypoints[x] = Wpl[x];//"$PMGNWPL,"
	UTMNorthing = NewLoc[LocNum].NUTM;
	UTMEasting = NewLoc[LocNum].EUTM;
	if (NewLoc[LocNum].UTMZone != 0)//it's not always filled in!
		UTMZone = NewLoc[LocNum].UTMZone;
	UTMtoLatLon();
	minutes = modf(Lat, &degrees) * 60.0;
	x += sprintf((char*)&SendMagWaypoints[x], "%2.0f", degrees);
	x += sprintf((char*)&SendMagWaypoints[x], "%06.3f", minutes);
	SendMagWaypoints[x++] = ',';
	SendMagWaypoints[x++] = 'N';
	SendMagWaypoints[x++] = ',';
	Lon = -Lon;
	minutes = modf(Lon, &degrees) * 60.0;
	x += sprintf((char*)&SendMagWaypoints[x], "%3.0f", degrees);
	x += sprintf((char*)&SendMagWaypoints[x], "%06.3f", minutes);
	SendMagWaypoints[x++] = ',';
	SendMagWaypoints[x++] = 'W';
	SendMagWaypoints[x++] = ',';
	if ((NewLoc[LocNum].Elev != NULL) && (NewLoc[LocNum].Elev[0] != 0))
		for (y = 0; (y < 9) && (NewLoc[LocNum].Elev[y] != '<'); x++, y++)
			SendMagWaypoints[x] = NewLoc[LocNum].Elev[y];
	SendMagWaypoints[x++] = ',';
	SendMagWaypoints[x++] = 'M';//meters
	SendMagWaypoints[x++] = ',';
	if (SendMagWaypoints[20] == ' ')
		SendMagWaypoints[20] = '0';//make degrees Longitude "084" from " 84"

	if ((NewLoc[LocNum].Ident != NULL) && (NewLoc[LocNum].Ident[0] != 0))
	{
		for (y = 0; (y < 8) && (NewLoc[LocNum].Ident[y] != '<'); x++, y++)
		{
			ch = NewLoc[LocNum].Ident[y];
			if ((ch >= 'a') && (ch <= 'z'))
				ch &= 0xDF;
			SendMagWaypoints[x] = ch;
		}
	}
	else if ((NewLoc[LocNum].Location != NULL) && (NewLoc[LocNum].Location[0] != 0))
	{//send cmt as name
		for (y = 0; (y < 8) && (NewLoc[LocNum].Location[y] != '<'); x++, y++)
		{
			ch = NewLoc[LocNum].Location[y];
			if ((ch >= 'a') && (ch <= 'z'))
				ch &= 0xDF;
			SendMagWaypoints[x] = ch;
		}
	}

	if ((NewLoc[LocNum].Location != NULL) && (NewLoc[LocNum].Location[0] != 0))
	{
		SendMagWaypoints[x++] = ',';
		for (y = 0; (y < 30) && (NewLoc[LocNum].Location[y] != '<'); x++, y++)//30 to add up to 82 (max NMEA)
		{
			ch = NewLoc[LocNum].Location[y];
			if ((ch >= 'a') && (ch <= 'z'))
				ch &= 0xDF;
			SendMagWaypoints[x] = ch;
		}
	}
//	else if ((NewLoc[LocNum].Ident != NULL) && (NewLoc[LocNum].Ident[0] != 0))
//	{
//		SendMagWaypoints[x++] = ',';
//		for (y = 0; (y < 8) && (NewLoc[LocNum].Ident[y] != '<'); x++, y++)
//		{
//			ch = NewLoc[LocNum].Ident[y];
//			if ((ch >= 'a') && (ch <= 'z'))
//				ch &= 0xDF;
//			SendMagWaypoints[x] = ch;
//		}
//	}
	else
		SendMagWaypoints[x++] = ',';
	if (itsmeridian)
	{
		SendMagWaypoints[x++] = ',';
		if (NewLoc[LocNum].Sym == NULL)
			SendMagWaypoints[x++] = 'a';//'x';//medium city symbol
		else if (NewLoc[LocNum].Sym != 0)
		{
			for (y = 0; NewLoc[LocNum].Sym[y] != '<'; y++)
				Sym[y] = NewLoc[LocNum].Sym[y];
			Sym[y] = 0;
			if (0 == strcmp(Sym, Mb))
				SendMagWaypoints[x++] = 'b';
			else if (0 == strcmp(Sym, Mc))
				SendMagWaypoints[x++] = 'c';
			else if (0 == strcmp(Sym, Md))
				SendMagWaypoints[x++] = 'd';
			else if (0 == strcmp(Sym, Me))
				SendMagWaypoints[x++] = 'e';
			else if (0 == strcmp(Sym, Mf))
				SendMagWaypoints[x++] = 'f';
			else if (0 == strcmp(Sym, Mg))
				SendMagWaypoints[x++] = 'g';
			else if (0 == strcmp(Sym, Mh))
				SendMagWaypoints[x++] = 'h';
			else if (0 == strcmp(Sym, Mi))
				SendMagWaypoints[x++] = 'i';
			else if (0 == strcmp(Sym, Mj))
				SendMagWaypoints[x++] = 'j';
			else if (0 == strcmp(Sym, Mk))
				SendMagWaypoints[x++] = 'k';
			else if (0 == strcmp(Sym, Ml))
				SendMagWaypoints[x++] = 'l';
			else if (0 == strcmp(Sym, Mm))
				SendMagWaypoints[x++] = 'm';
			else if (0 == strcmp(Sym, Mn))
				SendMagWaypoints[x++] = 'n';
			else if (0 == strcmp(Sym, Mo))
				SendMagWaypoints[x++] = 'o';
			else if (0 == strcmp(Sym, Mp))
				SendMagWaypoints[x++] = 'p';
			else if (0 == strcmp(Sym, Mq))
				SendMagWaypoints[x++] = 'q';
			else if (0 == strcmp(Sym, Mr))
				SendMagWaypoints[x++] = 'r';
			else if (0 == strcmp(Sym, Ms))
				SendMagWaypoints[x++] = 's';
			else if (0 == strcmp(Sym, Mt))
				SendMagWaypoints[x++] = 't';
			else if (0 == strcmp(Sym, Mu))
				SendMagWaypoints[x++] = 'u';
			else if (0 == strcmp(Sym, Mv))
				SendMagWaypoints[x++] = 'v';
			else if (0 == strcmp(Sym, Mw))
				SendMagWaypoints[x++] = 'w';
			else if (0 == strcmp(Sym, Mx))
				SendMagWaypoints[x++] = 'x';
			else if (0 == strcmp(Sym, My))
				SendMagWaypoints[x++] = 'y';
			else if (0 == strcmp(Sym, Mz))
				SendMagWaypoints[x++] = 'z';

			else if (0 == strcmp(Sym, aa))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'a';
			}
			else if (0 == strcmp(Sym, ab))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'b';
			}
			else if (0 == strcmp(Sym, ac))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'c';
			}
			else if (0 == strcmp(Sym, ad))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'd';
			}
			else if (0 == strcmp(Sym, ae))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'e';
			}
			else if (0 == strcmp(Sym, af))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'f';
			}
			else if (0 == strcmp(Sym, ag))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'g';
			}
			else if (0 == strcmp(Sym, ah))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'h';
			}
			else if (0 == strcmp(Sym, ai))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'i';
			}
			else if (0 == strcmp(Sym, aj))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'j';
			}
			else if (0 == strcmp(Sym, ak))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'k';
			}
			else if (0 == strcmp(Sym, al))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'l';
			}
			else if (0 == strcmp(Sym, am))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'm';
			}
			else if (0 == strcmp(Sym, an))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'n';
			}
			else if (0 == strcmp(Sym, ao))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'o';
			}
			else if (0 == strcmp(Sym, ap))
			{
				SendMagWaypoints[x++] = 'a';
				SendMagWaypoints[x++] = 'p';
			}
			else
				SendMagWaypoints[x++] = 'a';//default
		}
		else
			SendMagWaypoints[x++] = 'a';//default
	}//end of itsmeridian
//	else
//		SendMagWaypoints[x++] = 'a';//basic symbol
	SendMagWaypoints[x++] = '*';
	for (checksum = 0, y = 1; SendMagWaypoints[y] != '*'; y++)
		checksum ^= SendMagWaypoints[y];
	y = checksum >> 4;
	SendMagWaypoints[x++] = (char)(y > 9) ? y + 0x37 : y + 0x30;
	y = checksum & 0x0F;
	SendMagWaypoints[x++] = (char)(y > 9) ? y + 0x37 : y + 0x30;
	SendMagWaypoints[x++] = '\x0D';
	SendMagWaypoints[x++] = '\x0A';
	return x;
//$PMGNWPL,3647.692,N,12142.807,W,0000000,M,15002,15002 CASTROVILLE,a*24
//         10        20        30        40         50        60        70        80
//01234567890123456789012345678901234567890123445678901234567890123456789012345678901234567890
//$PMGNWPL,3647.692,N,12142.807,W,00000,M,15002 ,15002 CASTROVILLE             ,a*24\r\n
//"$PMGNWPL,4006.281,N,11348.990,W,,M,CLIFTON,CLIFTON,a*70"
}//end of PrepMagellanWaypoint


void FillWaypointArray(int importedx)
{
	int x, y, StrLen;
	static char wpt[] = "<wpt lat=\"";
	static char lon[] = "\" lon=\"-";
	static char quote[] = "\">";
	static char ele[] = "\r\n<ele>";
	static char endele[] = "</ele>";
	static char name[] = "\r\n<name>";
	static char endname[] = "</name>";
	static char cmt[] = "\r\n<cmt>";
	static char endcmt[] = "</cmt>";
	static char sym[] = "\r\n<sym>";
	static char endsym[] = "</sym>";
	static char endwpt[] = "\r\n</wpt>\r\n";
	static char *buffer;

	x = WaypointSize;
//	WaypointArray = (char*)realloc(WaypointSize + 1000);
	NewLoc[importedx].pWaypoints = &WaypointArray[x];//end of WaypointArray
//lat
	for (y = 0; wpt[y] != 0; x++, y++)
		WaypointArray[x] = wpt[y];
	StrLen = 8;
	buffer = _ecvt(Lat, StrLen, &decPos, &sign);
	for (y = 0; y < decPos; x++, y++)
		WaypointArray[x] = buffer[y];
	WaypointArray[x++] = '.';
	for ( ; y < StrLen; x++, y++)
		WaypointArray[x] = buffer[y];
//lon
	for (y = 0; lon[y] != 0; x++, y++)
		WaypointArray[x] = lon[y];
	if (abs((int)Lon) >= 100)
		StrLen++;
	buffer = _ecvt(Lon, StrLen, &decPos, &sign);
	for (y = 0; y < decPos; x++, y++)
		WaypointArray[x] = buffer[y];
	WaypointArray[x++] = '.';
	for ( ; y < StrLen; x++, y++)
		WaypointArray[x] = buffer[y];
	for (y = 0; quote[y] != 0; x++, y++)
		WaypointArray[x] = quote[y];
//elev
	if (Elev[0] != 0)
	{//if there's an elevation for the waypoint
		for (y = 0; ele[y] != 0; x++, y++)
			WaypointArray[x] = ele[y];
		NewLoc[importedx].Elev = &WaypointArray[x];
		for (y = 0; Elev[y] != 0; x++, y++)
			WaypointArray[x] = Elev[y];
		for (y = 0; endele[y] != 0; x++, y++)
			WaypointArray[x] = endele[y];
	}
	else
		NewLoc[importedx].Elev = NULL;
//name
	if (Ident[0] != 0)
	{
		for (y = 0; name[y] != 0; x++, y++)
			WaypointArray[x] = name[y];
		NewLoc[importedx].Ident = &WaypointArray[x];
		for (y = 0; Ident[y] != 0; x++, y++)
			WaypointArray[x] = Ident[y];
		for (y = 0; endname[y] != 0; x++, y++)
			WaypointArray[x] = endname[y];
	}
	else
		NewLoc[importedx].Ident = NULL;
//cmt
	if (Location[0] != 0)
	{
		for (y = 0; cmt[y] != 0; x++, y++)
			WaypointArray[x] = cmt[y];
		NewLoc[importedx].Location = &WaypointArray[x];
		for (y = 0; Location[y] != 0; x++, y++)
			WaypointArray[x] = Location[y];
		for (y = 0; endcmt[y] != 0; x++, y++)
			WaypointArray[x] = endcmt[y];
	}
//	else if (NewLoc[importedx].Description != NULL)
//		NewLoc[importedx].Location = NewLoc[importedx].Description;
	else
		NewLoc[importedx].Location = NULL;
//sym
	if (Sym[0] != 0)
	{
		for (y = 0; sym[y] != 0; x++, y++)
			WaypointArray[x] = sym[y];
		NewLoc[importedx].Sym = &WaypointArray[x];
		for (y = 0; Sym[y] != 0; x++, y++)
			WaypointArray[x] = Sym[y];
		for (y = 0; endsym[y] != 0; x++, y++)
			WaypointArray[x] = endsym[y];
	}
	else
		NewLoc[importedx].Sym = NULL;
	for (y = 0; endwpt[y] != 0; x++, y++)
		WaypointArray[x] = endwpt[y];
	NewLoc[importedx].size = x - WaypointSize;
	WaypointSize = x;
	newLoc = TRUE;
}//end of FillWaypointArray


int FillListBox(HWND hwndDlg)
{
	int x, y, z;

	longest = 0;
	for (x = 0; NewLoc[x].EUTM != 0; x++)
	{
		y = 0;
		if (NewLoc[x].Ident != NULL)
		{
			if ((NewLoc[x].Ident[0] == '<')
			 && (NewLoc[x].Ident[1] == '!')
			 && (NewLoc[x].Ident[2] == '[')
			 && (NewLoc[x].Ident[3] == 'C'))
			{//if <![CDATA[
				for (z = 9; (y < 100) && ((NewLoc[x].Ident[z] != ']') || (NewLoc[x].Ident[z+1] != ']')); y++, z++)
					Combined[y] = NewLoc[x].Ident[z];
			}
			else
				for ( ; (y < 100) && (NewLoc[x].Ident[y] != 0) && (NewLoc[x].Ident[y] != '<'); y++)
					Combined[y] = NewLoc[x].Ident[y];
		}
		if (y > longest)
			longest = y;
		Combined[y++] = TAB;
		if (NewLoc[x].Location != NULL)
		{
			if ((NewLoc[x].Location[0] == '<')
			 && (NewLoc[x].Location[1] == '!')
			 && (NewLoc[x].Location[2] == '[')
			 && (NewLoc[x].Location[3] == 'C'))
			{//if <![CDATA[
				for (z = 9; (y < 100) && ((NewLoc[x].Location[z] != ']') || (NewLoc[x].Location[z+1] != ']')); y++, z++)
					Combined[y] = NewLoc[x].Location[z];
			}
			else
				for (z = 0; (y < 100) && (NewLoc[x].Location[z] != 0) && (NewLoc[x].Location[z] != '<'); y++, z++)
					Combined[y] = NewLoc[x].Location[z];
		}
		else if (NewLoc[x].Description != NULL)
		{
			if ((NewLoc[x].Description[0] == '<')
			 && (NewLoc[x].Description[1] == '!')
			 && (NewLoc[x].Description[2] == '[')
			 && (NewLoc[x].Description[3] == 'C'))
			{//if <![CDATA[
				for (z = 9; (y < 100) && ((NewLoc[x].Description[z] != ']') || (NewLoc[x].Description[z+1] != ']')); y++, z++)
					Combined[y] = NewLoc[x].Description[z];
			}
			else
				for (z = 0; (y < 100) && (NewLoc[x].Description[z] != 0) && (NewLoc[x].Description[z] != '<') && (NewLoc[x].Description[z] != '\r'); y++, z++)
					Combined[y] = NewLoc[x].Description[z];
		}
		Combined[y] = 0;
		SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)Combined);
	}
	return x;
}

void SaveTracks(void)
{
	int x;

//	if (newelev)
//	{
//		if  (IDNO == MessageBox(hwnd, "... and replace GPS altitudes with\nUSAPhotoMaps elevations?", "Save Edited Tracks?", MB_YESNO))
//			return;
//	}
	hFile = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (trackcommas == 9)
		WriteFile(hFile, OldTrackHead, strlen(OldTrackHead), &dwBytesWritten, NULL);
	else
		WriteFile(hFile, TrackHead, strlen(TrackHead), &dwBytesWritten, NULL);
	for (x = 0; trak[x].time != 0; x++)
	{
		WriteTracks(hFile, x);
	}
	CloseHandle(hFile);
}

void WriteTracks(HANDLE hFile, int t)//wxyz
{
	int i, z, North, West;
	unsigned char ch;
	float Alt;
	float Unknown = (float)1.0e25;//"\x51\x59\x04\x69";
//	char Track2[] = "N 1,990,102   W 705,542   15:42:30z   05/16   UTM Zone 19                 \r\n";//76
	char Track[128];
//"New,10,578212,4140440,7,17,18,7,59,"
//trak[t].time = (UTMZone << 26) | (st.wMonth << 22) | (st.wDay << 17) | (st.wHour << 12) | (st.wMinute << 6) | st.wSecond;
//char TrackHead[] = "Track,UTM Zone,UTM Northing,UTM Easting,Hour,Min,Sec,Month,Date,Year,Alt(Meters)\r\n";
	i = 0;
	if (trak[t].newtrk != 0)
	{
		if (trak[t].color == 0)
		{
			Track[i++] = 'N';
			Track[i++] = 'e';
			Track[i++] = 'w';
		}
		else
		{
			z = (trak[t].color & 0xFF0000) >> 16;
			if (z == 0)
				Track[i++] = '0';
			else if (z == 0x80)
				Track[i++] = '1';
			else if (z == 0xC0)
				Track[i++] = '2';
			else if (z == 0xFF)
				Track[i++] = '3';
			z = (trak[t].color & 0x00FF00) >> 8;
			if (z == 0)
				Track[i++] = '0';
			else if (z == 0x80)
				Track[i++] = '1';
			else if (z == 0xC0)
				Track[i++] = '2';
			else if (z == 0xFF)
				Track[i++] = '3';
			z = (trak[t].color & 0x0000FF);
			if (z == 0)
				Track[i++] = '0';
			else if (z == 0x80)
				Track[i++] = '1';
			else if (z == 0xC0)
				Track[i++] = '2';
			else if (z == 0xFF)
				Track[i++] = '3';
		}
	}
	Track[i++] = ',';
	ch = (trak[t].time >> 26) & 0xFF;
	Track[i++] = (ch / 10) + '0';//UTM Zone
	Track[i++] = (ch % 10) + '0';//UTM Zone
	Track[i++] = ',';
	North = trak[t].NUTM;
	West = trak[t].EUTM;
	Track[i++] = (North / MILLION) + '0';
	Track[i++] = ((North % MILLION) / HUNDREDTHOUSAND) + '0';
	Track[i++] = ((North % HUNDREDTHOUSAND) / TENTHOUSAND) + '0';
	Track[i++] = ((North % TENTHOUSAND) / THOUSAND) + '0';
	Track[i++] = ((North % THOUSAND) / HUNDRED) + '0';
	Track[i++] = ((North % HUNDRED) / TEN) + '0';
	Track[i++] = (North % TEN) + '0';
	Track[i++] = ',';
	Track[i++] = (West / HUNDREDTHOUSAND) + '0';
	Track[i++] = ((West % HUNDREDTHOUSAND) / TENTHOUSAND) + '0';
	Track[i++] = ((West % TENTHOUSAND) / THOUSAND) + '0';
	Track[i++] = ((West % THOUSAND) / HUNDRED) + '0';
	Track[i++] = ((West % HUNDRED) / TEN) + '0';
	Track[i++] = (West % TEN) + '0';
	Track[i++] = ',';

	if (trackcommas == 9)
	{
		ch = (trak[t].time >> 22) & 0xF;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//month
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = (trak[t].time >> 17) & 0x1F;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//day
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = (trak[t].time >> 12) & 0x1F;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//hour
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = (trak[t].time >> 6) & 0x3F;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//minute
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = trak[t].time & 0x3F;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//second
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
	}

	else//if (trackcommas == 10)
	{//newer type
		ch = (trak[t].time >> 12) & 0x1F;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//hour
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = (trak[t].time >> 6) & 0x3F;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//minute
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = trak[t].time & 0x3F;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//second
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = (trak[t].time >> 22) & 0xF;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//month
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = (trak[t].time >> 17) & 0x1F;
		if (ch != 0)
		{
			Track[i++] = (ch / 10) + '0';//day
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
		ch = trak[t].year;
		if (ch != 0)
		{
			Track[i++] = '2';
			Track[i++] = '0';
			Track[i++] = (ch / 10) + '0';//year
			Track[i++] = (ch % 10) + '0';
		}
		Track[i++] = ',';
	}
	if ((trak[t].alt != 0) && ((trak[t].alt != (float)1.0e25)))
	{
		Alt = (float)trak[t].alt;
		count = 6;
		ptrToAscii = _ecvt(Alt, count, &decPos, &sign);
		for (z = 0; z < decPos; z++)
			Track[i++] = ptrToAscii[z];
		Track[i++] = '.';
		for ( ; ptrToAscii[z] != 0; z++)
			Track[i++] = ptrToAscii[z];
	}
	Track[i++] = '\r';
	Track[i++] = '\n';
	WriteFile(hFile, Track, i, &dwBytesWritten, NULL);
	if (i >= 128)
		MessageBeep(MB_ICONASTERISK);
}

int ReadTracks(int fileSize)
{//tracks are in pTrackBuf
	int v, w, x, y, z, i, j, k;
//	unsigned int u, u2;
	unsigned char UTMZone, month, day, hour, minute, second;
	double e, n;
	BOOL GotDem[MAX_DEMS];
//     1        2            3           4    5   6   7     8    9   10
//Track,UTM Zone,UTM Northing,UTM Easting,Hour,Min,Sec,Month,Date,Year,Alt(Meters)
//New,11,4180501,271088,23,18,16,09,15,2003,1185.00
	savetracks = FALSE;
	newelev = FALSE;
	for (x = 0; x < MAX_DEMS; x++)
		GotDem[x] = 0;
	for (y = 0; pTrackBuf[y] != '\n'; y++)
		;
	y++;//put y at beginning of first data row
	numofTracks = 0;
	for (x = y; x < (int)fileSize; x++)
		if (pTrackBuf[x] == '\n')
			numofTracks++;
	if (pTrackBuf[x-1] != '\n')
		numofTracks++;//if no line feed at end of data
	if (trak != NULL)
	{
		free(trak);
		trak = NULL;
	}
	trak = (struct TRAC*) calloc(1, (numofTracks+100) * sizeof(struct TRAC));
//	trak[0].dist = 0.0;

	ScreenDems = 0;
	for (x = 0; y < fileSize; x++)
	{//big loop!
		for (z = y; pTrackBuf[z] != '\n'; z++)
			if (z == fileSize)//if an incomplete line at end
				return x;//numofTracks
//		trak[x].color = 0;
		if (((pTrackBuf[y] & 0xDF) == 'N') && ((pTrackBuf[y+1] & 0xDF) == 'E') && ((pTrackBuf[y+2] & 0xDF) == 'W'))
		{
			trak[x].newtrk = 1;
//			trak[x].dist = 0.0;
			y += 4;//past New,
		}
		else if (pTrackBuf[y] != ',')
		{//trak segment color '301' (full blue, 0 green, 1/2 red)
			trak[x].newtrk = 1;
			trak[x].dist = 0.0;
			if (pTrackBuf[y] == '1')
				trak[x].color = 0x800000;
			else if (pTrackBuf[y] == '2')
				trak[x].color = 0xC00000;
			else if (pTrackBuf[y] == '3')
				trak[x].color = 0xFF0000;
			if (pTrackBuf[y+1] == '1')
				trak[x].color |= 0x8000;
			else if (pTrackBuf[y+1] == '2')
				trak[x].color |= 0xC000;
			else if (pTrackBuf[y+1] == '3')
				trak[x].color |= 0xFF00;
			if (pTrackBuf[y+2] == '1')
				trak[x].color |= 0x80;
			else if (pTrackBuf[y+2] == '2')
				trak[x].color |= 0xC0;
			else if (pTrackBuf[y+2] == '3')
				trak[x].color |= 0xFF;
			y += 4;//past 123,
		}
		else
		{
			y++;//past ,
		}
		UTMZone = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
		y += 3;//past , 2
		trak[x].NUTM = (((pTrackBuf[y] - '0') * MILLION)
		 + ((pTrackBuf[y+1] - '0') * HUNDREDTHOUSAND)
		 + ((pTrackBuf[y+2] - '0') * TENTHOUSAND)
		 + ((pTrackBuf[y+3] - '0') * THOUSAND)
		 + ((pTrackBuf[y+4] - '0') * HUNDRED)
		 + ((pTrackBuf[y+5] - '0') * TEN)
		 + (pTrackBuf[y+6] - '0'));
		y += 8;//past , 3
		trak[x].EUTM = (((pTrackBuf[y] - '0') * HUNDREDTHOUSAND)
		 + ((pTrackBuf[y+1] - '0') * TENTHOUSAND)
		 + ((pTrackBuf[y+2] - '0') * THOUSAND)
		 + ((pTrackBuf[y+3] - '0') * HUNDRED)
		 + ((pTrackBuf[y+4] - '0') * TEN)
		 + (pTrackBuf[y+5] - '0'));
		y += 7;//past , 4

		if (trak[x].newtrk == 0 && x)
		{
			e = abs(trak[x].EUTM - trak[x-1].EUTM);
			n = abs(trak[x].NUTM - trak[x-1].NUTM);
			trak[x].dist = (sqrt(e*e + n*n) + trak[x-1].dist);
		}

		if (trackcommas == 9)
		{//old data type - Track,UTM Zone,UTM Northing,UTM Easting,Month,Date,Hour,Minute,Second,
			if (pTrackBuf[y] != ',')
			{
				if (pTrackBuf[y+1] != ',')
				{
					month = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past , 4
				}
				else
				{
					month = (pTrackBuf[y] - '0');
					y += 2;//past ,
				}
			}
			else
			{
				month = 0;
				y++;
			}
			if (pTrackBuf[y] != ',')
			{
				if (pTrackBuf[y+1] != ',')
				{
					day = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past ,
				}
				else
				{
					day = (pTrackBuf[y] - '0');
					y += 2;//past ,
				}
			}
			else
			{
				day = 0;
				y++;
			}
			if (pTrackBuf[y] != ',')
			{
				if (pTrackBuf[y+1] != ',')
				{
					hour = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past ,
				}
				else
				{
					hour = (pTrackBuf[y] - '0');
					y += 2;//past ,
				}
			}
			else
			{
				hour = 0;
				y++;
			}
			if (pTrackBuf[y] != ',')
			{
				if (pTrackBuf[y+1] != ',')
				{
					minute = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past ,
				}
				else
				{
					minute = (pTrackBuf[y] - '0');
					y += 2;//past ,
				}
			}
			else
			{
				minute = 0;
				y++;
			}
			if (pTrackBuf[y] != ',')
			{
				if (pTrackBuf[y+1] != ',')
				{
					second = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past ,
				}
				else
				{
					second = (pTrackBuf[y] - '0');
					y += 2;//past ,
				}
			}
			else
			{
				second = 0;
				y++;
			}
		}
//     1        2            3           4    5   6   7     8    9   10
//Track,UTM Zone,UTM Northing,UTM Easting,Hour,Min,Sec,Month,Date,Year,Alt(Meters)
//New,11,4180501,271088,23,18,16,09,15,2003,1185.00
		else//if (trackcommas == 10)
		{//new data type
			if (pTrackBuf[y] != ',')
			{//if hour isn't empty
				if (pTrackBuf[y+1] != ',')
				{//if 2 hour digits
					hour = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past , 5
				}
				else
				{
					hour = (pTrackBuf[y] - '0');
					y += 2;//past , 5
				}
			}
			else
			{
				hour = 0;
				y++;
			}
			if (pTrackBuf[y] != ',')
			{//if minute isn't empty
				if (pTrackBuf[y+1] != ',')
				{//if 2 minute digits
					minute = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past , 6
				}
				else
				{
					minute = (pTrackBuf[y] - '0');
					y += 2;//past , 6
				}
			}
			else
			{
				minute = 0;
				y++;//past , 6
			}
			if (pTrackBuf[y] != ',')
			{//if second isn't empty
				if (pTrackBuf[y+1] != ',')
				{//if 2 digits
					second = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past , 7
				}
				else
				{
					second = (pTrackBuf[y] - '0');
					y += 2;//past , 7
				}
			}
			else
			{
				second = 0;
				y++;// past , 7
			}
			if (pTrackBuf[y] != ',')
			{
				if (pTrackBuf[y+1] != ',')
				{
					month = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past , 8
				}
				else
				{
					month = (pTrackBuf[y] - '0');
					y += 2;//past , 8
				}
			}
			else
			{
				month = 0;
				y++;//past , 8
			}
			if (pTrackBuf[y] != ',')
			{
				if (pTrackBuf[y+1] != ',')
				{
					day = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
					y += 3;//past , 9
				}
				else
				{
					day = (pTrackBuf[y] - '0');
					y += 2;//past , 9
				}
			}
			else
			{
				day = 0;
				y++;//past , 9
			}
			if (pTrackBuf[y] != ',')
			{//if year isn't empty
				if (pTrackBuf[y] +2 != ',')//if 4 char year
					y += 2;
				trak[x].year = ((pTrackBuf[y] - '0') * 10) + (pTrackBuf[y+1] - '0');
				y += 3;//past , 10
			}
			else
			{
				trak[x].year = 0;
				y++;//past , 10
			}
		}
//     1        2            3           4    5   6   7     8    9   10
//Track,UTM Zone,UTM Northing,UTM Easting,Hour,Min,Sec,Month,Date,Year,Alt(Meters)
//New,11,4180501,271088,23,18,16,09,15,2003,1185.00
		trak[x].time = (UTMZone << 26) | (month << 22) | (day << 17) | (hour << 12) | (minute << 6) | second;

		for (v = 0; v < NumOfDems; v++)
		{
			if ((UTMZone == Dem[v].Zone) && (trak[x].NUTM <= Dem[v].North) && (trak[x].NUTM > Dem[v].South) && (trak[x].EUTM >= Dem[v].West) && (trak[x].EUTM < Dem[v].East))
			{
				if (GotDem[v] == FALSE)
				{
					GotDem[v] = TRUE;
					for (w = 10, z = 0; Dem[v].Name[z] != 0; w++, z++)
						NewElevFile[w] = Dem[v].Name[z];
					NewElevFile[w] = 0;
					hFile2 = CreateFile(NewElevFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile2 != INVALID_HANDLE_VALUE)
					{
						if (fileSize2 = GetFileSize(hFile2, NULL))
						{
							Associated[ScreenDems] = v;
							DemData[ScreenDems] = (WORD*) malloc(fileSize2);
							ReadFile(hFile2, DemData[ScreenDems], fileSize2, &dwBytesRead, NULL);
							if (ScreenDems < 500)
								ScreenDems++;
						}
						CloseHandle(hFile2);
					}
				}					
			}
		}

		dElev = 0.0;
		for (k = 0; k < ScreenDems; k++)
		{
			w = Associated[k];
			if ((UTMZone == Dem[w].Zone) && (trak[x].NUTM <= Dem[w].North) && (trak[x].NUTM > Dem[w].South) && (trak[x].EUTM >= Dem[w].West) && (trak[x].EUTM < Dem[w].East))
			{
				i = (trak[x].EUTM - Dem[w].West) / 30;
				j = (Dem[w].North - trak[x].NUTM) / 30;
				tl = DemData[k][(j*Dem[w].Cols)+i];
				llElev = DemData[k][((j+1)*Dem[w].Cols)+i];
				lrElev = DemData[k][((j+1)*Dem[w].Cols)+i+1];
				urElev = DemData[k][((j)*Dem[w].Cols)+i+1];
				
				if ((tl != 0x8002) && (llElev != 0x8002) && (lrElev != 0x8002) && (urElev != 0x8002))
				{
					GetPointerElev(w);
					dElev = (double)tl;
					if (Dem[w].Meas == 'M')//in "METERS"
						dElev /= 0.3048;
					trak[x].alt = (float)dElev;
				}
			}
		}

		if ((pTrackBuf[y] != '\r') && (y < (int)fileSize))
		{//if there's altitude data
			for (z = y; (pTrackBuf[z] != '\r') && (z < (int)fileSize); z++)
				;//put z at end of line
			pTrackBuf[z] = 0;
			if (dElev == 0.0)
			{
				trak[x].alt = (float)atof((char*)&pTrackBuf[y]);
			}
			else
				newelev = TRUE;//if there's both elevation and altitude data
			pTrackBuf[z] = '\r';
			y = z;//to \r
		}
		y += 2;//past \r\n
//		if (x)
//		{
//			u = abs(trak[x-1].NUTM - trak[x].NUTM);
//			u2 = abs(trak[x-1].EUTM - trak[x].EUTM);
//			if (sqrt((double)((u*u)+(u2*u2))) > 304.8)//1,000 feet
//			{
//				trak[x].newtrk = 1;
//				savetracks = TRUE;
//			}
//		}
	}//end of BIG for loop
//	if (savetracks)
//		SaveTracks();
	return x;//numofTracks
}

void CheckRadio(HWND hwndDlg, int red, int green, int blue)
{
	switch (red)
	{
	case 0xFF:
		CheckRadioButton(hwndDlg, IDC_RADIO8, IDC_RADIO11, IDC_RADIO8);
		break;
	case 0xC0:
		CheckRadioButton(hwndDlg, IDC_RADIO8, IDC_RADIO11, IDC_RADIO9);
		break;
	case 0x80:
		CheckRadioButton(hwndDlg, IDC_RADIO8, IDC_RADIO11, IDC_RADIO10);
		break;
	case 0x00:
		CheckRadioButton(hwndDlg, IDC_RADIO8, IDC_RADIO11, IDC_RADIO11);
		break;
	}
	switch (green)
	{
	case 0xFF:
		CheckRadioButton(hwndDlg, IDC_RADIO12, IDC_RADIO15, IDC_RADIO12);
		break;
	case 0xC0:
		CheckRadioButton(hwndDlg, IDC_RADIO12, IDC_RADIO15, IDC_RADIO13);
		break;
	case 0x80:
		CheckRadioButton(hwndDlg, IDC_RADIO12, IDC_RADIO15, IDC_RADIO14);
		break;
	case 0x00:
		CheckRadioButton(hwndDlg, IDC_RADIO12, IDC_RADIO15, IDC_RADIO15);
		break;
	}
	switch (blue)
	{
	case 0xFF:
		CheckRadioButton(hwndDlg, IDC_RADIO16, IDC_RADIO19, IDC_RADIO16);
		break;
	case 0xC0:
		CheckRadioButton(hwndDlg, IDC_RADIO16, IDC_RADIO19, IDC_RADIO17);
		break;
	case 0x80:
		CheckRadioButton(hwndDlg, IDC_RADIO16, IDC_RADIO19, IDC_RADIO18);
		break;
	case 0x00:
		CheckRadioButton(hwndDlg, IDC_RADIO16, IDC_RADIO19, IDC_RADIO19);
		break;
	}
}

int CALLBACK DotProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static int GotData;
	int x;
	char *pUSAPMbuf;
	HANDLE hFile;
	static HWND h1mp, h2mp, h4mp, h8mp, h16mp, h32mp, h64mp, h4mt, h8mt, h16mt, h32mt, h14mu, h12mu, h64mt, h128mt, h256mt, h512mt;

	switch (message)
	{
	case WM_INITDIALOG:
		h1mp = GetDlgItem(hwndDlg, IDC_EDIT1);
		h2mp = GetDlgItem(hwndDlg, IDC_EDIT2);
		h4mp = GetDlgItem(hwndDlg, IDC_EDIT3);
		h8mp = GetDlgItem(hwndDlg, IDC_EDIT4);
		h16mp = GetDlgItem(hwndDlg, IDC_EDIT5);
		h32mp = GetDlgItem(hwndDlg, IDC_EDIT6);
		h64mp = GetDlgItem(hwndDlg, IDC_EDIT7);
		h4mt = GetDlgItem(hwndDlg, IDC_EDIT8);
		h8mt = GetDlgItem(hwndDlg, IDC_EDIT9);
		h16mt = GetDlgItem(hwndDlg, IDC_EDIT10);
		h32mt = GetDlgItem(hwndDlg, IDC_EDIT11);
		h14mu = GetDlgItem(hwndDlg, IDC_EDIT12);
		h12mu = GetDlgItem(hwndDlg, IDC_EDIT13);
		h64mt = GetDlgItem(hwndDlg, IDC_EDIT14);
		h128mt = GetDlgItem(hwndDlg, IDC_EDIT15);
		h256mt = GetDlgItem(hwndDlg, IDC_EDIT16);
		h512mt = GetDlgItem(hwndDlg, IDC_EDIT17);
		SetWindowText(h1mp, PhotoDot1);
		SetWindowText(h2mp, PhotoDot2);
		SetWindowText(h4mp, PhotoDot4);
		SetWindowText(h8mp, PhotoDot8);
		SetWindowText(h16mp, PhotoDot16);
		SetWindowText(h32mp, PhotoDot32);
		SetWindowText(h64mp, PhotoDot64);
		SetWindowText(h4mt, TopoDot4);
		SetWindowText(h8mt, TopoDot8);
		SetWindowText(h16mt, TopoDot16);
		SetWindowText(h32mt, TopoDot32);
		SetWindowText(h64mt, TopoDot64);
		SetWindowText(h128mt, TopoDot128);
		SetWindowText(h256mt, TopoDot256);
		SetWindowText(h512mt, TopoDot512);
		SetWindowText(h14mu, UrbanDot14);
		SetWindowText(h12mu, UrbanDot12);
		SetFocus(h1mp);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (GetWindowText(h1mp, PhotoDot1, 2) == 0)
				break;//all boxes need an entry
			else if (GetWindowText(h2mp, PhotoDot2, 2) == 0)
				break;
			else if (GetWindowText(h4mp, PhotoDot4, 2) == 0)
				break;
			else if (GetWindowText(h8mp, PhotoDot8, 2) == 0)
				break;
			else if (GetWindowText(h16mp, PhotoDot16, 2) == 0)
				break;
			else if (GetWindowText(h32mp, PhotoDot32, 2) == 0)
				break;
			else if (GetWindowText(h64mp, PhotoDot64, 2) == 0)
				break;
			else if (GetWindowText(h4mt, TopoDot4, 2) == 0)
				break;
			else if (GetWindowText(h8mt, TopoDot8, 2) == 0)
				break;
			else if (GetWindowText(h16mt, TopoDot16, 2) == 0)
				break;
			else if (GetWindowText(h32mt, TopoDot32, 2) == 0)
				break;
			else if (GetWindowText(h64mt, TopoDot64, 2) == 0)
				break;
			else if (GetWindowText(h128mt, TopoDot128, 2) == 0)
				break;
			else if (GetWindowText(h256mt, TopoDot256, 2) == 0)
				break;
			else if (GetWindowText(h512mt, TopoDot512, 2) == 0)
				break;
			else if (GetWindowText(h14mu, UrbanDot14, 2) == 0)
				break;
			else if (GetWindowText(h12mu, UrbanDot12, 2) == 0)
				break;
			GetDotRadius(); // DotRadius is used elsewhere and may have changed here
///
			hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				fileSize = GetFileSize(hFile, NULL);
				pUSAPMbuf = (char*)malloc(fileSize);
				ReadFile(hFile, pUSAPMbuf, fileSize, &dwBytesRead, NULL);
				GotData = 0;//to see if data already there
				for (x = 0; x < (int)fileSize; x++)
				{
					if ((pUSAPMbuf[x] == '=') && (pUSAPMbuf[x-3] == 'D') && (pUSAPMbuf[x-2] == 'o') && (pUSAPMbuf[x-1] == 't')) // Dot=
					{
						GotData = 1;
						if ((pUSAPMbuf[x-22] == '1') && (pUSAPMbuf[x-16] == 'P'))
							pUSAPMbuf[x+1] = PhotoDot1[0];
						else if ((pUSAPMbuf[x-22] == '2') && (pUSAPMbuf[x-16] == 'P'))
						{
							if (pUSAPMbuf[x-23] != '3')
								pUSAPMbuf[x+1] = PhotoDot2[0];
							else
								pUSAPMbuf[x+1] = PhotoDot32[0];
						}
						else if ((pUSAPMbuf[x-22] == '4') && (pUSAPMbuf[x-16] == 'P'))
						{
							if (pUSAPMbuf[x-23] == '6')
								pUSAPMbuf[x+1] = PhotoDot64[0];
							else
								pUSAPMbuf[x+1] = PhotoDot4[0];
						}
						else if ((pUSAPMbuf[x-22] == '8') && (pUSAPMbuf[x-16] == 'P'))
							pUSAPMbuf[x+1] = PhotoDot8[0];
						else if ((pUSAPMbuf[x-22] == '6') && (pUSAPMbuf[x-16] == 'P'))
							pUSAPMbuf[x+1] = PhotoDot16[0];
						else if (pUSAPMbuf[x-15] == 'T')
						{//Topo
							if ((pUSAPMbuf[x-21] == '4') && (pUSAPMbuf[x-22] != '6'))
								pUSAPMbuf[x+1] = TopoDot4[0];
							else if ((pUSAPMbuf[x-21] == '8') && (pUSAPMbuf[x-22] != '2'))
								pUSAPMbuf[x+1] = TopoDot8[0];
							else if ((pUSAPMbuf[x-21] == '6') && (pUSAPMbuf[x-22] != '5'))
								pUSAPMbuf[x+1] = TopoDot16[0];
							else if ((pUSAPMbuf[x-21] == '2') && (pUSAPMbuf[x-22] != '1'))
								pUSAPMbuf[x+1] = TopoDot32[0];
							else if ((pUSAPMbuf[x-21] == '4') && (pUSAPMbuf[x-22] == '6'))
								pUSAPMbuf[x+1] = TopoDot64[0];
							else if ((pUSAPMbuf[x-21] == '8') && (pUSAPMbuf[x-22] == '2'))
								pUSAPMbuf[x+1] = TopoDot128[0];
							else if ((pUSAPMbuf[x-21] == '6') && (pUSAPMbuf[x-22] == '5'))
								pUSAPMbuf[x+1] = TopoDot256[0];
							else if ((pUSAPMbuf[x-21] == '2') && (pUSAPMbuf[x-22] == '1'))
								pUSAPMbuf[x+1] = TopoDot512[0];
						}
						else if (pUSAPMbuf[x-16] == 'U')
						{
							if ((pUSAPMbuf[x-22] == '4') && (pUSAPMbuf[x-23] == '1'))
								pUSAPMbuf[x+1] = UrbanDot14[0];
							else if ((pUSAPMbuf[x-22] == '2') && (pUSAPMbuf[x-23] == '1'))
								pUSAPMbuf[x+1] = UrbanDot12[0];
						}
					}
				}
				SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
				WriteFile(hFile, pUSAPMbuf, fileSize, &dwBytesWritten, NULL);
				if (GotData == 0)//if it's not there yet
					WriteDots(hFile);
				CloseHandle(hFile);
				free(pUSAPMbuf);
			}
//			else
//			{
//				hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
//				WriteDots(hFile);
//				CloseHandle(hFile);
//			}
///
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK LineWidthProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x;
	static int GotData;
	char *pUSAPMbuf;
	HANDLE hFile;
	static HWND h1mp, h2mp, h4mp, h8mp, h16mp, h32mp, h64mp, h4mt, h8mt, h16mt, h32mt, h64mt, h128mt, h256mt;

	switch (message)
	{
	case WM_INITDIALOG:
		h1mp = GetDlgItem(hwndDlg, IDC_EDIT1);
		h2mp = GetDlgItem(hwndDlg, IDC_EDIT2);
		h4mp = GetDlgItem(hwndDlg, IDC_EDIT3);
		h8mp = GetDlgItem(hwndDlg, IDC_EDIT4);
		h16mp = GetDlgItem(hwndDlg, IDC_EDIT5);
		h32mp = GetDlgItem(hwndDlg, IDC_EDIT6);
		h64mp = GetDlgItem(hwndDlg, IDC_EDIT7);
		h4mt = GetDlgItem(hwndDlg, IDC_EDIT8);
		h8mt = GetDlgItem(hwndDlg, IDC_EDIT9);
		h16mt = GetDlgItem(hwndDlg, IDC_EDIT10);
		h32mt = GetDlgItem(hwndDlg, IDC_EDIT11);
		h64mt = GetDlgItem(hwndDlg, IDC_EDIT12);
		h128mt = GetDlgItem(hwndDlg, IDC_EDIT13);
		h256mt = GetDlgItem(hwndDlg, IDC_EDIT14);
		SetWindowText(h1mp, LineWidth1);
		SetWindowText(h2mp, LineWidth2);
		SetWindowText(h4mp, LineWidth4);
		SetWindowText(h8mp, LineWidth8);
		SetWindowText(h16mp, LineWidth16);
		SetWindowText(h32mp, LineWidth32);
		SetWindowText(h64mp, LineWidth64);
		SetWindowText(h4mt, TopoLine4);
		SetWindowText(h8mt, TopoLine8);
		SetWindowText(h16mt, TopoLine16);
		SetWindowText(h32mt, TopoLine32);
		SetWindowText(h64mt, TopoLine64);
		SetWindowText(h128mt, TopoLine128);
		SetWindowText(h256mt, TopoLine256);
		SetFocus(h1mp);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (GetWindowText(h1mp, LineWidth1, 2) == 0)
				break;//all boxes need an entry
			else if (GetWindowText(h2mp, LineWidth2, 2) == 0)
				break;
			else if (GetWindowText(h4mp, LineWidth4, 2) == 0)
				break;
			else if (GetWindowText(h8mp, LineWidth8, 2) == 0)
				break;
			else if (GetWindowText(h16mp, LineWidth16, 2) == 0)
				break;
			else if (GetWindowText(h32mp, LineWidth32, 2) == 0)
				break;
			else if (GetWindowText(h64mp, LineWidth64, 2) == 0)
				break;
			else if (GetWindowText(h4mt, TopoLine4, 2) == 0)
				break;
			else if (GetWindowText(h8mt, TopoLine8, 2) == 0)
				break;
			else if (GetWindowText(h16mt, TopoLine16, 2) == 0)
				break;
			else if (GetWindowText(h32mt, TopoLine32, 2) == 0)
				break;
			else if (GetWindowText(h64mt, TopoLine64, 2) == 0)
				break;
			else if (GetWindowText(h128mt, TopoLine128, 2) == 0)
				break;
			else if (GetWindowText(h256mt, TopoLine256, 2) == 0)
				break;
			GetDotRadius();
			FillZoomTable();
///
			hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				fileSize = GetFileSize(hFile, NULL);
				pUSAPMbuf = (char*)malloc(fileSize);
				ReadFile(hFile, pUSAPMbuf, fileSize, &dwBytesRead, NULL);
				GotData = 0;//to see if data already there
				for (x = 0; x < (int)fileSize; x++)
				{
					if (pUSAPMbuf[x] == '=')
					{
						if (pUSAPMbuf[x-5] == 'W')
						{//2MeterLineWidth=4; or 32MeterLineWidth=4;
							if ((pUSAPMbuf[x-15] == '1') && (pUSAPMbuf[x-9] == 'L'))
							{
								pUSAPMbuf[x+1] = LineWidth1[0];
								GotData = 1;
							}
							else if ((pUSAPMbuf[x-15] == '2') && (pUSAPMbuf[x-9] == 'L'))
							{
								if (pUSAPMbuf[x-16] != '3')
								{
									pUSAPMbuf[x+1] = LineWidth2[0];
									GotData = 1;
								}
								else
								{
									pUSAPMbuf[x+1] = LineWidth32[0];
									GotData = 1;
								}
							}
							else if ((pUSAPMbuf[x-15] == '4') && (pUSAPMbuf[x-9] == 'L'))
							{
								if (pUSAPMbuf[x-16] == '6')
								{
									pUSAPMbuf[x+1] = LineWidth64[0];
									GotData = 1;
								}
								else
								{
									pUSAPMbuf[x+1] = LineWidth4[0];
									GotData = 1;
								}
							}
							else if ((pUSAPMbuf[x-15] == '8') && (pUSAPMbuf[x-9] == 'L'))
							{
								pUSAPMbuf[x+1] = LineWidth8[0];
								GotData = 1;
							}
							else if ((pUSAPMbuf[x-15] == '6') && (pUSAPMbuf[x-9] == 'L'))
							{
								pUSAPMbuf[x+1] = LineWidth16[0];
								GotData = 1;
							}
						}
						else if (pUSAPMbuf[x-4] == 'L')
						{//4MeterTopoLine=2
							if ((pUSAPMbuf[x-14] == '4') && (pUSAPMbuf[x-8] == 'T'))
							{
								if (pUSAPMbuf[x-15] != '6')
								{
									pUSAPMbuf[x+1] = TopoLine4[0];
									GotData = 1;
								}
								else if (pUSAPMbuf[x-15] == '6')
								{
									pUSAPMbuf[x+1] = TopoLine64[0];
									GotData = 1;
								}
							}
							else if ((pUSAPMbuf[x-14] == '8') && (pUSAPMbuf[x-8] == 'T'))
							{
								if (pUSAPMbuf[x-15] != '2')
								{
									pUSAPMbuf[x+1] = TopoLine8[0];
									GotData = 1;
								}
								else if (pUSAPMbuf[x-15] == '2')
								{
									pUSAPMbuf[x+1] = TopoLine128[0];
									GotData = 1;
								}
							}
							else if ((pUSAPMbuf[x-14] == '6') && (pUSAPMbuf[x-8] == 'T'))
							{
								if (pUSAPMbuf[x-15] != '5')
								{
									pUSAPMbuf[x+1] = TopoLine16[0];
									GotData = 1;
								}
								else if (pUSAPMbuf[x-15] == '5')
								{
									pUSAPMbuf[x+1] = TopoLine256[0];
									GotData = 1;
								}
							}
							else if ((pUSAPMbuf[x-14] == '2') && (pUSAPMbuf[x-8] == 'T'))
							{
								pUSAPMbuf[x+1] = TopoLine32[0];
								GotData = 1;
							}
						}
					}
				}
				SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
				WriteFile(hFile, pUSAPMbuf, fileSize, &dwBytesWritten, NULL);
				if (GotData == 0)//if it's not there yet
				{
					WriteLineWidth(hFile);
				}
				CloseHandle(hFile);
				free(pUSAPMbuf);
			}
//			else
//			{
//				hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
//				WriteLineWidth(hFile);
//				CloseHandle(hFile);
//			}
///
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK ColorsProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, y, z;
	byte red, green, blue;
	static COLORREF *ptr, OldWaypointColor, OldRouteColor, OldTrackColor, OldPositionColor, OldTextColor, OldAPRSColor, OldTigerColor;
	char USAPMbuf[2048];

	switch (message)
	{
	case WM_INITDIALOG:
		OldWaypointColor = WaypointColor;
		OldRouteColor = RouteColor;
		OldTrackColor = TrackColor;
		OldPositionColor = PositionColor;
		OldTextColor = TextColor;
		OldAPRSColor = APRSColor;
		OldTigerColor = TigerColor;
		ptr = &TrackColor;
		x = CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO7, IDC_RADIO3);
		red = GetRValue(TrackColor);
		green = GetGValue(TrackColor);
		blue = GetBValue(TrackColor);
		CheckRadio(hwndDlg, red, green, blue);
		SetFocus(hwndDlg);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_RADIO1:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO7, IDC_RADIO1);
			ptr = &WaypointColor;
			red = GetRValue(WaypointColor);
			green = GetGValue(WaypointColor);
			blue = GetBValue(WaypointColor);
			CheckRadio(hwndDlg, red, green, blue);
			break;
		case IDC_RADIO2:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO7, IDC_RADIO2);
			ptr = &RouteColor;
			red = GetRValue(RouteColor);
			green = GetGValue(RouteColor);
			blue = GetBValue(RouteColor);
			CheckRadio(hwndDlg, red, green, blue);
			break;
		case IDC_RADIO3:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO7, IDC_RADIO3);
			ptr = &TrackColor;
			red = GetRValue(TrackColor);
			green = GetGValue(TrackColor);
			blue = GetBValue(TrackColor);
			CheckRadio(hwndDlg, red, green, blue);
			break;
		case IDC_RADIO4:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO7, IDC_RADIO4);
			ptr = &PositionColor;
			red = GetRValue(PositionColor);
			green = GetGValue(PositionColor);
			blue = GetBValue(PositionColor);
			CheckRadio(hwndDlg, red, green, blue);
			break;
		case IDC_RADIO5:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO7, IDC_RADIO5);
			ptr = &TextColor;
			red = GetRValue(TextColor);
			green = GetGValue(TextColor);
			blue = GetBValue(TextColor);
			CheckRadio(hwndDlg, red, green, blue);
			break;

		case IDC_RADIO6:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO7, IDC_RADIO6);
			ptr = &APRSColor;
			red = GetRValue(APRSColor);
			green = GetGValue(APRSColor);
			blue = GetBValue(APRSColor);
			CheckRadio(hwndDlg, red, green, blue);
			break;

		case IDC_RADIO7:
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO7, IDC_RADIO7);
			ptr = &TigerColor;
			red = GetRValue(TigerColor);
			green = GetGValue(TigerColor);
			blue = GetBValue(TigerColor);
			CheckRadio(hwndDlg, red, green, blue);
			break;

		case IDC_RADIO8:
			*ptr = (*ptr & 0xFFFF00) | 0x0000FF;
			goto showit;
		case IDC_RADIO9:
			*ptr = (*ptr & 0xFFFF00) | 0x0000C0;
			goto showit;
		case IDC_RADIO10:
			*ptr = (*ptr & 0xFFFF00) | 0x000080;
			goto showit;
		case IDC_RADIO11:
			*ptr = *ptr & 0xFFFF00;
			goto showit;

		case IDC_RADIO12:
			*ptr = (*ptr & 0xFF00FF) | 0x00FF00;
			goto showit;
		case IDC_RADIO13:
			*ptr = (*ptr & 0xFF00FF) | 0x00C000;
			goto showit;
		case IDC_RADIO14:
			*ptr = (*ptr & 0xFF00FF) | 0x008000;
			goto showit;
		case IDC_RADIO15:
			*ptr = *ptr & 0xFF00FF;
			goto showit;

		case IDC_RADIO16:
			*ptr = (*ptr & 0x00FFFF) | 0xFF0000;
			goto showit;
		case IDC_RADIO17:
			*ptr = (*ptr & 0x00FFFF) | 0xC00000;
			goto showit;
		case IDC_RADIO18:
			*ptr = (*ptr & 0x00FFFF) | 0x800000;
			goto showit;
		case IDC_RADIO19:
			*ptr = *ptr & 0x00FFFF;
showit:		InvalidateRect(hwnd, &rect, FALSE);
			break;

		case IDOK:
			WaypointColour[21] = (char)(WaypointColor & 0xF) + '0';
			if (WaypointColour[21] > '9')
				WaypointColour[21] += 7;
			WaypointColour[20] = (char)((WaypointColor >> 4) & 0xF) + '0';
			if (WaypointColour[20] > '9')
				WaypointColour[20] += 7;
			WaypointColour[19] = (char)((WaypointColor >> 8) & 0xF) + '0';
			if (WaypointColour[19] > '9')
				WaypointColour[19] += 7;
			WaypointColour[18] = (char)((WaypointColor >> 12) & 0xF) + '0';
			if (WaypointColour[18] > '9')
				WaypointColour[18] += 7;
			WaypointColour[17] = (char)((WaypointColor >> 16) & 0xF) + '0';
			if (WaypointColour[17] > '9')
				WaypointColour[17] += 7;
			WaypointColour[16] = (char)((WaypointColor >> 20) & 0xF) + '0';
			if (WaypointColour[16] > '9')
				WaypointColour[16] += 7;

			RouteColour[18] = (char)(RouteColor & 0xF) + '0';
			if (RouteColour[18] > '9')
				RouteColour[18] += 7;
			RouteColour[17] = (char)((RouteColor >> 4) & 0xF) + '0';
			if (RouteColour[17] > '9')
				RouteColour[17] += 7;
			RouteColour[16] = (char)((RouteColor >> 8) & 0xF) + '0';
			if (RouteColour[16] > '9')
				RouteColour[16] += 7;
			RouteColour[15] = (char)((RouteColor >> 12) & 0xF) + '0';
			if (RouteColour[15] > '9')
				RouteColour[15] += 7;
			RouteColour[14] = (char)((RouteColor >> 16) & 0xF) + '0';
			if (RouteColour[14] > '9')
				RouteColour[14] += 7;
			RouteColour[13] = (char)((RouteColor >> 20) & 0xF) + '0';
			if (RouteColour[13] > '9')
				RouteColour[13] += 7;

			TrackColour[18] = (char)(TrackColor & 0xF) + '0';
			if (TrackColour[18] > '9')
				TrackColour[18] += 7;
			TrackColour[17] = (char)((TrackColor >> 4) & 0xF) + '0';
			if (TrackColour[17] > '9')
				TrackColour[17] += 7;
			TrackColour[16] = (char)((TrackColor >> 8) & 0xF) + '0';
			if (TrackColour[16] > '9')
				TrackColour[16] += 7;
			TrackColour[15] = (char)((TrackColor >> 12) & 0xF) + '0';
			if (TrackColour[15] > '9')
				TrackColour[15] += 7;
			TrackColour[14] = (char)((TrackColor >> 16) & 0xF) + '0';
			if (TrackColour[14] > '9')
				TrackColour[14] += 7;
			TrackColour[13] = (char)((TrackColor >> 20) & 0xF) + '0';
			if (TrackColour[13] > '9')
				TrackColour[13] += 7;

			PositionColour[21] = (char)(PositionColor & 0xF) + '0';
			if (PositionColour[21] > '9')
				PositionColour[21] += 7;
			PositionColour[20] = (char)((PositionColor >> 4) & 0xF) + '0';
			if (PositionColour[20] > '9')
				PositionColour[20] += 7;
			PositionColour[19] = (char)((PositionColor >> 8) & 0xF) + '0';
			if (PositionColour[19] > '9')
				PositionColour[19] += 7;
			PositionColour[18] = (char)((PositionColor >> 12) & 0xF) + '0';
			if (PositionColour[18] > '9')
				PositionColour[18] += 7;
			PositionColour[17] = (char)((PositionColor >> 16) & 0xF) + '0';
			if (PositionColour[17] > '9')
				PositionColour[17] += 7;
			PositionColour[16] = (char)((PositionColor >> 20) & 0xF) + '0';
			if (PositionColour[16] > '9')
				PositionColour[16] += 7;

			TextColour[17] = (char)(TextColor & 0xF) + '0';
			if (TextColour[17] > '9')
				TextColour[17] += 7;
			TextColour[16] = (char)((TextColor >> 4) & 0xF) + '0';
			if (TextColour[16] > '9')
				TextColour[16] += 7;
			TextColour[15] = (char)((TextColor >> 8) & 0xF) + '0';
			if (TextColour[15] > '9')
				TextColour[15] += 7;
			TextColour[14] = (char)((TextColor >> 12) & 0xF) + '0';
			if (TextColour[14] > '9')
				TextColour[14] += 7;
			TextColour[13] = (char)((TextColor >> 16) & 0xF) + '0';
			if (TextColour[13] > '9')
				TextColour[13] += 7;
			TextColour[12] = (char)((TextColor >> 20) & 0xF) + '0';
			if (TextColour[12] > '9')
				TextColour[12] += 7;

			APRSColour[17] = (char)(APRSColor & 0xF) + '0';
			if (APRSColour[17] > '9')
				APRSColour[17] += 7;
			APRSColour[16] = (char)((APRSColor >> 4) & 0xF) + '0';
			if (APRSColour[16] > '9')
				APRSColour[16] += 7;
			APRSColour[15] = (char)((APRSColor >> 8) & 0xF) + '0';
			if (APRSColour[15] > '9')
				APRSColour[15] += 7;
			APRSColour[14] = (char)((APRSColor >> 12) & 0xF) + '0';
			if (APRSColour[14] > '9')
				APRSColour[14] += 7;
			APRSColour[13] = (char)((APRSColor >> 16) & 0xF) + '0';
			if (APRSColour[13] > '9')
				APRSColour[13] += 7;
			APRSColour[12] = (char)((APRSColor >> 20) & 0xF) + '0';
			if (APRSColour[12] > '9')
				APRSColour[12] += 7;

			TigerColour[18] = (char)(TigerColor & 0xF) + '0';
			if (TigerColour[18] > '9')
				TigerColour[18] += 7;
			TigerColour[17] = (char)((TigerColor >> 4) & 0xF) + '0';
			if (TigerColour[17] > '9')
				TigerColour[17] += 7;
			TigerColour[16] = (char)((TigerColor >> 8) & 0xF) + '0';
			if (TigerColour[16] > '9')
				TigerColour[16] += 7;
			TigerColour[15] = (char)((TigerColor >> 12) & 0xF) + '0';
			if (TigerColour[15] > '9')
				TigerColour[15] += 7;
			TigerColour[14] = (char)((TigerColor >> 16) & 0xF) + '0';
			if (TigerColour[14] > '9')
				TigerColour[14] += 7;
			TigerColour[13] = (char)((TigerColor >> 20) & 0xF) + '0';
			if (TigerColour[13] > '9')
				TigerColour[13] += 7;

			hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile == INVALID_HANDLE_VALUE)
			{
				hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
//				strcpy(USAPMbufOut, Deg);
//				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
//				strcpy(USAPMbufOut, Zoom1);
//				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
//				strcpy(USAPMbufOut, DoShowNearest);
//				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
//				strcpy(USAPMbufOut, DoShowName);
//				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
//				strcpy(USAPMbufOut, DoSortbyName);
//				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
				strcpy(USAPMbufOut, WaypointColour);
				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
				strcpy(USAPMbufOut, RouteColour);
				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
				strcpy(USAPMbufOut, TrackColour);
				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
				strcpy(USAPMbufOut, PositionColour);
				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
				strcpy(USAPMbufOut, TextColour);
				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
				strcpy(USAPMbufOut, APRSColour);
				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
				strcpy(USAPMbufOut, TigerColour);
				WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);
			}
			else//if it exists
			{
				fileSize = GetFileSize(hFile, NULL);
				ReadFile(hFile, USAPMbuf, fileSize, &dwBytesRead, NULL);
				for (x = 0, z = 0; (x < (int)fileSize) && (z <= 6); x++)
				{//change color numbers
					if ((USAPMbuf[x] == '=') && (USAPMbuf[x-1] == 'r'))
					{
						if (USAPMbuf[x-7] == 'n')//WaypointColor=0x00FF00
						{
							for (y = 0; y < 6; y++)
								USAPMbuf[x+3+y] = WaypointColour[16+y];
							z++;
						}
						else if (USAPMbuf[x-6] == 'e')//RouteColor=0xFFFFFF
						{
							for (y = 0; y < 6; y++)
								USAPMbuf[x+3+y] = RouteColour[13+y];
							z++;
						}
						else if (USAPMbuf[x-6] == 'k')//TrackColor=0xC08000
						{
							for (y = 0; y < 6; y++)
								USAPMbuf[x+3+y] = TrackColour[13+y];
							z++;
						}
						else if (USAPMbuf[x-6] == 'n')//PositionColor=0xFFFF00
						{
							for (y = 0; y < 6; y++)
								USAPMbuf[x+3+y] = PositionColour[16+y];
							z++;
						}
						else if (USAPMbuf[x-7] == 'x')//TextColor=0x80FF00
						{
							for (y = 0; y < 6; y++)
								USAPMbuf[x+3+y] = TextColour[12+y];
							z++;
						}
						else if (USAPMbuf[x-7] == 'R')//APRSColor=0x0000FF
						{
							for (y = 0; y < 6; y++)
								USAPMbuf[x+3+y] = APRSColour[12+y];
							z++;
						}
						else if ((USAPMbuf[x-7] == 'e') && (USAPMbuf[x-6] == 'r'))//TigerColor=0x0000FF
						{
							for (y = 0; y < 6; y++)
								USAPMbuf[x+3+y] = TigerColour[13+y];
							z++;
						}
					}
				}		
				if (z == 7)
				{//got color lines
					SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
					WriteFile(hFile, USAPMbuf, fileSize, &dwBytesWritten, NULL);
				}
				else if (z == 4)//TextColour not included - append it
					WriteFile(hFile, TextColour, sizeof(TextColour)-1, &dwBytesWritten, NULL);
				else if (z == 5)//APRSColour not included - append it
					WriteFile(hFile, APRSColour, sizeof(APRSColour)-1, &dwBytesWritten, NULL);
				else if (z == 6)//TigerColour not included - append it
					WriteFile(hFile, TigerColour, sizeof(TigerColour)-1, &dwBytesWritten, NULL);
				else
				{//no colors
					WriteFile(hFile, WaypointColour, sizeof(WaypointColour)-1, &dwBytesWritten, NULL);
					WriteFile(hFile, RouteColour, sizeof(RouteColour)-1, &dwBytesWritten, NULL);
					WriteFile(hFile, TrackColour, sizeof(TrackColour)-1, &dwBytesWritten, NULL);
					WriteFile(hFile, PositionColour, sizeof(PositionColour)-1, &dwBytesWritten, NULL);
					WriteFile(hFile, TextColour, sizeof(TextColour)-1, &dwBytesWritten, NULL);
					WriteFile(hFile, APRSColour, sizeof(APRSColour)-1, &dwBytesWritten, NULL);
					WriteFile(hFile, TigerColour, sizeof(TigerColour)-1, &dwBytesWritten, NULL);
				}
			}
			CloseHandle(hFile);
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			WaypointColor = OldWaypointColor;
			RouteColor = OldRouteColor;
			TrackColor = OldTrackColor;
			PositionColor = OldPositionColor;
			TextColor = OldTextColor;
			APRSColor = OldAPRSColor;
			TigerColor = OldTigerColor;
			InvalidateRect(hwnd, &rect, FALSE);
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK PreferencesProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x;
	static HWND hwndExisting, hwndNearest, hwndCheck1, hwndCheck2, hwndCheck3, hwndCheck4, hwndCheck5, hwndCheck6, hwndCheck7, hButton1, hButton2, hSlider2, hButton3, hButton4;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndCheck1 = GetDlgItem(hwndDlg, IDC_CHECK1);
		hwndCheck2 = GetDlgItem(hwndDlg, IDC_CHECK2);
		hwndCheck3 = GetDlgItem(hwndDlg, IDC_CHECK3);
		hwndCheck4 = GetDlgItem(hwndDlg, IDC_CHECK4);
		hwndCheck5 = GetDlgItem(hwndDlg, IDC_CHECK5);
		hwndCheck6 = GetDlgItem(hwndDlg, IDC_CHECK6);
		hwndCheck7 = GetDlgItem(hwndDlg, IDC_CHECK7);
		hButton1 = GetDlgItem(hwndDlg, IDC_BUTTON1);
		hButton2 = GetDlgItem(hwndDlg, IDC_BUTTON2);
		hSlider2 = GetDlgItem(hwndDlg, IDC_SLIDER2);
		hButton3 = GetDlgItem(hwndDlg, IDC_BUTTON3);
		hButton4 = GetDlgItem(hwndDlg, IDC_BUTTON4);
		SendMessage(hSlider2, TBM_SETRANGE, (WPARAM)TRUE, (LPARAM)MAKELONG(0, 9));
		SendMessage(hSlider2, TBM_SETTICFREQ, (WPARAM)1, (LPARAM)0);
		SendMessage(hSlider2, TBM_SETLINESIZE, (WPARAM)0, (LPARAM)1);
		SendMessage(hSlider2, TBM_SETPAGESIZE, (WPARAM)0, (LPARAM)1);
		if (Spaces2Move != 0)
			SendMessage(hSlider2, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)(Spaces2Move));
		if (showlatlon == TRUE)
			CheckDlgButton (hwndDlg, IDC_CHECK2, BST_CHECKED);
		if (sortbyname == TRUE)
			CheckDlgButton (hwndDlg, IDC_CHECK4, BST_CHECKED);
		if (showname == TRUE)
			CheckDlgButton (hwndDlg, IDC_CHECK3, BST_CHECKED);
		if (zoom1to8 == TRUE)//ZoomTo8Meters
			CheckDlgButton (hwndDlg, IDC_CHECK5, BST_CHECKED);
		if (openatclosing == TRUE)
			CheckDlgButton (hwndDlg, IDC_CHECK6, BST_CHECKED);
		if (FadeIncrement == 10)
			CheckDlgButton (hwndDlg, IDC_CHECK7, BST_CHECKED);
		SetFocus(GetDlgItem(hwndDlg, IDCANCEL));
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_BUTTON3:
			x = SendMessage(hSlider2, TBM_GETPOS, 0, 0);
			if (x > 0)
				SendMessage(hSlider2, TBM_SETPOS, TRUE, --x);
			break;
		case IDC_BUTTON4:
			x = SendMessage(hSlider2, TBM_GETPOS, 0, 0);
			if (x < 9)
				SendMessage(hSlider2, TBM_SETPOS, TRUE, ++x);
			break;
		case IDC_CHECK1:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK1))
				SendMessage(hwndCheck1, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
			else
				SendMessage(hwndCheck1, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
			break;
		case IDC_CHECK2:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK2))
				SendMessage(hwndCheck2, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
			else
				SendMessage(hwndCheck2, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
			break;
		case IDC_CHECK3:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK3))
				SendMessage(hwndCheck3, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
			else
				SendMessage(hwndCheck3, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
			break;
		case IDC_CHECK4:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK4))
			{
				SendMessage(hwndCheck4, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
				newLoc = TRUE;
			}
			else
			{
				SendMessage(hwndCheck4, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
				newLoc = TRUE;
			}
			break;
		case IDC_CHECK5:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK5))
				SendMessage(hwndCheck5, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
			else
				SendMessage(hwndCheck5, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
			break;
		case IDC_CHECK6:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK6))
				SendMessage(hwndCheck6, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
			else
				SendMessage(hwndCheck6, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
			break;

		case IDOK:
			{
				prefOutMouseLoc = prefInMouseLoc;
				prefOutZoom = prefInZoom;
				if (BST_CHECKED == IsDlgButtonChecked (hwndDlg, IDC_CHECK6))
					openatclosing = TRUE;
				else
					openatclosing = FALSE;

				if (BST_CHECKED == IsDlgButtonChecked (hwndDlg, IDC_CHECK1))
					ChangeUSAPhotoMapsIni();//changes stuff that ChangeUSAPMIni() looks for

				if (BST_CHECKED == IsDlgButtonChecked (hwndDlg, IDC_CHECK2))
				{
					prefOutLatlon = TRUE;
					showlatlon = TRUE;
				}
				else
				{
					prefOutLatlon = FALSE;
					showlatlon = FALSE;
				}

				if (BST_CHECKED == IsDlgButtonChecked (hwndDlg, IDC_CHECK3))
				{
					prefOutName = TRUE;
					showname = TRUE;
				}
				else
				{
					prefOutName = FALSE;
					showname = FALSE;
				}

				if (BST_CHECKED == IsDlgButtonChecked (hwndDlg, IDC_CHECK4))
				{
					sortbyname = TRUE;
					qsort(NewLoc, EmptyLoc, sizeof(NewLoc[0]), compareIdent);
				}
				else
				{
					sortbyname = FALSE;
					qsort(NewLoc, EmptyLoc, sizeof(NewLoc[0]), compareLoc);
				}

				if (BST_CHECKED == IsDlgButtonChecked (hwndDlg, IDC_CHECK5))
					zoom1to8 = TRUE;
				else
					zoom1to8 = FALSE;

				if (BST_CHECKED == IsDlgButtonChecked (hwndDlg, IDC_CHECK7))
					FadeIncrement = 10;
				else
					FadeIncrement = 0;

				x = SendMessage(hSlider2, TBM_GETPOS, 0, 0);
				if (x != 0)
					Spaces2Move = x;
				else
					Spaces2Move = 0;
				/////////////////
				ChangeUSAPMIni();
				/////////////////
			}
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK LatLonProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	HWND hwndText;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetWindowText(hwndText, LatLonUTM);
		SetFocus(hwndText);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

void ChangeZone(int xUTMZone, int from)
{
	int x, y, z, savex, ptr, ptr2, N, E;
	unsigned char *pIni;
	double a, b;
	char NewArea[] = "ZoneXX";
	char Newline[] = "*Zone11&X=                     ";
//*Atlanta&X=3710&Y=18706&Z=16
	HANDLE hIniFile;

	struct {
		int N;
		int E;
		int linebeg;
		char Name[48];
		double dist;
	} Inzone[100];

 	UTMZone = xUTMZone;
	if ((UTMNorthing < 1975000) || (UTMNorthing > 7991000) || (UTMEasting < 150000) || (UTMEasting > 999999) || (UTMZone > 20) || (UTMZone < 3))
	{
char *From[] = {"GoTo a Populated Place OR GoTo an Address OR GoTo a USGS Landmark",\
"GoTo Beginning of Tracks",\
"Show Route",\
"GoTo USNG coordinates",\
"Right Mouse Button",\
"GoTo Lat/Lon",\
"Show Position",\
"Show Position",\
"Left Mouse Button",\
"Left or Right Arrow Key"};

		sprintf(Error, "%s%s\nUTM Easting was %i\nUTM Northing was %i\nUTM Zone was %i", PreError, From[from], UTMEasting, UTMNorthing, UTMZone);
		MessageBox(hwnd, Error, ERROR, MB_OK);
		openatclosing = FALSE;
		SendMessage(hwnd, WM_CLOSE, 0,0);
		return;
	}
	N = UTMNorthing / MetersPerTile;
	E = UTMEasting / MetersPerTile;
	ptr = 0;
	for (x = 0; x < 100; x++)
 		Inzone[x].N = 0;//flag was linebeg

	hFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			pIni = (unsigned char*)malloc(fileSize+33);//31 to add new line
				ReadFile(hFile, pIni, fileSize, &dwBytesRead, NULL);
			CloseHandle(hFile);
			if (newLoc)
				SaveLocs();
			if (newText)
				SaveText();
			for (x = 0; (pIni[x] != '*') && (x < fileSize); x++)
				;
			if (x == (int)fileSize)
			{
				MessageBox(hwnd, "No '*' at beginning of any line\nin USAPhotoMaps.ini file!", NULL, MB_OK);
				return;
			}
			y = x + 1;
			for ( ; y < fileSize; x++, y++)
				pIni[x] = pIni[y];//get rid of '*'
			fileSize--;

			waypointinini = FALSE;
			if (fromwaypoints)
			{
				for (x = 0; x < (int)fileSize; x++)
				{//look for same waypoint name in pIni
					if ((x == 0) || (pIni[x-1] == '\n'))
					{
						int linebegin = x;
						for (z = x, w = 0; pIni[z] != '&'; w++, z++)
						{
							if (pIni[z] != Waypoints[w])
								break;
						}
						if ((pIni[z] == '&') && (Waypoints[w] == '.'))//found match
						{// BayArea& BayArea.xml
							x = z;
							for ( ; pIni[z] != '\r'; z++)
								;
							w = (pIni[z-1] - '0') + ((pIni[z-2] - '0') * 10);//utmzone in pIni line
							if (w == UTMZone)
							{//same name, same zone
								for (y = (int)fileSize; y > linebegin; y--)
									pIni[y] = pIni[y-1];
								pIni[y++] = '*';
								x++;
								for (z = 0; (pIni[y] != '&') && (y < (int)fileSize); y++, z++)
									Area[z] = pIni[y];
								Area[z] = 0;
								fileSize++;
								y = x + 3;//to Easting
								for (x = 0; pIni[y] != '&'; x++, y++)
									X[x] = pIni[y];
								X[x] = 0;
								y += 3;//to Northing
								for (x = 0; pIni[y] != '&'; x++, y++)
									Y[x] = pIni[y];
								Y[x] = 0;
								y += 3;//to Zone
								Z[0] = pIni[y++];
								Z[1] = pIni[y];
								BeginX = atoi(X);
								BeginY = atoi(Y);
								if (MetersPerTile == 1600)
								{
									BeginX /= 8;
									BeginY /= 8;
								}
								else if (MetersPerTile == 800)
								{
									BeginX /= 4;
									BeginY /= 4;
								}
								else if (MetersPerTile == 50)
								{
									BeginX *= 4;
									BeginY *= 4;
								}
								UTMNorthing = BeginY * MetersPerTile;
								UTMEasting =  BeginX * MetersPerTile;
//								GetLatLon();

								waypointinini = TRUE;
								break;
							}
						}
					}
				}//end of for
			}//end of if (fromwaypoints)

			if (FALSE == waypointinini)
			{
				for (x = 0; x < (int)fileSize; x++)
				{//put all possible Maps in Inzone
					if (pIni[x] == '\r')
					{//at end of a line
						if (UTMZone == ((pIni[x-2] - '0') * 10) + pIni[x-1] - '0')
						{//if desired UTMZone is in .ini file
							savex = x;//pIni[x] is at '\r'
							for ( ; (pIni[x-1] != '\n') && (x != 0); x--)
								;//go back to beginning of line
							Inzone[ptr].linebeg = x;
							for (y = x, x = 0; (pIni[y] != '&') && (y < (int)fileSize); x++, y++)
							{
								Inzone[ptr].Name[x] = pIni[y];
								if (fromwaypoints == FALSE)
									Area[x] = pIni[y];
							}
							if (fromwaypoints == FALSE)
								Area[x] = 0;
							if (y == (int)fileSize)
							{
								free(pIni);
								MessageBox(hwnd, "Error 69", ERROR, MB_OK);
								return;
							}
							Inzone[ptr].Name[x] = 0;
							y += 3;//to Easting
							Inzone[ptr].E = atoi((char*)&pIni[y]);
							y += 7;
							Inzone[ptr].N = atoi((char*)&pIni[y]);
							if (MetersPerTile == 1600)
							{
								Inzone[ptr].E /= 8;
								Inzone[ptr].N /= 8;
							}
							else if (MetersPerTile == 800)
							{
								Inzone[ptr].E /= 4;
								Inzone[ptr].N /= 4;
							}
							else if (MetersPerTile == 50)
							{
								Inzone[ptr].E *= 4;
								Inzone[ptr].N *= 4;
							}
							a = abs(N - Inzone[ptr].N);
							b = abs(E - Inzone[ptr].E);
							Inzone[ptr].dist = sqrt(a*a + b*b);
							ptr++;
							x = savex;
						}
					}
				}

				if (Inzone[0].N != 0)
				{//if zone match found in pIni
					ptr2 = 0;
					a = Inzone[0].dist;
					for (ptr = 1; Inzone[ptr].N != 0; ptr++)
					{//get closest Inzone Name
						if (Inzone[ptr].dist <= a)
						{
							ptr2 = ptr;
							a = Inzone[ptr].dist;
						}
					}
					fileSize++;
					for (y = (int)fileSize; y > Inzone[ptr2].linebeg; y--)
						pIni[y] = pIni[y-1];
					pIni[y++] = '*';
//					if (fromwaypoints)
					{
						for (x = 0; pIni[y] != '&'; x++, y++)
							Area[x] = pIni[y];
						Area[x] = 0;
						if (notfromroute)
						{
							y += 3;//to Easting
							for (x = 0; pIni[y] != '&'; x++, y++)
								X[x] = pIni[y];
							X[x] = 0;
							y += 3;//to Northing
							for (x = 0; pIni[y] != '&'; x++, y++)
								Y[x] = pIni[y];
							Y[x] = 0;
							y += 3;//to Zone
							Z[0] = pIni[y++];
							Z[1] = pIni[y];
							BeginY = Inzone[ptr2].N;
							BeginX = Inzone[ptr2].E;
//							UTMNorthing = BeginY * MetersPerTile;
//							UTMEasting =  BeginX * MetersPerTile;
//							GetLatLon();
						}
					}
				}
//char Newline[] = "*Zonexx&X=xxxx&Y=                                    ";
//*Atlanta&X=3710&Y=18706&Z=16
				else
				{//create line in ini file
					BeginY = UTMNorthing / MetersPerTile;
					BeginX = UTMEasting / MetersPerTile;
					if (DialogBox(hInst, "MAPLOCATION", hwnd, MapLocationProc))
					{
						x = (int)fileSize;
						pIni[x++] = '*';
						for (z = 0; Area[z] != 0; x++, z++)
							pIni[x] = Area[z];
						y = UTMNorthing / 200;
						z = UTMEasting / 200;
						pIni[x++] = '&';
						pIni[x++] = 'X';
						pIni[x++] = '=';
						pIni[x++] = (z / 1000) + '0';
 						pIni[x++] = ((z % 1000) / 100) + '0';
 						pIni[x++] = ((z % 100) / 10) + '0';
						pIni[x++] = (z % 10) + '0';
 						pIni[x++] = '&';
						pIni[x++] = 'Y';
						pIni[x++] = '=';
						if (BeginY > 99999)
							pIni[x++] = (y / 100000) + '0';
						pIni[x++] = ((y % 100000) / 10000) + '0';
 						pIni[x++] = ((y % 10000) / 1000) + '0';
 						pIni[x++] = ((y % 1000) / 100) + '0';
 						pIni[x++] = ((y % 100) / 10) + '0';
 						pIni[x++] = (y % 10) + '0';
						pIni[x++] = '&';
						pIni[x++] = 'Z';
						pIni[x++] = '=';
						pIni[x++] = (UTMZone / 10) + '0';//zone
						pIni[x++] = (UTMZone % 10) + '0';//zone
						pIni[x++] = '\r';
						pIni[x++] = '\n';
						y = fileSize+1;//beginning of the new line (after the '*')
						fileSize = x;
					}
					else
					{
						MessageBox(hwnd, "Zonexx added", "", MB_OK);
						for (y = 0; y < 4; y++)
							Area[y] = NewArea[y];
						Area[y++] = (UTMZone / 10) + '0';
						Area[y++] = (UTMZone % 10) + '0';
						Area[y] = 0;
						y = UTMNorthing / 200;
						z = UTMEasting / 200;
						Newline[5] = (UTMZone / 10) + '0';//zone
						Newline[6] = (UTMZone % 10) + '0';//zone
						Newline[10] = (z / 1000) + '0';
 						Newline[11] = ((z % 1000) / 100) + '0';
 						Newline[12] = ((z % 100) / 10) + '0';
 						Newline[13] = (z % 10) + '0';
 						Newline[14] = '&';
						Newline[15] = 'Y';
						Newline[16] = '=';
						x = 17;
						if (BeginY > 99999)
							Newline[x++] = (y / 100000) + '0';
						Newline[x++] = ((y % 100000) / 10000) + '0';
 						Newline[x++] = ((y % 10000) / 1000) + '0';
 						Newline[x++] = ((y % 1000) / 100) + '0';
 						Newline[x++] = ((y % 100) / 10) + '0';
 						Newline[x++] = (y % 10) + '0';
 						Newline[x++] = '&';
						Newline[x++] = 'Z';
						Newline[x++] = '=';
						Newline[x++] = (UTMZone / 10) + '0';//zone
						Newline[x++] = (UTMZone % 10) + '0';//zone
						Newline[x++] = '\r';
						Newline[x++] = '\n';
						for (y = (int)fileSize, z = 0; z < x; y++, z++)
							pIni[y] = Newline[z];
						y = fileSize+1;//beginning of the new line (after the '*')
						fileSize += x;
					}
					if (fromwaypoints)
					{
						for (x = 0; pIni[y] != '&'; x++, y++)
							;
						y += 3;//to Easting
						for (x = 0; pIni[y] != '&'; x++, y++)
							X[x] = pIni[y];
						X[x] = 0;
						y += 3;//to Northing
						for (x = 0; pIni[y] != '&'; x++, y++)
							Y[x] = pIni[y];
						Y[x] = 0;
						y += 3;//to Zone
						Z[0] = pIni[y++];
						Z[1] = pIni[y];
					}
//					GetLatLon();
				}
			}//end of if (FALSE == waypointinini)

			x = CheckIniProc(pIni, fileSize, 5);//ChangeZone
			if (x == (int)fileSize)
			{
 				hIniFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hIniFile, pIni, fileSize, &dwBytesWritten, NULL);
				CloseHandle(hIniFile);
			}
			else
			{
				MessageBox(hwnd, Buf2, ERROR, MB_OK);
				openatclosing = FALSE;
				SendMessage(hwnd, WM_CLOSE, 0, 0);
			}
			free(pIni);
		}//end of if (fileSize
		else
		{
			CloseHandle(hFile);
			MessageBox(hwnd, "USAPhotoMaps.ini is empty!", NULL, MB_OK);
		}
		if (USGSBuf != NULL)
		{
			VirtualFree(USGSBuf, 0, MEM_RELEASE);
			VirtualFree(PtrBuf, 0, MEM_RELEASE);
			USGSBuf = NULL;
			GetUSGSData();
		}
	}//end of if (hFile != INVALID_HANDLE_VALUE)
	else
		MessageBox(hwnd, "No USAPhotoMaps.ini file!", NULL, MB_OK);

	GetTigerIndex();
}

void GetRandomNum(void)
{
	int y;
	LARGE_INTEGER large;

	GetSystemTimeAsFileTime(&ft);
	li = *(LARGE_INTEGER*)&ft;
	li.QuadPart >>= 16;//get rid of unnecessary numbers;
	for (y = 5; y >= 0; y--)
	{
		large.QuadPart = (li.QuadPart & 0x1F);//lowest 5 bits
		li.QuadPart >>= 5;
		c = (char)large.QuadPart;
		if (c > 25) c = (c - 26) + '0';
		else c += 'A';
		Num[y] = c;//Ident
	}
}

int AsciiToHex(int x)
{
	int w, y, z;

	for (z = 0, y = 3; y < 9; y++)
	{
		w = pUSAPMbufIn[x+y] - '0';
		z <<= 4;
		if (w > 9) w -= 7;
		z |= w;
	}
	return z;
}

//$PMGNRTE,2,1,c,1,GCQAJR,a,GCQAK4,a*61
//$PMGNRTE,2,2,c,1,GCJ37G,a,GC33E5,a*7C
DWORD PrepSendRoute(void)
{//$PMGNRTE,2,1,c,1,1,a,2,a,3,a*6C
	int x, y;

	for (y = 0; y < 9; y++)
		SendRoute[y] = Rute[y];//$PMGNRTE,
	_itoa(totalroutelines, &SendRoute[y], 10);
	y++;
	if (totalroutelines >= 10)
		y++;//past second digit
	SendRoute[y++] = ',';
	_itoa(routeline, &SendRoute[y], 10);
	y++;
	if (routeline >= 10)
		y++;//past second digit
	routeline++;
	SendRoute[y++] = ',';
	SendRoute[y++] = 'c';
	SendRoute[y++] = ',';
	SendRoute[y++] = '1';//route number
//	SendRoute[y++] = ',';
//	SendRoute[y++] = 'F';//RouteName[0];
//	SendRoute[y++] = 'O';//RouteName[1];
//	SendRoute[y++] = 'O';//RouteName[1];
	for (x = 0; x < 3; x++)
	{//max of 3 waypoints/line
		SendRoute[y++] = ',';
		SendRoute[y++] = Nums[LocNum][0];
		if (Nums[LocNum][1] != '<')//if there are 2 numbers in waypoint name
		{
			SendRoute[y++] = Nums[LocNum][1];
			if (Nums[LocNum][2] != '<')//if there are 3 numbers in waypoint name
				SendRoute[y++] = Nums[LocNum][2];
		}
		LocNum++;
		numofRoutes--;
		SendRoute[y++] = ',';
		SendRoute[y++] = 'a';
		if (numofRoutes == 0)
			break;
	}
	SendRoute[y++] = '*';
	for (checksum = 0, x = 1; SendRoute[x] != '*'; x++)
		checksum ^= SendRoute[x];//MAGELLAN
	x = checksum >> 4;
	SendRoute[y++] = (char)(x > 9) ? x + 0x37 : x + 0x30;
	x = checksum & 0x0F;
	SendRoute[y++] = (char)(x > 9) ? x + 0x37 : x + 0x30;
	SendRoute[y++] = '\r';
	SendRoute[y++] = '\n';
	SendRoute[y] = 0;
	return y;
}//$PMGNRTE,2,1,c,01,1,2,3,4*xx<CR><LF>

void ShowDownloadProgress(int x)
{//recursive
	DownloadProgress[x]++;
	if (DownloadProgress[x] > '9')
	{
		DownloadProgress[x] = '0';
		if (x == 0)
			return;
		x--;
		ShowDownloadProgress(x);
	}
}

void PhotoNames(void)
{
	char ch1, ch2;

	if ((fd.cFileName[0] != '.') && (fd.cFileName[1] != '.'))
	{
		for (x = 0; fd.cFileName[x] != 0; x++)
			Photo[P].name[x] = fd.cFileName[x];
		Photo[P].name[x] = 0;
		for (x = 0; Description[x] != 0; x++)
		{
			ch1 = Description[x];
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 &= 0xDF;
			ch2 = Photo[P].name[0];
			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 &= 0xDF;
			if (ch1 == ch2)
			{
				Photo[P].begin = x;
				for (x++, y = 1; Photo[P].name[y] != 0; x++, y++)
				{
					ch1 = Description[x];
					if ((ch1 >= 'a') && (ch1 <= 'z'))
						ch1 &= 0xDF;
					ch2 = Photo[P].name[y];
					if ((ch2 >= 'a') && (ch2 <= 'z'))
						ch2 &= 0xDF;
					if (ch1 != ch2)
						break;
				}
				if (Photo[P].name[y] == 0)
				{
					Photo[P].end = y + Photo[P].begin;
					if (P < 100)
						P++;
					else
						MessageBox(hwnd, "Too many photos!", ERROR, MB_OK);
				}
			}
		}		
	}
}

int CALLBACK DescriptionProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
		if (Location[0] != 0)
			SetWindowText(hDlg, Location);
		else if (Ident[0] != 0)
			SetWindowText(hDlg, Ident);
		hwndDescEdit = GetDlgItem(hDlg, IDC_EDIT1);
		pDescEditProc = (WNDPROC)SetWindowLong(hwndDescEdit, GWL_WNDPROC, (LONG)DescEditProc);
		SetWindowText(hwndDescEdit, Description);
		hFont2 = CreateFontIndirect (&lf3);
		SelectObject (hdc, hFont2);
		SendMessage(hwndDescEdit, WM_SETFONT, (UINT)hFont2, TRUE);
		SetFocus(hwndDescEdit);
		hFindFile = FindFirstFile("Photos\\*.*", &fd);
		if (hFindFile != INVALID_HANDLE_VALUE)
		{
			P = 0;
			PhotoNames();
			while (FindNextFile(hFindFile, &fd))
			{
				if ((fd.cFileName[0] != '.') && (fd.cFileName[1] != '.'))
					PhotoNames();
			}
			FindClose(hFindFile);
//			for (x = 0; x < P; x++)//doesn't work - only selects the last one
//				SendMessage(hwndDescEdit, EM_SETSEL, (WPARAM)Photo[x].begin, (LPARAM)Photo[x].end);
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDCANCEL:
			EndDialog (hDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

//<wpt lat="33.893402" lon="-84.347084">
//<name>60</name>
//<cmt>18-JAN-02-18-56</cmt>
//</wpt>
BOOL CheckFormat(int y)
{
	int x, z;
	char wpt1[] = "<wpt lat=\"";
	char wpt2[] = "\" lon=\"";

	if ((tempWayArray[y+1] == 'w') && (tempWayArray[y+2] == 'p'))
	{
		if (gotway == TRUE)
		{
			for (x = 0; tempWayArray[y+x] != '\r'; x++)
				;
			tempWayArray[y+x] = 0;
			sprintf(Error, "%s\nin %s doesn't have a line with '</wpt>' preceding it.", &tempWayArray[y], NewLocations);
			return FALSE;
		}
		for (x = 0; x < 10; x++)
		{
			if (tempWayArray[y+x] != wpt1[x])
				break;
		}
		if (x != 10)
		{
			XMLError(y);
			return FALSE;
		}
		for ( ; tempWayArray[y+x] != '"'; x++)
			;
		for (z = 0; z < 7; x++, z++)
		{
			if (tempWayArray[y+x] != wpt2[z])
				break;
		}
		if (z != 7)
		{
			XMLError(y);
			return FALSE;
		}
		if (tempWayArray[y+x] != '-')
		{
			XMLError(y);
			return FALSE;
		}
		for ( ; tempWayArray[y+x] != '"'; x++)
			;
		if (tempWayArray[y+x+1] != '>')
		{
			XMLError(y);
			return FALSE;
		}
		gotway = TRUE;
	}
	else if (tempWayArray[y+1] == '/')
	{
		if ((tempWayArray[y+2] == 'w') && (tempWayArray[y+3] == 'p'))
		{
			if (gotway)
				gotway = FALSE;
			else
			{
				for (x = 0; tempWayArray[y+x] != '\r'; x++)
					;
				tempWayArray[y+x] = 0;
				sprintf(Error, "%s\nin %s doesn't have a line with '<wpt' preceding it,\nor that <wpt line was bad.", &tempWayArray[y], NewLocations);
				return FALSE;
			}
			if (gotcmt || gotname || gotdescr || gotelev)
			{
				for (x = 0; tempWayArray[y+x] != '\r'; x++)
					;
				tempWayArray[y+x] = 0;
				for (x = 0; (tempWayArray[y-x] != '<') || (tempWayArray[y-x+1] != 'w'); x++)
					;
				sprintf(Error, "%s\nin\n %s\n is wrong.", &tempWayArray[y-x], NewLocations);
				return FALSE;
			}
		}
		else if (tempWayArray[y+2] == 'n')
		{
			if (gotname == FALSE)
			{
				XMLError(y);
				return FALSE;
			}
			gotname = FALSE;
		}
		else if (tempWayArray[y+2] == 'c')
		{
			if (gotcmt == FALSE)
			{
				XMLError(y);
				return FALSE;
			}
			gotcmt = FALSE;
		}
		else if (tempWayArray[y+2] == 'd')
		{
			if (gotdescr == FALSE)
			{
				XMLError(y);
				return FALSE;
			}
			gotdescr = FALSE;
		}
		else if (tempWayArray[y+2] == 'e')
		{
			if (gotelev == FALSE)
			{
				XMLError(y);
				return FALSE;
			}
			gotelev = FALSE;
		}
	}
	else if (tempWayArray[y+1] == 'n')
	{
		gotname = TRUE;
	}
	else if (tempWayArray[y+1] == 'c')
	{
		gotcmt = TRUE;
	}
	else if (tempWayArray[y+1] == 'd')
	{
		gotdescr = TRUE;
	}
	else if (tempWayArray[y+1] == 'e')
	{
		gotelev = TRUE;
	}
	return TRUE;
}

void XMLError(int y)
{
	int x;

	for (x = 0; tempWayArray[y+x] != '\r'; x++)
		;
	tempWayArray[y+x] = 0;
	for (x = 0; tempWayArray[y-x] != '\n'; x++)
		;
	sprintf(Error, "'%s'\nin %s is wrong...", &tempWayArray[y-x+1], NewLocations);
}

void ShowTopo(void)
{
	int x;
	char ItsTopo[] = "Topo      ";

	if (MouseLoc == ITSUTM)
	{
		for (x = 0; x < 10; x++)
			UTM[x+107] = ItsTopo[x];
		SetWindowText(hwnd, UTM);
	}
	else if (MouseLoc == ITSUSNG)
	{
		for (x = 0; x < 10; x++)
			USNG[x+107] = ItsTopo[x];
		SetWindowText(hwnd, USNG);
	}
	else
	{
		for (x = 0; x < 10; x++)
			LatLon[x+107] = ItsTopo[x];
		SetWindowText(hwnd, LatLon);
	}
}

void ShowPhoto(void)
{
	int x;
	char ItsPhoto[] = "Photo     ";

	if (MouseLoc == ITSUTM)
	{
		for (x = 0; x < 10; x++)
			UTM[x+107] = ItsPhoto[x];
		SetWindowText(hwnd, UTM);
	}
	else if (MouseLoc == ITSUSNG)
	{
		for (x = 0; x < 10; x++)
			USNG[x+107] = ItsPhoto[x];
		SetWindowText(hwnd, USNG);
	}
	else
	{
		for (x = 0; x < 10; x++)
			LatLon[x+107] = ItsPhoto[x];
		SetWindowText(hwnd, LatLon);
	}
}

void ShowUrbanArea(void)
{
	int x;
	char ItsUrbanArea[] = "Urban Area";

	if (MouseLoc == ITSUTM)
	{
		for (x = 0; x < 10; x++)
			UTM[x+107] = ItsUrbanArea[x];
		SetWindowText(hwnd, UTM);
	}
	else if (MouseLoc == ITSUSNG)
	{
		for (x = 0; x < 10; x++)
			USNG[x+107] = ItsUrbanArea[x];
		SetWindowText(hwnd, USNG);
	}
	else
	{
		for (x = 0; x < 10; x++)
			LatLon[x+107] = ItsUrbanArea[x];
		SetWindowText(hwnd, LatLon);
	}
}

void GetRowName(int North, int West)
{
	int x;

	if (MapType == PHOTO)
		RowName[36] = 'z';
	else if (MapType == TOPO)
		RowName[36] = 'a';
	else//if (MapType == URBANAREA)
		RowName[36] = 'u';
	RowName[37] = Z[0];
	RowName[38] = Z[1];
	x = 40;
	_itoa(North, &RowName[x], 10);
	for ( ; RowName[x] != 0; x++)
		;
	RowName[x++] = ' ';
	RowName[x++] = 'x';
	_itoa(West, &RowName[x], 10);
	for ( ; RowName[x] != 0; x++)
		;
	RowName[x] = ' ';//for use in the X routine
}

void GetDotRadius(void)
{
	if (MapType != URBANAREA)
	{
		int mpp = MetersPerTile/PixelsPerTile;

		if (MapType == PHOTO)
		{
			switch (mpp)
			{
			case 1:
				DotRadius = PhotoDot1[0] - '0';
				break;
			case 2:
				DotRadius = PhotoDot2[0] - '0';
				break;
			case 4:
				DotRadius = PhotoDot4[0] - '0';
				break;
			case 8:
				DotRadius = PhotoDot8[0] - '0';
				break;
			case 16:
				DotRadius = PhotoDot16[0] - '0';
				break;
			case 32:
				DotRadius = PhotoDot32[0] - '0';
				break;
			case 64:
				DotRadius = PhotoDot64[0] - '0';
				break;
			}
		}
		else//if (MapType == TOPO)
		{
			switch (mpp)
			{
			case 4:
				DotRadius = TopoDot4[0] - '0';
				break;
			case 8:
				DotRadius = TopoDot8[0] - '0';
				break;
			case 16:
				DotRadius = TopoDot16[0] - '0';
				break;
			case 32:
				DotRadius = TopoDot32[0] - '0';
				break;
			case 64:
				DotRadius = TopoDot64[0] - '0';
				break;
			case 128:
				DotRadius = TopoDot128[0] - '0';
				break;
			case 256:
				DotRadius = TopoDot256[0] - '0';
				break;
			case 512:
				DotRadius = TopoDot512[0] - '0';
				break;
			}
		}
	}
	else//if (MapType == URBANAREA)
	{
		if (MetersPerTile == 50)
		{
			switch (PixelsPerTile)
			{
			case 200:
				DotRadius = UrbanDot14[0] - '0';
				break;
			case 100:
				DotRadius = UrbanDot12[0] - '0';
				break;
			case 50:
				DotRadius = PhotoDot1[0] - '0';
				break;
			case 25:
				DotRadius = PhotoDot2[0] - '0';
				break;
			}
		}
		else//if (MetersPerTile == 800)
		{
			switch (PixelsPerTile)
			{
			case 200:
				DotRadius = PhotoDot4[0] - '0';
				break;
			case 100:
				DotRadius = PhotoDot8[0] - '0';
				break;
			case 50:
				DotRadius = PhotoDot16[0] - '0';
				break;
			case 25:
				DotRadius = PhotoDot32[0] - '0';
				break;
			}
		}
	}
}

void ChangeAPRSBaud(int BaudUnits)
{
	int baudlen;
	char *pUSAPMbuf;
	char baud[7];
	
	_itoa(APRSBaud, baud, 10);
	baudlen = lstrlen(baud);

	CheckMenuItem(hMenu, ID_APRS_BAUD_4800, MF_UNCHECKED);
	CheckMenuItem(hMenu, ID_APRS_BAUD_9600, MF_UNCHECKED);
	CheckMenuItem(hMenu, ID_APRS_BAUD_19200, MF_UNCHECKED);
	CheckMenuItem(hMenu, ID_APRS_BAUD_38400, MF_UNCHECKED);
	CheckMenuItem(hMenu, ID_APRS_BAUD_57600, MF_UNCHECKED);
	CheckMenuItem(hMenu, ID_APRS_BAUD_115200, MF_UNCHECKED);
	CheckMenuItem(hMenu, BaudUnits, MF_CHECKED);

	hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		fileSize = GetFileSize(hFile, NULL);
		pUSAPMbuf = (char*)malloc(fileSize);
		ReadFile(hFile, pUSAPMbuf, fileSize, &dwBytesRead, NULL);
		for (x = 0; x < (int)fileSize; x++)
		{//APRSBaud=9600
			if (pUSAPMbuf[x] == '=')
			{
				if ((pUSAPMbuf[x-1] == 'd') && (pUSAPMbuf[x-8] == 'A') && (pUSAPMbuf[x-4] == 'B'))
				{//found "APRSBaud=4800\r\n'
					CloseHandle(hFile);
					hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
					WriteFile(hFile, pUSAPMbuf, x+1, &dwBytesWritten, NULL);
					WriteFile(hFile, baud, baudlen, &dwBytesWritten, NULL);
					for (y = x+1; (y < fileSize) && (pUSAPMbuf[y] != '\r'); y++)
						;
					WriteFile(hFile, &pUSAPMbuf[y], fileSize-y, &dwBytesWritten, NULL);
					CloseHandle(hFile);
					break;
				}
			}
		}
		if (x == fileSize)//not found
		{
			WriteFile(hFile, APRSBAUD, 9, &dwBytesWritten, NULL);
			WriteFile(hFile, baud, baudlen, &dwBytesWritten, NULL);
			WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);
			CloseHandle(hFile);
		}
		free(pUSAPMbuf);
	}
}

//4800 9600 19200 57600 115200
void ChangeBaud(void)
{
	char FortyEight[] = "4800";
	char NintySix[] = "9600";
	char NinteenTwo[] = "19200";
	char ThirtyEight[] = "38400";
	char FiftySeven[] = "57600";
	char OneFifteen[] = "115200";

	CheckMenuItem (hMenu, ID_GPS_BAUD_4800, MF_UNCHECKED);
	CheckMenuItem (hMenu, ID_GPS_BAUD_9600, MF_UNCHECKED);
	CheckMenuItem (hMenu, ID_GPS_BAUD_19200, MF_UNCHECKED);
	CheckMenuItem (hMenu, ID_GPS_BAUD_38400, MF_UNCHECKED);
	CheckMenuItem (hMenu, ID_GPS_BAUD_57600, MF_UNCHECKED);
	CheckMenuItem (hMenu, ID_GPS_BAUD_115200, MF_UNCHECKED);

	CheckMenuItem (hMenu, BaudUnits, MF_CHECKED);

	if (RegValue[3] == '0')
	{
		MessageBox(hwnd, SelectCommPort, NULL, MB_OK);
		return;
	}
	GetCommHandle();
	GetCommState(hComm, &dcb);
	dcb.BaudRate = Baud;
	SetCommState(hComm, &dcb);
//	SetEvent(hEventExit);
	switch (Baud)
	{
	case 4800:
		strcpy((char*)&RegValue[13], FortyEight);
		RegValue[17] = ' ';
		RegValue[18] = ' ';
		RegValue[19] = ' ';
		break;
	case 9600:
		strcpy((char*)&RegValue[13], NintySix);
		RegValue[17] = ' ';
		RegValue[18] = ' ';
		RegValue[19] = ' ';
		break;
	case 19200:
		strcpy((char*)&RegValue[13], NinteenTwo);
		RegValue[18] = ' ';
		RegValue[19] = ' ';
		break;
	case 38400:
		strcpy((char*)&RegValue[13], ThirtyEight);
		RegValue[18] = ' ';
		RegValue[19] = ' ';
		break;
	case 57600:
		strcpy((char*)&RegValue[13], FiftySeven);
		RegValue[18] = ' ';
		RegValue[19] = ' ';
		break;
	case 115200:
		strcpy((char*)&RegValue[13], OneFifteen);
		RegValue[19] = ' ';
		break;
	}
	if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, SubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRegKey, &RegKeyResult))
	{
		RegSetValueEx(hRegKey, NULL, 0, REG_SZ, RegValue, RegValueSize);
		RegFlushKey(hRegKey);
		RegCloseKey(hRegKey);
	}
	else
		MessageBox(hwnd, Registry, ERROR, MB_OK);
}

void ConvertoMeridian(DWORD fileSize)
{//GPSBud's format: 35.1874666,-106.4902700,
//	int g;
	int x, y, z, n, tempZone, tempNorthing, tempEasting, lat, lon, el;
	double tempLat, tempLon, min, elev;
	char Pmgntrk[] = "$PMGNTRK,";
	char MeridianLine[83];
	char H[2], M[2], S[2], Mo[2], Da[2], Yr[2], El[5];
	DWORD dwBytesWritten;
	HANDLE hFile;

	tempLat = Lat;
	tempLon = Lon;
	tempZone = UTMZone;
	tempNorthing = UTMNorthing;
	tempEasting = UTMEasting;

	hFile = CreateFile(MeridianFullName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	x = firsttrack;
	while (x < (int)fileSize)
	{//New,19,1991352,752355,19,6,45,12,26,2002,4 0x0D 0x0A
		if (pTrackBuf[x] != ',')
			for ( ; (pTrackBuf[x] != ',') && (x < (int)fileSize); x++)
				;
		x++;
		UTMZone = ((pTrackBuf[x] - '0') * 10) + (pTrackBuf[x+1] - '0');
		x += 3;// to northing
		UTMNorthing = atoi((char*)&pTrackBuf[x]);
		x += 8;//to easting
		UTMEasting = atoi((char*)&pTrackBuf[x]);
		x += 7;//to hour
		UTMtoLatLon();
		Lon = -Lon;
		lat = (int)Lat;
		if (pTrackBuf[x] == ',')
		{
			H[0] = '0';
			H[1] = '0';
		}
		else
		{
			if (pTrackBuf[x+1] == ',')
				H[0] = '0';
			else
				H[0] = pTrackBuf[x++];
			H[1] = pTrackBuf[x++];
		}
		x++;//past comma
		if (pTrackBuf[x] == ',')
		{
			M[0] = '0';
			M[1] = '0';
		}
		else
		{
			if (pTrackBuf[x+1] == ',')
				M[0] = '0';
			else
				M[0] = pTrackBuf[x++];
			M[1] = pTrackBuf[x++];
		}
		x++;//past comma
		if (pTrackBuf[x] == ',')
		{
			S[0] = '0';
			S[1] = '0';
		}
		else
		{
			if (pTrackBuf[x+1] == ',')
				S[0] = '0';
			else
				S[0] = pTrackBuf[x++];
			S[1] = pTrackBuf[x++];
		}
		x++;//past comma
		if (pTrackBuf[x] == ',')
		{
			Mo[0] = '0';
			Mo[1] = '0';
		}
		else
		{
			if (pTrackBuf[x+1] == ',')
				Mo[0] = '0';
			else
				Mo[0] = pTrackBuf[x++];
			Mo[1] = pTrackBuf[x++];
		}
		x++;
		if (pTrackBuf[x] == ',')
		{
			Da[0] = '0';
			Da[1] = '0';
		}
		else
		{
			if (pTrackBuf[x+1] == ',')
				Da[0] = '0';
			else
				Da[0] = pTrackBuf[x++];
			Da[1] = pTrackBuf[x++];
		}
//		x += 3;//to last 2 digits of year
		x++;
		if (pTrackBuf[x] == ',')
		{
			Yr[0] = '0';
			Yr[1] = '0';
		}
		else
		{
			if (pTrackBuf[x+1] == ',')
				Yr[0] = '0';
			else
				Yr[0] = pTrackBuf[x++];
			Yr[1] = pTrackBuf[x++];
		}
		x++;//past comma
		
		elev = atof((char*)&pTrackBuf[x]);
		el = (int)elev;
		for (z = 0, n = 10000; z < 5; z++, n /= 10)
		{
			if (el < n)
				El[z] = '0';
			else
				El[z] = (el / n) + '0';
			el %= n;
		}
		while ((pTrackBuf[x] != '\n') && (x < (int)fileSize))
			x++;
		x++;//to beginning of line
//to $PMGNTRK,1759.753,N,06637.009,W,00004,M,190645.34,A,,261202*6D
		for (y = 0; y < 9; y++)
			MeridianLine[y] = Pmgntrk[y];
		MeridianLine[y++] = (lat / 10) + '0';
		MeridianLine[y++] = (lat % 10) + '0';
		min = (modf(Lat, &Lat)) * 60.0;
		if (min < 10.0)
			MeridianLine[y++] = '0';
		if (min < 1.0)
			MeridianLine[y++] = '0';
		y += sprintf(&MeridianLine[y],  "%.3f", min);
		MeridianLine[y++] = ',';
		MeridianLine[y++] = 'N';
		MeridianLine[y++] = ',';
		lon = (int)Lon;
		MeridianLine[y++] = (lon / 100) + '0';
		MeridianLine[y++] = ((lon % 100) / 10) + '0';
		MeridianLine[y++] = (lon % 10) + '0';
		min = (modf(Lon, &Lon)) * 60.0;
		if (min < 10.0)
			MeridianLine[y++] = '0';
		if (min < 1.0)
			MeridianLine[y++] = '0';
		y += sprintf(&MeridianLine[y],  "%.3f", min);
		MeridianLine[y++] = ',';
		MeridianLine[y++] = 'W';
		MeridianLine[y++] = ',';
		for (z = 0; z < 5; z++)
			MeridianLine[y++] = El[z];
		MeridianLine[y++] = ',';
		MeridianLine[y++] = 'M';
		MeridianLine[y++] = ',';
		MeridianLine[y++] = H[0];
		MeridianLine[y++] = H[1];
		MeridianLine[y++] = M[0];
		MeridianLine[y++] = M[1];
		MeridianLine[y++] = S[0];
		MeridianLine[y++] = S[1];
		MeridianLine[y++] = '.';
		MeridianLine[y++] = '0';
		MeridianLine[y++] = '0';
		MeridianLine[y++] = ',';
		MeridianLine[y++] = 'A';
		MeridianLine[y++] = ',';
		MeridianLine[y++] = ',';
		MeridianLine[y++] = Da[0];
		MeridianLine[y++] = Da[1];
		MeridianLine[y++] = Mo[0];
		MeridianLine[y++] = Mo[1];
		MeridianLine[y++] = Yr[0];
		MeridianLine[y++] = Yr[1];
		MeridianLine[y++] = '*';
		for (checksum = 0, z = 1; MeridianLine[z] != '*'; z++)
			checksum ^= MeridianLine[z];
		z = checksum >> 4;
		MeridianLine[y++] = (char)(z > 9) ? z + 0x37 : z + 0x30;
		z = checksum & 0x0F;
		MeridianLine[y++] = (char)(z > 9) ? z + 0x37 : z + 0x30;
		MeridianLine[y++] = '\r';
		MeridianLine[y++] = '\n';
		WriteFile(hFile, MeridianLine, y, &dwBytesWritten, NULL);
	}
	WriteFile(hFile, &SendEnd, 17, &dwBytesWritten, NULL);
	CloseHandle(hFile);
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempZone;
	UTMNorthing = tempNorthing;
	UTMEasting = tempEasting;
}

void GetMagSym(int x)
{//tempLatLon[x] == ','
	x++;
	if (itsmeridian)
	{
		if (tempLatLon[x+1] == '*')
		{
			switch (tempLatLon[x])
			{
//			case 'a': strcpy(Sym, Ma); break;//default
			case 'b': strcpy(Sym, Mb); break;
			case 'c': strcpy(Sym, Mc); break;
			case 'd': strcpy(Sym, Md); break;
			case 'e': strcpy(Sym, Me); break;
			case 'f': strcpy(Sym, Mf); break;
			case 'g': strcpy(Sym, Mg); break;
			case 'h': strcpy(Sym, Mh); break;
			case 'i': strcpy(Sym, Mi); break;
			case 'j': strcpy(Sym, Mj); break;
			case 'k': strcpy(Sym, Mk); break;
			case 'l': strcpy(Sym, Ml); break;
			case 'm': strcpy(Sym, Mm); break;
			case 'n': strcpy(Sym, Mn); break;
			case 'o': strcpy(Sym, Mo); break;
			case 'p': strcpy(Sym, Mp); break;
			case 'q': strcpy(Sym, Mq); break;
			case 'r': strcpy(Sym, Mr); break;
			case 's': strcpy(Sym, Ms); break;
			case 't': strcpy(Sym, Mt); break;
			case 'u': strcpy(Sym, Mu); break;
			case 'v': strcpy(Sym, Mv); break;
			case 'w': strcpy(Sym, Mw); break;
			case 'x': strcpy(Sym, Mx); break;
			case 'y': strcpy(Sym, My); break;
			case 'z': strcpy(Sym, Mz); break;
			}
		}
		else if (tempLatLon[x] == 'a')
		{
			switch(tempLatLon[x+1])
			{
			case 'a':
				strcpy(Sym, aa);
				break;
			case 'b':
				strcpy(Sym, ab);
				break;
			case 'c':
				strcpy(Sym, ac);
				break;
			case 'd':
				strcpy(Sym, ad);
				break;
			case 'e':
				strcpy(Sym, ae);
				break;
			case 'f':
				strcpy(Sym, af);
				break;
			case 'g':
				strcpy(Sym, ag);
				break;
			case 'h':
				strcpy(Sym, ah);
				break;
			case 'i':
				strcpy(Sym, ai);
				break;
			case 'j':
				strcpy(Sym, aj);
				break;
			case 'k':
				strcpy(Sym, ak);
				break;
			case 'l':
				strcpy(Sym, al);
				break;
			case 'm':
				strcpy(Sym, am);
				break;
			case 'n':
				strcpy(Sym, an);
				break;
			case 'o':
				strcpy(Sym, ao);
				break;
			case 'p':
				strcpy(Sym, ap);
				break;
			}
		}
	}
	else
	{
		switch(tempLatLon[x])
		{
		case 'a':
			strcpy(Sym, Xa);
			break;
		case 'b':
			strcpy(Sym, Xb);
			break;
		case 'c':
			strcpy(Sym, Xc);
			break;
		case 'd':
			strcpy(Sym, Xd);
			break;
		case 'e':
			strcpy(Sym, Xe);
			break;
		case 'f':
			strcpy(Sym, Xf);
			break;
		case 'g':
			strcpy(Sym, Xg);
			break;
		case 'h':
			strcpy(Sym, Xh);
			break;
		case 'i':
			strcpy(Sym, Xi);
			break;
		case 'j':
			strcpy(Sym, Xj);
			break;
		case 'k':
			strcpy(Sym, Xk);
			break;
		case 'l':
			strcpy(Sym, Xl);
			break;
		case 'm':
			strcpy(Sym, Xm);
			break;
		case 'n':
			strcpy(Sym, Xn);
			break;
		case 'o':
			strcpy(Sym, Xo);
			break;
		case 'p':
			strcpy(Sym, Xp);
			break;
		case 'q':
			strcpy(Sym, Xq);
			break;
		case 'r':
			strcpy(Sym, Xr);
			break;
		case 's':
			strcpy(Sym, Xs);
			break;
		case 't':
			strcpy(Sym, Xt);
			break;
		}
	}
}

void GetSym(int x)
{
	switch (x)
	{
	case 0:
		strcpy(Sym, G0);
		break;
	case 1:
		strcpy(Sym, G1);
		break;
	case 2:
		strcpy(Sym, G2);
		break;
	case 3:
		strcpy(Sym, G3);
		break;
	case 4:
		strcpy(Sym, G4);
		break;
	case 5:
		strcpy(Sym, G5);
		break;
	case 6:
		strcpy(Sym, G6);
		break;
	case 7:
		strcpy(Sym, G7);
		break;
	case 8:
		strcpy(Sym, G8);
		break;
	case 9:
		strcpy(Sym, G9);
		break;
	case 10:
		strcpy(Sym, G10);
		break;
	case 11:
		strcpy(Sym, G11);
		break;
	case 12:
		strcpy(Sym, G12);
		break;
	case 13:
		strcpy(Sym, G13);
		break;
	case 14:
		strcpy(Sym, G14);
		break;
	case 15:
		strcpy(Sym, G15);
		break;
	case 16:
		strcpy(Sym, G16);
		break;
	case 17:
		strcpy(Sym, G17);
		break;
	case 18:
		strcpy(Sym, G18);
		break;
	case 19:
		strcpy(Sym, G19);
		break;
	case 20:
		strcpy(Sym, G20);
		break;
	case 21:
		strcpy(Sym, G21);
		break;
	case 22:
		strcpy(Sym, G22);
		break;
	case 23:
		strcpy(Sym, G23);
		break;
	case 24:
		strcpy(Sym, G24);
		break;
	case 25:
		strcpy(Sym, G25);
		break;
	case 26:
		strcpy(Sym, G26);
		break;
	case 27:
		strcpy(Sym, G27);
		break;
	case 28:
		strcpy(Sym, G28);
		break;
	case 29:
		strcpy(Sym, G29);
		break;
	case 30:
		strcpy(Sym, G30);
		break;
	case 31:
		strcpy(Sym, G31);
		break;
	case 32:
		strcpy(Sym, G32);
		break;
	case 33:
		strcpy(Sym, G33);
		break;
	case 34:
		strcpy(Sym, G34);
		break;
	case 35:
		strcpy(Sym, G35);
		break;
	case 36:
		strcpy(Sym, G36);
		break;
	case 37:
		strcpy(Sym, G37);
		break;
	case 150:
		strcpy(Sym, G150);
		break;
	case 151:
		strcpy(Sym, G151);
		break;
	case 152:
		strcpy(Sym, G152);
		break;
	case 153:
		strcpy(Sym, G153);
		break;
	case 154:
		strcpy(Sym, G154);
		break;
	case 155:
		strcpy(Sym, G155);
		break;
	case 156:
		strcpy(Sym, G156);
		break;
	case 157:
		strcpy(Sym, G157);
		break;
	case 158:
		strcpy(Sym, G158);
		break;
	case 159:
		strcpy(Sym, G159);
		break;
	case 160:
		strcpy(Sym, G160);
		break;
	case 161:
		strcpy(Sym, G161);
		break;
	case 162:
		strcpy(Sym, G162);
		break;
	case 163:
		strcpy(Sym, G163);
		break;
	case 164:
		strcpy(Sym, G164);
		break;
	case 165:
		strcpy(Sym, G165);
		break;
	case 166:
		strcpy(Sym, G166);
		break;
	case 167:
		strcpy(Sym, G167);
		break;
	case 168:
		strcpy(Sym, G168);
		break;
	case 169:
		strcpy(Sym, G169);
		break;
	case 170:
		strcpy(Sym, G170);
		break;
	case 171:
		strcpy(Sym, G171);
		break;
	case 172:
		strcpy(Sym, G172);
		break;
	case 173:
		strcpy(Sym, G173);
		break;
	case 174:
		strcpy(Sym, G174);
		break;
	case 175:
		strcpy(Sym, G175);
		break;
	case 176:
		strcpy(Sym, G176);
		break;
	case 177:
		strcpy(Sym, G177);
		break;
	case 178:
		strcpy(Sym, G178);
		break;
	case 179:
		strcpy(Sym, G179);
		break;
	case 8192:
		strcpy(Sym, G8192);
		break;
	case 8193:
		strcpy(Sym, G8193);
		break;
	case 8194:
		strcpy(Sym, G8194);
		break;
	case 8195:
		strcpy(Sym, G8195);
		break;
	case 8196:
		strcpy(Sym, G8196);
		break;
	case 8197:
		strcpy(Sym, G8197);
		break;
	case 8198:
		strcpy(Sym, G8198);
		break;
	case 8199:
		strcpy(Sym, G8199);
		break;
	case 8200:
		strcpy(Sym, G8200);
		break;
	case 8201:
		strcpy(Sym, G8201);
		break;
	case 8202:
		strcpy(Sym, G8202);
		break;
	case 8203:
		strcpy(Sym, G8203);
		break;
	case 8204:
		strcpy(Sym, G8204);
		break;
	case 8205:
		strcpy(Sym, G8205);
		break;
	case 8206:
		strcpy(Sym, G8206);
		break;
	case 8207:
		strcpy(Sym, G8207);
		break;
	case 8208:
		strcpy(Sym, G8208);
		break;
	case 8209:
		strcpy(Sym, G8209);
		break;
	case 8210:
		strcpy(Sym, G8210);
		break;
	case 8211:
		strcpy(Sym, G8211);
		break;
	case 8212:
		strcpy(Sym, G8212);
		break;
	case 8213:
		strcpy(Sym, G8213);
		break;
	case 8214:
		strcpy(Sym, G8214);
		break;
	case 8215:
		strcpy(Sym, G8215);
		break;
	case 8216:
		strcpy(Sym, G8216);
		break;
	case 8217:
		strcpy(Sym, G8217);
		break;
	case 8218:
		strcpy(Sym, G8218);
		break;
	case 8219:
		strcpy(Sym, G8219);
		break;
	case 8220:
		strcpy(Sym, G8220);
		break;
	case 8221:
		strcpy(Sym, G8221);
		break;
	case 8222:
		strcpy(Sym, G8222);
		break;
	case 8223:
		strcpy(Sym, G8223);
		break;
	case 8224:
		strcpy(Sym, G8224);
		break;
	case 8225:
		strcpy(Sym, G8225);
		break;
	case 8226:
		strcpy(Sym, G8226);
		break;
	case 8227:
		strcpy(Sym, G8227);
		break;
	case 8228:
		strcpy(Sym, G8228);
		break;
	case 8229:
		strcpy(Sym, G8229);
		break;
	case 8230:
		strcpy(Sym, G8230);
		break;
	case 8231:
		strcpy(Sym, G8231);
		break;
	case 8232:
		strcpy(Sym, G8232);
		break;
	case 8233:
		strcpy(Sym, G8233);
		break;
	case 8234:
		strcpy(Sym, G8234);
		break;
	case 8235:
		strcpy(Sym, G8235);
		break;
	case 8236:
		strcpy(Sym, G8236);
		break;
	case 8237:
		strcpy(Sym, G8237);
		break;
	case 8238:
		strcpy(Sym, G8238);
		break;
	case 8239:
		strcpy(Sym, G8239);
		break;
	case 8240:
		strcpy(Sym, G8240);
		break;
	case 8241:
		strcpy(Sym, G8241);
		break;
	case 8242:
		strcpy(Sym, G8242);
		break;
	case 8243:
		strcpy(Sym, G8243);
		break;
	case 8244:
		strcpy(Sym, G8244);
		break;
	case 8245:
		strcpy(Sym, G8245);
		break;
	case 8246:
		strcpy(Sym, G8246);
		break;
	case 8247:
		strcpy(Sym, G8247);
		break;
	case 8248:
		strcpy(Sym, G8248);
		break;
	case 8249:
		strcpy(Sym, G8249);
		break;
	case 8250:
		strcpy(Sym, G8250);
		break;
	case 8251:
		strcpy(Sym, G8251);
		break;
	case 8252:
		strcpy(Sym, G8252);
		break;
	case 8253:
		strcpy(Sym, G8253);
		break;
	case 8254:
		strcpy(Sym, G8254);
		break;
	case 16384:
		strcpy(Sym, G16384);
		break;
	case 16385:
		strcpy(Sym, G16385);
		break;
	case 16386:
		strcpy(Sym, G16386);
		break;
	case 16387:
		strcpy(Sym, G16387);
		break;
	case 16388:
		strcpy(Sym, G16388);
		break;
	case 16389:
		strcpy(Sym, G16389);
		break;
	case 16390:
		strcpy(Sym, G16390);
		break;
	case 16391:
		strcpy(Sym, G16391);
		break;
	case 16392:
		strcpy(Sym, G16392);
		break;
	case 16393:
		strcpy(Sym, G16393);
		break;
	case 16394:
		strcpy(Sym, G16394);
		break;
	case 16395:
		strcpy(Sym, G16395);
		break;
	case 16396:
		strcpy(Sym, G16396);
		break;
	case 16397:
		strcpy(Sym, G16397);
		break;
	case 16398:
		strcpy(Sym, G16398);
		break;
	case 16399:
		strcpy(Sym, G16399);
		break;
	case 16400:
		strcpy(Sym, G16400);
		break;
	case 16401:
		strcpy(Sym, G16401);
		break;
	case 16402:
		strcpy(Sym, G16402);
		break;
	default:
		strcpy(Sym, G18);
	}
}

int GarminSym(void)
{
	int x, y;
	char *ptr1[] = {G0, G1, G2, G3, G4, G5, G6, G7, G8, G9, G10, G11, G12, G13, G14, G15, G16, G17, G18, G19, G20, G21, G22, G23, G24, G25, G26, G27, G28, G29, G30, G31, G32, G33, G34, G35, G36, G37};
	char *ptr2[] = {G150, G151, G152, G153, G154, G155, G156, G157, G158, G159, G160, G161, G162, G163, G164, G165, G166, G167, G168, G169, G170, G171, G172, G173, G174, G175, G176, G177, G178, G179};
	char *ptr3[] = {G8192, G8193, G8194, G8195, G8196, G8197, G8198, G8199, G8200, G8201, G8202, G8203, G8204, G8205, G8206, G8207, G8208, G8209, G8210, G8211, G8212, G8213, G8214, G8215, G8216, G8217, G8218, G8219, G8220, G8221, G8222, G8223, G8224, G8225, G8226, G8227, G8228, G8229, G8230, G8231, G8232, G8233, G8234, G8235, G8236, G8237, G8238, G8239, G8240, G8241, G8242, G8243, G8244, G8245, G8246, G8247, G8248, G8249, G8250, G8251, G8252, G8253, G8254};
	char *ptr4[] = {G16384, G16385, G16386, G16387, G16388, G16389, G16390, G16391, G16392, G16393, G16394, G16395, G16396, G16397, G16398, G16399, G16400, G16401, G16402};

	y = sizeof(ptr1) / sizeof(*ptr1);
	for (x = 0; x < y; x++)
	{
		if (0 == strcmp(Sym, ptr1[x]))
			return x;
	}
	y = sizeof(ptr2) / sizeof(*ptr2);
	for (x = 0; x < y; x++)//150
	{
		if (0 == strcmp(Sym, ptr2[x]))
			return x+150;
	}
	y = sizeof(ptr3) / sizeof(*ptr3);
	for (x = 0; x < y; x++)//8192
	{
		if (0 == strcmp(Sym, ptr3[x]))
			return x+8192;
	}
	y = sizeof(ptr4) / sizeof(*ptr4);
	for (x = 0; x < y; x++)//16384
	{
		if (0 == strcmp(Sym, ptr4[x]))
			return x+16384;
	}
	return 18;
}

void ChangeUSAPhotoMapsIni(void)
{
	int x;
	unsigned char *pIniPrefBuf;
	DWORD fileSize, dwBytesRead, dwBytesWritten;
	HANDLE hFile;

	prefOutMouseLoc = MouseLoc;
	prefOutZoom = Zoom;

	if ((Lat == 0.0) && (Lon == 0.0))
		return;//mouse never was over map
	if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
	{
		sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
		MessageBox(hwnd, Error, "Error 9", MB_OK);
		return;
	}
	hFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			pIniPrefBuf = (unsigned char*) malloc(fileSize+2);
			ReadFile(hFile, pIniPrefBuf, fileSize, &dwBytesRead, NULL);
			for (x = 0; (pIniPrefBuf[x] != '*') && (x < (int)fileSize); x++)
				;
			if (x < (int)fileSize)
			{//*Ithaca&X=1880&Y=23516&Z=18
			 //       098765432109876543210
				for ( ; (pIniPrefBuf[x] != '=') && x < (int)fileSize; x++)
					;
				if ((x < (int)fileSize) && (pIniPrefBuf[x-1] == 'X') && (pIniPrefBuf[x-2] == '&'))
				{
					x++;
					BeginY = ((rowOffset + (TilesDown/2)) * MetersPerTile) / 200;
					BeginX = ((colOffset + ((TilesAcross-1)/2)) * MetersPerTile) / 200;
					pIniPrefBuf[x++] = (BeginX / 1000) + '0';
					pIniPrefBuf[x++] = ((BeginX % 1000) / 100) + '0';
					pIniPrefBuf[x++] = ((BeginX % 100) / 10) + '0';
					pIniPrefBuf[x++] = (BeginX % 10) + '0';
					pIniPrefBuf[x++] = '&';
					pIniPrefBuf[x++] = 'Y';
					pIniPrefBuf[x++] = '=';
					pIniPrefBuf[x++] = (BeginY / 10000) + '0';
					pIniPrefBuf[x++] = ((BeginY % 10000) / 1000) + '0';
					pIniPrefBuf[x++] = ((BeginY % 1000) / 100) + '0';
					pIniPrefBuf[x++] = ((BeginY % 100) / 10) + '0';
					pIniPrefBuf[x++] = (BeginY % 10) + '0';
					pIniPrefBuf[x++] = '&';
					pIniPrefBuf[x++] = 'Z';
					pIniPrefBuf[x++] = '=';
					pIniPrefBuf[x++] = (UTMZone / 10) + '0';
					pIniPrefBuf[x++] = (UTMZone % 10) + '0';
					if (pIniPrefBuf[x] == '\r')
					{
						x = CheckIniProc(pIniPrefBuf, fileSize, 6);
						if (x == (int)fileSize)
						{
							SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
							WriteFile(hFile, pIniPrefBuf, fileSize, &dwBytesWritten, NULL);
						}
						else
							MessageBox(hwnd, Buf2, ERROR, MB_OK);
					}
				}
			}		
			free(pIniPrefBuf);
		}
		CloseHandle(hFile);
	}
}

void ChangeUSAPMIni(void)
{
	int x, y, GotData;
	DWORD fileSize;
	char *pUSAPMbuf;

	hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		if (prefOutMouseLoc == DEG)
			strcpy(USAPMbufOut, Deg);
		else if (prefOutMouseLoc == DEGMIN)
			strcpy(USAPMbufOut, Min);
		else if (prefOutMouseLoc == DEGMINSEC)
			strcpy(USAPMbufOut, Sec);
		else if (prefOutMouseLoc == ITSUTM)
			strcpy(USAPMbufOut, Utm);
		else if (prefOutMouseLoc == ITSUSNG)
			strcpy(USAPMbufOut, Usng);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//LatLonUTM=MIN

		if (prefOutZoom == 1)
			strcpy(USAPMbufOut, Zoom1);
		else if (prefOutZoom == 2)
			strcpy(USAPMbufOut, Zoom2);
		else if (prefOutZoom == 3)
			strcpy(USAPMbufOut, Zoom3);
		else if (prefOutZoom == 4)
			strcpy(USAPMbufOut, Zoom4);
		else if (prefOutZoom == 5)
			strcpy(USAPMbufOut, Zoom5);
		else if (prefOutZoom == 6)
			strcpy(USAPMbufOut, Zoom6);
		else if (prefOutZoom == 7)
			strcpy(USAPMbufOut, Zoom7);
		else if (prefOutZoom == 8)
			strcpy(USAPMbufOut, Zoom8);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//ZoomLevel=1

		if (prefOutLatlon == TRUE)
			strcpy(USAPMbufOut, DoShowNearest);
		else
			strcpy(USAPMbufOut, DontShowNearest);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//ShowLatlon=NO

		if (prefOutName == TRUE)
			strcpy(USAPMbufOut, DoShowName);
		else
			strcpy(USAPMbufOut, DontShowName);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//ShowName=NO

		if (sortbyname == TRUE)
			strcpy(USAPMbufOut, DoSortbyName);
		else
			strcpy(USAPMbufOut, DontSortbyName);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//SortbyName=NO

		if (zoom1to8 == TRUE)
			strcpy(USAPMbufOut, ZoomTo8Meters);
		else
			strcpy(USAPMbufOut, DontZoomTo8Meters);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//ZoomTo8Meters=YES

		if (MapType == TOPO)
			strcpy(USAPMbufOut, Topo);
		else if (MapType == PHOTO)
			strcpy(USAPMbufOut, NotTopo);
		else//if (MapType == URBANAREA)
			strcpy(USAPMbufOut, UrbanColor);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//Topo=NO

		if (openatclosing)
			strcpy(USAPMbufOut, OpenAtClosing);
		else
			strcpy(USAPMbufOut, DontOpenAtClosing);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//OpenAtClosing=

		if (showtext)
			strcpy(USAPMbufOut, ShowText);
		else
			strcpy(USAPMbufOut, DontShowText);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//ShowText=
			
		FadeIncr[14] = (FadeIncrement / 10)  + '0';
		FadeIncr[15] = (FadeIncrement % 10)  + '0';
		strcpy(USAPMbufOut, FadeIncr);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//FadeIncrement=

		Spaces2[12] = Spaces2Move + '0';
		strcpy(USAPMbufOut, Spaces2);
		WriteFile(hFile, USAPMbufOut, strlen(USAPMbufOut), &dwBytesWritten, NULL);//Spaces2Move=
	}
	else // if USAPM.ini exists
	{
		BOOL gotspaces2move = FALSE, gotshowtext = FALSE;

		fileSize = GetFileSize(hFile, NULL);
		pUSAPMbuf = (char*)malloc(fileSize+50);//leave space to add a line
		ReadFile(hFile, pUSAPMbuf, fileSize, &dwBytesRead, NULL);
		GotData = 0;
		for (x = 0; x < (int)fileSize; x++)
		{
			if (pUSAPMbuf[x] == '=')
			{
				if ((pUSAPMbuf[x-3] == 'U') && (pUSAPMbuf[x-2] == 'T'))//LatLonUTM=
				{
					GotData++;
					if (prefOutMouseLoc == DEG)
					{
						pUSAPMbuf[x+1] = 'D';
						pUSAPMbuf[x+2] = 'E';
						pUSAPMbuf[x+3] = 'G';
					}
					else if (prefOutMouseLoc == DEGMIN)
					{
						pUSAPMbuf[x+1] = 'M';
						pUSAPMbuf[x+2] = 'I';
						pUSAPMbuf[x+3] = 'N';
					}
					else if (prefOutMouseLoc == DEGMINSEC)
					{
						pUSAPMbuf[x+1] = 'S';
						pUSAPMbuf[x+2] = 'E';
						pUSAPMbuf[x+3] = 'C';
					}
					else if (prefOutMouseLoc == ITSUTM)
					{
						pUSAPMbuf[x+1] = 'U';
						pUSAPMbuf[x+2] = 'T';
						pUSAPMbuf[x+3] = 'M';
					}
					else if (prefOutMouseLoc == ITSUSNG)
					{
						pUSAPMbuf[x+1] = 'U';
						pUSAPMbuf[x+2] = 'S';
						pUSAPMbuf[x+3] = 'G';
					}
				}
				else if (pUSAPMbuf[x-5] == 'L')//ZoomLevel=
				{
					GotData++;
					if (prefOutZoom == 1)
						pUSAPMbuf[x+1] = '1';
					else if (prefOutZoom == 2)
						pUSAPMbuf[x+1] = '2';
					else if (prefOutZoom == 3)
						pUSAPMbuf[x+1] = '3';
					else if (prefOutZoom == 4)
						pUSAPMbuf[x+1] = '4';
					else if (prefOutZoom == 5)
						pUSAPMbuf[x+1] = '5';
					else if (prefOutZoom == 6)
						pUSAPMbuf[x+1] = '6';
					else if (prefOutZoom == 7)
						pUSAPMbuf[x+1] = '7';
					else if (prefOutZoom == 8)
						pUSAPMbuf[x+1] = '8';
				}
				else if ((pUSAPMbuf[x-6] == 'L') && (pUSAPMbuf[x-10] == 'S'))//ShowLatlon=
				{
					GotData++;
					if (prefOutLatlon == TRUE)
					{
						pUSAPMbuf[x+1] = 'Y';
						pUSAPMbuf[x+2] = 'E';
						if (pUSAPMbuf[x+3] == ' ')
							pUSAPMbuf[x+3] = 'S';
					}
					else
					{
						pUSAPMbuf[x+1] = 'N';
						pUSAPMbuf[x+2] = 'O';
						if (pUSAPMbuf[x+3] == 'S')
							pUSAPMbuf[x+3] = ' ';
					}
				}
				else if ((pUSAPMbuf[x-4] == 'N') && (pUSAPMbuf[x-5] == 'w'))//ShowName=
				{
					GotData++;
					if (prefOutName == TRUE)
					{
						pUSAPMbuf[x+1] = 'Y';
						pUSAPMbuf[x+2] = 'E';
						if (pUSAPMbuf[x+3] == ' ')
							pUSAPMbuf[x+3] = 'S';
					}
					else
					{
						pUSAPMbuf[x+1] = 'N';
						pUSAPMbuf[x+2] = 'O';
						if (pUSAPMbuf[x+3] == 'S')
							pUSAPMbuf[x+3] = ' ';
					}
				}
				else if ((pUSAPMbuf[x-5] == 'y') && (pUSAPMbuf[x-4] == 'N'))//SortbyName=
				{
					GotData++;
					if (sortbyname == TRUE)
					{
						pUSAPMbuf[x+1] = 'Y';
						pUSAPMbuf[x+2] = 'E';
						if (pUSAPMbuf[x+3] == ' ')
							pUSAPMbuf[x+3] = 'S';
					}
					else
					{
						pUSAPMbuf[x+1] = 'N';
						pUSAPMbuf[x+2] = 'O';
						if (pUSAPMbuf[x+3] == 'S')
							pUSAPMbuf[x+3] = ' ';
					}
				}
				else if (pUSAPMbuf[x-7] == '8')//ZoomTo8Meters=
				{
					GotData++;
					if (zoom1to8 == TRUE)
					{
						pUSAPMbuf[x+1] = 'Y';
						pUSAPMbuf[x+2] = 'E';
						if (pUSAPMbuf[x+3] == ' ')
							pUSAPMbuf[x+3] = 'S';
					}
					else
					{
						pUSAPMbuf[x+1] = 'N';
						pUSAPMbuf[x+2] = 'O';
						if (pUSAPMbuf[x+3] == 'S')
							pUSAPMbuf[x+3] = ' ';
					}
				}
				else if ((pUSAPMbuf[x-4] == 'T') && (pUSAPMbuf[x-3] == 'o') && (pUSAPMbuf[x-2] == 'p'))//Topo=
				{
					GotData++;
					if (MapType == TOPO)
					{
						pUSAPMbuf[x+1] = 'Y';
						pUSAPMbuf[x+2] = 'E';
						if (pUSAPMbuf[x+3] == ' ')
							pUSAPMbuf[x+3] = 'S';
					}
					else if (MapType == PHOTO)
					{
						pUSAPMbuf[x+1] = 'N';
						pUSAPMbuf[x+2] = 'O';
						if (pUSAPMbuf[x+3] == 'S')
							pUSAPMbuf[x+3] = ' ';
					}
					else//if (MapType == URBANAREA)
					{
						pUSAPMbuf[x+1] = 'Q';
						pUSAPMbuf[x+2] = 'Q';
						if (pUSAPMbuf[x+3] == 'S')
							pUSAPMbuf[x+3] = ' ';
					}
				}
				else if ((pUSAPMbuf[x-1] == 'g') && (pUSAPMbuf[x-7] == 'C'))//OpenAtClosing=
				{
					GotData++;
					if (openatclosing)
					{
						pUSAPMbuf[x+1] = 'Y';
						pUSAPMbuf[x+2] = 'E';
						if (pUSAPMbuf[x+3] == ' ')
							pUSAPMbuf[x+3] = 'S';
					}
					else
					{
						pUSAPMbuf[x+1] = 'N';
						pUSAPMbuf[x+2] = 'O';
						if (pUSAPMbuf[x+3] == 'S')
							pUSAPMbuf[x+3] = ' ';
					}
				}
				else if ((pUSAPMbuf[x-9] == 'I') && (pUSAPMbuf[x-1] == 't'))//FadeIncrement=
				{
					GotData++;
					pUSAPMbuf[x+1] = (FadeIncrement / 10)  + '0';
					pUSAPMbuf[x+2] = (FadeIncrement % 10)  + '0';
				}
				else if (pUSAPMbuf[x-5] == '2')//Spaces2Move=
				{
					GotData++;
					gotspaces2move = TRUE;
					pUSAPMbuf[x+1] = Spaces2Move + '0';
				}
				else if ((pUSAPMbuf[x-1] == 't') && (pUSAPMbuf[x-4] == 'T') && (pUSAPMbuf[x-8] == 'S'))//ShowText=
				{
					gotshowtext = TRUE;
					GotData++;
					if (showtext)
					{
						pUSAPMbuf[x+1] = 'Y';
						pUSAPMbuf[x+2] = 'E';
						if (pUSAPMbuf[x+3] == ' ')
							pUSAPMbuf[x+3] = 'S';
					}
					else
					{
						pUSAPMbuf[x+1] = 'N';
						pUSAPMbuf[x+2] = 'O';
						if (pUSAPMbuf[x+3] == 'S')
							pUSAPMbuf[x+3] = ' ';
					}
				}
			}
		}//end of for (
		SetFilePointer(hFile, 0, NULL, FILE_BEGIN); // re-write it
		WriteFile(hFile, pUSAPMbuf, fileSize, &dwBytesWritten, NULL);
		free(pUSAPMbuf);
		if (gotshowtext == FALSE)
		{
			if (showtext)
				WriteFile(hFile, ShowText, 14, &dwBytesWritten, NULL);
			else
				WriteFile(hFile, DontShowText, 14, &dwBytesWritten, NULL);
		}
		if (GotData == 0)
		{
			y = 0;
			pUSAPMbuf = (char*)malloc(1000);//use it again
			if (prefOutMouseLoc == DEG)
				y += sprintf(&pUSAPMbuf[y], Deg);
			else if (prefOutMouseLoc == DEGMIN)
				y += sprintf(&pUSAPMbuf[y], Min);
			else if (prefOutMouseLoc == DEGMINSEC)
				y += sprintf(&pUSAPMbuf[y], Sec);
			else if (prefOutMouseLoc == ITSUTM)
				y += sprintf(&pUSAPMbuf[y], Utm);
			else if (prefOutMouseLoc == ITSUSNG)
				y += sprintf(&pUSAPMbuf[y], Usng);
			if (prefOutZoom == 1)
				y += sprintf(&pUSAPMbuf[y], Zoom1);
			else if (prefOutZoom == 2)
				y += sprintf(&pUSAPMbuf[y], Zoom2);
			else if (prefOutZoom == 3)
				y += sprintf(&pUSAPMbuf[y], Zoom3);
			else if (prefOutZoom == 4)
				y += sprintf(&pUSAPMbuf[y], Zoom4);
			else if (prefOutZoom == 5)
				y += sprintf(&pUSAPMbuf[y], Zoom5);
			else if (prefOutZoom == 6)
				y += sprintf(&pUSAPMbuf[y], Zoom6);
			else if (prefOutZoom == 7)
				y += sprintf(&pUSAPMbuf[y], Zoom7);
			else if (prefOutZoom == 8)
				y += sprintf(&pUSAPMbuf[y], Zoom8);
			if (prefOutLatlon == TRUE)
				y += sprintf(&pUSAPMbuf[y], DoShowNearest);
			else
				y += sprintf(&pUSAPMbuf[y], DontShowNearest);
			if (prefOutName == TRUE)
				y += sprintf(&pUSAPMbuf[y], DoShowName);
			else
				y += sprintf(&pUSAPMbuf[y], DontShowName);
			if (sortbyname == TRUE)
				y += sprintf(&pUSAPMbuf[y], DoSortbyName);
			else
				y += sprintf(&pUSAPMbuf[y], DontSortbyName);
			if (zoom1to8 == TRUE)
				y += sprintf(&pUSAPMbuf[y], ZoomTo8Meters);
			else
				y += sprintf(&pUSAPMbuf[y], DontZoomTo8Meters);
			if (MapType == TOPO)
				y += sprintf(&pUSAPMbuf[y], Topo);
			else if (MapType == PHOTO)
				y += sprintf(&pUSAPMbuf[y], NotTopo);
			else//if (MapType == URBANAREA)
				y += sprintf(&pUSAPMbuf[y], UrbanColor);
			if (openatclosing)
				y += sprintf(&pUSAPMbuf[y], OpenAtClosing);
			else
				y += sprintf(&pUSAPMbuf[y], DontOpenAtClosing);
			if (showtext)
				y += sprintf(&pUSAPMbuf[y], ShowText);
			else
				y += sprintf(&pUSAPMbuf[y], DontShowText);
			FadeIncr[14] = (FadeIncrement / 10)  + '0';
			FadeIncr[15] = (FadeIncrement % 10)  + '0';
			y += sprintf(&pUSAPMbuf[y], FadeIncr);
			Spaces2[12] = Spaces2Move  + '0';
			y += sprintf(&pUSAPMbuf[y], Spaces2);
			WriteFile(hFile, pUSAPMbuf, y, &dwBytesWritten, NULL);
			free(pUSAPMbuf);
		}
		else if (gotspaces2move == FALSE)
		{
			Spaces2[12] = Spaces2Move  + '0';
			y = sprintf(Error, Spaces2);
			WriteFile(hFile, Error, y, &dwBytesWritten, NULL);
		}
	}
	CloseHandle(hFile);
}

void ShowWaypointData(int x, int y)
{
	int z;
	char wp[50];

	y += 3;//to comment
	for (z = 0; (z < 50) && (NewLoc[x].pWaypoints[y] != '<'); y++, z++)
		wp[z] = NewLoc[x].pWaypoints[y];
	hdc = GetDC(hwnd);
	if (MapType != TOPO)
	{
		SetBkMode(hdc, TRANSPARENT);
		SetTextColor(hdc, WHITE);
	}
	TextOut(hdc, ((NewLoc[x].EUTM - ScreenLeft) * PixelsPerTile / MetersPerTile) + 10, ((ScreenTop - NewLoc[x].NUTM) * PixelsPerTile / MetersPerTile) - 10, wp, z);
 	ReleaseDC(hwnd, hdc);
}

void FillZoomTable(void)
{
	ZoomTable[1] = LineWidth1[0] - '0';
	ZoomTable[2] = LineWidth2[0] - '0';
	ZoomTable[3] = LineWidth4[0] - '0';
	ZoomTable[4] = LineWidth8[0] - '0';
	ZoomTable[5] = LineWidth8[0] - '0';
	ZoomTable[6] = LineWidth16[0] - '0';
	ZoomTable[7] = LineWidth32[0] - '0';
	ZoomTable[8] = LineWidth64[0] - '0';
	ZoomTable[9] = TopoLine4[0] - '0';
	ZoomTable[10] = TopoLine8[0] - '0';
	ZoomTable[11] = TopoLine16[0] - '0';
	ZoomTable[12] = TopoLine32[0] - '0';
	ZoomTable[13] = TopoLine64[0] - '0';
	ZoomTable[14] = TopoLine128[0] - '0';
	ZoomTable[15] = TopoLine256[0] - '0';
}

void WriteDots(HANDLE hFile)
{
	Meter1PhotoDot[23] = PhotoDot1[0];
	WriteFile(hFile, &Meter1PhotoDot, sizeof(Meter1PhotoDot)-1, &dwBytesWritten, NULL);
	Meter2PhotoDot[23] = PhotoDot2[0];
	WriteFile(hFile, &Meter2PhotoDot, sizeof(Meter2PhotoDot)-1, &dwBytesWritten, NULL);
	Meter4PhotoDot[23] = PhotoDot4[0];
	WriteFile(hFile, &Meter4PhotoDot, sizeof(Meter4PhotoDot)-1, &dwBytesWritten, NULL);
	Meter8PhotoDot[23] = PhotoDot8[0];
	WriteFile(hFile, &Meter8PhotoDot, sizeof(Meter8PhotoDot)-1, &dwBytesWritten, NULL);
	Meter16PhotoDot[24] = PhotoDot16[0];
	WriteFile(hFile, &Meter16PhotoDot, sizeof(Meter16PhotoDot)-1, &dwBytesWritten, NULL);
	Meter32PhotoDot[24] = PhotoDot32[0];
	WriteFile(hFile, &Meter32PhotoDot, sizeof(Meter32PhotoDot)-1, &dwBytesWritten, NULL);
	Meter64PhotoDot[24] = PhotoDot64[0];
	WriteFile(hFile, &Meter64PhotoDot, sizeof(Meter64PhotoDot)-1, &dwBytesWritten, NULL);
	Meter4TopoDot[22] = TopoDot4[0];
	WriteFile(hFile, &Meter4TopoDot, sizeof(Meter4TopoDot)-1, &dwBytesWritten, NULL);
	Meter8TopoDot[22] = TopoDot8[0];
	WriteFile(hFile, &Meter8TopoDot, sizeof(Meter8TopoDot)-1, &dwBytesWritten, NULL);
	Meter16TopoDot[23] = TopoDot16[0];
	WriteFile(hFile, &Meter16TopoDot, sizeof(Meter16TopoDot)-1, &dwBytesWritten, NULL);
	Meter32TopoDot[23] = TopoDot32[0];
	WriteFile(hFile, &Meter32TopoDot, sizeof(Meter32TopoDot)-1, &dwBytesWritten, NULL);
	Meter64TopoDot[23] = TopoDot64[0];
	WriteFile(hFile, &Meter64TopoDot, sizeof(Meter64TopoDot)-1, &dwBytesWritten, NULL);
	Meter128TopoDot[24] = TopoDot128[0];
	WriteFile(hFile, &Meter128TopoDot, sizeof(Meter128TopoDot)-1, &dwBytesWritten, NULL);
	Meter256TopoDot[24] = TopoDot256[0];
	WriteFile(hFile, &Meter256TopoDot, sizeof(Meter256TopoDot)-1, &dwBytesWritten, NULL);
	Meter512TopoDot[24] = TopoDot512[0];
	WriteFile(hFile, &Meter512TopoDot, sizeof(Meter512TopoDot)-1, &dwBytesWritten, NULL);
	Meter14UrbanDot[24] = UrbanDot14[0];
	WriteFile(hFile, &Meter14UrbanDot, sizeof(Meter14UrbanDot)-1, &dwBytesWritten, NULL);
	Meter12UrbanDot[24] = UrbanDot12[0];
	WriteFile(hFile, &Meter12UrbanDot, sizeof(Meter12UrbanDot)-1, &dwBytesWritten, NULL);
}

void WriteLineWidth(HANDLE hFile)
{
	Meter1LineWidth[16] = LineWidth1[0];
	WriteFile(hFile, &Meter1LineWidth, sizeof(Meter1LineWidth)-1, &dwBytesWritten, NULL);
	Meter2LineWidth[16] = LineWidth2[0];
	WriteFile(hFile, &Meter2LineWidth, sizeof(Meter2LineWidth)-1, &dwBytesWritten, NULL);
	Meter4LineWidth[16] = LineWidth4[0];
	WriteFile(hFile, &Meter4LineWidth, sizeof(Meter4LineWidth)-1, &dwBytesWritten, NULL);
	Meter8LineWidth[16] = LineWidth8[0];
	WriteFile(hFile, &Meter8LineWidth, sizeof(Meter8LineWidth)-1, &dwBytesWritten, NULL);
	Meter16LineWidth[17] = LineWidth16[0];
	WriteFile(hFile, &Meter16LineWidth, sizeof(Meter16LineWidth)-1, &dwBytesWritten, NULL);
	Meter32LineWidth[17] = LineWidth32[0];
	WriteFile(hFile, &Meter32LineWidth, sizeof(Meter32LineWidth)-1, &dwBytesWritten, NULL);
	Meter64LineWidth[17] = LineWidth64[0];
	WriteFile(hFile, &Meter64LineWidth, sizeof(Meter64LineWidth)-1, &dwBytesWritten, NULL);
	Meter4TopoLine[15] = TopoLine4[0];
	WriteFile(hFile, &Meter4TopoLine, sizeof(Meter4TopoLine)-1, &dwBytesWritten, NULL);
	Meter8TopoLine[15] = TopoLine8[0];
	WriteFile(hFile, &Meter8TopoLine, sizeof(Meter8TopoLine)-1, &dwBytesWritten, NULL);
	Meter16TopoLine[16] = TopoLine16[0];
	WriteFile(hFile, &Meter16TopoLine, sizeof(Meter16TopoLine)-1, &dwBytesWritten, NULL);
	Meter32TopoLine[16] = TopoLine32[0];
	WriteFile(hFile, &Meter32TopoLine, sizeof(Meter32TopoLine)-1, &dwBytesWritten, NULL);
	Meter64TopoLine[16] = TopoLine64[0];
	WriteFile(hFile, &Meter64TopoLine, sizeof(Meter64TopoLine)-1, &dwBytesWritten, NULL);
	Meter128TopoLine[17] = TopoLine128[0];
	WriteFile(hFile, &Meter128TopoLine, sizeof(Meter128TopoLine)-1, &dwBytesWritten, NULL);
	Meter256TopoLine[17] = TopoLine256[0];
	WriteFile(hFile, &Meter256TopoLine, sizeof(Meter256TopoLine)-1, &dwBytesWritten, NULL);
}

void GetElevData(void)
{
	int w, x, y, z, ScreenRow, ScreenCol;
	char *ElevBuf;
	static HANDLE hElevFile;

	ScreenLeft = colOffset*MetersPerTile;
	ScreenRight	= ScreenLeft + (TilesAcross*MetersPerTile);
	ScreenBottom = rowOffset*MetersPerTile;
	ScreenTop = ScreenBottom + (TilesDown*MetersPerTile);
	if (ScreenDems != 0)
	{
		for (x = 0; x < ScreenDems; x++)
			free(DemData[x]);
		ScreenDems = 0;
	}
	for (x = 0; (x < NumOfDems) && (ScreenDems < MAX_DEMS); x++)
	{
		if ((Dem[x].Zone == UTMZone) && (Dem[x].North > ScreenBottom) && (Dem[x].South < ScreenTop) && (Dem[x].West < ScreenRight) && (Dem[x].East > ScreenLeft))
		{//if on-screen
			hFindFile = FindFirstFile(ElevationDir, &fd);
			if ((INVALID_HANDLE_VALUE != hFindFile) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				FindClose(hFindFile);//it's a folder, don't do anything
			else//it's not a folder
			{
				MessageBox(hwnd, "Creating a sub-folder of USAPhotoMaps named\nElevations, and moving the elevation data into it.", "", MB_OK);
				if (CreateDirectory(ElevationDir, NULL))
				{
					hElevFile = CreateFile(ElevIni, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
					if (hElevFile != INVALID_HANDLE_VALUE)
					{
						if (fileSize2 = GetFileSize(hElevFile, NULL))
						{
							ElevBuf = (char*)malloc(fileSize2);
							ReadFile(hElevFile, ElevBuf, fileSize2, &dwBytesRead, NULL);
							for (y = 0; y < fileSize2; y++)
							{
								if ((ElevBuf[y] == 'N') && (ElevBuf[y+1] == 'a') && (ElevBuf[y+2] == 'm') && (ElevBuf[y+3] == 'e') && (ElevBuf[y+4] == '='))
								{//Name=
									y += 5;
									for (z = y; z < fileSize2; z++)
										if ((ElevBuf[z] == ' ') && (ElevBuf[z+1] == 'R') && (ElevBuf[z+2] == 'o') && (ElevBuf[z+3] == 'w') && (ElevBuf[z+4] == 's') && (ElevBuf[z+5] == '='))
											break;
									ElevBuf[z] = 0;
									for (w = 10, z = y; ElevBuf[z] != 0; w++, z++)
										NewElevFile[w] = ElevBuf[z];
									NewElevFile[w] = 0;
									MoveFile(&ElevBuf[y], NewElevFile);
								}
							}
							free(ElevBuf);
						}
						CloseHandle(hElevFile);
					}					
				}
			}

			for (w = 10, z = 0; Dem[x].Name[z] != 0; w++, z++)
				NewElevFile[w] = Dem[x].Name[z];
			NewElevFile[w] = 0;
			hFile2 = CreateFile(NewElevFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);//Dem[x].Name
			if (hFile2 != INVALID_HANDLE_VALUE)
			{
				if (fileSize2 = GetFileSize(hFile2, NULL))
				{
					Associated[ScreenDems] = x;
					DemData[ScreenDems] = (WORD*) malloc(fileSize2);
					ReadFile(hFile2, DemData[ScreenDems], fileSize2, &dwBytesRead, NULL);
					if (ScreenDems < 500)
						ScreenDems++;
				}
				CloseHandle(hFile2);
			}					
		}
	}

//fill ScreenElev
	ScreenRow = ScreenCol = topleftrow = topleftcol = 0;
	for (z = 0; z < ScreenDems; z++)
	{
		w = Associated[z];
		if ((ScreenTop <= Dem[w].North) && (ScreenTop > Dem[w].South) && (ScreenLeft >= Dem[w].West) && (ScreenLeft < Dem[w].East))
		{//if this Dem covers the top left corner of the screen
			ScreenRow = topleftrow = 30 - ((Dem[w].North - ScreenTop) % 30);
			ScreenCol = topleftcol = 30 - ((ScreenLeft - Dem[w].West) % 30);
			break;
		}
	}
	y = 41 * 64;
	for (x = 0; x < y; x++)
		ScreenElev[x] = 0x8002;
	lowest = 0x8002;
	highest = 0;
	for (yCon = 0; yCon < 40; yCon++)
	{
		for (xCon = 0; xCon < 64; xCon++)
		{
			for (z = 0; z < ScreenDems; z++)
			{
				w = Associated[z];
				if (((ScreenTop-(ScreenRow*MetersPerTile/PixelsPerTile)) <= Dem[w].North)
				 && ((ScreenTop-(ScreenRow*MetersPerTile/PixelsPerTile)) > Dem[w].South)
				 && ((ScreenLeft+(ScreenCol*MetersPerTile/PixelsPerTile)) >= Dem[w].West)
				 && ((ScreenLeft+(ScreenCol*MetersPerTile/PixelsPerTile)) < Dem[w].East))
				{
					x = (ScreenLeft+(ScreenCol*MetersPerTile/PixelsPerTile) - Dem[w].West) / 30;
					y = (Dem[w].North - (ScreenTop-(ScreenRow*MetersPerTile/PixelsPerTile))) / 30;
					if ((x < Dem[w].Cols) && (y < Dem[w].Rows))
					{
						tl = DemData[z][(y*Dem[w].Cols)+x];
						if (tl != 0x8002)
						{
							if (Dem[w].Meas == 'M')
								tl = (int)((double)tl / 0.3048);
							if (tl < lowest)
								lowest = tl;
							if (tl > highest)
								highest = tl;
							ScreenElev[(yCon<<6)+xCon] = tl;//ScreenElev[41][64]//[1200/30][(1600/30)+1]
						}
					}
				}
			}//end of z
			if (ScreenCol < (rect.right))
				ScreenCol += 30;
			else
				break;
		}//end of for (xCon
		if (ScreenRow < rect.bottom)
		{
			ScreenCol = topleftcol;
			ScreenRow += 30;
		}
		else
			break;
	}//end of for (yCon
	yConMax = yCon;
	xConMax = xCon;
}

void GridSeventyFive(void)
{
	int i, j, UTZ;
	double TopLat, LeftLon, BottomLat, RightLon;
	double TopDecimal, TopDegrees;
	double LeftDecimal, LeftDegrees;
	for (y = 0; y < 20; y++)
	{
		for (x = 0; x < 20; x++)
		{
			HorizPoint[y][x] = 0;
			VertPoint[y][x] = 0;
		}
	}
	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;

	UTMNorthing = ScreenTop;
	UTMEasting = ScreenLeft;
	UTMtoLatLon();
	UTZ = UTMZone;
	TopLat = Lat;
	LeftLon = -Lon;
	TopDecimal = modf(TopLat, &TopDegrees);
	LeftDecimal = modf(LeftLon, &LeftDegrees);
	UTMNorthing = ScreenBottom;
	UTMEasting = ScreenRight;
	UTMtoLatLon();
	BottomLat = Lat - 0.125;
	RightLon = Lon + 0.125;

	if (TopDecimal >= 0.875)
		Lat = 0.875;
	else if (TopDecimal >= 0.750)
		Lat = 0.750;
	else if (TopDecimal >= 0.625)
		Lat = 0.625;
	else if (TopDecimal >= 0.500)
		Lat = 0.500;
	else if (TopDecimal >= 0.375)
		Lat = 0.375;
	else if (TopDecimal >= 0.250)
		Lat = 0.250;
	else if (TopDecimal >= 0.125)
		Lat = 0.125;
	else if (TopDecimal >= 0)
		Lat = 0.0;
	if (LeftDecimal >= 0.875)
		lon = 0.875;
	else if (LeftDecimal >= 0.750)
		lon = 0.750;
	else if (LeftDecimal >= 0.625)
		lon = 0.625;
	else if (LeftDecimal >= 0.500)
		lon = 0.500;
	else if (LeftDecimal >= 0.375)
		lon = 0.375;
	else if (LeftDecimal >= 0.250)
		lon = 0.250;
	else if (LeftDecimal >= 0.125)
		lon = 0.125;
	else if (LeftDecimal >= 0)
		lon = 0.0;
	Lat += TopDegrees;
	lon += LeftDegrees;
	lon = -lon;
	for (i = 0; Lat > BottomLat; i++, Lat -= 0.125)
	{
		for (j = 0, Lon = lon; Lon < RightLon; j++, Lon += 0.125)
		{
			LatRad = Lat*deg2rad;
			LonRad = Lon*deg2rad;
			LatLontoUTM();
			if (UTMZone == UTZ)
			{
				HorizPoint[i][j] = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
				if (HorizPoint[i][j] == 0)
					HorizPoint[i][j] = 1;
				VertPoint[i][j] = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
				if (VertPoint[i][j] == 0)
					VertPoint[i][j] = 1;
			}
		}
	}
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;//new
	UTMNorthing = tempUTMN;//
	UTMEasting = tempUTME;//
}

/* store_pixel -- add pixel to decoded image */
void store_pixel(int index)
{
	int x = index*3;

	pixel_buf[pixelptr++] = ColorTable[x+2];
	pixel_buf[pixelptr++] = ColorTable[x+1];
	pixel_buf[pixelptr++] = ColorTable[x];
}

/*loop over the data for an image, until an EOI code */
int decodeLZW(void)
{
	#define MAX_LZW_BITS 12
	#define MAXSTACK 4096
	int clear_code, eoi_code, min_code_size, free_code;
	int code = -1, first;
	int nrworkbits = 0, code_size, code_mask, sp = 0;
	int bufidx = 0, buflen = 0, prev_code = -2;
	int offset = 0;
	unsigned char buf[256];
	unsigned long workbits = 0;
	int stack[MAXSTACK], prefix[MAXSTACK], extnsn[MAXSTACK];
//Read initial code size, initialize special codes
	if (offset + 1 > GifBufSize) return FALSE;
	buf[0] = GifBuf[offset];
	offset += 1;

	min_code_size = buf[0];
	clear_code = 1 << min_code_size;
	eoi_code = clear_code + 1;
	free_code = clear_code + 2;
	code_size = min_code_size + 1;
	code_mask = (1 << code_size) - 1;
	pixelptr = 0;
	/* Decode until we find an End-of-Information code */
	while (code != eoi_code) {
		/* Add bytes until we have enough bits for next code */
		while (nrworkbits < code_size) {
			/* Read new data block if needed */
			if (bufidx == buflen) {
				if (offset + 1 > GifBufSize) return FALSE;
				buf[0] = GifBuf[offset];
				offset += 1;
				buflen = buf[0];
				if (offset + buflen > GifBufSize) return FALSE;
				memcpy(buf, &GifBuf[offset], buflen);
				offset += buflen;
				bufidx = 0;
			}
			workbits |= ((unsigned long) (buf[bufidx++]) << nrworkbits);
			nrworkbits += 8;
		}
		/* Get next code */
		code = workbits & code_mask;
		workbits >>= code_size;
		nrworkbits -= code_size;
		/* Force first code of image to be a clear code */
		if (prev_code == -2) code = clear_code;
		/* Branch on type of code */
		if (code == clear_code) {				/* Reset the decoder */
			code_size = min_code_size + 1;		/* Original code size */
			code_mask = (1 << code_size) - 1;	/* Corresponding mask */
			free_code = clear_code + 2; 		/* First pos. in tables */
			prev_code = -1; 					/* Next code is a root code */
		} else if (code == eoi_code) {			/* End of Information */
			/* skip */
		} else if (prev_code == -1) {			/* 1st code after clearcode */
			if (code < 0)
				return FALSE;
			store_pixel(code);					/* Add to image */
			first = prev_code = code;
		} else {								/* We've got a normal code */
			if (code >= free_code) {			/* It's a new code */
				stack[sp++] = first;
				first = prev_code;
			} else								/* It's an existing code */
				first = code;
			while (first >= clear_code) {		/* Push string of pixels */
				stack[sp++] = extnsn[first];
				first = prefix[first];
			}
			stack[sp++] = first;				/* Push string's root code */
			while (sp != 0) {					/* Now add pixels to image */
				sp--;
				if (stack[sp] < 0)
					return FALSE;
				store_pixel(stack[sp]);
			}
			prefix[free_code] = prev_code;
			extnsn[free_code++] = first;
			prev_code = code;
			/* Check if code_size needs to increase */
			if (free_code > code_mask && code_size != MAX_LZW_BITS) {
				code_size++;
				code_mask = (1 << code_size) - 1;
			}
		}
	}
	return TRUE;
}

DWORD CreateTileBuf(unsigned char *RowBufs, unsigned int col)
{
	DWORD fileSize;

	ijlInit(&jcprops);//use Intel's ijl15.dll to convert JPEG files
	jcprops.DIBWidth= 200;
	jcprops.DIBHeight = 200;
	jcprops.DIBPadBytes = IJL_DIB_PAD_BYTES(200, 3);
	jcprops.DIBChannels = 3;
	jcprops.DIBColor = IJL_BGR;
	jcprops.DIBBytes = pixel_buf;//input

	jcprops.JPGWidth = 200;
	jcprops.JPGHeight = 200;
	jcprops.JPGBytes = &RowBufs[col];//output
	jcprops.JPGSizeBytes = MAX_TILE_SIZE;//estimate
	jcprops.JPGFile = NULL;
	jcprops.JPGChannels = 3;
	jcprops.JPGColor = IJL_YCBCR;
	jcprops.JPGSubsampling = IJL_411;//4:1:1 subsampling
	jcprops.jquality = 75;
	ijlWrite(&jcprops, IJL_JBUFF_WRITEWHOLEIMAGE);
	fileSize = jcprops.JPGSizeBytes;//re-computed by ijl15.dll
	ijlFree(&jcprops);
	return fileSize;
}

int CALLBACK TrackColorsProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int x;
	BYTE red, green, blue;

	switch (msg)
	{
	case WM_INITDIALOG:
		CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO5, IDC_RADIO3);
		red = GetRValue(TrackSegmentColor);
		green = GetGValue(TrackSegmentColor);
		blue = GetBValue(TrackSegmentColor);
		CheckRadio(hwndDlg, red, green, blue);
		SetFocus(hwndDlg);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_RADIO6:
			TrackSegmentColor = (TrackSegmentColor & 0xFFFF00) | 0x0000FF;
			goto invalidate;
		case IDC_RADIO7:
			TrackSegmentColor = (TrackSegmentColor & 0xFFFF00) | 0x0000C0;
			goto invalidate;
		case IDC_RADIO8:
			TrackSegmentColor = (TrackSegmentColor & 0xFFFF00) | 0x000080;
			goto invalidate;
		case IDC_RADIO9:
			TrackSegmentColor = TrackSegmentColor & 0xFFFF00;
			goto invalidate;

		case IDC_RADIO10:
			TrackSegmentColor = (TrackSegmentColor & 0xFF00FF) | 0x00FF00;
			goto invalidate;
		case IDC_RADIO11:
			TrackSegmentColor = (TrackSegmentColor & 0xFF00FF) | 0x00C000;
			goto invalidate;
		case IDC_RADIO12:
			TrackSegmentColor = (TrackSegmentColor & 0xFF00FF) | 0x008000;
			goto invalidate;
		case IDC_RADIO13:
			TrackSegmentColor = TrackSegmentColor & 0xFF00FF;
			goto invalidate;

		case IDC_RADIO14:
			TrackSegmentColor = (TrackSegmentColor & 0x00FFFF) | 0xFF0000;
			goto invalidate;
		case IDC_RADIO15:
			TrackSegmentColor = (TrackSegmentColor & 0x00FFFF) | 0xC00000;
			goto invalidate;
		case IDC_RADIO16:
			TrackSegmentColor = (TrackSegmentColor & 0x00FFFF) | 0x800000;
			goto invalidate;
		case IDC_RADIO17:
			TrackSegmentColor = TrackSegmentColor & 0x00FFFF;
invalidate:
			for (x = currentpoint;(trak[x].newtrk == 0) && (x > 0); x--)
				;
			trak[x].color = TrackSegmentColor;
			InvalidateRect(hwnd, &rect, FALSE);
			break;

		case IDOK:
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			InvalidateRect(hwnd, &rect, FALSE);
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CheckIniProc(unsigned char *pIni, DWORD fileSize, int From)
{
	int x, y, z, tempUTMZone, tempUTMN, tempUTME;
	double tempLat, tempLon;
	char Buf[200];

	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;

	sprintf(Buf2, "%i", From);
	if ((pIni[fileSize-1] != '\n') && (pIni[fileSize-2] != '\r'))
	{
		sprintf(Buf2, "There isn't a blank line at the\n\
end of USAPhotoMaps.ini.\n\
Using Notepad, put one there by\n\
moving the cursor to the end\n\
of the last line and\n\
pressing Enter.");
		return 1;
	}
	x = 0;
	for (x = 0 ; x < (int)fileSize; x++)
	{//double-check format
		while ((pIni[x] == '\r') && (pIni[x+1] == '\n') && (x < (int)fileSize))
		{//in case there's a blank line
			x += 2;
		}
		for ( ; (pIni[x] != '\r') && (x < (int)fileSize); x++)
			;//end of a line
		if ((pIni[x-1] == ' ') && (x < (int)fileSize))
		{
			sprintf(Buf2, "A line in USAPhotoMaps.ini\n has a space at the end of it.");
			break;
		}
		UTMEasting = 200 * atoi((char*)&pIni[x-17]);
		UTMNorthing = 200 * atoi((char*)&pIni[x-10]);
		UTMZone = atoi((char*)&pIni[x-2]);
		UTMtoLatLon();
		if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
		{
			for (y = x; (pIni[y] != '\n') && (y > 0); y--)
				;
			if (pIni[y] == '\n')
				y++;
			for (z = 0; y < x; y++, z++)
				Buf[z] = pIni[y];
			Buf[z] = 0;
			y = sprintf(Buf2, "Error #%i\nThis line in USAPhotoMaps.ini represents\na Lat/Lon that's outside the USA:\n%s\nN %f\nW %f", From, Buf, Lat, Lon);
			break;
		}
		else if ((pIni[x-1] < '0') || (pIni[x-1] > '9')
		 ||	(pIni[x-2] < '0') || (pIni[x-2] > '9')
		 || (pIni[x-3] != '=')
		 || (pIni[x-4] != 'Z')
		 || (pIni[x-5] != '&')
		 ||	(pIni[x-6] < '0') || (pIni[x-6] > '9')
		 ||	(pIni[x-7] < '0') || (pIni[x-7] > '9')
		 ||	(pIni[x-8] < '0') || (pIni[x-8] > '9')
		 ||	(pIni[x-9] < '0') || (pIni[x-9] > '9')
		 ||	(pIni[x-10] < '0') || (pIni[x-10] > '9')
		 || (pIni[x-11] != '=')
		 || (pIni[x-12] != 'Y')
		 || (pIni[x-13] != '&')
		 ||	(pIni[x-14] < '0') || (pIni[x-14] > '9')
		 ||	(pIni[x-15] < '0') || (pIni[x-15] > '9')
		 ||	(pIni[x-16] < '0') || (pIni[x-16] > '9')
		 ||	(pIni[x-17] < '0') || (pIni[x-17] > '9')
		 || (pIni[x-18] != '=')
		 || (pIni[x-19] != 'X')
		 || (pIni[x-20] != '&'))
		{//*Ithaca&X=1880&Y=23516&Z=18
		 //       098765432109876543210
			for (y = x; (pIni[y] != '\n') && (y > 0); y--)
				;
			if (pIni[y] == '\n')
				y++;
			for (z = 0; y < x; y++, z++)
				Buf[z] = pIni[y];
			Buf[z] = 0;
			y = sprintf(Buf2, "\
Error #%i.\n\
The line in USAPhotoMaps.ini (configuration file):\n\
%s\n\
doesn't have the following format:\n\
MapName&X=1234&Y=12345&Z=12\n\
(note the number of digits)\n\n\
You'll have to edit it with Notepad to either\n\
fix it or delete it. And remember that an asterisk (*)\n\
has to be at the beginning of a line.", From, Buf);
			Buf[0] = 0;//flag
			break;
		}
		x++;//to '\n'
	}//end of for (x = 0
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
	return x;
}

void ShowPosition(void)
{
	int x, y, z;

	if (((Pvt.fix >= 2) && (Pvt.lat != 0.0) && (Pvt.lon != 0.0)) || ((itsgarmin == FALSE) && (itsusb == FALSE)))
	{
		if ((itsgarmin) || (itsusb))
		{//already have it for NMEA data
			LatRad = Pvt.lat;
			LonRad = Pvt.lon;
			Lat = LatRad * rad2deg;
			Lon = LonRad * rad2deg;
			LatLontoUTM();//get UTMEasting & UTMNorthing
		}
		if (UTMZone != tempUTMZone)//tempUTMZone = UTMZone in VK_SPACE
		{
			tempUTMZone = UTMZone;
			ChangeZone(UTMZone, 7);
			BeginY = UTMNorthing / MetersPerTile;
			BeginX = UTMEasting / MetersPerTile;
			_itoa(BeginX, X, 10);
			_itoa(BeginY, Y, 10);
			Z[0] = (UTMZone / 10) + '0';
			Z[1] = (UTMZone % 10) + '0';
			fromOpen = TRUE;
			Waypoints[0] = 0;
			SendMessage(hwnd, WM_USER4, 0, 0);
//hFile = CreateFile(Bug, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
//WriteFile(hFile, "1", 1, &dwBytesWritten, NULL);
//CloseHandle(hFile);
		}
		Position[pos].UTMN = UTMNorthing;
		Position[pos].UTME = UTMEasting;
		Position[pos].UTMZ = UTMZone;
		if ((UTMEasting > ScreenLeft) && (UTMEasting < (ScreenLeft + (TilesAcross*MetersPerTile)))
		 && (UTMNorthing < ScreenTop) && (UTMNorthing > (ScreenTop - (TilesDown*MetersPerTile))))
		{//if current GPS location is on-screen, center it
			if (UTMEasting > (ScreenLeft + (rSquare*MetersPerTile/PixelsPerTile)))
				SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_RIGHT, (LPARAM)FROMCOMM);
			else if (UTMEasting < (ScreenLeft + (lSquare*MetersPerTile/PixelsPerTile)))
				SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_LEFT, (LPARAM)FROMCOMM);
			else if (UTMNorthing > (ScreenTop - (tSquare*MetersPerTile/PixelsPerTile)))//else added 10/15/2004
				SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_UP, (LPARAM)FROMCOMM);
			else if (UTMNorthing < (ScreenTop - (bSquare*MetersPerTile/PixelsPerTile)))
				SendMessage(hwnd, WM_KEYDOWN, (WPARAM)VK_DOWN, (LPARAM)FROMCOMM);
		}
		else
		{
			rowOffset = (UTMNorthing / MetersPerTile) - ((TilesDown)/2);//center it
			colOffset = (UTMEasting / MetersPerTile) - ((TilesAcross-1)/2);//center it
			autoLoc = TRUE;//in case user changed map to correct one
			SendMessage(hwnd, WM_USER, 0, 0);
//hFile = CreateFile(Bug, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
//WriteFile(hFile, "2", 1, &dwBytesWritten, NULL);
//CloseHandle(hFile);
		}
		InvalidateRect(hwnd, &rect, FALSE);
		UpdateWindow(hwnd);

		if (makewaypoint)
		{
			makewaypoint = FALSE;//note it's after InvalidateRect
			if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
				;//don't do anything
			else if (NewLoc[TOTAL_LOCS-1].EUTM == 0)
			{
				strcpy(Location, _itoa(UTMEasting, Error, 10));
				strcat(Location, "  ");
				strcat(Location, _itoa(UTMNorthing, Error, 10));
				for (x = 0; x < TOTAL_LOCS; x++)
					if (NewLoc[x].EUTM == 0)
						break;
				Ident[0] = 0;
				Elev[0] = 0;
				Sym[0] = 0;
				NewLoc[x].EUTM = UTMEasting;
				NewLoc[x].NUTM = UTMNorthing;
				NewLoc[x].UTMZone = UTMZone;
///--->
				FillWaypointArray(x);//Lat & Lon are already known
///--->
			}
		}

		if (showlatlon == FALSE)
		{
			nearest = HUNDRED_MILES;
			for (z = 0; NewLoc[z].EUTM != 0; z++)
			{
				if (UTMEasting >= NewLoc[z].EUTM)
					x = UTMEasting - NewLoc[z].EUTM;
				else x = NewLoc[z].EUTM - UTMEasting;
				if (UTMNorthing >= NewLoc[z].NUTM)
					y = UTMNorthing - NewLoc[z].NUTM;
				else y = NewLoc[z].NUTM - UTMNorthing;
				A = x*0.621371192;//1000 * miles/meter
				B = y*0.621371192;
				distance = (int) sqrt(A*A + B*B);

				if ((distance <= prevDist[z]) && (distance <= nearest))
				{
					nearest = distance;
					ChosenLoc = z;
				}
				prevDist[z] = distance;//for next dot
			}
			if (nearest < HUNDRED_MILES)
				ShowNearest(nearest);
			else
			{
				for (x = 0; x < 36; x++)
					Nearest[x] = ' ';
			}
			SetWindowText(hwnd, Nearest);
//hFile = CreateFile(Bug, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
//WriteFile(hFile, "3", 1, &dwBytesWritten, NULL);
//CloseHandle(hFile);
		}
		else // if (showlatlon)
		{
			if (MouseLoc == ITSUTM)
			{
				GetUTM(UTMNorthing, UTMEasting);
				SetWindowText(hwnd, UTM);
			}
			else if (MouseLoc == ITSUSNG)
			{
				GetUSNG(UTMNorthing, UTMEasting);
				SetWindowText(hwnd, USNG);
			}
			else
			{
				GetLatLon();
				SetWindowText(hwnd, LatLon);
			}
//hFile = CreateFile(Bug, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
//WriteFile(hFile, "4", 1, &dwBytesWritten, NULL);
//CloseHandle(hFile);
		}
		if ((itsgarmin == TRUE) || (itsusb == TRUE))
		{
			double Vel = sqrt((Pvt.lat_vel*Pvt.lat_vel)+(Pvt.lon_vel*Pvt.lon_vel));//meters/second
			Position[pos].Alt = (int)((Pvt.alt + Pvt.msl_hght) / 0.3048);//in feet;
			Position[pos].HorizEpe = (int)(Pvt.eph / 0.6096);//(2.0 * 0.3048) radius instead of diameter
			Position[pos].VertEpe = (int)(Pvt.epv / 0.6096);
			Position[pos].Velocity = (float)(Vel * 3600.0 / 1609.344);//to convert meters/second to miles/hour
			Velocity = Position[pos].Velocity;
//			Position[pos].RateOfClimb = (float)(Pvt.alt_vel * 60.0 / 0.3048);//to convert meters/second to feet/minute
		}
	}
	else
	{
		Position[pos].UTMN = 0;
		Position[pos].UTME = 0;
		Position[pos].UTMZ = 0;
		Position[pos].Alt = 0;
		Position[pos].HorizEpe = 0;
		Position[pos].VertEpe = 0;
		Position[pos].Velocity = 0;
//		Position[pos].RateOfClimb = 0;
//hFile = CreateFile(Bug, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
//WriteFile(hFile, "5", 1, &dwBytesWritten, NULL);
//CloseHandle(hFile);
	}
	if ((itsgarmin == TRUE) || (itsusb == TRUE))
	{
		double SSS =  Pvt.tow - Pvt.leap_sec;//Seconds Since Sunday
		int DaysSinceDec311989 = Pvt.grmn_days;
		__int64 SecsSinceDec311989 = (__int64)SSS + ((__int64)DaysSinceDec311989 * (__int64)86400.0);
		SecsSinceDec311989 *= 10000000;//* 100 nanoseconds for FILETIME format
		li.LowPart = 4000088064;//pre-computed for 00:00am Dec 31, 1989
		li.HighPart = 28581216;//ditto
		li.QuadPart += SecsSinceDec311989;
		ft = *(FILETIME *) &li;
		FileTimeToSystemTime(&ft, &st);//get time & date from trak.time
		Position[pos].Hour = (BYTE)st.wHour;
		Position[pos].Min = (BYTE)st.wMinute;
		Position[pos].Sec = (BYTE)st.wSecond;
		Position[pos].Month = (BYTE)st.wMonth;
		Position[pos].Date = (BYTE)st.wDay;
		Position[pos].Year = (BYTE)(st.wYear - 2000);
	}
	if (tnc && MYCALL[7] && UNPROTO[7])
	{
		if (smartbeaconing == FALSE)
		{
			if (((pos%120)+1) == 1)//BEACON every 2 minutes
			{
//				if ((LastGPSNorthing >= (Position[pos].UTMN + 100)) || (LastGPSNorthing <= (Position[pos].UTMN - 100)) || (LastGPSEasting >= (Position[pos].UTME + 100)) || (LastGPSEasting <= (Position[pos].UTME - 100)))
				{
					LastGPSNorthing = Position[pos].UTMN;
					LastGPSEasting = Position[pos].UTME;
					ConvertoGPSLatLon();
				}
			}
		}
		else if (SmartBeacon(pos))
		{
			if ((LastGPSNorthing >= (Position[pos].UTMN + 100)) || (LastGPSNorthing <= (Position[pos].UTMN - 100)) || (LastGPSEasting >= (Position[pos].UTME + 100)) || (LastGPSEasting <= (Position[pos].UTME - 100)))
			{
				LastGPSNorthing = Position[pos].UTMN;
				LastGPSEasting = Position[pos].UTME;
				ConvertoGPSLatLon();
			}
		}
	}
	pos++;
	if (pos == 14400)
		pos = 0;
}

//**********GARMIN USB***************

void SendPacket(DWORD dwBytesToSend)
{
	while (0 == WriteFile(hUSBFile, &Packet[PacketPtr], dwBytesToSend, &dwBytesWritten, &ol2))
	{
		if (ERROR_IO_PENDING == GetLastError())
		{
			if (WAIT_TIMEOUT != WaitForSingleObject(ol2.hEvent, 1000))
			{
				GetOverlappedResult(hUSBFile, &ol2, &dwBytesReceived, TRUE);
			}
			break;
		}
	}
}

UINT CALLBACK ReadFileThread(void* pParam)
{
//	USBptr += dwBytesReceived;
	ReadPtr = USBptr;
	while (TRUE)
	{
		if (0 == ReadFile(hUSBFile, BulkBuf, USB_MAX_BUFFER_SIZE, &dwBytesRead, &ol3))
		{
			LastError = GetLastError();
			if (ERROR_IO_PENDING == LastError)
			{
				if (WAIT_TIMEOUT != WaitForSingleObject(ol3.hEvent, 2000))
				{
					if (GetOverlappedResult(hUSBFile, &ol3, &dwBytesReceived, TRUE))
					{
						if (dwBytesReceived)
						{
							memcpy(FromUSBBuf+USBptr, BulkBuf, dwBytesReceived);
//y = sprintf(Error, "Bulk USBptr: %i\r\n", USBptr);
//WriteFile(hDeviceFile, Error, y, &dwBytesWritten, NULL);
							USBptr += dwBytesReceived;
							if ((*(DWORD*)&FromUSBBuf[USBptr-76] == 20) && (*(DWORD*)&FromUSBBuf[USBptr-76+4] == 51) && (*(DWORD*)&FromUSBBuf[USBptr-76+8] == 64))
							{//get the whole line of data
//y = sprintf(Error, "Bulk Pvt USBptr: %i\r\n", USBptr);
//WriteFile(hDeviceFile, Error, y, &dwBytesWritten, NULL);
								PvtBegin = USBptr-76;//new
								Pvt.alt = *(float*)&FromUSBBuf[PvtBegin+12];//76-12=64
								Pvt.epe = *(float*)&FromUSBBuf[PvtBegin+16];
								Pvt.eph = *(float*)&FromUSBBuf[PvtBegin+20];
								Pvt.epv = *(float*)&FromUSBBuf[PvtBegin+24];
								Pvt.fix = *(WORD*)&FromUSBBuf[PvtBegin+28];
								Pvt.tow = *(double*)&FromUSBBuf[PvtBegin+30];
								Pvt.lat = *(double*)&FromUSBBuf[PvtBegin+38];//radians
								Pvt.lon = *(double*)&FromUSBBuf[PvtBegin+46];//radians
								Pvt.lon_vel = *(float*)&FromUSBBuf[PvtBegin+54];
								Pvt.lat_vel = *(float*)&FromUSBBuf[PvtBegin+58];
								Pvt.alt_vel = *(float*)&FromUSBBuf[PvtBegin+62];
								Pvt.msl_hght = *(float*)&FromUSBBuf[PvtBegin+66];
								Pvt.leap_sec = *(WORD*)&FromUSBBuf[PvtBegin+70];
								Pvt.grmn_days = *(UINT*)&FromUSBBuf[PvtBegin+72];

								PostMessage(hwnd, WM_USB, 0, 0);
							}
						}
						/////////////////////////
						else//if (dwBytesReceived == 0)
						{
//break;//FOR MAGELLAN TEST ONLY!
							for (x = ReadPtr; x < USBptr; x++)
							{
								if(*(int*)&FromUSBBuf[x] == 0x14)
								{
									if ((*(int*)&FromUSBBuf[x+4] == 0x0C) && (*(int*)&FromUSBBuf[x+8] == 2))
									{//Pid_Xfer_Cmplt
										xfercmplt = TRUE;
									}
									else if (getprotocol)
									{
										if ((*(int*)&FromUSBBuf[x+4] == 0xFF) && (gotFF == FALSE))
											gotFF = TRUE;
										if ((*(int*)&FromUSBBuf[x+4] == 0xFD) && (gotFD == FALSE))
											gotFD = TRUE;
									}
								}
							}
							if ((getprotocol) && (gotFF) && (gotFD) && (dwBytesReceived < USB_INTERRUPT_DATA_SIZE))
							{
								getprotocol = FALSE;
								SetEvent(hEvent1);//to make sure it doesn' time out before getting this stuff
							}
							else if (xfercmplt)
							{
								xfercmplt = FALSE;
								SetEvent(hEvent2);
							}
						}
						/////////////////////////
					}
				}//end of if (WAIT_TIMEOUT
				else
				{//commanded to stop positioning by SignalUSBStop
					SetEvent(hEvent3);//signal to end position
					break;//close thread
				}
			}//end of if (ERROR_IO_PENDING == LastError)
		}//end of if (0 == ReadFile
	}//end of while (TRUE)
	return 0;
}

UINT CALLBACK DeviceThread(void* pParam)
{
//	int y;

	while (TRUE)
	{
		if (0 == DeviceIoControl(hUSBFile, IOCTL_GARMIN_USB_INTERRUPT_IN, 0, 0, USBBuf, USB_INTERRUPT_DATA_SIZE, &dwBytesReturned, &ol))
		{
			if (ERROR_IO_PENDING == GetLastError())
			{
				if (WAIT_TIMEOUT != WaitForSingleObject(ol.hEvent, 2000))
				{
					if (GetOverlappedResult(hUSBFile, &ol, &dwBytesReceived, TRUE))
					{
						memcpy(FromUSBBuf+USBptr, USBBuf, dwBytesReceived);
//y = sprintf(Error, "Interrupt USBptr: %i\r\n", USBptr);
//WriteFile(hDeviceFile, Error, y, &dwBytesWritten, NULL);
						USBptr += dwBytesReceived;//new
						Packets++;
						if (USBdownloading == FALSE)
						{
							if (0 == Packets % 50)
								ShowPackets();
						}
//						else if ((UINT)USBptr == PvtBegin + USB_INTERRUPT_DATA_SIZE)
						else if ((*(DWORD*)&FromUSBBuf[USBptr-76] == 20) && (*(DWORD*)&FromUSBBuf[USBptr-76+4] == 51) && (*(DWORD*)&FromUSBBuf[USBptr-76+8] == 64))
						{//get the whole line of data
//y = sprintf(Error, "Interrupt Pvt USBptr: %i\r\n", USBptr);
//WriteFile(hDeviceFile, Error, y, &dwBytesWritten, NULL);
							PvtBegin = USBptr-76;//new
							Pvt.alt = *(float*)&FromUSBBuf[PvtBegin+12];//76-12=64
							Pvt.epe = *(float*)&FromUSBBuf[PvtBegin+16];
							Pvt.eph = *(float*)&FromUSBBuf[PvtBegin+20];
							Pvt.epv = *(float*)&FromUSBBuf[PvtBegin+24];
							Pvt.fix = *(WORD*)&FromUSBBuf[PvtBegin+28];
							Pvt.tow = *(double*)&FromUSBBuf[PvtBegin+30];
							Pvt.lat = *(double*)&FromUSBBuf[PvtBegin+38];//radians
							Pvt.lon = *(double*)&FromUSBBuf[PvtBegin+46];//radians
							Pvt.lon_vel = *(float*)&FromUSBBuf[PvtBegin+54];
							Pvt.lat_vel = *(float*)&FromUSBBuf[PvtBegin+58];
							Pvt.alt_vel = *(float*)&FromUSBBuf[PvtBegin+62];
							Pvt.msl_hght = *(float*)&FromUSBBuf[PvtBegin+66];
							Pvt.leap_sec = *(WORD*)&FromUSBBuf[PvtBegin+70];
							Pvt.grmn_days = *(UINT*)&FromUSBBuf[PvtBegin+72];

							PostMessage(hwnd, WM_USB, 0, 0);
						}

						if ((*(DWORD*)&USBBuf[0] == 0) && (*(DWORD*)&USBBuf[4] == 2) && (*(DWORD*)&USBBuf[8] == 0))
						{			
							if (hReadFileThread == NULL)
								hReadFileThread = _beginthreadex(NULL, 0, ReadFileThread, 0, 0, &idThread8);
						}
						else if (*(DWORD*)&USBBuf[0] == 0x14)
						{//Garmin protocol
							if (getprotocol)
							{
								if((*(DWORD*)&USBBuf[4] == 0xFF) && (gotFF == FALSE))
									gotFF = TRUE;
								else if ((*(DWORD*)&USBBuf[4] == 0xFD) && (gotFD == FALSE))
									gotFD = TRUE;
							}
//							else if ((*(DWORD*)&USBBuf[4] == 0x33) && (*(DWORD*)&USBBuf[8] == 64))//Pid_Pvt_Data
//							{
//								int y = sprintf(Error, "PvtBegin = %i\r\n", USBptr);
//								WriteFile(hDeviceFile, Error, y, &dwBytesWritten, NULL);
//								PvtBegin = USBptr;//increments by 76
//							}
							else if ((*(DWORD*)&USBBuf[4] == 0x0C) && (*(DWORD*)&USBBuf[8] == 2))//Pid_Xfer_Cmplt
								xfercmplt = TRUE;
						}
						else if ((hevent0set == FALSE) && (*(DWORD*)&USBBuf[0] == 0) && (*(DWORD*)&USBBuf[4] == 6))
						{
							hevent0set = TRUE;
							SetEvent(hEvent0);
						}
//						USBptr += dwBytesReceived;
					}//end of if (GetOverlappedResult
				}//end of if (WAIT_TIMEOUT !=
				else
				{//commanded to stop positioning by SignalUSBStop
					SetEvent(hEvent3);//signal to end position
					break;//close thread
				}
			}//end of if (ERROR_IO_PENDING
			if ((getprotocol) && (gotFF) && (gotFD) && (dwBytesReceived < USB_INTERRUPT_DATA_SIZE))
			{
				getprotocol = FALSE;
				SetEvent(hEvent1);
				MessageBeep(MB_OK);
			}
			else if (xfercmplt)
			{
				xfercmplt = FALSE;
				SetEvent(hEvent2);
			}
		}//end of if (0 == DeviceIoControl
		else if (hevent0set == FALSE)
		{
			hevent0set = TRUE;
			SetEvent(hEvent0);
		}
	}//end of while (TRUE)
	return 0;
}

void ShowPackets(void)
{
	HDC hUSBdc;

	Numero[0] = (Packets / 1000) + '0';
	Numero[1] = ((Packets % 1000) / 100) + '0';
	Numero[2] = ((Packets % 100) / 10) + '0';
	hUSBdc = GetDC(hwnd);
//	TextOut(hUSBdc, xPos+20, yPos-5, Numero, 4);
	TextOut(hUSBdc, rect.right/2, rect.bottom/2, Numero, 4);
	ReleaseDC(hwnd, hUSBdc);
}

UINT WINAPI USBThread(void* pParam)
{
	int TransmitType = (int)Param;
	int r = 0, x, y, z, ptr;
	int Protocol_ArraySize, Product_DataSize;
	BYTE Protocol_Array[1000], Product_Data[1000];
	DWORD BulkOutPacketSize, TotalBytesToSend;
	WORD Protocols[50];
	WORD TrackType = 0, TrackHeaderType = 0, WaypointType = 0;
	char TimedOut[] = "Timed out waiting for download completion.";
	char Overwrite[] = "Okay, the above file will be overwritten...";
	char Csv[] = ".csv\0";
	char ActiveLog[] = "ACTIVE LOG";
	char RootName[50][100];
	HANDLE hRoute[50];
	GUID ClassGuid = {0x2c9c45c2L, 0x8e7d, 0x4c08, 0xa1, 0x2d, 0x81, 0x6b, 0xba, 0xe7, 0x22, 0xc0};//Garmin USB
	ol.Offset = ol2.Offset = ol3.Offset = 0;
	ol.OffsetHigh = ol2.OffsetHigh = ol3.OffsetHigh = 0;
	ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	ol2.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	ol3.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	hEvent0 = CreateEvent(NULL, TRUE, FALSE, NULL);
	hEvent1 = CreateEvent(NULL, TRUE, FALSE, NULL);
	hEvent2 = CreateEvent(NULL, TRUE, FALSE, NULL);
	hEvent3 = CreateEvent(NULL, TRUE, FALSE, NULL);

	xfercmplt = FALSE;
	Packets = 0;
	hUSBFile = NULL;
	USBptr = PacketPtr = 0;
	Numero[3] = '0';
	for (x = 0; x < 50; x++)
		hRoute[x] = NULL;
	hevent0set = FALSE, gotFD = FALSE, gotFF = FALSE, getprotocol = TRUE;
	DevInfo = SetupDiGetClassDevs((LPGUID)&ClassGuid, NULL, NULL, DIGCF_PRESENT|DIGCF_DEVICEINTERFACE);
	InterfaceData.cbSize = sizeof(InterfaceData);
	if (SetupDiEnumDeviceInterfaces(DevInfo, NULL, (LPGUID)&ClassGuid, 0, &InterfaceData))
	{
		SetupDiGetDeviceInterfaceDetail(DevInfo, &InterfaceData, NULL, 0, &dwBytesReturned, NULL);
		DevDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) malloc(dwBytesReturned);
		DevDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
		SetupDiGetDeviceInterfaceDetail(DevInfo, &InterfaceData, DevDetailData, dwBytesReturned, NULL, &DevInfoData);
		hUSBFile = CreateFile(DevDetailData->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
//
//WriteFile(hUSBFile, &GetMagellanVersion, sizeof(GetMagellanVersion)-1, &dwBytesWritten, NULL);
//dwBytesReceived = 0;
//if (hReadFileThread == NULL)
//	hReadFileThread = _beginthreadex(NULL, 0, ReadFileThread, 0, 0, &idThread8);
//goto usbend;
//
		DeviceIoControl(hUSBFile, IOCTL_GARMIN_USB_BULK_OUT_PACKET_SIZE, 0, 0, USBBuf, USB_INTERRUPT_DATA_SIZE, &dwBytesReturned, &ol);
		BulkOutPacketSize = *(DWORD*)&USBBuf[0];

		if (hDeviceThread == NULL)
			hDeviceThread = _beginthreadex(NULL, 0, DeviceThread, 0, 0, &idThread5);
		else
			MessageBox(hwnd, "Thread already running!", ERROR, MB_OK);

		for (x = 0; x < PACKETSIZE; x++)
			Packet[x] = 0;
		Packet[4] = 5;//Start Session
		dwBytesToSend = 12;
		SendPacket(dwBytesToSend);

		if (WAIT_TIMEOUT == WaitForSingleObject(hEvent0, 1000))
		{
			MessageBox(hwnd, "Timed out waiting for hEvent0", NULL, MB_OK);
			goto usbend;
		}
		if (USBBuf[4] == 6)
		{
			Packet[0] = 0x14;
			Packet[4] = 0xFE;//Pid_Product_Rqst
			Packet[8] = 2;
			dwBytesToSend = 14;
			SendPacket(dwBytesToSend);

			if (WAIT_TIMEOUT == WaitForSingleObject(hEvent1, 3000))
			{
				MessageBox(hwnd, "Timed out waiting for hEvent1", NULL, MB_OK);
				goto usbend;
			}
			gotFF = gotFD = FALSE;
			for (ptr = 0; ptr < USBptr; ptr++)
			{
				if (FromUSBBuf[ptr] == 0x14)
				{
					if((*(WORD*)&FromUSBBuf[ptr+4] == 0xFF) && (gotFF == FALSE))
					{
						gotFF = TRUE;
						Product_DataSize = *(int*)&FromUSBBuf[ptr+8];
						for (x = 0, y = 12; x < Product_DataSize; x++, y++)
							Product_Data[x] = FromUSBBuf[ptr+y];
					}
					else if ((*(WORD*)&FromUSBBuf[ptr+4] == 0xFD) && (gotFD == FALSE))
					{
						gotFD = TRUE;
						Protocol_ArraySize = *(int*)&FromUSBBuf[ptr+8];;
						for (x = 0, y = 12; x < Protocol_ArraySize; x++, y++)
							Protocol_Array[x] = FromUSBBuf[ptr+y];
					}
				}
				if ((gotFF) && (gotFD))
					break;
			}
			for (x = 0, y = 0, z = 0; y < Protocol_ArraySize; x += 3, y++)
			{
				if (Protocol_Array[x] == 'D')
				{
					Protocols[z++] = *(WORD*)&Protocol_Array[x+1];
					if (z > 50)
						break;
				}
			}
			for (x = 0; x < z; x++)
			{
				if (Protocols[x] < 200)
				{
					WaypointType = Protocols[x];
					switch(WaypointType)
					{
					case 108:
						Noffset = 24;
						Eoffset = 28;
						ElevOffset = 32;
						IdentOffset = 48;
						SymOffset = 4;
						WaypointProt = 108;
						break;
					case 109:
						Noffset = 24;
						Eoffset = 28;
						ElevOffset = 32;
						IdentOffset = 52;
						SymOffset = 4;
						WaypointProt = 109;
						break;
					case 110:
						Noffset = 24;
						Eoffset = 28;
						ElevOffset = 32;
						IdentOffset = 62;
						SymOffset = 4;
						WaypointProt = 110;
						break;
//					default://got a d120, which is definitely unknown, but harmless
//						MessageBox(hwnd, "Unknown waypoint type!\nWaypoints will be a mess!", NULL, MB_OK);
					}
				}
				else if (Protocols[x] == 300)
				{
					TrackType = 300;
					d300 = TRUE;
				}
				else if (Protocols[x] == 301)
				{
					TrackType = 301;
					d301 = TRUE;
				}
				else if (Protocols[x] == 302)
				{
					TrackType = 302;
					d302 = TRUE;
				}
				else if ((Protocols[x] >= 310) && (Protocols[x] <= 312))
					TrackHeaderType = Protocols[x];
			}

			if (TransmitType == SENDROUTE)
			{
//				TerminateThread((HANDLE)hDeviceThread, 0);
//				CloseHandle((HANDLE)hDeviceThread);
//				hDeviceThread = NULL;
				if (FALSE != GetOpenFileName(&ofn3))
				{
					hFile3 = CreateFile(FullRoutes, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile3 != INVALID_HANDLE_VALUE)
					{
						if (fileSize = GetFileSize(hFile3, NULL))
						{
							sendingroute = TRUE;
							pRoutes = (char*)malloc(fileSize);
							ReadFile(hFile3, pRoutes, fileSize, &dwBytesRead, NULL);
							CloseHandle(hFile3);
							if ((pRoutes[2] == ',') && (pRoutes[10] == ',') && (pRoutes[17] == '\r'))
							{
								for (x = 0, y = 0; (y < (int)fileSize) && (x < 300); x++)
								{
									Root[0][x].Z = ((pRoutes[y] - '0') * TEN) + (pRoutes[y+1] - '0');
									y += 3;//past ,
									Root[0][x].N = (((pRoutes[y] - '0') * MILLION)
									 + ((pRoutes[y+1] - '0') * HUNDREDTHOUSAND)
									 + ((pRoutes[y+2] - '0') * TENTHOUSAND)
									 + ((pRoutes[y+3] - '0') * THOUSAND)
									 + ((pRoutes[y+4] - '0') * HUNDRED)
									 + ((pRoutes[y+5] - '0') * TEN)
									 + (pRoutes[y+6] - '0'));
									y += 8;//past ,
									Root[0][x].E = (((pRoutes[y] - '0') * HUNDREDTHOUSAND)
									 + ((pRoutes[y+1] - '0') * TENTHOUSAND)
									 + ((pRoutes[y+2] - '0') * THOUSAND)
									 + ((pRoutes[y+3] - '0') * HUNDRED)
									 + ((pRoutes[y+4] - '0') * TEN)
									 + (pRoutes[y+5] - '0'));
									y += 8;//to next line
								}
							}
							else
							{
								MessageBox(hwnd, NotRoute, NULL, MB_OK);
								free(pRoutes);
								goto usbend;
							}
							numofRoutes = x;
							Root[0][x].Z = 0;
							free(pRoutes);
							for (x = 0; (Routes[x] != '.') && (Routes[x] != 0); x++)
							{
								RootName[0][x] = Routes[x];
								if ((RootName[0][x] >= 'a') && (RootName[0][x] <= 'z'))
									RootName[0][x] &= 0xDF;
							}
							RootName[0][x] = 0;
							Packet[0] = 0x14;
							Packet[4] = 0x1B;//Pid_Records
							Packet[8] = 2;
							*(WORD*)&Packet[12] = numofRoutes;
							dwBytesToSend = 14;
							SendPacket(dwBytesToSend);

							Packet[4] = 0x1D;//Pid_Rte_Hdr
							x = 12;
							for (y = 0; RootName[0][y] != 0; x++, y++)
								Packet[x] = RootName[0][y];
							Packet[x] = 0;
							Packet[8] = x - 11;
							dwBytesToSend = x+12;
							SendPacket(dwBytesToSend);

							for (TrackNum = 0; TrackNum < numofRoutes; TrackNum++)
							{
								Packet[0] = 0x14;
								Packet[4] = 0x1E;//Pid_Rte_Wpt_Data
								GetRandomNum();
								PrepRoute();
								Sleep(100);//for a different random number
								for (x = 0, y = 12; x < SendWaypointSize; x++, y++)
									Packet[y] = Waypoint[x];
								Packet[8] = SendWaypointSize;
								TotalBytesToSend = SendWaypointSize + 12;
								while (TotalBytesToSend >= 64)
								{
									dwBytesToSend = 64;
									SendPacket(dwBytesToSend);
									TotalBytesToSend -= 64;
									PacketPtr += 64;
								}
								dwBytesToSend = TotalBytesToSend;
								SendPacket(dwBytesToSend);
								PacketPtr = 0;
								for (x = 0, y = 12; x < 21; x++, y++)
									Packet[y] = RouteLink[x];
								Packet[4] = 0x62;//Pid_Rte_Link_Dta
								*(DWORD*)&Packet[8] = 21;
								dwBytesToSend = 21+12;
								SendPacket(dwBytesToSend);
								PacketPtr = 0;
							}

							Packet[4] = 0x0C;//Pid_Xfer_Cmplt
							*(DWORD*)&Packet[8] = 2;
							*(WORD*)&Packet[12] = 0;
							dwBytesToSend = 14;
							SendPacket(dwBytesToSend);
							sendingroute = FALSE;
						}
						else
						{
							MessageBox(hwnd, "is empty.", Routes, MB_OK);
							CloseHandle(hFile3);
							free(pRoutes);
							goto usbend;
						}
					}
				}
			}

			else if (TransmitType == SENDWAYPOINTS)
			{
//				TerminateThread((HANDLE)hDeviceThread, 0);
//				CloseHandle((HANDLE)hDeviceThread);
//				hDeviceThread = NULL;
				Packet[0] = 0x14;
				Packet[4] = 0x1B;//Pid_Records
				Packet[8] = 2;
				if (FALSE == onewaypoint)
					*(WORD*)&Packet[12] = EmptyLoc;
				else
					*(WORD*)&Packet[12] = 1;
				dwBytesToSend = 14;
				SendPacket(dwBytesToSend);
				Packet[4] = 0x23;//Pid_Wpt_Data
				if (FALSE == onewaypoint)
				{
					for (LocNum = 0; LocNum < EmptyLoc; LocNum++)
					{
						PrepWaypoint();
						Packet[8] = SendWaypointSize;
						for (y = 0, z = 12; y < SendWaypointSize; y++, z++)
							Packet[z] = Waypoint[y];
						TotalBytesToSend = SendWaypointSize + 12;
						while (TotalBytesToSend >= 64)
						{
							dwBytesToSend = 64;
							SendPacket(dwBytesToSend);
							TotalBytesToSend -= 64;
							PacketPtr += 64;
							Packets++;
							if (0 == Packets % 50)
								ShowPackets();
						}
						dwBytesToSend = TotalBytesToSend;
						SendPacket(dwBytesToSend);
						PacketPtr = 0;
						Packets++;
						if (0 == Packets % 50)
							ShowPackets();
					}
				}
				else
				{
					onewaypoint = FALSE;
					LocNum = ChosenLoc;
					PrepWaypoint();
					Packet[8] = SendWaypointSize;
					for (y = 0, z = 12; y < SendWaypointSize; y++, z++)
						Packet[z] = Waypoint[y];
					TotalBytesToSend = SendWaypointSize + 12;
					while (TotalBytesToSend >= 64)
					{
						dwBytesToSend = 64;
						SendPacket(dwBytesToSend);
						TotalBytesToSend -= 64;
						PacketPtr += 64;
						Packets++;
						if (0 == Packets % 50)
							ShowPackets();
					}
					dwBytesToSend = TotalBytesToSend;
					SendPacket(dwBytesToSend);
					PacketPtr = 0;
					Packets++;
					if (0 == Packets % 50)
						ShowPackets();
				}
				Packet[4] = 0x0C;//Pid_Xfer_Cmplt
				*(DWORD*)&Packet[8] = 2;
				*(WORD*)&Packet[12] = 0;
				dwBytesToSend = 14;
				SendPacket(dwBytesToSend);
			}

			else if (TransmitType == SENDTRACKS)
			{
//				TerminateThread((HANDLE)hDeviceThread, 0);
//				CloseHandle((HANDLE)hDeviceThread);
//				hDeviceThread = NULL;
				ofn.lpstrInitialDir = CurrentTrackDir;
				if (FALSE != GetOpenFileName(&ofn))
				{
					hFile3 = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
					if (hFile3 != INVALID_HANDLE_VALUE)
					{
						if (fileSize = GetFileSize(hFile3, NULL))
						{
							ReadFile(hFile3, Trackid, 100, &dwBytesRead, NULL);
							SetFilePointer(hFile3, 0, 0, FILE_BEGIN);
							if ((Trackid[0] == 'T') && (Trackid[1] == 'r') && (Trackid[2] == 'a') && (Trackid[3] == 'c'))
							{
								for (x = 0, trackcommas = 0; (Trackid[x] != '\r') && (x < 100); x++)
									if (Trackid[x] == ',')
										trackcommas++;
								firsttrack = x+2;
								pTrackBuf = (unsigned char*)malloc(fileSize);
								ReadFile(hFile3, pTrackBuf, fileSize, &dwBytesRead, NULL);
								numofTracks = ReadTracks(fileSize);
								free(pTrackBuf);
								pTrackBuf = NULL;

								if (numofTracks)
								{
									Packet[0] = 0x14;
									Packet[4] = 0x1B;//Pid_Records
									Packet[8] = 2;
									*(WORD*)&Packet[12] = numofTracks;
									dwBytesToSend = 14;
									SendPacket(dwBytesToSend);

									Packet[4] = 0x63;//Pid_Trk_Hdr
									x = 12;
									if ((TrackHeaderType == 310) || (TrackHeaderType == 312))
									{
										Packet[x++] = 1;
										Packet[x++] = 0xFF;
										for (y = 0; ActiveLog[y] != 0; x++, y++)
											Packet[x] = ActiveLog[y];
										Packet[x] = 0;
									}
									else if (TrackHeaderType == 311)
									{
										Packet[x++] = Tracks[0] ^ Tracks[3];
										Packet[x] = Tracks[1] ^ Tracks[4];
									}
									Packet[8] = x - 11;
									dwBytesToSend = x;
									SendPacket(dwBytesToSend);

									Packet[4] = 0x22;//Pid_Trk_Data
									for (TrackNum = 0; TrackNum < numofTracks; TrackNum++)
									{
										TrackSize = PrepTrack();//get SendTrack here
										Packet[8] = TrackSize;
										for (y = 0, z = 12; y < TrackSize; y++, z++)
											Packet[z] = SendTrack[y];
										TotalBytesToSend = TrackSize + 12;
										while (TotalBytesToSend >= 64)
										{
											dwBytesToSend = 64;
											SendPacket(dwBytesToSend);
											TotalBytesToSend -= 64;
											PacketPtr += 64;
											Packets++;
											if (0 == Packets % 50)
												ShowPackets();
										}
										dwBytesToSend = TotalBytesToSend;
										SendPacket(dwBytesToSend);
										PacketPtr = 0;
										Packets++;
										if (0 == Packets % 50)
											ShowPackets();
									}
									Packet[4] = 0x0C;//Pid_Xfer_Cmplt
									Packet[8] = 2;
									*(WORD*)&Packet[12] = 0;
									dwBytesToSend = 14;
									SendPacket(dwBytesToSend);
								}
								else
									MessageBox(hwnd, "Track file was empty", ERROR, MB_OK);
							}
							else
								MessageBox(hwnd, "That's not the current Track file format", NULL, MB_OK);
						}
						CloseHandle(hFile3);
					}
				}
				ofn.lpstrInitialDir = CurrentDir;

			}

			else if (TransmitType == GETTRACKS)
			{
				trackcommas = 10;
				Packet[0] = 0x14;
				Packet[4] = 0x0A;//Pid_Command_Data
				*(DWORD*)&Packet[8] = 2;
				*(WORD*)&Packet[12] = 6;//Cmnd_Transfer_Trk
				dwBytesToSend = 14;
				SendPacket(dwBytesToSend);
				if (WAIT_TIMEOUT == WaitForSingleObject(hEvent2, 30000))
				{
					MessageBox(hwnd, TimedOut, NULL, MB_OK);
					goto usbend;
				}
			}
			else if (TransmitType == GETWAYPOINTS)
			{
				Packet[4] = 0x0A;//Pid_Command_Data
				*(DWORD*)&Packet[8] = 2;
				*(WORD*)&Packet[12] = 7;//Cmnd_Transfer_Wpt
				dwBytesToSend = 14;
				SendPacket(dwBytesToSend);
				if (WAIT_TIMEOUT == WaitForSingleObject(hEvent2, 30000))
				{
					MessageBox(hwnd, TimedOut, NULL, MB_OK);
					goto usbend;
				}
			}
			else if (TransmitType == RECEIVEROUTE)
			{
				for (y = 0; y < 50; y++)
				{
					for (x = 0; x < 300; x++)
						Root[y][x].Z = 0;
				}
				Packet[4] = 0x0A;//Pid_Command_Data
				*(DWORD*)&Packet[8] = 2;
				*(WORD*)&Packet[12] = 4;//Cmnd_Transfer_Rte
				dwBytesToSend = 14;
				SendPacket(dwBytesToSend);
				if (WAIT_TIMEOUT == WaitForSingleObject(hEvent2, 30000))
				{
					MessageBox(hwnd, TimedOut, NULL, MB_OK);
					goto usbend;
				}
			}
			else if (TransmitType == STARTPVT)
			{//Positioning
				USBdownloading = TRUE;
				PvtBegin = 0xFFFFFFFF - 76;
				Packet[4] = 0x0A;//Pid_Command_Data
				*(DWORD*)&Packet[8] = 2;
				*(WORD*)&Packet[12] = 0x31;//Cmnd_Start_Pvt_Data
				dwBytesToSend = 14;
				SendPacket(dwBytesToSend);

				WaitForSingleObject(hEvent3, INFINITE);//wait for hEvent3 to be signaled
				SetEvent(hUSBEvent);//for SignalUSBStop
				if (pos)
				{
					SavePosition();
				}
			}
//*****************************************************
			if ((TransmitType == GETWAYPOINTS) || (TransmitType == GETTRACKS) || TransmitType == RECEIVEROUTE)
			{
				for (tnum = 0, PrevTnum = 0; ptr < USBptr; ptr++)
				{
					if (*(int*)&FromUSBBuf[ptr]== 0x14)
					{
						if (*(int*)&FromUSBBuf[ptr+4] == 0x63)//Pid_Trk_Hdr
						{
							if ((TrackHeaderType == 310) || (TrackHeaderType == 312))
							{
								if (tnum != 0)//save tracks to name in TrackHeader after those tracks downloaded
									SaveDownloadedTracks();
								for (x = 0, y = ptr+14; FromUSBBuf[y] != 0; x++, y++)
									Tracks[x] = FromUSBBuf[y];
								for (y = 0; y < 5; x++, y++)
									Tracks[x] = Csv[y];
checkitagain:					for (x = 0; CurrentTrackDir[x] != 0; x++)
									FullTracks[x] = CurrentTrackDir[x];
								for (y = 0; Tracks[y] != 0; x++, y++)
									FullTracks[x] = Tracks[y];
								FullTracks[x] = 0;
//checkitagain:
//								FindFirstFile(Tracks, &fd);
//								if (0 == _stricmp(fd.cFileName, Tracks))
								if (INVALID_HANDLE_VALUE != FindFirstFile(FullTracks, &fd))
								{
									InvalidateRect(hwnd, &rect, FALSE);
									if (IDYES == MessageBox(hwnd, "...already exists.\nWrite this data to a new file?",Tracks, MB_YESNO))
									{
										x = DialogBox(hInst, "GETFILENAME", hwnd, GetFilenameProc);
										if (x)
										{
											for (x = 0; Tracks[x] != 0; x++)
												;
											for (y = x; (Tracks[y] != '.') && (y > 0); y--)
												;
											if (y == 0)//no '.'
												for (y = 0; y < 5; x++, y++)
													Tracks[x] = Csv[y];
											else if (((Tracks[y+1] & 0xDF) != 'C') || ((Tracks[y+2] & 0xDF)  != 'S') || ((Tracks[y+3] & 0xDF)  != 'V'))
												for (x = y, y = 0; y < 5; x++, y++)
													Tracks[x] = Csv[y];
											goto checkitagain;
										}
 										else
											MessageBox(hwnd, Overwrite, Tracks, MB_OK);
									}
 									else
										MessageBox(hwnd, Overwrite, Tracks, MB_OK);
								}
								else
								{
//									for (x = 0; Tracks[x] != 0; x++)
//										if (Tracks[x] == '.')
//											break;
//									if (Tracks[x] == 0)
//									{
//										for (y = 0; y < 5; x++, y++)
//											Tracks[x] = Csv[y];
//									}
									MessageBox(hwnd, Tracks, "Writing:", MB_OK);
								}
								for (x = 0; CurrentTrackDir[x] != 0; x++)//this is necessary if GetFilenameProc gets different Tracks name
									FullTracks[x] = CurrentTrackDir[x];
								for (y = 0; Tracks[y] != 0; x++, y++)
									FullTracks[x] = Tracks[y];
								FullTracks[x] = 0;
							}
						}//end of if (*(int*)&FromUSBBuf[ptr+4] == 0x63)//Pid_Trk_Hdr
						else if (*(int*)&FromUSBBuf[ptr+4] == 0x22)//Pid_Trk_Data
						{
							trak[tnum].NUTM = *(signed int*)&FromUSBBuf[ptr+12];//Semicircle_Type//wxyz
							trak[tnum].EUTM = *(signed int*)&FromUSBBuf[ptr+16];//Semicircle_Type
							trak[tnum].time = *(unsigned int*)&FromUSBBuf[ptr+20];
							if (TrackType == 300)
								trak[tnum].newtrk = *(unsigned char*)&FromUSBBuf[ptr+24];
							else if (TrackType == 301)
							{
//								f = *(float*)&FromUSBBuf[ptr+24];
//								if (f != 1.0e25)
								if (*(UINT*)&FromUSBBuf[ptr+24] != 0x69045951)
								{
									f = *(float*)&FromUSBBuf[ptr+24];
									f /= (float)0.3048;//convert meters to feet
									trak[tnum].alt = f;
								}
								else
									trak[tnum].alt = 0;
								trak[tnum].newtrk = *(unsigned char*)&FromUSBBuf[ptr+32];
							}
							else if (TrackType == 302)
							{
//								f = *(float*)&FromUSBBuf[ptr+24];
//								if (f != 1.0e25)
								if (*(UINT*)&FromUSBBuf[ptr+24] != 0x69045951)
								{
									f = *(float*)&FromUSBBuf[ptr+24];
									f /= (float)0.3048;//convert meters to feet
									trak[tnum].alt = f;
								}
								else
									trak[tnum].alt = 0;
								trak[tnum].newtrk = *(unsigned char*)&FromUSBBuf[ptr+36];
							}
							tnum++;
						}

						else if (*(int*)&FromUSBBuf[ptr+4] == 0x23)//Pid_Wpt_Data
						{
							for (x = 0, y = ptr+12, z = *(int*)&FromUSBBuf[ptr+8]; x < z; x++, y++)
								ReceivedData[x] = FromUSBBuf[y];
							if (EmptyLoc < TOTAL_LOCS)
								SaveDownloadedWaypoints();
						}

						else if (*(int*)&FromUSBBuf[ptr+4] == 0x1D)//Pid_Rte_Hdr
						{
							y = ptr+12;//presumes d202
							for (x = 0, z = *(int*)&FromUSBBuf[ptr+8]; (x < z) && (x < 100); x++, y++)
								RootName[r][x] = FromUSBBuf[y];
							RootName[r][x-1] = '.';//was 0
							RootName[r][x++] = 't';
							RootName[r][x++] = 'x';
							RootName[r][x++] = 't';
							RootName[r][x] = 0;
							gettingroute = TRUE;
							hRoute[r] = CreateFile(RootName[r], GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
							r++;
						}

						else if (*(int*)&FromUSBBuf[ptr+4] == 0x1E)//Pid_Rte_Wpt_Data
						{
							for (x = 0, y = ptr+12, z = *(int*)&FromUSBBuf[ptr+8]; x < z; x++, y++)
								ReceivedData[x] = FromUSBBuf[y];
							semicircleN = *(signed int*)&ReceivedData[Noffset];
							semicircleE = *(signed int*)&ReceivedData[Eoffset];
							Lat = (double) (semicircleN * semicircle2deg);
							Lon = (double) (semicircleE * semicircle2deg);
							LatRad = (double) (semicircleN * semicircle2rad);
							LonRad = (double) (semicircleE * semicircle2rad);
							LatLontoUTM();

							y = 0;
							Raut[y++] = (UTMZone / 10) + '0';
							Raut[y++] = (UTMZone % 10) + '0';
							Raut[y++] = ',';
							_itoa(UTMNorthing, RouteDist, 10);
							for (x = 0; RouteDist[x] != 0; x++, y++)
								Raut[y] = RouteDist[x];
							Raut[y++] = ',';
							_itoa(UTMEasting, RouteDist, 10);
							for (x = 0; RouteDist[x] != 0; x++, y++)
								Raut[y] = RouteDist[x];
							Raut[y++] = '\r';
							Raut[y++] = '\n';
							WriteFile(hRoute[r-1], Raut, y, &dwBytesWritten, NULL);
						}
					}
				}//end of for
				if (TransmitType == GETTRACKS)
				{
					SaveDownloadedTracks();
				}
/*
				if (gettingroute)
				{
					gettingroute = FALSE;
					for (y = 0; y < r; y++)
					{
						hFile = CreateFile(RootName[y], GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
						for (x = 0; Root[y][x].Z != 0; x++)
						{
							z = sprintf(Error, "%i,%i,%i\r\n", Root[y][x].Z, Root[y][x].N, Root[y][x].E);
							WriteFile(hFile, Error, z, &dwBytesWritten, NULL);
						}
						CloseHandle(hFile);
						MessageBox(hwnd, "has been written.", RootName[y], MB_OK);
					}
				}
*/
			}
		}
		else
		MessageBox(NULL, "Session didn't start.", NULL, MB_OK);
	}
	else
	{
		x = GetLastError();//259 = NO MORE ITEMS
		MessageBox(NULL, "Your USB Garmin\ndoesn't seem to be attached.", NULL, MB_OK);
		fromFlag = MENU;//for ID_STOPPOSITIONING
		SendMessage(hwnd, WM_COMMAND, ID_STOPPOSITIONING, 0);
	}
usbend:
	for (x = 0; (x < r) && (x < 50); x++)
	{
		if (hRoute[x])
		{
			CloseHandle(hRoute[x]);
			hRoute[x] = NULL;
		}
	}
	hUSB = CreateFile(USBdta, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	WriteFile(hUSB, FromUSBBuf, USBptr, &dwBytesWritten, NULL);
	CloseHandle(hUSB);

	if (hUSBFile != NULL)
		CloseHandle(hUSBFile);
	if (DevDetailData != 0)
		free(DevDetailData);
	SetupDiDestroyDeviceInfoList(DevInfo);
	if (hDeviceThread != NULL)
	{
		TerminateThread((HANDLE)hDeviceThread, 0);
		CloseHandle((HANDLE)hDeviceThread);
		hDeviceThread = NULL;
	}
	if (hReadFileThread != NULL)
	{
		TerminateThread((HANDLE)hReadFileThread, 0);
		CloseHandle((HANDLE)hReadFileThread);
		hReadFileThread = NULL;
	}
	CloseHandle(hEvent0);
	CloseHandle(hEvent1);
	CloseHandle(hEvent2);
	CloseHandle(hEvent3);
	CloseHandle(ol.hEvent);
	CloseHandle(ol2.hEvent);
	CloseHandle(ol3.hEvent);
	CloseHandle((HANDLE)hUSBThread);
	hUSBThread = 0;
	VirtualFree(FromUSBBuf, 0, MEM_RELEASE);
	InvalidateRect(hwnd, &rect, FALSE);
	return 0;
}//end of USBThread



void SaveDownloadedTracks(void)
{

	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;
	gettingtracks = FALSE;
	trak[tnum].time = 0;
	hFile = CreateFile(FullTracks, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	WriteFile(hFile, TrackHead, strlen(TrackHead), &dwBytesWritten, NULL);
	for (x = PrevTnum; x < tnum; x++)
	{
		Lat = (double)trak[x].NUTM * semicircle2deg;//wxyz
		Lon = (double)trak[x].EUTM * semicircle2deg;
		LatRad = (double)trak[x].NUTM * semicircle2rad;
		LonRad = (double)trak[x].EUTM * semicircle2rad;
		LatLontoUTM();
		trak[x].NUTM = UTMNorthing;
		trak[x].EUTM = UTMEasting;
		if ((trak[x].time != 0) && (trak[x].time != 0xFFFFFFFF))
		{
			quad = (_int64) trak[x].time;//seconds since 00:00am Dec 31, 1989
			quad *= 10000000;//* 100 nanoseconds for FILETIME format
			li.LowPart = 4000088064;//pre-computed for 00:00am Dec 31, 1989
			li.HighPart = 28581216;//ditto
			li.QuadPart += quad;
			ft = *(FILETIME *) &li;
			FileTimeToSystemTime(&ft, &st);//get time & date from trak.time
//UTMZone, mon, day, hour, min, sec
//     20,  12,  31,   24,  60,  60
//63       = 00000000 00000000 00000000 00111111
//63 <<  6 = 00000000 00000000 00001111 11000000
//31 << 12 = 00000000 00000001 11110000 00000000
//31 << 17 = 00000000 00111110 00000000 00000000
//15 << 22 = 00000011 11000000 00000000 00000000
//31 << 26 = 01111100 00000000 00000000 00000000
			trak[x].time = (UTMZone << 26) | (st.wMonth << 22) | (st.wDay << 17) | (st.wHour << 12) | (st.wMinute << 6) | st.wSecond;
			trak[x].year = st.wYear - 2000;
		}
		else
		{
			trak[x].time = UTMZone << 26;
			trak[x].year = 0;
		}
		WriteTracks(hFile, x);
	}
	PrevTnum = tnum;
	GetLocalTime(lpSystemTime);//back to normal
	CloseHandle(hFile);
	if ((trak[0].time != 0) && (trak[0].time != 0xFFFFFFFF))
	{
		trackUTMZone = trak[0].time >> 26;
		if (trackUTMZone == tempUTMZone)// || (x < 10))//x < 10 in old Track.dta format
		{//if first trak in current UTM zone
			BeginY = trak[0].NUTM / MetersPerTile;
			BeginX = trak[0].EUTM / MetersPerTile;
			rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
			colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
		}
			showingtracks = TRUE;
			fromTracks = TRUE;
			editingtracks = FALSE;
//			if (itsusb == FALSE)
//			{//because it gets over-written when thread closes or something
//				CreateTracks();
//				SendMessage(hwnd, WM_USER, 0, 0);
//			}
//			else
//			{//weird but necessary
				fromusbtracks = TRUE;
				SendMessage(hwnd, WM_USER, 0, 0);
//			}
//		}
	}
	else
		trackUTMZone = 0;
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
}


void SaveDownloadedWaypoints(void)
{
	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;
	semicircleN = *(signed int*)&ReceivedData[Noffset];
	semicircleE = *(signed int*)&ReceivedData[Eoffset];
	Lat = (double) (semicircleN * semicircle2deg);
	Lon = (double) (semicircleE * semicircle2deg);
	LatRad = (double) (semicircleN * semicircle2rad);
	LonRad = (double) (semicircleE * semicircle2rad);
	LatLontoUTM();
	if ((WaypointProt == 108) || (WaypointProt == 109) || (WaypointProt == 110))
	{
		u = *(UINT*)&ReceivedData[ElevOffset];
		if (u != 0x69045951)//1.0e25
		{
			f = *(float*)&ReceivedData[ElevOffset];
			sprintf(Elev, "%.4f", f);
		}
		else
			Elev[0] = 0;

		for (x = 0; ReceivedData[x+IdentOffset] != 0; x++)
			Ident[x] = ReceivedData[x+IdentOffset];
		Ident[x++] = 0;
		LocOffset = x + IdentOffset;
		x = 0;
		if (ReceivedData[LocOffset] != 0)
			for ( ; ReceivedData[x+LocOffset] != 0; x++)
				Location[x] = ReceivedData[x+LocOffset];
		Location[x] = 0;

		for (x = 0; x < EmptyLoc; x++)
		{//check for duplicate
			if (NewLoc[x].Ident != NULL)//name
			{
				for (y = 0; Ident[y] != 0; y++)
					if (NewLoc[x].Ident[y] != Ident[y])
						break;
				if (((NewLoc[x].Ident[y] == '<') || (NewLoc[x].Ident[y] == ' ')) && (Ident[y] == 0))
				{
					if (NewLoc[x].Ident[y] == '<')
						return;//don't save it
					else//if NewLoc[x].Ident[y] == ' ')
					{
						for ( ; NewLoc[x].Ident[y] != '<'; y++)
						{
							if (NewLoc[x].Ident[y] != ' ')
								break;
						}
						if (NewLoc[x].Ident[y] == '<')
							return;//don't save it
					}
				}
			}
			else if (NewLoc[x].Location != NULL)//cmt
			{
				for (y = 0; Location[y] != 0; y++)
					if (NewLoc[x].Location[y] != Location[y])
						break;
				if (((NewLoc[x].Location[y] == '<') || (NewLoc[x].Location[y] == ' ')) && (Location[y] == 0))
				{
					if (NewLoc[x].Location[y] == '<')
						return;//don't save it
					else//if NewLoc[x].Location[y] == ' ')
					{
						for ( ; NewLoc[x].Location[y] != '<'; y++)
						{
							if (NewLoc[x].Location[y] != ' ')
								break;
						}
						if (NewLoc[x].Location[y] == '<')
							return;//don't save it
					}
				}
			}
		}
	}

	else//if WaypointProt == 104, etc
	{
		for (x = 0; (x < 6) && (ReceivedData[x] != 0); x++)
			Ident[x] = ReceivedData[x];
		Ident[x] = 0;
		for (x = 0; (x < 20) && (ReceivedData[x+LocOffset] != 0); x++)
			Location[x] = ReceivedData[x+LocOffset];
		Location[x] = 0;
		for (x = 0; x < EmptyLoc; x++)
		{//check for duplicate & ignore it
			if (NewLoc[x].Ident != NULL)//name
			{
				for (y = 0; (NewLoc[x].Ident[y] == Ident[y]) && (Ident[y] != 0); y++)
					;
				if ((NewLoc[x].Ident[y] == '<') && (Ident[y] == 0))
					return;//don't save it
			}
		}
	}
	if (sortbyname)
	{
		for (x = 0; x < EmptyLoc; x++)
		{//qsort
			if ((NewLoc[x].Ident != NULL) && (strcmp(NewLoc[x].Ident, Ident) > 0))
			{
				InsertLoc = x;
				EmptyLoc++;
				for (x = EmptyLoc; x > InsertLoc; x--)
					NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
				break;
			}
		}
	}
	else
	{
		for (x = 0; x < EmptyLoc; x++)
		{//qsort
			if ((NewLoc[x].Location != NULL) && (strcmp(NewLoc[x].Location, Location) > 0))
			{
				InsertLoc = x;
				EmptyLoc++;
				for (x = EmptyLoc; x > InsertLoc; x--)
					NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
				break;
			}
		}
	}
	if (x == EmptyLoc)
	{
		InsertLoc = x;
		EmptyLoc++;
	}
	NewLoc[InsertLoc].EUTM = UTMEasting;
	NewLoc[InsertLoc].NUTM = UTMNorthing;
	NewLoc[InsertLoc].UTMZone = UTMZone;
	Sym[0] = 0;
	if (SymOffset != 0)
	{
		if (WaypointProt >= 108)
			x = *(WORD*)&ReceivedData[SymOffset];
		else
			x = *(BYTE*)&ReceivedData[SymOffset];
		GetSym(x);
	}
///--->
	FillWaypointArray(InsertLoc);
///--->
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
}

void SignalUSBStop(void)
{//stop positioning
	USBdownloading = FALSE;
	Packet[4] = 0x0A;//Pid_Command_Data
	Packet[8] = 2;
	Packet[12] = 0x32;//Cmnd_Stop_Pvt_Data
	dwBytesToSend = 14;
	SendPacket(dwBytesToSend);

	ResetEvent(hUSBEvent);//unsignal it
	if (WAIT_TIMEOUT == WaitForSingleObject(hUSBEvent, 4000))
	{//shouldn't happen because hUSBEvent should be signaled
		TerminateThread((HANDLE)hUSBThread, 1);
		MessageBeep(MB_OK);
		if (hUSBFile != NULL)
			CloseHandle(hUSBFile);
		if (hUSBThread != 0)
			CloseHandle ((HANDLE)hUSBThread);
		hUSBThread = 0;
		VirtualFree(FromUSBBuf, 0, MEM_RELEASE);
		if (pos)
		{
			SavePosition();
		}
		hUSB = CreateFile(USBdta, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		WriteFile(hUSB, FromUSBBuf, USBptr, &dwBytesWritten, NULL);
		CloseHandle(hUSB);

		if (DevDetailData != 0)
			free(DevDetailData);
		SetupDiDestroyDeviceInfoList(DevInfo);
		if (hDeviceThread != NULL)
		{
			TerminateThread((HANDLE)hDeviceThread, 0);
			CloseHandle((HANDLE)hDeviceThread);
			hDeviceThread = NULL;
		}
		CloseHandle(hEvent0);
		CloseHandle(hEvent1);
		CloseHandle(hEvent2);
		CloseHandle(hEvent3);
		CloseHandle(ol.hEvent);
		CloseHandle(ol2.hEvent);
		CloseHandle(ol3.hEvent);
	}
}

void GetDems(void)
{
	gotelevini = FALSE;
	pDemIni = NULL;
	hFile = CreateFile(ElevIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		if (DEMfileSize = GetFileSize(hFile, NULL))
		{
			gotelevini = TRUE;
			veryfirstime = TRUE;
			pDemIni = (char*) malloc(DEMfileSize);
			ReadFile(hFile, pDemIni, DEMfileSize, &dwBytesRead, NULL);
			for (x = 0, NumOfDems = 0; (NumOfDems < MAX_DEMS) && (x < (int)(DEMfileSize - 50)); NumOfDems++)
			{
				for ( ; pDemIni[x] != '='; x++)
					;
				x++;// to Zone
				Dem[NumOfDems].Zone = (pDemIni[x++] - '0') * 10;
				Dem[NumOfDems].Zone += (pDemIni[x++] - '0');
				for ( ; pDemIni[x] != '='; x++)
					;
				x += 2;//to UTMNorthing
				Dem[NumOfDems].North = ((pDemIni[x] - '0') * 1000000) + ((pDemIni[x+1] - '0') * 100000) + ((pDemIni[x+2] - '0') * 10000) + ((pDemIni[x+3] - '0') * 1000) + ((pDemIni[x+4] - '0') * 100) + ((pDemIni[x+5] - '0') * 10) + (pDemIni[x+6] - '0');
				x += 8;//past 'w'
				Dem[NumOfDems].West = ((pDemIni[x] - '0') * 100000) + ((pDemIni[x+1] - '0') * 10000) + ((pDemIni[x+2] - '0') * 1000) + ((pDemIni[x+3] - '0') * 100) + ((pDemIni[x+4] - '0') * 10) + (pDemIni[x+5] - '0');

				x += 12;//to Name
				DemNameBegin = x;
				x++;//past '=n'
				w = x;
				for ( ; (pDemIni[x] != ' ') || (pDemIni[x+1] != 'R') || (pDemIni[x+5] != '='); x++)
					;
				pDemIni[x] = 0;
				strcpy(Dem[NumOfDems].Name, &pDemIni[DemNameBegin]);
//				Dem[NumOfDems].Lat = atof(&Dem[NumOfDems].Name[1]);
//				Dem[NumOfDems].Lon = atof(&Dem[NumOfDems].Name[9]);
				pDemIni[x] = ' ';

				for ( ; pDemIni[x] != '='; x++)
					;
				x++;// to rows
				
				for (Dem[NumOfDems].Rows = 0 ; pDemIni[x] != ' '; x++)
				{
					Dem[NumOfDems].Rows *= 10;
					Dem[NumOfDems].Rows += (pDemIni[x]) - '0';
				}

				for ( ; pDemIni[x] != '='; x++)
					;
				x++;// to cols
				
				for (Dem[NumOfDems].Cols = 0 ; pDemIni[x] != ' '; x++)
				{
					Dem[NumOfDems].Cols *= 10;
					Dem[NumOfDems].Cols += (pDemIni[x]) - '0';
				}

				for ( ; pDemIni[x] != '='; x++)
					;
				x++;//to spacing
//					Dem[NumOfDems].Spacing = ((pDemIni[x] - '0') * 10) + (pDemIni[x+1] - '0');
				for ( ; pDemIni[x] != ' '; x++);
					;

				for ( ; pDemIni[x] != '='; x++);
					;
				x++;//to 'F'in FEET or 'M' in METERS
				Dem[NumOfDems].Meas = pDemIni[x];

				Dem[NumOfDems].South = Dem[NumOfDems].North - ((Dem[NumOfDems].Rows) * 30);
				Dem[NumOfDems].East = Dem[NumOfDems].West + ((Dem[NumOfDems].Cols) * 30);

				for ( ; (pDemIni[x] != 0x0A) && (x < (int)(DEMfileSize - 50)); x++)
					;//go to the end of the line
			}
			free(pDemIni);//needs to stay in memory for Dem[].Name pointer
		}
		CloseHandle (hFile);
	}
}

void SavePosition(void)
{
	int x, y;
	char Pos[60];

	if (INVALID_HANDLE_VALUE == FindFirstFile(PositionCsv, &fd))
	{
		hPosFile = CreateFile(PositionCsv, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		WriteFile(hPosFile, PositionHeader, sizeof(PositionHeader)-1, &dwBytesWritten, NULL);
	}
	else
	{
		hPosFile = CreateFile(PositionCsv, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
 		SetFilePointer(hPosFile, 0, 0, FILE_END);
	}
	y = 0;
	Pos[y++] = 'N';
	Pos[y++] = 'e';
	Pos[y++] = 'w';
	for (x = 0; x < pos; x++)
	{
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].UTMZ);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].UTMN);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].UTME);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].Hour);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].Min);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].Sec);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].Month);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].Date);
		Pos[y++] = ',';
		if (Position[x].Year != 0)
			y += sprintf(&Pos[y], "%i", Position[x].Year + 2000);
		else
			Pos[y++] = '0';
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].Alt);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].HorizEpe);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%i", Position[x].VertEpe);
		Pos[y++] = ',';
		y += sprintf(&Pos[y], "%.2f", Position[x].Velocity);
		Pos[y++] = '\r';
		Pos[y++] = '\n';
		WriteFile(hPosFile, Pos, y, &dwBytesWritten, NULL);
		y = 0;
	}
	CloseHandle(hPosFile);
	pos = 0;
//	sprintf(Error, "Written in %s:", CurrentDir);
//	MessageBox(hwnd, Error, PositionCsv, MB_OK);

}


UINT CALLBACK URLThread(PVOID pParam)
{
	THREADPARAMS ptp = *(THREADPARAMS*)pParam;
	DWORD fileSize, dwBytesRead;
	BOOL goodread;
	HINTERNET hInternet;

	SetEvent(hThreadEvent);
#ifdef onetime0
	if (onetime2 == FALSE)
	{
		onetime2 = TRUE;
		MessageBox(hwnd, "Still good...", "", MB_OK);
	}
#endif
	if (hInternet = InternetOpenUrl(hOpen, ptp.URLName, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
	{
		EnterCriticalSection(&cs);
		internetconnect = TRUE;
		LeaveCriticalSection(&cs);
		for (fileSize = 0; (goodread = InternetReadFile(hInternet, ptp.RowBufs, MAX_TILE_SIZE, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
			;
		InternetCloseHandle(hInternet);
		if (fileSize > MAX_TILE_SIZE)
		{
			MessageBox(hwnd, "fileSize > MAX_TILE_SIZE", ERROR, MB_OK);
			goodread = FALSE;
			fileSize = 0;
		}
		if ((goodread) && (dwBytesRead == 0))
		{
			EnterCriticalSection(&cs);
			RowBufSize[ptp.col] = fileSize;
			LeaveCriticalSection(&cs);
		}
		if (fileSize == 0)
		{
			EnterCriticalSection(&cs);
			RowBufSize[ptp.col] = 0;
			LeaveCriticalSection(&cs);
			hdc = GetDC(hwnd);
			MoveToEx(hdc, ptp.col*PixelsPerTile, yLoc, NULL);
			LineTo(hdc, ptp.col*PixelsPerTile + PixelsPerTile, yLoc + PixelsPerTile);
			MoveToEx(hdc, ptp.col*PixelsPerTile + PixelsPerTile, yLoc, NULL);
			LineTo(hdc, ptp.col*PixelsPerTile, yLoc + PixelsPerTile);
			ReleaseDC(hwnd, hdc);
		}
		return ptp.col;
	}
	else
	{
#ifdef onetime0
		if (onetime3 == FALSE)
		{
			onetime3 = TRUE;
			y = sprintf(Error, "URL: %s\n", ptp.URLName);
			y += sprintf(&Error[y], "%s\n", Accept);
			sprintf(&Error[y], "hOpen: %i", hOpen);
			MessageBox(hwnd, Error, "", MB_OK);
		}
#endif
		return -1;
	}
}

//							0123456789012345667890123456789
//char pointerFileName[] = "USAPhotoMapsData\\z00y00000.xxx";
//char fileName[] =        "USAPhotoMapsData\\z00y00000.xxx";//row data file
void GetFileName(void)
{
	North = ScreenTop - (yPos*MetersPerTile/PixelsPerTile);
	y = North / MetersPerTile;
	West = ScreenLeft + (xPos*MetersPerTile/PixelsPerTile);
	fileName[18] = Z[0];
	fileName[19] = Z[1];
	pointerFileName[18] = Z[0];
	pointerFileName[19] = Z[1];
	z = 21;
	if ((y / 100000) != 0)
	{
		fileName[z] = (y / 100000) + '0';
		pointerFileName[z++] = (y / 100000) + '0';
	}
	if ((y / 10000) != 0)
	{
		fileName[z] = ((y % 100000) / 10000) + '0';
		pointerFileName[z++] = ((y % 100000) / 10000) + '0';
	}
	if ((y / 1000) != 0)
	{
		fileName[z] = ((y % 10000) / 1000) + '0';
		pointerFileName[z++] = ((y % 10000) / 1000) + '0';
	}
	fileName[z] = ((y % 1000) / 100) + '0';
	pointerFileName[z++] = ((y % 1000) / 100) + '0';
	fileName[z] = ((y % 100) / 10) + '0';
	pointerFileName[z++] = ((y % 100) / 10) + '0';
	fileName[z] = (y % 10) + '0';
	pointerFileName[z++] = (y % 10) + '0';
}

void CreateTracks(void)
{
	hwndTrack = CreateWindow("EDIT", Tracks,
		WS_CHILD | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | ES_MULTILINE,
		0, 0, 300, 240,
		hwnd, (HMENU)178, hInst, NULL);
	pTrackProc = (WNDPROC)SetWindowLong(hwndTrack, GWL_WNDPROC, (LONG)TrackProc);//sub-class for WM_DESTROYWINDOW
	SendMessage(hwndTrack, EM_SETREADONLY, 1, 0);
	SetWindowText(hwndTrack, Trac);

	hwndButton2 = CreateWindow("BUTTON", "Goto &Beginning of Tracks",
		WS_CHILD | WS_VISIBLE,
		0, 110, 160, 25,
		hwndTrack, (HMENU)92, hInst, NULL);
	hdcButton = GetDC(hwndButton2);
	hFont = CreateFontIndirect (&lf2);
	SelectObject(hdcButton, hFont);
	ReleaseDC(hwndButton2, hdcButton);
	SendMessage(hwndButton2, WM_SETFONT, (UINT)hFont, TRUE);

	hwndButton = CreateWindow("BUTTON", "&Edit Tracks",
		WS_CHILD | WS_VISIBLE,
		0, 135, 85, 25,
		hwndTrack, (HMENU)93, hInst, NULL);
	hdcButton = GetDC(hwndButton);
	hFont = CreateFontIndirect (&lf2);
	SelectObject(hdcButton, hFont);
	ReleaseDC(hwndButton, hdcButton);
	SendMessage(hwndButton, WM_SETFONT, (UINT)hFont, TRUE);
}

void UncheckZoom(void)
{
	UINT param;

	switch (Zoom)
	{
	case 1:
		param = ID_ZOOM_1METERPIXEL;
		break;
	case 2:
		param = ID_ZOOM_2METERSPIXEL;
		break;
	case 3:
		param = ID_ZOOM_4METERSPIXEL;
		break;
	case 4:
		param = ID_ZOOM_8METERSPIXEL;
		break;
	case 5:
		param = ID_ZOOM_BIG8METERSPIXEL;
		break;
	case 6:
		param = ID_ZOOM_16METERSPIXEL;
		break;
	case 7:
		param = ID_ZOOM_32METERSPIXEL;
		break;
	case 8:
		param = ID_ZOOM_64METERSPIXEL;
		break;
	}
	CheckMenuItem(hMenu, param, MF_UNCHECKED);
}

//char ZonePath[] = "\\States\\??.dta";
//char PtrPath[] = "\\States\\??.ptr";
BOOL GetUSGSData(void)
{
	lf5.lfEscapement = 0;
	lf5.lfOrientation = 0;
	ZonePath[8] = PtrPath[8] = (UTMZone / 10) + '0';
	ZonePath[9] = PtrPath[9] = (UTMZone % 10) + '0';
	for (x = 0; CurrentDir[x] != 0; x++)
		USGSFile[x] = PtrFile[x] = CurrentDir[x];
	for (y = 0; ZonePath[y] != 0; x++, y++)
	{
		USGSFile[x] = ZonePath[y];
		PtrFile[x] = PtrPath[y];
	}
	USGSFile[x] = PtrFile[x] = 0;
	if ((INVALID_HANDLE_VALUE != FindFirstFile(USGSFile, &fd)) && (INVALID_HANDLE_VALUE != FindFirstFile(PtrFile, &fd)))
	{
		hUSGSFile = CreateFile(USGSFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		hPtrFile = CreateFile(PtrFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		USGSfileSize = GetFileSize(hUSGSFile, NULL);
		fileSize2 = GetFileSize(hPtrFile, NULL);
		if ((USGSfileSize) && (fileSize2))
		{
			CheckMenuItem(hMenu, ID_VIEW_SHOWUSGSLANDMARKS, MF_CHECKED);
			USGSBuf = (char*)VirtualAlloc(NULL, USGSfileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			ReadFile(hUSGSFile, USGSBuf, USGSfileSize, &dwBytesRead, NULL);
			NumOfPtrs = fileSize2 / sizeof(Ptr10);
			PtrBuf = (struct Ptr10*)VirtualAlloc(NULL, fileSize2, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			ReadFile(hPtrFile, PtrBuf, fileSize2, &dwBytesRead, NULL);
		}
		CloseHandle(hPtrFile);
		CloseHandle(hUSGSFile);
	}
	else
	{
		char *UTMSizes[18] = {"51 KB","137 KB","115 KB","78 KB","30 KB","69 KB","17 KB","1.4 MB","1.6 MB","1.7 MB","1.6 MB","1.5 MB","2.9 MB","4.8 MB","4.5 MB","2.1 MB","844 KB","19 KB"};
		char GetZones1[] = "Do you want to download USGS data files\n";
		char Zone[] = "xx.dta and xx.ptr (";
		char GetZones2[] = ") from jdmcox.com?";

		Zone[0] = Zone[11] = (UTMZone / 10) + '0';
		Zone[1] = Zone[12] = (UTMZone % 10) + '0';
		sprintf(Error, "%s%s%s%s", GetZones1, Zone, UTMSizes[UTMZone-3], GetZones2);
		if (IDOK == MessageBox(hwnd, Error, "FIRST", MB_OKCANCEL))
			hDownloadUTMThread = _beginthreadex(NULL, 0, DownloadUTMThread, hwnd, 0, &idThread11);
		return FALSE;
	}
	return TRUE;
}

int NSWEelevs(int zN, int zE)
{
	elevN = nw + ((ne-nw)*(zE-nwE)/(nwE-neE));
	elevS = sw + ((se-sw)*(zE-swE)/(swE-seE));
	elevW = nw + ((sw-nw)*(zN-nwN)/(swN-nwN));
	elevE = ne + ((se-ne)*(zN-neN)/(seN-neN));
	elevNS = elevN + ((elevS-elevN)*(zN-nwN)/(swN-nwN));
	elevEW = elevW + ((elevE-elevW)*(zE-nwE)/(neE-nwE));
	if (elevNS > elevEW)
		return ((elevNS - elevEW) / 2) + elevEW;
	else
		return ((elevEW - elevNS) / 2) + elevNS;
}

DWORD ConvertBILData(void)
{
	BYTE blwBuf[1024];
	BYTE hdrBuf[1024];
	BYTE Datasize = 0;
	char blw[] = "blw\0";
	char blwFile[MAX_PATH];// = "NED_46542986.blw";
	char hdr[] = "hdr\0";
	char hdrFile[MAX_PATH];// = "NED_46542986.hdr";

	bilrows = bilcols = 0;
	ExitCode = 1;
	ofn5.lpstrFilter = "*.bil\0""*.bil\0\0";
	ofn5.lpstrFile = ElevationFile;//full filename
	ofn5.lpstrFileTitle = ShortElevationFile;
	ofn5.Flags = OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
	ofn5.lpstrTitle = NULL;//title bar
	ofn5.lpstrDefExt = "bil";
	if (FALSE != GetOpenFileName(&ofn5))
	{
		strcpy(blwFile, ElevationFile);
		strcpy(hdrFile, ElevationFile);
		for (x = ofn5.nFileExtension, y = 0; y < 4; x++, y++)
		{
			blwFile[x] = blw[y];
			hdrFile[x] = hdr[y];
		}

		hFile = CreateFile(hdrFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (INVALID_HANDLE_VALUE != hFile)
		{
			DWORD fileSize2 = GetFileSize(hFile, NULL);
			if (fileSize2)
			{
				ReadFile(hFile, hdrBuf, fileSize2, &dwBytesRead, NULL) ;
				for (x = 0; x < (int)fileSize2; x++)
				{
					if ((hdrBuf[x] == 'N') && (hdrBuf[x+1] == 'R') && (hdrBuf[x+2] == 'O') && (hdrBuf[x+3] == 'W') && (hdrBuf[x+4] == 'S'))
					{
						for (x += 5; hdrBuf[x] == ' '; x++)
							;
						bilrows = Atoi((char*)&hdrBuf[x]);
					}
					if ((hdrBuf[x] == 'N') && (hdrBuf[x+1] == 'C') && (hdrBuf[x+2] == 'O') && (hdrBuf[x+3] == 'L') && (hdrBuf[x+4] == 'S'))
					{
						for (x += 5; hdrBuf[x] == ' '; x++)
							;
						bilcols = Atoi((char*)&hdrBuf[x]);
					}
					if ((hdrBuf[x] == 'R') && (hdrBuf[x-1] == 'D') && (hdrBuf[x-2] == 'N'))
					{
						if ((hdrBuf[x-8] == '3') && (hdrBuf[x-7] == '2'))
							Datasize = 32;// float
						else if (hdrBuf[x-7] == ' ')
							Datasize = 8;
						else
							Datasize = 16;
						break;
					}
				}
			}
			CloseHandle(hFile);
		}
		else
			return ExitCode;
		if (Datasize == 0)
			return ExitCode;

		hFile = CreateFile(ElevationFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (INVALID_HANDLE_VALUE != hFile)
		{
			DWORD fileSize = GetFileSize(hFile, NULL);
			if (fileSize)
			{
				int u, v;
				int z1N, z2N, z3N, z4N, z1E, z2E, z3E, z4E;
				DWORD i, j, k;
				float *bilBufFloat;
				WORD *bilBuf;
				BYTE *bilBufSmall;
				double InitialLat, InitialLon, Increment;
				double d1, d2;
				char Zone[] = "Zone=";
				char nUTM[8];
				char UTM[] = " UTM=n";
				char Name[] = " Name=";
				char Row[] = " Rows=";
				char Col[] = " Cols=";
				char SpacingEtc[] = " Spacing=30 Elev=METERS File=";

				if (Datasize == 32)
				{
					bilBufFloat = (float*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					ReadFile(hFile, bilBufFloat, fileSize, &dwBytesRead, NULL) ;
				}
				else if (Datasize == 16)
				{
					bilBuf = (WORD*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					ReadFile(hFile, bilBuf, fileSize, &dwBytesRead, NULL) ;
				}
				else
				{
					bilBufSmall = (BYTE*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
					ReadFile(hFile, bilBufSmall, fileSize, &dwBytesRead, NULL) ;
				}
				CloseHandle(hFile);

				hFile = CreateFile(blwFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
				if (INVALID_HANDLE_VALUE != hFile)
				{
					DWORD fileSize2 = GetFileSize(hFile, NULL);
					if (fileSize2)
					{
						ReadFile(hFile, blwBuf, fileSize2, &dwBytesRead, NULL) ;
						for (x = 0; x < (int)fileSize2; x++)
							if (blwBuf[x] == '0')
								break;
						Increment = atof((char*)&blwBuf[x]);
						for (y = 0; blwBuf[x] < (int)fileSize2; x++)
						{
							if (blwBuf[x] == '\n')
								y++;
							if (y == 4)
							{
								for (x++ ; (blwBuf[x] < (int)fileSize2) && (blwBuf[x] == ' '); x++)
									;
								InitialLon = atof((char*)&blwBuf[x]);
								for ( ; (blwBuf[x] < (int)fileSize2) && (blwBuf[x] != '\n'); x++)
									;
								x++;
								for ( ; (blwBuf[x] < (int)fileSize2) && (blwBuf[x] == ' '); x++)
									;
								InitialLat = atof((char*)&blwBuf[x]);
								break;
							}
						}
					}
					CloseHandle(hFile);
				}
				else
					return ExitCode;

				Lat = InitialLat;
				Lon = InitialLon;
				LatRad = Lat*deg2rad;
				LonRad = Lon*deg2rad;
				LatLontoUTM();
				UTMNorthing -= 30;
				UTMEasting += 30;
				UTMtoLatLon();
				if ((bilrows == 0) || (bilcols == 0))
				{
//					d1 = 0.125 / Increment;//0.125 degrees = 7.5 minutes
					d1 = 0.50 / Increment;
					d1 = modf(d1, &d2);
					bilrows = (int)d2 + 1;
					if (Datasize != 8)
						bilrows /= 2;
					bilcols = bilrows;
				}
////////////////////////////////////////////////////////////////
				double a = Increment, b = InitialLat, c = InitialLon;

				for (y = 0; y < (int)bilrows; y++)
				{
					for (x = 0; x < (int)bilcols; x++)
					{
						tempLat = Lat;
						tempLon = Lon;
						tempUTMZone = UTMZone;
						tempUTMN = UTMNorthing;
						tempUTME = UTMEasting;

						Lat = b - (a*y);
						Lon = c + (a*x);
						LatRad = Lat * deg2rad;
						LonRad = Lon * deg2rad;
						LatLontoUTM();
						UTMNbilBuf[y][x] = UTMNorthing;
						UTMEbilBuf[y][x] = UTMEasting;
						if (Northest < UTMNorthing)
							Northest = UTMNorthing;
						if (Southest > UTMNorthing)
							Southest = UTMNorthing;
						if (Eastest > UTMEasting)
							Eastest = UTMEasting;
						if (Westest < UTMEasting)
							Westest = UTMEasting;
						Lat = tempLat;
						Lon = tempLon;
						UTMZone = tempUTMZone;
						UTMNorthing = tempUTMN;
						UTMEasting = tempUTME;
					}
				}
				Northest = Northest-(Northest%30);//make it evenly divisible by 30
				Eastest = Eastest+30-(Eastest%30);
				Southest = Southest-(Southest%30);
				Westest = Westest+30-(Westest%30);
				NminusS = (Northest-Southest) / 30;
				WminusEx30 = (Westest-Eastest) / 30;
				for (y = 0; y < NminusS; y++)
				{
					for (x = 0; x < WminusEx30; x++)
					{
						UTMN30Buf[x+(y*WminusEx30)] = Northest-(y*30);
						UTME30Buf[x+(y*WminusEx30)] = Eastest+(x*30);
						UTMElevBuf[x+(y*WminusEx30)] = 0x8002;
					}
				}

				for (y = 0; y < (int)bilrows-2; y++)
				{
					for (x = 0; x < (int)bilcols-2; x++)
					{
						u = (Northest - UTMNbilBuf[y][x]) / 30;
						v = (UTMEbilBuf[y][x] - Eastest) / 30;
						//30 meter UTM points
						z1N = UTMN30Buf[v+(u*WminusEx30)];
						z1E = UTME30Buf[v+(u*WminusEx30)];
						z2N = UTMN30Buf[v+1+(u*WminusEx30)];
						z2E = UTME30Buf[v+1+(u*WminusEx30)];
						z3N = UTMN30Buf[v+((u+1)*WminusEx30)];
						z3E = UTME30Buf[v+((u+1)*WminusEx30)];
						z4N = UTMN30Buf[v+1+((u+1)*WminusEx30)];
						z4E = UTME30Buf[v+1+((u+1)*WminusEx30)];
						//Lat/Lon converted to UTM
						nwN = UTMNbilBuf[y][x];
						nwE = UTMEbilBuf[y][x];
						swN = UTMNbilBuf[y+1][x];
						swE = UTMEbilBuf[y+1][x];
						neN = UTMNbilBuf[y][x+1];
						neE = UTMEbilBuf[y][x+1];
						seN = UTMNbilBuf[y+1][x+1];
						seE = UTMEbilBuf[y+1][x+1];
						//elevations of converted Lat/Lon points
						if (Datasize == 32)
						{
							nw = (int)*(float*)&bilBufFloat[x+(y*bilcols)];
							ne = (int)*(float*)&bilBufFloat[x+2+(y*bilcols)];
							sw = (int)*(float*)&bilBufFloat[x+((y+2)*bilcols)];
							se = (int)*(float*)&bilBufFloat[x+2+((y+2)*bilcols)];
						}
						else if (Datasize == 16)
						{
							nw = *(WORD*)&bilBuf[x+(y*bilcols)];
							ne = *(WORD*)&bilBuf[x+2+(y*bilcols)];
							sw = *(WORD*)&bilBuf[x+((y+2)*bilcols)];
							se = *(WORD*)&bilBuf[x+2+((y+2)*bilcols)];
						}
						else
						{
							nw = bilBufSmall[x+(y*bilcols)];
							ne = bilBufSmall[x+2+(y*bilcols)];
							sw = bilBufSmall[x+((y+2)*bilcols)];
							se = bilBufSmall[x+2+((y+2)*bilcols)];
						}

						if (((z1N <= nwN) || (z1N <= neN)) && ((z1E >= nwE) || (z1E >= swE)) && ((z1N >= swN) || (z1N >= seN)) && ((z1E <= neE) || (z1E <= seE)))
						{
							elev = NSWEelevs(z1N, z1E);
							if (elev < 9144)//30,000'
								UTMElevBuf[v+(u*WminusEx30)] = elev;
							else
								UTMElevBuf[v+(u*WminusEx30)] = 0x8002;
						}
						if (((z2N <= nwN) || (z2N <= neN)) && ((z2E >= nwE) || (z2E >= swE)) && ((z2N >= swN) && (z2N >= seN)) && ((z2E <= neE) && (z2E <= seE)))
						{
							elev = NSWEelevs(z2N, z2E);
							if (elev < 9144)//30,000'
								UTMElevBuf[v+1+(u*WminusEx30)] = elev;
							else
								UTMElevBuf[v+1+(u*WminusEx30)] = 0x8002;
						}
						if (((z3N <= nwN) || (z3N <= neN)) && ((z3E >= nwE) || (z3E >= swE)) && ((z3N >= swN) && (z3N >= seN)) && ((z3E <= neE) && (z3E <= seE)))
						{
							elev = NSWEelevs(z3N, z3E);
							if (elev < 9144)//30,000'
								UTMElevBuf[v+((u+1)*WminusEx30)] = elev;
							else
								UTMElevBuf[v+((u+1)*WminusEx30)] = 0x8002;
						}
						if (((z4N <= nwN) || (z4N <= neN)) && ((z4E >= nwE) || (z4E >= swE)) && ((z4N >= swN) && (z4N >= seN)) && ((z4E <= neE) && (z4E <= seE)))
						{
							elev = NSWEelevs(z4N, z4E);
							if (elev < 9144)//30,000'
								UTMElevBuf[v+1+((u+1)*WminusEx30)] = elev;
							else
								UTMElevBuf[v+1+((u+1)*WminusEx30)] = 0x8002;
						}
					}
				}

////////////////////////////////////////////////////////////////
				i = (int)(1000.0 * InitialLat);
				j = i % 25;
				if (j == 24)
					i++;
				else if (j == 1)
					i--;
				k = (int)(1000.0 * (-InitialLon));
				j = k % 25;
				if (j == 24)
					k++;
				else if (j == 1)
					k--;
				for (x = 0; ElevationDir[x] != 0; x++)
					DemFileName[x] = ElevationDir[x];
				DemFileName[x++] = '\\';
				DemFileName[x++] = 'n';
				DemFileName[x++] = (char)(i / 10000) + '0';
				DemFileName[x++] = (char)((i % 10000) / 1000) + '0';
				DemFileName[x++] = '.';
				DemFileName[x++] = (char)((i % 1000) / 100) + '0';
				DemFileName[x++] = (char)((i % 100) / 10) + '0';
				DemFileName[x++] = (char)(i % 10) + '0';
				DemFileName[x++] = ' ';
				DemFileName[x++] = 'w';
				if (k >= 100000)
					DemFileName[x++] = (char)(k / 100000) + '0';
				DemFileName[x++] = (char)((k % 100000) / 10000) + '0';
				DemFileName[x++] = (char)((k % 10000) / 1000) + '0';
				DemFileName[x++] = '.';
				DemFileName[x++] = (char)((k % 1000) / 100) + '0';
				DemFileName[x++] = (char)((k % 100) / 10) + '0';
				DemFileName[x++] = (char)(k % 10) + '0';
				DemFileName[x] = 0;

				for (x = 0; Zone[x] != 0; x++)
					DemIni[x] = Zone[x];
				DemIni[x++] = (UTMZone / 10) + '0';
				DemIni[x++] = (UTMZone % 10) + '0';
				for (y = 0; UTM[y] != 0; x++, y++)
					DemIni[x] = UTM[y];
				_itoa(Northest, nUTM, 10);
				for (y = 0; nUTM[y] != 0; x++, y++)
					DemIni[x] = nUTM[y];
				DemIni[x++] = 'w';
				_itoa(Eastest, nUTM, 10);
				for (y = 0; nUTM[y] != 0; x++, y++)
					DemIni[x] = nUTM[y];
				for (y = 0; Name[y] != 0; x++, y++)
					DemIni[x] = Name[y];
				for (y = 10; DemFileName[y] != 0; x++, y++)
					DemIni[x] = DemFileName[y];
				for (y = 0; Row[y] != 0; x++, y++)
					DemIni[x] = Row[y];
				DemIni[x++] = (char)(NminusS / 100) + '0';
				DemIni[x++] = (char)((NminusS % 100) / 10) + '0';
				DemIni[x++] = (char)(NminusS % 10) + '0';
				for (y = 0; Col[y] != 0; x++, y++)
					DemIni[x] = Col[y];
				DemIni[x++] = (char)(WminusEx30 / 100) + '0';
				DemIni[x++] = (char)((WminusEx30 % 100) / 10) + '0';
				DemIni[x++] = (char)(WminusEx30 % 10) + '0';
				for (y = 0; SpacingEtc[y] != 0; x++, y++)
					DemIni[x] = SpacingEtc[y];
				for (y = 0; ShortElevationFile[y] != 0; x++, y++)
					DemIni[x] = ShortElevationFile[y];
				DemIni[x++] = '\r';
				DemIni[x++] = '\n';
				notthere = TRUE;
				hFile = CreateFile(ElevIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
				if (fileSize = GetFileSize(hFile, NULL))
				{
					pDemIniBuf = (unsigned char*) malloc(fileSize + 100);
					ReadFile(hFile, pDemIniBuf, fileSize, &dwBytesRead, NULL);
					//check for being already there...
					for (y = 33, z = 33; y < (int)fileSize; y++, z++)
					{//just past "NAME="
						if (DemIni[z] != pDemIniBuf[y])
						{
							for ( ; (pDemIniBuf[y] != '\n') && (y < (int)fileSize); y++)
								;
							y += 33;
							z = 32;
						}
						else if (DemIni[z] == '\r')
						{
							notthere = FALSE;
							break;
						}
					}
					free(pDemIniBuf);
				}
				if (notthere == TRUE)
				{
					SetFilePointer(hFile, 0, 0, FILE_END);
					WriteFile(hFile, DemIni, x, &dwBytesWritten, NULL);
				}
				CloseHandle(hFile);

				hFile2 = CreateFile(DemFileName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile2, UTMElevBuf, 2*NminusS*WminusEx30, &dwBytesWritten, NULL);
				CloseHandle(hFile2);
				ExitCode = 0;
				if (Datasize == 32)
					VirtualFree(bilBufFloat, 0, MEM_RELEASE);
				else if (Datasize == 16)
					VirtualFree(bilBuf, 0, MEM_RELEASE);
				else
					VirtualFree(bilBufSmall, 0, MEM_RELEASE);
			}
			else
				CloseHandle(hFile);
		}
	}
	return ExitCode;
}
/*
DWORD ConvertSDTSData(void)
{
	ConusLatData = NULL;
	ConusLonData = NULL;
	PrviLatData = NULL;
	PrviLonData = NULL;
	HawaiiLatData = NULL;
	HawaiiLonData = NULL;
	AlaskaLatData = NULL;
	AlaskaLonData = NULL;

	ExitCode = 3;

	hFile = gzopen(SDTSfilename, "rb");
	if (0 == hFile)
	{
		MessageBox(hwnd, "Couldn't open .gz data file.", ERROR, MB_OK);
		return ExitCode;
	}
	pBuf = (BYTE*)VirtualAlloc(NULL, 0x10000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
	//////////////////////////////////////////
	TarSize = gzread(hFile, pBuf, 0x10000000);
	//////////////////////////////////////////
	gzclose(hFile);
	if (-1 == TarSize)
	{
		MessageBox(hwnd, "Error reading .gz file.", ERROR, MB_OK);
		return ExitCode;
	}
	DeleteFile(SDTSfilename);
	MyDem = (WORD*)malloc(0x500000);
	if (0 == ReadLatLonData())
		////////////////////////
		ExitCode = Subroutine();
		////////////////////////
	free(MyDem);
	VirtualFree(pBuf, 0, MEM_RELEASE);
	if (ConusLatData != NULL)
		free(ConusLatData);
	if (ConusLonData != NULL)
		free(ConusLonData);
	if (PrviLatData != NULL)
		free(PrviLatData);
	if (PrviLonData != NULL)
		free(PrviLonData);
	if (HawaiiLatData != NULL)
		free(HawaiiLatData);
	if (HawaiiLonData != NULL)
		free(HawaiiLonData);
	if (AlaskaLatData != NULL)
		free(AlaskaLatData);
	if (AlaskaLonData != NULL)
		free(AlaskaLonData);
	return ExitCode;
}

//write "Elev.ini" and (e.g.)"n37.500 w122.125" from data in the .TAR file
int Subroutine(void)
{
	int i, j, xincr, colincr, yincr, increment;
	int SaveX, SaveY, row, col, Rows, Cols;
	int DataCols, DataBegin, OfficialZone, WrongUTMEasting, WrongUTMZone;
	int nCorrected, wCorrected, nIREF, wIREF;
	DWORD fileSize, dwBytesRead, dwBytesWritten;
	double up, right, nothing, DegreesPerRow;
	float nDiff, wDiff, nDiffUp1, wDiffUp1, nDiffRight1, wDiffRight1, nDiffUp1Right1, wDiffUp1Right1;
	float nDiffHalfRight, wDiffHalfRight, nDiffHalfRightUp1, wDiffHalfRightUp1, BeginLat, BeginLon;
	char DemName[50];//e.g.MOUNTAIN VIEW
	char Zone[] = "Zone=  ";
	char UTM[] = " UTM=";
	char nUTM[8];
	char Name[] = " Name=";
	char Row[] = " Rows=";
	char Col[] = " Cols=";
	char Spacing[] = " Spacing=";
	char Elev[] = " Elev=";
	char File[] = " File=";
	BOOL itsnad27, halfup, halfright, itsdecimal;
	HANDLE hFile2, hFile3;
	WIN32_FIND_DATA fd2;
	union
	{
		float floatingpoint;
		unsigned int integer;
	} elev;

	for (x = 0; x < 199; x++)
		DemIni[x] = ' ';//for debugging
	DemIni[x] = 0;

	for (x = 0; x < 7; x++)
		DemIni[x] = Zone[x];
	for (x = 7, z = 0; z < 5; x++, z++)
		DemIni[x] = UTM[z];//" UTM=";
//get UTM Zone
	for (x = TarSize-1, y = 0; (x > 0) && (y < 4); x--)//(int)fileSize-1
		if (pBuf[x] == 0x1F)
			y++;
	if (x == 0)
	{
		MessageBox(NULL, "UTM zone format is wrong...", NULL, MB_OK);
		return ExitCode;
	}
	if (pBuf[x+3] != 0x1E)
	{
		DemIni[5] = pBuf[x+2];
		DemIni[6] = pBuf[x+3];
	}
	else
	{
		DemIni[5] = '0';
		DemIni[6] = pBuf[x+2];
	}
	OfficialZone = ((DemIni[5] - 0x30) * 10) + (DemIni[6] - 0x30);
//see if it's NAD27 Datum
	if (pBuf[x] == 'S')//'NAS'
		itsnad27 = TRUE;
	else
		itsnad27 = FALSE;
//get IREF UTM
	for ( ; x > 0; x--)
	{
		if ((pBuf[x] == 0x1E)
		&& (pBuf[x+1] == 'I')
		&& (pBuf[x+2] == 'R')
		&& (pBuf[x+3] == 'E')
		&& (pBuf[x+4] == 'F'))
		{
			SaveX = x;//new down to break
			x += 24;
			for (y = 0; (pBuf[x] != 0x1E) && (y < 17); x++, y++)
				;
			x = SaveX;
			if (y < 17)
				break;//if 0x1E was found after Lat
		}
	}
	if (x == 0)
	{
		MessageBox(NULL, "Couldn't find IREF...", NULL, MB_OK);
		return ExitCode;
	}
	SaveX = x;
	x += 24;//to top left North UTM
	nIREF = atoi((char*)&pBuf[x]);
	x = SaveX + 8;//to top left West UTM
	wIREF = atoi((char*)&pBuf[x]);
//get rows & cols
	x = SaveX;
	for ( ; x > 0; x--)
	{
		if ((pBuf[x] == 'D') && (pBuf[x+1] == 'E') && (pBuf[x+2] == 'F'))
			break;
	}
	x += 4;//to rows
	Rows = atoi((char*)&pBuf[x]);
	for ( ; (pBuf[x] != 0x1F) && (x < TarSize); x++)//(int)fileSize)
		;
	if (x == TarSize)//(int)fileSize)
	{
		MessageBox(NULL, "DEF format is wrong...", NULL, MB_OK);
		return ExitCode;
	}
	x++;
	Cols = atoi((char*)&pBuf[x]);
//get DemName (e.g.MOUNTAIN VIEW)
	for ( ; x > 0; x--)
	{
		if ((pBuf[x] == 'I')
		&& (pBuf[x+1] == 'D')
		&& (pBuf[x+2] == 'E')
		&& (pBuf[x+3] == 'N')
		&& (pBuf[x+4] == '.')
		&& (pBuf[x+5] == 'D')
		&& (pBuf[x+6] == 'D')
		&& (pBuf[x+7] == 'F'))
			break;
	}
	if (x == 0)
	{
		MessageBox(NULL, "Couldn't find IDEN.DDF", NULL, MB_OK);
		return ExitCode;
	}
	SaveX = x;
	for (z = 0 ; (z < 16) && (x < TarSize); x++)//(int)fileSize
		if (pBuf[x] == 0x1F)
			z++;// go to 16th 0x1F after IDEN.DDF
	if (x == TarSize)//(int)fileSize)
	{
		MessageBox(NULL, "IDEN.DDF format is wrong...", NULL, MB_OK);
		return ExitCode;
	}
	for (y = 0, z = 0; ((pBuf[x] >= 'A') && (pBuf[x] <= 'Z')) || (pBuf[x] == ' '); x++, z++)
	{
		DemName[z] = pBuf[x];//SAN MATEO
		if (pBuf[x] == ' ')
			y++;
		if (y == 2)
			break;//only 1 space in name
	}
	if (DemName[z-1] == ' ')
		z--;
	DemName[z] = 0;
//get DemFileName (e.g.N37x500W122x125)
	for (y = 27, z = 0; z < 6; y++, z++)
		DemIni[y] = Name[z];
	for ( ; (pBuf[x] != ':') && (x < TarSize); x++)//(int)fileSize
		;
	if (x == TarSize)//(int)fileSize)
	{
		MessageBox(NULL, "Couldn't find ':'", NULL, MB_OK);
		return ExitCode;
	}
	for (z = 0 ; (z < 6) && ((pBuf[x] < '0') || (pBuf[x] > '9')); z++, x++)
		;
	if (z < 6)
	{
		DemIni[y++] = 'n';//Lat/Lon
		DemFileName[0] = 'n';
		z = 1;
		ConvertLatLon();
		DemIni[y++] = ' ';
		DemIni[y++] = 'w';
		DemFileName[z++] = ' ';
		DemFileName[z++] = 'w';
		for ( ; pBuf[x] != '-'; x++)
			;
		x++;
		ConvertLatLon();
	}
	else
	{
		for (z = 0; DemName[z] != 0; z++, y++)
		{
			DemFileName[z] = DemName[z];
			DemIni[y] = DemName[z];
		}
	}
	DemFileName[z] = 0;
	SaveY = y;
//get UTM (IREF corrected to NAD83) location for topleft location of elevation data
	if (itsnad27 == FALSE)
	{
		nCorrected = nIREF;
		wCorrected = wIREF;
	}
	else//if (itsnad27) get NAD83 from NAD27
	{
//Reading conus.las:
//at offset 64 the integer is data columns - 1 (each one is 4 bytes, and there's a 0 integer at the beginning (or end?) of each data column)
//at offset 68 the integer is the number of rows + 1
//at offset 76 the float is the beginning longitude
//at offset 84 the float is the beginning latitude
//data begins at the end of a lot of 0's
		UTMZone = OfficialZone;
		UTMNorthing = nIREF;
		UTMEasting = wIREF;
		ECC_SQUARED = 0.006768658;//Eccentricity Squared for Clarke 1866 Ellipsiod
		a0 = 6378206.0;//Equatorial Radius for Clarke 1866 Ellipsoid (used with NAD27)
		UTMtoLatLon();
		a0 = 6378137.0;//Equatorial Radius for WGS-84 datum
		ECC_SQUARED = 0.006694379990;//Eccentricity Squared for WGS-84 datum
		LatRad = Lat*deg2rad;
		LonRad = Lon*deg2rad;
		LatLontoUTM();//after this UTM MIGHT be in different Zone (if at 6 degree Lon UTM edge)
		Lon = -Lon;
		WrongUTMEasting = UTMEasting;//MAYBE different
		WrongUTMZone = UTMZone;//MAYBE different
		if ((Lat >= 20.0) && (Lat < 72.0) && (Lon <= 168.0) && (Lon > 63.0))
		{//CONUS Lat/Lon boundaries
			BeginLat = 20.0;
			BeginLon = 131.0;
			DegreesPerRow = 0.25;
			DataCols = 274;
			DataBegin = 1100;
			LatData = ConusLatData;
			LonData = ConusLonData;
		}
		else if ((Lat >= 17.0) && (Lat < 19.0) && (Lon <= 68.0) && (Lon > 64.0) && (PrviLatData != NULL) && (PrviLonData != NULL))
		{//Puerto Rico/Virgin Islands Lat/Lon boundaries
			BeginLat = 17.0;
			BeginLon = 68.0;
			DegreesPerRow = 0.05;
			DataCols = 82;
			DataBegin = 332;
			LatData = PrviLatData;
			LonData = PrviLonData;
		}			
		else if ((Lat >= 46.0) && (Lat < 77.0) && (Lon <= 168.0) && (Lon > 128.0))
		{//Alaska
			BeginLat = 46.0;
			BeginLon = 194.0;
			DegreesPerRow = 0.125;//248 rows
			DataCols = 529;
			DataBegin = 2124;
			LatData = AlaskaLatData;
			LonData = AlaskaLonData;
		}
		else if ((Lat >= 18.0) && (Lat < 23.0) && (Lon <= 161.0) && (Lon > 154.0) && (HawaiiLatData != NULL) && (HawaiiLonData != NULL))
		{//Hawaii
			BeginLat = 18.0;
			BeginLon = 161.0;
			DegreesPerRow = 0.025;//40 rows/degree - 200 rows
			DataCols = 282;//1128 bytes/row
			DataBegin = 1132;
			LatData = HawaiiLatData;
			LonData = HawaiiLonData;
		}
		else
		{
			sprintf(Error, "N %f\nW %f %s", Lat, Lon, OutsideUSA);
			MessageBox(hwnd, Error, "Error 10", MB_OK);
			return ExitCode;
		}			
//get NAD27 to NAD83 correction at Lat/Lon offsets in LatData & LonData
		up = (Lat - BeginLat) / DegreesPerRow;
		right = (BeginLon - Lon) / DegreesPerRow;
		z = DataBegin + ((((int)up * DataCols) + (int)right) * 4);//4 bytes per float number
		nDiff = *(float*) &LatData[z];
		wDiff = *(float*) &LonData[z];
		z = DataBegin + (((((int)up + 1) * DataCols) + (int)right) * 4);//4 bytes per float number
		nDiffUp1 = *(float*) &LatData[z];
		wDiffUp1 = *(float*) &LonData[z];
		z = DataBegin + ((((int)up * DataCols) + ((int)right) + 1) * 4);//4 bytes per float number
		nDiffRight1 = *(float*) &LatData[z];
		wDiffRight1 = *(float*) &LonData[z];
		z = DataBegin + (((((int)up + 1) * DataCols) + ((int)right) + 1) * 4);//4 bytes per float number
		nDiffUp1Right1 = *(float*) &LatData[z];
		wDiffUp1Right1 = *(float*) &LonData[z];

		halfup = halfright = FALSE;
		if (modf(up, &nothing))//if there's a fractional part
			halfup = TRUE;
		if (modf(right, &nothing))//if there's a fractional part
			halfright = TRUE;
		if ((halfup) && (!halfright))
		{
			nDiff = ((nDiff - nDiffUp1) / 2) + nDiffUp1;//half-way
			wDiff = ((wDiff - wDiffUp1) / 2) + wDiffUp1;//half-way
		}
		else if ((halfright) && (!halfup))
		{
			nDiff = ((nDiff - nDiffRight1) / 2) + nDiffRight1;//half-way
			wDiff = ((wDiff - wDiffRight1) / 2) + wDiffRight1;//half-way
		}
		else if ((halfup) && (halfright))
		{
			nDiffHalfRight = ((nDiff - nDiffRight1) / 2) + nDiffRight1;//half-way
			wDiffHalfRight = ((wDiff - wDiffRight1) / 2) + wDiffRight1;//half-way
			nDiffHalfRightUp1 = ((nDiffUp1 - nDiffUp1Right1) / 2) + nDiffUp1Right1;
			wDiffHalfRightUp1 = ((wDiffUp1 - wDiffUp1Right1) / 2) + wDiffUp1Right1;
			nDiff = ((nDiffHalfRight - nDiffHalfRightUp1) / 2) + nDiffHalfRightUp1;
			wDiff = ((wDiffHalfRight - wDiffHalfRightUp1) / 2) + wDiffHalfRightUp1;
		}
		Lat += nDiff / 3600.0;//NAD83 IREF
		Lon += wDiff / 3600.0;//NAD83 IREF
		Lon = -Lon;
		LatRad = Lat*deg2rad;
		LonRad = Lon*deg2rad;
		LatLontoUTM();
		nCorrected = UTMNorthing;
		if (WrongUTMZone == OfficialZone)
			wCorrected = UTMEasting;
		else//use a correlation
			wCorrected = wIREF  + (UTMEasting - WrongUTMEasting);
	}
//put UTM in DemIni
	_itoa(nCorrected, nUTM, 10);
	DemIni[12] = 'n';
	for (y = 13, z = 0; z < 7; y++, z++)
		DemIni[y] = nUTM[z];
	_itoa(wCorrected, nUTM, 10);
	DemIni[y++] = 'w';
	for ( z = 0; z < 6; y++, z++)
		DemIni[y] = nUTM[z];
//get type of elevation data (16 or 32-bit)
	for (x = 0; x < TarSize; x++)//(int)fileSize
	{
		if ((pBuf[x] == ')')
		&& (pBuf[x-1] == ')')
		&& (pBuf[x-4] == '(')
		&& (pBuf[x-5] == 'B')
		&& (pBuf[x-6] == '('))
			break;
	}
	if (x == TarSize)//(int)fileSize)
	{
		MessageBox(NULL, "No '*ELEVATION' info", NULL, MB_OK);
		return ExitCode;
	}
	if ((pBuf[x-3] == '3') && (pBuf[x-2] == '2'))
		itsdecimal = TRUE;
	else
		itsdecimal = FALSE;
	 //prepare to put data in MyDem
	for ( ; x < TarSize; x++)//(int)fileSize
	{
		if ((pBuf[x] == 0x1E)
		&& (pBuf[x-1] == '1')
		&& (pBuf[x-2] == '0')
		&& (pBuf[x-3] == '0')
		&& (pBuf[x-4] == '0')
		&& (pBuf[x-5] == '0')
		&& (pBuf[x-6] == '1')
		&& (pBuf[x-7] == '0')
		&& (pBuf[x-8] == '0')
		&& (pBuf[x-9] == '0')
		&& (pBuf[x-10] == '0'))
			break;
	}
	x++;
//put data in MyDem to write to DemFileName
	y = i = j = 0;
	if (Rows < 600)//if 30 meter data
		increment = 1;
	else//if 10 meter data
		increment = 3;
	for (yincr = 0, row = 0; row < Rows; row++)
	{
		for (xincr = 0, col = 0; col < Cols; col++)
		{
			if (itsdecimal == FALSE)
			{
				if ((i == 0) && (j == 0))
				{//only copy every 3rd elevation if it's 10 meter data
					MyDem[y] = (pBuf[x]) << 8;
					MyDem[y] = MyDem[y] | pBuf[x+1];
					y++;
					xincr++;
					colincr = xincr;//new
				}
				x += 2;
			}
			else
			{
				if ((i == 0) && (j == 0))
				{
					elev.integer = (pBuf[x+3] + (pBuf[x+2]<<8) + (pBuf[x+1]<<16) + (pBuf[x]<<24));
					if (elev.integer != 0xC6FFFC00)//signifies no data
					{
						MyDem[y] = (int)elev.floatingpoint;
						if (MyDem[y] > 15000)
						{
							MyDem[y] = 0x8002;//signifies no data
						}

					}
					else
						MyDem[y] = 0x8002;//signifies no data
					y++;
					xincr++;
					colincr = xincr;
				}
				x += 4;
			}
			if (increment == 3)
			{
				j++;
				if (j == 3) j = 0;
			}
		}
		if (increment == 3)
		{
			if (i == 0) yincr++;
			i++;
			if (i == 3) i = 0;
		}
		for (x++, z = 2; z > 0; x++)
			if (pBuf[x] == 0x1E)
				z--;//put x at beginning of next row
	}
	if (increment == 3)
	{
		row = yincr;
		col = colincr;
	}
//put Rows & Cols in DemIni
	y = SaveY;
	for (x = 0; x < 6; x++, y++)
		DemIni[y] = Row[x];
	DemIni[y++] = (row % 1000) / 100 + '0';
	DemIni[y++] = ((row % 100) / 10) + '0';
	DemIni[y++] = (row % 10) + '0';
	for (x = 0; x < 6; x++, y++)
		DemIni[y] = Col[x];
	DemIni[y++] = (col % 1000) / 100 + '0';
	DemIni[y++] = ((col % 100) / 10) + '0';
	DemIni[y++] = (col % 10) + '0';

	for (x = 0; x < 9; x++, y++)
		DemIni[y] = Spacing[x];
	for (x = SaveX; x > 0; x--)
	{
		if ((pBuf[x] == ' ')
		&& (pBuf[x+1] == 'X')
		&& (pBuf[x+2] == ',')
		&& (pBuf[x+3] == ' '))
			break;
	}
	DemIni[y++] = '3';//pBuf[x+4];//"30" or "10"
	DemIni[y++] = '0';//pBuf[x+5];
//put Elev & File & DemName in DemIni
	for (z = 0; z < 6; z++, y++)
		DemIni[y] = Elev[z];
	for (z = x-1; pBuf[z] != ' '; z--)
		;
	z++;//to either "FEET" or "METERS"
	for ( ; z < x; z++)
		DemIni[y++] = pBuf[z];
	for (x = 0; x < 6; x++, y++)
		DemIni[y] = File[x];
	for (x = 0; (SDTSfilename[x] != '.') && (SDTSfilename[x] != '['); x++, y++)
		DemIni[y] = SDTSfilename[x];
	DemIni[y++] = ' ';
	for (x = 0; DemName[x] != 0; x++, y++)
		DemIni[y] = DemName[x];
	DemIni[y++] = '\r';
	DemIni[y++] = '\n';
	DemIni[y] = 0;
//	VirtualFree(pBuf, 0, MEM_RELEASE);

//write data file (e.g."N37x500W122x125")
	hFindFile = FindFirstFile(ElevationDir, &fd);
	if ((INVALID_HANDLE_VALUE != hFindFile) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		FindClose(hFindFile);//Elevation folder exists
		for (w = 10, z = 0; DemFileName[z] != 0; w++, z++)
			NewElevFile[w] = DemFileName[z];
		NewElevFile[w] = 0;
		hFile2 = CreateFile(NewElevFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	}
	else
		hFile2 = CreateFile(DemFileName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	WriteFile(hFile2, MyDem, row*col*2, &dwBytesWritten, NULL);
	CloseHandle(hFile2);

	notthere = TRUE;
	if (INVALID_HANDLE_VALUE == FindFirstFile(ElevIni, &fd2))
		hFile3 = CreateFile(ElevIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	else
	{
		hFile3 = CreateFile(ElevIni, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (fileSize = GetFileSize(hFile3, NULL))
		{
			pDemIniBuf = (unsigned char*) malloc(fileSize + 100);
			ReadFile(hFile3, pDemIniBuf, fileSize, &dwBytesRead, NULL);
			//check for being already there...
			for (x = 33, z = 33; x < (int)fileSize; x++, z++)
			{//just past "NAME="
				if (DemIni[z] != pDemIniBuf[x])
				{
					for ( ; (pDemIniBuf[x] != '\n') && (x < (int)fileSize); x++)
						;
					x += 33;
					z = 32;
				}
				else if (DemIni[z] == '\r')
				{
					notthere = FALSE;
					break;
				}
			}
			free(pDemIniBuf);
		}
	}
//write "Elev.ini"
	if (notthere)
	{
		SetFilePointer(hFile3, 0, 0, FILE_END);
		WriteFile(hFile3, DemIni, y, &dwBytesWritten, NULL);
	}
	CloseHandle(hFile3);
	if (FALSE == notthere)
		return ExitCode;
	else
		return 0;
}

void ConvertLatLon(void)
{//7.5' difference
	int w;
	char One[] =   "125";
	char Two[] =   "250";
	char Three[] = "375";
	char Four[] =  "500";
	char Five[] =  "625";
	char Six[] =   "750";
	char Seven[] = "875";
	char Eight[] = "000";

	for ( ; pBuf[x] != ' '; x++, y++, z++)
	{
		DemIni[y] = pBuf[x];
		DemFileName[z] = pBuf[x];
	}
	DemIni[y++] = '.';//n37.125 w122.750
	DemFileName[z++] = '.';
	for ( ; (pBuf[x] < '0') || (pBuf[x] > '9'); x++)
		;
	switch (pBuf[x])
	{//trick: add 0.125 to N & W
 	case '1':
		for (w = 0; w < 3; w++)
		{
			DemIni[y++] = Three[w];
			DemFileName[z++] = Three[w];
		}
		break;
 	case '2':
		for (w = 0; w < 3; w++)
		{
			DemIni[y++] = Four[w];
			DemFileName[z++] = Four[w];
		}
		break;
 	case '4':
		for (w = 0; w < 3; w++)
		{
			DemIni[y++] = Seven[w];
			DemFileName[z++] = Seven[w];
		}
		break;
 	case '5':
		for (w = 0; w < 3; w++)
		{
			DemIni[y++] = Eight[w];
			DemFileName[z++] = Eight[w];
		}
		DemIni[y-5]++;
		DemFileName[z-5]++;
		if (DemIni[y-5] > '9')
		{
			DemIni[y-5] = '0';
			DemIni[y-6]++;
			DemFileName[z-5] = '0';
			DemFileName[z-6]++;
			if (DemIni[y-6] > '9')
			{
				DemIni[y-6] = '0';
				DemIni[y-7]++;
				DemFileName[z-6] = '0';
				DemFileName[z-7]++;
			}
		}
		break;
	case '7':
		for (w = 0; w < 3; w++)
		{
			DemIni[y++] = Two[w];
			DemFileName[z++] = Two[w];
		}
		break;
	}
	x++;
	if ((pBuf[x-1] == '3') && (pBuf[x] == '0'))
	{
		for (w = 0; w < 3; w++)
		{
			DemIni[y++] = Five[w];
			DemFileName[z++] = Five[w];
		}

	}
	else if ((pBuf[x-1] == '3') && (pBuf[x] == '7'))
	{
		for (w = 0; w < 3; w++)
		{
			DemIni[y++] = Six[w];
			DemFileName[z++] = Six[w];
		}
	}
	else if ((pBuf[x-1] == '0') && (pBuf[x] == ' '))
	{
		for (w = 0; w < 3; w++)
		{
			DemIni[y++] = One[w];
			DemFileName[z++] = One[w];
		}
	}
}

//get NAD27 to NAD83 conversion data
int ReadLatLonData(void)
{
	hFile = CreateFile(ConusLas, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			ConusLatData = (unsigned char *) malloc(fileSize);
			ReadFile(hFile, ConusLatData, fileSize, &dwBytesRead, NULL);
		}
		CloseHandle(hFile);
	}	
	else
	{
		MessageBox(NULL, "Can't find 'CONUS.LAS'", NULL, MB_OK);
		ExitCode = 3;
		return ExitCode;
	}
	hFile = CreateFile(ConusLos, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			ConusLonData = (unsigned char *) malloc(fileSize);
			ReadFile(hFile, ConusLonData, fileSize, &dwBytesRead, NULL);
		}	
		CloseHandle(hFile);
	}
	else
	{
		MessageBox(NULL, "Can't find 'CONUS.LOS'", NULL, MB_OK);
		ExitCode = 3;
		return ExitCode;
	}
	hFile = CreateFile(PrviLas, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			PrviLatData = (unsigned char *) malloc(fileSize);
			ReadFile(hFile, PrviLatData, fileSize, &dwBytesRead, NULL);
		}
		CloseHandle(hFile);
	}
	hFile = CreateFile(PrviLos, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			PrviLonData = (unsigned char *) malloc(fileSize);
			ReadFile(hFile, PrviLonData, fileSize, &dwBytesRead, NULL);
		}	
		CloseHandle(hFile);
	}
	hFile = CreateFile(HawaiiLas, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			HawaiiLatData = (unsigned char *) malloc(fileSize);
			ReadFile(hFile, HawaiiLatData, fileSize, &dwBytesRead, NULL);
		}
		CloseHandle(hFile);
	}	
	hFile = CreateFile(HawaiiLos, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			HawaiiLonData = (unsigned char *) malloc(fileSize);
			ReadFile(hFile, HawaiiLonData, fileSize, &dwBytesRead, NULL);
		}	
		CloseHandle(hFile);
	}
	hFile = CreateFile(AlaskaLas, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			AlaskaLatData = (unsigned char *) malloc(fileSize);
			ReadFile(hFile, AlaskaLatData, fileSize, &dwBytesRead, NULL);
		}
		CloseHandle(hFile);
	}	
	hFile = CreateFile(AlaskaLos, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			AlaskaLonData = (unsigned char *) malloc(fileSize);
			ReadFile(hFile, AlaskaLonData, fileSize, &dwBytesRead, NULL);
		}	
		CloseHandle(hFile);
	}
	return 0;
}

*/
BOOL GetDownloadedData(void)
{
	while (index > 0)
	{
		ArrayIndex = WaitForMultipleObjects(index, aThreads, FALSE, 60000);
		if (ArrayIndex == WAIT_TIMEOUT)
		{
			MessageBox(hwnd, "Timed out waiting for\nphoto/topo data (1 minute).", ERROR, MB_OK);
			EnterCriticalSection(&cs); downloading = FALSE; LeaveCriticalSection(&cs);
			return FALSE;
 		}
		GetExitCodeThread(aThreads[ArrayIndex], &Col);//URLThread returns col as exit code in Col
		CloseHandle(aThreads[ArrayIndex]);
		if ((Col == -1) && (firstbad))
		{
			firstbad = FALSE;
//			MessageBox(hwnd, "Couldn't get data from msrmaps.com.", ERROR, MB_OK);
			EnterCriticalSection(&cs); downloading = FALSE; LeaveCriticalSection(&cs);
			return FALSE;
		}
		index--;
		if (ArrayIndex < index)
			aThreads[ArrayIndex] = aThreads[index];
		aThreads[index] = NULL;

		if (RowBufSize[Col] != 0)
		{
			xLoc = Col*PixelsPerTile;
			ColPtr = Col*MAX_TILE_SIZE;
			if ((RowBufs[ColPtr+6] == 'J') && (RowBufs[ColPtr+7] == 'F'))
			{//if good jpeg file
				if (RowBufs[ColPtr+0x18] == 0)
				{
					if (fillscreen)
					{
						/////////////////////////
						Convert_TileBuf_hdcMem(RowBufs, ColPtr);
						/////////////////////////					
						hdc = GetDC(hwnd);
						BitBlt(hdc, Col*PixelsPerTile, yLoc, PixelsPerTile, PixelsPerTile, hdcMem, Col*PixelsPerTile, yLoc, SRCCOPY);
						ReleaseDC(hwnd, hdc);
					}
				}
				else if (fillscreen)
				{//no photo/topo available
					RowBufSize[Col] = 0;
					hdc = GetDC(hwnd);
					MoveToEx(hdc, Col*PixelsPerTile, yLoc, NULL);
					LineTo(hdc, (Col*PixelsPerTile) + PixelsPerTile, yLoc + PixelsPerTile);
					MoveToEx(hdc, (Col*PixelsPerTile) + PixelsPerTile, yLoc, NULL);
					LineTo(hdc, Col*PixelsPerTile, yLoc + PixelsPerTile);
					ReleaseDC(hwnd, hdc);
				}
			}
			else if ((RowBufs[ColPtr] == 'G') && (RowBufs[ColPtr+1] == 'I') && (RowBufs[ColPtr+2] == 'F') && (RowBufs[ColPtr+3] == '8') && (RowBufs[ColPtr+4] == '7') && (RowBufs[ColPtr+5] == 'a'))
			{//GIF87a
				fileSize = RowBufSize[Col];
				GifBuf = (BYTE*)malloc(fileSize);
				c = RowBufs[ColPtr+10];//10110011
				if ((c >> 7) & 1)//Global color map follows Descriptor
				{
					c2 = 3 * (1 << ((c & 7) + 1));//size of color table
					for (w = 0, z = 13; w < c2; w++, z++)
						ColorTable[w] = RowBufs[ColPtr+z];
					if (RowBufs[ColPtr+z] != ',')
						goto gifexit;
					z += 9;
					c2 = *(BYTE*)&RowBufs[ColPtr+(z++)];//flags
					if (c2)
						goto gifexit;
					for (w = 0; z < fileSize; w++, z++)
						GifBuf[w] = RowBufs[ColPtr+z];
					GifBufSize = w;
					if (FALSE == decodeLZW())//fill pixel_buf
					{
						for (z = 0; z < MAX_IMAGE_SIZE; z++)
							pixel_buf[z] = 0;
					}
					RowBufSize[Col] = CreateTileBuf(RowBufs, ColPtr);//put pixel_buf in jpeg format in RowBufs[ColPtr]
					if (RowBufSize[Col] > MAX_TILE_SIZE)
						MessageBox(hwnd, "bug", ERROR, MB_OK);
					if (fillscreen)
					{
						/////////////////////////
						Convert_TileBuf_hdcMem(RowBufs, ColPtr);
						/////////////////////////					
						hdc = GetDC(hwnd);
						BitBlt(hdc, Col*PixelsPerTile, yLoc, PixelsPerTile, PixelsPerTile, hdcMem, Col*PixelsPerTile, yLoc, SRCCOPY);
						ReleaseDC(hwnd, hdc);
					}
				}
gifexit:		free(GifBuf);
			}
			else//if ((RowBufs[ColPtr+6] != 'J') || (RowBufs[ColPtr+7] != 'F'))
			{
				MessageBeep(MB_ICONEXCLAMATION);
				if (onetime == FALSE)
				{
					onetime = TRUE;
					hFile2 = CreateFile("DownloadError.htm", GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
					WriteFile(hFile2, "msrmaps.com is probably too busy.\r\n\r\n", 37, &dwBytesWritten, NULL);
					if (RowBufSize[ColPtr])
					{
						WriteFile(hFile2, "This tile had a problem:\r\n", 26, &dwBytesWritten, NULL);
						WriteFile(hFile2, pURLName, sizeof(pURLName), &dwBytesWritten, NULL);
						WriteFile(hFile2, "\r\n", 2, &dwBytesWritten, NULL);
						WriteFile(hFile2, &RowBufs[ColPtr], RowBufSize[ColPtr], &dwBytesWritten, NULL);
					}
					else
						WriteFile(hFile2, "Nothing downloaded!", 19, &dwBytesWritten, NULL);
					CloseHandle(hFile2);
					downloaderror = TRUE;
				}
				RowBufSize[Col] = 0;
			}
		}//end of if (RowBufSize[col] != 0)
	}//end of while (index > 0)
	return TRUE;
}

int CALLBACK FindUSGSProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
//	static DWORD x;
	static char Temp[256];
	static HWND hwndList, hwndEdit;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndList = GetDlgItem(hwndDlg, IDC_LIST1);
		SetFocus(hwndEdit);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_EDIT1:
			if (HIWORD(wParam) != EN_KILLFOCUS)
			{
				GetWindowText(hwndEdit, FirstLetter, 2);
				if ((FirstLetter[0] >= 'A') && (FirstLetter[0] <= 'Z'))
				{
					SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_RESETCONTENT, 0, 0);
					z = fileSize2/sizeof(PtrBuf[0]);
					for (x = 0; x < z; x++)
					{
						y = PtrBuf[x].ptr;
						if (USGSBuf[y] == FirstLetter[0])
						{
							for (w = 0; USGSBuf[y] != 0; w++, y++)
								Temp[w] = USGSBuf[y];
							Temp[w++] = ' ';
							Temp[w++] = (PtrBuf[x].UTME / 100000) + '0';
							Temp[w++] = ((PtrBuf[x].UTME % 100000) / 10000) + '0';
							Temp[w++] = ((PtrBuf[x].UTME % 10000) / 1000) + '0';
							Temp[w++] = ((PtrBuf[x].UTME % 1000) / 100) + '0';
							Temp[w++] = ((PtrBuf[x].UTME % 100) / 10) + '0';
							Temp[w++] = (PtrBuf[x].UTME % 10) + '0';
							Temp[w++] = ' ';
							Temp[w++] = (PtrBuf[x].UTMN / 1000000) + '0';
							Temp[w++] = ((PtrBuf[x].UTMN % 1000000) / 100000) + '0';
							Temp[w++] = ((PtrBuf[x].UTMN % 100000) / 10000) + '0';
							Temp[w++] = ((PtrBuf[x].UTMN % 10000) / 1000) + '0';
							Temp[w++] = ((PtrBuf[x].UTMN % 1000) / 100) + '0';
							Temp[w++] = ((PtrBuf[x].UTMN % 100) / 10) + '0';
							Temp[w++] = (PtrBuf[x].UTMN % 10) + '0';
							Temp[w] = 0;
							SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)Temp);
						}
					}
//					for (x = 0; x < (int)USGSfileSize; x++)
//					{
//						if ((USGSBuf[x] == 0) && (USGSBuf[x+1] == FirstLetter[0]))
//							SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)&USGSBuf[x+1]);
//					}
				}
			}
			break;

		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_SELCHANGE)
				IniNumber = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
			break;

		case IDOK:
			if (IniNumber == -1)
				break;
			SendMessage(hwndList, LB_GETTEXT, IniNumber, (LPARAM)&SelectedUSGSLoc);
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK FindProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	RECT editRect;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetWindowText(hwndEdit, Find);
		SetFocus(hwndEdit);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (GetWindowText(hwndEdit, Find, 100) == 0)
				break;
			SetFocus(hwndInstr);
			Lines = SendMessage(hwndInstr, EM_GETLINECOUNT, 0, 0);
			GetClientRect(hwndInstr, &editRect);
			y = (editRect.bottom - 20) << 16;//put it in high word
			ScreenLines = SendMessage(hwndInstr, EM_CHARFROMPOS, 0, (LPARAM)y);
			ScreenLines >>= 16;
			LastLineFromChar = ScreenLines >> 1;
			/////////
			FindIt();
			/////////
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

void FindIt(void)
{
	int x, y = 0, z;

	for (x = 0; Find[x] != 0; x++)
		if ((Find[x] >= 'a') && (Find[x] <= 'z'))
			Find[x] &= 0xDF;//make uppercase
	for (x = NextFind; x < FindSize; x++)
	{
		if ((pFind[x] >= 'a') && (pFind[x] <= 'z'))
			pFind[x] &= 0xDF;
		if (Find[0] == pFind[x])
		{
			for (y = 1, z = x+1; Find[y] != 0; y++, z++)
			{
				if ((pFind[z] >= 'a') && (pFind[z] <= 'z'))
					pFind[z] &= 0xDF;
				if (Find[y] != pFind[z])
					break;
			}
			if (Find[y] == 0)
			{
				NextFind = x+1;
				z = SendMessage(hwndInstr, EM_LINEFROMCHAR, (WPARAM)x, 0);
				if (z > (ScreenLines >> 1))
					SendMessage(hwndInstr, EM_LINESCROLL, 0, (LPARAM)(z-LastLineFromChar));
				LastLineFromChar = z;
				SendMessage(hwndInstr, EM_SETSEL, (WPARAM)x, (LPARAM)x+y);
				break;//found it
			}
		}
	}
	if (Find[y] != 0)
	{
		MessageBox(hwndInstr, "Not found", "", MB_OK);
		SetFocus(hwndInstr);
	}
}

void RestoreScreen(void)
{
	bigjpeg = FALSE;
	Zoom = saveZoom;
	rowOffset = saveRowOffset;
	colOffset = saveColOffset;
	PixelsPerTile = savePixelsPerTile;
	MetersPerTile = saveMetersPerTile;
	TilesAcross = saveTilesAcross;
	TilesDown = saveTilesDown;
	ImageSize = saveImageSize;
	fromOpen = TRUE;
}

int BigJpeg(void)
{
	#define TILESIZE 200
//int screen_buf_size;
//BYTE *screen_buf;
	int x, y, i, j, smallrow;
	int quality = 75;
	int mcu_width, mcu_height, num_x_mcu, num_y_mcu, dib_line_size, dib_chunk_size;
	int BYTES_WIDE, IMAGE_SIZE;
	int BeginW, LeftSide, NumOfPtrs, OrigNumOfPtrs, InitialOffset, PtrOffset, DataSize, cyVScroll;
	int row, col, TotalRows, TotalCols, TotalColsXBytesWide, LastRow, LastCol, col_offset, row_offset, PadBytes;
	int big_buf_size;
	void *p;//trick
	int *ptrFile;//points to PtrFileName data
	BYTE *dib_chunk_ptr;
	BYTE *dtaFile;//points to FileName data
	BYTE *pixel_buf;//individual un-jpegged photo data
	BYTE *big_buf;//points to big un-jpegged data
	int tomp;
	char Temp[] = "Temp.dta";
	char temp[10];
	char WorldFile[] = "1.000000\r\n0.000000\r\n0.000000\r\n-1.000000\r\nxxxxxx.00000\r\nyyyyyyy.00000\r\n";
	char WorldFileName[25];
//	char LeftUTM[] = "xxxxxx\r\n";
//	char RightUTM[] = "xxxxxx\r\n";
//	char BottomUTM[] = "xxxxxxx\r\n";
//	char TopUTM[] = "xxxxxxx\r\n";
	char txt[] = "txt";
	char FileName[32];//USAPhotoMapsData/z10y12345.dta or BigPhotoMapsData/z10y1234.dta
	char PtrFileName[32];
	char dta[] = ".dta\0";
	char ptr[] = ".ptr\0";
	char jgw[] = ".jgw\0";
	char jpg[] = ".jpg\0";
	DWORD fileSize, dwBytesRead, dwBytesWritten;
	HWND hwndPB;
	HANDLE hFile, hFile2, hFile4;
	LPBITMAPINFO lpbi;
	JPEG_CORE_PROPERTIES jcprops, jcprops2;

	for (x = 0; fileName[x] != '\\'; x++)
		FileName[x] = fileName[x];
	FileName[x] = fileName[x];
	if (BigJpegFilename[18] == 't')
		FileName[17] = 'a';
	else if ((BigJpegFilename[18] == 'p') || (BigJpegFilename[18] == 'b'))
		FileName[17] = 'z';
	else if (BigJpegFilename[18] == 'u')
		FileName[17] = 'u';
	else if (BigJpegFilename[18] == 'c')
		FileName[17] = 'c';
	else if (BigJpegFilename[18] == 'T')
		FileName[17] = 't';
	else
	{
		MessageBox(NULL, "Something went wrong!\nInform jdmcox@jdmcox.com", ERROR, MB_OK);
		bigjpeg = FALSE;
		return 0;
	}
	FileName[18] = BigJpegFilename[16];
	FileName[19] = BigJpegFilename[17];
	FileName[20] = 'y';
	for (x = 0, y = 8; x < 7; x++, y++)
		temp[x] = BigJpegFilename[y];
	temp[x] = 0;
	tomp = atoi(temp);
	saveRowOffset = rowOffset;
	saveColOffset = colOffset;
	saveZoom = Zoom;
	savePixelsPerTile = PixelsPerTile;
	saveMetersPerTile = MetersPerTile;
	saveTilesAcross = TilesAcross;
	saveTilesDown = TilesDown;
	saveImageSize = ImageSize;
	Zoom = 1;
	PixelsPerTile = TILESIZE;
	TilesAcross = (rect.right / PixelsPerTile) + 1;
	TilesDown = (rect.bottom / PixelsPerTile) + 1;
	MetersPerTile = TILESIZE;
	BYTES_WIDE = TILESIZE;
	IMAGE_SIZE = TILESIZE*TILESIZE;
	if (BigJpegFilename[18] == 't')
	{//topo
		MetersPerTile = 800;
		BYTES_WIDE *= 3;
		IMAGE_SIZE *= 3;
		WorldFile[0] = '4';
		WorldFile[31] = '4';
	}
	else if (BigJpegFilename[18] == 'b')
	{//big
		Zoom = 5;
		MetersPerTile = 1600;
		WorldFile[0] = '8';
		WorldFile[31] = '8';
	}
	else if (BigJpegFilename[18] == 'u')
	{//urban area
		MetersPerTile = 50;
		BYTES_WIDE *= 3;
		IMAGE_SIZE *= 3;
		WorldFile[0] = '0';
		WorldFile[2] = '2';
		WorldFile[3] = '5';
		WorldFile[31] = '0';
		WorldFile[33] = '2';
		WorldFile[34] = '5';
	}
	else if (BigJpegFilename[18] == 'c')
	{//big urban area
		Zoom = 5;
		MetersPerTile = 800;
		BYTES_WIDE *= 3;
		IMAGE_SIZE *= 3;
		WorldFile[0] = '4';
		WorldFile[31] = '4';
	}
	else if (BigJpegFilename[18] == 'T')
	{//big topo
		Zoom = 5;
		MetersPerTile = 12800;
		WorldFile[0] = '6';
		WorldFile[1] = '4';
		WorldFile[2] = '.';
		WorldFile[31] = '6';
		WorldFile[32] = '4';
		WorldFile[33] = '.';
		BYTES_WIDE *= 3;
		IMAGE_SIZE *= 3;
	}
	tomp /= MetersPerTile;
	_itoa(tomp, temp, 10);
	for (x = 0, y = 21; temp[x] != 0; x++, y++)
		FileName[y] = temp[x];
	FileName[y] = 0;
	strcpy(PtrFileName, FileName);
	for (x = 0; x < 5; x++, y++)
	{
		FileName[y] = dta[x];
		PtrFileName[y] = ptr[x];
	}
	for (x = 0; BigJpegFilename[x] != '.'; x++)
		FileOut[x] = BigJpegFilename[x];
	for (y = 0; y < 5; x++, y++)
		FileOut[x] = jpg[y];
	for (x = 41, y = 1; y < 7; x++, y++)
		WorldFile[x] = BigJpegFilename[y];
	for (x = 55, y = 8; y < 15; x++, y++)
		WorldFile[x] = BigJpegFilename[y];
	for (x = 0; BigJpegFilename[x] != '.'; x++)
		WorldFileName[x] = BigJpegFilename[x];
	for (y = 0; y < 5; x++, y++)
		WorldFileName[x] = jgw[y];

	col = atoi(BigJpegData) / MetersPerTile;
	BeginW = col;
	for (x = 0; BigJpegData[x] != '\n'; x++)
		;
	x++;//to LastCol
	LastCol = atoi(&BigJpegData[x]) / MetersPerTile;
	for ( ; BigJpegData[x] != '\n'; x++)
		;
	x++;//to row
	row = (atoi(&BigJpegData[x]) - MetersPerTile) / MetersPerTile;//go to bottom of top image
	for ( ; BigJpegData[x] != '\n'; x++)
		;
	x++;//to LastRow
	LastRow = (atoi(&BigJpegData[x]) - MetersPerTile) / MetersPerTile;

	TotalRows = row - LastRow;
	TotalCols = LastCol - col;
	if (0 == TotalCols)
	{
		RestoreScreen();
		SendMessage(hwnd, WM_USER2, 0, 0);
		return 0;
	}
	TotalColsXBytesWide = TotalCols * BYTES_WIDE;

	PadBytes = IJL_DIB_PAD_BYTES(TILESIZE, 3);
	big_buf_size = (BYTES_WIDE*3)+(BYTES_WIDE*(LastCol-col))+(TotalColsXBytesWide*TILESIZE);
	big_buf = (BYTE*)VirtualAlloc(NULL, big_buf_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (NULL == big_buf)
	{
		MessageBox(NULL, "Not enough memory", NULL, MB_OK);
		RestoreScreen();
		SendMessage(hwnd, WM_USER2, 0, 0);
		return 0;
	}

	SetCursor(hWaitingCursor);

	lpbi = NULL;
	pixel_buf = NULL;
	if (FileName[17] == 'z')
		lpbi = (struct tagBITMAPINFO*)malloc(40 + (256*4) + IMAGE_SIZE);//black & white
	else
		pixel_buf = (BYTE*)malloc(IMAGE_SIZE);
/*//this method of including "annotations" in Big Jpeg would cut off some annotations
	x = ((cxScreen/TILESIZE)*TILESIZE) + TILESIZE;
	y = ((cyScreen/TILESIZE)*TILESIZE) + TILESIZE;
	screen_buf_size = x * y * 3;
	screen_buf = (BYTE*)VirtualAlloc(NULL, screen_buf_size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
	bmih2.biSize = sizeof(BITMAPINFOHEADER);
	bmih2.biWidth = x;
	bmih2.biHeight = -y;// - for right-side-up picture
	bmih2.biPlanes = 1;
	bmih2.biBitCount = 24;
	bmih2.biCompression = BI_RGB;
	bmih2.biSizeImage = screen_buf_size;
	bmi2.bmiHeader = bmih2;

	for (rowOffset = row-(cyScreen/TILESIZE); rowOffset > (LastRow-TilesDown); rowOffset -= TilesDown)
	{
		for (colOffset = col; colOffset < LastCol; colOffset += TilesAcross)
		{
			fromOpen = TRUE;
			SendMessage(hwnd, WM_USER2, 0, 0);
			hdc = GetDC(hwnd);
			GetDIBits(hdc, hBitmap, 0, y, screen_buf, &bmi2, DIB_RGB_COLORS);
			ReleaseDC(hwnd, hdc);
			MessageBox(hwnd, "", "", MB_OK);
		}
	}
	VirtualFree(screen_buf, 0, MEM_RELEASE);
*/
	hFile4 = CreateFile(Temp, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);

	InitCommonControls();
	cyVScroll = GetSystemMetrics(SM_CYVSCROLL);
	hwndPB = CreateWindowEx(0, PROGRESS_CLASS, "",
		WS_CHILD | WS_VISIBLE,
		rect.left, rect.bottom - cyVScroll, rect.right, cyVScroll,
		hwnd, (HMENU)0, hInst, NULL);

	SendMessage(hwndPB, PBM_SETRANGE, 0, MAKELPARAM(0, row-LastRow));
	SendMessage(hwndPB, PBM_SETSTEP, (WPARAM) 1, 0);

	for (row_offset = 0; row > LastRow; row_offset += TotalColsXBytesWide*TILESIZE, row--)
	{
//		for (x = 0; x < big_buf_size; x++)
//			big_buf[x] = 0xFF;//white
		_asm pushad
		_asm pushfd
		_asm mov ecx, 4
		_asm mov eax, big_buf
		_asm sub edx, edx
		_asm div ecx  /*get remainder in edx*/
		_asm mov edi, big_buf
		_asm mov eax, 0xFFFFFFFF//white
		_asm mov ecx, big_buf_size
		_asm add edx, 4
		_asm sub ecx, 4/*for remainder stosb*/
		_asm shr ecx, 2/*div 4*/
		_asm or ecx, ecx
		_asm jz asm3
asm1:	_asm stosd
		_asm dec ecx
		_asm jnz asm1
		_asm or edx, edx
		_asm jz asm3
asm2:	_asm stosb
		_asm dec edx
		_asm jnz asm2
asm3:	_asm popfd
		_asm popad

		dtaFile = NULL;
		col = BeginW;
		col_offset = 0;
//get file name of each row of photo jpeg data
		x = 21;
		_itoa(row, &FileName[21], 10);
		_itoa(row, &PtrFileName[21], 10);
		for ( ; FileName[x] != 0; x++)
			;
		for (y = 0 ; y < 5; x++, y++)
		{
			FileName[x] = dta[y];
			PtrFileName[x] = ptr[y];
		}
//put each row of photo jpeg data into memory
		hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			if (fileSize = GetFileSize(hFile, NULL))
			{
				dtaFile = (BYTE*)malloc(fileSize);
				ReadFile(hFile, dtaFile, fileSize, &dwBytesRead, NULL);
			}
			CloseHandle(hFile);
		}
		else
		{
			if (lpbi != NULL)
				free(lpbi);
			else if (pixel_buf != NULL)
				free(pixel_buf);
			VirtualFree(big_buf, 0, MEM_RELEASE);
			MessageBox(NULL, FileName, "Couldn't find:", MB_OK);
			DestroyWindow(hwndPB);
			SetCursor(hCursor);
			RestoreScreen();
			SendMessage(hwnd, WM_USER2, 0, 0);
			return 0;
		}
		hFile2 = CreateFile(PtrFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile2 != INVALID_HANDLE_VALUE)
		{
			if (fileSize = GetFileSize(hFile2, NULL))
			{
//get each photo's jpeg data
				ptrFile = (int*)malloc(fileSize);
				ReadFile(hFile2, ptrFile, fileSize, &dwBytesRead, NULL);
				LeftSide = ptrFile[0];
				NumOfPtrs = ptrFile[1];
				OrigNumOfPtrs = NumOfPtrs;
				ptrFile[1] = 0;//offset of first jpeg photo data in .dta file
				for ( ; col < LastCol; col_offset += BYTES_WIDE, col++)// && (NumOfPtrs > 0) , NumOfPtrs--
				{
//					if (col < LeftSide)
//					{
//						for (smallrow = 0, y = 0; y < TILESIZE; smallrow += TotalColsXBytesWide, y++)
//						{
//							for (x = 0; x < BYTES_WIDE; x++)
//								big_buf[col_offset + smallrow + x] = 0;//black
//						}
//					}
//					else
					if (col >= LeftSide)
					{
						InitialOffset = col - LeftSide + 1;
						PtrOffset = ptrFile[InitialOffset];
						if (InitialOffset > OrigNumOfPtrs)
							DataSize = 0;
						else
							DataSize = ptrFile[InitialOffset+1] - ptrFile[InitialOffset];
						if (DataSize != 0)
						{
							if (FileName[17] == 'z')
							{
								if (lpbi == NULL)
								{
									MessageBox(NULL, "Oh Oh!", NULL, MB_OK);
									DestroyWindow(hwndPB);
									SetCursor(hCursor);
									RestoreScreen();
									SendMessage(hwnd, WM_USER2, 0, 0);
									return 0;
								}
								lpbi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
								lpbi->bmiHeader.biWidth = TILESIZE;
								lpbi->bmiHeader.biHeight = TILESIZE;
								lpbi->bmiHeader.biPlanes = 1;
								lpbi->bmiHeader.biBitCount = 8;
								lpbi->bmiHeader.biCompression = BI_RGB;
								lpbi->bmiHeader.biSizeImage = 0;
								lpbi->bmiHeader.biXPelsPerMeter = 0;
								lpbi->bmiHeader.biYPelsPerMeter = 0;
								lpbi->bmiHeader.biClrUsed = 0;
								lpbi->bmiHeader.biClrImportant = 0;
								for (x = 0; x < 256; x++)
								{
									lpbi->bmiColors[x].rgbRed      = x;
									lpbi->bmiColors[x].rgbGreen    = x;
									lpbi->bmiColors[x].rgbBlue     = x;
									lpbi->bmiColors[x].rgbReserved = 0;
								}
								p = &lpbi->bmiColors[x];//trick
								pixel_buf = (BYTE*)p;//trick
							}
//translate jpeg data into pixel_buf
							ijlInit(&jcprops);//use Intel's ijl15.dll to convert JPEG files
							jcprops.JPGBytes = &dtaFile[PtrOffset];//input
							jcprops.JPGSizeBytes = DataSize;
							jcprops.JPGFile = NULL;
							jcprops.JPGChannels = 3;
							jcprops.JPGColor = IJL_YCBCR;
							ijlRead(&jcprops, IJL_JBUFF_READPARAMS);

							jcprops.DIBWidth=TILESIZE;
							jcprops.DIBHeight = TILESIZE;
							if (FileName[17] == 'z')
							{
								jcprops.DIBPadBytes = 0;
								jcprops.DIBChannels = 1;
								jcprops.DIBColor = IJL_G;
							}
							else
							{
								jcprops.DIBPadBytes = PadBytes;
								jcprops.DIBChannels = 3;
								jcprops.DIBColor = IJL_BGR;
							}
							jcprops.DIBBytes = pixel_buf;//output
							ijlRead(&jcprops, IJL_JBUFF_READWHOLEIMAGE);
							ijlFree(&jcprops);
//put pixel_buf data into big_buf
							for (smallrow = 0, y = 0; y < TILESIZE; smallrow += TotalColsXBytesWide, y++)
							{
								for (x = 0; x < BYTES_WIDE; x++)
									big_buf[col_offset + smallrow + x] = pixel_buf[(y*BYTES_WIDE) + x];
							}
						}
//						else
//						{
//							for (smallrow = 0, y = 0; y < TILESIZE; smallrow += TotalColsXBytesWide, y++)
//							{
//								for (x = 0; x < BYTES_WIDE; x++)
//									big_buf[col_offset + smallrow + x] = 0;//black
//							}
//						}
					}
				}//end of for (col =
				WriteFile(hFile4, big_buf, TotalColsXBytesWide*TILESIZE, &dwBytesWritten, NULL);
				free(ptrFile);
			}//end of if (fileSize =
			CloseHandle(hFile2);
		}//end of if (hFile2 =
		else
		{
			if (lpbi != NULL)
				free(lpbi);
			if (pixel_buf != NULL)
				free(pixel_buf);
			VirtualFree(big_buf, 0, MEM_RELEASE);
			MessageBox(NULL, FileName, "Unable to find:", MB_OK);
			DestroyWindow(hwndPB);
			SetCursor(hCursor);
			RestoreScreen();
			SendMessage(hwnd, WM_USER2, 0, 0);
			return 0;
		}
		if (dtaFile != NULL)
			free(dtaFile);
		SendMessage(hwndPB, PBM_STEPIT, 0, 0);
	}//end of for (row =
	DestroyWindow(hwndPB);
	SetFilePointer(hFile4, 0, 0, FILE_BEGIN);//to read from beginning
	if (lpbi != NULL)
		free(lpbi);
	else if (pixel_buf != NULL)
		free(pixel_buf);
	VirtualFree(big_buf, 0, MEM_RELEASE);

//translate big_buf data into big_jpeg_buf
//	InitCommonControls();
	cyVScroll = GetSystemMetrics(SM_CYVSCROLL);
	hwndPB = CreateWindowEx(0, PROGRESS_CLASS, "",
		WS_CHILD | WS_VISIBLE,
 		rect.left, rect.bottom - cyVScroll, rect.right, cyVScroll,
		hwnd, (HMENU)0, hInst, NULL);

	SendMessage(hwndPB, PBM_SETRANGE, 0, MAKELPARAM(0, ((TotalCols * TILESIZE) + 16 - 1) / 16));
	SendMessage(hwndPB, PBM_SETSTEP, (WPARAM) 1, 0);

	ijlInit(&jcprops2);//use Intel's ijl15.dll to convert JPEG files
	jcprops2.DIBWidth = TotalCols * TILESIZE;
	jcprops2.DIBHeight = TotalRows * TILESIZE;
	jcprops2.DIBSubsampling = (IJL_DIBSUBSAMPLING)IJL_NONE;
	if (FileName[17] == 'z')
	{
		jcprops2.DIBPadBytes = 0;
		jcprops2.DIBChannels = 1;
		jcprops2.DIBColor = IJL_G;
	}
	else
	{
		jcprops2.DIBPadBytes = PadBytes;
		jcprops2.DIBChannels = 3;
		jcprops2.DIBColor = IJL_BGR;
	}
	jcprops2.DIBBytes = NULL;
	jcprops2.JPGWidth = TotalCols * TILESIZE;
	jcprops2.JPGHeight = TotalRows * TILESIZE;
	jcprops2.JPGBytes = NULL;
	jcprops2.JPGSizeBytes = 0;
	jcprops2.JPGFile = FileOut;
	jcprops2.JPGChannels = 3;
	jcprops2.JPGColor = IJL_YCBCR;
	jcprops2.JPGSubsampling = IJL_411;//4:1:1 subsampling
	jcprops2.jquality = quality;

	mcu_width = 16;
	mcu_height = 16;
	num_x_mcu = ((TotalCols * TILESIZE) + mcu_width - 1) / mcu_width;
	num_y_mcu = ((TotalRows * TILESIZE) + mcu_height - 1) / mcu_height;
	dib_line_size = (TotalCols * TILESIZE) * jcprops2.DIBChannels + IJL_DIB_PAD_BYTES((TotalCols * TILESIZE), jcprops2.DIBChannels);
	dib_chunk_size = dib_line_size * mcu_height;
	dib_chunk_ptr = (BYTE*)malloc(dib_chunk_size);
	jcprops2.DIBBytes = dib_chunk_ptr;
	for(j = 0; j < num_y_mcu; j++)
	{
		ReadFile(hFile4, dib_chunk_ptr, dib_chunk_size, &dwBytesRead, NULL);
		jcprops2.jprops.state.DIB_ptr = dib_chunk_ptr;
		for(i = 0; i < num_x_mcu; i++)
		{
			jcprops2.jprops.interrupt = 1;
			jerr = ijlWrite(&jcprops2,IJL_JFILE_WRITEWHOLEIMAGE);
			if(IJL_INTERRUPT_OK == jerr)
				continue;
			if(IJL_OK == jerr)
				break;
			if(IJL_OK > jerr)
				break;
		}
		SendMessage(hwndPB, PBM_STEPIT, 0, 0);
	}
	if(IJL_INTERRUPT_OK == jerr)
	{
		jcprops2.jprops.interrupt = 1;
		jerr = ijlWrite(&jcprops2,IJL_JFILE_WRITEWHOLEIMAGE);
	}
	ijlFree(&jcprops2);
	CloseHandle(hFile4);
	DeleteFile(Temp);
	DestroyWindow(hwndPB);
	hFile = CreateFile(WorldFileName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	WriteFile(hFile, WorldFile, sizeof(WorldFile), &dwBytesWritten, NULL);
	CloseHandle(hFile);
	hFile = CreateFile(BigJpegFilename, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);//ger
	WriteFile(hFile, BigJpegData, BigJpegDataSize, &dwBytesWritten, NULL);
	CloseHandle(hFile);
	SetCursor(hCursor);
	MessageBox(hwnd, "has been created in the USAPhotoMaps folder.", FileOut, MB_OK);
	RestoreScreen();
	SendMessage(hwnd, WM_USER2, 0, 0);
	return 0;
}

void SavenameCommentProc(void)
{
	char *pUSAPM;
	DWORD fileSize;

	pUSAPM = NULL;
	hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		fileSize = GetFileSize(hFile, NULL);
		pUSAPM = (char*)malloc(fileSize);
		ReadFile(hFile, pUSAPM, fileSize, &dwBytesRead, NULL);
	}
	else
	{
		fileSize = 0;
		hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	}
	CloseHandle(hFile);
	for (x = 0; x < (int)fileSize; x++)
	{
		if (pUSAPM[x] == '=')
		{
			if ((pUSAPM[x-7] == 'C') && (pUSAPM[x-11] == 'N') && (pUSAPM[x-15] == 'S'))
			{//ShowNameComment=
				if ((pUSAPM[x+1] == 'N') && (shownamecomment))
				{
					pUSAPM[x+1] = 'Y';
					pUSAPM[x+2] = 'E';
					if (pUSAPM[x+3] == ' ')
						pUSAPM[x+3] = 'S';
				}
				else if ((pUSAPM[x+1] == 'Y') && (shownamecomment == FALSE))
				{
					pUSAPM[x+1] = 'N';
					pUSAPM[x+2] = 'O';
					pUSAPM[x+3] = ' ';
				}
				hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, pUSAPM, fileSize, &dwBytesWritten, NULL);
				CloseHandle(hFile);
				break;
			}
		}
	}
	if (x == (int)fileSize)
	{
		hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile(hFile, ShowNameComment, strlen(ShowNameComment), &dwBytesWritten, NULL);
		CloseHandle(hFile);
	}
	if (pUSAPM != NULL)
		free(pUSAPM);
}

void SaveDescriptionProc(void)
{
	char *pUSAPM;
	DWORD fileSize;

	pUSAPM = NULL;
	hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		fileSize = GetFileSize(hFile, NULL);
		pUSAPM = (char*)malloc(fileSize);
		ReadFile(hFile, pUSAPM, fileSize, &dwBytesRead, NULL);
	}
	else
	{
		fileSize = 0;
		hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	}
	CloseHandle(hFile);
	for (x = 0; x < (int)fileSize; x++)
	{
		if (pUSAPM[x] == '=')
		{
			if ((pUSAPM[x-11] == 'D') && (pUSAPM[x-15] == 'S'))
			{//SaveDescription=
				if ((pUSAPM[x+1] == 'N') && (showdescription))
				{
					pUSAPM[x+1] = 'Y';
					pUSAPM[x+2] = 'E';
					if (pUSAPM[x+3] == ' ')
						pUSAPM[x+3] = 'S';
				}
				else if ((pUSAPM[x+1] == 'Y') && (showdescription == FALSE))
				{
					pUSAPM[x+1] = 'N';
					pUSAPM[x+2] = 'O';
					pUSAPM[x+3] = ' ';
				}
				hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, pUSAPM, fileSize, &dwBytesWritten, NULL);
				CloseHandle(hFile);
				break;
			}
		}
	}
	if (x == (int)fileSize)
	{
		hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile(hFile, ShowDescription, strlen(ShowDescription), &dwBytesWritten, NULL);
		CloseHandle(hFile);
	}
	if (pUSAPM != NULL)
		free(pUSAPM);
}

UINT WINAPI DownloadStatesThread(void*)
{
	#define inputsize 1920165 // exact size of States.gz
	#define outputsize 5547000
	char DownloadStates[] = "http://jdmcox.com/States.gz";
	char StatesGZ[] = "States.gz";
	char State[] = "States\\xx.txt";
	char StatesFolder[MAX_PATH];
	char States[] = "\\States\\";

	hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if (hInternet = InternetOpenUrl(hOpen, DownloadStates, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
	{
		hdc = GetDC(hwnd);
		TextOut(hdc, (rect.right/2) - 70, rect.bottom/2, "Downloading...", 14);
		ReleaseDC(hwnd, hdc);
		pBuf = (BYTE*)VirtualAlloc(NULL, inputsize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
		for (fileSize = 0; (goodread = InternetReadFile(hInternet, pBuf, inputsize, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
			;
		InternetCloseHandle(hInternet);
		if ((goodread) && (dwBytesRead == 0))
		{
			hFile = CreateFile(StatesGZ, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, pBuf, fileSize, &dwBytesWritten, NULL);
			CloseHandle(hFile);
			VirtualFree(pBuf, 0, MEM_RELEASE);

			pBuf = (BYTE*)VirtualAlloc(NULL, outputsize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			hGZFile = gzopen("States.gz", "rb");
			TarSize = gzread(hGZFile, pBuf, outputsize);
			gzclose(hGZFile);
			DeleteFile("States.gz");

			if (INVALID_HANDLE_VALUE == FindFirstFile(States, &fd))
			{
				for (x = 0; CurrentDir[x] != 0; x++)
					StatesFolder[x] = CurrentDir[x];
				for (y = 0; States[y] != 0; x++, y++)
					StatesFolder[x] = States[y];
				StatesFolder[x] = 0;
				CreateDirectory(StatesFolder, NULL);
			}
			for (x = 0, y = 0; x < 53; x++)
			{
				State[7] = pBuf[y++];
				State[8] = pBuf[y++];
				fileSize = *(int*)&pBuf[y];
				y += 4;
				hFile = CreateFile(State, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, &pBuf[y], fileSize, &dwBytesWritten, NULL);
				CloseHandle(hFile);
				y += fileSize;
			}
			VirtualFree(pBuf, 0, MEM_RELEASE);
			pBuf = NULL;
		}
		if (pBuf != NULL)
			VirtualFree(pBuf, 0, MEM_RELEASE);
	}
 	InternetCloseHandle(hOpen);
	hDownloadThread = 0;
	SendMessage(hwnd, WM_COMMAND, ID_GOTO_TOWNSHIP, 0);
	return 0;
}

UINT WINAPI DownloadStateOutlineThread(void*)
{
	int Inputsize = 962686;
	int Outputsize = 3000000;
	char DownloadStateOutlines[] = "http://jdmcox.com/StateOutlines.zip";
	char StatesZip[] = "StateOutlines.zip";

	hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if (hInternet = InternetOpenUrl(hOpen, DownloadStateOutlines, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
	{
		hdc = GetDC(hwnd);
		TextOut(hdc, (rect.right/2) - 70, rect.bottom/2, "Downloading...", 14);
		ReleaseDC(hwnd, hdc);
		pBuf = (BYTE*)VirtualAlloc(NULL, Inputsize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
		for (fileSize = 0; (goodread = InternetReadFile(hInternet, pBuf, Inputsize, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
			;
		InternetCloseHandle(hInternet);
		if ((goodread) && (dwBytesRead == 0))
		{
			hFile = CreateFile(StatesZip, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, pBuf, fileSize, &dwBytesWritten, NULL);
			CloseHandle(hFile);
			VirtualFree(pBuf, 0, MEM_RELEASE);

unzip2:		x = WinExec(UnzipUSA, SW_HIDE);
			if (x <= 31)
			{
				if (x == ERROR_FILE_NOT_FOUND)
				{//get unzip.exe from jdmcox.com
					if (IDYES == MessageBox(hwnd, "Do you want to download\nunzip.exe(164K) from jdmcox.com,\nand then try again?", "", MB_YESNO))
					{
						SetCursor(hWaitingCursor);
						hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
						if (hInternet = InternetOpenUrl(hOpen, GetUnzip, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
						{
							BYTE *unzip;
							unzip = (BYTE*)malloc(167936);
							for (fileSize = 0; (goodread = InternetReadFile(hInternet, unzip, 167936, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
								;
							InternetCloseHandle(hInternet);
							if ((goodread) && (dwBytesRead == 0))
							{
								HANDLE hunzipFile = CreateFile(unzipFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
								WriteFile(hunzipFile, unzip, fileSize, &dwBytesWritten, NULL);
								CloseHandle(hunzipFile);
							}
							free(unzip);
						}
						InternetCloseHandle(hOpen);
						SetCursor(hCursor);
						goto unzip2;
					}
				}
			}	
		}
	}
 	InternetCloseHandle(hOpen);
	hDownloadStatesThread = 0;
	if ((goodread) && (dwBytesRead == 0))
	{
		MessageBox(hwnd, "Got the state outline data","Ok...", MB_OK);
		SendMessage(hwnd, WM_COMMAND, ID_VIEW_MAPOFUSA, 0);
	}
	return 0;
}

UINT WINAPI DownloadUTMThread(void*)
{
	#define inputsize2 5000000 // to hold any XX.gz
	#define outputsize2 13000000
	char DownloadUTM[] = "http://jdmcox.com/XX.gz";
	char GZ[] = "XX.gz";
	char UTM[] = "States\\xx.dta";
	char StatesFolder[MAX_PATH];
	char States[] = "\\States\\";

	DownloadUTM[18] = GZ[0] = UTM[7] = (UTMZone / 10) + '0';
	DownloadUTM[19] = GZ[1] = UTM[8] = (UTMZone % 10) + '0';

	hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if (hInternet = InternetOpenUrl(hOpen, DownloadUTM, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
	{
		hdc = GetDC(hwnd);
		TextOut(hdc, (rect.right/2) - 70, rect.bottom/2, "Downloading...", 14);
		ReleaseDC(hwnd, hdc);
		pBuf = (BYTE*)VirtualAlloc(NULL, inputsize2, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);//to hold biggest .gx file
		for (fileSize = 0; (goodread = InternetReadFile(hInternet, pBuf, inputsize2, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
			;
		InternetCloseHandle(hInternet);
		if ((goodread) && (dwBytesRead == 0))
		{
			hFile = CreateFile(GZ, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, pBuf, fileSize, &dwBytesWritten, NULL);
			CloseHandle(hFile);
			VirtualFree(pBuf, 0, MEM_RELEASE);

			pBuf = (BYTE*)VirtualAlloc(NULL, outputsize2, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			hGZFile = gzopen(GZ, "rb");
			TarSize = gzread(hGZFile, pBuf, outputsize2);
			gzclose(hGZFile);
			DeleteFile(GZ);

			if (INVALID_HANDLE_VALUE == FindFirstFile(States, &fd))
			{
				for (x = 0; CurrentDir[x] != 0; x++)
					StatesFolder[x] = CurrentDir[x];
				for (y = 0; States[y] != 0; x++, y++)
					StatesFolder[x] = States[y];
				StatesFolder[x] = 0;
				CreateDirectory(StatesFolder, NULL);
			}
			for (x = 0, y = 0; x < 2; x++)
			{
				y += 2;
				fileSize = *(int*)&pBuf[y];
				y += 4;
				hFile = CreateFile(UTM, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, &pBuf[y], fileSize, &dwBytesWritten, NULL);
				CloseHandle(hFile);
				y += fileSize;
				UTM[10] = 'p';
				UTM[12] = 'r';
			}
			VirtualFree(pBuf, 0, MEM_RELEASE);
			pBuf = NULL;
		}
		if (pBuf != NULL)
			VirtualFree(pBuf, 0, MEM_RELEASE);
	}
 	InternetCloseHandle(hOpen);
	hDownloadThread = 0;
	SendMessage(hwnd, WM_COMMAND, ID_GOTO_USGSLANDMARK, 0);
	return 0;
}

int CALLBACK MapLocationProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetFocus(hwndText);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			TextBufSize = GetWindowText(hwndText, Area, MAX_PATH);
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

//TIGER SUBROUTINES & THREADS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CALLBACK GetTigerProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int index = 0;
	static HWND hwndList;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndList = GetDlgItem(hwndDlg, IDC_LIST1);
		for (x = 0; x < CountySize; x++)
		{
			z = x;
			for ( ; pCounties[x] != '\n'; x++)
				;
			pCounties[x-1] = 0;
			if ((pCounties[x-6] == Fips[0]) && (pCounties[x-5] == Fips[1]) && (pCounties[x-4] == Fips[2]) && (pCounties[x-3] == Fips[3]) && (pCounties[x-2] == Fips[4]) && (pCounties[x-1] == Fips[5]))
				County = index;
			SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)&pCounties[z]);
			index++;
		}
		if (Fips[0] != 0)
			SendMessage(hwndList, LB_SETCURSEL, County, 0);
		SetFocus(hwndList);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				County = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
				if (County == -1)
					break;
				break;
			}
			else if (HIWORD (wParam) == LBN_DBLCLK)
			{
				County = SendMessage(GetDlgItem(hwndDlg, IDC_LIST1), LB_GETCURSEL, 0, 0);
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else
				break;

		case IDOK:
			County = SendMessage(GetDlgItem(hwndDlg, IDC_LIST1), LB_GETCURSEL, 0, 0);
			if (County == -1)
				break;
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

void LatLontoUTM2(double Lat, double Lon)
{
	int UTMZoneMinusOne;
	double LatRad, LonRad;
	double Easting, Northing;
	double LongTemp, LongOrigin, LongOriginRad, N, T, C, A, M;

	LatRad = Lat*deg2rad;
	LonRad = Lon*deg2rad;
//Make sure the longitude is between -180.00 .. 179.9
	LongTemp = (Lon + 180) - (int)((Lon + 180) / 360) * 360 - 180; // -180.00 .. 179.9;
	UTMZoneMinusOne = (int)((LongTemp + 180) / 6);
	tUTMZone = UTMZoneMinusOne + 1;
	LongOrigin = (UTMZoneMinusOne) * 6 - 180 + 3;  //+3 puts origin in middle of zone
	LongOriginRad = LongOrigin * deg2rad;

	N = a0/sqrt(1-ECC_SQUARED*sin(LatRad)*sin(LatRad));
	T = tan(LatRad)*tan(LatRad);
	C = eccPrimeSquared*cos(LatRad)*cos(LatRad);
	A = cos(LatRad)*(LonRad-LongOriginRad);
	M = a0*((1	- ECC_SQUARED/4		- 3*ECC_SQUARED*ECC_SQUARED/64	- 5*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/256)*LatRad
 				- (3*ECC_SQUARED/8	+ 3*ECC_SQUARED*ECC_SQUARED/32	+ 45*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/1024)*sin(2*LatRad)
 									+ (15*ECC_SQUARED*ECC_SQUARED/256 + 45*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/1024)*sin(4*LatRad)
 									- (35*ECC_SQUARED*ECC_SQUARED*ECC_SQUARED/3072)*sin(6*LatRad));
	
	Easting = (k0*N*(A+(1-T+C)*A*A*A/6
					+ (5-18*T+T*T+72*C-58*eccPrimeSquared)*A*A*A*A*A/120)
					+ 500000.0);
	Northing = (k0*(M+N*tan(LatRad)*(A*A/2+(5-T+9*C+4*C*C)*A*A*A*A/24
				 + (61-58*T+T*T+600*C-330*eccPrimeSquared)*A*A*A*A*A*A/720)));
	tUTMEasting = (int)Easting;
	if (modf(Easting, &N) >= 0.500)
		tUTMEasting += 1;
	tUTMNorthing = (int)Northing;
	if (modf(Northing, &N) >= 0.500)
		tUTMNorthing += 1;
}

void GetTigerIndex(void)
{
	int utmz1, utmz2;
	double Lat, Lon, Lon2, Lat2;

	TigerIndex[21] = (UTMZone / 10) + '0';
	TigerIndex[22] = (UTMZone % 10) + '0';
	hIndexFile = CreateFile(TigerIndex, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hIndexFile != INVALID_HANDLE_VALUE)
	{
		if (IndexSize = GetFileSize(hIndexFile, NULL))
		{
			if (pTigerIndex != NULL)
			{
				free(pTigerIndex);
				pTigerIndex = NULL;
			}
			pTigerBoundaries = (char*)malloc(IndexSize);//input
			pTigerIndex = (char*)malloc(IndexSize);//output
			ReadFile(hIndexFile, pTigerBoundaries, IndexSize, &dwBytesRead, NULL);
			for (x = 0, y = 0; x < (int)IndexSize; x++)
			{//06003: 120.073332W 119.542332E 38.933324N 38.326880S  Alpine County, CA
				for (z = 0; z < 5; z++)
					pTigerIndex[y++] = pTigerBoundaries[x++];
				x++;//to West Longitude
				Lon = -atof(&pTigerBoundaries[x]);
				utmz1 = 30 - ((int)-Lon / 6);
				for ( ; pTigerBoundaries[x] != 'W'; x++)
					;
				x += 2;//to East Longitude:
				Lon2 = -atof(&pTigerBoundaries[x]);
				utmz2 = 30-((int)-Lon2 / 6);
				if (utmz1 != utmz2)
				{
					if (UTMZone == utmz1)
					{
						Lon2 = -(double)((30-utmz1) * 6);
						Lon2 -= 0.0001;//make -120.0 -120.0001
					}
					else if (UTMZone == utmz2)
					{
						Lon = -(double)((30-utmz2) * 6);
					}
					else//arbitrary
					{
						Lon2 = -(double)((30-utmz1) * 6);
						Lon2 -= 0.0001;//make -120.0 -120.0001
					}
				}
				for ( ; pTigerBoundaries[x] != 'E'; x++)
					;
				x += 2;//to North Latitude:
				Lat = atof(&pTigerBoundaries[x]);
				for ( ; pTigerBoundaries[x] != 'N'; x++)
					;
				x += 2;//to South Latitude:
				Lat2 = atof(&pTigerBoundaries[x]);
				LatLontoUTM2(Lat, Lon);
				*(int*)&pTigerIndex[y] = tUTMEasting;
				y += 4;
				*(int*)&pTigerIndex[y] = tUTMNorthing;
				y += 4;
				Lon = Lon2;//use North Lat because it gives a smaller tUTMEasting
				LatLontoUTM2(Lat, Lon);
				Lat = Lat2;//now get South Lat
				LatLontoUTM2(Lat, Lon);
				*(int*)&pTigerIndex[y] = tUTMEasting;
				y += 4;
				*(int*)&pTigerIndex[y] = tUTMNorthing;
				y += 4;
				for ( ; (pTigerBoundaries[x] != '\n') && x < (int)IndexSize; x++)
					;
 			}
			free(pTigerBoundaries);
			IndexSize = y;//for different use
		}
		CloseHandle(hIndexFile);
	}
//	else
//		MessageBox(hwnd, TigerIndex, "Couldn't find", MB_OK);
}

LRESULT CALLBACK TigerCountProc(HWND hwndTiger, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndCancel;
	HDC hdcTiger;
	PAINTSTRUCT ps;

	switch (message)
	{
	case WM_CREATE:
		hwndCancel = CreateWindow("BUTTON", "Cancel",
			WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
			cxChar*11, cyChar*5, cxChar*8, (cyChar*3)/2,
			hwndTiger, (HMENU)117, hInst, NULL);
		SetFocus(hwndCancel);//hwndTiger
		return 0;

	case WM_KEYDOWN:
		if (wParam == VK_ESCAPE)
			SendMessage(hwndTiger, WM_COMMAND, 0, (LPARAM)hwndCancel);
		return 0;

	case WM_COMMAND:
		if (lParam == (long)hwndCancel)//if cancel button pressed
		{
			SetEvent(hTigerEvent);
			SendMessage(hwndTiger, WM_CLOSE, 0, 0);
		}
		return 0;

	case WM_PAINT:
		hdcTiger = BeginPaint(hwndTiger, &ps);
		SetBkColor(hdcTiger, LIGHTGRAY);
		if (downloaded == FALSE)
		{
			TextOut(hdcTiger, cxChar, 0, Downloading, 11);
			TextOut(hdcTiger, cxChar, cyChar, Downloaded, 27);
		}
		else//if (downloaded)
		{
			if (hwndCancel != NULL)
			{
				SendMessage(hwndCancel, WM_CLOSE, 0, 0);
				hwndCancel = NULL;
			}
			TextOut(hdcTiger, cxChar, cyChar*2, Converting, 10);
			TextOut(hdcTiger, cxChar, cyChar*3, Converted, 31);
		}
		EndPaint(hwndTiger, &ps);
		return 0;

	case WM_CLOSE:
		notcancelled = FALSE;
		DestroyWindow(hwndTiger);
		break;		

	}
	return DefWindowProc(hwndTiger, message, wParam, lParam);
}

UINT WINAPI TigerCommThread(void*)
{
	static int PacketSize;
	static char Get[] = "GET /geo/tiger/tiger2006se/xx/ HTTP/1.1\r\nHost: www2.census.gov\r\nAccept: */*\r\n\r\n";
	static char GetZip[] = "GET /geo/tiger/tiger2006se/xx/TGRxxxxx.ZIP HTTP/1.0\r\nHost: www2.census.gov\r\nAccept: */*\r\n\r\n";
	static HANDLE hFile;

	downloadingstreets = TRUE;
	tiger = 0;
	GetZip[27] = GetTigerZip[45];
	Get[27] = GetTigerZip[45];
	GetZip[28] = GetTigerZip[46];
	Get[28] = GetTigerZip[46];
	for (x = 51, y = 33; x < 56; x++, y++)
		GetZip[y] = GetTigerZip[x];
	for (y = 0; y < 11; y++)
		Downloaded[y] = ' ';
//	for (y = 21; y < 27; y++)
//		Downloaded[y] = ' ';
	if (0 != WSAStartup(0x0202, &wsaData))
	{
		MessageBox(NULL, "bad socket startup", ERROR, MB_OK);
		return 0;
	}
	s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	if (INVALID_SOCKET == s)
	{
		MessageBox(hwnd, "bad socket", ERROR, MB_OK);
		WSACleanup();
		return 0;
	}
	he = gethostbyname("ftp2.census.gov");//"www2.census.gov"
	if (NULL == he)
	{
		MessageBox(hwnd, "bad host", ERROR, MB_OK);
		WSACleanup();
		return 0;
	}
	memcpy(&dest.sin_addr, he->h_addr_list[0], he->h_length);
//	dest.sin_addr.S_un.S_un_b.s_b1 = 148;
//	dest.sin_addr.S_un.S_un_b.s_b2 = 129;
//	dest.sin_addr.S_un.S_un_b.s_b3 = 75;
//	dest.sin_addr.S_un.S_un_b.s_b4 = 27;
//	dest.sin_family = 2;
	dest.sin_family = he->h_addrtype;
	dest.sin_port = htons(80);

	hSmallFile = CreateFile(SmallBufDta, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (SOCKET_ERROR == connect(s, (struct sockaddr*)&dest, sizeof(SOCKADDR)))
	{
		x = WSAGetLastError();
		sprintf(Error, "Connect error %i", x);
		MessageBox(hwnd, Error, ERROR, MB_OK);//"bad connect"
		goto quit2;
	}
/*
	if (SOCKET_ERROR == send(s, Get, strlen(Get), 0))
	{
		MessageBox(hwnd, "bad send GET", ERROR, MB_OK);
		goto quit2;
	}
	PacketSize = recv(s, &SmallBuf[y], SMALLBUF, 0);
	if (SOCKET_ERROR == PacketSize)
	{
		MessageBox(hwnd, "bad initial receive", ERROR, MB_OK);
		goto quit2;
	}
	for (x = 0; x < PacketSize; x++)
	{
		if ((SmallBuf[x] == 'z') && (SmallBuf[x-1] == '.'))
		{//.zip
			if ((SmallBuf[x-6] == TigerZip[3]) && (SmallBuf[x-5] == TigerZip[4]) && (SmallBuf[x-4] == TigerZip[5]) && (SmallBuf[x-3] == TigerZip[6]) && (SmallBuf[x-2] == TigerZip[7]))
			{
				for ( ; x < PacketSize; x++)
				{
					if (SmallBuf[x] == '\n')
					{
						for (y = 21, z = x-6; z < x; y++, z++)
							Downloaded[y] = SmallBuf[z];
						break;
					}
				}
				break;
			}
		}
	}
*/
	if (SOCKET_ERROR == send(s, GetZip, strlen(GetZip), 0))
	{
		MessageBox(hwnd, "bad send GET data", ERROR, MB_OK);
		goto quit2;
	}

	x = 0;
	do
	{//get the zip file
		PacketSize = recv(s, SmallBuf, SMALLBUFSIZE, 0);
		if (SOCKET_ERROR == PacketSize)
		{
			MessageBox(hwnd, "bad data receive", ERROR, MB_OK);
			break;
		}
		WriteFile(hSmallFile, SmallBuf, PacketSize, &dwBytesWritten, NULL);
		x += PacketSize;
		if (x >= 10000000)
			Downloaded[1] = (x / 10000000) + '0';
		if (x >= 1000000)
		{
			Downloaded[2] = ((x % 10000000) / 1000000) + '0';
			Downloaded[3] = ',';
		}
		if (x >= 100000)
			Downloaded[4] = ((x % 1000000) / 100000) + '0';
		if (x >= 10000)
			Downloaded[5] = ((x % 100000) / 10000) + '0';
		if (x >= 1000)
		{
			Downloaded[6] = ((x % 10000) / 1000) + '0';
			Downloaded[7] = ',';
		}
		Downloaded[8] = ((x % 1000) / 100) + '0';
		Downloaded[9] = ((x % 100) / 10) + '0';
		Downloaded[10] = (x % 10) + '0';
		if (notcancelled)
			InvalidateRect(hwndTiger, &tigerRect, FALSE);
		else
			break;
	}
	while (PacketSize != 0);// && (WaitForSingleObject(hTigerEvent, 0) != WAIT_OBJECT_0));
	if (PacketSize == 0)
		tiger = 1;
quit2:
	CloseHandle(hSmallFile);
	WSACleanup();
	if (notcancelled)
	{
		downloaded = TRUE;
		PostMessage(hwnd, WM_USER8, 0, 0);//the "go-between"
	}
	downloadingstreets = FALSE;
	return tiger;
}


void GetAngle(void)
{
	int BeginEast, BeginNorth, EndEast, EndNorth;
	double A, angle;
	BOOL setflag;

	BeginEast = TigerUTM[pNameBeginLatLon] & 0x000FFFFF;
	BeginNorth = TigerUTM[pNameBeginLatLon+1];
	EndEast = TigerUTM[TigerPtr-2];
	EndNorth = TigerUTM[TigerPtr-1];
	if (EndEast > BeginEast)
	{//going from left to right
		if (EndNorth > BeginNorth)
		{//angled up
			A = (double)(EndNorth - BeginNorth) / (double)(EndEast - BeginEast);
			angle = (rad2deg * atan(A));
		}
		else if (EndNorth == BeginNorth)
		{
			if (EndEast > BeginEast)
				angle = 0.0;
			else
				angle = 180.0;
		}
		else//if (EndNorth < BeginNorth)
		{//angled down
			A = (double)(BeginNorth - EndNorth) / (double)(EndEast - BeginEast);
			angle = (360.0 - (rad2deg * atan(A)));// + 270.0
		}
		setflag = FALSE;
	}
	else if (EndEast == BeginEast)
	{
		if (EndNorth <= BeginNorth)
			angle = 90.0;
		else
			angle = 270.0;
	}
	else//if (BeginEast > EndEast)
	{//going from right to left (backwards)
		if (EndNorth >= BeginNorth)
		{//angled up
			A = (double)(EndNorth - BeginNorth) / (double)(BeginEast - EndEast);
			angle = (360.0 - (rad2deg * atan(A)));
		}
		else//if (EndNorth < BeginNorth)
		{//angled down
			A = (double)(BeginNorth - EndNorth) / (double)(BeginEast - EndEast);
			angle = ((rad2deg * atan(A)));
 		}
		setflag = TRUE;
	}
	TigerAngle = (int)(10.0 * angle);
	if (setflag)
		TigerAngle |= 0x80000000;
	WriteFile(hNameFile, &TigerAngle, 4, &dwBytesWritten, NULL);
	if (Buf1[NameBegin-2] != ' ')
		WriteFile(hNameFile, &Buf1[NameBegin-2], 2, &dwBytesWritten, NULL);
	WriteFile(hNameFile, &Buf1[NameBegin], NameLen, &dwBytesWritten, NULL);
	if (Buf1[NameBegin+30] != ' ')
		WriteFile(hNameFile, &Buf1[NameBegin+30], 4, &dwBytesWritten, NULL);//over-writes a 0
	if (Buf1[NameBegin+34] != ' ')
		WriteFile(hNameFile, &Buf1[NameBegin+34], 2, &dwBytesWritten, NULL);
	WriteFile(hNameFile, "\x00", 1, &dwBytesWritten, NULL);
}


UINT WINAPI TigerThread(void* pParam)
{
	int w, x, y, z;
//	int fick, fuck, fook;
	int pTiger2, BoundaryTitle, TigerBoundsZone;
	int UTMNorthing1, UTMNorthing2, UTMEasting1, UTMEasting2;
	DWORD fileSize, fileSize1, fileSize2, dwBytesRead, dwBytesWritten;
	char *IndexBuf, *Buf2;
	char *BoundaryBuf;
	double Lat, Lon, Lon2;
	BOOL gotline, savename, gotangle;
	HANDLE hFile, hFile1, hFile2, hFile3;
	WIN32_FIND_DATA fd;

	saveshowstreets = showstreets;
	showstreets = FALSE;//to stop using it while its data is being changed
	TigerUTM = NULL;
	IndexBuf = NULL;
	Buf2 = NULL;

	for (x = 0; x < 10; x++)
		Converted[x] = ' ';
	for (x = 14; x < 24; x++)
		Converted[x] = ' ';
	if (INVALID_HANDLE_VALUE == FindFirstFile(TigerDir, &fd))
		CreateDirectory(TigerDir, NULL);
	else if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		;//it's a folder, don't do anything (yes, kludgy)
	else//it's not a folder
		CreateDirectory(TigerDir, NULL);

	if (INVALID_HANDLE_VALUE == FindFirstFile(TigerZip, &fd))
	{
		MessageBox(hwnd, TigerZip, "File not found", MB_OK);
		goto endo;
	}
	for (x = 3, y = 13; x < 8; x++, y++)
	{
		TigerName[y] = fd.cFileName[x];
		TigerDta[y] = fd.cFileName[x];
	}
	for (x = 3; x < 8; x++)
	{
		TigerMet[x] = fd.cFileName[x];
		TigerData[x] = fd.cFileName[x];
		TigerRecord1[x] = fd.cFileName[x];
		TigerRecord2[x] = fd.cFileName[x];
	}
	for (x = 0, y = 0; CurrentDir[x] != 0; x++, y++)
		ZippedTiger[y] = CurrentDir[x];
	ZippedTiger[y++] = '\\';
	for (x = 0; fd.cFileName[x] != 0; x++, y++)
		ZippedTiger[y] = fd.cFileName[x];
	ZippedTiger[y] = 0;
	for (x = 3, y = 16; x < 8; x++, y++)
	{
		Unzip[y] = fd.cFileName[x];
		Unzip[y+13] = fd.cFileName[x];
		Unzip[y+26] = fd.cFileName[x];
		Unzip[y+39] = fd.cFileName[x];
	}
	for (x = 3, y = 15; x < 8; x++, y++)
		OldTigerZip[y] = fd.cFileName[x];
unzip:
	x = WinExec(Unzip, SW_HIDE);//SW_SHOWNORMAL
	if (x <= 31)
	{
		if (x == ERROR_FILE_NOT_FOUND)
		{//get unzip.exe from jdmcox.com
			if (IDYES == MessageBox(hwnd, "Do you want to download\nunzip.exe(164K) from jdmcox.com,\nand then try again?", "", MB_YESNO))
			{
				SetCursor(hWaitingCursor);
				hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
				if (hInternet = InternetOpenUrl(hOpen, GetUnzip, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
				{
					BYTE *unzip;
					unzip = (BYTE*)malloc(167936);
					for (fileSize = 0; (goodread = InternetReadFile(hInternet, unzip, 167936, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
						;
					InternetCloseHandle(hInternet);
					if ((goodread) && (dwBytesRead == 0))
					{
						HANDLE hunzipFile = CreateFile(unzipFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
						WriteFile(hunzipFile, unzip, fileSize, &dwBytesWritten, NULL);
						CloseHandle(hunzipFile);
					}
					free(unzip);
				}
				InternetCloseHandle(hOpen);
				SetCursor(hCursor);
				goto unzip;
			}
			else
			{
				notcancelled = FALSE;
				goto prendo;
			}
		}
		else
		{
			if (x == ERROR_BAD_FORMAT)
				MessageBox(hwnd, "ERROR_BAD_FORMAT", ERROR, MB_OK);
			else if (x == ERROR_PATH_NOT_FOUND)
				MessageBox(hwnd, "ERROR_PATH_NOT_FOUND", ERROR, MB_OK);
			else
				MessageBox(hwnd, "Unknown Unzip Error!", ERROR, MB_OK);
			notcancelled = FALSE;
			goto prendo;
		}
	}

	if ((downloaded == FALSE) && (notcancelled))
	{//coming from Ctrl-Y
		downloaded = TRUE;
		hwndTiger = CreateWindow(Tiger, TigerZip,
			WS_CHILD | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
			(cxScreen/2)-(16*cxChar), (cyScreen/2)-((8*cyChar)/2), 30*cxChar, 10*cyChar,
			hwnd, (HMENU)176, hInst, NULL);
		GetClientRect(hwndTiger, &tigerRect);
		InvalidateRect(hwndTiger, &tigerRect, FALSE);
		UpdateWindow(hwndTiger);
	}
	SetCursor(hWaitingCursor);
	for (x = 0; x < 10; x++)
	{
		Sleep(1000);//give unzip.exe time to unzip the files
		hFile = CreateFile(TigerMet, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
			break;
	}

	if (hFile != INVALID_HANDLE_VALUE)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			IndexBuf = (char*)malloc(fileSize);
			ReadFile(hFile, IndexBuf, fileSize, &dwBytesRead, NULL);
			CloseHandle(hFile);
			hFile = NULL;
			for (x = 0; x < (int)fileSize; x++)
				if ((IndexBuf[x] == 'T') && (IndexBuf[x+5] == ':'))
					break;
			for ( ; x < (int)fileSize; x++)
				if (IndexBuf[x] == '\n')
					break;
			for ( ; IndexBuf[x] != ','; x--)
				;
			x++;//to title
			BoundaryTitle = x;
			
			for (x = 0; x < (int)fileSize; x++)
				if ((IndexBuf[x] == 'W') && (IndexBuf[x+4] == '_') && (IndexBuf[x+24] == ':'))
					break;
			if (x != (int)fileSize)
			{
				x += 27;//to West_Bounding_Coordinate:
				Lon = -atof(&IndexBuf[x]);
				for (y = 7; (IndexBuf[x] != '\n') && (x < (int)fileSize); x++, y++)
					TigerBounds[y] = IndexBuf[x];
				if (x == (int)fileSize)
					goto prendo;
				TigerBounds[y++] = 'W';
				TigerBounds[y++] = ' ';
				for ( ; (IndexBuf[x] != ':') && (x < (int)fileSize); x++)
					;//to East_Bounding_Coordinate
				if (x == (int)fileSize)
					goto prendo;
				x += 3;
				Lon2 = -atof(&IndexBuf[x]);
				for ( ; (IndexBuf[x] != '\n') && (x < (int)fileSize); x++, y++)
					TigerBounds[y] = IndexBuf[x];
				if (x == (int)fileSize)
					goto prendo;
				TigerBounds[y++] = 'E';
				TigerBounds[y++] = ' ';
				for ( ; (IndexBuf[x] != ':') && (x < (int)fileSize); x++)
					;//to North_Bounding_Coordinate
				if (x == (int)fileSize)
					goto prendo;
				for (x += 2; (IndexBuf[x] != '\n') && (x < (int)fileSize); x++, y++)
					TigerBounds[y] = IndexBuf[x];
				if (x == (int)fileSize)
					goto prendo;
				TigerBounds[y++] = 'N';
				TigerBounds[y++] = ' ';
				for ( ; (IndexBuf[x] != ':') && (x < (int)fileSize); x++)
					;//to South_Bounding_Coordinate
				if (x == (int)fileSize)
					goto prendo;
				x += 2;
				Lat = atof(&IndexBuf[x]);
				LatLontoUTM2(Lat, Lon);
				TigerBoundsZone = tUTMZone;
				if (tUTMZone != UTMZone)
				{//see if the east side of the data is in the current utm zone
					Lon = Lon2;
					LatLontoUTM2(Lat, Lon);
					if (tUTMZone == UTMZone)
						TigerBoundsZone = tUTMZone;
				}
				TigerIndex[21] = (TigerBoundsZone / 10) + '0';
				TigerIndex[22] = (TigerBoundsZone % 10) + '0';
				TigerDta[19] = TigerIndex[21];
				TigerDta[20] = TigerIndex[22];
				TigerName[19] = TigerIndex[21];
				TigerName[20] = TigerIndex[22];
				for ( ; (IndexBuf[x] != '\n') && (x < (int)fileSize); x++, y++)
					TigerBounds[y] = IndexBuf[x];
				if (x == (int)fileSize)
					goto prendo;
				TigerBounds[y++] = 'S';
				TigerBounds[y++] = ' ';
				for ( ; IndexBuf[BoundaryTitle] != '\n'; y++, BoundaryTitle++)
					TigerBounds[y] = IndexBuf[BoundaryTitle];
				for ( ; x <= (int)fileSize; x++)
				{//look for Place_Keyword: CA
					if ((IndexBuf[x] == 'P')
					 && (IndexBuf[x+5] == '_')
					 && (IndexBuf[x+6] == 'K')
					 && (IndexBuf[x+13] == ':')
					 && ((IndexBuf[x+15] >= 'A') && (IndexBuf[x+15] <= 'Z'))
					 && ((IndexBuf[x+16] >= 'A') && (IndexBuf[x+16] <= 'Z'))
					 && (IndexBuf[x+17] == '\n'))
 					{
						TigerBounds[y++] = ',';
						TigerBounds[y++] = ' ';
						TigerBounds[y++] = IndexBuf[x+15];
						TigerBounds[y++] = IndexBuf[x+16];
						break;
					}
				}
				TigerBounds[y++] = '\r';
				TigerBounds[y++] = '\n';
				if (y > 100)
					y = 100;//because of BoundaryBuf's new max size
				TigerBounds[y] = 0;
				for (x = 3, z = 0; x < 8; x++, z++)
					TigerBounds[z] = TigerMet[x];

				if (pTigerIndex != NULL)
				{
					free(pTigerIndex);//BoundaryBuf is the same
					pTigerIndex = NULL;
				}
				x = 0;
				hFile1 = CreateFile(TigerIndex, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
				if (fileSize = GetFileSize(hFile1, NULL))
				{
					BoundaryBuf = (char*)malloc(fileSize + 100);//hopefully big enough...
					ReadFile(hFile1, BoundaryBuf, fileSize, &dwBytesRead, NULL);
					for ( ; x < (int)fileSize; x++)
					{
						if ((TigerBounds[0] == BoundaryBuf[x])
						 && (TigerBounds[1] == BoundaryBuf[x+1])
						 && (TigerBounds[2] == BoundaryBuf[x+2])
						 && (TigerBounds[3] == BoundaryBuf[x+3])
						 && (TigerBounds[4] == BoundaryBuf[x+4])
						 && (TigerBounds[5] == BoundaryBuf[x+5]))
							break;//it's already there
						for ( ; (BoundaryBuf[x] != '\n') && (x < (int)fileSize); x++)
							;//to end of line
					}
					if (x >= (int)fileSize)
					{//not found - insert it numerically
						BOOL atlinebegin = TRUE;
						for (x = 0; x < (int)fileSize; x++)
						{
							if (atlinebegin)
							{
								atlinebegin = FALSE;
								if (TigerBounds[0] < BoundaryBuf[x])
									break;
								else if (TigerBounds[0] == BoundaryBuf[x])
								{
									if (TigerBounds[1] < BoundaryBuf[x+1])
										break;
									else if (TigerBounds[1] == BoundaryBuf[x+1])
									{
										if (TigerBounds[2] < BoundaryBuf[x+2])
											break;
										else if (TigerBounds[2] == BoundaryBuf[x+2])
										{
											if (TigerBounds[3] < BoundaryBuf[x+3])
												break;
											else if (TigerBounds[3] == BoundaryBuf[x+3])
											{
												if (TigerBounds[4] < BoundaryBuf[x+4])
													break;
												else if (TigerBounds[4] == BoundaryBuf[x+4])
												{
													if (TigerBounds[5] <= BoundaryBuf[x+5])
														break;
												}
											}
										}
									}
								}
							}
							if (BoundaryBuf[x] == '\n')
								atlinebegin = TRUE;
						}
						for (w = fileSize+y, z = fileSize; z >= x; z--, w--)
							BoundaryBuf[w] = BoundaryBuf[z];
						for (z = 0; z < y; x++, z++)
							BoundaryBuf[x] = TigerBounds[z];
						SetFilePointer(hFile1, 0, 0, FILE_BEGIN);
						WriteFile(hFile1, BoundaryBuf, fileSize+y, &dwBytesWritten, NULL);
					}
					free(BoundaryBuf);
				}
				else
					WriteFile(hFile1, TigerBounds, y, &dwBytesWritten, NULL);
				CloseHandle(hFile1);
			}//end of if (x !=
 		}
		if (hFile != NULL)
			CloseHandle(hFile);
	}
	else
	{
		MessageBox(hwnd, "wasn't unzipped.\nTry getting the .zip file again.", TigerMet, MB_OK);
		goto prendo;
	}

//	if (x == 0)
//	{
//		if (IndexBuf != NULL)
//			free(IndexBuf);
//		MessageBox(hwnd, TigerIndex, "Couldn't find", MB_OK);
//		goto prendo;//not found
//	}
	TigerPtr = 0;
	TigerUTM = (int*)VirtualAlloc(NULL, 10000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);//L.A. data is almost 8,000,000 bytes
	hNameFile = CreateFile(TigerName, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	hFile2 = CreateFile(TigerRecord2, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile2 != INVALID_HANDLE_VALUE)
	{//210 bytes/line
		if (fileSize2 = GetFileSize(hFile2, NULL))
		{
			Buf2 = (char*)VirtualAlloc(NULL, fileSize2, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			ReadFile(hFile2, Buf2, fileSize2, &dwBytesRead, NULL);
		}
		CloseHandle(hFile2);
	}

	hFile1 = CreateFile(TigerRecord1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile1 != INVALID_HANDLE_VALUE)
	{
		if (fileSize1 = GetFileSize(hFile1, NULL))
		{//230 bytes/line
			if (fileSize1 >= 10000000)
				Converted[14] = ((int)fileSize1 / 10000000) + '0';
			if (fileSize1 >= 1000000)
			{
				Converted[15] = (((int)fileSize1 % 10000000) / 1000000) + '0';
				Converted[16] = ',';
			}
			if (fileSize1 >= 100000)
				Converted[17] = (((int)fileSize1 % 1000000) / 100000) + '0';
			if (fileSize1 >= 10000)
				Converted[18] = (((int)fileSize1 % 100000) / 10000) + '0';
			if (fileSize1 >= 1000)
			{
				Converted[19] = (((int)fileSize1 % 10000) / 1000) + '0';
				Converted[20] = ',';
			}
			Converted[21] = (((int)fileSize1 % 1000) / 100) + '0';
			Converted[22] = (((int)fileSize1 % 100) / 10) + '0';
			Converted[23] = ((int)fileSize1 % 10) + '0';

			Buf1 = (char*)VirtualAlloc(NULL, fileSize1, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			ReadFile(hFile1, Buf1, fileSize1, &dwBytesRead, NULL);

			pTiger2 = 0;

			for (x = 0; x < (int)fileSize1; x += 230)
			{//the following is MUCH faster than using atof or strtod
				if ((Buf1[x+55] == 'A') || (Buf1[x+55] == 'P'))
				{//e.g. A41
					z = x + 191;
					if (Buf1[z] == '-')
					{
						z++;
						Lon = -(((double)(Buf1[z] - '0') * 10.0) + (double)(Buf1[z+1] - '0') + ((double)(Buf1[z+2] - '0') / 10.0) + ((double)(Buf1[z+3] - '0') / 100.0) + ((double)(Buf1[z+4] - '0') / 1000.0) + ((double)(Buf1[z+5] - '0') / 10000.0) + ((double)(Buf1[z+6] - '0') / 100000.0) + ((double)(Buf1[z+7] - '0') / 1000000.0));
					}
					else
						Lon = -(((double)(Buf1[z] - '0') * 100.0) + ((double)(Buf1[z+1] - '0') * 10.0) + (double)(Buf1[z+2] - '0') + ((double)(Buf1[z+3] - '0') / 10.0) + ((double)(Buf1[z+4] - '0') / 100.0) + ((double)(Buf1[z+5] - '0') / 1000.0) + ((double)(Buf1[z+6] - '0') / 10000.0) + ((double)(Buf1[z+7] - '0') / 100000.0) + ((double)(Buf1[z+8] - '0') / 1000000.0));
					z += 9;
					if (Buf1[z] == '+')
						z++;
					Lat = (((double)(Buf1[z] - '0') * 10.0) + (double)(Buf1[z+1] - '0') + ((double)(Buf1[z+2] - '0') / 10.0) + ((double)(Buf1[z+3] - '0') / 100.0) + ((double)(Buf1[z+4] - '0') / 1000.0) + ((double)(Buf1[z+5] - '0') / 10000.0) + ((double)(Buf1[z+6] - '0') / 100000.0) + ((double)(Buf1[z+7] - '0') / 1000000.0));
					LatLontoUTM2(Lat, Lon);
					UTMNorthing1 = tUTMNorthing;
					UTMEasting1 = tUTMEasting;
					if (tUTMZone != TigerBoundsZone)
						continue;
					z = x + 210;//ending Lat/Lon - check it "up-top" to continue if it's outside the current tUTMZone
					if (Buf1[z] == '-')
					{
						z++;
						Lon = -(((double)(Buf1[z] - '0') * 10.0) + (double)(Buf1[z+1] - '0') + ((double)(Buf1[z+2] - '0') / 10.0) + ((double)(Buf1[z+3] - '0') / 100.0) + ((double)(Buf1[z+4] - '0') / 1000.0) + ((double)(Buf1[z+5] - '0') / 10000.0) + ((double)(Buf1[z+6] - '0') / 100000.0) + ((double)(Buf1[z+7] - '0') / 1000000.0));
					}
					else
						Lon = -(((double)(Buf1[z] - '0') * 100.0) + ((double)(Buf1[z+1] - '0') * 10.0) + (double)(Buf1[z+2] - '0') + ((double)(Buf1[z+3] - '0') / 10.0) + ((double)(Buf1[z+4] - '0') / 100.0) + ((double)(Buf1[z+5] - '0') / 1000.0) + ((double)(Buf1[z+6] - '0') / 10000.0) + ((double)(Buf1[z+7] - '0') / 100000.0) + ((double)(Buf1[z+8] - '0') / 1000000.0));
					z += 9;
					if (Buf1[z] == '+')
						z++;
					Lat = (((double)(Buf1[z] - '0') * 10.0) + (double)(Buf1[z+1] - '0') + ((double)(Buf1[z+2] - '0') / 10.0) + ((double)(Buf1[z+3] - '0') / 100.0) + ((double)(Buf1[z+4] - '0') / 1000.0) + ((double)(Buf1[z+5] - '0') / 10000.0) + ((double)(Buf1[z+6] - '0') / 100000.0) + ((double)(Buf1[z+7] - '0') / 1000000.0));
					LatLontoUTM2(Lat, Lon);
					UTMNorthing2 = tUTMNorthing;
					UTMEasting2 = tUTMEasting;
					if (tUTMZone != TigerBoundsZone)
						continue;
					pNameBeginLatLon = TigerPtr;

					TigerUTM[TigerPtr++] = UTMEasting1;
					TigerUTM[TigerPtr++] = UTMNorthing1;
					FeatureType = (((Buf1[x+55] - 'A') << 6 ) | ((Buf1[x+56] - '0') * 10) | (Buf1[x+57] - '0'));
					if (FeatureType > 0xFFF)//'P' is last possible letter
						FeatureType = 0xFFF;
					NameBegin = x + 19;//to feature name (30 spaces)
					savename = FALSE;
					if (Buf1[NameBegin] != ' ')
					{//save name & its location
						savename = TRUE;
						z = x + 55;//to feature type
						WriteFile(hNameFile, &Buf1[z], 3, &dwBytesWritten, NULL);
						for (w = NameBegin+29; Buf1[w] == ' '; w--)
							;
	//					Buf1[w+1] = 0;//in case there's no 'Rd'
						NameLen = w-NameBegin+2;
						WriteFile(hNameFile, &TigerUTM[TigerPtr-2], 8, &dwBytesWritten, NULL);
					}
					TigerUTM[TigerPtr-2] |= (FeatureType << 20);
	//add data in RT2 to data in RT1
					gotline = gotangle = FALSE;
					for (y = pTiger2; y < (int)fileSize2; y += 210)
					{
	//if ((Buf2[y+7] == '6') && (Buf2[y+8] == '3') && (Buf2[y+9] == '1') && (Buf2[y+10] == '2') && (Buf2[y+11] == '3') && (Buf2[y+12] == '7') && (Buf2[y+13] == '7') && (Buf2[y+14] == '0'))
	//	x=x;																										//63123770
//	if ((Buf1[x+6] == '2')
//	 && (Buf1[x+7] == '1')
//	 && (Buf1[x+8] == '3')
//	 && (Buf1[x+9] == '1')
//	 && (Buf1[x+10] == '2')
//	 && (Buf1[x+11] == '3')
//	 && (Buf1[x+12] == '4')
//	 && (Buf1[x+13] == '8')
//	 && (Buf1[x+14] == '3'))
//		x=x;//213123483
	//					for (fick = x+5, fuck = x+14, fook = y+14; fuck > fick; fuck--, fook--)
	//						if (Buf1[fuck] != Buf2[fook])
	//							break;
	//					if (fuck == fick)
						if ((*(int*)&Buf1[x+11] == *(int*)&Buf2[y+11])
						 && (*(int*)&Buf1[x+7] == *(int*)&Buf2[y+7])
						 && (*(BYTE*)&Buf1[x+6] == *(BYTE*)&Buf2[y+6]))//a trick way of comparing 9 bytes
						{//add Buf2 data
							pTiger2 = y;
							z = y + 19;
							w = y + 190;
							do
							{
								if (Buf2[z] == '-')
									Lon = -(((double)(Buf2[z+1] - '0') * 10.0) + (double)(Buf2[z+2] - '0') + ((double)(Buf2[z+3] - '0') / 10.0) + ((double)(Buf2[z+4] - '0') / 100.0) + ((double)(Buf2[z+5] - '0') / 1000.0) + ((double)(Buf2[z+6] - '0') / 10000.0) + ((double)(Buf2[z+7] - '0') / 100000.0) + ((double)(Buf2[z+8] - '0') / 1000000.0));
								else
									Lon = -(((double)(Buf2[z] - '0') * 100.0) + ((double)(Buf2[z+1] - '0') * 10.0) + (double)(Buf2[z+2] - '0') + ((double)(Buf2[z+3] - '0') / 10.0) + ((double)(Buf2[z+4] - '0') / 100.0) + ((double)(Buf2[z+5] - '0') / 1000.0) + ((double)(Buf2[z+6] - '0') / 10000.0) + ((double)(Buf2[z+7] - '0') / 100000.0) + ((double)(Buf2[z+8] - '0') / 1000000.0));
								z += 10;
								Lat = (((double)(Buf2[z] - '0') * 10.0) + (double)(Buf2[z+1] - '0') + ((double)(Buf2[z+2] - '0') / 10.0) + ((double)(Buf2[z+3] - '0') / 100.0) + ((double)(Buf2[z+4] - '0') / 1000.0) + ((double)(Buf2[z+5] - '0') / 10000.0) + ((double)(Buf2[z+6] - '0') / 100000.0) + ((double)(Buf2[z+7] - '0') / 1000000.0));
								z += 9;
								LatLontoUTM2(Lat, Lon);
								if (tUTMZone != TigerBoundsZone)
									break;
								TigerUTM[TigerPtr++] = tUTMEasting;
								TigerUTM[TigerPtr++] = tUTMNorthing;
								if ((savename) && (gotline == FALSE))
								{
									GetAngle();//get only the first one
									gotangle = TRUE;
								}
								gotline = TRUE;
							} while ((Buf2[z] != '0') && (z <= w));
						}
						else if ((gotline) && (pTiger2) && (y >= (pTiger2+420)))
							break;//if got a line and then nothing after the next 2 lines
					}//end of for (y = ptiger2;

					TigerUTM[TigerPtr++] = UTMEasting2;
					TigerUTM[TigerPtr++] = UTMNorthing2;
					if ((savename) && (gotangle == FALSE))//if no Buf2 lat/lon
						GetAngle();
					TigerUTM[TigerPtr-1] |= 0x80000000;//flag for last in row
					if ((x % 230000) == 0)
					{
						if (x >= 10000000)
							Converted[0] = (x / 10000000) + '0';
						if (x >= 1000000)
						{
							Converted[1] = ((x % 10000000) / 1000000) + '0';
							Converted[2] = ',';
						}
						if (x >= 100000)
							Converted[3] = ((x % 1000000) / 100000) + '0';
						if (x >= 10000)
							Converted[4] = ((x % 100000) / 10000) + '0';
						if (x >= 1000)
						{
							Converted[5] = ((x % 10000) / 1000) + '0';
							Converted[6] = ',';
						}
						Converted[7] = ((x % 1000) / 100) + '0';
						Converted[8] = ((x % 100) / 10) + '0';
						Converted[9] = (x % 10) + '0';
						if (notcancelled)
						{
							InvalidateRect(hwndTiger, &tigerRect, FALSE);
							UpdateWindow(hwndTiger);
						}
						else
							break;
						if ((TigerPtr*4) >= 10000000)
						{
							MessageBox(hwnd, "(TigerPtr*4) >= 10000000", ERROR, MB_OK);
							goto badbreak;
						}
					}
					if (notcancelled == FALSE)
						break;
				}
			}//end of for (x = 0; x < (int)fileSize1; x += 230)

badbreak:	VirtualFree(Buf1, 0, MEM_RELEASE);
		}
		CloseHandle(hFile1);
	}
	CloseHandle(hNameFile);
	hFile3 = CreateFile(TigerDta, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	WriteFile(hFile3, TigerUTM, TigerPtr*4, &dwBytesWritten, NULL);
	CloseHandle(hFile3);
	if (TigerUTM != NULL)
		VirtualFree(TigerUTM, 0, MEM_RELEASE);
	if (Buf2 != NULL)
		VirtualFree(Buf2, 0, MEM_RELEASE);
prendo:
	if (IndexBuf != NULL)
		free(IndexBuf);
	if (INVALID_HANDLE_VALUE == FindFirstFile(OldTigerZip, &fd))
		MoveFile(fd.cFileName, OldTigerZip);
	else
		DeleteFile(fd.cFileName);
	DeleteFile(TigerMet);
	DeleteFile(TigerRecord1);
	DeleteFile(TigerRecord2);
endo:
	GetTigerIndex();
	if (notcancelled)
		SendMessage(hwndTiger, WM_CLOSE, 0, 0);
	SetCursor(hCursor);
	showstreets = saveshowstreets;
	InvalidateRect(hwnd, &rect, FALSE);
	CloseHandle((HANDLE)hThread);
	hThread = 0;
	MessageBeep(MB_OK);
	return 0;
}

void Uncheck(void)
{
	switch (HighestFeatureType)
	{
		case 19:
			CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_INTERSTATES, MF_UNCHECKED);
			break;
		case 39:
			CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_HIGHWAYS, MF_UNCHECKED);
			break;
		case 49:
			CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_LOCALSTREETS, MF_UNCHECKED);
			break;
		case 59:
			CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_TRAILS, MF_UNCHECKED);
			break;
		case 0xFF://'A255'
			CheckMenuItem(hMenu, ID_VIEW_TIGERLINES_EVERYTHING, MF_UNCHECKED);
			break;
	}
}

void FreepTiger(void)
{
	for (x = 0; x < MAXPTIGERS; x++)
	{
		if (pTiger[x] != NULL)
		{
			free(pTiger[x]);
			pTiger[x] = NULL;
		}
		if (pTigerNames[x] != NULL)
		{
			free(pTigerNames[x]);
			pTigerNames[x] = NULL;
		}
	}
	VirtualFree(pt, 0, MEM_RELEASE);
}

int Sign(double x)
{
	if (x < 0.0)
		return(-1);
	else
		return(1);
}

double adjust_lon(double x)
{// x is an angle in radians
	int count;
	double MaxLong = 2147483647.0;
	double DBLLONG = 4.61168601E+18;
	double HALF_PI = PI * 0.50;
	double TWO_PI = PI * 2.0;
	double FOURTH_PI = PI * 0.25;

	for (count = 0; count < 4; count++)
	{
		if (fabs(x) <= PI)
			break;
		else if (fabs(x/PI) < 2.0)
			x = x - (Sign(x) * TWO_PI);
		else if ((fabs(x/TWO_PI)) < MaxLong)
			x = x - (((x/TWO_PI))*TWO_PI);
		else if ((fabs(x/(MaxLong * TWO_PI))) < MaxLong)
			x = x - (((x/(MaxLong * TWO_PI))) * (TWO_PI * MaxLong));
		else if ((fabs(x/(DBLLONG * TWO_PI))) < MaxLong)
			x = x - (((x/(DBLLONG * TWO_PI))) * (TWO_PI * DBLLONG));
		else
			x = x - (Sign(x) * TWO_PI);
	}
	return x;
}

int LatLontoLambertAzimuthal(double lat, double lon)
{
	double radius = 6370997.0;
    double EPSLN = 0.0000000001;
    double R2D = 180.0 / PI;
	double D2R = PI / 180.0;
	double S2R = 0.00000484813681109536;
	double CENTERLAT = 45.0 * 3600.0 * S2R;
	double CENTERLONG = -100.0 * 3600.0 * S2R;
	double sinCLat = sin(CENTERLAT);
	double cosCLat = cos(CENTERLAT);
	double deltaLong;//Delta longitude (Given longitude - center
	double sinDeltaLong;
	double cosDeltaLong;
	double g;
	double ksp;//height above elipsiod
	double sinLat;
	double cosLat;

	lon *= D2R;//convert to radians
	lat *= D2R;
	sinLat = sin(lat);
	cosLat = cos(lat);
	deltaLong = adjust_lon(lon - CENTERLONG);
	sinDeltaLong = sin(deltaLong);
	cosDeltaLong = cos(deltaLong);
	g = (sinCLat * sinLat) + (cosCLat * cosLat * cosDeltaLong);
	if (g != -1)
	{
		ksp = radius * sqrt((2/(1+g)));
		Xlambert = ksp * cosLat * sinDeltaLong;
		Ylambert = ksp * ((cosCLat * sinLat) - (sinCLat * cosLat * cosDeltaLong));
	}
	else
	{
		MessageBox(hwnd, "g = -1", ERROR, MB_OK);
		return FALSE;
	}
	return TRUE;
}
/*
http://mike.teczno.com/Map_Projection/Lambert_Azimuthal_EqualArea.phps
function _GPSToMap($lat, $lon)
{
	$k = sqrt(2 / (1 + (sin($this->lat0) * sin($lat)) + (cos($this->lat0) * cos($lat) * cos($lon - $this->lon0))));
	$x = $k * cos($lat) * sin($lon - $this->lon0);
	$y = $k * ((cos($this->lat0) * sin($lat)) - (sin($this->lat0) * cos($lat) * cos($lon - $this->lon0)));
	$vector = new Math_Matrix(array(array($x, $y, 1)));
	$vector->multiply($this->transform);
	return array('x' => $vector->getElement(0, 0),'y' => $vector->getElement(0, 1));
}

function _mapToGPS($x, $y)
{
	$vector = new Math_Matrix(array(array($x, $y, 1)));
	$vector->multiply($this->inverse);
	$x = $vector->getElement(0, 0);
	$y = $vector->getElement(0, 1);
	$p = sqrt(pow($x, 2) + pow($y, 2));
	$c = 2 * asin(0.5 * $p);
	if ($p == 0) {
		$lat = $this->lat0;
		$lon = $this->lon0;
	} else {
		$lat = asin((cos($c) * sin($this->lat0)) + (($y * sin($c) * cos($this->lat0)) / $p));
		$lon = $this->lon0 + atan(($x * sin($c)) / (($p * cos($this->lat0) * cos($c)) - ($y * sin($this->lat0) * sin($c))));
	}
	return array('lat' => $lat, 'lon' => $lon);
}
*/

//"http://nationalatlas.gov/servlet/com.esri.esrimap.Esrimap?Name=VBAtlas&cmd=Identify&ClickX=1992787.08018333&ClickY=-261510.462855761&bgoff=T&visLayers=Counties,States";
void GetCountyFromLatLon(void)
{
	Fips[0] = 0;
	if (LatLontoLambertAzimuthal(Lat, Lon))
	{
		z = sprintf(Error, "%s%f", CountyFromLatLon1, Xlambert);
		z += sprintf((char*)&Error[z], "%s%f", CountyFromLatLon2, Ylambert);
		z += sprintf((char*)&Error[z], "%s", CountyFromLatLon3);

		hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
		if (hInternet = InternetOpenUrl(hOpen, Error, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
		{
			char *NotMyWebPage;
			NotMyWebPage = (char*)malloc(10000);//shouldn't get any bigger than this
			for (fileSize = 0; (goodread = InternetReadFile(hInternet, NotMyWebPage, 10000, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
				;
			InternetCloseHandle(hInternet);
			if ((goodread) && (dwBytesRead == 0))
			{
				for (x = 0; x < fileSize; x++)
				{//"states/xx/xxxxx."
					if ((NotMyWebPage[x] == 's') && (NotMyWebPage[x+1] == 't') && (NotMyWebPage[x+2] == 'a') && (NotMyWebPage[x+3] == 't') && (NotMyWebPage[x+4] == 'e') && (NotMyWebPage[x+5] == 's') && (NotMyWebPage[x+2] == 'a') && (NotMyWebPage[x+9] == '/') && (NotMyWebPage[x+15] == '.'))
					{
						for (x += 10, y = 0; y < 5; x++, y++)
							Fips[y] = NotMyWebPage[x];
						break;
					}
				}
//				if (x == fileSize)
//				{
//					HANDLE htempFile = CreateFile("NotMyWebPage.html", GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
//					WriteFile(htempFile, NotMyWebPage, fileSize, &dwBytesWritten, NULL);
//					CloseHandle(htempFile);
//					MessageBox(hwnd, "Can't find what county you're looking at.\nMaybe your mouse is not in a county\n(maybe it's over water).\nSee NotMyWebPage.html.", ERROR, MB_OK);
//				}
			}
			free(NotMyWebPage);
		}
		InternetCloseHandle(hOpen);
	}
}

UINT WINAPI FillCacheThread(void*)
{
	int rowOffset = (int)Param;
	int x, z, row, BigfileSize;
	BYTE *BigFileBuf;
	DWORD dwBytesRead;
	char Y[8];
	HANDLE hFill;
	int maxRows = rowOffset + TilesDown;
	SetEvent(hCacheOk);//it's started
	BigFileBuf = (BYTE*)VirtualAlloc(NULL, 10000000, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
	for (row = rowOffset; row < maxRows; row++)
	{
		for (x = 0, z = 18; x < 3; x++, z++)
			cachName[z] = ZoneName[x];
		_itoa(row, Y, 10);
		for (x = 0; Y[x] != 0; x++, z++)
			cachName[z] = Y[x];
		for (x = 0; x < 5; x++, z++)
			cachName[z] = Dta[x];
		hFill = CreateFile(cachName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		BigfileSize = GetFileSize(hFill, NULL);
		if (BigfileSize < 10000000)
			ReadFile(hFill, BigFileBuf, BigfileSize, &dwBytesRead, NULL);//just to fill up the Windows file cache
		CloseHandle(hFill);
		WaitForSingleObject(hCacheEvent, 1000);
	}
	VirtualFree(BigFileBuf, 0, MEM_RELEASE);
	return 0;
}

void InitDirectDraw(void)
{
	if (maximized)
	{
		lpDD7 = NULL;
		lpDDSPrimary = lpDDSBack = lpDDSBack2 = NULL;
		if (DD_OK == DirectDrawCreateEx(NULL, (VOID**)&lpDD7, IID_IDirectDraw7, NULL))
		{
			if (DD_OK == lpDD7->SetCooperativeLevel(hwnd, DDSCL_NORMAL))
			{
				ZeroMemory(&ddsd, sizeof(ddsd));
				ddsd.dwSize = sizeof(ddsd);
				ddsd.dwFlags = DDSD_CAPS;
				ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
				if (DD_OK == lpDD7->CreateSurface(&ddsd, &lpDDSPrimary, NULL))
				{
					ddsd.dwFlags = DDSD_CAPS|DDSD_WIDTH|DDSD_HEIGHT;
					ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
//					GetWindowRect(hwnd, &rect);//full screen
					GetClientRect(hwnd, &rect);//full screen
					rect.bottom += TitleAndMenu;
					ddsd.dwHeight = rect.bottom;
					ddsd.dwWidth = rect.right;
					if (DD_OK == lpDD7->CreateSurface(&ddsd, &lpDDSBack, NULL))
					{
						ddsd.dwWidth = rect.right+PixelsPerTile;
						if (DD_OK == lpDD7->CreateSurface(&ddsd, &lpDDSBack2, NULL))
						{
							if (DD_OK == lpDDSBack->Blt(&rect, lpDDSPrimary, &rect, DDBLT_WAIT, NULL))//the old screen
							{
								directdraw = TRUE;
							}
						}
					}
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GetStateBorders(void)
{
	char FullFilename[MAX_PATH] = "StateOutlines\\";
	static double Lat, Lon;

	for (x = 14, y = 0; fd.cFileName[y] != 0; x++, y++)
		FullFilename[x] = fd.cFileName[y];
	FullFilename[x] = 0;
	hFile = CreateFile(FullFilename, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		if (fileSize = GetFileSize(hFile, NULL))
		{
			ReadFile(hFile, USABuf, fileSize, &dwBytesRead, NULL);

			for (x = 0, y = 0; x < (int)fileSize; x++)
			{
				if ((USABuf[x] == 10) && (USABuf[x-1] == 13))//end of line
					y++;
			}
			TotalLams += y;

			LambertX[Lams] = 0;//flag to indicate beginning of this state data
			LambertY[Lams] = 0;
			Lams++;
			TotalLams++;
			for (x = 0; Lams < TotalLams; Lams++)
			{
				Lat = (((double)(USABuf[x] - '0') * 10.0)
				 + (double)(USABuf[x+1] - '0')
				 + ((double)(USABuf[x+3] - '0') / 10.0)
				 + ((double)(USABuf[x+4] - '0') / 100.0)
				 + ((double)(USABuf[x+5] - '0') / 1000.0)
				 + ((double)(USABuf[x+6] - '0') / 10000.0)
				 + ((double)(USABuf[x+7] - '0') / 100000.0)
				 + ((double)(USABuf[x+8] - '0') / 1000000.0));
				x += 11;
				if (USABuf[x+2] == '.')
				{
					Lon = -(((double)(USABuf[x] - '0') * 10.0)
					 + (double)(USABuf[x+1] - '0')
					 + ((double)(USABuf[x+3] - '0') / 10.0)
					 + ((double)(USABuf[x+4] - '0') / 100.0)
					 + ((double)(USABuf[x+5] - '0') / 1000.0)
					 + ((double)(USABuf[x+6] - '0') / 10000.0)
					 + ((double)(USABuf[x+7] - '0') / 100000.0)
					 + ((double)(USABuf[x+8] - '0') / 1000000.0));
					x += 11;
				}
				else if (USABuf[x+3] == '.')
				{
					Lon = -(((double)(USABuf[x] - '0') * 100.0)
					 + ((double)(USABuf[x+1] - '0') * 10.0)
					 + (double)(USABuf[x+2] - '0')
					 + ((double)(USABuf[x+4] - '0') / 10.0)
					 + ((double)(USABuf[x+5] - '0') / 100.0)
					 + ((double)(USABuf[x+6] - '0') / 1000.0)
					 + ((double)(USABuf[x+7] - '0') / 10000.0)
					 + ((double)(USABuf[x+8] - '0') / 100000.0)
					 + ((double)(USABuf[x+9] - '0') / 1000000.0));
					x += 12;
				}
				if (Lat != 0.0)
				{
					LatLontoLambertAzimuthal(Lat, Lon);
					LambertX[Lams] = Xlambert;
					LambertY[Lams] = Ylambert;
				}
				else
				{
					LambertX[Lams] = 0.0;//flag
				}
			}
		}
		CloseHandle(hFile);
	}
}

int GetXY(void)
{//get pUSA[].x and pUSA[].y
	int x, y;
	int cxScreen = GetSystemMetrics(SM_CXFULLSCREEN);

	if (cxScreen >= 1600)
	{
		ScreenModifier = 2860.0;//1600x1200
		Xmodifier = 712;
		Ymodifier = 320;
		pZone = Zone1600;
		pLonx = Lon1600x;
		pLony = Lon1600y;
	}
	else if (cxScreen >=1280)
	{
		ScreenModifier = 3575.0;//1280x960 20/25
//		ScreenModifier = 3800.0;//1280x960 20/25 this was for my wide-screen laptop, but it screws up some things
		Xmodifier = 570;
		Ymodifier = (320*4)/5;
//		Ymodifier = (240*4)/5; ditto
		pZone = Zone1280;
		pLonx = Lon1280x;
		pLony = Lon1280y;
	}
	else if (cxScreen >=1152)
	{
		ScreenModifier = 3972.22;//1152x864 18/25
		Xmodifier = 512;
		Ymodifier = (320*18)/25;//202;
		pZone = Zone1152;
		pLonx = Lon1152x;
		pLony = Lon1152y;
	}
	else if (cxScreen >= 1024)
	{
		ScreenModifier = 4468.75;//1024x758 16/25
		Xmodifier = 455;
		Ymodifier = (320*16)/25;//179;
		pZone = Zone1024;
		pLonx = Lon1024x;
		pLony = Lon1024y;
	}
	else
	{
		ScreenModifier = 5720.0;//800x600 1/2
		Xmodifier = 356;
		Ymodifier = 150;
		pZone = Zone800;
		pLonx =	Lon1600y;//offsecreen
		pLony =	Lon1600y;//offscreen
	}

	for (x = 0, y = 0; y < Lams; y++)
	{
		if (LambertX[y] != 0.0)
		{
			pUSA[x].x = Xmodifier + (int)(LambertX[y] / ScreenModifier);
			pUSA[x].y = Ymodifier - (int)(LambertY[y] / ScreenModifier);
			if ((pUSA[x].x != pUSA[x-1].x) || (pUSA[x].y != pUSA[x-1].y))
				x++;
		}
		else
		{
			pUSA[x].x = 0;
			pUSA[x].y = 0;
			x++;
		}
	}
	return x;
}

LRESULT CALLBACK USAProc(HWND hwndUSA, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, y, z;
	char *IniBuf;
	static HDC hdc;
	static PAINTSTRUCT ps;
	static BOOL saveshowtext;

	switch(message)
	{
	case WM_CREATE:
		TotalLams = Lams = 0;
		hFindFile = FindFirstFile("StateOutlines\\*.txt", &fd);
		if (hFindFile != INVALID_HANDLE_VALUE)
		{
			LambertX = (double*)malloc(150000*sizeof(double));
			LambertY = (double*)malloc(150000*sizeof(double));
			pUSA = (POINT*)malloc(150000*sizeof(POINT));
			USABuf = (char*)malloc(160000);

			GetStateBorders();
			while (FindNextFile(hFindFile, &fd))
			{
				GetStateBorders();
			}
			FindClose(hFindFile);
			Lon = -120.0;
			for (x = 0; x < 9; x++)
			{
				Lat = 52.0;
				for (y = 0; y < 27; y++)
				{
					LatLontoLambertAzimuthal(Lat, Lon);
					LambertX[Lams] = Xlambert;
					LambertY[Lams] = Ylambert;
					Lams++;
					Lat --;
				}
				Lon += 6.0;
			}
			Lams = GetXY();

			ChangeUSAPhotoMapsIni();
			hFile = CreateFile(USAPhotoMapsIni, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				fileSize = GetFileSize(hFile, NULL);
				if (fileSize > 22)
				{
					IniBuf = (char*) malloc(fileSize);
					ReadFile(hFile, IniBuf, fileSize, &dwBytesRead, NULL);
					CloseHandle(hFile);

					tempLat = Lat;
					tempLon = Lon;
					tempUTMZone = UTMZone;
					tempUTMN = UTMNorthing;
					tempUTME = UTMEasting;
					for (x = 0, Dots = 0, USAIndex = 0; (x < fileSize) && (Dots < 500); x++)
					{//Anchorage&X=1736&Y=33960&Z=06
						if ((IniBuf[x] == '&') && (IniBuf[x+1] == 'X'))
						{
							UTMEasting = 200 * (((IniBuf[x+3] - '0') * 1000) + ((IniBuf[x+4] - '0') * 100) + ((IniBuf[x+5] - '0') * 10) + (IniBuf[x+6] - '0'));
							UTMNorthing = 200 * (((IniBuf[x+10] - '0') * 10000) + ((IniBuf[x+11] - '0') * 1000) + ((IniBuf[x+12] - '0') * 100) + ((IniBuf[x+13] - '0') * 10) + (IniBuf[x+14] - '0'));
							UTMZone = (((IniBuf[x+18] - '0') * 10) + (IniBuf[x+19] - '0'));
							UTMtoLatLon();
							if ((Lon > -124.0) && (Lon < -66.0) && (Lat > 24.0) && (Lat < 52.0))
							{
								LatLontoLambertAzimuthal(Lat, Lon);
								Dot[Dots].x = Xmodifier + (int)(Xlambert / ScreenModifier);
								Dot[Dots].y = Ymodifier - (int)(Ylambert / ScreenModifier);
								for (y = x; (IniBuf[y] != '\n') && (y != 0); y--)
									;
								if (y != 0)
									y++;
								for (z = 0; (y < x) && (25 > (x-y)); y++, z++)
									DotUSAName[Dots][z] = IniBuf[y];
								DotUSAName[Dots][z] = 0;
								DotUSAIndex[Dots] = USAIndex;
								Dots++;
							}
							USAIndex++;
						}
					}
					Lat = tempLat;
					Lon = tempLon;
					UTMZone = tempUTMZone;
					UTMNorthing = tempUTMN;
					UTMEasting = tempUTME;
					Dot[Dots].x = 0;
					Dot[Dots].y = 0;
					free(IniBuf);
				}
			}
			free(USABuf);
			free(LambertY);
			free(LambertX);
		}
		else
			DestroyWindow(hwndUSA);
		SetWindowText(hwnd, USA);

		saveshowtext = showtext;
		savedHead = head;
		head = new_node = NULL;
		if ((hFile = CreateFile(USADta, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
		{
			if (fileSize = GetFileSize(hFile, NULL))
			{
				showtext = TRUE;
				z = sizeof(struct Text);
				y = fileSize / z;
				for (x = 0; x < y; x++)
				{
					cur = (struct Text*) malloc(z);
					if (x != 0)
						prev->next = cur;
					else
						head = cur;
					ReadFile(hFile, cur, z, &dwBytesRead, NULL);
					prev = cur;
					cur->next = NULL;
				}
			}
			CloseHandle(hFile);
		}
		return 0;

	case WM_MOUSEMOVE:
		if (wParam == MK_SHIFT)
		{//if Shift key is down
			enteringtext = TRUE;
			xPos = LOWORD(lParam);
			yPos = HIWORD(lParam);
			if (xBeg == -1)
			{
				xBeg = xPos;
				yBeg = yPos;
			}
//			else
//			{
//				hdc = GetDC(hwndUSA);
//				MoveToEx(hdc, xBeg, yBeg, NULL);
//				LineTo(hdc, xPos, yPos);
//				ReleaseDC(hwndUSA, hdc);
//			}
			InvalidateRect(hwndUSA, &rect, FALSE);
			UpdateWindow(hwndUSA);
		}
		return 0;
/*
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		for (z = 0; Dot[z].x != 0; z++)
		{
			if ((x >= (Dot[z].x-4)) && (x <= (Dot[z].x+4)) && (y >= (Dot[z].y-4)) && (y <= (Dot[z].y+4)))
			{
				hdc = GetDC(hwnd);
				SetBkMode(hdc, TRANSPARENT);
				TextOut(hdc, Dot[z].x+10, Dot[z].y-10, DotUSAName[z], lstrlen(DotUSAName[z]));
				ReleaseDC(hwnd, hdc);
				break;
			}
		}
		if (Dot[z].x == 0)
		{//if not over a MapLocation dot, but the name is showing
			InvalidateRect(hwnd, &rect, FALSE);
		}
		return 0;

	case WM_RBUTTONDOWN:
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		for (z = 0; DotUSAx[z] != 0; z++)
		{
			if ((x >= (DotUSAx[z]-4)) && (x <= (DotUSAx[z]+4)) && (y >= (DotUSAy[z]-4)) && (y <= (DotUSAy[z]+4)))
			{
				notfromusa = FALSE;
				IniNumber = DotUSAIndex[z];
				SendMessage(hwnd, WM_COMMAND, ID_FILES_OPENMAPFILE, 0);
				SendMessage(hwnd, WM_RBUTTONDOWN, 0, 0);
				break;
			}
		}
		return 0;
*/
	case WM_LBUTTONDOWN:
		x = LOWORD(lParam);
		y = HIWORD(lParam);
		for (z = 0; Dot[z].x != 0; z++)
		{
			if ((x >= (Dot[z].x-4)) && (x <= (Dot[z].x+4)) && (y >= (Dot[z].y-4)) && (y <= (Dot[z].y+4)))
			{
				CheckMenuItem(hMenu, ID_APRS_RECEIVEINTERNETDATA, MF_UNCHECKED);
				aprs = tnc = FALSE;
 				notfromusa = FALSE;
				IniNumber = DotUSAIndex[z];
				SendMessage(hwnd, WM_KEYDOWN, VK_ESCAPE, 0);
				break;
			}
		}
		return 0;

	case WM_PAINT:
		hdc = BeginPaint(hwndUSA, &ps);
		if ((xBeg != -1) && (enteringtext))
		{
			FillRect(hdc, &rect, (HBRUSH)CreateSolidBrush(LIGHTGRAY));
			hPen = CreatePen(PS_SOLID, 1, 0xFFFFFF);
			hObject = SelectObject(hdc, hPen);
			MoveToEx(hdc, xBeg, yBeg, NULL);
			LineTo(hdc, xPos, yPos);
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
		}
		else if (showtext)
		{
			SetGraphicsMode(hdc, GM_COMPATIBLE);//GM_ADVANCED
			SetBkMode(hdc, TRANSPARENT);
			SetTextAlign(hdc, TA_LEFT|TA_BASELINE);
			SetTextColor(hdc, TextColor);//0x90FF00
			for (cur = head, prev = NULL; cur != NULL; prev = cur, cur = cur->next)
			{
				TigerAngle = cur->angle;
				lf4.lfEscapement = lf4.lfOrientation = TigerAngle * 10;
				hFont = CreateFontIndirect (&lf4);
				hObject = SelectObject (hdc, hFont);
				x = cur->EUTM;
				y = cur->NUTM;
				for (z = 0; cur->text[z] != 0; z++)
					;
				SetTextAlign(hdc, TA_LEFT|TA_BASELINE);
				TextOut(hdc, x, y, cur->text, z);
				SelectObject(hdc, hObject);
				DeleteObject(hFont);
			}
			SetTextAlign(hdc, TA_LEFT|TA_TOP);//TA_LEFT, TA_TOP, and TA_NOUPDATECP
			SetTextColor(hdc, 0);
		}

		for (x = 0; x < (Lams-(9*27)); x++)
		{
			if (pUSA[x].x != 0)
				LineTo(hdc, pUSA[x].x, pUSA[x].y);
			else
			{
				x++;
				MoveToEx(hdc, pUSA[x].x, pUSA[x].y, NULL);
			}
		}
		SetBkMode(hdc, TRANSPARENT);
		TextOut(hdc, 0, 0, "UTM Zones", 9);
		hPen = CreatePen(PS_SOLID, 1, 0xFFFFFF);
		hObject = SelectObject(hdc, hPen);
		ZoneNum[1] = '0';
		for (x = Lams-(9*27), z = 0; x < Lams; x++, z++)
		{
			TextOut(hdc, pZone[z], 0, ZoneNum, 2);
			ZoneNum[1]++;
			MoveToEx(hdc, pUSA[x].x, pUSA[x].y, NULL);
			for (y = 0; y < 26; y++)
			{
				x++;
				LineTo(hdc, pUSA[x].x, pUSA[x].y);
			}
		}
		TextOut(hdc, pZone[z], 0, ZoneNum, 2);
		for (x = 0; x < 9; x++)
			TextOut(hdc, pLonx[x], pLony[x], &Lons[x*4], 4);
		SelectObject(hdc, hObject);
		DeleteObject(hPen);
		for (x = 0; x < Dots; x++)
		{
			if (DotUSAName[x][0] == '*')
			{
				hWaypointBrush = CreateSolidBrush(WaypointColor);
				hObject = SelectObject(hdc, hWaypointBrush);
				Ellipse(hdc, Dot[x].x-4, Dot[x].y-4, Dot[x].x+4, Dot[x].y+4);
				SelectObject(hdc, hObject);
				DeleteObject(hWaypointBrush);
				SetBkMode(hdc, TRANSPARENT);
				TextOut(hdc, Dot[x].x+10, Dot[x].y-10, DotUSAName[x], lstrlen(DotUSAName[x]));
			}
			else
			{
				Ellipse(hdc, Dot[x].x-4, Dot[x].y-4, Dot[x].x+4, Dot[x].y+4);
				SetBkMode(hdc, TRANSPARENT);
				TextOut(hdc, Dot[x].x+10, Dot[x].y-10, DotUSAName[x], lstrlen(DotUSAName[x]));
			}
		}
		EndPaint(hwndUSA, &ps);
		return 0;

	case WM_DESTROY:
		if (usatext)
			SaveText();
		showtext = saveshowtext;
		head = savedHead;
		return 0;		
	}
	return DefWindowProc(hwndUSA, message, wParam, lParam);
}

void ShowDistanceAngle(void)
{
	if (xPos >= xbeg)
	{
		xleg = xPos - xbeg;
		right = TRUE;
	}
	else
	{
		xleg = xbeg - xPos;
		right = FALSE;
	}
	if (yPos >= ybeg)
	{
		yleg = yPos - ybeg;
		top = TRUE;
	}
	else
	{
		yleg = ybeg - yPos;
		top = FALSE;
	}
	legsquared = (xleg*xleg*MetersPerTile*MetersPerTile)/(PixelsPerTile*PixelsPerTile);
	legsquared += (yleg*yleg*MetersPerTile*MetersPerTile)/(PixelsPerTile*PixelsPerTile);
	routeDist = (sqrt(legsquared) + totalRouteDist[ptr-1]);
	if (routeDist < 1609.344)//1 mile
		x = sprintf(RouteDist, "%.2f", routeDist/0.3048);
	else
	{
		if (!approachcontrol)
			x = sprintf(RouteDist, "%.4f", routeDist/1609.344);//miles
		else
			x = sprintf(RouteDist, "%.4f", routeDist/1852.0);//nautical miles
	}
	if (!fromuser3)
	{
		if (MapType != TOPO)
		{
			SetBkMode(hdc, TRANSPARENT);
			SetTextColor(hdc, 0xFFFFFF);
		}
		TextOut(hdc, xPos, yPos-20, RouteDist, x);
	}
	else
		TextOut(hdcMem3, xPos, yPos-20, RouteDist, x);
	if ((right) && (top))
	{
		if (yleg < xleg)
		{
			if (xleg == 0) xleg = 1;
			d = 90.0 + atan((double)yleg / (double)xleg) * rad2deg;
		}
		else
		{
			if (yleg == 0) yleg = 1;
			d = 180.0 - atan((double)xleg / (double)yleg) * rad2deg;
		}
	}
	else if ((!right) && (top))
	{
		if (xleg < yleg)
		{
			if (yleg == 0) yleg = 1;
			d = 180.0 + atan((double)xleg / (double)yleg) * rad2deg;
		}
		else
		{
			if (xleg == 0) xleg = 1;
			d = 270.0 - atan((double)yleg / (double)xleg) * rad2deg;
		}
	}
	else if ((right) && (!top))
	{
		if (xleg < yleg)
		{
			if (yleg == 0) yleg = 1;
			d = atan((double)xleg / (double)yleg) * rad2deg;
		}
		else
		{
			if (xleg == 0) xleg = 1;
			d = 90.0 - atan((double)yleg / (double)xleg) * rad2deg;
		}
	}
	else if ((!right) && (!top))
	{
		if (yleg < xleg)
		{
			if (xleg == 0) xleg = 1;
			d = 270.0 + atan((double)yleg / (double)xleg) * rad2deg;
		}
		else
		{
			if (yleg == 0) yleg = 1;
			d = 360.0 - atan((double)xleg / (double)yleg) * rad2deg;
		}
	}
	x = sprintf(Error, "    %.1f\260 ", d);
	if (!fromuser3)
		TextOut(hdc, xPos+offset, yPos, Error, x);
	else {
		double rate, time;

		TextOut(hdcMem3, xPos, yPos, Error, x);
		for (x = 0; x < plane; x++)
		{
			if ((xbeg >= Plane[x].x - PlaneRadius) && (xbeg <= Plane[x].x + PlaneRadius) && (ybeg >= Plane[x].y - PlaneRadius) && (ybeg <= Plane[x].y + PlaneRadius)) {
				rate = (double)Plane[x].TAS * MetersPerSec;
				time = routeDist / rate;
				x = (int)time;
				y = x % 60;
				x /= 60;
				z = sprintf(tempPlane, "%i:%.2i", x, y);
				for (x = 0; x < 8; x++)
					if (tempPlane[x] == 0)
						break;
				TextOut(hdcMem3, xPos - 30, yPos, tempPlane, z);
				break;
			}
		}
	}
}

LRESULT CALLBACK BigProc(HWND hwndBig, UINT message, WPARAM wParam, LPARAM lParam)
{
	static int xPos, yPos;
	static int BigPadBytes;
	static int xPrevious = -1, yPrevious;
	DWORD kb, fileSize;
	BYTE *JpegBuf;
//	HDC hdc;
//	PAINTSTRUCT ps;
//	static BITMAPINFOHEADER bmih, *pbmih = &bmih;
//	static BITMAPINFO bmi, *pbmi = &bmi;

	switch(message)
	{
	case WM_CREATE:
		Pixels = NULL;
		showjpeg = FALSE;
		hFile = CreateFile(ofn6.lpstrFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			char Loading[256] = "...Loading ";
			char asdf[20];
			char Bytes[] = " Kbytes)";

			fileSize = GetFileSize(hFile, NULL);
			for (x = 11, y = 0; ofn6.lpstrFileTitle[y] != 0; x++, y++)
				Loading[x] = ofn6.lpstrFileTitle[y];
			Loading[x++] = ' ';
			Loading[x++] = ' ';
			Loading[x++] = '(';
			kb = fileSize/1024;
			_itoa(kb, asdf, 10);
			for (y = 0; asdf[y] != 0; x++, y++)
				Loading[x] = asdf[y];
			for (y = 0; y < 8; x++, y++)
				Loading[x] = Bytes[y];
			Loading[x] = 0;
			SetWindowText(hwnd, Loading);
			SetCursor(hWaitingCursor);
			JpegBuf = (BYTE*)VirtualAlloc(NULL, fileSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
			ReadFile(hFile, JpegBuf, fileSize, &dwBytesRead, NULL);
			CloseHandle(hFile);

			if ((JpegBuf[0] == 0xFF) && (JpegBuf[1] == 0xD8) && (JpegBuf[2] == 0xFF))
			{//it's a jpeg file
				ijlInit (&jcprops);//use Intel's ijl15.dll to convert JPEG files
				jcprops.JPGBytes = JpegBuf;//source
				jcprops.JPGSizeBytes = fileSize;
				jcprops.JPGFile = NULL;
				jerr = ijlRead(&jcprops, IJL_JBUFF_READPARAMS);
 				BigWidth = jcprops.JPGWidth;
				BigHeight = jcprops.JPGHeight;
				jcprops.DIBWidth = BigWidth;
				jcprops.DIBHeight = BigHeight;
				BigPadBytes = IJL_DIB_PAD_BYTES(BigWidth, 3);
				jcprops.DIBPadBytes = BigPadBytes;
				Pixels = (BYTE*)VirtualAlloc(NULL, (((BigWidth*3)+BigPadBytes) * BigHeight), MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
				if (Pixels != NULL)
				{
					jcprops.DIBBytes = Pixels;//destination
					jcprops.DIBChannels = 3;
					jcprops.DIBColor = IJL_BGR;
					jerr = ijlRead (&jcprops, IJL_JBUFF_READWHOLEIMAGE);//IJL_JBUFF_READONEHALF);
					ijlFree(&jcprops);
				}
				else
					showjpeg = TRUE;
			}
			else
				showjpeg = TRUE;
			VirtualFree(JpegBuf, 0, MEM_RELEASE);

			if ((IJL_OK == jerr) && (showjpeg == FALSE))
			{
				bmih5.biSize = sizeof(BITMAPINFOHEADER);
				bmih5.biWidth = BigWidth;
				bmih5.biHeight = -(BigHeight);// - for right-side-up picture
				bmih5.biPlanes = 1;
				bmih5.biBitCount = 24;
				bmih5.biCompression = BI_RGB;
				bmih5.biSizeImage = 0;
				bmih5.biXPelsPerMeter = 0;
				bmih5.biYPelsPerMeter = 0;
				bmih5.biClrUsed = 0;
				bmih5.biClrImportant = 0;
				bmi5.bmiHeader = *pbmih5;

				if (BigHeight > rect.bottom)
					BigTop = BigHeight-rect.bottom;
				else
					BigTop = 0;
				if (BigWidth > rect.right)
 					BigLeft = BigWidth-rect.right;
				else
					BigLeft = 0;
				xBigLoc = yBigLoc = 0;
				xPrevious = -1;
				SetWindowText(hwnd, Big);
			}
			else
			{
				MessageBox(hwndBig, "That JPEG file was too big\nor it wasn't a JPEG file", ERROR, MB_OK);
				SendMessage(hwnd, WM_KEYDOWN, VK_ESCAPE, 0);
				DestroyWindow(hwndBig);
			}
		}
		else
		{
			VirtualFree(Pixels, 0, MEM_RELEASE);
			Pixels = NULL;
			DestroyWindow(hwndBig);
		}
		return 0;

	case WM_LBUTTONDOWN:
		return 0;
	case WM_MOUSEMOVE:
		if (wParam == MK_LBUTTON)
		{
			if (xPrevious != -1)
			{//normal
				xPrevious = xPos;
				yPrevious = yPos;
			}
			xPos = LOWORD(lParam);
			yPos = HIWORD(lParam);
			if (xPrevious == -1)
			{//initialize it
				xPrevious = xPos;
				yPrevious = yPos;
			}
			if (BigWidth > cxScreen)
				xBigLoc += (xPrevious-xPos);
			if (BigHeight > cyScreen)
				yBigLoc += (yPrevious-yPos);
			if (xBigLoc < 0)
				xBigLoc = 0;
			if (xBigLoc > BigLeft)
				xBigLoc = BigLeft;
			if (yBigLoc < 0)
				yBigLoc = 0;
			if (yBigLoc > BigTop)
				yBigLoc = BigTop;
			InvalidateRect(hwndBig, &rect, FALSE);
		}
		else
		{
			xPos = LOWORD(lParam);
			yPos = HIWORD(lParam);
		}
		return 0;

	case WM_PAINT:
		hdc = BeginPaint(hwndBig, &ps);
		SetCursor(hDrawingCursor);
//		SetStretchBltMode(hdc, HALFTONE);//COLORONCOLOR
//		StretchDIBits(hdc, 0, 0, rect.right, rect.bottom, 0, 0, BigWidth, BigHeight, Pixels, pbmi5, DIB_RGB_COLORS, SRCCOPY);
		SetDIBitsToDevice(hdc, 0, 0, rect.right, rect.bottom, xBigLoc, BigTop, yBigLoc, BigHeight, Pixels, pbmi5, DIB_RGB_COLORS);
		EndPaint(hwndBig, &ps);
		return 0;
	}
	return DefWindowProc(hwndBig, message, wParam, lParam);
}

LRESULT CALLBACK PhotoProc(HWND hwndPhoto, UINT message, WPARAM wParam, LPARAM lParam)
{
	HDC hdcPhoto;
	PAINTSTRUCT psPhoto;

	switch(message)
	{
	case WM_CREATE:
		bmih4.biSize = sizeof(BITMAPINFOHEADER);
		bmih4.biWidth = Width;
		bmih4.biHeight = -(Height);// - for right-side-up picture
		bmih4.biPlanes = 1;
		bmih4.biBitCount = 24;
		bmih4.biCompression = BI_RGB;
		bmih4.biSizeImage = 0;
		bmih4.biXPelsPerMeter = 0;
		bmih4.biYPelsPerMeter = 0;
		bmih4.biClrUsed = 0;
		bmih4.biClrImportant = 0;
		bmi4.bmiHeader = *pbmih4;
		return 0;

	case WM_PAINT:
		hdcPhoto = BeginPaint(hwndPhoto, &psPhoto);
		SetDIBitsToDevice(hdcPhoto, 0, 0, Width, Height, 0, 0, 0, Height, photo_pixel_buf, pbmi4, DIB_RGB_COLORS);
		EndPaint(hwndPhoto, &psPhoto);
		return 0;

	case WM_DESTROY:
		VirtualFree(photo_pixel_buf, 0, MEM_RELEASE);
		photo_pixel_buf = NULL;
		break;		
	}
	return DefWindowProc(hwndPhoto, message, wParam, lParam);
}

void EditWaypoint(void)
{
//check previous name, cmt, description and if one is changed,
//make a new entry in WaypointArray & point to it instead of current entry
	if ((strcmp(Location, LocBuf)) || (strcmp(Ident, IdentBuf)) || (strcmp(Description, DescBuf)))
	{
		temp = WaypointSize;
		if ((WaypointArray[temp-5] == 'g') && (WaypointArray[temp-4] == 'p') && (WaypointArray[temp-3] == 'x'))
			temp -= 7;//to write over </gpx> at end of WaypointArray
		tempWaypoints = &WaypointArray[temp];
		tempIdent = tempLoc = tempDesc = NULL;
		gotname = gotcmt = gotdescr = FALSE;
		tempNUTM = NewLoc[ChosenLoc].NUTM;
		tempEUTM = NewLoc[ChosenLoc].EUTM;
		temp2UTMZone = NewLoc[ChosenLoc].UTMZone;
		tempElev = NewLoc[ChosenLoc].Elev;
		tempSym = NewLoc[ChosenLoc].Sym;
//big loop
		for (x = 0, z = temp;
			(NewLoc[ChosenLoc].pWaypoints[x] != '\n')
			 || (NewLoc[ChosenLoc].pWaypoints[x-7] != '<')
			 || (NewLoc[ChosenLoc].pWaypoints[x-6] != '/')
			 || (NewLoc[ChosenLoc].pWaypoints[x-5] != 'w')
			 || (NewLoc[ChosenLoc].pWaypoints[x-4] != 'p')
			 || (NewLoc[ChosenLoc].pWaypoints[x-3] != 't')
			 || (NewLoc[ChosenLoc].pWaypoints[x-2] != '>')
			 || (NewLoc[ChosenLoc].pWaypoints[x-1] != '\r');
			x++, z++)
		{//put it at end of WaypointArray & put new IdentBuf or LocBuf or DescBuf in
			if (NewLoc[ChosenLoc].pWaypoints[x] != '>')//this is the key IF
				WaypointArray[z] = NewLoc[ChosenLoc].pWaypoints[x];

			else//if (NewLoc[ChosenLoc].pWaypoints[x] == '>')
			{
				WaypointArray[z++] = NewLoc[ChosenLoc].pWaypoints[x++];//'>'
				if ((NewLoc[ChosenLoc].pWaypoints[x-6] == '<')
				  && (NewLoc[ChosenLoc].pWaypoints[x-5] == 'n')
				  && (NewLoc[ChosenLoc].pWaypoints[x-4] == 'a')
				  && (NewLoc[ChosenLoc].pWaypoints[x-3] == 'm')
				  && (NewLoc[ChosenLoc].pWaypoints[x-2] == 'e')
				  && (gotname == FALSE))
				{
					gotname = TRUE;
					if (IdentBuf[0] != 0)
					{
						gotcmt = TRUE;
						tempIdent = &WaypointArray[z];
						for (y = 0; IdentBuf[y] != 0; y++, z++)
							WaypointArray[z] = IdentBuf[y];
						for ( ; (NewLoc[ChosenLoc].pWaypoints[x] != '<') || (NewLoc[ChosenLoc].pWaypoints[x+1] != '/'); x++)
							;//x is incremented again in big loop
						for ( ; NewLoc[ChosenLoc].pWaypoints[x] != '>'; x++, z++)
							WaypointArray[z] = NewLoc[ChosenLoc].pWaypoints[x];
						for ( ; NewLoc[ChosenLoc].pWaypoints[x] != '<'; x++, z++)
							WaypointArray[z] = NewLoc[ChosenLoc].pWaypoints[x];
						if ((NewLoc[ChosenLoc].pWaypoints[x+1] != 'c')
						 ||(NewLoc[ChosenLoc].pWaypoints[x+2] != 'm')
						 ||(NewLoc[ChosenLoc].pWaypoints[x+3] != 't')
						 ||(NewLoc[ChosenLoc].pWaypoints[x+4] != '>'))
						{
							if (LocBuf[0] != 0)
							{//insert new <cmt>
								for (y = 0; Cmt[y] != 0; y++, z++)
									WaypointArray[z] = Cmt[y];
								tempLoc = &WaypointArray[z];
								for (y = 0; LocBuf[y] != 0; y++, z++)
									WaypointArray[z] = LocBuf[y];
								for (y = 0; CmtEnd[y] != 0; y++, z++)
									WaypointArray[z] = CmtEnd[y];
							}
						}
						x--;//incremented in big loop
						z--;//incremented in big loop
					}
					else//if (IdentBuf[0] == 0)
					{
						z -= 7;//back up over <name>
						for ( ; (NewLoc[ChosenLoc].pWaypoints[x+1] != '<') || (NewLoc[ChosenLoc].pWaypoints[x+2] != '/'); x++)
							;//x is incremented again in big loop
						for ( ; NewLoc[ChosenLoc].pWaypoints[x] != '\n'; x++)
							;//go past "</name>\r\n"
					}
				}//end of <name>

				else if ((NewLoc[ChosenLoc].pWaypoints[x-5] == '<')
				  && (NewLoc[ChosenLoc].pWaypoints[x-4] == 'c')
				  && (NewLoc[ChosenLoc].pWaypoints[x-3] == 'm')
				  && (NewLoc[ChosenLoc].pWaypoints[x-2] == 't'))
				{
					gotcmt = TRUE;
					if ((gotname == FALSE) && (IdentBuf[0] != 0))
					{//name always before comment
						gotname = TRUE;
						z -= 5;//back up over <cmt>
						for (y = 0; Name[y] != 0; y++, z++)
							WaypointArray[z] = Name[y];
						tempIdent = &WaypointArray[z];
						for (y = 0; IdentBuf[y] != 0; y++, z++)
							WaypointArray[z] = IdentBuf[y];
						for (y = 0; EndName[y] != 0; y++, z++)
							WaypointArray[z] = EndName[y];
						for (y = 0; Cmt[y] != 0; y++, z++)
							WaypointArray[z] = Cmt[y];
					}
					tempLoc = &WaypointArray[z];
					for (y = 0; LocBuf[y] != 0; y++, z++)
						WaypointArray[z] = LocBuf[y];
					z--;//it's incremented in big loop
					for ( ; (NewLoc[ChosenLoc].pWaypoints[x+1] != '<') || (NewLoc[ChosenLoc].pWaypoints[x+2] != '/'); x++)
						;//x is incremented again in big loop
				}//end of <cmt>
				else if ((NewLoc[ChosenLoc].pWaypoints[x-6] == '<')
				  && (NewLoc[ChosenLoc].pWaypoints[x-5] == 'd')
				  && (NewLoc[ChosenLoc].pWaypoints[x-4] == 'e')
				  && (NewLoc[ChosenLoc].pWaypoints[x-3] == 's')
				  && (NewLoc[ChosenLoc].pWaypoints[x-2] == 'c'))
				{
					if ((gotdescr == FALSE) && (DescBuf[0] != 0))
					{
						gotdescr = TRUE;
						tempDesc = &WaypointArray[z];
						for (y = 0; DescBuf[y] != 0; y++, z++)
							WaypointArray[z] = DescBuf[y];
						for ( ; (NewLoc[ChosenLoc].pWaypoints[x] != '<') || (NewLoc[ChosenLoc].pWaypoints[x+1] != '/'); x++)
							;//go to </desc>
						for ( ; NewLoc[ChosenLoc].pWaypoints[x] != '\n'; x++, z++)
							WaypointArray[z] = NewLoc[ChosenLoc].pWaypoints[x];
						WaypointArray[z] = NewLoc[ChosenLoc].pWaypoints[x];
					}
					else//if (DescBuf[0] == 0)
					{
						z -= 7;//back up over <desc>
						for ( ; (NewLoc[ChosenLoc].pWaypoints[x+1] != '<') || (NewLoc[ChosenLoc].pWaypoints[x+2] != '/'); x++)
							;//x is incremented again in big loop
						for ( ; NewLoc[ChosenLoc].pWaypoints[x] != '\n'; x++)
							;//go past "</desc>\r\n"
					}
				}//end of <desc>

				else
					WaypointArray[z] = NewLoc[ChosenLoc].pWaypoints[x];
			}//end of else at '<'
		}//end of big loop

//Ident = name (IdentBuf)
//Location = cmt (LocBuf)
/*impossible
		if ((IdentBuf[0] != 0) && (gotname == FALSE))
		{//back up over the new entry's </way> (after the </gpx>)
			gotname = TRUE;
			z -= 7;
			for (y = 0; Name[y] != 0; y++, z++)
				WaypointArray[z] = Name[y];
			tempIdent = &WaypointArray[z];
			for (y = 0; IdentBuf[y] != 0; y++, z++)
				WaypointArray[z] = IdentBuf[y];
 			for (y = 0; EndName[y] != 0; y++, z++)
				WaypointArray[z] = EndName[y];
		}
*/
		if ((LocBuf[0] != 0) && (gotcmt == FALSE))
		{
			gotcmt = TRUE;
			z -= 7;
			for (y = 0; Cmt[y] != 0; y++, z++)
				WaypointArray[z] = Cmt[y];
			tempLoc = &WaypointArray[z];
			for (y = 0; LocBuf[y] != 0; y++, z++)
				WaypointArray[z] = LocBuf[y];
 			for (y = 0; CmtEnd[y] != 0; y++, z++)
				WaypointArray[z] = CmtEnd[y];
			for (y = 0; WptEnd[y] != 0; y++, z++)
				WaypointArray[z] = WptEnd[y];
		}
		if ((DescBuf[0] != 0) && (gotdescr == FALSE))
		{
			gotdescr = TRUE;
			z -= 7;
			for (y = 0; Desc[y] != 0; y++, z++)
				WaypointArray[z] = Desc[y];
			tempDesc = &WaypointArray[z];
			for (y = 0; DescBuf[y] != 0; y++, z++)
				WaypointArray[z] = DescBuf[y];
 			for (y = 0; DescEnd[y] != 0; y++, z++)
				WaypointArray[z] = DescEnd[y];
			for (y = 0; WptEnd[y] != 0; y++, z++)
				WaypointArray[z] = WptEnd[y];
		}

		WaypointArray[z++] = NewLoc[ChosenLoc].pWaypoints[x++];//'\n'
		WaypointArray[z] = 0;
		WaypointSize = z;

		for (x = ChosenLoc; x < EmptyLoc; x++)
			NewLoc[x] = NewLoc[x+1];//over-write this entry
		EmptyLoc--;
		for (x = 0; x < EmptyLoc; x++)
		{//new waypoint
			if ((sortbyname == FALSE) || (IdentBuf[0] == 0))
			{
				if (NewLoc[x].Location != NULL)
				{
					if (_stricmp(NewLoc[x].Location, LocBuf) > 0)
					{
						InsertLoc = x;
						EmptyLoc++;
						for (x = EmptyLoc; x > InsertLoc; x--)
							NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
						break;
					}
				}
			}
			else if (sortbyname)
			{
				if (NewLoc[x].Ident != NULL)
				{
					if (_stricmp(NewLoc[x].Ident, IdentBuf) > 0)
					{
						InsertLoc = x;
						EmptyLoc++;
						for (x = EmptyLoc; x > InsertLoc; x--)
							NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
						break;
					}
				}
			}
		}

		if (x == EmptyLoc)
		{
			InsertLoc = x;
			EmptyLoc++;
		}
		NewLoc[InsertLoc].NUTM = tempNUTM;
		NewLoc[InsertLoc].EUTM = tempEUTM;
		NewLoc[InsertLoc].UTMZone = temp2UTMZone;
		NewLoc[InsertLoc].pWaypoints = tempWaypoints;
		NewLoc[InsertLoc].Ident = tempIdent;
		if (tempLoc != NULL)
			NewLoc[InsertLoc].Location = tempLoc;
		else if (tempDesc != NULL)
			NewLoc[InsertLoc].Location = tempDesc;
		NewLoc[InsertLoc].Description = tempDesc;
		NewLoc[InsertLoc].Elev = tempElev;
		NewLoc[InsertLoc].size = WaypointSize - temp;
		NewLoc[InsertLoc].Sym = NULL;
		newLoc = TRUE;
	}//end of if ((strcmp(
}

void EndRoute(void)
{
	Response = MessageBox(hwnd, "Save the Route?", "Create a Route", MB_YESNOCANCEL);
	if (Response == IDCANCEL)
		return;
	if ((Response == IDYES) && (FALSE != GetSaveFileName(&ofn3)))
	{//if a line has been drawn
		if ((ptr == 0) || ((pRoute[ptr-1].NUTM != UTMNorthing) || (pRoute[ptr-1].EUTM != UTMEasting)))
		{//don't duplicate previous point
			pRoute[ptr].UTMZone = UTMZone;
			pRoute[ptr].NUTM = UTMNorthing;
			pRoute[ptr].EUTM = UTMEasting;
			Radius = DotRadius*MetersPerTile/PixelsPerTile;
			for (z = 0; NewLoc[z].EUTM != 0; z++)
			{//check for route point near a waypoint & move it to waypoint if it is	
				if ((NewLoc[z].UTMZone == UTMZone) && (NewLoc[z].EUTM < x+Radius) && (NewLoc[z].EUTM > x-Radius)
				 && (NewLoc[z].NUTM < y+Radius) && (NewLoc[z].NUTM > y-Radius))
				{
					MessageBeep(MB_OK);
					pRoute[ptr].NUTM = NewLoc[z].NUTM;
					pRoute[ptr].EUTM = NewLoc[z].EUTM;
					break;
				}
			}
			if (ptr < MAX_PTR)
				ptr++;
		}

		hFile = CreateFile(FullRoutes, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		for (z = 0; z < ptr; z++)
		{
			if ((z == ptr-1)
			 && (pRoute[z].UTMZone == pRoute[0].UTMZone)
			 && ((UINT)(pRoute[z].EUTM - (UINT)pRoute[0].EUTM) < 5 || ((UINT)pRoute[0].EUTM - (UINT)pRoute[z].EUTM) < 5)
			 && (((UINT)pRoute[z].NUTM - (UINT)pRoute[0].NUTM) < 5 || ((UINT)pRoute[0].NUTM - (UINT)pRoute[z].NUTM) < 5))
			{//if almost a closed polygon
				int i, j;
				double acres, area = 0, n0, e0, n1, e1;

				if (IDYES == MessageBox(hwnd, "Move end to beginning coordinates?\n(to make an enclosed area)", "", MB_YESNO))
				{
					y = 0;
					Raut[y++] = (pRoute[0].UTMZone / 10) + '0';
					Raut[y++] = (pRoute[0].UTMZone % 10) + '0';
					Raut[y++] = ',';
					_itoa(pRoute[0].NUTM, RouteDist, 10);
					for (x = 0; RouteDist[x] != 0; x++, y++)
						Raut[y] = RouteDist[x];
					Raut[y++] = ',';
					_itoa(pRoute[0].EUTM, RouteDist, 10);
					for (x = 0; RouteDist[x] != 0; x++, y++)
						Raut[y] = RouteDist[x];

					pRoute[z] = pRoute[0];
					for (i = 0; i < y; i++)
					{
						j = (i + 1) % y;
						e0 = (double)pRoute[i].EUTM;
						n0 = (double)pRoute[i].NUTM;
						e1 = (double)pRoute[j].EUTM;
						n1 = (double)pRoute[j].NUTM;
						area += e0 * n1;//pRoute[i].EUTM * pRoute[j].NUTM;
						area -= n0 * e1;//pRoute[i].NUTM * pRoute[j].EUTM;
					}
					area /= 2.0;
					if (area < 0)
						area = -area;
					acres = area * 0.00024710538146716533;
					sprintf(Acres, "%.6f", acres);
					MessageBox(hwnd, Acres, "Acres:", MB_OK);
					z++;//to ptr
				}
				else
				{
					y = 0;
					Raut[y++] = (pRoute[z].UTMZone / 10) + '0';
					Raut[y++] = (pRoute[z].UTMZone % 10) + '0';
					Raut[y++] = ',';
					_itoa(pRoute[z].NUTM, RouteDist, 10);
					for (x = 0; RouteDist[x] != 0; x++, y++)
						Raut[y] = RouteDist[x];
					Raut[y++] = ',';
					_itoa(pRoute[z].EUTM, RouteDist, 10);
					for (x = 0; RouteDist[x] != 0; x++, y++)
						Raut[y] = RouteDist[x];
				}
			}
			else
			{
				y = 0;
				Raut[y++] = (pRoute[z].UTMZone / 10) + '0';
				Raut[y++] = (pRoute[z].UTMZone % 10) + '0';
				Raut[y++] = ',';
				_itoa(pRoute[z].NUTM, RouteDist, 10);
				for (x = 0; RouteDist[x] != 0; x++, y++)
					Raut[y] = RouteDist[x];
				Raut[y++] = ',';
				_itoa(pRoute[z].EUTM, RouteDist, 10);
				for (x = 0; RouteDist[x] != 0; x++, y++)
					Raut[y] = RouteDist[x];
			}
			Raut[y++] = '\r';
			Raut[y++] = '\n';

			WriteFile(hFile, Raut, y, &dwBytesWritten, NULL);
		}
		CloseHandle(hFile);
	}
	else
	{
		CheckMenuItem(hMenu, ID_ROUTE_SHOW, MF_UNCHECKED);
		showingroute = FALSE;
	}
	InvalidateRect(hwnd, &rect, FALSE);
	UpdateWindow(hwnd);
	drawing = FALSE;//has to be after InvalidateRect
	xBeg = -1;
}

/*<name id="GCQH5B"><![CDATA[Hey Bubb! by pao_flyers]]></name>
<coord lat="37.3783166666667" lon="-122.0837"/>
becomes
<wpt lat="37.3783166666667" lon="-122.0837">
<name>GCQH5B</name>
<desc><![CDATA[Hey Bubb! by pao_flyers]]></desc>
</wpt>*/

void ConvertLocToXML(char *tempBuf, char *tempBuf2, int x, DWORD fileSize)
{
	int Name, Desc, Lat, Lon;
	DWORD y, z, saveY;
	static char wpt[] = "<wpt lat=\"";
	static char lon[] = "\" lon=\"";
	static char name[] = "\">\r\n<name>";
	static char desc[] = "</name>\r\n<desc>";
	static char endwpt[] = "></desc>\r\n</wpt>\r\n";
	static char endgpx[] = "</gpx>\r\n";
	HANDLE hFile;

	for (y = 0; y < fileSize; y++)
	{
		if ((tempBuf[y] == '<') && (tempBuf[y+1] == 'n'))
		{
			y += 10;
			if (y >= fileSize)
				break;
			Name = y;
			for ( ; (y < fileSize) && (tempBuf[y] != '<'); y++)
				;
			if (y == fileSize)
				break;
			Desc = y;
			for ( ; (y < fileSize) && ((tempBuf[y] != ']') || (tempBuf[y-1] != ']')); y++)
				;//go to the end of CDATA stuff
			if (y == fileSize)
				break;
		}
		if ((tempBuf[y] == '<') && (tempBuf[y+1] == 'c'))
		{//<coord lat
			y += 12;
			if (y >= fileSize)
				break;
			Lat = y;
			for ( ; (tempBuf[y] != 'l') || (tempBuf[y+1] != 'o') || (tempBuf[y+2] != 'n'); y++)
				;
			y += 5;
			if (y >= fileSize)
				break;
			Lon = y;
		}
		if ((tempBuf[y] == '<') && (tempBuf[y+1] == '/') && (tempBuf[y+2] == 'w'))
		{
			saveY = y;
			for (z = 0; z < 10; x++, z++)
				tempBuf2[x] = wpt[z];
			for (y = Lat; tempBuf[y] != '\"'; x++, y++)
				tempBuf2[x] = tempBuf[y];
			for (z = 0; z < 7; x++, z++)
				tempBuf2[x] = lon[z];
			for (y = Lon; tempBuf[y] != '\"'; x++, y++)
				tempBuf2[x] = tempBuf[y];
			for (z = 0; z < 10; x++, z++)
				tempBuf2[x] = name[z];
			for (y = Name; tempBuf[y] != '\"'; x++, y++)
				tempBuf2[x] = tempBuf[y];
			for (z = 0; z < 15; x++, z++)
				tempBuf2[x] = desc[z];
			for (y = Desc; (tempBuf[y] != '>') || (tempBuf[y-1] != ']') || (tempBuf[y-2] != ']'); x++, y++)
				tempBuf2[x] = tempBuf[y];
			for (z = 0; z < 18; x++, z++)
				tempBuf2[x] = endwpt[z];
			y = saveY;
		}
	}
 	for (z = 0; z < 8; x++, z++)
		tempBuf2[x] = endgpx[z];
	hFile = CreateFile(WaypointsFullPath, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	WriteFile(hFile, tempBuf2, x, &dwBytesWritten, NULL);
	CloseHandle(hFile);
	fromconvertloctoxml = TRUE;
	SendMessage(hwnd, WM_COMMAND, ID_WAYPOINTS_OPENFILE, 0);
}


void SendMagRoutes(void) {
	if (FALSE != GetOpenFileName(&ofn3))
	{
		int numofWpts;
		char Wpts[4];
		char Test[] = "TEST";

		hFile4 = NULL;
		hFile3 = CreateFile(FullRoutes, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile3 != INVALID_HANDLE_VALUE)
		{
			if (fileSize = GetFileSize(hFile3, NULL))
			{
				ReadFile(hFile3, Trackid, 100, &dwBytesRead, NULL);
				SetFilePointer(hFile3, 0, 0, FILE_BEGIN);
				if ((Trackid[2] == ',') && (Trackid[10] == ',') && (Trackid[17] == '\r'))
				{
					hFile4 = CreateFile(Test, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
					pRoutes = (char*)malloc(fileSize);
					ReadFile(hFile3, pRoutes, fileSize, &dwBytesRead, NULL);
					for (z = 0, numofWpts = 0; z < fileSize; numofWpts++)
					{
						for (x = 0; x < 100; x++)
							SendMagWaypoints[x] = 0;
						for (x = 0; Wpl[x] != 0; x++)
							SendMagWaypoints[x] = Wpl[x];//"$PMGNWPL,"
						UTMZone = (((pRoutes[z] - '0') * 10) + pRoutes[z+1] - '0');
						z += 3;//to UTMNorthing
						UTMNorthing = atoi(&pRoutes[z]);
						z += 8;//to UTMEasting
						UTMEasting = atoi(&pRoutes[z]);
						z += 8;//to next line
						UTMtoLatLon();
						Lon = -Lon;
						minutes = modf(Lat, &degrees) * 60.0;
						x += sprintf((char*)&SendMagWaypoints[x], "%2.0f", degrees);
						x += sprintf((char*)&SendMagWaypoints[x], "%06.3f", minutes);
						SendMagWaypoints[x++] = ',';
						SendMagWaypoints[x++] = 'N';
						SendMagWaypoints[x++] = ',';
						minutes = modf(Lon, &degrees) * 60.0;
						x += sprintf((char*)&SendMagWaypoints[x], "%3.0f", degrees);
						x += sprintf((char*)&SendMagWaypoints[x], "%06.3f", minutes);
						if (SendMagWaypoints[20] == ' ')
							SendMagWaypoints[20] = '0';//make degrees Longitude "084" from " 84"
						SendMagWaypoints[x++] = ',';
						SendMagWaypoints[x++] = 'W';
						SendMagWaypoints[x++] = ',';
						SendMagWaypoints[x++] = '0';
						SendMagWaypoints[x++] = '0';
						SendMagWaypoints[x++] = '0';
						SendMagWaypoints[x++] = '0';
						SendMagWaypoints[x++] = '0';
						SendMagWaypoints[x++] = '0';
						SendMagWaypoints[x++] = '0';
						SendMagWaypoints[x++] = ',';
						SendMagWaypoints[x++] = 'M';//meters
						SendMagWaypoints[x++] = ',';
						_itoa(numofWpts+1, Wpts, 10);
						for (y = 0; Wpts[y] != 0; x++, y++)
							SendMagWaypoints[x] = Wpts[y];
						SendMagWaypoints[x++] = ',';
						SendMagWaypoints[x++] = ',';
						SendMagWaypoints[x++] = 'a';//medium city symbol
						SendMagWaypoints[x++] = '*';
						for (checksum = 0, y = 1; SendMagWaypoints[y] != '*'; y++)
							checksum ^= SendMagWaypoints[y];
						y = checksum >> 4;
						SendMagWaypoints[x++] = (char)(y > 9) ? y + 0x37 : y + 0x30;
						y = checksum & 0x0F;
						SendMagWaypoints[x++] = (char)(y > 9) ? y + 0x37 : y + 0x30;
						SendMagWaypoints[x++] = '\x0D';
						SendMagWaypoints[x++] = '\x0A';
						WriteFile(hFile4, SendMagWaypoints, x, &dwBytesWritten, NULL);
					}
					free(pRoutes);
				}
			}
			CloseHandle(hFile3);
		}
		//now add route
		if (hFile4 != NULL)
		{
			numofRoutes = 0;
			totalroutelines = (numofWpts / 2);
			if (numofWpts % 2)
				totalroutelines++;
			routeline = 1;
			for (z = 0; z < totalroutelines; z++)
			{
				for (y = 0; y < 82; y++)
					SendRoute[y] = 0;
				for (y = 0; y < 9; y++)
					SendRoute[y] = Rute[y];//$PMGNRTE,
				_itoa(totalroutelines, &SendRoute[y], 10);
				y++;
				if (totalroutelines >= 10)
					y++;//past second digit
				if (totalroutelines >= 100)
					y++;//past third digit
				SendRoute[y++] = ',';
				_itoa(routeline, &SendRoute[y], 10);
				y++;
				if (routeline >= 10)
					y++;//past second digit
				if (routeline >= 100)
					y++;//past third digit
				routeline++;
				SendRoute[y++] = ',';
				SendRoute[y++] = 'c';
				SendRoute[y++] = ',';
				SendRoute[y++] = '1';//route number
				for (x = 0; x < 2; x++)
				{
					SendRoute[y++] = ',';
					if (numofRoutes < numofWpts)
					{
						_itoa(numofRoutes+1, Wpts, 10);
						for (w = 0; Wpts[w] != 0; w++, y++)
							SendRoute[y] = Wpts[w];
					}
					SendRoute[y++] = ',';
					if (numofRoutes < numofWpts)
						SendRoute[y++] = 'a';//symbol type
					numofRoutes++;
				}
				SendRoute[y++] = '*';
				for (checksum = 0, x = 1; SendRoute[x] != '*'; x++)
					checksum ^= SendRoute[x];//MAGELLAN
				x = checksum >> 4;
				SendRoute[y++] = (char)(x > 9) ? x + 0x37 : x + 0x30;
				x = checksum & 0x0F;
				SendRoute[y++] = (char)(x > 9) ? x + 0x37 : x + 0x30;
				SendRoute[y++] = '\r';
				SendRoute[y++] = '\n';
				WriteFile(hFile4, SendRoute, y, &dwBytesWritten, NULL);
			}
			CloseHandle(hFile4);
		}
	}
}

//void GetExploristDir(void)
//{
//	hFindFile = FindFirstFile(eXploristDir, &fd);
//	if ((INVALID_HANDLE_VALUE != hFindFile) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
//		FindClose(hFindFile);//it's a folder, don't do anything
//	else//it's not a folder
//		CreateDirectory(eXploristDir, NULL);
//}

//$PMGNWPL,1827.026,N,06604.448,W,0000017,M,BUS STOP,BUS STOP,x*5D
int GetExploristWaypoints(int i)
{
	for ( ; (i < fileSize)
		&& ((ExploristBuf[i] != '$')
		|| (ExploristBuf[i+1] != 'P') 		|| (ExploristBuf[i+2] != 'M') 		|| (ExploristBuf[i+5] != 'W') 		|| (ExploristBuf[i+6] != 'P')
		|| (ExploristBuf[i+7] != 'L')); i++)
		;
	if (i == fileSize)
		return i;
	Lat = ((double)((ExploristBuf[i+9] - '0') * 10) + (ExploristBuf[i+10] - '0'))
	 + ((atof(&ExploristBuf[i+11])) / 60.0);
	for (x = i+12; (ExploristBuf[x] != 'N') && (x < (i+100)); x++)
		;
	x += 2;//to Longitude
	Lon = -((double)((ExploristBuf[x] - '0') * 100)
	 + ((ExploristBuf[x+1] - '0') * 10)
	 + (ExploristBuf[x+2] - '0')
	 + ((atof(&ExploristBuf[x+3])) / 60.0));
	if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))//WM_LBUTTONDOWN
		return x;
	else
	{
		LatRad = Lat*deg2rad;
		LonRad = Lon*deg2rad;
		LatLontoUTM();//get UTMEasting & UTMNorthing
	}

	for ( ; (ExploristBuf[x] != 'W') && (x < (i+100)); x++)
		;
	x += 2;//to elevation
	for (z = 0; (ExploristBuf[x] != ',') && (x < (i+100)); x++, z++)
		Elev[z] = ExploristBuf[x];
	Elev[z] = 0;
	x++;//to either 'F,' or 'M,' or 'MYHOUSE'
	if (ExploristBuf[x] == 'F')
	{
		eleM = atoi(Elev) * 0.3048;//convert to meters
		sprintf(Elev, "%.4f", eleM);//& put it back in Elev
	}
	for (z = 0; Elev[z] != 0; z++)
		if (Elev[z] != '0')
			break;
	if (Elev[z] == 0)
		Elev[0] = 0;//don't bother with all 0's
	if (ExploristBuf[x+1] == ',')
		x += 2;//to waypoint name
	IdentOffset = x;
	//get ident/name
	for (x = 0; (ExploristBuf[IdentOffset+x] != ',') && (ExploristBuf[IdentOffset+x] != '*'); x++)
		Ident[x] = ExploristBuf[IdentOffset+x];
	Ident[x] = 0;
	//get location/comment
	x += IdentOffset;
	Location[0] = 0;
	if (ExploristBuf[x] == ',')//if it's not '*'
	{
		x++;//to possible comment
		LocOffset = x;
		if (ExploristBuf[x] != ',')//if it's not empty
		{
			for (x = 0; (ExploristBuf[LocOffset+x] != ',') && (ExploristBuf[LocOffset+x] != '*'); x++)
				Location[x] = ExploristBuf[LocOffset+x];
			Location[x] = 0;
		}
		x = LocOffset;
	}
	Sym[0] = 0;
	if (ExploristBuf[x] == ',')
	{//not '*'
		GetMagSym(x);
	}
i = x;
	for (x = 0; x < EmptyLoc; x++)
	{//check for duplicate & ignore it
		if (NewLoc[x].Ident != NULL)
		{
			for (y = 0; (NewLoc[x].Ident[y] == Ident[y]) && (Ident[y] != 0); y++)
				;
			if (((NewLoc[x].Ident[y] == '<') || (NewLoc[x].Ident[y] == ' ')) && (Ident[y] == 0))
				return i;
		}
	}
	for (x = 0; x < EmptyLoc; x++)
	{
		if ((NewLoc[x].Location != NULL) && (strcmp(NewLoc[x].Location, Location) > 0))
		{
			InsertLoc = x;
			EmptyLoc++;
			for (x = EmptyLoc; x > InsertLoc; x--)
				NewLoc[x] = NewLoc[x-1];//move to make room to insert new data
			break;
		}
	}
	if (x == EmptyLoc)
	{
		InsertLoc = x;
		EmptyLoc++;
	}
	NewLoc[InsertLoc].EUTM = UTMEasting;
	NewLoc[InsertLoc].NUTM = UTMNorthing;
	NewLoc[InsertLoc].UTMZone = UTMZone;
///--->
	FillWaypointArray(InsertLoc);
///--->
	return i;
}
//				  1 2        3 4     5 6         7 8      9
//$PMGNTRK,llll.ll,N,yyyyy.yy,W,xxxxx,F,hhmmss.ss,A,c----c,ddmmyy*hh<CR><LF>
void FillTrackFromNMEA(void)
{
	if (tempUTMZone == UTMZone)
		inutmzone = TRUE;
	trak[tnum].NUTM = UTMNorthing;
	trak[tnum].EUTM = UTMEasting;
	trak[tnum].year = 0;
	y = hour = minute = second = Day = Month = Year = 0;
	for (x = 0; tempLatLon[x] != 0; x++)
	{//3724.441,N,12206.979,W,00025,M,035457.94,A*6B
		if (tempLatLon[x] == ',')
		{
			y++;
			if (y == 4)
			{
				x++;
				if (tempLatLon[x] != ',')
				{
					for (z = 0; tempLatLon[x] != ','; x++)
						z = (z * 10) + (tempLatLon[x] - '0');
					trak[tnum].alt = (float) z;
					if (tempLatLon[x+1] == 'M')
						trak[tnum].alt /= (float)0.3048;//convert meters to feet
					y++;//because tempLatLon[x] is at ','
//					if (tempLatLon[x+1] == 'F')
//						trak[tnum].alt *= (float)0.3048;
				}
			}
			else if (y == 6)
			{
				x++;
				if (tempLatLon[x] != ',')
				{
					hour = ((tempLatLon[x] - '0') * 10) + (tempLatLon[x+1] - '0');
					x += 2;
					minute = ((tempLatLon[x] - '0') * 10) + (tempLatLon[x+1] - '0');
					x += 2;
					second = ((tempLatLon[x] - '0') * 10) + (tempLatLon[x+1] - '0');
					x += 2;
				}
			}
			else if (y == 9)
			{
				x++;
				if (tempLatLon[x] != ',')
				{
					Day = ((tempLatLon[x] - '0') * 10)  + (tempLatLon[x+1] - '0');
					Month = ((tempLatLon[x+2] - '0') * 10) + (tempLatLon[x+3] - '0');
					Year = ((tempLatLon[x+4] - '0') * 10) + (tempLatLon[x+5] - '0');//03 = 2003
				}
			}
		}
	}
	trak[tnum].time = (UTMZone << 26) | (Month << 22) | (Day << 17) | (hour << 12) | (minute << 6) | second;
	trak[tnum].year = Year;
	tnum++;
}

int CALLBACK CommPortProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndEdit;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetWindowText(hwndEdit, &NewComm[7]);
		SetFocus(hwndEdit);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (GetWindowText(hwndEdit, CommPort, 3))
			{
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else
				return FALSE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK APRSCommPortProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndEdit;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetWindowText(hwndEdit, APRSCommPort);
		SetFocus(hwndEdit);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (GetWindowText(hwndEdit, APRSCommPort, 3))
			{
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else
				return FALSE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK ExcludeSymbolsCallsProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndEdit1, hwndEdit2, hwndEdit3, hwndEdit4;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit1 = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndEdit2 = GetDlgItem(hwndDlg, IDC_EDIT2);
		hwndEdit3 = GetDlgItem(hwndDlg, IDC_EDIT3);
		hwndEdit4 = GetDlgItem(hwndDlg, IDC_EDIT4);
		SetWindowText(hwndEdit1, ShowList1);
		SetWindowText(hwndEdit2, ShowList2);
		SetWindowText(hwndEdit3, ShowList3);
		SetWindowText(hwndEdit4, ShowList4);
		if (showlist & 0x00000001)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO5, IDC_RADIO1);
		else if (showlist & 0x00000010)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO5, IDC_RADIO2);
		else if (showlist & 0x01000000)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO5, IDC_RADIO3);
		else if (showlist & 0x00000100)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO5, IDC_RADIO4);
		else if (showlist & 0x00001000)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO5, IDC_RADIO5);
		SetFocus(hwndDlg);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			showlist &= 0x10110000;
			GetWindowText(hwndEdit1, ShowList1, 256);
			GetWindowText(hwndEdit2, ShowList2, 256);
			GetWindowText(hwndEdit3, ShowList3, 256);
			GetWindowText(hwndEdit4, ShowList4, 256);
			if (IsDlgButtonChecked(hwndDlg, IDC_RADIO1))
			{
				showlist |= 0x00000001;
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else if (IsDlgButtonChecked(hwndDlg, IDC_RADIO2))
			{
				showlist |= 0x00000010;
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else if (IsDlgButtonChecked(hwndDlg, IDC_RADIO3))
			{
				showlist |= 0x01000000;
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else if (IsDlgButtonChecked(hwndDlg, IDC_RADIO4))
			{
				showlist |= 0x00000100;
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else if (IsDlgButtonChecked(hwndDlg, IDC_RADIO5))
			{
				showlist |= 0x00001000;
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			break;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK ExcludeTracksProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, y, z, linebeg, last;
	static HWND hwndEdit1, hwndEdit2;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit1 = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndEdit2 = GetDlgItem(hwndDlg, IDC_EDIT2);
		SetWindowText(hwndEdit1, ShowList5);
		SetWindowText(hwndEdit2, ShowList6);
		if (showlist & 0x00010000)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO1);//show only these callsign tracks
		else if (showlist & 0x00100000)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO2);//don't show these callsign tracks
		else if (showlist & 0x10000000)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO3);//show all callsign tracks
		SetFocus(hwndDlg);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			showlist &= 0x01001111;
			GetWindowText(hwndEdit1, ShowList5, 256);
			GetWindowText(hwndEdit2, ShowList6, 256);
			for (x = Aprsi; x != 0xFFFFFFFF;x--)
			{
				for (y = x-1; y != 0xFFFFFFFF; y--)
				{
					if ((Aprs[y].Call[0] != 0) && (Aprs[y].UTMN != 0))
					{
						for (z = 0; Aprs[y].Call[z] != 0; z++)
							if (Aprs[y].Call[z] != Aprs[x].Call[z])
								break;
						if ((Aprs[y].Call[z] == 0) && (Aprs[x].Call[z] == 0) && ((Aprs[y].UTMN != Aprs[x].UTMN) || (Aprs[y].UTME != Aprs[x].UTME)))
						{//same callsign
							Aprs[y].RedDot = 1;//default - to show tracks
						}
					}
				}
			}
			if (IsDlgButtonChecked(hwndDlg, IDC_RADIO1))
			{//show ONLY these callsigns tracks
				for (y = 0; ShowList5[y] != 0; )
				{
					linebeg = y;
					last = -1;
					for (x = 0; x < Aprsi; x++)
					{
						y = linebeg;
						for (z = 0; ; y++, z++)
							if (ShowList5[y] != Aprs[x].Call[z])
								break;
						if ((ShowList5[y] == 0) || (ShowList5[y] == '\r'))
						{
							Aprs[x].RedDot = 2;//the 2 is temporary
							last = x;
						}
						else if (Aprs[x].RedDot == 1)
							Aprs[x].RedDot = 3;
					}
					if (last != -1)
						Aprs[last].RedDot = 0;
					for ( ;(ShowList5[y] != 0) && (ShowList5[y] != '\n'); y++)
						;//go to next line
					if (ShowList5[y] == '\n')
						y++;
				}
				for (x = 0; x < Aprsi; x++)
					if (Aprs[x].RedDot == 2)//end of temporary 2
						Aprs[x].RedDot = 1;
				showlist |= 0x00010000;
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else if (IsDlgButtonChecked(hwndDlg, IDC_RADIO2))
			{//DON'T show these callsigns tracks
				for (y = 0; ShowList6[y] != 0; )
				{
					linebeg = y;
					last = -1;
					for (x = 0; x < Aprsi; x++)
					{
						y = linebeg;
						for (z = 0; ; y++, z++)
							if (ShowList6[y] != Aprs[x].Call[z])
								break;
						if ((ShowList6[y] == 0) || (ShowList6[y] == '\r'))
						{
							Aprs[x].RedDot = 3;//don't show track
							last = x;
						}
					}
					if (last != -1)
						Aprs[last].RedDot = 0;//only show the last position
					for ( ;(ShowList6[y] != 0) && (ShowList6[y] != '\n'); y++)
						;//go to next line
					if (ShowList6[y] == '\n')
						y++;
				}
				showlist |= 0x00100000;
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			else if (IsDlgButtonChecked(hwndDlg, IDC_RADIO3))
			{
				showlist |= 0x10000000;
				EndDialog (hwndDlg, TRUE);
				return TRUE;
			}
			break;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

/*
void GetAPRS(void)
{
	int x, y, z, MaxZips, xDist, yDist;
	DWORD ClosestDist, zbx;
	DWORD *Dist;
	BYTE *ZipBuf;
	char Zip[6];
	char Wind[] = "wind ";
	char APRSWebPage[] = "APRSWebPage.htm";
	char *aprsWorld;
	char *pGlobal;
	HGLOBAL hGlobal;

xyz:if (INVALID_HANDLE_VALUE  != (hFile = CreateFile("ZipCode.dta", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)))
	{
		fileSize = GetFileSize(hFile, NULL);
		if (fileSize == 0)
		{
			CloseHandle(hFile);
			return;
		}
		else
		{
			ZipBuf = (BYTE*)malloc(fileSize);
			MaxZips = fileSize/14;
			Dist = (DWORD*)malloc(MaxZips);
			ReadFile(hFile, ZipBuf, fileSize, &dwBytesRead, NULL) ;
			ClosestDist = 0xFFFFFFFF;
			tempLat = Lat;
			tempLon = Lon;
			tempUTMZone = UTMZone;
			tempUTMN = UTMNorthing;
			tempUTME = UTMEasting;
			centerX = rect.right >> 1;
			centerY = rect.bottom >> 1;
			UTMEasting = (centerX * MetersPerTile/PixelsPerTile) + ScreenLeft;
			UTMNorthing = ScreenTop - (centerY * MetersPerTile/PixelsPerTile);
			for (x = 5, z = 0; x < fileSize; x += 14)
			{
				if (ZipBuf[x] == (BYTE)UTMZone)
				{
					if (UTMEasting > *(int*)&ZipBuf[x+5])
						xDist = UTMEasting - *(int*)&ZipBuf[x+5];
					else
						xDist = *(int*)&ZipBuf[x+5] - UTMEasting;
					if (UTMNorthing > *(int*)&ZipBuf[x+1])
						yDist = UTMNorthing - *(int*)&ZipBuf[x+1];
					else
						yDist = *(int*)&ZipBuf[x+1] - UTMNorthing;
					Dist[z] = xDist + yDist;
					if (Dist[z] < ClosestDist)
					{
						ClosestDist = Dist[z];
						zbx = x;
					}
					z++;
				}
			}
			zbx -= 5;//to zip code
			for (y = 0; y < 5; y++, zbx++)
				Zip[y] = ZipBuf[zbx];
			Zip[y] = 0;
			free(Dist);
			free(ZipBuf);
		}
		CloseHandle(hFile);
	}
	else
	{
		if (IDYES == MessageBox(hwnd, "Do you want to download ZipCode.dta (522Kbytes) from jdmcox.com,\nand automatically try again?", "Couldn't find \"ZipCode.dta\" file", MB_YESNO))
		{
			goodread = FALSE;
			dwBytesRead = 1;
			SetCursor(hWaitingCursor);
			hOpen = InternetOpen(ProgName, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
			if (hInternet = InternetOpenUrl(hOpen, GetZipCode, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
			{
				BYTE *zipcode;
				zipcode = (BYTE*)malloc(535178);
				for (fileSize = 0; (goodread = InternetReadFile(hInternet, zipcode, 535178, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
					;
				InternetCloseHandle(hInternet);
				if ((goodread) && (dwBytesRead == 0))
				{
					HANDLE hZipcodeFile = CreateFile(ZipCode, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
					WriteFile(hZipcodeFile, zipcode, fileSize, &dwBytesWritten, NULL);
					CloseHandle(hZipcodeFile);
				}
				free(zipcode);
			}
			InternetCloseHandle(hOpen);
			SetCursor(hCursor);
			if ((goodread) && (dwBytesRead == 0) && (fileSize == 535178))
			{
				MessageBox(hwnd, "Got it. Trying again...", "", MB_OK);
				goto xyz;
			}
			else if (fileSize != 535178)
			{
				DeleteFile("ZipCode.dta");//it's not good
				MessageBox(hwnd, "File not found at jdmcox.com,\nor it was a bad download.", ERROR, MB_OK);
			}
			else
				MessageBox(hwnd, "Couldn't connect to the Internet", ERROR, MB_OK);
		}
		Lat = tempLat;
		Lon = tempLon;
		UTMZone = tempUTMZone;
		UTMNorthing = tempUTMN;
		UTMEasting = tempUTME;
		return;
	}
	for (y = 0; y < MAXAPRS; y++)
	{
		Aprs[y].UTMN = 0;
		Aprs[y].DescOrWx[0] = 0;
	}
	aprs = FALSE;

	y = sprintf(Error, "http://maps.aprsworld.net/map/near-switch.phtml?name=%s", Zip);

	hGlobal = GlobalAlloc(GHND|GMEM_SHARE, y+1);
	pGlobal = (char*)GlobalLock(hGlobal);
	lstrcpy(pGlobal, Error);
	GlobalUnlock(hGlobal);
	OpenClipboard(NULL);
	EmptyClipboard();
	SetClipboardData(CF_TEXT, hGlobal);
	CloseClipboard();

	SetCursor(hWaitingCursor);

	if (hInternet = InternetOpenUrl(hOpen, Error, Accept, -1, INTERNET_FLAG_NO_CACHE_WRITE|INTERNET_FLAG_KEEP_CONNECTION, 0))
	{
		aprsWorld = (char*)malloc(500000);//shouldn't get any bigger than this
		for (fileSize = 0; (fileSize < 500000) && (goodread = InternetReadFile(hInternet, &aprsWorld[fileSize], 500000-fileSize, &dwBytesRead)) && (dwBytesRead); fileSize += dwBytesRead)
			;
		InternetCloseHandle(hInternet);
		if ((goodread) && (dwBytesRead == 0))
		{
			HANDLE hFile = CreateFile(APRSWebPage, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, aprsWorld, fileSize, &dwBytesWritten, NULL);
			CloseHandle(hFile);
			GetLocalTime(&st);
			Aprsi = -1;
			x = -1;
			for (x++; (x < fileSize) && (*(int*)&aprsWorld[x] != 0X3B697026); x++)//&pi;
				;
			while (TRUE)
			{//
				for (x++; (x < fileSize) && (*(int*)&aprsWorld[x] != 0x3E52543C); x++)//<TR>
					;
				for (x += 75; (x < fileSize) && (*(int*)&aprsWorld[x] != 0x6C6C6163); x++)//"call"
					;
				if (*(int*)&aprsWorld[x] == 0x6C6C6163)//call
				{
					if ((Aprsi < MAXAPRS) || (Aprsi == -1))
						Aprsi++;
					x += 5;//to callsign
					for (z = 0; (z < 10) && (x < fileSize) && (aprsWorld[x] != '"'); x++, z++)
						Aprs[Aprsi].Call[z] = aprsWorld[x];
					Aprs[Aprsi].Call[z] = 0;
					for ( ; (x < fileSize) && (*(int*)&aprsWorld[x] != 0x3E226575); x++)//"ue">" (end of return true">)
						;
					if (x >= fileSize)
						break;
					x += 9;//to month
					Month = ((aprsWorld[x] -'0') * 10) + (aprsWorld[x+1] -'0');
					x += 3;//to date
					Day = ((aprsWorld[x] -'0') * 10) + (aprsWorld[x+1] -'0');
					if ((Month != st.wMonth) || (Day != st.wDay))
						continue;
					x += 3;//to time
					Aprs[Aprsi].Time = (((aprsWorld[x] - '0') * 1000) + ((aprsWorld[x+1] - '0') * 100) + ((aprsWorld[x+3] - '0') * 10) + (aprsWorld[x+4] - '0'));
					for ( ; (x < fileSize) && (*(int*)&aprsWorld[x] != 0x3E44543C); x++)//"<TD>"
						;
					for (x++; (x < fileSize) && (*(int*)&aprsWorld[x] != 0x3E44543C); x++)//"<TD>"
						;
					x += 4;//to latitude
					Lat = atof(&aprsWorld[x]);
					for ( ; (x < fileSize) && aprsWorld[x] != ' '; x++)
						;
					x += 2;//to longitude (past '-')
					Lon = -(atof(&aprsWorld[x]));
					if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))//outside USA
						continue;
					LatRad = Lat*deg2rad;
					LonRad = Lon*deg2rad;
					LatLontoUTM();
					Aprs[Aprsi].UTMN = UTMNorthing;
					Aprs[Aprsi].UTME = UTMEasting;
					Aprs[Aprsi].UTMZ = UTMZone;
					Aprs[Aprsi].DescOrWx[0] = ' ';//so info will show
					for ( ; (x < fileSize) && (*(int*)&aprsWorld[x] != 0x3E44543C); x++)//"<TD>"
						;
					x += 4;//to speed
					Speed = atoi(&aprsWorld[x]);
					for ( ; (x < fileSize) && (*(int*)&aprsWorld[x] != 0x3E44543C); x++)//"<TD>"
						;
					x += 4;//to course
					Course = atoi(&aprsWorld[x]);
					for (x++; (x < fileSize) && ((*(int*)&aprsWorld[x] != 0x74617453) || (*(int*)&aprsWorld[x+4] != 0x3C3A7375)); x++);//"Status:<"
						;
					if (x == fileSize)
						break;
					x += 12;//to status field
					z = 0;//overwrite ' '
					if ((aprsWorld[x] == 'g') || (aprsWorld[x] == 't'))
					{
						if (aprsWorld[x] == 'g') 
						{
							if ((aprsWorld[x+1] >= '0') && (aprsWorld[x+1] <= '9')
							 && (aprsWorld[x+2] >= '0') && (aprsWorld[x+2] <= '9')
							 && (aprsWorld[x+3] >= '1') && (aprsWorld[x+3] <= '9'))
							{
								for (y = 0; y < 5; y++)
									Aprs[Aprsi].DescOrWx[z++] = Wind[y];
								if (aprsWorld[x+1] != '0')
									Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x+1];
								if ((aprsWorld[x+1] != '0') && (aprsWorld[x+2] != '0'))
									Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x+2];
								Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x+3];
								Aprs[Aprsi].DescOrWx[z++] = 'm';
								Aprs[Aprsi].DescOrWx[z++] = 'p';
								Aprs[Aprsi].DescOrWx[z++] = 'h';
								Aprs[Aprsi].DescOrWx[z++] = ' ';
							}
							x += 5;//to temp
							Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x++];
							Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x++];
							Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x++];
							Aprs[Aprsi].DescOrWx[z++] = '\xB0';//degrees
							Aprs[Aprsi].DescOrWx[z++] = 'F';
						}
						else//if (aprsWorld[x] == 't')
						{
							if ((aprsWorld[x+1] >= '0') && (aprsWorld[x+1] <= '9')
							 && (aprsWorld[x+2] >= '0') && (aprsWorld[x+2] <= '9')
							 && (aprsWorld[x+3] >= '0') && (aprsWorld[x+3] <= '9'))
							{
								x++;
								Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x++];
								Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x++];
								Aprs[Aprsi].DescOrWx[z++] = aprsWorld[x++];
								Aprs[Aprsi].DescOrWx[z++] = '\xB0';//degrees
								Aprs[Aprsi].DescOrWx[z++] = 'F';
							}
						}
						Aprs[Aprsi].DescOrWx[z] = 0;
					}
					else if ((Speed) && (Course))
					{
						Aprs[Aprsi].DescOrWx[z++] = (((Course % 1000) / 100) + '0');
						Aprs[Aprsi].DescOrWx[z++] = (((Course % 100) / 10) + '0');
						Aprs[Aprsi].DescOrWx[z++] = ((Course % 10) + '0');
						Aprs[Aprsi].DescOrWx[z++] = '\xB0';//degrees
						Aprs[Aprsi].DescOrWx[z++] = ' ';
						w = (((Speed % 1000) / 100) + '0');
						if (w != '0')
							Aprs[Aprsi].DescOrWx[z++] = w;
						Aprs[Aprsi].DescOrWx[z++] = (((Speed % 100) / 10) + '0');
						Aprs[Aprsi].DescOrWx[z++] = ((Speed % 10) + '0');
						Aprs[Aprsi].DescOrWx[z++] = 'm';
						Aprs[Aprsi].DescOrWx[z++] = 'p';
						Aprs[Aprsi].DescOrWx[z++] = 'h';
						Aprs[Aprsi].DescOrWx[z] = 0;
					}
				}
				else if (x >= fileSize)
					break;
			}
		}
		free(aprsWorld);
	}
	InternetCloseHandle(hOpen);
	SetCursor(hCursor);

	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
	if (Aprsi != -1)
		aprs = TRUE;
	else
	{
		CheckMenuItem(hMenu, ID_APRS_RECEIVEINTERNETDATA, MF_UNCHECKED);
		aprs = tnc = FALSE;
		MessageBox(hwnd, "No APRS data", ERROR, MB_OK);
	}
}
*/
void GetAPRSLL(void)//called from GetAPRSLatLon and GetAPRSLatLon2
{
	LatRad = Lat*deg2rad;
	LonRad = Lon*deg2rad;
	LatLontoUTM();
	Aprs[Aprsi].UTMN = UTMNorthing;
	Aprs[Aprsi].UTME = UTMEasting;
	Aprs[Aprsi].UTMZ = UTMZone;
	for (y = 0; Addr[y] != 0; y++)
		Aprs[Aprsi].Call[y] = Addr[y];
	Aprs[Aprsi].Call[y] = 0;
	if (weatherlessposition)
	{
		weatherlessposition = FALSE;
		if (Aprsi)
		{
			for (y = Aprsi-1; y > 0; y--)
			{
				for (z = 0; Addr[z] != 0; z++)
					if (Aprs[y].Call[z] != Addr[z])
						break;
				if ((Addr[z] == 0))// && (Aprs[y].UTMN == 0)
				{//same callsign
					Aprs[y].UTMN = Aprs[Aprsi].UTMN;
					Aprs[y].UTME = Aprs[Aprsi].UTME;
					Aprs[y].UTMZ = Aprs[Aprsi].UTMZ;
					Aprs[y].SymbolType = '/';
					Aprs[y].Symbol = 62;//WX
					break;
				}
			}
		}
		Aprs[Aprsi].Call[0] = 0;
		Aprs[Aprsi].UTMN = 0;
		Aprs[Aprsi].DescOrWx[0] = 0;
		Aprs[Aprsi].Status[0] = 0;
		Aprs[Aprsi].RedDot = 0;
		Aprsi--;//don't show this data
	}
	else if (Aprsi)
	{
		for (y = Aprsi-1; y != 0xFFFFFFFF; y--)
		{
			if ((Aprs[y].Call[0] != 0) && (Aprs[y].UTMN != 0))
			{
				for (z = 0; Aprs[y].Call[z] != 0; z++)
					if (Aprs[y].Call[z] != Aprs[Aprsi].Call[z])
						break;
				if ((Aprs[y].Call[z] == 0) && (Aprs[Aprsi].Call[z] == 0) && ((Aprs[y].UTMN != Aprs[Aprsi].UTMN) || (Aprs[y].UTME != Aprs[Aprsi].UTME)))
				{//same callsign
					Aprs[y].RedDot = 1;// to show track
					if (showlist & 0x00100000)
					{// don't show tracks
						for (int i = 0; (i < 256) && (ShowList6[i] != 0); )
						{
							for (z = 0; ; i++, z++)
								if (ShowList6[i] != Aprs[y].Call[z])
									break;
							if ((ShowList6[i] == 0) || (ShowList6[i] == '\r'))
							{// found a match
								Aprs[y].RedDot = 3;// to just show a red dot
								Aprs[Aprsi].RedDot = 0;// to show symbol, but not show track
								break;
							}
							for ( ; (i < 256) && (ShowList6[i] != 0) && (ShowList6[i] != '\n'); i++)
								;//go to beginning of line
							if ((i == 256) || (ShowList6[i] == 0))
								break;
							i++;
						}
					}
				}
			}
		}
	}

	if ((Aprsi < MAXAPRS) || (Aprsi == -1))
		Aprsi++;
	else
		SaveAPRSlog();
	aprs = TRUE;
}

//KQ7J>APU25N,WIDE3-3,qAo,W7PAQ:=4649.05N/11402.05Wy>>>>Big Sky Country{UIV32N}
void GetAPRSLatLon(int x)
{
	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;
	Lat = (double)(((aprsBuf[x] - '0') * 10) + (aprsBuf[x+1] - '0'));
	x += 2;//to minutes
	Lat += (double)atof((char*)&aprsBuf[x]) / 60.0;
	x += 5;//to N or S
	x++;//to symbol table
	if (aprsBuf[x] == '/')
		SymbolTable = PRIMARY;
	else if (aprsBuf[x] == '\\')
		SymbolTable = SECONDARY;
	else
		SymbolTable = aprsBuf[x];
	Aprs[Aprsi].SymbolType = aprsBuf[x];
	x++;
	Lon = (double)(((aprsBuf[x] - '0') * 100) + ((aprsBuf[x+1] - '0') * 10) + (aprsBuf[x+2] - '0'));
	x += 3;//to minutes
	Lon += (double)atof((char*)&aprsBuf[x]) / 60.0;
	x += 5;//to W or E
	if (aprsBuf[x] == 'W')
		Lon = -Lon;
	if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
	{
		Lat = tempLat;
		Lon = tempLon;
		UTMZone = tempUTMZone;
		UTMNorthing = tempUTMN;
		UTMEasting = tempUTME;
		Aprs[Aprsi].Call[0] = 0;
		Aprs[Aprsi].UTMN = 0;
		Aprs[Aprsi].DescOrWx[0] = 0;
		Aprs[Aprsi].Status[0] = 0;
		Aprs[Aprsi].RedDot = 0;
		Aprsi--;//don't show this data
		return;
	}
	x++;//to symbol
	for (y = 0; (y < 95) && (APRSSymbols[y].symbol != aprsBuf[x]); y++)
		;
	Aprs[Aprsi].Symbol = (BYTE)y;
	if (y < 95)
	{
		z = 0;
		if (SymbolTable == PRIMARY)
		{
			if (aprsBuf[x] == '_')
			{
				if ((aprsBuf[x+1] >= '0') && (aprsBuf[x+1] <= '9'))
					GetWX(x);
				else
				{
					weatherlessposition = TRUE;
//					for ( ; APRSSymbols[y].Primary[z] != 0; z++)//put WX Station in case there's no positionless WX station
//						Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Primary[z];
//					Aprs[Aprsi].DescOrWx[z] = 0;
				}
			}
			else
			{
				if (itsobject)
				{
					itsobject = FALSE;
				for (y = 0; Object[y] != 0; ObjectPtr++, y++)
					Aprs[Aprsi].DescOrWx[ObjectPtr] = Object[y];
				Aprs[Aprsi].DescOrWx[ObjectPtr] = 0;
				}
				else
				{
					for ( ; APRSSymbols[y].Primary[z] != 0; z++)
						Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Primary[z];
					Aprs[Aprsi].DescOrWx[z] = 0;
				}
			}
		}
		else if (SymbolTable == SECONDARY)
		{
			if (aprsBuf[x] == '_')
			{
				if ((aprsBuf[x+1] >= '0') && (aprsBuf[x+1] <= '9'))
					GetWX(x);
				else
				{
					weatherlessposition = TRUE;
//					for ( ; APRSSymbols[y].Primary[z] != 0; z++)//put WX Station in case there's no positionless WX station
//						Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Primary[z];
//					Aprs[Aprsi].DescOrWx[z] = 0;
				}
			}
			else
			{
				if (itsobject)
				{
					itsobject = FALSE;
				for (y = 0; Object[y] != 0; ObjectPtr++, y++)
					Aprs[Aprsi].DescOrWx[ObjectPtr] = Object[y];
				Aprs[Aprsi].DescOrWx[ObjectPtr] = 0;
				}
				else
				{
					for ( ; APRSSymbols[y].Secondary[z] != 0; z++)
						Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Secondary[z];
					Aprs[Aprsi].DescOrWx[z] = 0;
				}
			}
		}
		else//SymbolTable is overlayed on Secondary
		{
			if (itsobject)
			{
				itsobject = FALSE;
				for (y = 0; Object[y] != 0; ObjectPtr++, y++)
					Aprs[Aprsi].DescOrWx[ObjectPtr] = Object[y];
				Aprs[Aprsi].DescOrWx[ObjectPtr] = 0;
			}
			else
			{
				for (w = 0; APRSSymbols[y].Secondary[w] != 0; z++, w++)
					Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Secondary[w];
				Aprs[Aprsi].DescOrWx[z++] = ' ';
				Aprs[Aprsi].DescOrWx[z++] = SymbolTable;
				Aprs[Aprsi].DescOrWx[z] = 0;
			}
		}
	}
	if (aprsBuf[x] != '_')
	{//if not wx
		x++;//to status: 000/000
		if ((aprsBuf[x+3] == '/') && (aprsBuf[x] >= '0') && (aprsBuf[x] <= '9') && (aprsBuf[x+1] >= '0') && (aprsBuf[x+1] <= '9') && (aprsBuf[x+2] >= '0') && (aprsBuf[x+2] <= '9'))
		{
			Course = (((aprsBuf[x] - '0') * 100) + ((aprsBuf[x+1] - '0') * 10) + (aprsBuf[x+2] - '0'));
			Speed = (((aprsBuf[x+4] - '0') * 100) + ((aprsBuf[x+5] - '0') * 10) + (aprsBuf[x+6] - '0'));
			if (Speed)
			{
				d = Speed  * 1.150779448;//to convert knots to miles/hour
				Speed = (int)d;
				Aprs[Aprsi].DescOrWx[z++] = ' ';
				Aprs[Aprsi].DescOrWx[z++] = (((Course % 1000) / 100) + '0');
				Aprs[Aprsi].DescOrWx[z++] = (((Course % 100) / 10) + '0');
				Aprs[Aprsi].DescOrWx[z++] = ((Course % 10) + '0');
				Aprs[Aprsi].DescOrWx[z++] = '\xB0';//degrees
				Aprs[Aprsi].DescOrWx[z++] = ' ';
				w = (((Speed % 1000) / 100) + '0');
				if (w != '0')
					Aprs[Aprsi].DescOrWx[z++] = w;
				Aprs[Aprsi].DescOrWx[z++] = (((Speed % 100) / 10) + '0');
				Aprs[Aprsi].DescOrWx[z++] = ((Speed % 10) + '0');
				Aprs[Aprsi].DescOrWx[z++] = 'm';
				Aprs[Aprsi].DescOrWx[z++] = 'p';
				Aprs[Aprsi].DescOrWx[z++] = 'h';
			}
		}
	}
//	x++;//to Status/comment
	z = 0;
	for ( ; (z < 48) && (aprsBuf[x] != '\r'); x++, z++)
		Aprs[Aprsi].Status[z] = aprsBuf[x];
	Aprs[Aprsi].Status[z] = 0;

//	if (Aprs[Aprsi].UTMN)
	{
		for (y = Aprsi-1; y != 0xFFFFFFFF; y--)
		{
			if (Aprs[y].UTMN != 0)
			{
				for (z = 0; Addr[z] != 0; z++)
					if (Aprs[y].Call[z] != Addr[z])
						break;
				if ((Addr[z] == 0) && (Aprs[y].Call[z] == 0))
				{//same callsign
					if ((Aprs[y].Status[0]) && (Aprs[Aprsi].Status[0] == 0))
					{
						for (z = 0; Aprs[y].Status[z] != 0; z++)
							Aprs[Aprsi].Status[z] = Aprs[y].Status[z];
						Aprs[Aprsi].Status[z] = 0;
						break;
					}
					else if ((Aprs[Aprsi].Status[0]) && (Aprs[y].Status[0] == 0))
					{
						for (z = 0; Aprs[Aprsi].Status[z] != 0; z++)
							Aprs[y].Status[z] = Aprs[Aprsi].Status[z];
						Aprs[y].Status[z] = 0;
						break;
					}
				}
			}
		}
	}

	GetAPRSLL();
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
//	if ((!aprsimulate) && (Aprs[Aprsi-1].UTMZ == UTMZone)
//	 && (Aprs[Aprsi-1].UTME > ScreenLeft) && (Aprs[Aprsi-1].UTME < ScreenRight)
//	 && (Aprs[Aprsi-1].UTMN < ScreenTop) && (Aprs[Aprsi-1].UTMN > ScreenBottom))
//	{
//		InvalidateRect(hwnd, &rect, FALSE);
//		UpdateWindow(hwnd);
//	}
}

/*
void GetAPRSLatLon2(int x)//called from KISS
{
	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;
	if ((KissPos[x] >= '0') && (KissPos[x] <= '9'))
	{
		Lat = (double)(((KissPos[x] - '0') * 10) + (KissPos[x+1] - '0'));
		x += 2;//to minutes
		Lat += (double)atof(&KissPos[x]) / 60.0;
		if ((Lat > 72.0) || (Lat < 17.5))
		{
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
			return;
		}
		x += 5;//to N or S
		if (KissPos[x] == 'S')
			return;
		x += 2;
		Lon = (double)(((KissPos[x] - '0') * 100) + ((KissPos[x+1] - '0') * 10) + (KissPos[x+2] - '0'));
		x += 3;//to minutes
		Lon += (double)atof(&KissPos[x]) / 60.0;
		x += 5;//to W or E
		if (KissPos[x] == 'W')
			Lon = -Lon;
		if ((Lon > -60.0) || (Lon < -168.0))
		{
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
			return;
		}
	}
	else
	{//compressed
		UINT Total;

		x++;//past symbol table ID
		Total = ((KissPos[x++]-33) * 753571) + ((KissPos[x++]-33) * 8281) + ((KissPos[x++]-33) * 91) + (KissPos[x++]-33);
		Lat = 90.0 - ((double)Total / 380926.0);
		if ((Lat > 72.0) || (Lat < 17.5))
		{
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
			return;
		}
		Total = ((KissPos[x++]-33) * 753571) + ((KissPos[x++]-33) * 8281) + ((KissPos[x++]-33) * 91) + (KissPos[x++]-33);
		Lon = - 180.0 + ((double)Total / 190463.0);
		if ((Lon > -60.0) || (Lon < -168.0))
		{
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
			return;
		}
	}
	GetAPRSLL();
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
	if ((!aprsimulate) && (Aprs[Aprsi-1].UTMZ == UTMZone))
	{
		InvalidateRect(hwnd, &rect, FALSE);
		UpdateWindow(hwnd);
	}
}

BOOL GetTNCLL(void)//called from GetTNCLatLon (KISS)
{
	x += 2;
	Lon = ((Nmea[x] - '0') * 100) + ((Nmea[x+1] - '0') * 10) + (Nmea[x+2] - '0') + ((atof(&Nmea[x+3])) / 60.0);
	for (x += 5; (Nmea[x] != ',') && (Nmea[x] != 0); x++)
		;
	x++;
	if (Nmea[x] == 'W')
	{
		Lon = -Lon;
		LatRad = Lat*deg2rad;
		LonRad = Lon*deg2rad;
		LatLontoUTM();
		Aprs[Aprsi].UTMN = UTMNorthing;
		Aprs[Aprsi].UTME = UTMEasting;
		Aprs[Aprsi].UTMZ = UTMZone;
		for (y = 0; Addr[y] != 0; y++)
			Aprs[Aprsi].Call[y] = Addr[y];
		Aprs[Aprsi].Call[y] = 0;
		aprs = TRUE;
		return TRUE;
	}
	else
		return FALSE;
}

//GPGLL,4916.45,N,12311.12,W,225444,A
//GPGGA,123519,4807.038,N,01131.324,E,1,08,0.9,545.4,M,46.9,M, , *42
//GPRMC,225446,A,4916.45,N,12311.12,W,000.5,054.7,191194,020.3,E*68
void GetTNCLatLon(void)//called from KISS
{
	if (Nmea[0] != 'G')
		return;
	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;
	if ((Nmea[3] == 'L') && (Nmea[4] == 'L'))
	{
		Lat = ((Nmea[6] - '0') * 10) + (Nmea[7] - '0') + ((atof(&Nmea[8])) / 60.0);
		for (x = 11; (Nmea[x] != ',') && (Nmea[x] != 0); x++)
			;
		x++;
		if (Nmea[x] == 'N')
		{
			if (GetTNCLL())
			{
				x += 2;
				Aprs[Aprsi].Time = (((Nmea[x] - '0') * 1000) + ((Nmea[x+1] - '0') * 100) + ((Nmea[x+2] - '0') * 10) + (Nmea[x+3] - '0'));
				if ((Aprsi < MAXAPRS) || (Aprsi == -1))
					Aprsi++;
				else
					SaveAPRSlog();
			}
		}
	}
	else if ((Nmea[3] == 'G') && (Nmea[4] == 'A'))
	{
		Aprs[Aprsi].Time = (((Nmea[6] - '0') * 1000) + ((Nmea[7] - '0') * 100) + ((Nmea[8] - '0') * 10) + (Nmea[9] - '0'));
		Lat = ((Nmea[13] - '0') * 10) + (Nmea[14] - '0') + ((atof(&Nmea[15])) / 60.0);
		for (x = 18; (Nmea[x] != ',') && (Nmea[x] != 0); x++)
			;
		x++;
		if (Nmea[x] == 'N')
		{
			if (GetTNCLL())
			if ((Aprsi < MAXAPRS) || (Aprsi == -1))
				Aprsi++;
			else
				SaveAPRSlog();
		}
	}
	else if ((Nmea[3] == 'R') && (Nmea[4] == 'M') && (Nmea[5] == 'C'))
	{
		Aprs[Aprsi].Time = (((Nmea[6] - '0') * 1000) + ((Nmea[7] - '0') * 100) + ((Nmea[8] - '0') * 10) + (Nmea[9] - '0'));
		Lat = ((Nmea[15] - '0') * 10) + (Nmea[16] - '0') + ((atof(&Nmea[17])) / 60.0);
		for (x = 20; (Nmea[x] != ',') && (Nmea[x] != 0); x++)
			;
		x++;
		if (Nmea[x] == 'N')
		{
			if (GetTNCLL())
			if ((Aprsi < MAXAPRS) || (Aprsi == -1))
				Aprsi++;
			else
				SaveAPRSlog();
		}
	}
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
}
*/
void MicE(int x)
{
	int Deg, Min, Hundredths;
	if ((Dest[3] & 0x40) && (Dest[5] & 0x40))//N and W bits
	{
		tempLat = Lat;
		tempLon = Lon;
		tempUTMZone = UTMZone;
		tempUTMN = UTMNorthing;
		tempUTME = UTMEasting;
		Deg = ((Dest[0] & 0x0F) * 10) + (Dest[1] & 0x0F);
		Min = ((Dest[2] & 0x0F) * 10) + (Dest[3] & 0x0F);
		Hundredths = ((Dest[4] & 0x0F) * 10) + (Dest[5] & 0x0F);
		Lat = (double)Deg + (((double)Min + (((double)Hundredths)/100.0))/60.0);
		Deg = KissPos[0]-28;
		if (Dest[4] & 0x40)//Longitude Offset bit
			Deg += 100;
		if ((Deg >= 180) && (Deg <= 189))
			Deg -= 80;
		else if ((Deg >= 190) && (Deg <= 199))
			Deg -= 90;
		Min = KissPos[1]-28;
		if (Min >= 60)
			Min -= 60;
		Hundredths = KissPos[2]-28;
		Lon = (double)Deg + (((double)Min + (((double)Hundredths)/100.0))/60.0);
		Lon = -Lon;
		if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
		{
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
			Aprs[Aprsi].Call[0] = 0;
			Aprs[Aprsi].UTMN = 0;
			Aprs[Aprsi].DescOrWx[0] = 0;
			Aprs[Aprsi].Status[0] = 0;
			Aprs[Aprsi].RedDot = 0;
			Aprsi--;//don't show this data
			return;
		}
		LatRad = Lat*deg2rad;
		LonRad = Lon*deg2rad;
		LatLontoUTM();
		Aprs[Aprsi].UTMN = UTMNorthing;
		Aprs[Aprsi].UTME = UTMEasting;
		Aprs[Aprsi].UTMZ = UTMZone;
		Speed = ((SP-28)*10) + ((DC-28)/10);
		Course = (((DC-28)%10)*100) + (SE-28);
		if (Speed >= 800)
			Speed -= 800;
		if (Course >= 400)
			Course -= 400;
		d = Speed * 1.150779448;//to convert knots to miles/hour
		Speed = (int)d;
		for (y = 0; Addr[y] != 0; y++)
			Aprs[Aprsi].Call[y] = Addr[y];
		Aprs[Aprsi].Call[y] = 0;
		y = x+8;//to Mic-E Status
		if ((aprsBuf[y] == '>') || (aprsBuf[y] == ']'))
			y++;//past Kenwood marks
		if (aprsBuf[y+3] == '}')//altitude
			y += 4;
		for (z = 0; (z < 48) && (y < (int)fileSize) && (aprsBuf[y] != '\r'); y++, z++)
			Aprs[Aprsi].Status[z] = aprsBuf[y];
		Aprs[Aprsi].Status[z] = 0;
		if (KissPos[4] == '/')
			SymbolTable = PRIMARY;
		else if (KissPos[4] == '\\')
			SymbolTable = SECONDARY;
		else
			SymbolTable = KissPos[4];
		Aprs[Aprsi].SymbolType = KissPos[4];
		for (y = 0; (y < 95) && (APRSSymbols[y].symbol != KissPos[3]); y++)
			;
		Aprs[Aprsi].Symbol = (BYTE)y;
		if (y < 95)
		{
			z = 0;
			if (KissPos[4] == '/')
			{
				if (KissPos[3] == '_')
					GetWX(x);
				else
				{
					for ( ; APRSSymbols[y].Primary[z] != 0; z++)
						Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Primary[z];
					if ((Speed) && (Course))
					{
						Aprs[Aprsi].DescOrWx[z++] = ' ';
						Aprs[Aprsi].DescOrWx[z++] = (((Course % 1000) / 100) + '0');
						Aprs[Aprsi].DescOrWx[z++] = (((Course % 100) / 10) + '0');
						Aprs[Aprsi].DescOrWx[z++] = ((Course % 10) + '0');
						Aprs[Aprsi].DescOrWx[z++] = '\xB0';//degrees
						Aprs[Aprsi].DescOrWx[z++] = ' ';
						w = (((Speed % 1000) / 100) + '0');
						if (w != '0')
							Aprs[Aprsi].DescOrWx[z++] = w;
						Aprs[Aprsi].DescOrWx[z++] = (((Speed % 100) / 10) + '0');
						Aprs[Aprsi].DescOrWx[z++] = ((Speed % 10) + '0');
						Aprs[Aprsi].DescOrWx[z++] = 'm';
						Aprs[Aprsi].DescOrWx[z++] = 'p';
						Aprs[Aprsi].DescOrWx[z++] = 'h';
					}
					if ((KissPos[3] == '\'') || (KissPos[3] == 'O'))
					{//small plane or balloon
						int Altitude;

						x += 8;//to Status Text
						if ((aprsBuf[x] == '>') || (aprsBuf[x] == ']'))
							x++;//Kenwood identifiers
						//from int Uncompress(int x): Total = (((aprsBuf[x+2]-33) * 8281) + ((aprsBuf[x+3]-33) * 91) + (aprsBuf[x+4]-33);
						d = ((((aprsBuf[x]-33) * 8281) + ((aprsBuf[x+1]-33) * 91) + (aprsBuf[x+2]-33)) - 10000) / 0.3048;
						Altitude = (int)d;//not shown yet...
						if (0 == (Altitude & 0x80000000))//if not a negative altitude
						{
							Aprs[Aprsi].DescOrWx[z++] = ' ';
							w = ((Altitude % 100000) / 10000) + '0';
							if (w != '0')
								Aprs[Aprsi].DescOrWx[z++] = w;
							Aprs[Aprsi].DescOrWx[z++] = ((Altitude % 10000) / 1000) + '0';
							Aprs[Aprsi].DescOrWx[z++] = (((Altitude % 1000) / 100) + '0');
							Aprs[Aprsi].DescOrWx[z++] = (((Altitude % 100) / 10) + '0');
							Aprs[Aprsi].DescOrWx[z++] = ((Altitude % 10) + '0');
							Aprs[Aprsi].DescOrWx[z++] = '\'';
						}
					}
					Aprs[Aprsi].DescOrWx[z] = 0;
				}
			}
			else if (KissPos[4] == '\\')
			{
				if (KissPos[3] == '_')
					GetWX(x);
				else
				{
					for ( ; APRSSymbols[y].Secondary[z] != 0; z++)
						Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Secondary[z];
					Aprs[Aprsi].DescOrWx[z] = 0;
				}
			}
			else//SymbolTable is overlayed on Secondary
			{
				for (w = 0; APRSSymbols[y].Secondary[w] != 0; z++, w++)
					Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Secondary[w];
				Aprs[Aprsi].DescOrWx[z++] = ' ';
				Aprs[Aprsi].DescOrWx[z++] = KissPos[4];
				Aprs[Aprsi].DescOrWx[z] = 0;
			}
		}
		if ((Aprsi != 0) && (Aprsi != -1))
		{
			for (y = Aprsi-1; y != 0xFFFFFFFF; y--)
			{
				if ((Aprs[y].Call[0] != 0) && (Aprs[y].UTMN != 0))
				{
					for (z = 0; Aprs[y].Call[z] != 0; z++)
						if (Aprs[y].Call[z] != Aprs[Aprsi].Call[z])
							break;
					if ((Aprs[y].Call[z] == 0) && (Aprs[Aprsi].Call[z] == 0) && ((Aprs[y].UTMN != Aprs[Aprsi].UTMN) || (Aprs[y].UTME != Aprs[Aprsi].UTME)))
					{//same callsign
						Aprs[y].RedDot = 1;// to show track
					}
				}
			}
		}
		if ((Aprsi < MAXAPRS) || (Aprsi == -1))
			Aprsi++;
		else
			SaveAPRSlog();
		aprs = TRUE;
		Lat = tempLat;
		Lon = tempLon;
		UTMZone = tempUTMZone;
		UTMNorthing = tempUTMN;
		UTMEasting = tempUTME;
	}
}

/*
c = wind direction in degrees
s = sustained one-minute wind speed in mph
g = gust (peak wind speed in mph in the last 5 minutes)
t = temperature in degrees Fahrenheit
r = rainfall in hundredths of an inch in the last hour
P = rainfall in hundredths of an inch in the last 24 hours
p = rainfall in hundredths of an inch since midnight
h = humidity in %
b = barometric pressure in thenths of millibars/tenths of hPascal
s = snowfall in inches in the last 24 hours
e.g. W_316/000g000t051P001h59b10196r000OU2k
Aprs[Aprsi].DescOrWx = 56F 75%  from 179 9G15
W6SAS>APTW01,W6CX-3*,WIDE2:_11231620c035s010g006t064r000p000P000h12b10154tU2k
KK6ZL>APTW01,W6CX-3*,WIDE2-1:!3740.81N/12153.33W_
*/
void FillDescOrWx(int x)
{
	int y, z;

	for ( ; aprsBuf[x] != '\r'; x++)
	{
		if ((aprsBuf[x] == 'c') && (aprsWindDir[0] == 0))//positionless wx only
		{
			for (y = 0, z = x+1; y < 3; y++, z++)
				aprsWindDir[y] = aprsBuf[z];
			aprsWindDir[y] = 0;
		}
		if ((aprsBuf[x] == 's') && (aprsWindSpeed[0] == 0))//positionless wx only
		{
			for (y = 0, z = x+1; y < 3; y++, z++)//x+4
				aprsWindSpeed[y] = aprsBuf[z];
			aprsWindSpeed[y] = 0;
		}
		if ((aprsBuf[x] == 'g') && (aprsGust[0] == 0))
		{
			if ((aprsBuf[x+1] != '0') || (aprsBuf[x+2] != '0') || (aprsBuf[x+3] != '0'))
			{
				for (y = 0, z = x+1; y < 3; y++, z++)//x+8
					aprsGust[y] = aprsBuf[z];
				aprsGust[y] = 0;
			}
		}
		if ((aprsBuf[x] == 't') && (aprsTemp[0] == 0))
		{
			aprsTemp[0] = aprsBuf[x+1];
			aprsTemp[1] = aprsBuf[x+2];
			aprsTemp[2] = aprsBuf[x+3];
			aprsTemp[3] = 0;
		}
		if ((aprsBuf[x] == 'h') && (aprsHumidity[0]))
		{
			aprsHumidity[0] = aprsBuf[x+1];
			aprsHumidity[1] = aprsBuf[x+2];
			aprsHumidity[2] = aprsBuf[x+3];
			aprsHumidity[3] = 0;
		}
	}
	z = 0;
	Aprs[Aprsi].DescOrWx[z++] = 'W';
	Aprs[Aprsi].DescOrWx[z++] = 'X';
	Aprs[Aprsi].DescOrWx[z++] = ' ';
	if (aprsTemp[0])
	{
		if (aprsTemp[0] != '0')
			Aprs[Aprsi].DescOrWx[z++] = aprsTemp[0];
		Aprs[Aprsi].DescOrWx[z++] = aprsTemp[1];
		Aprs[Aprsi].DescOrWx[z++] = aprsTemp[2];
		Aprs[Aprsi].DescOrWx[z++] = '\xB0';//degrees
		Aprs[Aprsi].DescOrWx[z++] = 'F';
	}
	if (aprsHumidity[0])
	{
		Aprs[Aprsi].DescOrWx[z++] = ' ';
		for (y = 0; y < 2; y++, z++)
			Aprs[Aprsi].DescOrWx[z] = aprsHumidity[y];
		Aprs[Aprsi].DescOrWx[z++] = '%';
		
	}
	if (aprsWindDir[0])
	{
		for (y = 0; wind[y] != 0; y++, z++)
			Aprs[Aprsi].DescOrWx[z] = wind[y];
		for (y = 0; y < 3; y++, z++)
			Aprs[Aprsi].DescOrWx[z] = aprsWindDir[y];
		Aprs[Aprsi].DescOrWx[z++] = ' ';
		if (aprsWindSpeed[0] != '0')
			Aprs[Aprsi].DescOrWx[z++] = aprsWindSpeed[0];
		if ((aprsWindSpeed[0] != '0') && (aprsWindSpeed[1] != '0'))
			Aprs[Aprsi].DescOrWx[z++] = aprsWindSpeed[1];
		Aprs[Aprsi].DescOrWx[z++] = aprsWindSpeed[2];
		if (aprsGust[0])
		{
			Aprs[Aprsi].DescOrWx[z++] = 'g';
			if (aprsGust[0] != '0')
				Aprs[Aprsi].DescOrWx[z++] = aprsGust[0];
			if ((aprsGust[0] != '0') && (aprsGust[1] != '0'))
				Aprs[Aprsi].DescOrWx[z++] = aprsGust[1];
			Aprs[Aprsi].DescOrWx[z++] = aprsGust[2];
		}
	}
	Aprs[Aprsi].DescOrWx[z] = 0;
}

void GetWX(int x)
{
	int y, z;

	x++;//to possible WX data
	if ((aprsBuf[x] >= '0') && (aprsBuf[x] <= '9'))
	{
		aprsWindSpeed[0] = 0;
		aprsGust[0] = 0;
		aprsWindDir[0] = 0;
		aprsTemp[0] = 0;
		aprsHumidity[0] = 0;

		if ((aprsBuf[x+4] != '0') || (aprsBuf[x+5] != '0') || (aprsBuf[x+6] != '0') || (aprsBuf[x+8] != '0') || (aprsBuf[x+9] != '0') || (aprsBuf[x+10] != '0'))
		{
			for (y = 0, z = x; y < 3; y++, z++)
				aprsWindDir[y] = aprsBuf[z];
			aprsWindDir[y] = 0;

			for (y = 0, z = x+4; y < 3; y++, z++)
				aprsWindSpeed[y] = aprsBuf[z];
			aprsWindSpeed[y] = 0;
		}
		x += 7;//to wind gust info
		FillDescOrWx(x);
	}
}

void GetAPRSlogFile(void)
{
	strcpy(APRSBufferTxt, "APRS log01.txt");
	HANDLE hFile = FindFirstFile("APRS log??.txt", &fd);
	if (hFile != INVALID_HANDLE_VALUE)
	{//found it
//		APRSBufferTxt[8] = '0';
//		APRSBufferTxt[9] = '1';
		while (TRUE)
		{
			FindClose(hFile);
			hFile = FindFirstFile(APRSBufferTxt, &fd);
			if (hFile == INVALID_HANDLE_VALUE)
				break;
			APRSBufferTxt[9]++;
			if (APRSBufferTxt[9] > '9')
			{
				if (APRSBufferTxt[8] != '9')
				{
					APRSBufferTxt[9] = '0';
					APRSBufferTxt[8]++;
				}
				else
				{
					itsfull = TRUE;
					FindClose(hFile);
					MessageBox(hwnd, "Move your 99 APRS logXX.txt files\nto another folder\nso you can start over.", "", MB_OK);
					break;
				}
			}
		}
	}
}

void GetAPRSlogFile2(void)
{
	strcpy(APRSlog, "APRS log01.dta");
	HANDLE hFile = FindFirstFile("APRS log??.dta", &fd);
	if (hFile != INVALID_HANDLE_VALUE)
	{//found it
		APRSlog[8] = '0';
		APRSlog[9] = '1';
		while (TRUE)
		{
			FindClose(hFile);
			hFile = FindFirstFile(APRSlog, &fd);
			if (hFile == INVALID_HANDLE_VALUE)
				break;
			APRSlog[9]++;
			if (APRSlog[9] > '9')
			{
				if (APRSlog[8] != '9')
				{
					APRSlog[9] = '0';
					APRSlog[8]++;
				}
				else
				{
					itsfull = TRUE;
					FindClose(hFile);
					MessageBox(hwnd, "Move your 99 APRS logXX.dta files\nto another folder\nso you can start over.", "", MB_OK);
					break;
				}
			}
		}
	}
}

int PutSpeedCourse(int z)
{
	Aprs[Aprsi].DescOrWx[z++] = ' ';
	Aprs[Aprsi].DescOrWx[z++] = (((Course % 1000) / 100) + '0');
	Aprs[Aprsi].DescOrWx[z++] = (((Course % 100) / 10) + '0');
	Aprs[Aprsi].DescOrWx[z++] = ((Course % 10) + '0');
	Aprs[Aprsi].DescOrWx[z++] = '\xB0';//degrees
	Aprs[Aprsi].DescOrWx[z++] = ' ';
	w = (((Speed % 1000) / 100) + '0');
	if (w != '0')
		Aprs[Aprsi].DescOrWx[z++] = w;
	Aprs[Aprsi].DescOrWx[z++] = (((Speed % 100) / 10) + '0');
	Aprs[Aprsi].DescOrWx[z++] = ((Speed % 10) + '0');
	Aprs[Aprsi].DescOrWx[z++] = 'm';
	Aprs[Aprsi].DescOrWx[z++] = 'p';
	Aprs[Aprsi].DescOrWx[z++] = 'h';
	return z;
}

//if ((Addr[0] == 'K') && (Addr[1] == 'G') && (Addr[2] == '6') && (Addr[3] == 'O') && (Addr[4] == 'W') && (Addr[5] == 'S'))
int Uncompress(int x)
{
	UINT Total;

	Aprs[Aprsi].SymbolType = aprsBuf[x];
	for (y = 0; (y < 95) && (APRSSymbols[y].symbol != aprsBuf[x+9]); y++)
		;
	Aprs[Aprsi].Symbol = (BYTE)y;
	if (y < 95)
	{
		z = 0;
		if (aprsBuf[x] == '/')
		{//PRIMARY
			if (aprsBuf[x+9] == '_')
				GetWX(x+13);
			else if (itsobject)
			{
				itsobject = FALSE;
				for (y = 0; Object[y] != 0; ObjectPtr++, y++)
					Aprs[Aprsi].DescOrWx[ObjectPtr] = Object[y];
				Aprs[Aprsi].DescOrWx[ObjectPtr] = 0;
			}
			else
			{
				for (w = 0; APRSSymbols[y].Primary[w] != 0; w++, z++)
					Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Primary[w];
//				Aprs[Aprsi].DescOrWx[z] = 0;
			}
		}
		else if (aprsBuf[x] == '\\')
		{//SECONDARY
			if (aprsBuf[x+9] == '_')
				GetWX(x+13);
			else if (itsobject)
			{
				itsobject = FALSE;
				for (y = 0; Object[y] != 0; ObjectPtr++, y++)
					Aprs[Aprsi].DescOrWx[ObjectPtr] = Object[y];
				Aprs[Aprsi].DescOrWx[ObjectPtr] = 0;
			}
			else
			{
				for (w = 0; APRSSymbols[y].Secondary[w] != 0; w++, z++)
					Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Secondary[w];
//				Aprs[Aprsi].DescOrWx[z] = 0;
			}
		}
		else
		{//OVERLAY
			for (w = 0; APRSSymbols[y].Secondary[w] != 0; z++, w++)
				Aprs[Aprsi].DescOrWx[z] = APRSSymbols[y].Secondary[w];
			Aprs[Aprsi].DescOrWx[z++] = ' ';
			Aprs[Aprsi].DescOrWx[z++] = aprsBuf[x];
			Aprs[Aprsi].DescOrWx[z] = 0;
		}
		tempLat = Lat;
		tempLon = Lon;
		tempUTMZone = UTMZone;
		tempUTMN = UTMNorthing;
		tempUTME = UTMEasting;
		Total = ((aprsBuf[x+1]-33) * 753571) + ((aprsBuf[x+2]-33) * 8281) + ((aprsBuf[x+3]-33) * 91) + (aprsBuf[x+4]-33);
		Lat = 90.0 - ((double)Total / 380926.0);
		Total = ((aprsBuf[x+5]-33) * 753571) + ((aprsBuf[x+6]-33) * 8281) + ((aprsBuf[x+7]-33) * 91) + (aprsBuf[x+8]-33);
		Lon = -180.0 + ((double)Total / 190463.0);
		if ((aprsBuf[x+10] >= '!') && (aprsBuf[x+10] <= 'z'))
		{
			Course = (aprsBuf[x+10] - 33) * 4;
			Speed = (int)((pow(1.08, (double)(aprsBuf[x+11])-33) - 1.0) * 1.150779448);//also converts knots to MPH
			if (Speed)
				z = PutSpeedCourse(z);
		}
		Aprs[Aprsi].DescOrWx[z] = 0;
		x += 12;//to last byte of compressed data
		if ((Lon > -60.0) || (Lon < -168.0) || (Lat > 72.0) || (Lat < 17.5))
		{
			Lat = tempLat;
			Lon = tempLon;
			UTMZone = tempUTMZone;
			UTMNorthing = tempUTMN;
			UTMEasting = tempUTME;
			Aprs[Aprsi].Call[0] = 0;
			Aprs[Aprsi].UTMN = 0;
			Aprs[Aprsi].DescOrWx[0] = 0;
			Aprs[Aprsi].Status[0] = 0;
			Aprs[Aprsi].RedDot = 0;
			Aprsi--;//don't show this data
			return x;
		}
		GetAPRSLL();
		Lat = tempLat;
		Lon = tempLon;
		UTMZone = tempUTMZone;
		UTMNorthing = tempUTMN;
		UTMEasting = tempUTME;
		if ((!aprsimulate) && (Aprs[Aprsi-1].UTMZ == UTMZone)
		 && (Aprs[Aprsi-1].UTME > ScreenLeft) && (Aprs[Aprsi-1].UTME < ScreenRight)
		 && (Aprs[Aprsi-1].UTMN < ScreenTop) && (Aprs[Aprsi-1].UTMN > ScreenBottom))
		{
			InvalidateRect(hwnd, &rect, FALSE);
			UpdateWindow(hwnd);
		}
	}
	else
	{
		Aprs[Aprsi].Call[0] = 0;
		Aprs[Aprsi].UTMN = 0;
		Aprs[Aprsi].DescOrWx[0] = 0;
		Aprs[Aprsi].Status[0] = 0;
		Aprs[Aprsi].RedDot = 0;
		Aprsi--;//don't show this data
	}
	return x;//to add status
}

void SaveAPRSlog(void)
{
	int x;
	HANDLE hAPRSLog;

	if (aprsimulate == FALSE)
	{
		if (!strlen(APRSlog))
		{
			GetAPRSlogFile2();
		}
		hAPRSLog = CreateFile(APRSlog, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
		SetFilePointer(hAPRSLog,0,NULL,FILE_END);
		for (x = 0; x < Aprsi; x++)
			WriteFile(hAPRSLog, &Aprs[x], 100, &dwBytesWritten, NULL);
		CloseHandle(hAPRSLog);
	}
	Aprs[0] = Aprs[Aprsi];
	Aprsi = 1;
}

void SaveAPRSlogAsText(void)
{
	HANDLE hAPRSLog;

	if (!strlen(APRSBufferTxt))
	{
		GetAPRSlogFile();
	}
	hAPRSLog = CreateFile(APRSBufferTxt, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
	SetFilePointer(hAPRSLog,0,NULL,FILE_END);
	WriteFile(hAPRSLog, aprsBuf, aprsi, &dwBytesWritten, NULL);
	CloseHandle(hAPRSLog);
	aprsi = 0;
}

void ParseAPRS(int x)
{
	BOOL CSFlag;

	if ((firsttx) && (gettingsaved == FALSE))
		InitializeAPRSComm();
	GetSystemTime(&st);
	ObjectPtr = 0;
	if (aprsBuf[x] == ';')
	{//Object
		if (aprsBuf[x+10] == '_')
		{//"killed" object
			for (y = 0; y < Aprsi; y++)
			{
				for (w = x+1, z = 0; z < 9; w++, z++)
					if (Aprs[y].Call[z] != aprsBuf[w])
						break;
				if (z == 9)
					for (z = y; z < Aprsi; z++)
						Aprs[z] = Aprs[z+1];//delete that entry
			}
			InvalidateRect(hwnd, &rect, FALSE);
			return;
		}

		for (y = 0; Addr[y] != 0; ObjectPtr++, y++)
			Aprs[Aprsi].DescOrWx[ObjectPtr] = Addr[y];
		for (x++, y = 0; (y < 9) && (Addr[y] != '\r'); x++, y++)
			Addr[y] = aprsBuf[x];
		if (Addr[y] == '\r')
			return;//bogus object
		x++;//past * or _
//		for (y--; Addr[y] == ' '; y--)
//			;
//		y++;
		Addr[y] = 0;
		if ((aprsBuf[x] >= '0') && (aprsBuf[x] <= '9') && (aprsBuf[x+1] >= '0') && (aprsBuf[x+1] <= '9') && (aprsBuf[x+2] >= '0') && (aprsBuf[x+2] <= '9'))
		{//timestamp
			Aprs[Aprsi].Time = (((aprsBuf[x+2] - '0') * 1000) + ((aprsBuf[x+3] - '0') * 100) + ((aprsBuf[x+4] - '0') * 10) + (aprsBuf[x+5] - '0'));
			if ((aprsBuf[x+6] == '/') && (aprsimulate == FALSE))
			{//092345/ is 2345 local time on the 9th
				GetTimeZoneInformation(&tzi);
				y = (tzi.Bias/60)*100;
				Aprs[Aprsi].Time += y;//convert it to UTC
				if (Aprs[Aprsi].Time > 2359)
					Aprs[Aprsi].Time -= 2400;
			}
			else if ((aprsBuf[x+6] == 'h') && (aprsimulate == FALSE))
			{//234517h is 2345Z and 17 seconds
				Aprs[Aprsi].Time = (((aprsBuf[x] - '0') * 1000) + ((aprsBuf[x+1] - '0') * 100) + ((aprsBuf[x+2] - '0') * 10) + (aprsBuf[x+3] - '0'));
			}
//			else if (aprsimulate == FALSE)
//				Aprs[Aprsi].Time = (st.wHour * 100) + st.wMinute;
			x += 7;//to degrees
			itsobject = TRUE;
			if ((aprsBuf[x] >= '0') && (aprsBuf[x] <= '9') && (aprsBuf[x+1] >= '0') && (aprsBuf[x+1] <= '9') && (aprsBuf[x+2] >= '0') && (aprsBuf[x+2] <= '9'))
				GetAPRSLatLon(x);
			else
				x = Uncompress(x);
		}
	}

	else if ((aprsBuf[x] == '/') || (aprsBuf[x] == '@'))//APRS Data Type Identifiers
	{//position with timestamp
		x += 8;
		goto notimestamp;
	}

	else if ((aprsBuf[x] == '!') || (aprsBuf[x] == '='))
	{//position without timestamp (! could also be Ultimeter 2000 Wx Station)
		x++;
notimestamp:
		if (aprsimulate == FALSE)
			Aprs[Aprsi].Time = (st.wHour * 100) + st.wMinute;
		if ((aprsBuf[x] < '0') || (aprsBuf[x] > '9') || (aprsBuf[x+1] < '0') || (aprsBuf[x+1] > '9'))
			x = Uncompress(x);
		else
			GetAPRSLatLon(x);
	}

	else if (aprsBuf[x] == '_')
	{//positionless WX
		for (y = 0; Addr[y] != 0; y++)
			Aprs[Aprsi].Call[y] = Addr[y];
		Aprs[Aprsi].Call[y] = 0;
		for (y = 0; y < Aprsi; y++)
		{//get Lat/Lon from positionless WX station entry
			for (z = 0; Addr[z] != 0; z++)
				if (Aprs[y].Call[z] != Addr[z])
					break;
			if (Addr[z] == 0)
			{//same callsign
				Aprs[Aprsi].UTMN = Aprs[y].UTMN;
				Aprs[Aprsi].UTME = Aprs[y].UTME;
				Aprs[Aprsi].UTMZ = Aprs[y].UTMZ;
				Aprs[Aprsi].SymbolType = Aprs[y].SymbolType;
				Aprs[Aprsi].Symbol = Aprs[y].Symbol;
				break;
			}
		}
		x += 5; //to hour
		Aprs[Aprsi].Time = (((aprsBuf[x] - '0') * 1000) + ((aprsBuf[x+1] - '0') * 100) + ((aprsBuf[x+2] - '0') * 10) + (aprsBuf[x+3] - '0'));
		x += 4;//to weather
		aprsWindSpeed[0] = 0;
		aprsGust[0] = 0;
		aprsWindDir[0] = 0;
		aprsTemp[0] = 0;
		aprsHumidity[0] = 0;

		FillDescOrWx(x);

		if ((Aprsi < MAXAPRS) || (Aprsi == -1))
			Aprsi++;
		else
			SaveAPRSlog();
		aprs = TRUE;
	}

	else if ((aprsBuf[x] == '`') || (aprsBuf[x] == '\''))
	{//Mic-E
		x++;
			Aprs[Aprsi].Time = (st.wHour * 100) + st.wMinute;
		KissPos[0] = aprsBuf[x];
		KissPos[1] = aprsBuf[x+1];
		KissPos[2] = aprsBuf[x+2];
		SP = aprsBuf[x+3];
		DC = aprsBuf[x+4];
		SE = aprsBuf[x+5];
		KissPos[3] = aprsBuf[x+6];//symbol
		KissPos[4] = aprsBuf[x+7];//symbol / or \ or overlay

		MicE(x);
	}

	//$GPGLL,4916.45,N,12311.12,W,225444,A
	//$GPGGA,123519,4807.038,N,01131.324,E,1,08,0.9,545.4,M,46.9,M, , *42
	//$GPRMC,225446,A,4916.45,N,12311.12,W,000.5,054.7,191194,020.3,E*68
	else if ((aprsBuf[x] == '$') && (aprsBuf[x+1] == 'G') && (aprsBuf[x+2] == 'P'))//raw GPS
	{
		int savex;

		Aprs[Aprsi].SymbolType = '/';
		Aprs[Aprsi].Symbol = 1;//no symbol
		for (y = x; (y != 0xFFFFFFFF) && (aprsBuf[y] != '\n'); y--)
		{
			if ((aprsBuf[y] == 'G') && (aprsBuf[y+1] == 'P') && (aprsBuf[y-1] == '>'))
			{//GPSMV1 or GPSC30 
				if ((aprsBuf[y+3] == 'C') || (aprsBuf[y+3] == 'E'))
				{
					Aprs[Aprsi].SymbolType = '/';
					Aprs[Aprsi].Symbol = ((aprsBuf[y+4] - '0') * 10) + (aprsBuf[y+5] - '0') - 1;
				}
				else
				{
					for (z = 0; z < 95; z++)
					{
						if (*(WORD*)&aprsBuf[y+3] == *(WORD*)&APRSSymbols[z].PrimaryGPS)
						{
							Aprs[Aprsi].SymbolType = '/';
							Aprs[Aprsi].Symbol = z;
							break;
						}
						else if (*(WORD*)&aprsBuf[y+3] == *(WORD*)&APRSSymbols[z].SecondaryGPS)
						{
							if (((aprsBuf[y+5] >= 'A') && (aprsBuf[5] <= 'Z'))
							 || ((aprsBuf[y+5] >= '0') && (aprsBuf[5] <= '9')))
								Aprs[Aprsi].SymbolType = aprsBuf[y+5];
							else
								Aprs[Aprsi].SymbolType = '\\';
							Aprs[Aprsi].Symbol = z;
							break;
						}
					}
				}
				break;
			}
		}

		GPtype = aprsBuf[x+4];//$GPGGA, $GPRMC, or $GGLL
		if ((GPtype == 'G') || (GPtype == 'M'))//$GPGGA or $GPRMC
			x += 7;//to time
		else if (GPtype == 'L')
		{
			savex = x;
			for (y = 0; y < 5; y++)
			{
				while (aprsBuf[x] != ',')
					x++;
				x++;
			} 
		}
		Aprs[Aprsi].Time = (((aprsBuf[x] - '0') * 1000) + ((aprsBuf[x+1] - '0') * 100) + ((aprsBuf[x+2] - '0') * 10) + (aprsBuf[x+3] - '0'));
		if (GPtype == 'L')
			x = savex;
		x += 7;//to Lat
		if (GPtype == 'M')//$GPRMC
			x += 2;//past "A,"
		tempLat = Lat;
		tempLon = Lon;
		tempUTMZone = UTMZone;
		tempUTMN = UTMNorthing;
		tempUTME = UTMEasting;
		Lat = (double)(((aprsBuf[x] - '0') * 10) + (aprsBuf[x+1] - '0'));
		x += 2;//to minutes
		Lat += (double)atof((char*)&aprsBuf[x]) / 60.0;
		if ((Lat > 72.0) || (Lat < 17.5))
			goto gpsexit;
		for ( ; aprsBuf[x] != ','; x++)
			;
		x++;//to 'N' or 'S'
		if (aprsBuf[x] == 'S')
			goto gpsexit;
		x += 2;//to Lon
		Lon = (double)(((aprsBuf[x] - '0') * 100) + ((aprsBuf[x+1] - '0') * 10) + (aprsBuf[x+2] - '0'));
		x += 3;//to minutes
		Lon += (double)atof((char*)&aprsBuf[x]) / 60.0;
		for ( ; aprsBuf[x] != ','; x++)
			;
		x++;//to 'E' or 'W'
		if (aprsBuf[x] == 'W')
			Lon = -Lon;
		if ((Lon > -60.0) || (Lon < -168.0))
			goto gpsexit;
		z = 0;
		Aprs[Aprsi].DescOrWx[z++] = 'G';
		Aprs[Aprsi].DescOrWx[z++] = 'P';
		Aprs[Aprsi].DescOrWx[z++] = 'S';
		if (GPtype == 'M')
		{
			x += 2;//to speed
			for (Speed = 0; (aprsBuf[x] != '.') && (aprsBuf[x] != ','); x++)
			{
				Speed *= 10;
				Speed += (aprsBuf[x] - '0');
				d = Speed * 1.150779448;//to convert knots to miles/hour
				Speed = (int)d;
			}
			if (aprsBuf[x] == '.')
				while (aprsBuf[x] != ',')
					x++;
			x++;//to course
			for (Course = 0; (aprsBuf[x] != '.') && (aprsBuf[x] != ','); x++)
			{
				Course *= 10;
				Course += (aprsBuf[x] - '0');
			}
			if (Speed)
				z = PutSpeedCourse(z);
		}
		Aprs[Aprsi].DescOrWx[z] = 0;
		GetAPRSLL();
gpsexit:
		Lat = tempLat;
		Lon = tempLon;
		UTMZone = tempUTMZone;
		UTMNorthing = tempUTMN;
		UTMEasting = tempUTME;
	}

	/*
	Ultimeter:
	$ULTW 0000 0000 0208 015A ---- 0000 86A0 0001 ---- 015C 03DE 0000 0000
	 4    * 1. Wind Speed Peak over last 5 min. (0.1 kph)
	 8    * 2. Wind Direction of Wind Speed Peak (0-255)
	12    * 3. Current Outdoor Temp (0.1 deg F)
	16    * 4. Rain Long Term Total (0.01 in.)
	20    * 5. Current Barometer (0.1 mbar)
	24    * 6. Barometer Delta Value(0.1 mbar)
	28    * 7. Barometer Corr. Factor(LSW)
	32    * 8. Barometer Corr. Factor(MSW)
	36    * 9. Current Outdoor Humidity (0.1%)
	40    * 10. Date (day of year)
	44    * 11. Time (minute of day)
	48    * 12. Today's Rain Total (0.01 inches)*
	52    * 13. 5 Minute Wind Speed Average (0.1kph)* 
	*/
	else if (aprsBuf[x] == '$')//Peet Bros Ultimeter WX data
	{//positionless WX
		DWORD Raw;
		double raw;

		x++;
		for (y = 0; Addr[y] != 0; y++)
			Aprs[Aprsi].Call[y] = Addr[y];
		Aprs[Aprsi].Call[y] = 0;
		for (y = 0; y < Aprsi; y++)
		{//get Lat/Lon from previous station entry
			for (z = 0; Addr[z] != 0; z++)
				if (Aprs[y].Call[z] != Addr[z])
					break;
			if (Addr[z] == 0)
			{//if same callsign
				Aprs[Aprsi].UTMN = Aprs[y].UTMN;
				Aprs[Aprsi].UTME = Aprs[y].UTME;
				Aprs[Aprsi].UTMZ = Aprs[y].UTMZ;
				Aprs[Aprsi].SymbolType = Aprs[y].SymbolType;
				Aprs[Aprsi].Symbol = Aprs[y].Symbol;
				break;
			}
		}
		z = 0;
		Aprs[Aprsi].DescOrWx[z++] = 'W';
		Aprs[Aprsi].DescOrWx[z++] = 'X';
		Aprs[Aprsi].DescOrWx[z++] = ' ';
		Raw = (((aprsBuf[x+12] - '0') << 12) | ((aprsBuf[x+13] - '0') << 8) | ((aprsBuf[x+14] - '0') << 4) | (aprsBuf[x+15] - '0'));
		Raw /= 10;
		y = (Raw / 1000) + '0';
		if (y != '0')
			Aprs[Aprsi].DescOrWx[z++] = y;
		y = (((Raw % 1000) / 100) + '0');
		if (y != '0')
			Aprs[Aprsi].DescOrWx[z++] = y;
		Aprs[Aprsi].DescOrWx[z++] = (char)(((Raw % 100) / 10) + '0');
		Aprs[Aprsi].DescOrWx[z++] = (char)((Raw % 10) + '0');
		Aprs[Aprsi].DescOrWx[z++] = '\xB0';//degrees
		Aprs[Aprsi].DescOrWx[z++] = 'F';
		if ((aprsBuf[x+4] != '0') || (aprsBuf[x+5] != '0') || (aprsBuf[x+6] != '0') || (aprsBuf[x+7] != '0'))
		{//wind direction
			for (y = 0; wind[y] != 0; y++, z++)
				Aprs[Aprsi].DescOrWx[z] = wind[y];
			Raw = (((aprsBuf[x+8] - '0') << 12) + ((aprsBuf[x+9] - '0') << 8) + ((aprsBuf[x+10] - '0') << 4) + (aprsBuf[x+11] - '0'));
			Aprs[Aprsi].DescOrWx[z++] = (char)((Raw / 100) + '0');
			Aprs[Aprsi].DescOrWx[z++] = (char)(((Raw % 100) / 10) + '0');
			Aprs[Aprsi].DescOrWx[z++] = (char)((Raw % 10) + '0');
			for (y = x, w = 0; aprsBuf[y] != '\r'; y++, w++)
				;
			if (w == 56)
			{
				Aprs[Aprsi].DescOrWx[z++] = '/';
				raw = (double)(((aprsBuf[x+53] - '0') << 8) | ((aprsBuf[x+54] - '0') << 4) | (aprsBuf[x+55] - '0'));
				raw /= 16.09344;//1 mile = 1.609 344 kilometer
				Raw = (int)raw;
				y = ((Raw / 100) + '0');
				if (y != '0')
					Aprs[Aprsi].DescOrWx[z++] = y;
				y = (((Raw % 100) / 10) + '0');
				if (y != '0')
					Aprs[Aprsi].DescOrWx[z++] = y;
				Aprs[Aprsi].DescOrWx[z++] = (char)((Raw % 10) + '0');
			}
			Aprs[Aprsi].DescOrWx[z++] = 'g';
			raw = (double)(((aprsBuf[x+4] - '0') << 12) + ((aprsBuf[x+5] - '0') << 8) + ((aprsBuf[x+6] - '0') << 4) + (aprsBuf[x+7] - '0'));
			raw /= 16.09344;//1 mile = 1.609 344 kilometer
			Raw = (int)raw;
			y = (Raw / 1000) + '0';
			if (y != '0')
				Aprs[Aprsi].DescOrWx[z++] = y;
			y = (((Raw % 1000) / 100) + '0');
			if (y != '0')
				Aprs[Aprsi].DescOrWx[z++] = y;
			Aprs[Aprsi].DescOrWx[z++] = (char)(((Raw % 100) / 10) + '0');
			Aprs[Aprsi].DescOrWx[z++] = (char)((Raw % 10) + '0');
		}
		Aprs[Aprsi].DescOrWx[z++] = 0;
		Aprs[Aprsi].SymbolType = '/';
		Aprs[Aprsi].Symbol = 62;//WX
		if ((Aprsi < MAXAPRS) || (Aprsi == -1))
			Aprsi++;
		else
			SaveAPRSlog();
	}

	else if ((aprsBuf[x] == ':') || (aprsBuf[x] == '>') || (aprsBuf[x] == '<') || (aprsBuf[x] == '?') || (aprsBuf[x] == ')'))
	{//Message/Bulletin, Status, Station Capabilities, Query, Item)
		if (aprsimulate == FALSE)
			Aprs[Aprsi].Time = (st.wHour * 100) + st.wMinute;
		for (y = 0; Addr[y] != 0; y++)
			Aprs[Aprsi].Call[y] = Addr[y];
		Aprs[Aprsi].Call[y] = 0;
		for (z = 0; z < 11; z++)
			Aprs[Aprsi].DescOrWx[z] = NoDescript[z];//just in case
		Aprs[Aprsi].DescOrWx[z] = 0;

		if (aprsBuf[x] == ':')//Message/Bulletin
		{
			y = x;
			for (z = 0; Addr[z] != 0; msgPtr++, z++)
				Msg[msgPtr] = Addr[z];
			for ( ; (msgPtr < 10240) && (aprsBuf[y] != '\n'); msgPtr++, y++)
				Msg[msgPtr] = aprsBuf[y];
			Msg[msgPtr++] = '\n';
			Msg[msgPtr] = 0;
			if ((aprsBuf[x+1] == 'B') && (aprsBuf[x+2] == 'L') && (aprsBuf[x+3] == 'N'))
				goto itsabulletin;
			else if ((aprsBuf[x+1] == 'N') && (aprsBuf[x+2] == 'W') && (aprsBuf[x+3] == 'S') && (aprsBuf[x+4] == '-'))
				goto itsabulletin;
			for (y = x+1, z = 0; (aprsBuf[y] != ' ') && (aprsBuf[y] != ':'); y++, z++)
				if (aprsBuf[y] != MyCall[z])
					break;
			if (((aprsBuf[y] == ' ') || (aprsBuf[y] == ':')) && (MyCall[z] == 0))
			{//message to me
				for (z = 0; Msg[z] != 0; z++)
					if (Msg[z] == '{')
						break;
				if (Msg[z] != 0)
				{//send ack
					for (y = 7, w = 0; Addr[w] != 0; y++, w++)
						Ack[y] = Addr[w];
					if (w != 9)
						for ( ; w < 9; y++, w++)
							Ack[y] = ' ';
					Ack[y++] = ':';
					Ack[y++] = 'a';
					Ack[y++] = 'c';
					Ack[y++] = 'k';
					z++;//to message no.
					for ( ; (Msg[z] != '\r') && (Msg[z] != 0); y++, z++)
						Ack[y] = Msg[z];
					Ack[y] = 0;
					if (gettingreceived)
					{
						WriteFile(hAPRSComm, Ack, strlen(Ack), &dwBytesWritten, NULL);
						WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
						Sleep(500);
						WriteFile(hAPRSComm, BeaconEvery1, 14, &dwBytesWritten, NULL);
//						WriteFile(hAPRSComm, BEACON, strlen(BEACON), &dwBytesWritten, NULL);
						WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
						transmitted = TRUE;
					}
				}
itsabulletin:	if ((Message == FALSE) || (hwndMessageDlg == NULL))
					hwndMessageDlg = CreateDialog(hInst, "MESSAGE", hwnd, MessageProc);
				else//if dialog box has already been created
					SetDlgItemText(hwndMessageDlg, IDC_EDIT1, Msg);
			}
		}

		x++;
		for (z = 0; (z < 48) && (aprsBuf[x] != '\r'); x++, z++)
			Aprs[Aprsi].Status[z] = aprsBuf[x];
		Aprs[Aprsi].Status[z] = 0;
		if (Aprsi)
		{
			for (y = Aprsi-1; y != 0xFFFFFFFF; y--)
			{//get Lat/Lon for positionless entry
				for (z = 0; Addr[z] != 0; z++)
					if (Aprs[y].Call[z] != Addr[z])
						break;
				if ((Addr[z] == 0) && (Aprs[y].Call[z] == 0))
				{//same callsign
					Aprs[Aprsi].UTMN = Aprs[y].UTMN;
					Aprs[Aprsi].UTME = Aprs[y].UTME;
					Aprs[Aprsi].UTMZ = Aprs[y].UTMZ;
					Aprs[Aprsi].SymbolType = Aprs[y].SymbolType;
					Aprs[Aprsi].Symbol = Aprs[y].Symbol;
					if (Aprs[y].DescOrWx[0])
					{
						for (z = 0; Aprs[y].DescOrWx[z] != 0; z++)
							Aprs[Aprsi].DescOrWx[z] = Aprs[y].DescOrWx[z];
						Aprs[Aprsi].DescOrWx[z] = 0;
					}
					break;
				}
			}
		}
		if ((Aprsi < MAXAPRS) || (Aprsi == -1))
			Aprsi++;
		else
			SaveAPRSlog();
	}

	do
	{
		EnterCriticalSection(&cs); CSFlag = ClearStationsFlag; LeaveCriticalSection(&cs);
	} while (CSFlag);
	for (y = 0; y < stationPtr; )
	{
		for (z = 0; (Aprs[Aprsi-1].Call[z] != 0) && (y < 10240); y++, z++)
			if (Stations[y] != Aprs[Aprsi-1].Call[z])
				break;
		if ((Stations[y] == TAB) && (Aprs[Aprsi-1].Call[z] == 0))
		{//found station
			y++;
			Stations[y++] = (st.wHour/10) + '0';
			Stations[y++] = (st.wHour%10) + '0';
			y++;
			Stations[y++] = (st.wMinute/10) + '0';
			Stations[y++] = (st.wMinute%10) + '0';
			y++;
			Stations[y++] = (st.wSecond/10) + '0';
			Stations[y++] = (st.wSecond%10) + '0';
			break;
		}
		for ( ; Stations[y] != 0; y++)
			;
		y++;
	}
	if (y == stationPtr)
	{
		for (stationPtr = y, z = 0; Aprs[Aprsi-1].Call[z] != 0; stationPtr++, z++)
			Stations[stationPtr] = Aprs[Aprsi-1].Call[z];
		Stations[stationPtr++] = TAB;
		Stations[stationPtr++] = (st.wHour/10) + '0';
		Stations[stationPtr++] = (st.wHour%10) + '0';
		Stations[stationPtr++] = ':';
		Stations[stationPtr++] = (st.wMinute/10) + '0';
		Stations[stationPtr++] = (st.wMinute%10) + '0';
		Stations[stationPtr++] = ':';
		Stations[stationPtr++] = (st.wSecond/10) + '0';
		Stations[stationPtr++] = (st.wSecond%10) + '0';
		Stations[stationPtr++] = 'z';
		Stations[stationPtr++] = 0;
		NumOfStations++;
	}
	if (hwndStationsDlg)
		SendMessage(hwndStationsDlg, WM_COMMAND, IDC_RADIO1, 0);
	if (hwndStationInfoDlg)
	{
		for (z = 0; Call[z] != 0; z++)
			if (Aprs[Aprsi-1].Call[z] != Call[z])
				break;
		if ((Call[z] == 0) && (Aprs[Aprsi-1].Call[z] == 0))
		{
			StationInfo(x);
		}
	}
	if ((!aprsimulate) && (Aprs[Aprsi-1].UTMZ == UTMZone)
	 && (Aprs[Aprsi-1].UTME > ScreenLeft) && (Aprs[Aprsi-1].UTME < ScreenRight)
	 && (Aprs[Aprsi-1].UTMN < ScreenTop) && (Aprs[Aprsi-1].UTMN > ScreenBottom))
	{
		InvalidateRect(hwnd, &rect, FALSE);
		UpdateWindow(hwnd);
	}
}

UINT WINAPI aprsISthread2(void*)
{
//	static int x, y, PacketSize;

	if (wsaData.szSystemStatus[0] == 0)
		WSAStartup(0x0202, &wsaData);
	else
		dontcleanup = TRUE;
	if (INVALID_SOCKET == (s2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)))
	{
		sprintf(Error, "Bad Socket (error %ld)", 37608);
		MessageBox(hwnd, Error, ERROR, MB_OK);
		goto nosocket2;
	}
	if (NULL == (he = gethostbyname(Tier2Server)))
	{
		MessageBox(hwnd, "bad host", ERROR, MB_OK);
		goto nosocket2;
	}
	else
	{
		memcpy(&dest.sin_addr, he->h_addr_list[0], he->h_length);
		dest.sin_family = he->h_addrtype;
		dest.sin_port = htons(14580);// 10152 for concord.aprs.net
	}
	if (SOCKET_ERROR == connect(s2, (struct sockaddr*)&dest, sizeof(SOCKADDR)))
	{
		sprintf(Error, "Connect error %i", WSAGetLastError());
		MessageBox(hwnd, Error, ERROR, MB_OK);
	}
	else
	{
		PacketSize = recv(s2, SmallBuf2, 1024, 0);
		if ((PacketSize == 0) || (SOCKET_ERROR == PacketSize))
		{
			MessageBox(hwnd, "bad initial receive", ERROR, MB_OK);
			goto nosocket2;
		}
		if (FilterLen)
		{
			if (SOCKET_ERROR == send(s2, Filter, FilterLen, 0))
			{
				sprintf(Error, "Send error %i\n(error %i)", WSAGetLastError(), 37640);
				MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
			}
		}
		PacketSize = recv(s2, SmallBuf2, 1024, 0);
		if ((PacketSize == 0) || (SOCKET_ERROR == PacketSize))
		{
			sprintf(Error, "Receive error %i\n(error %i)", WSAGetLastError(), 37647);
			MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
		}
		else if (SOCKET_ERROR == send(s2, MyLoc, strlen(MyLoc), 0))
		{
			sprintf(Error, "Send error %i\n(error %i)", WSAGetLastError(), 37652);
			MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
		}
	}

nosocket2:;
	if (dontcleanup == FALSE)
		WSACleanup();
	CloseHandle((HANDLE)hAPRSThread2);
	hAPRSThread2 = 0;
	return 0;
}

UINT WINAPI aprsISthread(void*)
{
	static int xaprs, PacketSize;

	WSAStartup(0x0202, &wsaData);
	if (INVALID_SOCKET == (s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)))
	{
		sprintf(Error, "Bad socket (error %ld)", 37672);
		MessageBox(hwnd, Error, ERROR, MB_OK);
		goto nosocket;
	}
	if (fromctrli)
	{
		int x;
		DWORD secretIP;
		WORD secretPort;

		fromctrli = FALSE;
		for (x = 0; (SecretIP[x] != ':') && (SecretIP[x] != 0); x++)
			;
		SecretIP[x] = 0;
		secretIP = inet_addr(SecretIP);
		memcpy(&dest.sin_addr, (const void*)&secretIP, 4);
		if (SecretIP[x+1])
		{
			secretPort = 0;
			for (x++; SecretIP[x] != 0; x++)
			{
				secretPort *= 10;
				secretPort += (SecretIP[x] - '0');
			}
			dest.sin_port = htons(secretPort);
			dest.sin_family = AF_INET;
		}
	}
	else if (NULL == (he = gethostbyname(Tier2Server)))
	{
		MessageBox(hwnd, "bad host", ERROR, MB_OK);
		goto nosocket;
	}
	else
	{
		memcpy(&dest.sin_addr, he->h_addr_list[0], he->h_length);
		dest.sin_family = he->h_addrtype;
		dest.sin_port = htons(14580);// 10152 for concord.aprs.net
	}

	if (SOCKET_ERROR == connect(s, (struct sockaddr*)&dest, sizeof(SOCKADDR)))
	{
		sprintf(Error, "Connect error %i", WSAGetLastError());
		MessageBox(hwnd, Error, ERROR, MB_OK);
	}
	else
	{
		PacketSize = recv(s, SmallBuf, SMALLBUFSIZE, 0);
		if ((PacketSize == 0) || (SOCKET_ERROR == PacketSize))
		{
			MessageBox(hwnd, "bad initial receive", ERROR, MB_OK);
			goto nosocket;
		}
		if (FilterLen)
		{
			if (SOCKET_ERROR == send(s, Filter, FilterLen, 0))
			{
				sprintf(Error, "Send error %i\n(error %i)", WSAGetLastError(),37729);
				MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
			}
		}
		xaprs = 0;
		while (WaitForSingleObject(hAPRSISEvent, 0) != WAIT_OBJECT_0)
		{
			PacketSize = recv(s, SmallBuf, SMALLBUFSIZE, 0);
			if (PacketSize == 0)
				break;
			if (SOCKET_ERROR == PacketSize)
			{
				MessageBox(hwnd, "bad data receive", ERROR, MB_OK);
				break;
			}
			if (xaprs >= (MEGABYTE+PacketSize))
			{
				*(int*)&aprsBuf[0] = *(int*)&aprsBuf[xaprs];
				xaprs = 4;
				aprsISend = xaprs;//for isaprslinebeg
			}
//			for (yaprs = 0; yaprs < PacketSize; xaprs++, yaprs++)
//				aprsBuf[xaprs] = SmallBuf[yaprs];
			_asm pushad
			_asm pushfd
			_asm mov eax, PacketSize
			_asm mov ecx, 4
			_asm sub edx, edx
			_asm div ecx  //get remainder in edx
			_asm mov eax, xaprs
			_asm lea edi, aprsBuf[eax]
			_asm lea esi, SmallBuf
			_asm mov ecx, PacketSize
			_asm sub ecx, 4//for remainder stosb
			_asm jc asm6  //if ecx was less than 4
			_asm add edx, 4
			_asm shr ecx, 2//div 4
			_asm or ecx,ecx
			_asm jz asm6
asm4:		_asm movsd    //the main loop
			_asm dec ecx
			_asm jnz asm4
			_asm or edx,edx
			_asm jz asm6
asm5:			_asm movsb
			_asm dec edx
			_asm jnz asm5
asm6:			_asm mov eax, xaprs
			_asm add eax, PacketSize
			_asm mov xaprs, eax
			_asm popfd
			_asm popad

			PostMessage(hwnd, WM_APRS_IS_COMM, 0, (LPARAM) xaprs);
		}
		send(s, Quit, strlen(Quit), 0);
		PacketSize = recv(s, SmallBuf, SMALLBUFSIZE, 0);
	}
nosocket:;
	WSACleanup();
	if ((!gettingsaved) && (!gettingreceived))
		aprsi = Aprsi = aprs = 0;//FALSE
	InvalidateRect(hwnd, &rect, FALSE);
	CloseHandle((HANDLE)hAPRSThread);
	hAPRSThread = 0;
	return 0;
}


int CALLBACK SymbolsProc(HWND hwndListDlg, UINT message, WPARAM wParam, LPARAM lParam)
{//uses owner-drawn list box APIs
	int x, y;
	static HWND hwndList, hwndOverlay;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndList = GetDlgItem(hwndListDlg, IDC_LIST1);
		hwndOverlay = GetDlgItem(hwndListDlg, IDC_EDIT1);
		SendMessage(hwndOverlay, EM_SETREADONLY, 1, 0);
		for (x = 0; x < 94; x++)
			SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)APRSSymbols[x].Primary);
		for (x = 0; x < 94; x++)
			SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)APRSSymbols[x].Secondary);
		SendMessage(hwndList, LB_SETCURSEL, (WPARAM)symbolindex, 0);
		if ((symbolindex == 96) || (symbolindex == 99) || (symbolindex == 109) || (symbolindex == 123) || (symbolindex == 126) || (symbolindex == 148) || (symbolindex == 155) || (symbolindex == 156) || (symbolindex == 158) || (symbolindex == 160) || (symbolindex == 166) || (symbolindex == 171) || (symbolindex == 176) || (symbolindex == 178) || (symbolindex == 179) || (symbolindex == 183))
			SendMessage(hwndOverlay, EM_SETREADONLY, 0, 0);
		else
			SendMessage(hwndOverlay, EM_SETREADONLY, 1, 0);
		if (fromindex == HOMEINDEX)
		{
			if ((HomeSymbol[0] != '/') && (HomeSymbol[0] != '\\'))
			{
				Overlay[0] = HomeSymbol[0];
				SetWindowText(hwndOverlay, Overlay);
			}
		}
		else if (fromindex == GPSINDEX)
		{
			if ((GPSSymbol[0] != '/') && (GPSSymbol[0] != '\\'))
			{
				Overlay[0] = GPSSymbol[0];
				SetWindowText(hwndOverlay, Overlay);
			}
		}
		SetFocus(hwndList);
		break;

	case WM_MEASUREITEM:
		lpmis = (LPMEASUREITEMSTRUCT)lParam;
		lpmis->itemHeight = 20;
		return TRUE;

	case WM_DRAWITEM:
		lpdis = (LPDRAWITEMSTRUCT)lParam;
		switch (lpdis->itemAction)
		{
		case ODA_SELECT:
		case ODA_DRAWENTIRE:
			rcBitmap.left = lpdis->rcItem.left; 
			rcBitmap.top = lpdis->rcItem.top; 
			rcBitmap.right = lpdis->rcItem.right-lpdis->rcItem.left; 
			rcBitmap.bottom = lpdis->rcItem.top + YBITMAP;
			if (lpdis->itemState & ODS_SELECTED)
			{
				FillRect(lpdis->hDC, &rcBitmap, (HBRUSH)CreateSolidBrush(0xC56A31));//Windows highlight color
				SetBkMode(lpdis->hDC, TRANSPARENT);
				SetTextColor(lpdis->hDC, 0xFFFFFF);
			}
			else
			{
				FillRect(lpdis->hDC, &rcBitmap, (HBRUSH)CreateSolidBrush(0xFFFFFF));
				SetBkColor(lpdis->hDC, 0xFFFFFF);
				SetTextColor(lpdis->hDC, 0);
			}
			GetTextMetrics(lpdis->hDC, &tm);
			y = (rcBitmap.bottom + rcBitmap.top - tm.tmHeight) / 2;
			SendMessage(lpdis->hwndItem, LB_GETTEXT, lpdis->itemID, (LPARAM) tchBuffer);
			TextOut(lpdis->hDC, XBITMAP+6, y, tchBuffer, strlen(tchBuffer));
			y = lpdis->itemID;
			if (y >= 94)
				y -= 94;
			xIndex = y % 16;
			yIndex = y / 16;
			if (lpdis->itemID < 94)
				TransparentBlt(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, 20, 20, hdcSymMem1, (21*xIndex)+1, (21*yIndex)+1, 20, 20, 0xFFFFFF);
			else
				TransparentBlt(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, 20, 20, hdcSymMem2, (21*xIndex)+1, (21*yIndex)+1, 20, 20, 0xFFFFFF);
			break;	
		case ODA_FOCUS:
			break;
		}
		return TRUE;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_DBLCLK)
				SendMessage(hwndListDlg, WM_COMMAND, (WPARAM)IDOK, 0);
			else if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				Overlay[0] = 0;
				SetWindowText(hwndOverlay, Overlay);
				symbolindex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
				SendMessage(hwndList, LB_SETCURSEL, symbolindex, 0);
				if ((symbolindex == 96) || (symbolindex == 99) || (symbolindex == 109) || (symbolindex == 123) || (symbolindex == 126) || (symbolindex == 148) || (symbolindex == 155) || (symbolindex == 156) || (symbolindex == 158) || (symbolindex == 160) || (symbolindex == 166) || (symbolindex == 171) || (symbolindex == 176) || (symbolindex == 178) || (symbolindex == 179) || (symbolindex == 183))
				{
					SendMessage(hwndOverlay, EM_SETREADONLY, 0, 0);
					if (((homesymbolindex+94) == symbolindex) && (HomeSymbol[0] != '/') && (HomeSymbol[0] != '\\'))
					{
						Overlay[0] = HomeSymbol[0];
						SetWindowText(hwndOverlay, Overlay);
					}
				}
				else
					SendMessage(hwndOverlay, EM_SETREADONLY, 1, 0);
			}
			break;

		case IDC_EDIT1:
			GetWindowText(hwndOverlay, Overlay, 2);
			break;

		case IDOK:
			SendMessage(hwndList, LB_GETTEXT, symbolindex, (LPARAM)Symbol);
			EndDialog (hwndListDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndListDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}


int CALLBACK APRSProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndEdit1, hwndEdit2, hwndEdit3, hwndEdit4, hwndEdit5, hwndCheck1;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit2 = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetWindowText(hwndEdit2, MyCall);
		hwndEdit1 = GetDlgItem(hwndDlg, IDC_EDIT2);
		SetWindowText(hwndEdit1, HomeLatLon);
		hwndEdit3 = GetDlgItem(hwndDlg, IDC_EDIT3);
		SetWindowText(hwndEdit3, Destination);
		hwndEdit4 = GetDlgItem(hwndDlg, IDC_EDIT4);
		SetWindowText(hwndEdit4, Comment);
		hwndEdit5 = GetDlgItem(hwndDlg, IDC_EDIT5);
		SetWindowText(hwndEdit5, Beacon);
		if (transmitto == TRANSMITHOME)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO1);
		else if (transmitto == TRANSMITGPS)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO2);
		else//if (transmitto == TRANSMITNONE)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO3);
		hwndCheck1 = GetDlgItem(hwndDlg, IDC_CHECK1);
		if (smartbeaconing)
			CheckDlgButton(hwndDlg, IDC_CHECK1, BST_CHECKED);
		if (compressit)
			CheckDlgButton(hwndDlg, IDC_CHECK2, BST_CHECKED);
		SetFocus(hwndEdit5);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_EDIT1://KI6NLA
			GetWindowText(hwndEdit2, MyCall, 10);
			break;

		case IDC_EDIT2://3724.44N/12206.98W
			SetFocus(hwndDlg);
			break;

		case IDC_CHECK1:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK1))
				smartbeaconing = TRUE;
			else
				smartbeaconing = FALSE;
			break;

		case IDC_CHECK2:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CHECK2))
				compressit = TRUE;
			else
				compressit = FALSE;
			break;

		case IDC_BUTTON1:
			if (DialogBox(hInst, "GOTO", hwnd, GotoProc) != EXIT)
			{
				LatMin = modf(Lat, &Lat) * 60.0;
				LonMin = modf(-Lon, &Lon) * 60.0;
				sprintf(HomeLatLon, "%2.0f%5.2fN/%3.0f%5.2fW", Lat, LatMin, Lon, LonMin);//3724.44N/12206.98W
				for (x = 0; HomeLatLon[x] != 0; x++)
					if (HomeLatLon[x] == ' ')
						HomeLatLon[x] = '0';
				if ((homesymbolindex != -1) && (HomeSymbol[0]))
					HomeLatLon[8] = HomeSymbol[0];
				SetWindowText(hwndEdit1, HomeLatLon);
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
			}
			SetFocus(hwndDlg);
			break;			

		case IDC_BUTTON2://home symbol
			if (homesymbolindex != -1)
			{
				symbolindex = homesymbolindex;
				if (HomeSymbol[0] != '/')
					symbolindex += 94;
				Overlay[0] = HomeSymbol[0];
			}
			fromindex = HOMEINDEX;
			if (DialogBox(hInst, "SYMBOLS", hwnd, SymbolsProc))
			{
				if (symbolindex < 94)
					HomeSymbol[0] = '/';
				else if (Overlay[0] == 0)
					HomeSymbol[0] = '\\';
				else
					HomeSymbol[0] = Overlay[0];
				strcpy(&HomeSymbol[1], Symbol);
				homesymbolindex = symbolindex;
				if (homesymbolindex >= 94)
					homesymbolindex -= 94; 
				HomeLatLon[8] = HomeSymbol[0];
			}
			SetFocus(hwndDlg);
			break;

		case IDC_BUTTON3://gps symbol
			if (gpssymbolindex != -1)
			{
				symbolindex = gpssymbolindex;
				if (GPSSymbol[0] != '/')
					symbolindex += 94;
				Overlay[0] = GPSSymbol[0];
			}
			fromindex = GPSINDEX;
			if (DialogBox(hInst, "SYMBOLS", hwnd, SymbolsProc))
			{
				if (symbolindex < 94)
					GPSSymbol[0] = '/';
				else if (Overlay[0] == 0)
					GPSSymbol[0] = '\\';
				else
					GPSSymbol[0] = Overlay[0];
				strcpy(&GPSSymbol[1], Symbol);
				gpssymbolindex = symbolindex;
				if (gpssymbolindex >= 94)
					gpssymbolindex -= 94;
			}
			SetFocus(hwndDlg);
			break;

		case IDC_BUTTON4:
			DialogBox(hInst, "SMARTBEACONING", hwnd, SmartBeaconingProc);
			testingsmartbeaconing = FALSE;
			pos = 0;
			posflag = TRUE;
			InvalidateRect(hwnd, &rect, FALSE);//clear position data
			break;

		case IDC_RADIO1:
			transmitto = TRANSMITHOME;
			break;
		case IDC_RADIO2:
			transmitto = TRANSMITGPS;
			break;
		case IDC_RADIO3:
			transmitto = TRANSMITNONE;
			break;

		case IDC_EDIT3://APZUSA VIA WIDE2-1
			GetWindowText(hwndEdit3, Destination, 32);
			break;

		case IDC_EDIT4://USAPhotoMaps
			GetWindowText(hwndEdit4, Comment, 24);
			break;

		case IDC_EDIT5://BEACON EVERY 180
			GetWindowText(hwndEdit5, Beacon, 12);
			break;

		case IDOK:
			if (transmitto == TRANSMITHOME)
			{
				if (MyCall[0] == 0)
				{
					SetFocus(hwndEdit2);
					break;
				}
				if (HomeLatLon[0] == 0)
				{
					SendMessage(hwndDlg, WM_COMMAND, IDC_BUTTON1, 0);
					break;
				}
				if (HomeSymbol[0] == 0)
				{
					SendMessage(hwndDlg, WM_COMMAND, IDC_BUTTON2, 0);
					break;
				}
				if (Destination[0] == 0)
				{
					SetFocus(hwndEdit3);
					break;
				}
				if (Beacon[0] == 0)
				{
					SetFocus(hwndEdit5);
					break;
				}
			}
			if (transmitto == TRANSMITGPS)
			{
				if (MyCall[0] == 0)
				{
					SetFocus(hwndEdit2);
					break;
				}
				if (GPSSymbol[0] == 0)
				{
					SendMessage(hwndDlg, WM_COMMAND, IDC_BUTTON3, 0);
					break;
				}
				if (Destination[0] == 0)
				{
					SetFocus(hwndEdit3);
					break;
				}
			}
			FillMYCALLUNPROTOBTEXTKISS();

			if (inaprs)
			{
				SetDlgItemText(hwndAPRSDlg, IDC_BUTTON1, MYCALL);
				SetDlgItemText(hwndAPRSDlg, IDC_BUTTON2, UNPROTO);
				SetDlgItemText(hwndAPRSDlg, IDC_BUTTON3, BTEXT);
				SetDlgItemText(hwndAPRSDlg, IDC_BUTTON5, BEACON);
			}
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK APRSEditProc(HWND hwndAPRSDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, dlgWidth, dlgHeight, EditHeight;
	RECT dlgRect;
	static HWND hwndEdit2;

	switch (message)
	{
	case WM_INITDIALOG:
		MoveWindow(hwndAPRSDlg, rect.right-800, TitleAndMenu, 800, rect.bottom, TRUE);
		GetWindowRect(hwndAPRSDlg, &dlgRect);
		dlgWidth = dlgRect.right-dlgRect.left;
		dlgHeight = dlgRect.bottom-dlgRect.top;
		EditHeight = dlgHeight-TitleAndMenu-70;

		hwndComm = GetDlgItem(hwndAPRSDlg, IDC_EDIT1);
		x = MoveWindow(hwndComm, 0, 27, dlgWidth-(Frame*2), EditHeight, TRUE);
		MaxText = SendMessage(hwndComm, EM_GETLIMITTEXT, 0, 0);
		pCommProc = (WNDPROC)SetWindowLong(hwndComm, GWL_WNDPROC, (LONG)CommProc);
		SetFocus(hwndComm);
		if (aprsi > MaxText)
			x = aprsi - (MaxText/2);
		else
			x = 0;
		for ( ; x < aprsi; x++)
			if (aprsBuf[x] != '\r')
				SendMessage(hwndComm, WM_CHAR, aprsBuf[x], 0);
		x = SendMessage(hwndComm, EM_GETLINECOUNT, 0, 0);
		SendMessage(hwndComm, EM_LINESCROLL, 0, x);

		hwndMyCall = GetDlgItem(hwndAPRSDlg, IDC_BUTTON1);
		MoveWindow(hwndMyCall, 2, 2, 130, 23, TRUE);
		SetWindowText(hwndMyCall, MYCALL);
		hwndDestination = GetDlgItem(hwndAPRSDlg, IDC_BUTTON2);
		MoveWindow(hwndDestination, 132, 2, 300, 23, TRUE);
		SetWindowText(hwndDestination, UNPROTO);
		hwndBtext = GetDlgItem(hwndAPRSDlg, IDC_BUTTON3);
		MoveWindow(hwndBtext, 432, 2, 358, 23, TRUE);
		SetWindowText(hwndBtext, BTEXT);
		hwndCtrlC = GetDlgItem(hwndAPRSDlg, IDC_BUTTON4);
		MoveWindow(hwndCtrlC, 10, 29+EditHeight, 50, 23, TRUE);
		hwndBeacon = GetDlgItem(hwndAPRSDlg, IDC_BUTTON5);
		MoveWindow(hwndBeacon, 70, 29+EditHeight, 150, 23, TRUE);
		SetWindowText(hwndBeacon, BEACON);
		hwndEdit2 = GetDlgItem(hwndAPRSDlg, IDC_EDIT2);
		MoveWindow(hwndEdit2, 230, 29+EditHeight, 260, 23, TRUE);
		pEdit2Proc = (WNDPROC)SetWindowLong(hwndEdit2, GWL_WNDPROC, (LONG)Edit2Proc);
		hwndStartKISS = GetDlgItem(hwndAPRSDlg, IDC_BUTTON7);
		MoveWindow(hwndStartKISS, 500, 29+EditHeight, 80, 23, TRUE);
		hwndSend = GetDlgItem(hwndAPRSDlg, IDC_BUTTON6);
		MoveWindow(hwndSend, 590, 29+EditHeight, 100, 23, TRUE);
		hwndStopKISS = GetDlgItem(hwndAPRSDlg, IDC_BUTTON8);
		MoveWindow(hwndStopKISS, 700, 29+EditHeight, 80, 23, TRUE);
		hwndMessage = GetDlgItem(hwndAPRSDlg, IDC_BUTTON9);
		MoveWindow(hwndMessage, 10, 29+EditHeight+30, 110, 23, TRUE);
		hwndObject = GetDlgItem(hwndAPRSDlg, IDC_BUTTON10);
		MoveWindow(hwndObject, 130, 29+EditHeight+30, 90, 23, TRUE);
		hwndTranslate = GetDlgItem(hwndAPRSDlg, IDC_CHECK1);
		MoveWindow(hwndTranslate, 650, 29+EditHeight+30, 130, 23, TRUE);
		if (kiss)
			CheckDlgButton(hwndAPRSDlg, IDC_CHECK1, BST_CHECKED);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_BUTTON1:
			WriteFile(hAPRSComm, MYCALL, lstrlen(MYCALL), &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			break;
		case IDC_BUTTON2:
			WriteFile(hAPRSComm, UNPROTO, lstrlen(UNPROTO), &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			break;
		case IDC_BUTTON3:
			WriteFile(hAPRSComm, BTEXT, lstrlen(BTEXT), &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			break;
		case IDC_BUTTON4:
			WriteFile(hAPRSComm, "\3", 1, &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			break;
		case IDC_BUTTON5:
			WriteFile(hAPRSComm, BEACON, lstrlen(BEACON), &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			break;
		case IDC_BUTTON6:
			if (kiss)
			{
				GetKiss();
				WriteFile(hAPRSComm, Kiss, KissLen, &dwBytesWritten, NULL);
				WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			}
			break;
		case IDC_BUTTON7:
			WriteFile(hAPRSComm, "KISS ON", 7, &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
//			CheckMenuItem(hMenu, ID_APRS_TRANSLATEKISSDATA, MF_CHECKED);
			CheckDlgButton(hwndAPRSDlg, IDC_CHECK1, BST_CHECKED);
			kiss = TRUE;
			SetFocus(hwndEdit2);
			break;
		case IDC_BUTTON8:
//			CheckMenuItem(hMenu, ID_APRS_TRANSLATEKISSDATA, MF_UNCHECKED);
			WriteFile(hAPRSComm, "\xC0\xFF\xC0", 3, &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			CheckDlgButton(hwndAPRSDlg, IDC_CHECK1, BST_UNCHECKED);
			kiss = FALSE;
			break;

		case IDC_BUTTON9:
			if (goodmessage)
			{
				for (x = 7, y = 0; (y < 9) && (MsgTo[y] != 0); x++, y++)
					MESSAGE[x] = MsgTo[y];
				if (y != 9)
					for ( ; y < 9; x++, y++)
						MESSAGE[x] = ' ';
				MESSAGE[x++] = ':';
				for (y = 0; SendMsg[y] != 0; x++, y++)
					MESSAGE[x] = SendMsg[y];
				MESSAGE[x] = 0;
				WriteFile(hAPRSComm, MESSAGE, strlen(MESSAGE), &dwBytesWritten, NULL);
				WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
				Sleep(500);
				if (kiss == FALSE)
				{
					Sleep(500);
					WriteFile(hAPRSComm, BeaconEvery1, 14, &dwBytesWritten, NULL);
//					WriteFile(hAPRSComm, BEACON, strlen(BEACON), &dwBytesWritten, NULL);
					transmitted = TRUE;
				}
				else
				{
					frommessage = TRUE;
					GetKiss();
					frommessage = FALSE;
					WriteFile(hAPRSComm, Kiss, KissLen, &dwBytesWritten, NULL);
				}
				WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			}
			break;

		case IDC_BUTTON10:
			if (objectPtr == 0)
				LoadObjects();
			sendit = TRUE;
			if (DialogBox(hInst, "EDITOBJECTS", hwndAPRSDlg, EditObjectProc))
			{
				for (x = 7, y = 0; Objects[objectindex].Name[y] != 0; x++, y++)
					OBJECT[x] = Objects[objectindex].Name[y];
				if (y != 9)
					for ( ; y < 9; x++, y++)
						OBJECT[x] = ' ';
				if (itslive)
					OBJECT[x++] = '*';
				else
					OBJECT[x++] = '_';
				if (Objects[objectindex].Time[0])
					for (y = 0; Objects[objectindex].Time[y] != 0; x++, y++)
						OBJECT[x] = Objects[objectindex].Time[y];
				else
				{
					for (y = 0; y < 6; x++, y++)
						OBJECT[x] = '1';
					OBJECT[x++] = 'z';
				}
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
				UTMNorthing = Objects[objectindex].UTMN;
				UTMEasting = Objects[objectindex].UTME;
				UTMZone = Objects[objectindex].UTMZ;
				UTMtoLatLon();
				symbol = Objects[objectindex].Symbol;
				if (symbol >= 94)
					symbol -= 94;
				if (compressed == FALSE)
				{
					LatMin = modf(Lat, &Lat) * 60.0;
					LonMin = modf(-Lon, &Lon) * 60.0;
y = sprintf(&OBJECT[x], "%2.0f%5.2fN%c%3.0f%5.2fW%c", Lat, LatMin, Objects[objectindex].SymbolType, Lon, LonMin, APRSSymbols[symbol].symbol);//3724.44N/12206.98W
					for (x = 20; OBJECT[x] != 0; x++)//because sprintf puts space in Lat or Lon
						if (OBJECT[x] == ' ')
							OBJECT[x] = '0';
					x += y;
				}
				else//if (compressed == TRUE)
				{
					Compressed[0] = Objects[objectindex].SymbolType;

					y = (int)(380926 * (90.0 - Lat));
					Compressed[1] = (BYTE)((y / 753571) + 33);
					y %= 753571;//91^3
					Compressed[2] = (BYTE)((y / 8281) + 33);
					y %= 8281;//91^2
					Compressed[3] = (BYTE)((y / 91) + 33);
					y %= 91;
					Compressed[4] = (BYTE)(y + 33);

					y = (int)(190463 * (180.0 + Lon));
					Compressed[5] = (BYTE)((y / 753571) + 33);
					y %= 753571;
					Compressed[6] = (BYTE)((y / 8281) + 33);
					y %= 8281;
					Compressed[7] = (BYTE)((y / 91) + 33);
					y %= 91;
					Compressed[8] = (BYTE)(y + 33);

					Compressed[9] = APRSSymbols[symbol].symbol;
					Compressed[10] = ' ';//no speed
					Compressed[11] = ' ';//no course
					Compressed[12] = ' ';//compressed flag
//					Compressed[13] = 0;
					for (y = 0; y < 13; x++, y++)
						OBJECT[x] = Compressed[y];
					OBJECT[x] = 0;
				}
				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;
				for (y = 0; Objects[objectindex].Comment[y] != 0; x++, y++)
					OBJECT[x] = Objects[objectindex].Comment[y];
				OBJECT[x] = 0;
				WriteFile(hAPRSComm, OBJECT, strlen(OBJECT), &dwBytesWritten, NULL);
				WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
				Sleep(500);
				if (kiss == FALSE)
				{
					Sleep(500);
					WriteFile(hAPRSComm, BeaconEvery1, 14, &dwBytesWritten, NULL);
//					WriteFile(hAPRSComm, BEACON, strlen(BEACON), &dwBytesWritten, NULL);
					transmitted = TRUE;
				}
				else
				{
					fromobject = TRUE;
					GetKiss();
					fromobject = FALSE;
					WriteFile(hAPRSComm, Kiss, KissLen, &dwBytesWritten, NULL);
				}
				WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			}
			break;

		case IDC_CHECK1:
			if (kiss == FALSE)
				kiss = TRUE;
			else
				kiss = FALSE;
			break;

		case IDCANCEL:
			DestroyWindow(hwndComm);
			hwndComm = NULL;
			EndDialog (hwndAPRSDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

DWORD AddtoUSAPMini(char* Ptr)
{
	for (z = 0; Ptr[z] != 0; z++)
		;
	x++;//past '='
	for (y = x; (y < (int)fileSize) && (pUSAPMbufIn[y] != '\r'); y++)
		;
	if ((y-x) > z)//new entry is smaller than old entry
		for (w = x+z, v = y; w < (int)fileSize; w++, v++)
			pUSAPMbufIn[w] = pUSAPMbufIn[v];
	fileSize += (z - (y-x));
	if ((y-x) < z)
		for (w = fileSize, v = fileSize - (z-(y-x)); v >= y; w--, v--)
			pUSAPMbufIn[w] = pUSAPMbufIn[v];
	for (z = 0;Ptr[z] != 0; x++, z++)
		pUSAPMbufIn[x] = Ptr[z];
	return fileSize;
}

void GetKiss(void)
{//APZUSA0KI6NLA0WIDE2 1
	x = 0;
	Kiss[x++] = '\xC0';
	Kiss[x++] = 0;
	for (z = 1; z < 7; x++, z++)
		Kiss[x] = FirstDest[z] << 1;//APZUSA
	Kiss[x++] = '0' << 1;
	for (z = 0; (MyCall[z] != 0) && (MyCall[z] != '-') && (x < 15); x++, z++)
		Kiss[x] = MyCall[z] << 1;
	if (MyCall[z] == '-')
	{
		if ((MyCall[z+1] >= '1') && (MyCall[z+1] <= '9') && (MyCall[z+2] >= '1') && (MyCall[z+2] <= '9'))
		{
			int number = ((MyCall[z+1] - '0') * 10) + (MyCall[z+2] - '0');
			Kiss[15] = (0x70 + number) << 1;
		}
		else if ((MyCall[z+1] >= '1') && (MyCall[z+1] <= '9'))
			Kiss[15] = MyCall[z+1] << 1;
	}
	else
		Kiss[15] = '0' << 1;
	for ( ; x < 15; x++)
		Kiss[x] = ' ' << 1;

	DestBegin = 16;
	DestEnd = 22;
	z = 0;
dest:
	for (x = DestBegin; (Destination[z] != 0) && (Destination[z] != '-') && (Destination[z] != ','); x++, z++)
		Kiss[x] = Destination[z] << 1;
	if (Destination[z] == '-')
	{
		if ((Destination[z+1] >= '1') && (Destination[z+1] <= '9') && (Destination[z+2] >= '1') && (Destination[z+2] <= '9'))
		{
			int number = ((Destination[z+1] - '0') * 10) + (Destination[z+2] - '0');
			Kiss[DestEnd] = (0x70 + number) << 1;
			z += 1;
		}
		else if ((Destination[z+1] >= '1') && (Destination[z+1] <= '9'))
			Kiss[DestEnd] = Destination[z+1] << 1;
		z += 2;
	}
	else
		Kiss[DestEnd] = '0' << 1;
	for ( ; x < DestEnd; x++)
		Kiss[x] = ' ' << 1; 
	if (Destination[z] == ',')
	{
		DestBegin += 7;
		DestEnd += 7;
		z++;
		goto dest;
	}

	Kiss[x++] += 1;
	Kiss[x++] = 3;
	Kiss[x++] = '\xF0';
	if (fromobject)
		for (z = 6; OBJECT[z] != 0; x++, z++)
			Kiss[x] = OBJECT[z];
	else if (frommessage)
		for (z = 6; MESSAGE[z] != 0; x++, z++)
			Kiss[x] = MESSAGE[z];
	else
		for (z = 6; BTEXT[z] != 0; x++, z++)
			Kiss[x] = BTEXT[z];
	Kiss[x++] = '\xC0';
	KissLen = x;
}

void FillMYCALLUNPROTOBTEXTKISS(void)
{
	if (MyCall[0])
	{
		MYCALL[6] = ' ';
		for (x = 7, y = 0; MyCall[y] != 0; x++, y++)
			MYCALL[x] = MyCall[y];
		MYCALL[x] = 0;
	}
	if (Destination[0])
	{
		for (x = 7, y = 0; FirstDest[y] != 0; x++, y++)
			UNPROTO[x] = FirstDest[y];
		for (y = 0; Destination[y] != 0; x++, y++)
			UNPROTO[x] = Destination[y];
		UNPROTO[x] = 0;
	}
	if (HomeLatLon[0])
	{
		BTEXT[5] = ' ';
		BTEXT[6] = '=';
		if (compressit == FALSE)
		{
			for (x = 7, y = 0; HomeLatLon[y] != 0; x++, y++)
				BTEXT[x] = HomeLatLon[y];
			BTEXT[x++] = APRSSymbols[homesymbolindex].symbol;
			for (y = 0; Comment[y] != 0; x++, y++)
				BTEXT[x] = Comment[y];
		}
		else//if (compressit)
		{//3724.44N/12206.98W
			LatMin = atof(&HomeLatLon[2]);
			LonMin = atof(&HomeLatLon[12]);
			tempLat = ((HomeLatLon[0] - '0') * 10) + (HomeLatLon[1] - '0') + (LatMin/60.0);
			tempLon = ((HomeLatLon[9] - '0') * 100) + ((HomeLatLon[10] - '0') * 10) + (HomeLatLon[11] - '0') + (LonMin/60.0);
		x = 7;
		BTEXT[x++] = HomeSymbol[0];//symbol type

		y = (int)(380926.0 * (90.0 - tempLat));
		BTEXT[x++] = (BYTE)((y / 753571) + 33);
		y %= 753571;//91^3
		BTEXT[x++] = (BYTE)((y / 8281) + 33);
		y %= 8281;//91^2
		BTEXT[x++] = (BYTE)((y / 91) + 33);
		y %= 91;
		BTEXT[x++] = (BYTE)(y + 33);

		y = (int)(190463.0 * (180.0 - tempLon));
		BTEXT[x++] = (BYTE)((y / 753571) + 33);
		y %= 753571;
		BTEXT[x++] = (BYTE)((y / 8281) + 33);
		y %= 8281;
		BTEXT[x++] = (BYTE)((y / 91) + 33);
		y %= 91;
		BTEXT[x++] = (BYTE)(y + 33);

		BTEXT[x++] = APRSSymbols[homesymbolindex].symbol;
		BTEXT[x++] = ' ';//no speed
		BTEXT[x++] = ' ';//no course
		BTEXT[x++] = ' ';//compressed flag
		}
		BTEXT[x] = 0;
	}
	z = 13;
	if (transmitto == TRANSMITNONE)
		BEACON[z++] = '0';
	else if ((transmitto != TRANSMITNONE) && (Beacon[0]))
		for (x = 0, z = 13; Beacon[x] != 0; x++, z++)
			BEACON[z] = Beacon[x];
	BEACON[z] = 0;
	if (kiss)
		GetKiss();
}

void ConvertoGPSLatLon(void)
{
	tempLat = Lat;
	tempLon = Lon;
	tempUTMZone = UTMZone;
	tempUTMN = UTMNorthing;
	tempUTME = UTMEasting;
	UTMZone = Position[pos].UTMZ;
	UTMEasting = Position[pos].UTME;
	UTMNorthing = Position[pos].UTMN;
	UTMtoLatLon();
	Lon = -Lon;
	LatMin = modf(Lat, &Lat1) * 60.0;
	LonMin = modf(Lon, &Lon1) * 60.0;
	sprintf(GPSLatLon, "%2.0f%5.2fN/%3.0f%5.2fW", Lat1, LatMin, Lon1, LonMin);//3724.44N/12206.98W
	for (x = 0; GPSLatLon[x] != 0; x++)
		if (GPSLatLon[x] == ' ')
			GPSLatLon[x] = '0';
	BTEXT[5] = ' ';
	BTEXT[6] = '=';
	if (compressit == FALSE)
	{
		for (x = 7, y = 0; GPSLatLon[y] != 0; x++, y++)
			BTEXT[x] = GPSLatLon[y];
		BTEXT[x++] = APRSSymbols[gpssymbolindex].symbol;
		GetCourse(pos);
		sprintf(CourseSpeed, "%3.0f/%3.0f", Angle, Position[x].Velocity);
		for (y = 0; y < 7; y++)
			if (CourseSpeed[y] == ' ')
				CourseSpeed[y] = '0';//because sprintf doesn't work the way it should
		for ( y = 0; CourseSpeed[y] != 0; x++, y++)
			BTEXT[x] = CourseSpeed[y];
		for ( y = 0; Comment[y] != 0; x++, y++)
			BTEXT[x] = Comment[y];
	}
	else//if (compressit)
	{
		x = 7;
		BTEXT[x++] = GPSSymbol[0];//symbol type

		y = (int)(380926 * (90.0 - Lat));
		BTEXT[x++] = (BYTE)((y / 753571) + 33);
		y %= 753571;//91^3
		BTEXT[x++] = (BYTE)((y / 8281) + 33);
		y %= 8281;//91^2
		BTEXT[x++] = (BYTE)((y / 91) + 33);
		y %= 91;
		BTEXT[x++] = (BYTE)(y + 33);

		y = (int)(190463.0 * (180.0 - Lon));
		BTEXT[x++] = (BYTE)((y / 753571) + 33);
		y %= 753571;
		BTEXT[x++] = (BYTE)((y / 8281) + 33);
		y %= 8281;
		BTEXT[x++] = (BYTE)((y / 91) + 33);
		y %= 91;
		BTEXT[x++] = (BYTE)(y + 33);

		BTEXT[x++] = APRSSymbols[gpssymbolindex].symbol;
		if (pos)
		{
			GetCourse(pos);//get Angle
			BTEXT[x++] = 33 + ((BYTE)(Angle / 4));
			//from APRS 1.01: speed = (1.08 to the power of s) - 1
			//if 1.08 to the power of y = speed, then y = log base 1.08 speed
			//and log base 1.08 speed = (log base e speed) / (log base e 1.08)
			speed = Position[pos].Velocity * 0.86897624191;//convert MPH to knots  
			d = log(speed) / LOG108;
			y = (int)d;
			if (modf(d, &degrees) > 0.5)
				y++;
			y += 33;
			BTEXT[x++] = (BYTE)y;
		}
		else
		{
			BTEXT[x++] = ' ';//no speed
			BTEXT[x++] = ' ';//no course
		}
		BTEXT[x++] = ' ';//compressed gps flag
	}
	BTEXT[x] = 0;
	SetDlgItemText(hwndAPRSDlg, IDC_BUTTON3, BTEXT);
	if (kiss == FALSE)
	{
		WriteFile(hAPRSComm, BTEXT, lstrlen(BTEXT), &dwBytesWritten, NULL);
		WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
		Sleep(500);
		WriteFile(hAPRSComm, BEACON, lstrlen(BEACON), &dwBytesWritten, NULL);
	}
	else
	{
		if (kiss)
			GetKiss();
		WriteFile(hAPRSComm, Kiss, KissLen, &dwBytesWritten, NULL);
	}
	WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
}

void InitializeAPRSComm(void)
{
	int x, y;

	firsttx = FALSE;
	WriteFile(hAPRSComm, "\3", 1, &dwBytesWritten, NULL);//Ctrl-C
	WriteFile(hAPRSComm, "MONITOR OFF", 11, &dwBytesWritten, NULL);
	WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
	WriteFile(hAPRSComm, "ECHO ON", 7, &dwBytesWritten, NULL);
	WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
	WriteFile(hAPRSComm, "HID OFF", 7, &dwBytesWritten, NULL);
	WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
	if ((MyCall[0]) && (Destination[0]) && (HomeLatLon[0]) && (HomeSymbol[0]))//(transmitto == TRANSMITHOME) && 
	{
		BTEXT[5] = ' ';
		BTEXT[6] = '=';
		if (compressit == FALSE)
		{
			for (x = 7, y = 0; HomeLatLon[y] != 0; x++, y++)
				BTEXT[x] = HomeLatLon[y];
			BTEXT[x++] = APRSSymbols[homesymbolindex].symbol;
			for ( y = 0; Comment[y] != 0; x++, y++)
				BTEXT[x] = Comment[y];
		}
		else//if (compressit)
		{//3724.44N/12206.98W
			LatMin = atof(&HomeLatLon[2]);
			LonMin = atof(&HomeLatLon[12]);
			tempLat = ((HomeLatLon[0] - '0') * 10) + (HomeLatLon[1] - '0') + (LatMin/60.0);
			tempLon = ((HomeLatLon[9] - '0') * 100) + ((HomeLatLon[10] - '0') * 10) + (HomeLatLon[11] - '0') + (LonMin/60.0);
			x = 7;
			BTEXT[x++] = HomeSymbol[0];//symbol type

			y = (int)(380926.0 * (90.0 - tempLat));
			BTEXT[x++] = (BYTE)((y / 753571) + 33);
			y %= 753571;//91^3
			BTEXT[x++] = (BYTE)((y / 8281) + 33);
			y %= 8281;//91^2
			BTEXT[x++] = (BYTE)((y / 91) + 33);
			y %= 91;
			BTEXT[x++] = (BYTE)(y + 33);

			y = (int)(190463.0 * (180.0 - tempLon));
			BTEXT[x++] = (BYTE)((y / 753571) + 33);
			y %= 753571;
			BTEXT[x++] = (BYTE)((y / 8281) + 33);
			y %= 8281;
			BTEXT[x++] = (BYTE)((y / 91) + 33);
			y %= 91;
			BTEXT[x++] = (BYTE)(y + 33);

			BTEXT[x++] = APRSSymbols[homesymbolindex].symbol;
			BTEXT[x++] = ' ';//no speed
			BTEXT[x++] = ' ';//no course
			BTEXT[x++] = ' ';//compressed flag
		}
		BTEXT[x] = 0;
		if (kiss == FALSE)
		{//it should always be false
			WriteFile(hAPRSComm, MYCALL, lstrlen(MYCALL), &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, UNPROTO, lstrlen(UNPROTO), &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, BTEXT, lstrlen(BTEXT), &dwBytesWritten, NULL);
			WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			if (transmitto == TRANSMITHOME)
			{//Home
				Sleep(500);
				WriteFile(hAPRSComm, BEACON, lstrlen(BEACON), &dwBytesWritten, NULL);
				WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
			}
		}
//		else if (transmitto != TRANSMITNONE)
//			WriteFile(hAPRSComm, Kiss, KissLen, &dwBytesWritten, NULL);
//		WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
	}
	WriteFile(hAPRSComm, "MONITOR ON", 10, &dwBytesWritten, NULL);
	WriteFile(hAPRSComm, "\x0D", 1, &dwBytesWritten, NULL);
}

HDC ReadBmpFile(char *FileName)
{
	static int BitmapInfoSize;
	static void *Buf;//the system allocates this memory in CreateDIBSection
	static DWORD bmpFileSize, dwBytesRead;
	static HANDLE hFile;
	static BITMAPINFO *pBmi;
	static BITMAPINFOHEADER bmih;
	static BITMAPFILEHEADER bmfh;

	hdcSymMem = 0;
	if ((hFile = CreateFile(FileName, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
	{
		if (bmpFileSize = GetFileSize(hFile, NULL))
		{
			ReadFile(hFile, &bmfh, BITMAPFILEHEADER_SIZE, &dwBytesRead, NULL);
			if (bmfh.bfType != 0x4D42)//"BM"
			{
				CloseHandle(hFile);
				MessageBox(hwnd, "Not a .bmp file", NULL, MB_OK);
				return 0;
			}
			BitmapInfoSize = bmfh.bfOffBits - BITMAPFILEHEADER_SIZE;
			pBmi = (BITMAPINFO*) malloc(BitmapInfoSize);
			ReadFile(hFile, pBmi, BitmapInfoSize, &dwBytesRead, NULL);
			bmih = pBmi->bmiHeader;
			bmpFileSize -= bmfh.bfOffBits;
			hSymbolBitmap = CreateDIBSection(NULL, pBmi, DIB_RGB_COLORS, &Buf, NULL, 0);
			ReadFile(hFile, Buf, bmpFileSize, &dwBytesRead, NULL);//Buf is allocated by system
			free(pBmi);
			pBmi = NULL;
			CloseHandle(hFile);
		}
		else
		{
			CloseHandle(hFile);
			MessageBox(hwnd, "File size was 0", NULL, MB_OK);
			return 0;
		}
		hdc = GetDC(hwnd);
		hdcSymMem = CreateCompatibleDC(hdc);
		if (NULL == hdcSymMem)
		{
			MessageBox(hwnd, "Can't create hdcSymMem!", NULL, MB_OK);
			return 0;
		}
		ReleaseDC(hwnd, hdc);
		if (NULL == hSymbolBitmap)
		{//from CreateDIBSection, above
			MessageBox(hwnd, "Can't get hSymbolBitmap!", NULL, MB_OK);
			return 0;
		}
		hObject = SelectObject(hdcSymMem, hSymbolBitmap);
		if (NULL == hObject)
		{
			MessageBox(hwnd, "Can't select hSymbolBitmap into hdcSymMem!", NULL, MB_OK);
			return 0;
		}
	}
	return hdcSymMem;
}

void ShowIcon(int x)
{
	int y;

	DotX = (Aprs[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
	DotY = (ScreenTop - Aprs[x].UTMN) * PixelsPerTile / MetersPerTile;
	SetBkColor(hdc, LIGHTGRAY);
	if (Aprs[x].RedDot == 0)
	{
		if (usetactical)
		{
			for (y = 0; y < (int)TacticalFileSize; y++)
			{
				for (z = 0; Aprs[x].Call[z] != 0; y++, z++)
				{
					if (Aprs[x].Call[z] != TacticalCalls[y])
						break;
				}
				if ((Aprs[x].Call[z] == 0) && (TacticalCalls[y] == ' '))
				{//found it
					y++;//to tactical callsign
					for (z = y; TacticalCalls[z] != '\r'; z++)
						;
					TextOut(hdc, DotX+10, DotY-7, &TacticalCalls[y], z-y);
					goto tac;
				}
				for ( ; (y < (int)TacticalFileSize) && (TacticalCalls[y] != '\n'); y++)
					;
			}
		}
		TextOut(hdc, DotX+10, DotY-7, Aprs[x].Call, strlen(Aprs[x].Call));
	}

tac:if ((hdcSymMem1) && (Aprs[x].RedDot == 0))
	{
		symbolcol = Aprs[x].Symbol % 16;
		symbolrow = Aprs[x].Symbol / 16;
		if (Aprs[x].SymbolType == '/')
			TransparentBlt(hdc, DotX-10, DotY-10, 20, 20, hdcSymMem1, (21*symbolcol)+1, (21*symbolrow)+1, 20, 20, 0xFFFFFF);
		else
		{
			TransparentBlt(hdc, DotX-10, DotY-10, 20, 20, hdcSymMem2, (21*symbolcol)+1, (21*symbolrow)+1, 20, 20, 0xFFFFFF);
			if (Aprs[x].SymbolType != '\\')
			{
				SetBkMode(hdc, TRANSPARENT);
				SetTextColor(hdc, 0xFFFFFF);
				TextOut(hdc, DotX-5, DotY-8, &Aprs[x].SymbolType, 1);
				SetTextColor(hdc, 0);
				SetBkMode(hdc, OPAQUE);
			}
		}
	}
	else if (hdcSymMem1 == 0)
		Ellipse(hdc, DotX-DotRadius, DotY-DotRadius, DotX+DotRadius, DotY+DotRadius);
	else if (Aprs[x].RedDot != 3)//&& (hdcSymMem1) && (Aprs[x].RedDot)
		Ellipse(hdc, DotX-3, DotY-3, DotX+3, DotY+3);
	if (x)
	{
		for (y = x-1; y != 0xFFFFFFFF; y--)
		{
			if ((Aprs[y].RedDot == 1) && (Aprs[y].UTMZ == Aprs[x].UTMZ))
			{// show tracks
				for (z = 0; Aprs[y].Call[z] != 0; z++)
					if (Aprs[y].Call[z] != Aprs[x].Call[z])
						break;
				if ((Aprs[y].Call[z] == 0) && (Aprs[x].Call[z] == 0))
				{//same callsign
					hPen = CreatePen(PS_SOLID, 0, 0xF0);
					hObject = SelectObject(hdc, hPen);
					MoveToEx(hdc, DotX, DotY, NULL);
					LineTo(hdc, (Aprs[y].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile, (ScreenTop - Aprs[y].UTMN) * PixelsPerTile / MetersPerTile);
					MoveToEx(hdc, 1+DotX, DotY, NULL);
					LineTo(hdc, 1+(Aprs[y].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile, (ScreenTop - Aprs[y].UTMN) * PixelsPerTile / MetersPerTile);
					SelectObject(hdc, hObject);
					DeleteObject(hPen);
					break;
				}
			}
		}
	}
/*
	if (showrangecircles)
	{
		int P, H, G;

		radius = 0;
		if ((Aprs[x].Status[0] == 'P') && (Aprs[x].Status[1] == 'H') && (Aprs[x].Status[2] == 'G'))
		{
			P = Aprs[x].Status[3] - '0';
			H = Aprs[x].Status[4] - '0';
			G = Aprs[x].Status[5] - '0';
			GAIN = G;
			radius = sqrt(2*HEIGHT[H]*sqrt((POWER[P]/10)*(GAIN/2)));
		}
		else if ((Aprs[x].Status[0] == 'R') && (Aprs[x].Status[1] == 'N') && (Aprs[x].Status[2] == 'G'))
		{
			radius = (((Aprs[x].Status[3] - '0') * 1000) + ((Aprs[x].Status[4] - '0') * 100) + ((Aprs[x].Status[5] - '0') * 10) + (Aprs[x].Status[6] - '0'));
		}
		if (radius)
		{
			Meters = (radius * 5280.0 * 0.3048);
			Radius = (int)(Meters * PixelsPerTile / MetersPerTile);
			hPen = CreatePen(PS_SOLID, 2, Objects[x].CircleColor);
			hObject = SelectObject(hdc, hPen);
			DotX = (Aprs[x].UTME - ScreenLeft) * PixelsPerTile / MetersPerTile;
			DotY = (ScreenTop - Aprs[x].UTMN) * PixelsPerTile / MetersPerTile;
			MoveToEx(hdc, DotX, DotY, NULL);
			AngleArc(hdc, DotX, DotY, Radius, 90.0, 360.0);
			SelectObject(hdc, hObject);
			DeleteObject(hPen);
		}
	}
*/
}

void BadLatLon(void)
{
	MessageBox(hwnd, "Bad location info", "", MB_OK);
	Lat = tempLat;
	Lon = tempLon;
	UTMZone = tempUTMZone;
	UTMNorthing = tempUTMN;
	UTMEasting = tempUTME;
}

int CALLBACK StationInfoProc(HWND hwndStationInfoDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, stationInfoIndex;
	int dlgWidth, dlgHeight;
	RECT dlgRect;
	static HWND hwndList;

	switch (message)
	{
	case WM_INITDIALOG:
		GetWindowRect(hwndStationInfoDlg, &dlgRect);
		dlgWidth = dlgRect.right-dlgRect.left;
		dlgHeight = dlgRect.bottom-dlgRect.top;
		MoveWindow(hwndStationInfoDlg, (cxScreen/2) - (dlgWidth/2), cyScreen-dlgHeight, dlgWidth, dlgHeight, TRUE);
		hwndList = GetDlgItem(hwndStationInfoDlg, IDC_LIST1);
		hwndButton = GetDlgItem(hwndStationInfoDlg, IDC_BUTTON1);
		for (x = 16, y = 0; Call[y] != 0; x++, y++)
			StationsInfo[x] = Call[y];
		StationsInfo[x] = 0;
//		SetWindowText(hwndStationInfoDlg, Call);
		SetWindowText(hwndStationInfoDlg, StationsInfo);
		for (x = 22, y = 0; (Call[y] != '-') && (Call[y] != 0); x++, y++)
			QRZ[x] = Call[y];
		QRZ[x] = 0;
		SetWindowText(hwndButton, QRZ);
		for (x = 0; x < Aprsi; x++)
		{
			if (0 == strcmp(Aprs[x].Call, Call))
			{
				StationInfo(x);
				SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)AprsLine);
			}
		}
		pInfoListProc = (WNDPROC)SetWindowLong(hwndList, GWL_WNDPROC, (LONG)EditInfoListProc);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_DBLCLK)
			{
				stationInfoIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
				SendMessage(hwndList, LB_GETTEXT, stationInfoIndex, (LPARAM)AprsLine);
				//find this UTM and center it on screen
				for (x = 0; (AprsLine[x-1] != ' ') || (AprsLine[x-2] != ' ') || (AprsLine[x-3] != '-'); x++)
					;
				if ((AprsLine[x] < '1') || (AprsLine[x] > '9'))
				{
					BadLatLon();
					break;
				}
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;
//37o5.090' 120o52.050'				
				Lat = atof(&AprsLine[x]);//((AprsLine[x] - '0') * 10) + (AprsLine[x+1] - '0');
				LatMin = atof(&AprsLine[x+3]);
				Lat += (LatMin / 60.0);
				for ( ; (AprsLine[x] != 0) && (AprsLine[x] != '\'') ; x++)
					;
				x += 2; // to Lon
				Lon = atof(&AprsLine[x]);//((AprsLine[x] - '0') * 10) + (AprsLine[x+1] - '0');
				for ( ; (AprsLine[x] != 0) && (AprsLine[x] != '\xB0') ; x++) // degree sign
					;
				x++; // to LonMin
				LonMin = atof(&AprsLine[x]);
				Lon += (LonMin / 60.0);
				Lon = -Lon;
				LatRad = Lat*deg2rad;
				LonRad = Lon*deg2rad;
				LatLontoUTM();

				ChangeZone(UTMZone, 10);//StationInforProc
				BeginX = UTMEasting / MetersPerTile;
				BeginY = UTMNorthing / MetersPerTile;
				_itoa(BeginX, X, 10);
				_itoa(BeginY, Y, 10);
				Z[0] = (UTMZone / 10) + '0';
				Z[1] = (UTMZone % 10) + '0';
				Waypoints[0] = 0;
				if (tempUTMZone != UTMZone)
					SendMessage(hwnd, WM_USER4, 0, 0);
				tempLat = Lat;
				tempLon = Lon;
				tempUTMZone = UTMZone;
				tempUTMN = UTMNorthing;
				tempUTME = UTMEasting;

				wastopo = FALSE;
				veryfirstime = TRUE;
				rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
				colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
				SetCursor(hWaitingCursor);
				fromOpen = TRUE;
				SendMessage(hwnd, WM_USER, 0, 0);//was WM_USER2
				SetCursor(hCursor);

				Lat = tempLat;
				Lon = tempLon;
				UTMZone = tempUTMZone;
				UTMNorthing = tempUTMN;
				UTMEasting = tempUTME;

				lButtonDotX = (UTMEasting - ScreenLeft) * PixelsPerTile / MetersPerTile;
				lButtonDotY = (ScreenTop - UTMNorthing) * PixelsPerTile / MetersPerTile;
				fromstationinfo = TRUE;
				SendMessage(hwnd, WM_USER6, 0, 0);
				fromstationinfo = FALSE;
			}
			break;

		case IDC_BUTTON1:
			for (x = 48, y = 0; QRZ[y] != 0; x++, y++)
				TerraServer[x] = QRZ[y];
			TerraServer[x] = 0;
			WinExec(TerraServer, SW_SHOW);
			break;

		case IDOK:
			EndDialog (hwndStationInfoDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndStationInfoDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

void SortStations(HWND hwndList)
{
	for (y = 0, staptr = 0; y < stationPtr; )
	{
		stationlinebeg = y;
		for ( ; Stations[y] != 0; y++)
			;
		Ptrs[staptr++] = stationlinebeg;
		y++;
	}
	Ptrs[staptr] = y;
	Stations[y++] = 'Z';
	Stations[y++] = 'Z';
	Stations[y++] = 0;
	for (y = 0; y < staptr; y++)
	{
		smallest = staptr;
		for (z = 0; z < staptr; z++)
		{
			if ((z != smallest) && (Ptrs[z] != -1))
			{
				for (v = 0; ; v++)
				{
					if (Stations[Ptrs[z]+v] < Stations[Ptrs[smallest]+v])
					{
						smallest = z;
						break;
					}
					else if (Stations[Ptrs[z]+v] > Stations[Ptrs[smallest]+v])
						break;
				}
			} 
		}
		SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)&Stations[Ptrs[smallest]]);
		PtrsCopy[y] = Ptrs[smallest];
		Ptrs[smallest] = -1;
	}
	if ((Call[0]) && (stationIndex != -1))
	{
		for (y = 0; y < staptr; y++)
		{
			for (z = 0; Call[z] != 0; z++)
				if (Call[z] != Stations[PtrsCopy[y]+z])
					break;
			if ((Call[z] == 0) && ((Stations[PtrsCopy[y]+z] == TAB) || (Stations[PtrsCopy[y]+z] == 0)))
			{
				stationIndex = y;
				break;
			}
		}
		SendMessage(hwndList, LB_SETCURSEL, stationIndex, 0);
	}
	if (NumOfStations >= 100)
		StationsTitle[0] = (NumOfStations/100) + '0';
	else
		StationsTitle[0] = ' ';
	if (NumOfStations >= 10)
		StationsTitle[1] = ((NumOfStations%100)/10) + '0';
	else
		StationsTitle[1] = ' ';
	StationsTitle[2] = (NumOfStations%10) + '0';
}

int CALLBACK StationsProc(HWND hwndStationsDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, y, z, dlgWidth, dlgHeight, ListHeight;
	int Tabs[] = {54};//this works...
	RECT dlgRect;
	static HWND hwndList;
	int topoflist;
	char deleteStation[20];
	static char deletequery[20];
	int pointA, pointB;

	switch (message)
	{
	case WM_INITDIALOG:
		Call[0] = 0;
		MoveWindow(hwndStationsDlg, 0, TitleAndMenu, 180, rect.bottom, TRUE);
		GetWindowRect(hwndStationsDlg, &dlgRect);
		dlgWidth = dlgRect.right-dlgRect.left;
		dlgHeight = dlgRect.bottom-dlgRect.top;
		hwndList = GetDlgItem(hwndStationsDlg, IDC_LIST1);
		ListHeight = dlgHeight-TitleAndMenu-10;//-30
		MoveWindow(hwndList, 10, 10, dlgWidth-(Frame*2)-20, ListHeight, TRUE);//30
		SortStations(hwndList);
		SetWindowText(hwndStationsDlg, StationsTitle);
		pEditListProc = (WNDPROC)SetWindowLong(hwndList, GWL_WNDPROC, (LONG)EditListProc);
		SendMessage(hwndList, LB_SETTABSTOPS, (WPARAM)1, (LPARAM)&Tabs);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_RADIO1:
			topoflist = (int)SendMessage(hwndList, LB_GETTOPINDEX, 0, 0);
			SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
			SortStations(hwndList);
			SendMessage(hwndList, LB_SETTOPINDEX, topoflist, 0);
			SetWindowText(hwndStationsDlg, StationsTitle);
			break;

		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				if (hwndStationInfoDlg)
				{
					stationIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
					SendMessage(hwndList, LB_GETTEXT, stationIndex, (LPARAM)Call);//Call is changed
					for (y = 0; (Call[y] != TAB) && (Call[y] != 0); y++)
						;
					if (Call[y] == TAB)
						Call[y] = 0;
					SendDlgItemMessage(hwndStationInfoDlg, IDC_LIST1, LB_RESETCONTENT, 0, 0);
					for (x = 0; x < Aprsi; x++)
					{
						if (0 == strcmp(Aprs[x].Call, Call))
						{
//							SetWindowText(hwndStationInfoDlg, Call);
							for (z = 16, y = 0; Call[y] != 0; z++, y++)
								StationsInfo[z] = Call[y];
							StationsInfo[z] = 0;
							SetWindowText(hwndStationInfoDlg, StationsInfo);
							for (z = 22, y = 0; (Call[y] != '-') && (Call[y] != 0); z++, y++)
								QRZ[z] = Call[y];
							QRZ[z] = 0;
							SetWindowText(hwndButton, QRZ);
							StationInfo(x);
						}
					}
				}
			}
			else if (HIWORD (wParam) == LBN_DBLCLK)
			{
				stationIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
				SendMessage(hwndList, LB_GETTEXT, stationIndex, (LPARAM)Call);//Call is filled
				for (y = 0; (Call[y] != TAB) && (Call[y] != 0); y++)
					;
				if (Call[y] == TAB)
					Call[y] = 0;
				if (hwndStationInfoDlg != NULL)
				{
					DestroyWindow(hwndStationInfoDlg);
					hwndStationInfoDlg = NULL;
				}
				hwndStationInfoDlg = CreateDialog(hInst, "STATIONINFO", hwnd, StationInfoProc);
				SetFocus(hwndStationsDlg);
			}
			break;

		case VK_DELETE:
			if (GetKeyState(VK_CONTROL) & 0x80000000)
			{
				if (NumOfStations){
					if (IDYES == MessageBox(hwnd, "       Are you sure?", "Delete all stations?", MB_YESNO|MB_DEFBUTTON2))
					{
						EnterCriticalSection(&cs);ClearStationsFlag = TRUE;LeaveCriticalSection(&cs);
						memset(Stations, '\0', sizeof(Stations));
						NumOfStations = stationPtr = 0;
						SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
						StationsTitle[0] = StationsTitle[1] = ' ';
						StationsTitle[2] = '0';
						SetWindowText(hwndStationsDlg, StationsTitle);
						ClearStationsFlag = FALSE;
					}
				}
			}
			else
			{
				if (LB_ERR != (stationIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0)))
				{
					SendMessage(hwndList, LB_GETTEXT, stationIndex, (LPARAM)Call);
					for (x = 0; (Call[x] != TAB) && (Call[x] != '\0'); x++)
						deleteStation[x] = Call[x];
					deleteStation[x] = '\0';
					sprintf(deletequery, "Delete %s?", deleteStation);
					if (IDYES == MessageBox(hwnd, deletequery, "Delete Station", MB_YESNO|MB_DEFBUTTON2))
					{
						SendMessage(hwndList, LB_DELETESTRING, stationIndex, 0);
						pointA = 0;
						while (pointA < stationPtr)
						{
							if (!strncmp(&Stations[pointA], deleteStation, strlen(deleteStation)))
							{
								pointB = pointA;
								do
									++pointB;
								while (Stations[pointB] != '\0');
								++pointB;
								memmove(&Stations[pointA], &Stations[pointB], (int)(stationPtr - pointB));
								stationPtr -= (pointB - pointA);
								memset(&Stations[stationPtr - 1], '\0', (pointB - pointA));
								--NumOfStations;
								break;
							}
							++pointA;
						}
					}
				}
			}
			break;

		case IDOK:
			EndDialog (hwndStationsDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			if (hwndStationInfoDlg)
			{
				DestroyWindow(hwndStationInfoDlg);
				hwndStationInfoDlg = NULL;
			}
			EndDialog (hwndStationsDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK MessageProc(HWND hwndMessageDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText;

	switch (message)
	{
	case WM_INITDIALOG:
		Message = TRUE;
		hwndText = GetDlgItem(hwndMessageDlg, IDC_EDIT1);
		SetWindowText(hwndText, Msg);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			Message = FALSE;
			EndDialog (hwndMessageDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			Message = FALSE;
			EndDialog (hwndMessageDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK EditMessageProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText, hwndTo;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndTo = GetDlgItem(hwndDlg, IDC_EDIT2);
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
		if (MsgTo[0])
			SetWindowText(hwndTo, MsgTo);
		if (SendMsg[0])
			SetWindowText(hwndText, SendMsg);
		SetFocus(hwndTo);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (0 == GetWindowText(hwndTo, MsgTo, 9))
				break;
			if (0 == GetWindowText(hwndText, SendMsg, 67))
				break;
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK GetObjectProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText, hwndSymbols, hwndComment;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndSymbols = GetDlgItem(hwndDlg, IDC_BUTTON1);
		hwndComment = GetDlgItem(hwndDlg, IDC_EDIT2);
		gotsymbol = FALSE;
		SetFocus(hwndText);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_BUTTON1:
			symbolindex = 0;
			Overlay[0] = 0;
			fromindex = OBJECTINDEX;
			if (FALSE == DialogBox(hInst, "SYMBOLS", hwnd, SymbolsProc))
			{
				EndDialog (hwndDlg, EXIT);
				return EXIT;
			}
			else
				gotsymbol = TRUE;//to show objects
			break;

		case IDOK:
			if (0 == GetWindowText(hwndText, ObjectName, 32))
				break;
			if (gotsymbol == FALSE)
			{
				symbolindex = 0;
				Overlay[0] = 0;
				fromindex = OBJECTINDEX;
				if (FALSE == DialogBox(hInst, "SYMBOLS", hwnd, SymbolsProc))
				{
					EndDialog (hwndDlg, EXIT);
					return EXIT;
				}
				else
					gotsymbol = TRUE;//to show objects
				break;
			}
			objectPtr = 0;
			LoadObjects();
			if (objectPtr < MAXOBJECTS)
			{
				strcpy(Objects[objectPtr].Name, ObjectName);
				GetWindowText(hwndComment, Objects[objectPtr].Comment, 44);
				Objects[objectPtr].Symbol = symbolindex;
				if (symbolindex < 94)
					Objects[objectPtr].SymbolType = '/';
				else if (Overlay[0] == 0)
					Objects[objectPtr].SymbolType = '\\';
				else
					Objects[objectPtr].SymbolType = Overlay[0];
				Objects[objectPtr].UTMN = ObjectUTMN;
				Objects[objectPtr].UTME = ObjectUTME;
				Objects[objectPtr].UTMZ = ObjectUTMZ;
				objectPtr++;
				hFile = CreateFile(ObjectsDta, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
				WriteFile(hFile, Objects, objectPtr*120, &dwBytesWritten, NULL);
				CloseHandle(hFile);
			}
			else
				MessageBox(hwnd, "You can only have 25 objects...", "", MB_OK);
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

int CALLBACK CircleProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndRadius;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndRadius = GetDlgItem(hwndDlg, IDC_EDIT1);
		if (Objects[objectindex].CircleRadius == 0)
		{
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
			CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO3);
//			CheckRadioButton(hwndDlg, IDC_RADIO11, IDC_RADIO12, IDC_RADIO11);
		}
		else
		{
			sprintf(CircleRadius, "%.4f", Objects[objectindex].CircleRadius);
			SetWindowText(hwndRadius, CircleRadius); 
			if (Objects[objectindex].itsmiles)
				CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
			else
				CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);

			if (Objects[objectindex].CircleColor == 0)//black
				CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO3);
			else if (Objects[objectindex].CircleColor == 0xFF0000)//blue
				CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO4);
			else if (Objects[objectindex].CircleColor == 0x00FF00)//green
				CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO5);
			else if (Objects[objectindex].CircleColor == 0xFFFF00)//cyan
				CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO6);
			else if (Objects[objectindex].CircleColor == 0x0000FF)//red
				CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO7);
			else if (Objects[objectindex].CircleColor == 0xFF00FF)//violet
				CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO8);
			else if (Objects[objectindex].CircleColor == 0x00FFFF)//yellow
				CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO9);
			else if (Objects[objectindex].CircleColor == 0x808080)//gray
				CheckRadioButton(hwndDlg, IDC_RADIO3, IDC_RADIO10, IDC_RADIO10);
//			if (Objects[objectindex].intense)
//				CheckRadioButton(hwndDlg, IDC_RADIO11, IDC_RADIO12, IDC_RADIO11);
//			else
//				CheckRadioButton(hwndDlg, IDC_RADIO11, IDC_RADIO12, IDC_RADIO12);
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (0 == GetWindowText(hwndRadius, CircleRadius, 11))
				break;
			Objects[objectindex].CircleRadius = atof(CircleRadius);
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO1))
				Objects[objectindex].itsmiles = TRUE;
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO2))
				Objects[objectindex].itsmiles = FALSE;

			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO3))
				Objects[objectindex].CircleColor = 0;//black
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO4))
				Objects[objectindex].CircleColor = 0xFF0000;//blue
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO5))
				Objects[objectindex].CircleColor = 0x00FF00;//green
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO6))
				Objects[objectindex].CircleColor = 0xFFFF00;//cyan
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO7))
				Objects[objectindex].CircleColor = 0x0000FF;//red
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO8))
				Objects[objectindex].CircleColor = 0xFF00FF;//violet
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO9))
				Objects[objectindex].CircleColor = 0x00FFFF;//yellow
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO10))
				Objects[objectindex].CircleColor = 0x808080;//gray
//			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO11))
//				Objects[objectindex].intense = TRUE;
//			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO12))
//				Objects[objectindex].intense = FALSE;
			hFile = CreateFile(ObjectsDta, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, Objects, objectPtr*120, &dwBytesWritten, NULL);
			CloseHandle(hFile);
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, EXIT);
			return EXIT;
		}
	}
	return FALSE;
}

int CALLBACK EditObjectProc(HWND hwndEditObjectDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x, y, z;
	static char Objectime[12];
	static HWND hwndList, hwndComment, hwndOK, hwndCheck, hwndTime, hwndTimeButton;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndList = GetDlgItem(hwndEditObjectDlg, IDC_LIST1);
		hwndComment = GetDlgItem(hwndEditObjectDlg, IDC_EDIT1);
		hwndTime = GetDlgItem(hwndEditObjectDlg, IDC_EDIT2);
		hwndOK = GetDlgItem(hwndEditObjectDlg, IDOK);
		hwndTimeButton = GetDlgItem(hwndEditObjectDlg, IDC_BUTTON3);
		GetSystemTime(&st);
		Objectime[0] = '<';
		Objectime[1] = '-';
		Objectime[2] = ' ';
		Objectime[3] = (st.wDay / 10) + '0';
		Objectime[4] = (st.wDay % 10) + '0';
		Objectime[5] = (st.wHour / 10) + '0';
		Objectime[6] = (st.wHour % 10) + '0';
		Objectime[7] = (st.wMinute / 10) + '0';
		Objectime[8] = (st.wMinute % 10) + '0';
		Objectime[9] = 'z';
		Objectime[10] = 0;
		SetWindowText(hwndTimeButton, Objectime);
		for (x = 0; x < objectPtr; x++)
			SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)Objects[x].Name);
		objectindex = 0;
		SendMessage(hwndList, LB_SETCURSEL, (WPARAM)objectindex, 0);
		SetWindowText(hwndComment, Objects[objectindex].Comment);
		if (Objects[objectindex].Time[0])
			SetWindowText(hwndTime, Objects[objectindex].Time);
		if (sendit)
		{
			sendit = FALSE;
			SetWindowText(hwndOK, "SEND");
		}
		hwndCheck = GetDlgItem(hwndEditObjectDlg, IDC_CHECK1);
		if (compressed)
			CheckDlgButton (hwndEditObjectDlg, IDC_CHECK1, BST_CHECKED);
		if (itslive)
			CheckRadioButton(hwndEditObjectDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
		else	
			CheckRadioButton(hwndEditObjectDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
		SetFocus(hwndList);
		break;

	case WM_MEASUREITEM:
		lpmis = (LPMEASUREITEMSTRUCT)lParam;
		lpmis->itemHeight = 20;
		return TRUE;

	case WM_DRAWITEM:
		lpdis = (LPDRAWITEMSTRUCT)lParam;
		switch (lpdis->itemAction)
		{
		case ODA_SELECT:
		case ODA_DRAWENTIRE:
			rcBitmap.left = lpdis->rcItem.left; 
			rcBitmap.top = lpdis->rcItem.top; 
			rcBitmap.right = lpdis->rcItem.right-lpdis->rcItem.left; 
			rcBitmap.bottom = lpdis->rcItem.top + YBITMAP;
			if (lpdis->itemState & ODS_SELECTED)
			{
				FillRect(lpdis->hDC, &rcBitmap, (HBRUSH)CreateSolidBrush(0xC56A31));//Windows highlight color
				SetBkMode(lpdis->hDC, TRANSPARENT);
				SetTextColor(lpdis->hDC, 0xFFFFFF);
			}
			else
			{
				FillRect(lpdis->hDC, &rcBitmap, (HBRUSH)CreateSolidBrush(0xFFFFFF));
				SetBkColor(lpdis->hDC, 0xFFFFFF);
				SetTextColor(lpdis->hDC, 0);
			}
			GetTextMetrics(lpdis->hDC, &tm);
			y = (rcBitmap.bottom + rcBitmap.top - tm.tmHeight) / 2;
			SendMessage(lpdis->hwndItem, LB_GETTEXT, lpdis->itemID, (LPARAM) tchBuffer);
			TextOut(lpdis->hDC, XBITMAP+6, y, tchBuffer, strlen(tchBuffer));
			z = Objects[lpdis->itemID].Symbol;
			if (Objects[lpdis->itemID].SymbolType != '/')
				z -= 94;
			xIndex = z % 16;
			yIndex = z / 16;
			if (Objects[lpdis->itemID].SymbolType == '/')
				TransparentBlt(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, 20, 20, hdcSymMem1, (21*xIndex)+1, (21*yIndex)+1, 20, 20, 0xFFFFFF);
			else
			{
				TransparentBlt(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, 20, 20, hdcSymMem2, (21*xIndex)+1, (21*yIndex)+1, 20, 20, 0xFFFFFF);
				if (Objects[lpdis->itemID].SymbolType != '\\')
				{
					SetBkMode(lpdis->hDC, TRANSPARENT);
					SetTextColor(lpdis->hDC, 0xFFFFFF);
					TextOut(lpdis->hDC, 5, y, &Objects[lpdis->itemID].SymbolType, 1);
					SetTextColor(lpdis->hDC, 0);
					SetBkMode(lpdis->hDC, OPAQUE);
				}
			}
			break;	
		case ODA_FOCUS:
			break;
		}
		return TRUE;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_BUTTON3:
			SetWindowText(hwndTime, &Objectime[3]);
			break;

		case IDC_CHECK1:
			if (BST_CHECKED == IsDlgButtonChecked(hwndEditObjectDlg, IDC_CHECK1))
				compressed = TRUE;
			else
				compressed = FALSE;
			break;

		case IDC_LIST1:
			if (HIWORD (wParam) == LBN_DBLCLK)
				SendMessage(hwndEditObjectDlg, WM_COMMAND, (WPARAM)IDOK, 0);
			else if (HIWORD (wParam) == LBN_SELCHANGE)
			{
				objectindex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);
				SendMessage(hwndList, LB_SETCURSEL, objectindex, 0);
				SetWindowText(hwndComment, Objects[objectindex].Comment);
			}
			break;

		case IDC_BUTTON1://delete
			SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
			for (x = objectindex, y = objectindex+1; x < objectPtr; x++, y++)
				Objects[x] = Objects[y];
			objectPtr--;
			for (x = 0; x < objectPtr; x++)
				SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)Objects[x].Name);
			objectindex = 0;
			SetFocus(hwndEditObjectDlg);
			break;

		case IDC_BUTTON2://circle
			DialogBox(hInst, "CIRCLE", NULL, CircleProc);
			break;

		case IDOK:
			if (BST_CHECKED == IsDlgButtonChecked(hwndEditObjectDlg, IDC_RADIO1))
				itslive = TRUE;
			else
				itslive = FALSE;
			Objects[objectindex].Comment[0] = 0;
			GetWindowText(hwndComment, Objects[objectindex].Comment, 44);
			if (0 == GetWindowText(hwndTime, Objects[objectindex].Time, 8))
				for (x = 0; x < 7; x++)
					Objects[objectindex].Time[x] = 0;
			else
			{
				for (x = 0; x < 6; x++)
				{
					if ((Objects[objectindex].Time[x] < '0') || (Objects[objectindex].Time[x] > '9'))
					{
						MessageBox(hwnd, "timestamp needs to be ddhhmmz format", "", MB_OK);
						break;
					}
				}
				if (Objects[objectindex].Time[6] != 'z')
				{
					MessageBox(hwnd, "timestamp needs to be in UTC time with a 'z' at the end", "", MB_OK);
					break;
				}
			}
			hFile = CreateFile(ObjectsDta, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
			WriteFile(hFile, Objects, objectPtr*120, &dwBytesWritten, NULL);
			CloseHandle(hFile);
			EndDialog (hwndEditObjectDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndEditObjectDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

void LoadObjects(void)
{
	hFile = CreateFile(ObjectsDta, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		fileSize = GetFileSize(hFile, NULL);
		if (fileSize)
		{
			ReadFile(hFile, Objects, fileSize, &dwBytesRead, NULL);
			objectPtr = fileSize / 120;
		}
		CloseHandle(hFile);
	}
}

int CALLBACK TacticalProc(HWND hwndTacticalDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndTacticalDlg, IDC_EDIT1);
		SetWindowText(hwndText, TacticalCalls);
		SetFocus(hwndText);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_EDIT1:
			TacticalFileSize = GetWindowText(hwndText, TacticalCalls, 1024);
			break;

		case IDOK:
			if (INVALID_HANDLE_VALUE != (hFile3 = CreateFile(Tactical, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL)))
			{
				WriteFile(hFile3, TacticalCalls, TacticalFileSize, &dwBytesWritten, NULL);
				CloseHandle(hFile3);
			}
			EndDialog (hwndTacticalDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndTacticalDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

void StationInfo(int x)
{
	if (Aprs[x].UTMN)
	{
		tempLat = Lat;
		tempLon = Lon;
		tempUTMZone = UTMZone;
		tempUTMN = UTMNorthing;
		tempUTME = UTMEasting;
		UTMNorthing = Aprs[x].UTMN;
		UTMEasting = Aprs[x].UTME;
		UTMZone = Aprs[x].UTMZ;
		UTMtoLatLon();
		LatMin = modf(Lat, &lat) * 60.0;
		LonMin = modf(-Lon, &lon) * 60.0;
		Lat = tempLat;
		Lon = tempLon;
		UTMZone = tempUTMZone;
		UTMNorthing = tempUTMN;
		UTMEasting = tempUTME;
	}
	else
		lat = LatMin = lon = LonMin = 0.0;
	sprintf(AprsLine, "%.4dz  -  %2.0f\xB0%5.3f' %3.0f%\xB0%5.3f'  -  %s  -  %s", Aprs[x].Time, lat, LatMin, lon, LonMin, Aprs[x].DescOrWx, Aprs[x].Status);
	for (y = 0; AprsLine[y] != 0; y++)//because sprintf puts space in Lat or Lon
	{
		if ((AprsLine[y] == '\xB0') && (AprsLine[y+1] == ' '))
			AprsLine[y+1] = '0';
		if ((AprsLine[y] == '\xB0') && (AprsLine[y+2] == ' '))
			AprsLine[y+2] = '0';
	}
	SendDlgItemMessage(hwndStationInfoDlg, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)AprsLine);
}

int CALLBACK APRSServerProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static char *ptr;

	switch (message)
	{
	case WM_INITDIALOG:
		if (sendmyloc == FALSE)
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO10, IDC_RADIO2);
		else
			CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO10, IDC_RADIO6);
		SetFocus(hwndDlg);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO1))
				ptr = &missouri[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO2))
				ptr = &montana[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO3))
				ptr = &nebraska[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO4))
				ptr = &southwest[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO5))
				ptr = &socal[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO6))
				ptr = &midwest[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO7))
				ptr = &central[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO8))
				ptr = &aprswest[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO9))
				ptr = &newengland[0];
			else if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_RADIO10))
				ptr = &westtn[0];
			for (x = 0; ptr[x] != 0; x++)
				Tier2Server[x] = ptr[x];
			for (y = 0; aprs2net[y] != 0; x++, y++)
				Tier2Server[x] = aprs2net[y];
			Tier2Server[x] = 0;
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK SecretIPProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText, hwndInitialize;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetWindowText(hwndText, "192.168.1.105:1448");
		hwndInitialize = GetDlgItem(hwndDlg, IDC_EDIT2);
		SetFocus(hwndText);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (0 == GetWindowText(hwndText, SecretIP, 24))
				break;
			FilterLen = GetWindowText(hwndInitialize, Filter, 128);
			if (FilterLen)
				Filter[FilterLen++] = '\x0D';
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int GetInitString(void)
{
	int x;

	for (x = 0; Filter1[x] != 0; x++)
		Filter[x] = Filter1[x];
	hashMyCall[0] = 0;//flag
	x = 11;//used if MyCall[0] == 0
	if (_stricmp(MyCall, "NOCALL"))
	{//if not the same
		if (MyCall[0])
		{
			for (x = 5, y = 0; MyCall[y] != 0; x++, y++)
				Filter[x] = MyCall[y];
			for (y = 0, z = 0; (MyCall[y] != '-') && (MyCall[y] != 0); y++, z++)
				hashMyCall[z] = MyCall[y];
			hashMyCall[z] = 0;
			if (hashMyCall[0])
			{
				hash = 0x73e2;
				for (y = 0; y < z; )
				{
					hash ^= (hashMyCall[y++] << 8);
					hash ^= hashMyCall[y++];
				}
				hash &= 0x7fff;
			}
		}
	}
	for (y = 0; Filter2[y] != 0; x++, y++)
		Filter[x] = Filter2[y];
	if (hashMyCall[0])
	{
		_itoa(hash, (char*)hashMyCall, 10);
		for (y = 0; hashMyCall[y] != 0; x++, y++)
			Filter[x] = hashMyCall[y];
	}
	else
	{
		Filter[x++] = '-';
		Filter[x++] = '1';
	}
	for (y = 0; Filter3[y] != 0; x++, y++)
		Filter[x] = Filter3[y];
	return x;
}

int CALLBACK SmartBeaconingProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int SlowSpeedLen, SlowBeaconLen, HighSpeedLen, HighBeaconLen, TurnTimeLen, AngleLen, ConstantLen;
	static HWND hwndEdit1, hwndEdit2, hwndEdit3, hwndEdit4, hwndEdit5, hwndEdit6, hwndEdit7;

	switch (message)
	{
	case WM_INITDIALOG:
		_itoa(sbSlowSpeed, SlowSpeedSB, 10);
		_itoa(sbSlowBeacon, SlowBeaconSB, 10);
		_itoa(sbHighSpeed, HighSpeedSB, 10);
		_itoa(sbHighBeacon, HighBeaconSB, 10);
		_itoa(sbTurnTime, TurnTimeSB, 10);
		_itoa(sbAngle, AngleSB, 10);
		_itoa(sbConstant, ConstantSB, 10);
		hwndEdit1 = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetWindowText(hwndEdit1, SlowSpeedSB);
		hwndEdit2 = GetDlgItem(hwndDlg, IDC_EDIT2);
		SetWindowText(hwndEdit2, SlowBeaconSB);
		hwndEdit3 = GetDlgItem(hwndDlg, IDC_EDIT3);
		SetWindowText(hwndEdit3, HighSpeedSB);
		hwndEdit4 = GetDlgItem(hwndDlg, IDC_EDIT4);
		SetWindowText(hwndEdit4, HighBeaconSB);
		hwndEdit5 = GetDlgItem(hwndDlg, IDC_EDIT5);
		SetWindowText(hwndEdit5, TurnTimeSB);
		hwndEdit6 = GetDlgItem(hwndDlg, IDC_EDIT6);
		SetWindowText(hwndEdit6, AngleSB);
		hwndEdit7 = GetDlgItem(hwndDlg, IDC_EDIT7);
		SetWindowText(hwndEdit7, ConstantSB);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_BUTTON1://Test SmartBeaconing
			if (0 == GetWindowText(hwndEdit1, SlowSpeedSB, 12))
				break;
			if (0 == GetWindowText(hwndEdit2, SlowBeaconSB, 12))
				break;
			if (0 == GetWindowText(hwndEdit3, HighSpeedSB, 12))
				break;
			if (0 == GetWindowText(hwndEdit4, HighBeaconSB, 12))
				break;
			if (0 == GetWindowText(hwndEdit5, TurnTimeSB, 12))
				break;
			if (0 == GetWindowText(hwndEdit6, AngleSB, 4))
				break;
			if (0 == GetWindowText(hwndEdit7, ConstantSB, 12))
				break;
			sbSlowSpeed = atoi(SlowSpeedSB);
			sbSlowBeacon = atoi(SlowBeaconSB);
			sbHighSpeed = atoi(HighSpeedSB);
			sbHighBeacon = atoi(HighBeaconSB);
			sbTurnTime = atoi(TurnTimeSB);
			sbAngle = atoi(AngleSB);
			sbConstant = atoi(ConstantSB);

			firstposX = -1;
			if (testingsmartbeaconing)
			{
				pos = 0;
				posflag = TRUE;
				InvalidateRect(hwnd, &rect, FALSE);//clear position data
			}
			else
				testingsmartbeaconing = TRUE;
			SendMessage(hwnd, WM_COMMAND, ID_GPS_LOCATION_DISPLAYPOSITION01CSV, 0);
			break;

		case IDOK:
			SlowSpeedLen = GetWindowText(hwndEdit1, SlowSpeedSB, 12);
			if (0 == SlowSpeedLen)
				break;
			SlowBeaconLen = GetWindowText(hwndEdit2, SlowBeaconSB, 12);
			if (0 == SlowBeaconLen)
				break;
			HighSpeedLen = GetWindowText(hwndEdit3, HighSpeedSB, 12);
			if (0 == HighSpeedLen)
				break;
			HighBeaconLen = GetWindowText(hwndEdit4, HighBeaconSB, 12);
			if (0 == HighBeaconLen)
				break;
			TurnTimeLen = GetWindowText(hwndEdit5, TurnTimeSB, 12);
			if (0 == TurnTimeLen)
				break;
			AngleLen = GetWindowText(hwndEdit6, AngleSB, 4);
			if (0 == AngleLen)
				break;
			ConstantLen = GetWindowText(hwndEdit7, ConstantSB, 12);
			if (0 == ConstantLen)
				break;
			sbSlowSpeed = atoi(SlowSpeedSB);
			sbSlowBeacon = atoi(SlowBeaconSB);
			sbHighSpeed = atoi(HighSpeedSB);
			sbHighBeacon = atoi(HighBeaconSB);
			sbTurnTime = atoi(TurnTimeSB);
			sbAngle = atoi(AngleSB);
			sbConstant = atoi(ConstantSB);

			hFile = CreateFile(USAPMini, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				fileSize = GetFileSize(hFile, NULL);
				pUSAPMbufIn = (char*)malloc(fileSize);
				ReadFile(hFile, pUSAPMbufIn, fileSize, &dwBytesRead, NULL);
				gotit = FALSE;
				for (x = 0; x < (int)fileSize; x++)
				{
					if (pUSAPMbufIn[x] == '=')
					{
						if ((pUSAPMbufIn[x-11] == 'S') && (pUSAPMbufIn[x-10] == 'B') && (pUSAPMbufIn[x-9] == 'S') && (pUSAPMbufIn[x-5] == 'S'))
						{//SBSlowSpeed=
							fileSize = AddtoUSAPMini(SlowSpeedSB);
							gotit = TRUE;
						}
						else if ((pUSAPMbufIn[x-12] == 'S') && (pUSAPMbufIn[x-11] == 'B') && (pUSAPMbufIn[x-10] == 'S') && (pUSAPMbufIn[x-6] == 'B'))
						{//SBSlowBeacon=
							fileSize = AddtoUSAPMini(SlowBeaconSB);
							gotit = TRUE;
						}
						else if ((pUSAPMbufIn[x-11] == 'S') && (pUSAPMbufIn[x-10] == 'B') && (pUSAPMbufIn[x-9] == 'H') && (pUSAPMbufIn[x-5] == 'S'))
						{//SBHighSpeed=
							fileSize = AddtoUSAPMini(HighSpeedSB);
							gotit = TRUE;
						}
						else if ((pUSAPMbufIn[x-12] == 'S') && (pUSAPMbufIn[x-11] == 'B') && (pUSAPMbufIn[x-10] == 'H') && (pUSAPMbufIn[x-6] == 'B'))
						{//SBHighBeacon=
							fileSize = AddtoUSAPMini(HighBeaconSB);
							gotit = TRUE;
						}
						else if ((pUSAPMbufIn[x-10] == 'S') && (pUSAPMbufIn[x-9] == 'B') && (pUSAPMbufIn[x-8] == 'T') && (pUSAPMbufIn[x-4] == 'T'))
						{//SBTurnTime=
							fileSize = AddtoUSAPMini(TurnTimeSB);
							gotit = TRUE;
						}
						else if ((pUSAPMbufIn[x-7] == 'S') && (pUSAPMbufIn[x-6] == 'B') && (pUSAPMbufIn[x-5] == 'A'))
						{//SBAngle=
							fileSize = AddtoUSAPMini(AngleSB);
							gotit = TRUE;
						}
						else if ((pUSAPMbufIn[x-10] == 'S') && (pUSAPMbufIn[x-9] == 'B') && (pUSAPMbufIn[x-8] == 'C'))
						{//SBConstant=
							fileSize = AddtoUSAPMini(ConstantSB);
							gotit = TRUE;
						}
					}
				}
				if (gotit)
				{
					SetFilePointer(hFile, 0, 0, FILE_BEGIN);
					WriteFile(hFile, pUSAPMbufIn, fileSize, &dwBytesWritten, NULL);
				}
				else//if (gotit == FALSE)
				{
					WriteFile(hFile, SBSlowSpeed, lstrlen(SBSlowSpeed), &dwBytesWritten, NULL);
					WriteFile(hFile, SlowSpeedSB, SlowSpeedLen, &dwBytesWritten, NULL);
					WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);

					WriteFile(hFile, SBSlowBeacon, lstrlen(SBSlowBeacon), &dwBytesWritten, NULL);
					WriteFile(hFile, SlowBeaconSB, SlowBeaconLen, &dwBytesWritten, NULL);
					WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);

					WriteFile(hFile, SBHighSpeed, lstrlen(SBHighSpeed), &dwBytesWritten, NULL);
					WriteFile(hFile, HighSpeedSB, HighSpeedLen, &dwBytesWritten, NULL);
					WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);

					WriteFile(hFile, SBHighBeacon, lstrlen(SBHighBeacon), &dwBytesWritten, NULL);
					WriteFile(hFile, HighBeaconSB, HighBeaconLen, &dwBytesWritten, NULL);
					WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);

					WriteFile(hFile, SBTurnTime, lstrlen(SBTurnTime), &dwBytesWritten, NULL);
					WriteFile(hFile, TurnTimeSB, TurnTimeLen, &dwBytesWritten, NULL);
					WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);

					WriteFile(hFile, SBAngle, lstrlen(SBAngle), &dwBytesWritten, NULL);
					WriteFile(hFile, AngleSB, AngleLen, &dwBytesWritten, NULL);
					WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);

					WriteFile(hFile, SBConstant, lstrlen(SBConstant), &dwBytesWritten, NULL);
					WriteFile(hFile, ConstantSB, ConstantLen, &dwBytesWritten, NULL);
					WriteFile(hFile, "\r\n", 2, &dwBytesWritten, NULL);
				}
				CloseHandle(hFile);
				free(pUSAPMbufIn);
			}

			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			smartbeaconing = FALSE;
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}


/*
int CALLBACK LocalServerProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND hwndText;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndText = GetDlgItem(hwndDlg, IDC_EDIT1);
		SetFocus(hwndText);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (0 == GetWindowText(hwndText, ServerIP, 24))
				break;
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

				y = 0;
				AprsLine[y++] = (Aprs[x].Time / 1000) + '0';
				AprsLine[y++] = ((Aprs[x].Time % 1000) / 100) + '0';
				AprsLine[y++] = ((Aprs[x].Time % 100) / 10) + '0';
				AprsLine[y++] = (Aprs[x].Time % 10) + '0';
				AprsLine[y++] = 'z';
				for (z = 0; z < 5; y++, z++)
					AprsLine[y] = Dash[z];
				if (Aprs[x].UTMN)
				{
					AprsLine[y++] = (Aprs[x].UTMZ / 10) + '0';
					AprsLine[y++] = (Aprs[x].UTMZ % 10)+ '0';
					AprsLine[y++] = ' ';
					AprsLine[y++] = (Aprs[x].UTME / 100000) + '0';
					AprsLine[y++] = ((Aprs[x].UTME % 100000) / 10000) + '0';
					AprsLine[y++] = ((Aprs[x].UTME % 10000) / 1000) + '0';
					AprsLine[y++] = ((Aprs[x].UTME % 1000) / 100) + '0';
					AprsLine[y++] = ((Aprs[x].UTME % 100) / 10) + '0';
					AprsLine[y++] = (Aprs[x].UTME % 10)+ '0';
					AprsLine[y++] = ' ';
					AprsLine[y++] = (Aprs[x].UTMN / 1000000) + '0';
					AprsLine[y++] = ((Aprs[x].UTMN % 1000000) / 100000) + '0';
					AprsLine[y++] = ((Aprs[x].UTMN % 100000) / 10000) + '0';
					AprsLine[y++] = ((Aprs[x].UTMN % 10000) / 1000) + '0';
					AprsLine[y++] = ((Aprs[x].UTMN % 1000) / 100) + '0';
					AprsLine[y++] = ((Aprs[x].UTMN % 100) / 10) + '0';
					AprsLine[y++] = (Aprs[x].UTMN % 10)+ '0';
				}
				else
					for (z = 0; Unknown[z] != 0; y++, z++)
						AprsLine[y] = Unknown[z];
				for (z = 0; z < 5; y++, z++)
					AprsLine[y] = Dash[z];
				for (z = 0; Aprs[x].DescOrWx[z] != 0; y++, z++)
				{
					if (Aprs[x].DescOrWx[z] != '\xB0')//degrees
						AprsLine[y] = Aprs[x].DescOrWx[z];
					else
					{
						AprsLine[y++] = 'd';
						AprsLine[y++] = 'e';
						AprsLine[y] = 'g';
					}
				}
				for (z = 0; z < 5; y++, z++)
					AprsLine[y] = Dash[z];
				for (z = 0; Aprs[x].Status[z] != 0; y++, z++)
					AprsLine[y] = Aprs[x].Status[z];
				AprsLine[y++] = '\n';
				AprsLine[y++] = 0;
				for (z = 0; z < y; z++)
					SendMessage(hwndText, WM_CHAR, AprsLine[z], 0);
	{
		y = aprslinebeg;
		if ((aprsBuf[y] == 'c')
		 && (aprsBuf[y+1] == 'm')
		 && (aprsBuf[y+2] == 'd')
		 && (aprsBuf[y+3] == ':'))
		{
			y += 4;
		}
		for (z = 0; (z < 9) && (aprsBuf[y] != '>'); y++, z++)
			temp[z] = aprsBuf[y];
		temp[z] = 0;
		for (y = 0; y < stationPtr; )
		{
			stationlinebeg = y;
			for (z = 0; temp[z] != 0; y++, z++)
				if (Stations[y] != temp[z])
					break;
			if ((Stations[y] == TAB) && (temp[z] == 0))
			{//found station
				y++;
				Stations[y++] = (st.wHour/10) + '0';
				Stations[y++] = (st.wHour%10) + '0';
				y++;
				Stations[y++] = (st.wMinute/10) + '0';
				Stations[y++] = (st.wMinute%10) + '0';
				y++;
				Stations[y++] = (st.wSecond/10) + '0';
				Stations[y++] = (st.wSecond%10) + '0';
				break;
			}
			for ( ; Stations[y] != 0; y++)
				;
			y++;
		}
		if (y == stationPtr)
		{
			for (stationPtr = y, z = 0; temp[z] != 0; stationPtr++, z++)
				Stations[stationPtr] = temp[z];
			Stations[stationPtr++] = TAB;
			Stations[stationPtr++] = (st.wHour/10) + '0';
			Stations[stationPtr++] = (st.wHour%10) + '0';
			Stations[stationPtr++] = ':';
			Stations[stationPtr++] = (st.wMinute/10) + '0';
			Stations[stationPtr++] = (st.wMinute%10) + '0';
			Stations[stationPtr++] = ':';
			Stations[stationPtr++] = (st.wSecond/10) + '0';
			Stations[stationPtr++] = (st.wSecond%10) + '0';
			Stations[stationPtr++] = 'z';
			Stations[stationPtr++] = 0;
			NumOfStations++;
		}
		if (hwndStationsDlg)
		{
			SendMessage(hwndStationsDlg, WM_COMMAND, IDC_RADIO1, 0);
		}
	}

		if (aprsimulate)
		{
			SortStations(hwndList);
			CheckRadioButton(hwndStationsDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
		}

		else
		{
			for (x = 0; x < stationPtr; x++)
			{
				SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)&Stations[x]);
				for ( ; (Stations[x] != 0) && (x < stationPtr); x++)
					;
			}
			CheckRadioButton(hwndStationsDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
		}

char Symbols[] = "Select a symbol";
	wndclass.lpfnWndProc = SymbolChartProc;
	wndclass.hIcon = NULL;
	wndclass.lpszClassName = Symbols;
	RegisterClass(&wndclass);
			hwndSymbolChart = CreateWindow(Symbols, Symbols,
				WS_CHILD | WS_VISIBLE | WS_DLGFRAME | WS_CAPTION | WS_SYSMENU,
				0, 0, 25*16, 45*6,
				hwnd, (HMENU)666, hInst, NULL);
LRESULT CALLBACK SymbolChartProc(HWND hwndSymbolChart, UINT message, WPARAM wParam, LPARAM lParam)
{
	HDC hdc;
	PAINTSTRUCT ps;

	switch(message)
	{
	case WM_LBUTTONDOWN:
		DestroyWindow(hwndSymbolChart);
		break;

	case WM_PAINT:
		hdc = BeginPaint(hwndSymbolChart, &ps);
		for (x = 0; x < 16; x++)
		{
			for (y = 0; y < 6; y++)
				TransparentBlt(hdc, x*20, y*20, 20, 20, hdcSymMem1, (21*x)+1, (21*y)+1, 20, 20, 0xFFFFFF);
		}
		for (x = 0; x < 16; x++)
		{
			for (y = 0; y < 6; y++)
				TransparentBlt(hdc, x*20, 120+(y*20), 20, 20, hdcSymMem2, (21*x)+1, (21*y)+1, 20, 20, 0xFFFFFF);
		}
		EndPaint(hwndSymbolChart, &ps);
		return 0;

	}
	return DefWindowProc(hwndSymbolChart, message, wParam, lParam);
}
SetTextAlign (hdc, GetTextAlign(hdc) & (~TA_CENTER))
or
SetTextAlign (hdc,TA_LEFT | <other flags>)
*/

void GetCourse(int x)
{
	beginE = Position[x-1].UTME;
	endE = Position[x].UTME;
	beginN = Position[x-1].UTMN;
	endN = Position[x].UTMN;
	if ((endE == beginE) && (endN == beginN))
		return;
	if (endE > beginE)
	{
		if (endN > beginN)
		{
			A = (endN - beginN) / (endE - beginE);
			Angle = 90 - (rad2deg * atan(A));
		}
		else if (endN == beginN)
		{
			if (endE > beginE)
				Angle = 90.0;
			else
				Angle = 270.0;
		}
		else//if (endN < beginN)
		{//angled down
			A = (beginN - endN) / (endE - beginE);
			Angle = 90.0 + (rad2deg * atan(A));
		}
	}
	else if (endE == beginE)
	{
		if (endN <= beginN)
			Angle = 180.0;
		else
			Angle = 360.0;
	}
	else//if (beginE > endE)
	{//going from right to left (backwards)
		if (endN >= beginN)
		{//angled up
			A = (endN - beginN) / (beginE - endE);
			Angle = 270 + (rad2deg * atan(A));
		}
		else//if (endN < beginN)
		{//angled down
			A = (beginN - endN) / (beginE - endE);
			Angle = 180.0 + (rad2deg * atan(A));
 		}
	}
}

void GetSpeed(int x)
{
	time = (Position[x].Hour*3600)+(Position[x].Min*60)+(Position[x].Sec);
	d = Position[x].Velocity;
	sbSpeed = (int)d;
	if (modf(d, &degrees) > 0.5)
		sbSpeed++;//round up
	if (sbSpeed == 0)
	{
		prevtime = (Position[x-1].Hour*3600)+(Position[x-1].Min*60)+(Position[x-1].Sec);
		ndist = abs(Position[x].UTMN - Position[x-1].UTMN);
		edist = abs(Position[x].UTME - Position[x-1].UTME);
		if (prevtime > time)//passing midnight
			prevtime -= (24*3600);
		if (time - prevtime)
		{
			d = (sqrt(ndist*ndist + edist*edist)) / (time - prevtime);//meters/sec
			d *= 2.2369363;//mph
		}
		else
			d = 0.0;
		sbSpeed = (int)d;
		if (modf(d, &degrees) > 0.5)
			sbSpeed++;
	}
}

BOOL SmartBeacon(int x)
{
	int turned, z;

	if (x == 0)
		gotfirstpos = FALSE;//for loop in WM_PAINT
	if (gotfirstpos == FALSE)
	{
		if ((x) && ((Position[x].UTME != Position[x-1].UTME) || (Position[x].UTMN != Position[x-1].UTMN)) && (Position[x].UTMZ == Position[x-1].UTMZ))
		{
			GetCourse(x);
			Position[x].Course = (int)Angle;
			if (modf(Angle, &degrees) > 0.5)
				Position[x].Course++;//round up
			if ((Position[x].Course <= (Position[x-1].Course+20)) && (Position[x].Course >= (Position[x-1].Course-20)))
			{
				if ((x > 1) && (Position[x-1].Course <= (Position[x-2].Course+20)) && (Position[x-1].Course >= (Position[x-2].Course-20)))
				{
					if ((x > 2) && (Position[x-2].Course <= (Position[x-3].Course+20)) && (Position[x-2].Course >= (Position[x-3].Course-20)))
					{
						gotfirstpos = TRUE;
						firstposX = x;
//						LastX = firstposX;
						LastBeacon = (Position[x].Hour*3600)+(Position[x].Min*60)+(Position[x].Sec);
						LastCourse = Position[x].Course;
						return TRUE;
					}
				}
			}
		}
		return FALSE;
	}

	if (x >= firstposX)
	{
		GetSpeed(x);
		if (sbSpeed == 0)
			return FALSE;
		GetCourse(x);
		sbCourse = (int)Angle;
		if (modf(Angle, &degrees) > 0.5)
			sbCourse++;//round up
		Position[x].Course = sbCourse;

		if (sbSpeed < sbSlowSpeed)
			sbBeacon = sbSlowBeacon;
		else if (sbSpeed > sbHighSpeed)
			sbBeacon = sbHighBeacon;
		else if (sbSlowBeacon == sbHighBeacon)
			sbBeacon = sbSlowBeacon;
		else
		{
			z = sbHighSpeed - sbSlowSpeed;
			if (z == 0)
				return FALSE;
			sbBeacon = sbSlowBeacon + ((sbSpeed-sbSlowSpeed) * (sbHighBeacon-sbSlowBeacon) / z);
		}
		if (sbBeacon <= (time-LastBeacon))
		{
//			LastPosition = LastX;
//			LastX = x;
			LastBeacon = time;
			LastCourse = sbCourse;
			return TRUE;
		}

		if (sbSpeed >= sbSlowSpeed)
		{
			if (sbCourse > LastCourse)
			{
				if ((sbCourse < (360 - sbAngle)) || (LastCourse > sbAngle))
					turned = sbCourse - LastCourse;
				else
					turned = LastCourse + 360 - sbCourse;
			}	
			else if (sbCourse < LastCourse)
			{
				if ((LastCourse < (360 - sbAngle)) || (sbAngle > LastCourse))
					turned = LastCourse - sbCourse;
				else
					turned = sbCourse + 360 - LastCourse;
			}
			else
				turned = 0;
			z = LastBeacon;
			if (z > time)//passing midnight
				z -= (24*3600);
			if ((turned > (sbAngle + (sbConstant / sbSpeed))) && ((time-z) > sbTurnTime))
			{
				LastBeacon = time;
				LastCourse = sbCourse;
				return TRUE;
			}
		}
	}
	return FALSE;
}

// This function will look for any packets from the Igate. Just discards them because they are unused.

void LookForIgateMessages(void)
{
	u_long i_bytes = 0l;
	char FromIgate[512];
	
	if (ioctlsocket(s3, FIONREAD, &i_bytes) != SOCKET_ERROR)
	{
		if (i_bytes > 0l)
		{
			if (SOCKET_ERROR == recv(s3, FromIgate, 512, 0))
			{
				sprintf(Error, "Receive error %d\n(ERROR %d)", WSAGetLastError, 40537); // __LINE__
				SendMessage(hwnd, WM_COMMAND, ID_APRS_INTERNETNETWORK_ACTASANIGATE, 0);
				MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
			}
		}
	}
	else
	{
		sprintf(Error, "Receive error %d\n(ERROR %d)", WSAGetLastError(), 40545); // __LINE__
		MessageBox(hwnd, Error, IgateErrorCaption, MB_OK);
	}
}

DWORD Atoi(char *ptr)
{
	DWORD x;

	for (x = 0;(*ptr >= '0') && (*ptr <= '9'); ptr++)
	{
		x *= 10;
		x += *ptr - '0';
	}
	return x;
}

int CALLBACK CenterlineProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int FieldElev;
	static HWND hwndEdit1;

	switch (message)
	{
	case WM_INITDIALOG:
		hwndEdit1 = GetDlgItem(hwndDlg, IDC_EDIT1);
		hwndEdit2 = GetDlgItem(hwndDlg, IDC_EDIT2);
		hwndEdit3 = GetDlgItem(hwndDlg, IDC_EDIT3);
		hwndEdit4 = GetDlgItem(hwndDlg, IDC_EDIT4);
		hwndEdit5 = GetDlgItem(hwndDlg, IDC_EDIT5);
		centerline[0] = 0;
		downwindAlt[0] = 0;
		downwindIAS[0] = 0;
		gs[0] = 0;
		fieldelev[0] = 0;
		rightdownwind = FALSE;
		CheckRadioButton(hwndDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1); // left downwind
		SetFocus(hwndEdit1);
 		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_RADIO1:
			rightdownwind = FALSE;
			break;
		case IDC_RADIO2:
			rightdownwind = TRUE;
			break;

		case IDOK:
			if (0 == GetWindowText(hwndEdit1, centerline, 8))
				break;
			GetWindowText(hwndEdit2, downwindAlt, 8);
			GetWindowText(hwndEdit3, downwindIAS, 8);
			GetWindowText(hwndEdit4, gs, 8);
			GetWindowText(hwndEdit5, fieldelev, 8);
			dCenterline = atof((char*)centerline);
			if (dCenterline < 180.0)
				dCenterline += 180.0;
			else
				dCenterline -= 180.0;
			DownwindAlt = Atoi((char*)downwindAlt);
//			if (DownwindAlt < 1000) // 2 or 200 20 or 2000 200 or 20000
//				DownwindAlt *= 100;
			DownwindIAS = Atoi((char*)downwindIAS);
			GlideSlopeIntercept = Atoi((char*)gs);
			FieldElev = Atoi((char*)fieldelev);
			GlideSlopeAlt = GlideSlopeIntercept - FieldElev;
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

int CALLBACK NewPlaneProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int x;
	static char tempHeading[6];
	static HWND hwndHeading, hwndAirspeed, hwndAltitude;

	switch (message)
	{
	case WM_INITDIALOG:
		for (x = 0; x < 6; x++)
			ApproachAltitude[x] = 0;
		hwndHeading = GetDlgItem(hwndDlg, IDC_EDIT2);
		hwndAirspeed = GetDlgItem(hwndDlg, IDC_EDIT3);
		hwndAltitude = GetDlgItem(hwndDlg, IDC_EDIT4);
		if ((tempUTME >= AirportUTMEasting) && (tempUTMN >= AirportUTMNorthing))
			radianheading = PI + (atan((double)(tempUTME-AirportUTMEasting) / (double)(tempUTMN-AirportUTMNorthing)));
		else if ((tempUTME >= AirportUTMEasting) && (tempUTMN <= AirportUTMNorthing))
			radianheading = (PI * 2.0) - (atan((double)(tempUTME-AirportUTMEasting) / (double)(AirportUTMNorthing-tempUTMN)));
		else if ((tempUTME <= AirportUTMEasting) && (tempUTMN <= AirportUTMNorthing))
			radianheading = atan((double)(AirportUTMEasting-tempUTME) / (double)(AirportUTMNorthing-tempUTMN));
		else if ((tempUTME <= AirportUTMEasting) && (tempUTMN >= AirportUTMNorthing))
			radianheading = (PI / 2.0) + (atan((double)(tempUTMN-AirportUTMNorthing) / (double)(AirportUTMEasting-tempUTME)));
		heading = radianheading * rad2deg;
		modf(heading, &iHeading);
		_itoa((int)iHeading, Heading, 10);
		SetWindowText(hwndHeading, Heading);
		SetFocus(hwndAirspeed);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (0 == GetWindowText(hwndHeading, tempHeading, 6))
				break;
			if (0 == GetWindowText(hwndAirspeed, Airspeed, 6))
				break;
			if (0 == GetWindowText(hwndAltitude, ApproachAltitude, 6)) // 100 or 10000 or 80 or 8000 or 2 or 200
				break;
			if (0 != strcmp(tempHeading, Heading))
			{
				strcpy(Heading, tempHeading);
				heading = Atoi(Heading);
				iHeading = (double)heading;
				radianheading = iHeading * deg2rad;
			}
			if (ApproachAltitude[1] == 0)
			{
				ApproachAltitude[1] = '0';
				ApproachAltitude[2] = '0';
			}
			else if (ApproachAltitude[2] == 0)
			{
				ApproachAltitude[2] = '0';
				ApproachAltitude[3] = '0';
			}
			else if (ApproachAltitude[3] == 0)
			{
				ApproachAltitude[3] = '0';
				ApproachAltitude[4] = '0';
			}
			EndDialog (hwndDlg, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog (hwndDlg, FALSE);
			return FALSE;
		}
	}
	return FALSE;
}

void ApproachControl(void)
{
	approachcontrol = TRUE;
	plane = 0;
	lines = 0;
	planecommand = FALSE;
	dCenterline = 370.0; // flag
	for (x = 0; x < command; x++)
		Command[x] = 0;
	AirportUTMEasting = UTMEasting;
	AirportUTMNorthing = UTMNorthing;
	ChangeZone(UTMZone, 5);//GoToProc
	BeginX = UTMEasting / MetersPerTile;
	BeginY = UTMNorthing / MetersPerTile;
	colOffset = BeginX - ((TilesAcross-1) / 2);//left edge of opening screen
	rowOffset = BeginY - (TilesDown / 2);//bottom edge of opening screen
	Waypoints[0] = 0;
	fromOpen = TRUE; // for WM_USER
	SendMessage(hwnd, WM_USER4, 0, 0);
	hdc = GetDC(hwnd);
	GetTextExtentPoint32(hdc, NewPlane, 46, &Size);
	TextOut(hdc, (cxScreen/2) - (Size.cx/2), cyScreen/2, NewPlane, 51);
	TextOut(hdc, (cxScreen/2) - (Size.cx/2), (cyScreen/2) + 20, CenterLine, 65);
	ReleaseDC(hwnd, hdc);
	return;
}
