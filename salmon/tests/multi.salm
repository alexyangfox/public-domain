/* file "multi.salm" */

/*
 *  This file contains multiple tests of Salmon.
 *
 *  Written by Chris Wilson.
 *
 *  This file is hearby placed in the public domain by its author.
 */


/* This is the starting test -- the traditional ``Hello, World!''. */
print("Hello, World!\n");

/* Now we add another argument to the function call to test the handling of
 * calls with multiple arguments. */
print("Hello, World!\n", "Hello, again!\n");

/* Next, we print a mixture of strings and characters, testing both the
 * handling of character literals and the handling of characters by the
 * built-in ``print()'' function. */
print("Hello, ", 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', 's', "!\n");

/* Now, we test the handling of both forms of comments and nested comments. */

/* Comment form 1 */
// Comment form 2
#  Comment form 3

/* Nested /* comment /* test */ is */ here */

/* And next we test the handling of whitespace by the tokenizer. */


    

 print  (
"Hello, whitespace.\n"  ) ;

/* Next, we try a very simple test of variable declaration, initialization, and
 * use. */

variable x := "value";

print("The value of x is `", x, "'.\n");

/* Next comes a test of decimal integer literals. */

print("The value of 123 is ", 123, ".\n");

/* Next we have a test of integer addition. */

print("The value of 12 + 17 is ", 12 + 17, ".\n");

/* And now we'll try assignment. */

variable v1 := 1;

print("The initial value of v1 is ", v1, ".\n");

v1 := 2;

print("After the first assignment, the value of v1 is ", v1, ".\n");

v1 := 27;

print("After the second assignment, the value of v1 is ", v1, ".\n");

/* Next, let's try an ``if'' statement. */

variable v2 := 12;

if (v2 > 0)
  {
    print("v2 is greater than zero.\n");
  };

if (v2 > 100)
  {
    print("v2 is greater than 100.\n");
  };

if (v2 > 10)
  {
    print("v2 is greater than 10.\n");
  }
else
  {
    print("v2 is not greater than 10.\n");
  };

if (v2 > 20)
  {
    print("v2 is greater than 20.\n");
  }
else
  {
    print("v2 is not greater than 20.\n");
  };

/* And now let's try a couple of ``for'' statements. */

for (i; 0; i < 3; 1)
  {
    print("i is ", i, ".\n");
  };

for (i; 0; i < 3)
    print("i is ", i, ".\n");;


/* Next, let's try ``while'' statements. */

variable v3;

v3 := 10;

while (v3 > 5)
  {
    print("v3 is ", v3, ".\n");
    v3 -= 2;
  };

v3 := 110;

while (v3 > 105)
  {
    print("v3 is ", v3, ".\n");
  }
step
  {
    v3 -= 2;
  };

v3 := 210;

while (v3 > 205)
step
  {
    v3 -= 2;
  }
  {
    print("v3 is ", v3, ".\n");
  };

/* And after that, we'll try something similar with do-while statements. */

variable v4;

v4 := 10;

do
  {
    print("v4 is ", v4, ".\n");
    v4 -= 2;
  } while (v4 > 5);

v4 := 110;

do
  {
    print("v4 is ", v4, ".\n");
  } while (v4 > 105)
step
  {
    v4 -= 2;
  };

v4 := 210;

do
  {
    print("v4 is ", v4, ".\n");
  } while (v4 > 305)
step
  {
    v4 -= 2;
  };

print("After the loop, v4 is ", v4, ".\n");

/* Now, let's try creating a procedure and calling it. */

procedure p()
  {
    print("p() was called.\n");
  };

p();

/* And next, let's try a parmater. */

procedure p2(x)
  {
    print("p2() was called with ", x, " as an argument.\n");
  };

p2(10);

p2(20);

/* Next, we'll try an ``iterate'' statement. */

iterate (e; ["snow", "rain", "hail"])
  {
    print("e is `", e, "'.\n");
  };

/* Next, we'll do some tests of break and continue statements. */

variable v5 := 10;

while (v5 < 20)
  {
    print("before test with v5 = ", v5, ".\n");
    if (v5 >= 14)
      {
        break;
      };
    print("after test with v5 = ", v5, ".\n");
  }
step
  {
    v5 += 2;
  };

variable v6 := 10;

while (v6 < 20)
  {
    print("before test with v6 = ", v6, ".\n");
    if (v6 >= 14)
      {
        continue;
      };
    print("after test with v6 = ", v6, ".\n");
  }
step
  {
    v6 += 2;
  };

variable v7 := 10;

do
  {
    print("before test with v7 = ", v7, ".\n");
    if (v7 >= 14)
      {
        break;
      };
    print("after test with v7 = ", v7, ".\n");
  } while (v7 < 20)
step
  {
    v7 += 2;
  };

variable v8 := 10;

do
  {
    print("before test with v8 = ", v8, ".\n");
    if (v8 >= 14)
      {
        continue;
      };
    print("after test with v8 = ", v8, ".\n");
  } while (v8 < 20)
step
  {
    v8 += 2;
  };

for (i; 0; i < 5)
  {
    print("before test i is ", i, ".\n");
    if (i >= 2)
      {
        break;
      };
    print("after test i is ", i, ".\n");
  };

for (i; 0; i < 5)
  {
    print("before test i is ", i, ".\n");
    if (i >= 2)
      {
        continue;
      };
    print("after test i is ", i, ".\n");
  };

iterate (e; ["snow", "rain", "hail"])
  {
    print("before test e is `", e, "'.\n");
    if (e == "rain")
      {
        break;
      };
    print("after test e is `", e, "'.\n");
  };

iterate (e; ["snow", "rain", "hail"])
  {
    print("before test e is `", e, "'.\n");
    if (e == "rain")
      {
        continue;
      };
    print("after test e is `", e, "'.\n");
  };

outer1:
for (i; 0; i < 3)
  {
    for (j; 0; j < 3)
      {
        print("before test (i, j) is (", i, ", ", j, ").\n");
        if ((i == 1) && (j == 1))
          {
            break from outer1;
          };
        print("after test (i, j) is (", i, ", ", j, ").\n");
      };
  };

outer2:
for (i; 0; i < 3)
  {
    for (j; 0; j < 3)
      {
        print("before test (i, j) is (", i, ", ", j, ").\n");
        if ((i == 1) && (j == 1))
          {
            continue with outer2;
          };
        print("after test (i, j) is (", i, ", ", j, ").\n");
      };
  };

procedure p3(pp)
  {
    print("p3() before the call to pp().\n");
    pp();
    print("p3() after the call to pp().\n");
  };

for (i; 0; i < 5)
  {
    procedure p()
      {
        if (i >= 2)
          {
            break;
          };
      };

    print("before test i is ", i, ".\n");
    p3(p);
    print("after test i is ", i, ".\n");
  };

for (i; 0; i < 5)
  {
    procedure p()
      {
        if (i >= 2)
          {
            continue;
          };
      };

    print("before test i is ", i, ".\n");
    p3(p);
    print("after test i is ", i, ".\n");
  };


/* Next, we'll try return statements in procedures. */

procedure p4()
  {
    print("p4() was called.\n");
    return;
  };

p4();

procedure p5()
  {
    procedure p()
      {
        return from p5;
      };

    print("before p().\n");
    p();
    print("after p().\n");
  };

p5();

/* And now we'll try user-defined functions. */

function f1()
  {
    return 15;
  };

print("f1() returns ", f1(), ".\n");

function f2()
  {
    function f()
      {
        return 29 from f2;
      };

    print("before f().\n");
    f();
    print("after f().\n");
  };

print("f2() returns ", f2(), ".\n");

/* Next, let's try statement block expressions. */

print("The value is ", { p5(); return f2(); }, ".\n");

/* Now let's try a semi-labeled value list with some labeled elements, and try
 * accessing elements by label and by number. */

variable v9 := [x := 1, 2, y := 17];

print("v9[0] is ", v9[0], ".\n");
print("v9[1] is ", v9[1], ".\n");
print("v9[2] is ", v9[2], ".\n");
print("v9.x is ", v9.x, ".\n");
print("v9.y is ", v9.y, ".\n");

/* Now, we'll try a class. */

class c1(x)
  {
    variable y := x + 2;
    print("Constructing a c1 with x = ", x, ".\n");
    procedure do_print()
      {
        print("The value of c1.y is ", y, ".\n");
      };
    cleanup
      {
        print("Cleaning up a c1 with y = ", y, ".\n");
      };
  };

  {
    variable cc := c1(10);

    print("The value of cc.y is ", cc.y, ".\n");
    cc.do_print();
    cc.y := "bluebird";
    print("The value of cc.y is now ", cc.y, ".\n");
    cc.do_print();
  };

print("We've now finished with cc.\n");

/* Next, we'll test an include file. */

include "multi_include.salm";

/* Now, we'll try a simple recursive function to compute Fibonocci numbers. */

function fib(x : [1...+oo)) returns [0...+oo)
  {
    function helper(x : [2...+oo)) returns [[0...+oo), [1...+oo)]
      {
        variable minus_2;
        variable minus_1;

        if (x == 2)
          {
            return [0, 1];
          };
        [minus_2, minus_1] := helper(x - 1);
        return [minus_1, minus_1 + minus_2];
      };

    if (x == 1)
      {
        return 0;
      };
    return helper(x)[1];
  };

print("The first Fibonocci number is ", fib(1), ".\n");
print("The second Fibonocci number is ", fib(2), ".\n");
print("The third Fibonocci number is ", fib(3), ".\n");
print("The fourth Fibonocci number is ", fib(4), ".\n");
print("The fifth Fibonocci number is ", fib(5), ".\n");
print("The sixth Fibonocci number is ", fib(6), ".\n");
print("The seventh Fibonocci number is ", fib(7), ".\n");
print("The eighth Fibonocci number is ", fib(8), ".\n");
print("The 400th Fibonocci number is ", fib(400), ".\n");


/* Next, let's try some multiplication. */

print("2 * 3 is ", 2 * 3, ".\n");
print("20 * 30 is ", 20 * 30, ".\n");
print("317 * 487 is ", 317 * 487, ".\n");
print("-317 * 487 is ", (-317) * 487, ".\n");


/* Now we'll try ``in'' expressions with simple enumeration types. */

print("1 in {3, 5, 7}: ", 1 in {3, 5, 7}, ".\n");
print("2 in {3, 5, 7}: ", 2 in {3, 5, 7}, ".\n");
print("3 in {3, 5, 7}: ", 3 in {3, 5, 7}, ".\n");
print("4 in {3, 5, 7}: ", 4 in {3, 5, 7}, ".\n");
print("5 in {3, 5, 7}: ", 5 in {3, 5, 7}, ".\n");
print("6 in {3, 5, 7}: ", 6 in {3, 5, 7}, ".\n");
print("7 in {3, 5, 7}: ", 7 in {3, 5, 7}, ".\n");
print("8 in {3, 5, 7}: ", 8 in {3, 5, 7}, ".\n");


/* Next, we'll try an assertion. */

assert(7 > 5);


/* Now, we'll do a test of try-handle exception handling. */

procedure p6(e : exception)
  {
    print("Took an exception!\n");
    if (e.tag == exception_tag_bad_operands)
      {
        print("Exception tag is bad_operands.\n");
      }
    else
      {
        print("Exception tag is not bad_operands.\n");
      };
    print("Exception message: `", e.message, "'.\n");
    print("Exception source file name: `", e.source.file_name, "'.\n");
    print("Exception source start line number: `", e.source.start_line,
          "'.\n");
    print("Exception source start column number: `", e.source.start_column,
          "'.\n");
    print("Exception source end line number: `", e.source.end_line, "'.\n");
    print("Exception source end column number: `", e.source.end_column,
          "'.\n");

    goto after_try;
  };

try
  {
    variable x;

    print("Before exception.\n");
    x := "aaa" + "bbb";
    print("After exception.\n");
  } handle p6;

after_try:
print("The try-handle block is now done.\n");


/* Now, let's try printing some non-finite values. */

print("Positive infinity: ", +oo, ".\n");
print("Negative infinity: ", -oo, ".\n");
print("Unsigned infinity: ", 1/0, ".\n");
print("Zero-zero: ", 0/0, ".\n");


/* Next, we'll try a more complex case of exception handling. */

  {
    function handler1(e : exception)
      {
        print("Handler 1: `", e.message, "'.\n");
        goto done1;
      };
    cleanup
      {
        print("Cleanup 1.\n");
      };
    try
      {
        function handler2(e : exception)
          {
            print("Handler 2: `", e.message, "'.\n");
            e := 17;
          };
        cleanup
          {
            print("Cleanup 2.\n");
          };
        try
          {
            function handler3(e : exception)
              {
                print("Handler 3: `", e.message, "'.\n");
                goto done3;
              };
            cleanup
              {
                print("Cleanup 3a.\n");
                function handler4(e : exception)
                  {
                    print("Handler 4: `", e.message, "'.\n");
                  };
                cleanup
                  {
                    print("Cleanup 4.\n");
                  };
                try
                  {
                    function handler5(e : exception)
                      {
                        print("Handler 5: `", e.message, "'.\n");
                      };
                    cleanup
                      {
                        print("Cleanup 5.\n");
                      };
                    try
                      {
                        function handler6(e : exception)
                          {
                            print("Handler 6: `", e.message, "'.\n");
                          };
                        cleanup
                          {
                            print("Cleanup 6.\n");
                          };
                        try
                          {
                            variable v2 : string;
                            v2 := 12;
                          } handle handler6;
                      } handle handler5;
                  } handle handler4;
                print("Cleanup 3b.\n");
              };
            try
              {
                variable v1 : integer := "string";
              } handle handler3;
          done3:
          } handle handler2;
      } handle handler1;
  done1:
  };


/* Next, we'll test the standard library throw() function. */

  {
    quark my_tag;

    function handler(e : exception)
      {
        print("Handler: `", e.message, "'.\n");
        if (e.tag == my_tag)
          {
            print("    my_field: `", e.my_field, "'.\n");
          };
        goto done;
      };
    try
      {
        throw(tag := my_tag, message := "My exception!",
              other := [my_field := 117]);
      } handle handler;
  done:
  };


/* Next, we'll test try-catch statements. */

  {
    try
      {
        variable x := "aaa" * 13;
      }
    catch
      {
        print("Caught: `", current_exceptions()[0].message, "'.\n");
      };
  };

  {
    try
      {
        cleanup
          {
            variable y := 13(17);
          };
        variable x := "aaa" * 13;
      }
    catch
      {
        print("Caught first: `", current_exceptions()[0].message, "'.\n");
        print("Caught second: `", current_exceptions()[1].message, "'.\n");
      };
  };


/* Now we'll try using a type based on a filter function. */

  {
    pure function a(x) returns boolean  (x == 17);
    print("16 in a? ", (16 in a), ".\n");
    print("17 in a? ", (17 in a), ".\n");
    print("18 in a? ", (18 in a), ".\n");
  };


/* Next, we'll try using an overloaded filter function. */

  {
    pure function b(x) returns boolean  (x == 17);
    pure function b(x : string) returns boolean  (x == "17");
    print("16 in b? ", (16 in b), ".\n");
    print("17 in b? ", (17 in b), ".\n");
    print("18 in b? ", (18 in b), ".\n");
    print("\"16\" in b? ", ("16" in b), ".\n");
    print("\"17\" in b? ", ("17" in b), ".\n");
    print("\"18\" in b? ", ("18" in b), ".\n");
  };


/* Next, we'll try some tests of Unicode functions from the standard library.
 */

/* The list of four characters used in this example is from the Unicode version
 * 5.1 specification document, which uses the same list of 4 as an example. */

function hex(to_convert : integer) returns string
  {
    if (to_convert == 0)
      {
        return "0";
      };

    variable result := "";
    variable remainder := to_convert;
    while (remainder != 0)
      {
        immutable mod := remainder % 16;
        immutable utf32 :=
                ((mod < 10) ? (mod + to_utf32('0')) :
                              ((mod - 10) + to_utf32('a')));
        result := from_utf32(utf32) ~ result;
        remainder -= mod;
        remainder /= 16;
      };
    return result;
  };

function prefixed_hex(to_convert : integer) returns string
  { return "0x" ~ hex(to_convert); };

function join(to_map : array[string], joiner : string) returns string
  {
    variable result := "";

    variable first := true;
    iterate (item; to_map)
      {
        if (first)
          { first := false; }
        else
          { result ~= joiner; };
        result ~= item;
      };
    return result;
  };

function apply(to_call, data : array) returns array
  {
    variable result := [];
    iterate (item; data)
      { result ~= [to_call(item)]; };
    return result;
  };

function flatten(to_flatten : array[array]) returns array
  {
    variable result := [];
    iterate (item; to_flatten)
      { result ~= item; };
    return result;
  };

  {
    immutable utf32 := [0x004d, 0x0430, 0x4e8c, 0x10302];

    print("UTF-8 of [0x004d, 0x0430, 0x4e8c, 0x10302]: [");
    immutable utf8 := to_utf8(string_from_utf32(utf32));
    print(join(apply(prefixed_hex, utf8), ", "));
    print("].\n");

    print("Converting back from UTF-8 to a string to UTF-32 gives: [");
    print(join(apply(prefixed_hex, to_utf32(string_from_utf8(utf8))), ", "));
    print("].\n");

    print("UTF-16 of [0x004d, 0x0430, 0x4e8c, 0x10302]: [");
    immutable utf16 := to_utf16(string_from_utf32(utf32));
    print(join(apply(prefixed_hex, utf16), ", "));
    print("].\n");

    print("Converting back from UTF-16 to a string to UTF-32 gives: [");
    print(join(apply(prefixed_hex, to_utf32(string_from_utf16(utf16))), ", "));
    print("].\n");

    print("UTF-8 by character of [0x004d, 0x0430, 0x4e8c, 0x10302]: [");
    immutable utf8_by_chars := apply(to_utf8, apply(from_utf32, utf32));
    print(join(apply(prefixed_hex, flatten(utf8_by_chars)), ", "));
    print("].\n");

    print("Converting back from UTF-8 to characters to UTF-32 gives: [");
    print(join(apply(prefixed_hex,
                     apply(to_utf32, apply(from_utf8, utf8_by_chars))), ", "));
    print("].\n");

    print("UTF-16 by character of [0x004d, 0x0430, 0x4e8c, 0x10302]: [");
    immutable utf16_by_chars := apply(to_utf16, apply(from_utf32, utf32));
    print(join(apply(prefixed_hex, flatten(utf16_by_chars)), ", "));
    print("].\n");

    print("Converting back from UTF-16 to a characters to UTF-32 gives: [");
    print(join(apply(prefixed_hex,
            apply(to_utf32, apply(from_utf16, utf16_by_chars))), ", "));
    print("].\n");
  };


/* Next, we'll try some scientific notation. */

print("1.000 = ", 1.000, ".\n");
print("1.001 = ", 1.001, ".\n");
print("0.3 = ", 0.3, ".\n");
print("12e0 = ", 12e0, ".\n");
print("12e1 = ", 12e1, ".\n");
print("12e2 = ", 12e2, ".\n");
print("12e3 = ", 12e3, ".\n");
print("12e4 = ", 12e4, ".\n");
print("12e+0 = ", 12e+0, ".\n");
print("12e+1 = ", 12e+1, ".\n");
print("12e+2 = ", 12e+2, ".\n");
print("12e+3 = ", 12e+3, ".\n");
print("12e+4 = ", 12e+4, ".\n");
print("12e-0 = ", 12e-0, ".\n");
print("12e-1 = ", 12e-1, ".\n");
print("12e-2 = ", 12e-2, ".\n");
print("12e-3 = ", 12e-3, ".\n");
print("12e-4 = ", 12e-4, ".\n");
print("1.2e0 = ", 1.2e0, ".\n");
print("0.5e10 = ", 0.5e10, ".\n");


/* Next, we'll try some tests of regular expressions. */

  {
    procedure test_string(to_test : string)
      {
        print("Testing `", to_test, "':\n");
        iterate (item;
                 [@@, @a*b@, @a+b@, @a@, @b@, @ab@, @ba@, @a.b@, @^a@, @^b@,
                  @a$@, @b$@, @ab|(ba)@, @^(ab|(ba))$@, @d[abc]+d@, @d[a-c]+d@,
                  @b\@b@])
          {
            if (to_test in item)
              { print("    YES    "); }
            else
              { print("    NO, not"); };
            print(" in @", pattern(item), "@\n");
          };
      };

    test_string("");
    test_string("aabb");
    test_string("ab");
    test_string("ba");
    test_string("d");
    test_string("bd");
    test_string("dd");
    test_string("dad");
    test_string("dbbd");
    test_string("ddd");
    test_string("b@b");
  };


/* And now we'll try a test of split(). */

  {
    print("split(@a.@, \"bbaaaaabccbabbbabd\") = [");
    variable first := true;
    iterate (item; split(@a.@, "bbaaaaabccbabbbabd"))
      {
        if (first)
          { first := false; }
        else
          { print(", "); };
        print("\"", item, "\"");
      };
    print("].\n");
  };


/* Next, we'll go through the various sorts of types and try some basic tests
 * of all of them. */

  {
    lepton my_lepton1[a : integer, b : string];
    pure function odd(x) returns boolean  (false);
    pure function odd(x : integer) returns boolean  ((x % 2) == 1);
    class my_class1(x)
      {
        function y() (x);
      };
    class my_class2(x : integer, y : string)
      {
        export;
        immutable a : integer := x;
        immutable b : string := y;
      };
    class my_class3(x : integer, y : string)
      {
        export;
        variable a : integer := x;
        immutable b : string := y;
      };
    immutable my_class4 := class(x : integer, y : string)
      {
        export;
        variable a : integer := x;
        immutable b : string := y;
      };

    procedure try_one(x)
      {
        iterate (item;
                [[type {}, "nothing"],
                 [type !{}, "anything"],
                 [integer, "integer"],
                 [rational, "rational"],
                 [regular_expression, "regular_expression"],
                 [any_quark, "any_quark"],
                 [any_lepton, "any_lepton"],
                 [lepton_key, "lepton_key"],
                 [jump_target, "jump_target"],
                 [object, "object"],
                 [tagalong_key, "tagalong_key"],
                 [any_lock, "any_lock"],
                 [string, "string"],
                 [character, "character"],
                 [type {17, 83, 57}, "{17, 83, 57}"],
                 [type !{17, 83, 57}, "!{17, 83, 57}"],
                 [type rational & !integer, "rational & !integer"],
                 [type lepton_key | integer, "lepton_key | integer"],
                 [type {18, 20, 40, 80} ^ !{18, 20, 57},
                  "{18, 20, 40, 80} ^ !{18, 20, 57}"],
                 [type array, "array"],
                 [type array[integer], "array[integer]"],
                 [type string[17], "string[17]"],
                 [type string[13...18], "string[13...18]"],
                 [type [18...83], "[18...83]"],
                 [type *integer, "*integer"],
                 [type *.integer, "*.integer"],
                 [type +integer, "+integer"],
                 [type +.integer, "+.integer"],
                 [type *+integer, "*+integer"],
                 [type *+.integer, "*+.integer"],
                 [type type integer, "type integer"],
                 [type integer --> string, "integer --> string"],
                 [type integer <-- (integer, a : integer, integer := *),
                  "integer <-- (integer, a : integer, integer := *)"],
                 [type fields[], "fields[]"],
                 [type fields[...], "fields[...]"],
                 [type fields[a : integer, b : string],
                  "fields[a : integer, b : string]"],
                 [type fields[a : integer, b : string, ...],
                  "fields[a : integer, b : string, ...]"],
                 [type lepton my_lepton1[a : integer, b : string, ...],
                  "lepton my_lepton1[a : integer, b : string, ...]"],
                 [type multiset[a : integer, b : string],
                  "multiset[a : integer, b : string]"],
                 [type multiset[a : integer, b : string, ...],
                  "multiset[a : integer, b : string, ...]"],
                 [type interface[a : integer, b :- string],
                  "interface[a : integer, b :- string]"],
                 [type [...], "[...]"],
                 [type [a : integer, b : string], "[a : integer, b : string]"],
                 [type [a : integer, b : string, ...],
                  "[a : integer, b : string, ...]"],
                 [type [integer, b : string, ...],
                  "[integer, b : string, ...]"],
                 [type [string, string, ...], "[string, string, ...]"],
                 [type @a..@, "@a..@"],
                 [type odd, "odd"],
                 [type <<pure function(x) returns boolean
                           ((x in integer) && ((x % 2) == 1))>>,
                  "inline odd"],
                 [my_class1, "my_class1"],
                 [my_class4, "my_class4"],
                 [any_class, "any_class"]])
          {
            if (x in <<item[0]>>)
              { print("    YES    "); }
            else
              { print("    NO, not"); };
            print(" in ", item[1]);
            if (!(x in <<item[0]>>))
              { print(" because ", why_not_in(x, type <<item[0]>>)); };
            print("\n");
          };
      };

    procedure try_one_function_limited(x)
      {
        iterate (item;
                [[type integer <-- (integer, a : integer, integer := *),
                  "integer <-- (integer, a : integer, integer := *)"]])
          {
            if (x in <<item[0]>>)
              { print("    YES    "); }
            else
              { print("    NO, not"); };
            print(" in ", item[1]);
            if (!(x in <<item[0]>>))
              { print(" because ", why_not_in(x, type <<item[0]>>)); };
            print("\n");
          };
      };

    print("Testing 1:\n");
    try_one(1);

    print("Testing `abc':\n");
    try_one("abc");

    print("Testing 2.7:\n");
    try_one(2.7);

    print("Testing @(a|b)c@:\n");
    try_one(@(a|b)c@);

    quark my_quark;
    print("Testing my_quark:\n");
    try_one(my_quark);

    print("Testing my_lepton1[a := 15, b := \"efg\"]:\n");
    try_one(my_lepton1[a := 15, b := "efg"]);

    lepton my_lepton2[a : integer, b : string];
    print("Testing my_lepton2[a := 15, b := \"efg\"]:\n");
    try_one(my_lepton2[a := 15, b := "efg"]);

    print("Testing my_lepton1:\n");
    try_one(my_lepton1);

  my_jump_target:
    print("Testing my_jump_target:\n");
    try_one(my_jump_target);

    immutable my_object1 := my_class1(8338);
    print("Testing my_object1:\n");
    try_one(my_object1);

    immutable my_object2 := my_class2(8338, "aaa");
    print("Testing my_object2:\n");
    try_one(my_object2);

    immutable my_object3 := my_class3(8338, "aaa");
    print("Testing my_object3:\n");
    try_one(my_object3);

    immutable my_object4 := my_class4(8338, "aaa");
    print("Testing my_object4:\n");
    try_one(my_object4);

    print("Testing my_class4:\n");
    try_one(my_class4);

    tagalong my_tagalong;
    print("Testing my_tagalong:\n");
    try_one(my_tagalong);

    lock my_lock;
    print("Testing my_lock:\n");
    try_one(my_lock);

    print("Testing 'q':\n");
    try_one('q');

    print("Testing 82:\n");
    try_one(82);

    print("Testing 83:\n");
    try_one(83);

    print("Testing 84:\n");
    try_one(84);

    print("Testing 17:\n");
    try_one(17);

    print("Testing 18:\n");
    try_one(18);

    print("Testing 20:\n");
    try_one(20);

    print("Testing 40:\n");
    try_one(40);

    print("Testing 80:\n");
    try_one(80);

    print("Testing 57:\n");
    try_one(57);

    print("Testing <<(\"a\" --> 13), (\"b\" --> 17), (\"c\" --> 75)>>:\n");
    try_one(<<("a" --> 13), ("b" --> 17), ("c" --> 75)>>);

    print("Testing <<(13 --> \"a\"), (17 --> \"b\"), (75 --> \"c\")>>:\n");
    try_one(<<(13 --> "a"), (17 --> "b"), (75 --> "c")>>);

    print("Testing <<>>:\n");
    try_one(<<>>);

    print("Testing <<(-57 --> 18), (4 --> 3)>>:\n");
    try_one(<<(-57 --> 18), (4 --> 3)>>);

    print("Testing <<(5 --> \"abc\"), (7 --> \"seven\")>>:\n");
    try_one(<<(5 --> "abc"), (7 --> "seven")>>);

    print("Testing <<(5 --> \"five\"), (15 --> \"fifteen\")>>:\n");
    try_one(<<(5 --> "five"), (15 --> "fifteen")>>);

    print("Testing <<(13 --> \"thirteen\"), (15 --> \"fifteen\")>>:\n");
    try_one(<<(13 --> "thirteen"), (15 --> "fifteen")>>);

    print("Testing <<(13 --> \"thirteen\"), (17 --> \"seventeen\")>>:\n");
    try_one(<<(13 --> "thirteen"), (17 --> "seventeen")>>);

    print("Testing <<(13 --> \"thirteen\"), (18 --> \"eighteen\")>>:\n");
    try_one(<<(13 --> "thirteen"), (18 --> "eighteen")>>);

    print("Testing null:\n");
    try_one(null);

    variable x1 : integer;
    print("Testing &x1 (variable x1 : integer):\n");
    try_one(&x1);

    immutable x2 : integer;
    print("Testing &x2 (immutable x2 : integer):\n");
    try_one(&x2);

    variable x3 : [0...15];
    print("Testing &x3 (variable x3 : [0...15]):\n");
    try_one(&x3);

    immutable x4 : [0...15];
    print("Testing &x4 (immutable x4 : [0...15]):\n");
    try_one(&x4);

    variable x5 : rational;
    print("Testing &x5 (variable x5 : rational):\n");
    try_one(&x5);

    immutable x6 : rational;
    print("Testing &x6 (immutable x6 : rational):\n");
    try_one(&x6);

    print("Testing type [0...15]:\n");
    try_one(type [0...15]);

    print("Testing integer:\n");
    try_one(integer);

    print("Testing rational:\n");
    try_one(rational);

    function f1(: integer, a : integer, : integer := 15) returns integer
      { return (a + 12); };
    print("Testing f1(: integer, a : integer, : integer := 15) returns " ~
          "integer:\n");
    try_one(f1);

    function f2(: rational, a : integer, : integer := 15) returns integer
      { return (a + 12); };
    print("Testing f2(: rational, a : integer, : integer := 15) returns " ~
          "integer:\n");
    try_one_function_limited(f2);

    function f3(: [0...15], a : integer, : integer := 15) returns integer
      { return (a + 12); };
    print("Testing f3(: [0...15], a : integer, : integer := 15) returns " ~
          "integer:\n");
    try_one_function_limited(f3);

    function f4(b : integer, a : integer, : integer := 15) returns integer
      { return (a + 12); };
    print("Testing f4(b : integer, a : integer, : integer := 15) returns " ~
          "integer:\n");
    try_one_function_limited(f4);

    function f5(: integer, : integer, : integer := 15) returns integer
      { return (15 + 12); };
    print("Testing f5(: integer, : integer, : integer := 15) returns " ~
          "integer:\n");
    try_one_function_limited(f5);

    function f6(a : integer, : integer, : integer := 15) returns integer
      { return (a + 12); };
    print("Testing f6(a : integer, : integer, : integer := 15) returns " ~
          "integer:\n");
    try_one_function_limited(f6);

    function f7(: integer, a : integer, : integer) returns integer
      { return (a + 12); };
    print("Testing f7(: integer, a : integer, : integer) returns integer:\n");
    try_one_function_limited(f7);

    function f8(: integer, a : integer, : integer := 15, b : integer := 17)
            returns integer
      { return (a + 12); };
    print("Testing f8(: integer, a : integer, : integer := 15, " ~
          "b : integer := 17) returns integer:\n");
    try_one_function_limited(f8);

    function f9(: integer, a : integer, : integer := 15) returns rational
      { return (a + 12); };
    print("Testing f9(: integer, a : integer, : integer := 15) returns " ~
          "rational:\n");
    try_one_function_limited(f9);

    function f10(: integer, a : integer, : integer := 15) returns [0...11]
      { return (a % 12); };
    print("Testing f10(: integer, a : integer, : integer := 15) returns " ~
          "[0...11]:\n");
    try_one_function_limited(f10);

    function f11(: integer, a : integer, : integer := 15) returns integer
      { return (a % 12); };
    function f11(: [0...15], a : integer, : integer := 15) returns rational
      { return (a + 1.2); };
    print("Testing f11() (overloaded, doesn't always return integer):\n");
    try_one_function_limited(f11);

    function f12(: [0...75], a : integer, : integer := 15) returns rational
      { return (a + 0.12); };
    function f12(: integer, a : integer, : integer := 15) returns integer
      { return (a % 12); };
    function f12(: [0...15], a : integer, : integer := 15) returns integer
      { return (a + 1.2); };
    print("Testing f12() (overloaded, always return integer):\n");
    try_one_function_limited(f12);

    print("Testing []:\n");
    try_one([]);

    print("Testing [\"aaa\"]:\n");
    try_one(["aaa"]);

    print("Testing [\"aaa\", \"bbb\", \"ccc\"]:\n");
    try_one(["aaa", "bbb", "ccc"]);

    print("Testing [a := 13]:\n");
    try_one([a := 13]);

    print("Testing [a := 13, b := \"abc\"]:\n");
    try_one([a := 13, b := "abc"]);

    print("Testing [a := 13, b := \"abc\", c := \"def\"]:\n");
    try_one([a := 13, b := "abc", c := "def"]);

    print("Testing [b := \"abc\", c := \"def\", a := 13]:\n");
    try_one([b := "abc", c := "def", a := 13]);

    print("Testing [a := 13, b := 19, c := \"def\"]:\n");
    try_one([a := 13, b := 19, c := "def"]);

    variable x7;
    x7.a := 13;
    print("Testing x7 (a := 13):\n");
    try_one(x7);

    x7.b := 19;
    print("Testing x7 (a := 13, b := 19):\n");
    try_one(x7);

    x7.b := "nineteen";
    print("Testing x7 (a := 13, b := \"nineteen\"):\n");
    try_one(x7);

    x7.c := 58;
    print("Testing x7 (a := 13, b := \"nineteen\", c := 58):\n");
    try_one(x7);
  };


/* We'll next try a recursive interface type using a filter function for the
 * recursion. */

  {
    immutable linked_interface := type
            interface
              [
                next : *.<<pure function(x) returns boolean
                             (x in linked_interface)>>
              ];

    lepton linked_lepton
      [
        next : *.<<pure function(x) returns boolean (x in linked_interface)>>
      ];

    variable a : linked_interface := linked_lepton[next := null];
    variable b : linked_interface := linked_lepton[next := &a];
    variable c : linked_interface := linked_lepton[next := &b];

    if (linked_lepton[next := null] in linked_interface)
      { print("YES, linked_lepton[next := null] in linked_interface.\n"); }
    else
      { print("NO, linked_lepton[next := null] not in linked_interface.\n"); };

    if (a in linked_interface)
      { print("YES, a in linked_interface.\n"); }
    else
      { print("NO, a not in linked_interface.\n"); };

    if (b in linked_interface)
      { print("YES, b in linked_interface.\n"); }
    else
      { print("NO, b not in linked_interface.\n"); };

    if (c in linked_interface)
      { print("YES, c in linked_interface.\n"); }
    else
      { print("NO, c not in linked_interface.\n"); };
  };


/* Next, we'll try the same thing but using the ``lazy'' keyword. */

  {
    immutable linked_interface := type
            interface
              [
                next : *.lazy linked_interface
              ];

    lepton linked_lepton
      [
        next : *.lazy linked_interface
      ];

    variable a : linked_interface := linked_lepton[next := null];
    variable b : linked_interface := linked_lepton[next := &a];
    variable c : linked_interface := linked_lepton[next := &b];

    if (linked_lepton[next := null] in linked_interface)
      { print("YES, linked_lepton[next := null] in linked_interface.\n"); }
    else
      { print("NO, linked_lepton[next := null] not in linked_interface.\n"); };

    if (a in linked_interface)
      { print("YES, a in linked_interface.\n"); }
    else
      { print("NO, a not in linked_interface.\n"); };

    if (b in linked_interface)
      { print("YES, b in linked_interface.\n"); }
    else
      { print("NO, b not in linked_interface.\n"); };

    if (c in linked_interface)
      { print("YES, c in linked_interface.\n"); }
    else
      { print("NO, c not in linked_interface.\n"); };
  };


/* Next, we'll try a lazy lepton reference. */

  {
    lepton linked_lepton
      [
        next : *.lazy linked_lepton
      ];

    variable a : linked_lepton := linked_lepton[next := null];
    variable b : linked_lepton := linked_lepton[next := &a];
    variable c : linked_lepton := linked_lepton[next := &b];

    if (linked_lepton[next := null] in linked_lepton)
      { print("YES, linked_lepton[next := null] in linked_lepton.\n"); }
    else
      { print("NO, linked_lepton[next := null] not in linked_lepton.\n"); };

    if (a in linked_lepton)
      { print("YES, a in linked_lepton.\n"); }
    else
      { print("NO, a not in linked_lepton.\n"); };

    if (b in linked_lepton)
      { print("YES, b in linked_lepton.\n"); }
    else
      { print("NO, b not in linked_lepton.\n"); };

    if (c in linked_lepton)
      { print("YES, c in linked_lepton.\n"); }
    else
      { print("NO, c not in linked_lepton.\n"); };
  };


/* Now we'll test for a bug in early versions of SalmonEye. */

  {
    immutable x := string;

    function a(x) returns x  ("x: `" ~ x ~ "'");

    print("a(\"hello\"): ", a("hello"), ".\n");
  };


/* Next, we'll try testing ``single'' statements. */

  {
    lock my_lock;

    single
      { print("Single 1.\n"); };
    single(my_lock)
      { print("Single 2.\n"); };
    single(my_lock)
      { print("Single 3.\n"); };
    single(context_switching)
      { print("Single 4.\n"); };
  };


/* And now we'll try testing ``single'' modifiers on variable declarations. */

  {
    lock my_lock;
    single variable v1;
    single(my_lock) variable v2;

    v1 := 23;
    v2 := v1 + v1 + 17;
    print("v2: ", v2, ".\n");
  };


/* Next, we'll try testing ``single'' modifiers on routine declarations. */

  {
    lock my_lock;
    single procedure p1()  { print("p1().\n"); };
    single(my_lock) procedure p2()  { print("p2().\n"); };

    print("Before p1().\n");
    p1();
    print("After p1().\n");

    print("Before p2().\n");
    p2();
    print("After p2().\n");
  };


/* Next, we'll try testing ``single'' modifiers on tagalong declarations. */

  {
    lock my_lock;
    single tagalong t1;
    single(my_lock) tagalong t2;
    variable v1;

    v1 := 15;
    v1..t1 := 23;
    v1..t2 := v1..t1 + v1..t1 + 17;
    print("v1..t2: ", v1..t2, ".\n");
  };


/* Next, we'll try testing ``single'' modifiers on lock declarations. */

  {
    lock my_lock1;
    single(my_lock1) lock my_lock2;
    single(my_lock2) procedure p()  { print("p().\n"); };

    print("Before p().\n");
    p();
    print("After p().\n");
  };


/* Next, we'll try some more lepton declarations. */

  {
    lepton l1[x : integer, y : string];
    lepton l2[x : integer, y : string];
    variable v1 : l1;
    variable v2 : l2;

    v1 := l1[x := 15, y := "fifteen"];
    v2 := l2[x := 17, y := "seventeen"];
    print("v1.x: ", v1.x, ".\n");
    print("v2.x: ", v2.x, ".\n");
    v1.x := 23;
    v2.x := v1.x + v1.x + 17;
    print("v1.x: ", v1.x, ".\n");
    print("v2.x: ", v2.x, ".\n");
  };


/* Next, we'll test overloading through multiple scopes. */
  {
    procedure p1(x : {1, 2})
      { print("p1() a.\n"); };
    procedure p1(x : {3, 4})
      { print("p1() b.\n"); };

      {
        procedure p1(x : {5, 6})
          { print("p1() c.\n"); };
        procedure p1(x : {7, 8})
          { print("p1() d.\n"); };

          {
            procedure p1(x : {9, 10})
              { print("p1() e.\n"); };
            procedure p1(x : {11, 12})
              { print("p1() f.\n"); };

            p1(1);
            p1(2);
            p1(3);
            p1(4);
            p1(5);
            p1(6);
            p1(7);
            p1(8);
            p1(9);
            p1(10);
            p1(11);
            p1(12);
          };
      };
  };


/* Next, we'll test ``static'' modifiers on variable declarations. */

  {
    function f1()
      {
        print("outer f1().\n");
        return 1;
      };

    procedure p1()
      {
        function f1()
          {
            print("inner f1().\n");
            return 1;
          };
        static variable x := f1();

        print("x is ", x, ".\n");
        ++x;
      };
    p1();
    p1();
    p1();

    procedure p2()
      {
        static function f1()
          {
            print("inner f1().\n");
            return 1;
          };
        static variable x := f1();

        print("x is ", x, ".\n");
        ++x;
      };
    p2();
    p2();
    p2();
  };


/* Next, we'll test ``construct'' expressions. */

  {
    class my_class(x : integer)
      {
        procedure p()  { print("x: ", x, ".\n"); };
      };
    immutable x := construct my_class(3);
    immutable y := construct my_class(17);
    x->p();
    y->p();
  };


/* Next, we'll test operator overloading. */

  {
    include "complex.salm";

    variable c1 : complex;
    variable c2 : complex;
    variable c3 : complex;

    c1 := complex(52, 73);
    print("c1: ", c1, ".\n");
    print("c1.operator+(1, reversed := false): ",
          c1.operator+(1, reversed := false), ".\n");
    print("c1 + 1: ", c1 + 1, ".\n");
    c2 := complex(11, 22);
    print("c2: ", c2, ".\n");
    print("c1 + c2: ", c1 + c2, ".\n");
    print("c1 - 1: ", c1 - 1, ".\n");
    print("c1 - c2: ", c1 - c2, ".\n");
    print("c1 - i: ", c1 - i, ".\n");
    print("i * i: ", i * i, ".\n");
    print("i / 2: ", i / 2, ".\n");
    c1 := complex(2, 3);
    c2 := complex(5, 7);
    print("c1: ", c1, ".\n");
    print("c2: ", c2, ".\n");
    print("c1 * c2: ", c1 * c2, ".\n");
    c3 := c1 * c2;
    print("c3: ", c3, ".\n");
    print("c3 / c1: ", c3 / c1, ".\n");
    print("c3 / c2: ", c3 / c2, ".\n");
    print("(c3 / c2) == c1: ", (c3 / c2) == c1, ".\n");
    print("(c3 / c2) != c1: ", (c3 / c2) != c1, ".\n");
    print("i == 1: ", i == 1, ".\n");
    print("i != 1: ", i != 1, ".\n");
    print("+c3: ", +c3, ".\n");
    print("-c3: ", -c3, ".\n");
    print("2 + 3i: ", 2 + (3 * i), ".\n");
    print("2 - 3i: ", 2 - (3 * i), ".\n");
    print("1 / i: ", 1 / i, ".\n");
    print("1 == (i / i): ", 1 == (i / i), ".\n");
    print("1 != (i / i): ", 1 != (i / i), ".\n");

      {
        function operator+(x : rational, y : rational) returns rational
          { return (2 * x) - (-3 * y); };

        print("Funny 1 + 1: ", 1 + 1, ".\n");
        variable v1 := 1;
        print("v1: ", v1, ".\n");
        ++v1;
        print("v1: ", v1, ".\n");
        v1 += 2;
        print("v1: ", v1, ".\n");
      };

      {
        function operator+(x : rational) returns rational (x + 3);

        print("Funny +1: ", +1, ".\n");
        print("Funny +72: ", +72, ".\n");
      };

      {
        /* Override the :: operator to round to the closest integer instead of
         * rouding down when converting from a rational to an integer. */

        static function old_conversion(to_convert : rational) returns integer
          { return to_convert :: integer; };
        function operator::(to_convert : rational, : {type integer})
                returns integer
          {
            immutable down := old_conversion(to_convert);
            variable fraction := to_convert - down;
            if (fraction < 0)
              {
                if (fraction < -0.5)
                  { return down - 1; }
                else
                  { return down; };
              }
            else
              {
                if (fraction > 0.5)
                  { return down + 1; }
                else
                  { return down; };
              };
          };

        print("1 :: integer: ", 1 :: integer, ".\n");
        print("1.2 :: integer: ", 1.2 :: integer, ".\n");
        print("1.5 :: integer: ", 1.5 :: integer, ".\n");
        print("1.6 :: integer: ", 1.6 :: integer, ".\n");
        print("1.9 :: integer: ", 1.9 :: integer, ".\n");
        print("-1.2 :: integer: ", -1.2 :: integer, ".\n");
        print("-1.5 :: integer: ", -1.5 :: integer, ".\n");
        print("-1.6 :: integer: ", -1.6 :: integer, ".\n");
        print("-1.9 :: integer: ", -1.9 :: integer, ".\n");
      };

      {
        class c1(x : rational)
          {
            function operator::(: {type string}) returns string
              { return "~" ~ sprint(x) ~ "~"; };
            function operator::(: {type integer}) returns integer
              { return (x + 10) :: integer; };
          };

        print("c1(5) :: string: ", c1(5) :: string, ".\n");
        print("c1(5) :: integer: ", c1(5) :: integer, ".\n");
      };

      {
        function operator()(x : integer, y : [...]) returns string
          { return "|" ~ sprint(x) ~ "|(" ~ sprint(y) ~ ")"; };
        procedure operator()(x : string, y : [...])
          { print("called |", x, "|(", y, ").\n"); };

        print("1(17): ", 1(17), ".\n");
        print("2(\"abc\", x := 18): ", 2("abc", x := 18), ".\n");
        "trout"("rainbow");
      };

      {
        class c(x)
          {
            function operator()(y : [...]) returns string
              { return "|" ~ sprint(x) ~ "|(" ~ sprint(y) ~ ")"; };
          };
        class d(x)
          {
            procedure operator()(y : [...])
              { print("called |", x, "|(", y, ").\n"); };
          };

        immutable c1 := c(1);
        immutable c2 := c(2);
        immutable d1 := d(1);
        immutable d2 := d(2);
        print("c1(14, n := 15): ", c1(14, n := 15), ".\n");
        print("c2(14, n := 15): ", c2(14, n := 15), ".\n");
        d1(14, n := 15);
        d2(14, n := 15);
      };

      {
        class a()
          {
            function operator*() returns integer
              {
                print("a: Read through operator*() called.\n");
                return 5;
              };
            procedure operator*(new_value : integer)
              {
                print("a: Write of ", new_value,
                      " through operator*() called.\n");
              };
          };

        immutable b := a();
        print("*b: ", *b, ".\n");
        *b := 10;
        *b += 10;

        print("(&(*b)) in +integer: ", (&(*b)) in +integer, ".\n");
        print("(&(*b)) in +rational: ", (&(*b)) in +rational, ".\n");
        print("(&(*b)) in +[0...4]: ", (&(*b)) in +[0...4], ".\n");
        print("(&(*b)) in *integer: ", (&(*b)) in *integer, ".\n");
        print("(&(*b)) in *rational: ", (&(*b)) in *rational, ".\n");
        print("(&(*b)) in *[0...4]: ", (&(*b)) in *[0...4], ".\n");
      };

      {
        function operator*(base : integer) returns integer
          {
            print("Read of ", base, " through operator*() called.\n");
            return base + 55;
          };
        procedure operator*(base : integer, new_value : integer)
          {
            print("Write of ", new_value, " to ", base,
                  " through operator*() called.\n");
          };

        print("*15: ", *15, ".\n");
        *19 := 10;
        *23 += 10;

        print("(&(*173)) in +integer: ", (&(*173)) in +integer, ".\n");
        print("(&(*173)) in +rational: ", (&(*173)) in +rational, ".\n");
        print("(&(*173)) in +[0...4]: ", (&(*173)) in +[0...4], ".\n");
        print("(&(*173)) in *integer: ", (&(*173)) in *integer, ".\n");
        print("(&(*173)) in *rational: ", (&(*173)) in *rational, ".\n");
        print("(&(*173)) in *[0...4]: ", (&(*173)) in *[0...4], ".\n");
      };

      {
        class a()
          {
            function operator->(field : string) returns integer
              {
                print("a: Read of field `", field,
                      "' through operator->() called.\n");
                return 5;
              };
            procedure operator->(field : string, new_value : integer)
              {
                print("a: Write of ", new_value, " to field `", field,
                      "' through operator->() called.\n");
              };
          };

        immutable b := a();
        print("b->c: ", b->c, ".\n");
        b->d := 10;
        b->e += 10;

        print("(&(b->f)) in +integer: ", (&(b->f)) in +integer, ".\n");
        print("(&(b->f)) in +rational: ", (&(b->f)) in +rational, ".\n");
        print("(&(b->f)) in +[0...4]: ", (&(b->f)) in +[0...4], ".\n");
        print("(&(b->f)) in *integer: ", (&(b->f)) in *integer, ".\n");
        print("(&(b->f)) in *rational: ", (&(b->f)) in *rational, ".\n");
        print("(&(b->f)) in *[0...4]: ", (&(b->f)) in *[0...4], ".\n");
      };

      {
        function operator->(base : integer, field : string) returns integer
          {
            print("Read of field `", field, "' of ", base,
                  " through operator->() called.\n");
            return base + 55;
          };
        procedure operator->(base : integer, field : string,
                             new_value : integer)
          {
            print("Write of ", new_value, " to field `", field, "' of ", base,
                  " through operator->() called.\n");
          };

        print("15->aaa: ", 15->aaa, ".\n");
        19->bbb := 10;
        23->ccc += 10;

        print("(&(34->ddd)) in +integer: ", (&(34->ddd)) in +integer, ".\n");
        print("(&(34->ddd)) in +rational: ", (&(34->ddd)) in +rational, ".\n");
        print("(&(34->ddd)) in +[0...4]: ", (&(34->ddd)) in +[0...4], ".\n");
        print("(&(34->ddd)) in *integer: ", (&(34->ddd)) in *integer, ".\n");
        print("(&(34->ddd)) in *rational: ", (&(34->ddd)) in *rational, ".\n");
        print("(&(34->ddd)) in *[0...4]: ", (&(34->ddd)) in *[0...4], ".\n");
      };

      {
        class a(x : integer)
          {
            function operator[](key : integer) returns integer
              {
                print("a: Read of element ", key,
                      " through operator[]() called.\n");
                return x + key;
              };
            function operator[](lower : integer, upper : integer)
                    returns array[integer]
              {
                variable result : array[integer] := [];

                print("a: Read of elements ", lower, " to ", upper,
                      " through operator[]() called.\n");

                for (i; lower; i <= upper)
                    result ~= [x + i];;

                return result;
              };
            function operator[](star : {"*"}) returns array[integer]
              {
                print("a: Read of all elements through operator[]() " ~
                      "called.\n");
                return [x, x * x];
              };
            function operator[](key : integer, new_value : integer) returns a
              {
                print("a: Write of ", new_value, " to element ", key,
                      " through operator[]() called.\n");
                return a(x + key + new_value);
              };
          };

        variable b := a(10);
        print("b[12]: ", b[12], ".\n");
        print("b[15]: ", b[15], ".\n");
        b[3] := 5;
        print("b[12]: ", b[12], ".\n");
        print("b[15]: ", b[15], ".\n");
        print("b[12...15]: ", b[12...15], ".\n");
        print("b[*]: ", b[*], ".\n");
        b[12...15] := [10, 20, 30, 40];
        b[*] := [5];
      };

      {
        class a(x : integer)
          {
            function operator[](key : integer) returns integer
              {
                print("a: Read of element ", key,
                      " through operator[]() called.\n");
                return x + key;
              };
            function operator[](lower : integer, upper : integer)
                    returns array[integer]
              {
                variable result : array[integer] := [];

                print("a: Read of elements ", lower, " to ", upper,
                      " through operator[]() called.\n");

                for (i; lower; i <= upper)
                    result ~= [x + i];;

                return result;
              };
            function operator[](star : {"*"}) returns array[integer]
              {
                print("a: Read of all elements through operator[]() " ~
                      "called.\n");
                return [x, x * x];
              };
            function operator[](key : integer, new_value : integer) returns a
              {
                print("a: Write of ", new_value, " to element ", key,
                      " through operator[]() called.\n");
                return a(x + key + new_value);
              };
            function operator[](lower : integer, upper : integer,
                                new_value : array[integer]) returns a
              {
                print("a: Write of ", new_value, " to elements ", lower,
                      " to ", upper, " through operator[]() called.\n");

                return a(x + lower + upper);
              };
            function operator[](star : {"*"}, new_value : array[integer])
                    returns a
              {
                print("a: Write of ", new_value,
                      " to all elements through operator[]() called.\n");
                return a(x * x);
              };
          };

        variable b := a(10);
        b[12...15] := [10, 20, 30, 40];
        b[*] := [5];
      };

      {
        function operator[](x : integer, key : integer) returns integer
          {
            print("Read of element ", key, " of ", x,
                  " through operator[]() called.\n");
            return x + key;
          };
        function operator[](x : integer, lower : integer, upper : integer)
                returns array[integer]
          {
            variable result : array[integer] := [];

            print("Read of elements ", lower, " to ", upper, " of ", x,
                  " through operator[]() called.\n");

            for (i; lower; i <= upper)
                result ~= [x + i];;

            return result;
          };
        function operator[](x : integer, star : {"*"}) returns array[integer]
          {
            print("Read of all elements of ", x,
                  " through operator[]() called.\n");
            return [x, x * x];
          };
        function operator[](x : integer, key : integer, new_value : integer)
                returns integer
          {
            print("Write of ", new_value, " to element ", key, " of ", x,
                  " through operator[]() called.\n");
            return (x + key + new_value);
          };

        variable b : integer := 10;
        print("10[12]: ", 10[12], ".\n");
        print("10[15]: ", 10[15], ".\n");
        print("b: ", b, ".\n");
        b[3] := 5;
        print("b: ", b, ".\n");
        print("10[12]: ", 10[12], ".\n");
        print("10[15]: ", 10[15], ".\n");
        print("10[12...15]: ", 10[12...15], ".\n");
        print("10[*]: ", 10[*], ".\n");
        print("b: ", b, ".\n");
        b[12...15] := [10, 20, 30, 40];
        print("b: ", b, ".\n");
        b[*] := [5];
        print("b: ", b, ".\n");
      };

      {
        function operator[](x : integer, key : integer) returns integer
          {
            print("Read of element ", key, " of ", x,
                  " through operator[]() called.\n");
            return x + key;
          };
        function operator[](x : integer, lower : integer, upper : integer)
                returns array[integer]
          {
            variable result : array[integer] := [];

            print("Read of elements ", lower, " to ", upper, " of ", x,
                  " through operator[]() called.\n");

            for (i; lower; i <= upper)
                result ~= [x + i];;

            return result;
          };
        function operator[](x : integer, star : {"*"}) returns array[integer]
          {
            print("Read of all elements of ", x,
                  " through operator[]() called.\n");
            return [x, x * x];
          };
        function operator[](x : integer, key : integer, new_value : integer)
                returns integer
          {
            print("Write of ", new_value, " to element ", key, " of ", x,
                  " through operator[]() called.\n");
            return (x + key + new_value);
          };
        function operator[](x : integer, lower : integer, upper : integer,
                            new_value : array[integer]) returns integer
          {
            print("Write of ", new_value, " to elements ", lower, " to ",
                  upper, " of ", x, " through operator[]() called.\n");

            return (x + lower + upper);
          };
        function operator[](x : integer, star : {"*"},
                            new_value : array[integer]) returns integer
          {
            print("Write of ", new_value, " to all elements of ", x,
                  " through operator[]() called.\n");
            return (x * x);
          };

        variable b : integer := 10;
        print("b: ", b, ".\n");
        b[12...15] := [10, 20, 30, 40];
        print("b: ", b, ".\n");
        b[*] := [5];
        print("b: ", b, ".\n");
      };

      {
        function operator[](value, lower : integer, upper : integer)
          { return ["Broadcom"]; };
        function operator[](value, lower : integer, upper : integer, new_value)
          { return ["Broadcom", new_value]; };
        variable v1 := 17;
        v1[15...18] := 18;
        print("v1: ", v1, ".\n");
      };
  };


/* And now we'll try testing some arithmetic. */

print("12 > 5: ", 12 > 5, ".\n");
print("-12 > 5: ", -12 > 5, ".\n");
print("-0.2 > 0.5: ", -0.2 > 0.5, ".\n");
print("-0.8 > 0.5: ", -0.8 > 0.5, ".\n");
print("-1.8 - -1: ", -1.8 - -1, ".\n");


/* And now we'll try testing lookup expressions. */

  {
    variable m := [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

    print("m: ", m, ".\n");
    print("m[0]: ", m[0], ".\n");
    print("m[1]: ", m[1], ".\n");
    print("m[2]: ", m[2], ".\n");
    print("m[0][0]: ", m[0][0], ".\n");
    print("m[0, 0]: ", m[0, 0], ".\n");
    print("m[1][2]: ", m[1][2], ".\n");
    print("m[1, 2]: ", m[1, 2], ".\n");
    m[1, 2] := 66;
    print("m: ", m, ".\n");
    m[1][2] := 77;
    print("m: ", m, ".\n");
    print("m[*]: ", m[*], ".\n");
    print("m[0, *]: ", m[0, *], ".\n");
    print("m[2, *]: ", m[2, *], ".\n");
    print("m[*, 0]: ", m[*, 0], ".\n");
    print("m[*, 2]: ", m[*, 2], ".\n");
    print("m[0, 0...1]: ", m[0, 0...1], ".\n");
    print("m[2, 1...2]: ", m[2, 1...2], ".\n");
    print("m[0...1, 0]: ", m[0...1, 0], ".\n");
    print("m[1...2, 2]: ", m[1...2, 2], ".\n");
    print("m[0, 1...7]: ", m[0, 1...7], ".\n");
    print("m[0, 5...7]: ", m[0, 5...7], ".\n");
    print("[100, 110, 120][1...2]: ", [100, 110, 120][1...2], ".\n");
    print("[100, 110, 120][1...7]: ", [100, 110, 120][1...7], ".\n");
    print("[100, 110, 120][5...7]: ", [100, 110, 120][5...7], ".\n");
    print("[][5...7]: ", [][5...7], ".\n");
    m[0, *] := [100, 101, 102];
    print("m: ", m, ".\n");
    m[*, 2] := [200, 201, 202];
    print("m: ", m, ".\n");
    m[1...2, 1] := [300, 301];
    print("m: ", m, ".\n");
    m[1, 1...2] := [400, 401];
    print("m: ", m, ".\n");
    m[1, *].a := ["a1", "a2", "a3"];
    print("m: ", m, ".\n");
    m := 10;
    print("m: ", m, ".\n");
    m[0] := 10;
    print("m: ", m, ".\n");
    m[3] := 33;
    print("m: ", m, ".\n");
  };


/* Next, we'll try testing lookup expressions with a typed base. */

  {
    variable m : integer[3][3] := [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

    print("m: ", m, ".\n");
    print("m[0]: ", m[0], ".\n");
    print("m[1]: ", m[1], ".\n");
    print("m[2]: ", m[2], ".\n");
    print("m[0][0]: ", m[0][0], ".\n");
    print("m[0, 0]: ", m[0, 0], ".\n");
    print("m[1][2]: ", m[1][2], ".\n");
    print("m[1, 2]: ", m[1, 2], ".\n");
    m[1, 2] := 66;
    print("m: ", m, ".\n");
    m[1][2] := 77;
    print("m: ", m, ".\n");
    print("m[*]: ", m[*], ".\n");
    print("m[0, *]: ", m[0, *], ".\n");
    print("m[2, *]: ", m[2, *], ".\n");
    print("m[*, 0]: ", m[*, 0], ".\n");
    print("m[*, 2]: ", m[*, 2], ".\n");
    print("m[0, 0...1]: ", m[0, 0...1], ".\n");
    print("m[2, 1...2]: ", m[2, 1...2], ".\n");
    print("m[0...1, 0]: ", m[0...1, 0], ".\n");
    print("m[1...2, 2]: ", m[1...2, 2], ".\n");
    m[0, *] := [100, 101, 102];
    print("m: ", m, ".\n");
    m[*, 2] := [200, 201, 202];
    print("m: ", m, ".\n");
    m[1...2, 1] := [300, 301];
    print("m: ", m, ".\n");
    m[1, 1...2] := [400, 401];
    print("m: ", m, ".\n");

    print("(&(m[1, 2])) in +integer: ", (&(m[1, 2])) in +integer, ".\n");
    print("(&(m[1, 2])) in +rational: ", (&(m[1, 2])) in +rational, ".\n");

    print("(&(m[1][2])) in +integer: ", (&(m[1][2])) in +integer, ".\n");
    print("(&(m[1][2])) in +rational: ", (&(m[1][2])) in +rational, ".\n");

    print("(&(m[0, *])) in +integer: ", (&(m[0, *])) in +integer, ".\n");
    print("(&(m[0, *])) in +(integer[0...2]): ",
          (&(m[0, *])) in +(integer[0...2]), ".\n");
    print("(&(m[0, *])) in +(integer[0...3]): ",
          (&(m[0, *])) in +(integer[0...3]), ".\n");
    print("(&(m[0, *])) in +(rational[0...2]): ",
          (&(m[0, *])) in +(rational[0...2]), ".\n");

    print("(&(m[*, 2])) in +integer: ", (&(m[*, 2])) in +integer, ".\n");
    print("(&(m[*, 2])) in +(integer[0...2]): ",
          (&(m[*, 2])) in +(integer[0...2]), ".\n");
    print("(&(m[*, 2])) in +(integer[0...3]): ",
          (&(m[*, 2])) in +(integer[0...3]), ".\n");
    print("(&(m[*, 2])) in +(rational[0...2]): ",
          (&(m[*, 2])) in +(rational[0...2]), ".\n");

    print("(&(m[1...2, 1])) in +integer: ", (&(m[1...2, 1])) in +integer,
          ".\n");
    print("(&(m[1...2, 1])) in +(integer[0...2]): ",
          (&(m[1...2, 1])) in +(integer[0...2]), ".\n");
    print("(&(m[1...2, 1])) in +(integer[0...1]): ",
          (&(m[1...2, 1])) in +(integer[0...1]), ".\n");
    print("(&(m[1...2, 1])) in +(integer[1...2]): ",
          (&(m[1...2, 1])) in +(integer[1...2]), ".\n");
    print("(&(m[1...2, 1])) in +(rational[0...1]): ",
          (&(m[1...2, 1])) in +(rational[0...1]), ".\n");

    print("(&(m[1, 1...2])) in +integer: ", (&(m[1, 1...2])) in +integer,
          ".\n");
    print("(&(m[1, 1...2])) in +(integer[0...2]): ",
          (&(m[1, 1...2])) in +(integer[0...2]), ".\n");
    print("(&(m[1, 1...2])) in +(integer[0...1]): ",
          (&(m[1, 1...2])) in +(integer[0...1]), ".\n");
    print("(&(m[1, 1...2])) in +(integer[1...2]): ",
          (&(m[1, 1...2])) in +(integer[1...2]), ".\n");
    print("(&(m[1, 1...2])) in +(rational[0...1]): ",
          (&(m[1, 1...2])) in +(rational[0...1]), ".\n");
  };


/* Next, let's try some tests on maps with filters. */

  {
    immutable a1 := <<>>;
    print("a1: ", a1, "\n");

    immutable a2 := <<(* --> "something")>>;
    print("a2: ", a2, "\n");
    print("a2[1]: ", a2[1], "\n");

    immutable a3 := <<(* : integer --> "integer")>>;
    print("a3: ", a3, "\n");
    print("a3[1]: ", a3[1], "\n");

    immutable a4 := <<(* --> "something"), (* : integer --> "integer")>>;
    print("a4: ", a4, "\n");
    print("a4[1]: ", a4[1], "\n");
    print("a4[1.1]: ", a4[1.1], "\n");

    immutable a5 :=
            <<(* --> "something"), (* : integer --> "integer"), (2 --> "two"),
              (3 --> "three")>>;
    print("a5: ", a5, "\n");
    print("a5[1]: ", a5[1], "\n");
    print("a5[2]: ", a5[2], "\n");
    print("a5[3]: ", a5[3], "\n");
    print("a5[1.1]: ", a5[1.1], "\n");

    immutable a6 :=
            <<(* --> "something"), (2 --> "two"), (* : integer --> "integer"),
              (3 --> "three")>>;
    print("a6: ", a6, "\n");
    print("a6[1]: ", a6[1], "\n");
    print("a6[2]: ", a6[2], "\n");
    print("a6[3]: ", a6[3], "\n");
    print("a6[1.1]: ", a6[1.1], "\n");

    variable v1 := <<>>;
    print("v1: ", v1, "\n");
    v1[*] := <<(* --> "something")>>;
    print("v1: ", v1, "\n");
    print("&(v1[* : integer]): ", &(v1[* : integer]), "\n");
    v1[* : integer] := <<(* --> "integer")>>;
    print("v1: ", v1, "\n");
  };


/* Next, we'll try testing the call() standard library routine. */

  {
    function f1(x : integer, y : integer) returns integer
      {
        print("Called f1(", x, ", ", y, ").\n");
        return x + y;
      };
    procedure p1(x : integer, y : integer, z : integer)
      {
        print("Called p1(", x, ", ", y, ", ", z, ").\n");
      };

    print("call(f1, [10, 20]): ", call(f1, [10, 20]), ".\n");
    print("call(f1, [y := 10, x := 20]): ", call(f1, [y := 10, x := 20]),
          ".\n");
    call(p1, [5, 10, 15]);
    call(p1, [5, z := 10, y := 15]);
  };


/* Next, we'll try testing the return_value_expected() standard library
 * routine. */

  {
    routine r1(x : integer) returns integer
      {
      here:
        if (return_value_expected(here))
          {
            print("r1() called as a function with argument ", x, ".\n");
            return x + 7;
          }
        else
          {
            print("r1() called as a procedure with argument ", x, ".\n");
          };
      };

    print("r1(8): ", r1(8), ".\n");
    print("r1(12): ", r1(12), ".\n");
    r1(8);
    r1(12);
    r1(32);
  };


/* Next, we'll try testing the translate() standard library routine. */

print(translate("This sentence is in English.\n"));


/* Next, we'll try testing ``else if'' clauses of ``if'' statements. */

  {
    procedure p(x)
      {
        print("Running p(", x, ").\n");

        if (x == 5)
          {
            print("Case a1 hit.\n");
          };

        if (x == 5)
          {
            print("Case b1 hit.\n");
          }
        else
          {
            print("Case b2 hit.\n");
          };

        if (x == 5)
          {
            print("Case c1 hit.\n");
          }
        else if (x == 6)
          {
            print("Case c2 hit.\n");
          };

        if (x == 5)
          {
            print("Case d1 hit.\n");
          }
        else if (x == 6)
          {
            print("Case d2 hit.\n");
          }
        else
          {
            print("Case d3 hit.\n");
          };

        if (x == 5)
          {
            print("Case e1 hit.\n");
          }
        else if (x == 6)
          {
            print("Case e2 hit.\n");
          }
        else if (x == 7)
          {
            print("Case e3 hit.\n");
          };

        if (x == 5)
          {
            print("Case f1 hit.\n");
          }
        else if (x == 6)
          {
            print("Case f2 hit.\n");
          }
        else if (x == 7)
          {
            print("Case f3 hit.\n");
          }
        else
          {
            print("Case f4 hit.\n");
          };
      };

    p(5);
    p(6);
    p(7);
    p(8);
  };


/* Next, we'll try testing virtual modifiers on declarations. */

  {
    class a()
      {
        procedure p1()  { print("a's p1().\n"); };
        virtual procedure p2()  { print("a's p2().\n"); };
        procedure p3()  { print("a's p3().\n"); };
        virtual procedure p4()  { print("a's p4().\n"); };
        procedure p_all()
          {
            p1();
            p2();
            p3();
            p4();
          };
      };
    class b()
      {
        use a();
        procedure p1()  { print("b's p1().\n"); };
        procedure p2()  { print("b's p2().\n"); };
        variable p4;
      };
    class c()
      {
        use b();
        procedure p3()  { print("c's p3().\n"); };
        procedure p4()  { print("c's p4().\n"); };
      };

    immutable a1 := a();
    a1.p_all();
    immutable b1 := b();
    b1.p_all();
    immutable c1 := c();
    c1.p_all();
    delete(a1);
    delete(b1);
    delete(c1);
  };


/* Next, we'll try testing ``use'' statements some more. */

  {
    class a(x : integer)
      {
        immutable aaa := x;
        variable bbb := x + 2;
        procedure ccc(y : integer)
          { print("ccc: x is ", x, ", y is ", y, ".\n"); };
        procedure ddd(y : integer)
          { print("a's ddd() called.\n"); };
        procedure ggg(y : integer)
          { print("a's ggg() called.\n"); };
        procedure iii(y : integer)
          { print("a's iii() called.\n"); };
        procedure jjj(y : integer)
          { print("a's jjj() called.\n"); };
        procedure kkk(y : rational)
          { print("a's kkk() (rational) called.\n"); };
        procedure kkk(y : integer)
          { print("a's kkk() (integer) called.\n"); };
        procedure lll(y : rational)
          { print("a's lll() (rational) called.\n"); };
        procedure lll(y : integer)
          { print("a's lll() (integer) called.\n"); };
        procedure mmm(y : rational)
          { print("a's mmm() (rational) called.\n"); };
        procedure mmm(y : integer)
          { print("a's mmm() (integer) called.\n"); };
        procedure nnn(y : rational)
          { print("a's nnn() (rational) called.\n"); };
        procedure nnn(y : integer)
          { print("a's nnn() (integer) called.\n"); };
        tagalong ooo;
        lepton qqq;
        quark rrr;
        lock sss;
      };

      {
        procedure fff(y : string)
          { print("Outer fff() called.\n"); };
        procedure hhh(y : string)
          { print("Outer hhh() called.\n"); };
        procedure iii(y : string)
          { print("Outer iii() called.\n"); };
        procedure jjj(y : string)
          { print("Outer jjj() called.\n"); };
        procedure mmm(y : string)
          { print("Outer mmm() called.\n"); };
        procedure nnn(y : string)
          { print("Outer nnn() called.\n"); };
        tagalong ppp;

          {
            use a(15);
            print("aaa: ", aaa, ".\n");
            print("bbb: ", bbb, ".\n");
            bbb := 23;
            print("bbb: ", bbb, ".\n");
            ccc(12);

            ddd(1);
            ddd(2);

            procedure eee(y : {1, 5})
              { print("Inner eee() called.\n"); };
            eee(1);

            fff("one");

            procedure ggg(y : {1, 5})
              { print("Inner ggg() called.\n"); };
            ggg(1);
            ggg(2);

            procedure hhh(y : {1, 5})
              { print("Inner hhh() called.\n"); };
            hhh(1);
            hhh("one");

            iii(1);
            iii(2);
            iii("one");

            procedure jjj(y : {1, 5})
              { print("Inner jjj() called.\n"); };
            jjj(1);
            jjj(2);
            jjj("one");

            kkk(1);
            kkk(1.5);
            kkk(2);

            procedure lll(y : {1, 5})
              { print("Inner lll() called.\n"); };
            lll(1);
            lll(1.5);
            lll(2);

            mmm(1);
            mmm(1.5);
            mmm(2);
            mmm("one");

            procedure nnn(y : {1, 5})
              { print("Inner nnn() called.\n"); };
            nnn(1);
            nnn(1.5);
            nnn(2);
            nnn("one");

            variable v1 := 112;
            v1..ooo := "a";
            v1..ppp := "outer";
            print("v1..ooo: ", v1..ooo, ".\n");
            print("v1..ppp: ", v1..ppp, ".\n");

            print("qqq[a := 5, b := 7].b: ", qqq[a := 5, b := 7].b, ".\n");

            print("rrr == 5: ", rrr == 5, ".\n");

            single(sss)
              { print("In single(sss).\n"); };
          };
      };

    class b(x : integer)
      {
        procedure b1(y : integer)
          { print("b1() called.\n"); };
        procedure e1(y : {1})
          { print("b's e1() called.\n"); };
        procedure f1(y : {1})
          { print("b's first f1() called.\n"); };
        procedure f1(y : {2})
          { print("b's second f1() called.\n"); };
        procedure g1(y : {1})
          { print("b's first g1() called.\n"); };
        procedure g1(y : {2})
          { print("b's second g1() called.\n"); };
        procedure h1(y : {1})
          { print("b's h1() called.\n"); };
        procedure i1(y : {1})
          { print("b's first i1() called.\n"); };
        procedure i1(y : {2})
          { print("b's second i1() called.\n"); };
        procedure j1(y : {1})
          { print("b's first j1() called.\n"); };
        procedure j1(y : {2})
          { print("b's second j1() called.\n"); };
      };
    class c(x : integer)
      {
        procedure c1(y : integer)
          { print("c1() called.\n"); };
        procedure e1(y : {2})
          { print("c's e1() called.\n"); };
        procedure f1(y : {3})
          { print("c's first f1() called.\n"); };
        procedure f1(y : {4})
          { print("c's second f1() called.\n"); };
        procedure g1(y : {3})
          { print("c's g1() called.\n"); };
        procedure h1(y : {2})
          { print("c's h1() called.\n"); };
        procedure i1(y : {3})
          { print("c's first i1() called.\n"); };
        procedure i1(y : {4})
          { print("c's second i1() called.\n"); };
        procedure j1(y : {3})
          { print("c's j1() called.\n"); };
      };
    class d(x : integer)
      {
        procedure d1(y : integer)
          { print("d1() called.\n"); };
        procedure e1(y : {3})
          { print("d's e1() called.\n"); };
        procedure f1(y : {5})
          { print("d's first f1() called.\n"); };
        procedure f1(y : {6})
          { print("d's second f1() called.\n"); };
        procedure g1(y : {4})
          { print("d's first g1() called.\n"); };
        procedure g1(y : {5})
          { print("d's second g1() called.\n"); };
        procedure h1(y : {3})
          { print("d's h1() called.\n"); };
        procedure i1(y : {5})
          { print("d's first i1() called.\n"); };
        procedure i1(y : {6})
          { print("d's second i1() called.\n"); };
        procedure j1(y : {4})
          { print("d's first j1() called.\n"); };
        procedure j1(y : {5})
          { print("d's second j1() called.\n"); };
      };

      {
        use b(1);
        use c(2);
        use d(3);

        b1(10);
        c1(20);
        d1(230);
        e1(1);
        e1(2);
        e1(3);
        f1(1);
        f1(2);
        f1(3);
        f1(4);
        f1(5);
        f1(6);
        g1(1);
        g1(2);
        g1(3);
        g1(4);
        g1(5);

        procedure h1(y : {4})
          { print("Local h1() called.\n"); };
        h1(1);
        h1(2);
        h1(3);
        h1(4);

        procedure i1(y : {7})
          { print("Local i1() called.\n"); };
        i1(1);
        i1(2);
        i1(3);
        i1(4);
        i1(5);
        i1(6);
        i1(7);

        procedure j1(y : {6})
          { print("Local j1() called.\n"); };
        j1(1);
        j1(2);
        j1(3);
        j1(4);
        j1(5);
        j1(6);
      };

      {
        try
          {
            b1(55);
            use b(1);
          }
        catch
          {
            print("Caught: `", current_exceptions()[0].message, "'.\n");
          };
      };

      {
        class e(x : integer)
          {
            hide;
            use d(x);

            export d1 as e1;
          };

        immutable ee := e(12);
        ee.e1(122);
        delete(ee);
      };
  };


/* Next, we'll try testing declaration statements with more than one
 * declaration. */

  {
    immutable x := 1, y := 2, z := 3;

    print("x, y, z: ", x, ", ", y, ", ", z, ".\n");

    function f1()
      {
        static variable xx := 1, yy := 2, zz := 3;

        [xx, yy, zz] := [yy, zz, xx + 10];
        return [xx, yy, zz];
      },
    f2(xx : integer)
      { return xx * 2; };

    print("f1(): ", f1(), ".\n");
    print("f1(): ", f1(), ".\n");
    print("f1(): ", f1(), ".\n");
    print("f2(14): ", f2(14), ".\n");

    variable v1, v2, v3;
    tagalong t1, t2;
    v2 := 17;
    v2..t1 := "tt1";
    v2..t2 := "tt2";
    print("v2..t1: ", v2..t1, ".\n");
    print("v2..t2: ", v2..t2, ".\n");

    lepton l1[...], l2[...];
    print("l1[a := \"aaa\", b := \"bbb\"].b: ", l1[a := "aaa", b := "bbb"].b,
          ".\n");
    print("l2[a := \"aaa\", b := \"bbb\"].a: ", l2[a := "aaa", b := "bbb"].a,
          ".\n");

    quark q1, q2, q3;
    print("q1 == q1: ", q1 == q1, ".\n");
    print("q1 == q2: ", q1 == q2, ".\n");
    print("q1 == q3: ", q1 == q3, ".\n");

    lock s1, s2;
    single(s1)
      { print("In single(s1).\n"); };
    single(s2)
      { print("In single(s2).\n"); };
  };


/* Next, we'll try testing ``quark enumeration'' declarations. */

  {
    quark enumeration abc { aaa, bbb, ccc};
    quark enumeration xyz { xxx, yyy, zzz};

    print("aaa in abc: ", aaa in abc, ".\n");
    print("aaa in xyz: ", aaa in xyz, ".\n");
    print("bbb in abc: ", bbb in abc, ".\n");
    print("bbb in xyz: ", bbb in xyz, ".\n");
    print("ccc in abc: ", ccc in abc, ".\n");
    print("ccc in xyz: ", ccc in xyz, ".\n");
    print("xxx in abc: ", xxx in abc, ".\n");
    print("xxx in xyz: ", xxx in xyz, ".\n");
    print("yyy in abc: ", yyy in abc, ".\n");
    print("yyy in xyz: ", yyy in xyz, ".\n");
    print("zzz in abc: ", zzz in abc, ".\n");
    print("zzz in xyz: ", zzz in xyz, ".\n");
  };


/* Next, we'll try testing sending named arguments through ``...'' in calls. */

  {
    procedure p1(...)
      { print("p1() arguments: ", arguments, ".\n"); };
    procedure p2(x, ...)
      { print("p2() arguments: ", arguments, ".\n"); };

    p1();
    p1(3);
    p1(5, a := 7, 9);
    p2(3);
    p2(5, a := 7, 9);
  };


/* Next, we'll try testing power(). */

  {
    print("power(1, 1): ", power(1, 1), ".\n");
    print("power(1, 2): ", power(1, 2), ".\n");
    print("power(2, 1): ", power(2, 1), ".\n");
    print("power(2, 2): ", power(2, 2), ".\n");
    print("power(2, 8): ", power(2, 8), ".\n");
    print("power(3, 2): ", power(3, 2), ".\n");
    print("power(3, 1): ", power(3, 1), ".\n");
    print("power(3, 0): ", power(3, 0), ".\n");
    print("power(3, -1): ", power(3, -1), ".\n");
    print("power(3, -2): ", power(3, -2), ".\n");
    print("power(-3, 2): ", power(-3, 2), ".\n");
    print("power(-3, 1): ", power(-3, 1), ".\n");
    print("power(-3, 0): ", power(-3, 0), ".\n");
    print("power(-3, -1): ", power(-3, -1), ".\n");
    print("power(-3, -2): ", power(-3, -2), ".\n");
    print("power(2/3, 2): ", power(2/3, 2), ".\n");
    print("power(2/3, 1): ", power(2/3, 1), ".\n");
    print("power(2/3, 0): ", power(2/3, 0), ".\n");
    print("power(2/3, -1): ", power(2/3, -1), ".\n");
    print("power(2/3, -2): ", power(2/3, -2), ".\n");
  };


/* Next, we'll try testing printf(). */

  {
    printf("abc.\n");
    printf("100%%.\n");
    printf("%v%, %v%, %v%.\n", 1, 2, 3);
    printf("%2:v%, %v%, %1:v%.\n", 1, 2, 3);
    printf("%2:%, %v%, %1:%.\n", 1, 2, 3);
    printf("%last:v%, %first:v%, %v%.\n", first := 1, 2, last := 3);
    printf("`%1v%'.\n", 17);
    printf("`%2v%'.\n", 17);
    printf("`%3v%'.\n", 17);
    printf("`%4v%'.\n", 17);
    printf("`%-1v%'.\n", 17);
    printf("`%-2v%'.\n", 17);
    printf("`%-3v%'.\n", 17);
    printf("`%-4v%'.\n", 17);
    printf("`%.0v%'.\n", 17);
    printf("`%.1v%'.\n", 17);
    printf("`%.2v%'.\n", 17);
    printf("`%.3v%'.\n", 17);
    printf("`%.0d%'.\n", 17);
    printf("`%.1d%'.\n", 17);
    printf("`%.2d%'.\n", 17);
    printf("`%.3d%'.\n", 17);
    printf("`%.0i%'.\n", 17);
    printf("`%.1i%'.\n", 17);
    printf("`%.2i%'.\n", 17);
    printf("`%.3i%'.\n", 17);
    printf("`%d%'.\n", 17);
    printf("`%d%'.\n", -17);
    printf("`%+d%'.\n", 17);
    printf("`%+d%'.\n", -17);
    printf("`% d%'.\n", 17);
    printf("`% d%'.\n", -17);
    printf("`%1d%'.\n", -17);
    printf("`%2d%'.\n", -17);
    printf("`%3d%'.\n", -17);
    printf("`%4d%'.\n", -17);
    printf("`%01d%'.\n", -17);
    printf("`%02d%'.\n", -17);
    printf("`%03d%'.\n", -17);
    printf("`%04d%'.\n", -17);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 1);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 2);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 3);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 4);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 5);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 6);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 7);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 8);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 9);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 10);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 11);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 12);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 13);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 14);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 15);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 16);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 17);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x3f);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x40);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x41);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0xff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x100);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x101);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x1ff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x200);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x201);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0xfff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x1000);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x1001);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x7fff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x8000);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x8001);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0xffff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x10000);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x10001);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x3ffff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x40000);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x40001);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0xfffff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x100000);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x100001);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x1fffff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x200000);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x200001);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0xffffff);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x1000000);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", 0x1000001);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -1);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -2);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -3);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -4);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -5);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -6);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -7);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -8);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -9);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -10);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -11);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -12);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -13);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -14);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -15);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -16);
    printf("`%1:d%', `%1:o%', `%1:x%', `%1:X%'.\n", -17);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 0);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 1);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 2);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 3);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 4);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 5);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 6);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 7);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 8);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 9);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 10);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 11);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 12);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 13);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 14);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 15);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 16);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", 17);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -1);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -2);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -3);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -4);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -5);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -6);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -7);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -8);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -9);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -10);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -11);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -12);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -13);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -14);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -15);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -16);
    printf("`%1:cd%', `%1:co%', `%1:cx%', `%1:cX%'.\n", -17);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", 1);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", 0);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -1);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -2);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -3);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -4);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -5);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -6);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -7);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -8);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -9);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -10);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -11);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -12);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -13);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -14);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -15);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -16);
    printf("`%1:.0cd%', `%1:.0co%', `%1:.0cx%', `%1:.0cX%'.\n", -17);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", 1);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", 0);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -1);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -2);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -3);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -4);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -5);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -6);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -7);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -8);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -9);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -10);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -11);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -12);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -13);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -14);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -15);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -16);
    printf("`%1:.1cd%', `%1:.1co%', `%1:.1cx%', `%1:.1cX%'.\n", -17);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", 1);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", 0);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -1);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -2);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -3);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -4);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -5);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -6);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -7);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -8);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -9);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -10);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -11);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -12);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -13);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -14);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -15);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -16);
    printf("`%1:.2cd%', `%1:.2co%', `%1:.2cx%', `%1:.2cX%'.\n", -17);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", 1);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", 0);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -1);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -2);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -3);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -4);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -5);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -6);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -7);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -8);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -9);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -10);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -11);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -12);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -13);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -14);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -15);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -16);
    printf("`%1:.3cd%', `%1:.3co%', `%1:.3cx%', `%1:.3cX%'.\n", -17);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", 1);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", 0);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -1);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -2);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -3);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -4);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -5);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -6);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -7);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -8);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -9);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -10);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -11);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -12);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -13);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -14);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -15);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -16);
    printf("`%1:04cd%', `%1:04co%', `%1:04cx%', `%1:04cX%'.\n", -17);
    printf("`%f%'.\n", 1);
    printf("`%f%'.\n", 1.2);
    printf("`%f%'.\n", 1/3);
    printf("`%f%'.\n", 2/3);
    printf("`%g%'.\n", 1);
    printf("`%g%'.\n", 1.2);
    printf("`%g%'.\n", 1/3);
    printf("`%g%'.\n", 2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1.2);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e3/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e3/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e4/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e4/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e5/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e5/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e-1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e-1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e-2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e-2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e-3/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e-3/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e-4/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e-4/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 1e-5/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", 2e-5/3);
    printf("`%f%'.\n", -1);
    printf("`%f%'.\n", -1.2);
    printf("`%f%'.\n", -1/3);
    printf("`%f%'.\n", -2/3);
    printf("`%g%'.\n", -1);
    printf("`%g%'.\n", -1.2);
    printf("`%g%'.\n", -1/3);
    printf("`%g%'.\n", -2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1.2);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e3/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e3/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e4/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e4/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e5/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e5/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e-1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e-1/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e-2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e-2/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e-3/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e-3/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e-4/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e-4/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -1e-5/3);
    printf("`%1:.0g%', `%1:.1g%', `%1:.2g%', `%1:.3g%'.\n", -2e-5/3);
    printf("`%cf%'.\n", 1);
    printf("`%cf%'.\n", 1.2);
    printf("`%cf%'.\n", 1/3);
    printf("`%cf%'.\n", 2/3);
    printf("`%cg%'.\n", 1);
    printf("`%cg%'.\n", 1.2);
    printf("`%cg%'.\n", 1/3);
    printf("`%cg%'.\n", 2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1.2);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e3/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e3/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e4/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e4/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e5/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e5/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e-1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e-1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e-2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e-2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e-3/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e-3/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e-4/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e-4/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 1e-5/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", 2e-5/3);
    printf("`%cf%'.\n", -1);
    printf("`%cf%'.\n", -1.2);
    printf("`%cf%'.\n", -1/3);
    printf("`%cf%'.\n", -2/3);
    printf("`%cg%'.\n", -1);
    printf("`%cg%'.\n", -1.2);
    printf("`%cg%'.\n", -1/3);
    printf("`%cg%'.\n", -2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1.2);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e3/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e3/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e4/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e4/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e5/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e5/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e-1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e-1/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e-2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e-2/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e-3/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e-3/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e-4/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e-4/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -1e-5/3);
    printf("`%1:.0cg%', `%1:.1cg%', `%1:.2cg%', `%1:.3cg%'.\n", -2e-5/3);
    printf("`%E%'.\n", 0.99999);
    printf("`%E%'.\n", 0.999999);
    printf("`%E%'.\n", 0.9999999);
    printf("`%E%'.\n", 0.99999999);
    printf("`%.0E%'.\n", 1/3);
    printf("`%.1E%'.\n", 1/3);
    printf("`%.2E%'.\n", 1/3);
    printf("`%.3E%'.\n", 1/3);
    printf("`%#.0E%'.\n", 1/3);
    printf("`%#.1E%'.\n", 1/3);
    printf("`%#.2E%'.\n", 1/3);
    printf("`%#.3E%'.\n", 1/3);
    printf("`%E%'.\n", 0);
    printf("`%G%'.\n", 0);
    printf("`%1:f%', `%1:e%', `%1:g%'.\n", 0);
    printf("`%1:f%', `%1:e%', `%1:g%'.\n", +oo);
    printf("`%1:f%', `%1:e%', `%1:g%'.\n", -oo);
    printf("`%1:f%', `%1:e%', `%1:g%'.\n", 1/0);
    printf("`%1:f%', `%1:e%', `%1:g%'.\n", 0/0);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e-5, 0.9999e-5, 0.999e-5);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e-4, 0.9999e-4, 0.999e-4);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e-3, 0.9999e-3, 0.999e-3);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e-2, 0.9999e-2, 0.999e-2);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e-1, 0.9999e-1, 0.999e-1);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e0, 0.9999e0, 0.999e0);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e1, 0.9999e1, 0.999e1);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e2, 0.9999e2, 0.999e2);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e3, 0.9999e3, 0.999e3);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e4, 0.9999e4, 0.999e4);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", 1e5, 0.9999e5, 0.999e5);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e-5, -0.9999e-5, -0.999e-5);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e-4, -0.9999e-4, -0.999e-4);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e-3, -0.9999e-3, -0.999e-3);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e-2, -0.9999e-2, -0.999e-2);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e-1, -0.9999e-1, -0.999e-1);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e0, -0.9999e0, -0.999e0);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e1, -0.9999e1, -0.999e1);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e2, -0.9999e2, -0.999e2);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e3, -0.9999e3, -0.999e3);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e4, -0.9999e4, -0.999e4);
    printf("`%.3g%', `%.3g%', `%.3g%'.\n", -1e5, -0.9999e5, -0.999e5);

    class print_test()
      {
        function sprint(...) returns string (sprintf("%v%", arguments));
      };
    immutable tester := print_test();
    printf("`%1:%'.\n", tester);
    printf("`%1:v%'.\n", tester);
    printf("`%v%'.\n", tester);
    printf("`%vx%'.\n", tester);
    printf("`%x%'.\n", tester);
    printf("`%+x%'.\n", tester);
    printf("`%-x%'.\n", tester);
    printf("`% x%'.\n", tester);
    printf("`%#x%'.\n", tester);
    printf("`%0x%'.\n", tester);
    printf("`%03x%'.\n", tester);
    printf("`%.7x%'.\n", tester);
    printf("`%+- #03.7x%'.\n", tester);
    printf("`%+ #03.7x%'.\n", tester);
    printf("`%7x%'.\n", tester);
    printf("`%-7x%'.\n", tester);
    printf("`%07x%'.\n", tester);
    printf("`%024x%'.\n", tester);
    printf("`%s%'.\n", "abcde");
    printf("`%2s%'.\n", "abcde");
    printf("`%7s%'.\n", "abcde");
    printf("`%.0s%'.\n", "abcde");
    printf("`%.1s%'.\n", "abcde");
    printf("`%.2s%'.\n", "abcde");
    printf("`%.3s%'.\n", "abcde");
    printf("`%.4s%'.\n", "abcde");
    printf("`%.5s%'.\n", "abcde");
    printf("`%.6s%'.\n", "abcde");
    printf("`%.1000000000000000000000000000000000000000s%'.\n", "abcde");
    printf("`%2.6s%'.\n", "abcde");
    printf("`%7.6s%'.\n", "abcde");
  };


/* Next, we'll try testing open_input_string(). */

  {
    immutable stream : input_text_stream & look_ahead_stream :=
            open_input_string("abcdefghij");
    print("Character: `", stream.read_character(), "'.\n");
    print("Character: `", stream.read_character(), "'.\n");
    print("String(3): `", stream.read_string(3), "'.\n");
    print("Next: `", stream.next_character(), "'.\n");
    print("Look-ahead(0): `", stream.look_ahead(0), "'.\n");
    print("Look-ahead(1): `", stream.look_ahead(1), "'.\n");
    print("Look-ahead(2): `", stream.look_ahead(2), "'.\n");
    print("Character: `", stream.read_character(), "'.\n");
    print("Look-ahead(0): `", stream.look_ahead(0), "'.\n");
    print("Look-ahead(1): `", stream.look_ahead(1), "'.\n");
    print("Look-ahead(2): `", stream.look_ahead(2), "'.\n");
    print("End?: ", stream.is_end_of_input, ".\n");
    print("String(4): `", stream.read_string(4), "'.\n");
    print("End?: ", stream.is_end_of_input, ".\n");
  };

  {
    immutable stream : input_text_stream & look_ahead_stream :=
            open_input_string("lmno");
    print("End?: ", stream.is_end_of_input, ".\n");
    print("Character: `", stream.read_character(), "'.\n");
    print("End?: ", stream.is_end_of_input, ".\n");
    print("Character: `", stream.read_character(), "'.\n");
    print("End?: ", stream.is_end_of_input, ".\n");
    print("Character: `", stream.read_character(), "'.\n");
    print("End?: ", stream.is_end_of_input, ".\n");
    print("Character: `", stream.read_character(), "'.\n");
    print("End?: ", stream.is_end_of_input, ".\n");
  };


/* Next, we'll try testing open_output_string(). */

  {
    variable output : string := "";
    immutable stream : output_text_stream := open_output_string(&output);
    print("Output: `", output, "'.\n");
    stream.print("hello.");
    print("Output: `", output, "'.\n");
    stream.printf("0x%x%", 127);
    print("Output: `", output, "'.\n");
  };


/* Next, we'll try testing scanf(). */

  {
    procedure test(format : string, input : string)
      {
        printf("Testing scanf(%v%) on %v%:\n", format, input);
        try
          {
            immutable stream := open_input_string(input);
            immutable result := scanf(stream, format);
            print("    No exception.\n");
            print("    Result: `", result, "'.\n");
            print("    Remainder: `");
            while (true)
              {
                immutable next := stream.read_character();
                if (next == end_of_input)
                  { break; };
                print(next);
              };
            print("'.\n");
          }
        catch
          {
            print("    Exception: `", current_exceptions()[0].message, "'.\n");
          };
      };

    test("a", "a");
    test("a", "b");
    test("a", "");
    test("a", "ab");
    test("@", "ab");
    test("%", "ab");
    test("#", "ab");
    test("@@", "ab");
    test("@@", "@@");
    test("%%", "cc");
    test("%%", "%%");
    test("##", "dd");
    test("##", "##");
    test("@a|b@", "ab");
    test("@a|b@", "cb");
    test("@a|b@", "bb");
    test("@.*b@", "ababc");
    test("#.*b#", "ababc");
    test("@.*b@", "abab");
    test("#.*b#", "abab");
    test("@.*b$@", "ababc");
    test("#.*b$#", "ababc");
    test("@.*b$@", "abab");
    test("#.*b$#", "abab");
    test("@\\\\@", "\\ab");
    test("@\\@*@", "@@@@cd");
    test("#\\\\#", "\\ab");
    test("#\\#*#", "####cd");
    test("#\\##", "####cd");

    test("%d%", "123abc");
    test("%d%", "123");
    test("%d%", "00");
    test("%d%", "013");
    test("%d%", "0");
    test("%d%", "0 ab");
    test("%d%", "99.13");
    test("%d%", "+12");
    test("%d%", "-12");
    test("%d%", "+0");
    test("%d%", "-0");
    test("%d%", "++12");
    test("%d%", "+-12");
    test("%d%", "-+12");
    test("%d%", "--12");
    test("%d%", "+oooo");
    test("%d%", "+o");
    test("%d%", "+ooo");
    test("%d%", "+oo");
    test("%d%", "-ooo");
    test("%d%", "-oo");
    test("%d%", "-");
    test("%d%", "+");
    test("%d%", "oo");
    test("%d%", "");
    test("%d%", "+infinity");
    test("%d%", "-infinity");
    test("%d%", "infinity");

    test("%ud%", "123abc");
    test("%ud%", "123");
    test("%ud%", "00");
    test("%ud%", "013");
    test("%ud%", "0");
    test("%ud%", "0 ab");
    test("%ud%", "99.13");
    test("%ud%", "+12");
    test("%ud%", "-12");
    test("%ud%", "+0");
    test("%ud%", "-0");
    test("%ud%", "++12");
    test("%ud%", "+-12");
    test("%ud%", "-+12");
    test("%ud%", "--12");
    test("%ud%", "+oooo");
    test("%ud%", "+o");
    test("%ud%", "+ooo");
    test("%ud%", "+oo");
    test("%ud%", "-ooo");
    test("%ud%", "-oo");
    test("%ud%", "-");
    test("%ud%", "+");
    test("%ud%", "oo");
    test("%ud%", "");

    test("%cd%", "123abc");
    test("%cd%", "123");
    test("%cd%", "00");
    test("%cd%", "013");
    test("%cd%", "0");
    test("%cd%", "0 ab");
    test("%cd%", "99.13");
    test("%cd%", "+12");
    test("%cd%", "-12");
    test("%cd%", "+0");
    test("%cd%", "-0");
    test("%cd%", "++12");
    test("%cd%", "+-12");
    test("%cd%", "-+12");
    test("%cd%", "--12");
    test("%cd%", "+oooo");
    test("%cd%", "+o");
    test("%cd%", "+ooo");
    test("%cd%", "+oo");
    test("%cd%", "-ooo");
    test("%cd%", "-oo");
    test("%cd%", "-");
    test("%cd%", "+");
    test("%cd%", "oo");
    test("%cd%", "");
    test("%cd%", "-99.13");
    test("%cd%", "-98");
    test("%cd%", "-0");
    test("%cd%", "-00");

    test("%o%", "123abc");
    test("%o%", "123");
    test("%o%", "00");
    test("%o%", "013");
    test("%o%", "0");
    test("%o%", "0 ab");
    test("%o%", "99.13");
    test("%o%", "+12");
    test("%o%", "-12");
    test("%o%", "+0");
    test("%o%", "-0");
    test("%o%", "++12");
    test("%o%", "+-12");
    test("%o%", "-+12");
    test("%o%", "--12");
    test("%o%", "+oooo");
    test("%o%", "+o");
    test("%o%", "+ooo");
    test("%o%", "+oo");
    test("%o%", "-ooo");
    test("%o%", "-oo");
    test("%o%", "-");
    test("%o%", "+");
    test("%o%", "oo");
    test("%o%", "");

    test("%uo%", "123abc");
    test("%uo%", "123");
    test("%uo%", "00");
    test("%uo%", "013");
    test("%uo%", "0");
    test("%uo%", "0 ab");
    test("%uo%", "99.13");
    test("%uo%", "+12");
    test("%uo%", "-12");
    test("%uo%", "+0");
    test("%uo%", "-0");
    test("%uo%", "++12");
    test("%uo%", "+-12");
    test("%uo%", "-+12");
    test("%uo%", "--12");
    test("%uo%", "+oooo");
    test("%uo%", "+o");
    test("%uo%", "+ooo");
    test("%uo%", "+oo");
    test("%uo%", "-ooo");
    test("%uo%", "-oo");
    test("%uo%", "-");
    test("%uo%", "+");
    test("%uo%", "oo");
    test("%uo%", "");

    test("%co%", "123abc");
    test("%co%", "123");
    test("%co%", "00");
    test("%co%", "013");
    test("%co%", "0");
    test("%co%", "0 ab");
    test("%co%", "99.13");
    test("%co%", "+12");
    test("%co%", "-12");
    test("%co%", "+0");
    test("%co%", "-0");
    test("%co%", "++12");
    test("%co%", "+-12");
    test("%co%", "-+12");
    test("%co%", "--12");
    test("%co%", "+oooo");
    test("%co%", "+o");
    test("%co%", "+ooo");
    test("%co%", "+oo");
    test("%co%", "-ooo");
    test("%co%", "-oo");
    test("%co%", "-");
    test("%co%", "+");
    test("%co%", "oo");
    test("%co%", "");
    test("%co%", "-99.13");
    test("%co%", "-98");
    test("%co%", "-0");
    test("%co%", "-00");

    test("%x%", "123abc");
    test("%x%", "123");
    test("%x%", "00");
    test("%x%", "013");
    test("%x%", "0");
    test("%x%", "0 ab");
    test("%x%", "99.13");
    test("%x%", "+12");
    test("%x%", "-12");
    test("%x%", "+0");
    test("%x%", "-0");
    test("%x%", "++12");
    test("%x%", "+-12");
    test("%x%", "-+12");
    test("%x%", "--12");
    test("%x%", "+oooo");
    test("%x%", "+o");
    test("%x%", "+ooo");
    test("%x%", "+oo");
    test("%x%", "-ooo");
    test("%x%", "-oo");
    test("%x%", "-");
    test("%x%", "+");
    test("%x%", "oo");
    test("%x%", "");

    test("%ux%", "123abc");
    test("%ux%", "123");
    test("%ux%", "00");
    test("%ux%", "013");
    test("%ux%", "0");
    test("%ux%", "0 ab");
    test("%ux%", "99.13");
    test("%ux%", "+12");
    test("%ux%", "-12");
    test("%ux%", "+0");
    test("%ux%", "-0");
    test("%ux%", "++12");
    test("%ux%", "+-12");
    test("%ux%", "-+12");
    test("%ux%", "--12");
    test("%ux%", "+oooo");
    test("%ux%", "+o");
    test("%ux%", "+ooo");
    test("%ux%", "+oo");
    test("%ux%", "-ooo");
    test("%ux%", "-oo");
    test("%ux%", "-");
    test("%ux%", "+");
    test("%ux%", "oo");
    test("%ux%", "");

    test("%cx%", "123abc");
    test("%cx%", "123");
    test("%cx%", "00");
    test("%cx%", "013");
    test("%cx%", "0");
    test("%cx%", "0 ab");
    test("%cx%", "99.13");
    test("%cx%", "+12");
    test("%cx%", "-12");
    test("%cx%", "+0");
    test("%cx%", "-0");
    test("%cx%", "++12");
    test("%cx%", "+-12");
    test("%cx%", "-+12");
    test("%cx%", "--12");
    test("%cx%", "+oooo");
    test("%cx%", "+o");
    test("%cx%", "+ooo");
    test("%cx%", "+oo");
    test("%cx%", "-ooo");
    test("%cx%", "-oo");
    test("%cx%", "-");
    test("%cx%", "+");
    test("%cx%", "oo");
    test("%cx%", "");
    test("%cx%", "-99.13");
    test("%cx%", "-98");
    test("%cx%", "-0");
    test("%cx%", "-00");

    test("%d%", "00");
    test("%d%", "01");
    test("%d%", "02");
    test("%d%", "03");
    test("%d%", "04");
    test("%d%", "05");
    test("%d%", "06");
    test("%d%", "07");
    test("%d%", "08");
    test("%d%", "09");
    test("%d%", "0a");
    test("%d%", "0b");
    test("%d%", "0c");
    test("%d%", "0d");
    test("%d%", "0e");
    test("%d%", "0f");
    test("%d%", "0g");
    test("%d%", "0h");
    test("%d%", "0i");
    test("%d%", "0j");
    test("%d%", "0k");
    test("%d%", "0l");
    test("%d%", "0m");
    test("%d%", "0n");
    test("%d%", "0o");
    test("%d%", "0p");
    test("%d%", "0q");
    test("%d%", "0r");
    test("%d%", "0s");
    test("%d%", "0t");
    test("%d%", "0u");
    test("%d%", "0v");
    test("%d%", "0w");
    test("%d%", "0x");
    test("%d%", "0y");
    test("%d%", "0z");
    test("%d%", "0A");
    test("%d%", "0B");
    test("%d%", "0C");
    test("%d%", "0D");
    test("%d%", "0E");
    test("%d%", "0F");
    test("%d%", "0G");
    test("%d%", "0H");
    test("%d%", "0I");
    test("%d%", "0J");
    test("%d%", "0K");
    test("%d%", "0L");
    test("%d%", "0M");
    test("%d%", "0N");
    test("%d%", "0O");
    test("%d%", "0P");
    test("%d%", "0Q");
    test("%d%", "0R");
    test("%d%", "0S");
    test("%d%", "0T");
    test("%d%", "0U");
    test("%d%", "0V");
    test("%d%", "0W");
    test("%d%", "0X");
    test("%d%", "0Y");
    test("%d%", "0Z");
    test("%d%", "fF");

    test("%o%", "00");
    test("%o%", "01");
    test("%o%", "02");
    test("%o%", "03");
    test("%o%", "04");
    test("%o%", "05");
    test("%o%", "06");
    test("%o%", "07");
    test("%o%", "08");
    test("%o%", "09");
    test("%o%", "0a");
    test("%o%", "0b");
    test("%o%", "0c");
    test("%o%", "0d");
    test("%o%", "0e");
    test("%o%", "0f");
    test("%o%", "0g");
    test("%o%", "0h");
    test("%o%", "0i");
    test("%o%", "0j");
    test("%o%", "0k");
    test("%o%", "0l");
    test("%o%", "0m");
    test("%o%", "0n");
    test("%o%", "0o");
    test("%o%", "0p");
    test("%o%", "0q");
    test("%o%", "0r");
    test("%o%", "0s");
    test("%o%", "0t");
    test("%o%", "0u");
    test("%o%", "0v");
    test("%o%", "0w");
    test("%o%", "0x");
    test("%o%", "0y");
    test("%o%", "0z");
    test("%o%", "0A");
    test("%o%", "0B");
    test("%o%", "0C");
    test("%o%", "0D");
    test("%o%", "0E");
    test("%o%", "0F");
    test("%o%", "0G");
    test("%o%", "0H");
    test("%o%", "0I");
    test("%o%", "0J");
    test("%o%", "0K");
    test("%o%", "0L");
    test("%o%", "0M");
    test("%o%", "0N");
    test("%o%", "0O");
    test("%o%", "0P");
    test("%o%", "0Q");
    test("%o%", "0R");
    test("%o%", "0S");
    test("%o%", "0T");
    test("%o%", "0U");
    test("%o%", "0V");
    test("%o%", "0W");
    test("%o%", "0X");
    test("%o%", "0Y");
    test("%o%", "0Z");
    test("%o%", "fF");

    test("%x%", "00");
    test("%x%", "01");
    test("%x%", "02");
    test("%x%", "03");
    test("%x%", "04");
    test("%x%", "05");
    test("%x%", "06");
    test("%x%", "07");
    test("%x%", "08");
    test("%x%", "09");
    test("%x%", "0a");
    test("%x%", "0b");
    test("%x%", "0c");
    test("%x%", "0d");
    test("%x%", "0e");
    test("%x%", "0f");
    test("%x%", "0g");
    test("%x%", "0h");
    test("%x%", "0i");
    test("%x%", "0j");
    test("%x%", "0k");
    test("%x%", "0l");
    test("%x%", "0m");
    test("%x%", "0n");
    test("%x%", "0o");
    test("%x%", "0p");
    test("%x%", "0q");
    test("%x%", "0r");
    test("%x%", "0s");
    test("%x%", "0t");
    test("%x%", "0u");
    test("%x%", "0v");
    test("%x%", "0w");
    test("%x%", "0x");
    test("%x%", "0y");
    test("%x%", "0z");
    test("%x%", "0A");
    test("%x%", "0B");
    test("%x%", "0C");
    test("%x%", "0D");
    test("%x%", "0E");
    test("%x%", "0F");
    test("%x%", "0G");
    test("%x%", "0H");
    test("%x%", "0I");
    test("%x%", "0J");
    test("%x%", "0K");
    test("%x%", "0L");
    test("%x%", "0M");
    test("%x%", "0N");
    test("%x%", "0O");
    test("%x%", "0P");
    test("%x%", "0Q");
    test("%x%", "0R");
    test("%x%", "0S");
    test("%x%", "0T");
    test("%x%", "0U");
    test("%x%", "0V");
    test("%x%", "0W");
    test("%x%", "0X");
    test("%x%", "0Y");
    test("%x%", "0Z");
    test("%x%", "fF");

    test("%i%", "0");
    test("%i%", "+0");
    test("%i%", "-0");
    test("%i%", "0x0");
    test("%i%", "0x+0");
    test("%i%", "0x-0");
    test("%i%", "+0x0");
    test("%i%", "-0x0");
    test("%i%", "0x");
    test("%i%", "+0x");
    test("%i%", "-0x");
    test("%i%", "0xg");
    test("%i%", "+0xg");
    test("%i%", "-0xg");
    test("%i%", "0X0");
    test("%i%", "0X+0");
    test("%i%", "0X-0");
    test("%i%", "+0X0");
    test("%i%", "-0X0");
    test("%i%", "0X");
    test("%i%", "+0X");
    test("%i%", "-0X");
    test("%i%", "0Xg");
    test("%i%", "+0Xg");
    test("%i%", "-0Xg");
    test("%i%", "12");
    test("%i%", "+12");
    test("%i%", "-12");
    test("%i%", "0x12");
    test("%i%", "0x+12");
    test("%i%", "0x-12");
    test("%i%", "+0x12");
    test("%i%", "-0x12");
    test("%i%", "0X12");
    test("%i%", "0X+12");
    test("%i%", "0X-12");
    test("%i%", "+0X12");
    test("%i%", "-0X12");
    test("%i%", "aF");
    test("%i%", "+aF");
    test("%i%", "-aF");
    test("%i%", "0xaF");
    test("%i%", "0x+aF");
    test("%i%", "0x-aF");
    test("%i%", "+0xaF");
    test("%i%", "-0xaF");
    test("%i%", "0XaF");
    test("%i%", "0X+aF");
    test("%i%", "0X-aF");
    test("%i%", "+0XaF");
    test("%i%", "-0XaF");
    test("%i%", "-0X-aF");
    test("%i%", "-0X+aF");
    test("%i%", "+0X-aF");
    test("%i%", "+0X+aF");

    test("%ui%", "0");
    test("%ui%", "+0");
    test("%ui%", "-0");
    test("%ui%", "0x0");
    test("%ui%", "0x+0");
    test("%ui%", "0x-0");
    test("%ui%", "+0x0");
    test("%ui%", "-0x0");
    test("%ui%", "0x");
    test("%ui%", "+0x");
    test("%ui%", "-0x");
    test("%ui%", "0xg");
    test("%ui%", "+0xg");
    test("%ui%", "-0xg");
    test("%ui%", "0X0");
    test("%ui%", "0X+0");
    test("%ui%", "0X-0");
    test("%ui%", "+0X0");
    test("%ui%", "-0X0");
    test("%ui%", "0X");
    test("%ui%", "+0X");
    test("%ui%", "-0X");
    test("%ui%", "0Xg");
    test("%ui%", "+0Xg");
    test("%ui%", "-0Xg");
    test("%ui%", "12");
    test("%ui%", "+12");
    test("%ui%", "-12");
    test("%ui%", "0x12");
    test("%ui%", "0x+12");
    test("%ui%", "0x-12");
    test("%ui%", "+0x12");
    test("%ui%", "-0x12");
    test("%ui%", "0X12");
    test("%ui%", "0X+12");
    test("%ui%", "0X-12");
    test("%ui%", "+0X12");
    test("%ui%", "-0X12");
    test("%ui%", "aF");
    test("%ui%", "+aF");
    test("%ui%", "-aF");
    test("%ui%", "0xaF");
    test("%ui%", "0x+aF");
    test("%ui%", "0x-aF");
    test("%ui%", "+0xaF");
    test("%ui%", "-0xaF");
    test("%ui%", "0XaF");
    test("%ui%", "0X+aF");
    test("%ui%", "0X-aF");
    test("%ui%", "+0XaF");
    test("%ui%", "-0XaF");
    test("%ui%", "-0X-aF");
    test("%ui%", "-0X+aF");
    test("%ui%", "+0X-aF");
    test("%ui%", "+0X+aF");

    test("%ci%", "0");
    test("%ci%", "+0");
    test("%ci%", "-0");
    test("%ci%", "0x0");
    test("%ci%", "0x+0");
    test("%ci%", "0x-0");
    test("%ci%", "+0x0");
    test("%ci%", "-0x0");
    test("%ci%", "0x");
    test("%ci%", "+0x");
    test("%ci%", "-0x");
    test("%ci%", "0xg");
    test("%ci%", "+0xg");
    test("%ci%", "-0xg");
    test("%ci%", "0X0");
    test("%ci%", "0X+0");
    test("%ci%", "0X-0");
    test("%ci%", "+0X0");
    test("%ci%", "-0X0");
    test("%ci%", "0X");
    test("%ci%", "+0X");
    test("%ci%", "-0X");
    test("%ci%", "0Xg");
    test("%ci%", "+0Xg");
    test("%ci%", "-0Xg");
    test("%ci%", "12");
    test("%ci%", "+12");
    test("%ci%", "-12");
    test("%ci%", "0x12");
    test("%ci%", "0x+12");
    test("%ci%", "0x-12");
    test("%ci%", "+0x12");
    test("%ci%", "-0x12");
    test("%ci%", "0X12");
    test("%ci%", "0X+12");
    test("%ci%", "0X-12");
    test("%ci%", "+0X12");
    test("%ci%", "-0X12");
    test("%ci%", "aF");
    test("%ci%", "+aF");
    test("%ci%", "-aF");
    test("%ci%", "0xaF");
    test("%ci%", "0x+aF");
    test("%ci%", "0x-aF");
    test("%ci%", "+0xaF");
    test("%ci%", "-0xaF");
    test("%ci%", "0XaF");
    test("%ci%", "0X+aF");
    test("%ci%", "0X-aF");
    test("%ci%", "+0XaF");
    test("%ci%", "-0XaF");
    test("%ci%", "-0X-aF");
    test("%ci%", "-0X+aF");
    test("%ci%", "+0X-aF");
    test("%ci%", "+0X+aF");

    test("%df%", "12");
    test("%df%", "12ab");
    test("%df%", "12.");
    test("%df%", "12.ab");
    test("%df%", "12.34");
    test("%df%", "12.34ab");
    test("%df%", "+oo");
    test("%df%", "-oo");
    test("%df%", "oo");
    test("%df%", "+infinity");
    test("%df%", "-infinity");
    test("%df%", "infinity");
    test("%df%", "+12.34ab");
    test("%df%", "-12.34ab");

    test("%cdf%", "12");
    test("%cdf%", "12ab");
    test("%cdf%", "12.");
    test("%cdf%", "12.ab");
    test("%cdf%", "12.34");
    test("%cdf%", "12.34ab");
    test("%cdf%", "+oo");
    test("%cdf%", "-oo");
    test("%cdf%", "oo");
    test("%cdf%", "+infinity");
    test("%cdf%", "-infinity");
    test("%cdf%", "infinity");
    test("%cdf%", "+12.34ab");
    test("%cdf%", "-12.34ab");

    test("%of%", "12");
    test("%of%", "12ab");
    test("%of%", "12.");
    test("%of%", "12.ab");
    test("%of%", "12.34");
    test("%of%", "12.34ab");
    test("%of%", "+oo");
    test("%of%", "-oo");
    test("%of%", "oo");
    test("%of%", "+infinity");
    test("%of%", "-infinity");
    test("%of%", "infinity");
    test("%of%", "+12.34ab");
    test("%of%", "-12.34ab");

    test("%cof%", "12");
    test("%cof%", "12ab");
    test("%cof%", "12.");
    test("%cof%", "12.ab");
    test("%cof%", "12.34");
    test("%cof%", "12.34ab");
    test("%cof%", "+oo");
    test("%cof%", "-oo");
    test("%cof%", "oo");
    test("%cof%", "+infinity");
    test("%cof%", "-infinity");
    test("%cof%", "infinity");
    test("%cof%", "+12.34ab");
    test("%cof%", "-12.34ab");

    test("%xf%", "12");
    test("%xf%", "12ab");
    test("%xf%", "12.");
    test("%xf%", "12.ab");
    test("%xf%", "12.34");
    test("%xf%", "12.34ab");
    test("%xf%", "+oo");
    test("%xf%", "-oo");
    test("%xf%", "oo");
    test("%xf%", "+infinity");
    test("%xf%", "-infinity");
    test("%xf%", "infinity");
    test("%xf%", "+12.34ab");
    test("%xf%", "-12.34ab");

    test("%cxf%", "12");
    test("%cxf%", "12ab");
    test("%cxf%", "12.");
    test("%cxf%", "12.ab");
    test("%cxf%", "12.34");
    test("%cxf%", "12.34ab");
    test("%cxf%", "+oo");
    test("%cxf%", "-oo");
    test("%cxf%", "oo");
    test("%cxf%", "+infinity");
    test("%cxf%", "-infinity");
    test("%cxf%", "infinity");
    test("%cxf%", "+12.34ab");
    test("%cxf%", "-12.34ab");

    test("%f%", "12");
    test("%f%", "12ab");
    test("%f%", "12.");
    test("%f%", "12.ab");
    test("%f%", "12.34");
    test("%f%", "12.34ab");
    test("%f%", "+oo");
    test("%f%", "-oo");
    test("%f%", "oo");
    test("%f%", "+infinity");
    test("%f%", "-infinity");
    test("%f%", "infinity");
    test("%f%", "+12.34ab");
    test("%f%", "-12.34ab");
    test("%f%", "0x12");
    test("%f%", "0x12ab");
    test("%f%", "0x12.");
    test("%f%", "0x12.ab");
    test("%f%", "0x12.34");
    test("%f%", "0x12.34ab");
    test("%f%", "0x+oo");
    test("%f%", "0x-oo");
    test("%f%", "0xoo");
    test("%f%", "0x+infinity");
    test("%f%", "0x-infinity");
    test("%f%", "0xinfinity");
    test("%f%", "0x+12.34ab");
    test("%f%", "0x-12.34ab");
    test("%f%", "+0xoo");
    test("%f%", "-0xoo");
    test("%f%", "+0xinfinity");
    test("%f%", "-0xinfinity");
    test("%f%", "+0x12.34ab");
    test("%f%", "-0x12.34ab");
    test("%f%", "+0x+oo");
    test("%f%", "-0x-oo");
    test("%f%", "+0x+infinity");
    test("%f%", "-0x-infinity");
    test("%f%", "+0x+12.34ab");
    test("%f%", "-0x-12.34ab");

    test("%cf%", "12");
    test("%cf%", "12ab");
    test("%cf%", "12.");
    test("%cf%", "12.ab");
    test("%cf%", "12.34");
    test("%cf%", "12.34ab");
    test("%cf%", "+oo");
    test("%cf%", "-oo");
    test("%cf%", "oo");
    test("%cf%", "+infinity");
    test("%cf%", "-infinity");
    test("%cf%", "infinity");
    test("%cf%", "+12.34ab");
    test("%cf%", "-12.34ab");
    test("%cf%", "0x12");
    test("%cf%", "0x12ab");
    test("%cf%", "0x12.");
    test("%cf%", "0x12.ab");
    test("%cf%", "0x12.34");
    test("%cf%", "0x12.34ab");
    test("%cf%", "0x+oo");
    test("%cf%", "0x-oo");
    test("%cf%", "0xoo");
    test("%cf%", "0x+infinity");
    test("%cf%", "0x-infinity");
    test("%cf%", "0xinfinity");
    test("%cf%", "0x+12.34ab");
    test("%cf%", "0x-12.34ab");
    test("%cf%", "+0xoo");
    test("%cf%", "-0xoo");
    test("%cf%", "+0xinfinity");
    test("%cf%", "-0xinfinity");
    test("%cf%", "+0x12.34ab");
    test("%cf%", "-0x12.34ab");
    test("%cf%", "+0x+oo");
    test("%cf%", "-0x-oo");
    test("%cf%", "+0x+infinity");
    test("%cf%", "-0x-infinity");
    test("%cf%", "+0x+12.34ab");
    test("%cf%", "-0x-12.34ab");

    test("%de%", "12");
    test("%de%", "12ab");
    test("%de%", "12.");
    test("%de%", "12.ab");
    test("%de%", "12.34");
    test("%de%", "12.34ab");
    test("%de%", "12e15");
    test("%de%", "12.e15");
    test("%de%", "12.34e15");
    test("%de%", "12.34e+15");
    test("%de%", "12.34e-15");
    test("%de%", "12.34e-1a");
    test("%de%", "-12.34e-1a");
    test("%de%", "-12.34E-1a");
    test("%de%", "+oo");
    test("%de%", "-oo");
    test("%de%", "oo");
    test("%de%", "+infinity");
    test("%de%", "-infinity");
    test("%de%", "infinity");
    test("%de%", "+infinitye15");
    test("%de%", "-infinitye+15");
    test("%de%", "infinitye-15");

    test("%cde%", "12");
    test("%cde%", "12ab");
    test("%cde%", "12.");
    test("%cde%", "12.ab");
    test("%cde%", "12.34");
    test("%cde%", "12.34ab");
    test("%cde%", "12e15");
    test("%cde%", "12.e15");
    test("%cde%", "12.34e15");
    test("%cde%", "12.34e+15");
    test("%cde%", "12.34e-15");
    test("%cde%", "12.34e-1a");
    test("%cde%", "-12.34e-1a");
    test("%cde%", "-12.34E-1a");
    test("%cde%", "+oo");
    test("%cde%", "-oo");
    test("%cde%", "oo");
    test("%cde%", "+infinity");
    test("%cde%", "-infinity");
    test("%cde%", "infinity");
    test("%cde%", "+infinitye15");
    test("%cde%", "-infinitye+15");
    test("%cde%", "infinitye-15");

    test("%oe%", "12");
    test("%oe%", "12ab");
    test("%oe%", "12.");
    test("%oe%", "12.ab");
    test("%oe%", "12.34");
    test("%oe%", "12.34ab");
    test("%oe%", "12e15");
    test("%oe%", "12.e15");
    test("%oe%", "12.34e15");
    test("%oe%", "12.34e+15");
    test("%oe%", "12.34e-15");
    test("%oe%", "12.34e-1a");
    test("%oe%", "-12.34e-1a");
    test("%oe%", "-12.34E-1a");
    test("%oe%", "+oo");
    test("%oe%", "-oo");
    test("%oe%", "oo");
    test("%oe%", "+infinity");
    test("%oe%", "-infinity");
    test("%oe%", "infinity");
    test("%oe%", "+infinitye15");
    test("%oe%", "-infinitye+15");
    test("%oe%", "infinitye-15");

    test("%coe%", "12");
    test("%coe%", "12ab");
    test("%coe%", "12.");
    test("%coe%", "12.ab");
    test("%coe%", "12.34");
    test("%coe%", "12.34ab");
    test("%coe%", "12e15");
    test("%coe%", "12.e15");
    test("%coe%", "12.34e15");
    test("%coe%", "12.34e+15");
    test("%coe%", "12.34e-15");
    test("%coe%", "12.34e-1a");
    test("%coe%", "-12.34e-1a");
    test("%coe%", "-12.34E-1a");
    test("%coe%", "+oo");
    test("%coe%", "-oo");
    test("%coe%", "oo");
    test("%coe%", "+infinity");
    test("%coe%", "-infinity");
    test("%coe%", "infinity");
    test("%coe%", "+infinitye15");
    test("%coe%", "-infinitye+15");
    test("%coe%", "infinitye-15");

    test("%xe%", "12");
    test("%xe%", "12ab");
    test("%xe%", "12.");
    test("%xe%", "12.ab");
    test("%xe%", "12.34");
    test("%xe%", "12.34ab");
    test("%xe%", "12e15");
    test("%xe%", "12.e15");
    test("%xe%", "12.34e15");
    test("%xe%", "12.34e+15");
    test("%xe%", "12.34e-15");
    test("%xe%", "12.34e-1a");
    test("%xe%", "-12.34e-1a");
    test("%xe%", "-12.34E-1a");
    test("%xe%", "12x15");
    test("%xe%", "12.x15");
    test("%xe%", "12.34x15");
    test("%xe%", "12.34x+15");
    test("%xe%", "12.34x-15");
    test("%xe%", "12.34x-1a");
    test("%xe%", "-12.34x-1a");
    test("%xe%", "-12.34X-1a");
    test("%xe%", "+oo");
    test("%xe%", "-oo");
    test("%xe%", "oo");
    test("%xe%", "+infinity");
    test("%xe%", "-infinity");
    test("%xe%", "infinity");
    test("%xe%", "+infinitye15");
    test("%xe%", "-infinitye+15");
    test("%xe%", "infinitye-15");

    test("%cxe%", "12");
    test("%cxe%", "12ab");
    test("%cxe%", "12.");
    test("%cxe%", "12.ab");
    test("%cxe%", "12.34");
    test("%cxe%", "12.34ab");
    test("%cxe%", "12e15");
    test("%cxe%", "12.e15");
    test("%cxe%", "12.34e15");
    test("%cxe%", "12.34e+15");
    test("%cxe%", "12.34e-15");
    test("%cxe%", "12.34e-1a");
    test("%cxe%", "-12.34e-1a");
    test("%cxe%", "-12.34E-1a");
    test("%cxe%", "12x15");
    test("%cxe%", "12.x15");
    test("%cxe%", "12.34x15");
    test("%cxe%", "12.34x+15");
    test("%cxe%", "12.34x-f5");
    test("%cxe%", "12.34x-fa");
    test("%cxe%", "-12.34x-fa");
    test("%cxe%", "-12.34X-fa");
    test("%cxe%", "+oo");
    test("%cxe%", "-oo");
    test("%cxe%", "oo");
    test("%cxe%", "+infinity");
    test("%cxe%", "-infinity");
    test("%cxe%", "infinity");
    test("%cxe%", "+infinitye15");
    test("%cxe%", "-infinitye+15");
    test("%cxe%", "infinitye-15");

    test("%e%", "12");
    test("%e%", "12ab");
    test("%e%", "12.");
    test("%e%", "12.ab");
    test("%e%", "12.34");
    test("%e%", "12.34ab");
    test("%e%", "12e15");
    test("%e%", "12.e15");
    test("%e%", "12.34e15");
    test("%e%", "12.34e+15");
    test("%e%", "12.34e-15");
    test("%e%", "12.34e-1a");
    test("%e%", "-12.34e-1a");
    test("%e%", "-12.34E-1a");
    test("%e%", "+oo");
    test("%e%", "-oo");
    test("%e%", "oo");
    test("%e%", "+infinity");
    test("%e%", "-infinity");
    test("%e%", "infinity");
    test("%e%", "+infinitye15");
    test("%e%", "-infinitye+15");
    test("%e%", "infinitye-15");
    test("%e%", "0x12");
    test("%e%", "0x12ab");
    test("%e%", "0x12.");
    test("%e%", "0x12.ab");
    test("%e%", "0x12.34");
    test("%e%", "0x12.34ab");
    test("%e%", "0x12e15");
    test("%e%", "0x12.e15");
    test("%e%", "0x12.34e15");
    test("%e%", "0x12.34e+15");
    test("%e%", "0x12.34e-15");
    test("%e%", "0x12.34e-1a");
    test("%e%", "0x-12.34e-1a");
    test("%e%", "0x-12.34E-1a");
    test("%e%", "0x12x15");
    test("%e%", "0x12.x15");
    test("%e%", "0x12.34x15");
    test("%e%", "0x12.34x+15");
    test("%e%", "0x12.34x-15");
    test("%e%", "0x12.34x-1a");
    test("%e%", "0x-12.34x-1a");
    test("%e%", "0x-12.34X-1a");
    test("%e%", "0x+oo");
    test("%e%", "0x-oo");
    test("%e%", "0xoo");
    test("%e%", "0x+infinity");
    test("%e%", "0x-infinity");
    test("%e%", "0xinfinity");
    test("%e%", "0x+infinitye15");
    test("%e%", "0x-infinitye+15");
    test("%e%", "0xinfinitye-15");

    test("%ce%", "12");
    test("%ce%", "12ab");
    test("%ce%", "12.");
    test("%ce%", "12.ab");
    test("%ce%", "12.34");
    test("%ce%", "12.34ab");
    test("%ce%", "12e15");
    test("%ce%", "12.e15");
    test("%ce%", "12.34e15");
    test("%ce%", "12.34e+15");
    test("%ce%", "12.34e-15");
    test("%ce%", "12.34e-1a");
    test("%ce%", "-12.34e-1a");
    test("%ce%", "-12.34E-1a");
    test("%ce%", "+oo");
    test("%ce%", "-oo");
    test("%ce%", "oo");
    test("%ce%", "+infinity");
    test("%ce%", "-infinity");
    test("%ce%", "infinity");
    test("%ce%", "+infinitye15");
    test("%ce%", "-infinitye+15");
    test("%ce%", "infinitye-15");
    test("%ce%", "0X12");
    test("%ce%", "0X12ab");
    test("%ce%", "0X12.");
    test("%ce%", "0X12.ab");
    test("%ce%", "0X12.34");
    test("%ce%", "0X12.34ab");
    test("%ce%", "0X12e15");
    test("%ce%", "0X12.e15");
    test("%ce%", "0X12.34e15");
    test("%ce%", "0X12.34e+15");
    test("%ce%", "0X12.34e-15");
    test("%ce%", "0X12.34e-1a");
    test("%ce%", "0X-12.34e-1a");
    test("%ce%", "0X-12.34E-1a");
    test("%ce%", "0X12x15");
    test("%ce%", "0X12.x15");
    test("%ce%", "0X12.34x15");
    test("%ce%", "0X12.34x+15");
    test("%ce%", "0X12.34x-f5");
    test("%ce%", "0X12.34x-fa");
    test("%ce%", "0X-12.34x-fa");
    test("%ce%", "0X-12.34X-fa");
    test("%ce%", "0X+oo");
    test("%ce%", "0X-oo");
    test("%ce%", "0Xoo");
    test("%ce%", "0X+infinity");
    test("%ce%", "0X-infinity");
    test("%ce%", "0Xinfinity");
    test("%ce%", "0X+infinitye15");
    test("%ce%", "0X-infinitye+15");
    test("%ce%", "0Xinfinitye-15");

    test("%dg%", "12");
    test("%dg%", "12ab");
    test("%dg%", "12.");
    test("%dg%", "12.ab");
    test("%dg%", "12.34");
    test("%dg%", "12.34ab");
    test("%dg%", "12e15");
    test("%dg%", "12.e15");
    test("%dg%", "12.34e15");
    test("%dg%", "12.34e+15");
    test("%dg%", "12.34e-15");
    test("%dg%", "12.34e-1a");
    test("%dg%", "-12.34e-1a");
    test("%dg%", "-12.34E-1a");
    test("%dg%", "+oo");
    test("%dg%", "-oo");
    test("%dg%", "oo");
    test("%dg%", "+infinity");
    test("%dg%", "-infinity");
    test("%dg%", "infinity");
    test("%dg%", "+infinitye15");
    test("%dg%", "-infinitye+15");
    test("%dg%", "infinitye-15");

    test("%cdg%", "12");
    test("%cdg%", "12ab");
    test("%cdg%", "12.");
    test("%cdg%", "12.ab");
    test("%cdg%", "12.34");
    test("%cdg%", "12.34ab");
    test("%cdg%", "12e15");
    test("%cdg%", "12.e15");
    test("%cdg%", "12.34e15");
    test("%cdg%", "12.34e+15");
    test("%cdg%", "12.34e-15");
    test("%cdg%", "12.34e-1a");
    test("%cdg%", "-12.34e-1a");
    test("%cdg%", "-12.34E-1a");
    test("%cdg%", "+oo");
    test("%cdg%", "-oo");
    test("%cdg%", "oo");
    test("%cdg%", "+infinity");
    test("%cdg%", "-infinity");
    test("%cdg%", "infinity");
    test("%cdg%", "+infinitye15");
    test("%cdg%", "-infinitye+15");
    test("%cdg%", "infinitye-15");

    test("%og%", "12");
    test("%og%", "12ab");
    test("%og%", "12.");
    test("%og%", "12.ab");
    test("%og%", "12.34");
    test("%og%", "12.34ab");
    test("%og%", "12e15");
    test("%og%", "12.e15");
    test("%og%", "12.34e15");
    test("%og%", "12.34e+15");
    test("%og%", "12.34e-15");
    test("%og%", "12.34e-1a");
    test("%og%", "-12.34e-1a");
    test("%og%", "-12.34E-1a");
    test("%og%", "+oo");
    test("%og%", "-oo");
    test("%og%", "oo");
    test("%og%", "+infinity");
    test("%og%", "-infinity");
    test("%og%", "infinity");
    test("%og%", "+infinitye15");
    test("%og%", "-infinitye+15");
    test("%og%", "infinitye-15");

    test("%cog%", "12");
    test("%cog%", "12ab");
    test("%cog%", "12.");
    test("%cog%", "12.ab");
    test("%cog%", "12.34");
    test("%cog%", "12.34ab");
    test("%cog%", "12e15");
    test("%cog%", "12.e15");
    test("%cog%", "12.34e15");
    test("%cog%", "12.34e+15");
    test("%cog%", "12.34e-15");
    test("%cog%", "12.34e-1a");
    test("%cog%", "-12.34e-1a");
    test("%cog%", "-12.34E-1a");
    test("%cog%", "+oo");
    test("%cog%", "-oo");
    test("%cog%", "oo");
    test("%cog%", "+infinity");
    test("%cog%", "-infinity");
    test("%cog%", "infinity");
    test("%cog%", "+infinitye15");
    test("%cog%", "-infinitye+15");
    test("%cog%", "infinitye-15");

    test("%xg%", "12");
    test("%xg%", "12ab");
    test("%xg%", "12.");
    test("%xg%", "12.ab");
    test("%xg%", "12.34");
    test("%xg%", "12.34ab");
    test("%xg%", "12e15");
    test("%xg%", "12.e15");
    test("%xg%", "12.34e15");
    test("%xg%", "12.34e+15");
    test("%xg%", "12.34e-15");
    test("%xg%", "12.34e-1a");
    test("%xg%", "-12.34e-1a");
    test("%xg%", "-12.34E-1a");
    test("%xg%", "12x15");
    test("%xg%", "12.x15");
    test("%xg%", "12.34x15");
    test("%xg%", "12.34x+15");
    test("%xg%", "12.34x-15");
    test("%xg%", "12.34x-1a");
    test("%xg%", "-12.34x-1a");
    test("%xg%", "-12.34X-1a");
    test("%xg%", "+oo");
    test("%xg%", "-oo");
    test("%xg%", "oo");
    test("%xg%", "+infinity");
    test("%xg%", "-infinity");
    test("%xg%", "infinity");
    test("%xg%", "+infinitye15");
    test("%xg%", "-infinitye+15");
    test("%xg%", "infinitye-15");

    test("%cxg%", "12");
    test("%cxg%", "12ab");
    test("%cxg%", "12.");
    test("%cxg%", "12.ab");
    test("%cxg%", "12.34");
    test("%cxg%", "12.34ab");
    test("%cxg%", "12e15");
    test("%cxg%", "12.e15");
    test("%cxg%", "12.34e15");
    test("%cxg%", "12.34e+15");
    test("%cxg%", "12.34e-15");
    test("%cxg%", "12.34e-1a");
    test("%cxg%", "-12.34e-1a");
    test("%cxg%", "-12.34E-1a");
    test("%cxg%", "12x15");
    test("%cxg%", "12.x15");
    test("%cxg%", "12.34x15");
    test("%cxg%", "12.34x+15");
    test("%cxg%", "12.34x-f5");
    test("%cxg%", "12.34x-fa");
    test("%cxg%", "-12.34x-fa");
    test("%cxg%", "-12.34X-fa");
    test("%cxg%", "+oo");
    test("%cxg%", "-oo");
    test("%cxg%", "oo");
    test("%cxg%", "+infinity");
    test("%cxg%", "-infinity");
    test("%cxg%", "infinity");
    test("%cxg%", "+infinitye15");
    test("%cxg%", "-infinitye+15");
    test("%cxg%", "infinitye-15");

    test("%g%", "12");
    test("%g%", "12ab");
    test("%g%", "12.");
    test("%g%", "12.ab");
    test("%g%", "12.34");
    test("%g%", "12.34ab");
    test("%g%", "12e15");
    test("%g%", "12.e15");
    test("%g%", "12.34e15");
    test("%g%", "12.34e+15");
    test("%g%", "12.34e-15");
    test("%g%", "12.34e-1a");
    test("%g%", "-12.34e-1a");
    test("%g%", "-12.34E-1a");
    test("%g%", "+oo");
    test("%g%", "-oo");
    test("%g%", "oo");
    test("%g%", "+infinity");
    test("%g%", "-infinity");
    test("%g%", "infinity");
    test("%g%", "+infinitye15");
    test("%g%", "-infinitye+15");
    test("%g%", "infinitye-15");
    test("%g%", "0x12");
    test("%g%", "0x12ab");
    test("%g%", "0x12.");
    test("%g%", "0x12.ab");
    test("%g%", "0x12.34");
    test("%g%", "0x12.34ab");
    test("%g%", "0x12e15");
    test("%g%", "0x12.e15");
    test("%g%", "0x12.34e15");
    test("%g%", "0x12.34e+15");
    test("%g%", "0x12.34e-15");
    test("%g%", "0x12.34e-1a");
    test("%g%", "0x-12.34e-1a");
    test("%g%", "0x-12.34E-1a");
    test("%g%", "0x12x15");
    test("%g%", "0x12.x15");
    test("%g%", "0x12.34x15");
    test("%g%", "0x12.34x+15");
    test("%g%", "0x12.34x-15");
    test("%g%", "0x12.34x-1a");
    test("%g%", "0x-12.34x-1a");
    test("%g%", "0x-12.34X-1a");
    test("%g%", "0x+oo");
    test("%g%", "0x-oo");
    test("%g%", "0xoo");
    test("%g%", "0x+infinity");
    test("%g%", "0x-infinity");
    test("%g%", "0xinfinity");
    test("%g%", "0x+infinitye15");
    test("%g%", "0x-infinitye+15");
    test("%g%", "0xinfinitye-15");

    test("%cg%", "12");
    test("%cg%", "12ab");
    test("%cg%", "12.");
    test("%cg%", "12.ab");
    test("%cg%", "12.34");
    test("%cg%", "12.34ab");
    test("%cg%", "12e15");
    test("%cg%", "12.e15");
    test("%cg%", "12.34e15");
    test("%cg%", "12.34e+15");
    test("%cg%", "12.34e-15");
    test("%cg%", "12.34e-1a");
    test("%cg%", "-12.34e-1a");
    test("%cg%", "-12.34E-1a");
    test("%cg%", "+oo");
    test("%cg%", "-oo");
    test("%cg%", "oo");
    test("%cg%", "+infinity");
    test("%cg%", "-infinity");
    test("%cg%", "infinity");
    test("%cg%", "+infinitye15");
    test("%cg%", "-infinitye+15");
    test("%cg%", "infinitye-15");
    test("%cg%", "0X12");
    test("%cg%", "0X12ab");
    test("%cg%", "0X12.");
    test("%cg%", "0X12.ab");
    test("%cg%", "0X12.34");
    test("%cg%", "0X12.34ab");
    test("%cg%", "0X12e15");
    test("%cg%", "0X12.e15");
    test("%cg%", "0X12.34e15");
    test("%cg%", "0X12.34e+15");
    test("%cg%", "0X12.34e-15");
    test("%cg%", "0X12.34e-1a");
    test("%cg%", "0X-12.34e-1a");
    test("%cg%", "0X-12.34E-1a");
    test("%cg%", "0X12x15");
    test("%cg%", "0X12.x15");
    test("%cg%", "0X12.34x15");
    test("%cg%", "0X12.34x+15");
    test("%cg%", "0X12.34x-f5");
    test("%cg%", "0X12.34x-fa");
    test("%cg%", "0X-12.34x-fa");
    test("%cg%", "0X-12.34X-fa");
    test("%cg%", "0X+oo");
    test("%cg%", "0X-oo");
    test("%cg%", "0Xoo");
    test("%cg%", "0X+infinity");
    test("%cg%", "0X-infinity");
    test("%cg%", "0Xinfinity");
    test("%cg%", "0X+infinitye15");
    test("%cg%", "0X-infinitye+15");
    test("%cg%", "0Xinfinitye-15");

    test("%dr%", "12");
    test("%dr%", "12ab");
    test("%dr%", "12/");
    test("%dr%", "12/ab");
    test("%dr%", "12/3");
    test("%dr%", "12/3ab");
    test("%dr%", "-12/3ab");
    test("%dr%", "-12./3ab");
    test("%dr%", "-12.7/3ab");
    test("%dr%", "-12.7e5/3ab");
    test("%dr%", "-12e5/3ab");
    test("%dr%", "-12.7x5/3ab");
    test("%dr%", "-12x5/3ab");
    test("%dr%", "oo");
    test("%dr%", "oo/");
    test("%dr%", "oo/12");
    test("%dr%", "+oo");
    test("%dr%", "-oo");
    test("%dr%", "12/oo");
    test("%dr%", "12/-3");

    test("%cdr%", "12");
    test("%cdr%", "12ab");
    test("%cdr%", "12/");
    test("%cdr%", "12/ab");
    test("%cdr%", "12/3");
    test("%cdr%", "12/3ab");
    test("%cdr%", "-12/3ab");
    test("%cdr%", "-12./3ab");
    test("%cdr%", "-12.7/3ab");
    test("%cdr%", "-12.7e5/3ab");
    test("%cdr%", "-12e5/3ab");
    test("%cdr%", "-12.7x5/3ab");
    test("%cdr%", "-12x5/3ab");
    test("%cdr%", "oo");
    test("%cdr%", "oo/");
    test("%cdr%", "oo/12");
    test("%cdr%", "+oo");
    test("%cdr%", "-oo");
    test("%cdr%", "12/oo");
    test("%cdr%", "12/-3");

    test("%or%", "12");
    test("%or%", "12ab");
    test("%or%", "12/");
    test("%or%", "12/ab");
    test("%or%", "12/3");
    test("%or%", "12/3ab");
    test("%or%", "-12/3ab");
    test("%or%", "-12./3ab");
    test("%or%", "-12.7/3ab");
    test("%or%", "-12.7e5/3ab");
    test("%or%", "-12e5/3ab");
    test("%or%", "-12.7x5/3ab");
    test("%or%", "-12x5/3ab");
    test("%or%", "oo");
    test("%or%", "oo/");
    test("%or%", "oo/12");
    test("%or%", "+oo");
    test("%or%", "-oo");
    test("%or%", "12/oo");
    test("%or%", "12/-3");

    test("%cor%", "12");
    test("%cor%", "12ab");
    test("%cor%", "12/");
    test("%cor%", "12/ab");
    test("%cor%", "12/3");
    test("%cor%", "12/3ab");
    test("%cor%", "-12/3ab");
    test("%cor%", "-12./3ab");
    test("%cor%", "-12.7/3ab");
    test("%cor%", "-12.7e5/3ab");
    test("%cor%", "-12e5/3ab");
    test("%cor%", "-12.7x5/3ab");
    test("%cor%", "-12x5/3ab");
    test("%cor%", "oo");
    test("%cor%", "oo/");
    test("%cor%", "oo/12");
    test("%cor%", "+oo");
    test("%cor%", "-oo");
    test("%cor%", "12/oo");
    test("%cor%", "12/-3");

    test("%xr%", "12");
    test("%xr%", "12ab");
    test("%xr%", "12/");
    test("%xr%", "12/ab");
    test("%xr%", "12/3");
    test("%xr%", "12/3ab");
    test("%xr%", "-12/3ab");
    test("%xr%", "-12./3ab");
    test("%xr%", "-12.7/3ab");
    test("%xr%", "-12.7e5/3ab");
    test("%xr%", "-12e5/3ab");
    test("%xr%", "-12.7x5/3ab");
    test("%xr%", "-12x5/3ab");
    test("%xr%", "oo");
    test("%xr%", "oo/");
    test("%xr%", "oo/12");
    test("%xr%", "+oo");
    test("%xr%", "-oo");
    test("%xr%", "12/oo");
    test("%xr%", "12/-3");

    test("%cxr%", "12");
    test("%cxr%", "12ab");
    test("%cxr%", "12/");
    test("%cxr%", "12/ab");
    test("%cxr%", "12/3");
    test("%cxr%", "12/3ab");
    test("%cxr%", "-12/3ab");
    test("%cxr%", "-12./3ab");
    test("%cxr%", "-12.7/3ab");
    test("%cxr%", "-12.7e5/3ab");
    test("%cxr%", "-12e5/3ab");
    test("%cxr%", "-12.7x5/3ab");
    test("%cxr%", "-12x5/3ab");
    test("%cxr%", "oo");
    test("%cxr%", "oo/");
    test("%cxr%", "oo/12");
    test("%cxr%", "+oo");
    test("%cxr%", "-oo");
    test("%cxr%", "12/oo");
    test("%cxr%", "12/-3");

    test("%r%", "12");
    test("%r%", "12ab");
    test("%r%", "12/");
    test("%r%", "12/ab");
    test("%r%", "12/3");
    test("%r%", "12/3ab");
    test("%r%", "-12/3ab");
    test("%r%", "-12./3ab");
    test("%r%", "-12.7/3ab");
    test("%r%", "-12.7e5/3ab");
    test("%r%", "-12e5/3ab");
    test("%r%", "-12.7x5/3ab");
    test("%r%", "-12x5/3ab");
    test("%r%", "oo");
    test("%r%", "oo/");
    test("%r%", "oo/12");
    test("%r%", "+oo");
    test("%r%", "-oo");
    test("%r%", "12/oo");
    test("%r%", "12/-3");
    test("%r%", "0x12");
    test("%r%", "0x12ab");
    test("%r%", "0x12/");
    test("%r%", "0x12/ab");
    test("%r%", "0x12/3");
    test("%r%", "0x12/3ab");
    test("%r%", "0x-12/3ab");
    test("%r%", "0x-12./3ab");
    test("%r%", "0x-12.7/3ab");
    test("%r%", "0x-12.7e5/3ab");
    test("%r%", "0x-12e5/3ab");
    test("%r%", "0x-12.7x5/3ab");
    test("%r%", "0x-12x5/3ab");
    test("%r%", "0xoo");
    test("%r%", "0xoo/");
    test("%r%", "0xoo/12");
    test("%r%", "0x+oo");
    test("%r%", "0x-oo");
    test("%r%", "0x12/oo");
    test("%r%", "0x12/-3");
    test("%r%", "12/0xab");
    test("%r%", "12/0x3");
    test("%r%", "12/0x3ab");
    test("%r%", "-12/0x3ab");
    test("%r%", "-12./0x3ab");
    test("%r%", "-12.7/0x3ab");
    test("%r%", "-12.7e5/0x3ab");
    test("%r%", "-12e5/0x3ab");
    test("%r%", "-12.7x5/0x3ab");
    test("%r%", "-12x5/0x3ab");
    test("%r%", "oo/0x12");
    test("%r%", "12/0xoo");
    test("%r%", "12/0x-3");
    test("%r%", "0x12/0xab");
    test("%r%", "0x12/0x3");
    test("%r%", "0x12/0x3ab");
    test("%r%", "0x-12/0x3ab");
    test("%r%", "0x-12./0x3ab");
    test("%r%", "0x-12.7/0x3ab");
    test("%r%", "0x-12.7e5/0x3ab");
    test("%r%", "0x-12e5/0x3ab");
    test("%r%", "0x-12.7x5/0x3ab");
    test("%r%", "0x-12x5/0x3ab");
    test("%r%", "0xoo/0x12");
    test("%r%", "0x12/0xoo");
    test("%r%", "0x12/0x-3");

    test("%cr%", "12");
    test("%cr%", "12ab");
    test("%cr%", "12/");
    test("%cr%", "12/ab");
    test("%cr%", "12/3");
    test("%cr%", "12/3ab");
    test("%cr%", "-12/3ab");
    test("%cr%", "-12./3ab");
    test("%cr%", "-12.7/3ab");
    test("%cr%", "-12.7e5/3ab");
    test("%cr%", "-12e5/3ab");
    test("%cr%", "-12.7x5/3ab");
    test("%cr%", "-12x5/3ab");
    test("%cr%", "oo");
    test("%cr%", "oo/");
    test("%cr%", "oo/12");
    test("%cr%", "+oo");
    test("%cr%", "-oo");
    test("%cr%", "12/oo");
    test("%cr%", "12/-3");
    test("%cr%", "0x12");
    test("%cr%", "0x12ab");
    test("%cr%", "0x12/");
    test("%cr%", "0x12/ab");
    test("%cr%", "0x12/3");
    test("%cr%", "0x12/3ab");
    test("%cr%", "0x-12/3ab");
    test("%cr%", "0x-12./3ab");
    test("%cr%", "0x-12.7/3ab");
    test("%cr%", "0x-12.7e5/3ab");
    test("%cr%", "0x-12e5/3ab");
    test("%cr%", "0x-12.7x5/3ab");
    test("%cr%", "0x-12x5/3ab");
    test("%cr%", "0xoo");
    test("%cr%", "0xoo/");
    test("%cr%", "0xoo/12");
    test("%cr%", "0x+oo");
    test("%cr%", "0x-oo");
    test("%cr%", "0x12/oo");
    test("%cr%", "0x12/-3");
    test("%cr%", "12/0xab");
    test("%cr%", "12/0x3");
    test("%cr%", "12/0x3ab");
    test("%cr%", "-12/0x3ab");
    test("%cr%", "-12./0x3ab");
    test("%cr%", "-12.7/0x3ab");
    test("%cr%", "-12.7e5/0x3ab");
    test("%cr%", "-12e5/0x3ab");
    test("%cr%", "-12.7x5/0x3ab");
    test("%cr%", "-12x5/0x3ab");
    test("%cr%", "oo/0x12");
    test("%cr%", "12/0xoo");
    test("%cr%", "12/0x-3");
    test("%cr%", "0x12/0xab");
    test("%cr%", "0x12/0x3");
    test("%cr%", "0x12/0x3ab");
    test("%cr%", "0x-12/0x3ab");
    test("%cr%", "0x-12./0x3ab");
    test("%cr%", "0x-12.7/0x3ab");
    test("%cr%", "0x-12.7e5/0x3ab");
    test("%cr%", "0x-12e5/0x3ab");
    test("%cr%", "0x-12.7x5/0x3ab");
    test("%cr%", "0x-12x5/0x3ab");
    test("%cr%", "0xoo/0x12");
    test("%cr%", "0x12/0xoo");
    test("%cr%", "0x12/0x-3");

    test("%v%", "12");
    test("%v%", "12ab");
    test("%v%", "12/");
    test("%v%", "12/ab");
    test("%v%", "12/3");
    test("%v%", "12/3ab");
    test("%v%", "-12/3ab");
    test("%v%", "-12./3ab");
    test("%v%", "-12.7/3ab");
    test("%v%", "-12.7e5/3ab");
    test("%v%", "-12e5/3ab");
    test("%v%", "-12.7x5/3ab");
    test("%v%", "-12x5/3ab");
    test("%v%", "oo");
    test("%v%", "oo/");
    test("%v%", "oo/12");
    test("%v%", "+oo");
    test("%v%", "-oo");
    test("%v%", "12/oo");
    test("%v%", "12/-3");
    test("%v%", "0x12");
    test("%v%", "0x12ab");
    test("%v%", "0x12/");
    test("%v%", "0x12/ab");
    test("%v%", "0x12/3");
    test("%v%", "0x12/3ab");
    test("%v%", "0x-12/3ab");
    test("%v%", "0x-12./3ab");
    test("%v%", "0x-12.7/3ab");
    test("%v%", "0x-12.7e5/3ab");
    test("%v%", "0x-12e5/3ab");
    test("%v%", "0x-12.7x5/3ab");
    test("%v%", "0x-12x5/3ab");
    test("%v%", "0xoo");
    test("%v%", "0xoo/");
    test("%v%", "0xoo/12");
    test("%v%", "0x+oo");
    test("%v%", "0x-oo");
    test("%v%", "0x12/oo");
    test("%v%", "0x12/-3");
    test("%v%", "12/0xab");
    test("%v%", "12/0x3");
    test("%v%", "12/0x3ab");
    test("%v%", "-12/0x3ab");
    test("%v%", "-12./0x3ab");
    test("%v%", "-12.7/0x3ab");
    test("%v%", "-12.7e5/0x3ab");
    test("%v%", "-12e5/0x3ab");
    test("%v%", "-12.7x5/0x3ab");
    test("%v%", "-12x5/0x3ab");
    test("%v%", "oo/0x12");
    test("%v%", "12/0xoo");
    test("%v%", "12/0x-3");
    test("%v%", "0x12/0xab");
    test("%v%", "0x12/0x3");
    test("%v%", "0x12/0x3ab");
    test("%v%", "0x-12/0x3ab");
    test("%v%", "0x-12./0x3ab");
    test("%v%", "0x-12.7/0x3ab");
    test("%v%", "0x-12.7e5/0x3ab");
    test("%v%", "0x-12e5/0x3ab");
    test("%v%", "0x-12.7x5/0x3ab");
    test("%v%", "0x-12x5/0x3ab");
    test("%v%", "0xoo/0x12");
    test("%v%", "0x12/0xoo");
    test("%v%", "0x12/0x-3");
    test("%v%", "true");
    test("%v%", "trueab");
    test("%v%", "false");
    test("%v%", "falseab");
    test("%v%", "null");
    test("%v%", "nullab");
    test("%v%", "\"abc\"");
    test("%v%", "\"abc");
    test("%v%", "\"abc\"de");
    test("%v%", "\"ab\\\"c\"");
    test("%v%", "\"ab\\nc\"");
    test("%v%", "\"ab\\\\c\"");
    test("%v%", "'a'");
    test("%v%", "'a'b");
    test("%v%", "'a");
    test("%v%", "'ab'");
    test("%v%", "'\\''");
    test("%v%", "'\\\"'");
    test("%v%", "'\\n'");
    test("%v%", "'\\\\'");
    test("%v%", "@ab@");
    test("%v%", "@ab");
    test("%v%", "@(a|b)*c@");
    test("%v%", "@ab\\@c@");
    test("%v%", "[1,2,3]");
    test("%v%", "[1,2,3]ab");
    test("%v%", "[ 1 , 2 , 3 ] ab");
    test("%v%", "[1, [2, 3], 4] ab");
    test("%v%", "[1, [-2, 3], -4] ab");
    test("%v%", "[11, [-22, 31], -14] ab");
    test("%v%", "[11, a:=[-22, 31], -14] ab");
    test("%v%", "[11, a := [-22, 31], -14] ab");
    test("%v%", "<<>>");
    test("%v%", "<<  >>");
    test("%v%", "<<(*-->15)>>");
    test("%v%", "<<(3-->33),(4-->44)>>");
    test("%v%", "<< ( 3 --> 33 ) , ( 4 --> 44 ) >> ab");
    test("%v%", "<<(3 --> 33), (4 --> 44), (4 --> 45)>> ab");
    test("%v%", "<<(* --> 45), (3 --> 33), (4 --> 44)>> ab");
    test("%v%", "<<(3 --> 33), (4 --> 44), (* --> 45), (* -->55)>> ab");
    test("%v%", "<<(* --> -45), (3 --> 33), (4 --> 44)>> ab");
    test("%v%", "<<(* --> -45), (3 --> 33.7e-4), (4 --> 44.7)>> ab");
    test("%v%", "{}");
    test("%v%", "{17,82}");
    test("%v%", "{ 17 , 82 } ab");
    test("%v%", "{17, 82, 17} ab");
    test("%v%", "{17, 0x82, [a := -17]} ab");

    test("%cv%", "12");
    test("%cv%", "12ab");
    test("%cv%", "12/");
    test("%cv%", "12/ab");
    test("%cv%", "12/3");
    test("%cv%", "12/3ab");
    test("%cv%", "-12/3ab");
    test("%cv%", "-12./3ab");
    test("%cv%", "-12.7/3ab");
    test("%cv%", "-12.7e5/3ab");
    test("%cv%", "-12e5/3ab");
    test("%cv%", "-12.7x5/3ab");
    test("%cv%", "-12x5/3ab");
    test("%cv%", "oo");
    test("%cv%", "oo/");
    test("%cv%", "oo/12");
    test("%cv%", "+oo");
    test("%cv%", "-oo");
    test("%cv%", "12/oo");
    test("%cv%", "12/-3");
    test("%cv%", "0x12");
    test("%cv%", "0x12ab");
    test("%cv%", "0x12/");
    test("%cv%", "0x12/ab");
    test("%cv%", "0x12/3");
    test("%cv%", "0x12/3ab");
    test("%cv%", "0x-12/3ab");
    test("%cv%", "0x-12./3ab");
    test("%cv%", "0x-12.7/3ab");
    test("%cv%", "0x-12.7e5/3ab");
    test("%cv%", "0x-12e5/3ab");
    test("%cv%", "0x-12.7x5/3ab");
    test("%cv%", "0x-12x5/3ab");
    test("%cv%", "0xoo");
    test("%cv%", "0xoo/");
    test("%cv%", "0xoo/12");
    test("%cv%", "0x+oo");
    test("%cv%", "0x-oo");
    test("%cv%", "0x12/oo");
    test("%cv%", "0x12/-3");
    test("%cv%", "12/0xab");
    test("%cv%", "12/0x3");
    test("%cv%", "12/0x3ab");
    test("%cv%", "-12/0x3ab");
    test("%cv%", "-12./0x3ab");
    test("%cv%", "-12.7/0x3ab");
    test("%cv%", "-12.7e5/0x3ab");
    test("%cv%", "-12e5/0x3ab");
    test("%cv%", "-12.7x5/0x3ab");
    test("%cv%", "-12x5/0x3ab");
    test("%cv%", "oo/0x12");
    test("%cv%", "12/0xoo");
    test("%cv%", "12/0x-3");
    test("%cv%", "0x12/0xab");
    test("%cv%", "0x12/0x3");
    test("%cv%", "0x12/0x3ab");
    test("%cv%", "0x-12/0x3ab");
    test("%cv%", "0x-12./0x3ab");
    test("%cv%", "0x-12.7/0x3ab");
    test("%cv%", "0x-12.7e5/0x3ab");
    test("%cv%", "0x-12e5/0x3ab");
    test("%cv%", "0x-12.7x5/0x3ab");
    test("%cv%", "0x-12x5/0x3ab");
    test("%cv%", "0xoo/0x12");
    test("%cv%", "0x12/0xoo");
    test("%cv%", "0x12/0x-3");
    test("%cv%", "true");
    test("%cv%", "trueab");
    test("%cv%", "false");
    test("%cv%", "falseab");
    test("%cv%", "null");
    test("%cv%", "nullab");
    test("%cv%", "\"abc\"");
    test("%cv%", "\"abc");
    test("%cv%", "\"abc\"de");
    test("%cv%", "\"ab\\\"c\"");
    test("%cv%", "\"ab\\nc\"");
    test("%cv%", "\"ab\\\\c\"");
    test("%cv%", "'a'");
    test("%cv%", "'a'b");
    test("%cv%", "'a");
    test("%cv%", "'ab'");
    test("%cv%", "'\\''");
    test("%cv%", "'\\\"'");
    test("%cv%", "'\\n'");
    test("%cv%", "'\\\\'");
    test("%cv%", "@ab@");
    test("%cv%", "@ab");
    test("%cv%", "@(a|b)*c@");
    test("%cv%", "@ab\\@c@");
    test("%cv%", "[1,2,3]");
    test("%cv%", "[1,2,3]ab");
    test("%cv%", "[ 1 , 2 , 3 ] ab");
    test("%cv%", "[1, [2, 3], 4] ab");
    test("%cv%", "[1, [-2, 3], -4] ab");
    test("%cv%", "[11, [-22, 31], -14] ab");
    test("%cv%", "[11, a:=[-22, 31], -14] ab");
    test("%cv%", "[11, a := [-22, 31], -14] ab");
    test("%cv%", "<<>>");
    test("%cv%", "<<  >>");
    test("%cv%", "<<(*-->15)>>");
    test("%cv%", "<<(3-->33),(4-->44)>>");
    test("%cv%", "<< ( 3 --> 33 ) , ( 4 --> 44 ) >> ab");
    test("%cv%", "<<(3 --> 33), (4 --> 44), (4 --> 45)>> ab");
    test("%cv%", "<<(* --> 45), (3 --> 33), (4 --> 44)>> ab");
    test("%cv%", "<<(3 --> 33), (4 --> 44), (* --> 45), (* -->55)>> ab");
    test("%cv%", "<<(* --> -45), (3 --> 33), (4 --> 44)>> ab");
    test("%cv%", "<<(* --> -45), (3 --> 33.7e-4), (4 --> 44.7)>> ab");
    test("%cv%", "{}");
    test("%cv%", "{17,82}");
    test("%cv%", "{ 17 , 82 } ab");
    test("%cv%", "{17, 82, 17} ab");
    test("%cv%", "{17, 0x82, [a := -17]} ab");

    test("%v%, %v%, %v%", "17, 18, 19");
    test("%a:v%, %v%, %v%", "17, 18, 19");
    test("%v%, %b:v%, %v%", "17, 18, 19");
    test("%v%, %v%, %c:v%", "17, 18, 19");
    test("%a:v%, %b:v%, %c:v%", "17, 18, 19");
    test("%operator+:v%, %b:v%, %operator:::v%", "17, 18, 19");
  };


/* Next, we'll try testing dynamic function return types. */

  {
    function return_a(a : type !{}) returns !{} / a
      { return 12; };

    procedure test(a : type !{})
      {
        print("Testing return_a(\"", a, "\"):\n");
        try
          {
            immutable result := return_a(a);
            print("    No exception.\n");
            print("    Result: `", result, "'.\n");
          }
        catch
          {
            print("    Exception: `", current_exceptions()[0].message, "'.\n");
          };
      };
    test(integer);
    test(type {12, 13, 14});
    test(type {13, 14, 15});
  };


/* Next, we'll try testing dynamic function parameter types. */

  {
    function to_test(a : integer / a_type,
            b : [integer, integer] / [b_type, b_type], a_type : type !{},
            b_type : type !{}) returns {12}
      {
        return 12;
      };

    procedure test(a : integer, b : [integer, integer], a_type : type !{},
                   b_type : type !{})
      {
        print("Testing to_test(", a, ", ", b, ", ", a_type, ", ", b_type,
              "):\n");
        try
          {
            immutable result := to_test(a, b, a_type, b_type);
            print("    No exception.\n");
          }
        catch
          {
            print("    Exception: `", current_exceptions()[0].message, "'.\n");
          };
      };

    test(1, [2, 3], integer, integer);
    test(1, [2, 3], type {1, 2, 3}, type {1, 2, 3});
    test(1, [2, 3], type {2, 3}, type {1, 2, 3});
    test(1, [2, 3], type {1, 2, 3}, type {2, 3});
    test(1, [2, 3], type {1, 2, 3}, type {1, 3});
  };


/* Next, we'll try testing iterate statements on objects. */

  {
    procedure test(subject)
      {
        print("Testing ", subject, ":\n");
        try
          {
            variable first : boolean := true;
            print("[");
            iterate (item; subject)
              {
                if (first)
                  { first := false; }
                else
                  { print(", "); };
                printf("%v%", item);
              };
            print("].\n");
            print("    No exception.\n");
          }
        catch
          {
            print("    Exception: `", current_exceptions()[0].message, "'.\n");
          };
      };

    test([1, 2, 3]);

    class aaa(start : [1...+oo))
      {
        hide;

        variable current_value : [1...+oo) := start;
        variable finished : boolean := false;

        export;

        function is_done() returns boolean  (finished);
        function current() returns [1...+oo)
          { return current_value; };
        procedure step()
          {
            assert(!finished);
            if (current_value == 1)
              {
                finished := true;
                return;
              };
            current_value := ((current_value * 3) + 1);
            while ((current_value % 2) == 0)
              { current_value /= 2; };
          };
        function sprint()  ("aaa(" ~ sprint(start) ~ ")");
      };

    class bbb(start : [1...+oo))
      {
        function iterator()  (aaa(start));
        function sprint()  ("bbb(" ~ sprint(start) ~ ")");
      };

    class no_is_done(start : [1...+oo))
      {
        function iterator() (class() { use aaa(start) except is_done; }());
        function sprint() ("no_is_done(" ~ sprint(start) ~ ")");
      };
    class no_current(start : [1...+oo))
      {
        function iterator() (class() { use aaa(start) except current; }());
        function sprint() ("no_current(" ~ sprint(start) ~ ")");
      };
    class no_step(start : [1...+oo))
      {
        function iterator() (class() { use aaa(start) except step; }());
        function sprint() ("no_step(" ~ sprint(start) ~ ")");
      };

    test(aaa(1));
    test(bbb(1));
    test(bbb(2));
    test(bbb(3));
    test(bbb(57));
    immutable ccc := bbb(108);
    test(ccc);
    test(ccc);
    test(no_is_done(108));
    test(no_current(108));
    test(no_step(108));
  };


/* Next, we'll try testing function expressions with expression bodies. */

  {
    procedure run(f : !{} <-- (integer))
      {
        print("f(1): ", f(1), ".\n");
        print("f(2): ", f(2), ".\n");
      };
    run(function(x)(x + 3));
    run(function(x)(x < 2));
  };


/* Next, we'll try testing the ``ageless'' modifier. */

  {
    function f1(x : integer) returns boolean <-- (integer)
      {
        ageless immutable lower_bound : integer := x;
        return function(y : integer) returns boolean (y >= lower_bound);
      };

    print("f1(1)(2): ", f1(1)(2), ".\n");
    print("f1(1)(0): ", f1(1)(0), ".\n");

    function f2(ageless x : integer) returns boolean <-- (integer)
      {
        return function(y : integer) returns boolean (y >= x);
      };

    print("f2(1)(2): ", f2(1)(2), ".\n");
    print("f2(1)(0): ", f2(1)(0), ".\n");

    function f3(x : integer) returns boolean <-- (integer)
      {
        function f4() returns boolean <-- (integer)
          {
            static ageless immutable lower_bound : integer := x;
            return function(y : integer) returns boolean (y >= lower_bound);
          };
        return f4();
      };

    print("f3(1)(2): ", f3(1)(2), ".\n");
    print("f3(1)(0): ", f3(1)(0), ".\n");

    function f5(ageless x : integer) returns boolean <-- (integer)
      {
        ageless function f6(y : integer) returns boolean (y >= x);
        return f6;
      };

    immutable f7 := f5(1);
    print("f7(2): ", f7(2), ".\n");
    print("f7(0): ", f7(0), ".\n");
    delete(f7);

    function f8()
      {
        ageless tagalong a;
        return a;
      };

    immutable t1 := f8();
    immutable t2 := f8();
    variable v1 := 8;
    v1..t1 := 12;
    v1..t2 := 13;
    print("v1..t1: ", v1..t1, ".\n");
    print("v1..t2: ", v1..t2, ".\n");

    function f9()
      {
        ageless lepton a[x : integer, y : integer];
        return a;
      };

    immutable v2 := f9()[x := 15, y := 16];
    print("v2.x: ", v2.x, ".\n");
    print("v2.y: ", v2.y, ".\n");

    function f10()
      {
        ageless quark a;
        return a;
      };

    immutable a1 := f10();
    immutable a2 := f10();
    print("a1 == a1: ", a1 == a1, ".\n");
    print("a1 == a2: ", a1 == a2, ".\n");

    function f11()
      {
        ageless lock a;
        return a;
      };

    single(f11()) { print("In single(f11()).\n"); };
  };


/* Next, we'll try testing printing various kinds of values. */

  {
    /*
     * Printing some anonymous objects results in output that includes hex
     * digits that depend on the physical address of the object in memory.
     * That means the exact digits printed will vary across implementations.
     * To make the output of this test program portable, we will use the
     * following function to munge the output for those cases to substitute
     * ``XXX'' for the sequence of hex digits.
     */
    function sprint_with_munged_suffix(to_print) returns string
      (substitute(@0x[0-9a-fA-F]+@, sprint(to_print), "0xXXX"));

    procedure p1() { };
    print("A procedure named p1(): ", p1, ".\n");

    print("An anonymous procedure: ",
          sprint_with_munged_suffix(procedure() { }), ".\n");

    function f1() (1);
    print("A function named f1(): ", f1, ".\n");

    print("An anonymous function: ", sprint_with_munged_suffix(function() (1)),
          ".\n");

    tagalong t1;
    print("A tagalong key named t1: ", t1, ".\n");

    print("An anonymous tagalong key: ", sprint_with_munged_suffix(tagalong),
          ".\n");

    lepton l1[...];
    print("A lepton key named l1: ", l1, ".\n");
    print("A lepton l1[a := 10]: ", l1[a := 10], ".\n");

    print("An anonymous lepton key: ", sprint_with_munged_suffix(lepton[...]),
          ".\n");
    print("An anonymous lepton[a := 10]: ",
          sprint_with_munged_suffix(lepton[...][a := 10]), ".\n");

    quark q1;
    print("A quark named q1: ", q1, ".\n");

    print("An anonymous quark: ", sprint_with_munged_suffix(quark), ".\n");

    lock l2;
    print("A lock named l2: ", l2, ".\n");

    print("An anonymous lock: ", sprint_with_munged_suffix(lock), ".\n");

  j1:
    print("A jump target named j1: ", j1, ".\n");

    variable v1;
    print("The location of a variable named v1: ", &v1, ".\n");

    print("The location of an anonymous variable: ",
          sprint_with_munged_suffix(variable), ".\n");

    immutable i1;
    print("The location of a immutable named i1: ", &i1, ".\n");

    print("The location of an anonymous immutable: ",
          sprint_with_munged_suffix(immutable), ".\n");

    print("The location of a lookup of 1: ", &(v1[1]), ".\n");
    print("The location of a lookup of 3...5: ", &(v1[3...5]), ".\n");
    print("The location of a lookup of *: ", &(v1[*]), ".\n");
    print("The location of a multi-dimensional lookup: ", &(v1[1, 3...5, *]),
          ".\n");

    print("The location of a field named f1: ", &(v1.f1), ".\n");

    print("The location of a tagalong field named t1: ", &(v1..t1), ".\n");

    print("The location of an anonymous tagalong field: ",
          sprint_with_munged_suffix(&(v1..tagalong)), ".\n");

      {
        function operator->(:{5}) (5);
        print("The location of an overload &5->x: ", &(5->x), ".\n");
      };

      {
        function operator*(:{&v1}) (5);
        print("The location of &*&v1 where * is overloaded: ", &*&v1, ".\n");
      };
  };


/* Next, we'll try testing interface includes. */

  {
    immutable aaa := type interface[a : integer, b : string];
    print("aaa: ", aaa, ".\n");

    immutable bbb := type interface[include "multi_empty.si"];
    print("bbb: ", bbb, ".\n");

    immutable ccc :=
            type interface[a : integer, include "multi_empty.si", b : string];
    print("ccc: ", ccc, ".\n");

    immutable ddd := type interface[include "multi_one_item.si"];
    print("ddd: ", ddd, ".\n");

    immutable eee :=
            type interface[a : integer, include "multi_one_item.si",
                           b : string];
    print("eee: ", eee, ".\n");

    immutable fff := type interface[include "multi_two_items.si"];
    print("fff: ", fff, ".\n");

    immutable ggg :=
            type interface[a : integer, include "multi_two_items.si",
                           b : string];
    print("ggg: ", ggg, ".\n");
  };


/* Next, we'll try some more corner cases for exception handling. */

  {
      {
        print("Point pp1a.\n");
        try
          {
            print("Point pp1b.\n");
            cleanup
              {
                print("Point pp1c.\n");
                immutable a : string := 5;
                print("Point pp1d.\n");
              };
            print("Point pp1e.\n");
            goto pp1j;
            print("Point pp1f.\n");
          }
        handle (function(e : exception)
          {
            print("Point pp1g.\n");
            goto pp1j;
            print("Point pp1h.\n");
          });
        print("Point pp1i.\n");
      pp1j:
        print("Point pp1j.\n");
      };

      {
        print("Point pp2a.\n");
        try
          {
            print("Point pp2b.\n");
           try
             {
               print("Point pp2c.\n");
               cleanup
                 {
                   print("Point pp2d.\n");
                   immutable a : string := 5;
                   print("Point pp2e.\n");
                 };
               print("Point pp2f.\n");
               goto pp1i;
               print("Point pp2g.\n");
             }
           catch
             {
               iterate (e; current_exceptions())
                 { print("Point pp2h: `", e.message, "'.\n"); };
             };
            print("Point pp2i.\n");
          pp1i:
            print("Point pp2j.\n");
          }
        catch
          {
            iterate (e; current_exceptions())
              { print("Point pp2k: `", e.message, "'.\n"); };
          };
        print("Point pp2l.\n");
      };
  };


/* Next, we'll try some tests of value validation. */

  {
    procedure test(position : string, subject)
      {
        print("Position ", position, ": ");
        try
          {
            [] := [subject != 57];
            print("valid");
          }
        catch
          {
            print("invalid (");
            switch (current_exceptions()[0].tag)
            case ({exception_tag_variable_use_before_instantiation})
              {
                print("variable before instantiation");
              }
            case ({exception_tag_routine_use_before_instantiation})
              {
                print("routine before instantiation");
              }
            case ({exception_tag_tagalong_use_before_instantiation})
              {
                print("tagalong before instantiation");
              }
            case ({exception_tag_lepton_key_use_before_instantiation})
              {
                print("lepton key before instantiation");
              }
            case ({exception_tag_quark_use_before_instantiation})
              {
                print("quark before instantiation");
              }
            case ({exception_tag_lock_use_before_instantiation})
              {
                print("lock before instantiation");
              }
            case ({exception_tag_variable_use_after_deallocation})
              {
                print("variable after de-allocation");
              }
            case ({exception_tag_routine_use_after_deallocation})
              {
                print("routine after de-allocation");
              }
            case ({exception_tag_tagalong_use_after_deallocation})
              {
                print("tagalong after de-allocation");
              }
            case ({exception_tag_lepton_key_use_after_deallocation})
              {
                print("lepton key after de-allocation");
              }
            case ({exception_tag_quark_use_after_deallocation})
              {
                print("quark after de-allocation");
              }
            case ({exception_tag_lock_use_after_deallocation})
              {
                print("lock after de-allocation");
              }
            case ({exception_tag_jump_target_use_after_deallocation})
              {
                print("jump target after de-allocation");
              }
            case ({exception_tag_object_use_after_deallocation})
              {
                print("object after de-allocation");
              };
            print(")");
          };
        print(".\n");
      };

    variable p1;
      {
        test("1.1", &v1);
        p1 := &v1;
        test("1.2", p1);
        variable v1;
        test("1.3", &v1);
        test("1.4", p1);
      };
    test("1.5", p1);

    variable p2;
      {
        test("2.1", f1);
        p2 := f1;
        test("2.2", p2);
        function f1()  (15);
        test("2.3", f1);
        test("2.4", p2);
      };
    test("2.5", p2);

    variable p3;
      {
        test("3.1", t1);
        p3 := t1;
        test("3.2", p3);
        tagalong t1;
        test("3.3", t1);
        test("3.4", p3);
      };
    test("3.5", p3);

    variable p4;
      {
        test("4.1", l1);
        p4 := l1;
        test("4.2", p4);
        lepton l1;
        test("4.3", l1);
        test("4.4", p4);
      };
    test("4.5", p4);

    variable p5;
      {
        test("5.1", q1);
        p5 := q1;
        test("5.2", p5);
        quark q1;
        test("5.3", q1);
        test("5.4", p5);
      };
    test("5.5", p5);

    variable p6;
      {
        test("6.1", l1);
        p6 := l1;
        test("6.2", p6);
        lock l1;
        test("6.3", l1);
        test("6.4", p6);
      };
    test("6.5", p6);

    variable p7;
      {
        test("7.1", &v1);
        p7 := &v1;
        test("7.2", p7);
        ageless variable v1;
        test("7.3", &v1);
        test("7.4", p7);
      };
    test("7.5", p7);
    delete(p7);
    test("7.6", p7);

    variable p8;
      {
        test("8.1", f1);
        p8 := f1;
        test("8.2", p8);
        ageless function f1()  (15);
        test("8.3", f1);
        test("8.4", p8);
      };
    test("8.5", p8);
    delete(p8);
    test("8.6", p8);

    variable p9;
      {
        test("9.1", t1);
        p9 := t1;
        test("9.2", p9);
        ageless tagalong t1;
        test("9.3", t1);
        test("9.4", p9);
      };
    test("9.5", p9);
    delete(p9);
    test("9.6", p9);

    variable p10;
      {
        test("10.1", l1);
        p10 := l1;
        test("10.2", p10);
        ageless lepton l1;
        test("10.3", l1);
        test("10.4", p10);
      };
    test("10.5", p10);
    delete(p10);
    test("10.6", p10);

    variable p11;
      {
        test("11.1", q1);
        p11 := q1;
        test("11.2", p11);
        ageless quark q1;
        test("11.3", q1);
        test("11.4", p11);
      };
    test("11.5", p11);
    delete(p11);
    test("11.6", p11);

    variable p12;
      {
        test("12.1", l1);
        p12 := l1;
        test("12.2", p12);
        ageless lock l1;
        test("12.3", l1);
        test("12.4", p12);
      };
    test("12.5", p12);
    delete(p12);
    test("12.6", p12);

    immutable p13 := variable;
    test("13.1", p13);
    delete(p13);
    test("13.2", p13);

    immutable p14 := function()  (15);
    test("14.1", p14);
    delete(p14);
    test("14.2", p14);

    immutable p15 := tagalong;
    test("15.1", p15);
    delete(p15);
    test("15.2", p15);

    immutable p16 := lepton;
    test("16.1", p16);
    delete(p16);
    test("16.2", p16);

    immutable p17 := quark;
    test("17.1", p17);
    delete(p17);
    test("17.2", p17);

    immutable p18 := lock;
    test("18.1", p18);
    delete(p18);
    test("18.2", p18);

      {
        test("19.1", [&v1, &v2]);
        immutable i1 := [&v1, &v2];
        test("19.2", i1);
        ageless variable v1;
        test("19.3", [&v1, &v2]);
        test("19.4", i1);
        ageless variable v2;
        test("19.5", [&v1, &v2]);
        test("19.6", i1);
        delete(&v1);
        test("19.7", [&v1, &v2]);
        test("19.8", i1);
        delete(&v2);
        test("19.9", [&v1, &v2]);
        test("19.10", i1);
      };

      {
        test("20.1", <<(0 --> &v1), (1 --> &v2)>>);
        immutable i1 := <<(0 --> &v1), (1 --> &v2)>>;
        test("20.2", i1);
        ageless variable v1;
        test("20.3", <<(0 --> &v1), (1 --> &v2)>>);
        test("20.4", i1);
        ageless variable v2;
        test("20.5", <<(0 --> &v1), (1 --> &v2)>>);
        test("20.6", i1);
        delete(&v1);
        test("20.7", <<(0 --> &v1), (1 --> &v2)>>);
        test("20.8", i1);
        delete(&v2);
        test("20.9", <<(0 --> &v1), (1 --> &v2)>>);
        test("20.10", i1);
      };

      {
        test("21.1", <<(0 --> &v1), (1 --> &v2)>>);
        immutable i1 := <<(0 --> &v1), (1 --> &v2)>>;
        test("21.2", i1);
        ageless variable v1;
        test("21.3", <<(0 --> &v1), (1 --> &v2)>>);
        test("21.4", i1);
        ageless variable v2;
        test("21.5", <<(0 --> &v1), (1 --> &v2)>>);
        test("21.6", i1);
        delete(&v2);
        test("21.7", <<(0 --> &v1), (1 --> &v2)>>);
        test("21.8", i1);
        delete(&v1);
        test("21.9", <<(0 --> &v1), (1 --> &v2)>>);
        test("21.10", i1);
      };

      {
        test("22.1", [[&v1, &v2], [&v3, &v4]]);
        immutable i1 := [[&v1, &v2], [&v3, &v4]];
        test("22.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("22.3", [[&v1, &v2], [&v3, &v4]]);
        test("22.4", i1);
        ageless variable v4;
        test("22.5", [[&v1, &v2], [&v3, &v4]]);
        test("22.6", i1);
        delete(&v2);
        test("22.7", [[&v1, &v2], [&v3, &v4]]);
        test("22.8", i1);
        delete(&v3);
        delete(&v4);
        delete(&v1);
        test("22.9", [[&v1, &v2], [&v3, &v4]]);
        test("22.10", i1);
      };

      {
        test("23.1", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        immutable i1 := <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                          (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>;
        test("23.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("23.3", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("23.4", i1);
        ageless variable v4;
        test("23.5", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("23.6", i1);
        delete(&v2);
        test("23.7", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("23.8", i1);
        delete(&v3);
        delete(&v4);
        delete(&v1);
        test("23.9", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("23.10", i1);
      };

      {
        test("24.1", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        variable i1 := <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                         (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>;
        test("24.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("24.3", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("24.4", i1);
        i1[2, 2] := 15;
        test("24.5", i1);
        i1[2, 2] := &v4;
        test("24.6", i1);
        ageless variable v4;
        test("24.7", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("24.8", i1);
        delete(&v2);
        test("24.9", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("24.10", i1);
        i1[1, 2] := 18;
        test("24.11", i1);
        delete(&v3);
        test("24.12", i1);
        i1[2, 1] := 19;
        test("24.13", i1);
        delete(&v4);
        test("24.14", i1);
        i1[2, 2] := 20;
        test("24.15", i1);
        delete(&v1);
        test("24.16", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                        (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("24.17", i1);
        i1[1, 1] := 21;
        test("24.18", i1);
      };

      {
        test("25.1", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        variable i1 := <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                         (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>;
        test("25.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("25.3", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("25.4", i1);
        immutable i2 := i1;
        i1[2, 2] := 15;
        test("25.5", i1);
        i1[2, 2] := &v4;
        test("25.6", i1);
        ageless variable v4;
        test("25.7", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("25.8", i1);
        delete(&v2);
        test("25.9", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                       (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("25.10", i1);
        i1[1, 2] := 18;
        test("25.11", i1);
        delete(&v3);
        test("25.12", i1);
        i1[2, 1] := 19;
        test("25.13", i1);
        delete(&v4);
        test("25.14", i1);
        i1[2, 2] := 20;
        test("25.15", i1);
        delete(&v1);
        test("25.16", <<(1 --> <<(1 --> &v1), (2 --> &v2)>>),
                        (2 --> <<(1 --> &v3), (2 --> &v4)>>)>>);
        test("25.17", i1);
        i1[1, 1] := 21;
        test("25.18", i1);
      };

      {
        class c1()  { };
        immutable o1 := c1();
        immutable o2 := c1();
        immutable o3 := c1();
        immutable o4 := c1();
        test("26.1", <<(1 --> <<(1 --> o1), (2 --> o2)>>),
                       (2 --> <<(1 --> o3), (2 --> o4)>>)>>);
        variable i1 := <<(1 --> <<(1 --> o1), (2 --> o2)>>),
                         (2 --> <<(1 --> o3), (2 --> o4)>>)>>;
        test("26.2", i1);
        delete(o2);
        test("26.3", <<(1 --> <<(1 --> o1), (2 --> o2)>>),
                       (2 --> <<(1 --> o3), (2 --> o4)>>)>>);
        test("26.4", i1);
        i1[1, 2] := 18;
        test("26.5", i1);
        delete(o3);
        test("26.6", i1);
        i1[2, 1] := 19;
        test("26.7", i1);
        delete(o4);
        test("26.8", i1);
        i1[2, 2] := 20;
        test("26.9", i1);
        delete(o1);
        test("26.10", <<(1 --> <<(1 --> o1), (2 --> o2)>>),
                        (2 --> <<(1 --> o3), (2 --> o4)>>)>>);
        test("26.11", i1);
        i1[1, 1] := 21;
        test("26.12", i1);
      };

      {
        variable i1;
          {
          jt1:
              {
              jt4:
                  {
                  jt3:
                      {
                      jt2:
                        test("27.1", <<(1 --> <<(1 --> jt1), (2 --> jt2)>>),
                                       (2 --> <<(1 --> jt3), (2 --> jt4)>>)>>);
                        i1 := <<(1 --> <<(1 --> jt1), (2 --> jt2)>>),
                                (2 --> <<(1 --> jt3), (2 --> jt4)>>)>>;
                        test("27.2", i1);
                      };
                    test("27.3", i1);
                    i1[1, 2] := 18;
                    test("27.4", i1);
                  };
                test("27.5", i1);
                i1[2, 1] := 19;
                test("27.6", i1);
              };
            test("27.7", i1);
            i1[2, 2] := 20;
            test("27.8", i1);
          };
        test("27.9", i1);
        i1[1, 1] := 21;
        test("27.10", i1);
      };

      {
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        ageless variable v4;
        test("28.1", <<(1 --> <<(&v1 --> 1), (&v2 --> 2)>>),
                       (2 --> <<(&v3 --> 1), (&v4 --> 2)>>)>>);
        immutable i1 := <<(1 --> <<(&v1 --> 1), (&v2 --> 2)>>),
                          (2 --> <<(&v3 --> 1), (&v4 --> 2)>>)>>;
        test("28.2", i1);
        delete(&v2);
        test("28.3", i1);
        delete(&v3);
        delete(&v4);
        delete(&v1);
        test("28.4", i1);
      };

      {
        lepton aaa;
        test("29.1",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        variable i1 :=
                aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>];
        test("29.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("29.3",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("29.4", i1);
        i1.c[2] := 15;
        test("29.5", i1);
        i1.c[2] := &v4;
        test("29.6", i1);
        ageless variable v4;
        test("29.7",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("29.8", i1);
        delete(&v2);
        test("29.9",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("29.10", i1);
        i1.b := 18;
        test("29.11", i1);
        delete(&v3);
        test("29.12", i1);
        i1.c[1] := 19;
        test("29.13", i1);
        delete(&v4);
        test("29.14", i1);
        i1.c[2] := 20;
        test("29.15", i1);
        delete(&v1);
        test("29.16",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("29.17", i1);
        i1.a := 21;
        test("29.18", i1);
      };

      {
        lepton aaa;
        test("30.1",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        variable i1 :=
                aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>];
        test("30.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("30.3",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("30.4", i1);
        immutable i2 := i1;
        i1.c[2] := 15;
        test("30.5", i1);
        i1.c[2] := &v4;
        test("30.6", i1);
        ageless variable v4;
        test("30.7",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("30.8", i1);
        delete(&v2);
        test("30.9",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("30.10", i1);
        i1.b := 18;
        test("30.11", i1);
        delete(&v3);
        test("30.12", i1);
        i1.c[1] := 19;
        test("30.13", i1);
        delete(&v4);
        test("30.14", i1);
        i1.c[2] := 20;
        test("30.15", i1);
        delete(&v1);
        test("30.16",
             aaa[a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("30.17", i1);
        i1.a := 21;
        test("30.18", i1);
      };

      {
        test("31.1", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        variable i1 := [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>];
        test("31.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("31.3", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("31.4", i1);
        i1.c[2] := 15;
        test("31.5", i1);
        i1.c[2] := &v4;
        test("31.6", i1);
        ageless variable v4;
        test("31.7", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("31.8", i1);
        delete(&v2);
        test("31.9", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("31.10", i1);
        i1.b := 18;
        test("31.11", i1);
        delete(&v3);
        test("31.12", i1);
        i1.c[1] := 19;
        test("31.13", i1);
        delete(&v4);
        test("31.14", i1);
        i1.c[2] := 20;
        test("31.15", i1);
        delete(&v1);
        test("31.16", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("31.17", i1);
        i1.a := 21;
        test("31.18", i1);
      };

      {
        test("32.1", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        variable i1 := [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>];
        test("32.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("32.3", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("32.4", i1);
        immutable i2 := i1;
        i1.c[2] := 15;
        test("32.5", i1);
        i1.c[2] := &v4;
        test("32.6", i1);
        ageless variable v4;
        test("32.7", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("32.8", i1);
        delete(&v2);
        test("32.9", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("32.10", i1);
        i1.b := 18;
        test("32.11", i1);
        delete(&v3);
        test("32.12", i1);
        i1.c[1] := 19;
        test("32.13", i1);
        delete(&v4);
        test("32.14", i1);
        i1.c[2] := 20;
        test("32.15", i1);
        delete(&v1);
        test("32.16", [a := &v1, b := &v2, c := <<(1 --> &v3), (2 --> &v4)>>]);
        test("32.17", i1);
        i1.a := 21;
        test("32.18", i1);
      };

      {
        function make_multi_set()
          {
            variable result;
            result.a := &v1;
            result.b := &v2;
            result.c := <<(1 --> &v3), (2 --> &v4)>>;
            return result;
          };
        test("33.1", make_multi_set());
        variable i1 := make_multi_set();
        test("33.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("33.3", make_multi_set());
        test("33.4", i1);
        i1.c[2] := 15;
        test("33.5", i1);
        i1.c[2] := &v4;
        test("33.6", i1);
        ageless variable v4;
        test("33.7", make_multi_set());
        test("33.8", i1);
        delete(&v2);
        test("33.9", make_multi_set());
        test("33.10", i1);
        i1.b := 18;
        test("33.11", i1);
        delete(&v3);
        test("33.12", i1);
        i1.c[1] := 19;
        test("33.13", i1);
        delete(&v4);
        test("33.14", i1);
        i1.c[2] := 20;
        test("33.15", i1);
        delete(&v1);
        test("33.16", make_multi_set());
        test("33.17", i1);
        i1.a := 21;
        test("33.18", i1);
      };

      {
        function make_multi_set()
          {
            variable result;
            result.a := &v1;
            result.b := &v2;
            result.c := <<(1 --> &v3), (2 --> &v4)>>;
            return result;
          };
        test("34.1", make_multi_set());
        variable i1 := make_multi_set();
        test("34.2", i1);
        ageless variable v1;
        ageless variable v2;
        ageless variable v3;
        test("34.3", make_multi_set());
        test("34.4", i1);
        immutable i2 := i1;
        i1.c[2] := 15;
        test("34.5", i1);
        i1.c[2] := &v4;
        test("34.6", i1);
        ageless variable v4;
        test("34.7", make_multi_set());
        test("34.8", i1);
        delete(&v2);
        test("34.9", make_multi_set());
        test("34.10", i1);
        i1.b := 18;
        test("34.11", i1);
        delete(&v3);
        test("34.12", i1);
        i1.c[1] := 19;
        test("34.13", i1);
        delete(&v4);
        test("34.14", i1);
        i1.c[2] := 20;
        test("34.15", i1);
        delete(&v1);
        test("34.16", make_multi_set());
        test("34.17", i1);
        i1.a := 21;
        test("34.18", i1);
      };

      {
        test("35.1", f2);
        variable i1 := f2;
        test("35.2", i1);
        function f2(: {1})  (15);
        function f2(: {2})  (16);
        function f2(: {3})  (17);
        test("35.3", f2);
        test("35.4", i1);
        ageless function f2(: {4})  (18);
        test("35.5", f2);
        test("35.6", i1);
        delete(f2);
        test("35.7", f2);
        test("35.8", i1);
      };

      {
        test("36.1", &(v1[10]));
        test("36.2", &(v2[10]));
        test("36.3", &(v1[&v2]));
        test("36.4", &(v2[&v1]));
        immutable i1 := &(v1[10]);
        immutable i2 := &(v2[10]);
        immutable i3 := &(v1[&v2]);
        immutable i4 := &(v2[&v1]);
        test("36.5", i1);
        test("36.6", i2);
        test("36.7", i3);
        test("36.8", i4);
        ageless variable v1;
        test("36.9", &(v1[10]));
        test("36.10", &(v2[10]));
        test("36.11", &(v1[&v2]));
        test("36.12", &(v2[&v1]));
        test("36.13", i1);
        test("36.14", i2);
        test("36.15", i3);
        test("36.16", i4);
        ageless variable v2;
        test("36.17", &(v1[10]));
        test("36.18", &(v2[10]));
        test("36.19", &(v1[&v2]));
        test("36.20", &(v2[&v1]));
        test("36.21", i1);
        test("36.22", i2);
        test("36.23", i3);
        test("36.24", i4);
        delete(&v1);
        test("36.25", &(v1[10]));
        test("36.26", &(v2[10]));
        test("36.27", &(v1[&v2]));
        test("36.28", &(v2[&v1]));
        test("36.29", i1);
        test("36.30", i2);
        test("36.31", i3);
        test("36.32", i4);
        delete(&v2);
        test("36.33", &(v1[10]));
        test("36.34", &(v2[10]));
        test("36.35", &(v1[&v2]));
        test("36.36", &(v2[&v1]));
        test("36.37", i1);
        test("36.38", i2);
        test("36.39", i3);
        test("36.40", i4);
      };

      {
        ageless function operator[]()  (85);
        test("37.1", &(v1[10]));
        test("37.2", &(v2[10]));
        test("37.3", &(v1[&v2]));
        test("37.4", &(v2[&v1]));
        immutable i1 := &(v1[10]);
        immutable i2 := &(v2[10]);
        immutable i3 := &(v1[&v2]);
        immutable i4 := &(v2[&v1]);
        test("37.5", i1);
        test("37.6", i2);
        test("37.7", i3);
        test("37.8", i4);
        ageless variable v1;
        test("37.9", &(v1[10]));
        test("37.10", &(v2[10]));
        test("37.11", &(v1[&v2]));
        test("37.12", &(v2[&v1]));
        test("37.13", i1);
        test("37.14", i2);
        test("37.15", i3);
        test("37.16", i4);
        ageless variable v2;
        test("37.17", &(v1[10]));
        test("37.18", &(v2[10]));
        test("37.19", &(v1[&v2]));
        test("37.20", &(v2[&v1]));
        test("37.21", i1);
        test("37.22", i2);
        test("37.23", i3);
        test("37.24", i4);
        delete(&v1);
        test("37.25", &(v1[10]));
        test("37.26", &(v2[10]));
        test("37.27", &(v1[&v2]));
        test("37.28", &(v2[&v1]));
        test("37.29", i1);
        test("37.30", i2);
        test("37.31", i3);
        test("37.32", i4);
        delete(operator[]);
        test("37.33", i1);
        test("37.34", i2);
        test("37.35", i3);
        test("37.36", i4);
        delete(&v2);
        test("37.37", i1);
        test("37.38", i2);
        test("37.39", i3);
        test("37.40", i4);
      };

      {
        test("38.1", &(v1.b[10]));
        test("38.2", &(v2.b[10]));
        test("38.3", &(v1.b[&v2]));
        test("38.4", &(v2.b[&v1]));
        immutable i1 := &(v1.b[10]);
        immutable i2 := &(v2.b[10]);
        immutable i3 := &(v1.b[&v2]);
        immutable i4 := &(v2.b[&v1]);
        test("38.5", i1);
        test("38.6", i2);
        test("38.7", i3);
        test("38.8", i4);
        ageless variable v1;
        test("38.9", &(v1.b[10]));
        test("38.10", &(v2.b[10]));
        test("38.11", &(v1.b[&v2]));
        test("38.12", &(v2.b[&v1]));
        test("38.13", i1);
        test("38.14", i2);
        test("38.15", i3);
        test("38.16", i4);
        ageless variable v2;
        test("38.17", &(v1.b[10]));
        test("38.18", &(v2.b[10]));
        test("38.19", &(v1.b[&v2]));
        test("38.20", &(v2.b[&v1]));
        test("38.21", i1);
        test("38.22", i2);
        test("38.23", i3);
        test("38.24", i4);
        delete(&v1);
        test("38.25", &(v1.b[10]));
        test("38.26", &(v2.b[10]));
        test("38.27", &(v1.b[&v2]));
        test("38.28", &(v2.b[&v1]));
        test("38.29", i1);
        test("38.30", i2);
        test("38.31", i3);
        test("38.32", i4);
        delete(&v2);
        test("38.33", &(v1.b[10]));
        test("38.34", &(v2.b[10]));
        test("38.35", &(v1.b[&v2]));
        test("38.36", &(v2.b[&v1]));
        test("38.37", i1);
        test("38.38", i2);
        test("38.39", i3);
        test("38.40", i4);
      };

      {
        ageless function operator->(...)  (85);
        test("39.1", &(12->b[10]));
        test("39.2", &(12->b[&v2]));
        test("39.3", &(12->b[&v1]));
        test("39.4", &((&v1)->b[10]));
        test("39.5", &((&v1)->b[&v2]));
        test("39.6", &((&v2)->b[&v1]));
        immutable i1 := &(12->b[10]);
        immutable i2 := &(12->b[&v2]);
        immutable i3 := &(12->b[&v1]);
        immutable i4 := &((&v1)->b[10]);
        immutable i5 := &((&v1)->b[&v2]);
        immutable i6 := &((&v2)->b[&v1]);
        test("39.7", i1);
        test("39.8", i2);
        test("39.9", i3);
        test("39.10", i4);
        test("39.11", i5);
        test("39.12", i6);
        ageless variable v1;
        test("39.13", &(12->b[10]));
        test("39.14", &(12->b[&v2]));
        test("39.15", &(12->b[&v1]));
        test("39.16", &((&v1)->b[10]));
        test("39.17", &((&v1)->b[&v2]));
        test("39.18", &((&v2)->b[&v1]));
        test("39.19", i1);
        test("39.20", i2);
        test("39.21", i3);
        test("39.22", i4);
        test("39.23", i5);
        test("39.24", i6);
        ageless variable v2;
        test("39.25", &(12->b[10]));
        test("39.26", &(12->b[&v2]));
        test("39.27", &(12->b[&v1]));
        test("39.28", &((&v1)->b[10]));
        test("39.29", &((&v1)->b[&v2]));
        test("39.30", &((&v2)->b[&v1]));
        test("39.31", i1);
        test("39.32", i2);
        test("39.33", i3);
        test("39.34", i4);
        test("39.35", i5);
        test("39.36", i6);
        delete(&v1);
        test("39.37", &(12->b[10]));
        test("39.38", &(12->b[&v2]));
        test("39.39", &(12->b[&v1]));
        test("39.40", &((&v1)->b[10]));
        test("39.41", &((&v1)->b[&v2]));
        test("39.42", &((&v2)->b[&v1]));
        test("39.43", i1);
        test("39.44", i2);
        test("39.45", i3);
        test("39.46", i4);
        test("39.47", i5);
        test("39.48", i6);
        delete(operator->);
        test("39.49", &(12->b[10]));
        test("39.50", &(12->b[&v2]));
        test("39.51", &(12->b[&v1]));
        test("39.52", &((&v1)->b[10]));
        test("39.53", &((&v1)->b[&v2]));
        test("39.54", &((&v2)->b[&v1]));
        test("39.55", i1);
        test("39.56", i2);
        test("39.57", i3);
        test("39.58", i4);
        test("39.59", i5);
        test("39.60", i6);
        delete(&v2);
        test("39.61", &(12->b[10]));
        test("39.62", &(12->b[&v2]));
        test("39.63", &(12->b[&v1]));
        test("39.64", &((&v1)->b[10]));
        test("39.65", &((&v1)->b[&v2]));
        test("39.66", &((&v2)->b[&v1]));
        test("39.67", i1);
        test("39.68", i2);
        test("39.69", i3);
        test("39.70", i4);
        test("39.71", i5);
        test("39.72", i6);
      };

      {
        test("40.1", &(v1..t1[10]));
        test("40.2", &(v1..t2[10]));
        test("40.3", &(v1..t1[&v2]));
        test("40.4", &(v1..t2[&v2]));
        immutable i1 := &(v1..t1[10]);
        immutable i2 := &(v1..t2[10]);
        immutable i3 := &(v1..t1[&v2]);
        immutable i4 := &(v1..t2[&v2]);
        test("40.5", i1);
        test("40.6", i2);
        test("40.7", i3);
        test("40.8", i4);
        ageless tagalong t1;
        test("40.9", &(v1..t1[10]));
        test("40.10", &(v1..t2[10]));
        test("40.11", &(v1..t1[&v2]));
        test("40.12", &(v1..t2[&v2]));
        test("40.13", i1);
        test("40.14", i2);
        test("40.15", i3);
        test("40.16", i4);
        ageless variable v1;
        test("40.17", &(v1..t1[10]));
        test("40.18", &(v1..t2[10]));
        test("40.19", &(v1..t1[&v2]));
        test("40.20", &(v1..t2[&v2]));
        test("40.21", i1);
        test("40.22", i2);
        test("40.23", i3);
        test("40.24", i4);
        ageless variable v2;
        test("40.25", &(v1..t1[10]));
        test("40.26", &(v1..t2[10]));
        test("40.27", &(v1..t1[&v2]));
        test("40.28", &(v1..t2[&v2]));
        test("40.29", i1);
        test("40.30", i2);
        test("40.31", i3);
        test("40.32", i4);
        ageless tagalong t2;
        test("40.33", &(v1..t1[10]));
        test("40.34", &(v1..t2[10]));
        test("40.35", &(v1..t1[&v2]));
        test("40.36", &(v1..t2[&v2]));
        test("40.37", i1);
        test("40.38", i2);
        test("40.39", i3);
        test("40.40", i4);
        delete(t1);
        test("40.41", &(v1..t1[10]));
        test("40.42", &(v1..t2[10]));
        test("40.43", &(v1..t1[&v2]));
        test("40.44", &(v1..t2[&v2]));
        test("40.45", i1);
        test("40.46", i2);
        test("40.47", i3);
        test("40.48", i4);
        delete(&v1);
        test("40.49", &(v1..t1[10]));
        test("40.50", &(v1..t2[10]));
        test("40.51", &(v1..t1[&v2]));
        test("40.52", &(v1..t2[&v2]));
        test("40.53", i1);
        test("40.54", i2);
        test("40.55", i3);
        test("40.56", i4);
        delete(&v2);
        test("40.57", &(v1..t1[10]));
        test("40.58", &(v1..t2[10]));
        test("40.59", &(v1..t1[&v2]));
        test("40.60", &(v1..t2[&v2]));
        test("40.61", i1);
        test("40.62", i2);
        test("40.63", i3);
        test("40.64", i4);
        delete(t2);
        test("40.65", &(v1..t1[10]));
        test("40.66", &(v1..t2[10]));
        test("40.67", &(v1..t1[&v2]));
        test("40.68", &(v1..t2[&v2]));
        test("40.69", i1);
        test("40.70", i2);
        test("40.71", i3);
        test("40.72", i4);
      };

      {
        test("41.1", &(12->b[10]));
        test("41.2", &(12->b[&v1]));
        test("41.3", &(q1->b[10]));
        test("41.4", &(q1->b[&v1]));
        immutable i1 := &(12->b[10]);
        immutable i2 := &(12->b[&v1]);
        immutable i3 := &(q1->b[10]);
        immutable i4 := &(q1->b[&v1]);
        test("41.5", i1);
        test("41.6", i2);
        test("41.7", i3);
        test("41.8", i4);
        ageless variable v1;
        test("41.9", &(12->b[10]));
        test("41.10", &(12->b[&v1]));
        test("41.11", &(q1->b[10]));
        test("41.12", &(q1->b[&v1]));
        test("41.13", i1);
        test("41.14", i2);
        test("41.15", i3);
        test("41.16", i4);
        ageless function operator->(...)  (85);
        test("41.17", &(12->b[10]));
        test("41.18", &(12->b[&v1]));
        test("41.19", &(q1->b[10]));
        test("41.20", &(q1->b[&v1]));
        test("41.21", i1);
        test("41.22", i2);
        test("41.23", i3);
        test("41.24", i4);
        ageless quark q1;
        test("41.25", &(12->b[10]));
        test("41.26", &(12->b[&v1]));
        test("41.27", &(q1->b[10]));
        test("41.28", &(q1->b[&v1]));
        test("41.29", i1);
        test("41.30", i2);
        test("41.31", i3);
        test("41.32", i4);
        delete(&v1);
        test("41.33", &(12->b[10]));
        test("41.34", &(12->b[&v1]));
        test("41.35", &(q1->b[10]));
        test("41.36", &(q1->b[&v1]));
        test("41.37", i1);
        test("41.38", i2);
        test("41.39", i3);
        test("41.40", i4);
        delete(operator->);
        test("41.41", &(12->b[10]));
        test("41.42", &(12->b[&v1]));
        test("41.43", &(q1->b[10]));
        test("41.44", &(q1->b[&v1]));
        test("41.45", i1);
        test("41.46", i2);
        test("41.47", i3);
        test("41.48", i4);
        delete(q1);
        test("41.49", &(12->b[10]));
        test("41.50", &(12->b[&v1]));
        test("41.51", &(q1->b[10]));
        test("41.52", &(q1->b[&v1]));
        test("41.53", i1);
        test("41.54", i2);
        test("41.55", i3);
        test("41.56", i4);
      };

      {
        class c1()
          {
            ageless function operator->(...)  (85);
          };
        immutable o1 := c1();
        test("42.1", &(12->b[10]));
        test("42.2", &(12->b[&v1]));
        test("42.3", &(o1->b[10]));
        test("42.4", &(o1->b[&v1]));
        immutable i1 := &(12->b[10]);
        immutable i2 := &(12->b[&v1]);
        immutable i3 := &(o1->b[10]);
        immutable i4 := &(o1->b[&v1]);
        test("42.5", i1);
        test("42.6", i2);
        test("42.7", i3);
        test("42.8", i4);
        ageless variable v1;
        test("42.9", &(12->b[10]));
        test("42.10", &(12->b[&v1]));
        test("42.11", &(o1->b[10]));
        test("42.12", &(o1->b[&v1]));
        test("42.13", i1);
        test("42.14", i2);
        test("42.15", i3);
        test("42.16", i4);
        ageless function operator->(...)  (85);
        test("42.17", &(12->b[10]));
        test("42.18", &(12->b[&v1]));
        test("42.19", &(o1->b[10]));
        test("42.20", &(o1->b[&v1]));
        test("42.21", i1);
        test("42.22", i2);
        test("42.23", i3);
        test("42.24", i4);
        delete(o1.operator->);
        test("42.25", &(12->b[10]));
        test("42.26", &(12->b[&v1]));
        test("42.27", &(o1->b[10]));
        test("42.28", &(o1->b[&v1]));
        test("42.29", i1);
        test("42.30", i2);
        test("42.31", i3);
        test("42.32", i4);
        delete(&v1);
        test("42.33", &(12->b[10]));
        test("42.34", &(12->b[&v1]));
        test("42.35", &(o1->b[10]));
        test("42.36", &(o1->b[&v1]));
        test("42.37", i1);
        test("42.38", i2);
        test("42.39", i3);
        test("42.40", i4);
        delete(operator->);
        test("42.41", &(12->b[10]));
        test("42.42", &(12->b[&v1]));
        test("42.43", &(o1->b[10]));
        test("42.44", &(o1->b[&v1]));
        test("42.45", i1);
        test("42.46", i2);
        test("42.47", i3);
        test("42.48", i4);
        delete(o1);
        test("42.49", &(12->b[10]));
        test("42.50", &(12->b[&v1]));
        test("42.51", i1);
        test("42.52", i2);
        test("42.53", i3);
        test("42.54", i4);
      };

      {
        test("43.1", &*&v1);
        test("43.2", &*&v2);
        immutable i1 := &*&v1;
        immutable i2 := &*&v2;
        test("43.3", i1);
        test("43.4", i2);
        ageless variable v1;
        test("43.5", &*&v1);
        test("43.6", &*&v2);
        test("43.7", i1);
        test("43.8", i2);
        ageless function operator*(...)  (85);
        test("43.9", &*&v1);
        test("43.10", &*&v2);
        test("43.11", i1);
        test("43.12", i2);
        ageless variable v2;
        test("43.13", &*&v1);
        test("43.14", &*&v2);
        test("43.15", i1);
        test("43.16", i2);
        delete(&v1);
        test("43.17", &*&v1);
        test("43.18", &*&v2);
        test("43.19", i1);
        test("43.20", i2);
        delete(operator*);
        test("43.21", &*&v1);
        test("43.22", &*&v2);
        test("43.23", i1);
        test("43.24", i2);
        delete(&v2);
        test("43.25", &*&v1);
        test("43.26", &*&v2);
        test("43.27", i1);
        test("43.28", i2);
      };

      {
        ageless pure function ff1(x)  ((x in integer) && ((x % 3) == 2));
        ageless quark q2;
        test("44.1", type {ff1});
        test("44.2", type {q2});
        test("44.3", type {ff1, q2});
        test("44.4", type !{ff1});
        test("44.5", type !{q2});
        test("44.6", type !{ff1, q2});
        test("44.7", type (fields[a : {ff1}, ...] & fields[b : {q2}, ...]));
        test("44.8", type (fields[a : {ff1}, ...] & {q2}));
        test("44.9", type (fields[a : {ff1}, ...] | {q2}));
        test("44.10", type (fields[a : {ff1}, ...] ^ {q2}));
        test("44.11", type array[{ff1}]);
        test("44.12", type *{ff1});
        test("44.13", type type *{ff1});
        test("44.14", type {ff1} --> {q2});
        test("44.15", type {ff1} <-- ({q2}));
        test("44.16", type fields[a : {ff1}, b : {q2}]);
        test("44.17", type multiset[a : {ff1}, b : {q2}]);
        test("44.18", type interface[a :- {ff1}, b :- {q2}]);
        test("44.19", type [a : {ff1}, b : {q2}]);
        test("44.20",
             type (multiset[a : {ff1}, ...] & multiset[b : {q2}, ...]));
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        immutable i1 := type {ff1};
        immutable i2 := type {q2};
        immutable i3 := type {ff1, q2};
        immutable i4 := type !{ff1};
        immutable i5 := type !{q2};
        immutable i6 := type !{ff1, q2};
        immutable i7 := type (fields[a : {ff1}, ...] & fields[b : {q2}, ...]);
        immutable i8 :=
                type ((fields[a : {ff1}, ...] | filter_a) & ({q2} | filter_a));
        immutable i9 := type (fields[a : {ff1}, ...] | {q2});
        immutable i10 := type (fields[a : {ff1}, ...] ^ {q2});
        immutable i11 := type array[{ff1}];
        immutable i12 := type *{ff1};
        immutable i13 := type type *{ff1};
        immutable i14 := type {ff1} --> {q2};
        immutable i15 := type {ff1} <-- ({q2});
        immutable i16 := type fields[a : {ff1}, b : {q2}];
        immutable i17 := type multiset[a : {ff1}, b : {q2}];
        immutable i18 := type interface[a :- {ff1}, b :- {q2}];
        immutable i19 := type [a : {ff1}, b : {q2}];
        immutable i20 :=
             type (multiset[a : {ff1}, ...] & multiset[b : {q2}, ...]);
        test("44.21", i1);
        test("44.22", i2);
        test("44.23", i3);
        test("44.24", i4);
        test("44.25", i5);
        test("44.26", i6);
        test("44.27", i7);
        test("44.28", i8);
        test("44.29", i9);
        test("44.30", i10);
        test("44.31", i11);
        test("44.32", i12);
        test("44.33", i13);
        test("44.34", i14);
        test("44.35", i15);
        test("44.36", i16);
        test("44.37", i17);
        test("44.38", i18);
        test("44.39", i19);
        test("44.40", i20);
        delete(ff1);
        test("44.41", i1);
        test("44.42", i2);
        test("44.43", i3);
        test("44.44", i4);
        test("44.45", i5);
        test("44.46", i6);
        test("44.47", i7);
        test("44.48", i8);
        test("44.49", i9);
        test("44.50", i10);
        test("44.51", i11);
        test("44.52", i12);
        test("44.53", i13);
        test("44.54", i14);
        test("44.55", i15);
        test("44.56", i16);
        test("44.57", i17);
        test("44.58", i18);
        test("44.59", i19);
        test("44.60", i20);
        delete(q2);
        test("44.61", i1);
        test("44.62", i2);
        test("44.63", i3);
        test("44.64", i4);
        test("44.65", i5);
        test("44.66", i6);
        test("44.67", i7);
        test("44.68", i8);
        test("44.69", i9);
        test("44.70", i10);
        test("44.71", i11);
        test("44.72", i12);
        test("44.73", i13);
        test("44.74", i14);
        test("44.75", i15);
        test("44.76", i16);
        test("44.77", i17);
        test("44.78", i18);
        test("44.79", i19);
        test("44.80", i20);
      };

      {
        ageless lepton l1;
        ageless pure function ff1(x)  ((x in integer) && ((x % 3) == 2));
        ageless quark q2;
        test("45.1", type lepton l1[a : {ff1}, b : {q2}]);
        test("45.2",
             type (lepton l1[a : {ff1}, ...] & lepton l1[b : {q2}, ...]));
        immutable i1 := type lepton l1[a : {ff1}, b : {q2}];
        immutable i2 :=
             type (lepton l1[a : {ff1}, ...] & lepton l1[b : {q2}, ...]);
        test("45.3", i1);
        test("45.4", i2);
        delete(l1);
        test("45.5", i1);
        test("45.6", i2);
        delete(ff1);
        test("45.7", i1);
        test("45.8", i2);
        delete(q2);
        test("45.9", i1);
        test("45.10", i2);
      };

      {
        test("46.1", type c1);
        immutable i1 := type c1;
        test("46.2", i1);
        ageless class c1()  { };
        test("46.3", type c1);
        test("46.4", i1);
        delete(c1);
        test("46.5", type c1);
        test("46.6", i1);
      };

      {
        ageless pure function filter1(x) returns boolean
          ((x in integer) && ((x % 3) == 2));
        test("47.1", type filter1);
        immutable i1 := type filter1;
        test("47.2", i1);
        delete(filter1);
        test("47.3", i1);
      };

      {
        pure function filter1(x) returns boolean
          ((x in integer) && ((x % 3) == 2));
        ageless pure function filter1(x : [1...100]) returns boolean
          ((x in integer) && ((x % 5) == 2));
        test("48.1", type filter1);
        immutable i1 := type filter1;
        test("48.2", i1);
        delete(filter1);
        test("48.3", i1);
      };
  };


/* Next, we'll do some testing of theorem statements. */

  {
    /*
     *  Executing a theorem statement has no effect and an implementation is
     *  free to ignore them.  The testing here is just to make sure the
     *  implementation can parse theorem statements and ignore them.
     */
    print("Starting theorem tests.\n");

    variable x := 10;

    /* This is a valid theorem. */
    theorem(x < 15);

    /*
     *  This is a theorem with a valid claim but garbage for the proof part.
     *  The reason for this is to make sure the interpreter can parse theorems
     *  with proof parts and ignore them properly.  But I haven't yet worked
     *  out the full syntax of proof parts, so in this test, garbage of the
     *  sort the interpreter should be able to skip is used in the proof part.
     *  In the future, when the syntax of proof parts is worked out, this test
     *  should be changed, so that this test will also work on implementations
     *  that care about proof parts.  For now, this should be sufficient to
     *  test that the current interpreter will be be compatible with future
     *  programs that use the real proof part syntax.
     */
    theorem(x < 75)
    proof
      {
        something(x && 87);
        induction(i)
          {
            something_else(i);
          };
      };

    print("Done with theorem tests.\n");
  };


/* Next is a test of a case that triggered a bug in some versions of SalmonEye.
 */

  {
    variable v1;
      {
        v1 := &v2;
        goto done;
        variable v2;
      done:
      };
  };


/* Next, we'll test the alias statement. */

  {
    procedure system(param : string)
      {
        print("system: `", param, "'.\n");
      };

    variable a := 5;
    variable b := 7;
    print("a: ", a, ".\n");
    print("b: ", b, ".\n");
      {
        print("a: ", a, ".\n");
        print("b: ", b, ".\n");
        a := 9;
        b := 11;
        print("a: ", a, ".\n");
        print("b: ", b, ".\n");
        alias a b;
        print("a: ", a, ".\n");
        print("b: ", b, ".\n");
        a := 13;
        print("a: ", a, ".\n");
        print("b: ", b, ".\n");
        b := 15;
        print("a: ", a, ".\n");
        print("b: ", b, ".\n");

        `$a $b`;
        `$(a) $(b)`;
      };

    `$a $b`;
    `$(a) $(b)`;

    print("a: ", a, ".\n");
    print("b: ", b, ".\n");
    a := 17;
    print("a: ", a, ".\n");
    print("b: ", b, ".\n");
    b := 19;
    print("a: ", a, ".\n");
    print("b: ", b, ".\n");

    alias p procedure;
    p p1()
      { print("p1().\n"); };
    p1();
  };


/* Next, we'll do some testing of ::= in various contexts. */

  {
    variable v1 : [0...9];
    v1 ::= 5;
    print("v1: ", v1, ".\n");
    v1 ::= 27;
    print("v1: ", v1, ".\n");

    variable v2 : [0...9] ::= 38;
    print("v2: ", v2, ".\n");

    immutable i1 : [0...9] ::= 49;
    print("i1: ", i1, ".\n");

    procedure p1(a1 : [0...9] ::= 53)
      { print("a1: ", a1, ".\n"); };
    p1();

    tagalong t1 : [0...9] ::= 64;
    print("i1..t1: ", i1..t1, ".\n");
  };


/* Next, we'll do some testing of ``use'' statements. */

  {
    use "multi_include.salm";
  };

  {
    use "multi_include2.salm";
    p1();
    p2(5);
    p2(7);
  };

  {
    use "multi_include2.salm" : interface
      [ p1 :- !{} <-- (), p2 :- !{} <-- (integer) ];
    p1();
    p2(9);
    p2(11);
  };

  {
    use "multi_include2.salm" : "multi_include2.si";
    p1();
    p2(13);
    p2(15);
  };


/* Next, we'll do some more testing of maps. */

  {
    variable x;

    x := <<(* --> "blue"), (3 --> "red"), (5 --> "green")>>;
    print("x: ", x, ".\n");
    x[*] := <<(3 --> "yellow"), (4 --> "black")>>;
    print("x: ", x, ".\n");

    x := <<(* --> "blue"), (3 --> "red"), (5 --> "green")>>;
    print("x: ", x, ".\n");
    x[*] := <<(* --> "purple"), (3 --> "yellow"), (4 --> "black")>>;
    print("x: ", x, ".\n");

    pure function f1(x) returns boolean (true);
    variable x2 := [];
    x2[11...13] := <<(* : f1 --> 12)>>;
  };


/* Now, let's try a couple of tests to make sure tagalong value references are
 * removed when the tagalong key is de-allocated. */

  {
    ageless tagalong t1;
    variable v1 := 5;
    class c1() { cleanup { "c1() closing."! }; };
    v1..t1 := c1();
    "About to delete t1."!
    delete(t1);
    "t1 has now been deleted."!

    ageless tagalong t2 on object !{};
    class c2() { };
    variable v2 := c2();
    class c3() { cleanup { "c3() closing."! }; };
    v2..t2 := c3();
    "About to delete t2."!
    delete(t2);
    "t2 has now been deleted."!
  };


/* Next, we'll make sure writing works properly in relation to immutables. */

  {
    class c1()
      {
        immutable i1 := 1;
        variable v1 := 2;
      };
    immutable i2 := c1();
    i2.v1!
    i2.v1 := 3;
    i2.v1!
    i2.i1!
    try
      {
        i2.i1 := 4;
      }
    catch
      {
        print("Exception: `", current_exceptions()[0].message, "'.\n");
      };
    i2.i1!
    variable v2 := c1();
    v2.v1!
    v2.v1 := 5;
    v2.v1!
    v2.i1!
    try
      {
        v2.i1 := 6;
      }
    catch
      {
        print("Exception: `", current_exceptions()[0].message, "'.\n");
      };
    v2.i1!
  };


/* Next, let's try nested uses of the same lock. */

  {
    lock a;
    single (a)
      {
        single (a)
          {
          };
      };
  };


/* Now we'll do some more map value testing. */

  {
    pure function is_one_hundreds(x) returns boolean (x in [100...199]);
    pure function is_two_hundreds(x) returns boolean (x in [200...299]);
    pure function is_three_hundreds(x) returns boolean (x in [300...399]);
    pure function is_thousands(x) returns boolean (x in [1000...1999]);
    immutable i1 :=
      <<(1 --> "one"), (2 --> "two"), (3 --> "three"), (4 --> "four"),
        (5 --> "five"), (6 --> "six"), (7 --> "seven"),
        ((type is_thousands) --> "thousands")>>;
    variable v1 := i1;
    v1[6] := "Six";
    v1[*] := <<(* : type is_one_hundreds --> "hundred")>>;
    v1[type is_thousands] := "thousands";
    v1!
    immutable i2 := v1;
    v1[7] := "Seven";
    immutable i3 := v1;
    v1[*] := <<(* : type is_two_hundreds --> "two hundred")>>;
    v1[type is_thousands] := "thousands";
    v1!
    v1[8] := "Eight";
    immutable i4 := v1;
    v1[*] := <<(* : type is_three_hundreds --> "three hundred")>>;
    v1[type is_thousands] := "thousands";
    v1!
    v1[9] := "Nine";
    immutable i5 := v1;
    v1[* : [400...499]] := <<(* : [400...499] --> "four hundred")>>;
    v1[type is_thousands] := "thousands";
    v1!
    v1[10] := "Ten";
    immutable i6 := v1;
    v1!
    v1[5] := "Five";
    immutable i7 := v1;
    i2!
    v1!
    v1[4]!
    v1[5]!
    v1[11] := "eleven";
    immutable i8 := v1;
    v1[2] := "Two";
    v1[12] := "twelve";
    immutable i9 := v1;
    v1[13] := "thirteen";
    immutable i10 := v1;
    v1[14] := "fourteen";
    immutable i11 := v1;
    v1[15] := "fifteen";
    v1!
    v1[4]!
    v1[5]!
    v1[15]!
  };


/* Next, we'll try an ageless static and make sure deleting it works. */

  {
    procedure p1()
      {
        ageless static variable v1;
        delete(&v1);
      };
    p1();
  };


/* Now let's try some integer range expressions. */

  {
    print("[0...5]: ");
    iterate (x; [0...5])
        print(x);;
    print("\n");

    print("[0...5): ");
    iterate (x; [0...5))
        print(x);;
    print("\n");

    print("(0...5]: ");
    iterate (x; (0...5])
        print(x);;
    print("\n");

    print("(0...5): ");
    iterate (x; (0...5))
        print(x);;
    print("\n");
  };


/* Next, it's time to test garbage collection of scopes with ageless
 * declarations. */

  {
      {
        "AA point 1."!
        variable v1 := class () { cleanup { "AA cleaned up."! }; }();
          {
            ageless immutable i1 := v1;
            ageless function f1() (1);
            v1 := null;
            "AA point 2."!
          };
        "AA point 3."!
      };

      {
        "BB point 1."!
        variable v1 := class () { cleanup { "BB cleaned up."! }; }();
          {
            ageless immutable i1 := v1;
            ageless function f1() (1);
            v1 := null;
            "BB point 2."!
          };
        "BB point 3."!
      };

      {
        "CC point 1."!
        variable v1 := class () { cleanup { "CC cleaned up."! }; }();
          {
            ageless immutable i1 := v1;
            ageless class c1() {};
            v1 := null;
            "CC point 2."!
          };
        "CC point 3."!
      };
  };


/* And now we'll try garbage collection of objects, including those using
 * virtuals through inheritance. */

  {
      {
        "Starting AA."!
        class c1()
          {
            variable v1 := &v2;
            variable v2 := &v1;
            cleanup { "Cleaning up AA."! };
          };
        [] := [c1()];
        "Finished AA."!
      };

      {
        "Starting BB."!
        class c1()
          {
            variable v1 := &v2;
            variable v2 := &v1;
          };
        class c2()
          {
            use c1();
            cleanup { "Cleaning up BB."! };
          };
        [] := [c2()];
        "Finished BB."!
      };

      {
        "Starting CC."!
        class c1()
          {
            variable v1 := &v2;
            variable v2 := &v1;
            virtual variable v3 := null;
            virtual procedure p1() {};
          };
        class c2()
          {
            use c1();
            variable v3;
            procedure p1() {};
            cleanup { "Cleaning up CC."! };
          };
        [] := [c2()];
        "Finished CC."!
      };
  };


/* Next, we'll try a tests that triggers a bug in some old versions of
 * SalmonEye, where creating a map by modifying a semi-labeled value list and
 * then creating another map by modifying the same semi-labeled value list led
 * to the changes erroneously showing up in both maps. */

  {
    variable v1 := ["a", "b", "c"];
    variable v2 := v1;
    v1[0] := "d";
    v2[1] := "e";
    v1!
    v2!
  };


/* And now comes a test that triggers a similar bug in some old SalmonEye
 * versions, but triggered by a change involving a filter function. */

  {
    variable v1 := ["a", "b", "c"];
    variable v2 := v1;
    v1[*] := <<(* : [2...+oo] --> "d")>>;
    v2[1] := "e";
    v1!
    v2!
  };


/* Next, we'll run some tests of garbage collection of objects with various
 * complications. */

  {
    "Starting variable_field test."!
    class variable_field()
      {
        variable v1 := 1;
        cleanup { "Cleaning up variable_field."! };
      };
    [] := [variable_field()];
    "Finished variable_field test."!

    "Starting immutable_field test."!
    class immutable_field()
      {
        immutable i1 := 1;
        cleanup { "Cleaning up immutable_field."! };
      };
    [] := [immutable_field()];
    "Finished immutable_field test."!

    "Starting procedure_field test."!
    class procedure_field()
      {
        procedure p1() { };
        cleanup { "Cleaning up procedure_field."! };
      };
    [] := [procedure_field()];
    "Finished procedure_field test."!

    "Starting lepton_field test."!
    class lepton_field()
      {
        lepton l1[...];
        cleanup { "Cleaning up lepton_field."! };
      };
    [] := [lepton_field()];
    "Finished lepton_field test."!

    "Starting lock_field test."!
    class lock_field()
      {
        lock lk1;
        cleanup { "Cleaning up lock_field."! };
      };
    [] := [lock_field()];
    "Finished lock_field test."!

    "Starting quark_field test."!
    class quark_field()
      {
        quark q1;
        cleanup { "Cleaning up quark_field."! };
      };
    [] := [quark_field()];
    "Finished quark_field test."!

    "Starting tagalong_field test."!
    class tagalong_field()
      {
        tagalong t1;
        cleanup { "Cleaning up tagalong_field."! };
      };
    [] := [tagalong_field()];
    "Finished tagalong_field test."!

    "Starting filter_type test."!
    class filter_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        variable v1 := type filter_a;
        cleanup { "Cleaning up filter_type."! };
      };
    [] := [filter_type()];
    "Finished filter_type test."!

    "Starting enumeration_type test."!
    class enumeration_type()
      {
        immutable i1 := 1;
        variable v1 := type {1, 3, 5, &i1};
        cleanup { "Cleaning up enumeration_type."! };
      };
    [] := [enumeration_type()];
    "Finished enumeration_type test."!

    "Starting not_type test."!
    class not_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        variable v1 := type !filter_a;
        cleanup { "Cleaning up not_type."! };
      };
    [] := [not_type()];
    "Finished not_type test."!

    "Starting intersection_type test."!
    class intersection_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type (filter_a & filter_b);
        cleanup { "Cleaning up intersection_type."! };
      };
    [] := [intersection_type()];
    "Finished intersection_type test."!

    "Starting union_type test."!
    class union_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type (filter_a | filter_b);
        cleanup { "Cleaning up union_type."! };
      };
    [] := [union_type()];
    "Finished union_type test."!

    "Starting xor_type test."!
    class xor_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type (filter_a ^ filter_b);
        cleanup { "Cleaning up xor_type."! };
      };
    [] := [xor_type()];
    "Finished xor_type test."!

    "Starting array_type test."!
    class array_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        variable v1 := type filter_a[15...87];
        cleanup { "Cleaning up array_type."! };
      };
    [] := [array_type()];
    "Finished array_type test."!

    "Starting pointer_type test."!
    class pointer_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        variable v1 := type *filter_a;
        cleanup { "Cleaning up pointer_type."! };
      };
    [] := [pointer_type()];
    "Finished pointer_type test."!

    "Starting type_type test."!
    class type_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        variable v1 := type type filter_a;
        cleanup { "Cleaning up type_type."! };
      };
    [] := [type_type()];
    "Finished type_type test."!

    "Starting map_type test."!
    class map_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type (filter_a --> filter_b);
        cleanup { "Cleaning up map_type."! };
      };
    [] := [map_type()];
    "Finished map_type test."!

    "Starting routine_type test."!
    class routine_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type filter_a <-- (filter_b);
        cleanup { "Cleaning up routine_type."! };
      };
    [] := [routine_type()];
    "Finished routine_type test."!

    "Starting fields_type test."!
    class fields_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type fields[a : filter_a, b : filter_b];
        cleanup { "Cleaning up fields_type."! };
      };
    [] := [fields_type()];
    "Finished fields_type test."!

    "Starting lepton_type test."!
    class lepton_type()
      {
        lepton l1[...];
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type lepton l1[a : filter_a, b : filter_b];
        cleanup { "Cleaning up lepton_type."! };
      };
    [] := [lepton_type()];
    "Finished lepton_type test."!

    "Starting multiset_type test."!
    class multiset_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type multiset[a : filter_a, b : filter_b];
        cleanup { "Cleaning up multiset_type."! };
      };
    [] := [multiset_type()];
    "Finished multiset_type test."!

    "Starting interface_type test."!
    class interface_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type interface[a : filter_a, b : filter_b];
        cleanup { "Cleaning up interface_type."! };
      };
    [] := [interface_type()];
    "Finished interface_type test."!

    "Starting semi_labeled_value_list_type test."!
    class semi_labeled_value_list_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v1 := type [a : filter_a, b : filter_b];
        cleanup { "Cleaning up semi_labeled_value_list_type."! };
      };
    [] := [semi_labeled_value_list_type()];
    "Finished semi_labeled_value_list_type test."!

    "Starting class_type test."!
    class class_type()
      {
        class c1() { };
        variable v1 := type c1;
        cleanup { "Cleaning up class_type."! };
      };
    [] := [class_type()];
    "Finished class_type test."!

    "Starting overloaded_filter_type test."!
    class overloaded_filter_type()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_a(x : integer) returns boolean
          ((x in integer) && ((x % 5) == 4));
        variable v1 := type filter_a;
        cleanup { "Cleaning up overloaded_filter_type."! };
      };
    [] := [overloaded_filter_type()];
    "Finished overloaded_filter_type test."!

    "Starting semi_labeled_value_list test."!
    class semi_labeled_value_list()
      {
        immutable i1 := 1;
        immutable i2 := 1;
        variable v1 := [a := &i1, b := &i2];
        cleanup { "Cleaning up semi_labeled_value_list."! };
      };
    [] := [semi_labeled_value_list()];
    "Finished semi_labeled_value_list test."!

    "Starting semi_labeled_multi_set test."!
    class semi_labeled_multi_set()
      {
        immutable i1 := 1;
        immutable i2 := 1;
        variable v1;
        v1.a := &i1;
        v1.b := &i2;
        cleanup { "Cleaning up semi_labeled_multi_set."! };
      };
    [] := [semi_labeled_multi_set()];
    "Finished semi_labeled_multi_set test."!

    "Starting map_value_key test."!
    class map_value_key()
      {
        immutable i1 := 1;
        immutable i2 := 1;
        variable v1 := <<(&i2 --> &i1), (&i1 --> &i2)>>;
        cleanup { "Cleaning up map_value_key."! };
      };
    [] := [map_value_key()];
    "Finished map_value_key test."!

    "Starting map_type_key test."!
    class map_type_key()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        immutable i1 := 1;
        immutable i2 := 1;
        variable v1 := <<(* : filter_a --> &i1), (* : filter_b --> &i2)>>;
        cleanup { "Cleaning up map_type_key."! };
      };
    [] := [map_type_key()];
    "Finished map_type_key test."!

    "Starting quark_value test."!
    class quark_value()
      {
        quark q1;
        variable v1 := q1;
        cleanup { "Cleaning up quark_value."! };
      };
    [] := [quark_value()];
    "Finished quark_value test."!

    "Starting lepton_value test."!
    class lepton_value()
      {
        lepton l1[...];
        variable v1 := l1[a := 1, b := "hello"];
        cleanup { "Cleaning up lepton_value."! };
      };
    [] := [lepton_value()];
    "Finished lepton_value test."!

    "Starting lepton_key_value test."!
    class lepton_key_value()
      {
        lepton l1[...];
        variable v1 := l1;
        cleanup { "Cleaning up lepton_key_value."! };
      };
    [] := [lepton_key_value()];
    "Finished lepton_key_value test."!

    "Starting slot_location_value test."!
    class slot_location_value()
      {
        variable v1;
        variable v2 := &v1;
        cleanup { "Cleaning up slot_location_value."! };
      };
    [] := [slot_location_value()];
    "Finished slot_location_value test."!

    "Starting routine_value test."!
    class routine_value()
      {
        variable v1;
        variable v2 := function(x : {&v1}) (3);
        cleanup { "Cleaning up routine_value."! };
      };
    [] := [routine_value()];
    "Finished routine_value test."!

    "Starting routine_chain_value test."!
    class routine_chain_value()
      {
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_a(x : integer) returns boolean
          ((x in integer) && ((x % 5) == 4));
        variable v1 := filter_a;
        cleanup { "Cleaning up routine_chain_value."! };
      };
    [] := [routine_chain_value()];
    "Finished routine_chain_value test."!

    "Starting object_value test."!
    class object_value()
      {
        variable v1 := this;
        cleanup { "Cleaning up object_value."! };
      };
    [] := [object_value()];
    "Finished object_value test."!

    "Starting tagalong_key_value test."!
    class tagalong_key_value()
      {
        tagalong t1;
        variable v1 := t1;
        cleanup { "Cleaning up tagalong_key_value."! };
      };
    [] := [tagalong_key_value()];
    "Finished tagalong_key_value test."!

    "Starting lock_value test."!
    class lock_value()
      {
        lock lk1;
        variable v1 := lk1;
        cleanup { "Cleaning up lock_value."! };
      };
    [] := [lock_value()];
    "Finished lock_value test."!

    "Starting variable_value test."!
    class variable_value()
      {
        variable v1 := 1;
        variable v2 := &v1;
        cleanup { "Cleaning up variable_value."! };
      };
    [] := [variable_value()];
    "Finished variable_value test."!

    "Starting variable_type test."!
    class variable_type()
      {
        variable v1 := 1;
        variable v2 : {&v1};
        cleanup { "Cleaning up variable_type."! };
      };
    [] := [variable_type()];
    "Finished variable_type test."!

    "Starting variable_lock test."!
    class variable_lock()
      {
        lock lk1;
        single(lk1) variable v1;
        cleanup { "Cleaning up variable_lock."! };
      };
    [] := [variable_lock()];
    "Finished variable_lock test."!

    "Starting function_return_type test."!
    class function_return_type()
      {
        variable v1 := 1;
        function f1() returns {&v1} (&v1);
        cleanup { "Cleaning up function_return_type."! };
      };
    [] := [function_return_type()];
    "Finished function_return_type test."!

    "Starting function_argument_type test."!
    class function_argument_type()
      {
        variable v1 := 1;
        function f1(x : {&v1}) (3);
        cleanup { "Cleaning up function_argument_type."! };
      };
    [] := [function_argument_type()];
    "Finished function_argument_type test."!

    "Starting function_lock test."!
    class function_lock()
      {
        lock lk1;
        single(lk1) function f1() (3);
        cleanup { "Cleaning up function_lock."! };
      };
    [] := [function_lock()];
    "Finished function_lock test."!

    "Starting lepton_field_type test."!
    class lepton_field_type()
      {
        variable v1 := 1;
        lepton l1[a : {&v1}];
        cleanup { "Cleaning up lepton_field_type."! };
      };
    [] := [lepton_field_type()];
    "Finished lepton_field_type test."!

    "Starting lock_lock test."!
    class lock_lock()
      {
        lock lk1;
        single(lk1) lock lk2;
        cleanup { "Cleaning up lock_lock."! };
      };
    [] := [lock_lock()];
    "Finished lock_lock test."!

    "Starting tagalong_type test."!
    class tagalong_type()
      {
        variable v1 := 1;
        tagalong t1 : {&v1};
        cleanup { "Cleaning up tagalong_type."! };
      };
    [] := [tagalong_type()];
    "Finished tagalong_type test."!

    "Starting tagalong_on_type test."!
    class tagalong_on_type()
      {
        variable v1 := 1;
        tagalong t1 on {&v1};
        cleanup { "Cleaning up tagalong_on_type."! };
      };
    [] := [tagalong_on_type()];
    "Finished tagalong_on_type test."!

    "Starting tagalong_default test."!
    class tagalong_default()
      {
        variable v1 := 1;
        tagalong t1 := &v1;
        cleanup { "Cleaning up tagalong_default."! };
      };
    [] := [tagalong_default()];
    "Finished tagalong_default test."!

    "Starting tagalong_lock test."!
    class tagalong_lock()
      {
        lock lk1;
        single(lk1) tagalong t1;
        cleanup { "Cleaning up tagalong_lock."! };
      };
    [] := [tagalong_lock()];
    "Finished tagalong_lock test."!

    "Starting lookup1 test."!
    class lookup1()
      {
        variable v1;
        variable v2 := &(v1[3]);
        cleanup { "Cleaning up lookup1."! };
      };
    [] := [lookup1()];
    "Finished lookup1 test."!

    "Starting lookup2 test."!
    class lookup2()
      {
        variable v1;
        variable v2;
        variable v3 := &(v1[&v2]);
        cleanup { "Cleaning up lookup2."! };
      };
    [] := [lookup2()];
    "Finished lookup2 test."!

    "Starting lookup3 test."!
    class lookup3()
      {
        variable v1;
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        variable v2 := &(v1[* : filter_a]);
        cleanup { "Cleaning up lookup3."! };
      };
    [] := [lookup3()];
    "Finished lookup3 test."!

    "Starting slot_field test."!
    class slot_field()
      {
        variable v1;
        variable v2 := &(v1.aaa);
        cleanup { "Cleaning up slot_field."! };
      };
    [] := [slot_field()];
    "Finished slot_field test."!

    "Starting slot_tagalong test."!
    class slot_tagalong()
      {
        variable v1;
        tagalong t1;
        variable v2 := &(v1..t1);
        cleanup { "Cleaning up slot_tagalong."! };
      };
    [] := [slot_tagalong()];
    "Finished slot_tagalong test."!

    "Starting big test."!
    class big()
      {
        variable v1 := 1;
        immutable i1 := 1;
        procedure p1() { };
        lepton l1[...];
        lock lk1;
        quark q1;
        tagalong t1;
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 3));
        variable v2 := type filter_a;
        variable v3 := type {1, 3, 5, &i1};
        variable v4 := type !filter_a;
        variable v5 := type (filter_a & filter_b);
        variable v6 := type (filter_a | filter_b);
        variable v7 := type (filter_a ^ filter_b);
        variable v8 := type filter_a[15...87];
        variable v9 := type *filter_a;
        variable v10 := type type filter_a;
        variable v11 := type (filter_a --> filter_b);
        variable v12 := type filter_a <-- (filter_b);
        variable v13 := type fields[a : filter_a, b : filter_b];
        variable v14 := type lepton l1[a : filter_a, b : filter_b];
        variable v15 := type multiset[a : filter_a, b : filter_b];
        variable v16 := type interface[a : filter_a, b : filter_b];
        variable v17 := type [a : filter_a, b : filter_b];
        class c1() { };
        variable v18 := type c1;
        pure function filter_c(x) returns boolean
          ((x in integer) && ((x % 5) == 3));
        pure function filter_c(x : integer) returns boolean
          ((x in integer) && ((x % 5) == 4));
        variable v19 := type filter_c;
        immutable i2 := 1;
        variable v20 := [a := &i1, b := &i2];
        variable v21;
        v21.a := &i1;
        v21.b := &i2;
        variable v22 := <<(&i2 --> &i1), (&i1 --> &i2)>>;
        variable v23 := <<(* : filter_a --> &i1), (* : filter_b --> &i2)>>;
        variable v24 := q1;
        variable v25 := l1[a := 1, b := "hello"];
        variable v26 := l1;
        variable v27 := &v1;
        variable v28 := function(x : {&v1}) (3);
        variable v29 := filter_c;
        variable v30 := this;
        variable v31 := t1;
        variable v32 := lk1;
        variable v33 := &v1;
        variable v34 : {&v1};
        single(lk1) variable v35;
        function f1() returns {&v1} (&v1);
        function f2(x : {&v1}) (3);
        single(lk1) function f3() (3);
        lepton l2[a : {&v1}];
        single(lk1) lock lk2;
        tagalong t2 : {&v1};
        tagalong t3 on {&v1};
        tagalong t4 := &v1;
        single(lk1) tagalong t5;
        variable v36 := &(v1[3]);
        variable v37 := &(v1[&v2]);
        variable v38 := &(v1[* : filter_a]);
        variable v39 := &(v1.aaa);
        variable v40 := &(v1..t1);
        cleanup { "Cleaning up big."! };
      };
    [] := [big()];
    "Finished big test."!
  };


/* Now we'll try a test that triggered a bug in some versions of SalmonEye. */

  {
    "Starting map-object test."!
    variable x := <<(* --> null)>>;
    immutable i1 := class(){}();
    x[3] := i1;
    x[5] := i1;
    x[7] := i1;
    "Finished map-object test."!
  };


/* And now we'll try another test of maps and objects that tripped up some
 * versions of SalmonEye. */

  {
    "Starting second map-object test."!
    class c1() {};
    class c2()
      {
        variable v1;
        v1[0] := c1();
        v1[1] := c1();
        v1[2] := c1();
        v1[2] := c1();
        v1[3] := c1();
        v1[0] := 0;
        v1[1] := 0;
      };

    [] := [c2()];
    "Finished second map-object test."!
  };


/* And now we'll try a more complex version of the previous test. */

  {
    "Starting third map-object test."!
    class c1() {};
    class c2()
      {
        variable v1 := <<(* --> null)>>;
        v1[0] := c1();
        v1[1] := c1();
        v1[1] := v1[0];
        v1[2] := c1();
        v1[2] := c1();
        v1[3] := c1();
        v1[4] := c1();
        v1[5] := c1();
        v1["one"] := c1();
        v1["two"] := c1();
        v1["three"] := c1();
        v1["four"] := c1();
        v1["five"] := c1();
        v1[0] := c1();
        variable v2 := v1;
        quark q1;
        v2[8] := q1;
        v2[3] := null;
        v2[13] := null;
        v1["six"] := c1();
        v1["seven"] := c1();
        v1["eight"] := c1();
        v1["nine"] := c1();
        v1["ten"] := c1();
        v1[0] := 0;
        v1[1] := 0;
        v1[2] := 0;
        v1[3] := 0;
        v1[4] := 0;
        v1[5] := 0;
        v1["one"] := 0;
        v1["two"] := 0;
        v1["three"] := 0;
        v1["four"] := 0;
        v1["five"] := 0;
        v1["six"] := 0;
        v1["seven"] := 0;
        v1["eight"] := 0;
        v1["nine"] := 0;
        v1["ten"] := 0;
        v2[8] := 0;
        v1[0] := 0;
        v1[1] := 0;
      };

    [] := [c2()];
    "Finished third map-object test."!
  };


/* Now come a couple more map tests. */

  {
    variable v1;
    v1[0] := 0;
    v1[1] := 0;
    v1[2] := 0;
    v1[3] := 0;
    variable v2 := v1;
    v1[4] := 0;
    v1[5] := 0;
    v1[6] := 0;
    v1[7] := 0;
  };

  {
    variable v1 := ["a", "b", "c"];
    variable v2 := v1;
    v1[* : [2...2]] := ["d", "e"];
    v2[1] := "f";
    v1!
    v2!
  };

  {
    variable v1 := ["a", "b", "c"];
    variable v2 := v1;
    v1[* : [1...2]] := ["d", "e"];
    v2[1] := "f";
    v1!
    v2!
  };

  {
    variable v1 := ["a", "b", "c"];
    variable v2 := v1;
    v1[* : [0...2]] := ["d", "e"];
    v2[1] := "f";
    v1!
    v2!
  };


/* The following test triggers a performance bug in some old versions of
 * SalmonEye in which an assertion took time that was exponential in the length
 * of a map value chain. */

  {
    variable v1;
    for (i; 0; i < 200; 1)
      {
        v1[type <<pure function(x) returns boolean
                    ((x in integer) && (x % 5) == 4)>>] := 1;
      };
    length(split(@ --> @, sprint(v1)))!
  };


/* And now we have a couple tests of cases where a key value becomes invalid
 * while the map expression it is a part of is still being evaluated.  In some
 * old versions of SalmonEye, this caused assertion failures. */

  {
    ageless variable v1;
    class c1()
      {
        cleanup { delete(&v1); };
      };
    [] := [<<(&v1 --> 1), (2 --> c1()), (* : integer --> 2)>>];
  };

  {
    ageless variable v1;
    class c1()
      {
        cleanup { delete(&v1); };
      };
    try
      {
        [] := [<<(&v1 --> 1), (2 --> c1()), (* : integer --> 2), (8 --> 9)>>];
      }
    catch
      {
        print("Exception caught: ", current_exceptions(), ".\n");
      };
  };


/* Next, we'll do some tests of the numerator() and denominator() functions. */

  {
    procedure do_one(value : rational)
      {
        print(value, ": numerator = ", numerator(value), ", denominator = ",
              denominator(value), ".\n");
      };

    do_one(0);
    do_one(1);
    do_one(2);
    do_one(-1);
    do_one(1/3);
    do_one(-1/3);
    do_one(-oo);
    do_one(+oo);
    do_one(1/0);
    do_one(0/0);
  };


/* Next we'll test putting a return type on a class. */

  {
    procedure test(to_test : {} <-- ())
      {
        try
          {
            to_test();
            print("No exception.\n");
          }
        catch
          {
            immutable e1 : exception := current_exceptions()[0];
            print("Caught [", e1.tag, "]: `", e1.message, "'.\n");
          };
      };

    test(procedure()
      {
        class c1() returns interface[a :- integer, b :- [5...7]]
          {
            immutable a := 3;
            immutable b := 5;
          };
        [] := [c1()];
      });

    test(procedure()
      {
        class c1() returns interface[a :- integer, b :- [5...7], c :- [8...9]]
          {
            immutable a := 3;
            immutable b := 5;
          };
        [] := [c1()];
      });
  };


/* Now, we'll do some testing of pure virtual routines. */

  {
    procedure test(to_test : {} <-- ())
      {
        try
          {
            to_test();
            print("No exception.\n");
          }
        catch
          {
            immutable e1 : exception := current_exceptions()[0];
            print("Caught [", e1.tag, "]: `", e1.message, "'.\n");
          };
      };

    test(procedure() { virtual procedure p1() := null; });

    class base()
      {
        virtual procedure p1() := null;
      };

    test(procedure() { [] := [base()]; });

    test(procedure()
      {
        class sub()
          {
            use base();
            procedure p2() { "sub()'s p2() called."! };
          };
        [] := [sub()];
      });

    test(procedure()
      {
        class sub()
          {
            use base();
            procedure p1() { "sub()'s p1() called."! };
          };
        [] := [sub()];
      });
  };


/* Next, let's do some tests of conversion of large integers. */

  {
    printf("%%d%% on 0x10000000000: %d%.\n", 0x10000000000);
    printf("%%x%% on 1099511627776: %x%.\n", 1099511627776);
    printf("%%x%% on 0x10000000000: %x%.\n", 0x10000000000);
    printf("%%d%% on 3e33: %d%.\n", 3e33);
    printf("%%x%% on 3e33: %x%.\n", 3e33);
    printf("%%d%% on 0x93e952cda8b9aa44111e00000000: %d%.\n",
           0x93e952cda8b9aa44111e00000000);
    printf("%%x%% on 3e3: %x%.\n", 3e3);
    printf("%%d%% on 0xbb8: %d%.\n", 0xbb8);
    printf("%%x%% on 3e5: %x%.\n", 3e5);
    printf("%%d%% on 0x493e0: %d%.\n", 0x493e0);
    printf("%%x%% on 3e7: %x%.\n", 3e7);
    printf("%%d%% on 0x1c9c380: %d%.\n", 0x1c9c380);
    printf("%%x%% on 3e8: %x%.\n", 3e8);
    printf("%%d%% on 0x11e1a300: %d%.\n", 0x11e1a300);
    printf("%%x%% on 3e9: %x%.\n", 3e9);
    printf("%%d%% on 0xb2d05e00: %d%.\n", 0xb2d05e00);
    printf("%%x%% on 3e10: %x%.\n", 3e10);
    printf("%%d%% on 0x6fc23ac00: %d%.\n", 0x6fc23ac00);
  };


/* Now, we'll do a test to make sure name references in parameter types aren't
 * bound to parameter names in the same parameter list.  This shows a bug in
 * some early versions of SalmonEye. */

  {
    immutable x := integer;
    procedure p1(x, y : x)
      {
        print("x: ", x, ".\n");
        print("y: ", y, ".\n");
      };

    p1("blue", 13);
  };


/* Next, we'll do some testing of use statements that change the names of the
 * things being used. */

  {
    immutable c1 := class() { variable a := "a", b := "b"; }();
    immutable empty := class() { }();

    procedure try_one(to_try : {} <-- ())
      {
        try
          {
            to_try();
          }
        catch
          {
            immutable e1 := current_exceptions()[0];
            print("Exception: ", e1.tag, ".\n");
          };
      };

    try_one(procedure()
      {
        use empty;
        use c1;
        print("a: ", a, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1;
        print("b: ", b, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1;
        print("c: ", c, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a;
        print("a: ", a, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a;
        print("b: ", b, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a;
        print("c: ", c, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a as c;
        print("a: ", a, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a as c;
        print("b: ", b, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a as c;
        print("c: ", c, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for c as c;
        print("a: ", a, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for c as c;
        print("b: ", b, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for c as c;
        print("c: ", c, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a as b, b as a;
        print("a: ", a, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a as b, b as a;
        print("b: ", b, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 for a as b, b as a;
        print("c: ", c, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except a;
        print("a: ", a, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except a;
        print("b: ", b, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except a;
        print("c: ", c, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except b, c;
        print("a: ", a, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except b, c;
        print("b: ", b, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except b, c;
        print("c: ", c, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except a, b;
        print("a: ", a, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except a, b;
        print("b: ", b, ".\n");
      });

    try_one(procedure()
      {
        use empty;
        use c1 except a, b;
        print("c: ", c, ".\n");
      });
  };


/* We'll now try some tests of use statements with types that refers to names
 * that aren't exported by the use statement.  This catches a bug in some early
 * versions of SalmonEye. */

  {
    immutable to_use := class()
      { quark outside; immutable aaa := outside; }();

      {
        use to_use : "multi_name_reference.salm";
        "Passed first use test of \"multi_name_reference.salm\"."!
      };

      {
        use to_use : "multi_name_reference.salm" except outside;
        "Passed second use test of \"multi_name_reference.salm\"."!
      };

      {
        use to_use : "multi_name_reference.salm" except aaa;
        "Passed third use test of \"multi_name_reference.salm\"."!
      };

      {
        use to_use : "multi_name_reference.salm" for aaa;
        "Passed fourth use test of \"multi_name_reference.salm\"."!
      };

      {
        use to_use : "multi_name_reference.salm" for outside as bbb;
        "Passed fifth use test of \"multi_name_reference.salm\"."!
      };
  };


/* Next, we'll do a test of trying to use an object after its class has gone
 * away.  In earlier versions of the SalmonEye interpreter, this could cause
 * the interpreter to crash. */

  {
    ageless class c1() { immutable a := 1; };
    immutable i1 := c1();
    i1.a!
    delete(c1);
    try
      {
        i1.a!
      }
    catch
      {
        print("Caught exception ", current_exceptions()[0].tag, ".\n");
      };
  };


/* Now, we'll test identifiers that start with the prefix ``operator''.  There
 * was a bug in early versions of SalmonEye that caused them to be tokenized
 * improperly. */

  {
    immutable operator := "Julia";
    immutable operatora := "Nicole";
    immutable operator_ := "Wilson";
    immutable operator5 := "Benjamin";
    immutable operator57 := "Hoyt";
    immutable operatorZ := "Wilson";
    operator !
    operatora!
    operator_!
    operator5!
    operator57!
    operatorZ!
  };


/* Next comes a type test that triggers a bug in some early versions of
 * SalmonEye. */

  {
    quark q1;
    print("q1 in (integer | {q1}): ", q1 in (integer | {q1}), ".\n");
    print("q1 in !(integer | {q1}): ", q1 in !(integer | {q1}), ".\n");
    print("q1 in (!(integer)) & (!{q1}): ", q1 in (!(integer)) & (!{q1}),
          ".\n");
    print("q1 in (!(integer)): ", q1 in (!(integer)), ".\n");
    print("q1 in (!{q1}): ", q1 in (!{q1}), ".\n");
  };


/* Now we'll do a test of having a type that is a filter function have the
 * filter function throw an exception.  In some early versions of SalmonEye,
 * this caused a memory leak. */

  {
    try
      { [] := [13 in <<pure function(x) returns boolean ("strawberry")>>]; }
    catch
      { print("Exception: ", current_exceptions()[0].tag, ".\n"); };
  };


/* Next, we'll test to make sure a reference with the initializer of a static
 * declaration doesn't pick up a parameter.  This catches a bug in some early
 * versions of SalmonEye. */

  {
    immutable i1 := 5;
    procedure p1(i1)
      {
        static immutable outer_i1 := i1;
        print("i1: ", i1, ".\n");
        print("outer_i1: ", outer_i1, ".\n");
      };
    p1(6);
  };


/* Now we'll test giving a name to a ``use'' statement. */

  {
    use aaa := class()
      {
        virtual immutable bbb := 3;
        virtual immutable ccc := 4;
      }();
    immutable ccc := 5;
    print("bbb: ", bbb, ".\n");
    print("ccc: ", ccc, ".\n");
    print("aaa.bbb: ", aaa.bbb, ".\n");
    print("aaa.ccc: ", aaa.ccc, ".\n");
  };


/* Next, we'll do some tests of the modules that allow strings to be accessed
 * with lookup operators, as if they were arrays of characters, bytes in UTF-8
 * form, unsigned 16-bit integers in UTF-16 form, or unsigned 32-bit integers
 * in UTF-32 form. */

try
  {
    print("\"abc\"[0]: ", "abc"[0]);
  }
catch
  {
    print("Exception: ", current_exceptions()[0].tag, ".\n");
  };

  {
    use "string_char_op.salm" : "string_char_op.si";

    print("\"abc\"[0]: ", "abc"[0], ".\n");
    print("\"abc\"[1]: ", "abc"[1], ".\n");
    print("\"abc\"[2]: ", "abc"[2], ".\n");
    print("\"abc\"[0...1]: ", "abc"[0...1], ".\n");
    print("\"abc\"[1...2]: ", "abc"[1...2], ".\n");

    variable v1 := "abc";
    print("v1: ", v1, ".\n");
    v1[0] := 'd';
    print("v1: ", v1, ".\n");
    v1[1] := 'e';
    print("v1: ", v1, ".\n");
    v1[0...1] := "fg";
    print("v1: ", v1, ".\n");
    v1[1...2] := "hi";
    print("v1: ", v1, ".\n");
    v1[1] := from_utf16([0x3c0]);
    print("to_utf8(v1): ", to_utf8(v1), ".\n");
    print("v1[0]: ", v1[0], ".\n");
    print("to_utf8(v1[1]): ", to_utf8(v1[1]), ".\n");
    print("v1[2]: ", v1[2], ".\n");
    v1[1] := from_utf32(0x13076);
    print("to_utf8(v1): ", to_utf8(v1), ".\n");
    print("v1[0]: ", v1[0], ".\n");
    print("to_utf8(v1[1]): ", to_utf8(v1[1]), ".\n");
    print("v1[2]: ", v1[2], ".\n");
  };

  {
    use "string_utf8_op.salm" : "string_utf8_op.si";

    print("\"abc\"[0]: ", "abc"[0], ".\n");
    print("\"abc\"[1]: ", "abc"[1], ".\n");
    print("\"abc\"[2]: ", "abc"[2], ".\n");
    print("\"abc\"[0...1]: ", "abc"[0...1], ".\n");
    print("\"abc\"[1...2]: ", "abc"[1...2], ".\n");

    variable v1 := "abc";
    print("v1: ", v1, ".\n");
    v1[0] := 100;
    print("v1: ", v1, ".\n");
    v1[1] := 101;
    print("v1: ", v1, ".\n");
    v1[0...1] := "fg";
    print("v1: ", v1, ".\n");
    v1[1...2] := "hi";
    print("v1: ", v1, ".\n");
    v1 := "f" ~ from_utf16([0x3c0]) ~ "i";
    print("to_utf8(v1): ", to_utf8(v1), ".\n");
    print("v1[0]: ", v1[0], ".\n");
    print("v1[1]: ", v1[1], ".\n");
    print("v1[2]: ", v1[2], ".\n");
    print("v1[3]: ", v1[3], ".\n");
    v1 := "f" ~ from_utf32(0x13076) ~ "i";
    print("to_utf8(v1): ", to_utf8(v1), ".\n");
    print("v1[0]: ", v1[0], ".\n");
    print("v1[1]: ", v1[1], ".\n");
    print("v1[2]: ", v1[2], ".\n");
    print("v1[3]: ", v1[3], ".\n");
    print("v1[4]: ", v1[4], ".\n");
    print("v1[5]: ", v1[5], ".\n");
  };

  {
    use "string_utf16_op.salm" : "string_utf16_op.si";

    print("\"abc\"[0]: ", "abc"[0], ".\n");
    print("\"abc\"[1]: ", "abc"[1], ".\n");
    print("\"abc\"[2]: ", "abc"[2], ".\n");
    print("\"abc\"[0...1]: ", "abc"[0...1], ".\n");
    print("\"abc\"[1...2]: ", "abc"[1...2], ".\n");

    variable v1 := "abc";
    print("v1: ", v1, ".\n");
    v1[0] := 100;
    print("v1: ", v1, ".\n");
    v1[1] := 101;
    print("v1: ", v1, ".\n");
    v1[0...1] := "fg";
    print("v1: ", v1, ".\n");
    v1[1...2] := "hi";
    print("v1: ", v1, ".\n");
    v1[1] := 0x3c0;
    print("to_utf8(v1): ", to_utf8(v1), ".\n");
    print("v1[0]: ", v1[0], ".\n");
    printf("v1[1]: 0x%x%.\n", v1[1]);
    print("v1[2]: ", v1[2], ".\n");
    v1 := "f" ~ from_utf32(0x13076) ~ "i";
    print("to_utf8(v1): ", to_utf8(v1), ".\n");
    print("v1[0]: ", v1[0], ".\n");
    printf("v1[1]: 0x%x%.\n", v1[1]);
    printf("v1[2]: 0x%x%.\n", v1[2]);
    print("v1[3]: ", v1[3], ".\n");
  };

  {
    use "string_utf32_op.salm" : "string_utf32_op.si";

    print("\"abc\"[0]: ", "abc"[0], ".\n");
    print("\"abc\"[1]: ", "abc"[1], ".\n");
    print("\"abc\"[2]: ", "abc"[2], ".\n");
    print("\"abc\"[0...1]: ", "abc"[0...1], ".\n");
    print("\"abc\"[1...2]: ", "abc"[1...2], ".\n");

    variable v1 := "abc";
    print("v1: ", v1, ".\n");
    v1[0] := 100;
    print("v1: ", v1, ".\n");
    v1[1] := 101;
    print("v1: ", v1, ".\n");
    v1[0...1] := "fg";
    print("v1: ", v1, ".\n");
    v1[1...2] := "hi";
    print("v1: ", v1, ".\n");
    v1[1] := 0x3c0;
    print("to_utf8(v1): ", to_utf8(v1), ".\n");
    print("v1[0]: ", v1[0], ".\n");
    printf("v1[1]: 0x%x%.\n", v1[1]);
    print("v1[2]: ", v1[2], ".\n");
    v1[1] := 0x13076;
    print("to_utf8(v1): ", to_utf8(v1), ".\n");
    print("v1[0]: ", v1[0], ".\n");
    printf("v1[1]: 0x%x%.\n", v1[1]);
    print("v1[2]: ", v1[2], ".\n");
  };


/* Now, let's try some tests of ``use'' statements with non-object values. */

  {
    use [];
  };

  {
    use [a := 1, b := "butter"];
    print("a: ", a, ".\n");
    print("b: ", b, ".\n");
  };

  {
    variable v1;
    v1.a := 2;
    v1.b := "milk";
    use v1;
    print("a: ", a, ".\n");
    print("b: ", b, ".\n");
    v1.a := 3;
    v1.b := "eggs";
    print("a: ", a, ".\n");
    print("b: ", b, ".\n");
  };

  {
    lepton l1;
    use l1[a := 4, b := "flour"];
    print("a: ", a, ".\n");
    print("b: ", b, ".\n");
  };

  {
    use [a := 1, b := "butter"] for a as b, b as a;
    print("a: ", a, ".\n");
    print("b: ", b, ".\n");
  };

  {
    immutable a := 17;
      {
        use [a := 1, b := "butter"] except a;
        print("a: ", a, ".\n");
        print("b: ", b, ".\n");
      };
  };

  {
    variable v1;
      {
        use [a := 1, b := "butter"];
        print("a: ", a, ".\n");
        print("b: ", b, ".\n");
        v1 := &a;
        print("*v1: ", *v1, ".\n");
        try
          {
            *v1 := 3;
          }
        catch
          {
            print("Exception: ", current_exceptions()[0].tag, ".\n");
          };
        print("a: ", a, ".\n");
      };
    try
      {
        print("*v1: ", *v1, ".\n");
      }
    catch
      {
        print("Exception: ", current_exceptions()[0].tag, ".\n");
      };
  };

  {
    class c1()
      {
        use [a := 1, b := "butter"];
        immutable c := 15;
      };
    immutable i1 := c1();
    print("i1.a: ", i1.a, ".\n");
    print("i1.b: ", i1.b, ".\n");
    print("i1.c: ", i1.c, ".\n");
  };

  {
    class c1()
      {
        use [a := 1, b := "butter"] for a as b, b as a;
        immutable c := 15;
      };
    immutable i1 := c1();
    print("i1.a: ", i1.a, ".\n");
    print("i1.b: ", i1.b, ".\n");
    print("i1.c: ", i1.c, ".\n");
  };


/* Next, we'll do some tests of comprehend expressions with iterators. */

  {
    iterate (x; [1...10])
        print("A: ", x, ".\n");;

    iterate (x; comprehend(y; [1...10]) (y*y))
        print("B: ", x, ".\n");;

    immutable i1 := comprehend(y; [1...10]) (y*y);
    iterate (x; i1)
        print("C: ", x, ".\n");;
    iterate (x; i1)
        print("D: ", x, ".\n");;

    immutable i2 := comprehend(y; [1...10])
      {
        if ((y % 2) == 0)
            continue;;
        return (y*y);
      };
    iterate (x; i2)
        print("E: ", x, ".\n");;

    immutable i3 := comprehend(y; [1...10])
      {
        if (y == 5)
            break;;
        return (y*y);
      };
    iterate (x; i3)
        print("F: ", x, ".\n");;

    iterate (x; comprehend(y; [1...10]; (y % 3) == 0) (y*y))
        print("G: ", x, ".\n");;

    immutable i4 :=
            comprehend(y; [1...10]; { if (y == 7) continue;; return true; })
              (y*y);
    iterate (x; i4)
        print("H: ", x, ".\n");;

    immutable i5 :=
        comprehend(y; [1...10]; { if (y == 7) break;; return true; }) (y*y);
    iterate (x; i5)
        print("I: ", x, ".\n");;
  };


/* Now, let's try some tests of iterate statements with filter expressions. */

  {
    iterate (x; [1...6]; (x % 2) == 0)
        print("A: ", x, ".\n");;

    iterate (x; [1...6]; { if (x == 5) break;; return true; })
        print("B: ", x, ".\n");;

    iterate (x; [1...6]; { if (x == 5) continue;; return true; })
        print("C: ", x, ".\n");;

    iterate (x; [1, 2, 3, 4, 5, 6]; (x % 2) == 0)
        print("D: ", x, ".\n");;

    iterate (x; [1, 2, 3, 4, 5, 6]; { if (x == 5) break;; return true; })
        print("E: ", x, ".\n");;

    iterate (x; [1, 2, 3, 4, 5, 6]; { if (x == 5) continue;; return true; })
        print("F: ", x, ".\n");;
  };


/* Next, we'll do some testing of try-catch statements with clauses specifying
 * single exceptions to handle. */

  {
    procedure p1(subject : {} <-- ())
      {
        try
          {
            subject();
            "p1(): No exception."!
          }
        catch (e1)
          { print("p1() A: ", e1.tag, ".\n"); };
      };

    procedure p2(subject : {} <-- ())
      {
        try
          {
            subject();
            "p2(): No exception."!
          }
        catch (e1 tagged {})
          { print("p2() A: ", e1.tag, ".\n"); }
        catch (e1 tagged {exception_tag_lookup_bad_base})
          { print("p2() B: ", e1.tag, ".\n"); }
        catch (e1 tagged {exception_tag_immutable_modification})
          { print("p2() C: ", e1.tag, ".\n"); }
        catch (e1)
          { print("p2() D: ", e1.tag, ".\n"); }
        catch (e1)
          { print("p2() E: ", e1.tag, ".\n"); };
      };

    procedure p3(subject : {} <-- ())
      {
        try
          {
            subject();
            "p3(): No exception."!
          }
        catch (e1 tagged {})
          { print("p3() A: ", e1.tag, ".\n"); }
        catch (e1 tagged {exception_tag_lookup_bad_base,
                          exception_tag_immutable_modification})
          { print("p3() B: ", e1.tag, ".\n"); }
        catch
          { print("p3() C: ", current_exceptions()[0].tag, ".\n"); };
      };

    iterate(pp; [p1, p2, p3])
      {
        pp(procedure() { });
        pp(procedure() { [] := [3[4]]; });
        pp(procedure() { immutable i1 := 3; i1 := 5; });
        pp(procedure() { [] := [3->ab]; });
      };
  };


/* And now let's do a test of read_line() from a string stream.  This was
 * broken on some early versions of SalmonEye. */

  {
    immutable stream :=
            open_input_string("To be, or not to be;\nthat is the question.");
    printf("First line: %v%.\n", stream.read_line());
    printf("Second line: %v%.\n", stream.read_line());
    printf("Third line: %v%.\n", stream.read_line());
  };


/* Next, we'll try a test that shows all the fields of the exception thrown by
 * the throw() procedure. */

  {
    quark et_test;
    try
        throw(et_test, "This is a test.");
    catch (e1)
        print("Exception from throw(): ", e1, ".\n");;
  };
