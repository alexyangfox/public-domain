Anonymous test: yes.
Anonymous test: no (no value is in the empty type).
Anonymous test: Error -- unexpected exception with tag exception_tag_type_for_invalid_nothing_indeterminate (While checking to see if an invaid value was in a type, SalmonEye could not determine whether the type could be the empty type or not.).
Anonymous test: Error -- unexpected exception with tag exception_tag_type_for_invalid_everything_indeterminate (While checking to see if an invaid value was in a type, SalmonEye could not determine whether the type could be the type of all values or not.).
Anonymous test: Error -- unexpected exception with tag exception_tag_variable_use_after_deallocation (Anonymous variable (declared at "tests/type.salm":67:39) was used after it had been deallocated.).
Testing if 1 is in type !{}: yes.
Testing if 1 is in type {}: no (no value is in the empty type).
Testing if 1 is in type integer: yes.
Testing if blue is in type integer: no (the value is not an integer and the type is that of all integers).
Testing if 1 is in type rational: yes.
Testing if 3/2 is in type rational: yes.
Testing if blue is in type rational: no (the value is not a rational and the type is that of all rationals).
Testing if @abc@ is in type regular_expression: yes.
Testing if 1 is in type regular_expression: no (the value is not a regular expression and the type is that of all regular expressions).
Testing if q1 is in type any_quark: yes.
Testing if 1 is in type any_quark: no (the value is not a quark and the type is that of all quarks).
Testing if l1[] is in type any_lepton: yes.
Testing if 1 is in type any_lepton: no (the value is not a lepton and the type is that of all leptons).
Testing if l1 is in type lepton_key: yes.
Testing if 1 is in type lepton_key: no (the value is not a lepton key and the type is that of all lepton keys).
Testing if j1 is in type jump_target: yes.
Testing if 1 is in type jump_target: no (the value is not a jump target and the type is that of all jump targets).
Testing if c1 is in type any_class: yes.
Testing if r1 is in type any_class: no (the value is a non-class routine and the type is that of all classes).
Anonymous test: yes.
Anonymous test: no (the value is a non-class routine and the type is that of all classes).
Testing if 1 is in type any_class: no (the value is not a routine of any sort and the type is that of all classes).
Anonymous test: yes.
Testing if 1 is in type object: no (the value is not an object and the type is that of all objects).
Testing if t1 is in type tagalong_key: yes.
Testing if 1 is in type tagalong_key: no (the value is not a tagalong key and the type is that of all tagalong keys).
Testing if lk1 is in type any_lock: yes.
Testing if 1 is in type any_lock: no (the value is not a lock and the type is that of all locks).
Testing if blue is in type string: yes.
Testing if 1 is in type string: no (the value is not a string and the type is that of all strings).
Testing if T is in type character: yes.
Testing if 1 is in type character: no (the value is not a character and the type is that of all characters).
Testing if 1 is in type [1...3]: yes.
Testing if 4 is in type [1...3]: no (the value is 4 and the type is a subset of the integers that does not include that value).
Testing if type filter_a is in type {type filter_b}: unknown (the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if type filter_a is in type {type filter_b, type filter_c}: unknown (the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if type filter_b is in type {type filter_b, type filter_c}: yes.
Testing if type filter_c is in type {type filter_b, type filter_c}: yes.
Testing if 1 is in type {type filter_b, type filter_c}: no (the type is an enumeration and the value is not in the enumeration list).
Testing if type filter_a is in type !{type filter_b, type filter_c}: unknown (the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if type filter_b is in type !{type filter_b, type filter_c}: no (the type is the negation of another type and the value is in that type).
Testing if 1 is in type !{type filter_b, type filter_c}: yes.
Testing if 1 is in type {2}: no (the value is 1 and the type is a subset of the integers that does not include that value).
Testing if 2 is in type {2}: yes.
Testing if 3 is in type {2}: no (the value is 3 and the type is a subset of the integers that does not include that value).
Testing if 4 is in type {2}: no (the value is 4 and the type is a subset of the integers that does not include that value).
Testing if a is in type {'a', 'b'} & {'b', 'c'}: no (the type is an intersection type and the value is not in the right-hand type of the intersection because the type is an enumeration and the value is not in the enumeration list).
Testing if b is in type {'a', 'b'} & {'b', 'c'}: yes.
Testing if c is in type {'a', 'b'} & {'b', 'c'}: no (the type is an intersection type and the value is not in the left-hand type of the intersection because the type is an enumeration and the value is not in the enumeration list).
Testing if d is in type {'a', 'b'} & {'b', 'c'}: no (the type is an intersection type and the value is not in the left-hand type of the intersection because the type is an enumeration and the value is not in the enumeration list).
Testing if type filter_a is in type {type filter_a} & {type filter_b}: unknown (the type is an intersection type and the value is in the left-hand type of the intersection and it is unclear if the value is in the right-hand type of the intersection because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if type filter_b is in type {type filter_a} & {type filter_b}: unknown (the type is an intersection type and the value is in the right-hand type of the intersection and it is unclear if the value is in the left-hand type of the intersection because the type is an enumeration and it is unclear whether the value is equal to type filter_a, which is one of the items in the enumeration list).
Testing if type filter_c is in type {type filter_a} & {type filter_b}: unknown (the type is an intersection type and it is unclear if the value is in the left-hand type of the intersection because the type is an enumeration and it is unclear whether the value is equal to type filter_a, which is one of the items in the enumeration list; and it is unclear if the value is in the right-hand type of the intersection because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if 1 is in type filter_a | filter_b: no (the type is a union type and the value is not in the left-hand type of the union because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the union because the type is a test function and calling the function on the value returned false).
Testing if 2 is in type filter_a | filter_b: no (the type is a union type and the value is not in the left-hand type of the union because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the union because the type is a test function and calling the function on the value returned false).
Testing if 3 is in type filter_a | filter_b: yes.
Testing if 4 is in type filter_a | filter_b: no (the type is a union type and the value is not in the left-hand type of the union because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the union because the type is a test function and calling the function on the value returned false).
Testing if 5 is in type filter_a | filter_b: no (the type is a union type and the value is not in the left-hand type of the union because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the union because the type is a test function and calling the function on the value returned false).
Testing if 6 is in type filter_a | filter_b: no (the type is a union type and the value is not in the left-hand type of the union because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the union because the type is a test function and calling the function on the value returned false).
Testing if 7 is in type filter_a | filter_b: yes.
Testing if 8 is in type filter_a | filter_b: yes.
Testing if 9 is in type filter_a | filter_b: no (the type is a union type and the value is not in the left-hand type of the union because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the union because the type is a test function and calling the function on the value returned false).
Testing if type filter_a is in type integer | {type filter_b}: unknown (the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and it is unclear if the value is in the right-hand type of the union because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if type filter_a is in type {type filter_b} | filter_c: unknown (the type is a union type and it is unclear if the value is in the left-hand type of the union because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list; and the value is not in the right-hand type of the union because the type is a test function and calling the function on the value returned false).
Testing if type filter_a is in type {type filter_b} | {type filter_c} & filter_any: unknown (the type is a union type and it is unclear if the value is in the left-hand type of the union because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list; and it is unclear if the value is in the right-hand type of the union because the type is an intersection type and the value is in the right-hand type of the intersection and it is unclear if the value is in the left-hand type of the intersection because the type is an enumeration and it is unclear whether the value is equal to type filter_c, which is one of the items in the enumeration list).
Testing if type filter_a is in type {type filter_b} | filter_any: yes.
Testing if 1 is in type filter_a ^ filter_b: no (the type is an exclusive-or type and the value is not in the left-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false).
Testing if 2 is in type filter_a ^ filter_b: no (the type is an exclusive-or type and the value is not in the left-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false).
Testing if 3 is in type filter_a ^ filter_b: no (the type is an exclusive-or type and the value is in both the left-hand and the right-hand types of the exclusive-or).
Testing if 4 is in type filter_a ^ filter_b: no (the type is an exclusive-or type and the value is not in the left-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false).
Testing if 5 is in type filter_a ^ filter_b: no (the type is an exclusive-or type and the value is not in the left-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false).
Testing if 6 is in type filter_a ^ filter_b: no (the type is an exclusive-or type and the value is not in the left-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false).
Testing if 7 is in type filter_a ^ filter_b: yes.
Testing if 8 is in type filter_a ^ filter_b: yes.
Testing if 9 is in type filter_a ^ filter_b: no (the type is an exclusive-or type and the value is not in the left-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false; and the value is not in the right-hand type of the exclusive-or because the type is a test function and calling the function on the value returned false).
Testing if type filter_a is in type integer ^ {type filter_b}: unknown (the type is an exclusive-or type and it is unclear if the value is in the right-hand type of the exclusive-or because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if type filter_a is in type {type filter_b} ^ filter_c: unknown (the type is an exclusive-or type and it is unclear if the value is in the left-hand type of the exclusive-or because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if type filter_a is in type {type filter_b} ^ {type filter_c} & filter_any: unknown (the type is an exclusive-or type and it is unclear if the value is in the left-hand type of the exclusive-or because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list; and it is unclear if the value is in the right-hand type of the exclusive-or because the type is an intersection type and the value is in the right-hand type of the intersection and it is unclear if the value is in the left-hand type of the intersection because the type is an enumeration and it is unclear whether the value is equal to type filter_c, which is one of the items in the enumeration list).
Testing if 1 is in type integer[-oo...+oo]: no (the value is not a map or semi-labeled value list and the type is an array type).
Testing if <<>> is in type integer[-oo...+oo]: yes.
Testing if <<(5 --> 17)>> is in type integer[-oo...+oo]: yes.
Testing if <<(5 --> "purple")>> is in type integer[-oo...+oo]: no (the value is a map with element "purple" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers).
Testing if <<(-5 --> 17)>> is in type integer[-oo...+oo]: yes.
Testing if <<(-5 --> "purple")>> is in type integer[-oo...+oo]: no (the value is a map with element "purple" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers).
Testing if <<(*: [-5...5] --> 17)>> is in type integer[-oo...+oo]: yes.
Testing if <<(*: [-5...5] --> "purple")>> is in type integer[-oo...+oo]: no (the value is a map with element "purple" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers).
Testing if <<(* --> 17)>> is in type integer[-oo...+oo]: no (the value is a map with key filter type !{} and the type is an array with bounds [-oo...+oo] and the key filter type is not a subset of that range because the candidate sub-type is the type containing all values and the candidate super-type does not contain all values).
Testing if <<(* --> "purple")>> is in type integer[-oo...+oo]: no (the value is a map with key filter type !{} and the type is an array with bounds [-oo...+oo] and the key filter type is not a subset of that range because the candidate sub-type is the type containing all values and the candidate super-type does not contain all values).
Testing if <<("blue" --> 17)>> is in type integer[-oo...+oo]: no (the value is a map with non-integer key "blue" and the type is an array type).
Testing if <<("blue" --> "purple")>> is in type integer[-oo...+oo]: no (the value is a map with non-integer key "blue" and the type is an array type).
Testing if <<(1/0 --> 17)>> is in type integer[-oo...+oo]: no (the value is a map with key oo and the type is an array type).
Testing if <<(1/0 --> "purple")>> is in type integer[-oo...+oo]: no (the value is a map with key oo and the type is an array type).
Testing if <<(0/0 --> 17)>> is in type integer[-oo...+oo]: no (the value is a map with key 0/0 and the type is an array type).
Testing if <<(0/0 --> "purple")>> is in type integer[-oo...+oo]: no (the value is a map with key 0/0 and the type is an array type).
Testing if <<(-1 --> 17)>> is in type integer[0...1]: no (the value is a map with key -1 and the type is an array type with lower bound 0).
Testing if <<(0 --> 17)>> is in type integer[0...1]: yes.
Testing if <<(1 --> 17)>> is in type integer[0...1]: yes.
Testing if <<(2 --> 17)>> is in type integer[0...1]: no (the value is a map with key 2 and the type is an array type with upper bound 1).
Testing if <<(1 --> type filter_a)>> is in type type filter_b[0...1]: unknown (the value is a map with element type filter_a and the type is an array type with an element type for which it is unclear whether that element value is in that element type because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both filter function types but with different filter functions and SalmonEye doesn't try to dig deeper in such situations).
Testing if <<(*: filter_a --> 17)>> is in type integer[0...1]: unknown (the value is a map with key filter type filter_a and the type is an array with bounds [0...1] and it is unclear whether the key filter type is a subset of that range because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if [] is in type integer[0...1]: yes.
Testing if [1] is in type integer[0...1]: yes.
Testing if [1] is in type integer[1...2]: no (the value is a non-empty semi-labeled value list and the type is an array type with a greater-than-zero lower bound (1)).
Testing if [1] is in type integer[-1...2]: yes.
Testing if [1, 1] is in type integer[0...1]: yes.
Testing if [1, 1, 1] is in type integer[0...1]: no (the value is a semi-labeled value list with 3 elements and the type is an array type with an upper bound of 1).
Testing if [1, a := 1] is in type integer[0...1]: no (the value is a semi-labeled value list with a label (a) on element number 1 and the type is an array type).
Testing if [1, "purple"] is in type integer[0...1]: no (the value is a semi-labeled value list with element "purple" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers).
Testing if [type filter_a] is in type type filter_b[0...1]: unknown (the value is a semi-labeled value list with element type filter_a and the type is an array type with an element type for which it is unclear whether that element value is in that element type because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both filter function types but with different filter functions and SalmonEye doesn't try to dig deeper in such situations).
Testing if -1 is in type {0, 1}: no (the value is -1 and the type is a subset of the integers that does not include that value).
Testing if 0 is in type {0, 1}: yes.
Testing if 1/2 is in type {0, 1}: no (the value is not an integer and the type is a subset of the integers).
Testing if 1 is in type {0, 1}: yes.
Testing if 3/2 is in type {0, 1}: no (the value is not an integer and the type is a subset of the integers).
Testing if 2 is in type {0, 1}: no (the value is 2 and the type is a subset of the integers that does not include that value).
Testing if 1/0 is in type {0, 1}: no (the value is oo and the type is a subset of the integers that does not include that value).
Testing if 0/0 is in type {0, 1}: no (the value is 0/0 and the type is a subset of the integers that does not include that value).
Testing if purple is in type {0, 1}: no (the value is not an integer and the type is a subset of the integers).
Testing if -1 is in type [0....1]: no (the value is -1 and the type is a subset of the rationals that does not include that value).
Testing if 0 is in type [0....1]: yes.
Testing if 1/2 is in type [0....1]: yes.
Testing if 1 is in type [0....1]: yes.
Testing if 3/2 is in type [0....1]: no (the value is 3/2 and the type is a subset of the rationals that does not include that value).
Testing if 2 is in type [0....1]: no (the value is 2 and the type is a subset of the rationals that does not include that value).
Testing if 1/0 is in type [0....1]: no (the value is 1/0 and the type is a subset of the rationals that does not include that value).
Testing if 0/0 is in type [0....1]: no (the value is 0/0 and the type is a subset of the rationals that does not include that value).
Testing if purple is in type [0....1]: no (the value is not a rational and the type is a subset of the rationals).
Testing if -1 is in type {1}: no (the value is -1 and the type is a subset of the integers that does not include that value).
Testing if 0 is in type {1}: no (the value is 0 and the type is a subset of the integers that does not include that value).
Testing if 1/2 is in type {1}: no (the value is not an integer and the type is a subset of the integers).
Testing if 1 is in type {1}: yes.
Testing if 3/2 is in type {1}: no (the value is not an integer and the type is a subset of the integers).
Testing if 2 is in type {1}: no (the value is 2 and the type is a subset of the integers that does not include that value).
Testing if 1/0 is in type {1}: no (the value is oo and the type is a subset of the integers that does not include that value).
Testing if 0/0 is in type {1}: no (the value is 0/0 and the type is a subset of the integers that does not include that value).
Testing if purple is in type {1}: no (the value is not an integer and the type is a subset of the integers).
Testing if -1 is in type (0....1]: no (the value is -1 and the type is a subset of the rationals that does not include that value).
Testing if 0 is in type (0....1]: no (the value is 0 and the type is a subset of the rationals that does not include that value).
Testing if 1/2 is in type (0....1]: yes.
Testing if 1 is in type (0....1]: yes.
Testing if 3/2 is in type (0....1]: no (the value is 3/2 and the type is a subset of the rationals that does not include that value).
Testing if 2 is in type (0....1]: no (the value is 2 and the type is a subset of the rationals that does not include that value).
Testing if 1/0 is in type (0....1]: no (the value is 1/0 and the type is a subset of the rationals that does not include that value).
Testing if 0/0 is in type (0....1]: no (the value is 0/0 and the type is a subset of the rationals that does not include that value).
Testing if purple is in type (0....1]: no (the value is not a rational and the type is a subset of the rationals).
Testing if -1 is in type {0}: no (the value is -1 and the type is a subset of the integers that does not include that value).
Testing if 0 is in type {0}: yes.
Testing if 1/2 is in type {0}: no (the value is not an integer and the type is a subset of the integers).
Testing if 1 is in type {0}: no (the value is 1 and the type is a subset of the integers that does not include that value).
Testing if 3/2 is in type {0}: no (the value is not an integer and the type is a subset of the integers).
Testing if 2 is in type {0}: no (the value is 2 and the type is a subset of the integers that does not include that value).
Testing if 1/0 is in type {0}: no (the value is oo and the type is a subset of the integers that does not include that value).
Testing if 0/0 is in type {0}: no (the value is 0/0 and the type is a subset of the integers that does not include that value).
Testing if purple is in type {0}: no (the value is not an integer and the type is a subset of the integers).
Testing if -1 is in type [0....1): no (the value is -1 and the type is a subset of the rationals that does not include that value).
Testing if 0 is in type [0....1): yes.
Testing if 1/2 is in type [0....1): yes.
Testing if 1 is in type [0....1): no (the value is 1 and the type is a subset of the rationals that does not include that value).
Testing if 3/2 is in type [0....1): no (the value is 3/2 and the type is a subset of the rationals that does not include that value).
Testing if 2 is in type [0....1): no (the value is 2 and the type is a subset of the rationals that does not include that value).
Testing if 1/0 is in type [0....1): no (the value is 1/0 and the type is a subset of the rationals that does not include that value).
Testing if 0/0 is in type [0....1): no (the value is 0/0 and the type is a subset of the rationals that does not include that value).
Testing if purple is in type [0....1): no (the value is not a rational and the type is a subset of the rationals).
Testing if -1 is in type {}: no (no value is in the empty type).
Testing if 0 is in type {}: no (no value is in the empty type).
Testing if 1/2 is in type {}: no (no value is in the empty type).
Testing if 1 is in type {}: no (no value is in the empty type).
Testing if 3/2 is in type {}: no (no value is in the empty type).
Testing if 2 is in type {}: no (no value is in the empty type).
Testing if 1/0 is in type {}: no (no value is in the empty type).
Testing if 0/0 is in type {}: no (no value is in the empty type).
Testing if purple is in type {}: no (no value is in the empty type).
Testing if -1 is in type (0....1): no (the value is -1 and the type is a subset of the rationals that does not include that value).
Testing if 0 is in type (0....1): no (the value is 0 and the type is a subset of the rationals that does not include that value).
Testing if 1/2 is in type (0....1): yes.
Testing if 1 is in type (0....1): no (the value is 1 and the type is a subset of the rationals that does not include that value).
Testing if 3/2 is in type (0....1): no (the value is 3/2 and the type is a subset of the rationals that does not include that value).
Testing if 2 is in type (0....1): no (the value is 2 and the type is a subset of the rationals that does not include that value).
Testing if 1/0 is in type (0....1): no (the value is 1/0 and the type is a subset of the rationals that does not include that value).
Testing if 0/0 is in type (0....1): no (the value is 0/0 and the type is a subset of the rationals that does not include that value).
Testing if purple is in type (0....1): no (the value is not a rational and the type is a subset of the rationals).
Testing if -oo is in type (0....+oo): no (the value is -oo and the type is a subset of the rationals that does not include that value).
Testing if -1 is in type (0....+oo): no (the value is -1 and the type is a subset of the rationals that does not include that value).
Testing if 0 is in type (0....+oo): no (the value is 0 and the type is a subset of the rationals that does not include that value).
Testing if 1 is in type (0....+oo): yes.
Testing if +oo is in type (0....+oo): no (the value is +oo and the type is a subset of the rationals that does not include that value).
Testing if -oo is in type (-oo....0): no (the value is -oo and the type is a subset of the rationals that does not include that value).
Testing if -1 is in type (-oo....0): yes.
Testing if 0 is in type (-oo....0): no (the value is 0 and the type is a subset of the rationals that does not include that value).
Testing if 1 is in type (-oo....0): no (the value is 1 and the type is a subset of the rationals that does not include that value).
Testing if +oo is in type (-oo....0): no (the value is +oo and the type is a subset of the rationals that does not include that value).
Testing if -oo is in type (-oo....+oo): no (the value is -oo and the type is a subset of the rationals that does not include that value).
Testing if -1 is in type (-oo....+oo): yes.
Testing if 0 is in type (-oo....+oo): yes.
Testing if 1 is in type (-oo....+oo): yes.
Testing if +oo is in type (-oo....+oo): no (the value is +oo and the type is a subset of the rationals that does not include that value).
Testing if -oo is in type (0....+oo]: no (the value is -oo and the type is a subset of the rationals that does not include that value).
Testing if -1 is in type (0....+oo]: no (the value is -1 and the type is a subset of the rationals that does not include that value).
Testing if 0 is in type (0....+oo]: no (the value is 0 and the type is a subset of the rationals that does not include that value).
Testing if 1 is in type (0....+oo]: yes.
Testing if +oo is in type (0....+oo]: yes.
Testing if -oo is in type [-oo....0): yes.
Testing if -1 is in type [-oo....0): yes.
Testing if 0 is in type [-oo....0): no (the value is 0 and the type is a subset of the rationals that does not include that value).
Testing if 1 is in type [-oo....0): no (the value is 1 and the type is a subset of the rationals that does not include that value).
Testing if +oo is in type [-oo....0): no (the value is +oo and the type is a subset of the rationals that does not include that value).
Testing if -oo is in type [-oo....+oo]: yes.
Testing if -1 is in type [-oo....+oo]: yes.
Testing if 0 is in type [-oo....+oo]: yes.
Testing if 1 is in type [-oo....+oo]: yes.
Testing if +oo is in type [-oo....+oo]: yes.
Testing if null is in type *.integer: yes.
Testing if null is in type *integer: no (the value is null and the type is a pointer type that disallows null values).
Testing if 15 is in type *integer: no (the type is a pointer type and the value is neither a pointer nor null).
Testing if &x is in type *+integer: yes.
Testing if &x is in type *+integer: no (the type is a writable pointer type and the value is a location based on an immutable).
Testing if &x is in type *integer: unknown (the type is a readable pointer type and the value is a pointer for which it is unclear whether all possible readable values are in the base type of the pointer because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if &x is in type *integer: no (the type is a readable pointer type and the value is a pointer for which not all possible readable values are in the base type of the pointer because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if &x is in type +integer: yes.
Testing if &x is in type +integer: unknown (the type is a writable pointer type and the value is a pointer for which it is unclear whether the base type of the pointer type is a subset of the legal writable values because the candidate super-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if &x is in type +rational: no (the type is a writable pointer type and the value is a pointer for which not all values in the base type of the pointer type are in the legal writable values because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if 989 is in type type !{}: no (the value is not a type and the type is a type type).
Testing if type integer is in type type rational: yes.
Testing if type rational is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type filter_a is in type type integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if <<>> is in type integer --> string: yes.
Testing if <<(*: integer --> "hello")>> is in type integer --> string: yes.
Testing if <<(*: filter_a --> "hello")>> is in type integer --> string: unknown (the value is a map with a key filter type of filter_a and the type is a map type with a key type for which it is unclear whether that key type is included because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if <<(type filter_a --> "hello")>> is in type type integer --> string: unknown (the value is a map with a key value of type filter_a and the type is a map type with a key type for which it is unclear whether that key value is included because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if <<(*: rational --> "hello")>> is in type integer --> string: no (the value is a map with a key filter type of rational and the type is a map type with a key type which does not include that key type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if <<(37/2 --> "hello")>> is in type integer --> string: no (the value is a map with a key value of 37/2 and the type is a map type with a key type which does not include that key value because the value is not an integer and the type is that of all integers).
Testing if <<(*: filter_a --> "hello"), (*: rational --> "hello")>> is in type integer --> string: no (the value is a map with a key filter type of rational and the type is a map type with a key type which does not include that key type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if <<(37/2 --> "hello"), (type filter_a --> "hello")>> is in type integer --> string: no (the value is a map with a key value of 37/2 and the type is a map type with a key type which does not include that key value because the value is not an integer and the type is that of all integers).
Testing if <<("hello" --> type filter_a)>> is in type string --> type integer: unknown (the value is a map with a target value of type filter_a and the type is a map type with a target type for which it is unclear whether that target value is included because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if <<(*: string --> type filter_a)>> is in type string --> type integer: unknown (the value is a map with a target value of type filter_a and the type is a map type with a target type for which it is unclear whether that target value is included because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if <<("hello" --> 37/2)>> is in type string --> integer: no (the value is a map with a target value of 37/2 and the type is a map type with a target type which does not include that target value because the value is not an integer and the type is that of all integers).
Testing if [] is in type integer --> string: yes.
Testing if ["aaa", "bbb"] is in type integer --> string: yes.
Testing if ["aaa", c := "bbb"] is in type integer --> string: no (the value is a semi-labeled value list with a label (c) on element number 1 and the type is a map type).
Testing if ["aaa", "bbb"] is in type {0, 1} --> string: yes.
Testing if ["aaa", "bbb", "ccc"] is in type {0, 1} --> string: no (the value is a semi-labeled value list with an element with index 2 and the type is a map type with a key type which does not include that index because the value is 2 and the type is a subset of the integers that does not include that value).
Testing if [type filter_a] is in type {0, 1} --> type integer: unknown (the value is a semi-labeled value list with an element value type filter_a and the type is a map type with a target type for which it is unclear whether that element is included because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if [37/2] is in type {0, 1} --> integer: no (the value is a semi-labeled value list with an element value 37/2 and the type is a map type with a target type which does not include that element because the value is not an integer and the type is that of all integers).
Testing if 12 is in type integer --> string: no (the value is not a map or semi-labeled value list and the type is a map type).
Anonymous test: yes.
Anonymous test: yes.
Anonymous test: yes.
Anonymous test: no (the routine type requires formal name `x' for parameter 0 but the value allows a routine with no name for that parameter).
Anonymous test: no (the routine type requires formal name `x' for parameter 0 but the value allows a routine with formal name `y' for that parameter).
Anonymous test: no (the routine type requires a default value for parameter 1 but the value allows a routine without a default value for that parameter).
Anonymous test: unknown (the routine type requires type integer for parameter 0 but the value allows a routine that has type filter_a for that parameter and SalmonEye could not determine whether the former is a subset of the later because the candidate super-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Anonymous test: no (the routine type requires type integer for parameter 0 but the value allows a routine that has type [0...1000] for that parameter and the former is not a subset of the later because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include +oo).
Anonymous test: yes.
Anonymous test: no (the routine type requires a parameter list of only 0 items be legal, but the value allows a routine that takes a parameter 0 and doesn't have an initializer for that parameter).
Anonymous test: no (the routine type requires a parameter list of only 1 item be legal, but the value allows a routine that takes a parameter 1 and doesn't have an initializer for that parameter).
Anonymous test: no (the routine type requires a parameter list of only 2 items be legal, but the value allows a routine that takes a parameter 2 and doesn't have an initializer for that parameter).
Anonymous test: yes.
Anonymous test: no (the routine type requires that an argument list of 1 item be allowed but the value allows a routine that takes only 0 arguments).
Anonymous test: no (the routine type requires that an argument list of 2 items be allowed but the value allows a routine that takes only 1 argument).
Anonymous test: no (the routine type requires that an argument list of 3 items be allowed but the value allows a routine that takes only 2 arguments).
Anonymous test: no (the routine type requires that an argument list with an argument with named `x' for argument 2 be allowed but the value allows a routine that doesn't take a named argument in that position).
Anonymous test: no (the routine type requires that any number of additional arguments be allowed but the value allows a routine that doesn't allow unlimited additional arguments).
Anonymous test: yes.
Anonymous test: no (the routine value matches parameters, but its return type does not match the required return type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Anonymous test: unknown (the routine value matches parameters, but SalmonEye is unable to determine whether its return type matches because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if p is in type {} <-- (): yes.
Testing if p is in type {} <-- (integer): yes.
Testing if p is in type {} <-- (x : integer): yes.
Testing if p is in type {} <-- (x : integer): no (the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires formal name `x' for parameter 0 but the value allows a routine with no name for that parameter).
Testing if p is in type {} <-- (x : integer): no (the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires formal name `x' for parameter 0 but the value allows a routine with formal name `y' for that parameter).
Testing if p is in type {} <-- (integer): unknown (the routine value is overloaded; SalmonEye can't tell if routine 0 on the overload list matches because the routine type requires type integer for parameter 0 but the value allows a routine that has type filter_a for that parameter and SalmonEye could not determine whether the former is a subset of the later because the candidate super-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if f is in type integer <-- (): unknown (the routine value is overloaded; routine 0 on the overload list matches parameters, but SalmonEye is unable to determine whether its return type matches because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if f is in type integer <-- (): no (the routine value is overloaded; routine 0 on the overload list matches parameters, but the return type of that routine does not match the required return type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if 12 is in type integer <-- (): no (the value is not a routine or routine chain and the type is a routine type).
Testing if bacon is in type fields[a : integer, b : string]: no (the type is a fields type and the value is one that has no fields).
Testing if [a := 5, b := "bacon"] is in type fields[a : integer, b : string]: yes.
Testing if [a := 5, b := 212] is in type fields[a : integer, b : string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if [a := 5] is in type fields[a : integer, b : string]: no (the type requires that a field named `b' exist, but the value has no such field).
Testing if [a := 5, b := "bacon", c := 212] is in type fields[a : integer, b : string]: no (the value has a field named `c' and the type disallows such a field).
Testing if [a := 5, b := "bacon", 212] is in type fields[a : integer, b : string]: no (the value has an unnamed field and the type disallows such a field).
Testing if [a := 5, b := "bacon", c := 212] is in type fields[a : integer, b : string, ...]: yes.
Testing if [a := 5, b := "bacon", 212] is in type fields[a : integer, b : string, ...]: yes.
Testing if [a := 5, b := type filter_a] is in type fields[a : integer, b : type integer]: unknown (the type requires that the field named `b' have type type integer, but the value has a field of that name with value type filter_a and SalmonEye is unable to determine whether that field value is in the required type because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Anonymous test: yes.
Anonymous test: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Anonymous test: no (the type requires that a field named `b' exist, but the value has no such field).
Anonymous test: no (the value has a field named `c' and the type disallows such a field).
Anonymous test: yes.
Anonymous test: unknown (the type requires that the field named `b' have type type integer, but the value has a field of that name with value type filter_a and SalmonEye is unable to determine whether that field value is in the required type because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Anonymous test: yes.
Anonymous test: no (the type requires that the field named `a' have type integer, but the value is an object with a variable field of that name with type rational, and the variable field's type is not a subset of the required type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Anonymous test: unknown (the type requires that the field named `a' have type integer, but the value is an object with a variable field of that name with type filter_a, and SalmonEye is unable to determine whether the variable field's type is a subset of the required type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if [a := 5, b := "bacon"] is in type fields[a : integer, b : string]: yes.
Testing if [a := 5, b := 212] is in type fields[a : integer, b : string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if l1[a := 5, b := "bacon"] is in type fields[a : integer, b : string]: yes.
Testing if l1[a := 5, b := 212] is in type fields[a : integer, b : string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if bacon is in type lepton l1[a : integer, b : string]: no (the type is a lepton type and the value is not a lepton).
Testing if [a := 5, b := "bacon"] is in type lepton l1[a : integer, b : string]: no (the type is a lepton type and the value is not a lepton).
Testing if [a := 5, b := 212] is in type lepton l1[a : integer, b : string]: no (the type is a lepton type and the value is not a lepton).
Anonymous test: no (the type is a lepton type and the value is not a lepton).
Anonymous test: no (the type is a lepton type and the value is not a lepton).
Testing if [a := 5, b := "bacon"] is in type lepton l1[a : integer, b : string]: no (the type is a lepton type and the value is not a lepton).
Testing if [a := 5, b := 212] is in type lepton l1[a : integer, b : string]: no (the type is a lepton type and the value is not a lepton).
Testing if l1[a := 5, b := "bacon"] is in type lepton l1[a : integer, b : string]: yes.
Testing if l1[a := 5, b := 212] is in type lepton l1[a : integer, b : string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if l2[a := 5, b := "bacon"] is in type lepton l1[a : integer, b : string]: no (the type is a lepton type with key l1 and the value is a lepton with a different key (l2)).
Testing if l2[a := 5, b := 212] is in type lepton l1[a : integer, b : string]: no (the type is a lepton type with key l1 and the value is a lepton with a different key (l2)).
Testing if bacon is in type multiset[a : integer, b : string]: no (the type is a multi-set type and the value is not a multi-set).
Testing if [a := 5, b := "bacon"] is in type multiset[a : integer, b : string]: no (the type is a multi-set type and the value is not a multi-set).
Testing if [a := 5, b := 212] is in type multiset[a : integer, b : string]: no (the type is a multi-set type and the value is not a multi-set).
Anonymous test: no (the type is a multi-set type and the value is not a multi-set).
Anonymous test: no (the type is a multi-set type and the value is not a multi-set).
Testing if [a := 5, b := "bacon"] is in type multiset[a : integer, b : string]: yes.
Testing if [b := "bacon", a := 5] is in type multiset[a : integer, b : string]: yes.
Testing if [a := 5, b := 212] is in type multiset[a : integer, b : string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if l1[a := 5, b := "bacon"] is in type multiset[a : integer, b : string]: no (the type is a multi-set type and the value is not a multi-set).
Testing if l1[a := 5, b := 212] is in type multiset[a : integer, b : string]: no (the type is a multi-set type and the value is not a multi-set).
Testing if bacon is in type interface[a : integer, b : string]: no (the type is an interface type and the value is one that has no fields).
Testing if [a := 5, b := "bacon"] is in type interface[a : integer, b : string]: yes.
Testing if [a := 5, b := 212] is in type interface[a : integer, b : string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Anonymous test: no (the type is an interface type that requires field `a' to be writable, but the value is an object with an immutable field by that name).
Anonymous test: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Anonymous test: yes.
Anonymous test: no (the type requires that the field named `b' have type string, but the value is an object with a variable field of that name with type integer, and the variable field's type is not a subset of the required type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not).
Anonymous test: no (the type is an interface type that requires field `b' to be writable, but the value is an object with a non-variable field by that name).
Anonymous test: yes.
Anonymous test: no (the type is an interface type that requires field `a' to be writable with all values of type rational, but the value is an object with a variable field by that name with type integer, and the field type is not a subset of the variable type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Anonymous test: unknown (the type is an interface type that requires field `a' to be writable with all values of type !{}, but the value is an object with a variable field by that name with type filter_a, and SalmonEye is unable to determine whether that field type is a subset of the variable type because the candidate sub-type is the type containing all values and SalmonEye is unable to determine whether the candidate super-type is the type containing all values).
Testing if [a := 5, b := "bacon"] is in type interface[a : integer, b : string]: yes.
Testing if [b := "bacon", a := 5] is in type interface[a : integer, b : string]: yes.
Testing if [a := 5, b := 212] is in type interface[a : integer, b : string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if l1[a := 5, b := "bacon"] is in type interface[a : integer, b : string]: yes.
Testing if l1[a := 5, b := 212] is in type interface[a : integer, b : string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if bacon is in type interface[a :- integer, b :- string]: no (the type is an interface type and the value is one that has no fields).
Testing if [a := 5, b := "bacon"] is in type interface[a :- integer, b :- string]: yes.
Testing if [a := 5, b := 212] is in type interface[a :- integer, b :- string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Anonymous test: yes.
Anonymous test: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Anonymous test: yes.
Anonymous test: no (the type requires that the field named `b' have type string, but the value is an object with a variable field of that name with type integer, and the variable field's type is not a subset of the required type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not).
Testing if [a := 5, b := "bacon"] is in type interface[a :- integer, b :- string]: yes.
Testing if [b := "bacon", a := 5] is in type interface[a :- integer, b :- string]: yes.
Testing if [a := 5, b := 212] is in type interface[a :- integer, b :- string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if l1[a := 5, b := "bacon"] is in type interface[a :- integer, b :- string]: yes.
Testing if l1[a := 5, b := 212] is in type interface[a :- integer, b :- string]: no (the type requires that the field named `b' have type string, but the value has a field of that name with value 212 and that field value is not in the required type because the value is not a string and the type is that of all strings).
Testing if 72 is in type [a : integer, b : string]: no (the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value).
Testing if <<(*: filter_a --> "Bob")>> is in type [string, string]: no (the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key).
Testing if <<(*: filter_a --> "Bob"), (0 --> "Fred"), (1 --> "Ginger")>> is in type [string, string]: unknown (the type is a semi-labeled value list type and the value is a map value with a filter component for which SalmonEye is unable to determine whether the filter is a subset of the range allowed for keys by the type ({0, 1}) because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if <<(*: {0, 1} --> "Bob")>> is in type [string, string]: yes.
Testing if <<(*: [0...2] --> "Bob")>> is in type [string, string]: no (the type is a semi-labeled value list type and the value is a map value with a filter component for which the filter is not a subset of the range allowed for keys by the type ({0, 1}) because the candidate sub-type is an integer type containing the value 2, which is not in the candidate super-type because the value is 2 and the type is a subset of the integers that does not include that value).
Testing if <<(*: {0, 1} --> "Bob"), ("Chuck" --> "Sarah")>> is in type [string, string, ...]: no (the type is a semi-labeled value list type and the value is a map value with a component with a non-integer key).
Testing if <<(*: {0, 1} --> "Bob"), (2 --> "Sarah")>> is in type [string, string, ...]: yes.
Testing if <<(*: {0, 1} --> "Bob"), (-1 --> "Sarah")>> is in type [string, string, ...]: no (the type is a semi-labeled value list type and the value is a map value with a component with a negative key).
Testing if <<(*: {0, 1} --> "Bob"), (+oo --> "Sarah")>> is in type [string, string, ...]: yes.
Testing if <<(*: {0, 1} --> "Bob"), (-oo --> "Sarah")>> is in type [string, string, ...]: no (the type is a semi-labeled value list type and the value is a map value with a component with an illegal non-finite key).
Testing if <<(*: {0, 1} --> "Bob"), (1/0 --> "Sarah")>> is in type [string, string, ...]: no (the type is a semi-labeled value list type and the value is a map value with a component with an illegal non-finite key).
Testing if <<(*: {0, 1} --> "Bob"), (0/0 --> "Sarah")>> is in type [string, string, ...]: no (the type is a semi-labeled value list type and the value is a map value with a component with an illegal non-finite key).
Testing if <<(*: {0, 1} --> "Bob"), (2 --> "Sarah")>> is in type [string, string]: no (the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a map value with a component with a key (2) that is beyond the end of those specified by the type).
Testing if <<(*: {0, 1} --> "Bob")>> is in type [string, b : string]: no (the type is a semi-labeled value list type which requires a name (`b') for one of its fields and the value is a map value).
Testing if <<(0 --> "Bob"), (1 --> 47)>> is in type [string, string]: no (the type is a semi-labeled value list type and the value is a map value for which the target for key 1 isn't in the type specified for this component by the semi-labeled value list type because the value is not a string and the type is that of all strings).
Testing if <<(0 --> "Bob"), (1 --> type filter_a)>> is in type [string, type integer]: unknown (the type is a semi-labeled value list type and the value is a map value for which SalmonEye is unable to determine whether the target for key 1 is in the type specified for this component by the semi-labeled value list type because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if [] is in type [string, string]: no (the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 0 values).
Testing if ["fish"] is in type [string, string]: no (the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value).
Testing if ["fish", "bird"] is in type [string, string]: yes.
Testing if ["fish", "bird", "lizard"] is in type [string, string]: no (the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a semi-labeled value list value with 3 values).
Testing if [] is in type [string, string, ...]: no (the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 0 values).
Testing if ["fish"] is in type [string, string, ...]: no (the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value).
Testing if ["fish", "bird"] is in type [string, string, ...]: yes.
Testing if ["fish", "bird", "lizard"] is in type [string, string, ...]: yes.
Testing if [] is in type [string]: no (the type is a semi-labeled value list type which specifies 1 value and the value is a semi-labeled value list value with only 0 values).
Testing if ["fish"] is in type [string]: yes.
Testing if ["fish", "bird"] is in type [string]: no (the type is a semi-labeled value list type which doesn't allow values beyond the 1 explicitly specified and the value is a semi-labeled value list value with 2 values).
Testing if ["fish", "bird", "lizard"] is in type [string]: no (the type is a semi-labeled value list type which doesn't allow values beyond the 1 explicitly specified and the value is a semi-labeled value list value with 3 values).
Testing if [] is in type [string, ...]: no (the type is a semi-labeled value list type which specifies 1 value and the value is a semi-labeled value list value with only 0 values).
Testing if ["fish"] is in type [string, ...]: yes.
Testing if ["fish", "bird"] is in type [string, ...]: yes.
Testing if ["fish", "bird", "lizard"] is in type [string, ...]: yes.
Testing if [] is in type []: yes.
Testing if ["fish"] is in type []: no (the type is a semi-labeled value list type which doesn't allow values beyond the 0 explicitly specified and the value is a semi-labeled value list value with 1 value).
Testing if [] is in type [...]: yes.
Testing if ["fish"] is in type [...]: yes.
Testing if ["fish", b := "bird"] is in type [string, b : string]: yes.
Testing if ["fish", "bird"] is in type [string, b : string]: no (the type is a semi-labeled value list type which specifies name `b' for component 1, and the value is a semi-labeled value list value with no name for that component).
Testing if ["fish", c := "bird"] is in type [string, b : string]: no (the type is a semi-labeled value list type which specifies name `b' for component 1, and the value is a semi-labeled value list value with a different name (`c') for that component).
Testing if ["fish", c := "bird", "lizard"] is in type [string, string, c : string]: no (the type is a semi-labeled value list type and the value is a semi-labeled value list with a field named `c' in a position different from the one specified for it by the type).
Testing if ["fish", 17] is in type [string, string]: no (the type is a semi-labeled value list type and the value is a semi-labeled value list value for which the value for component 1 isn't in the type specified for this component by the semi-labeled value list type because the value is not a string and the type is that of all strings).
Testing if ["fish", type filter_a] is in type [string, type integer]: unknown (the type is a semi-labeled value list type and the value is a semi-labeled value list value for which SalmonEye is unable to determine whether the value for component 1 is in the type specified for this component by the semi-labeled value list type because the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if 5 is in type @ab@: no (the type is a regular expression type and the value is not a string value).
Testing if a is in type @ab@: no (the type is a regular expression type and the value is a string value that doesn't match the regular expression).
Testing if b is in type @ab@: no (the type is a regular expression type and the value is a string value that doesn't match the regular expression).
Testing if ab is in type @ab@: yes.
Testing if ba is in type @ab@: no (the type is a regular expression type and the value is a string value that doesn't match the regular expression).
Testing if abc is in type @ab@: yes.
Testing if zabc is in type @ab@: yes.
Testing if 5 is in type c2: no (the type is a class type and the value is not an object value).
Anonymous test: yes.
Anonymous test: no (the type is a class type and the value is an object value for a different class).
Anonymous test: no (the type is a test function and calling the function on the value returned false).
Anonymous test: yes.
Anonymous test: no (the type is a test function and calling the function on the value returned false).
Anonymous test: yes.
Anonymous test: no (the type is a test function and calling the function on the value returned false).
Anonymous test: yes.
Testing if 1 is in type filter_d: no (the type is a test function and calling the function on the value returned false).
Testing if 2 is in type filter_d: no (the type is a test function and calling the function on the value returned false).
Testing if 3 is in type filter_d: yes.
Testing if 4 is in type filter_d: no (the type is a test function and calling the function on the value returned false).
Testing if 7 is in type filter_d: no (the type is a test function and calling the function on the value returned false).
Testing if 8 is in type filter_d: yes.
Testing if type filter_a is in type type !{}: yes.
Testing if type {} is in type type filter_a: yes.
Testing if type filter_a is in type type filter_a: yes.
Testing if type integer is in type type {}: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate super-type is the empty type and the candidate sub-type is non-empty).
Testing if type filter_a is in type type {}: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate super-type is the empty type and SalmonEye is unable to determine whether the candidate sub-type is non-empty).
Testing if type [1...3] is in type type integer: yes.
Testing if type [1...3] is in type type [0...2]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an integer type containing the value 3, which is not in the candidate super-type because the value is 3 and the type is a subset of the integers that does not include that value).
Testing if type {1, 2, 3, type filter_a} is in type type {1, 2, 3, type filter_b}: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is an enumeration containing the value type filter_a, and SalmonEye is unable to determine whether that value is in the candidate super-type because the type is an enumeration and it is unclear whether the value is equal to type filter_b, which is one of the items in the enumeration list).
Testing if type {1, 2, 3, type filter_a} is in type type {1, 2, 4, type filter_b}: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an enumeration containing the value 3, which is not in the candidate super-type because the type is an enumeration and the value is not in the enumeration list).
Anonymous test: no (the type is a test function and calling the function on the value returned false).
Testing if type [1...3] is in type type integer: yes.
Anonymous test: yes.
Anonymous test: yes.
Anonymous test: yes.
Anonymous test: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Anonymous test: yes.
Testing if type !integer is in type type !rational: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both negation types and the base type of the later is not a sub-type of the base type of the former because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type !rational is in type type !integer: yes.
Testing if type !filter_a is in type type !integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both negation types and SalmonEye is unable to determine whether the base type of the later is a sub-type of the base type of the former because the candidate super-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer & filter_a is in type type (rational & filter_a): yes.
Testing if type integer & filter_a is in type type (string & filter_a): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is an intersection type and SalmonEye was unable to determine that either component of this intersection type was in the candidate super-type (the left component might not be in the later because the candidate super-type is an intersection type and SalmonEye doesn't try to dig deeper in such situations; and the right component might not be in the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations) and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer | filter_a is in type type (rational | filter_a): yes.
Testing if type integer | filter_a is in type type (string | filter_a): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a union type and SalmonEye is unable to determine whether the left component of the union is in the candidate super-type because the candidate super-type is a union type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer ^ filter_a is in type type (rational ^ filter_a): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both exclusive-or types and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer[1...5] is in type type (rational[1...5]): yes.
Testing if type rational[1...5] is in type type (integer[1...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both array types and the base of the former is not a sub-set of the base of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type filter_a[1...5] is in type type (integer[1...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both array types and SalmonEye is unable to determine whether the base of the former is a sub-set of the base of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer[0...5] is in type type (rational[1...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both array types and the lower bound of the former is less than the lower bound of the later, while the base of the former is non-empty).
Testing if type integer[2...5] is in type type (rational[1...5]): yes.
Testing if type integer[1...4] is in type type (rational[1...5]): yes.
Testing if type integer[1...6] is in type type (rational[1...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both array types and the upper bound of the former is greater than the upper bound of the later, while the base of the former is non-empty).
Testing if type filter_a[1...5] is in type type (filter_a[1...5]): yes.
Testing if type filter_a[0...5] is in type type (filter_a[1...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both array types and the lower bound of the former is less than the lower bound of the later, while SalmonEye is unable to determine whether the base of the former is non-empty).
Testing if type filter_a[2...5] is in type type (filter_a[1...5]): yes.
Testing if type filter_a[1...4] is in type type (filter_a[1...5]): yes.
Testing if type filter_a[1...6] is in type type (filter_a[1...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both array types and the upper bound of the former is greater than the upper bound of the later, while SalmonEye is unable to determine whether the base of the former is non-empty).
Testing if type [1...5] is in type type [1...5]: yes.
Testing if type [0...5] is in type type [1...5]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an integer type containing the value 0, which is not in the candidate super-type because the value is 0 and the type is a subset of the integers that does not include that value).
Testing if type [2...5] is in type type [1...5]: yes.
Testing if type [1...4] is in type type [1...5]: yes.
Testing if type [1...6] is in type type [1...5]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an integer type containing the value 6, which is not in the candidate super-type because the value is 6 and the type is a subset of the integers that does not include that value).
Testing if type *integer is in type type *integer: yes.
Testing if type *.integer is in type type *integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types and the former allows null while the later does not).
Testing if type *integer is in type type *.integer: yes.
Testing if type *.integer is in type type *.integer: yes.
Testing if type *+integer is in type type *integer: yes.
Testing if type *integer is in type type *+integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types and the later requires writing be allowed while the former does not, and the base type of the later is non-empty).
Testing if type *+integer is in type type *+integer: yes.
Testing if type +integer is in type type +integer: yes.
Testing if type *+integer is in type type +integer: yes.
Testing if type +integer is in type type *+integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types and the later requires reading be allowed while the former does not).
Testing if type *filter_a is in type type *filter_a: yes.
Testing if type *.filter_a is in type type *filter_a: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types and the former allows null while the later does not).
Testing if type *filter_a is in type type *.filter_a: yes.
Testing if type *.filter_a is in type type *.filter_a: yes.
Testing if type *+filter_a is in type type *filter_a: yes.
Testing if type *filter_a is in type type *+filter_a: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types and the later requires writing be allowed while the former does not, and SalmonEye is unable to determine whether the base type of the later might be the empty type).
Testing if type *+filter_a is in type type *+filter_a: yes.
Testing if type +filter_a is in type type +filter_a: yes.
Testing if type *+filter_a is in type type +filter_a: yes.
Testing if type +filter_a is in type type *+filter_a: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types and the later requires reading be allowed while the former does not).
Testing if type *integer is in type type *integer: yes.
Testing if type *integer is in type type *rational: yes.
Testing if type *rational is in type type *integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require reading be allowed and the base type of the former is not a sub-type of the base type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type *rational is in type type *rational: yes.
Testing if type *integer is in type type *integer: yes.
Testing if type *integer is in type type *filter_a: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require reading be allowed and SalmonEye is unable to determine whether the base type of the former is a sub-type of the base type of the later because the candidate super-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type *filter_a is in type type *integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require reading be allowed and SalmonEye is unable to determine whether the base type of the former is a sub-type of the base type of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type *filter_a is in type type *filter_a: yes.
Testing if type +integer is in type type +integer: yes.
Testing if type +integer is in type type +rational: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require writing be allowed and the base type of the later is not a sub-type of the base type of the former because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type +rational is in type type +integer: yes.
Testing if type +rational is in type type +rational: yes.
Testing if type +integer is in type type +integer: yes.
Testing if type +integer is in type type +filter_a: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require writing be allowed and SalmonEye is unable to determine whether the base type of the later is a sub-type of the base type of the former because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type +filter_a is in type type +integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require writing be allowed and SalmonEye is unable to determine whether the base type of the later is a sub-type of the base type of the former because the candidate super-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type +filter_a is in type type +filter_a: yes.
Testing if type *+integer is in type type *+integer: yes.
Testing if type *+integer is in type type *+rational: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require both reading and writing be allowed and the base type of the former is not equal to the base type of the later).
Testing if type *+rational is in type type *+integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require both reading and writing be allowed and the base type of the former is not equal to the base type of the later).
Testing if type *+rational is in type type *+rational: yes.
Testing if type *+integer is in type type *+integer: yes.
Testing if type *+integer is in type type *+filter_a: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require both reading and writing be allowed and SalmonEye is unable to determine whether the base type of the former is equal to the base type of the later).
Testing if type *+filter_a is in type type *+integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types that require both reading and writing be allowed and SalmonEye is unable to determine whether the base type of the former is equal to the base type of the later).
Testing if type *+filter_a is in type type *+filter_a: yes.
Testing if type *filter_a is in type type +filter_a: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types and the later requires writing be allowed while the former does not, and SalmonEye is unable to determine whether the base of the later is the empty type).
Testing if type *integer is in type type +integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both pointer types and the later requires writing be allowed while the former does not, and the base of the later is not the empty type).
Testing if type type integer is in type type type rational: yes.
Testing if type type rational is in type type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both type types and the base type of the former is not a sub-type of the base type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type type filter_a is in type type type integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both type types and SalmonEye is unable to determine whether the base type of the former is a sub-type of the base type of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer --> integer is in type type (rational --> rational): yes.
Testing if type rational --> rational is in type type (integer --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both map types, the target of the former is not the empty type, and the key type of the former is not a sub-type of the key type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type {} --> rational is in type type (integer --> integer): yes.
Testing if type rational --> {} is in type type (integer --> integer): yes.
Testing if type rational --> filter_a is in type type (integer --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both map types, SalmonEye is unable to determine whether the target of the former is the empty type, and the key type of the former is not a sub-type of the key type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type {} --> rational is in type type (integer --> integer): yes.
Testing if type integer --> rational is in type type (integer --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both map types, the key of the former is not the empty type, and the target type of the former is not a sub-type of the target type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type filter_a --> rational is in type type (integer --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both map types, SalmonEye is unable to determine whether the key of the former is the empty type, and the target type of the former is not a sub-type of the target type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type filter_a --> integer is in type type (integer --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both map types and SalmonEye is unable to determine whether the key type of the former is a sub-type of the key type of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer --> filter_a is in type type (integer --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both map types and SalmonEye is unable to determine whether the target type of the former is a sub-type of the target type of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer <-- () is in type type (integer <-- ()): yes.
Testing if type integer <-- (...) is in type type (integer <-- ()): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not the empty type and requires that extra arguments be allowed while the later does not allow extra arguments).
Testing if type integer <-- () is in type type (integer <-- (...)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not the empty type and the later requires that extra arguments be allowed while the former does not allow extra arguments).
Testing if type integer <-- (...) is in type type (integer <-- (...)): yes.
Testing if type integer <-- (*) is in type type (integer <-- ()): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not the empty type and leaves extra arguments unspecified while the later does not).
Testing if type integer <-- () is in type type (integer <-- (*)): yes.
Testing if type integer <-- (*) is in type type (integer <-- (*)): yes.
Testing if type integer <-- () is in type type (rational <-- ()): yes.
Testing if type rational <-- () is in type type (integer <-- ()): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not the empty type and has a return type that is not a sub-type of the return type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type filter_a <-- () is in type type (integer <-- ()): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and SalmonEye is unable to determine whether the return type of the former is a sub-type of the return type of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer <-- () is in type type (filter_a <-- ()): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and SalmonEye is unable to determine whether the return type of the former is a sub-type of the return type of the later because the candidate super-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer <-- () is in type type (integer <-- (integer)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 0 arguments while the later only allows routines with at least 1 argument).
Testing if type integer <-- (...) is in type type (integer <-- (integer, ...)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 0 arguments while the later only allows routines with at least 1 argument).
Testing if type integer <-- (*) is in type type (integer <-- (integer, *)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 0 arguments while the later only allows routines with at least 1 argument).
Testing if type integer <-- (integer) is in type type (integer <-- (integer, integer)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 1 argument while the later only allows routines with at least 2 arguments).
Testing if type integer <-- (integer, ...) is in type type (integer <-- (integer, integer, ...)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 1 argument while the later only allows routines with at least 2 arguments).
Testing if type integer <-- (integer, *) is in type type (integer <-- (integer, integer, *)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 1 argument while the later only allows routines with at least 2 arguments).
Testing if type integer <-- (integer, integer) is in type type (integer <-- (integer, integer, integer)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 2 arguments while the later only allows routines with at least 3 arguments).
Testing if type integer <-- (integer, integer, ...) is in type type (integer <-- (integer, integer, integer, ...)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 2 arguments while the later only allows routines with at least 3 arguments).
Testing if type integer <-- (integer, integer, *) is in type type (integer <-- (integer, integer, integer, *)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 2 arguments while the later only allows routines with at least 3 arguments).
Testing if type integer <-- (integer) is in type type (integer <-- ()): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 1 argument while the later only allows routines with 0 arguments).
Testing if type integer <-- (integer, ...) is in type type (integer <-- (...)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 1 argument while the later only allows routines with 0 arguments).
Testing if type integer <-- (integer, *) is in type type (integer <-- (*)): yes.
Testing if type integer <-- (integer, integer) is in type type (integer <-- (integer)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 2 arguments while the later only allows routines with 1 argument).
Testing if type integer <-- (integer, integer, ...) is in type type (integer <-- (integer, ...)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 2 arguments while the later only allows routines with 1 argument).
Testing if type integer <-- (integer, integer, *) is in type type (integer <-- (integer, *)): yes.
Testing if type integer <-- (integer, integer, integer) is in type type (integer <-- (integer, integer)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 3 arguments while the later only allows routines with 2 arguments).
Testing if type integer <-- (integer, integer, integer, ...) is in type type (integer <-- (integer, integer, ...)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not empty and allows routines with 3 arguments while the later only allows routines with 2 arguments).
Testing if type integer <-- (integer, integer, integer, *) is in type type (integer <-- (integer, integer, *)): yes.
Testing if type integer <-- (rational) is in type type (integer <-- (integer)): yes.
Testing if type integer <-- (integer) is in type type (integer <-- (rational)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not the empty type and argument type 0 of the former is not a sub-type of argument type 0 of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type integer <-- (integer) is in type type (integer <-- (filter_a)): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and SalmonEye is unable to determine whether argument type 0 of the former is a sub-type of argument type 0 of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer <-- (integer) is in type type (integer <-- (integer)): yes.
Testing if type integer <-- (integer) is in type type (integer <-- (a : integer)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not the empty type and the former requires no name for argument 0 while the later requires the name `a' for this argument).
Testing if type integer <-- (a : integer) is in type type (integer <-- (integer)): yes.
Testing if type integer <-- (a : integer) is in type type (integer <-- (a : integer)): yes.
Testing if type integer <-- (a : integer) is in type type (integer <-- (b : integer)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not the empty type and the former requires the name `a' for argument 0 while the later requires the name `b' for this argument).
Testing if type integer <-- (integer) is in type type (integer <-- (integer := *)): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both routine types and the former is not the empty type and the later requires a default for argument 0 while the former does not).
Testing if type integer <-- (integer := *) is in type type (integer <-- (integer)): yes.
Testing if type integer <-- (integer := *) is in type type (integer <-- (integer := *)): yes.
Testing if type fields[a : integer] is in type type fields[a : integer]: yes.
Testing if type fields[a : integer] is in type type fields[a : integer, ...]: yes.
Testing if type fields[a : integer, ...] is in type type fields[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows additional fields beyond those explicitly specified while the later does not and the former is not the empty type).
Testing if type fields[a : integer, ...] is in type type fields[a : integer, ...]: yes.
Testing if type fields[a : filter_a, ...] is in type type fields[a : integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows additional fields beyond those explicitly specified while the later does not and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type fields[a : integer] is in type type multiset[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is a multi-set type, and the former includes object values while the later does not).
Testing if type multiset[a : integer] is in type type fields[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows field `a' to be empty while the later does not and the former is not the empty type).
Testing if type {} is in type type fields[a : filter_a]: yes.
Testing if type multiset[a : filter_a, b : filter_a] is in type type fields[a : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows field `a' to be empty while the later does not and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type fields[a : integer, b : string, ...] is in type type fields[a : integer, ...]: yes.
Testing if type fields[a : integer, ...] is in type type fields[a : integer, b : string, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former doesn't specify field `b' while the later requires such a field and the former is not the empty type).
Testing if type fields[a : integer, b : string, ...] is in type type fields[a : integer, b : string, ...]: yes.
Testing if type fields[a : filter_a, b : string, ...] is in type type fields[a : filter_a, ...]: yes.
Testing if type fields[a : filter_a, ...] is in type type fields[a : filter_a, b : string, ...]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former doesn't specify field `b' while the later requires such a field and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type fields[a : filter_a, b : string, ...] is in type type fields[a : filter_a, b : string, ...]: yes.
Testing if type fields[a : integer, b : string] is in type type fields[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields, the former is not the empty type, and the former specifies field `b' while the later doesn't specify a field by that name and doesn't allow additional fields, and the former's type for this field is not the empty type).
Testing if type fields[a : filter_a, b : string] is in type type fields[a : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields, SalmonEye is unable to determine whether the former is the empty type, and the former specifies field `b' while the later doesn't specify a field by that name and doesn't allow additional fields, and the former's type for this field is not the empty type).
Testing if type fields[a : integer, b : filter_a] is in type type fields[a : integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former specifies field `b' while the later doesn't specify a field by that name and doesn't allow additional fields, and SalmonEye is unable to determine whether the former's type for this field might be the empty type).
Testing if type fields[a : filter_a, b : filter_a] is in type type fields[a : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former specifies field `b' while the later doesn't specify a field by that name and doesn't allow additional fields, and SalmonEye is unable to determine whether the former's type for this field might be the empty type).
Testing if type fields[a : integer, b : integer] is in type type fields[a : integer, b : rational]: yes.
Testing if type fields[a : integer, b : rational] is in type type fields[a : integer, b : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields, the former is not the empty type, and the type allowed by the former for field `b' is not a subset of the type allowed by the later for that field because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type fields[a : filter_a, b : integer] is in type type fields[a : filter_a, b : rational]: yes.
Testing if type fields[a : filter_a, b : rational] is in type type fields[a : filter_a, b : integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields, SalmonEye cannot determine whether the former might be the empty type, and the type allowed by the former for field `b' is not a subset of the type allowed by the later for that field because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type fields[a : filter_a, b : filter_a] is in type type fields[a : filter_a, b : integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and SalmonEye is unable to determine whether the type allowed by the former for field `b' is a subset of the type allowed by the later for that field because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type lepton l1[a : integer, b : integer] is in type type lepton l2[a : integer, b : rational]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both lepton types but with different keys (l1 and l2), and the former is not the empty type).
Testing if type lepton l1[a : filter_a, b : integer] is in type type lepton l2[a : filter_a, b : rational]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both lepton types but with different keys (l1 and l2), and SalmonEye is unable to determine whether the former is the empty type).
Testing if type lepton l1[a : integer, b : integer] is in type type lepton l1[a : integer, b : rational]: yes.
Testing if type lepton l1[a : integer, b : rational] is in type type lepton l1[a : integer, b : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields, the former is not the empty type, and the type allowed by the former for field `b' is not a subset of the type allowed by the later for that field because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type multiset[a : integer, b : integer] is in type type multiset[a : integer, b : rational]: yes.
Testing if type multiset[a : integer, b : rational] is in type type multiset[a : integer, b : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields, the former is not the empty type, and the type allowed by the former for field `b' is not a subset of the type allowed by the later for that field because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type interface[a : integer, b : string] is in type type interface[a : integer]: yes.
Testing if type interface[a :- integer, b : string] is in type type interface[a : integer]: yes.
Testing if type interface[a : integer, b : string] is in type type interface[a :- integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both interface types and the former allows writing to field `a' while the later does not and the former is not the empty type).
Testing if type interface[a :- integer, b : string] is in type type interface[a :- integer]: yes.
Testing if type interface[a : integer, b : filter_a] is in type type interface[a : integer]: yes.
Testing if type interface[a :- integer, b : filter_a] is in type type interface[a : integer]: yes.
Testing if type interface[a : integer, b : filter_a] is in type type interface[a :- integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both interface types and the former allows writing to field `a' while the later does not and SalmonEye is unable to determine whether the former is the empty type).
Testing if type interface[a :- integer, b : filter_a] is in type type interface[a :- integer]: yes.
Testing if type interface[a :- integer, b : filter_a] is in type type interface[a :- rational]: yes.
Testing if type interface[a :- rational, b : filter_a] is in type type interface[a :- integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both interface types and SalmonEye is unable to determine whether the former is the empty type and the type of the former for field `a' is not a subset of the type of the later for that field because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type interface[a :- filter_a, b : filter_a] is in type type interface[a :- integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both interface types and SalmonEye is unable to determine whether the type of the former for field `a' is a subset of the type of the later for that field because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type interface[a :- integer, b : string] is in type type interface[a :- rational]: yes.
Testing if type interface[a :- rational, b : string] is in type type interface[a :- integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both interface types and the former is not the empty type and the type of the former for field `a' is not a subset of the type of the later for that field because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type interface[a :- filter_a, b : string] is in type type interface[a :- integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both interface types and SalmonEye is unable to determine whether the type of the former for field `a' is a subset of the type of the later for that field because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type [a : integer, string] is in type type [a : integer, string]: yes.
Testing if type [a : integer, string] is in type type [a : integer, string, ...]: yes.
Testing if type [a : integer, string, ...] is in type type [a : integer, string]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former allows arbitrary additional elements while the later does not and the former is not the empty type).
Testing if type [a : integer, string, ...] is in type type [a : integer, string, ...]: yes.
Testing if type [a : integer, filter_a] is in type type [a : integer, filter_a]: yes.
Testing if type [a : integer, filter_a] is in type type [a : integer, filter_a, ...]: yes.
Testing if type [a : integer, filter_a, ...] is in type type [a : integer, filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former allows arbitrary additional elements while the later does not and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : integer, filter_a, ...] is in type type [a : integer, filter_a, ...]: yes.
Testing if type [a : integer] is in type type [a : integer, string]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 1 element while the later requires exactly 2 elements and the former is not the empty type).
Testing if type [a : integer] is in type type [a : integer, string, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 1 element while the later requires at least 2 elements and the former is not the empty type).
Testing if type [a : filter_a] is in type type [a : filter_a, string]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 1 element while the later requires exactly 2 elements and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type [a : filter_a] is in type type [a : filter_a, string, ...]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 1 element while the later requires at least 2 elements and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type [a : integer, string] is in type type [a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the later requires exactly 1 element while the former requires exactly 2 elements and the former is not the empty type).
Testing if type [a : integer, string, ...] is in type type [a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former allows arbitrary additional elements while the later does not and the former is not the empty type).
Testing if type [a : filter_a, string] is in type type [a : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the later requires exactly 1 element while the former requires exactly 2 elements and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type [a : filter_a, string, ...] is in type type [a : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former allows arbitrary additional elements while the later does not and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [] is in type type [string]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 0 elements while the later requires exactly 1 element and the former is not the empty type).
Testing if type [] is in type type [string, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 0 elements while the later requires at least 1 element and the former is not the empty type).
Testing if type [string] is in type type []: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the later requires exactly 0 elements while the former requires exactly 1 element and the former is not the empty type).
Testing if type [string, ...] is in type type []: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former allows arbitrary additional elements while the later does not and the former is not the empty type).
Testing if type [filter_a] is in type type []: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the later requires exactly 0 elements while the former requires exactly 1 element and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type [filter_a, ...] is in type type []: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former allows arbitrary additional elements while the later does not and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : integer, b : rational] is in type type [a : integer, b : rational, string]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 2 elements while the later requires exactly 3 elements and the former is not the empty type).
Testing if type [a : integer, b : rational] is in type type [a : integer, b : rational, string, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 2 elements while the later requires at least 3 elements and the former is not the empty type).
Testing if type [a : filter_a, b : rational] is in type type [a : filter_a, b : rational, string]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 2 elements while the later requires exactly 3 elements and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type [a : filter_a, b : rational] is in type type [a : filter_a, b : rational, string, ...]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former requires exactly 2 elements while the later requires at least 3 elements and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type [a : integer, b : rational, string] is in type type [a : integer, b : rational]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the later requires exactly 2 elements while the former requires exactly 3 elements and the former is not the empty type).
Testing if type [a : integer, b : rational, string, ...] is in type type [a : integer, b : rational]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former allows arbitrary additional elements while the later does not and the former is not the empty type).
Testing if type [a : filter_a, b : rational, string] is in type type [a : filter_a, b : rational]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the later requires exactly 2 elements while the former requires exactly 3 elements and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type [a : filter_a, b : rational, string, ...] is in type type [a : filter_a, b : rational]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former allows arbitrary additional elements while the later does not and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : integer] is in type type [a : rational]: yes.
Testing if type [a : rational] is in type type [a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former is not the empty type and the type of the former for element 0 is not a subset of the type of the later for that element because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type [a : filter_a] is in type type [a : integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and SalmonEye is unable to determine whether the type of the former for element 0 is a subset of the type of the later for that element because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type [a : integer, filter_a] is in type type [a : rational, filter_a]: yes.
Testing if type [a : rational, filter_a] is in type type [a : integer, filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and SalmonEye is unable to determine whether the former is the empty type and the type of the former for element 0 is not a subset of the type of the later for that element because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type [a : filter_a, filter_a] is in type type [a : integer, filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and SalmonEye is unable to determine whether the type of the former for element 0 is a subset of the type of the later for that element because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type [integer] is in type type [rational]: yes.
Testing if type [a : integer] is in type type [rational]: yes.
Testing if type [integer] is in type type [a : rational]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the later specifies a name (`a') for element 0 while the former does not and the former is not the empty type).
Testing if type [a : integer] is in type type [a : rational]: yes.
Testing if type [a : integer] is in type type [b : rational]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former specifies a name (`a') for element 0 that is different from the name specified by the later (`b') for that element and the former is not the empty type).
Testing if type [integer, filter_a] is in type type [rational, filter_a]: yes.
Testing if type [a : integer, filter_a] is in type type [rational, filter_a]: yes.
Testing if type [integer, filter_a] is in type type [a : rational, filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the later specifies a name (`a') for element 0 while the former does not and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type [a : integer, filter_a] is in type type [a : rational, filter_a]: yes.
Testing if type [a : integer, filter_a] is in type type [b : rational, filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both semi-labeled value list types and the former specifies a name (`a') for element 0 that is different from the name specified by the later (`b') for that element and SalmonEye is unable to determine whether the former might be the empty type).
Testing if type @.*ab*@ is in type type @.*abb*@: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both regular expression types and SalmonEye doesn't try to dig deeper in such situations).
Testing if type c1 is in type type c1: yes.
Testing if type c1 is in type type c2: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both class types but for different classes (c1 and c2)).
Testing if type filter_a is in type type filter_a: yes.
Testing if type filter_a is in type type filter_b: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type and the candidate super-type are both filter function types but with different filter functions and SalmonEye doesn't try to dig deeper in such situations).
Testing if type !{} is in type type !{}: yes.
Testing if type !{} is in type type rational: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type containing all values and the candidate super-type does not contain all values).
Testing if type !{} is in type type filter_a: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is the type containing all values and SalmonEye is unable to determine whether the candidate super-type is the type containing all values).
Testing if type !integer is in type type rational: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a negation type and the candidate super-type is not a negation type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer is in type type integer: yes.
Testing if type integer is in type type integer: yes.
Testing if type {} is in type type integer: yes.
Testing if type integer | filter_a is in type type integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a union type and SalmonEye is unable to determine whether the right component of the union is in the candidate super-type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type filter_a | filter_b is in type type filter_a: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a union type and SalmonEye is unable to determine whether the right component of the union is in the candidate super-type because the candidate sub-type and the candidate super-type are both filter function types but with different filter functions and SalmonEye doesn't try to dig deeper in such situations).
Testing if type filter_a | filter_b is in type type filter_b: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a union type and SalmonEye is unable to determine whether the left component of the union is in the candidate super-type because the candidate sub-type and the candidate super-type are both filter function types but with different filter functions and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer ^ rational is in type type string: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is an exclusive-or type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type filter_a is in type type integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer is in type type !string: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate super-type is a negation type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer is in type type (string & @ab*@): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate super-type is an intersection type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer is in type type (rational | @ab*@): yes.
Testing if type integer is in type type (rational ^ @ab*@): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate super-type is an exclusive-or type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer is in type type filter_a: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate super-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer is in type type [1...3]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include +oo).
Testing if type @a|b@ is in type type {"a", "b"}: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate super-type is an enumeration type and SalmonEye is unable to determine whether the candidate sub-type has an enumeration of that size or smaller).
Testing if type integer is in type type rational: yes.
Testing if type integer is in type type [-5...5]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include +oo).
Testing if type integer is in type type [-oo...+oo]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include oo).
Testing if type integer is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not).
Testing if type integer is in type type regular_expression: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all regular expressions, and the former includes integer values while the later does not).
Testing if type integer is in type type any_quark: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all quarks, and the former includes integer values while the later does not).
Testing if type integer is in type type any_lepton: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all leptons, and the former includes integer values while the later does not).
Testing if type integer is in type type lepton_key: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all lepton keys, and the former includes integer values while the later does not).
Testing if type integer is in type type jump_target: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all jump targets, and the former includes integer values while the later does not).
Testing if type integer is in type type any_class: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all classes, and the former includes integer values while the later does not).
Testing if type integer is in type type object: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all objects, and the former includes integer values while the later does not).
Testing if type integer is in type type tagalong_key: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all tagalong keys, and the former includes integer values while the later does not).
Testing if type integer is in type type any_lock: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all locks, and the former includes integer values while the later does not).
Testing if type integer is in type type character: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all characters, and the former includes integer values while the later does not).
Testing if type integer is in type type (integer[0...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is an array type, and the former includes integer values while the later does not).
Testing if type integer is in type type *integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a pointer type, and the former includes integer values while the later does not).
Testing if type integer is in type type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a type type, and the former includes integer values while the later does not).
Testing if type integer is in type type (integer --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a map type, and the former includes integer values while the later does not).
Testing if type integer is in type type (integer <-- ()): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a routine type, and the former includes integer values while the later does not).
Testing if type integer is in type type fields[a : integer, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a fields type, and the former includes integer values while the later does not).
Testing if type integer is in type type lepton l1[...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a lepton type, and the former includes integer values while the later does not).
Testing if type integer is in type type multiset[a : integer, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a multi-set type, and the former includes integer values while the later does not).
Testing if type integer is in type type interface[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is an interface type, and the former includes integer values while the later does not).
Testing if type integer is in type type [a : integer, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a semi-labeled value list type, and the former includes integer values while the later does not).
Testing if type integer is in type type @ab@: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a regular expression type, and the former includes integer values while the later does not).
Testing if type integer is in type type c1: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all integers and the candidate super-type is a class type, and the former includes integer values while the later does not).
Testing if type rational is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type rational is in type type [-5...5]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all rationals and the candidate super-type is an integer type, and the former includes fractional values while the later does not).
Testing if type rational is in type type [-oo...+oo]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all rationals and the candidate super-type is an integer type, and the former includes fractional values while the later does not).
Testing if type rational is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all strings, and the former includes rational values while the later does not).
Testing if type regular_expression is in type type [-5...5]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all regular expressions and the candidate super-type is an integer type, and the former includes regular expression values while the later does not).
Testing if type any_quark is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all quarks and the candidate super-type is the type of all integers, and the former includes quark values while the later does not).
Testing if type any_lepton is in type type fields[...]: yes.
Testing if type any_lepton is in type type fields[]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all leptons and the candidate super-type is a fields type that doesn't allow fields beyond those it explicitly specifies, so the later does not include all leptons).
Testing if type any_lepton is in type type fields[a : !{}, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all leptons and the candidate super-type is a fields type that requires a field named `a' exist).
Testing if type any_lepton is in type type fields[a : rational, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all leptons and the candidate super-type is a fields type that requires a field named `a' exist).
Testing if type any_lepton is in type type fields[a : filter_a, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all leptons and the candidate super-type is a fields type that requires a field named `a' exist).
Testing if type object is in type type fields[...]: yes.
Testing if type object is in type type fields[]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all objects and the candidate super-type is a fields type that doesn't allow fields beyond those it explicitly specifies, so the later does not include all objects).
Testing if type object is in type type fields[a : !{}, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all objects and the candidate super-type is a fields type that requires a field named `a' exist).
Testing if type object is in type type fields[a : rational, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all objects and the candidate super-type is a fields type that requires a field named `a' exist).
Testing if type object is in type type fields[a : filter_a, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all objects and the candidate super-type is a fields type that requires a field named `a' exist).
Testing if type any_lepton is in type type interface[]: yes.
Testing if type any_lepton is in type type interface[a :- !{}]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all leptons and the candidate super-type is an interface type that makes requirements about certain fields, so the later does not include all leptons).
Testing if type object is in type type interface[]: yes.
Testing if type object is in type type interface[a :- !{}]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all objects and the candidate super-type is an interface type that makes requirements about certain fields, so the later does not include all objects).
Testing if type any_lepton is in type type lepton l1[...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all leptons and the candidate super-type is a specific lepton type, and the former includes all lepton values while the later only includes those for one specific lepton key).
Testing if type object is in type type lepton l1[...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all objects and the candidate super-type is a lepton type, and the former includes object values while the later does not).
Testing if type any_lepton is in type type c1: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all leptons and the candidate super-type is a class type, and the former includes lepton values while the later does not).
Testing if type object is in type type c1: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all objects and the candidate super-type is a class type, and the former includes all object values while the later only includes objects based on one specific class).
Testing if type any_lepton is in type type rational: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all leptons and the candidate super-type is the type of all rationals, and the former includes lepton values while the later does not).
Testing if type object is in type type rational: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all objects and the candidate super-type is the type of all rationals, and the former includes object values while the later does not).
Testing if type lepton_key is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all lepton keys and the candidate super-type is the type of all strings, and the former includes lepton key values while the later does not).
Testing if type jump_target is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all jump targets and the candidate super-type is the type of all strings, and the former includes jump target values while the later does not).
Testing if type any_class is in type type (!{} <-- ()): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all classes and the candidate super-type is a routine type that doesn't leave extra arguments unspecified, so the later does not include all possible classes).
Testing if type any_class is in type type (!{} <-- (*)): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is the type of all classes and the candidate super-type is a routine type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type any_class is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all classes and the candidate super-type is the type of all strings, and the former includes class values while the later does not).
Testing if type tagalong_key is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all tagalong keys and the candidate super-type is the type of all strings, and the former includes tagalong key values while the later does not).
Testing if type any_lock is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all locks and the candidate super-type is the type of all strings, and the former includes lock values while the later does not).
Testing if type string is in type type @ab@: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is the type of all strings and the candidate super-type is a regular expression type, so the former is a sub-type if and only if the regular expression of the later matches all strings and SalmonEye doesn't try to analyze regular expressions to see whether they match all strings).
Testing if type string is in type type rational: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all strings and the candidate super-type is the type of all rationals, and the former includes string values while the later does not).
Testing if type character is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all characters and the candidate super-type is the type of all strings, and the former includes character values while the later does not).
Testing if type character[0...5] is in type type (integer --> character): yes.
Testing if type character[0...5] is in type type (integer --> string): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both map types, the key of the former is not the empty type, and the target type of the former is not a sub-type of the target type of the later because the candidate sub-type is the type of all characters and the candidate super-type is the type of all strings, and the former includes character values while the later does not).
Testing if type character[0...5] is in type type [...]: yes.
Testing if type {}[0...5] is in type type [...]: yes.
Testing if type {}[0...5] is in type type []: yes.
Testing if type {}[0...5] is in type type [a : integer, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is a semi-labeled value list type, and the later specifies more than zero elements, so it does not include the empty semi-labeled value list, while all array types include the empty semi-labeled value list).
Testing if type {}[0...5] is in type type [a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is a semi-labeled value list type, and the later specifies more than zero elements, so it does not include the empty semi-labeled value list, while all array types include the empty semi-labeled value list).
Testing if type integer[0...5] is in type type [...]: yes.
Testing if type integer[0...5] is in type type []: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is a semi-labeled value list type, and the later allows only zero-element values and the former's bounds allow allow a non-zero number of elements, and the former's base type is non-empty).
Testing if type integer[0...5] is in type type [a : integer, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is a semi-labeled value list type, and the later specifies more than zero elements, so it does not include the empty semi-labeled value list, while all array types include the empty semi-labeled value list).
Testing if type integer[0...5] is in type type [a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is a semi-labeled value list type, and the later specifies more than zero elements, so it does not include the empty semi-labeled value list, while all array types include the empty semi-labeled value list).
Testing if type filter_a[0...5] is in type type []: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is a semi-labeled value list type, and the later allows only zero-element values and the former's bounds allow allow a non-zero number of elements, and SalmonEye is unable to determine whether the former's base type is empty).
Testing if type integer[0...-1] is in type type []: yes.
Testing if type integer[-5...5] is in type type [...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is a semi-labeled value list type, and the former's lower bound allows values with elements with negative indexes, and the former's base type is non-empty).
Testing if type filter_a[-5...5] is in type type [...]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is a semi-labeled value list type, and the former's lower bound allows values with elements with negative indexes, and SalmonEye is unable to determine whether the former's base type is empty).
Testing if type integer[0...5] is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an array type and the candidate super-type is the type of all integers, and the former includes map values while the later does not).
Testing if type [0...5] is in type type integer: yes.
Testing if type [0...5] is in type type rational: yes.
Testing if type [0...5] is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an integer type containing the value 0, which is not in the candidate super-type because the value is not a string and the type is that of all strings).
Testing if type *integer is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a pointer type and the candidate super-type is the type of all strings, and the former includes pointer values while the later does not).
Testing if type *filter_a is in type type string: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a pointer type and the candidate super-type is the type of all strings, and if the former is non-empty it includes pointer values while the later does not, but SalmonEye is unable to determine whether the former is empty).
Testing if type type !{} is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a type type and the candidate super-type is the type of all strings, and the former includes type values while the later does not).
Testing if type type filter_a is in type type string: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a type type and the candidate super-type is the type of all strings, and if the former is non-empty it includes type values while the later does not, but SalmonEye is unable to determine whether the former is empty).
Testing if type [0...5] --> string is in type type (string[0...4]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both map types, the target of the former is not the empty type, and the key type of the former is not a sub-type of the key type of the later because the candidate sub-type is an integer type containing the value 5, which is not in the candidate super-type because the value is 5 and the type is a subset of the integers that does not include that value).
Testing if type [0...5] --> string is in type type (string[0...5]): yes.
Testing if type [0...5] --> string is in type type (string[0...6]): yes.
Testing if type [0...5] --> string is in type type [string]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a map type and the candidate super-type is a semi-labeled value list type that specifies more than zero elements, so the former includes the empty map while the later does not).
Testing if type [0...5] --> string is in type type []: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a map type with a non-empty target type and the candidate super-type is a semi-labeled value list type, and the former's key type is not a subset the range of keys allowed by the later because the candidate super-type is the empty type and the candidate sub-type is non-empty).
Testing if type [0...5] --> string is in type type [...]: yes.
Testing if type rational --> string is in type type []: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a map type with a non-empty target type and the candidate super-type is a semi-labeled value list type, and the former's key type is not a subset the range of keys allowed by the later because the candidate super-type is the empty type and the candidate sub-type is non-empty).
Testing if type rational --> string is in type type [...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a map type with a non-empty target type and the candidate super-type is a semi-labeled value list type, and the former's key type is not a subset the range of keys allowed by the later because the candidate sub-type is the type of all rationals and the candidate super-type is an integer type, and the former includes fractional values while the later does not).
Testing if type filter_a --> string is in type type []: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a map type and the candidate super-type is a semi-labeled value list type, and SalmonEye is unable to determine whether the former's key type is a subset the range of keys allowed by the later because the candidate super-type is the empty type and SalmonEye is unable to determine whether the candidate sub-type is non-empty).
Testing if type filter_a --> string is in type type [...]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a map type and the candidate super-type is a semi-labeled value list type, and SalmonEye is unable to determine whether the former's key type is a subset the range of keys allowed by the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type rational --> {} is in type type []: yes.
Testing if type rational --> {} is in type type [...]: yes.
Testing if type rational --> filter_a is in type type []: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a map type and the candidate super-type is a semi-labeled value list type, and SalmonEye is unable to determine whether the former's target type is the empty type, and the former's key type is not a subset the range of keys allowed by the later because the candidate super-type is the empty type and the candidate sub-type is non-empty).
Testing if type rational --> filter_a is in type type [...]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a map type and the candidate super-type is a semi-labeled value list type, and SalmonEye is unable to determine whether the former's target type is the empty type, and the former's key type is not a subset the range of keys allowed by the later because the candidate sub-type is the type of all rationals and the candidate super-type is an integer type, and the former includes fractional values while the later does not).
Testing if type rational --> filter_a is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a map type and the candidate super-type is the type of all strings, and the former includes map values while the later does not).
Testing if type integer <-- () is in type type any_class: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a routine type and the candidate super-type is the type of all classes and SalmonEye doesn't try to dig deeper in such situations).
Testing if type integer <-- () is in type type string: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a routine type and the candidate super-type is the type of all strings, and the former includes routine values while the later does not).
Testing if type fields[a : integer] is in type type interface[a :- integer]: yes.
Testing if type fields[a : integer] is in type type interface[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is an interface type and the later requires writing be allowed for a field named `a' and specifies a non-empty type for that field, and the former is not the empty type).
Testing if type fields[a : filter_a] is in type type interface[a :- filter_a]: yes.
Testing if type fields[a : filter_a] is in type type interface[a : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is an interface type and the later requires writing be allowed for a field named `a' and SalmonEye is unable to determine whether the type specified by the later for that field is the empty type).
Testing if type fields[a : rational] is in type type interface[a :- integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields, the former is not the empty type, and the type allowed by the former for field `a' is not a subset of the type allowed by the later for that field because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type fields[a : integer, b : filter_a] is in type type interface[a : integer]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is an interface type and the later requires writing be allowed for a field named `a' and specifies a non-empty type for that field, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type fields[a : integer] is in type type any_lepton: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is the type of all leptons, and the former includes object values while the later does not).
Testing if type fields[a : integer] is in type type (integer[0...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is an array type, and the former includes object values while the later does not).
Testing if type fields[a : integer] is in type type (integer --> string): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is a map type, and the former includes object values while the later does not).
Testing if type fields[a : integer] is in type type lepton l1[...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is a lepton type, and the former includes object values while the later does not).
Testing if type fields[a : integer] is in type type multiset[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is a multi-set type, and the former includes object values while the later does not).
Testing if type fields[a : integer] is in type type [a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is a semi-labeled value list type, and the former includes object values while the later does not).
Testing if type fields[a : integer] is in type type object: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is the type of all objects, and the former includes semi-labeled value list values while the later does not).
Testing if type fields[a : integer] is in type type c1: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is a class type, and the former includes semi-labeled value list values while the later does not).
Testing if type fields[a : integer] is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a fields type and the candidate super-type is the type of all integers, and the former includes semi-labeled value list values while the later does not).
Testing if type lepton l1[...] is in type type any_lepton: yes.
Testing if type lepton l1[a : integer] is in type type any_lepton: yes.
Testing if type lepton l1[...] is in type type fields[...]: yes.
Testing if type lepton l1[a : integer] is in type type fields[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows field `a' to be empty while the later does not and the former is not the empty type).
Testing if type lepton l1[...] is in type type interface[]: yes.
Testing if type lepton l1[a : integer] is in type type interface[a :- integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows field `a' to be empty while the later does not and the former is not the empty type).
Testing if type lepton l1[...] is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a lepton type and the candidate super-type is the type of all integers, and the former includes lepton values while the later does not).
Testing if type lepton l1[a : integer] is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a lepton type and the candidate super-type is the type of all integers, and the former includes lepton values while the later does not).
Testing if type multiset[...] is in type type any_lepton: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a multi-set type and the candidate super-type is the type of all leptons, and the former includes multi-set values while the later does not).
Testing if type multiset[a : integer] is in type type any_lepton: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a multi-set type and the candidate super-type is the type of all leptons, and the former includes multi-set values while the later does not).
Testing if type multiset[...] is in type type fields[...]: yes.
Testing if type multiset[a : integer] is in type type fields[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows field `a' to be empty while the later does not and the former is not the empty type).
Testing if type multiset[...] is in type type interface[]: yes.
Testing if type multiset[a : integer] is in type type interface[a :- integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows field `a' to be empty while the later does not and the former is not the empty type).
Testing if type multiset[...] is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a multi-set type and the candidate super-type is the type of all integers, and the former includes multi-set values while the later does not).
Testing if type multiset[a : integer] is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a multi-set type and the candidate super-type is the type of all integers, and the former includes multi-set values while the later does not).
Testing if type interface[] is in type type fields[...]: yes.
Testing if type interface[] is in type type fields[]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields and the former allows additional fields beyond those explicitly specified while the later does not and the former is not the empty type).
Testing if type interface[a : integer] is in type type fields[a : integer, ...]: yes.
Testing if type interface[a :- integer] is in type type fields[a : integer, ...]: yes.
Testing if type interface[a :- integer] is in type type fields[a : rational, ...]: yes.
Testing if type interface[a :- rational] is in type type fields[a : integer, ...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type and the candidate super-type are both types with fields, the former is not the empty type, and the type allowed by the former for field `a' is not a subset of the type allowed by the later for that field because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type interface[a :- integer] is in type type any_lepton: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is the type of all leptons, and the former includes object values while the later does not).
Testing if type interface[a :- integer] is in type type (integer[0...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is an array type, and the former includes object values while the later does not).
Testing if type interface[a :- integer] is in type type (integer --> string): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is a map type, and the former includes object values while the later does not).
Testing if type interface[a :- integer] is in type type lepton l1[...]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is a lepton type, and the former includes object values while the later does not).
Testing if type interface[a :- integer] is in type type multiset[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is a multi-set type, and the former includes object values while the later does not).
Testing if type interface[a :- integer] is in type type [a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is a semi-labeled value list type, and the former includes object values while the later does not).
Testing if type interface[a :- integer] is in type type object: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is the type of all objects, and the former includes semi-labeled value list values while the later does not).
Testing if type interface[a :- integer] is in type type c1: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is a class type, and the former includes semi-labeled value list values while the later does not).
Testing if type interface[a :- integer] is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is an interface type and the candidate super-type is the type of all integers, and the former includes semi-labeled value list values while the later does not).
Testing if type [] is in type type (integer[0...5]): yes.
Testing if type [] is in type type ({}[0...5]): yes.
Testing if type [{}] is in type type ({}[0...5]): yes.
Testing if type [{}, {}] is in type type ({}[0...5]): yes.
Testing if type [integer, b : {}] is in type type ({}[0...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has an empty base type while the former has a non-empty type for element 0, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [integer, b : integer] is in type type ({}[0...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has an empty base type while the former has a non-empty type for element 0, and the former is not the empty type).
Testing if type [filter_a, b : integer] is in type type ({}[0...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has an empty base type while the former has a non-empty type for element 1, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [filter_a, b : filter_a] is in type type ({}[0...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has an empty base type while SalmonEye is unable to determine whether the former's type for element 0 is non-empty).
Testing if type [...] is in type type (integer[0...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has an upper bound less than positive infinity while the former allows unlimited additional elements, and the former is not the empty type).
Testing if type [...] is in type type (!{}[0...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has an upper bound less than positive infinity while the former allows unlimited additional elements, and the former is not the empty type).
Testing if type [...] is in type type (!{}[0...+oo]): yes.
Testing if type [...] is in type type (integer[0...+oo]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has a base type that is not the type of all values while the former allows unlimited additional elements, and the former is not the empty type).
Testing if type [...] is in type type (filter_a[0...+oo]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and SalmonEye is unable to determine whether the later's base type is the type of all values, while the former allows unlimited additional elements).
Testing if type [integer, ...] is in type type (!{}[0...+oo]): yes.
Testing if type [filter_a, ...] is in type type (!{}[0...+oo]): yes.
Testing if type [filter_a, ...] is in type type (!{}[0...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has an upper bound less than positive infinity while the former allows unlimited additional elements, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [filter_a, ...] is in type type (filter_a[0...+oo]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and SalmonEye is unable to determine whether the later's base type is the type of all values, while the former allows unlimited additional elements).
Testing if type [filter_a, ...] is in type type (integer[0...+oo]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the later has a base type that is not the type of all values while the former allows unlimited additional elements, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : integer, ...] is in type type (!{}[0...+oo]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former specifies a name (`a') for element 0 and specifies a non-empty type for that element, and the former is not the empty type).
Testing if type [integer] is in type type (integer[0...5]): yes.
Testing if type [a : integer] is in type type (integer[0...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former specifies a name (`a') for element 0 and specifies a non-empty type for that element, and the former is not the empty type).
Testing if type [a : integer] is in type type (!{}[0...5]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former specifies a name (`a') for element 0 and specifies a non-empty type for that element, and the former is not the empty type).
Testing if type [a : integer, filter_a] is in type type (!{}[0...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former specifies a name (`a') for element 0 and specifies a non-empty type for that element, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : filter_a] is in type type (!{}[0...5]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former specifies a name (`a') for element 0 and SalmonEye is unable to determine whether the type that the former specifies for that element is the empty type).
Testing if type [integer, integer, integer] is in type type (integer[0...1]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former is not the empty type, and the former specifies a non-empty type for element 2, but 2 is outside the bounds of the later).
Testing if type [integer, integer, integer] is in type type (integer[0...2]): yes.
Testing if type [integer, integer, integer] is in type type (integer[0...3]): yes.
Testing if type [integer, integer, integer] is in type type (integer[-1...2]): yes.
Testing if type [integer, integer, integer] is in type type (integer[0...2]): yes.
Testing if type [integer, integer, integer] is in type type (integer[1...2]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former is not the empty type, and the former specifies a non-empty type for element 0, but 0 is outside the bounds of the later).
Testing if type [filter_a, integer, integer] is in type type (integer[1...2]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and SalmonEye is unable to determine whether the type specified by the former for element 0 is empty, but 0 is outside the bounds of the later).
Testing if type [filter_a, integer, integer] is in type type (integer[0...2]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and SalmonEye is unable to determine whether the type specified by the former for element 0 is a subset of the base type of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type [rational, integer, integer] is in type type (integer[0...2]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former is not the empty type, and the former specifies a type for element 0 which is not a subset of the base type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type [rational, filter_a, integer] is in type type (integer[0...2]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and SalmonEye is unable to determine whether the former is the empty type, and the former specifies a type for element 0 which is not a subset of the base type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type [rational, integer, integer] is in type type (integer[1...2]): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and the former is not the empty type, and the former specifies a non-empty type for element 0, but 0 is outside the bounds of the later).
Testing if type [rational, filter_a, integer] is in type type (integer[1...2]): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is an array type, and SalmonEye is unable to determine whether the former is the empty type, and the former specifies a non-empty type for element 0, but 0 is outside the bounds of the later).
Testing if type [] is in type type (integer --> string): yes.
Testing if type [...] is in type type (integer --> string): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former allows unlimited additional elements and the later's target type is not the type containing all values).
Testing if type [...] is in type type (integer --> !{}): yes.
Testing if type [] is in type type ([0...5] --> integer): yes.
Testing if type [] is in type type ([0...5] --> {}): yes.
Testing if type [{}] is in type type ([0...5] --> {}): yes.
Testing if type [{}, {}] is in type type ([0...5] --> {}): yes.
Testing if type [integer, b : {}] is in type type ([0...5] --> {}): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the later has an empty target type while the former has a non-empty type for element 0, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [integer, b : integer] is in type type ([0...5] --> {}): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the later has an empty target type while the former has a non-empty type for element 0, and the former is not the empty type).
Testing if type [filter_a, b : integer] is in type type ([0...5] --> {}): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the later has an empty target type while the former has a non-empty type for element 1, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [filter_a, b : filter_a] is in type type ([0...5] --> {}): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the later has an empty target type while SalmonEye is unable to determine whether the former's type for element 0 is non-empty).
Testing if type [...] is in type type ([0...5] --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former allows unlimited additional elements and the type of indexes for these extra elements is not a subset of the later's key type because the candidate sub-type is an integer type containing the value +oo, which is not in the candidate super-type because the value is +oo and the type is a subset of the integers that does not include that value).
Testing if type [...] is in type type ([0...5] --> !{}): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former allows unlimited additional elements and the type of indexes for these extra elements is not a subset of the later's key type because the candidate sub-type is an integer type containing the value +oo, which is not in the candidate super-type because the value is +oo and the type is a subset of the integers that does not include that value).
Testing if type [...] is in type type ([0...+oo] --> !{}): yes.
Testing if type [...] is in type type (filter_a --> !{}): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former allows unlimited additional elements and the type of indexes for these extra elements is not a subset of the later's key type because the candidate sub-type is an integer type containing the value 1, which is not in the candidate super-type because the type is a test function and calling the function on the value returned false).
Testing if type [...] is in type type ([0...+oo] --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former allows unlimited additional elements and the later's target type is not the type containing all values).
Testing if type [...] is in type type ([0...+oo] --> filter_a): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former allows unlimited additional elements and SalmonEye is unable to determine whether the later's target type is the type containing all values).
Testing if type [integer, ...] is in type type ([0...+oo] --> !{}): yes.
Testing if type [filter_a, ...] is in type type ([0...+oo] --> !{}): yes.
Testing if type [filter_a, ...] is in type type ([0...5] --> !{}): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and SalmonEye is unable to determine whether the former is the empty type, and the former allows unlimited additional elements and the type of indexes for these extra elements is not a subset of the later's key type because the candidate sub-type is an integer type containing the value +oo, which is not in the candidate super-type because the value is +oo and the type is a subset of the integers that does not include that value).
Testing if type [filter_a, ...] is in type type ([0...+oo] --> filter_a): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former allows unlimited additional elements and SalmonEye is unable to determine whether the later's target type is the type containing all values).
Testing if type [filter_a, ...] is in type type ([0...+oo] --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and SalmonEye is unable to determine whether the former is the empty type, and the former allows unlimited additional elements and the later's target type is not the type containing all values).
Testing if type [a : integer, ...] is in type type ([0...+oo] --> !{}): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former specifies a name (`a') for element 0 and specifies a non-empty type for that element, and the former is not the empty type).
Testing if type [integer] is in type type ([0...5] --> integer): yes.
Testing if type [a : integer] is in type type ([0...5] --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former specifies a name (`a') for element 0 and specifies a non-empty type for that element, and the former is not the empty type).
Testing if type [a : integer] is in type type ([0...5] --> !{}): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former specifies a name (`a') for element 0 and specifies a non-empty type for that element, and the former is not the empty type).
Testing if type [a : integer, filter_a] is in type type ([0...5] --> !{}): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former specifies a name (`a') for element 0 and specifies a non-empty type for that element, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : filter_a] is in type type ([0...5] --> !{}): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former specifies a name (`a') for element 0 and SalmonEye is unable to determine whether the type that the former specifies for that element is the empty type).
Testing if type [integer, integer, integer] is in type type ({0, 1} --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former specifies a non-empty type for element 2, but 2 is outside the key type of the later).
Testing if type [integer, integer, integer] is in type type ([0...2] --> integer): yes.
Testing if type [integer, integer, integer] is in type type ([0...3] --> integer): yes.
Testing if type [integer, integer, integer] is in type type ([-1...2] --> integer): yes.
Testing if type [integer, integer, integer] is in type type ([0...2] --> integer): yes.
Testing if type [integer, integer, integer] is in type type ({1, 2} --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former specifies a non-empty type for element 0, but 0 is outside the key type of the later).
Testing if type [filter_a, integer, integer] is in type type ({1, 2} --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and SalmonEye is unable to determine whether the type specified by the former for element 0 is empty, but 0 is outside the key type of the later).
Testing if type [filter_a, integer, integer] is in type type ([0...2] --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and SalmonEye is unable to determine whether the type specified by the former for element 0 is a subset of the target type of the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type [rational, integer, integer] is in type type ([0...2] --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former specifies a type for element 0 which is not a subset of the target type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type [rational, filter_a, integer] is in type type ([0...2] --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and SalmonEye is unable to determine whether the former is the empty type, and the former specifies a type for element 0 which is not a subset of the target type of the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type [rational, integer, integer] is in type type ({1, 2} --> integer): no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and the former is not the empty type, and the former specifies a non-empty type for element 0, but 0 is outside the key type of the later).
Testing if type [rational, filter_a, integer] is in type type ({1, 2} --> integer): unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a map type, and SalmonEye is unable to determine whether the former is the empty type, and the former specifies a non-empty type for element 0, but 0 is outside the key type of the later).
Testing if type [...] is in type type fields[a : integer, b : string]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the former allows unlimited additional elements while the later does not allow anything beyond the finite number of fields it explicitly specifies, and the former is not the empty type).
Testing if type [a : filter_a, ...] is in type type fields[a : filter_a, b : string]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the former allows unlimited additional elements while the later does not allow anything beyond the finite number of fields it explicitly specifies, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : integer, b : string, ...] is in type type fields[a : integer, b : string, ...]: yes.
Testing if type [a : integer, b : string, ...] is in type type interface[a : integer, b : string]: yes.
Testing if type [a : integer, b : string] is in type type fields[a : integer, b : string]: yes.
Testing if type [a : integer, b : string] is in type type fields[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the former specifies a field with name `b', which isn't specified by the later, and the later does not allow anything beyond the finite number of fields it explicitly specifies, and the former is not the empty type).
Testing if type [a : integer, string] is in type type fields[a : integer]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the former specifies no name for a field, and the later does not allow anything beyond the finite number of fields it explicitly specifies, and the former is not the empty type).
Testing if type [a : filter_a, b : string] is in type type fields[a : filter_a, b : string]: yes.
Testing if type [a : filter_a, b : string] is in type type fields[a : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the former specifies a field with name `b', which isn't specified by the later, and the later does not allow anything beyond the finite number of fields it explicitly specifies, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : filter_a, string] is in type type fields[a : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the former specifies no name for a field, and the later does not allow anything beyond the finite number of fields it explicitly specifies, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : filter_a, b : string] is in type type fields[a : integer, b : string]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and SalmonEye is unable to determine whether the type specified for a field named `a' by the former is a subset of the type specified for a field of that name by the later because the candidate sub-type is a filter function type and SalmonEye doesn't try to dig deeper in such situations).
Testing if type [a : rational, b : string] is in type type fields[a : integer, b : string]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the former is not the empty type, and the type specified for a field named `a' by the former is not a subset of the type specified for a field of that name by the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type [a : integer, b : string] is in type type fields[a : rational, b : string]: yes.
Testing if type [a : rational, b : filter_a] is in type type fields[a : integer, b : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and SalmonEye is unable to determine whether the former is the empty type, and the type specified for a field named `a' by the former is not a subset of the type specified for a field of that name by the later because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if type [a : integer] is in type type fields[a : integer, b : filter_a]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the later specifies a field named `b', and specifies that it is not optional, while the former does not specify a field by that name, and the former is not the empty type).
Testing if type [a : integer] is in type type interface[a : integer, b : filter_a]: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the later specifies a field named `b', and specifies that it is not optional, while the former does not specify a field by that name, and the former is not the empty type).
Testing if type [a : filter_a] is in type type fields[a : filter_a, b : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the later specifies a field named `b', and specifies that it is not optional, while the former does not specify a field by that name, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : filter_a] is in type type interface[a : filter_a, b : filter_a]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is a type that specifies field information, and the later specifies a field named `b', and specifies that it is not optional, while the former does not specify a field by that name, and SalmonEye is unable to determine whether the former is the empty type).
Testing if type [a : integer] is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is the type of all integers, and the former includes semi-labeled value list values while the later does not).
Testing if type [a : filter_a] is in type type integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a semi-labeled value list type and the candidate super-type is the type of all integers, and if the former is non-empty it includes semi-labeled value list values while the later does not, but SalmonEye is unable to determine whether the former is empty).
Testing if type @ab@ is in type type string: yes.
Testing if type @ab@ is in type type integer: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a regular expression type and the candidate super-type is the type of all integers, and if the former is non-empty it includes string values while the later does not, but SalmonEye is unable to determine whether the former is empty).
Testing if type c1 is in type type object: yes.
Testing if type c1 is in type type fields[a : integer, b : string]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a class type and the candidate super-type is a fields type, and SalmonEye doesn't try to dig deeper in such situations).
Testing if type c1 is in type type interface[a : integer, b : string]: unknown (the type is a type type and the value is a type for which it is unclear whether it is a subset of the base type of the type because the candidate sub-type is a class type and the candidate super-type is an interface type, and SalmonEye doesn't try to dig deeper in such situations).
Testing if type c1 is in type type integer: no (the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is a class type and the candidate super-type is the type of all integers, and the former includes object values while the later does not).
Testing if f1 is in type integer <-- (integer | string, integer | string): yes.
Testing if f1 is in type integer <-- (integer | string, integer | string): unknown (the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires type integer | string for parameter 0 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the right component of the union is not in the candidate super-type because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not; routine 1 on the overload list doesn't match because the routine type requires type string for parameter 0 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not; routine 2 on the overload list doesn't match because the routine type requires type integer | string for parameter 1 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the right component of the union is not in the candidate super-type because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not).
Testing if f1 is in type integer <-- (integer | string, integer | string): unknown (the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires type integer | string for parameter 0 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the right component of the union is not in the candidate super-type because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not; routine 1 on the overload list doesn't match because the routine type requires type string for parameter 0 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not; routine 2 on the overload list doesn't match because the routine type requires type integer | string for parameter 1 but the value allows a routine that has type string for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the left component of the union is not in the candidate super-type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not).
Testing if f1 is in type integer <-- (integer | string, integer | string): unknown (the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires type integer | string for parameter 1 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the right component of the union is not in the candidate super-type because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not; routine 1 on the overload list doesn't match because the routine type requires type integer | string for parameter 0 but the value allows a routine that has type string for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the left component of the union is not in the candidate super-type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not; routine 2 on the overload list doesn't match because the routine type requires type integer for parameter 0 but the value allows a routine that has type string for that parameter and the former is not a subset of the later because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not).
Testing if f1 is in type integer <-- (integer | string, integer | string): unknown (the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires type integer | string for parameter 1 but the value allows a routine that has type string for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the left component of the union is not in the candidate super-type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not; routine 1 on the overload list doesn't match because the routine type requires type integer | string for parameter 0 but the value allows a routine that has type string for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the left component of the union is not in the candidate super-type because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not; routine 2 on the overload list doesn't match because the routine type requires type integer for parameter 0 but the value allows a routine that has type string for that parameter and the former is not a subset of the later because the candidate sub-type is the type of all integers and the candidate super-type is the type of all strings, and the former includes integer values while the later does not).
Testing if f1 is in type integer <-- (integer | string, integer | string): unknown (the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires type integer | string for parameter 0 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the right component of the union is not in the candidate super-type because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not; routine 1 on the overload list doesn't match because the routine type requires type string for parameter 0 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not; routine 2 on the overload list doesn't match because the routine type requires type integer | string for parameter 1 but the value allows a routine that has type integer for that parameter and the former is not a subset of the later because the candidate sub-type is a union type and the right component of the union is not in the candidate super-type because the candidate sub-type is the type of all strings and the candidate super-type is the type of all integers, and the former includes string values while the later does not; routine 3 on the overload list matches parameters, but the return type of that routine does not match the required return type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
Testing if f1 is in type integer <-- (integer | string, integer | string): yes.
Testing if f1 is in type integer <-- ({"a", "b"}, integer | string): yes.
Testing if f1 is in type integer <-- ({"a", "b"}, integer | string): unknown (the routine value is overloaded; routine 0 on the overload list might match parameters, but the return type of that routine does not match the required return type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not).
