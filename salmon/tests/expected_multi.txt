Hello, World!
Hello, World!
Hello, again!
Hello, characters!
Hello, whitespace.
The value of x is `value'.
The value of 123 is 123.
The value of 12 + 17 is 29.
The initial value of v1 is 1.
After the first assignment, the value of v1 is 2.
After the second assignment, the value of v1 is 27.
v2 is greater than zero.
v2 is greater than 10.
v2 is not greater than 20.
i is 0.
i is 1.
i is 2.
i is 0.
i is 1.
i is 2.
v3 is 10.
v3 is 8.
v3 is 6.
v3 is 110.
v3 is 108.
v3 is 106.
v3 is 210.
v3 is 208.
v3 is 206.
v4 is 10.
v4 is 8.
v4 is 6.
v4 is 110.
v4 is 108.
v4 is 106.
v4 is 210.
After the loop, v4 is 208.
p() was called.
p2() was called with 10 as an argument.
p2() was called with 20 as an argument.
e is `snow'.
e is `rain'.
e is `hail'.
before test with v5 = 10.
after test with v5 = 10.
before test with v5 = 12.
after test with v5 = 12.
before test with v5 = 14.
before test with v6 = 10.
after test with v6 = 10.
before test with v6 = 12.
after test with v6 = 12.
before test with v6 = 14.
before test with v6 = 16.
before test with v6 = 18.
before test with v7 = 10.
after test with v7 = 10.
before test with v7 = 12.
after test with v7 = 12.
before test with v7 = 14.
before test with v8 = 10.
after test with v8 = 10.
before test with v8 = 12.
after test with v8 = 12.
before test with v8 = 14.
before test with v8 = 16.
before test with v8 = 18.
before test i is 0.
after test i is 0.
before test i is 1.
after test i is 1.
before test i is 2.
before test i is 0.
after test i is 0.
before test i is 1.
after test i is 1.
before test i is 2.
before test i is 3.
before test i is 4.
before test e is `snow'.
after test e is `snow'.
before test e is `rain'.
before test e is `snow'.
after test e is `snow'.
before test e is `rain'.
before test e is `hail'.
after test e is `hail'.
before test (i, j) is (0, 0).
after test (i, j) is (0, 0).
before test (i, j) is (0, 1).
after test (i, j) is (0, 1).
before test (i, j) is (0, 2).
after test (i, j) is (0, 2).
before test (i, j) is (1, 0).
after test (i, j) is (1, 0).
before test (i, j) is (1, 1).
before test (i, j) is (0, 0).
after test (i, j) is (0, 0).
before test (i, j) is (0, 1).
after test (i, j) is (0, 1).
before test (i, j) is (0, 2).
after test (i, j) is (0, 2).
before test (i, j) is (1, 0).
after test (i, j) is (1, 0).
before test (i, j) is (1, 1).
before test (i, j) is (2, 0).
after test (i, j) is (2, 0).
before test (i, j) is (2, 1).
after test (i, j) is (2, 1).
before test (i, j) is (2, 2).
after test (i, j) is (2, 2).
before test i is 0.
p3() before the call to pp().
p3() after the call to pp().
after test i is 0.
before test i is 1.
p3() before the call to pp().
p3() after the call to pp().
after test i is 1.
before test i is 2.
p3() before the call to pp().
before test i is 0.
p3() before the call to pp().
p3() after the call to pp().
after test i is 0.
before test i is 1.
p3() before the call to pp().
p3() after the call to pp().
after test i is 1.
before test i is 2.
p3() before the call to pp().
before test i is 3.
p3() before the call to pp().
before test i is 4.
p3() before the call to pp().
p4() was called.
before p().
f1() returns 15.
before f().
f2() returns 29.
before p().
before f().
The value is 29.
v9[0] is 1.
v9[1] is 2.
v9[2] is 17.
v9.x is 1.
v9.y is 17.
Constructing a c1 with x = 10.
The value of cc.y is 12.
The value of c1.y is 12.
The value of cc.y is now bluebird.
The value of c1.y is bluebird.
Cleaning up a c1 with y = bluebird.
We've now finished with cc.
File "multi_include.salm" line 1.
File "multi_include.salm" line 2.
The first Fibonocci number is 0.
The second Fibonocci number is 1.
The third Fibonocci number is 1.
The fourth Fibonocci number is 2.
The fifth Fibonocci number is 3.
The sixth Fibonocci number is 5.
The seventh Fibonocci number is 8.
The eighth Fibonocci number is 13.
The 400th Fibonocci number is 108788617463475645289761992289049744844995705477812699099751202749393926359816304226.
2 * 3 is 6.
20 * 30 is 600.
317 * 487 is 154379.
-317 * 487 is -154379.
1 in {3, 5, 7}: false.
2 in {3, 5, 7}: false.
3 in {3, 5, 7}: true.
4 in {3, 5, 7}: false.
5 in {3, 5, 7}: true.
6 in {3, 5, 7}: false.
7 in {3, 5, 7}: true.
8 in {3, 5, 7}: false.
Before exception.
Took an exception!
Exception tag is bad_operands.
Exception message: `Illegal left operand to add expression: string.'.
Exception source file name: `tests/multi.salm'.
Exception source start line number: `566'.
Exception source start column number: `10'.
Exception source end line number: `566'.
Exception source end column number: `23'.
The try-handle block is now done.
Positive infinity: +oo.
Negative infinity: -oo.
Unsigned infinity: 1/0.
Zero-zero: 0/0.
Handler 3: `Type error on initialization: value "string" is not in type integer because the value is not an integer and the type is that of all integers.'.
Cleanup 3a.
Handler 6: `Type error on assignment: value 12 is not in type string because the value is not a string and the type is that of all strings.'.
Handler 5: `Type error on assignment: value 12 is not in type string because the value is not a string and the type is that of all strings.'.
Handler 4: `Type error on assignment: value 12 is not in type string because the value is not a string and the type is that of all strings.'.
Handler 2: `Type error on assignment: value 12 is not in type string because the value is not a string and the type is that of all strings.'.
Handler 1: `An attempt was made to modify immutable `e' (declared at "tests/multi.salm":596:27).'.
Cleanup 6.
Cleanup 5.
Cleanup 4.
Cleanup 2.
Cleanup 1.
Handler: `My exception!'.
    my_field: `117'.
Caught: `Illegal left operand to multiply expression: string.'.
Caught first: `Illegal left operand to multiply expression: string.'.
Caught second: `The routine expression for a call did not evaluate to a routine.'.
16 in a? false.
17 in a? true.
18 in a? false.
16 in b? false.
17 in b? true.
18 in b? false.
"16" in b? false.
"17" in b? true.
"18" in b? false.
UTF-8 of [0x004d, 0x0430, 0x4e8c, 0x10302]: [0x4d, 0xd0, 0xb0, 0xe4, 0xba, 0x8c, 0xf0, 0x90, 0x8c, 0x82].
Converting back from UTF-8 to a string to UTF-32 gives: [0x4d, 0x430, 0x4e8c, 0x10302].
UTF-16 of [0x004d, 0x0430, 0x4e8c, 0x10302]: [0x4d, 0x430, 0x4e8c, 0xd800, 0xdf02].
Converting back from UTF-16 to a string to UTF-32 gives: [0x4d, 0x430, 0x4e8c, 0x10302].
UTF-8 by character of [0x004d, 0x0430, 0x4e8c, 0x10302]: [0x4d, 0xd0, 0xb0, 0xe4, 0xba, 0x8c, 0xf0, 0x90, 0x8c, 0x82].
Converting back from UTF-8 to characters to UTF-32 gives: [0x4d, 0x430, 0x4e8c, 0x10302].
UTF-16 by character of [0x004d, 0x0430, 0x4e8c, 0x10302]: [0x4d, 0x430, 0x4e8c, 0xd800, 0xdf02].
Converting back from UTF-16 to a characters to UTF-32 gives: [0x4d, 0x430, 0x4e8c, 0x10302].
1.000 = 1.
1.001 = 1001/1000.
0.3 = 3/10.
12e0 = 12.
12e1 = 120.
12e2 = 1200.
12e3 = 12000.
12e4 = 120000.
12e+0 = 12.
12e+1 = 120.
12e+2 = 1200.
12e+3 = 12000.
12e+4 = 120000.
12e-0 = 12.
12e-1 = 6/5.
12e-2 = 3/25.
12e-3 = 3/250.
12e-4 = 3/2500.
1.2e0 = 6/5.
0.5e10 = 5000000000.
Testing `':
    YES     in @@
    NO, not in @a*b@
    NO, not in @a+b@
    NO, not in @a@
    NO, not in @b@
    NO, not in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    NO, not in @^b@
    NO, not in @a$@
    NO, not in @b$@
    NO, not in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    NO, not in @b\@b@
Testing `aabb':
    YES     in @@
    YES     in @a*b@
    YES     in @a+b@
    YES     in @a@
    YES     in @b@
    YES     in @ab@
    NO, not in @ba@
    YES     in @a.b@
    YES     in @^a@
    NO, not in @^b@
    NO, not in @a$@
    YES     in @b$@
    YES     in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    NO, not in @b\@b@
Testing `ab':
    YES     in @@
    YES     in @a*b@
    YES     in @a+b@
    YES     in @a@
    YES     in @b@
    YES     in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    YES     in @^a@
    NO, not in @^b@
    NO, not in @a$@
    YES     in @b$@
    YES     in @ab|(ba)@
    YES     in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    NO, not in @b\@b@
Testing `ba':
    YES     in @@
    YES     in @a*b@
    NO, not in @a+b@
    YES     in @a@
    YES     in @b@
    NO, not in @ab@
    YES     in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    YES     in @^b@
    YES     in @a$@
    NO, not in @b$@
    YES     in @ab|(ba)@
    YES     in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    NO, not in @b\@b@
Testing `d':
    YES     in @@
    NO, not in @a*b@
    NO, not in @a+b@
    NO, not in @a@
    NO, not in @b@
    NO, not in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    NO, not in @^b@
    NO, not in @a$@
    NO, not in @b$@
    NO, not in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    NO, not in @b\@b@
Testing `bd':
    YES     in @@
    YES     in @a*b@
    NO, not in @a+b@
    NO, not in @a@
    YES     in @b@
    NO, not in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    YES     in @^b@
    NO, not in @a$@
    NO, not in @b$@
    NO, not in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    NO, not in @b\@b@
Testing `dd':
    YES     in @@
    NO, not in @a*b@
    NO, not in @a+b@
    NO, not in @a@
    NO, not in @b@
    NO, not in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    NO, not in @^b@
    NO, not in @a$@
    NO, not in @b$@
    NO, not in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    NO, not in @b\@b@
Testing `dad':
    YES     in @@
    NO, not in @a*b@
    NO, not in @a+b@
    YES     in @a@
    NO, not in @b@
    NO, not in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    NO, not in @^b@
    NO, not in @a$@
    NO, not in @b$@
    NO, not in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    YES     in @d[abc]+d@
    YES     in @d[a-c]+d@
    NO, not in @b\@b@
Testing `dbbd':
    YES     in @@
    YES     in @a*b@
    NO, not in @a+b@
    NO, not in @a@
    YES     in @b@
    NO, not in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    NO, not in @^b@
    NO, not in @a$@
    NO, not in @b$@
    NO, not in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    YES     in @d[abc]+d@
    YES     in @d[a-c]+d@
    NO, not in @b\@b@
Testing `ddd':
    YES     in @@
    NO, not in @a*b@
    NO, not in @a+b@
    NO, not in @a@
    NO, not in @b@
    NO, not in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    NO, not in @^b@
    NO, not in @a$@
    NO, not in @b$@
    NO, not in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    NO, not in @b\@b@
Testing `b@b':
    YES     in @@
    YES     in @a*b@
    NO, not in @a+b@
    NO, not in @a@
    YES     in @b@
    NO, not in @ab@
    NO, not in @ba@
    NO, not in @a.b@
    NO, not in @^a@
    YES     in @^b@
    NO, not in @a$@
    YES     in @b$@
    NO, not in @ab|(ba)@
    NO, not in @^(ab|(ba))$@
    NO, not in @d[abc]+d@
    NO, not in @d[a-c]+d@
    YES     in @b\@b@
split(@a.@, "bbaaaaabccbabbbabd") = ["bb", "", "", "ccb", "bb", "d"].
Testing 1:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is 1 and the type is a subset of the integers that does not include that value
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is 1 and the type is a subset of the integers that does not include that value
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    YES     in odd
    YES     in inline odd
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing `abc':
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    YES     in string
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    YES     in @a..@
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 2.7:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    YES     in rational & !integer
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing @(a|b)c@:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    YES     in regular_expression
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_quark:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    YES     in any_quark
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_lepton1[a := 15, b := "efg"]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    YES     in any_lepton
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    YES     in fields[a : integer, b : string]
    YES     in fields[a : integer, b : string, ...]
    YES     in lepton my_lepton1[a : integer, b : string, ...]
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    YES     in interface[a : integer, b :- string]
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_lepton2[a := 15, b := "efg"]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    YES     in any_lepton
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    YES     in fields[a : integer, b : string]
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type with key my_lepton1 and the value is a lepton with a different key (my_lepton2)
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    YES     in interface[a : integer, b :- string]
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_lepton1:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    YES     in lepton_key
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    YES     in lepton_key | integer
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_jump_target:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    YES     in jump_target
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_object1:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    YES     in object
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `y' and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in fields[a : integer, b : string, ...] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    YES     in my_class1
    NO, not in my_class4 because the type is a class type and the value is an object value for a different class
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_object2:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    YES     in object
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    YES     in fields[a : integer, b : string]
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type that requires field `a' to be writable, but the value is an object with an immutable field by that name
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is an object value for a different class
    NO, not in my_class4 because the type is a class type and the value is an object value for a different class
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_object3:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    YES     in object
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    YES     in fields[a : integer, b : string]
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    YES     in interface[a : integer, b :- string]
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is an object value for a different class
    NO, not in my_class4 because the type is a class type and the value is an object value for a different class
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_object4:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    YES     in object
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    YES     in fields[a : integer, b : string]
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    YES     in interface[a : integer, b :- string]
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is an object value for a different class
    YES     in my_class4
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_class4:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the routine type requires formal name `a' for parameter 1 but the value allows a routine with formal name `y' for that parameter
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    YES     in any_class
Testing my_tagalong:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    YES     in tagalong_key
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing my_lock:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    YES     in any_lock
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 'q':
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    YES     in character
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 82:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is 82 and the type is a subset of the integers that does not include that value
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    YES     in [18...83]
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 83:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    YES     in {17, 83, 57}
    NO, not in !{17, 83, 57} because the type is the negation of another type and the value is in that type
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    YES     in [18...83]
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    YES     in odd
    YES     in inline odd
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 84:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is 84 and the type is a subset of the integers that does not include that value
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is 84 and the type is a subset of the integers that does not include that value
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 17:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    YES     in {17, 83, 57}
    NO, not in !{17, 83, 57} because the type is the negation of another type and the value is in that type
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is 17 and the type is a subset of the integers that does not include that value
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    YES     in odd
    YES     in inline odd
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 18:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is 18 and the type is a subset of the integers that does not include that value
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    YES     in [18...83]
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 20:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is 20 and the type is a subset of the integers that does not include that value
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    YES     in [18...83]
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 40:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is 40 and the type is a subset of the integers that does not include that value
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    NO, not in {18, 20, 40, 80} ^ !{18, 20, 57} because the type is an exclusive-or type and the value is in both the left-hand and the right-hand types of the exclusive-or
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    YES     in [18...83]
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 80:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is 80 and the type is a subset of the integers that does not include that value
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    NO, not in {18, 20, 40, 80} ^ !{18, 20, 57} because the type is an exclusive-or type and the value is in both the left-hand and the right-hand types of the exclusive-or
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    YES     in [18...83]
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing 57:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    YES     in integer
    YES     in rational
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    YES     in {17, 83, 57}
    NO, not in !{17, 83, 57} because the type is the negation of another type and the value is in that type
    NO, not in rational & !integer because the type is an intersection type and the value is not in the right-hand type of the intersection because the type is the negation of another type and the value is in that type
    YES     in lepton_key | integer
    NO, not in {18, 20, 40, 80} ^ !{18, 20, 57} because the type is an exclusive-or type and the value is not in the left-hand type of the exclusive-or because the type is the negation of another type and the value is in that type; and the value is not in the right-hand type of the exclusive-or because the value is 57 and the type is a subset of the integers that does not include that value
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    YES     in [18...83]
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    YES     in odd
    YES     in inline odd
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<("a" --> 13), ("b" --> 17), ("c" --> 75)>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is a map with non-integer key "a" and the type is an array type
    NO, not in array[integer] because the value is a map with non-integer key "a" and the type is an array type
    NO, not in string[17] because the value is a map with non-integer key "a" and the type is an array type
    NO, not in string[13...18] because the value is a map with non-integer key "a" and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is a map with a key value of "a" and the type is a map type with a key type which does not include that key value because the value is not an integer and the type is that of all integers
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is a map value with a component with a non-integer key
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is a map value with a component with a non-integer key
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is a map value with a component with a non-integer key
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is a map value with a component with a non-integer key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is a map value with a component with a non-integer key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<(13 --> "a"), (17 --> "b"), (75 --> "c")>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    NO, not in array[integer] because the value is a map with element "a" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers
    NO, not in string[17] because the value is a map with key 17 and the type is an array type with upper bound 16
    NO, not in string[13...18] because the value is a map with key 75 and the type is an array type with upper bound 18
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a map value with a component with a key (13) that is beyond the end of those specified by the type
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which requires a name (`a') for one of its fields and the value is a map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    YES     in array[integer]
    YES     in string[17]
    YES     in string[13...18]
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which requires a name (`a') for one of its fields and the value is a map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which requires a name (`a') for one of its fields and the value is a map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<(-57 --> 18), (4 --> 3)>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    YES     in array[integer]
    NO, not in string[17] because the value is a map with key -57 and the type is an array type with lower bound 0
    NO, not in string[13...18] because the value is a map with key -57 and the type is an array type with lower bound 13
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is a map with a target value of 18 and the type is a map type with a target type which does not include that target value because the value is not a string and the type is that of all strings
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is a map value with a component with a negative key
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is a map value with a component with a negative key
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is a map value with a component with a negative key
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is a map value with a component with a negative key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is a map value with a component with a negative key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<(5 --> "abc"), (7 --> "seven")>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    NO, not in array[integer] because the value is a map with element "abc" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers
    YES     in string[17]
    NO, not in string[13...18] because the value is a map with key 5 and the type is an array type with lower bound 13
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a map value with a component with a key (5) that is beyond the end of those specified by the type
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which requires a name (`a') for one of its fields and the value is a map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<(5 --> "five"), (15 --> "fifteen")>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    NO, not in array[integer] because the value is a map with element "five" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers
    YES     in string[17]
    NO, not in string[13...18] because the value is a map with key 5 and the type is an array type with lower bound 13
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a map value with a component with a key (5) that is beyond the end of those specified by the type
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which requires a name (`a') for one of its fields and the value is a map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<(13 --> "thirteen"), (15 --> "fifteen")>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    NO, not in array[integer] because the value is a map with element "thirteen" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers
    YES     in string[17]
    YES     in string[13...18]
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a map value with a component with a key (13) that is beyond the end of those specified by the type
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which requires a name (`a') for one of its fields and the value is a map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<(13 --> "thirteen"), (17 --> "seventeen")>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    NO, not in array[integer] because the value is a map with element "thirteen" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers
    NO, not in string[17] because the value is a map with key 17 and the type is an array type with upper bound 16
    YES     in string[13...18]
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a map value with a component with a key (13) that is beyond the end of those specified by the type
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which requires a name (`a') for one of its fields and the value is a map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing <<(13 --> "thirteen"), (18 --> "eighteen")>>:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    NO, not in array[integer] because the value is a map with element "thirteen" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers
    NO, not in string[17] because the value is a map with key 18 and the type is an array type with upper bound 16
    YES     in string[13...18]
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a map value with a component with a key (13) that is beyond the end of those specified by the type
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which requires a name (`a') for one of its fields and the value is a map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which requires a value for component 0 and the value is a map value with no target for that key
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing null:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the value is null and the type is a pointer type that disallows null values
    YES     in *.integer
    NO, not in +integer because the value is null and the type is a pointer type that disallows null values
    YES     in +.integer
    NO, not in *+integer because the value is null and the type is a pointer type that disallows null values
    YES     in *+.integer
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing &x1 (variable x1 : integer):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    YES     in *integer
    YES     in *.integer
    YES     in +integer
    YES     in +.integer
    YES     in *+integer
    YES     in *+.integer
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing &x2 (immutable x2 : integer):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    YES     in *integer
    YES     in *.integer
    NO, not in +integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in +.integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in *+integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in *+.integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing &x3 (variable x3 : [0...15]):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    YES     in *integer
    YES     in *.integer
    NO, not in +integer because the type is a writable pointer type and the value is a pointer for which not all values in the base type of the pointer type are in the legal writable values because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include +oo
    NO, not in +.integer because the type is a writable pointer type and the value is a pointer for which not all values in the base type of the pointer type are in the legal writable values because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include +oo
    NO, not in *+integer because the type is a writable pointer type and the value is a pointer for which not all values in the base type of the pointer type are in the legal writable values because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include +oo
    NO, not in *+.integer because the type is a writable pointer type and the value is a pointer for which not all values in the base type of the pointer type are in the legal writable values because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include +oo
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing &x4 (immutable x4 : [0...15]):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    YES     in *integer
    YES     in *.integer
    NO, not in +integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in +.integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in *+integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in *+.integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing &x5 (variable x5 : rational):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a readable pointer type and the value is a pointer for which not all possible readable values are in the base type of the pointer because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not
    NO, not in *.integer because the type is a readable pointer type and the value is a pointer for which not all possible readable values are in the base type of the pointer because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not
    YES     in +integer
    YES     in +.integer
    NO, not in *+integer because the type is a readable pointer type and the value is a pointer for which not all possible readable values are in the base type of the pointer because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not
    NO, not in *+.integer because the type is a readable pointer type and the value is a pointer for which not all possible readable values are in the base type of the pointer because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing &x6 (immutable x6 : rational):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    YES     in *integer
    YES     in *.integer
    NO, not in +integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in +.integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in *+integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in *+.integer because the type is a writable pointer type and the value is a location based on an immutable
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing type [0...15]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    YES     in type integer
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing integer:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    YES     in type integer
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing rational:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the type is a type type and the value is a type which is not a subset of the base type of the type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing f1(: integer, a : integer, : integer := 15) returns integer:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    YES     in integer <-- (integer, a : integer, integer := *)
    NO, not in fields[] because the type is a fields type and the value is one that has no fields
    NO, not in fields[...] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string] because the type is a fields type and the value is one that has no fields
    NO, not in fields[a : integer, b : string, ...] because the type is a fields type and the value is one that has no fields
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type is an interface type and the value is one that has no fields
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is a non-class routine and the type is that of all classes
Testing f2(: rational, a : integer, : integer := 15) returns integer:
    YES     in integer <-- (integer, a : integer, integer := *)
Testing f3(: [0...15], a : integer, : integer := 15) returns integer:
    NO, not in integer <-- (integer, a : integer, integer := *) because the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires type integer for parameter 0 but the value allows a routine that has type [0...15] for that parameter and the former is not a subset of the later because the candidate sub-type is the type of all integers and the candidate super-type is an integer type that does not include +oo
Testing f4(b : integer, a : integer, : integer := 15) returns integer:
    YES     in integer <-- (integer, a : integer, integer := *)
Testing f5(: integer, : integer, : integer := 15) returns integer:
    NO, not in integer <-- (integer, a : integer, integer := *) because the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires formal name `a' for parameter 1 but the value allows a routine with no name for that parameter
Testing f6(a : integer, : integer, : integer := 15) returns integer:
    NO, not in integer <-- (integer, a : integer, integer := *) because the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires formal name `a' for parameter 1 but the value allows a routine with no name for that parameter
Testing f7(: integer, a : integer, : integer) returns integer:
    NO, not in integer <-- (integer, a : integer, integer := *) because the routine value is overloaded; routine 0 on the overload list doesn't match because the routine type requires a default value for parameter 2 but the value allows a routine without a default value for that parameter
Testing f8(: integer, a : integer, : integer := 15, b : integer := 17) returns integer:
    YES     in integer <-- (integer, a : integer, integer := *)
Testing f9(: integer, a : integer, : integer := 15) returns rational:
    NO, not in integer <-- (integer, a : integer, integer := *) because the routine value is overloaded; routine 0 on the overload list matches parameters, but the return type of that routine does not match the required return type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not
Testing f10(: integer, a : integer, : integer := 15) returns [0...11]:
    YES     in integer <-- (integer, a : integer, integer := *)
Testing f11() (overloaded, doesn't always return integer):
    NO, not in integer <-- (integer, a : integer, integer := *) because the routine value is overloaded; routine 0 on the overload list matches parameters, but the return type of that routine does not match the required return type because the candidate sub-type is the type of all rationals and the candidate super-type is the type of all integers, and the former includes fractional values while the later does not
Testing f12() (overloaded, always return integer):
    YES     in integer <-- (integer, a : integer, integer := *)
Testing []:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    YES     in array[integer]
    YES     in string[17]
    YES     in string[13...18]
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    YES     in fields[]
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in fields[a : integer, b : string, ...] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type requires that a field named `a' exist, but the value has no such field
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 0 values
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 0 values
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 0 values
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 0 values
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing ["aaa"]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    NO, not in array[integer] because the value is a semi-labeled value list with element "aaa" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers
    YES     in string[17]
    NO, not in string[13...18] because the value is a non-empty semi-labeled value list and the type is an array type with a greater-than-zero lower bound (13)
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has an unnamed field and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in fields[a : integer, b : string, ...] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type requires that a field named `a' exist, but the value has no such field
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing ["aaa", "bbb", "ccc"]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    YES     in array
    NO, not in array[integer] because the value is a semi-labeled value list with element "aaa" and the type is an array with an element type that the element value is not in because the value is not an integer and the type is that of all integers
    YES     in string[17]
    NO, not in string[13...18] because the value is a non-empty semi-labeled value list and the type is an array type with a greater-than-zero lower bound (13)
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    YES     in integer --> string
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has an unnamed field and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in fields[a : integer, b : string, ...] because the type requires that a field named `a' exist, but the value has no such field
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type requires that a field named `a' exist, but the value has no such field
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a semi-labeled value list value with 3 values
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which specifies name `a' for component 0, and the value is a semi-labeled value list value with no name for that component
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is a semi-labeled value list value for which the value for component 0 isn't in the type specified for this component by the semi-labeled value list type because the value is not an integer and the type is that of all integers
    YES     in [string, string, ...]
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing [a := 13]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in array[integer] because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in string[17] because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in string[13...18] because the value is a non-empty semi-labeled value list and the type is an array type with a greater-than-zero lower bound (13)
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is a semi-labeled value list with a label (a) on element number 0 and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the type requires that a field named `b' exist, but the value has no such field
    NO, not in fields[a : integer, b : string, ...] because the type requires that a field named `b' exist, but the value has no such field
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type requires that a field named `b' exist, but the value has no such field
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type which specifies 2 values and the value is a semi-labeled value list value with only 1 value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing [a := 13, b := "abc"]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in array[integer] because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in string[17] because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in string[13...18] because the value is a non-empty semi-labeled value list and the type is an array type with a greater-than-zero lower bound (13)
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is a semi-labeled value list with a label (a) on element number 0 and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    YES     in fields[a : integer, b : string]
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    YES     in interface[a : integer, b :- string]
    YES     in [...]
    YES     in [a : integer, b : string]
    YES     in [a : integer, b : string, ...]
    YES     in [integer, b : string, ...]
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is a semi-labeled value list value for which the value for component 0 isn't in the type specified for this component by the semi-labeled value list type because the value is not a string and the type is that of all strings
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing [a := 13, b := "abc", c := "def"]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in array[integer] because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in string[17] because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in string[13...18] because the value is a non-empty semi-labeled value list and the type is an array type with a greater-than-zero lower bound (13)
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is a semi-labeled value list with a label (a) on element number 0 and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the value has a field named `c' and the type disallows such a field
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    YES     in interface[a : integer, b :- string]
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a semi-labeled value list value with 3 values
    YES     in [a : integer, b : string, ...]
    YES     in [integer, b : string, ...]
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is a semi-labeled value list value for which the value for component 0 isn't in the type specified for this component by the semi-labeled value list type because the value is not a string and the type is that of all strings
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing [b := "abc", c := "def", a := 13]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is a semi-labeled value list with a label (b) on element number 0 and the type is an array type
    NO, not in array[integer] because the value is a semi-labeled value list with a label (b) on element number 0 and the type is an array type
    NO, not in string[17] because the value is a semi-labeled value list with a label (b) on element number 0 and the type is an array type
    NO, not in string[13...18] because the value is a non-empty semi-labeled value list and the type is an array type with a greater-than-zero lower bound (13)
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is a semi-labeled value list with a label (b) on element number 0 and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `b' and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the value has a field named `c' and the type disallows such a field
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    YES     in interface[a : integer, b :- string]
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a semi-labeled value list value with 3 values
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type which specifies name `a' for component 0, and the value is a semi-labeled value list value with a different name (`b') for that component
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is a semi-labeled value list with a field named `b' in a position different from the one specified for it by the type
    YES     in [string, string, ...]
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing [a := 13, b := 19, c := "def"]:
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in array[integer] because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in string[17] because the value is a semi-labeled value list with a label (a) on element number 0 and the type is an array type
    NO, not in string[13...18] because the value is a non-empty semi-labeled value list and the type is an array type with a greater-than-zero lower bound (13)
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is a semi-labeled value list with a label (a) on element number 0 and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the type requires that the field named `b' have type string, but the value has a field of that name with value 19 and that field value is not in the required type because the value is not a string and the type is that of all strings
    NO, not in fields[a : integer, b : string, ...] because the type requires that the field named `b' have type string, but the value has a field of that name with value 19 and that field value is not in the required type because the value is not a string and the type is that of all strings
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type is a multi-set type and the value is not a multi-set
    NO, not in multiset[a : integer, b : string, ...] because the type is a multi-set type and the value is not a multi-set
    NO, not in interface[a : integer, b :- string] because the type requires that the field named `b' have type string, but the value has a field of that name with value 19 and that field value is not in the required type because the value is not a string and the type is that of all strings
    YES     in [...]
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type which doesn't allow values beyond the 2 explicitly specified and the value is a semi-labeled value list value with 3 values
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is a semi-labeled value list value for which the value for component 1 isn't in the type specified for this component by the semi-labeled value list type because the value is not a string and the type is that of all strings
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is a semi-labeled value list value for which the value for component 1 isn't in the type specified for this component by the semi-labeled value list type because the value is not a string and the type is that of all strings
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is a semi-labeled value list value for which the value for component 0 isn't in the type specified for this component by the semi-labeled value list type because the value is not a string and the type is that of all strings
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing x7 (a := 13):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the type requires that a field named `b' exist, but the value has no such field
    NO, not in fields[a : integer, b : string, ...] because the type requires that a field named `b' exist, but the value has no such field
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    YES     in multiset[a : integer, b : string]
    YES     in multiset[a : integer, b : string, ...]
    NO, not in interface[a : integer, b :- string] because the type requires that a field named `b' exist, but the value has no such field
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing x7 (a := 13, b := 19):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the type requires that the field named `b' have type string, but the value has a field of that name with value 19 and that field value is not in the required type because the value is not a string and the type is that of all strings
    NO, not in fields[a : integer, b : string, ...] because the type requires that the field named `b' have type string, but the value has a field of that name with value 19 and that field value is not in the required type because the value is not a string and the type is that of all strings
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the type requires that the field named `b' have type string, but the value has a field of that name with value 19 and that field value is not in the required type because the value is not a string and the type is that of all strings
    NO, not in multiset[a : integer, b : string, ...] because the type requires that the field named `b' have type string, but the value has a field of that name with value 19 and that field value is not in the required type because the value is not a string and the type is that of all strings
    NO, not in interface[a : integer, b :- string] because the type requires that the field named `b' have type string, but the value has a field of that name with value 19 and that field value is not in the required type because the value is not a string and the type is that of all strings
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing x7 (a := 13, b := "nineteen"):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    YES     in fields[a : integer, b : string]
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    YES     in multiset[a : integer, b : string]
    YES     in multiset[a : integer, b : string, ...]
    YES     in interface[a : integer, b :- string]
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
Testing x7 (a := 13, b := "nineteen", c := 58):
    NO, not in nothing because no value is in the empty type
    YES     in anything
    NO, not in integer because the value is not an integer and the type is that of all integers
    NO, not in rational because the value is not a rational and the type is that of all rationals
    NO, not in regular_expression because the value is not a regular expression and the type is that of all regular expressions
    NO, not in any_quark because the value is not a quark and the type is that of all quarks
    NO, not in any_lepton because the value is not a lepton and the type is that of all leptons
    NO, not in lepton_key because the value is not a lepton key and the type is that of all lepton keys
    NO, not in jump_target because the value is not a jump target and the type is that of all jump targets
    NO, not in object because the value is not an object and the type is that of all objects
    NO, not in tagalong_key because the value is not a tagalong key and the type is that of all tagalong keys
    NO, not in any_lock because the value is not a lock and the type is that of all locks
    NO, not in string because the value is not a string and the type is that of all strings
    NO, not in character because the value is not a character and the type is that of all characters
    NO, not in {17, 83, 57} because the value is not an integer and the type is a subset of the integers
    YES     in !{17, 83, 57}
    NO, not in rational & !integer because the type is an intersection type and the value is not in the left-hand type of the intersection because the value is not a rational and the type is that of all rationals
    NO, not in lepton_key | integer because the type is a union type and the value is not in the left-hand type of the union because the value is not an integer and the type is that of all integers; and the value is not in the right-hand type of the union because the value is not a lepton key and the type is that of all lepton keys
    YES     in {18, 20, 40, 80} ^ !{18, 20, 57}
    NO, not in array because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in array[integer] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[17] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in string[13...18] because the value is not a map or semi-labeled value list and the type is an array type
    NO, not in [18...83] because the value is not an integer and the type is a subset of the integers
    NO, not in *integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in +.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in *+.integer because the type is a pointer type and the value is neither a pointer nor null
    NO, not in type integer because the value is not a type and the type is a type type
    NO, not in integer --> string because the value is not a map or semi-labeled value list and the type is a map type
    NO, not in integer <-- (integer, a : integer, integer := *) because the value is not a routine or routine chain and the type is a routine type
    NO, not in fields[] because the value has a field named `a' and the type disallows such a field
    YES     in fields[...]
    NO, not in fields[a : integer, b : string] because the value has a field named `c' and the type disallows such a field
    YES     in fields[a : integer, b : string, ...]
    NO, not in lepton my_lepton1[a : integer, b : string, ...] because the type is a lepton type and the value is not a lepton
    NO, not in multiset[a : integer, b : string] because the value has a field named `c' and the type disallows such a field
    YES     in multiset[a : integer, b : string, ...]
    YES     in interface[a : integer, b :- string]
    NO, not in [...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [a : integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [integer, b : string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in [string, string, ...] because the type is a semi-labeled value list type and the value is not a semi-labeled value list or map value
    NO, not in @a..@ because the type is a regular expression type and the value is not a string value
    NO, not in odd because the type is a test function and calling the function on the value returned false
    NO, not in inline odd because the type is a test function and calling the function on the value returned false
    NO, not in my_class1 because the type is a class type and the value is not an object value
    NO, not in my_class4 because the type is a class type and the value is not an object value
    NO, not in any_class because the value is not a routine of any sort and the type is that of all classes
YES, linked_lepton[next := null] in linked_interface.
YES, a in linked_interface.
YES, b in linked_interface.
YES, c in linked_interface.
YES, linked_lepton[next := null] in linked_interface.
YES, a in linked_interface.
YES, b in linked_interface.
YES, c in linked_interface.
YES, linked_lepton[next := null] in linked_lepton.
YES, a in linked_lepton.
YES, b in linked_lepton.
YES, c in linked_lepton.
a("hello"): x: `hello'.
locks: Lock `single-statement' (declared at "tests/multi.salm":1448:7) grabbed [1].
Single 1.
locks: Lock `single-statement' (declared at "tests/multi.salm":1448:7) released [0].
locks: Lock `my_lock' (declared at "tests/multi.salm":1445:10) grabbed [1].
Single 2.
locks: Lock `my_lock' (declared at "tests/multi.salm":1445:10) released [0].
locks: Lock `my_lock' (declared at "tests/multi.salm":1445:10) grabbed [1].
Single 3.
locks: Lock `my_lock' (declared at "tests/multi.salm":1445:10) released [0].
locks: Lock `context_switching' (declared at "standard_built_ins.c":3126:6) grabbed [1].
Single 4.
locks: Lock `context_switching' (declared at "standard_built_ins.c":3126:6) released [0].
locks: Anonymous lock (declared at "tests/multi.salm":1462:5) grabbed [1].
locks: Anonymous lock (declared at "tests/multi.salm":1462:5) released [0].
locks: Anonymous lock (declared at "tests/multi.salm":1462:5) grabbed [1].
locks: Anonymous lock (declared at "tests/multi.salm":1462:5) released [0].
locks: Anonymous lock (declared at "tests/multi.salm":1462:5) grabbed [1].
locks: Anonymous lock (declared at "tests/multi.salm":1462:5) released [0].
locks: Lock `my_lock' (declared at "tests/multi.salm":1461:10) grabbed [1].
locks: Lock `my_lock' (declared at "tests/multi.salm":1461:10) released [0].
locks: Lock `my_lock' (declared at "tests/multi.salm":1461:10) grabbed [1].
locks: Lock `my_lock' (declared at "tests/multi.salm":1461:10) released [0].
v2: 63.
Before p1().
locks: Anonymous lock (declared at "tests/multi.salm":1475:5) grabbed [1].
p1().
locks: Anonymous lock (declared at "tests/multi.salm":1475:5) released [0].
After p1().
Before p2().
locks: Lock `my_lock' (declared at "tests/multi.salm":1474:10) grabbed [1].
p2().
locks: Lock `my_lock' (declared at "tests/multi.salm":1474:10) released [0].
After p2().
locks: Anonymous lock (declared at "tests/multi.salm":1492:5) grabbed [1].
locks: Anonymous lock (declared at "tests/multi.salm":1492:5) released [0].
locks: Anonymous lock (declared at "tests/multi.salm":1492:5) grabbed [1].
locks: Anonymous lock (declared at "tests/multi.salm":1492:5) released [0].
locks: Anonymous lock (declared at "tests/multi.salm":1492:5) grabbed [1].
locks: Anonymous lock (declared at "tests/multi.salm":1492:5) released [0].
locks: Lock `my_lock' (declared at "tests/multi.salm":1491:10) grabbed [1].
locks: Lock `my_lock' (declared at "tests/multi.salm":1491:10) released [0].
locks: Lock `my_lock' (declared at "tests/multi.salm":1491:10) grabbed [1].
locks: Lock `my_lock' (declared at "tests/multi.salm":1491:10) released [0].
v1..t2: 63.
Before p().
locks: Lock `my_lock1' (declared at "tests/multi.salm":1506:10) grabbed [1].
locks: Lock `my_lock2' (declared at "tests/multi.salm":1507:27) grabbed [1].
p().
locks: Lock `my_lock2' (declared at "tests/multi.salm":1507:27) released [0].
locks: Lock `my_lock1' (declared at "tests/multi.salm":1506:10) released [0].
After p().
v1.x: 15.
v2.x: 17.
v1.x: 23.
v2.x: 63.
p1() a.
p1() a.
p1() b.
p1() b.
p1() c.
p1() c.
p1() d.
p1() d.
p1() e.
p1() e.
p1() f.
p1() f.
outer f1().
x is 1.
x is 2.
x is 3.
inner f1().
x is 1.
x is 2.
x is 3.
x: 3.
x: 17.
c1: (52, 73).
c1.operator+(1, reversed := false): (53, 73).
c1 + 1: (53, 73).
c2: (11, 22).
c1 + c2: (63, 95).
c1 - 1: (51, 73).
c1 - c2: (41, 51).
c1 - i: (52, 72).
i * i: (-1, 0).
i / 2: (0, 1/2).
c1: (2, 3).
c2: (5, 7).
c1 * c2: (-11, 29).
c3: (-11, 29).
c3 / c1: (5, 7).
c3 / c2: (2, 3).
(c3 / c2) == c1: true.
(c3 / c2) != c1: false.
i == 1: false.
i != 1: true.
+c3: (-11, 29).
-c3: (11, -29).
2 + 3i: (2, 3).
2 - 3i: (2, -3).
1 / i: (0, -1).
1 == (i / i): true.
1 != (i / i): false.
Funny 1 + 1: 5.
v1: 1.
v1: 5.
v1: 16.
Funny +1: 4.
Funny +72: 75.
1 :: integer: 1.
1.2 :: integer: 1.
1.5 :: integer: 1.
1.6 :: integer: 2.
1.9 :: integer: 2.
-1.2 :: integer: -1.
-1.5 :: integer: -1.
-1.6 :: integer: -2.
-1.9 :: integer: -2.
c1(5) :: string: ~5~.
c1(5) :: integer: 15.
1(17): |1|([17]).
2("abc", x := 18): |2|(["abc", x := 18]).
called |trout|(["rainbow"]).
c1(14, n := 15): |1|([14, n := 15]).
c2(14, n := 15): |2|([14, n := 15]).
called |1|([14, n := 15]).
called |2|([14, n := 15]).
a: Read through operator*() called.
*b: 5.
a: Write of 10 through operator*() called.
a: Read through operator*() called.
a: Write of 15 through operator*() called.
(&(*b)) in +integer: true.
(&(*b)) in +rational: false.
(&(*b)) in +[0...4]: true.
(&(*b)) in *integer: true.
(&(*b)) in *rational: true.
(&(*b)) in *[0...4]: false.
Read of 15 through operator*() called.
*15: 70.
Write of 10 to 19 through operator*() called.
Read of 23 through operator*() called.
Write of 88 to 23 through operator*() called.
(&(*173)) in +integer: true.
(&(*173)) in +rational: false.
(&(*173)) in +[0...4]: true.
(&(*173)) in *integer: true.
(&(*173)) in *rational: true.
(&(*173)) in *[0...4]: false.
a: Read of field `c' through operator->() called.
b->c: 5.
a: Write of 10 to field `d' through operator->() called.
a: Read of field `e' through operator->() called.
a: Write of 15 to field `e' through operator->() called.
(&(b->f)) in +integer: true.
(&(b->f)) in +rational: false.
(&(b->f)) in +[0...4]: true.
(&(b->f)) in *integer: true.
(&(b->f)) in *rational: true.
(&(b->f)) in *[0...4]: false.
Read of field `aaa' of 15 through operator->() called.
15->aaa: 70.
Write of 10 to field `bbb' of 19 through operator->() called.
Read of field `ccc' of 23 through operator->() called.
Write of 88 to field `ccc' of 23 through operator->() called.
(&(34->ddd)) in +integer: true.
(&(34->ddd)) in +rational: false.
(&(34->ddd)) in +[0...4]: true.
(&(34->ddd)) in *integer: true.
(&(34->ddd)) in *rational: true.
(&(34->ddd)) in *[0...4]: false.
a: Read of element 12 through operator[]() called.
b[12]: 22.
a: Read of element 15 through operator[]() called.
b[15]: 25.
a: Write of 5 to element 3 through operator[]() called.
a: Read of element 12 through operator[]() called.
b[12]: 30.
a: Read of element 15 through operator[]() called.
b[15]: 33.
a: Read of elements 12 to 15 through operator[]() called.
b[12...15]: [30, 31, 32, 33].
a: Read of all elements through operator[]() called.
b[*]: [18, 324].
a: Write of 10 to element 12 through operator[]() called.
a: Write of 20 to element 13 through operator[]() called.
a: Write of 30 to element 14 through operator[]() called.
a: Write of 40 to element 15 through operator[]() called.
a: Write of 5 to element 0 through operator[]() called.
a: Write of [10, 20, 30, 40] to elements 12 to 15 through operator[]() called.
a: Write of [5] to all elements through operator[]() called.
Read of element 12 of 10 through operator[]() called.
10[12]: 22.
Read of element 15 of 10 through operator[]() called.
10[15]: 25.
b: 10.
Write of 5 to element 3 of 10 through operator[]() called.
b: 18.
Read of element 12 of 10 through operator[]() called.
10[12]: 22.
Read of element 15 of 10 through operator[]() called.
10[15]: 25.
Read of elements 12 to 15 of 10 through operator[]() called.
10[12...15]: [22, 23, 24, 25].
Read of all elements of 10 through operator[]() called.
10[*]: [10, 100].
b: 18.
Write of 10 to element 12 of 18 through operator[]() called.
Write of 20 to element 13 of 40 through operator[]() called.
Write of 30 to element 14 of 73 through operator[]() called.
Write of 40 to element 15 of 117 through operator[]() called.
b: 172.
Write of 5 to element 0 of 172 through operator[]() called.
b: 177.
b: 10.
Write of [10, 20, 30, 40] to elements 12 to 15 of 10 through operator[]() called.
b: 37.
Write of [5] to all elements of 37 through operator[]() called.
b: 1369.
v1: ["Broadcom", 18].
12 > 5: true.
-12 > 5: false.
-0.2 > 0.5: false.
-0.8 > 0.5: false.
-1.8 - -1: -4/5.
m: [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
m[0]: [1, 2, 3].
m[1]: [4, 5, 6].
m[2]: [7, 8, 9].
m[0][0]: 1.
m[0, 0]: 1.
m[1][2]: 6.
m[1, 2]: 6.
m: <<(0 --> [1, 2, 3]), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 66)>>), (2 --> [7, 8, 9])>>.
m: <<(0 --> [1, 2, 3]), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 77)>>), (2 --> [7, 8, 9])>>.
m[*]: <<(0 --> [1, 2, 3]), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 77)>>), (2 --> [7, 8, 9])>>.
m[0, *]: [1, 2, 3].
m[2, *]: [7, 8, 9].
m[*, 0]: <<(0 --> 1), (1 --> 4), (2 --> 7)>>.
m[*, 2]: <<(0 --> 3), (1 --> 77), (2 --> 9)>>.
m[0, 0...1]: [1, 2].
m[2, 1...2]: [8, 9].
m[0...1, 0]: <<(0 --> 1), (1 --> 4)>>.
m[1...2, 2]: <<(0 --> 77), (1 --> 9)>>.
m[0, 1...7]: [2, 3].
m[0, 5...7]: [].
[100, 110, 120][1...2]: [110, 120].
[100, 110, 120][1...7]: [110, 120].
[100, 110, 120][5...7]: [].
[][5...7]: [].
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 102)>>), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 77)>>), (2 --> [7, 8, 9])>>.
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 200)>>), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 201)>>), (2 --> <<(0 --> 7), (1 --> 8), (2 --> 202)>>)>>.
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 200)>>), (1 --> <<(0 --> 4), (1 --> 300), (2 --> 201)>>), (2 --> <<(0 --> 7), (1 --> 301), (2 --> 202)>>)>>.
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 200)>>), (1 --> <<(0 --> 4), (1 --> 400), (2 --> 401)>>), (2 --> <<(0 --> 7), (1 --> 301), (2 --> 202)>>)>>.
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 200)>>), (1 --> <<(0 --> [a := "a1"]), (1 --> [a := "a2"]), (2 --> [a := "a3"])>>), (2 --> <<(0 --> 7), (1 --> 301), (2 --> 202)>>)>>.
m: 10.
m: <<(0 --> 10)>>.
m: <<(0 --> 10), (3 --> 33)>>.
m: [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
m[0]: [1, 2, 3].
m[1]: [4, 5, 6].
m[2]: [7, 8, 9].
m[0][0]: 1.
m[0, 0]: 1.
m[1][2]: 6.
m[1, 2]: 6.
m: <<(0 --> [1, 2, 3]), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 66)>>), (2 --> [7, 8, 9])>>.
m: <<(0 --> [1, 2, 3]), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 77)>>), (2 --> [7, 8, 9])>>.
m[*]: <<(0 --> [1, 2, 3]), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 77)>>), (2 --> [7, 8, 9])>>.
m[0, *]: [1, 2, 3].
m[2, *]: [7, 8, 9].
m[*, 0]: <<(0 --> 1), (1 --> 4), (2 --> 7)>>.
m[*, 2]: <<(0 --> 3), (1 --> 77), (2 --> 9)>>.
m[0, 0...1]: [1, 2].
m[2, 1...2]: [8, 9].
m[0...1, 0]: <<(0 --> 1), (1 --> 4)>>.
m[1...2, 2]: <<(0 --> 77), (1 --> 9)>>.
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 102)>>), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 77)>>), (2 --> [7, 8, 9])>>.
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 200)>>), (1 --> <<(0 --> 4), (1 --> 5), (2 --> 201)>>), (2 --> <<(0 --> 7), (1 --> 8), (2 --> 202)>>)>>.
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 200)>>), (1 --> <<(0 --> 4), (1 --> 300), (2 --> 201)>>), (2 --> <<(0 --> 7), (1 --> 301), (2 --> 202)>>)>>.
m: <<(0 --> <<(0 --> 100), (1 --> 101), (2 --> 200)>>), (1 --> <<(0 --> 4), (1 --> 400), (2 --> 401)>>), (2 --> <<(0 --> 7), (1 --> 301), (2 --> 202)>>)>>.
(&(m[1, 2])) in +integer: true.
(&(m[1, 2])) in +rational: false.
(&(m[1][2])) in +integer: true.
(&(m[1][2])) in +rational: false.
(&(m[0, *])) in +integer: false.
(&(m[0, *])) in +(integer[0...2]): true.
(&(m[0, *])) in +(integer[0...3]): false.
(&(m[0, *])) in +(rational[0...2]): false.
(&(m[*, 2])) in +integer: false.
(&(m[*, 2])) in +(integer[0...2]): true.
(&(m[*, 2])) in +(integer[0...3]): false.
(&(m[*, 2])) in +(rational[0...2]): false.
(&(m[1...2, 1])) in +integer: false.
(&(m[1...2, 1])) in +(integer[0...2]): false.
(&(m[1...2, 1])) in +(integer[0...1]): true.
(&(m[1...2, 1])) in +(integer[1...2]): false.
(&(m[1...2, 1])) in +(rational[0...1]): false.
(&(m[1, 1...2])) in +integer: false.
(&(m[1, 1...2])) in +(integer[0...2]): false.
(&(m[1, 1...2])) in +(integer[0...1]): true.
(&(m[1, 1...2])) in +(integer[1...2]): false.
(&(m[1, 1...2])) in +(rational[0...1]): false.
a1: <<>>
a2: <<(* --> "something")>>
a2[1]: something
a3: <<(*: integer --> "integer")>>
a3[1]: integer
a4: <<(* --> "something"), (*: integer --> "integer")>>
a4[1]: integer
a4[1.1]: something
a5: <<(* --> "something"), (*: integer --> "integer"), (2 --> "two"), (3 --> "three")>>
a5[1]: integer
a5[2]: two
a5[3]: three
a5[1.1]: something
a6: <<(* --> "something"), (*: integer --> "integer"), (3 --> "three")>>
a6[1]: integer
a6[2]: integer
a6[3]: three
a6[1.1]: something
v1: <<>>
v1: <<(* --> "something")>>
&(v1[* : integer]): &v1[* : integer]
v1: <<(* --> "something"), (*: integer --> "integer")>>
Called f1(10, 20).
call(f1, [10, 20]): 30.
Called f1(20, 10).
call(f1, [y := 10, x := 20]): 30.
Called p1(5, 10, 15).
Called p1(5, 15, 10).
r1() called as a function with argument 8.
r1(8): 15.
r1() called as a function with argument 12.
r1(12): 19.
r1() called as a procedure with argument 8.
r1() called as a procedure with argument 12.
r1() called as a procedure with argument 32.
This sentence is in English.
Running p(5).
Case a1 hit.
Case b1 hit.
Case c1 hit.
Case d1 hit.
Case e1 hit.
Case f1 hit.
Running p(6).
Case b2 hit.
Case c2 hit.
Case d2 hit.
Case e2 hit.
Case f2 hit.
Running p(7).
Case b2 hit.
Case d3 hit.
Case e3 hit.
Case f3 hit.
Running p(8).
Case b2 hit.
Case d3 hit.
Case f4 hit.
a's p1().
a's p2().
a's p3().
a's p4().
a's p1().
b's p2().
a's p3().
a's p4().
a's p1().
b's p2().
a's p3().
c's p4().
aaa: 15.
bbb: 17.
bbb: 23.
ccc: x is 15, y is 12.
a's ddd() called.
a's ddd() called.
Inner eee() called.
Outer fff() called.
Inner ggg() called.
a's ggg() called.
Inner hhh() called.
Outer hhh() called.
a's iii() called.
a's iii() called.
Outer iii() called.
Inner jjj() called.
a's jjj() called.
Outer jjj() called.
a's kkk() (integer) called.
a's kkk() (rational) called.
a's kkk() (integer) called.
Inner lll() called.
a's lll() (rational) called.
a's lll() (integer) called.
a's mmm() (integer) called.
a's mmm() (rational) called.
a's mmm() (integer) called.
Outer mmm() called.
Inner nnn() called.
a's nnn() (rational) called.
a's nnn() (integer) called.
Outer nnn() called.
v1..ooo: a.
v1..ppp: outer.
qqq[a := 5, b := 7].b: 7.
rrr == 5: false.
locks: Lock `sss' (declared at "tests/multi.salm":2506:14) grabbed [1].
In single(sss).
locks: Lock `sss' (declared at "tests/multi.salm":2506:14) released [0].
b1() called.
c1() called.
d1() called.
b's e1() called.
c's e1() called.
d's e1() called.
b's first f1() called.
b's second f1() called.
c's first f1() called.
c's second f1() called.
d's first f1() called.
d's second f1() called.
b's first g1() called.
b's second g1() called.
c's g1() called.
d's first g1() called.
d's second g1() called.
b's h1() called.
c's h1() called.
d's h1() called.
Local h1() called.
b's first i1() called.
b's second i1() called.
c's first i1() called.
c's second i1() called.
d's first i1() called.
d's second i1() called.
Local i1() called.
b's first j1() called.
b's second j1() called.
c's j1() called.
d's first j1() called.
d's second j1() called.
Local j1() called.
Caught: `Name `b1' was accessed before the `use' statement that could bind it was executed.'.
d1() called.
x, y, z: 1, 2, 3.
f1(): [2, 3, 11].
f1(): [3, 11, 12].
f1(): [11, 12, 13].
f2(14): 28.
v2..t1: tt1.
v2..t2: tt2.
l1[a := "aaa", b := "bbb"].b: bbb.
l2[a := "aaa", b := "bbb"].a: aaa.
q1 == q1: true.
q1 == q2: false.
q1 == q3: false.
locks: Lock `s1' (declared at "tests/multi.salm":2790:10) grabbed [1].
In single(s1).
locks: Lock `s1' (declared at "tests/multi.salm":2790:10) released [0].
locks: Lock `s2' (declared at "tests/multi.salm":2790:14) grabbed [1].
In single(s2).
locks: Lock `s2' (declared at "tests/multi.salm":2790:14) released [0].
aaa in abc: true.
aaa in xyz: false.
bbb in abc: true.
bbb in xyz: false.
ccc in abc: true.
ccc in xyz: false.
xxx in abc: false.
xxx in xyz: true.
yyy in abc: false.
yyy in xyz: true.
zzz in abc: false.
zzz in xyz: true.
p1() arguments: [].
p1() arguments: [3].
p1() arguments: [5, a := 7, 9].
p2() arguments: [x := 3].
p2() arguments: [x := 5, a := 7, 9].
power(1, 1): 1.
power(1, 2): 1.
power(2, 1): 2.
power(2, 2): 4.
power(2, 8): 256.
power(3, 2): 9.
power(3, 1): 3.
power(3, 0): 1.
power(3, -1): 1/3.
power(3, -2): 1/9.
power(-3, 2): 9.
power(-3, 1): -3.
power(-3, 0): 1.
power(-3, -1): -1/3.
power(-3, -2): 1/9.
power(2/3, 2): 4/9.
power(2/3, 1): 2/3.
power(2/3, 0): 1.
power(2/3, -1): 3/2.
power(2/3, -2): 9/4.
abc.
100%.
1, 2, 3.
2, 3, 1.
2, 3, 1.
3, 1, 2.
`17'.
`17'.
` 17'.
`  17'.
`17'.
`17'.
`17 '.
`17  '.
`'.
`1'.
`17'.
`17'.
`17'.
`17'.
`17'.
`017'.
`17'.
`17'.
`17'.
`017'.
`17'.
`-17'.
`+17'.
`-17'.
` 17'.
`-17'.
`-17'.
`-17'.
`-17'.
` -17'.
`-17'.
`-17'.
`-17'.
`-017'.
`0', `0', `0', `0'.
`1', `1', `1', `1'.
`2', `2', `2', `2'.
`3', `3', `3', `3'.
`4', `4', `4', `4'.
`5', `5', `5', `5'.
`6', `6', `6', `6'.
`7', `7', `7', `7'.
`8', `10', `8', `8'.
`9', `11', `9', `9'.
`10', `12', `a', `A'.
`11', `13', `b', `B'.
`12', `14', `c', `C'.
`13', `15', `d', `D'.
`14', `16', `e', `E'.
`15', `17', `f', `F'.
`16', `20', `10', `10'.
`17', `21', `11', `11'.
`63', `77', `3f', `3F'.
`64', `100', `40', `40'.
`65', `101', `41', `41'.
`255', `377', `ff', `FF'.
`256', `400', `100', `100'.
`257', `401', `101', `101'.
`511', `777', `1ff', `1FF'.
`512', `1000', `200', `200'.
`513', `1001', `201', `201'.
`4095', `7777', `fff', `FFF'.
`4096', `10000', `1000', `1000'.
`4097', `10001', `1001', `1001'.
`32767', `77777', `7fff', `7FFF'.
`32768', `100000', `8000', `8000'.
`32769', `100001', `8001', `8001'.
`65535', `177777', `ffff', `FFFF'.
`65536', `200000', `10000', `10000'.
`65537', `200001', `10001', `10001'.
`262143', `777777', `3ffff', `3FFFF'.
`262144', `1000000', `40000', `40000'.
`262145', `1000001', `40001', `40001'.
`1048575', `3777777', `fffff', `FFFFF'.
`1048576', `4000000', `100000', `100000'.
`1048577', `4000001', `100001', `100001'.
`2097151', `7777777', `1fffff', `1FFFFF'.
`2097152', `10000000', `200000', `200000'.
`2097153', `10000001', `200001', `200001'.
`16777215', `77777777', `ffffff', `FFFFFF'.
`16777216', `100000000', `1000000', `1000000'.
`16777217', `100000001', `1000001', `1000001'.
`-1', `-1', `-1', `-1'.
`-2', `-2', `-2', `-2'.
`-3', `-3', `-3', `-3'.
`-4', `-4', `-4', `-4'.
`-5', `-5', `-5', `-5'.
`-6', `-6', `-6', `-6'.
`-7', `-7', `-7', `-7'.
`-8', `-10', `-8', `-8'.
`-9', `-11', `-9', `-9'.
`-10', `-12', `-a', `-A'.
`-11', `-13', `-b', `-B'.
`-12', `-14', `-c', `-C'.
`-13', `-15', `-d', `-D'.
`-14', `-16', `-e', `-E'.
`-15', `-17', `-f', `-F'.
`-16', `-20', `-10', `-10'.
`-17', `-21', `-11', `-11'.
`0', `0', `0', `0'.
`1', `1', `1', `1'.
`2', `2', `2', `2'.
`3', `3', `3', `3'.
`4', `4', `4', `4'.
`5', `5', `5', `5'.
`6', `6', `6', `6'.
`7', `7', `7', `7'.
`8', `10', `8', `8'.
`9', `11', `9', `9'.
`10', `12', `a', `A'.
`11', `13', `b', `B'.
`12', `14', `c', `C'.
`13', `15', `d', `D'.
`14', `16', `e', `E'.
`15', `17', `f', `F'.
`16', `20', `10', `10'.
`17', `21', `11', `11'.
`-9', `-7', `-f', `-F'.
`-8', `-6', `-e', `-E'.
`-7', `-5', `-d', `-D'.
`-6', `-4', `-c', `-C'.
`-5', `-3', `-b', `-B'.
`-4', `-2', `-a', `-A'.
`-3', `-1', `-9', `-9'.
`-2', `-0', `-8', `-8'.
`-1', `-67', `-7', `-7'.
`-0', `-66', `-6', `-6'.
`-89', `-65', `-5', `-5'.
`-88', `-64', `-4', `-4'.
`-87', `-63', `-3', `-3'.
`-86', `-62', `-2', `-2'.
`-85', `-61', `-1', `-1'.
`-84', `-60', `-0', `-0'.
`-83', `-57', `-ef', `-EF'.
`1', `1', `1', `1'.
`', `', `', `'.
`-', `-', `-', `-'.
`-8', `-6', `-e', `-E'.
`-7', `-5', `-d', `-D'.
`-6', `-4', `-c', `-C'.
`-5', `-3', `-b', `-B'.
`-4', `-2', `-a', `-A'.
`-3', `-1', `-9', `-9'.
`-2', `-0', `-8', `-8'.
`-1', `-67', `-7', `-7'.
`-0', `-66', `-6', `-6'.
`-89', `-65', `-5', `-5'.
`-88', `-64', `-4', `-4'.
`-87', `-63', `-3', `-3'.
`-86', `-62', `-2', `-2'.
`-85', `-61', `-1', `-1'.
`-84', `-60', `-0', `-0'.
`-83', `-57', `-ef', `-EF'.
`1', `1', `1', `1'.
`0', `0', `0', `0'.
`-9', `-7', `-f', `-F'.
`-8', `-6', `-e', `-E'.
`-7', `-5', `-d', `-D'.
`-6', `-4', `-c', `-C'.
`-5', `-3', `-b', `-B'.
`-4', `-2', `-a', `-A'.
`-3', `-1', `-9', `-9'.
`-2', `-0', `-8', `-8'.
`-1', `-67', `-7', `-7'.
`-0', `-66', `-6', `-6'.
`-89', `-65', `-5', `-5'.
`-88', `-64', `-4', `-4'.
`-87', `-63', `-3', `-3'.
`-86', `-62', `-2', `-2'.
`-85', `-61', `-1', `-1'.
`-84', `-60', `-0', `-0'.
`-83', `-57', `-ef', `-EF'.
`01', `01', `01', `01'.
`00', `00', `00', `00'.
`-99', `-77', `-ff', `-FF'.
`-98', `-76', `-fe', `-FE'.
`-97', `-75', `-fd', `-FD'.
`-96', `-74', `-fc', `-FC'.
`-95', `-73', `-fb', `-FB'.
`-94', `-72', `-fa', `-FA'.
`-93', `-71', `-f9', `-F9'.
`-92', `-70', `-f8', `-F8'.
`-91', `-67', `-f7', `-F7'.
`-90', `-66', `-f6', `-F6'.
`-89', `-65', `-f5', `-F5'.
`-88', `-64', `-f4', `-F4'.
`-87', `-63', `-f3', `-F3'.
`-86', `-62', `-f2', `-F2'.
`-85', `-61', `-f1', `-F1'.
`-84', `-60', `-f0', `-F0'.
`-83', `-57', `-ef', `-EF'.
`001', `001', `001', `001'.
`000', `000', `000', `000'.
`-999', `-777', `-fff', `-FFF'.
`-998', `-776', `-ffe', `-FFE'.
`-997', `-775', `-ffd', `-FFD'.
`-996', `-774', `-ffc', `-FFC'.
`-995', `-773', `-ffb', `-FFB'.
`-994', `-772', `-ffa', `-FFA'.
`-993', `-771', `-ff9', `-FF9'.
`-992', `-770', `-ff8', `-FF8'.
`-991', `-767', `-ff7', `-FF7'.
`-990', `-766', `-ff6', `-FF6'.
`-989', `-765', `-ff5', `-FF5'.
`-988', `-764', `-ff4', `-FF4'.
`-987', `-763', `-ff3', `-FF3'.
`-986', `-762', `-ff2', `-FF2'.
`-985', `-761', `-ff1', `-FF1'.
`-984', `-760', `-ff0', `-FF0'.
`-983', `-757', `-fef', `-FEF'.
`0001', `0001', `0001', `0001'.
`0000', `0000', `0000', `0000'.
`-999', `-777', `-fff', `-FFF'.
`-998', `-776', `-ffe', `-FFE'.
`-997', `-775', `-ffd', `-FFD'.
`-996', `-774', `-ffc', `-FFC'.
`-995', `-773', `-ffb', `-FFB'.
`-994', `-772', `-ffa', `-FFA'.
`-993', `-771', `-ff9', `-FF9'.
`-992', `-770', `-ff8', `-FF8'.
`-991', `-767', `-ff7', `-FF7'.
`-990', `-766', `-ff6', `-FF6'.
`-989', `-765', `-ff5', `-FF5'.
`-988', `-764', `-ff4', `-FF4'.
`-987', `-763', `-ff3', `-FF3'.
`-986', `-762', `-ff2', `-FF2'.
`-985', `-761', `-ff1', `-FF1'.
`-984', `-760', `-ff0', `-FF0'.
`-983', `-757', `-fef', `-FEF'.
`1.000000'.
`1.200000'.
`0.333333'.
`0.666667'.
`1'.
`1'.
`0.3'.
`0.7'.
`1', `1', `1', `1'.
`1', `1', `1.2', `1.2'.
`0.3', `0.3', `0.33', `0.333'.
`0.7', `0.7', `0.67', `0.667'.
`3', `3', `3.3', `3.33'.
`7', `7', `6.7', `6.67'.
`3e+01', `3e+01', `33', `33.3'.
`7e+01', `7e+01', `67', `66.7'.
`3e+02', `3e+02', `3.3e+02', `333'.
`7e+02', `7e+02', `6.7e+02', `667'.
`3e+03', `3e+03', `3.3e+03', `3.33e+03'.
`7e+03', `7e+03', `6.7e+03', `6.67e+03'.
`3e+04', `3e+04', `3.3e+04', `3.33e+04'.
`7e+04', `7e+04', `6.7e+04', `6.67e+04'.
`0.03', `0.03', `0.033', `0.0333'.
`0.07', `0.07', `0.067', `0.0667'.
`0.003', `0.003', `0.0033', `0.00333'.
`0.007', `0.007', `0.0067', `0.00667'.
`0.0003', `0.0003', `0.00033', `0.000333'.
`0.0007', `0.0007', `0.00067', `0.000667'.
`3e-05', `3e-05', `3.3e-05', `3.33e-05'.
`7e-05', `7e-05', `6.7e-05', `6.67e-05'.
`3e-06', `3e-06', `3.3e-06', `3.33e-06'.
`7e-06', `7e-06', `6.7e-06', `6.67e-06'.
`-1.000000'.
`-1.200000'.
`-0.333333'.
`-0.666667'.
`-1'.
`-1'.
`-0.3'.
`-0.7'.
`-1', `-1', `-1', `-1'.
`-1', `-1', `-1.2', `-1.2'.
`-0.3', `-0.3', `-0.33', `-0.333'.
`-0.7', `-0.7', `-0.67', `-0.667'.
`-3', `-3', `-3.3', `-3.33'.
`-7', `-7', `-6.7', `-6.67'.
`-3e+01', `-3e+01', `-33', `-33.3'.
`-7e+01', `-7e+01', `-67', `-66.7'.
`-3e+02', `-3e+02', `-3.3e+02', `-333'.
`-7e+02', `-7e+02', `-6.7e+02', `-667'.
`-3e+03', `-3e+03', `-3.3e+03', `-3.33e+03'.
`-7e+03', `-7e+03', `-6.7e+03', `-6.67e+03'.
`-3e+04', `-3e+04', `-3.3e+04', `-3.33e+04'.
`-7e+04', `-7e+04', `-6.7e+04', `-6.67e+04'.
`-0.03', `-0.03', `-0.033', `-0.0333'.
`-0.07', `-0.07', `-0.067', `-0.0667'.
`-0.003', `-0.003', `-0.0033', `-0.00333'.
`-0.007', `-0.007', `-0.0067', `-0.00667'.
`-0.0003', `-0.0003', `-0.00033', `-0.000333'.
`-0.0007', `-0.0007', `-0.00067', `-0.000667'.
`-3e-05', `-3e-05', `-3.3e-05', `-3.33e-05'.
`-7e-05', `-7e-05', `-6.7e-05', `-6.67e-05'.
`-3e-06', `-3e-06', `-3.3e-06', `-3.33e-06'.
`-7e-06', `-7e-06', `-6.7e-06', `-6.67e-06'.
`1.000000'.
`1.200000'.
`0.333333'.
`0.666667'.
`1'.
`1'.
`0.3'.
`0.7'.
`1', `1', `1', `1'.
`1', `1', `1.2', `1.2'.
`0.3', `0.3', `0.33', `0.333'.
`0.7', `0.7', `0.67', `0.667'.
`3', `3', `3.3', `3.33'.
`7', `7', `6.7', `6.67'.
`3e+01', `3e+01', `33', `33.3'.
`7e+01', `7e+01', `67', `66.7'.
`3e+02', `3e+02', `3.3e+02', `333'.
`7e+02', `7e+02', `6.7e+02', `667'.
`3e+03', `3e+03', `3.3e+03', `3.33e+03'.
`7e+03', `7e+03', `6.7e+03', `6.67e+03'.
`3e+04', `3e+04', `3.3e+04', `3.33e+04'.
`7e+04', `7e+04', `6.7e+04', `6.67e+04'.
`0.03', `0.03', `0.033', `0.0333'.
`0.07', `0.07', `0.067', `0.0667'.
`0.003', `0.003', `0.0033', `0.00333'.
`0.007', `0.007', `0.0067', `0.00667'.
`0.0003', `0.0003', `0.00033', `0.000333'.
`0.0007', `0.0007', `0.00067', `0.000667'.
`3e-95', `3e-95', `3.3e-95', `3.33e-95'.
`7e-95', `7e-95', `6.7e-95', `6.67e-95'.
`3e-94', `3e-94', `3.3e-94', `3.33e-94'.
`7e-94', `7e-94', `6.7e-94', `6.67e-94'.
`-9.000000'.
`-8.800000'.
`-9.666667'.
`-9.333333'.
`-9'.
`-9'.
`-9.7'.
`-9.3'.
`-9', `-9', `-9', `-9'.
`-9', `-9', `-8.8', `-8.8'.
`-9.7', `-9.7', `-9.67', `-9.667'.
`-9.3', `-9.3', `-9.33', `-9.333'.
`-7', `-7', `-6.7', `-6.67'.
`-3', `-3', `-3.3', `-3.33'.
`-7e+01', `-7e+01', `-67', `-66.7'.
`-3e+01', `-3e+01', `-33', `-33.3'.
`-7e+02', `-7e+02', `-6.7e+02', `-667'.
`-3e+02', `-3e+02', `-3.3e+02', `-333'.
`-7e+03', `-7e+03', `-6.7e+03', `-6.67e+03'.
`-3e+03', `-3e+03', `-3.3e+03', `-3.33e+03'.
`-7e+04', `-7e+04', `-6.7e+04', `-6.67e+04'.
`-3e+04', `-3e+04', `-3.3e+04', `-3.33e+04'.
`-9.97', `-9.97', `-9.967', `-9.9667'.
`-9.93', `-9.93', `-9.933', `-9.9333'.
`-9.997', `-9.997', `-9.9967', `-9.99667'.
`-9.993', `-9.993', `-9.9933', `-9.99333'.
`-9.9997', `-9.9997', `-9.99967', `-9.999667'.
`-9.9993', `-9.9993', `-9.99933', `-9.999333'.
`-7e-95', `-7e-95', `-6.7e-95', `-6.67e-95'.
`-3e-95', `-3e-95', `-3.3e-95', `-3.33e-95'.
`-7e-94', `-7e-94', `-6.7e-94', `-6.67e-94'.
`-3e-94', `-3e-94', `-3.3e-94', `-3.33e-94'.
`9.999900E-01'.
`9.999990E-01'.
`9.999999E-01'.
`1.000000E+00'.
`3E-01'.
`3.3E-01'.
`3.33E-01'.
`3.333E-01'.
`3.E-01'.
`3.3E-01'.
`3.33E-01'.
`3.333E-01'.
`0.000000E+00'.
`0'.
`0.000000', `0.000000e+00', `0'.
`+oo', `+oo', `+oo'.
`-oo', `-oo', `-oo'.
`1/0', `1/0', `1/0'.
`0/0', `0/0', `0/0'.
`1e-05', `1e-05', `9.99e-06'.
`0.0001', `0.0001', `9.99e-05'.
`0.001', `0.001', `0.000999'.
`0.01', `0.01', `0.00999'.
`0.1', `0.1', `0.0999'.
`1', `1', `0.999'.
`10', `10', `9.99'.
`100', `100', `99.9'.
`1e+03', `1e+03', `999'.
`1e+04', `1e+04', `9.99e+03'.
`1e+05', `1e+05', `9.99e+04'.
`-1e-05', `-1e-05', `-9.99e-06'.
`-0.0001', `-0.0001', `-9.99e-05'.
`-0.001', `-0.001', `-0.000999'.
`-0.01', `-0.01', `-0.00999'.
`-0.1', `-0.1', `-0.0999'.
`-1', `-1', `-0.999'.
`-10', `-10', `-9.99'.
`-100', `-100', `-99.9'.
`-1e+03', `-1e+03', `-999'.
`-1e+04', `-1e+04', `-9.99e+03'.
`-1e+05', `-1e+05', `-9.99e+04'.
`[]'.
`[]'.
`[]'.
`["vx"]'.
`["x"]'.
`["x", plus := true]'.
`["x"]'.
`["x", space := true]'.
`["x", hash := true]'.
`["x"]'.
`["x", zero_width := 3]'.
`["x", precision := 7]'.
`["x", plus := true, hash := true, precision := 7]'.
`["x", plus := true, hash := true, zero_width := 3, precision := 7]'.
`  ["x"]'.
`["x"]  '.
`["x", zero_width := 7]'.
` ["x", zero_width := 24]'.
`abcde'.
`abcde'.
`  abcde'.
`'.
`a'.
`ab'.
`abc'.
`abcd'.
`abcde'.
`abcde'.
`abcde'.
`abcde'.
`  abcde'.
Character: `a'.
Character: `b'.
String(3): `cde'.
Next: `f'.
Look-ahead(0): `f'.
Look-ahead(1): `g'.
Look-ahead(2): `h'.
Character: `f'.
Look-ahead(0): `g'.
Look-ahead(1): `h'.
Look-ahead(2): `i'.
End?: false.
String(4): `ghij'.
End?: true.
End?: false.
Character: `l'.
End?: false.
Character: `m'.
End?: false.
Character: `n'.
End?: false.
Character: `o'.
End?: true.
Output: `'.
Output: `hello.'.
Output: `hello.0x7f'.
Testing scanf("a") on "a":
    No exception.
    Result: `[]'.
    Remainder: `'.
Testing scanf("a") on "b":
    Exception: `Plain text mismatch encountered in scanf(): expected `a', found `b'.'.
Testing scanf("a") on "":
    Exception: `Unexpected end-of-input encountered in scanf().'.
Testing scanf("a") on "ab":
    No exception.
    Result: `[]'.
    Remainder: `b'.
Testing scanf("@") on "ab":
    Exception: `Unterminated `@' specifier found in the format string of a scanf() call.'.
Testing scanf("%") on "ab":
    Exception: `Unterminated `%' specifier found in the format string of a scanf() call.'.
Testing scanf("#") on "ab":
    Exception: `Unterminated `#' specifier found in the format string of a scanf() call.'.
Testing scanf("@@") on "ab":
    Exception: `Plain text mismatch encountered in scanf(): expected `@', found `a'.'.
Testing scanf("@@") on "@@":
    No exception.
    Result: `[]'.
    Remainder: `@'.
Testing scanf("%%") on "cc":
    Exception: `Plain text mismatch encountered in scanf(): expected `%', found `c'.'.
Testing scanf("%%") on "%%":
    No exception.
    Result: `[]'.
    Remainder: `%'.
Testing scanf("##") on "dd":
    Exception: `Plain text mismatch encountered in scanf(): expected `#', found `d'.'.
Testing scanf("##") on "##":
    No exception.
    Result: `[]'.
    Remainder: `#'.
Testing scanf("@a|b@") on "ab":
    No exception.
    Result: `["a"]'.
    Remainder: `b'.
Testing scanf("@a|b@") on "cb":
    Exception: `No match for regular expression @a|b@.'.
Testing scanf("@a|b@") on "bb":
    No exception.
    Result: `["b"]'.
    Remainder: `b'.
Testing scanf("@.*b@") on "ababc":
    No exception.
    Result: `["abab"]'.
    Remainder: `c'.
Testing scanf("#.*b#") on "ababc":
    No exception.
    Result: `["ab"]'.
    Remainder: `abc'.
Testing scanf("@.*b@") on "abab":
    No exception.
    Result: `["abab"]'.
    Remainder: `'.
Testing scanf("#.*b#") on "abab":
    No exception.
    Result: `["ab"]'.
    Remainder: `ab'.
Testing scanf("@.*b$@") on "ababc":
    Exception: `No match for regular expression @.*b$@.'.
Testing scanf("#.*b$#") on "ababc":
    Exception: `No match for regular expression @.*b$@.'.
Testing scanf("@.*b$@") on "abab":
    No exception.
    Result: `["abab"]'.
    Remainder: `'.
Testing scanf("#.*b$#") on "abab":
    No exception.
    Result: `["abab"]'.
    Remainder: `'.
Testing scanf("@\\\\@") on "\\ab":
    No exception.
    Result: `["\\"]'.
    Remainder: `ab'.
Testing scanf("@\\@*@") on "@@@@cd":
    No exception.
    Result: `["@@@@"]'.
    Remainder: `cd'.
Testing scanf("#\\\\#") on "\\ab":
    No exception.
    Result: `["\\"]'.
    Remainder: `ab'.
Testing scanf("#\\#*#") on "####cd":
    No exception.
    Result: `[""]'.
    Remainder: `####cd'.
Testing scanf("#\\##") on "####cd":
    No exception.
    Result: `["#"]'.
    Remainder: `###cd'.
Testing scanf("%d%") on "123abc":
    No exception.
    Result: `[123]'.
    Remainder: `abc'.
Testing scanf("%d%") on "123":
    No exception.
    Result: `[123]'.
    Remainder: `'.
Testing scanf("%d%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%d%") on "013":
    No exception.
    Result: `[13]'.
    Remainder: `'.
Testing scanf("%d%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%d%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%d%") on "99.13":
    No exception.
    Result: `[99]'.
    Remainder: `.13'.
Testing scanf("%d%") on "+12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%d%") on "-12":
    No exception.
    Result: `[-12]'.
    Remainder: `'.
Testing scanf("%d%") on "+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%d%") on "-0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%d%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%d%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%d%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%d%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%d%") on "+oooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `oo'.
Testing scanf("%d%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%d%") on "+ooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `o'.
Testing scanf("%d%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%d%") on "-ooo":
    No exception.
    Result: `[-oo]'.
    Remainder: `o'.
Testing scanf("%d%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%d%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%d%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%d%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%d%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%d%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%d%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%d%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%ud%") on "123abc":
    No exception.
    Result: `[123]'.
    Remainder: `abc'.
Testing scanf("%ud%") on "123":
    No exception.
    Result: `[123]'.
    Remainder: `'.
Testing scanf("%ud%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ud%") on "013":
    No exception.
    Result: `[13]'.
    Remainder: `'.
Testing scanf("%ud%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ud%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%ud%") on "99.13":
    No exception.
    Result: `[99]'.
    Remainder: `.13'.
Testing scanf("%ud%") on "+12":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "-12":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "+0":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "-0":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "+oooo":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "+ooo":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "-ooo":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "oo":
    Exception: `Expected digits not found.'.
Testing scanf("%ud%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "123abc":
    No exception.
    Result: `[123]'.
    Remainder: `abc'.
Testing scanf("%cd%") on "123":
    No exception.
    Result: `[123]'.
    Remainder: `'.
Testing scanf("%cd%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cd%") on "013":
    No exception.
    Result: `[13]'.
    Remainder: `'.
Testing scanf("%cd%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cd%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%cd%") on "99.13":
    No exception.
    Result: `[99]'.
    Remainder: `.13'.
Testing scanf("%cd%") on "+12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cd%") on "-12":
    No exception.
    Result: `[-88]'.
    Remainder: `'.
Testing scanf("%cd%") on "+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cd%") on "-0":
    No exception.
    Result: `[-10]'.
    Remainder: `'.
Testing scanf("%cd%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "+oooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `oo'.
Testing scanf("%cd%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "+ooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `o'.
Testing scanf("%cd%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cd%") on "-ooo":
    No exception.
    Result: `[-oo]'.
    Remainder: `o'.
Testing scanf("%cd%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cd%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cd%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%cd%") on "-99.13":
    No exception.
    Result: `[-1]'.
    Remainder: `.13'.
Testing scanf("%cd%") on "-98":
    No exception.
    Result: `[-2]'.
    Remainder: `'.
Testing scanf("%cd%") on "-0":
    No exception.
    Result: `[-10]'.
    Remainder: `'.
Testing scanf("%cd%") on "-00":
    No exception.
    Result: `[-100]'.
    Remainder: `'.
Testing scanf("%o%") on "123abc":
    No exception.
    Result: `[83]'.
    Remainder: `abc'.
Testing scanf("%o%") on "123":
    No exception.
    Result: `[83]'.
    Remainder: `'.
Testing scanf("%o%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%o%") on "013":
    No exception.
    Result: `[11]'.
    Remainder: `'.
Testing scanf("%o%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%o%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%o%") on "99.13":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "+12":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%o%") on "-12":
    No exception.
    Result: `[-10]'.
    Remainder: `'.
Testing scanf("%o%") on "+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%o%") on "-0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%o%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "+oooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `oo'.
Testing scanf("%o%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "+ooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `o'.
Testing scanf("%o%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%o%") on "-ooo":
    No exception.
    Result: `[-oo]'.
    Remainder: `o'.
Testing scanf("%o%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%o%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%o%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "123abc":
    No exception.
    Result: `[83]'.
    Remainder: `abc'.
Testing scanf("%uo%") on "123":
    No exception.
    Result: `[83]'.
    Remainder: `'.
Testing scanf("%uo%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%uo%") on "013":
    No exception.
    Result: `[11]'.
    Remainder: `'.
Testing scanf("%uo%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%uo%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%uo%") on "99.13":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "+12":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "-12":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "+0":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "-0":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "+oooo":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "+ooo":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "-ooo":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "oo":
    Exception: `Expected digits not found.'.
Testing scanf("%uo%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "123abc":
    No exception.
    Result: `[83]'.
    Remainder: `abc'.
Testing scanf("%co%") on "123":
    No exception.
    Result: `[83]'.
    Remainder: `'.
Testing scanf("%co%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%co%") on "013":
    No exception.
    Result: `[11]'.
    Remainder: `'.
Testing scanf("%co%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%co%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%co%") on "99.13":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "+12":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%co%") on "-12":
    No exception.
    Result: `[-54]'.
    Remainder: `'.
Testing scanf("%co%") on "+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%co%") on "-0":
    No exception.
    Result: `[-8]'.
    Remainder: `'.
Testing scanf("%co%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "+oooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `oo'.
Testing scanf("%co%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "+ooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `o'.
Testing scanf("%co%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%co%") on "-ooo":
    No exception.
    Result: `[-oo]'.
    Remainder: `o'.
Testing scanf("%co%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%co%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%co%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "-99.13":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "-98":
    Exception: `Expected digits not found.'.
Testing scanf("%co%") on "-0":
    No exception.
    Result: `[-8]'.
    Remainder: `'.
Testing scanf("%co%") on "-00":
    No exception.
    Result: `[-64]'.
    Remainder: `'.
Testing scanf("%x%") on "123abc":
    No exception.
    Result: `[1194684]'.
    Remainder: `'.
Testing scanf("%x%") on "123":
    No exception.
    Result: `[291]'.
    Remainder: `'.
Testing scanf("%x%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%x%") on "013":
    No exception.
    Result: `[19]'.
    Remainder: `'.
Testing scanf("%x%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%x%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%x%") on "99.13":
    No exception.
    Result: `[153]'.
    Remainder: `.13'.
Testing scanf("%x%") on "+12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%x%") on "-12":
    No exception.
    Result: `[-18]'.
    Remainder: `'.
Testing scanf("%x%") on "+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%x%") on "-0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%x%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%x%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%x%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%x%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%x%") on "+oooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `oo'.
Testing scanf("%x%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%x%") on "+ooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `o'.
Testing scanf("%x%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%x%") on "-ooo":
    No exception.
    Result: `[-oo]'.
    Remainder: `o'.
Testing scanf("%x%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%x%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%x%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%x%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%x%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "123abc":
    No exception.
    Result: `[1194684]'.
    Remainder: `'.
Testing scanf("%ux%") on "123":
    No exception.
    Result: `[291]'.
    Remainder: `'.
Testing scanf("%ux%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ux%") on "013":
    No exception.
    Result: `[19]'.
    Remainder: `'.
Testing scanf("%ux%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ux%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%ux%") on "99.13":
    No exception.
    Result: `[153]'.
    Remainder: `.13'.
Testing scanf("%ux%") on "+12":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "-12":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "+0":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "-0":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "+oooo":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "+ooo":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "-ooo":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "oo":
    Exception: `Expected digits not found.'.
Testing scanf("%ux%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "123abc":
    No exception.
    Result: `[1194684]'.
    Remainder: `'.
Testing scanf("%cx%") on "123":
    No exception.
    Result: `[291]'.
    Remainder: `'.
Testing scanf("%cx%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cx%") on "013":
    No exception.
    Result: `[19]'.
    Remainder: `'.
Testing scanf("%cx%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cx%") on "0 ab":
    No exception.
    Result: `[0]'.
    Remainder: ` ab'.
Testing scanf("%cx%") on "99.13":
    No exception.
    Result: `[153]'.
    Remainder: `.13'.
Testing scanf("%cx%") on "+12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cx%") on "-12":
    No exception.
    Result: `[-238]'.
    Remainder: `'.
Testing scanf("%cx%") on "+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cx%") on "-0":
    No exception.
    Result: `[-16]'.
    Remainder: `'.
Testing scanf("%cx%") on "++12":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "+-12":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "-+12":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "--12":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "+oooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `oo'.
Testing scanf("%cx%") on "+o":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "+ooo":
    No exception.
    Result: `[+oo]'.
    Remainder: `o'.
Testing scanf("%cx%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cx%") on "-ooo":
    No exception.
    Result: `[-oo]'.
    Remainder: `o'.
Testing scanf("%cx%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cx%") on "-":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "+":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cx%") on "":
    Exception: `Expected digits not found.'.
Testing scanf("%cx%") on "-99.13":
    No exception.
    Result: `[-103]'.
    Remainder: `.13'.
Testing scanf("%cx%") on "-98":
    No exception.
    Result: `[-104]'.
    Remainder: `'.
Testing scanf("%cx%") on "-0":
    No exception.
    Result: `[-16]'.
    Remainder: `'.
Testing scanf("%cx%") on "-00":
    No exception.
    Result: `[-256]'.
    Remainder: `'.
Testing scanf("%d%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%d%") on "01":
    No exception.
    Result: `[1]'.
    Remainder: `'.
Testing scanf("%d%") on "02":
    No exception.
    Result: `[2]'.
    Remainder: `'.
Testing scanf("%d%") on "03":
    No exception.
    Result: `[3]'.
    Remainder: `'.
Testing scanf("%d%") on "04":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%d%") on "05":
    No exception.
    Result: `[5]'.
    Remainder: `'.
Testing scanf("%d%") on "06":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%d%") on "07":
    No exception.
    Result: `[7]'.
    Remainder: `'.
Testing scanf("%d%") on "08":
    No exception.
    Result: `[8]'.
    Remainder: `'.
Testing scanf("%d%") on "09":
    No exception.
    Result: `[9]'.
    Remainder: `'.
Testing scanf("%d%") on "0a":
    No exception.
    Result: `[0]'.
    Remainder: `a'.
Testing scanf("%d%") on "0b":
    No exception.
    Result: `[0]'.
    Remainder: `b'.
Testing scanf("%d%") on "0c":
    No exception.
    Result: `[0]'.
    Remainder: `c'.
Testing scanf("%d%") on "0d":
    No exception.
    Result: `[0]'.
    Remainder: `d'.
Testing scanf("%d%") on "0e":
    No exception.
    Result: `[0]'.
    Remainder: `e'.
Testing scanf("%d%") on "0f":
    No exception.
    Result: `[0]'.
    Remainder: `f'.
Testing scanf("%d%") on "0g":
    No exception.
    Result: `[0]'.
    Remainder: `g'.
Testing scanf("%d%") on "0h":
    No exception.
    Result: `[0]'.
    Remainder: `h'.
Testing scanf("%d%") on "0i":
    No exception.
    Result: `[0]'.
    Remainder: `i'.
Testing scanf("%d%") on "0j":
    No exception.
    Result: `[0]'.
    Remainder: `j'.
Testing scanf("%d%") on "0k":
    No exception.
    Result: `[0]'.
    Remainder: `k'.
Testing scanf("%d%") on "0l":
    No exception.
    Result: `[0]'.
    Remainder: `l'.
Testing scanf("%d%") on "0m":
    No exception.
    Result: `[0]'.
    Remainder: `m'.
Testing scanf("%d%") on "0n":
    No exception.
    Result: `[0]'.
    Remainder: `n'.
Testing scanf("%d%") on "0o":
    No exception.
    Result: `[0]'.
    Remainder: `o'.
Testing scanf("%d%") on "0p":
    No exception.
    Result: `[0]'.
    Remainder: `p'.
Testing scanf("%d%") on "0q":
    No exception.
    Result: `[0]'.
    Remainder: `q'.
Testing scanf("%d%") on "0r":
    No exception.
    Result: `[0]'.
    Remainder: `r'.
Testing scanf("%d%") on "0s":
    No exception.
    Result: `[0]'.
    Remainder: `s'.
Testing scanf("%d%") on "0t":
    No exception.
    Result: `[0]'.
    Remainder: `t'.
Testing scanf("%d%") on "0u":
    No exception.
    Result: `[0]'.
    Remainder: `u'.
Testing scanf("%d%") on "0v":
    No exception.
    Result: `[0]'.
    Remainder: `v'.
Testing scanf("%d%") on "0w":
    No exception.
    Result: `[0]'.
    Remainder: `w'.
Testing scanf("%d%") on "0x":
    No exception.
    Result: `[0]'.
    Remainder: `x'.
Testing scanf("%d%") on "0y":
    No exception.
    Result: `[0]'.
    Remainder: `y'.
Testing scanf("%d%") on "0z":
    No exception.
    Result: `[0]'.
    Remainder: `z'.
Testing scanf("%d%") on "0A":
    No exception.
    Result: `[0]'.
    Remainder: `A'.
Testing scanf("%d%") on "0B":
    No exception.
    Result: `[0]'.
    Remainder: `B'.
Testing scanf("%d%") on "0C":
    No exception.
    Result: `[0]'.
    Remainder: `C'.
Testing scanf("%d%") on "0D":
    No exception.
    Result: `[0]'.
    Remainder: `D'.
Testing scanf("%d%") on "0E":
    No exception.
    Result: `[0]'.
    Remainder: `E'.
Testing scanf("%d%") on "0F":
    No exception.
    Result: `[0]'.
    Remainder: `F'.
Testing scanf("%d%") on "0G":
    No exception.
    Result: `[0]'.
    Remainder: `G'.
Testing scanf("%d%") on "0H":
    No exception.
    Result: `[0]'.
    Remainder: `H'.
Testing scanf("%d%") on "0I":
    No exception.
    Result: `[0]'.
    Remainder: `I'.
Testing scanf("%d%") on "0J":
    No exception.
    Result: `[0]'.
    Remainder: `J'.
Testing scanf("%d%") on "0K":
    No exception.
    Result: `[0]'.
    Remainder: `K'.
Testing scanf("%d%") on "0L":
    No exception.
    Result: `[0]'.
    Remainder: `L'.
Testing scanf("%d%") on "0M":
    No exception.
    Result: `[0]'.
    Remainder: `M'.
Testing scanf("%d%") on "0N":
    No exception.
    Result: `[0]'.
    Remainder: `N'.
Testing scanf("%d%") on "0O":
    No exception.
    Result: `[0]'.
    Remainder: `O'.
Testing scanf("%d%") on "0P":
    No exception.
    Result: `[0]'.
    Remainder: `P'.
Testing scanf("%d%") on "0Q":
    No exception.
    Result: `[0]'.
    Remainder: `Q'.
Testing scanf("%d%") on "0R":
    No exception.
    Result: `[0]'.
    Remainder: `R'.
Testing scanf("%d%") on "0S":
    No exception.
    Result: `[0]'.
    Remainder: `S'.
Testing scanf("%d%") on "0T":
    No exception.
    Result: `[0]'.
    Remainder: `T'.
Testing scanf("%d%") on "0U":
    No exception.
    Result: `[0]'.
    Remainder: `U'.
Testing scanf("%d%") on "0V":
    No exception.
    Result: `[0]'.
    Remainder: `V'.
Testing scanf("%d%") on "0W":
    No exception.
    Result: `[0]'.
    Remainder: `W'.
Testing scanf("%d%") on "0X":
    No exception.
    Result: `[0]'.
    Remainder: `X'.
Testing scanf("%d%") on "0Y":
    No exception.
    Result: `[0]'.
    Remainder: `Y'.
Testing scanf("%d%") on "0Z":
    No exception.
    Result: `[0]'.
    Remainder: `Z'.
Testing scanf("%d%") on "fF":
    Exception: `Expected digits not found.'.
Testing scanf("%o%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%o%") on "01":
    No exception.
    Result: `[1]'.
    Remainder: `'.
Testing scanf("%o%") on "02":
    No exception.
    Result: `[2]'.
    Remainder: `'.
Testing scanf("%o%") on "03":
    No exception.
    Result: `[3]'.
    Remainder: `'.
Testing scanf("%o%") on "04":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%o%") on "05":
    No exception.
    Result: `[5]'.
    Remainder: `'.
Testing scanf("%o%") on "06":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%o%") on "07":
    No exception.
    Result: `[7]'.
    Remainder: `'.
Testing scanf("%o%") on "08":
    No exception.
    Result: `[0]'.
    Remainder: `8'.
Testing scanf("%o%") on "09":
    No exception.
    Result: `[0]'.
    Remainder: `9'.
Testing scanf("%o%") on "0a":
    No exception.
    Result: `[0]'.
    Remainder: `a'.
Testing scanf("%o%") on "0b":
    No exception.
    Result: `[0]'.
    Remainder: `b'.
Testing scanf("%o%") on "0c":
    No exception.
    Result: `[0]'.
    Remainder: `c'.
Testing scanf("%o%") on "0d":
    No exception.
    Result: `[0]'.
    Remainder: `d'.
Testing scanf("%o%") on "0e":
    No exception.
    Result: `[0]'.
    Remainder: `e'.
Testing scanf("%o%") on "0f":
    No exception.
    Result: `[0]'.
    Remainder: `f'.
Testing scanf("%o%") on "0g":
    No exception.
    Result: `[0]'.
    Remainder: `g'.
Testing scanf("%o%") on "0h":
    No exception.
    Result: `[0]'.
    Remainder: `h'.
Testing scanf("%o%") on "0i":
    No exception.
    Result: `[0]'.
    Remainder: `i'.
Testing scanf("%o%") on "0j":
    No exception.
    Result: `[0]'.
    Remainder: `j'.
Testing scanf("%o%") on "0k":
    No exception.
    Result: `[0]'.
    Remainder: `k'.
Testing scanf("%o%") on "0l":
    No exception.
    Result: `[0]'.
    Remainder: `l'.
Testing scanf("%o%") on "0m":
    No exception.
    Result: `[0]'.
    Remainder: `m'.
Testing scanf("%o%") on "0n":
    No exception.
    Result: `[0]'.
    Remainder: `n'.
Testing scanf("%o%") on "0o":
    No exception.
    Result: `[0]'.
    Remainder: `o'.
Testing scanf("%o%") on "0p":
    No exception.
    Result: `[0]'.
    Remainder: `p'.
Testing scanf("%o%") on "0q":
    No exception.
    Result: `[0]'.
    Remainder: `q'.
Testing scanf("%o%") on "0r":
    No exception.
    Result: `[0]'.
    Remainder: `r'.
Testing scanf("%o%") on "0s":
    No exception.
    Result: `[0]'.
    Remainder: `s'.
Testing scanf("%o%") on "0t":
    No exception.
    Result: `[0]'.
    Remainder: `t'.
Testing scanf("%o%") on "0u":
    No exception.
    Result: `[0]'.
    Remainder: `u'.
Testing scanf("%o%") on "0v":
    No exception.
    Result: `[0]'.
    Remainder: `v'.
Testing scanf("%o%") on "0w":
    No exception.
    Result: `[0]'.
    Remainder: `w'.
Testing scanf("%o%") on "0x":
    No exception.
    Result: `[0]'.
    Remainder: `x'.
Testing scanf("%o%") on "0y":
    No exception.
    Result: `[0]'.
    Remainder: `y'.
Testing scanf("%o%") on "0z":
    No exception.
    Result: `[0]'.
    Remainder: `z'.
Testing scanf("%o%") on "0A":
    No exception.
    Result: `[0]'.
    Remainder: `A'.
Testing scanf("%o%") on "0B":
    No exception.
    Result: `[0]'.
    Remainder: `B'.
Testing scanf("%o%") on "0C":
    No exception.
    Result: `[0]'.
    Remainder: `C'.
Testing scanf("%o%") on "0D":
    No exception.
    Result: `[0]'.
    Remainder: `D'.
Testing scanf("%o%") on "0E":
    No exception.
    Result: `[0]'.
    Remainder: `E'.
Testing scanf("%o%") on "0F":
    No exception.
    Result: `[0]'.
    Remainder: `F'.
Testing scanf("%o%") on "0G":
    No exception.
    Result: `[0]'.
    Remainder: `G'.
Testing scanf("%o%") on "0H":
    No exception.
    Result: `[0]'.
    Remainder: `H'.
Testing scanf("%o%") on "0I":
    No exception.
    Result: `[0]'.
    Remainder: `I'.
Testing scanf("%o%") on "0J":
    No exception.
    Result: `[0]'.
    Remainder: `J'.
Testing scanf("%o%") on "0K":
    No exception.
    Result: `[0]'.
    Remainder: `K'.
Testing scanf("%o%") on "0L":
    No exception.
    Result: `[0]'.
    Remainder: `L'.
Testing scanf("%o%") on "0M":
    No exception.
    Result: `[0]'.
    Remainder: `M'.
Testing scanf("%o%") on "0N":
    No exception.
    Result: `[0]'.
    Remainder: `N'.
Testing scanf("%o%") on "0O":
    No exception.
    Result: `[0]'.
    Remainder: `O'.
Testing scanf("%o%") on "0P":
    No exception.
    Result: `[0]'.
    Remainder: `P'.
Testing scanf("%o%") on "0Q":
    No exception.
    Result: `[0]'.
    Remainder: `Q'.
Testing scanf("%o%") on "0R":
    No exception.
    Result: `[0]'.
    Remainder: `R'.
Testing scanf("%o%") on "0S":
    No exception.
    Result: `[0]'.
    Remainder: `S'.
Testing scanf("%o%") on "0T":
    No exception.
    Result: `[0]'.
    Remainder: `T'.
Testing scanf("%o%") on "0U":
    No exception.
    Result: `[0]'.
    Remainder: `U'.
Testing scanf("%o%") on "0V":
    No exception.
    Result: `[0]'.
    Remainder: `V'.
Testing scanf("%o%") on "0W":
    No exception.
    Result: `[0]'.
    Remainder: `W'.
Testing scanf("%o%") on "0X":
    No exception.
    Result: `[0]'.
    Remainder: `X'.
Testing scanf("%o%") on "0Y":
    No exception.
    Result: `[0]'.
    Remainder: `Y'.
Testing scanf("%o%") on "0Z":
    No exception.
    Result: `[0]'.
    Remainder: `Z'.
Testing scanf("%o%") on "fF":
    Exception: `Expected digits not found.'.
Testing scanf("%x%") on "00":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%x%") on "01":
    No exception.
    Result: `[1]'.
    Remainder: `'.
Testing scanf("%x%") on "02":
    No exception.
    Result: `[2]'.
    Remainder: `'.
Testing scanf("%x%") on "03":
    No exception.
    Result: `[3]'.
    Remainder: `'.
Testing scanf("%x%") on "04":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%x%") on "05":
    No exception.
    Result: `[5]'.
    Remainder: `'.
Testing scanf("%x%") on "06":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%x%") on "07":
    No exception.
    Result: `[7]'.
    Remainder: `'.
Testing scanf("%x%") on "08":
    No exception.
    Result: `[8]'.
    Remainder: `'.
Testing scanf("%x%") on "09":
    No exception.
    Result: `[9]'.
    Remainder: `'.
Testing scanf("%x%") on "0a":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%x%") on "0b":
    No exception.
    Result: `[11]'.
    Remainder: `'.
Testing scanf("%x%") on "0c":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%x%") on "0d":
    No exception.
    Result: `[13]'.
    Remainder: `'.
Testing scanf("%x%") on "0e":
    No exception.
    Result: `[14]'.
    Remainder: `'.
Testing scanf("%x%") on "0f":
    No exception.
    Result: `[15]'.
    Remainder: `'.
Testing scanf("%x%") on "0g":
    No exception.
    Result: `[0]'.
    Remainder: `g'.
Testing scanf("%x%") on "0h":
    No exception.
    Result: `[0]'.
    Remainder: `h'.
Testing scanf("%x%") on "0i":
    No exception.
    Result: `[0]'.
    Remainder: `i'.
Testing scanf("%x%") on "0j":
    No exception.
    Result: `[0]'.
    Remainder: `j'.
Testing scanf("%x%") on "0k":
    No exception.
    Result: `[0]'.
    Remainder: `k'.
Testing scanf("%x%") on "0l":
    No exception.
    Result: `[0]'.
    Remainder: `l'.
Testing scanf("%x%") on "0m":
    No exception.
    Result: `[0]'.
    Remainder: `m'.
Testing scanf("%x%") on "0n":
    No exception.
    Result: `[0]'.
    Remainder: `n'.
Testing scanf("%x%") on "0o":
    No exception.
    Result: `[0]'.
    Remainder: `o'.
Testing scanf("%x%") on "0p":
    No exception.
    Result: `[0]'.
    Remainder: `p'.
Testing scanf("%x%") on "0q":
    No exception.
    Result: `[0]'.
    Remainder: `q'.
Testing scanf("%x%") on "0r":
    No exception.
    Result: `[0]'.
    Remainder: `r'.
Testing scanf("%x%") on "0s":
    No exception.
    Result: `[0]'.
    Remainder: `s'.
Testing scanf("%x%") on "0t":
    No exception.
    Result: `[0]'.
    Remainder: `t'.
Testing scanf("%x%") on "0u":
    No exception.
    Result: `[0]'.
    Remainder: `u'.
Testing scanf("%x%") on "0v":
    No exception.
    Result: `[0]'.
    Remainder: `v'.
Testing scanf("%x%") on "0w":
    No exception.
    Result: `[0]'.
    Remainder: `w'.
Testing scanf("%x%") on "0x":
    No exception.
    Result: `[0]'.
    Remainder: `x'.
Testing scanf("%x%") on "0y":
    No exception.
    Result: `[0]'.
    Remainder: `y'.
Testing scanf("%x%") on "0z":
    No exception.
    Result: `[0]'.
    Remainder: `z'.
Testing scanf("%x%") on "0A":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%x%") on "0B":
    No exception.
    Result: `[11]'.
    Remainder: `'.
Testing scanf("%x%") on "0C":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%x%") on "0D":
    No exception.
    Result: `[13]'.
    Remainder: `'.
Testing scanf("%x%") on "0E":
    No exception.
    Result: `[14]'.
    Remainder: `'.
Testing scanf("%x%") on "0F":
    No exception.
    Result: `[15]'.
    Remainder: `'.
Testing scanf("%x%") on "0G":
    No exception.
    Result: `[0]'.
    Remainder: `G'.
Testing scanf("%x%") on "0H":
    No exception.
    Result: `[0]'.
    Remainder: `H'.
Testing scanf("%x%") on "0I":
    No exception.
    Result: `[0]'.
    Remainder: `I'.
Testing scanf("%x%") on "0J":
    No exception.
    Result: `[0]'.
    Remainder: `J'.
Testing scanf("%x%") on "0K":
    No exception.
    Result: `[0]'.
    Remainder: `K'.
Testing scanf("%x%") on "0L":
    No exception.
    Result: `[0]'.
    Remainder: `L'.
Testing scanf("%x%") on "0M":
    No exception.
    Result: `[0]'.
    Remainder: `M'.
Testing scanf("%x%") on "0N":
    No exception.
    Result: `[0]'.
    Remainder: `N'.
Testing scanf("%x%") on "0O":
    No exception.
    Result: `[0]'.
    Remainder: `O'.
Testing scanf("%x%") on "0P":
    No exception.
    Result: `[0]'.
    Remainder: `P'.
Testing scanf("%x%") on "0Q":
    No exception.
    Result: `[0]'.
    Remainder: `Q'.
Testing scanf("%x%") on "0R":
    No exception.
    Result: `[0]'.
    Remainder: `R'.
Testing scanf("%x%") on "0S":
    No exception.
    Result: `[0]'.
    Remainder: `S'.
Testing scanf("%x%") on "0T":
    No exception.
    Result: `[0]'.
    Remainder: `T'.
Testing scanf("%x%") on "0U":
    No exception.
    Result: `[0]'.
    Remainder: `U'.
Testing scanf("%x%") on "0V":
    No exception.
    Result: `[0]'.
    Remainder: `V'.
Testing scanf("%x%") on "0W":
    No exception.
    Result: `[0]'.
    Remainder: `W'.
Testing scanf("%x%") on "0X":
    No exception.
    Result: `[0]'.
    Remainder: `X'.
Testing scanf("%x%") on "0Y":
    No exception.
    Result: `[0]'.
    Remainder: `Y'.
Testing scanf("%x%") on "0Z":
    No exception.
    Result: `[0]'.
    Remainder: `Z'.
Testing scanf("%x%") on "fF":
    No exception.
    Result: `[255]'.
    Remainder: `'.
Testing scanf("%i%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "-0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "0x0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "0x+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "0x-0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "+0x0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "-0x0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "0x":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "+0x":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "-0x":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "+0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "-0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "0X0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "0X+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "0X-0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "+0X0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "-0X0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%i%") on "0X":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "+0X":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "-0X":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "+0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "-0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%i%") on "+12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%i%") on "-12":
    No exception.
    Result: `[-12]'.
    Remainder: `'.
Testing scanf("%i%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%i%") on "0x+12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%i%") on "0x-12":
    No exception.
    Result: `[-18]'.
    Remainder: `'.
Testing scanf("%i%") on "+0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%i%") on "-0x12":
    No exception.
    Result: `[-18]'.
    Remainder: `'.
Testing scanf("%i%") on "0X12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%i%") on "0X+12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%i%") on "0X-12":
    No exception.
    Result: `[-18]'.
    Remainder: `'.
Testing scanf("%i%") on "+0X12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%i%") on "-0X12":
    No exception.
    Result: `[-18]'.
    Remainder: `'.
Testing scanf("%i%") on "aF":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "0xaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%i%") on "0x+aF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%i%") on "0x-aF":
    No exception.
    Result: `[-175]'.
    Remainder: `'.
Testing scanf("%i%") on "+0xaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%i%") on "-0xaF":
    No exception.
    Result: `[-175]'.
    Remainder: `'.
Testing scanf("%i%") on "0XaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%i%") on "0X+aF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%i%") on "0X-aF":
    No exception.
    Result: `[-175]'.
    Remainder: `'.
Testing scanf("%i%") on "+0XaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%i%") on "-0XaF":
    No exception.
    Result: `[-175]'.
    Remainder: `'.
Testing scanf("%i%") on "-0X-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "-0X+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "+0X-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%i%") on "+0X+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ui%") on "+0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0x0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ui%") on "0x+0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0x-0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0x0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0x0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0x":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0x":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0x":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0X0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ui%") on "0X+0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0X-0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0X0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0X0":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0X":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0X":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0X":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%ui%") on "+12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%ui%") on "0x+12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0x-12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0x12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0x12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0X12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%ui%") on "0X+12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0X-12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0X12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0X12":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0xaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%ui%") on "0x+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0x-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0xaF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0xaF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0XaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%ui%") on "0X+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "0X-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0XaF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0XaF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0X-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "-0X+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0X-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ui%") on "+0X+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ci%") on "+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ci%") on "-0":
    No exception.
    Result: `[-10]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x-0":
    No exception.
    Result: `[-16]'.
    Remainder: `'.
Testing scanf("%ci%") on "+0x0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ci%") on "-0x0":
    No exception.
    Result: `[-16]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "+0x":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "-0x":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "+0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "-0xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "0X0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ci%") on "0X+0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ci%") on "0X-0":
    No exception.
    Result: `[-16]'.
    Remainder: `'.
Testing scanf("%ci%") on "+0X0":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%ci%") on "-0X0":
    No exception.
    Result: `[-16]'.
    Remainder: `'.
Testing scanf("%ci%") on "0X":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "+0X":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "-0X":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "+0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "-0Xg":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%ci%") on "+12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%ci%") on "-12":
    No exception.
    Result: `[-88]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x+12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x-12":
    No exception.
    Result: `[-238]'.
    Remainder: `'.
Testing scanf("%ci%") on "+0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%ci%") on "-0x12":
    No exception.
    Result: `[-238]'.
    Remainder: `'.
Testing scanf("%ci%") on "0X12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%ci%") on "0X+12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%ci%") on "0X-12":
    No exception.
    Result: `[-238]'.
    Remainder: `'.
Testing scanf("%ci%") on "+0X12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%ci%") on "-0X12":
    No exception.
    Result: `[-238]'.
    Remainder: `'.
Testing scanf("%ci%") on "aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "0xaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x+aF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%ci%") on "0x-aF":
    No exception.
    Result: `[-81]'.
    Remainder: `'.
Testing scanf("%ci%") on "+0xaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%ci%") on "-0xaF":
    No exception.
    Result: `[-81]'.
    Remainder: `'.
Testing scanf("%ci%") on "0XaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%ci%") on "0X+aF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%ci%") on "0X-aF":
    No exception.
    Result: `[-81]'.
    Remainder: `'.
Testing scanf("%ci%") on "+0XaF":
    No exception.
    Result: `[175]'.
    Remainder: `'.
Testing scanf("%ci%") on "-0XaF":
    No exception.
    Result: `[-81]'.
    Remainder: `'.
Testing scanf("%ci%") on "-0X-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "-0X+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "+0X-aF":
    Exception: `Expected digits not found.'.
Testing scanf("%ci%") on "+0X+aF":
    Exception: `Expected digits not found.'.
Testing scanf("%df%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%df%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%df%") on "12.":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%df%") on "12.ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%df%") on "12.34":
    No exception.
    Result: `[617/50]'.
    Remainder: `'.
Testing scanf("%df%") on "12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%df%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%df%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%df%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%df%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%df%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%df%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%df%") on "+12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%df%") on "-12.34ab":
    No exception.
    Result: `[-617/50]'.
    Remainder: `ab'.
Testing scanf("%cdf%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cdf%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cdf%") on "12.":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cdf%") on "12.ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cdf%") on "12.34":
    No exception.
    Result: `[617/50]'.
    Remainder: `'.
Testing scanf("%cdf%") on "12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%cdf%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cdf%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cdf%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cdf%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cdf%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cdf%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cdf%") on "+12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%cdf%") on "-12.34ab":
    No exception.
    Result: `[-4383/50]'.
    Remainder: `ab'.
Testing scanf("%of%") on "12":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%of%") on "12ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%of%") on "12.":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%of%") on "12.ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%of%") on "12.34":
    No exception.
    Result: `[167/16]'.
    Remainder: `'.
Testing scanf("%of%") on "12.34ab":
    No exception.
    Result: `[167/16]'.
    Remainder: `ab'.
Testing scanf("%of%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%of%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%of%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%of%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%of%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%of%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%of%") on "+12.34ab":
    No exception.
    Result: `[167/16]'.
    Remainder: `ab'.
Testing scanf("%of%") on "-12.34ab":
    No exception.
    Result: `[-167/16]'.
    Remainder: `ab'.
Testing scanf("%cof%") on "12":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%cof%") on "12ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%cof%") on "12.":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%cof%") on "12.ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%cof%") on "12.34":
    No exception.
    Result: `[167/16]'.
    Remainder: `'.
Testing scanf("%cof%") on "12.34ab":
    No exception.
    Result: `[167/16]'.
    Remainder: `ab'.
Testing scanf("%cof%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cof%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cof%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cof%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cof%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cof%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cof%") on "+12.34ab":
    No exception.
    Result: `[167/16]'.
    Remainder: `ab'.
Testing scanf("%cof%") on "-12.34ab":
    No exception.
    Result: `[-857/16]'.
    Remainder: `ab'.
Testing scanf("%xf%") on "12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%xf%") on "12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%xf%") on "12.":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%xf%") on "12.ab":
    No exception.
    Result: `[4779/256]'.
    Remainder: `'.
Testing scanf("%xf%") on "12.34":
    No exception.
    Result: `[1165/64]'.
    Remainder: `'.
Testing scanf("%xf%") on "12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%xf%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%xf%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%xf%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%xf%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%xf%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%xf%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%xf%") on "+12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%xf%") on "-12.34ab":
    No exception.
    Result: `[-1193131/65536]'.
    Remainder: `'.
Testing scanf("%cxf%") on "12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cxf%") on "12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%cxf%") on "12.":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cxf%") on "12.ab":
    No exception.
    Result: `[4779/256]'.
    Remainder: `'.
Testing scanf("%cxf%") on "12.34":
    No exception.
    Result: `[1165/64]'.
    Remainder: `'.
Testing scanf("%cxf%") on "12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%cxf%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cxf%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cxf%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cxf%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cxf%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cxf%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cxf%") on "+12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%cxf%") on "-12.34ab":
    No exception.
    Result: `[-15584085/65536]'.
    Remainder: `'.
Testing scanf("%f%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%f%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%f%") on "12.":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%f%") on "12.ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%f%") on "12.34":
    No exception.
    Result: `[617/50]'.
    Remainder: `'.
Testing scanf("%f%") on "12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%f%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%f%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%f%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%f%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%f%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%f%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%f%") on "+12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%f%") on "-12.34ab":
    No exception.
    Result: `[-617/50]'.
    Remainder: `ab'.
Testing scanf("%f%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%f%") on "0x12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%f%") on "0x12.":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%f%") on "0x12.ab":
    No exception.
    Result: `[4779/256]'.
    Remainder: `'.
Testing scanf("%f%") on "0x12.34":
    No exception.
    Result: `[1165/64]'.
    Remainder: `'.
Testing scanf("%f%") on "0x12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%f%") on "0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "0x+infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "0x-infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "0xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "0x+12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%f%") on "0x-12.34ab":
    No exception.
    Result: `[-1193131/65536]'.
    Remainder: `'.
Testing scanf("%f%") on "+0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "-0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "+0xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "-0xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "+0x12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%f%") on "-0x12.34ab":
    No exception.
    Result: `[-1193131/65536]'.
    Remainder: `'.
Testing scanf("%f%") on "+0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "-0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "+0x+infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "-0x-infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "+0x+12.34ab":
    Exception: `Expected digits not found.'.
Testing scanf("%f%") on "-0x-12.34ab":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cf%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cf%") on "12.":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cf%") on "12.ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cf%") on "12.34":
    No exception.
    Result: `[617/50]'.
    Remainder: `'.
Testing scanf("%cf%") on "12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%cf%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cf%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cf%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cf%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cf%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cf%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cf%") on "+12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%cf%") on "-12.34ab":
    No exception.
    Result: `[-4383/50]'.
    Remainder: `ab'.
Testing scanf("%cf%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cf%") on "0x12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%cf%") on "0x12.":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cf%") on "0x12.ab":
    No exception.
    Result: `[4779/256]'.
    Remainder: `'.
Testing scanf("%cf%") on "0x12.34":
    No exception.
    Result: `[1165/64]'.
    Remainder: `'.
Testing scanf("%cf%") on "0x12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%cf%") on "0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "0x+infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "0x-infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "0xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "0x+12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%cf%") on "0x-12.34ab":
    No exception.
    Result: `[-15584085/65536]'.
    Remainder: `'.
Testing scanf("%cf%") on "+0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "-0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "+0xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "-0xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "+0x12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%cf%") on "-0x12.34ab":
    No exception.
    Result: `[-15584085/65536]'.
    Remainder: `'.
Testing scanf("%cf%") on "+0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "-0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "+0x+infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "-0x-infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "+0x+12.34ab":
    Exception: `Expected digits not found.'.
Testing scanf("%cf%") on "-0x-12.34ab":
    Exception: `Expected digits not found.'.
Testing scanf("%de%") on "12":
    Exception: `Expected exponent not found.'.
Testing scanf("%de%") on "12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%de%") on "12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%de%") on "12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%de%") on "12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%de%") on "12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%de%") on "12e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%de%") on "12.e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%de%") on "12.34e15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%de%") on "12.34e+15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%de%") on "12.34e-15":
    No exception.
    Result: `[617/50000000000000000]'.
    Remainder: `'.
Testing scanf("%de%") on "12.34e-1a":
    No exception.
    Result: `[617/500]'.
    Remainder: `a'.
Testing scanf("%de%") on "-12.34e-1a":
    No exception.
    Result: `[-617/500]'.
    Remainder: `a'.
Testing scanf("%de%") on "-12.34E-1a":
    No exception.
    Result: `[-617/500]'.
    Remainder: `a'.
Testing scanf("%de%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%de%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%de%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%de%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%de%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%de%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%de%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%de%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%de%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%cde%") on "12":
    Exception: `Expected exponent not found.'.
Testing scanf("%cde%") on "12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%cde%") on "12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%cde%") on "12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%cde%") on "12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%cde%") on "12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%cde%") on "12e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%cde%") on "12.e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%cde%") on "12.34e15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%cde%") on "12.34e+15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%cde%") on "12.34e-15":
    No exception.
    Result: `[617/500000000000000000000000000000000000000000000000000000000000000000000000000000000000000]'.
    Remainder: `'.
Testing scanf("%cde%") on "12.34e-1a":
    No exception.
    Result: `[617/50000000000]'.
    Remainder: `a'.
Testing scanf("%cde%") on "-12.34e-1a":
    No exception.
    Result: `[-4383/50000000000]'.
    Remainder: `a'.
Testing scanf("%cde%") on "-12.34E-1a":
    No exception.
    Result: `[-4383/50000000000]'.
    Remainder: `a'.
Testing scanf("%cde%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cde%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cde%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cde%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cde%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cde%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cde%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%cde%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%cde%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%oe%") on "12":
    Exception: `Expected exponent not found.'.
Testing scanf("%oe%") on "12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%oe%") on "12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%oe%") on "12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%oe%") on "12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%oe%") on "12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%oe%") on "12e15":
    No exception.
    Result: `[5497558138880]'.
    Remainder: `'.
Testing scanf("%oe%") on "12.e15":
    No exception.
    Result: `[5497558138880]'.
    Remainder: `'.
Testing scanf("%oe%") on "12.34e15":
    No exception.
    Result: `[5738076307456]'.
    Remainder: `'.
Testing scanf("%oe%") on "12.34e+15":
    No exception.
    Result: `[5738076307456]'.
    Remainder: `'.
Testing scanf("%oe%") on "12.34e-15":
    No exception.
    Result: `[167/8796093022208]'.
    Remainder: `'.
Testing scanf("%oe%") on "12.34e-1a":
    No exception.
    Result: `[167/128]'.
    Remainder: `a'.
Testing scanf("%oe%") on "-12.34e-1a":
    No exception.
    Result: `[-167/128]'.
    Remainder: `a'.
Testing scanf("%oe%") on "-12.34E-1a":
    No exception.
    Result: `[-167/128]'.
    Remainder: `a'.
Testing scanf("%oe%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%oe%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%oe%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%oe%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%oe%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%oe%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%oe%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%oe%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%oe%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%coe%") on "12":
    Exception: `Expected exponent not found.'.
Testing scanf("%coe%") on "12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%coe%") on "12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%coe%") on "12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%coe%") on "12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%coe%") on "12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%coe%") on "12e15":
    No exception.
    Result: `[5497558138880]'.
    Remainder: `'.
Testing scanf("%coe%") on "12.e15":
    No exception.
    Result: `[5497558138880]'.
    Remainder: `'.
Testing scanf("%coe%") on "12.34e15":
    No exception.
    Result: `[5738076307456]'.
    Remainder: `'.
Testing scanf("%coe%") on "12.34e+15":
    No exception.
    Result: `[5738076307456]'.
    Remainder: `'.
Testing scanf("%coe%") on "12.34e-15":
    No exception.
    Result: `[167/182687704666362864775460604089535377456991567872]'.
    Remainder: `'.
Testing scanf("%coe%") on "12.34e-1a":
    No exception.
    Result: `[167/33554432]'.
    Remainder: `a'.
Testing scanf("%coe%") on "-12.34e-1a":
    No exception.
    Result: `[-857/33554432]'.
    Remainder: `a'.
Testing scanf("%coe%") on "-12.34E-1a":
    No exception.
    Result: `[-857/33554432]'.
    Remainder: `a'.
Testing scanf("%coe%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%coe%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%coe%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%coe%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%coe%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%coe%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%coe%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%coe%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%coe%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%xe%") on "12":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.34e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.34e+15":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.34e-15":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12.34e-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "-12.34e-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "-12.34E-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%xe%") on "12x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%xe%") on "12.x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%xe%") on "12.34x15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%xe%") on "12.34x+15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%xe%") on "12.34x-15":
    No exception.
    Result: `[1165/1237940039285380274899124224]'.
    Remainder: `'.
Testing scanf("%xe%") on "12.34x-1a":
    No exception.
    Result: `[1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%xe%") on "-12.34x-1a":
    No exception.
    Result: `[-1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%xe%") on "-12.34X-1a":
    No exception.
    Result: `[-1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%xe%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%xe%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%xe%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%xe%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%xe%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%xe%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%xe%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%xe%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%xe%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%cxe%") on "12":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.34e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.34e+15":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.34e-15":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12.34e-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "-12.34e-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "-12.34E-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%cxe%") on "12x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%cxe%") on "12.x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%cxe%") on "12.34x15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%cxe%") on "12.34x+15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%cxe%") on "12.34x-f5":
    No exception.
    Result: `[1165/1125899906842624]'.
    Remainder: `'.
Testing scanf("%cxe%") on "12.34x-fa":
    No exception.
    Result: `[1165/1073741824]'.
    Remainder: `'.
Testing scanf("%cxe%") on "-12.34x-fa":
    No exception.
    Result: `[-15219/1073741824]'.
    Remainder: `'.
Testing scanf("%cxe%") on "-12.34X-fa":
    No exception.
    Result: `[-15219/1073741824]'.
    Remainder: `'.
Testing scanf("%cxe%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cxe%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cxe%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cxe%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cxe%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cxe%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cxe%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%cxe%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%cxe%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%e%") on "12":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "12e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%e%") on "12.e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%e%") on "12.34e15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%e%") on "12.34e+15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%e%") on "12.34e-15":
    No exception.
    Result: `[617/50000000000000000]'.
    Remainder: `'.
Testing scanf("%e%") on "12.34e-1a":
    No exception.
    Result: `[617/500]'.
    Remainder: `a'.
Testing scanf("%e%") on "-12.34e-1a":
    No exception.
    Result: `[-617/500]'.
    Remainder: `a'.
Testing scanf("%e%") on "-12.34E-1a":
    No exception.
    Result: `[-617/500]'.
    Remainder: `a'.
Testing scanf("%e%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%e%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%e%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%e%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%e%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%e%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%e%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%e%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%e%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%e%") on "0x12":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.34e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.34e+15":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.34e-15":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12.34e-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x-12.34e-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x-12.34E-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%e%") on "0x12x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%e%") on "0x12.x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%e%") on "0x12.34x15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%e%") on "0x12.34x+15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%e%") on "0x12.34x-15":
    No exception.
    Result: `[1165/1237940039285380274899124224]'.
    Remainder: `'.
Testing scanf("%e%") on "0x12.34x-1a":
    No exception.
    Result: `[1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%e%") on "0x-12.34x-1a":
    No exception.
    Result: `[-1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%e%") on "0x-12.34X-1a":
    No exception.
    Result: `[-1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%e%") on "0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%e%") on "0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%e%") on "0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%e%") on "0x+infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%e%") on "0x-infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%e%") on "0xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%e%") on "0x+infinitye15":
    Exception: `Expected digits not found.'.
Testing scanf("%e%") on "0x-infinitye+15":
    Exception: `Expected digits not found.'.
Testing scanf("%e%") on "0xinfinitye-15":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "12":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "12e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%ce%") on "12.e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%ce%") on "12.34e15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%ce%") on "12.34e+15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%ce%") on "12.34e-15":
    No exception.
    Result: `[617/500000000000000000000000000000000000000000000000000000000000000000000000000000000000000]'.
    Remainder: `'.
Testing scanf("%ce%") on "12.34e-1a":
    No exception.
    Result: `[617/50000000000]'.
    Remainder: `a'.
Testing scanf("%ce%") on "-12.34e-1a":
    No exception.
    Result: `[-4383/50000000000]'.
    Remainder: `a'.
Testing scanf("%ce%") on "-12.34E-1a":
    No exception.
    Result: `[-4383/50000000000]'.
    Remainder: `a'.
Testing scanf("%ce%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%ce%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%ce%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%ce%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%ce%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%ce%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%ce%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%ce%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%ce%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%ce%") on "0X12":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.34":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.34ab":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.34e15":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.34e+15":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.34e-15":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12.34e-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X-12.34e-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X-12.34E-1a":
    Exception: `Expected exponent not found.'.
Testing scanf("%ce%") on "0X12x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%ce%") on "0X12.x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%ce%") on "0X12.34x15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%ce%") on "0X12.34x+15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%ce%") on "0X12.34x-f5":
    No exception.
    Result: `[1165/1125899906842624]'.
    Remainder: `'.
Testing scanf("%ce%") on "0X12.34x-fa":
    No exception.
    Result: `[1165/1073741824]'.
    Remainder: `'.
Testing scanf("%ce%") on "0X-12.34x-fa":
    No exception.
    Result: `[-15219/1073741824]'.
    Remainder: `'.
Testing scanf("%ce%") on "0X-12.34X-fa":
    No exception.
    Result: `[-15219/1073741824]'.
    Remainder: `'.
Testing scanf("%ce%") on "0X+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "0X-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "0Xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "0X+infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "0X-infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "0Xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "0X+infinitye15":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "0X-infinitye+15":
    Exception: `Expected digits not found.'.
Testing scanf("%ce%") on "0Xinfinitye-15":
    Exception: `Expected digits not found.'.
Testing scanf("%dg%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%dg%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%dg%") on "12.":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%dg%") on "12.ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%dg%") on "12.34":
    No exception.
    Result: `[617/50]'.
    Remainder: `'.
Testing scanf("%dg%") on "12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%dg%") on "12e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%dg%") on "12.e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%dg%") on "12.34e15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%dg%") on "12.34e+15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%dg%") on "12.34e-15":
    No exception.
    Result: `[617/50000000000000000]'.
    Remainder: `'.
Testing scanf("%dg%") on "12.34e-1a":
    No exception.
    Result: `[617/500]'.
    Remainder: `a'.
Testing scanf("%dg%") on "-12.34e-1a":
    No exception.
    Result: `[-617/500]'.
    Remainder: `a'.
Testing scanf("%dg%") on "-12.34E-1a":
    No exception.
    Result: `[-617/500]'.
    Remainder: `a'.
Testing scanf("%dg%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%dg%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%dg%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%dg%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%dg%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%dg%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%dg%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%dg%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%dg%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%cdg%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cdg%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cdg%") on "12.":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cdg%") on "12.ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cdg%") on "12.34":
    No exception.
    Result: `[617/50]'.
    Remainder: `'.
Testing scanf("%cdg%") on "12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%cdg%") on "12e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%cdg%") on "12.e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%cdg%") on "12.34e15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%cdg%") on "12.34e+15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%cdg%") on "12.34e-15":
    No exception.
    Result: `[617/500000000000000000000000000000000000000000000000000000000000000000000000000000000000000]'.
    Remainder: `'.
Testing scanf("%cdg%") on "12.34e-1a":
    No exception.
    Result: `[617/50000000000]'.
    Remainder: `a'.
Testing scanf("%cdg%") on "-12.34e-1a":
    No exception.
    Result: `[-4383/50000000000]'.
    Remainder: `a'.
Testing scanf("%cdg%") on "-12.34E-1a":
    No exception.
    Result: `[-4383/50000000000]'.
    Remainder: `a'.
Testing scanf("%cdg%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cdg%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cdg%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cdg%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cdg%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cdg%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cdg%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%cdg%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%cdg%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%og%") on "12":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%og%") on "12ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%og%") on "12.":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%og%") on "12.ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%og%") on "12.34":
    No exception.
    Result: `[167/16]'.
    Remainder: `'.
Testing scanf("%og%") on "12.34ab":
    No exception.
    Result: `[167/16]'.
    Remainder: `ab'.
Testing scanf("%og%") on "12e15":
    No exception.
    Result: `[5497558138880]'.
    Remainder: `'.
Testing scanf("%og%") on "12.e15":
    No exception.
    Result: `[5497558138880]'.
    Remainder: `'.
Testing scanf("%og%") on "12.34e15":
    No exception.
    Result: `[5738076307456]'.
    Remainder: `'.
Testing scanf("%og%") on "12.34e+15":
    No exception.
    Result: `[5738076307456]'.
    Remainder: `'.
Testing scanf("%og%") on "12.34e-15":
    No exception.
    Result: `[167/8796093022208]'.
    Remainder: `'.
Testing scanf("%og%") on "12.34e-1a":
    No exception.
    Result: `[167/128]'.
    Remainder: `a'.
Testing scanf("%og%") on "-12.34e-1a":
    No exception.
    Result: `[-167/128]'.
    Remainder: `a'.
Testing scanf("%og%") on "-12.34E-1a":
    No exception.
    Result: `[-167/128]'.
    Remainder: `a'.
Testing scanf("%og%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%og%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%og%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%og%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%og%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%og%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%og%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%og%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%og%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%cog%") on "12":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%cog%") on "12ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%cog%") on "12.":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%cog%") on "12.ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%cog%") on "12.34":
    No exception.
    Result: `[167/16]'.
    Remainder: `'.
Testing scanf("%cog%") on "12.34ab":
    No exception.
    Result: `[167/16]'.
    Remainder: `ab'.
Testing scanf("%cog%") on "12e15":
    No exception.
    Result: `[5497558138880]'.
    Remainder: `'.
Testing scanf("%cog%") on "12.e15":
    No exception.
    Result: `[5497558138880]'.
    Remainder: `'.
Testing scanf("%cog%") on "12.34e15":
    No exception.
    Result: `[5738076307456]'.
    Remainder: `'.
Testing scanf("%cog%") on "12.34e+15":
    No exception.
    Result: `[5738076307456]'.
    Remainder: `'.
Testing scanf("%cog%") on "12.34e-15":
    No exception.
    Result: `[167/182687704666362864775460604089535377456991567872]'.
    Remainder: `'.
Testing scanf("%cog%") on "12.34e-1a":
    No exception.
    Result: `[167/33554432]'.
    Remainder: `a'.
Testing scanf("%cog%") on "-12.34e-1a":
    No exception.
    Result: `[-857/33554432]'.
    Remainder: `a'.
Testing scanf("%cog%") on "-12.34E-1a":
    No exception.
    Result: `[-857/33554432]'.
    Remainder: `a'.
Testing scanf("%cog%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cog%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cog%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cog%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cog%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cog%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cog%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%cog%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%cog%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%xg%") on "12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%xg%") on "12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.ab":
    No exception.
    Result: `[4779/256]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.34":
    No exception.
    Result: `[1165/64]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%xg%") on "12e15":
    No exception.
    Result: `[77333]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.e15":
    No exception.
    Result: `[77333/4096]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.34e15":
    No exception.
    Result: `[19090965/1048576]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.34e+15":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `+15'.
Testing scanf("%xg%") on "12.34e-15":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `-15'.
Testing scanf("%xg%") on "12.34e-1a":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `-1a'.
Testing scanf("%xg%") on "-12.34e-1a":
    No exception.
    Result: `[-37287/2048]'.
    Remainder: `-1a'.
Testing scanf("%xg%") on "-12.34E-1a":
    No exception.
    Result: `[-37287/2048]'.
    Remainder: `-1a'.
Testing scanf("%xg%") on "12x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.34x15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.34x+15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.34x-15":
    No exception.
    Result: `[1165/1237940039285380274899124224]'.
    Remainder: `'.
Testing scanf("%xg%") on "12.34x-1a":
    No exception.
    Result: `[1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%xg%") on "-12.34x-1a":
    No exception.
    Result: `[-1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%xg%") on "-12.34X-1a":
    No exception.
    Result: `[-1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%xg%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%xg%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%xg%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%xg%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%xg%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%xg%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%xg%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%xg%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%xg%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%cxg%") on "12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.ab":
    No exception.
    Result: `[4779/256]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.34":
    No exception.
    Result: `[1165/64]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12e15":
    No exception.
    Result: `[77333]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.e15":
    No exception.
    Result: `[77333/4096]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.34e15":
    No exception.
    Result: `[19090965/1048576]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.34e+15":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `+15'.
Testing scanf("%cxg%") on "12.34e-15":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `-15'.
Testing scanf("%cxg%") on "12.34e-1a":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `-1a'.
Testing scanf("%cxg%") on "-12.34e-1a":
    No exception.
    Result: `[-487001/2048]'.
    Remainder: `-1a'.
Testing scanf("%cxg%") on "-12.34E-1a":
    No exception.
    Result: `[-487001/2048]'.
    Remainder: `-1a'.
Testing scanf("%cxg%") on "12x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.34x15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.34x+15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.34x-f5":
    No exception.
    Result: `[1165/1125899906842624]'.
    Remainder: `'.
Testing scanf("%cxg%") on "12.34x-fa":
    No exception.
    Result: `[1165/1073741824]'.
    Remainder: `'.
Testing scanf("%cxg%") on "-12.34x-fa":
    No exception.
    Result: `[-15219/1073741824]'.
    Remainder: `'.
Testing scanf("%cxg%") on "-12.34X-fa":
    No exception.
    Result: `[-15219/1073741824]'.
    Remainder: `'.
Testing scanf("%cxg%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cxg%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cxg%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cxg%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cxg%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cxg%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cxg%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%cxg%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%cxg%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%g%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%g%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%g%") on "12.":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%g%") on "12.ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%g%") on "12.34":
    No exception.
    Result: `[617/50]'.
    Remainder: `'.
Testing scanf("%g%") on "12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%g%") on "12e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%g%") on "12.e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%g%") on "12.34e15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%g%") on "12.34e+15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%g%") on "12.34e-15":
    No exception.
    Result: `[617/50000000000000000]'.
    Remainder: `'.
Testing scanf("%g%") on "12.34e-1a":
    No exception.
    Result: `[617/500]'.
    Remainder: `a'.
Testing scanf("%g%") on "-12.34e-1a":
    No exception.
    Result: `[-617/500]'.
    Remainder: `a'.
Testing scanf("%g%") on "-12.34E-1a":
    No exception.
    Result: `[-617/500]'.
    Remainder: `a'.
Testing scanf("%g%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%g%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%g%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%g%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%g%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%g%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%g%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%g%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%g%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%g%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.ab":
    No exception.
    Result: `[4779/256]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.34":
    No exception.
    Result: `[1165/64]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12e15":
    No exception.
    Result: `[77333]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.e15":
    No exception.
    Result: `[77333/4096]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.34e15":
    No exception.
    Result: `[19090965/1048576]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.34e+15":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `+15'.
Testing scanf("%g%") on "0x12.34e-15":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `-15'.
Testing scanf("%g%") on "0x12.34e-1a":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `-1a'.
Testing scanf("%g%") on "0x-12.34e-1a":
    No exception.
    Result: `[-37287/2048]'.
    Remainder: `-1a'.
Testing scanf("%g%") on "0x-12.34E-1a":
    No exception.
    Result: `[-37287/2048]'.
    Remainder: `-1a'.
Testing scanf("%g%") on "0x12x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.34x15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.34x+15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.34x-15":
    No exception.
    Result: `[1165/1237940039285380274899124224]'.
    Remainder: `'.
Testing scanf("%g%") on "0x12.34x-1a":
    No exception.
    Result: `[1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%g%") on "0x-12.34x-1a":
    No exception.
    Result: `[-1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%g%") on "0x-12.34X-1a":
    No exception.
    Result: `[-1165/1298074214633706907132624082305024]'.
    Remainder: `'.
Testing scanf("%g%") on "0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%g%") on "0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%g%") on "0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%g%") on "0x+infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%g%") on "0x-infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%g%") on "0xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%g%") on "0x+infinitye15":
    Exception: `Expected digits not found.'.
Testing scanf("%g%") on "0x-infinitye+15":
    Exception: `Expected digits not found.'.
Testing scanf("%g%") on "0xinfinitye-15":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cg%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cg%") on "12.":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cg%") on "12.ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cg%") on "12.34":
    No exception.
    Result: `[617/50]'.
    Remainder: `'.
Testing scanf("%cg%") on "12.34ab":
    No exception.
    Result: `[617/50]'.
    Remainder: `ab'.
Testing scanf("%cg%") on "12e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%cg%") on "12.e15":
    No exception.
    Result: `[12000000000000000]'.
    Remainder: `'.
Testing scanf("%cg%") on "12.34e15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%cg%") on "12.34e+15":
    No exception.
    Result: `[12340000000000000]'.
    Remainder: `'.
Testing scanf("%cg%") on "12.34e-15":
    No exception.
    Result: `[617/500000000000000000000000000000000000000000000000000000000000000000000000000000000000000]'.
    Remainder: `'.
Testing scanf("%cg%") on "12.34e-1a":
    No exception.
    Result: `[617/50000000000]'.
    Remainder: `a'.
Testing scanf("%cg%") on "-12.34e-1a":
    No exception.
    Result: `[-4383/50000000000]'.
    Remainder: `a'.
Testing scanf("%cg%") on "-12.34E-1a":
    No exception.
    Result: `[-4383/50000000000]'.
    Remainder: `a'.
Testing scanf("%cg%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cg%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cg%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cg%") on "+infinity":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cg%") on "-infinity":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cg%") on "infinity":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cg%") on "+infinitye15":
    No exception.
    Result: `[+oo]'.
    Remainder: `e15'.
Testing scanf("%cg%") on "-infinitye+15":
    No exception.
    Result: `[-oo]'.
    Remainder: `e+15'.
Testing scanf("%cg%") on "infinitye-15":
    No exception.
    Result: `[1/0]'.
    Remainder: `e-15'.
Testing scanf("%cg%") on "0X12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.ab":
    No exception.
    Result: `[4779/256]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.34":
    No exception.
    Result: `[1165/64]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.34ab":
    No exception.
    Result: `[1193131/65536]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12e15":
    No exception.
    Result: `[77333]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.e15":
    No exception.
    Result: `[77333/4096]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.34e15":
    No exception.
    Result: `[19090965/1048576]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.34e+15":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `+15'.
Testing scanf("%cg%") on "0X12.34e-15":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `-15'.
Testing scanf("%cg%") on "0X12.34e-1a":
    No exception.
    Result: `[37287/2048]'.
    Remainder: `-1a'.
Testing scanf("%cg%") on "0X-12.34e-1a":
    No exception.
    Result: `[-487001/2048]'.
    Remainder: `-1a'.
Testing scanf("%cg%") on "0X-12.34E-1a":
    No exception.
    Result: `[-487001/2048]'.
    Remainder: `-1a'.
Testing scanf("%cg%") on "0X12x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.x15":
    No exception.
    Result: `[348170636049013202315378688]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.34x15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.34x+15":
    No exception.
    Result: `[352099644962760747133173760]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.34x-f5":
    No exception.
    Result: `[1165/1125899906842624]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X12.34x-fa":
    No exception.
    Result: `[1165/1073741824]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X-12.34x-fa":
    No exception.
    Result: `[-15219/1073741824]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X-12.34X-fa":
    No exception.
    Result: `[-15219/1073741824]'.
    Remainder: `'.
Testing scanf("%cg%") on "0X+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "0X-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "0Xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "0X+infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "0X-infinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "0Xinfinity":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "0X+infinitye15":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "0X-infinitye+15":
    Exception: `Expected digits not found.'.
Testing scanf("%cg%") on "0Xinfinitye-15":
    Exception: `Expected digits not found.'.
Testing scanf("%dr%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%dr%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%dr%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%dr%") on "12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%dr%") on "12/3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%dr%") on "12/3ab":
    No exception.
    Result: `[4]'.
    Remainder: `ab'.
Testing scanf("%dr%") on "-12/3ab":
    No exception.
    Result: `[-4]'.
    Remainder: `ab'.
Testing scanf("%dr%") on "-12./3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `./3ab'.
Testing scanf("%dr%") on "-12.7/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7/3ab'.
Testing scanf("%dr%") on "-12.7e5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%dr%") on "-12e5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `e5/3ab'.
Testing scanf("%dr%") on "-12.7x5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%dr%") on "-12x5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `x5/3ab'.
Testing scanf("%dr%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%dr%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%dr%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%dr%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%dr%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%dr%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%dr%") on "12/-3":
    No exception.
    Result: `[-4]'.
    Remainder: `'.
Testing scanf("%cdr%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cdr%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cdr%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%cdr%") on "12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%cdr%") on "12/3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%cdr%") on "12/3ab":
    No exception.
    Result: `[4]'.
    Remainder: `ab'.
Testing scanf("%cdr%") on "-12/3ab":
    No exception.
    Result: `[-88/3]'.
    Remainder: `ab'.
Testing scanf("%cdr%") on "-12./3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `./3ab'.
Testing scanf("%cdr%") on "-12.7/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7/3ab'.
Testing scanf("%cdr%") on "-12.7e5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%cdr%") on "-12e5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `e5/3ab'.
Testing scanf("%cdr%") on "-12.7x5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%cdr%") on "-12x5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `x5/3ab'.
Testing scanf("%cdr%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cdr%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%cdr%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cdr%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cdr%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cdr%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cdr%") on "12/-3":
    No exception.
    Result: `[-12/7]'.
    Remainder: `'.
Testing scanf("%or%") on "12":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%or%") on "12ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%or%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%or%") on "12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%or%") on "12/3":
    No exception.
    Result: `[10/3]'.
    Remainder: `'.
Testing scanf("%or%") on "12/3ab":
    No exception.
    Result: `[10/3]'.
    Remainder: `ab'.
Testing scanf("%or%") on "-12/3ab":
    No exception.
    Result: `[-10/3]'.
    Remainder: `ab'.
Testing scanf("%or%") on "-12./3ab":
    No exception.
    Result: `[-10]'.
    Remainder: `./3ab'.
Testing scanf("%or%") on "-12.7/3ab":
    No exception.
    Result: `[-10]'.
    Remainder: `.7/3ab'.
Testing scanf("%or%") on "-12.7e5/3ab":
    No exception.
    Result: `[-10]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%or%") on "-12e5/3ab":
    No exception.
    Result: `[-10]'.
    Remainder: `e5/3ab'.
Testing scanf("%or%") on "-12.7x5/3ab":
    No exception.
    Result: `[-10]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%or%") on "-12x5/3ab":
    No exception.
    Result: `[-10]'.
    Remainder: `x5/3ab'.
Testing scanf("%or%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%or%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%or%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%or%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%or%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%or%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%or%") on "12/-3":
    No exception.
    Result: `[-10/3]'.
    Remainder: `'.
Testing scanf("%cor%") on "12":
    No exception.
    Result: `[10]'.
    Remainder: `'.
Testing scanf("%cor%") on "12ab":
    No exception.
    Result: `[10]'.
    Remainder: `ab'.
Testing scanf("%cor%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%cor%") on "12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%cor%") on "12/3":
    No exception.
    Result: `[10/3]'.
    Remainder: `'.
Testing scanf("%cor%") on "12/3ab":
    No exception.
    Result: `[10/3]'.
    Remainder: `ab'.
Testing scanf("%cor%") on "-12/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `ab'.
Testing scanf("%cor%") on "-12./3ab":
    No exception.
    Result: `[-54]'.
    Remainder: `./3ab'.
Testing scanf("%cor%") on "-12.7/3ab":
    No exception.
    Result: `[-54]'.
    Remainder: `.7/3ab'.
Testing scanf("%cor%") on "-12.7e5/3ab":
    No exception.
    Result: `[-54]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%cor%") on "-12e5/3ab":
    No exception.
    Result: `[-54]'.
    Remainder: `e5/3ab'.
Testing scanf("%cor%") on "-12.7x5/3ab":
    No exception.
    Result: `[-54]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%cor%") on "-12x5/3ab":
    No exception.
    Result: `[-54]'.
    Remainder: `x5/3ab'.
Testing scanf("%cor%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cor%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%cor%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cor%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cor%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cor%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cor%") on "12/-3":
    No exception.
    Result: `[-2]'.
    Remainder: `'.
Testing scanf("%xr%") on "12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%xr%") on "12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%xr%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%xr%") on "12/ab":
    No exception.
    Result: `[2/19]'.
    Remainder: `'.
Testing scanf("%xr%") on "12/3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%xr%") on "12/3ab":
    No exception.
    Result: `[6/313]'.
    Remainder: `'.
Testing scanf("%xr%") on "-12/3ab":
    No exception.
    Result: `[-6/313]'.
    Remainder: `'.
Testing scanf("%xr%") on "-12./3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `./3ab'.
Testing scanf("%xr%") on "-12.7/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7/3ab'.
Testing scanf("%xr%") on "-12.7e5/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%xr%") on "-12e5/3ab":
    No exception.
    Result: `[-4837/939]'.
    Remainder: `'.
Testing scanf("%xr%") on "-12.7x5/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%xr%") on "-12x5/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `x5/3ab'.
Testing scanf("%xr%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%xr%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%xr%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%xr%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%xr%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%xr%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%xr%") on "12/-3":
    No exception.
    Result: `[-6]'.
    Remainder: `'.
Testing scanf("%cxr%") on "12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cxr%") on "12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%cxr%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%cxr%") on "12/ab":
    No exception.
    Result: `[2/19]'.
    Remainder: `'.
Testing scanf("%cxr%") on "12/3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%cxr%") on "12/3ab":
    No exception.
    Result: `[6/313]'.
    Remainder: `'.
Testing scanf("%cxr%") on "-12/3ab":
    No exception.
    Result: `[-238/939]'.
    Remainder: `'.
Testing scanf("%cxr%") on "-12./3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `./3ab'.
Testing scanf("%cxr%") on "-12.7/3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7/3ab'.
Testing scanf("%cxr%") on "-12.7e5/3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%cxr%") on "-12e5/3ab":
    No exception.
    Result: `[-20233/313]'.
    Remainder: `'.
Testing scanf("%cxr%") on "-12.7x5/3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%cxr%") on "-12x5/3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `x5/3ab'.
Testing scanf("%cxr%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cxr%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%cxr%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cxr%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cxr%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cxr%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cxr%") on "12/-3":
    No exception.
    Result: `[-18/13]'.
    Remainder: `'.
Testing scanf("%r%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%r%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%r%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "12/3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%r%") on "12/3ab":
    No exception.
    Result: `[4]'.
    Remainder: `ab'.
Testing scanf("%r%") on "-12/3ab":
    No exception.
    Result: `[-4]'.
    Remainder: `ab'.
Testing scanf("%r%") on "-12./3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `./3ab'.
Testing scanf("%r%") on "-12.7/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7/3ab'.
Testing scanf("%r%") on "-12.7e5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%r%") on "-12e5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `e5/3ab'.
Testing scanf("%r%") on "-12.7x5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%r%") on "-12x5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `x5/3ab'.
Testing scanf("%r%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%r%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%r%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%r%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%r%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%r%") on "12/-3":
    No exception.
    Result: `[-4]'.
    Remainder: `'.
Testing scanf("%r%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%r%") on "0x12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%r%") on "0x12/":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0x12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0x12/3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%r%") on "0x12/3ab":
    No exception.
    Result: `[6]'.
    Remainder: `ab'.
Testing scanf("%r%") on "0x-12/3ab":
    No exception.
    Result: `[-6]'.
    Remainder: `ab'.
Testing scanf("%r%") on "0x-12./3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `./3ab'.
Testing scanf("%r%") on "0x-12.7/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7/3ab'.
Testing scanf("%r%") on "0x-12.7e5/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%r%") on "0x-12e5/3ab":
    No exception.
    Result: `[-4837/3]'.
    Remainder: `ab'.
Testing scanf("%r%") on "0x-12.7x5/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%r%") on "0x-12x5/3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `x5/3ab'.
Testing scanf("%r%") on "0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0xoo/":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0xoo/12":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0x12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%r%") on "0x12/-3":
    No exception.
    Result: `[-6]'.
    Remainder: `'.
Testing scanf("%r%") on "12/0xab":
    No exception.
    Result: `[4/57]'.
    Remainder: `'.
Testing scanf("%r%") on "12/0x3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%r%") on "12/0x3ab":
    No exception.
    Result: `[4/313]'.
    Remainder: `'.
Testing scanf("%r%") on "-12/0x3ab":
    No exception.
    Result: `[-4/313]'.
    Remainder: `'.
Testing scanf("%r%") on "-12./0x3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `./0x3ab'.
Testing scanf("%r%") on "-12.7/0x3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7/0x3ab'.
Testing scanf("%r%") on "-12.7e5/0x3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7e5/0x3ab'.
Testing scanf("%r%") on "-12e5/0x3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `e5/0x3ab'.
Testing scanf("%r%") on "-12.7x5/0x3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `.7x5/0x3ab'.
Testing scanf("%r%") on "-12x5/0x3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `x5/0x3ab'.
Testing scanf("%r%") on "oo/0x12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%r%") on "12/0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "12/0x-3":
    No exception.
    Result: `[-4]'.
    Remainder: `'.
Testing scanf("%r%") on "0x12/0xab":
    No exception.
    Result: `[2/19]'.
    Remainder: `'.
Testing scanf("%r%") on "0x12/0x3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%r%") on "0x12/0x3ab":
    No exception.
    Result: `[6/313]'.
    Remainder: `'.
Testing scanf("%r%") on "0x-12/0x3ab":
    No exception.
    Result: `[-6/313]'.
    Remainder: `'.
Testing scanf("%r%") on "0x-12./0x3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `./0x3ab'.
Testing scanf("%r%") on "0x-12.7/0x3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7/0x3ab'.
Testing scanf("%r%") on "0x-12.7e5/0x3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7e5/0x3ab'.
Testing scanf("%r%") on "0x-12e5/0x3ab":
    No exception.
    Result: `[-4837/939]'.
    Remainder: `'.
Testing scanf("%r%") on "0x-12.7x5/0x3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `.7x5/0x3ab'.
Testing scanf("%r%") on "0x-12x5/0x3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `x5/0x3ab'.
Testing scanf("%r%") on "0xoo/0x12":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0x12/0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%r%") on "0x12/0x-3":
    No exception.
    Result: `[-6]'.
    Remainder: `'.
Testing scanf("%cr%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cr%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cr%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "12/3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%cr%") on "12/3ab":
    No exception.
    Result: `[4]'.
    Remainder: `ab'.
Testing scanf("%cr%") on "-12/3ab":
    No exception.
    Result: `[-88/3]'.
    Remainder: `ab'.
Testing scanf("%cr%") on "-12./3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `./3ab'.
Testing scanf("%cr%") on "-12.7/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7/3ab'.
Testing scanf("%cr%") on "-12.7e5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%cr%") on "-12e5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `e5/3ab'.
Testing scanf("%cr%") on "-12.7x5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%cr%") on "-12x5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `x5/3ab'.
Testing scanf("%cr%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cr%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cr%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cr%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cr%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cr%") on "12/-3":
    No exception.
    Result: `[-12/7]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x12/":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0x12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0x12/3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x12/3ab":
    No exception.
    Result: `[6]'.
    Remainder: `ab'.
Testing scanf("%cr%") on "0x-12/3ab":
    No exception.
    Result: `[-238/3]'.
    Remainder: `ab'.
Testing scanf("%cr%") on "0x-12./3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `./3ab'.
Testing scanf("%cr%") on "0x-12.7/3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7/3ab'.
Testing scanf("%cr%") on "0x-12.7e5/3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7e5/3ab'.
Testing scanf("%cr%") on "0x-12e5/3ab":
    No exception.
    Result: `[-20233]'.
    Remainder: `ab'.
Testing scanf("%cr%") on "0x-12.7x5/3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7x5/3ab'.
Testing scanf("%cr%") on "0x-12x5/3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `x5/3ab'.
Testing scanf("%cr%") on "0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0xoo/":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0xoo/12":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0x12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x12/-3":
    No exception.
    Result: `[-18/7]'.
    Remainder: `'.
Testing scanf("%cr%") on "12/0xab":
    No exception.
    Result: `[4/57]'.
    Remainder: `'.
Testing scanf("%cr%") on "12/0x3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%cr%") on "12/0x3ab":
    No exception.
    Result: `[4/313]'.
    Remainder: `'.
Testing scanf("%cr%") on "-12/0x3ab":
    No exception.
    Result: `[-88/939]'.
    Remainder: `'.
Testing scanf("%cr%") on "-12./0x3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `./0x3ab'.
Testing scanf("%cr%") on "-12.7/0x3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7/0x3ab'.
Testing scanf("%cr%") on "-12.7e5/0x3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7e5/0x3ab'.
Testing scanf("%cr%") on "-12e5/0x3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `e5/0x3ab'.
Testing scanf("%cr%") on "-12.7x5/0x3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `.7x5/0x3ab'.
Testing scanf("%cr%") on "-12x5/0x3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `x5/0x3ab'.
Testing scanf("%cr%") on "oo/0x12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cr%") on "12/0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "12/0x-3":
    No exception.
    Result: `[-12/13]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x12/0xab":
    No exception.
    Result: `[2/19]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x12/0x3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x12/0x3ab":
    No exception.
    Result: `[6/313]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x-12/0x3ab":
    No exception.
    Result: `[-238/939]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x-12./0x3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `./0x3ab'.
Testing scanf("%cr%") on "0x-12.7/0x3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7/0x3ab'.
Testing scanf("%cr%") on "0x-12.7e5/0x3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7e5/0x3ab'.
Testing scanf("%cr%") on "0x-12e5/0x3ab":
    No exception.
    Result: `[-20233/313]'.
    Remainder: `'.
Testing scanf("%cr%") on "0x-12.7x5/0x3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `.7x5/0x3ab'.
Testing scanf("%cr%") on "0x-12x5/0x3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `x5/0x3ab'.
Testing scanf("%cr%") on "0xoo/0x12":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0x12/0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cr%") on "0x12/0x-3":
    No exception.
    Result: `[-18/13]'.
    Remainder: `'.
Testing scanf("%v%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%v%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%v%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "12/3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%v%") on "12/3ab":
    No exception.
    Result: `[4]'.
    Remainder: `ab'.
Testing scanf("%v%") on "-12/3ab":
    No exception.
    Result: `[-4]'.
    Remainder: `ab'.
Testing scanf("%v%") on "-12./3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "-12.7/3ab":
    No exception.
    Result: `[-127/10]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "-12.7e5/3ab":
    No exception.
    Result: `[-1270000]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "-12e5/3ab":
    No exception.
    Result: `[-1200000]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "-12.7x5/3ab":
    No exception.
    Result: `[-127/10]'.
    Remainder: `x5/3ab'.
Testing scanf("%v%") on "-12x5/3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `x5/3ab'.
Testing scanf("%v%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%v%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%v%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%v%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%v%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%v%") on "12/-3":
    No exception.
    Result: `[-4]'.
    Remainder: `'.
Testing scanf("%v%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%v%") on "0x12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%v%") on "0x12/":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0x12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0x12/3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%v%") on "0x12/3ab":
    No exception.
    Result: `[6]'.
    Remainder: `ab'.
Testing scanf("%v%") on "0x-12/3ab":
    No exception.
    Result: `[-6]'.
    Remainder: `ab'.
Testing scanf("%v%") on "0x-12./3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "0x-12.7/3ab":
    No exception.
    Result: `[-295/16]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "0x-12.7e5/3ab":
    No exception.
    Result: `[-75749/4096]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "0x-12e5/3ab":
    No exception.
    Result: `[-4837/3]'.
    Remainder: `ab'.
Testing scanf("%v%") on "0x-12.7x5/3ab":
    No exception.
    Result: `[-19333120]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "0x-12x5/3ab":
    No exception.
    Result: `[-18874368]'.
    Remainder: `/3ab'.
Testing scanf("%v%") on "0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0xoo/":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0xoo/12":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0x12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%v%") on "0x12/-3":
    No exception.
    Result: `[-6]'.
    Remainder: `'.
Testing scanf("%v%") on "12/0xab":
    No exception.
    Result: `[4/57]'.
    Remainder: `'.
Testing scanf("%v%") on "12/0x3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%v%") on "12/0x3ab":
    No exception.
    Result: `[4/313]'.
    Remainder: `'.
Testing scanf("%v%") on "-12/0x3ab":
    No exception.
    Result: `[-4/313]'.
    Remainder: `'.
Testing scanf("%v%") on "-12./0x3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "-12.7/0x3ab":
    No exception.
    Result: `[-127/10]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "-12.7e5/0x3ab":
    No exception.
    Result: `[-1270000]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "-12e5/0x3ab":
    No exception.
    Result: `[-1200000]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "-12.7x5/0x3ab":
    No exception.
    Result: `[-127/10]'.
    Remainder: `x5/0x3ab'.
Testing scanf("%v%") on "-12x5/0x3ab":
    No exception.
    Result: `[-12]'.
    Remainder: `x5/0x3ab'.
Testing scanf("%v%") on "oo/0x12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%v%") on "12/0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "12/0x-3":
    No exception.
    Result: `[-4]'.
    Remainder: `'.
Testing scanf("%v%") on "0x12/0xab":
    No exception.
    Result: `[2/19]'.
    Remainder: `'.
Testing scanf("%v%") on "0x12/0x3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%v%") on "0x12/0x3ab":
    No exception.
    Result: `[6/313]'.
    Remainder: `'.
Testing scanf("%v%") on "0x-12/0x3ab":
    No exception.
    Result: `[-6/313]'.
    Remainder: `'.
Testing scanf("%v%") on "0x-12./0x3ab":
    No exception.
    Result: `[-18]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "0x-12.7/0x3ab":
    No exception.
    Result: `[-295/16]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "0x-12.7e5/0x3ab":
    No exception.
    Result: `[-75749/4096]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "0x-12e5/0x3ab":
    No exception.
    Result: `[-4837/939]'.
    Remainder: `'.
Testing scanf("%v%") on "0x-12.7x5/0x3ab":
    No exception.
    Result: `[-19333120]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "0x-12x5/0x3ab":
    No exception.
    Result: `[-18874368]'.
    Remainder: `/0x3ab'.
Testing scanf("%v%") on "0xoo/0x12":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0x12/0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%v%") on "0x12/0x-3":
    No exception.
    Result: `[-6]'.
    Remainder: `'.
Testing scanf("%v%") on "true":
    No exception.
    Result: `[true]'.
    Remainder: `'.
Testing scanf("%v%") on "trueab":
    No exception.
    Result: `[true]'.
    Remainder: `ab'.
Testing scanf("%v%") on "false":
    No exception.
    Result: `[false]'.
    Remainder: `'.
Testing scanf("%v%") on "falseab":
    No exception.
    Result: `[false]'.
    Remainder: `ab'.
Testing scanf("%v%") on "null":
    No exception.
    Result: `[null]'.
    Remainder: `'.
Testing scanf("%v%") on "nullab":
    No exception.
    Result: `[null]'.
    Remainder: `ab'.
Testing scanf("%v%") on "\"abc\"":
    No exception.
    Result: `["abc"]'.
    Remainder: `'.
Testing scanf("%v%") on "\"abc":
    Exception: `Bad string value in scanf(): unexpected end-of-input.'.
Testing scanf("%v%") on "\"abc\"de":
    No exception.
    Result: `["abc"]'.
    Remainder: `de'.
Testing scanf("%v%") on "\"ab\\\"c\"":
    No exception.
    Result: `["ab\"c"]'.
    Remainder: `'.
Testing scanf("%v%") on "\"ab\\nc\"":
    No exception.
    Result: `["ab\nc"]'.
    Remainder: `'.
Testing scanf("%v%") on "\"ab\\\\c\"":
    No exception.
    Result: `["ab\\c"]'.
    Remainder: `'.
Testing scanf("%v%") on "\'a\'":
    No exception.
    Result: `['a']'.
    Remainder: `'.
Testing scanf("%v%") on "\'a\'b":
    No exception.
    Result: `['a']'.
    Remainder: `b'.
Testing scanf("%v%") on "\'a":
    Exception: `Bad character value in scanf(): missing close quote.'.
Testing scanf("%v%") on "\'ab\'":
    Exception: `Bad character value in scanf(): missing close quote.'.
Testing scanf("%v%") on "\'\\\'\'":
    No exception.
    Result: `['\'']'.
    Remainder: `'.
Testing scanf("%v%") on "\'\\\"\'":
    No exception.
    Result: `['\"']'.
    Remainder: `'.
Testing scanf("%v%") on "\'\\n\'":
    No exception.
    Result: `['\n']'.
    Remainder: `'.
Testing scanf("%v%") on "\'\\\\\'":
    No exception.
    Result: `['\\']'.
    Remainder: `'.
Testing scanf("%v%") on "@ab@":
    No exception.
    Result: `[@ab@]'.
    Remainder: `'.
Testing scanf("%v%") on "@ab":
    Exception: `Bad regular expression in scanf(): end-of-input encountered while parsing regular expression.'.
Testing scanf("%v%") on "@(a|b)*c@":
    No exception.
    Result: `[@(a|b)*c@]'.
    Remainder: `'.
Testing scanf("%v%") on "@ab\\@c@":
    No exception.
    Result: `[@ab\@c@]'.
    Remainder: `'.
Testing scanf("%v%") on "[1,2,3]":
    No exception.
    Result: `[[1, 2, 3]]'.
    Remainder: `'.
Testing scanf("%v%") on "[1,2,3]ab":
    No exception.
    Result: `[[1, 2, 3]]'.
    Remainder: `ab'.
Testing scanf("%v%") on "[ 1 , 2 , 3 ] ab":
    No exception.
    Result: `[[1, 2, 3]]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "[1, [2, 3], 4] ab":
    No exception.
    Result: `[[1, [2, 3], 4]]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "[1, [-2, 3], -4] ab":
    No exception.
    Result: `[[1, [-2, 3], -4]]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "[11, [-22, 31], -14] ab":
    No exception.
    Result: `[[11, [-22, 31], -14]]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "[11, a:=[-22, 31], -14] ab":
    No exception.
    Result: `[[11, a := [-22, 31], -14]]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "[11, a := [-22, 31], -14] ab":
    No exception.
    Result: `[[11, a := [-22, 31], -14]]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "<<>>":
    No exception.
    Result: `[<<>>]'.
    Remainder: `'.
Testing scanf("%v%") on "<<  >>":
    No exception.
    Result: `[<<>>]'.
    Remainder: `'.
Testing scanf("%v%") on "<<(*-->15)>>":
    No exception.
    Result: `[<<(* --> 15)>>]'.
    Remainder: `'.
Testing scanf("%v%") on "<<(3-->33),(4-->44)>>":
    No exception.
    Result: `[<<(3 --> 33), (4 --> 44)>>]'.
    Remainder: `'.
Testing scanf("%v%") on "<< ( 3 --> 33 ) , ( 4 --> 44 ) >> ab":
    No exception.
    Result: `[<<(3 --> 33), (4 --> 44)>>]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "<<(3 --> 33), (4 --> 44), (4 --> 45)>> ab":
    Exception: `Bad map value in scanf(): key value `4' appears more than once.'.
Testing scanf("%v%") on "<<(* --> 45), (3 --> 33), (4 --> 44)>> ab":
    No exception.
    Result: `[<<(* --> 45), (3 --> 33), (4 --> 44)>>]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "<<(3 --> 33), (4 --> 44), (* --> 45), (* -->55)>> ab":
    Exception: `Bad map value in scanf(): `*' appears more than once.'.
Testing scanf("%v%") on "<<(* --> -45), (3 --> 33), (4 --> 44)>> ab":
    No exception.
    Result: `[<<(* --> -45), (3 --> 33), (4 --> 44)>>]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "<<(* --> -45), (3 --> 33.7e-4), (4 --> 44.7)>> ab":
    No exception.
    Result: `[<<(* --> -45), (3 --> 337/100000), (4 --> 447/10)>>]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "{}":
    No exception.
    Result: `[type {}]'.
    Remainder: `'.
Testing scanf("%v%") on "{17,82}":
    No exception.
    Result: `[type {17, 82}]'.
    Remainder: `'.
Testing scanf("%v%") on "{ 17 , 82 } ab":
    No exception.
    Result: `[type {17, 82}]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "{17, 82, 17} ab":
    No exception.
    Result: `[type {17, 82}]'.
    Remainder: ` ab'.
Testing scanf("%v%") on "{17, 0x82, [a := -17]} ab":
    No exception.
    Result: `[type {17, 130, [a := -17]}]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "12":
    No exception.
    Result: `[12]'.
    Remainder: `'.
Testing scanf("%cv%") on "12ab":
    No exception.
    Result: `[12]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "12/":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "12/3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%cv%") on "12/3ab":
    No exception.
    Result: `[4]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "-12/3ab":
    No exception.
    Result: `[-88/3]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "-12./3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "-12.7/3ab":
    No exception.
    Result: `[-873/10]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "-12.7e5/3ab":
    No exception.
    Result: `[-8730000]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "-12e5/3ab":
    No exception.
    Result: `[-8800000]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "-12.7x5/3ab":
    No exception.
    Result: `[-873/10]'.
    Remainder: `x5/3ab'.
Testing scanf("%cv%") on "-12x5/3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `x5/3ab'.
Testing scanf("%cv%") on "oo":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cv%") on "oo/":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "oo/12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cv%") on "+oo":
    No exception.
    Result: `[+oo]'.
    Remainder: `'.
Testing scanf("%cv%") on "-oo":
    No exception.
    Result: `[-oo]'.
    Remainder: `'.
Testing scanf("%cv%") on "12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cv%") on "12/-3":
    No exception.
    Result: `[-12/7]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x12":
    No exception.
    Result: `[18]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x12ab":
    No exception.
    Result: `[4779]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x12/":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0x12/ab":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0x12/3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x12/3ab":
    No exception.
    Result: `[6]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "0x-12/3ab":
    No exception.
    Result: `[-238/3]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "0x-12./3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "0x-12.7/3ab":
    No exception.
    Result: `[-3801/16]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "0x-12.7e5/3ab":
    No exception.
    Result: `[-972827/4096]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "0x-12e5/3ab":
    No exception.
    Result: `[-20233]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "0x-12.7x5/3ab":
    No exception.
    Result: `[-249102336]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "0x-12x5/3ab":
    No exception.
    Result: `[-249561088]'.
    Remainder: `/3ab'.
Testing scanf("%cv%") on "0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0xoo/":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0xoo/12":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0x+oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0x-oo":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0x12/oo":
    No exception.
    Result: `[0]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x12/-3":
    No exception.
    Result: `[-18/7]'.
    Remainder: `'.
Testing scanf("%cv%") on "12/0xab":
    No exception.
    Result: `[4/57]'.
    Remainder: `'.
Testing scanf("%cv%") on "12/0x3":
    No exception.
    Result: `[4]'.
    Remainder: `'.
Testing scanf("%cv%") on "12/0x3ab":
    No exception.
    Result: `[4/313]'.
    Remainder: `'.
Testing scanf("%cv%") on "-12/0x3ab":
    No exception.
    Result: `[-88/939]'.
    Remainder: `'.
Testing scanf("%cv%") on "-12./0x3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "-12.7/0x3ab":
    No exception.
    Result: `[-873/10]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "-12.7e5/0x3ab":
    No exception.
    Result: `[-8730000]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "-12e5/0x3ab":
    No exception.
    Result: `[-8800000]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "-12.7x5/0x3ab":
    No exception.
    Result: `[-873/10]'.
    Remainder: `x5/0x3ab'.
Testing scanf("%cv%") on "-12x5/0x3ab":
    No exception.
    Result: `[-88]'.
    Remainder: `x5/0x3ab'.
Testing scanf("%cv%") on "oo/0x12":
    No exception.
    Result: `[1/0]'.
    Remainder: `'.
Testing scanf("%cv%") on "12/0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "12/0x-3":
    No exception.
    Result: `[-12/13]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x12/0xab":
    No exception.
    Result: `[2/19]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x12/0x3":
    No exception.
    Result: `[6]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x12/0x3ab":
    No exception.
    Result: `[6/313]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x-12/0x3ab":
    No exception.
    Result: `[-238/939]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x-12./0x3ab":
    No exception.
    Result: `[-238]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "0x-12.7/0x3ab":
    No exception.
    Result: `[-3801/16]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "0x-12.7e5/0x3ab":
    No exception.
    Result: `[-972827/4096]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "0x-12e5/0x3ab":
    No exception.
    Result: `[-20233/313]'.
    Remainder: `'.
Testing scanf("%cv%") on "0x-12.7x5/0x3ab":
    No exception.
    Result: `[-249102336]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "0x-12x5/0x3ab":
    No exception.
    Result: `[-249561088]'.
    Remainder: `/0x3ab'.
Testing scanf("%cv%") on "0xoo/0x12":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0x12/0xoo":
    Exception: `Expected digits not found.'.
Testing scanf("%cv%") on "0x12/0x-3":
    No exception.
    Result: `[-18/13]'.
    Remainder: `'.
Testing scanf("%cv%") on "true":
    No exception.
    Result: `[true]'.
    Remainder: `'.
Testing scanf("%cv%") on "trueab":
    No exception.
    Result: `[true]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "false":
    No exception.
    Result: `[false]'.
    Remainder: `'.
Testing scanf("%cv%") on "falseab":
    No exception.
    Result: `[false]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "null":
    No exception.
    Result: `[null]'.
    Remainder: `'.
Testing scanf("%cv%") on "nullab":
    No exception.
    Result: `[null]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "\"abc\"":
    No exception.
    Result: `["abc"]'.
    Remainder: `'.
Testing scanf("%cv%") on "\"abc":
    Exception: `Bad string value in scanf(): unexpected end-of-input.'.
Testing scanf("%cv%") on "\"abc\"de":
    No exception.
    Result: `["abc"]'.
    Remainder: `de'.
Testing scanf("%cv%") on "\"ab\\\"c\"":
    No exception.
    Result: `["ab\"c"]'.
    Remainder: `'.
Testing scanf("%cv%") on "\"ab\\nc\"":
    No exception.
    Result: `["ab\nc"]'.
    Remainder: `'.
Testing scanf("%cv%") on "\"ab\\\\c\"":
    No exception.
    Result: `["ab\\c"]'.
    Remainder: `'.
Testing scanf("%cv%") on "\'a\'":
    No exception.
    Result: `['a']'.
    Remainder: `'.
Testing scanf("%cv%") on "\'a\'b":
    No exception.
    Result: `['a']'.
    Remainder: `b'.
Testing scanf("%cv%") on "\'a":
    Exception: `Bad character value in scanf(): missing close quote.'.
Testing scanf("%cv%") on "\'ab\'":
    Exception: `Bad character value in scanf(): missing close quote.'.
Testing scanf("%cv%") on "\'\\\'\'":
    No exception.
    Result: `['\'']'.
    Remainder: `'.
Testing scanf("%cv%") on "\'\\\"\'":
    No exception.
    Result: `['\"']'.
    Remainder: `'.
Testing scanf("%cv%") on "\'\\n\'":
    No exception.
    Result: `['\n']'.
    Remainder: `'.
Testing scanf("%cv%") on "\'\\\\\'":
    No exception.
    Result: `['\\']'.
    Remainder: `'.
Testing scanf("%cv%") on "@ab@":
    No exception.
    Result: `[@ab@]'.
    Remainder: `'.
Testing scanf("%cv%") on "@ab":
    Exception: `Bad regular expression in scanf(): end-of-input encountered while parsing regular expression.'.
Testing scanf("%cv%") on "@(a|b)*c@":
    No exception.
    Result: `[@(a|b)*c@]'.
    Remainder: `'.
Testing scanf("%cv%") on "@ab\\@c@":
    No exception.
    Result: `[@ab\@c@]'.
    Remainder: `'.
Testing scanf("%cv%") on "[1,2,3]":
    No exception.
    Result: `[[1, 2, 3]]'.
    Remainder: `'.
Testing scanf("%cv%") on "[1,2,3]ab":
    No exception.
    Result: `[[1, 2, 3]]'.
    Remainder: `ab'.
Testing scanf("%cv%") on "[ 1 , 2 , 3 ] ab":
    No exception.
    Result: `[[1, 2, 3]]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "[1, [2, 3], 4] ab":
    No exception.
    Result: `[[1, [2, 3], 4]]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "[1, [-2, 3], -4] ab":
    No exception.
    Result: `[[1, [-8, 3], -6]]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "[11, [-22, 31], -14] ab":
    No exception.
    Result: `[[11, [-78, 31], -86]]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "[11, a:=[-22, 31], -14] ab":
    No exception.
    Result: `[[11, a := [-78, 31], -86]]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "[11, a := [-22, 31], -14] ab":
    No exception.
    Result: `[[11, a := [-78, 31], -86]]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "<<>>":
    No exception.
    Result: `[<<>>]'.
    Remainder: `'.
Testing scanf("%cv%") on "<<  >>":
    No exception.
    Result: `[<<>>]'.
    Remainder: `'.
Testing scanf("%cv%") on "<<(*-->15)>>":
    No exception.
    Result: `[<<(* --> 15)>>]'.
    Remainder: `'.
Testing scanf("%cv%") on "<<(3-->33),(4-->44)>>":
    No exception.
    Result: `[<<(3 --> 33), (4 --> 44)>>]'.
    Remainder: `'.
Testing scanf("%cv%") on "<< ( 3 --> 33 ) , ( 4 --> 44 ) >> ab":
    No exception.
    Result: `[<<(3 --> 33), (4 --> 44)>>]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "<<(3 --> 33), (4 --> 44), (4 --> 45)>> ab":
    Exception: `Bad map value in scanf(): key value `4' appears more than once.'.
Testing scanf("%cv%") on "<<(* --> 45), (3 --> 33), (4 --> 44)>> ab":
    No exception.
    Result: `[<<(* --> 45), (3 --> 33), (4 --> 44)>>]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "<<(3 --> 33), (4 --> 44), (* --> 45), (* -->55)>> ab":
    Exception: `Bad map value in scanf(): `*' appears more than once.'.
Testing scanf("%cv%") on "<<(* --> -45), (3 --> 33), (4 --> 44)>> ab":
    No exception.
    Result: `[<<(* --> -55), (3 --> 33), (4 --> 44)>>]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "<<(* --> -45), (3 --> 33.7e-4), (4 --> 44.7)>> ab":
    No exception.
    Result: `[<<(* --> -55), (3 --> 337/10000000), (4 --> 447/10)>>]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "{}":
    No exception.
    Result: `[type {}]'.
    Remainder: `'.
Testing scanf("%cv%") on "{17,82}":
    No exception.
    Result: `[type {17, 82}]'.
    Remainder: `'.
Testing scanf("%cv%") on "{ 17 , 82 } ab":
    No exception.
    Result: `[type {17, 82}]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "{17, 82, 17} ab":
    No exception.
    Result: `[type {17, 82}]'.
    Remainder: ` ab'.
Testing scanf("%cv%") on "{17, 0x82, [a := -17]} ab":
    No exception.
    Result: `[type {17, 130, [a := -83]}]'.
    Remainder: ` ab'.
Testing scanf("%v%, %v%, %v%") on "17, 18, 19":
    No exception.
    Result: `[17, 18, 19]'.
    Remainder: `'.
Testing scanf("%a:v%, %v%, %v%") on "17, 18, 19":
    No exception.
    Result: `[a := 17, 18, 19]'.
    Remainder: `'.
Testing scanf("%v%, %b:v%, %v%") on "17, 18, 19":
    No exception.
    Result: `[17, b := 18, 19]'.
    Remainder: `'.
Testing scanf("%v%, %v%, %c:v%") on "17, 18, 19":
    No exception.
    Result: `[17, 18, c := 19]'.
    Remainder: `'.
Testing scanf("%a:v%, %b:v%, %c:v%") on "17, 18, 19":
    No exception.
    Result: `[a := 17, b := 18, c := 19]'.
    Remainder: `'.
Testing scanf("%operator+:v%, %b:v%, %operator:::v%") on "17, 18, 19":
    No exception.
    Result: `[operator+ := 17, b := 18, operator:: := 19]'.
    Remainder: `'.
Testing return_a("type integer"):
    No exception.
    Result: `12'.
Testing return_a("type [12...14]"):
    No exception.
    Result: `12'.
Testing return_a("type [13...15]"):
    Exception: `The value returned from a function call didn't match the dynamic return type of the function because the value is 12 and the type is a subset of the integers that does not include that value.'.
Testing to_test(1, [2, 3], type integer, type integer):
    No exception.
Testing to_test(1, [2, 3], type [1...3], type [1...3]):
    No exception.
Testing to_test(1, [2, 3], type {2, 3}, type [1...3]):
    Exception: `The value of parameter number 1 in a routine call didn't match the dynamic type of that parameter because the value is 1 and the type is a subset of the integers that does not include that value.'.
Testing to_test(1, [2, 3], type [1...3], type {2, 3}):
    No exception.
Testing to_test(1, [2, 3], type [1...3], type {1, 3}):
    Exception: `The value of parameter number 2 in a routine call didn't match the dynamic type of that parameter because the type is a semi-labeled value list type and the value is a semi-labeled value list value for which the value for component 0 isn't in the type specified for this component by the semi-labeled value list type because the value is 2 and the type is a subset of the integers that does not include that value.'.
Testing [1, 2, 3]:
[1, 2, 3].
    No exception.
Testing aaa(1):
[    Exception: `The base argument to an iterate statement evaluated to something other than an array or semi-labeled value list that didn't have an `iterator' function.'.
Testing bbb(1):
[1].
    No exception.
Testing bbb(2):
[2, 7, 11, 17, 13, 5, 1].
    No exception.
Testing bbb(3):
[3, 5, 1].
    No exception.
Testing bbb(57):
[57, 43, 65, 49, 37, 7, 11, 17, 13, 5, 1].
    No exception.
Testing bbb(108):
[108, 325, 61, 23, 35, 53, 5, 1].
    No exception.
Testing bbb(108):
[108, 325, 61, 23, 35, 53, 5, 1].
    No exception.
Testing no_is_done(108):
[    Exception: `Unable to call is_done() on the iterator of an iterate statement.'.
Testing no_current(108):
[    Exception: `Unable to call current() on the iterator of an iterate statement.'.
Testing no_step(108):
[108    Exception: `Unable to call step() on the iterator of an iterate statement.'.
f(1): 4.
f(2): 5.
f(1): true.
f(2): false.
f1(1)(2): true.
f1(1)(0): false.
f2(1)(2): true.
f2(1)(0): false.
f3(1)(2): true.
f3(1)(0): false.
f7(2): true.
f7(0): false.
v1..t1: 12.
v1..t2: 13.
v2.x: 15.
v2.y: 16.
a1 == a1: true.
a1 == a2: false.
locks: Lock `a' (declared at "tests/multi.salm":5479:17) grabbed [1].
In single(f11()).
locks: Lock `a' (declared at "tests/multi.salm":5479:17) released [0].
A procedure named p1(): p1.
An anonymous procedure: routine_0xXXX.
A function named f1(): f1.
An anonymous function: routine_0xXXX.
A tagalong key named t1: t1.
An anonymous tagalong key: tagalong_key_0xXXX.
A lepton key named l1: l1.
A lepton l1[a := 10]: l1[a := 10].
An anonymous lepton key: lepton_key_0xXXX.
An anonymous lepton[a := 10]: lepton_key_0xXXX[a := 10].
A quark named q1: q1.
An anonymous quark: quark_0xXXX.
A lock named l2: l2.
An anonymous lock: lock_0xXXX.
A jump target named j1: j1.
The location of a variable named v1: &v1.
The location of an anonymous variable: &variable_0xXXX.
The location of a immutable named i1: &i1.
The location of an anonymous immutable: &variable_0xXXX.
The location of a lookup of 1: &v1[1].
The location of a lookup of 3...5: &v1[3...5].
The location of a lookup of *: &v1[*].
The location of a multi-dimensional lookup: &v1[1, 3...5, *].
The location of a field named f1: &v1.f1.
The location of a tagalong field named t1: &v1..t1.
The location of an anonymous tagalong field: &v1..tagalong_key_0xXXX.
The location of an overload &5->x: &operator->(5, "x", ...).
The location of &*&v1 where * is overloaded: &v1.
aaa: type interface[a : integer, b : string].
bbb: type interface[].
ccc: type interface[a : integer, b : string].
ddd: type interface[ia : integer].
eee: type interface[a : integer, b : string, ia : integer].
fff: type interface[ia : integer, ib : string].
ggg: type interface[a : integer, b : string, ia : integer, ib : string].
Point pp1a.
Point pp1b.
Point pp1e.
Point pp1c.
Point pp1g.
Point pp1j.
Point pp2a.
Point pp2b.
Point pp2c.
Point pp2f.
Point pp2d.
Point pp2k: `Type error on initialization: value 5 is not in type string because the value is not a string and the type is that of all strings.'.
Point pp2l.
Position 1.1: invalid (variable before instantiation).
Position 1.2: invalid (variable before instantiation).
Position 1.3: valid.
Position 1.4: valid.
Position 1.5: invalid (variable after de-allocation).
Position 2.1: invalid (routine before instantiation).
Position 2.2: invalid (routine before instantiation).
Position 2.3: valid.
Position 2.4: valid.
Position 2.5: invalid (routine after de-allocation).
Position 3.1: invalid (tagalong before instantiation).
Position 3.2: invalid (tagalong before instantiation).
Position 3.3: valid.
Position 3.4: valid.
Position 3.5: invalid (tagalong after de-allocation).
Position 4.1: invalid (lepton key before instantiation).
Position 4.2: invalid (lepton key before instantiation).
Position 4.3: valid.
Position 4.4: valid.
Position 4.5: invalid (lepton key after de-allocation).
Position 5.1: invalid (quark before instantiation).
Position 5.2: invalid (quark before instantiation).
Position 5.3: valid.
Position 5.4: valid.
Position 5.5: invalid (quark after de-allocation).
Position 6.1: invalid (lock before instantiation).
Position 6.2: invalid (lock before instantiation).
Position 6.3: valid.
Position 6.4: valid.
Position 6.5: invalid (lock after de-allocation).
Position 7.1: invalid (variable before instantiation).
Position 7.2: invalid (variable before instantiation).
Position 7.3: valid.
Position 7.4: valid.
Position 7.5: valid.
Position 7.6: invalid (variable after de-allocation).
Position 8.1: invalid (routine before instantiation).
Position 8.2: invalid (routine before instantiation).
Position 8.3: valid.
Position 8.4: valid.
Position 8.5: valid.
Position 8.6: invalid (routine after de-allocation).
Position 9.1: invalid (tagalong before instantiation).
Position 9.2: invalid (tagalong before instantiation).
Position 9.3: valid.
Position 9.4: valid.
Position 9.5: valid.
Position 9.6: invalid (tagalong after de-allocation).
Position 10.1: invalid (lepton key before instantiation).
Position 10.2: invalid (lepton key before instantiation).
Position 10.3: valid.
Position 10.4: valid.
Position 10.5: valid.
Position 10.6: invalid (lepton key after de-allocation).
Position 11.1: invalid (quark before instantiation).
Position 11.2: invalid (quark before instantiation).
Position 11.3: valid.
Position 11.4: valid.
Position 11.5: valid.
Position 11.6: invalid (quark after de-allocation).
Position 12.1: invalid (lock before instantiation).
Position 12.2: invalid (lock before instantiation).
Position 12.3: valid.
Position 12.4: valid.
Position 12.5: valid.
Position 12.6: invalid (lock after de-allocation).
Position 13.1: valid.
Position 13.2: invalid (variable after de-allocation).
Position 14.1: valid.
Position 14.2: invalid (routine after de-allocation).
Position 15.1: valid.
Position 15.2: invalid (tagalong after de-allocation).
Position 16.1: valid.
Position 16.2: invalid (lepton key after de-allocation).
Position 17.1: valid.
Position 17.2: invalid (quark after de-allocation).
Position 18.1: valid.
Position 18.2: invalid (lock after de-allocation).
Position 19.1: invalid (variable before instantiation).
Position 19.2: invalid (variable before instantiation).
Position 19.3: invalid (variable before instantiation).
Position 19.4: invalid (variable before instantiation).
Position 19.5: valid.
Position 19.6: valid.
Position 19.7: invalid (variable after de-allocation).
Position 19.8: invalid (variable after de-allocation).
Position 19.9: invalid (variable after de-allocation).
Position 19.10: invalid (variable after de-allocation).
Position 20.1: invalid (variable before instantiation).
Position 20.2: invalid (variable before instantiation).
Position 20.3: invalid (variable before instantiation).
Position 20.4: invalid (variable before instantiation).
Position 20.5: valid.
Position 20.6: valid.
Position 20.7: invalid (variable after de-allocation).
Position 20.8: invalid (variable after de-allocation).
Position 20.9: invalid (variable after de-allocation).
Position 20.10: invalid (variable after de-allocation).
Position 21.1: invalid (variable before instantiation).
Position 21.2: invalid (variable before instantiation).
Position 21.3: invalid (variable before instantiation).
Position 21.4: invalid (variable before instantiation).
Position 21.5: valid.
Position 21.6: valid.
Position 21.7: invalid (variable after de-allocation).
Position 21.8: invalid (variable after de-allocation).
Position 21.9: invalid (variable after de-allocation).
Position 21.10: invalid (variable after de-allocation).
Position 22.1: invalid (variable before instantiation).
Position 22.2: invalid (variable before instantiation).
Position 22.3: invalid (variable before instantiation).
Position 22.4: invalid (variable before instantiation).
Position 22.5: valid.
Position 22.6: valid.
Position 22.7: invalid (variable after de-allocation).
Position 22.8: invalid (variable after de-allocation).
Position 22.9: invalid (variable after de-allocation).
Position 22.10: invalid (variable after de-allocation).
Position 23.1: invalid (variable before instantiation).
Position 23.2: invalid (variable before instantiation).
Position 23.3: invalid (variable before instantiation).
Position 23.4: invalid (variable before instantiation).
Position 23.5: valid.
Position 23.6: valid.
Position 23.7: invalid (variable after de-allocation).
Position 23.8: invalid (variable after de-allocation).
Position 23.9: invalid (variable after de-allocation).
Position 23.10: invalid (variable after de-allocation).
Position 24.1: invalid (variable before instantiation).
Position 24.2: invalid (variable before instantiation).
Position 24.3: invalid (variable before instantiation).
Position 24.4: invalid (variable before instantiation).
Position 24.5: valid.
Position 24.6: invalid (variable before instantiation).
Position 24.7: valid.
Position 24.8: valid.
Position 24.9: invalid (variable after de-allocation).
Position 24.10: invalid (variable after de-allocation).
Position 24.11: valid.
Position 24.12: invalid (variable after de-allocation).
Position 24.13: valid.
Position 24.14: invalid (variable after de-allocation).
Position 24.15: valid.
Position 24.16: invalid (variable after de-allocation).
Position 24.17: invalid (variable after de-allocation).
Position 24.18: valid.
Position 25.1: invalid (variable before instantiation).
Position 25.2: invalid (variable before instantiation).
Position 25.3: invalid (variable before instantiation).
Position 25.4: invalid (variable before instantiation).
Position 25.5: valid.
Position 25.6: invalid (variable before instantiation).
Position 25.7: valid.
Position 25.8: valid.
Position 25.9: invalid (variable after de-allocation).
Position 25.10: invalid (variable after de-allocation).
Position 25.11: valid.
Position 25.12: invalid (variable after de-allocation).
Position 25.13: valid.
Position 25.14: invalid (variable after de-allocation).
Position 25.15: valid.
Position 25.16: invalid (variable after de-allocation).
Position 25.17: invalid (variable after de-allocation).
Position 25.18: valid.
Position 26.1: valid.
Position 26.2: valid.
Position 26.3: invalid (object after de-allocation).
Position 26.4: invalid (object after de-allocation).
Position 26.5: valid.
Position 26.6: invalid (object after de-allocation).
Position 26.7: valid.
Position 26.8: invalid (object after de-allocation).
Position 26.9: valid.
Position 26.10: invalid (object after de-allocation).
Position 26.11: invalid (object after de-allocation).
Position 26.12: valid.
Position 27.1: valid.
Position 27.2: valid.
Position 27.3: invalid (jump target after de-allocation).
Position 27.4: valid.
Position 27.5: invalid (jump target after de-allocation).
Position 27.6: valid.
Position 27.7: invalid (jump target after de-allocation).
Position 27.8: valid.
Position 27.9: invalid (jump target after de-allocation).
Position 27.10: valid.
Position 28.1: valid.
Position 28.2: valid.
Position 28.3: invalid (variable after de-allocation).
Position 28.4: invalid (variable after de-allocation).
Position 29.1: invalid (variable before instantiation).
Position 29.2: invalid (variable before instantiation).
Position 29.3: invalid (variable before instantiation).
Position 29.4: invalid (variable before instantiation).
Position 29.5: valid.
Position 29.6: invalid (variable before instantiation).
Position 29.7: valid.
Position 29.8: valid.
Position 29.9: invalid (variable after de-allocation).
Position 29.10: invalid (variable after de-allocation).
Position 29.11: valid.
Position 29.12: invalid (variable after de-allocation).
Position 29.13: valid.
Position 29.14: invalid (variable after de-allocation).
Position 29.15: valid.
Position 29.16: invalid (variable after de-allocation).
Position 29.17: invalid (variable after de-allocation).
Position 29.18: valid.
Position 30.1: invalid (variable before instantiation).
Position 30.2: invalid (variable before instantiation).
Position 30.3: invalid (variable before instantiation).
Position 30.4: invalid (variable before instantiation).
Position 30.5: valid.
Position 30.6: invalid (variable before instantiation).
Position 30.7: valid.
Position 30.8: valid.
Position 30.9: invalid (variable after de-allocation).
Position 30.10: invalid (variable after de-allocation).
Position 30.11: valid.
Position 30.12: invalid (variable after de-allocation).
Position 30.13: valid.
Position 30.14: invalid (variable after de-allocation).
Position 30.15: valid.
Position 30.16: invalid (variable after de-allocation).
Position 30.17: invalid (variable after de-allocation).
Position 30.18: valid.
Position 31.1: invalid (variable before instantiation).
Position 31.2: invalid (variable before instantiation).
Position 31.3: invalid (variable before instantiation).
Position 31.4: invalid (variable before instantiation).
Position 31.5: valid.
Position 31.6: invalid (variable before instantiation).
Position 31.7: valid.
Position 31.8: valid.
Position 31.9: invalid (variable after de-allocation).
Position 31.10: invalid (variable after de-allocation).
Position 31.11: valid.
Position 31.12: invalid (variable after de-allocation).
Position 31.13: valid.
Position 31.14: invalid (variable after de-allocation).
Position 31.15: valid.
Position 31.16: invalid (variable after de-allocation).
Position 31.17: invalid (variable after de-allocation).
Position 31.18: valid.
Position 32.1: invalid (variable before instantiation).
Position 32.2: invalid (variable before instantiation).
Position 32.3: invalid (variable before instantiation).
Position 32.4: invalid (variable before instantiation).
Position 32.5: valid.
Position 32.6: invalid (variable before instantiation).
Position 32.7: valid.
Position 32.8: valid.
Position 32.9: invalid (variable after de-allocation).
Position 32.10: invalid (variable after de-allocation).
Position 32.11: valid.
Position 32.12: invalid (variable after de-allocation).
Position 32.13: valid.
Position 32.14: invalid (variable after de-allocation).
Position 32.15: valid.
Position 32.16: invalid (variable after de-allocation).
Position 32.17: invalid (variable after de-allocation).
Position 32.18: valid.
Position 33.1: invalid (variable before instantiation).
Position 33.2: invalid (variable before instantiation).
Position 33.3: invalid (variable before instantiation).
Position 33.4: invalid (variable before instantiation).
Position 33.5: valid.
Position 33.6: invalid (variable before instantiation).
Position 33.7: valid.
Position 33.8: valid.
Position 33.9: invalid (variable after de-allocation).
Position 33.10: invalid (variable after de-allocation).
Position 33.11: valid.
Position 33.12: invalid (variable after de-allocation).
Position 33.13: valid.
Position 33.14: invalid (variable after de-allocation).
Position 33.15: valid.
Position 33.16: invalid (variable after de-allocation).
Position 33.17: invalid (variable after de-allocation).
Position 33.18: valid.
Position 34.1: invalid (variable before instantiation).
Position 34.2: invalid (variable before instantiation).
Position 34.3: invalid (variable before instantiation).
Position 34.4: invalid (variable before instantiation).
Position 34.5: valid.
Position 34.6: invalid (variable before instantiation).
Position 34.7: valid.
Position 34.8: valid.
Position 34.9: invalid (variable after de-allocation).
Position 34.10: invalid (variable after de-allocation).
Position 34.11: valid.
Position 34.12: invalid (variable after de-allocation).
Position 34.13: valid.
Position 34.14: invalid (variable after de-allocation).
Position 34.15: valid.
Position 34.16: invalid (variable after de-allocation).
Position 34.17: invalid (variable after de-allocation).
Position 34.18: valid.
Position 35.1: invalid (routine before instantiation).
Position 35.2: invalid (routine before instantiation).
Position 35.3: invalid (routine before instantiation).
Position 35.4: invalid (routine before instantiation).
Position 35.5: valid.
Position 35.6: valid.
Position 35.7: invalid (routine after de-allocation).
Position 35.8: invalid (routine after de-allocation).
Position 36.1: invalid (variable before instantiation).
Position 36.2: invalid (variable before instantiation).
Position 36.3: invalid (variable before instantiation).
Position 36.4: invalid (variable before instantiation).
Position 36.5: invalid (variable before instantiation).
Position 36.6: invalid (variable before instantiation).
Position 36.7: invalid (variable before instantiation).
Position 36.8: invalid (variable before instantiation).
Position 36.9: valid.
Position 36.10: invalid (variable before instantiation).
Position 36.11: invalid (variable before instantiation).
Position 36.12: invalid (variable before instantiation).
Position 36.13: valid.
Position 36.14: invalid (variable before instantiation).
Position 36.15: invalid (variable before instantiation).
Position 36.16: invalid (variable before instantiation).
Position 36.17: valid.
Position 36.18: valid.
Position 36.19: valid.
Position 36.20: valid.
Position 36.21: valid.
Position 36.22: valid.
Position 36.23: valid.
Position 36.24: valid.
Position 36.25: invalid (variable after de-allocation).
Position 36.26: valid.
Position 36.27: invalid (variable after de-allocation).
Position 36.28: invalid (variable after de-allocation).
Position 36.29: invalid (variable after de-allocation).
Position 36.30: valid.
Position 36.31: invalid (variable after de-allocation).
Position 36.32: invalid (variable after de-allocation).
Position 36.33: invalid (variable after de-allocation).
Position 36.34: invalid (variable after de-allocation).
Position 36.35: invalid (variable after de-allocation).
Position 36.36: invalid (variable after de-allocation).
Position 36.37: invalid (variable after de-allocation).
Position 36.38: invalid (variable after de-allocation).
Position 36.39: invalid (variable after de-allocation).
Position 36.40: invalid (variable after de-allocation).
Position 37.1: invalid (variable before instantiation).
Position 37.2: invalid (variable before instantiation).
Position 37.3: invalid (variable before instantiation).
Position 37.4: invalid (variable before instantiation).
Position 37.5: invalid (variable before instantiation).
Position 37.6: invalid (variable before instantiation).
Position 37.7: invalid (variable before instantiation).
Position 37.8: invalid (variable before instantiation).
Position 37.9: valid.
Position 37.10: invalid (variable before instantiation).
Position 37.11: invalid (variable before instantiation).
Position 37.12: invalid (variable before instantiation).
Position 37.13: valid.
Position 37.14: invalid (variable before instantiation).
Position 37.15: invalid (variable before instantiation).
Position 37.16: invalid (variable before instantiation).
Position 37.17: valid.
Position 37.18: valid.
Position 37.19: valid.
Position 37.20: valid.
Position 37.21: valid.
Position 37.22: valid.
Position 37.23: valid.
Position 37.24: valid.
Position 37.25: invalid (variable after de-allocation).
Position 37.26: valid.
Position 37.27: invalid (variable after de-allocation).
Position 37.28: invalid (variable after de-allocation).
Position 37.29: invalid (variable after de-allocation).
Position 37.30: valid.
Position 37.31: invalid (variable after de-allocation).
Position 37.32: invalid (variable after de-allocation).
Position 37.33: invalid (routine after de-allocation).
Position 37.34: invalid (routine after de-allocation).
Position 37.35: invalid (routine after de-allocation).
Position 37.36: invalid (routine after de-allocation).
Position 37.37: invalid (routine after de-allocation).
Position 37.38: invalid (routine after de-allocation).
Position 37.39: invalid (routine after de-allocation).
Position 37.40: invalid (routine after de-allocation).
Position 38.1: invalid (variable before instantiation).
Position 38.2: invalid (variable before instantiation).
Position 38.3: invalid (variable before instantiation).
Position 38.4: invalid (variable before instantiation).
Position 38.5: invalid (variable before instantiation).
Position 38.6: invalid (variable before instantiation).
Position 38.7: invalid (variable before instantiation).
Position 38.8: invalid (variable before instantiation).
Position 38.9: valid.
Position 38.10: invalid (variable before instantiation).
Position 38.11: invalid (variable before instantiation).
Position 38.12: invalid (variable before instantiation).
Position 38.13: valid.
Position 38.14: invalid (variable before instantiation).
Position 38.15: invalid (variable before instantiation).
Position 38.16: invalid (variable before instantiation).
Position 38.17: valid.
Position 38.18: valid.
Position 38.19: valid.
Position 38.20: valid.
Position 38.21: valid.
Position 38.22: valid.
Position 38.23: valid.
Position 38.24: valid.
Position 38.25: invalid (variable after de-allocation).
Position 38.26: valid.
Position 38.27: invalid (variable after de-allocation).
Position 38.28: invalid (variable after de-allocation).
Position 38.29: invalid (variable after de-allocation).
Position 38.30: valid.
Position 38.31: invalid (variable after de-allocation).
Position 38.32: invalid (variable after de-allocation).
Position 38.33: invalid (variable after de-allocation).
Position 38.34: invalid (variable after de-allocation).
Position 38.35: invalid (variable after de-allocation).
Position 38.36: invalid (variable after de-allocation).
Position 38.37: invalid (variable after de-allocation).
Position 38.38: invalid (variable after de-allocation).
Position 38.39: invalid (variable after de-allocation).
Position 38.40: invalid (variable after de-allocation).
Position 39.1: valid.
Position 39.2: invalid (variable before instantiation).
Position 39.3: invalid (variable before instantiation).
Position 39.4: invalid (variable before instantiation).
Position 39.5: invalid (variable before instantiation).
Position 39.6: invalid (variable before instantiation).
Position 39.7: valid.
Position 39.8: invalid (variable before instantiation).
Position 39.9: invalid (variable before instantiation).
Position 39.10: invalid (variable before instantiation).
Position 39.11: invalid (variable before instantiation).
Position 39.12: invalid (variable before instantiation).
Position 39.13: valid.
Position 39.14: invalid (variable before instantiation).
Position 39.15: valid.
Position 39.16: valid.
Position 39.17: invalid (variable before instantiation).
Position 39.18: invalid (variable before instantiation).
Position 39.19: valid.
Position 39.20: invalid (variable before instantiation).
Position 39.21: valid.
Position 39.22: valid.
Position 39.23: invalid (variable before instantiation).
Position 39.24: invalid (variable before instantiation).
Position 39.25: valid.
Position 39.26: valid.
Position 39.27: valid.
Position 39.28: valid.
Position 39.29: valid.
Position 39.30: valid.
Position 39.31: valid.
Position 39.32: valid.
Position 39.33: valid.
Position 39.34: valid.
Position 39.35: valid.
Position 39.36: valid.
Position 39.37: valid.
Position 39.38: valid.
Position 39.39: invalid (variable after de-allocation).
Position 39.40: invalid (variable after de-allocation).
Position 39.41: invalid (variable after de-allocation).
Position 39.42: invalid (variable after de-allocation).
Position 39.43: valid.
Position 39.44: valid.
Position 39.45: invalid (variable after de-allocation).
Position 39.46: invalid (variable after de-allocation).
Position 39.47: invalid (variable after de-allocation).
Position 39.48: invalid (variable after de-allocation).
Position 39.49: invalid (routine after de-allocation).
Position 39.50: invalid (routine after de-allocation).
Position 39.51: invalid (variable after de-allocation).
Position 39.52: invalid (routine after de-allocation).
Position 39.53: invalid (routine after de-allocation).
Position 39.54: invalid (variable after de-allocation).
Position 39.55: invalid (routine after de-allocation).
Position 39.56: invalid (routine after de-allocation).
Position 39.57: invalid (variable after de-allocation).
Position 39.58: invalid (routine after de-allocation).
Position 39.59: invalid (routine after de-allocation).
Position 39.60: invalid (variable after de-allocation).
Position 39.61: invalid (routine after de-allocation).
Position 39.62: invalid (variable after de-allocation).
Position 39.63: invalid (variable after de-allocation).
Position 39.64: invalid (routine after de-allocation).
Position 39.65: invalid (variable after de-allocation).
Position 39.66: invalid (variable after de-allocation).
Position 39.67: invalid (routine after de-allocation).
Position 39.68: invalid (variable after de-allocation).
Position 39.69: invalid (variable after de-allocation).
Position 39.70: invalid (routine after de-allocation).
Position 39.71: invalid (variable after de-allocation).
Position 39.72: invalid (variable after de-allocation).
Position 40.1: invalid (tagalong before instantiation).
Position 40.2: invalid (tagalong before instantiation).
Position 40.3: invalid (variable before instantiation).
Position 40.4: invalid (variable before instantiation).
Position 40.5: invalid (tagalong before instantiation).
Position 40.6: invalid (tagalong before instantiation).
Position 40.7: invalid (variable before instantiation).
Position 40.8: invalid (variable before instantiation).
Position 40.9: invalid (variable before instantiation).
Position 40.10: invalid (tagalong before instantiation).
Position 40.11: invalid (variable before instantiation).
Position 40.12: invalid (variable before instantiation).
Position 40.13: invalid (variable before instantiation).
Position 40.14: invalid (tagalong before instantiation).
Position 40.15: invalid (variable before instantiation).
Position 40.16: invalid (variable before instantiation).
Position 40.17: valid.
Position 40.18: invalid (tagalong before instantiation).
Position 40.19: invalid (variable before instantiation).
Position 40.20: invalid (variable before instantiation).
Position 40.21: valid.
Position 40.22: invalid (tagalong before instantiation).
Position 40.23: invalid (variable before instantiation).
Position 40.24: invalid (variable before instantiation).
Position 40.25: valid.
Position 40.26: invalid (tagalong before instantiation).
Position 40.27: valid.
Position 40.28: invalid (tagalong before instantiation).
Position 40.29: valid.
Position 40.30: invalid (tagalong before instantiation).
Position 40.31: valid.
Position 40.32: invalid (tagalong before instantiation).
Position 40.33: valid.
Position 40.34: valid.
Position 40.35: valid.
Position 40.36: valid.
Position 40.37: valid.
Position 40.38: valid.
Position 40.39: valid.
Position 40.40: valid.
Position 40.41: invalid (tagalong after de-allocation).
Position 40.42: valid.
Position 40.43: invalid (tagalong after de-allocation).
Position 40.44: valid.
Position 40.45: invalid (tagalong after de-allocation).
Position 40.46: valid.
Position 40.47: invalid (tagalong after de-allocation).
Position 40.48: valid.
Position 40.49: invalid (tagalong after de-allocation).
Position 40.50: invalid (variable after de-allocation).
Position 40.51: invalid (tagalong after de-allocation).
Position 40.52: invalid (variable after de-allocation).
Position 40.53: invalid (tagalong after de-allocation).
Position 40.54: invalid (variable after de-allocation).
Position 40.55: invalid (tagalong after de-allocation).
Position 40.56: invalid (variable after de-allocation).
Position 40.57: invalid (tagalong after de-allocation).
Position 40.58: invalid (variable after de-allocation).
Position 40.59: invalid (variable after de-allocation).
Position 40.60: invalid (variable after de-allocation).
Position 40.61: invalid (tagalong after de-allocation).
Position 40.62: invalid (variable after de-allocation).
Position 40.63: invalid (variable after de-allocation).
Position 40.64: invalid (variable after de-allocation).
Position 40.65: invalid (tagalong after de-allocation).
Position 40.66: invalid (tagalong after de-allocation).
Position 40.67: invalid (variable after de-allocation).
Position 40.68: invalid (variable after de-allocation).
Position 40.69: invalid (tagalong after de-allocation).
Position 40.70: invalid (tagalong after de-allocation).
Position 40.71: invalid (variable after de-allocation).
Position 40.72: invalid (variable after de-allocation).
Position 41.1: invalid (routine before instantiation).
Position 41.2: invalid (variable before instantiation).
Position 41.3: invalid (quark before instantiation).
Position 41.4: invalid (variable before instantiation).
Position 41.5: invalid (routine before instantiation).
Position 41.6: invalid (variable before instantiation).
Position 41.7: invalid (quark before instantiation).
Position 41.8: invalid (variable before instantiation).
Position 41.9: invalid (routine before instantiation).
Position 41.10: invalid (routine before instantiation).
Position 41.11: invalid (quark before instantiation).
Position 41.12: invalid (quark before instantiation).
Position 41.13: invalid (routine before instantiation).
Position 41.14: invalid (routine before instantiation).
Position 41.15: invalid (quark before instantiation).
Position 41.16: invalid (quark before instantiation).
Position 41.17: valid.
Position 41.18: valid.
Position 41.19: invalid (quark before instantiation).
Position 41.20: invalid (quark before instantiation).
Position 41.21: valid.
Position 41.22: valid.
Position 41.23: invalid (quark before instantiation).
Position 41.24: invalid (quark before instantiation).
Position 41.25: valid.
Position 41.26: valid.
Position 41.27: valid.
Position 41.28: valid.
Position 41.29: valid.
Position 41.30: valid.
Position 41.31: valid.
Position 41.32: valid.
Position 41.33: valid.
Position 41.34: invalid (variable after de-allocation).
Position 41.35: valid.
Position 41.36: invalid (variable after de-allocation).
Position 41.37: valid.
Position 41.38: invalid (variable after de-allocation).
Position 41.39: valid.
Position 41.40: invalid (variable after de-allocation).
Position 41.41: invalid (routine after de-allocation).
Position 41.42: invalid (variable after de-allocation).
Position 41.43: invalid (routine after de-allocation).
Position 41.44: invalid (variable after de-allocation).
Position 41.45: invalid (routine after de-allocation).
Position 41.46: invalid (variable after de-allocation).
Position 41.47: invalid (routine after de-allocation).
Position 41.48: invalid (variable after de-allocation).
Position 41.49: invalid (routine after de-allocation).
Position 41.50: invalid (variable after de-allocation).
Position 41.51: invalid (quark after de-allocation).
Position 41.52: invalid (variable after de-allocation).
Position 41.53: invalid (routine after de-allocation).
Position 41.54: invalid (variable after de-allocation).
Position 41.55: invalid (quark after de-allocation).
Position 41.56: invalid (variable after de-allocation).
Position 42.1: invalid (routine before instantiation).
Position 42.2: invalid (variable before instantiation).
Position 42.3: invalid (routine before instantiation).
Position 42.4: invalid (variable before instantiation).
Position 42.5: invalid (routine before instantiation).
Position 42.6: invalid (variable before instantiation).
Position 42.7: invalid (routine before instantiation).
Position 42.8: invalid (variable before instantiation).
Position 42.9: invalid (routine before instantiation).
Position 42.10: invalid (routine before instantiation).
Position 42.11: invalid (routine before instantiation).
Position 42.12: invalid (routine before instantiation).
Position 42.13: invalid (routine before instantiation).
Position 42.14: invalid (routine before instantiation).
Position 42.15: invalid (routine before instantiation).
Position 42.16: invalid (routine before instantiation).
Position 42.17: valid.
Position 42.18: valid.
Position 42.19: valid.
Position 42.20: valid.
Position 42.21: valid.
Position 42.22: valid.
Position 42.23: valid.
Position 42.24: valid.
Position 42.25: valid.
Position 42.26: valid.
Position 42.27: invalid (routine after de-allocation).
Position 42.28: invalid (routine after de-allocation).
Position 42.29: valid.
Position 42.30: valid.
Position 42.31: invalid (routine after de-allocation).
Position 42.32: invalid (routine after de-allocation).
Position 42.33: valid.
Position 42.34: invalid (variable after de-allocation).
Position 42.35: invalid (routine after de-allocation).
Position 42.36: invalid (variable after de-allocation).
Position 42.37: valid.
Position 42.38: invalid (variable after de-allocation).
Position 42.39: invalid (routine after de-allocation).
Position 42.40: invalid (variable after de-allocation).
Position 42.41: invalid (routine after de-allocation).
Position 42.42: invalid (variable after de-allocation).
Position 42.43: invalid (routine after de-allocation).
Position 42.44: invalid (variable after de-allocation).
Position 42.45: invalid (routine after de-allocation).
Position 42.46: invalid (variable after de-allocation).
Position 42.47: invalid (routine after de-allocation).
Position 42.48: invalid (variable after de-allocation).
Position 42.49: invalid (routine after de-allocation).
Position 42.50: invalid (variable after de-allocation).
Position 42.51: invalid (routine after de-allocation).
Position 42.52: invalid (variable after de-allocation).
Position 42.53: invalid (object after de-allocation).
Position 42.54: invalid (variable after de-allocation).
Position 43.1: invalid (routine before instantiation).
Position 43.2: invalid (routine before instantiation).
Position 43.3: invalid (routine before instantiation).
Position 43.4: invalid (routine before instantiation).
Position 43.5: invalid (routine before instantiation).
Position 43.6: invalid (routine before instantiation).
Position 43.7: invalid (routine before instantiation).
Position 43.8: invalid (routine before instantiation).
Position 43.9: valid.
Position 43.10: invalid (variable before instantiation).
Position 43.11: valid.
Position 43.12: invalid (variable before instantiation).
Position 43.13: valid.
Position 43.14: valid.
Position 43.15: valid.
Position 43.16: valid.
Position 43.17: invalid (variable after de-allocation).
Position 43.18: valid.
Position 43.19: invalid (variable after de-allocation).
Position 43.20: valid.
Position 43.21: invalid (routine after de-allocation).
Position 43.22: invalid (routine after de-allocation).
Position 43.23: invalid (routine after de-allocation).
Position 43.24: invalid (routine after de-allocation).
Position 43.25: invalid (routine after de-allocation).
Position 43.26: invalid (routine after de-allocation).
Position 43.27: invalid (routine after de-allocation).
Position 43.28: invalid (routine after de-allocation).
Position 44.1: valid.
Position 44.2: valid.
Position 44.3: valid.
Position 44.4: valid.
Position 44.5: valid.
Position 44.6: valid.
Position 44.7: valid.
Position 44.8: valid.
Position 44.9: valid.
Position 44.10: valid.
Position 44.11: valid.
Position 44.12: valid.
Position 44.13: valid.
Position 44.14: valid.
Position 44.15: valid.
Position 44.16: valid.
Position 44.17: valid.
Position 44.18: valid.
Position 44.19: valid.
Position 44.20: valid.
Position 44.21: valid.
Position 44.22: valid.
Position 44.23: valid.
Position 44.24: valid.
Position 44.25: valid.
Position 44.26: valid.
Position 44.27: valid.
Position 44.28: valid.
Position 44.29: valid.
Position 44.30: valid.
Position 44.31: valid.
Position 44.32: valid.
Position 44.33: valid.
Position 44.34: valid.
Position 44.35: valid.
Position 44.36: valid.
Position 44.37: valid.
Position 44.38: valid.
Position 44.39: valid.
Position 44.40: valid.
Position 44.41: invalid (routine after de-allocation).
Position 44.42: valid.
Position 44.43: invalid (routine after de-allocation).
Position 44.44: invalid (routine after de-allocation).
Position 44.45: valid.
Position 44.46: invalid (routine after de-allocation).
Position 44.47: invalid (routine after de-allocation).
Position 44.48: invalid (routine after de-allocation).
Position 44.49: invalid (routine after de-allocation).
Position 44.50: invalid (routine after de-allocation).
Position 44.51: invalid (routine after de-allocation).
Position 44.52: invalid (routine after de-allocation).
Position 44.53: invalid (routine after de-allocation).
Position 44.54: invalid (routine after de-allocation).
Position 44.55: invalid (routine after de-allocation).
Position 44.56: invalid (routine after de-allocation).
Position 44.57: invalid (routine after de-allocation).
Position 44.58: invalid (routine after de-allocation).
Position 44.59: invalid (routine after de-allocation).
Position 44.60: invalid (routine after de-allocation).
Position 44.61: invalid (routine after de-allocation).
Position 44.62: invalid (quark after de-allocation).
Position 44.63: invalid (quark after de-allocation).
Position 44.64: invalid (routine after de-allocation).
Position 44.65: invalid (quark after de-allocation).
Position 44.66: invalid (quark after de-allocation).
Position 44.67: invalid (quark after de-allocation).
Position 44.68: invalid (quark after de-allocation).
Position 44.69: invalid (quark after de-allocation).
Position 44.70: invalid (quark after de-allocation).
Position 44.71: invalid (routine after de-allocation).
Position 44.72: invalid (routine after de-allocation).
Position 44.73: invalid (routine after de-allocation).
Position 44.74: invalid (quark after de-allocation).
Position 44.75: invalid (quark after de-allocation).
Position 44.76: invalid (quark after de-allocation).
Position 44.77: invalid (quark after de-allocation).
Position 44.78: invalid (quark after de-allocation).
Position 44.79: invalid (quark after de-allocation).
Position 44.80: invalid (quark after de-allocation).
Position 45.1: valid.
Position 45.2: valid.
Position 45.3: valid.
Position 45.4: valid.
Position 45.5: invalid (lepton key after de-allocation).
Position 45.6: invalid (lepton key after de-allocation).
Position 45.7: invalid (routine after de-allocation).
Position 45.8: invalid (routine after de-allocation).
Position 45.9: invalid (quark after de-allocation).
Position 45.10: invalid (quark after de-allocation).
Position 46.1: invalid (routine before instantiation).
Position 46.2: invalid (routine before instantiation).
Position 46.3: valid.
Position 46.4: valid.
Position 46.5: invalid (routine after de-allocation).
Position 46.6: invalid (routine after de-allocation).
Position 47.1: valid.
Position 47.2: valid.
Position 47.3: invalid (routine after de-allocation).
Position 48.1: valid.
Position 48.2: valid.
Position 48.3: invalid (routine after de-allocation).
Starting theorem tests.
Done with theorem tests.
a: 5.
b: 7.
a: 5.
b: 7.
a: 9.
b: 11.
a: 11.
b: 11.
a: 13.
b: 13.
a: 15.
b: 15.
system: `15 15'.
system: `15 15'.
system: `9 15'.
system: `9 15'.
a: 9.
b: 15.
a: 17.
b: 15.
a: 17.
b: 19.
p1().
v1: 5.
v1: 7.
v2: 8.
i1: 9.
a1: 3.
i1..t1: 4.
File "multi_include.salm" line 1.
File "multi_include.salm" line 2.
p1().
p2(5).
p2(7).
p1().
p2(9).
p2(11).
p1().
p2(13).
p2(15).
x: <<(* --> "blue"), (3 --> "red"), (5 --> "green")>>.
x: <<(* --> "blue"), (3 --> "yellow"), (4 --> "black"), (5 --> "green")>>.
x: <<(* --> "blue"), (3 --> "red"), (5 --> "green")>>.
x: <<(* --> "purple"), (3 --> "yellow"), (4 --> "black")>>.
About to delete t1.
c1() closing.
t1 has now been deleted.
About to delete t2.
c3() closing.
t2 has now been deleted.
2
3
1
Exception: `Type error on assignment: value 4 is not in type {} because no value is in the empty type.'.
1
2
5
1
Exception: `An attempt was made to modify immutable `i1' (declared at "tests/multi.salm":7353:19).'.
1
locks: Lock `a' (declared at "tests/multi.salm":7390:10) grabbed [1].
locks: Lock `a' (declared at "tests/multi.salm":7390:10) grabbed [2].
locks: Lock `a' (declared at "tests/multi.salm":7390:10) released [1].
locks: Lock `a' (declared at "tests/multi.salm":7390:10) released [0].
<<(1 --> "one"), (2 --> "two"), (3 --> "three"), (4 --> "four"), (5 --> "five"), (6 --> "Six"), (7 --> "seven"), (*: type is_one_hundreds --> "hundred"), (type is_thousands --> "thousands")>>
<<(1 --> "one"), (2 --> "two"), (3 --> "three"), (4 --> "four"), (5 --> "five"), (6 --> "Six"), (7 --> "Seven"), (*: type is_one_hundreds --> "hundred"), (*: type is_two_hundreds --> "two hundred"), (type is_thousands --> "thousands")>>
<<(1 --> "one"), (2 --> "two"), (3 --> "three"), (4 --> "four"), (5 --> "five"), (6 --> "Six"), (7 --> "Seven"), (*: type is_one_hundreds --> "hundred"), (*: type is_two_hundreds --> "two hundred"), (8 --> "Eight"), (*: type is_three_hundreds --> "three hundred"), (type is_thousands --> "thousands")>>
<<(1 --> "one"), (2 --> "two"), (3 --> "three"), (4 --> "four"), (5 --> "five"), (6 --> "Six"), (7 --> "Seven"), (*: type is_one_hundreds --> "hundred"), (*: type is_two_hundreds --> "two hundred"), (8 --> "Eight"), (*: type is_three_hundreds --> "three hundred"), (9 --> "Nine"), (type is_thousands --> "thousands"), (*: [400...499] --> "four hundred")>>
<<(1 --> "one"), (2 --> "two"), (3 --> "three"), (4 --> "four"), (5 --> "five"), (6 --> "Six"), (7 --> "Seven"), (*: type is_one_hundreds --> "hundred"), (*: type is_two_hundreds --> "two hundred"), (8 --> "Eight"), (*: type is_three_hundreds --> "three hundred"), (9 --> "Nine"), (type is_thousands --> "thousands"), (*: [400...499] --> "four hundred"), (10 --> "Ten")>>
<<(1 --> "one"), (2 --> "two"), (3 --> "three"), (4 --> "four"), (5 --> "five"), (6 --> "Six"), (7 --> "seven"), (*: type is_one_hundreds --> "hundred"), (type is_thousands --> "thousands")>>
<<(1 --> "one"), (2 --> "two"), (3 --> "three"), (4 --> "four"), (5 --> "Five"), (6 --> "Six"), (7 --> "Seven"), (*: type is_one_hundreds --> "hundred"), (*: type is_two_hundreds --> "two hundred"), (8 --> "Eight"), (*: type is_three_hundreds --> "three hundred"), (9 --> "Nine"), (type is_thousands --> "thousands"), (*: [400...499] --> "four hundred"), (10 --> "Ten")>>
four
Five
<<(1 --> "one"), (2 --> "Two"), (3 --> "three"), (4 --> "four"), (5 --> "Five"), (6 --> "Six"), (7 --> "Seven"), (*: type is_one_hundreds --> "hundred"), (*: type is_two_hundreds --> "two hundred"), (8 --> "Eight"), (*: type is_three_hundreds --> "three hundred"), (9 --> "Nine"), (type is_thousands --> "thousands"), (*: [400...499] --> "four hundred"), (10 --> "Ten"), (11 --> "eleven"), (12 --> "twelve"), (13 --> "thirteen"), (14 --> "fourteen"), (15 --> "fifteen")>>
four
Five
fifteen
[0...5]: 012345
[0...5): 01234
(0...5]: 12345
(0...5): 1234
AA point 1.
AA point 2.
AA cleaned up.
AA point 3.
BB point 1.
BB point 2.
BB cleaned up.
BB point 3.
CC point 1.
CC point 2.
CC cleaned up.
CC point 3.
Starting AA.
Cleaning up AA.
Finished AA.
Starting BB.
Cleaning up BB.
Finished BB.
Starting CC.
Cleaning up CC.
Finished CC.
<<(0 --> "d"), (1 --> "b"), (2 --> "c")>>
<<(0 --> "a"), (1 --> "e"), (2 --> "c")>>
<<(0 --> "a"), (1 --> "b"), (*: [2...+oo] --> "d")>>
<<(0 --> "a"), (1 --> "e"), (2 --> "c")>>
Starting variable_field test.
Cleaning up variable_field.
Finished variable_field test.
Starting immutable_field test.
Cleaning up immutable_field.
Finished immutable_field test.
Starting procedure_field test.
Cleaning up procedure_field.
Finished procedure_field test.
Starting lepton_field test.
Cleaning up lepton_field.
Finished lepton_field test.
Starting lock_field test.
Cleaning up lock_field.
Finished lock_field test.
Starting quark_field test.
Cleaning up quark_field.
Finished quark_field test.
Starting tagalong_field test.
Cleaning up tagalong_field.
Finished tagalong_field test.
Starting filter_type test.
Cleaning up filter_type.
Finished filter_type test.
Starting enumeration_type test.
Cleaning up enumeration_type.
Finished enumeration_type test.
Starting not_type test.
Cleaning up not_type.
Finished not_type test.
Starting intersection_type test.
Cleaning up intersection_type.
Finished intersection_type test.
Starting union_type test.
Cleaning up union_type.
Finished union_type test.
Starting xor_type test.
Cleaning up xor_type.
Finished xor_type test.
Starting array_type test.
Cleaning up array_type.
Finished array_type test.
Starting pointer_type test.
Cleaning up pointer_type.
Finished pointer_type test.
Starting type_type test.
Cleaning up type_type.
Finished type_type test.
Starting map_type test.
Cleaning up map_type.
Finished map_type test.
Starting routine_type test.
Cleaning up routine_type.
Finished routine_type test.
Starting fields_type test.
Cleaning up fields_type.
Finished fields_type test.
Starting lepton_type test.
Cleaning up lepton_type.
Finished lepton_type test.
Starting multiset_type test.
Cleaning up multiset_type.
Finished multiset_type test.
Starting interface_type test.
Cleaning up interface_type.
Finished interface_type test.
Starting semi_labeled_value_list_type test.
Cleaning up semi_labeled_value_list_type.
Finished semi_labeled_value_list_type test.
Starting class_type test.
Cleaning up class_type.
Finished class_type test.
Starting overloaded_filter_type test.
Cleaning up overloaded_filter_type.
Finished overloaded_filter_type test.
Starting semi_labeled_value_list test.
Cleaning up semi_labeled_value_list.
Finished semi_labeled_value_list test.
Starting semi_labeled_multi_set test.
Cleaning up semi_labeled_multi_set.
Finished semi_labeled_multi_set test.
Starting map_value_key test.
Cleaning up map_value_key.
Finished map_value_key test.
Starting map_type_key test.
Cleaning up map_type_key.
Finished map_type_key test.
Starting quark_value test.
Cleaning up quark_value.
Finished quark_value test.
Starting lepton_value test.
Cleaning up lepton_value.
Finished lepton_value test.
Starting lepton_key_value test.
Cleaning up lepton_key_value.
Finished lepton_key_value test.
Starting slot_location_value test.
Cleaning up slot_location_value.
Finished slot_location_value test.
Starting routine_value test.
Cleaning up routine_value.
Finished routine_value test.
Starting routine_chain_value test.
Cleaning up routine_chain_value.
Finished routine_chain_value test.
Starting object_value test.
Cleaning up object_value.
Finished object_value test.
Starting tagalong_key_value test.
Cleaning up tagalong_key_value.
Finished tagalong_key_value test.
Starting lock_value test.
Cleaning up lock_value.
Finished lock_value test.
Starting variable_value test.
Cleaning up variable_value.
Finished variable_value test.
Starting variable_type test.
Cleaning up variable_type.
Finished variable_type test.
Starting variable_lock test.
Cleaning up variable_lock.
Finished variable_lock test.
Starting function_return_type test.
Cleaning up function_return_type.
Finished function_return_type test.
Starting function_argument_type test.
Cleaning up function_argument_type.
Finished function_argument_type test.
Starting function_lock test.
Cleaning up function_lock.
Finished function_lock test.
Starting lepton_field_type test.
Cleaning up lepton_field_type.
Finished lepton_field_type test.
Starting lock_lock test.
Cleaning up lock_lock.
Finished lock_lock test.
Starting tagalong_type test.
Cleaning up tagalong_type.
Finished tagalong_type test.
Starting tagalong_on_type test.
Cleaning up tagalong_on_type.
Finished tagalong_on_type test.
Starting tagalong_default test.
Cleaning up tagalong_default.
Finished tagalong_default test.
Starting tagalong_lock test.
Cleaning up tagalong_lock.
Finished tagalong_lock test.
Starting lookup1 test.
Cleaning up lookup1.
Finished lookup1 test.
Starting lookup2 test.
Cleaning up lookup2.
Finished lookup2 test.
Starting lookup3 test.
Cleaning up lookup3.
Finished lookup3 test.
Starting slot_field test.
Cleaning up slot_field.
Finished slot_field test.
Starting slot_tagalong test.
Cleaning up slot_tagalong.
Finished slot_tagalong test.
Starting big test.
Cleaning up big.
Finished big test.
Starting map-object test.
Finished map-object test.
Starting second map-object test.
Finished second map-object test.
Starting third map-object test.
Finished third map-object test.
["a", "b", "c"]
<<(0 --> "a"), (1 --> "f"), (2 --> "c")>>
<<(0 --> "a"), (1 --> "e"), (2 --> "c")>>
<<(0 --> "a"), (1 --> "f"), (2 --> "c")>>
<<(0 --> "d"), (1 --> "e"), (2 --> "c")>>
<<(0 --> "a"), (1 --> "f"), (2 --> "c")>>
201
Exception caught: [exception[tag := exception_tag_variable_use_after_deallocation, message := "Variable `v1\' (declared at \"tests/multi.salm\":8464:13) was used after it had been deallocated.", source := source_region[file_name := "tests/multi.salm", start_line := 8471, start_column := 16, end_line := 8471, end_column := 77], call_stack := []]].
0: numerator = 0, denominator = 1.
1: numerator = 1, denominator = 1.
2: numerator = 2, denominator = 1.
-1: numerator = -1, denominator = 1.
1/3: numerator = 1, denominator = 3.
-1/3: numerator = -1, denominator = 3.
-oo: numerator = -oo, denominator = 1.
+oo: numerator = +oo, denominator = 1.
1/0: numerator = 1/0, denominator = 1.
0/0: numerator = 0/0, denominator = 1.
No exception.
Caught [exception_tag_call_return_type_mismatch]: `The value returned from a function call didn't match the static return type of the function because the type requires that a field named `c' exist, but the value has no such field.'.
Caught [exception_tag_pure_virtual_no_override]: `The statement block containing a pure virtual routine (routine `p1' (declared at "tests/multi.salm":8558:32)) was entered without an override for that routine.'.
Caught [exception_tag_pure_virtual_no_override]: `The statement block containing a pure virtual routine (routine `p1' (declared at "tests/multi.salm":8562:17)) was entered without an override for that routine.'.
Caught [exception_tag_pure_virtual_no_override]: `The statement block containing a pure virtual routine (routine `p1' (declared at "tests/multi.salm":8562:17)) was entered without an override for that routine.'.
No exception.
%d% on 0x10000000000: 1099511627776.
%x% on 1099511627776: 10000000000.
%x% on 0x10000000000: 10000000000.
%d% on 3e33: 3000000000000000000000000000000000.
%x% on 3e33: 93e952cda8b9aa44111e00000000.
%d% on 0x93e952cda8b9aa44111e00000000: 3000000000000000000000000000000000.
%x% on 3e3: bb8.
%d% on 0xbb8: 3000.
%x% on 3e5: 493e0.
%d% on 0x493e0: 300000.
%x% on 3e7: 1c9c380.
%d% on 0x1c9c380: 30000000.
%x% on 3e8: 11e1a300.
%d% on 0x11e1a300: 300000000.
%x% on 3e9: b2d05e00.
%d% on 0xb2d05e00: 3000000000.
%x% on 3e10: 6fc23ac00.
%d% on 0x6fc23ac00: 30000000000.
x: blue.
y: 13.
a: a.
b: b.
Exception: exception_tag_use_unbound_remains.
a: a.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
c: a.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
a: b.
b: a.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
b: b.
Exception: exception_tag_use_unbound_remains.
a: a.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
Exception: exception_tag_use_unbound_remains.
Passed first use test of "multi_name_reference.salm".
Passed second use test of "multi_name_reference.salm".
Passed third use test of "multi_name_reference.salm".
Passed fourth use test of "multi_name_reference.salm".
Passed fifth use test of "multi_name_reference.salm".
1
Caught exception exception_tag_object_use_after_deallocation.
Julia
Nicole
Wilson
Benjamin
Hoyt
Wilson
q1 in (integer | {q1}): true.
q1 in !(integer | {q1}): false.
q1 in (!(integer)) & (!{q1}): false.
q1 in (!(integer)): true.
q1 in (!{q1}): false.
Exception: exception_tag_call_return_type_mismatch.
i1: 6.
outer_i1: 5.
bbb: 3.
ccc: 5.
aaa.bbb: 3.
aaa.ccc: 5.
Exception: exception_tag_lookup_bad_base.
"abc"[0]: a.
"abc"[1]: b.
"abc"[2]: c.
"abc"[0...1]: ab.
"abc"[1...2]: bc.
v1: abc.
v1: dbc.
v1: dec.
v1: fgc.
v1: fhi.
to_utf8(v1): [102, 207, 128, 105].
v1[0]: f.
to_utf8(v1[1]): [207, 128].
v1[2]: i.
to_utf8(v1): [102, 240, 147, 129, 182, 105].
v1[0]: f.
to_utf8(v1[1]): [240, 147, 129, 182].
v1[2]: i.
"abc"[0]: 97.
"abc"[1]: 98.
"abc"[2]: 99.
"abc"[0...1]: ab.
"abc"[1...2]: bc.
v1: abc.
v1: dbc.
v1: dec.
v1: fgc.
v1: fhi.
to_utf8(v1): [102, 207, 128, 105].
v1[0]: 102.
v1[1]: 207.
v1[2]: 128.
v1[3]: 105.
to_utf8(v1): [102, 240, 147, 129, 182, 105].
v1[0]: 102.
v1[1]: 240.
v1[2]: 147.
v1[3]: 129.
v1[4]: 182.
v1[5]: 105.
"abc"[0]: 97.
"abc"[1]: 98.
"abc"[2]: 99.
"abc"[0...1]: ab.
"abc"[1...2]: bc.
v1: abc.
v1: dbc.
v1: dec.
v1: fgc.
v1: fhi.
to_utf8(v1): [102, 207, 128, 105].
v1[0]: 102.
v1[1]: 0x3c0.
v1[2]: 105.
to_utf8(v1): [102, 240, 147, 129, 182, 105].
v1[0]: 102.
v1[1]: 0xd80c.
v1[2]: 0xdc76.
v1[3]: 105.
"abc"[0]: 97.
"abc"[1]: 98.
"abc"[2]: 99.
"abc"[0...1]: ab.
"abc"[1...2]: bc.
v1: abc.
v1: dbc.
v1: dec.
v1: fgc.
v1: fhi.
to_utf8(v1): [102, 207, 128, 105].
v1[0]: 102.
v1[1]: 0x3c0.
v1[2]: 105.
to_utf8(v1): [102, 240, 147, 129, 182, 105].
v1[0]: 102.
v1[1]: 0x13076.
v1[2]: 105.
a: 1.
b: butter.
a: 2.
b: milk.
a: 2.
b: milk.
a: 4.
b: flour.
a: butter.
b: 1.
a: 17.
b: butter.
a: 1.
b: butter.
*v1: 1.
Exception: exception_tag_immutable_modification.
a: 1.
Exception: exception_tag_variable_use_after_deallocation.
i1.a: 1.
i1.b: butter.
i1.c: 15.
i1.a: butter.
i1.b: 1.
i1.c: 15.
A: 1.
A: 2.
A: 3.
A: 4.
A: 5.
A: 6.
A: 7.
A: 8.
A: 9.
A: 10.
B: 1.
B: 4.
B: 9.
B: 16.
B: 25.
B: 36.
B: 49.
B: 64.
B: 81.
B: 100.
C: 1.
C: 4.
C: 9.
C: 16.
C: 25.
C: 36.
C: 49.
C: 64.
C: 81.
C: 100.
D: 1.
D: 4.
D: 9.
D: 16.
D: 25.
D: 36.
D: 49.
D: 64.
D: 81.
D: 100.
E: 1.
E: 9.
E: 25.
E: 49.
E: 81.
F: 1.
F: 4.
F: 9.
F: 16.
G: 9.
G: 36.
G: 81.
H: 1.
H: 4.
H: 9.
H: 16.
H: 25.
H: 36.
H: 64.
H: 81.
H: 100.
I: 1.
I: 4.
I: 9.
I: 16.
I: 25.
I: 36.
A: 2.
A: 4.
A: 6.
B: 1.
B: 2.
B: 3.
B: 4.
C: 1.
C: 2.
C: 3.
C: 4.
C: 6.
D: 2.
D: 4.
D: 6.
E: 1.
E: 2.
E: 3.
E: 4.
F: 1.
F: 2.
F: 3.
F: 4.
F: 6.
p1(): No exception.
p1() A: exception_tag_lookup_bad_base.
p1() A: exception_tag_immutable_modification.
p1() A: exception_tag_pointer_field_reference_bad_base.
p2(): No exception.
p2() B: exception_tag_lookup_bad_base.
p2() C: exception_tag_immutable_modification.
p2() D: exception_tag_pointer_field_reference_bad_base.
p3(): No exception.
p3() B: exception_tag_lookup_bad_base.
p3() B: exception_tag_immutable_modification.
p3() C: exception_tag_pointer_field_reference_bad_base.
First line: "To be, or not to be;".
Second line: "that is the question.".
Third line: end_of_input.
Exception from throw(): exception[tag := et_test, message := "This is a test.", source := source_region[file_name := "", start_line := 0/0, start_column := 0/0, end_line := 0/0, end_column := 0/0], call_stack := [[callee_name := "throw", callee := source_region[file_name := "standard_built_ins.c", start_line := 3225, start_column := 11, end_line := 3234, end_column := 4], call_site := source_region[file_name := "tests/multi.salm", start_line := 9347, start_column := 9, end_line := 9347, end_column := 42]]]].
