/* file "type.c" */

/*
 *  This file contains the implementation of the type module.
 *
 *  This file is part of SalmonEye, an interpreter for the Salmon Programming
 *  Language.
 *
 *  Written by Chris Wilson.
 *
 *  This file is hearby placed in the public domain by its author.
 */


#include <stdlib.h>
#include <stddef.h>
#include <assert.h>
#include <string.h>
#include <stdarg.h>
#include "c_foundations/basic.h"
#include "c_foundations/memory_allocation.h"
#include "c_foundations/string_index.h"
#include "c_foundations/auto_array.h"
#include "c_foundations/buffer_print.h"
#include "c_foundations/auto_array_implementation.h"
#include "type.h"
#include "value.h"
#include "regular_expression.h"
#include "lepton_key_instance.h"
#include "routine_instance.h"
#include "routine_instance_chain.h"
#include "context.h"
#include "semi_labeled_value_list.h"
#include "execute.h"
#include "unicode.h"
#include "object.h"
#include "driver.h"
#include "source_location.h"
#include "validator.h"
#include "parser.h"
#include "reference_cluster.h"
#include "platform_dependent.h"
#include "thread.h"
#include "expression.h"
#include "utility.h"


AUTO_ARRAY(value_aa, value *);
AUTO_ARRAY(type_aa, type *);


typedef struct
  {
    const char *string;
    size_t the_size_t;
  } size_t_and_string;

typedef struct
  {
    size_t field_count;
    type **field_types;
    char **field_names;
    boolean *field_can_be_empty;
    boolean extra_fields_allowed;
    string_index *allowed_fields;
    boolean slippery;
  } field_type_info;

typedef struct
  {
    o_integer lower_bound;
    o_integer upper_bound;
  } integer_range_component;

typedef struct
  {
    rational *lower_bound;
    rational *upper_bound;
    boolean lower_is_inclusive;
    boolean upper_is_inclusive;
  } rational_range_component;

typedef unsigned long possible_value_kinds_bit_type;
#define VK_BIT(x) (((possible_value_kinds_bit_type)1) << (x))

struct type
  {
    type_kind kind;
    union
      {
        struct
          {
            size_t value_count;
            value **values;
            boolean slippery;
          } enumeration;
        struct
          {
            type *base;
          } not;
        struct
          {
            type *left;
            type *right;
          } intersection;
        struct
          {
            type *left;
            type *right;
          } union_type;
        struct
          {
            type *left;
            type *right;
          } xor;
        struct
          {
            type *base;
            o_integer lower_bound;
            o_integer upper_bound;
          } array;
        struct
          {
            size_t component_count;
            integer_range_component *components;
            boolean includes_positive_infinity;
            boolean includes_negative_infinity;
            boolean includes_unsigned_infinity;
            boolean includes_zero_zero;
          } integer_ranges;
        struct
          {
            size_t component_count;
            rational_range_component *components;
            boolean includes_positive_infinity;
            boolean includes_negative_infinity;
            boolean includes_unsigned_infinity;
            boolean includes_zero_zero;
          } rational_ranges;
        struct
          {
            type *base;
            boolean read_allowed;
            boolean write_allowed;
            boolean null_allowed;
          } pointer;
        struct
          {
            type *base;
            boolean slippery;
          } type;
        struct
          {
            type *key;
            type *target;
            boolean slippery;
          } map;
        struct
          {
            type *return_type;
            size_t argument_count;
            type **argument_types;
            char **argument_names;
            boolean *argument_has_defaults;
            boolean extra_arguments_allowed;
            boolean extra_arguments_unspecified;
            boolean slippery;
          } routine;
        struct
          {
            field_type_info field_info;
          } fields;
        struct
          {
            lepton_key_instance *key;
            field_type_info field_info;
          } lepton;
        struct
          {
            field_type_info field_info;
          } multiset;
        struct
          {
            field_type_info field_info;
            boolean *item_writing_alloweds;
            boolean null_allowed;
          } interface;
        struct
          {
            size_t element_count;
            type **element_types;
            char **element_names;
            boolean extra_elements_allowed;
            string_index *allowed_fields;
            boolean slippery;
          } semi_labeled_value_list;
        struct
          {
            regular_expression *regular_expression;
          } regular_expression;
        struct
          {
            routine_instance *routine;
          } class;
        struct
          {
            routine_instance *test_routine;
            type_aa provisional_subsets;
            type_aa provisional_supersets;
          } test_routine;
        struct
          {
            routine_instance_chain *routine_chain;
          } test_routine_chain;
      } u;
    possible_value_kinds_bit_type possible_value_kinds;
    reference_cluster *reference_cluster;
    validator *validator;
    DECLARE_SYSTEM_LOCK(reference_lock);
    size_t reference_count;
  };


static possible_value_kinds_bit_type all_possible_value_kinds;
static type *anything_type = NULL;
static type *nothing_type = NULL;
static type *integer_type = NULL;
static type *finite_integer_type = NULL;
static type *rational_type = NULL;
static type *any_regular_expression_type = NULL;
static type *any_quark_type = NULL;
static type *any_lepton_type = NULL;
static type *lepton_key_type = NULL;
static type *jump_target_type = NULL;
static type *any_class_type = NULL;
static type *object_type = NULL;
static type *any_tagalong_key_type = NULL;
static type *lock_type = NULL;
static type *string_type = NULL;
static type *character_type = NULL;
static type *boolean_type = NULL;
DECLARE_SYSTEM_LOCK(saved_shift_type_function_expression_lock);
static expression *saved_shift_type_function_expression = NULL;
DECLARE_SYSTEM_LOCK(saved_shift_type_function_value_lock);
static value *saved_shift_type_function_value = NULL;
DECLARE_SYSTEM_LOCK(provisional_subset_outer_lock);
DECLARE_SYSTEM_LOCK(provisional_subset_inner_lock);
static salmon_thread *provisional_subset_owner = NULL;


static type *create_empty_type(type_kind kind);
static string_index *make_allowed_fields_index(size_t field_count,
                                               char **field_names);
static boolean compound_value_uses_banned_field(value *compound_value,
        string_index *allowed_fields, const char **bad_field_name);
static boolean object_value_uses_banned_field(value *object_value,
        string_index *allowed_fields, const char **bad_field_name);
static boolean test_value_with_function(value *the_value,
        value *function_base_value, const source_location *location,
        jumper *the_jumper);
static boolean routine_instance_chain_is_in_routine_type(
        routine_instance_chain *instance_chain, type *the_type, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper);
static boolean routine_always_matches_type_parameters(
        routine_instance *the_routine_instance, type *routine_type,
        boolean *doubt, char **why_not, const source_location *location,
        jumper *the_jumper);
static boolean check_for_routine_argument_type_match(
        routine_instance *the_routine_instance, type *routine_type,
        size_t routine_num, routine_instance_chain *next_instance_chain,
        boolean previous_doubt, boolean *local_match, boolean *doubt,
        boolean *local_doubt, char **why_not, const source_location *location,
        jumper *the_jumper);
static type *block_out_part_of_routine_type(type *routine_type, size_t arg_num,
                                            type *to_block);
static boolean check_for_routine_argument_and_return_type_match(
        routine_instance_chain *instance_chain, type *the_type,
        size_t routine_num, boolean previous_doubt, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper);
static boolean routine_type_hits_routine(type *routine_type,
        routine_instance *instance, boolean *doubt,
        const source_location *location, jumper *the_jumper);
static int compare_generic_values(const void *left, const void *right);
static int compare_size_t_and_string(const void *left, const void *right);
static int compare_o_integers(const void *left, const void *right);
static int compare_rationals(const void *left, const void *right);
static boolean possibly_nothing(type *the_type);
static boolean possibly_everything(type *the_type);
static boolean enumeration_has_only_string_values(type *the_type);
static boolean array_and_map_are_equal(type *array_type, type *map_type,
        boolean *doubt, const source_location *location, jumper *the_jumper);
static boolean array_and_semi_labeled_value_list_are_equal(type *array_type,
        type *semi_labeled_value_list_type, boolean *doubt,
        const source_location *location, jumper *the_jumper);
static boolean semi_labeled_value_list_and_map_are_equal(
        type *semi_labeled_value_list_type, type *map_type, boolean *doubt,
        const source_location *location, jumper *the_jumper);
static boolean array_is_subset_of_semi_labeled_value_list(type *array_type,
        type *semi_labeled_value_list_type, boolean *doubt, char **why_not,
        const source_location *location, jumper *the_jumper);
static boolean semi_labeled_value_list_is_subset_of_array(
        type *semi_labeled_value_list_type, type *array_type, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper);
static boolean semi_labeled_value_list_is_subset_of_map(
        type *semi_labeled_value_list_type, type *map_type, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper);
static boolean semi_labeled_value_list_is_subset_of_field_info(
        type *semi_labeled_value_list_type, field_type_info *big_field_info,
        boolean *doubt, char **why_not, const source_location *location,
        jumper *the_jumper);
static boolean map_is_subset_of_semi_labeled_value_list(type *map_type,
        type *semi_labeled_value_list_type, boolean *doubt, char **why_not,
        const source_location *location, jumper *the_jumper);
static type *map_type_for_array_type(type *array_type);
static boolean type_has_finite_enumeration_within_limit(type *the_type,
        size_t maximum_elements, boolean *doubt, size_t *element_count,
        boolean *error);
static value **enumerate(type *the_type, size_t element_count,
        const source_location *location, jumper *the_jumper);
static void convert_components_to_enumeration(size_t field_count,
        type **field_types, char **field_names,
        value *(*value_builder)(void *data), void *data, size_t element_count,
        value **value_array, const source_location *location,
        jumper *the_jumper);
static void delete_enumeration(value **values, size_t count,
                               jumper *the_jumper);
static value *lepton_value_builder(void *data);
static value *multiset_value_builder(void *data);
static value *semi_labeled_value_list_value_builder(void *data);
static boolean unordered_named_field_rules_are_subset(
        field_type_info *small_field_info, field_type_info *big_field_info,
        boolean *doubt, char **why_not, boolean small_possibly_nothing,
        const source_location *location, jumper *the_jumper);
static verdict initialize_field_info(field_type_info *field_info,
        size_t field_count, type **field_types, const char **field_names,
        boolean extra_fields_allowed, boolean fields_can_be_empty,
        boolean *item_writing_alloweds_in, boolean **item_writing_alloweds_out,
        reference_cluster **cluster);
static void deallocate_field_info(field_type_info *field_info,
        jumper *the_jumper, reference_cluster *cluster);
static boolean value_fits_field_info(value *the_value,
        field_type_info *field_info, boolean *doubt, char **why_not,
        const source_location *location, jumper *the_jumper);
static boolean field_info_is_equal(field_type_info *left_field_info,
        field_type_info *right_field_info, boolean *doubt,
        const source_location *location, jumper *the_jumper);
static int field_info_structural_order(field_type_info *left_field_info,
                                       field_type_info *right_field_info);
static boolean field_info_possibly_nothing(field_type_info *field_info);
static type *field_info_field(field_type_info *field_info,
        const char *field_name, lower_or_upper bound_direction);
static boolean field_info_has_finite_enumeration_within_limit(
        field_type_info *field_info, size_t maximum_elements, boolean *doubt,
        size_t *element_count, boolean *error);
static boolean intersection_definitely_empty(type *left, type *right,
                                             boolean *error);
static boolean field_info_intersection_empty(field_type_info *left_field_info,
        field_type_info *right_field_info, boolean *doubt,
        const source_location *location, jumper *the_jumper);
static verdict field_info_intersection(field_type_info *result_field_info,
        field_type_info *left_field_info, field_type_info *right_field_info,
        boolean *empty, reference_cluster **cluster);
static verdict field_info_intersection_with_writing_alloweds(
        field_type_info *result_field_info, field_type_info *left_field_info,
        field_type_info *right_field_info, boolean *empty,
        reference_cluster **cluster, boolean *left_item_writing_alloweds,
        boolean *right_item_writing_alloweds,
        boolean **result_item_writing_alloweds, boolean *unknown);
static boolean field_info_empty_allowed(field_type_info *field_info);
static type *lepton_fields_intersection(type *lepton_type,
                                        field_type_info *field_info);
static type *multiset_fields_intersection(type *multiset_type,
                                          field_type_info *field_info);
static verdict field_info_from_lepton_key(field_type_info *result_field_info,
                                          lepton_key_instance *key_instance);
static boolean semi_labeled_and_field_info_intersection_empty(
        type *semi_labeled_value_list_type, field_type_info *field_info,
        boolean *doubt, const source_location *location, jumper *the_jumper);
static boolean semi_labeled_and_map_intersection_empty(
        type *semi_labeled_value_list_type, type *map_type, boolean *doubt,
        const source_location *location, jumper *the_jumper);
static boolean semi_labeled_and_array_intersection_empty(
        type *semi_labeled_value_list_type, type *array_type, boolean *doubt,
        const source_location *location, jumper *the_jumper);
static boolean semi_labeled_value_lists_intersection_empty(type *left_type,
        type *right_type, boolean *doubt, const source_location *location,
        jumper *the_jumper);
static boolean routine_types_intersection_empty(type *left_type,
        type *right_type, boolean *doubt, const source_location *location,
        jumper *the_jumper);
static o_integer force_rational_value_to_integer(value *to_force);
static value *force_value_to_map(value *to_force, type *key_type,
        type *target_type, const source_location *location,
        jumper *the_jumper);
static value *force_value_to_map_by_morph(value *to_force, type *key_type,
        type *target_type, const source_location *location,
        jumper *the_jumper);
static value *force_value_to_map_by_cloning(value *to_force, type *key_type,
        type *target_type, const source_location *location,
        jumper *the_jumper);
static value *take_or_force_value_to_type(value *to_force, type *the_type,
        const source_location *location, jumper *the_jumper);
static boolean value_has_fields(value *the_value);
static value *create_similar_field_value(value *source);
static verdict filter_fields_through_field_info(value *target, value *source,
        field_type_info *field_info, const source_location *location,
        jumper *the_jumper);
static void filter_field_through_field_info(value *target,
        const char *field_name, value *field_value,
        field_type_info *field_info, const source_location *location,
        jumper *the_jumper);
static void remove_value_field_ordering(value *the_value);
static type *find_wrapped_type(type *test_routine_type, jumper *the_jumper);
static boolean routine_type_fits_pattern(type *the_routine_type,
        size_t parameter_count,
        parameter_pattern_kind *parameter_pattern_kinds,
        const char **parameter_names, value **exact_parameters,
        type **parameter_lower_types, type **parameter_upper_types,
        type **result_parameter_types, boolean *doubt,
        const source_location *location, jumper *the_jumper);
static size_t *resolve_type_parameter_ordering_from_name_array(
        type *the_routine_type, size_t pre_order_count,
        const char **pre_order_actual_names, boolean *error,
        size_t *post_order_count, size_t *duplicate_formal_argument_num,
        size_t *bad_name_actual_argument_num);
static void print_field_type_info_with_override(field_type_info *field_info,
        boolean *item_writing_alloweds, boolean elipsis_implied,
        void (*printer)(void *data, const char *format, ...), void *data,
        void (*override)(value *the_value,
                void (*printer)(void *data, const char *format, ...),
                void *data));
static boolean type_in_doubt(boolean *doubt_pointer, char **why_not,
                             jumper *the_jumper, const char *format, ...);
static boolean type_in_no_doubt(boolean is_in, boolean *doubt_pointer,
        char **why_not, jumper *the_jumper, const char *format, ...);
static validator *validator_add_field_type_info(validator *base,
                                                field_type_info *field_info);
static expression *shift_type_function_expression(void);
static value *shift_type_function_value(jumper *the_jumper);
static boolean range_is_finite(o_integer lower_bound, o_integer upper_bound);
static boolean type_not_subset_because_value_kinds_different(type *small,
        type *big, boolean *doubt_pointer, char **why_not, jumper *the_jumper);
static const char *type_brief_description(type *the_type);
static const char *type_value_kind_description(type *the_type);
static boolean type_not_subset_unless_empty_different_kinds(type *small,
        type *big, boolean *doubt_pointer, char **why_not, jumper *the_jumper);
static boolean type_not_subset_unless_empty_different_kinds_with_kind(
        type *small, type *big, const char *missing_value_kind_description,
        boolean *doubt_pointer, char **why_not, jumper *the_jumper);
static void print_rational(rational *to_print,
        void (*printer)(void *data, const char *format, ...), void *data);
static o_integer integer_between_rationals(rational *lower, rational *upper,
        boolean lower_inclusive, boolean upper_inclusive, boolean *error);
static o_integer minimum_integer_between_rationals(rational *lower,
        rational *upper, boolean lower_inclusive, boolean upper_inclusive,
        boolean *error);
static o_integer maximum_integer_between_rationals(rational *lower,
        rational *upper, boolean lower_inclusive, boolean upper_inclusive,
        boolean *error);
static o_integer non_integer_rational_ceiling(rational *the_rational);
static boolean rational_less_than_integer(rational *left, o_integer right,
                                          boolean *error);
static boolean integer_less_than_rational(o_integer left, rational *right,
                                          boolean *error);
static void check_integer_in_type(o_integer to_check, type *big,
        boolean *doubt, char **why_not, const source_location *location,
        jumper *the_jumper, boolean *do_return, const char *which_type);
static void blot_out_integer_overlapping_rational_range(
        integer_range_component *new_integer_components,
        size_t *new_integer_component_num,
        rational_range_component *new_rational_components,
        size_t *new_rational_component_num, rational_range_component *to_add,
        boolean *error);
static type *get_intersection_of_enumeration_and_integer(type *the_enum);
static type *get_intersection_of_enumeration_and_rational(type *the_enum);
static type *get_intersection_of_integer_ranges(type *left, type *right);
static type *get_intersection_of_integer_and_rational_ranges(type *left,
                                                             type *right);
static type *get_intersection_of_rational_ranges(type *left, type *right);
static type *get_intersection_of_rational_ranges_and_integer(
        type *rational_type);
static type *split_intersection_of_union(type *union_type, type *other);
static type *get_union_of_enumerated_types(type *left, type *right);
static type *get_union_of_enumeration_and_integer_ranges(type *left,
        type *right, boolean *error);
static type *get_union_of_enumeration_and_rational_ranges(type *left,
        type *right, boolean *error);
static type *get_union_of_integer_ranges(type *left, type *right);
static type *get_union_of_integer_and_rational_ranges(type *left, type *right);
static type *get_union_of_rational_ranges(type *left, type *right);
static void add_rational_to_ranges(o_integer to_add,
        rational_range_component *new_rational_components,
        size_t *new_rational_component_num, boolean *error);


AUTO_ARRAY_IMPLEMENTATION(type_aa, type *, 0);


extern type *get_anything_type(void)
  {
    assert(anything_type != NULL);
    return anything_type;
  }

extern type *get_nothing_type(void)
  {
    assert(nothing_type != NULL);
    return nothing_type;
  }

extern type *get_integer_type(void)
  {
    assert(integer_type != NULL);
    return integer_type;
  }

extern type *get_finite_integer_type(void)
  {
    assert(finite_integer_type != NULL);
    return finite_integer_type;
  }

extern type *get_rational_type(void)
  {
    assert(rational_type != NULL);
    return rational_type;
  }

extern type *get_any_regular_expression_type(void)
  {
    assert(any_regular_expression_type != NULL);
    return any_regular_expression_type;
  }

extern type *get_any_quark_type(void)
  {
    assert(any_quark_type != NULL);
    return any_quark_type;
  }

extern type *get_any_lepton_type(void)
  {
    assert(any_lepton_type != NULL);
    return any_lepton_type;
  }

extern type *get_lepton_key_type(void)
  {
    assert(lepton_key_type != NULL);
    return lepton_key_type;
  }

extern type *get_jump_target_type(void)
  {
    assert(jump_target_type != NULL);
    return jump_target_type;
  }

extern type *get_any_class_type(void)
  {
    assert(any_class_type != NULL);
    return any_class_type;
  }

extern type *get_object_type(void)
  {
    assert(object_type != NULL);
    return object_type;
  }

extern type *get_tagalong_key_type(void)
  {
    assert(any_tagalong_key_type != NULL);
    return any_tagalong_key_type;
  }

extern type *get_lock_type(void)
  {
    assert(lock_type != NULL);
    return lock_type;
  }

extern type *get_string_type(void)
  {
    assert(string_type != NULL);
    return string_type;
  }

extern type *get_character_type(void)
  {
    assert(character_type != NULL);
    return character_type;
  }

extern type *get_boolean_type(void)
  {
    assert(boolean_type != NULL);
    return boolean_type;
  }

extern type *get_enumeration_type(size_t value_count, value **values)
  {
    size_t value_num;
    boolean all_rational;
    boolean all_integer;
    type *result;

    if (value_count == 0)
      {
        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
        return result;
      }

    all_rational = TRUE;
    all_integer = TRUE;
    for (value_num = 0; value_num < value_count; ++value_num)
      {
        switch (get_value_kind(values[value_num]))
          {
            case VK_INTEGER:
                break;
            case VK_RATIONAL:
                all_integer = FALSE;
                break;
            default:
                all_integer = FALSE;
                all_rational = FALSE;
                value_num = value_count;
                break;
          }
      }

    if (all_integer)
      {
        type *result;
        o_integer *buffer;
        size_t buffer_use;
        size_t value_num;
        size_t range_count;
        size_t oi_num;

        result = create_empty_type(TK_INTEGER_RANGES);
        if (result == NULL)
            return NULL;

        result->possible_value_kinds = VK_BIT(VK_INTEGER);

        buffer = MALLOC_ARRAY(o_integer, value_count);
        if (buffer == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }

        result->u.integer_ranges.includes_positive_infinity = FALSE;
        result->u.integer_ranges.includes_negative_infinity = FALSE;
        result->u.integer_ranges.includes_unsigned_infinity = FALSE;
        result->u.integer_ranges.includes_zero_zero = FALSE;

        buffer_use = 0;

        for (value_num = 0; value_num < value_count; ++value_num)
          {
            value *this_value;
            o_integer this_oi;

            this_value = values[value_num];
            assert(get_value_kind(this_value) == VK_INTEGER);
            this_oi = integer_value_data(this_value);
            switch (oi_kind(this_oi))
              {
                case IIK_FINITE:
                    assert(buffer_use < value_count);
                    buffer[buffer_use] = this_oi;
                    ++buffer_use;
                    break;
                case IIK_POSITIVE_INFINITY:
                    result->u.integer_ranges.includes_positive_infinity = TRUE;
                    break;
                case IIK_NEGATIVE_INFINITY:
                    result->u.integer_ranges.includes_negative_infinity = TRUE;
                    break;
                case IIK_UNSIGNED_INFINITY:
                    result->u.integer_ranges.includes_unsigned_infinity = TRUE;
                    break;
                case IIK_ZERO_ZERO:
                    result->u.integer_ranges.includes_zero_zero = TRUE;
                    break;
                default:
                    assert(FALSE);
                    break;
              }
          }

        if (buffer_use > 0)
            qsort(buffer, buffer_use, sizeof(o_integer), &compare_o_integers);

        range_count = ((buffer_use == 0) ? 0 : 1);

        for (oi_num = 1; oi_num < buffer_use; ++oi_num)
          {
            o_integer diff;

            assert(!(oi_less_than(buffer[oi_num], buffer[oi_num - 1])));
            oi_subtract(diff, buffer[oi_num], buffer[oi_num - 1]);
            if (oi_out_of_memory(diff))
              {
                free(buffer);
                validator_remove_reference(result->validator);
                DESTROY_SYSTEM_LOCK(result->reference_lock);
                free(result);
                return NULL;
              }

            if (oi_less_than(oi_one, diff))
                ++range_count;

            oi_remove_reference(diff);
          }

        result->u.integer_ranges.component_count = range_count;

        if (range_count == 0)
          {
            result->u.integer_ranges.components = NULL;
          }
        else
          {
            integer_range_component *components;
            size_t component_num;
            size_t oi_num;

            components = MALLOC_ARRAY(integer_range_component, range_count);
            if (components == NULL)
              {
                free(buffer);
                validator_remove_reference(result->validator);
                DESTROY_SYSTEM_LOCK(result->reference_lock);
                free(result);
                return NULL;
              }

            result->u.integer_ranges.components = components;

            components[0].lower_bound = buffer[0];
            components[0].upper_bound = buffer[0];
            oi_add_reference(buffer[0]);
            oi_add_reference(buffer[0]);
            component_num = 1;

            for (oi_num = 1; oi_num < buffer_use; ++oi_num)
              {
                o_integer this_oi;
                o_integer diff;

                this_oi = buffer[oi_num];
                assert(!(oi_less_than(this_oi, buffer[oi_num - 1])));
                oi_subtract(diff, this_oi, buffer[oi_num - 1]);
                if (oi_out_of_memory(diff))
                  {
                    while (component_num > 0)
                      {
                        oi_remove_reference(
                                components[component_num].lower_bound);
                        oi_remove_reference(
                                components[component_num].upper_bound);
                        --component_num;
                      }
                    free(components);
                    free(buffer);
                    validator_remove_reference(result->validator);
                    DESTROY_SYSTEM_LOCK(result->reference_lock);
                    free(result);
                    return NULL;
                  }

                if (oi_less_than(oi_one, diff))
                  {
                    components[component_num].lower_bound = this_oi;
                    components[component_num].upper_bound = this_oi;
                    oi_add_reference(this_oi);
                    oi_add_reference(this_oi);
                    ++component_num;
                  }
                else
                  {
                    oi_add_reference(this_oi);
                    oi_remove_reference(
                            components[component_num - 1].upper_bound);
                    components[component_num - 1].upper_bound = this_oi;
                  }

                oi_remove_reference(diff);
              }

            assert(component_num == range_count);
          }

        free(buffer);

        return result;
      }
    else if (all_rational)
      {
        type *result;
        rational **buffer;
        size_t buffer_use;
        size_t value_num;
        size_t range_count;
        size_t rational_num;

        result = create_empty_type(TK_RATIONAL_RANGES);
        if (result == NULL)
            return NULL;

        result->possible_value_kinds =
                (VK_BIT(VK_INTEGER) | VK_BIT(VK_RATIONAL));

        buffer = MALLOC_ARRAY(rational *, value_count);
        if (buffer == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }

        result->u.rational_ranges.includes_positive_infinity = FALSE;
        result->u.rational_ranges.includes_negative_infinity = FALSE;
        result->u.rational_ranges.includes_unsigned_infinity = FALSE;
        result->u.rational_ranges.includes_zero_zero = FALSE;

        buffer_use = 0;

        for (value_num = 0; value_num < value_count; ++value_num)
          {
            value *this_value;

            this_value = values[value_num];

            switch (get_value_kind(this_value))
              {
                case VK_INTEGER:
                  {
                    o_integer this_oi;

                    this_oi = integer_value_data(this_value);
                    switch (oi_kind(this_oi))
                      {
                        case IIK_FINITE:
                            assert(buffer_use < value_count);
                            buffer[buffer_use] =
                                    create_rational(this_oi, oi_one);
                            if (buffer[buffer_use] == NULL)
                              {
                                while (buffer_use > 0)
                                  {
                                    --buffer_use;
                                    rational_remove_reference(
                                            buffer[buffer_use]);
                                  }
                                free(buffer);
                                validator_remove_reference(result->validator);
                                DESTROY_SYSTEM_LOCK(result->reference_lock);
                                free(result);
                                return NULL;
                              }
                            ++buffer_use;
                            break;
                        case IIK_POSITIVE_INFINITY:
                            result->u.rational_ranges.
                                    includes_positive_infinity = TRUE;
                            break;
                        case IIK_NEGATIVE_INFINITY:
                            result->u.rational_ranges.
                                    includes_negative_infinity = TRUE;
                            break;
                        case IIK_UNSIGNED_INFINITY:
                            result->u.rational_ranges.
                                    includes_unsigned_infinity = TRUE;
                            break;
                        case IIK_ZERO_ZERO:
                            result->u.rational_ranges.includes_zero_zero =
                                    TRUE;
                            break;
                        default:
                            assert(FALSE);
                            break;
                      }
                    break;
                  }
                case VK_RATIONAL:
                  {
                    rational *this_rational;

                    this_rational = rational_value_data(this_value);
                    assert(this_rational != NULL);
                    assert(!(rational_is_integer(this_rational)));
                    assert(buffer_use < value_count);
                    rational_add_reference(this_rational);
                    buffer[buffer_use] = this_rational;
                    ++buffer_use;
                    break;
                  }
                default:
                  {
                    assert(FALSE);
                    break;
                  }
              }
          }

        if (buffer_use > 0)
            qsort(buffer, buffer_use, sizeof(rational *), &compare_rationals);

        range_count = ((buffer_use == 0) ? 0 : 1);

        for (rational_num = 1; rational_num < buffer_use; ++rational_num)
          {
            if (!(rationals_are_equal(buffer[rational_num],
                                      buffer[rational_num - 1])))
              {
                ++range_count;
              }
          }

        result->u.rational_ranges.component_count = range_count;

        if (range_count == 0)
          {
            result->u.rational_ranges.components = NULL;
          }
        else
          {
            rational_range_component *components;
            size_t component_num;
            size_t rational_num;

            components = MALLOC_ARRAY(rational_range_component, range_count);
            if (components == NULL)
              {
                while (buffer_use > 0)
                  {
                    --buffer_use;
                    rational_remove_reference(buffer[buffer_use]);
                  }
                free(buffer);
                validator_remove_reference(result->validator);
                DESTROY_SYSTEM_LOCK(result->reference_lock);
                free(result);
                return NULL;
              }

            result->u.rational_ranges.components = components;

            components[0].lower_bound = buffer[0];
            components[0].upper_bound = buffer[0];
            rational_add_reference(buffer[0]);
            component_num = 1;

            for (rational_num = 1; rational_num < buffer_use; ++rational_num)
              {
                rational *this_item;

                this_item = buffer[rational_num];

                if (!(rationals_are_equal(this_item,
                                          buffer[rational_num - 1])))
                  {
                    components[component_num].lower_bound = this_item;
                    components[component_num].upper_bound = this_item;
                    rational_add_reference(this_item);
                    ++component_num;
                  }
                else
                  {
                    rational_remove_reference(this_item);
                  }
              }

            assert(component_num == range_count);
          }

        free(buffer);

        return result;
      }

    result = create_empty_type(TK_ENUMERATION);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = 0;

    result->u.enumeration.slippery = FALSE;

    if (value_count == 0)
      {
        result->u.enumeration.values = NULL;
      }
    else
      {
        value **ordered_values;
        size_t value_num;
        size_t new_value_count;

        assert(values != NULL);

        ordered_values = MALLOC_ARRAY(value *, value_count);
        if (ordered_values == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }
        result->u.enumeration.values = ordered_values;

        for (value_num = 0; value_num < value_count; ++value_num)
          {
            if (result->reference_cluster == NULL)
              {
                result->reference_cluster =
                        value_reference_cluster(values[value_num]);
                if (result->reference_cluster != NULL)
                    reference_cluster_add_reference(result->reference_cluster);
              }

            result->possible_value_kinds |=
                    VK_BIT(get_value_kind(values[value_num]));
            value_add_reference_with_reference_cluster(values[value_num],
                    result->reference_cluster);
            assert(value_is_valid(values[value_num])); /* VERIFIED */
            ordered_values[value_num] = values[value_num];
            if ((!(result->u.enumeration.slippery)) &&
                (value_is_slippery(values[value_num])))
              {
                result->u.enumeration.slippery = TRUE;
              }
          }

        qsort(ordered_values, value_count, sizeof(value *),
              &compare_generic_values);

        new_value_count = 0;
        for (value_num = 0; value_num < value_count; ++value_num)
          {
            if (value_num > 0)
              {
                int order;

                assert(new_value_count > 0);

                assert(value_is_valid(ordered_values[new_value_count - 1]));
                        /* VERIFIED */
                assert(value_is_valid(ordered_values[value_num]));
                        /* VERIFIED */
                order = value_structural_order(
                        ordered_values[new_value_count - 1],
                        ordered_values[value_num]);
                if (order == -2)
                  {
                    while (new_value_count > 0)
                      {
                        --new_value_count;
                        value_remove_reference(
                                ordered_values[new_value_count], NULL);
                      }
                    while (value_num < value_count)
                      {
                        value_remove_reference(ordered_values[value_num],
                                               NULL);
                        ++value_num;
                      }
                    free(ordered_values);
                    validator_remove_reference(result->validator);
                    DESTROY_SYSTEM_LOCK(result->reference_lock);
                    free(result);
                    return NULL;
                  }
                assert(order <= 0);
                if (order == 0)
                  {
                    value_remove_reference(ordered_values[value_num], NULL);
                    continue;
                  }
              }

            if (value_num != new_value_count)
                ordered_values[new_value_count] = ordered_values[value_num];

            ++new_value_count;
          }

        assert(new_value_count <= value_count);
        assert(new_value_count > 0);

        value_count = new_value_count;
      }

    result->u.enumeration.value_count = value_count;

    for (value_num = 0; value_num < value_count; ++value_num)
      {
        result->validator = validator_add_validator(result->validator,
                value_validator(values[value_num]));
        if (result->validator == NULL)
          {
            type_remove_reference(result, NULL);
            return NULL;
          }
      }

    assert(type_is_valid(result)); /* VERIFIED */
    return result;
  }

extern type *get_not_type(type *base)
  {
    type *result;

    assert(base != NULL);

    assert(type_is_valid(base)); /* VERIFIED */

    switch (base->kind)
      {
        case TK_ANYTHING:
          {
            result = get_nothing_type();
            if (result != NULL)
                type_add_reference(result);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_NOTHING:
          {
            result = get_anything_type();
            if (result != NULL)
                type_add_reference(result);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_NOT:
          {
            result = base->u.not.base;
            assert(result != NULL);
            type_add_reference(result);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_INTERSECTION:
          {
            type *left;
            type *right;

            assert(type_is_valid(base->u.intersection.left)); /* VERIFIED */
            left = get_not_type(base->u.intersection.left);
            if (left == NULL)
                return NULL;

            assert(type_is_valid(base->u.intersection.right)); /* VERIFIED */
            right = get_not_type(base->u.intersection.right);
            if (right == NULL)
              {
                type_remove_reference(left, NULL);
                return NULL;
              }

            assert(type_is_valid(left)); /* VERIFIED */
            assert(type_is_valid(right)); /* VERIFIED */
            result = get_union_type(left, right);
            type_remove_reference(left, NULL);
            type_remove_reference(right, NULL);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_UNION:
          {
            type *left;
            type *right;

            assert(type_is_valid(base->u.union_type.left)); /* VERIFIED */
            left = get_not_type(base->u.union_type.left);
            if (left == NULL)
                return NULL;

            assert(type_is_valid(base->u.union_type.right)); /* VERIFIED */
            right = get_not_type(base->u.union_type.right);
            if (right == NULL)
              {
                type_remove_reference(left, NULL);
                return NULL;
              }

            assert(type_is_valid(left)); /* VERIFIED */
            assert(type_is_valid(right)); /* VERIFIED */
            result = get_intersection_type(left, right);
            type_remove_reference(left, NULL);
            type_remove_reference(right, NULL);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        default:
          {
            break;
          }
      }

    result = create_empty_type(TK_NOT);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = all_possible_value_kinds;

    assert(result->reference_cluster == NULL);
    result->reference_cluster = base->reference_cluster;
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    type_add_reference_with_reference_cluster(base, result->reference_cluster);
    result->u.not.base = base;

    result->validator =
            validator_add_validator(result->validator, type_validator(base));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    assert(type_is_valid(result)); /* VERIFIED */
    return result;
  }

extern type *get_intersection_type(type *left, type *right)
  {
    possible_value_kinds_bit_type possible_value_kinds;
    int order;
    type *result;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    possible_value_kinds =
            (left->possible_value_kinds & right->possible_value_kinds);
    if (possible_value_kinds == 0)
      {
        type *result;

        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
        return result;
      }

    order = type_structural_order(left, right);
    if (order == -2)
        return NULL;
    if (order == 0)
      {
        type_add_reference(left);
        assert(type_is_valid(left)); /* VERIFIED */
        return left;
      }

    if (left->kind == TK_ANYTHING)
      {
        type_add_reference(right);
        assert(type_is_valid(right)); /* VERIFIED */
        return right;
      }

    if (right->kind == TK_ANYTHING)
      {
        type_add_reference(left);
        assert(type_is_valid(left)); /* VERIFIED */
        return left;
      }

    if (left->kind == TK_NOTHING)
      {
        type_add_reference(left);
        assert(type_is_valid(left)); /* VERIFIED */
        return left;
      }

    if (right->kind == TK_NOTHING)
      {
        type_add_reference(right);
        assert(type_is_valid(right)); /* VERIFIED */
        return right;
      }

    if (right->kind == TK_NOT)
      {
        boolean error;
        boolean empty;

        empty = intersection_definitely_empty(right->u.not.base, left, &error);
        if (error)
            return NULL;
        if (empty)
          {
            type_add_reference(left);
            return left;
          }
      }

    if ((right->kind == TK_UNION) && (left->kind != TK_UNION))
        return get_intersection_type(right, left);

    switch (left->kind)
      {
        case TK_INTEGER:
          {
            switch (right->kind)
              {
                case TK_INTEGER:
                  {
                    assert(FALSE);
                    break;
                  }
                case TK_RATIONAL:
                  {
                    type_add_reference(left);
                    assert(type_is_valid(left)); /* VERIFIED */
                    return left;
                  }
                case TK_ENUMERATION:
                  {
                    return get_intersection_of_enumeration_and_integer(right);
                  }
                case TK_UNION:
                  {
                    type_kind left_kind;
                    type_kind right_kind;

                    left_kind = right->u.union_type.left->kind;
                    right_kind = right->u.union_type.right->kind;

                    if ((left_kind == TK_INTEGER) ||
                        (left_kind == TK_RATIONAL) ||
                        (left_kind == TK_ENUMERATION) ||
                        (left_kind == TK_INTEGER_RANGES) ||
                        (left_kind == TK_RATIONAL_RANGES) ||
                        (right_kind == TK_INTEGER) ||
                        (right_kind == TK_RATIONAL) ||
                        (right_kind == TK_ENUMERATION) ||
                        (right_kind == TK_INTEGER_RANGES) ||
                        (right_kind == TK_RATIONAL_RANGES))
                      {
                        return split_intersection_of_union(right, left);
                      }

                    break;
                  }
                case TK_INTEGER_RANGES:
                  {
                    type_add_reference(right);
                    assert(type_is_valid(right)); /* VERIFIED */
                    return right;
                  }
                case TK_RATIONAL_RANGES:
                  {
                    return get_intersection_of_rational_ranges_and_integer(
                            right);
                    break;
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_RATIONAL:
          {
            switch (right->kind)
              {
                case TK_INTEGER:
                  {
                    type_add_reference(right);
                    assert(type_is_valid(right)); /* VERIFIED */
                    return right;
                  }
                case TK_RATIONAL:
                  {
                    assert(FALSE);
                    break;
                  }
                case TK_ENUMERATION:
                  {
                    return get_intersection_of_enumeration_and_rational(right);
                  }
                case TK_UNION:
                  {
                    type_kind left_kind;
                    type_kind right_kind;

                    left_kind = right->u.union_type.left->kind;
                    right_kind = right->u.union_type.right->kind;

                    if ((left_kind == TK_INTEGER) ||
                        (left_kind == TK_RATIONAL) ||
                        (left_kind == TK_ENUMERATION) ||
                        (left_kind == TK_INTEGER_RANGES) ||
                        (left_kind == TK_RATIONAL_RANGES) ||
                        (right_kind == TK_INTEGER) ||
                        (right_kind == TK_RATIONAL) ||
                        (right_kind == TK_ENUMERATION) ||
                        (right_kind == TK_INTEGER_RANGES) ||
                        (right_kind == TK_RATIONAL_RANGES))
                      {
                        return split_intersection_of_union(right, left);
                      }

                    break;
                  }
                case TK_INTEGER_RANGES:
                case TK_RATIONAL_RANGES:
                  {
                    type_add_reference(right);
                    assert(type_is_valid(right)); /* VERIFIED */
                    return right;
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_ENUMERATION:
          {
            switch (right->kind)
              {
                case TK_INTEGER:
                  {
                    return get_intersection_of_enumeration_and_integer(left);
                  }
                case TK_RATIONAL:
                  {
                    return get_intersection_of_enumeration_and_rational(left);
                  }
                case TK_UNION:
                  {
                    type_kind left_kind;
                    type_kind right_kind;

                    left_kind = right->u.union_type.left->kind;
                    right_kind = right->u.union_type.right->kind;

                    if (((left_kind == TK_INTEGER) ||
                         (left_kind == TK_RATIONAL) ||
                         (left_kind == TK_INTEGER_RANGES) ||
                         (left_kind == TK_RATIONAL_RANGES)) &&
                        ((right_kind == TK_INTEGER) ||
                         (right_kind == TK_RATIONAL) ||
                         (right_kind == TK_INTEGER_RANGES) ||
                         (right_kind == TK_RATIONAL_RANGES)))
                      {
                        type *new_left;
                        type *result;

                        new_left =
                                get_intersection_of_enumeration_and_rational(
                                        left);
                        if (new_left == NULL)
                            return NULL;

                        result = get_union_type(new_left, right);
                        type_remove_reference(new_left, NULL);
                        return result;
                      }

                    break;
                  }
                case TK_INTEGER_RANGES:
                  {
                    type *intermediate;
                    type *result;

                    intermediate =
                            get_intersection_of_enumeration_and_integer(left);
                    if (intermediate == NULL)
                        return NULL;
                    result = get_intersection_type(intermediate, right);
                    type_remove_reference(intermediate, NULL);
                    return result;
                  }
                case TK_RATIONAL_RANGES:
                  {
                    type *intermediate;
                    type *result;

                    intermediate =
                            get_intersection_of_enumeration_and_rational(left);
                    if (intermediate == NULL)
                        return NULL;
                    result = get_intersection_type(intermediate, right);
                    type_remove_reference(intermediate, NULL);
                    return result;
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_NOT:
          {
            boolean error;
            boolean empty;

            empty = intersection_definitely_empty(left->u.not.base, right,
                                                  &error);
            if (error)
                return NULL;
            if (empty)
              {
                type_add_reference(right);
                return right;
              }

            if (right->kind == TK_UNION)
              {
                int order;

                order = type_structural_order(right->u.union_type.left,
                                              left->u.not.base);
                if (order == -2)
                    return NULL;
                if (order == 0)
                  {
                    return get_intersection_type(right->u.union_type.right,
                                                 left);
                  }

                order = type_structural_order(right->u.union_type.right,
                                              left->u.not.base);
                if (order == -2)
                    return NULL;
                if (order == 0)
                  {
                    return get_intersection_type(right->u.union_type.left,
                                                 left);
                  }
              }
            break;
          }
        case TK_UNION:
          {
            type *left_left;
            type *left_right;
            type_kind left_kind;
            type_kind right_kind;

            left_left = left->u.union_type.left;
            left_right = left->u.union_type.right;

            if (right->kind == TK_NOT)
              {
                int order;

                order = type_structural_order(left_right, right->u.not.base);
                if (order == -2)
                    return NULL;
                if (order == 0)
                    return get_intersection_type(left_left, right);

                order = type_structural_order(left_left, right->u.not.base);
                if (order == -2)
                    return NULL;
                if (order == 0)
                    return get_intersection_type(left_right, right);
              }

            if ((left_left->possible_value_kinds & right->possible_value_kinds)
                == 0)
              {
                return get_intersection_type(left_right, right);
              }

            if ((left_right->possible_value_kinds &
                 right->possible_value_kinds) == 0)
              {
                return get_intersection_type(left_left, right);
              }

            left_kind = left_left->kind;
            right_kind = left_right->kind;

            switch (right->kind)
              {
                case TK_INTEGER:
                    if ((left_kind == TK_INTEGER) ||
                        (left_kind == TK_RATIONAL) ||
                        (left_kind == TK_ENUMERATION) ||
                        (left_kind == TK_INTEGER_RANGES) ||
                        (left_kind == TK_RATIONAL_RANGES) ||
                        (right_kind == TK_INTEGER) ||
                        (right_kind == TK_RATIONAL) ||
                        (right_kind == TK_ENUMERATION) ||
                        (right_kind == TK_INTEGER_RANGES) ||
                        (right_kind == TK_RATIONAL_RANGES))
                      {
                        return split_intersection_of_union(left, right);
                      }

                    break;
                case TK_RATIONAL:
                    if ((left_kind == TK_INTEGER) ||
                        (left_kind == TK_RATIONAL) ||
                        (left_kind == TK_ENUMERATION) ||
                        (left_kind == TK_INTEGER_RANGES) ||
                        (left_kind == TK_RATIONAL_RANGES) ||
                        (right_kind == TK_INTEGER) ||
                        (right_kind == TK_RATIONAL) ||
                        (right_kind == TK_ENUMERATION) ||
                        (right_kind == TK_INTEGER_RANGES) ||
                        (right_kind == TK_RATIONAL_RANGES))
                      {
                        return split_intersection_of_union(left, right);
                      }

                    break;
                case TK_ENUMERATION:
                    if (((left_kind == TK_INTEGER) ||
                         (left_kind == TK_RATIONAL) ||
                         (left_kind == TK_INTEGER_RANGES) ||
                         (left_kind == TK_RATIONAL_RANGES)) &&
                        ((right_kind == TK_INTEGER) ||
                         (right_kind == TK_RATIONAL) ||
                         (right_kind == TK_INTEGER_RANGES) ||
                         (right_kind == TK_RATIONAL_RANGES)))
                      {
                        type *new_right;
                        type *result;

                        new_right =
                                get_intersection_of_enumeration_and_rational(
                                        right);
                        if (new_right == NULL)
                            return NULL;

                        result = get_union_type(new_right, left);
                        type_remove_reference(new_right, NULL);
                        return result;
                      }

                    break;
                case TK_UNION:
                    if (((left_kind == TK_INTEGER) ||
                         (left_kind == TK_RATIONAL) ||
                         (left_kind == TK_INTEGER_RANGES) ||
                         (left_kind == TK_RATIONAL_RANGES)) &&
                        ((right_kind == TK_INTEGER) ||
                         (right_kind == TK_RATIONAL) ||
                         (right_kind == TK_INTEGER_RANGES) ||
                         (right_kind == TK_RATIONAL_RANGES)))
                      {
                        type_kind right_left_kind;
                        type_kind right_right_kind;

                        right_left_kind = right->u.union_type.left->kind;
                        right_right_kind = right->u.union_type.right->kind;

                        if (((right_left_kind == TK_INTEGER) ||
                             (right_left_kind == TK_RATIONAL) ||
                             (right_left_kind == TK_INTEGER_RANGES) ||
                             (right_left_kind == TK_RATIONAL_RANGES)) &&
                            ((right_right_kind == TK_INTEGER) ||
                             (right_right_kind == TK_RATIONAL) ||
                             (right_right_kind == TK_INTEGER_RANGES) ||
                             (right_right_kind == TK_RATIONAL_RANGES)))
                          {
                            return split_intersection_of_union(left, right);
                          }
                      }

                    break;
                case TK_INTEGER_RANGES:
                    if ((left_kind == TK_INTEGER) ||
                        (left_kind == TK_RATIONAL) ||
                        (left_kind == TK_ENUMERATION) ||
                        (left_kind == TK_INTEGER_RANGES) ||
                        (left_kind == TK_RATIONAL_RANGES) ||
                        (right_kind == TK_INTEGER) ||
                        (right_kind == TK_RATIONAL) ||
                        (right_kind == TK_ENUMERATION) ||
                        (right_kind == TK_INTEGER_RANGES) ||
                        (right_kind == TK_RATIONAL_RANGES))
                      {
                        return split_intersection_of_union(left, right);
                      }

                    break;
                case TK_RATIONAL_RANGES:
                    if ((left_kind == TK_INTEGER) ||
                        (left_kind == TK_RATIONAL) ||
                        (left_kind == TK_ENUMERATION) ||
                        (left_kind == TK_INTEGER_RANGES) ||
                        (left_kind == TK_RATIONAL_RANGES) ||
                        (right_kind == TK_INTEGER) ||
                        (right_kind == TK_RATIONAL) ||
                        (right_kind == TK_ENUMERATION) ||
                        (right_kind == TK_INTEGER_RANGES) ||
                        (right_kind == TK_RATIONAL_RANGES))
                      {
                        return split_intersection_of_union(left, right);
                      }

                    break;
                default:
                    break;
              }
            break;
          }
        case TK_INTEGER_RANGES:
          {
            switch (right->kind)
              {
                case TK_INTEGER:
                case TK_RATIONAL:
                  {
                    type_add_reference(left);
                    assert(type_is_valid(left)); /* VERIFIED */
                    return left;
                  }
                case TK_ENUMERATION:
                  {
                    type *intermediate;
                    type *result;

                    intermediate =
                            get_intersection_of_enumeration_and_integer(right);
                    if (intermediate == NULL)
                        return NULL;
                    result = get_intersection_type(left, intermediate);
                    type_remove_reference(intermediate, NULL);
                    return result;
                  }
                case TK_UNION:
                  {
                    type_kind left_kind;
                    type_kind right_kind;

                    left_kind = right->u.union_type.left->kind;
                    right_kind = right->u.union_type.right->kind;

                    if ((left_kind == TK_INTEGER) ||
                        (left_kind == TK_RATIONAL) ||
                        (left_kind == TK_ENUMERATION) ||
                        (left_kind == TK_INTEGER_RANGES) ||
                        (left_kind == TK_RATIONAL_RANGES) ||
                        (right_kind == TK_INTEGER) ||
                        (right_kind == TK_RATIONAL) ||
                        (right_kind == TK_ENUMERATION) ||
                        (right_kind == TK_INTEGER_RANGES) ||
                        (right_kind == TK_RATIONAL_RANGES))
                      {
                        return split_intersection_of_union(right, left);
                      }

                    break;
                  }
                case TK_INTEGER_RANGES:
                  {
                    return get_intersection_of_integer_ranges(left, right);
                  }
                case TK_RATIONAL_RANGES:
                  {
                    return get_intersection_of_integer_and_rational_ranges(
                            left, right);
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_RATIONAL_RANGES:
          {
            switch (right->kind)
              {
                case TK_INTEGER:
                  {
                    return get_intersection_of_rational_ranges_and_integer(
                            left);
                  }
                case TK_RATIONAL:
                  {
                    type_add_reference(left);
                    assert(type_is_valid(left)); /* VERIFIED */
                    return left;
                  }
                case TK_ENUMERATION:
                  {
                    type *intermediate;
                    type *result;

                    intermediate =
                            get_intersection_of_enumeration_and_rational(
                                    right);
                    if (intermediate == NULL)
                        return NULL;
                    result = get_intersection_type(left, intermediate);
                    type_remove_reference(intermediate, NULL);
                    return result;
                  }
                case TK_UNION:
                  {
                    type_kind left_kind;
                    type_kind right_kind;

                    left_kind = right->u.union_type.left->kind;
                    right_kind = right->u.union_type.right->kind;

                    if ((left_kind == TK_INTEGER) ||
                        (left_kind == TK_RATIONAL) ||
                        (left_kind == TK_ENUMERATION) ||
                        (left_kind == TK_INTEGER_RANGES) ||
                        (left_kind == TK_RATIONAL_RANGES) ||
                        (right_kind == TK_INTEGER) ||
                        (right_kind == TK_RATIONAL) ||
                        (right_kind == TK_ENUMERATION) ||
                        (right_kind == TK_INTEGER_RANGES) ||
                        (right_kind == TK_RATIONAL_RANGES))
                      {
                        return split_intersection_of_union(right, left);
                      }

                    break;
                  }
                case TK_INTEGER_RANGES:
                  {
                    return get_intersection_of_integer_and_rational_ranges(
                            right, left);
                  }
                case TK_RATIONAL_RANGES:
                  {
                    return get_intersection_of_rational_ranges(left, right);
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_FIELDS:
          {
            switch (right->kind)
              {
                case TK_FIELDS:
                  {
                    type *result;
                    boolean empty;
                    verdict the_verdict;

                    result = create_empty_type(TK_FIELDS);
                    if (result == NULL)
                        return NULL;

                    result->possible_value_kinds =
                            (VK_BIT(VK_SEMI_LABELED_VALUE_LIST) |
                             VK_BIT(VK_SEMI_LABELED_MULTI_SET) |
                             VK_BIT(VK_LEPTON) | VK_BIT(VK_OBJECT));

                    assert(type_is_valid(left)); /* VERIFIED */
                    assert(type_is_valid(right)); /* VERIFIED */
                    the_verdict = field_info_intersection(
                            &(result->u.fields.field_info),
                            &(left->u.fields.field_info),
                            &(right->u.fields.field_info), &empty,
                            &(result->reference_cluster));
                    if (the_verdict != MISSION_ACCOMPLISHED)
                      {
                        if (result->validator != NULL)
                            validator_remove_reference(result->validator);
                        DESTROY_SYSTEM_LOCK(result->reference_lock);
                        free(result);
                        return NULL;
                      }
                    if (empty)
                      {
                        if (result->validator != NULL)
                            validator_remove_reference(result->validator);
                        DESTROY_SYSTEM_LOCK(result->reference_lock);
                        free(result);
                        result = get_nothing_type();
                        if (result != NULL)
                            type_add_reference(result);
                        assert((result == NULL) || type_is_valid(result));
                                /* VERIFIED */
                        return result;
                      }

                    result->validator = validator_add_field_type_info(
                            result->validator, &(result->u.fields.field_info));
                    if (result->validator == NULL)
                      {
                        type_remove_reference(result, NULL);
                        return NULL;
                      }

                    assert(type_is_valid(result)); /* VERIFIED */
                    return result;
                  }
                case TK_LEPTON:
                  {
                    assert(type_is_valid(right)); /* VERIFIED */
                    assert(type_is_valid(left)); /* VERIFIED */
                    return lepton_fields_intersection(right,
                            &(left->u.fields.field_info));
                  }
                case TK_MULTISET:
                  {
                    assert(type_is_valid(right)); /* VERIFIED */
                    assert(type_is_valid(left)); /* VERIFIED */
                    return multiset_fields_intersection(right,
                            &(left->u.fields.field_info));
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_LEPTON:
          {
            switch (right->kind)
              {
                case TK_FIELDS:
                  {
                    assert(type_is_valid(left)); /* VERIFIED */
                    assert(type_is_valid(right)); /* VERIFIED */
                    return lepton_fields_intersection(left,
                            &(right->u.fields.field_info));
                  }
                case TK_LEPTON:
                  {
                    if (left->u.lepton.key == right->u.lepton.key)
                      {
                        assert(type_is_valid(left)); /* VERIFIED */
                        assert(type_is_valid(right)); /* VERIFIED */
                        return lepton_fields_intersection(left,
                                &(right->u.lepton.field_info));
                      }
                    else
                      {
                        type *result;

                        result = get_nothing_type();
                        if (result != NULL)
                            type_add_reference(result);
                        assert((result == NULL) || type_is_valid(result));
                                /* VERIFIED */
                        return result;
                      }
                  }
                case TK_MULTISET:
                  {
                    type *result;

                    result = get_nothing_type();
                    if (result != NULL)
                        type_add_reference(result);
                    assert((result == NULL) || type_is_valid(result));
                            /* VERIFIED */
                    return result;
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_MULTISET:
          {
            switch (right->kind)
              {
                case TK_FIELDS:
                  {
                    assert(type_is_valid(left)); /* VERIFIED */
                    assert(type_is_valid(right)); /* VERIFIED */
                    return multiset_fields_intersection(left,
                            &(right->u.fields.field_info));
                  }
                case TK_LEPTON:
                  {
                    type *result;

                    result = get_nothing_type();
                    if (result != NULL)
                        type_add_reference(result);
                    assert((result == NULL) || type_is_valid(result));
                            /* VERIFIED */
                    return result;
                  }
                case TK_MULTISET:
                  {
                    assert(type_is_valid(left)); /* VERIFIED */
                    assert(type_is_valid(right)); /* VERIFIED */
                    return multiset_fields_intersection(left,
                            &(right->u.multiset.field_info));
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_INTERFACE:
          {
            switch (right->kind)
              {
                case TK_INTERFACE:
                  {
                    type *result;
                    boolean empty;
                    boolean unknown;
                    verdict the_verdict;

                    result = create_empty_type(TK_INTERFACE);
                    if (result == NULL)
                        return NULL;

                    result->possible_value_kinds =
                            (VK_BIT(VK_SEMI_LABELED_VALUE_LIST) |
                             VK_BIT(VK_SEMI_LABELED_MULTI_SET) |
                             VK_BIT(VK_LEPTON) | VK_BIT(VK_OBJECT));

                    result->u.interface.null_allowed =
                            (left->u.interface.null_allowed &&
                             right->u.interface.null_allowed);

                    assert(type_is_valid(left)); /* VERIFIED */
                    assert(type_is_valid(right)); /* VERIFIED */
                    the_verdict =
                            field_info_intersection_with_writing_alloweds(
                            &(result->u.interface.field_info),
                            &(left->u.interface.field_info),
                            &(right->u.interface.field_info), &empty,
                            &(result->reference_cluster),
                            left->u.interface.item_writing_alloweds,
                            right->u.interface.item_writing_alloweds,
                            &(result->u.interface.item_writing_alloweds),
                            &unknown);
                    if (the_verdict != MISSION_ACCOMPLISHED)
                      {
                        if (result->validator != NULL)
                            validator_remove_reference(result->validator);
                        DESTROY_SYSTEM_LOCK(result->reference_lock);
                        free(result);
                        return NULL;
                      }

                    if (unknown)
                      {
                        if (result->validator != NULL)
                            validator_remove_reference(result->validator);
                        DESTROY_SYSTEM_LOCK(result->reference_lock);
                        free(result);
                        break;
                      }

                    if (empty)
                      {
                        if (result->validator != NULL)
                            validator_remove_reference(result->validator);
                        DESTROY_SYSTEM_LOCK(result->reference_lock);
                        free(result);
                        result = get_nothing_type();
                        if (result != NULL)
                            type_add_reference(result);
                        assert((result == NULL) || type_is_valid(result));
                                /* VERIFIED */
                        return result;
                      }

                    result->validator = validator_add_field_type_info(
                            result->validator,
                            &(result->u.interface.field_info));
                    if (result->validator == NULL)
                      {
                        type_remove_reference(result, NULL);
                        return NULL;
                      }

                    assert(type_is_valid(result)); /* VERIFIED */
                    return result;
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        default:
          {
            break;
          }
      }

    result = create_empty_type(TK_INTERSECTION);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = possible_value_kinds;

    assert(result->reference_cluster == NULL);
    result->reference_cluster = left->reference_cluster;
    if (result->reference_cluster == NULL)
        result->reference_cluster = right->reference_cluster;
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    type_add_reference_with_reference_cluster(left, result->reference_cluster);
    type_add_reference_with_reference_cluster(right,
                                              result->reference_cluster);

    if (order < 0)
      {
        result->u.intersection.left = left;
        result->u.intersection.right = right;
      }
    else
      {
        result->u.intersection.left = right;
        result->u.intersection.right = left;
      }

    result->validator =
            validator_add_validator(result->validator, type_validator(left));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    result->validator =
            validator_add_validator(result->validator, type_validator(right));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    assert(type_is_valid(result)); /* VERIFIED */
    return result;
  }

extern type *get_union_type(type *left, type *right)
  {
    int order;
    type *result;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    order = type_structural_order(left, right);
    if (order == -2)
        return NULL;
    if (order == 0)
      {
        type_add_reference(left);
        assert(type_is_valid(left)); /* VERIFIED */
        return left;
      }

    if (left->kind == TK_ANYTHING)
      {
        type_add_reference(left);
        assert(type_is_valid(left)); /* VERIFIED */
        return left;
      }

    if (right->kind == TK_ANYTHING)
      {
        type_add_reference(right);
        assert(type_is_valid(right)); /* VERIFIED */
        return right;
      }

    if (left->kind == TK_NOTHING)
      {
        type_add_reference(right);
        assert(type_is_valid(right)); /* VERIFIED */
        return right;
      }

    if (right->kind == TK_NOTHING)
      {
        type_add_reference(left);
        assert(type_is_valid(left)); /* VERIFIED */
        return left;
      }

    switch (left->kind)
      {
        case TK_INTEGER:
          {
            switch (right->kind)
              {
                case TK_INTEGER:
                  {
                    assert(FALSE);
                    break;
                  }
                case TK_RATIONAL:
                  {
                    type_add_reference(right);
                    assert(type_is_valid(right)); /* VERIFIED */
                    return right;
                  }
                case TK_INTEGER_RANGES:
                  {
                    type_add_reference(left);
                    assert(type_is_valid(left)); /* VERIFIED */
                    return left;
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_RATIONAL:
          {
            switch (right->kind)
              {
                case TK_INTEGER:
                case TK_INTEGER_RANGES:
                case TK_RATIONAL_RANGES:
                  {
                    type_add_reference(left);
                    assert(type_is_valid(left)); /* VERIFIED */
                    return left;
                  }
                case TK_RATIONAL:
                  {
                    assert(FALSE);
                    break;
                  }
                case TK_UNION:
                  {
                    type *right_left;
                    type *right_right;

                    right_left = right->u.union_type.left;
                    right_right = right->u.union_type.right;

                    if (((right_left->kind == TK_INTEGER_RANGES) ||
                         (right_left->kind == TK_RATIONAL_RANGES)) &&
                        ((right_right->kind == TK_RATIONAL_RANGES) ||
                         (right_right->kind == TK_INTEGER_RANGES)))
                      {
                        type_add_reference(left);
                        assert(type_is_valid(left)); /* VERIFIED */
                        return left;
                      }

                    break;
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_ENUMERATION:
          {
            switch (right->kind)
              {
                case TK_ENUMERATION:
                  {
                    return get_union_of_enumerated_types(left, right);
                  }
                case TK_INTEGER_RANGES:
                  {
                    boolean error;
                    type *optimized_result;

                    optimized_result =
                            get_union_of_enumeration_and_integer_ranges(left,
                                    right, &error);
                    if (error)
                      {
                        assert(optimized_result == NULL);
                        return NULL;
                      }
                    if (optimized_result != NULL)
                        return optimized_result;
                    break;
                  }
                case TK_RATIONAL_RANGES:
                  {
                    boolean error;
                    type *optimized_result;

                    optimized_result =
                            get_union_of_enumeration_and_rational_ranges(left,
                                    right, &error);
                    if (error)
                      {
                        assert(optimized_result == NULL);
                        return NULL;
                      }
                    if (optimized_result != NULL)
                        return optimized_result;
                    break;
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_UNION:
          {
            type *left_left;
            type *left_right;

            left_left = left->u.union_type.left;
            left_right = left->u.union_type.right;

            if ((left_left->kind == TK_RATIONAL_RANGES) &&
                (left_right->kind == TK_INTEGER_RANGES))
              {
                switch (right->kind)
                  {
                    case TK_INTEGER:
                      {
                        return get_union_type(right, left_left);
                      }
                    case TK_RATIONAL:
                      {
                        type_add_reference(right);
                        assert(type_is_valid(right)); /* VERIFIED */
                        return right;
                      }
                    case TK_UNION:
                      {
                        type *right_left;
                        type *right_right;

                        right_left = right->u.union_type.left;
                        right_right = right->u.union_type.right;

                        if ((right_left->kind == TK_RATIONAL_RANGES) ||
                            (right_right->kind == TK_INTEGER_RANGES))
                          {
                            type *integer_union;
                            type *rational_union;
                            type *result;

                            integer_union =
                                    get_union_type(left_right, right_right);
                            if (integer_union == NULL)
                                return NULL;

                            rational_union =
                                    get_union_type(left_left, right_left);
                            if (rational_union == NULL)
                              {
                                type_remove_reference(integer_union, NULL);
                                return NULL;
                              }

                            result = get_union_type(integer_union,
                                                    rational_union);
                            type_remove_reference(integer_union, NULL);
                            type_remove_reference(rational_union, NULL);
                            return result;
                          }

                        if ((right_left->kind == TK_INTEGER_RANGES) ||
                            (right_right->kind == TK_RATIONAL_RANGES))
                          {
                            type *integer_union;
                            type *rational_union;
                            type *result;

                            integer_union =
                                    get_union_type(left_right, right_left);
                            if (integer_union == NULL)
                                return NULL;

                            rational_union =
                                    get_union_type(left_left, right_right);
                            if (rational_union == NULL)
                              {
                                type_remove_reference(integer_union, NULL);
                                return NULL;
                              }

                            result = get_union_type(integer_union,
                                                    rational_union);
                            type_remove_reference(integer_union, NULL);
                            type_remove_reference(rational_union, NULL);
                            return result;
                          }

                        break;
                      }
                    case TK_INTEGER_RANGES:
                      {
                        type *intermediate;
                        type *result;

                        intermediate = get_union_type(right, left_right);
                        if (intermediate == NULL)
                            return NULL;

                        result = get_union_type(intermediate, left_left);
                        type_remove_reference(intermediate, NULL);
                        return result;
                      }
                    case TK_RATIONAL_RANGES:
                      {
                        type *intermediate;
                        type *result;

                        intermediate = get_union_type(right, left_left);
                        if (intermediate == NULL)
                            return NULL;

                        result = get_union_type(intermediate, left_right);
                        type_remove_reference(intermediate, NULL);
                        return result;
                      }
                    default:
                      {
                        break;
                      }
                  }
              }

            if ((left_left->kind == TK_INTEGER_RANGES) &&
                (left_right->kind == TK_RATIONAL_RANGES))
              {
                switch (right->kind)
                  {
                    case TK_INTEGER:
                      {
                        return get_union_type(right, left_right);
                      }
                    case TK_RATIONAL:
                      {
                        type_add_reference(right);
                        assert(type_is_valid(right)); /* VERIFIED */
                        return right;
                      }
                    case TK_UNION:
                      {
                        type *right_left;
                        type *right_right;

                        right_left = right->u.union_type.left;
                        right_right = right->u.union_type.right;

                        if ((right_left->kind == TK_RATIONAL_RANGES) ||
                            (right_right->kind == TK_INTEGER_RANGES))
                          {
                            type *integer_union;
                            type *rational_union;
                            type *result;

                            integer_union =
                                    get_union_type(left_left, right_right);
                            if (integer_union == NULL)
                                return NULL;

                            rational_union =
                                    get_union_type(left_right, right_left);
                            if (rational_union == NULL)
                              {
                                type_remove_reference(integer_union, NULL);
                                return NULL;
                              }

                            result = get_union_type(integer_union,
                                                    rational_union);
                            type_remove_reference(integer_union, NULL);
                            type_remove_reference(rational_union, NULL);
                            return result;
                          }

                        if ((right_left->kind == TK_INTEGER_RANGES) ||
                            (right_right->kind == TK_RATIONAL_RANGES))
                          {
                            type *integer_union;
                            type *rational_union;
                            type *result;

                            integer_union =
                                    get_union_type(left_left, right_left);
                            if (integer_union == NULL)
                                return NULL;

                            rational_union =
                                    get_union_type(left_right, right_right);
                            if (rational_union == NULL)
                              {
                                type_remove_reference(integer_union, NULL);
                                return NULL;
                              }

                            result = get_union_type(integer_union,
                                                    rational_union);
                            type_remove_reference(integer_union, NULL);
                            type_remove_reference(rational_union, NULL);
                            return result;
                          }

                        break;
                      }
                    case TK_INTEGER_RANGES:
                      {
                        type *intermediate;
                        type *result;

                        intermediate = get_union_type(right, left_left);
                        if (intermediate == NULL)
                            return NULL;

                        result = get_union_type(intermediate, left_right);
                        type_remove_reference(intermediate, NULL);
                        return result;
                      }
                    case TK_RATIONAL_RANGES:
                      {
                        type *intermediate;
                        type *result;

                        intermediate = get_union_type(right, left_right);
                        if (intermediate == NULL)
                            return NULL;

                        result = get_union_type(intermediate, left_left);
                        type_remove_reference(intermediate, NULL);
                        return result;
                      }
                    default:
                      {
                        break;
                      }
                  }
              }

            break;
          }
        case TK_INTEGER_RANGES:
          {
            switch (right->kind)
              {
                case TK_INTEGER:
                  {
                    type_add_reference(right);
                    assert(type_is_valid(right)); /* VERIFIED */
                    return right;
                  }
                case TK_RATIONAL:
                  {
                    type_add_reference(right);
                    assert(type_is_valid(right)); /* VERIFIED */
                    return right;
                  }
                case TK_ENUMERATION:
                  {
                    boolean error;
                    type *optimized_result;

                    optimized_result =
                            get_union_of_enumeration_and_integer_ranges(right,
                                    left, &error);
                    if (error)
                      {
                        assert(optimized_result == NULL);
                        return NULL;
                      }
                    if (optimized_result != NULL)
                        return optimized_result;
                    break;
                  }
                case TK_UNION:
                  {
                    type *right_left;
                    type *right_right;

                    right_left = right->u.union_type.left;
                    right_right = right->u.union_type.right;

                    if (right_right->kind == TK_INTEGER_RANGES)
                      {
                        type *intermediate;
                        type *result;

                        intermediate = get_union_type(left, right_right);
                        if (intermediate == NULL)
                            return NULL;

                        result = get_union_type(intermediate, right_left);
                        type_remove_reference(intermediate, NULL);
                        return result;
                      }

                    if (right_left->kind == TK_INTEGER_RANGES)
                      {
                        type *intermediate;
                        type *result;

                        intermediate = get_union_type(left, right_left);
                        if (intermediate == NULL)
                            return NULL;

                        result = get_union_type(intermediate, right_right);
                        type_remove_reference(intermediate, NULL);
                        return result;
                      }

                    break;
                  }
                case TK_INTEGER_RANGES:
                  {
                    return get_union_of_integer_ranges(left, right);
                  }
                case TK_RATIONAL_RANGES:
                  {
                    return get_union_of_integer_and_rational_ranges(left,
                                                                    right);
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        case TK_RATIONAL_RANGES:
          {
            switch (right->kind)
              {
                case TK_RATIONAL:
                  {
                    type_add_reference(right);
                    assert(type_is_valid(right)); /* VERIFIED */
                    return right;
                  }
                case TK_ENUMERATION:
                  {
                    boolean error;
                    type *optimized_result;

                    optimized_result =
                            get_union_of_enumeration_and_rational_ranges(right,
                                    left, &error);
                    if (error)
                      {
                        assert(optimized_result == NULL);
                        return NULL;
                      }
                    if (optimized_result != NULL)
                        return optimized_result;
                    break;
                  }
                case TK_UNION:
                  {
                    type *right_left;
                    type *right_right;

                    right_left = right->u.union_type.left;
                    right_right = right->u.union_type.right;

                    if (right_right->kind == TK_RATIONAL_RANGES)
                      {
                        type *intermediate;
                        type *result;

                        intermediate = get_union_type(left, right_right);
                        if (intermediate == NULL)
                            return NULL;

                        result = get_union_type(intermediate, right_left);
                        type_remove_reference(intermediate, NULL);
                        return result;
                      }

                    if (right_left->kind == TK_RATIONAL_RANGES)
                      {
                        type *intermediate;
                        type *result;

                        intermediate = get_union_type(left, right_left);
                        if (intermediate == NULL)
                            return NULL;

                        result = get_union_type(intermediate, right_right);
                        type_remove_reference(intermediate, NULL);
                        return result;
                      }

                    break;
                  }
                case TK_INTEGER_RANGES:
                  {
                    return get_union_of_integer_and_rational_ranges(right,
                                                                    left);
                  }
                case TK_RATIONAL_RANGES:
                  {
                    return get_union_of_rational_ranges(left, right);
                  }
                default:
                  {
                    break;
                  }
              }
            break;
          }
        default:
          {
            break;
          }
      }

    result = create_empty_type(TK_UNION);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds =
            (left->possible_value_kinds | right->possible_value_kinds);

    assert(result->reference_cluster == NULL);
    result->reference_cluster = left->reference_cluster;
    if (result->reference_cluster == NULL)
        result->reference_cluster = right->reference_cluster;
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    type_add_reference_with_reference_cluster(left, result->reference_cluster);
    type_add_reference_with_reference_cluster(right,
                                              result->reference_cluster);

    if (order < 0)
      {
        result->u.union_type.left = left;
        result->u.union_type.right = right;
      }
    else
      {
        result->u.union_type.left = right;
        result->u.union_type.right = left;
      }

    result->validator =
            validator_add_validator(result->validator, type_validator(left));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    result->validator =
            validator_add_validator(result->validator, type_validator(right));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    assert(type_is_valid(result)); /* VERIFIED */
    return result;
  }

extern type *get_xor_type(type *left, type *right)
  {
    int order;
    type *result;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    order = type_structural_order(left, right);
    if (order == -2)
        return NULL;
    if (order == 0)
      {
        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        return result;
      }

    result = create_empty_type(TK_XOR);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds =
            (left->possible_value_kinds | right->possible_value_kinds);

    assert(result->reference_cluster == NULL);
    result->reference_cluster = left->reference_cluster;
    if (result->reference_cluster == NULL)
        result->reference_cluster = right->reference_cluster;
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    type_add_reference_with_reference_cluster(left, result->reference_cluster);
    type_add_reference_with_reference_cluster(right,
                                              result->reference_cluster);

    if (order < 0)
      {
        result->u.xor.left = left;
        result->u.xor.right = right;
      }
    else
      {
        result->u.xor.left = right;
        result->u.xor.right = left;
      }

    result->validator =
            validator_add_validator(result->validator, type_validator(left));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    result->validator =
            validator_add_validator(result->validator, type_validator(right));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_array_type(type *base, o_integer lower_bound,
                            o_integer upper_bound)
  {
    o_integer lower_to_use;
    o_integer upper_to_use;
    type *result;

    assert(base != NULL);
    assert(!(oi_out_of_memory(lower_bound)));
    assert(!(oi_out_of_memory(upper_bound)));

    assert(type_is_valid(base)); /* VERIFIED */

    if (oi_less_than(upper_bound, lower_bound))
      {
        lower_to_use = oi_zero;
        oi_create_from_long_int(upper_to_use, -1);
        assert(!(oi_out_of_memory(upper_to_use)));
      }
    else
      {
        lower_to_use = lower_bound;
        upper_to_use = upper_bound;
        oi_add_reference(upper_to_use);
      }

    result = create_empty_type(TK_ARRAY);
    if (result == NULL)
      {
        oi_remove_reference(upper_to_use);
        return NULL;
      }

    result->possible_value_kinds =
            (VK_BIT(VK_MAP) | VK_BIT(VK_SEMI_LABELED_VALUE_LIST));

    assert(result->reference_cluster == NULL);
    result->reference_cluster = base->reference_cluster;
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    type_add_reference_with_reference_cluster(base, result->reference_cluster);
    result->u.array.base = base;

    oi_add_reference(lower_to_use);
    result->u.array.lower_bound = lower_to_use;

    result->u.array.upper_bound = upper_to_use;

    result->validator =
            validator_add_validator(result->validator, type_validator(base));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_integer_range_type(o_integer lower_bound,
        o_integer upper_bound, boolean lower_is_inclusive,
        boolean upper_is_inclusive)
  {
    o_integer fixed_lower;
    o_integer fixed_upper;
    type *result;

    assert(!(oi_out_of_memory(lower_bound)));
    assert(!(oi_out_of_memory(upper_bound)));

    if (lower_is_inclusive)
      {
        oi_add_reference(lower_bound);
        fixed_lower = lower_bound;
      }
    else
      {
        oi_add(fixed_lower, lower_bound, oi_one);
        if (oi_out_of_memory(fixed_lower))
            return NULL;
      }

    if (upper_is_inclusive)
      {
        oi_add_reference(upper_bound);
        fixed_upper = upper_bound;
      }
    else
      {
        oi_subtract(fixed_upper, upper_bound, oi_one);
        if (oi_out_of_memory(fixed_upper))
          {
            oi_remove_reference(fixed_lower);
            return NULL;
          }
      }

    if (oi_less_than(fixed_upper, fixed_lower))
      {
        oi_remove_reference(fixed_lower);
        oi_remove_reference(fixed_upper);
        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        return result;
      }

    result = create_empty_type(TK_INTEGER_RANGES);
    if (result == NULL)
      {
        oi_remove_reference(fixed_lower);
        oi_remove_reference(fixed_upper);
        return NULL;
      }

    result->possible_value_kinds = VK_BIT(VK_INTEGER);

    result->u.integer_ranges.components =
            MALLOC_ARRAY(integer_range_component, 1);
    if (result->u.integer_ranges.components == NULL)
      {
        oi_remove_reference(fixed_lower);
        oi_remove_reference(fixed_upper);
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    result->u.integer_ranges.components->lower_bound = fixed_lower;
    result->u.integer_ranges.components->upper_bound = fixed_upper;

    result->u.integer_ranges.component_count = 1;
    result->u.integer_ranges.includes_positive_infinity =
            (upper_is_inclusive &&
             (oi_kind(upper_bound) == IIK_POSITIVE_INFINITY));
    result->u.integer_ranges.includes_negative_infinity =
            (lower_is_inclusive &&
             (oi_kind(lower_bound) == IIK_NEGATIVE_INFINITY));
    result->u.integer_ranges.includes_unsigned_infinity = FALSE;
    result->u.integer_ranges.includes_zero_zero = FALSE;

    return result;
  }

extern type *get_rational_range_type(rational *lower_bound,
        rational *upper_bound, boolean lower_is_inclusive,
        boolean upper_is_inclusive)
  {
    boolean error;
    boolean less_than;
    type *result;

    assert(lower_bound != NULL);
    assert(upper_bound != NULL);

    less_than = rational_less_than(upper_bound, lower_bound, &error);
    if (error)
        return NULL;

    if (less_than ||
        (rationals_are_equal(lower_bound, upper_bound) &&
         !(lower_is_inclusive && upper_is_inclusive)))
      {
        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        return result;
      }

    if (rational_is_integer(lower_bound) &&
        rationals_are_equal(lower_bound, upper_bound))
      {
        o_integer the_oi;

        assert(lower_is_inclusive && upper_is_inclusive);
        the_oi = rational_numerator(lower_bound);
        return get_integer_range_type(the_oi, the_oi, TRUE, TRUE);
      }

    result = create_empty_type(TK_RATIONAL_RANGES);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = (VK_BIT(VK_INTEGER) | VK_BIT(VK_RATIONAL));

    result->u.rational_ranges.components =
            MALLOC_ARRAY(rational_range_component, 1);
    if (result->u.rational_ranges.components == NULL)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    rational_add_reference(lower_bound);
    result->u.rational_ranges.components->lower_bound = lower_bound;

    rational_add_reference(upper_bound);
    result->u.rational_ranges.components->upper_bound = upper_bound;
    result->u.rational_ranges.components->lower_is_inclusive =
            lower_is_inclusive;
    result->u.rational_ranges.components->upper_is_inclusive =
            upper_is_inclusive;

    result->u.rational_ranges.component_count = 1;
    result->u.rational_ranges.includes_positive_infinity =
            (upper_is_inclusive &&
             (oi_kind(rational_numerator(upper_bound)) ==
              IIK_POSITIVE_INFINITY));
    result->u.rational_ranges.includes_negative_infinity =
            (lower_is_inclusive &&
             (oi_kind(rational_numerator(lower_bound)) ==
              IIK_NEGATIVE_INFINITY));
    result->u.rational_ranges.includes_unsigned_infinity = FALSE;
    result->u.rational_ranges.includes_zero_zero = FALSE;

    return result;
  }

extern type *get_pointer_type(type *base, boolean read_allowed,
                              boolean write_allowed, boolean null_allowed)
  {
    type *result;

    assert(base != NULL);

    assert(type_is_valid(base)); /* VERIFIED */

    result = create_empty_type(TK_POINTER);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds =
            (VK_BIT(VK_SLOT_LOCATION) | (null_allowed ? VK_BIT(VK_NULL) : 0));

    assert(result->reference_cluster == NULL);
    result->reference_cluster = base->reference_cluster;
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    type_add_reference_with_reference_cluster(base, result->reference_cluster);
    result->u.pointer.base = base;

    result->u.pointer.read_allowed = read_allowed;
    result->u.pointer.write_allowed = write_allowed;
    result->u.pointer.null_allowed = null_allowed;

    result->validator =
            validator_add_validator(result->validator, type_validator(base));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_type_type(type *base)
  {
    type *result;

    assert(base != NULL);

    assert(type_is_valid(base)); /* VERIFIED */

    result = create_empty_type(TK_TYPE);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_TYPE);

    assert(result->reference_cluster == NULL);
    result->reference_cluster = base->reference_cluster;
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    type_add_reference_with_reference_cluster(base, result->reference_cluster);
    result->u.type.base = base;
    result->u.type.slippery = type_is_slippery(base);

    result->validator =
            validator_add_validator(result->validator, type_validator(base));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_map_type(type *key, type *target)
  {
    type *result;

    assert(key != NULL);
    assert(target != NULL);

    assert(type_is_valid(key)); /* VERIFIED */
    assert(type_is_valid(target)); /* VERIFIED */

    result = create_empty_type(TK_MAP);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds =
            (VK_BIT(VK_MAP) | VK_BIT(VK_SEMI_LABELED_VALUE_LIST));

    assert(result->reference_cluster == NULL);
    result->reference_cluster = key->reference_cluster;
    if (result->reference_cluster == NULL)
        result->reference_cluster = target->reference_cluster;
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);

    type_add_reference_with_reference_cluster(key, result->reference_cluster);
    result->u.map.key = key;

    type_add_reference_with_reference_cluster(target,
                                              result->reference_cluster);
    result->u.map.target = target;

    result->u.map.slippery =
            (type_is_slippery(key) || type_is_slippery(target));

    result->validator =
            validator_add_validator(result->validator, type_validator(key));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    result->validator =
            validator_add_validator(result->validator, type_validator(target));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_routine_type(type *return_type, size_t argument_count,
        type **argument_types, const char **argument_names,
        boolean *argument_has_defaults, boolean extra_arguments_allowed,
        boolean extra_arguments_unspecified)
  {
    type *result;
    size_t argument_num;

    assert(return_type != NULL);

    assert(type_is_valid(return_type)); /* VERIFIED */

    result = create_empty_type(TK_ROUTINE);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds =
            (VK_BIT(VK_ROUTINE) | VK_BIT(VK_ROUTINE_CHAIN));

    assert(result->reference_cluster == NULL);

    result->u.routine.argument_count = argument_count;
    result->u.routine.extra_arguments_allowed = extra_arguments_allowed;
    result->u.routine.extra_arguments_unspecified =
            extra_arguments_unspecified;

    result->u.routine.slippery = FALSE;

    while (extra_arguments_allowed && (!extra_arguments_unspecified) &&
           (argument_count > 0) &&
           (argument_types[argument_count - 1]->kind == TK_ANYTHING) &&
           (argument_names[argument_count - 1] == NULL) &&
           (argument_has_defaults[argument_count - 1]))
      {
        --argument_count;
      }

    if (argument_count == 0)
      {
        result->u.routine.argument_types = NULL;
        result->u.routine.argument_names = NULL;
        result->u.routine.argument_has_defaults = NULL;
      }
    else
      {
        size_t argument_num;

        assert(argument_types != NULL);
        assert(argument_names != NULL);
        assert(argument_has_defaults != NULL);

        result->u.routine.argument_types =
                MALLOC_ARRAY(type *, argument_count);
        if (result->u.routine.argument_types == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }

        result->u.routine.argument_names =
                MALLOC_ARRAY(char *, argument_count);
        if (result->u.routine.argument_names == NULL)
          {
            free(result->u.routine.argument_types);
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }

        result->u.routine.argument_has_defaults =
                MALLOC_ARRAY(boolean, argument_count);
        if (result->u.routine.argument_has_defaults == NULL)
          {
            free(result->u.routine.argument_names);
            free(result->u.routine.argument_types);
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }

        for (argument_num = 0; argument_num < argument_count; ++argument_num)
          {
            char *name_copy;

            if (result->reference_cluster == NULL)
              {
                result->reference_cluster =
                        argument_types[argument_num]->reference_cluster;
                if (result->reference_cluster != NULL)
                    reference_cluster_add_reference(result->reference_cluster);
              }

            assert(type_is_valid(argument_types[argument_num])); /* VERIFIED */
            type_add_reference_with_reference_cluster(
                    argument_types[argument_num], result->reference_cluster);
            result->u.routine.argument_types[argument_num] =
                    argument_types[argument_num];

            if ((!(result->u.routine.slippery)) &&
                (type_is_slippery(argument_types[argument_num])))
              {
                result->u.routine.slippery = TRUE;
              }

            if (argument_names[argument_num] == NULL)
              {
                name_copy = NULL;
              }
            else
              {
                name_copy = MALLOC_ARRAY(char,
                        strlen(argument_names[argument_num]) + 1);
                if (name_copy == NULL)
                  {
                    type_remove_reference(argument_types[argument_num], NULL);

                    while (argument_num > 0)
                      {
                        --argument_num;
                        type_remove_reference(argument_types[argument_num],
                                              NULL);
                        if (result->u.routine.argument_names[argument_num] !=
                            NULL)
                          {
                            free(result->u.routine.argument_names[
                                    argument_num]);
                          }
                      }

                    free(result->u.routine.argument_has_defaults);
                    free(result->u.routine.argument_names);
                    free(result->u.routine.argument_types);

                    validator_remove_reference(result->validator);
                    DESTROY_SYSTEM_LOCK(result->reference_lock);
                    free(result);

                    return NULL;
                  }
                strcpy(name_copy, argument_names[argument_num]);
              }

            result->u.routine.argument_names[argument_num] = name_copy;

            result->u.routine.argument_has_defaults[argument_num] =
                    argument_has_defaults[argument_num];
          }
      }

    if (result->reference_cluster == NULL)
      {
        result->reference_cluster = return_type->reference_cluster;
        if (result->reference_cluster != NULL)
            reference_cluster_add_reference(result->reference_cluster);
      }

    type_add_reference_with_reference_cluster(return_type,
                                              result->reference_cluster);
    result->u.routine.return_type = return_type;

    if ((!(result->u.routine.slippery)) && (type_is_slippery(return_type)))
        result->u.routine.slippery = TRUE;

    result->validator = validator_add_validator(result->validator,
                                                type_validator(return_type));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    for (argument_num = 0; argument_num < argument_count; ++argument_num)
      {
        result->validator = validator_add_validator(result->validator,
                type_validator(argument_types[argument_num]));
        if (result->validator == NULL)
          {
            type_remove_reference(result, NULL);
            return NULL;
          }
      }

    return result;
  }

extern type *get_fields_type(size_t field_count, type **field_types,
        const char **field_names, boolean extra_fields_allowed)
  {
    type *result;
    verdict the_verdict;

    result = create_empty_type(TK_FIELDS);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds =
            (VK_BIT(VK_SEMI_LABELED_VALUE_LIST) |
             VK_BIT(VK_SEMI_LABELED_MULTI_SET) | VK_BIT(VK_LEPTON) |
             VK_BIT(VK_OBJECT));

    the_verdict = initialize_field_info(&(result->u.fields.field_info),
            field_count, field_types, field_names, extra_fields_allowed, FALSE,
            NULL, NULL, &(result->reference_cluster));
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    result->validator = validator_add_field_type_info(result->validator,
            &(result->u.fields.field_info));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_lepton_type(lepton_key_instance *key, size_t field_count,
        type **field_types, const char **field_names,
        boolean extra_fields_allowed)
  {
    type *result;
    field_type_info key_field_info;
    verdict the_verdict;
    field_type_info additional_field_info;
    boolean empty;

    assert(key != NULL);

    assert(lepton_key_instance_is_instantiated(key)); /* VERIFIED */
    assert(!(lepton_key_instance_scope_exited(key))); /* VERIFIED */

    result = create_empty_type(TK_LEPTON);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_LEPTON);

    assert(lepton_key_instance_is_instantiated(key)); /* VERIFIED */
    assert(!(lepton_key_instance_scope_exited(key))); /* VERIFIED */
    the_verdict = field_info_from_lepton_key(&key_field_info, key);
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    the_verdict = initialize_field_info(&additional_field_info, field_count,
            field_types, field_names, extra_fields_allowed, TRUE, NULL, NULL,
            NULL);
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        deallocate_field_info(&key_field_info, NULL, NULL);
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    the_verdict = field_info_intersection(&(result->u.lepton.field_info),
            &key_field_info, &additional_field_info, &empty,
            &(result->reference_cluster));
    deallocate_field_info(&key_field_info, NULL, NULL);
    deallocate_field_info(&additional_field_info, NULL, NULL);
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }
    if (empty)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        return result;
      }

    if (result->reference_cluster == NULL)
      {
        result->reference_cluster = lepton_key_instance_reference_cluster(key);
        if (result->reference_cluster != NULL)
            reference_cluster_add_reference(result->reference_cluster);
      }
    lepton_key_instance_add_reference_with_cluster(key,
                                                   result->reference_cluster);
    result->u.lepton.key = key;

    result->validator = validator_add_instance(result->validator,
            lepton_key_instance_instance(key));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    result->validator = validator_add_field_type_info(result->validator,
            &(result->u.lepton.field_info));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_multiset_type(size_t field_count, type **field_types,
        const char **field_names, boolean extra_fields_allowed)
  {
    type *result;
    verdict the_verdict;

    result = create_empty_type(TK_MULTISET);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_SEMI_LABELED_MULTI_SET);

    the_verdict = initialize_field_info(&(result->u.multiset.field_info),
            field_count, field_types, field_names, extra_fields_allowed, TRUE,
            NULL, NULL, &(result->reference_cluster));
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    result->validator = validator_add_field_type_info(result->validator,
            &(result->u.multiset.field_info));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_interface_type(size_t item_count, type **item_types,
        const char **item_names, boolean *item_writing_alloweds,
        boolean null_allowed)
  {
    type *result;
    verdict the_verdict;

    result = create_empty_type(TK_INTERFACE);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds =
            (VK_BIT(VK_SEMI_LABELED_VALUE_LIST) |
             VK_BIT(VK_SEMI_LABELED_MULTI_SET) | VK_BIT(VK_LEPTON) |
             VK_BIT(VK_OBJECT));

    the_verdict = initialize_field_info(&(result->u.interface.field_info),
            item_count, item_types, item_names, TRUE, FALSE,
            item_writing_alloweds,
            &(result->u.interface.item_writing_alloweds),
            &(result->reference_cluster));
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    result->u.interface.null_allowed = null_allowed;

    result->validator = validator_add_field_type_info(result->validator,
            &(result->u.interface.field_info));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_semi_labeled_value_list_type(size_t element_count,
        type **element_types, const char **element_names,
        boolean extra_elements_allowed)
  {
    type *result;
    size_t element_num;

    result = create_empty_type(TK_SEMI_LABELED_VALUE_LIST);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds =
            (VK_BIT(VK_MAP) | VK_BIT(VK_SEMI_LABELED_VALUE_LIST));

    result->u.semi_labeled_value_list.element_count = element_count;
    result->u.semi_labeled_value_list.extra_elements_allowed =
            extra_elements_allowed;

    result->u.semi_labeled_value_list.slippery = FALSE;

    if (element_count == 0)
      {
        result->u.semi_labeled_value_list.element_types = NULL;
        result->u.semi_labeled_value_list.element_names = NULL;
      }
    else
      {
        size_t element_num;

        assert(element_types != NULL);
        assert(element_names != NULL);

        result->u.semi_labeled_value_list.element_types =
                MALLOC_ARRAY(type *, element_count);
        if (result->u.semi_labeled_value_list.element_types == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }

        result->u.semi_labeled_value_list.element_names =
                MALLOC_ARRAY(char *, element_count);
        if (result->u.semi_labeled_value_list.element_names == NULL)
          {
            free(result->u.semi_labeled_value_list.element_types);
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }

        for (element_num = 0; element_num < element_count; ++element_num)
          {
            char *name_copy;

            if (result->reference_cluster == NULL)
              {
                result->reference_cluster =
                        element_types[element_num]->reference_cluster;
                if (result->reference_cluster != NULL)
                    reference_cluster_add_reference(result->reference_cluster);
              }

            assert(type_is_valid(element_types[element_num])); /* VERIFIED */
            type_add_reference_with_reference_cluster(
                    element_types[element_num], result->reference_cluster);
            result->u.semi_labeled_value_list.element_types[element_num] =
                    element_types[element_num];

            if ((!(result->u.semi_labeled_value_list.slippery)) &&
                (type_is_slippery(element_types[element_num])))
              {
                result->u.semi_labeled_value_list.slippery = TRUE;
              }

            if (element_names[element_num] == NULL)
              {
                name_copy = NULL;
              }
            else
              {
                name_copy = MALLOC_ARRAY(char,
                        strlen(element_names[element_num]) + 1);
                if (name_copy == NULL)
                  {
                    type_remove_reference_with_reference_cluster(
                            element_types[element_num], NULL,
                            result->reference_cluster);

                    while (element_num > 0)
                      {
                        --element_num;
                        type_remove_reference_with_reference_cluster(
                                element_types[element_num], NULL,
                                result->reference_cluster);
                        if (result->u.semi_labeled_value_list.element_names[
                                    element_num] != NULL)
                          {
                            free(result->u.semi_labeled_value_list.
                                         element_names[element_num]);
                          }
                      }

                    free(result->u.semi_labeled_value_list.element_names);
                    free(result->u.semi_labeled_value_list.element_types);

                    validator_remove_reference(result->validator);
                    DESTROY_SYSTEM_LOCK(result->reference_lock);
                    free(result);

                    return NULL;
                  }
                strcpy(name_copy, element_names[element_num]);
              }

            result->u.semi_labeled_value_list.element_names[element_num] =
                    name_copy;
          }
      }

    result->u.semi_labeled_value_list.allowed_fields =
            make_allowed_fields_index(element_count,
                    result->u.semi_labeled_value_list.element_names);
    if (result->u.semi_labeled_value_list.allowed_fields == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    for (element_num = 0; element_num < element_count; ++element_num)
      {
        result->validator = validator_add_validator(result->validator,
                type_validator(element_types[element_num]));
        if (result->validator == NULL)
          {
            type_remove_reference(result, NULL);
            return NULL;
          }
      }

    return result;
  }

extern type *get_regular_expression_type(
        regular_expression *the_regular_expression)
  {
    type *result;

    assert(the_regular_expression != NULL);

    result = create_empty_type(TK_REGULAR_EXPRESSION);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_STRING);

    regular_expression_add_reference(the_regular_expression);
    result->u.regular_expression.regular_expression = the_regular_expression;

    return result;
  }

extern type *get_class_type(routine_instance *class_routine)
  {
    type *result;

    assert(class_routine != NULL);

    result = create_empty_type(TK_CLASS);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_OBJECT);

    assert(result->reference_cluster == NULL);
    result->reference_cluster =
            routine_instance_reference_cluster(class_routine);
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    routine_instance_add_reference_with_cluster(class_routine,
                                                result->reference_cluster);
    result->u.class.routine = class_routine;

    result->validator = validator_add_instance(result->validator,
            routine_instance_instance(class_routine));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_test_routine_type(routine_instance *test_routine)
  {
    type *result;
    verdict the_verdict;

    assert(test_routine != NULL);

    assert(routine_instance_is_instantiated(test_routine)); /* VERIFIED */
    assert(!(routine_instance_scope_exited(test_routine))); /* VERIFIED */

    result = create_empty_type(TK_TEST_ROUTINE);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = all_possible_value_kinds;

    the_verdict =
            type_aa_init(&(result->u.test_routine.provisional_subsets), 10);
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    the_verdict =
            type_aa_init(&(result->u.test_routine.provisional_supersets), 10);
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        free(result->u.test_routine.provisional_subsets.array);
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }

    assert(result->reference_cluster == NULL);
    result->reference_cluster =
            routine_instance_reference_cluster(test_routine);
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    routine_instance_add_reference_with_cluster(test_routine,
                                                result->reference_cluster);
    result->u.test_routine.test_routine = test_routine;

    result->validator = validator_add_instance(result->validator,
            routine_instance_instance(test_routine));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern type *get_test_routine_chain_type(
        routine_instance_chain *instance_chain)
  {
    type *result;

    assert(instance_chain != NULL);

    assert(routine_instance_chain_is_valid(instance_chain)); /* VERIFIED */

    result = create_empty_type(TK_TEST_ROUTINE_CHAIN);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = all_possible_value_kinds;

    assert(result->reference_cluster == NULL);
    result->reference_cluster =
            routine_instance_chain_reference_cluster(instance_chain);
    if (result->reference_cluster != NULL)
        reference_cluster_add_reference(result->reference_cluster);
    routine_instance_chain_add_reference_with_cluster(instance_chain,
            result->reference_cluster);
    result->u.test_routine_chain.routine_chain = instance_chain;

    result->validator = validator_add_validator(result->validator,
            routine_instance_chain_validator(instance_chain));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    return result;
  }

extern void type_add_reference(type *the_type)
  {
    assert(the_type != NULL);

    GRAB_SYSTEM_LOCK(the_type->reference_lock);
    assert(the_type->reference_count > 0);
    ++(the_type->reference_count);
    RELEASE_SYSTEM_LOCK(the_type->reference_lock);

    if (the_type->reference_cluster != NULL)
        reference_cluster_add_reference(the_type->reference_cluster);
  }

static void delete_type(type *the_type, jumper *the_jumper);
extern void type_remove_reference(type *the_type, jumper *the_jumper)
  {
    size_t new_reference_count;

    assert(the_type != NULL);

    GRAB_SYSTEM_LOCK(the_type->reference_lock);
    assert(the_type->reference_count > 0);
    --(the_type->reference_count);
    new_reference_count = the_type->reference_count;
    RELEASE_SYSTEM_LOCK(the_type->reference_lock);

    if (the_type->reference_cluster != NULL)
      {
        reference_cluster_remove_reference(the_type->reference_cluster,
                                           the_jumper);
      }

    if (new_reference_count == 0)
        delete_type(the_type, the_jumper);
  }

static void delete_type(type *the_type, jumper *the_jumper)
  {
    assert(the_type != anything_type);
    assert(the_type != nothing_type);
    assert(the_type != integer_type);
    assert(the_type != finite_integer_type);
    assert(the_type != rational_type);
    assert(the_type != any_regular_expression_type);
    assert(the_type != any_quark_type);
    assert(the_type != any_lepton_type);
    assert(the_type != lepton_key_type);
    assert(the_type != jump_target_type);
    assert(the_type != any_class_type);
    assert(the_type != object_type);
    assert(the_type != any_tagalong_key_type);
    assert(the_type != lock_type);
    assert(the_type != string_type);
    assert(the_type != character_type);
    assert(the_type != boolean_type);

    if (the_type->validator != NULL)
        validator_remove_reference(the_type->validator);

    switch (the_type->kind)
      {
        case TK_ANYTHING:
          {
            break;
          }
        case TK_NOTHING:
          {
            break;
          }
        case TK_INTEGER:
          {
            break;
          }
        case TK_RATIONAL:
          {
            break;
          }
        case TK_ANY_REGULAR_EXPRESSION:
          {
            break;
          }
        case TK_ANY_QUARK:
          {
            break;
          }
        case TK_ANY_LEPTON:
          {
            break;
          }
        case TK_LEPTON_KEY:
          {
            break;
          }
        case TK_JUMP_TARGET:
          {
            break;
          }
        case TK_ANY_CLASS:
          {
            break;
          }
        case TK_OBJECT:
          {
            break;
          }
        case TK_TAGALONG_KEY:
          {
            break;
          }
        case TK_LOCK:
          {
            break;
          }
        case TK_STRING:
          {
            break;
          }
        case TK_CHARACTER:
          {
            break;
          }
        case TK_ENUMERATION:
          {
            size_t value_count;
            size_t value_num;

            value_count = the_type->u.enumeration.value_count;

            for (value_num = 0; value_num < value_count; ++value_num)
              {
                value_remove_reference_with_reference_cluster(
                        the_type->u.enumeration.values[value_num], the_jumper,
                        the_type->reference_cluster);
              }

            if (value_count > 0)
                free(the_type->u.enumeration.values);

            break;
          }
        case TK_NOT:
          {
            type_remove_reference_with_reference_cluster(the_type->u.not.base,
                    the_jumper, the_type->reference_cluster);
            break;
          }
        case TK_INTERSECTION:
          {
            type_remove_reference_with_reference_cluster(
                    the_type->u.intersection.left, the_jumper,
                    the_type->reference_cluster);
            type_remove_reference_with_reference_cluster(
                    the_type->u.intersection.right, the_jumper,
                    the_type->reference_cluster);
            break;
          }
        case TK_UNION:
          {
            type_remove_reference_with_reference_cluster(
                    the_type->u.union_type.left, the_jumper,
                    the_type->reference_cluster);
            type_remove_reference_with_reference_cluster(
                    the_type->u.union_type.right, the_jumper,
                    the_type->reference_cluster);
            break;
          }
        case TK_XOR:
          {
            type_remove_reference_with_reference_cluster(the_type->u.xor.left,
                    the_jumper, the_type->reference_cluster);
            type_remove_reference_with_reference_cluster(the_type->u.xor.right,
                    the_jumper, the_type->reference_cluster);
            break;
          }
        case TK_ARRAY:
          {
            type_remove_reference_with_reference_cluster(
                    the_type->u.array.base, the_jumper,
                    the_type->reference_cluster);
            oi_remove_reference(the_type->u.array.lower_bound);
            oi_remove_reference(the_type->u.array.upper_bound);
            break;
          }
        case TK_INTEGER_RANGES:
          {
            size_t component_count;
            integer_range_component *components;
            size_t component_num;

            component_count = the_type->u.integer_ranges.component_count;
            components = the_type->u.integer_ranges.components;
            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                oi_remove_reference(components[component_num].lower_bound);
                oi_remove_reference(components[component_num].upper_bound);
              }
            if (component_count == 0)
                assert(components == NULL);
            else
                free(components);
            break;
          }
        case TK_RATIONAL_RANGES:
          {
            size_t component_count;
            rational_range_component *components;
            size_t component_num;

            component_count = the_type->u.rational_ranges.component_count;
            components = the_type->u.rational_ranges.components;
            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                rational_remove_reference(
                        components[component_num].lower_bound);
                rational_remove_reference(
                        components[component_num].upper_bound);
              }
            free(components);
            break;
          }
        case TK_POINTER:
          {
            type_remove_reference_with_reference_cluster(
                    the_type->u.pointer.base, the_jumper,
                    the_type->reference_cluster);
            break;
          }
        case TK_TYPE:
          {
            type_remove_reference_with_reference_cluster(the_type->u.type.base,
                    the_jumper, the_type->reference_cluster);
            break;
          }
        case TK_MAP:
          {
            type_remove_reference_with_reference_cluster(the_type->u.map.key,
                    the_jumper, the_type->reference_cluster);
            type_remove_reference_with_reference_cluster(
                    the_type->u.map.target, the_jumper,
                    the_type->reference_cluster);
            break;
          }
        case TK_ROUTINE:
          {
            size_t argument_count;
            size_t argument_num;

            type_remove_reference_with_reference_cluster(
                    the_type->u.routine.return_type, the_jumper,
                    the_type->reference_cluster);

            argument_count = the_type->u.routine.argument_count;

            for (argument_num = 0; argument_num < argument_count;
                 ++argument_num)
              {
                type_remove_reference_with_reference_cluster(
                        the_type->u.routine.argument_types[argument_num],
                        the_jumper, the_type->reference_cluster);
                if (the_type->u.routine.argument_names[argument_num] != NULL)
                    free(the_type->u.routine.argument_names[argument_num]);
              }

            if (argument_count > 0)
              {
                free(the_type->u.routine.argument_types);
                free(the_type->u.routine.argument_names);
                free(the_type->u.routine.argument_has_defaults);
              }

            break;
          }
        case TK_FIELDS:
          {
            deallocate_field_info(&(the_type->u.fields.field_info), the_jumper,
                                  the_type->reference_cluster);

            break;
          }
        case TK_LEPTON:
          {
            lepton_key_instance_remove_reference_with_cluster(
                    the_type->u.lepton.key, the_jumper,
                    the_type->reference_cluster);

            deallocate_field_info(&(the_type->u.lepton.field_info), the_jumper,
                                  the_type->reference_cluster);

            break;
          }
        case TK_MULTISET:
          {
            deallocate_field_info(&(the_type->u.multiset.field_info),
                                  the_jumper, the_type->reference_cluster);

            break;
          }
        case TK_INTERFACE:
          {
            if (the_type->u.interface.field_info.field_count > 0)
                free(the_type->u.interface.item_writing_alloweds);

            deallocate_field_info(&(the_type->u.interface.field_info),
                                  the_jumper, the_type->reference_cluster);

            break;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t element_count;
            size_t element_num;

            element_count = the_type->u.semi_labeled_value_list.element_count;

            for (element_num = 0; element_num < element_count; ++element_num)
              {
                type_remove_reference_with_reference_cluster(
                        the_type->u.semi_labeled_value_list.element_types[
                                element_num], the_jumper,
                        the_type->reference_cluster);
                if (the_type->u.semi_labeled_value_list.element_names[
                            element_num] != NULL)
                  {
                    free(the_type->u.semi_labeled_value_list.element_names[
                                 element_num]);
                  }
              }

            if (element_count > 0)
              {
                free(the_type->u.semi_labeled_value_list.element_types);
                free(the_type->u.semi_labeled_value_list.element_names);
              }

            if (the_type->u.semi_labeled_value_list.allowed_fields != NULL)
              {
                destroy_string_index(
                        the_type->u.semi_labeled_value_list.allowed_fields);
              }

            break;
          }
        case TK_REGULAR_EXPRESSION:
          {
            regular_expression_remove_reference(
                    the_type->u.regular_expression.regular_expression);
            break;
          }
        case TK_CLASS:
          {
            routine_instance_remove_reference_with_cluster(
                    the_type->u.class.routine, the_type->reference_cluster,
                    the_jumper);
            break;
          }
        case TK_TEST_ROUTINE:
          {
            routine_instance_remove_reference_with_cluster(
                    the_type->u.test_routine.test_routine,
                    the_type->reference_cluster, the_jumper);
            free(the_type->u.test_routine.provisional_subsets.array);
            free(the_type->u.test_routine.provisional_supersets.array);
            break;
          }
        case TK_TEST_ROUTINE_CHAIN:
          {
            routine_instance_chain_remove_reference_with_cluster(
                    the_type->u.test_routine_chain.routine_chain,
                    the_type->reference_cluster, the_jumper);
            break;
          }
        case TK_SEPARATOR:
          {
            break;
          }
        default:
          {
            assert(FALSE);
          }
      }

    DESTROY_SYSTEM_LOCK(the_type->reference_lock);

    free(the_type);
  }

extern void type_add_reference_with_reference_cluster(type *the_type,
        reference_cluster *cluster)
  {
    assert(the_type != NULL);

    GRAB_SYSTEM_LOCK(the_type->reference_lock);
    assert(the_type->reference_count > 0);
    ++(the_type->reference_count);
    RELEASE_SYSTEM_LOCK(the_type->reference_lock);

    if ((the_type->reference_cluster != NULL) &&
        (the_type->reference_cluster != cluster))
      {
        reference_cluster_add_reference(the_type->reference_cluster);
      }
  }

extern void type_remove_reference_with_reference_cluster(type *the_type,
        jumper *the_jumper, reference_cluster *cluster)
  {
    size_t new_reference_count;

    assert(the_type != NULL);

    GRAB_SYSTEM_LOCK(the_type->reference_lock);
    assert(the_type->reference_count > 0);
    --(the_type->reference_count);
    new_reference_count = the_type->reference_count;
    RELEASE_SYSTEM_LOCK(the_type->reference_lock);

    if ((the_type->reference_cluster != NULL) &&
        (the_type->reference_cluster != cluster))
      {
        reference_cluster_remove_reference(the_type->reference_cluster,
                                           the_jumper);
      }

    if (new_reference_count == 0)
        delete_type(the_type, the_jumper);
  }

extern reference_cluster *type_reference_cluster(type *the_type)
  {
    assert(the_type != NULL);

    return the_type->reference_cluster;
  }

extern type_kind get_type_kind(type *the_type)
  {
    assert(the_type != NULL);

    return the_type->kind;
  }

extern boolean value_is_in_type(value *the_value, type *the_type,
        boolean *doubt, char **why_not, const source_location *location,
        jumper *the_jumper)
  {
    assert(the_value != NULL);
    assert(the_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(the_type)); /* VERIFIED */

    if (!(value_is_valid(the_value)))
      {
        switch (the_type->kind)
          {
            case TK_ANYTHING:
                *doubt = FALSE;
                return TRUE;
            case TK_NOTHING:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                                        "no value is in the empty type");
            default:
                break;
          }

        if (jumper_thread(the_jumper) == NULL)
          {
            assert(why_not == NULL);
            *doubt = TRUE;
            return FALSE;
          }

        assert(type_is_valid(the_type)); /* VERIFIED */
        if (possibly_nothing(the_type))
          {
            location_exception(the_jumper, location,
                    EXCEPTION_TAG(type_for_invalid_nothing_indeterminate),
                    "While checking to see if an invaid value was in a type, "
                    "%s could not determine whether the type could be the "
                    "empty type or not.", interpreter_name());
            return FALSE;
          }

        assert(type_is_valid(the_type)); /* VERIFIED */
        if (possibly_everything(the_type))
          {
            location_exception(the_jumper, location,
                    EXCEPTION_TAG(type_for_invalid_everything_indeterminate),
                    "While checking to see if an invaid value was in a type, "
                    "%s could not determine whether the type could be the type"
                    " of all values or not.", interpreter_name());
            return FALSE;
          }

        check_value_validity(the_value, location, the_jumper);
        assert(!(jumper_flowing_forward(the_jumper)));
        return FALSE;
      }

    assert(value_is_valid(the_value)); /* VERIFIED */
    assert(type_is_valid(the_type)); /* VERIFIED */

    if ((the_type->possible_value_kinds & VK_BIT(get_value_kind(the_value))) ==
        0)
      {
        if (why_not == NULL)
          {
            *doubt = FALSE;
            return FALSE;
          }

        switch (the_type->kind)
          {
            case TK_ANYTHING:
                assert(FALSE);
                break;
            case TK_NOTHING:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                                        "no value is in the empty type");
            case TK_INTEGER:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not an integer and the type is that of "
                        "all integers");
            case TK_RATIONAL:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a rational and the type is that of "
                        "all rationals");
            case TK_ANY_REGULAR_EXPRESSION:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a regular expression and the type is"
                        " that of all regular expressions");
            case TK_ANY_QUARK:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a quark and the type is that of all "
                        "quarks");
            case TK_ANY_LEPTON:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a lepton and the type is that of all"
                        " leptons");
            case TK_LEPTON_KEY:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a lepton key and the type is that of"
                        " all lepton keys");
            case TK_JUMP_TARGET:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a jump target and the type is that "
                        "of all jump targets");
            case TK_ANY_CLASS:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a routine of any sort and the type "
                        "is that of all classes");
            case TK_OBJECT:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not an object and the type is that of "
                        "all objects");
            case TK_TAGALONG_KEY:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a tagalong key and the type is that "
                        "of all tagalong keys");
            case TK_LOCK:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a lock and the type is that of all "
                        "locks");
            case TK_STRING:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a string and the type is that of all"
                        " strings");
            case TK_CHARACTER:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a character and the type is that of "
                        "all characters");
            case TK_ENUMERATION:
                goto enumeration_no_match;
            case TK_NOT:
                assert(FALSE);
                break;
            case TK_ARRAY:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a map or semi-labeled value list and"
                        " the type is an array type");
            case TK_INTEGER_RANGES:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not an integer and the type is a subset "
                        "of the integers");
            case TK_RATIONAL_RANGES:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a rational and the type is a subset "
                        "of the rationals");
            case TK_POINTER:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        ((get_value_kind(the_value) == VK_NULL) ?
                         "the value is null and the type is a pointer type "
                         "that disallows null values" :
                         "the type is a pointer type and the value is neither "
                         "a pointer nor null"));
            case TK_TYPE:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a type and the type is a type type");
            case TK_MAP:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a map or semi-labeled value list and"
                        " the type is a map type");
            case TK_ROUTINE:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the value is not a routine or routine chain and the "
                        "type is a routine type");
            case TK_FIELDS:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a fields type and the value is one that "
                        "has no fields");
            case TK_LEPTON:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a lepton type and the value is not a "
                        "lepton");
            case TK_MULTISET:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a multi-set type and the value is not a "
                        "multi-set");
            case TK_INTERFACE:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is an interface type and the value is one "
                        "that has no fields");
            case TK_SEMI_LABELED_VALUE_LIST:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a semi-labeled value list type and the "
                        "value is not a semi-labeled value list or map value");
            case TK_REGULAR_EXPRESSION:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a regular expression type and the value "
                        "is not a string value");
            case TK_CLASS:
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a class type and the value is not an "
                        "object value");
            case TK_TEST_ROUTINE:
            case TK_TEST_ROUTINE_CHAIN:
                assert(FALSE);
                break;
            default:
                /*
                 * For the other cases, the messages we want are more complex.
                 * So, we'll drop out of here and do the usual process,
                 * ignoring that we already know the result will be that the
                 * value is not in the type, just so we can generate the
                 * appropriate message.
                 */
                break;
          }
      }

    switch (the_type->kind)
      {
        case TK_ANYTHING:
          {
            *doubt = FALSE;
            return TRUE;
          }
        case TK_NOTHING:
          {
            assert(FALSE);
          }
        case TK_INTEGER:
          {
            assert(get_value_kind(the_value) == VK_INTEGER);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_RATIONAL:
          {
            assert((get_value_kind(the_value) == VK_INTEGER) ||
                   (get_value_kind(the_value) == VK_RATIONAL));
            *doubt = FALSE;
            return TRUE;
          }
        case TK_ANY_REGULAR_EXPRESSION:
          {
            assert(get_value_kind(the_value) == VK_REGULAR_EXPRESSION);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_ANY_QUARK:
          {
            assert(get_value_kind(the_value) == VK_QUARK);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_ANY_LEPTON:
          {
            assert(get_value_kind(the_value) == VK_LEPTON);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_LEPTON_KEY:
          {
            assert(get_value_kind(the_value) == VK_LEPTON_KEY);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_JUMP_TARGET:
          {
            assert(get_value_kind(the_value) == VK_JUMP_TARGET);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_ANY_CLASS:
          {
            routine_instance *instance;
            routine_declaration *declaration;

            switch (get_value_kind(the_value))
              {
                case VK_ROUTINE:
                  {
                    instance = routine_value_data(the_value);
                    break;
                  }
                case VK_ROUTINE_CHAIN:
                  {
                    routine_instance_chain *instance_chain;

                    instance_chain = routine_chain_value_data(the_value);
                    assert(instance_chain != NULL);

                    instance = routine_instance_chain_instance(instance_chain);

                    break;
                  }
                default:
                  {
                    assert(FALSE);
                    break;
                  }
              }

            assert(instance != NULL);

            declaration = routine_instance_declaration(instance);
            assert(declaration != NULL);

            return type_in_no_doubt(routine_declaration_is_class(declaration),
                    doubt, why_not, the_jumper,
                    "the value is a non-class routine and the type is that of "
                    "all classes");
          }
        case TK_OBJECT:
          {
            assert(get_value_kind(the_value) == VK_OBJECT);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_TAGALONG_KEY:
          {
            assert(get_value_kind(the_value) == VK_TAGALONG_KEY);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_LOCK:
          {
            assert(get_value_kind(the_value) == VK_LOCK);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_STRING:
          {
            assert(get_value_kind(the_value) == VK_STRING);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_CHARACTER:
          {
            assert(get_value_kind(the_value) == VK_CHARACTER);
            *doubt = FALSE;
            return TRUE;
          }
        case TK_ENUMERATION:
          {
            size_t value_count;

            assert(value_is_valid(the_value)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */

            value_count = the_type->u.enumeration.value_count;

            if (the_type->u.enumeration.slippery)
              {
                char *doubt_why_not;
                size_t value_num;

                doubt_why_not = NULL;
                *doubt = FALSE;

                for (value_num = 0; value_num < value_count; ++value_num)
                  {
                    value *item;
                    boolean local_doubt;
                    boolean equal;

                    assert(type_is_valid(the_type)); /* VERIFIED */
                    item = the_type->u.enumeration.values[value_num];
                    assert(value_is_valid(the_value)); /* VERIFIED */
                    assert(value_is_valid(item)); /* VERIFIED */
                    equal = values_are_equal(the_value, item, &local_doubt,
                                             location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if (doubt_why_not != NULL)
                            free(doubt_why_not);
                        return FALSE;
                      }
                    if (equal && !local_doubt)
                      {
                        if (doubt_why_not != NULL)
                            free(doubt_why_not);
                        *doubt = FALSE;
                        return TRUE;
                      }
                    if (local_doubt)
                      {
                        *doubt = TRUE;
                        if ((why_not != NULL) && (doubt_why_not == NULL))
                          {
                            doubt_why_not = allocate_printf(
                                    "the type is an enumeration and it is "
                                    "unclear whether the value is equal to %U,"
                                    " which is one of the items in the "
                                    "enumeration list", item);
                            if (doubt_why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                *doubt = FALSE;
                                return FALSE;
                              }
                          }
                      }
                  }

                if (doubt_why_not != NULL)
                  {
                    assert(*doubt == TRUE);
                    assert(why_not != NULL);
                    *why_not = doubt_why_not;
                  }
                else if (why_not != NULL)
                  {
                    assert(*doubt == FALSE);
                  enumeration_no_match:
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the type is an enumeration and the value is not "
                            "in the enumeration list");
                  }
                return FALSE;
              }
            else
              {
                size_t lower;
                size_t upper;

                lower = 0;
                upper = value_count;

                while (TRUE)
                  {
                    size_t to_test;
                    int test_order;

                    assert(lower <= upper);
                    assert(upper <= value_count);

                    if (lower >= upper)
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the type is an enumeration and the value is "
                                "not in the enumeration list");
                      }

                    to_test = (lower + ((upper - lower) / 2));
                    assert(to_test >= lower);
                    assert(to_test < upper);

                    assert(value_is_valid(the_value)); /* VERIFIED */
                    assert(type_is_valid(the_type)); /* VERIFIED */
                    assert(value_is_valid(
                            the_type->u.enumeration.values[to_test]));
                                    /* VERIFIED */
                    test_order = value_structural_order(the_value,
                            the_type->u.enumeration.values[to_test]);
                    if (test_order == -2)
                      {
                        jumper_do_abort(the_jumper);
                        *doubt = FALSE;
                        return FALSE;
                      }
                    else if (test_order == 0)
                      {
                        *doubt = FALSE;
                        return TRUE;
                      }
                    else if (test_order < 0)
                      {
                        upper = to_test;
                      }
                    else
                      {
                        lower = to_test + 1;
                      }
                  }
              }
          }
        case TK_NOT:
          {
            boolean result;

            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(type_is_valid(the_type->u.not.base)); /* VERIFIED */
            result = !(value_is_in_type(the_value, the_type->u.not.base, doubt,
                                        why_not, location, the_jumper));

            if ((!(*doubt)) && (why_not != NULL))
              {
                if (result)
                  {
                    assert(*why_not != NULL);
                    free(*why_not);
                    *why_not = NULL;
                  }
                else
                  {
                    *why_not = allocate_printf(
                            "the type is the negation of another type and the "
                            "value is in that type");
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
              }

            return result;
          }
        case TK_INTERSECTION:
          {
            boolean doubt_left;
            char *why_not_left;
            boolean in_left;
            boolean doubt_right;
            char *why_not_right;
            boolean in_right;

            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(type_is_valid(the_type->u.intersection.left));
                    /* VERIFIED */
            assert(type_is_valid(the_type->u.intersection.right));
                    /* VERIFIED */

            in_left = value_is_in_type(the_value,
                    the_type->u.intersection.left, &doubt_left,
                    ((why_not == NULL) ? NULL : &why_not_left), location,
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            if ((!in_left) && (!doubt_left))
              {
                *doubt = FALSE;
                if (why_not != NULL)
                  {
                    assert(why_not_left != NULL);
                    *why_not = allocate_printf(
                            "the type is an intersection type and the value is"
                            " not in the left-hand type of the intersection "
                            "because %s", why_not_left);
                    free(why_not_left);
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
                return FALSE;
              }

            assert(type_is_valid(the_type->u.intersection.right));
                    /* VERIFIED */
            in_right = value_is_in_type(the_value,
                    the_type->u.intersection.right, &doubt_right,
                    ((why_not == NULL) ? NULL : &why_not_right), location,
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if ((why_not != NULL) && doubt_left)
                  {
                    assert(why_not_left != NULL);
                    free(why_not_left);
                  }
                return FALSE;
              }
            if ((!in_right) && (!doubt_right))
              {
                *doubt = FALSE;
                if (why_not != NULL)
                  {
                    if (doubt_left)
                      {
                        assert(why_not_left != NULL);
                        free(why_not_left);
                      }
                    assert(why_not_right != NULL);
                    *why_not = allocate_printf(
                            "the type is an intersection type and the value is"
                            " not in the right-hand type of the intersection "
                            "because %s", why_not_right);
                    free(why_not_right);
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
                return FALSE;
              }

            *doubt = (doubt_left || doubt_right);
            if ((why_not != NULL) && (doubt_left || doubt_right))
              {
                if (doubt_left && doubt_right)
                  {
                    assert(doubt_left && doubt_right);
                    assert(why_not_left != NULL);
                    assert(why_not_right != NULL);
                    *why_not = allocate_printf(
                            "the type is an intersection type and it is "
                            "unclear if the value is in the left-hand type of "
                            "the intersection because %s; and it is unclear if"
                            " the value is in the right-hand type of the "
                            "intersection because %s", why_not_left,
                            why_not_right);
                    free(why_not_left);
                    free(why_not_right);
                  }
                else if (doubt_left)
                  {
                    assert(doubt_left && !doubt_right);
                    assert(why_not_left != NULL);
                    *why_not = allocate_printf(
                            "the type is an intersection type and the value is"
                            " in the right-hand type of the intersection and "
                            "it is unclear if the value is in the left-hand "
                            "type of the intersection because %s",
                            why_not_left);
                    free(why_not_left);
                  }
                else
                  {
                    assert((!doubt_left) && doubt_right);
                    assert(why_not_right != NULL);
                    *why_not = allocate_printf(
                            "the type is an intersection type and the value is"
                            " in the left-hand type of the intersection and it"
                            " is unclear if the value is in the right-hand "
                            "type of the intersection because %s",
                            why_not_right);
                    free(why_not_right);
                  }
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    *doubt = FALSE;
                    return FALSE;
                  }
              }
            return (in_left && in_right);
          }
        case TK_UNION:
          {
            boolean doubt_left;
            char *why_not_left;
            boolean in_left;
            boolean doubt_right;
            char *why_not_right;
            boolean in_right;

            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(type_is_valid(the_type->u.union_type.left)); /* VERIFIED */
            assert(type_is_valid(the_type->u.union_type.right)); /* VERIFIED */

            in_left = value_is_in_type(the_value, the_type->u.union_type.left,
                    &doubt_left, ((why_not == NULL) ? NULL : &why_not_left),
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            if (in_left && (!doubt_left))
              {
                *doubt = FALSE;
                return TRUE;
              }

            assert(type_is_valid(the_type->u.union_type.right)); /* VERIFIED */
            in_right = value_is_in_type(the_value,
                    the_type->u.union_type.right, &doubt_right,
                    ((why_not == NULL) ? NULL : &why_not_right), location,
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if (why_not != NULL)
                  {
                    assert(why_not_left != NULL);
                    free(why_not_left);
                  }
                return FALSE;
              }
            if (in_right && (!doubt_right))
              {
                if (why_not != NULL)
                  {
                    assert(why_not_left != NULL);
                    free(why_not_left);
                  }
                *doubt = FALSE;
                return TRUE;
              }

            *doubt = (doubt_left || doubt_right);
            if (why_not != NULL)
              {
                assert(why_not_left != NULL);
                assert(why_not_right != NULL);
                *why_not = allocate_printf(
                        "the type is a union type and %s in the left-hand type"
                        " of the union because %s; and %s in the right-hand "
                        "type of the union because %s",
                        (doubt_left ? "it is unclear if the value is" :
                                      "the value is not"), why_not_left,
                        (doubt_right ? "it is unclear if the value is" :
                                       "the value is not"), why_not_right);
                free(why_not_left);
                free(why_not_right);
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    *doubt = FALSE;
                    return FALSE;
                  }
              }
            return (in_left || in_right);
          }
        case TK_XOR:
          {
            boolean doubt_left;
            char *why_not_left;
            boolean in_left;
            boolean doubt_right;
            char *why_not_right;
            boolean in_right;

            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(type_is_valid(the_type->u.xor.left)); /* VERIFIED */
            assert(type_is_valid(the_type->u.xor.right)); /* VERIFIED */

            in_left = value_is_in_type(the_value, the_type->u.xor.left,
                    &doubt_left, ((why_not == NULL) ? NULL : &why_not_left),
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;

            assert(type_is_valid(the_type->u.xor.right)); /* VERIFIED */
            in_right = value_is_in_type(the_value, the_type->u.xor.right,
                    &doubt_right, ((why_not == NULL) ? NULL : &why_not_right),
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if ((why_not != NULL) && ((!in_left) || doubt_left))
                  {
                    assert(why_not_left != NULL);
                    free(why_not_left);
                  }
                return FALSE;
              }

            *doubt = (doubt_left || doubt_right);
            if (why_not != NULL)
              {
                boolean no_reason;

                no_reason = FALSE;
                if (doubt_left && doubt_right)
                  {
                    assert(why_not_left != NULL);
                    assert(why_not_right != NULL);
                    *why_not = allocate_printf(
                            "the type is an exclusive-or type and it is "
                            "unclear if the value is in the left-hand type of "
                            "the exclusive-or because %s; and it is unclear if"
                            " the value is in the right-hand type of the "
                            "exclusive-or because %s", why_not_left,
                            why_not_right);
                  }
                else if (doubt_left)
                  {
                    assert(why_not_left != NULL);
                    *why_not = allocate_printf(
                            "the type is an exclusive-or type and it is "
                            "unclear if the value is in the left-hand type of "
                            "the exclusive-or because %s", why_not_left);
                  }
                else if (doubt_right)
                  {
                    assert(why_not_right != NULL);
                    *why_not = allocate_printf(
                            "the type is an exclusive-or type and it is "
                            "unclear if the value is in the right-hand type of"
                            " the exclusive-or because %s", why_not_right);
                  }
                else if (in_left && in_right)
                  {
                    *why_not = allocate_printf(
                            "the type is an exclusive-or type and the value is"
                            " in both the left-hand and the right-hand types "
                            "of the exclusive-or");
                  }
                else if ((!in_left) && (!in_right))
                  {
                    assert(why_not_left != NULL);
                    assert(why_not_right != NULL);
                    *why_not = allocate_printf(
                            "the type is an exclusive-or type and the value is"
                            " not in the left-hand type of the exclusive-or "
                            "because %s; and the value is not in the right-"
                            "hand type of the exclusive-or because %s",
                            why_not_left, why_not_right);
                  }
                else
                  {
                    no_reason = TRUE;
                  }

                if ((!no_reason) && (*why_not == NULL))
                  {
                    jumper_do_abort(the_jumper);
                    *doubt = FALSE;
                    return FALSE;
                  }

                if ((!in_left) || doubt_left)
                  {
                    assert(why_not_left != NULL);
                    free(why_not_left);
                  }
                if ((!in_right) || doubt_right)
                  {
                    assert(why_not_right != NULL);
                    free(why_not_right);
                  }
              }
            return ((in_left && !in_right) || (in_right && !in_left));
          }
        case TK_ARRAY:
          {
            char *doubt_why_not;

            assert(value_is_valid(the_value)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */

            doubt_why_not = NULL;
            *doubt = FALSE;

            switch (get_value_kind(the_value))
              {
                case VK_MAP:
                  {
                    size_t item_count;
                    size_t item_num;

                    item_count = map_value_item_count(the_value);

                    for (item_num = 0; item_num < item_count; ++item_num)
                      {
                        boolean local_doubt;
                        char *local_why_not;
                        boolean ok;

                        if (map_value_item_is_type(the_value, item_num))
                          {
                            type *key_type;
                            type *range_type;
                            boolean key_doubt;
                            char *key_why_not;
                            boolean is_in;

                            assert(value_is_valid(the_value)); /* VERIFIED */
                            key_type = map_value_item_key_type(the_value,
                                                               item_num);
                            assert(key_type != NULL);
                            assert(type_is_valid(key_type)); /* VERIFIED */

                            range_type = get_integer_range_type(
                                    the_type->u.array.lower_bound,
                                    the_type->u.array.upper_bound, TRUE, TRUE);
                            if (range_type == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                if (doubt_why_not != NULL)
                                    free(doubt_why_not);
                                return FALSE;
                              }

                            assert(type_is_valid(key_type)); /* VERIFIED */
                            assert(type_is_valid(range_type)); /* VERIFIED */
                            is_in = type_is_subset(key_type, range_type,
                                    &key_doubt,
                                    ((why_not == NULL) ? NULL : &key_why_not),
                                    location, the_jumper);
                            type_remove_reference(range_type,
                                    ((jumper_thread(the_jumper) == NULL) ?
                                     NULL : the_jumper));
                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                if (doubt_why_not != NULL)
                                    free(doubt_why_not);
                                return FALSE;
                              }

                            if (key_doubt)
                              {
                                *doubt = TRUE;
                                if (why_not != NULL)
                                  {
                                    assert(key_why_not != NULL);
                                    if (doubt_why_not != NULL)
                                      {
                                        free(key_why_not);
                                      }
                                    else
                                      {
                                        doubt_why_not = allocate_printf(
                                                "the value is a map with key "
                                                "filter type %t and the type "
                                                "is an array with bounds "
                                                "[%I...%I] and it is unclear "
                                                "whether the key filter type "
                                                "is a subset of that range "
                                                "because %s", key_type,
                                                the_type->u.array.lower_bound,
                                                the_type->u.array.upper_bound,
                                                key_why_not);
                                        free(key_why_not);
                                        if (doubt_why_not == NULL)
                                          {
                                            jumper_do_abort(the_jumper);
                                            return FALSE;
                                          }
                                      }
                                  }
                              }
                            else if (!is_in)
                              {
                                if (doubt_why_not != NULL)
                                    free(doubt_why_not);
                                *doubt = FALSE;
                                if (why_not != NULL)
                                  {
                                    assert(key_why_not != NULL);
                                    *why_not = allocate_printf(
                                            "the value is a map with key "
                                            "filter type %t and the type is an"
                                            " array with bounds [%I...%I] and "
                                            "the key filter type is not a "
                                            "subset of that range because %s",
                                            key_type,
                                            the_type->u.array.lower_bound,
                                            the_type->u.array.upper_bound,
                                            key_why_not);
                                    free(key_why_not);
                                    if (*why_not == NULL)
                                        jumper_do_abort(the_jumper);
                                  }
                                return FALSE;
                              }
                          }
                        else
                          {
                            value *key_value;
                            o_integer key_oi;

                            key_value = map_value_item_key_value(the_value,
                                                                 item_num);
                            assert(key_value != NULL);

                            if (get_value_kind(key_value) != VK_INTEGER)
                              {
                                if (doubt_why_not != NULL)
                                    free(doubt_why_not);
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the value is a map with non-integer "
                                        "key %U and the type is an array type",
                                        key_value);
                              }

                            key_oi = integer_value_data(key_value);
                            assert(!(oi_out_of_memory(key_oi)));

                            if ((oi_kind(key_oi) == IIK_UNSIGNED_INFINITY) ||
                                (oi_kind(key_oi) == IIK_ZERO_ZERO))
                              {
                                if (doubt_why_not != NULL)
                                    free(doubt_why_not);
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the value is a map with key %I and "
                                        "the type is an array type", key_oi);
                              }

                            if (oi_less_than(key_oi,
                                             the_type->u.array.lower_bound))
                              {
                                if (doubt_why_not != NULL)
                                    free(doubt_why_not);
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the value is a map with key %I and "
                                        "the type is an array type with lower "
                                        "bound %I", key_oi,
                                        the_type->u.array.lower_bound);
                              }

                            if (oi_less_than(the_type->u.array.upper_bound,
                                             key_oi))
                              {
                                if (doubt_why_not != NULL)
                                    free(doubt_why_not);
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the value is a map with key %I and "
                                        "the type is an array type with upper "
                                        "bound %I", key_oi,
                                        the_type->u.array.upper_bound);
                              }
                          }

                        assert(type_is_valid(the_type)); /* VERIFIED */
                        assert(type_is_valid(the_type->u.array.base));
                                /* VERIFIED */
                        ok = value_is_in_type(
                                map_value_item_target(the_value, item_num),
                                the_type->u.array.base, &local_doubt,
                                ((why_not == NULL) ? NULL : &local_why_not),
                                location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            return FALSE;
                          }
                        if (local_doubt)
                          {
                            *doubt = TRUE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                if (doubt_why_not != NULL)
                                  {
                                    free(local_why_not);
                                  }
                                else
                                  {
                                    doubt_why_not = allocate_printf(
                                            "the value is a map with element "
                                            "%U and the type is an array type "
                                            "with an element type for which it"
                                            " is unclear whether that element "
                                            "value is in that element type "
                                            "because %s",
                                            map_value_item_target(the_value,
                                                    item_num), local_why_not);
                                    free(local_why_not);
                                    if (doubt_why_not == NULL)
                                      {
                                        jumper_do_abort(the_jumper);
                                        return FALSE;
                                      }
                                  }
                              }
                          }
                        else if (!ok)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            *doubt = FALSE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                *why_not = allocate_printf(
                                        "the value is a map with element %U "
                                        "and the type is an array with an "
                                        "element type that the element value "
                                        "is not in because %s",
                                        map_value_item_target(the_value,
                                                item_num), local_why_not);
                                free(local_why_not);
                                if (*why_not == NULL)
                                    jumper_do_abort(the_jumper);
                              }
                            return FALSE;
                          }
                      }

                    break;
                  }
                case VK_SEMI_LABELED_VALUE_LIST:
                  {
                    size_t component_count;
                    o_integer top_oi;
                    size_t component_num;

                    component_count = value_component_count(the_value);

                    if (component_count == 0)
                        return TRUE;

                    if (oi_less_than(oi_zero, the_type->u.array.lower_bound))
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the value is a non-empty semi-labeled value "
                                "list and the type is an array type with a "
                                "greater-than-zero lower bound (%I)",
                                the_type->u.array.lower_bound);
                      }

                    oi_create_from_size_t(top_oi, component_count - 1);
                    if (oi_out_of_memory(top_oi))
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }

                    if (oi_less_than(the_type->u.array.upper_bound, top_oi))
                      {
                        oi_remove_reference(top_oi);
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the value is a semi-labeled value list with "
                                "%lu elements and the type is an array type "
                                "with an upper bound of %I",
                                (unsigned long)component_count,
                                the_type->u.array.upper_bound);
                      }
                    oi_remove_reference(top_oi);

                    for (component_num = 0; component_num < component_count;
                         ++component_num)
                      {
                        boolean local_doubt;
                        char *local_why_not;
                        boolean ok;

                        if (value_component_label(the_value, component_num) !=
                            NULL)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the value is a semi-labeled value list "
                                    "with a label (%s) on element number %lu "
                                    "and the type is an array type",
                                    value_component_label(the_value,
                                            component_num),
                                    (unsigned long)component_num);
                          }

                        assert(type_is_valid(the_type)); /* VERIFIED */
                        assert(type_is_valid(the_type->u.array.base));
                                /* VERIFIED */
                        ok = value_is_in_type(
                                value_component_value(the_value,
                                                      component_num),
                                the_type->u.array.base, &local_doubt,
                                ((why_not == NULL) ? NULL : &local_why_not),
                                location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            return FALSE;
                          }
                        if (local_doubt)
                          {
                            *doubt = TRUE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                if (doubt_why_not != NULL)
                                  {
                                    free(local_why_not);
                                  }
                                else
                                  {
                                    doubt_why_not = allocate_printf(
                                            "the value is a semi-labeled value"
                                            " list with element %U and the "
                                            "type is an array type with an "
                                            "element type for which it is "
                                            "unclear whether that element "
                                            "value is in that element type "
                                            "because %s",
                                            value_component_value(the_value,
                                                    component_num),
                                            local_why_not);
                                    free(local_why_not);
                                    if (doubt_why_not == NULL)
                                      {
                                        jumper_do_abort(the_jumper);
                                        return FALSE;
                                      }
                                  }
                              }
                          }
                        else if (!ok)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            *doubt = FALSE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                *why_not = allocate_printf(
                                        "the value is a semi-labeled value "
                                        "list with element %U and the type is "
                                        "an array with an element type that "
                                        "the element value is not in because "
                                        "%s",
                                        value_component_value(the_value,
                                                component_num), local_why_not);
                                free(local_why_not);
                                if (*why_not == NULL)
                                    jumper_do_abort(the_jumper);
                              }
                            return FALSE;
                          }
                      }

                    break;
                  }
                default:
                  {
                    assert(FALSE);
                    break;
                  }
              }

            if (doubt_why_not != NULL)
              {
                assert(*doubt == TRUE);
                assert(why_not != NULL);
                *why_not = doubt_why_not;
              }
            else if (why_not != NULL)
              {
                assert(*doubt == FALSE);
              }
            return TRUE;
          }
        case TK_INTEGER_RANGES:
          {
            o_integer the_oi;
            size_t search_low;
            size_t search_high;

            assert(get_value_kind(the_value) == VK_INTEGER);

            the_oi = integer_value_data(the_value);
            assert(!(oi_out_of_memory(the_oi)));

            switch (oi_kind(the_oi))
              {
                case IIK_FINITE:
                    break;
                case IIK_POSITIVE_INFINITY:
                    return type_in_no_doubt(
                            the_type->u.integer_ranges.
                                    includes_positive_infinity, doubt, why_not,
                            the_jumper,
                            "the value is %I and the type is a subset of the "
                            "integers that does not include that value",
                            the_oi);
                case IIK_NEGATIVE_INFINITY:
                    return type_in_no_doubt(
                            the_type->u.integer_ranges.
                                    includes_negative_infinity, doubt, why_not,
                            the_jumper,
                            "the value is %I and the type is a subset of the "
                            "integers that does not include that value",
                            the_oi);
                case IIK_UNSIGNED_INFINITY:
                    return type_in_no_doubt(
                            the_type->u.integer_ranges.
                                    includes_unsigned_infinity, doubt, why_not,
                            the_jumper,
                            "the value is %I and the type is a subset of the "
                            "integers that does not include that value",
                            the_oi);
                case IIK_ZERO_ZERO:
                    return type_in_no_doubt(
                            the_type->u.integer_ranges.includes_zero_zero,
                            doubt, why_not, the_jumper,
                            "the value is %I and the type is a subset of the "
                            "integers that does not include that value",
                            the_oi);
                default:
                    assert(FALSE);
              }

            search_low = 0;
            search_high = the_type->u.integer_ranges.component_count;

            while (search_low < search_high)
              {
                size_t search_test;
                integer_range_component *this_component;

                search_test = (search_low + search_high) / 2;
                assert(search_test >= search_low);
                assert(search_test < search_high);

                this_component =
                        &(the_type->u.integer_ranges.components[search_test]);

                if (oi_less_than(the_oi, this_component->lower_bound))
                  {
                    search_high = search_test;
                    continue;
                  }

                if (oi_less_than(this_component->upper_bound, the_oi))
                  {
                    search_low = search_test + 1;
                    continue;
                  }

                *doubt = FALSE;
                return TRUE;
              }

            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the value is %I and the type is a subset of the integers "
                    "that does not include that value", the_oi);
          }
        case TK_RATIONAL_RANGES:
          {
            rational *the_rational;
            o_integer numerator;
            size_t search_low;
            size_t search_high;

            switch (get_value_kind(the_value))
              {
                case VK_INTEGER:
                  {
                    o_integer the_oi;

                    the_oi = integer_value_data(the_value);
                    assert(!(oi_out_of_memory(the_oi)));
                    the_rational = create_rational(the_oi, oi_one);
                    if (the_rational == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                    break;
                  }
                case VK_RATIONAL:
                  {
                    the_rational = rational_value_data(the_value);
                    assert(the_rational != NULL);
                    rational_add_reference(the_rational);
                    break;
                  }
                default:
                  {
                    assert(FALSE);
                    break;
                  }
              }

            assert(the_rational != NULL);

            numerator = rational_numerator(the_rational);

            switch (oi_kind(numerator))
              {
                case IIK_FINITE:
                    break;
                case IIK_POSITIVE_INFINITY:
                    rational_remove_reference(the_rational);
                    return type_in_no_doubt(
                            the_type->u.rational_ranges.
                                    includes_positive_infinity, doubt, why_not,
                            the_jumper,
                            "the value is %U and the type is a subset of the "
                            "rationals that does not include that value",
                            the_value);
                case IIK_NEGATIVE_INFINITY:
                    rational_remove_reference(the_rational);
                    return type_in_no_doubt(
                            the_type->u.rational_ranges.
                                    includes_negative_infinity, doubt, why_not,
                            the_jumper,
                            "the value is %U and the type is a subset of the "
                            "rationals that does not include that value",
                            the_value);
                case IIK_UNSIGNED_INFINITY:
                    rational_remove_reference(the_rational);
                    return type_in_no_doubt(
                            the_type->u.rational_ranges.
                                    includes_unsigned_infinity, doubt, why_not,
                            the_jumper,
                            "the value is %U and the type is a subset of the "
                            "rationals that does not include that value",
                            the_value);
                case IIK_ZERO_ZERO:
                    rational_remove_reference(the_rational);
                    return type_in_no_doubt(
                            the_type->u.rational_ranges.includes_zero_zero,
                            doubt, why_not, the_jumper,
                            "the value is %U and the type is a subset of the "
                            "rationals that does not include that value",
                            the_value);
                default:
                    assert(FALSE);
              }

            search_low = 0;
            search_high = the_type->u.rational_ranges.component_count;

            while (search_low < search_high)
              {
                size_t search_test;
                rational_range_component *this_component;
                boolean error;
                boolean less_than;

                search_test = (search_low + search_high) / 2;
                assert(search_test >= search_low);
                assert(search_test < search_high);

                this_component =
                        &(the_type->u.rational_ranges.components[search_test]);

                if (this_component->lower_is_inclusive)
                  {
                    less_than = rational_less_than(the_rational,
                            this_component->lower_bound, &error);
                  }
                else
                  {
                    less_than = !(rational_less_than(
                            this_component->lower_bound, the_rational,
                            &error));
                  }
                if (error)
                  {
                    jumper_do_abort(the_jumper);
                    rational_remove_reference(the_rational);
                    return FALSE;
                  }
                if (less_than)
                  {
                    search_high = search_test;
                    continue;
                  }

                if (this_component->upper_is_inclusive)
                  {
                    less_than = rational_less_than(this_component->upper_bound,
                                                   the_rational, &error);
                  }
                else
                  {
                    less_than = !(rational_less_than(the_rational,
                            this_component->upper_bound, &error));
                  }
                if (error)
                  {
                    jumper_do_abort(the_jumper);
                    rational_remove_reference(the_rational);
                    return FALSE;
                  }
                if (less_than)
                  {
                    search_low = search_test + 1;
                    continue;
                  }

                *doubt = FALSE;
                rational_remove_reference(the_rational);
                return TRUE;
              }

            rational_remove_reference(the_rational);
            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the value is %U and the type is a subset of the rationals"
                    " that does not include that value", the_value);
          }
        case TK_POINTER:
          {
            slot_location *the_slot_location;
            type *base_type;
            type *slot_read_lower;
            type *slot_read_upper;
            type *slot_write_lower;
            type *slot_write_upper;
            variable_instance *base_instance;
            char *doubt_why_not;

            assert(value_is_valid(the_value)); /* VERIFIED */

            if (get_value_kind(the_value) == VK_NULL)
              {
                assert(the_type->u.pointer.null_allowed);
                *doubt = FALSE;
                return TRUE;
              }

            assert(get_value_kind(the_value) == VK_SLOT_LOCATION);

            assert(value_is_valid(the_value)); /* VERIFIED */
            the_slot_location = slot_location_value_data(the_value);
            assert(the_slot_location != NULL);
            assert(slot_location_is_valid(the_slot_location)); /* VERIFIED */

            base_type = the_type->u.pointer.base;
            assert(base_type != NULL);
            assert(type_is_valid(base_type)); /* VERIFIED */

            if (jumper_thread(the_jumper) == NULL)
              {
                *doubt = TRUE;
                return FALSE;
              }

            slot_location_dereference_type_bounds(the_slot_location,
                    &slot_read_lower, &slot_read_upper, &slot_write_lower,
                    &slot_write_upper, &base_instance, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(slot_read_lower == NULL);
                assert(slot_read_upper == NULL);
                assert(slot_write_lower == NULL);
                assert(slot_write_upper == NULL);
                *doubt = TRUE;
                return FALSE;
              }
            assert(slot_read_lower != NULL);
            assert(slot_read_upper != NULL);
            assert(slot_write_lower != NULL);
            assert(slot_write_upper != NULL);
            assert(type_is_valid(slot_read_lower)); /* VERIFICATION NEEDED */
            assert(type_is_valid(slot_read_upper)); /* VERIFICATION NEEDED */
            assert(type_is_valid(slot_write_lower)); /* VERIFICATION NEEDED */
            assert(type_is_valid(slot_write_upper)); /* VERIFICATION NEEDED */

            doubt_why_not = NULL;
            *doubt = FALSE;

            if (the_type->u.pointer.read_allowed)
              {
                boolean local_doubt;
                char *local_why_not;
                boolean in_lower;
                boolean in_upper;

                assert(type_is_valid(slot_read_lower)); /* VERIFIED */
                assert(type_is_valid(base_type)); /* VERIFIED */
                in_lower = type_is_subset(slot_read_lower, base_type,
                        &local_doubt,
                        ((why_not == NULL) ? NULL : &local_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    assert(doubt_why_not == NULL);
                    return FALSE;
                  }
                if (local_doubt || !in_lower)
                  {
                    *doubt = TRUE;
                    if (why_not != NULL)
                      {
                        assert(local_why_not != NULL);
                        assert(doubt_why_not == NULL);
                        doubt_why_not = allocate_printf(
                                "the type is a readable pointer type and the "
                                "value is a pointer for which it is unclear "
                                "whether all possible readable values are in "
                                "the base type of the pointer because %s",
                                local_why_not);
                        free(local_why_not);
                        if (doubt_why_not == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                      }
                  }

                assert(type_is_valid(slot_read_upper)); /* VERIFIED */
                assert(type_is_valid(base_type)); /* VERIFIED */
                in_upper = type_is_subset(slot_read_upper, base_type,
                        &local_doubt,
                        ((why_not == NULL) ? NULL : &local_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if (doubt_why_not != NULL)
                        free(doubt_why_not);
                    return FALSE;
                  }
                if (local_doubt)
                  {
                    *doubt = TRUE;
                    if (why_not != NULL)
                      {
                        assert(local_why_not != NULL);
                        if (doubt_why_not != NULL)
                          {
                            free(local_why_not);
                          }
                        else
                          {
                            doubt_why_not = allocate_printf(
                                    "the type is a readable pointer type and "
                                    "the value is a pointer for which it is "
                                    "unclear whether all possible readable "
                                    "values are in the base type of the "
                                    "pointer because %s", local_why_not);
                            free(local_why_not);
                            if (doubt_why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                      }
                  }
                else if (!in_upper)
                  {
                    if (doubt_why_not != NULL)
                        free(doubt_why_not);
                    *doubt = FALSE;
                    if (why_not != NULL)
                      {
                        assert(local_why_not != NULL);
                        *why_not = allocate_printf(
                                "the type is a readable pointer type and the "
                                "value is a pointer for which not all possible"
                                " readable values are in the base type of the "
                                "pointer because %s", local_why_not);
                        free(local_why_not);
                        if (*why_not == NULL)
                            jumper_do_abort(the_jumper);
                      }
                    return FALSE;
                  }
              }

            if (the_type->u.pointer.write_allowed)
              {
                boolean local_doubt;
                char *local_why_not;
                boolean in_lower;
                boolean in_upper;

                if (base_instance != NULL)
                  {
                    variable_declaration *declaration;

                    assert(!(variable_instance_scope_exited(base_instance)));
                            /* VERIFIED */

                    declaration = variable_instance_declaration(base_instance);
                    assert(declaration != NULL);

                    if (variable_declaration_is_immutable(declaration))
                      {
                        if (doubt_why_not != NULL)
                            free(doubt_why_not);
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the type is a writable pointer type and the "
                                "value is a location based on an immutable");
                      }
                  }

                assert(type_is_valid(base_type)); /* VERIFIED */
                assert(type_is_valid(slot_write_lower)); /* VERIFIED */
                in_lower = type_is_subset(base_type, slot_write_lower,
                        &local_doubt,
                        ((why_not == NULL) ? NULL : &local_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if (doubt_why_not != NULL)
                        free(doubt_why_not);
                    return FALSE;
                  }
                if (local_doubt || !in_lower)
                  {
                    *doubt = TRUE;
                    if (why_not != NULL)
                      {
                        assert(local_why_not != NULL);
                        if (doubt_why_not != NULL)
                          {
                            free(local_why_not);
                          }
                        else
                          {
                            doubt_why_not = allocate_printf(
                                    "the type is a writable pointer type and "
                                    "the value is a pointer for which it is "
                                    "unclear whether the base type of the "
                                    "pointer type is a subset of the legal "
                                    "writable values because %s",
                                    local_why_not);
                            free(local_why_not);
                            if (doubt_why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                      }
                  }

                assert(type_is_valid(base_type)); /* VERIFIED */
                assert(type_is_valid(slot_write_upper)); /* VERIFIED */
                in_upper = type_is_subset(base_type, slot_write_upper,
                        &local_doubt,
                        ((why_not == NULL) ? NULL : &local_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if (doubt_why_not != NULL)
                        free(doubt_why_not);
                    return FALSE;
                  }
                if (local_doubt)
                  {
                    *doubt = TRUE;
                    if (why_not != NULL)
                      {
                        assert(local_why_not != NULL);
                        if (doubt_why_not != NULL)
                          {
                            free(local_why_not);
                          }
                        else
                          {
                            doubt_why_not = allocate_printf(
                                    "the type is a writable pointer type and "
                                    "the value is a pointer for which it is "
                                    "unclear whether the base type of the "
                                    "pointer type is a subset of the legal "
                                    "writable values because %s",
                                    local_why_not);
                            free(local_why_not);
                            if (doubt_why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                      }
                  }
                else if (!in_upper)
                  {
                    if (doubt_why_not != NULL)
                        free(doubt_why_not);
                    *doubt = FALSE;
                    if (why_not != NULL)
                      {
                        assert(local_why_not != NULL);
                        *why_not = allocate_printf(
                                "the type is a writable pointer type and the "
                                "value is a pointer for which not all values "
                                "in the base type of the pointer type are in "
                                "the legal writable values because %s",
                                local_why_not);
                        free(local_why_not);
                        if (*why_not == NULL)
                            jumper_do_abort(the_jumper);
                      }
                    return FALSE;
                  }
              }

            if (doubt_why_not != NULL)
              {
                assert(*doubt == TRUE);
                assert(why_not != NULL);
                *why_not = doubt_why_not;
              }
            else if (why_not != NULL)
              {
                assert(*doubt == FALSE);
              }
            return TRUE;
          }
        case TK_TYPE:
          {
            type *value_type;
            char *local_why_not;
            boolean result;

            assert(get_value_kind(the_value) == VK_TYPE);

            assert(value_is_valid(the_value)); /* VERIFIED */
            value_type = type_value_data(the_value);
            assert(value_type != NULL);

            assert(type_is_valid(value_type)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(type_is_valid(the_type->u.type.base)); /* VERIFIED */
            result = type_is_subset(value_type, the_type->u.type.base, doubt,
                    ((why_not == NULL) ? NULL : &local_why_not), location,
                    the_jumper);
            if (jumper_flowing_forward(the_jumper) && (why_not != NULL) &&
                ((*doubt) || !result))
              {
                assert(local_why_not != NULL);
                *why_not = allocate_printf(
                        "the type is a type type and the value is a type %s a "
                        "subset of the base type of the type because %s",
                        (*doubt ? "for which it is unclear whether it is" :
                                  "which is not"), local_why_not);
                free(local_why_not);
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            return result;
          }
        case TK_MAP:
          {
            type *key_type;
            type *target_type;
            char *doubt_why_not;

            key_type = the_type->u.map.key;
            target_type = the_type->u.map.target;

            assert(key_type != NULL);
            assert(type_is_valid(key_type)); /* VERIFIED */
            assert(target_type != NULL);
            assert(type_is_valid(target_type)); /* VERIFIED */

            doubt_why_not = NULL;
            *doubt = FALSE;

            switch (get_value_kind(the_value))
              {
                case VK_MAP:
                  {
                    size_t item_count;
                    size_t item_num;

                    item_count = map_value_item_count(the_value);
                    for (item_num = 0; item_num < item_count; ++item_num)
                      {
                        boolean is_filter;
                        type *item_key_type;
                        value *key_value;
                        boolean local_doubt;
                        char *local_why_not;
                        boolean ok;
                        value *target_value;

                        is_filter =
                                map_value_item_is_type(the_value, item_num);
                        if (is_filter)
                          {
                            item_key_type = map_value_item_key_type(the_value,
                                                                    item_num);
                            assert(item_key_type != NULL);
                            key_value = NULL;

                            assert(type_is_valid(item_key_type));
                                    /* VERIFIED */
                            assert(type_is_valid(key_type)); /* VERIFIED */
                            ok = type_is_subset(item_key_type, key_type,
                                    &local_doubt,
                                    ((why_not == NULL) ? NULL :
                                     &local_why_not), location, the_jumper);
                          }
                        else
                          {
                            item_key_type = NULL;
                            key_value = map_value_item_key_value(the_value,
                                                                 item_num);
                            assert(key_value != NULL);

                            assert(type_is_valid(key_type)); /* VERIFIED */
                            ok = value_is_in_type(key_value, key_type,
                                    &local_doubt,
                                    ((why_not == NULL) ? NULL :
                                     &local_why_not), location, the_jumper);
                          }

                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            return FALSE;
                          }

                        if (local_doubt)
                          {
                            *doubt = TRUE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                if (doubt_why_not != NULL)
                                  {
                                    free(local_why_not);
                                  }
                                else
                                  {
                                    char *key_description;

                                    if (is_filter)
                                      {
                                        key_description = allocate_printf(
                                                "key filter type of %t",
                                                item_key_type);
                                      }
                                    else
                                      {
                                        key_description = allocate_printf(
                                                "key value of %U", key_value);
                                      }
                                    if (key_description == NULL)
                                      {
                                        jumper_do_abort(the_jumper);
                                        free(local_why_not);
                                        return FALSE;
                                      }
                                    doubt_why_not = allocate_printf(
                                            "the value is a map with a %s and "
                                            "the type is a map type with a key"
                                            " type for which it is unclear "
                                            "whether that key %s is included "
                                            "because %s", key_description,
                                            (is_filter ? "type" : "value"),
                                            local_why_not);
                                    free(key_description);
                                    free(local_why_not);
                                    if (doubt_why_not == NULL)
                                      {
                                        jumper_do_abort(the_jumper);
                                        return FALSE;
                                      }
                                  }
                              }
                          }
                        else if (!ok)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            *doubt = FALSE;
                            if (why_not != NULL)
                              {
                                char *key_description;

                                assert(local_why_not != NULL);
                                if (is_filter)
                                  {
                                    key_description = allocate_printf(
                                            "key filter type of %t",
                                            item_key_type);
                                  }
                                else
                                  {
                                    key_description = allocate_printf(
                                            "key value of %U", key_value);
                                  }
                                if (key_description == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    free(local_why_not);
                                    return FALSE;
                                  }
                                *why_not = allocate_printf(
                                        "the value is a map with a %s and the "
                                        "type is a map type with a key type "
                                        "which does not include that key %s "
                                        "because %s", key_description,
                                        (is_filter ? "type" : "value"),
                                        local_why_not);
                                free(key_description);
                                free(local_why_not);
                                if (*why_not == NULL)
                                    jumper_do_abort(the_jumper);
                              }
                            return FALSE;
                          }

                        target_value =
                                map_value_item_target(the_value, item_num);
                        assert(target_value != NULL);

                        assert(type_is_valid(target_type)); /* VERIFIED */
                        ok = value_is_in_type(target_value, target_type,
                                &local_doubt,
                                ((why_not == NULL) ? NULL : &local_why_not),
                                location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            return FALSE;
                          }

                        if (local_doubt)
                          {
                            *doubt = TRUE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                if (doubt_why_not != NULL)
                                  {
                                    free(local_why_not);
                                  }
                                else
                                  {
                                    doubt_why_not = allocate_printf(
                                            "the value is a map with a target "
                                            "value of %U and the type is a map"
                                            " type with a target type for "
                                            "which it is unclear whether that "
                                            "target value is included because "
                                            "%s", target_value, local_why_not);
                                    free(local_why_not);
                                    if (doubt_why_not == NULL)
                                      {
                                        jumper_do_abort(the_jumper);
                                        return FALSE;
                                      }
                                  }
                              }
                          }
                        else if (!ok)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            *doubt = FALSE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                *why_not = allocate_printf(
                                        "the value is a map with a target "
                                        "value of %U and the type is a map "
                                        "type with a target type which does "
                                        "not include that target value because"
                                        " %s", target_value, local_why_not);
                                free(local_why_not);
                                if (*why_not == NULL)
                                    jumper_do_abort(the_jumper);
                              }
                            return FALSE;
                          }
                      }

                    break;
                  }
                case VK_SEMI_LABELED_VALUE_LIST:
                  {
                    size_t component_count;
                    size_t component_num;

                    component_count = value_component_count(the_value);
                    for (component_num = 0; component_num < component_count;
                         ++component_num)
                      {
                        o_integer key_oi;
                        value *key_value;
                        value *target_value;
                        boolean local_doubt;
                        char *local_why_not;
                        boolean ok;

                        if (value_component_label(the_value, component_num) !=
                            NULL)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the value is a semi-labeled value list "
                                    "with a label (%s) on element number %lu "
                                    "and the type is a map type",
                                    value_component_label(the_value,
                                            component_num),
                                    (unsigned long)component_num);
                          }

                        oi_create_from_size_t(key_oi, component_num);
                        if (oi_out_of_memory(key_oi))
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }

                        key_value = create_integer_value(key_oi);
                        oi_remove_reference(key_oi);
                        if (key_value == NULL)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }

                        target_value = value_component_value(the_value,
                                                             component_num);
                        assert(target_value != NULL);

                        assert(type_is_valid(key_type)); /* VERIFIED */
                        ok = value_is_in_type(key_value, key_type,
                                &local_doubt,
                                ((why_not == NULL) ? NULL : &local_why_not),
                                location, the_jumper);
                        value_remove_reference(key_value,
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            return FALSE;
                          }
                        if (local_doubt)
                          {
                            *doubt = TRUE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                if (doubt_why_not != NULL)
                                  {
                                    free(local_why_not);
                                  }
                                else
                                  {
                                    doubt_why_not = allocate_printf(
                                            "the value is a semi-labeled value"
                                            " list with an element with index "
                                            "%lu and the type is a map type "
                                            "with a key type for which it is "
                                            "unclear whether that index is "
                                            "included because %s",
                                            (unsigned long)component_num,
                                            local_why_not);
                                    free(local_why_not);
                                    if (doubt_why_not == NULL)
                                      {
                                        jumper_do_abort(the_jumper);
                                        return FALSE;
                                      }
                                  }
                              }
                          }
                        else if (!ok)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            *doubt = FALSE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                *why_not = allocate_printf(
                                        "the value is a semi-labeled value "
                                        "list with an element with index %lu "
                                        "and the type is a map type with a key"
                                        " type which does not include that "
                                        "index because %s",
                                        (unsigned long)component_num,
                                        local_why_not);
                                free(local_why_not);
                                if (*why_not == NULL)
                                    jumper_do_abort(the_jumper);
                              }
                            return FALSE;
                          }

                        assert(type_is_valid(target_type)); /* VERIFIED */
                        ok = value_is_in_type(target_value, target_type,
                                &local_doubt,
                                ((why_not == NULL) ? NULL : &local_why_not),
                                location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            return FALSE;
                          }
                        if (local_doubt)
                          {
                            *doubt = TRUE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                if (doubt_why_not != NULL)
                                  {
                                    free(local_why_not);
                                  }
                                else
                                  {
                                    doubt_why_not = allocate_printf(
                                            "the value is a semi-labeled value"
                                            " list with an element value %U "
                                            "and the type is a map type with a"
                                            " target type for which it is "
                                            "unclear whether that element is "
                                            "included because %s",
                                            target_value, local_why_not);
                                    free(local_why_not);
                                    if (doubt_why_not == NULL)
                                      {
                                        jumper_do_abort(the_jumper);
                                        return FALSE;
                                      }
                                  }
                              }
                          }
                        else if (!ok)
                          {
                            if (doubt_why_not != NULL)
                                free(doubt_why_not);
                            *doubt = FALSE;
                            if (why_not != NULL)
                              {
                                assert(local_why_not != NULL);
                                *why_not = allocate_printf(
                                        "the value is a semi-labeled value "
                                        "list with an element value %U and the"
                                        " type is a map type with a target "
                                        "type which does not include that "
                                        "element because %s", target_value,
                                        local_why_not);
                                free(local_why_not);
                                if (*why_not == NULL)
                                    jumper_do_abort(the_jumper);
                              }
                            return FALSE;
                          }
                      }

                    break;
                  }
                default:
                  {
                    assert(FALSE);
                    break;
                  }
              }

            if (doubt_why_not != NULL)
              {
                assert(*doubt == TRUE);
                assert(why_not != NULL);
                *why_not = doubt_why_not;
              }
            else if (why_not != NULL)
              {
                assert(*doubt == FALSE);
              }
            return TRUE;
          }
        case TK_ROUTINE:
          {
            switch (get_value_kind(the_value))
              {
                case VK_ROUTINE:
                  {
                    routine_instance *instance;
                    boolean parameter_doubt;
                    char *parameter_why_not;
                    boolean parameter_match;
                    type *return_type;
                    boolean return_doubt;
                    char *return_why_not;
                    boolean return_match;

                    assert(value_is_valid(the_value)); /* VERIFIED */
                    instance = routine_value_data(the_value);
                    assert(instance != NULL);

                    assert(routine_instance_is_instantiated(instance));
                            /* VERIFIED */
                    assert(!(routine_instance_scope_exited(instance)));
                            /* VERIFIED */
                    assert(type_is_valid(the_type)); /* VERIFIED */
                    parameter_match = routine_always_matches_type_parameters(
                            instance, the_type, &parameter_doubt,
                            ((why_not == NULL) ? NULL : &parameter_why_not),
                            location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                        return FALSE;
                    if ((!parameter_match) && (!parameter_doubt))
                      {
                        *doubt = FALSE;
                        if (why_not != NULL)
                            *why_not = parameter_why_not;
                        return FALSE;
                      }

                    if (jumper_thread(the_jumper) == NULL)
                      {
                        *doubt = TRUE;
                        if (parameter_doubt && (why_not != NULL))
                            free(parameter_why_not);
                        return FALSE;
                      }

                    assert(routine_instance_is_instantiated(instance));
                            /* VERIFIED */
                    assert(!(routine_instance_scope_exited(instance)));
                            /* VERIFIED */
                    return_type = routine_instance_valid_return_type(instance,
                            location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        assert(return_type == NULL);
                        if (parameter_doubt && (why_not != NULL))
                            free(parameter_why_not);
                        return FALSE;
                      }
                    assert(return_type != NULL);
                    type_add_reference(return_type);

                    assert(type_is_valid(return_type)); /* VERIFIED */
                    assert(type_is_valid(the_type)); /* VERIFIED */
                    assert(type_is_valid(the_type->u.routine.return_type));
                            /* VERIFIED */
                    return_match = type_is_subset(return_type,
                            the_type->u.routine.return_type, &return_doubt,
                            ((why_not == NULL) ? NULL : &return_why_not),
                            location, the_jumper);
                    type_remove_reference(return_type, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if (parameter_doubt && (why_not != NULL))
                            free(parameter_why_not);
                        return FALSE;
                      }
                    if ((!return_match) && (!return_doubt))
                      {
                        if (why_not != NULL)
                          {
                            if (parameter_doubt)
                                free(parameter_why_not);
                            *why_not = allocate_printf(
                                    "the routine value matches parameters, but"
                                    " its return type does not match the "
                                    "required return type because %s",
                                    return_why_not);
                            free(return_why_not);
                            if (*why_not == NULL)
                                jumper_do_abort(the_jumper);
                          }
                        *doubt = FALSE;
                        return FALSE;
                      }

                    if (why_not != NULL)
                      {
                        if (parameter_doubt)
                          {
                            *why_not = parameter_why_not;
                            if (return_doubt)
                                free(return_why_not);
                          }
                        else if (return_doubt)
                          {
                            *why_not = allocate_printf(
                                    "the routine value matches parameters, but"
                                    " %s is unable to determine whether its "
                                    "return type matches because %s",
                                    interpreter_name(), return_why_not);
                            free(return_why_not);
                            if (*why_not == NULL)
                                jumper_do_abort(the_jumper);
                          }
                      }
                    *doubt = (parameter_doubt || return_doubt);
                    return (parameter_match && return_match);
                  }
                case VK_ROUTINE_CHAIN:
                  {
                    routine_instance_chain *instance_chain;

                    assert(value_is_valid(the_value)); /* VERIFIED */
                    instance_chain = routine_chain_value_data(the_value);
                    assert(instance_chain != NULL);
                    assert(routine_instance_chain_is_valid(instance_chain));
                            /* VERIFIED */

                    return routine_instance_chain_is_in_routine_type(
                            instance_chain, the_type, doubt, why_not, location,
                            the_jumper);
                  }
                default:
                  {
                    assert(FALSE);
                    return FALSE;
                  }
              }
          }
        case TK_FIELDS:
          {
            assert((get_value_kind(the_value) == VK_SEMI_LABELED_VALUE_LIST) ||
                   (get_value_kind(the_value) == VK_SEMI_LABELED_MULTI_SET) ||
                   (get_value_kind(the_value) == VK_LEPTON) ||
                   (get_value_kind(the_value) == VK_OBJECT));

            assert(value_is_valid(the_value)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            return value_fits_field_info(the_value,
                    &(the_type->u.fields.field_info), doubt, why_not, location,
                    the_jumper);
          }
        case TK_LEPTON:
          {
            lepton_key_instance *key;

            assert(get_value_kind(the_value) == VK_LEPTON);

            key = the_type->u.lepton.key;
            if ((key != NULL) && (key != value_lepton_key(the_value)))
              {
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a lepton type with key %s and the value "
                        "is a lepton with a different key (%s)",
                        lepton_key_declaration_name(
                                lepton_key_instance_declaration(key)),
                        lepton_key_declaration_name(
                                lepton_key_instance_declaration(
                                        value_lepton_key(the_value))));
                *doubt = FALSE;
                return FALSE;
              }

            assert(value_is_valid(the_value)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            return value_fits_field_info(the_value,
                    &(the_type->u.lepton.field_info), doubt, why_not, location,
                    the_jumper);
          }
        case TK_MULTISET:
          {
            assert(get_value_kind(the_value) == VK_SEMI_LABELED_MULTI_SET);

            assert(value_is_valid(the_value)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            return value_fits_field_info(the_value,
                    &(the_type->u.multiset.field_info), doubt, why_not,
                    location, the_jumper);
          }
        case TK_INTERFACE:
          {
            field_type_info *field_info;
            boolean fits_field_info;

            assert((get_value_kind(the_value) == VK_SEMI_LABELED_VALUE_LIST) ||
                   (get_value_kind(the_value) == VK_SEMI_LABELED_MULTI_SET) ||
                   (get_value_kind(the_value) == VK_LEPTON) ||
                   (get_value_kind(the_value) == VK_OBJECT));

            assert(type_is_valid(the_type)); /* VERIFIED */
            field_info = &(the_type->u.interface.field_info);

            assert(value_is_valid(the_value)); /* VERIFIED */
            fits_field_info = value_fits_field_info(the_value, field_info,
                    doubt, why_not, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            if (!fits_field_info)
                return FALSE;

            if (get_value_kind(the_value) == VK_OBJECT)
              {
                size_t item_count;
                size_t item_num;

                item_count = field_info->field_count;

                for (item_num = 0; item_num < item_count; ++item_num)
                  {
                    object *the_object;
                    size_t object_field_num;

                    assert(value_is_valid(the_value)); /* VERIFIED */
                    the_object = object_value_data(the_value);
                    assert(the_object != NULL);
                    assert(!(object_is_closed(the_object))); /* VERIFIED */

                    object_field_num = object_field_lookup(the_object,
                            field_info->field_names[item_num]);
                    assert(object_field_num < object_field_count(the_object));
                    if (the_type->u.interface.item_writing_alloweds[item_num])
                      {
                        variable_instance *field_instance;
                        variable_declaration *field_declaration;
                        type *field_type;
                        type *variable_type;
                        boolean subset_doubt;
                        char *subset_why_not;
                        boolean is_subset;

                        assert(!(object_is_closed(the_object))); /* VERIFIED */
                        if (!(object_field_is_variable(the_object,
                                                       object_field_num)))
                          {
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is an interface type that "
                                    "requires field `%s' to be writable, but "
                                    "the value is an object with a "
                                    "non-variable field by that name",
                                    field_info->field_names[item_num]);
                          }

                        field_instance = object_field_variable(the_object,
                                object_field_num);
                        assert(field_instance != NULL);

                        field_declaration =
                                variable_instance_declaration(field_instance);
                        assert(field_declaration != NULL);

                        if (variable_declaration_is_immutable(
                                    field_declaration))
                          {
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is an interface type that "
                                    "requires field `%s' to be writable, but "
                                    "the value is an object with an immutable "
                                    "field by that name",
                                    field_info->field_names[item_num]);
                          }

                        assert(variable_instance_is_instantiated(
                                field_instance)); /* VERIFIED */
                        assert(!(variable_instance_scope_exited(
                                field_instance))); /* VERIFIED */
                        field_type = field_info->field_types[item_num];
                        variable_type = variable_instance_type(field_instance);
                        assert(type_is_valid(field_type)); /* VERIFIED */
                        assert(type_is_valid(variable_type)); /* VERIFIED */
                        is_subset = type_is_subset(field_type, variable_type,
                                &subset_doubt,
                                ((why_not == NULL) ? NULL : &subset_why_not),
                                location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            return FALSE;
                          }
                        if (subset_doubt)
                          {
                            if (why_not != NULL)
                              {
                                if (!*doubt)
                                  {
                                    *why_not = allocate_printf(
                                            "the type is an interface type "
                                            "that requires field `%s' to be "
                                            "writable with all values of type "
                                            "%t, but the value is an object "
                                            "with a variable field by that "
                                            "name with type %t, and %s is "
                                            "unable to determine whether that "
                                            "field type is a subset of the "
                                            "variable type because %s",
                                            field_info->field_names[item_num],
                                            field_type, variable_type,
                                            interpreter_name(),
                                            subset_why_not);
                                  }
                                free(subset_why_not);
                                if (*why_not == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }
                              }
                            *doubt = TRUE;
                          }
                        else if (!is_subset)
                          {
                            boolean result;

                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            result = type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is an interface type that "
                                    "requires field `%s' to be writable with "
                                    "all values of type %t, but the value is "
                                    "an object with a variable field by that "
                                    "name with type %t, and the field type is "
                                    "not a subset of the variable type because"
                                    " %s", field_info->field_names[item_num],
                                    field_type, variable_type, subset_why_not);
                            if (why_not != NULL)
                                free(subset_why_not);
                            return result;
                          }
                      }
                  }
              }

            return TRUE;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t type_elements;
            size_t value_elements;
            size_t element_num;

            assert(value_is_valid(the_value)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            type_elements = the_type->u.semi_labeled_value_list.element_count;

            if (get_value_kind(the_value) == VK_MAP)
              {
                o_integer max_oi;
                type *key_type;
                size_t item_count;
                size_t item_num;
                size_t element_num;

                if (the_type->u.semi_labeled_value_list.extra_elements_allowed)
                  {
                    max_oi = oi_positive_infinity;
                    oi_add_reference(max_oi);
                  }
                else
                  {
                    oi_create_from_size_t(max_oi, type_elements);
                  }
                if (oi_out_of_memory(max_oi))
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }

                key_type =
                        get_integer_range_type(oi_zero, max_oi, TRUE, FALSE);
                if (key_type == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    oi_remove_reference(max_oi);
                    return FALSE;
                  }
                assert(type_is_valid(key_type)); /* VERIFIED */

                *doubt = FALSE;

                item_count = map_value_item_count(the_value);

                for (item_num = 0; item_num < item_count; ++item_num)
                  {
                    if (map_value_item_is_type(the_value, item_num))
                      {
                        type *filter_type;
                        boolean subset_doubt;
                        char *subset_why_not;
                        boolean is_subset;

                        assert(value_is_valid(the_value)); /* VERIFIED */
                        filter_type =
                                map_value_item_key_type(the_value, item_num);
                        assert(filter_type != NULL);

                        assert(type_is_valid(filter_type)); /* VERIFIED */
                        assert(type_is_valid(key_type)); /* VERIFIED */
                        is_subset = type_is_subset(filter_type, key_type,
                                &subset_doubt,
                                ((why_not == NULL) ? NULL : &subset_why_not),
                                location, the_jumper);
                        if (subset_doubt)
                          {
                            if (why_not != NULL)
                              {
                                if (!*doubt)
                                  {
                                    *why_not = allocate_printf(
                                            "the type is a semi-labeled value "
                                            "list type and the value is a map "
                                            "value with a filter component for"
                                            " which %s is unable to determine "
                                            "whether the filter is a subset of"
                                            " the range allowed for keys by "
                                            "the type (%t) because %s",
                                            interpreter_name(), key_type,
                                            subset_why_not);
                                  }
                                free(subset_why_not);
                                if (*why_not == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    oi_remove_reference(max_oi);
                                    type_remove_reference(key_type,
                                            ((jumper_thread(the_jumper) ==
                                              NULL) ? NULL : the_jumper));
                                    return FALSE;
                                  }
                              }
                            *doubt = TRUE;
                          }
                        else if (!is_subset)
                          {
                            boolean result;

                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            result = type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is a semi-labeled value list "
                                    "type and the value is a map value with a "
                                    "filter component for which the filter is "
                                    "not a subset of the range allowed for "
                                    "keys by the type (%t) because %s",
                                    key_type, subset_why_not);
                            oi_remove_reference(max_oi);
                            type_remove_reference(key_type,
                                    ((jumper_thread(the_jumper) == NULL) ?
                                     NULL : the_jumper));
                            if (why_not != NULL)
                                free(subset_why_not);
                            return result;
                          }
                      }
                    else
                      {
                        value *key_value;
                        o_integer key_oi;
                        int order;

                        assert(value_is_valid(the_value)); /* VERIFIED */
                        key_value =
                                map_value_item_key_value(the_value, item_num);
                        assert(key_value != NULL);

                        if (get_value_kind(key_value) != VK_INTEGER)
                          {
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            oi_remove_reference(max_oi);
                            type_remove_reference(key_type,
                                    ((jumper_thread(the_jumper) == NULL) ?
                                     NULL : the_jumper));
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is a semi-labeled value list "
                                    "type and the value is a map value with a "
                                    "component with a non-integer key");
                          }

                        key_oi = integer_value_data(key_value);
                        assert(!(oi_out_of_memory(key_oi)));

                        if (((oi_kind(key_oi) != IIK_FINITE) &&
                             (oi_kind(key_oi) != IIK_POSITIVE_INFINITY)) ||
                            ((oi_kind(key_oi) == IIK_FINITE) &&
                             oi_is_negative(key_oi)))
                          {
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            oi_remove_reference(max_oi);
                            type_remove_reference(key_type,
                                    ((jumper_thread(the_jumper) == NULL) ?
                                     NULL : the_jumper));
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is a semi-labeled value list "
                                    "type and the value is a map value with a "
                                    "component with a%s key",
                                    ((oi_kind(key_oi) == IIK_FINITE) ?
                                     " negative" : "n illegal non-finite"));
                          }

                        if (the_type->u.semi_labeled_value_list.
                                    extra_elements_allowed)
                          {
                            continue;
                          }

                        order = oi_structural_order(key_oi, max_oi);
                        if (order == -2)
                          {
                            jumper_do_abort(the_jumper);
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            oi_remove_reference(max_oi);
                            type_remove_reference(key_type,
                                    ((jumper_thread(the_jumper) == NULL) ?
                                     NULL : the_jumper));
                            return FALSE;
                          }
                        if (order >= 0)
                          {
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            oi_remove_reference(max_oi);
                            type_remove_reference(key_type,
                                    ((jumper_thread(the_jumper) == NULL) ?
                                     NULL : the_jumper));
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is a semi-labeled value list "
                                    "type which doesn't allow values beyond "
                                    "the %lu explicitly specified and the "
                                    "value is a map value with a component "
                                    "with a key (%U) that is beyond the end of"
                                    " those specified by the type",
                                    (unsigned long)type_elements, key_value);
                          }
                      }
                  }

                oi_remove_reference(max_oi);
                type_remove_reference(key_type,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                                                               the_jumper));
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if ((why_not != NULL) && (*doubt))
                        free(*why_not);
                    return FALSE;
                  }

                for (element_num = 0; element_num < type_elements;
                     ++element_num)
                  {
                    o_integer key_oi;
                    value *key_value;
                    value *target_value;
                    boolean local_doubt;
                    type *element_type;
                    char *local_why_not;
                    boolean ok;

                    if (the_type->u.semi_labeled_value_list.element_names[
                                element_num] != NULL)
                      {
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the type is a semi-labeled value list type "
                                "which requires a name (`%s') for one of its "
                                "fields and the value is a map value",
                                the_type->u.semi_labeled_value_list.
                                        element_names[element_num]);
                      }

                    oi_create_from_size_t(key_oi, element_num);
                    if (oi_out_of_memory(key_oi))
                      {
                        jumper_do_abort(the_jumper);
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        return FALSE;
                      }

                    key_value = create_integer_value(key_oi);
                    oi_remove_reference(key_oi);
                    if (key_value == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        return FALSE;
                      }

                    if (jumper_thread(the_jumper) == NULL)
                      {
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        value_remove_reference(key_value, the_jumper);
                        *doubt = TRUE;
                        return FALSE;
                      }

                    assert(value_is_valid(the_value)); /* VERIFIED */
                    assert(map_value_all_keys_are_valid(the_value));
                            /* VERIFIED */
                    assert(value_is_valid(key_value)); /* VERIFIED */
                    target_value = map_value_lookup(the_value, key_value,
                            &local_doubt, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        assert(target_value == NULL);
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        value_remove_reference(key_value, the_jumper);
                        return FALSE;
                      }
                    value_remove_reference(key_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        if (target_value != NULL)
                            value_remove_reference(target_value, the_jumper);
                        return FALSE;
                      }
                    if (local_doubt)
                      {
                        assert(target_value == NULL);
                        if (why_not != NULL)
                          {
                            if (!*doubt)
                              {
                                *why_not = allocate_printf(
                                        "the type is a semi-labeled value list"
                                        " type which requires a value for "
                                        "component %lu and the value is a map "
                                        "value for which %s is unable to "
                                        "determine whether there is a target "
                                        "for that key",
                                        (unsigned long)element_num,
                                        interpreter_name());
                              }
                            if (*why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                        *doubt = TRUE;
                        continue;
                      }

                    if (target_value == NULL)
                      {
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the type is a semi-labeled value list type "
                                "which requires a value for component %lu and "
                                "the value is a map value with no target for "
                                "that key", (unsigned long)element_num);
                      }

                    assert(type_is_valid(the_type)); /* VERIFIED */
                    element_type = the_type->u.semi_labeled_value_list.
                            element_types[element_num];
                    assert(element_type != NULL);
                    assert(type_is_valid(element_type)); /* VERIFIED */

                    ok = value_is_in_type(target_value, element_type,
                            &local_doubt,
                            ((why_not == NULL) ? NULL : &local_why_not),
                            location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        return FALSE;
                      }
                    if (local_doubt)
                      {
                        if (why_not != NULL)
                          {
                            if (!*doubt)
                              {
                                *why_not = allocate_printf(
                                        "the type is a semi-labeled value list"
                                        " type and the value is a map value "
                                        "for which %s is unable to determine "
                                        "whether the target for key %lu is in "
                                        "the type specified for this component"
                                        " by the semi-labeled value list type "
                                        "because %s", interpreter_name(),
                                        (unsigned long)element_num,
                                        local_why_not);
                              }
                            free(local_why_not);
                            if (*why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                        *doubt = TRUE;
                      }
                    else if (!ok)
                      {
                        boolean result;

                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        result = type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the type is a semi-labeled value list type "
                                "and the value is a map value for which the "
                                "target for key %lu isn't in the type "
                                "specified for this component by the "
                                "semi-labeled value list type because %s",
                                (unsigned long)element_num, local_why_not);
                        if (why_not != NULL)
                            free(local_why_not);
                        return result;
                      }
                  }

                return TRUE;
              }

            assert(get_value_kind(the_value) == VK_SEMI_LABELED_VALUE_LIST);

            value_elements = value_component_count(the_value);

            if (value_elements < type_elements)
              {
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a semi-labeled value list type which "
                        "specifies %lu value%s and the value is a semi-labeled"
                        " value list value with only %lu value%s",
                        (unsigned long)type_elements,
                        ((type_elements == 1) ? "" : "s"),
                        (unsigned long)value_elements,
                        ((value_elements == 1) ? "" : "s"));
              }
            if ((!(the_type->u.semi_labeled_value_list.extra_elements_allowed))
                && (value_elements > type_elements))
              {
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type is a semi-labeled value list type which "
                        "doesn't allow values beyond the %lu explicitly "
                        "specified and the value is a semi-labeled value list "
                        "value with %lu value%s", (unsigned long)type_elements,
                        (unsigned long)value_elements,
                        ((value_elements == 1) ? "" : "s"));
              }

            *doubt = FALSE;

            for (element_num = 0; element_num < type_elements; ++element_num)
              {
                const char *type_name;
                const char *value_name;
                type *element_type;
                boolean local_doubt;
                char *local_why_not;
                boolean ok;

                type_name = the_type->u.semi_labeled_value_list.element_names[
                        element_num];
                value_name = value_component_label(the_value, element_num);
                if (type_name != NULL)
                  {
                    if ((value_name == NULL) ||
                        (strcmp(type_name, value_name) != 0))
                      {
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        if (value_name == NULL)
                          {
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is a semi-labeled value list "
                                    "type which specifies name `%s' for "
                                    "component %lu, and the value is a "
                                    "semi-labeled value list value with no "
                                    "name for that component", type_name,
                                    (unsigned long)element_num);
                          }
                        else
                          {
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the type is a semi-labeled value list "
                                    "type which specifies name `%s' for "
                                    "component %lu, and the value is a "
                                    "semi-labeled value list value with a "
                                    "different name (`%s') for that component",
                                    type_name, (unsigned long)element_num,
                                    value_name);
                          }
                      }
                  }
                else if (value_name != NULL)
                  {
                    if (exists_in_string_index(
                                the_type->u.semi_labeled_value_list.
                                        allowed_fields, value_name))
                      {
                        if ((why_not != NULL) && (*doubt))
                            free(*why_not);
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the type is a semi-labeled value list type "
                                "and the value is a semi-labeled value list "
                                "with a field named `%s' in a position "
                                "different from the one specified for it by "
                                "the type", value_name);
                      }
                  }

                assert(type_is_valid(the_type)); /* VERIFIED */
                element_type = the_type->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);
                assert(type_is_valid(element_type)); /* VERIFIED */

                ok = value_is_in_type(
                        value_component_value(the_value, element_num),
                        element_type, &local_doubt,
                        ((why_not == NULL) ? NULL : &local_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if ((why_not != NULL) && (*doubt))
                        free(*why_not);
                    return FALSE;
                  }
                if (local_doubt)
                  {
                    if (why_not != NULL)
                      {
                        if (!*doubt)
                          {
                            *why_not = allocate_printf(
                                    "the type is a semi-labeled value list "
                                    "type and the value is a semi-labeled "
                                    "value list value for which %s is unable "
                                    "to determine whether the value for "
                                    "component %lu is in the type specified "
                                    "for this component by the semi-labeled "
                                    "value list type because %s",
                                    interpreter_name(),
                                    (unsigned long)element_num, local_why_not);
                          }
                        free(local_why_not);
                        if (*why_not == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                      }
                    *doubt = TRUE;
                  }
                else if (!ok)
                  {
                    boolean result;

                    if ((why_not != NULL) && (*doubt))
                        free(*why_not);
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the type is a semi-labeled value list type and "
                            "the value is a semi-labeled value list value for "
                            "which the value for component %lu isn't in the "
                            "type specified for this component by the "
                            "semi-labeled value list type because %s",
                            (unsigned long)element_num, local_why_not);
                    if (why_not != NULL)
                        free(local_why_not);
                    return result;
                  }
              }

            return TRUE;
          }
        case TK_REGULAR_EXPRESSION:
          {
            boolean error;
            boolean match_found;

            assert(get_value_kind(the_value) == VK_STRING);

            match_found = matches(
                    the_type->u.regular_expression.regular_expression,
                    string_value_data(the_value), TRUE, &error);
            if (error)
                jumper_do_abort(the_jumper);
            return type_in_no_doubt(match_found, doubt, why_not, the_jumper,
                    "the type is a regular expression type and the value is a "
                    "string value that doesn't match the regular expression");
          }
        case TK_CLASS:
          {
            object *the_object;

            assert(get_value_kind(the_value) == VK_OBJECT);

            assert(value_is_valid(the_value)); /* VERIFIED */
            the_object = object_value_data(the_value);
            assert(the_object != NULL);
            assert(!(object_is_closed(the_object))); /* VERIFIED */

            return type_in_no_doubt(
                    (object_class(the_object) == the_type->u.class.routine),
                    doubt, why_not, the_jumper,
                    "the type is a class type and the value is an object value"
                    " for a different class");
          }
        case TK_TEST_ROUTINE:
          {
            value *base_value;
            boolean result;

            if (jumper_thread(the_jumper) == NULL)
              {
                *doubt = TRUE;
                return FALSE;
              }

            *doubt = FALSE;

            base_value = create_routine_value(
                    the_type->u.test_routine.test_routine);
            if (base_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }

            result = test_value_with_function(the_value, base_value, location,
                                              the_jumper);
            value_remove_reference(base_value, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            return type_in_no_doubt(result, doubt, why_not, the_jumper,
                    "the type is a test function and calling the function on "
                    "the value returned false");
          }
        case TK_TEST_ROUTINE_CHAIN:
          {
            value *base_value;
            boolean result;

            if (jumper_thread(the_jumper) == NULL)
              {
                *doubt = TRUE;
                return FALSE;
              }

            *doubt = FALSE;

            base_value = create_routine_chain_value(
                    the_type->u.test_routine_chain.routine_chain);
            if (base_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }

            result = test_value_with_function(the_value, base_value, location,
                                              the_jumper);
            value_remove_reference(base_value, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            return type_in_no_doubt(result, doubt, why_not, the_jumper,
                    "the type is a test function and calling the function on "
                    "the value returned false");
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return FALSE;
          }
        default:
          {
            assert(FALSE);
            return FALSE;
          }
      }
  }

extern boolean type_is_valid(type *the_type)
  {
    assert(the_type != NULL);

    return validator_is_valid(the_type->validator);
  }

extern void check_type_validity(type *the_type,
        const source_location *location, jumper *the_jumper)
  {
    assert(the_type != NULL);

    validator_check_validity(the_type->validator, location, the_jumper);
  }

extern validator *type_validator(type *the_type)
  {
    assert(the_type != NULL);

    return the_type->validator;
  }

extern boolean types_are_equal(type *type1, type *type2, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    int order;

    assert(type1 != NULL);
    assert(type2 != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(type1)); /* VERIFIED */
    assert(type_is_valid(type2)); /* VERIFIED */

    order = type_structural_order(type1, type2);
    if (order == -2)
      {
        jumper_do_abort(the_jumper);
        return FALSE;
      }
    if (order == 0)
      {
        *doubt = FALSE;
        return TRUE;
      }

    if ((!(type_is_slippery(type1))) && (!(type_is_slippery(type2))))
      {
        *doubt = FALSE;
        return FALSE;
      }

    if (type1->kind == type2->kind)
      {
        switch (type1->kind)
          {
            case TK_ANYTHING:
            case TK_NOTHING:
            case TK_INTEGER:
            case TK_RATIONAL:
            case TK_ANY_REGULAR_EXPRESSION:
            case TK_ANY_QUARK:
            case TK_ANY_LEPTON:
            case TK_LEPTON_KEY:
            case TK_JUMP_TARGET:
            case TK_ANY_CLASS:
            case TK_OBJECT:
            case TK_TAGALONG_KEY:
            case TK_LOCK:
            case TK_STRING:
            case TK_CHARACTER:
              {
                assert(FALSE);
                return FALSE;
              }
            case TK_ENUMERATION:
              {
                size_t value_count1;
                size_t value_count2;
                size_t value_num;

                *doubt = FALSE;

                value_count1 = type1->u.enumeration.value_count;
                value_count2 = type2->u.enumeration.value_count;

                for (value_num = 0; value_num < value_count1; ++value_num)
                  {
                    boolean local_doubt;
                    boolean in_type;

                    assert(type_is_valid(type2)); /* VERIFIED */
                    in_type = value_is_in_type(
                            type1->u.enumeration.values[value_num], type2,
                            &local_doubt, NULL, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                        return FALSE;
                    if ((!in_type) && !local_doubt)
                      {
                        *doubt = FALSE;
                        return FALSE;
                      }
                    if (local_doubt)
                        *doubt = TRUE;
                  }

                for (value_num = 0; value_num < value_count2; ++value_num)
                  {
                    boolean local_doubt;
                    boolean in_type;

                    assert(type_is_valid(type1)); /* VERIFIED */
                    in_type = value_is_in_type(
                            type2->u.enumeration.values[value_num], type1,
                            &local_doubt, NULL, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                        return FALSE;
                    if ((!in_type) && !local_doubt)
                      {
                        *doubt = FALSE;
                        return FALSE;
                      }
                    if (local_doubt)
                        *doubt = TRUE;
                  }

                return TRUE;
              }
            case TK_NOT:
              {
                assert(type_is_valid(type1->u.not.base)); /* VERIFIED */
                assert(type_is_valid(type2->u.not.base)); /* VERIFIED */
                return types_are_equal(type1->u.not.base, type2->u.not.base,
                                       doubt, location, the_jumper);
              }
            case TK_INTERSECTION:
              {
                boolean local_doubt;
                boolean left_equal;
                boolean right_equal;

                assert(type_is_valid(type1->u.intersection.left));
                        /* VERIFIED */
                assert(type_is_valid(type2->u.intersection.left));
                        /* VERIFIED */
                left_equal = types_are_equal(type1->u.intersection.left,
                        type2->u.intersection.left, &local_doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (local_doubt || !left_equal)
                  {
                    *doubt = TRUE;
                    return FALSE;
                  }

                assert(type_is_valid(type1->u.intersection.right));
                        /* VERIFIED */
                assert(type_is_valid(type2->u.intersection.right));
                        /* VERIFIED */
                right_equal = types_are_equal(type1->u.intersection.right,
                        type2->u.intersection.right, &local_doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (local_doubt || !right_equal)
                  {
                    *doubt = TRUE;
                    return FALSE;
                  }

                *doubt = FALSE;
                return TRUE;
              }
            case TK_UNION:
              {
                boolean local_doubt;
                boolean left_equal;
                boolean right_equal;

                assert(type_is_valid(type1->u.union_type.left)); /* VERIFIED */
                assert(type_is_valid(type2->u.union_type.left)); /* VERIFIED */
                left_equal = types_are_equal(type1->u.union_type.left,
                        type2->u.union_type.left, &local_doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (local_doubt || !left_equal)
                  {
                    *doubt = TRUE;
                    return FALSE;
                  }

                assert(type_is_valid(type1->u.union_type.right));
                        /* VERIFIED */
                assert(type_is_valid(type2->u.union_type.right));
                        /* VERIFIED */
                right_equal = types_are_equal(type1->u.union_type.right,
                        type2->u.union_type.right, &local_doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (local_doubt || !right_equal)
                  {
                    *doubt = TRUE;
                    return FALSE;
                  }

                *doubt = FALSE;
                return TRUE;
              }
            case TK_XOR:
              {
                boolean local_doubt;
                boolean left_equal;
                boolean right_equal;

                assert(type_is_valid(type1->u.xor.left)); /* VERIFIED */
                assert(type_is_valid(type2->u.xor.left)); /* VERIFIED */
                left_equal = types_are_equal(type1->u.xor.left,
                        type2->u.xor.left, &local_doubt, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (local_doubt || !left_equal)
                  {
                    *doubt = TRUE;
                    return FALSE;
                  }

                assert(type_is_valid(type1->u.xor.right)); /* VERIFIED */
                assert(type_is_valid(type2->u.xor.right)); /* VERIFIED */
                right_equal = types_are_equal(type1->u.xor.right,
                        type2->u.xor.right, &local_doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (local_doubt || !right_equal)
                  {
                    *doubt = TRUE;
                    return FALSE;
                  }

                *doubt = FALSE;
                return TRUE;
              }
            case TK_ARRAY:
              {
                boolean base_doubt;
                boolean base_equal;
                int lower_order;
                int upper_order;

                assert(type_is_valid(type1->u.array.base)); /* VERIFIED */
                assert(type_is_valid(type2->u.array.base)); /* VERIFIED */
                base_equal = types_are_equal(type1->u.array.base,
                        type2->u.array.base, &base_doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if ((!base_doubt) && !base_equal)
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }

                lower_order = oi_structural_order(type1->u.array.lower_bound,
                                                  type2->u.array.lower_bound);
                if (lower_order == -2)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }

                upper_order = oi_structural_order(type1->u.array.upper_bound,
                                                  type2->u.array.upper_bound);
                if (upper_order == -2)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }

                if ((lower_order != 0) || (upper_order != 0))
                  {
                    assert(type_is_valid(type1->u.array.base)); /* VERIFIED */
                    assert(type_is_valid(type2->u.array.base)); /* VERIFIED */
                    if (!(possibly_nothing(type1->u.array.base) &&
                          possibly_nothing(type2->u.array.base)))
                      {
                        *doubt = FALSE;
                      }
                    else
                      {
                        *doubt = TRUE;
                      }
                    return FALSE;
                  }

                *doubt = base_doubt;
                return TRUE;
              }
            case TK_INTEGER_RANGES:
              {
                size_t component_count;
                integer_range_component *components1;
                integer_range_component *components2;
                size_t component_num;

                *doubt = FALSE;

                if ((type1->u.integer_ranges.includes_positive_infinity !=
                     type2->u.integer_ranges.includes_positive_infinity) ||
                    (type1->u.integer_ranges.includes_negative_infinity !=
                     type2->u.integer_ranges.includes_negative_infinity) ||
                    (type1->u.integer_ranges.includes_unsigned_infinity !=
                     type2->u.integer_ranges.includes_unsigned_infinity) ||
                    (type1->u.integer_ranges.includes_zero_zero !=
                     type2->u.integer_ranges.includes_zero_zero))
                  {
                    return FALSE;
                  }

                component_count = type1->u.integer_ranges.component_count;
                if (component_count != type2->u.integer_ranges.component_count)
                    return FALSE;

                components1 = type1->u.integer_ranges.components;
                components2 = type2->u.integer_ranges.components;

                for (component_num = 0; component_num < component_count;
                     ++component_num)
                  {
                    int lower_order;
                    int upper_order;

                    lower_order = oi_structural_order(
                            components1[component_num].lower_bound,
                            components2[component_num].lower_bound);
                    if (lower_order == -2)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                    if (lower_order != 0)
                        return FALSE;

                    upper_order = oi_structural_order(
                            components1[component_num].upper_bound,
                            components2[component_num].upper_bound);
                    if (upper_order == -2)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                    if (upper_order != 0)
                        return FALSE;
                  }

                return TRUE;
              }
            case TK_RATIONAL_RANGES:
              {
                size_t component_count;
                rational_range_component *components1;
                rational_range_component *components2;
                size_t component_num;

                *doubt = FALSE;

                if ((type1->u.rational_ranges.includes_positive_infinity !=
                     type2->u.rational_ranges.includes_positive_infinity) ||
                    (type1->u.rational_ranges.includes_negative_infinity !=
                     type2->u.rational_ranges.includes_negative_infinity) ||
                    (type1->u.rational_ranges.includes_unsigned_infinity !=
                     type2->u.rational_ranges.includes_unsigned_infinity) ||
                    (type1->u.rational_ranges.includes_zero_zero !=
                     type2->u.rational_ranges.includes_zero_zero))
                  {
                    return FALSE;
                  }

                component_count = type1->u.rational_ranges.component_count;
                if (component_count !=
                    type2->u.rational_ranges.component_count)
                  {
                    return FALSE;
                  }

                components1 = type1->u.rational_ranges.components;
                components2 = type2->u.rational_ranges.components;

                for (component_num = 0; component_num < component_count;
                     ++component_num)
                  {
                    int lower_order;
                    int upper_order;

                    if ((components1[component_num].lower_is_inclusive !=
                         components2[component_num].lower_is_inclusive) ||
                        (components1[component_num].upper_is_inclusive !=
                         components2[component_num].upper_is_inclusive))
                      {
                        return FALSE;
                      }

                    lower_order = rational_structural_order(
                            components1[component_num].lower_bound,
                            components2[component_num].lower_bound);
                    if (lower_order == -2)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                    if (lower_order != 0)
                        return FALSE;

                    upper_order = rational_structural_order(
                            components1[component_num].upper_bound,
                            components2[component_num].upper_bound);
                    if (upper_order == -2)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                    if (upper_order != 0)
                        return FALSE;
                  }

                return TRUE;
              }
            case TK_POINTER:
              {
                if ((type1->u.pointer.read_allowed !=
                     type2->u.pointer.read_allowed) ||
                    (type1->u.pointer.write_allowed !=
                     type2->u.pointer.write_allowed))
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }
                if (type1->u.pointer.null_allowed !=
                    type2->u.pointer.null_allowed)
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }

                if ((!(type1->u.pointer.read_allowed)) &&
                    (!(type1->u.pointer.write_allowed)))
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }

                assert(type_is_valid(type1->u.pointer.base)); /* VERIFIED */
                assert(type_is_valid(type2->u.pointer.base)); /* VERIFIED */
                return types_are_equal(type1->u.pointer.base,
                        type2->u.pointer.base, doubt, location, the_jumper);
              }
            case TK_TYPE:
              {
                assert(type_is_valid(type1->u.type.base)); /* VERIFIED */
                assert(type_is_valid(type2->u.type.base)); /* VERIFIED */
                return types_are_equal(type1->u.type.base, type2->u.type.base,
                                       doubt, location, the_jumper);
              }
            case TK_MAP:
              {
                boolean key_doubt;
                boolean key_equal;
                boolean target_doubt;
                boolean target_equal;

                if ((type1->u.map.target->kind == TK_NOTHING) &&
                    (type2->u.map.target->kind == TK_NOTHING))
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }

                if ((type1->u.map.key->kind == TK_NOTHING) &&
                    (type2->u.map.key->kind == TK_NOTHING))
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }

                assert(type_is_valid(type1->u.map.key)); /* VERIFIED */
                assert(type_is_valid(type2->u.map.key)); /* VERIFIED */
                key_equal = types_are_equal(type1->u.map.key, type2->u.map.key,
                                            &key_doubt, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if ((!key_doubt) && (!key_equal))
                  {
                    assert(type_is_valid(type1->u.map.target)); /* VERIFIED */
                    assert(type_is_valid(type2->u.map.target)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1->u.map.target) &&
                              possibly_nothing(type2->u.map.target));
                    return FALSE;
                  }

                assert(type_is_valid(type1->u.map.target)); /* VERIFIED */
                assert(type_is_valid(type2->u.map.target)); /* VERIFIED */
                target_equal = types_are_equal(type1->u.map.target,
                        type2->u.map.target, &target_doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if ((!target_doubt) && (!target_equal))
                  {
                    assert(type_is_valid(type1->u.map.key)); /* VERIFIED */
                    assert(type_is_valid(type2->u.map.key)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1->u.map.key) &&
                              possibly_nothing(type2->u.map.key));
                    return FALSE;
                  }

                *doubt = (key_doubt || target_doubt);
                return (key_equal && target_equal);
              }
            case TK_ROUTINE:
              {
                boolean return_match;
                size_t left_arg_count;
                size_t right_arg_count;
                size_t max_arg_count;
                size_t arg_num;

                if (type1->u.routine.extra_arguments_allowed !=
                    type2->u.routine.extra_arguments_allowed)
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }

                if (type1->u.routine.extra_arguments_unspecified !=
                    type2->u.routine.extra_arguments_unspecified)
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }

                assert(type_is_valid(type1->u.routine.return_type));
                        /* VERIFIED */
                assert(type_is_valid(type2->u.routine.return_type));
                        /* VERIFIED */
                return_match = types_are_equal(type1->u.routine.return_type,
                        type2->u.routine.return_type, doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if ((!(*doubt)) && !return_match)
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }

                left_arg_count = type1->u.routine.argument_count;
                right_arg_count = type2->u.routine.argument_count;
                max_arg_count = ((left_arg_count > right_arg_count) ?
                                 left_arg_count : right_arg_count);

                if ((left_arg_count != right_arg_count) &&
                    (!(type1->u.routine.extra_arguments_allowed)))
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }

                for (arg_num = 0; arg_num < max_arg_count; ++arg_num)
                  {
                    type *left_arg_type;
                    const char *left_name;
                    type *right_arg_type;
                    const char *right_name;
                    boolean arg_doubt;
                    boolean arg_match;

                    if (arg_num >= left_arg_count)
                      {
                        assert(arg_num < right_arg_count);
                        left_arg_type = get_anything_type();
                        if (left_arg_type == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        left_name = NULL;
                      }
                    else
                      {
                        left_arg_type =
                                type1->u.routine.argument_types[arg_num];
                        left_name = type1->u.routine.argument_names[arg_num];
                      }

                    if (arg_num >= right_arg_count)
                      {
                        assert(arg_num < left_arg_count);
                        right_arg_type = get_anything_type();
                        if (right_arg_type == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        right_name = NULL;
                      }
                    else
                      {
                        right_arg_type =
                                type2->u.routine.argument_types[arg_num];
                        right_name = type2->u.routine.argument_names[arg_num];
                      }

                    assert(type_is_valid(left_arg_type)); /* VERIFIED */
                    assert(type_is_valid(right_arg_type)); /* VERIFIED */
                    arg_match = types_are_equal(left_arg_type, right_arg_type,
                            &arg_doubt, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                        return FALSE;
                    if ((!arg_doubt) && !arg_match)
                      {
                        assert(type_is_valid(type1)); /* VERIFIED */
                        assert(type_is_valid(type2)); /* VERIFIED */
                        *doubt = (possibly_nothing(type1) &&
                                  possibly_nothing(type2));
                        return FALSE;
                      }
                    if (arg_doubt)
                        *doubt = TRUE;

                    if (left_name == NULL)
                      {
                        if (right_name != NULL)
                          {
                            assert(type_is_valid(type1)); /* VERIFIED */
                            assert(type_is_valid(type2)); /* VERIFIED */
                            *doubt = (possibly_nothing(type1) &&
                                      possibly_nothing(type2));
                            return FALSE;
                          }
                      }
                    else if (right_name == NULL)
                      {
                        assert(type_is_valid(type1)); /* VERIFIED */
                        assert(type_is_valid(type2)); /* VERIFIED */
                        *doubt = (possibly_nothing(type1) &&
                                  possibly_nothing(type2));
                        return FALSE;
                      }
                    else
                      {
                        if (strcmp(left_name, right_name) != 0)
                          {
                            assert(type_is_valid(type1)); /* VERIFIED */
                            assert(type_is_valid(type2)); /* VERIFIED */
                            *doubt = (possibly_nothing(type1) &&
                                      possibly_nothing(type2));
                            return FALSE;
                          }
                      }

                    if (type1->u.routine.argument_has_defaults[arg_num] !=
                        type2->u.routine.argument_has_defaults[arg_num])
                      {
                        assert(type_is_valid(type1)); /* VERIFIED */
                        assert(type_is_valid(type2)); /* VERIFIED */
                        *doubt = (possibly_nothing(type1) &&
                                  possibly_nothing(type2));
                        return FALSE;
                      }
                  }

                return TRUE;
              }
            case TK_FIELDS:
              {
                boolean field_equality;

                assert(type_is_valid(type1)); /* VERIFIED */
                assert(type_is_valid(type2)); /* VERIFIED */
                field_equality = field_info_is_equal(
                        &(type1->u.fields.field_info),
                        &(type2->u.fields.field_info), doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (*doubt)
                    return FALSE;
                if (!field_equality)
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }
                return TRUE;
              }
            case TK_LEPTON:
              {
                boolean field_equality;

                assert(lepton_key_instance_is_instantiated(
                               type1->u.lepton.key)); /* VERIFIED */
                assert(lepton_key_instance_is_instantiated(
                               type2->u.lepton.key)); /* VERIFIED */
                assert(!(lepton_key_instance_scope_exited(
                                 type1->u.lepton.key))); /* VERIFIED */
                assert(!(lepton_key_instance_scope_exited(
                                 type2->u.lepton.key))); /* VERIFIED */

                if (!(lepton_key_instances_are_equal(type1->u.lepton.key,
                                                     type2->u.lepton.key)))
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }

                assert(type_is_valid(type1)); /* VERIFIED */
                assert(type_is_valid(type2)); /* VERIFIED */
                field_equality = field_info_is_equal(
                        &(type1->u.lepton.field_info),
                        &(type2->u.lepton.field_info), doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (*doubt)
                    return FALSE;
                if (!field_equality)
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }
                return TRUE;
              }
            case TK_MULTISET:
              {
                boolean field_equality;

                assert(type_is_valid(type1)); /* VERIFIED */
                assert(type_is_valid(type2)); /* VERIFIED */
                field_equality = field_info_is_equal(
                        &(type1->u.multiset.field_info),
                        &(type2->u.multiset.field_info), doubt, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (*doubt)
                    return FALSE;
                if (!field_equality)
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }
                return TRUE;
              }
            case TK_INTERFACE:
              {
                field_type_info *left_field_info;
                field_type_info *right_field_info;
                boolean field_equality;
                size_t field_count;
                size_t field_num;

                left_field_info = &(type1->u.interface.field_info);
                right_field_info = &(type2->u.interface.field_info);

                assert(type_is_valid(type1)); /* VERIFIED */
                assert(type_is_valid(type2)); /* VERIFIED */
                field_equality = field_info_is_equal(left_field_info,
                        right_field_info, doubt, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (*doubt)
                    return FALSE;
                if (!field_equality)
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }

                field_count = left_field_info->field_count;
                assert(field_count == right_field_info->field_count);

                for (field_num = 0; field_num < field_count; ++field_num)
                  {
                    if (type1->u.interface.item_writing_alloweds[field_num] !=
                        type2->u.interface.item_writing_alloweds[field_num])
                      {
                        assert(type_is_valid(type1)); /* VERIFIED */
                        assert(type_is_valid(type2)); /* VERIFIED */
                        *doubt = (possibly_nothing(type1) &&
                                  possibly_nothing(type2));
                        return FALSE;
                      }
                  }

                return TRUE;
              }
            case TK_SEMI_LABELED_VALUE_LIST:
              {
                size_t left_element_count;
                size_t right_element_count;
                size_t max_element_count;
                size_t element_num;

                if (type1->u.semi_labeled_value_list.extra_elements_allowed !=
                    type2->u.semi_labeled_value_list.extra_elements_allowed)
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }

                *doubt = FALSE;

                left_element_count =
                        type1->u.semi_labeled_value_list.element_count;
                right_element_count =
                        type2->u.semi_labeled_value_list.element_count;
                max_element_count =
                        ((left_element_count > right_element_count) ?
                         left_element_count : right_element_count);

                if ((left_element_count != right_element_count) &&
                    (!(type1->u.semi_labeled_value_list.
                               extra_elements_allowed)))
                  {
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = (possibly_nothing(type1) &&
                              possibly_nothing(type2));
                    return FALSE;
                  }

                for (element_num = 0; element_num < max_element_count;
                     ++element_num)
                  {
                    type *left_element_type;
                    const char *left_name;
                    type *right_element_type;
                    const char *right_name;
                    boolean element_doubt;
                    boolean element_match;

                    if (element_num >= left_element_count)
                      {
                        assert(element_num < right_element_count);
                        left_element_type = get_anything_type();
                        if (left_element_type == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        left_name = NULL;
                      }
                    else
                      {
                        left_element_type = type1->u.semi_labeled_value_list.
                                element_types[element_num];
                        left_name = type1->u.semi_labeled_value_list.
                                element_names[element_num];
                      }

                    if (element_num >= right_element_count)
                      {
                        assert(element_num < left_element_count);
                        right_element_type = get_anything_type();
                        if (right_element_type == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        right_name = NULL;
                      }
                    else
                      {
                        right_element_type = type2->u.semi_labeled_value_list.
                                element_types[element_num];
                        right_name = type2->u.semi_labeled_value_list.
                                element_names[element_num];
                      }

                    assert(type_is_valid(left_element_type)); /* VERIFIED */
                    assert(type_is_valid(right_element_type)); /* VERIFIED */
                    element_match = types_are_equal(left_element_type,
                            right_element_type, &element_doubt, location,
                            the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                        return FALSE;
                    if ((!element_doubt) && !element_match)
                      {
                        assert(type_is_valid(type1)); /* VERIFIED */
                        assert(type_is_valid(type2)); /* VERIFIED */
                        *doubt = (possibly_nothing(type1) &&
                                  possibly_nothing(type2));
                        return FALSE;
                      }
                    if (element_doubt)
                        *doubt = TRUE;

                    if (left_name == NULL)
                      {
                        if (right_name != NULL)
                          {
                            assert(type_is_valid(left_element_type));
                                    /* VERIFIED */
                            assert(type_is_valid(right_element_type));
                                    /* VERIFIED */
                            *doubt = (possibly_nothing(left_element_type) &&
                                      possibly_nothing(right_element_type));
                            return FALSE;
                          }
                      }
                    else if (right_name == NULL)
                      {
                        assert(type_is_valid(left_element_type));
                                /* VERIFIED */
                        assert(type_is_valid(right_element_type));
                                /* VERIFIED */
                        *doubt = (possibly_nothing(left_element_type) &&
                                  possibly_nothing(right_element_type));
                        return FALSE;
                      }
                    else
                      {
                        if (strcmp(left_name, right_name) != 0)
                          {
                            assert(type_is_valid(left_element_type));
                                    /* VERIFIED */
                            assert(type_is_valid(right_element_type));
                                    /* VERIFIED */
                            *doubt = (possibly_nothing(left_element_type) &&
                                      possibly_nothing(right_element_type));
                            return FALSE;
                          }
                      }
                  }

                return TRUE;
              }
            case TK_REGULAR_EXPRESSION:
              {
                *doubt = TRUE;
                return FALSE;
              }
            case TK_CLASS:
              {
                assert(FALSE);
                return FALSE;
              }
            case TK_TEST_ROUTINE:
            case TK_TEST_ROUTINE_CHAIN:
              {
                *doubt = TRUE;
                return FALSE;
              }
            case TK_SEPARATOR:
              {
                assert(FALSE);
                break;
              }
            default:
              {
                assert(FALSE);
              }
          }
      }

    if (type1->kind == TK_ANYTHING)
      {
        assert(type_is_valid(type2)); /* VERIFIED */
        if (possibly_everything(type2))
          {
            *doubt = TRUE;
            return FALSE;
          }
        else
          {
            *doubt = FALSE;
            return FALSE;
          }
      }

    if (type2->kind == TK_ANYTHING)
      {
        assert(type_is_valid(type1)); /* VERIFIED */
        if (possibly_everything(type1))
          {
            *doubt = TRUE;
            return FALSE;
          }
        else
          {
            *doubt = FALSE;
            return FALSE;
          }
      }

    if (type1->kind == TK_NOTHING)
      {
        assert(type_is_valid(type2)); /* VERIFIED */
        if (possibly_nothing(type2))
          {
            *doubt = TRUE;
            return FALSE;
          }
        else
          {
            *doubt = FALSE;
            return FALSE;
          }
      }

    if (type2->kind == TK_NOTHING)
      {
        assert(type_is_valid(type1)); /* VERIFIED */
        if (possibly_nothing(type1))
          {
            *doubt = TRUE;
            return FALSE;
          }
        else
          {
            *doubt = FALSE;
            return FALSE;
          }
      }

    switch (type1->kind)
      {
        case TK_NOT:
        case TK_INTERSECTION:
        case TK_UNION:
        case TK_XOR:
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
            *doubt = TRUE;
            return FALSE;
        default:
            break;
      }

    switch (type2->kind)
      {
        case TK_NOT:
        case TK_INTERSECTION:
        case TK_UNION:
        case TK_XOR:
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
            *doubt = TRUE;
            return FALSE;
        case TK_ENUMERATION:
            assert(type_is_valid(type2)); /* VERIFIED */
            assert(type_is_valid(type1)); /* VERIFIED */
            return types_are_equal(type2, type1, doubt, location, the_jumper);
        default:
            break;
      }

    switch (type1->kind)
      {
        case TK_ANYTHING:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_NOTHING:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_INTEGER:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_RATIONAL:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_ANY_REGULAR_EXPRESSION:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_ANY_QUARK:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_ANY_LEPTON:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_LEPTON_KEY:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_JUMP_TARGET:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_ANY_CLASS:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_OBJECT:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_TAGALONG_KEY:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_LOCK:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_STRING:
          {
            if (type2->kind == TK_REGULAR_EXPRESSION)
                *doubt = TRUE;
            else
                *doubt = FALSE;
            return FALSE;
          }
        case TK_CHARACTER:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_ENUMERATION:
          {
            boolean local_doubt;
            size_t second_count;
            boolean error;
            boolean has_enumeration;
            value **second_values;
            size_t value_count1;
            size_t value_num;

            assert(type_is_valid(type2)); /* VERIFIED */
            has_enumeration = type_has_finite_enumeration_within_limit(type2,
                    type1->u.enumeration.value_count, &local_doubt,
                    &second_count, &error);
            if (error)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
            if (local_doubt)
              {
                if (type2->kind == TK_REGULAR_EXPRESSION)
                    *doubt = enumeration_has_only_string_values(type1);
                else
                    *doubt = TRUE;
                return FALSE;
              }

            if ((!has_enumeration) ||
                (second_count != type1->u.enumeration.value_count))
              {
                *doubt = FALSE;
                return FALSE;
              }

            assert(type_is_valid(type2)); /* VERIFIED */
            second_values =
                    enumerate(type2, second_count, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(second_values == NULL);
                return FALSE;
              }
            if (second_values == NULL)
              {
                *doubt = TRUE;
                return FALSE;
              }
            assert(second_values != NULL);

            assert(type_is_valid(type1)); /* VERIFIED */

            *doubt = FALSE;

            value_count1 = type1->u.enumeration.value_count;

            for (value_num = 0; value_num < value_count1; ++value_num)
              {
                boolean local_doubt;
                boolean in_type;

                assert(type_is_valid(type2)); /* VERIFIED */
                in_type = value_is_in_type(
                        type1->u.enumeration.values[value_num], type2,
                        &local_doubt, NULL, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    delete_enumeration(second_values, second_count,
                                       the_jumper);
                    return FALSE;
                  }
                if ((!in_type) && !local_doubt)
                  {
                    delete_enumeration(second_values, second_count,
                                       the_jumper);
                    *doubt = FALSE;
                    return FALSE;
                  }
                if (local_doubt)
                    *doubt = TRUE;
              }

            for (value_num = 0; value_num < second_count; ++value_num)
              {
                boolean local_doubt;
                boolean in_type;

                assert(type_is_valid(type1)); /* VERIFIED */
                in_type = value_is_in_type(second_values[value_num], type1,
                        &local_doubt, NULL, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    delete_enumeration(second_values, second_count,
                                       the_jumper);
                    return FALSE;
                  }
                if ((!in_type) && !local_doubt)
                  {
                    delete_enumeration(second_values, second_count,
                                       the_jumper);
                    *doubt = FALSE;
                    return FALSE;
                  }
                if (local_doubt)
                    *doubt = TRUE;
              }

            delete_enumeration(second_values, second_count, the_jumper);

            return TRUE;
          }
        case TK_NOT:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_INTERSECTION:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_UNION:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_XOR:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_ARRAY:
          {
            if (type2->kind == TK_MAP)
              {
                assert(type_is_valid(type1)); /* VERIFIED */
                assert(type_is_valid(type2)); /* VERIFIED */
                return array_and_map_are_equal(type1, type2, doubt, location,
                                               the_jumper);
              }
            else if (type2->kind == TK_SEMI_LABELED_VALUE_LIST)
              {
                assert(type_is_valid(type1)); /* VERIFIED */
                assert(type_is_valid(type2)); /* VERIFIED */
                return array_and_semi_labeled_value_list_are_equal(type1,
                        type2, doubt, location, the_jumper);
              }

            *doubt = FALSE;
            return FALSE;
          }
        case TK_POINTER:
          {
            assert(type_is_valid(type1)); /* VERIFIED */
            assert(type_is_valid(type2)); /* VERIFIED */
            *doubt = (possibly_nothing(type1) && possibly_nothing(type2));
            return FALSE;
          }
        case TK_TYPE:
          {
            assert(type_is_valid(type1)); /* VERIFIED */
            assert(type_is_valid(type2)); /* VERIFIED */
            *doubt = (possibly_nothing(type1) && possibly_nothing(type2));
            return FALSE;
          }
        case TK_MAP:
          {
            if (type2->kind == TK_ARRAY)
              {
                assert(type_is_valid(type2)); /* VERIFIED */
                assert(type_is_valid(type1)); /* VERIFIED */
                return array_and_map_are_equal(type2, type1, doubt, location,
                                               the_jumper);
              }
            else if (type2->kind == TK_SEMI_LABELED_VALUE_LIST)
              {
                assert(type_is_valid(type2)); /* VERIFIED */
                assert(type_is_valid(type1)); /* VERIFIED */
                return semi_labeled_value_list_and_map_are_equal(type2, type1,
                        doubt, location, the_jumper);
              }

            *doubt = FALSE;
            return FALSE;
          }
        case TK_ROUTINE:
          {
            assert(type_is_valid(type1)); /* VERIFIED */
            assert(type_is_valid(type2)); /* VERIFIED */
            *doubt = (possibly_nothing(type1) && possibly_nothing(type2));
            return FALSE;
          }
        case TK_FIELDS:
          {
            assert(type_is_valid(type1)); /* VERIFIED */
            assert(type_is_valid(type2)); /* VERIFIED */
            *doubt = (possibly_nothing(type1) && possibly_nothing(type2));
            return FALSE;
          }
        case TK_LEPTON:
          {
            assert(type_is_valid(type1)); /* VERIFIED */
            assert(type_is_valid(type2)); /* VERIFIED */
            *doubt = (possibly_nothing(type1) && possibly_nothing(type2));
            return FALSE;
          }
        case TK_MULTISET:
          {
            assert(type_is_valid(type1)); /* VERIFIED */
            assert(type_is_valid(type2)); /* VERIFIED */
            *doubt = (possibly_nothing(type1) && possibly_nothing(type2));
            return FALSE;
          }
        case TK_INTERFACE:
          {
            assert(type_is_valid(type1)); /* VERIFIED */
            assert(type_is_valid(type2)); /* VERIFIED */
            *doubt = (possibly_nothing(type1) && possibly_nothing(type2));
            return FALSE;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            if (type2->kind == TK_ARRAY)
              {
                assert(type_is_valid(type2)); /* VERIFIED */
                assert(type_is_valid(type1)); /* VERIFIED */
                return array_and_semi_labeled_value_list_are_equal(type2,
                        type1, doubt, location, the_jumper);
              }
            else if (type2->kind == TK_MAP)
              {
                assert(type_is_valid(type1)); /* VERIFIED */
                assert(type_is_valid(type2)); /* VERIFIED */
                return semi_labeled_value_list_and_map_are_equal(type1, type2,
                        doubt, location, the_jumper);
              }

            assert(type_is_valid(type1)); /* VERIFIED */
            assert(type_is_valid(type2)); /* VERIFIED */
            *doubt = (possibly_nothing(type1) && possibly_nothing(type2));
            return FALSE;
          }
        case TK_REGULAR_EXPRESSION:
          {
            if (type2->kind == TK_STRING)
                *doubt = TRUE;
            else if (type2->kind == TK_ENUMERATION)
                *doubt = enumeration_has_only_string_values(type2);
            else
                *doubt = FALSE;
            return FALSE;
          }
        case TK_CLASS:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_TEST_ROUTINE:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_TEST_ROUTINE_CHAIN:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return FALSE;
          }
        default:
          {
            assert(FALSE);
            return FALSE;
          }
      }
  }

extern int type_structural_order(type *left, type *right)
  {
    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    if (left == right)
        return 0;

    if (left->kind != right->kind)
      {
        if (left->kind < right->kind)
            return -1;
        else
            return 1;
      }

    switch (left->kind)
      {
        case TK_ANYTHING:
        case TK_NOTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
          {
            return 0;
          }
        case TK_ENUMERATION:
          {
            size_t left_count;
            size_t right_count;
            size_t value_num;

            left_count = left->u.enumeration.value_count;
            right_count = right->u.enumeration.value_count;

            value_num = 0;
            while (TRUE)
              {
                int element_order;

                if (value_num >= left_count)
                  {
                    if (value_num >= right_count)
                        return 0;
                    else
                        return -1;
                  }

                if (value_num >= right_count)
                    return 1;

                assert(value_is_valid(left->u.enumeration.values[value_num]));
                        /* VERIFIED */
                assert(value_is_valid(right->u.enumeration.values[value_num]));
                        /* VERIFIED */
                element_order = value_structural_order(
                        left->u.enumeration.values[value_num],
                        right->u.enumeration.values[value_num]);
                if (element_order != 0)
                    return element_order;

                ++value_num;
              }
          }
        case TK_NOT:
          {
            assert(type_is_valid(left->u.not.base)); /* VERIFIED */
            assert(type_is_valid(right->u.not.base)); /* VERIFIED */
            return type_structural_order(left->u.not.base, right->u.not.base);
          }
        case TK_INTERSECTION:
          {
            int lefts_order;

            assert(type_is_valid(left->u.intersection.left)); /* VERIFIED */
            assert(type_is_valid(right->u.intersection.left)); /* VERIFIED */
            lefts_order = type_structural_order(left->u.intersection.left,
                                                right->u.intersection.left);
            if (lefts_order != 0)
                return lefts_order;
            assert(type_is_valid(left->u.intersection.right)); /* VERIFIED */
            assert(type_is_valid(right->u.intersection.right)); /* VERIFIED */
            return type_structural_order(left->u.intersection.right,
                                         right->u.intersection.right);
          }
        case TK_UNION:
          {
            int lefts_order;

            assert(type_is_valid(left->u.union_type.left)); /* VERIFIED */
            assert(type_is_valid(right->u.union_type.left)); /* VERIFIED */
            lefts_order = type_structural_order(left->u.union_type.left,
                                                right->u.union_type.left);
            if (lefts_order != 0)
                return lefts_order;
            assert(type_is_valid(left->u.union_type.right)); /* VERIFIED */
            assert(type_is_valid(right->u.union_type.right)); /* VERIFIED */
            return type_structural_order(left->u.union_type.right,
                                         right->u.union_type.right);
          }
        case TK_XOR:
          {
            int lefts_order;

            assert(type_is_valid(left->u.xor.left)); /* VERIFIED */
            assert(type_is_valid(right->u.xor.left)); /* VERIFIED */
            lefts_order =
                    type_structural_order(left->u.xor.left, right->u.xor.left);
            if (lefts_order != 0)
                return lefts_order;
            assert(type_is_valid(left->u.xor.right)); /* VERIFIED */
            assert(type_is_valid(right->u.xor.right)); /* VERIFIED */
            return type_structural_order(left->u.xor.right,
                                         right->u.xor.right);
          }
        case TK_ARRAY:
          {
            int test_order;

            assert(type_is_valid(left->u.array.base)); /* VERIFIED */
            assert(type_is_valid(right->u.array.base)); /* VERIFIED */
            test_order = type_structural_order(left->u.array.base,
                                               right->u.array.base);
            if (test_order != 0)
                return test_order;

            test_order = oi_structural_order(left->u.array.lower_bound,
                                             right->u.array.lower_bound);
            if (test_order != 0)
                return test_order;

            return oi_structural_order(left->u.array.upper_bound,
                                       right->u.array.upper_bound);
          }
        case TK_INTEGER_RANGES:
          {
            size_t component_count;
            integer_range_component *left_components;
            integer_range_component *right_components;
            size_t component_num;

            if (left->u.integer_ranges.includes_negative_infinity !=
                right->u.integer_ranges.includes_negative_infinity)
              {
                return (left->u.integer_ranges.includes_negative_infinity ? 1 :
                        -1);
              }

            component_count = left->u.integer_ranges.component_count;
            if (component_count != right->u.integer_ranges.component_count)
              {
                return ((component_count <
                         right->u.integer_ranges.component_count) ? -1 : 1);
              }

            left_components = left->u.integer_ranges.components;
            right_components = right->u.integer_ranges.components;

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                int lower_order;
                int upper_order;

                lower_order = oi_structural_order(
                        left_components[component_num].lower_bound,
                        right_components[component_num].lower_bound);
                if (lower_order != 0)
                    return lower_order;

                upper_order = oi_structural_order(
                        left_components[component_num].upper_bound,
                        right_components[component_num].upper_bound);
                if (upper_order != 0)
                    return upper_order;
              }

            if (left->u.integer_ranges.includes_positive_infinity !=
                right->u.integer_ranges.includes_positive_infinity)
              {
                return (left->u.integer_ranges.includes_positive_infinity ? 1 :
                        -1);
              }

            if (left->u.integer_ranges.includes_unsigned_infinity !=
                right->u.integer_ranges.includes_unsigned_infinity)
              {
                return (left->u.integer_ranges.includes_unsigned_infinity ? 1 :
                        -1);
              }

            if (left->u.integer_ranges.includes_zero_zero !=
                right->u.integer_ranges.includes_zero_zero)
              {
                return (left->u.integer_ranges.includes_zero_zero ? 1 : -1);
              }

            return 0;
          }
        case TK_RATIONAL_RANGES:
          {
            size_t component_count;
            rational_range_component *left_components;
            rational_range_component *right_components;
            size_t component_num;

            if (left->u.rational_ranges.includes_negative_infinity !=
                right->u.rational_ranges.includes_negative_infinity)
              {
                return (left->u.rational_ranges.includes_negative_infinity ?
                        1 : -1);
              }

            component_count = left->u.rational_ranges.component_count;
            if (component_count != right->u.rational_ranges.component_count)
              {
                return ((component_count <
                         right->u.rational_ranges.component_count) ? -1 : 1);
              }

            left_components = left->u.rational_ranges.components;
            right_components = right->u.rational_ranges.components;

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                int lower_order;
                int upper_order;

                if (left_components[component_num].lower_is_inclusive !=
                    right_components[component_num].lower_is_inclusive)
                  {
                    return (left_components[component_num].lower_is_inclusive ?
                            -1 : 1);
                  }

                lower_order = rational_structural_order(
                        left_components[component_num].lower_bound,
                        right_components[component_num].lower_bound);
                if (lower_order != 0)
                    return lower_order;

                upper_order = rational_structural_order(
                        left_components[component_num].upper_bound,
                        right_components[component_num].upper_bound);
                if (upper_order != 0)
                    return upper_order;

                if (left_components[component_num].upper_is_inclusive !=
                    right_components[component_num].upper_is_inclusive)
                  {
                    return (left_components[component_num].upper_is_inclusive ?
                            -1 : 1);
                  }
              }

            if (left->u.rational_ranges.includes_positive_infinity !=
                right->u.rational_ranges.includes_positive_infinity)
              {
                return (left->u.rational_ranges.includes_positive_infinity ?
                        1 : -1);
              }

            if (left->u.rational_ranges.includes_unsigned_infinity !=
                right->u.rational_ranges.includes_unsigned_infinity)
              {
                return (left->u.rational_ranges.includes_unsigned_infinity ?
                        1 : -1);
              }

            if (left->u.rational_ranges.includes_zero_zero !=
                right->u.rational_ranges.includes_zero_zero)
              {
                return (left->u.rational_ranges.includes_zero_zero ? 1 : -1);
              }

            return 0;
          }
        case TK_POINTER:
          {
            int test_order;

            assert(type_is_valid(left->u.pointer.base)); /* VERIFIED */
            assert(type_is_valid(right->u.pointer.base)); /* VERIFIED */
            test_order = type_structural_order(left->u.pointer.base,
                                               right->u.pointer.base);
            if (test_order != 0)
                return test_order;

            if (left->u.pointer.read_allowed != right->u.pointer.read_allowed)
                return (left->u.pointer.read_allowed ? 1 : -1);

            if (left->u.pointer.write_allowed !=
                right->u.pointer.write_allowed)
              {
                return (left->u.pointer.write_allowed ? 1 : -1);
              }

            if (left->u.pointer.null_allowed != right->u.pointer.null_allowed)
                return (left->u.pointer.null_allowed ? 1 : -1);

            return 0;
          }
        case TK_TYPE:
          {
            assert(type_is_valid(left->u.type.base)); /* VERIFIED */
            assert(type_is_valid(right->u.type.base)); /* VERIFIED */
            return type_structural_order(left->u.type.base,
                                         right->u.type.base);
          }
        case TK_MAP:
          {
            int key_order;

            assert(type_is_valid(left->u.map.key)); /* VERIFIED */
            assert(type_is_valid(right->u.map.key)); /* VERIFIED */
            key_order =
                    type_structural_order(left->u.map.key, right->u.map.key);
            if (key_order != 0)
                return key_order;
            assert(type_is_valid(left->u.map.target)); /* VERIFIED */
            assert(type_is_valid(right->u.map.target)); /* VERIFIED */
            return type_structural_order(left->u.map.target,
                                         right->u.map.target);
          }
        case TK_ROUTINE:
          {
            int test_order;
            size_t left_arg_count;
            size_t right_arg_count;
            size_t arg_num;

            assert(type_is_valid(left->u.routine.return_type)); /* VERIFIED */
            assert(type_is_valid(right->u.routine.return_type)); /* VERIFIED */
            test_order = type_structural_order(left->u.routine.return_type,
                                               right->u.routine.return_type);
            if (test_order != 0)
                return test_order;

            left_arg_count = left->u.routine.argument_count;
            right_arg_count = right->u.routine.argument_count;

            arg_num = 0;
            while (TRUE)
              {
                type *left_argument_type;
                type *right_argument_type;
                int test_order;
                const char *left_name;
                const char *right_name;

                if (arg_num >= left_arg_count)
                  {
                    if (arg_num < right_arg_count)
                        return -1;
                    break;
                  }

                if (arg_num >= right_arg_count)
                    return 1;

                left_argument_type = left->u.routine.argument_types[arg_num];
                right_argument_type = right->u.routine.argument_types[arg_num];
                assert(left_argument_type != NULL);
                assert(right_argument_type != NULL);
                assert(type_is_valid(left_argument_type)); /* VERIFIED */
                assert(type_is_valid(right_argument_type)); /* VERIFIED */
                test_order = type_structural_order(left_argument_type,
                                                   right_argument_type);
                if (test_order != 0)
                    return test_order;

                left_name = left->u.routine.argument_names[arg_num];
                right_name = right->u.routine.argument_names[arg_num];
                if (left_name == NULL)
                  {
                    if (right_name != NULL)
                        return -1;
                  }
                else if (right_name == NULL)
                  {
                    return 1;
                  }
                else
                  {
                    int test_order;

                    test_order =
                            utf8_string_lexicographical_order_by_code_point(
                                    left_name, right_name);
                    if (test_order != 0)
                        return test_order;
                  }

                if (left->u.routine.argument_has_defaults[arg_num] !=
                    right->u.routine.argument_has_defaults[arg_num])
                  {
                    return (left->u.routine.argument_has_defaults[arg_num] ?
                            1 : -1);
                  }

                ++arg_num;
              }

            if (left->u.routine.extra_arguments_allowed !=
                right->u.routine.extra_arguments_allowed)
              {
                return (left->u.routine.extra_arguments_allowed ? 1 : -1);
              }

            if (left->u.routine.extra_arguments_unspecified !=
                right->u.routine.extra_arguments_unspecified)
              {
                return (left->u.routine.extra_arguments_allowed ? 1 : -1);
              }

            return 0;
          }
        case TK_FIELDS:
          {
            assert(type_is_valid(left)); /* VERIFIED */
            assert(type_is_valid(right)); /* VERIFIED */
            return field_info_structural_order(&(left->u.fields.field_info),
                                               &(right->u.fields.field_info));
          }
        case TK_LEPTON:
          {
            int key_order;

            assert(lepton_key_instance_is_instantiated(left->u.lepton.key));
                    /* VERIFIED */
            assert(lepton_key_instance_is_instantiated(right->u.lepton.key));
                    /* VERIFIED */
            assert(!(lepton_key_instance_scope_exited(left->u.lepton.key)));
                    /* VERIFIED */
            assert(!(lepton_key_instance_scope_exited(right->u.lepton.key)));
                    /* VERIFIED */

            key_order = lepton_key_instance_structural_order(
                    left->u.lepton.key, right->u.lepton.key);
            if (key_order != 0)
                return key_order;

            assert(type_is_valid(left)); /* VERIFIED */
            assert(type_is_valid(right)); /* VERIFIED */
            return field_info_structural_order(&(left->u.lepton.field_info),
                                               &(right->u.lepton.field_info));
          }
        case TK_MULTISET:
          {
            assert(type_is_valid(left)); /* VERIFIED */
            assert(type_is_valid(right)); /* VERIFIED */
            return field_info_structural_order(&(left->u.multiset.field_info),
                    &(right->u.multiset.field_info));
          }
        case TK_INTERFACE:
          {
            field_type_info *left_field_info;
            field_type_info *right_field_info;
            int field_info_order;
            size_t field_count;
            size_t field_num;

            if (left->u.interface.null_allowed !=
                right->u.interface.null_allowed)
              {
                return (left->u.interface.null_allowed ? 1 : -1);
              }

            left_field_info = &(left->u.interface.field_info);
            right_field_info = &(right->u.interface.field_info);

            assert(type_is_valid(left)); /* VERIFIED */
            assert(type_is_valid(right)); /* VERIFIED */
            field_info_order = field_info_structural_order(left_field_info,
                                                           right_field_info);
            if (field_info_order != 0)
                return field_info_order;

            field_count = left_field_info->field_count;
            assert(field_count == right_field_info->field_count);

            for (field_num = 0; field_num < field_count; ++field_num)
              {
                if (left->u.interface.item_writing_alloweds[field_num] !=
                    right->u.interface.item_writing_alloweds[field_num])
                  {
                    return (left->u.interface.item_writing_alloweds[field_num]
                            ? 1 : -1);
                  }
              }

            return 0;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t left_count;
            size_t right_count;
            size_t element_num;

            left_count = left->u.semi_labeled_value_list.element_count;
            right_count = right->u.semi_labeled_value_list.element_count;

            element_num = 0;
            while (TRUE)
              {
                const char *left_name;
                const char *right_name;
                type *left_element_type;
                type *right_element_type;
                int test_order;

                if (element_num >= left_count)
                  {
                    if (element_num < right_count)
                        return -1;
                    break;
                  }

                if (element_num >= right_count)
                    return 1;

                left_name = left->u.semi_labeled_value_list.element_names[
                        element_num];
                right_name = right->u.semi_labeled_value_list.element_names[
                        element_num];
                if (left_name == NULL)
                  {
                    if (right_name != NULL)
                        return -1;
                  }
                else if (right_name == NULL)
                  {
                    return 1;
                  }
                else
                  {
                    int name_order;

                    name_order =
                            utf8_string_lexicographical_order_by_code_point(
                                    left_name, right_name);
                    if (name_order != 0)
                        return name_order;
                  }

                left_element_type = left->u.semi_labeled_value_list.
                        element_types[element_num];
                right_element_type = right->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(left_element_type != NULL);
                assert(right_element_type != NULL);
                assert(type_is_valid(left_element_type)); /* VERIFIED */
                assert(type_is_valid(right_element_type)); /* VERIFIED */
                test_order = type_structural_order(left_element_type,
                                                   right_element_type);
                if (test_order != 0)
                    return test_order;

                ++element_num;
              }

            if (left->u.semi_labeled_value_list.extra_elements_allowed !=
                right->u.semi_labeled_value_list.extra_elements_allowed)
              {
                return (left->u.semi_labeled_value_list.extra_elements_allowed
                        ? 1 : -1);
              }

            return 0;
          }
        case TK_REGULAR_EXPRESSION:
          {
            return regular_expression_structural_order(
                    left->u.regular_expression.regular_expression,
                    right->u.regular_expression.regular_expression);
          }
        case TK_CLASS:
          {
            assert(routine_instance_is_instantiated(left->u.class.routine));
                    /* VERIFIED */
            assert(routine_instance_is_instantiated(right->u.class.routine));
                    /* VERIFIED */
            assert(!(routine_instance_scope_exited(left->u.class.routine)));
                    /* VERIFIED */
            assert(!(routine_instance_scope_exited(right->u.class.routine)));
                    /* VERIFIED */
            return routine_instance_structural_order(left->u.class.routine,
                                                     right->u.class.routine);
          }
        case TK_TEST_ROUTINE:
          {
            assert(routine_instance_is_instantiated(
                           left->u.test_routine.test_routine)); /* VERIFIED */
            assert(routine_instance_is_instantiated(
                           right->u.test_routine.test_routine)); /* VERIFIED */
            assert(!(routine_instance_scope_exited(
                             left->u.test_routine.test_routine)));
                    /* VERIFIED */
            assert(!(routine_instance_scope_exited(
                             right->u.test_routine.test_routine)));
                    /* VERIFIED */
            return routine_instance_structural_order(
                    left->u.test_routine.test_routine,
                    right->u.test_routine.test_routine);
          }
        case TK_TEST_ROUTINE_CHAIN:
          {
            assert(routine_instance_chain_is_valid(
                           left->u.test_routine_chain.routine_chain));
                    /* VERIFIED */
            assert(routine_instance_chain_is_valid(
                           right->u.test_routine_chain.routine_chain));
                    /* VERIFIED */
            return routine_instance_chain_structural_order(
                    left->u.test_routine_chain.routine_chain,
                    right->u.test_routine_chain.routine_chain);
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return -2;
          }
        default:
          {
            assert(FALSE);
            return -2;
          }
      }
  }

extern boolean type_is_slippery(type *the_type)
  {
    assert(the_type != NULL);

    switch (the_type->kind)
      {
        case TK_ANYTHING:
        case TK_NOTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
            return FALSE;
        case TK_ENUMERATION:
            return the_type->u.enumeration.slippery;
        case TK_NOT:
        case TK_INTERSECTION:
        case TK_UNION:
        case TK_XOR:
            return TRUE;
        case TK_ARRAY:
            return TRUE;
        case TK_INTEGER_RANGES:
            return FALSE;
        case TK_RATIONAL_RANGES:
            return FALSE;
        case TK_POINTER:
            return TRUE;
        case TK_TYPE:
            return the_type->u.type.slippery;
        case TK_MAP:
            return the_type->u.map.slippery;
        case TK_ROUTINE:
            return the_type->u.routine.slippery;
        case TK_FIELDS:
            return the_type->u.fields.field_info.slippery;
        case TK_LEPTON:
            return the_type->u.lepton.field_info.slippery;
        case TK_MULTISET:
            return the_type->u.multiset.field_info.slippery;
        case TK_INTERFACE:
            return the_type->u.interface.field_info.slippery;
        case TK_SEMI_LABELED_VALUE_LIST:
            return the_type->u.semi_labeled_value_list.slippery;
        case TK_REGULAR_EXPRESSION:
            return TRUE;
        case TK_CLASS:
            return FALSE;
        case TK_TEST_ROUTINE:
            return TRUE;
        case TK_TEST_ROUTINE_CHAIN:
            return TRUE;
        case TK_SEPARATOR:
            assert(FALSE);
            return TRUE;
        default:
            assert(FALSE);
            return TRUE;
      }
  }

extern void print_type(type *the_type,
        void (*printer)(void *data, const char *format, ...), void *data,
        type_expression_parsing_precedence precedence)
  {
    print_type_with_override(the_type, printer, data, &print_value,
                             precedence);
  }

extern void print_type_with_override(type *the_type,
        void (*printer)(void *data, const char *format, ...), void *data,
        void (*override)(value *the_value,
                void (*printer)(void *data, const char *format, ...),
                void *data), type_expression_parsing_precedence precedence)
  {
    assert(the_type != NULL);
    assert(printer != NULL);
    assert(override != NULL);

    switch (the_type->kind)
      {
        case TK_ANYTHING:
          {
            if (precedence > TEPP_NOT)
                (*printer)(data, "(");
            (*printer)(data, "!{}");
            if (precedence > TEPP_NOT)
                (*printer)(data, ")");
            break;
          }
        case TK_NOTHING:
          {
            (*printer)(data, "{}");
            break;
          }
        case TK_INTEGER:
          {
            (*printer)(data, "integer");
            break;
          }
        case TK_RATIONAL:
          {
            (*printer)(data, "rational");
            break;
          }
        case TK_ANY_REGULAR_EXPRESSION:
          {
            (*printer)(data, "regular_expression");
            break;
          }
        case TK_ANY_QUARK:
          {
            (*printer)(data, "any_quark");
            break;
          }
        case TK_ANY_LEPTON:
          {
            (*printer)(data, "any_lepton");
            break;
          }
        case TK_LEPTON_KEY:
          {
            (*printer)(data, "lepton_key");
            break;
          }
        case TK_JUMP_TARGET:
          {
            (*printer)(data, "jump_target");
            break;
          }
        case TK_ANY_CLASS:
          {
            (*printer)(data, "any_class");
            break;
          }
        case TK_OBJECT:
          {
            (*printer)(data, "object");
            break;
          }
        case TK_TAGALONG_KEY:
          {
            (*printer)(data, "tagalong_key");
            break;
          }
        case TK_LOCK:
          {
            (*printer)(data, "any_lock");
            break;
          }
        case TK_STRING:
          {
            (*printer)(data, "string");
            break;
          }
        case TK_CHARACTER:
          {
            (*printer)(data, "character");
            break;
          }
        case TK_ENUMERATION:
          {
            size_t value_count;
            value **values;
            size_t value_num;

            value_count = the_type->u.enumeration.value_count;
            values = the_type->u.enumeration.values;

            (*printer)(data, "{");

            for (value_num = 0; value_num < value_count; ++value_num)
              {
                if (value_num != 0)
                    (*printer)(data, ", ");

                assert(values != NULL);
                assert(values[value_num] != NULL);
                (*override)(values[value_num], printer, data);
              }

            (*printer)(data, "}");

            break;
          }
        case TK_NOT:
          {
            if (precedence > TEPP_NOT)
                (*printer)(data, "(");
            (*printer)(data, "!");
            print_type_with_override(the_type->u.not.base, printer, data,
                                     override, TEPP_NOT);
            if (precedence > TEPP_NOT)
                (*printer)(data, ")");
            break;
          }
        case TK_INTERSECTION:
          {
            if (precedence > TEPP_AND)
                (*printer)(data, "(");
            print_type_with_override(the_type->u.intersection.left, printer,
                                     data, override, TEPP_AND);
            (*printer)(data, " & ");
            print_type_with_override(the_type->u.intersection.right, printer,
                                     data, override, TEPP_AND + 1);
            if (precedence > TEPP_AND)
                (*printer)(data, ")");
            break;
          }
        case TK_UNION:
          {
            if (precedence > TEPP_OR)
                (*printer)(data, "(");
            print_type_with_override(the_type->u.union_type.left, printer,
                                     data, override, TEPP_OR);
            (*printer)(data, " | ");
            print_type_with_override(the_type->u.union_type.right, printer,
                                     data, override, TEPP_OR + 1);
            if (precedence > TEPP_OR)
                (*printer)(data, ")");
            break;
          }
        case TK_XOR:
          {
            if (precedence > TEPP_XOR)
                (*printer)(data, "(");
            print_type_with_override(the_type->u.xor.left, printer, data,
                                     override, TEPP_XOR);
            (*printer)(data, " ^ ");
            print_type_with_override(the_type->u.xor.right, printer, data,
                                     override, TEPP_XOR + 1);
            if (precedence > TEPP_XOR)
                (*printer)(data, ")");
            break;
          }
        case TK_ARRAY:
          {
            if (precedence > TEPP_ARRAY)
                (*printer)(data, "(");
            print_type_with_override(the_type->u.array.base, printer, data,
                                     override, TEPP_ARRAY);
            (*printer)(data, "[");
            print_oi(the_type->u.array.lower_bound, printer, data);
            (*printer)(data, "...");
            print_oi(the_type->u.array.upper_bound, printer, data);
            (*printer)(data, "]");
            if (precedence > TEPP_ARRAY)
                (*printer)(data, ")");
            break;
          }
        case TK_INTEGER_RANGES:
          {
            size_t component_count;
            integer_range_component *components;
            boolean includes_negative_infinity;
            boolean includes_positive_infinity;
            boolean includes_unsigned_infinity;
            boolean includes_zero_zero;
            boolean use_parens;
            size_t component_num;
            boolean in_enumeration;
            boolean first;

            component_count = the_type->u.integer_ranges.component_count;

            components = the_type->u.integer_ranges.components;

            includes_negative_infinity =
                    the_type->u.integer_ranges.includes_negative_infinity;
            includes_positive_infinity =
                    the_type->u.integer_ranges.includes_positive_infinity;
            includes_unsigned_infinity =
                    the_type->u.integer_ranges.includes_unsigned_infinity;
            includes_zero_zero = the_type->u.integer_ranges.includes_zero_zero;

            if (precedence <= TEPP_OR)
              {
                use_parens = FALSE;
              }
            else
              {
                size_t component_num;

                use_parens = FALSE;

                for (component_num = 0; component_num < component_count;
                     ++component_num)
                  {
                    o_integer lower_bound;
                    o_integer upper_bound;
                    o_integer diff;
                    boolean do_range;

                    lower_bound = components[component_num].lower_bound;
                    upper_bound = components[component_num].upper_bound;

                    oi_subtract(diff, upper_bound, lower_bound);
                    if (oi_out_of_memory(diff))
                      {
                        do_range = TRUE;
                      }
                    else
                      {
                        do_range = oi_less_than(oi_one, diff);
                        oi_remove_reference(diff);
                      }

                    if (do_range)
                      {
                        use_parens =
                                ((component_num > 0) || (component_count > 1)
                                 || includes_unsigned_infinity ||
                                 includes_zero_zero ||
                                 (includes_negative_infinity &&
                                  (oi_kind(lower_bound) !=
                                   IIK_NEGATIVE_INFINITY)) ||
                                 (includes_positive_infinity &&
                                  (oi_kind(upper_bound) !=
                                   IIK_POSITIVE_INFINITY)));
                        break;
                      }
                  }
              }

            if (use_parens)
                (*printer)(data, "(");

            in_enumeration = FALSE;
            first = TRUE;

            if (includes_negative_infinity)
              {
                if ((component_count == 0) ||
                    (oi_kind(components[0].lower_bound) !=
                     IIK_NEGATIVE_INFINITY))
                  {
                    if (in_enumeration)
                      {
                        (*printer)(data, ", ");
                      }
                    else
                      {
                        if (!first)
                            (*printer)(data, " | ");
                        (*printer)(data, "{");
                        in_enumeration = TRUE;
                      }

                    print_oi(oi_negative_infinity, printer, data);
                  }
              }

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                o_integer lower_bound;
                o_integer upper_bound;
                o_integer diff;
                boolean do_range;

                lower_bound = components[component_num].lower_bound;
                upper_bound = components[component_num].upper_bound;

                oi_subtract(diff, upper_bound, lower_bound);
                if (oi_out_of_memory(diff))
                  {
                    do_range = TRUE;
                  }
                else
                  {
                    do_range = oi_less_than(oi_one, diff);
                    oi_remove_reference(diff);
                  }

                if (do_range)
                  {
                    if (in_enumeration)
                      {
                        (*printer)(data, "}");
                        first = FALSE;
                      }
                    in_enumeration = FALSE;
                    if (!first)
                        (*printer)(data, " | ");
                    first = FALSE;

                    if (oi_kind(lower_bound) == IIK_NEGATIVE_INFINITY)
                      {
                        if (!includes_negative_infinity)
                            (*printer)(data, "(");
                        else
                            (*printer)(data, "[");
                      }
                    else
                      {
                        (*printer)(data, "[");
                      }

                    print_oi(lower_bound, printer, data);
                    (*printer)(data, "...");
                    print_oi(upper_bound, printer, data);

                    if (oi_kind(upper_bound) == IIK_POSITIVE_INFINITY)
                      {
                        if (!includes_positive_infinity)
                            (*printer)(data, ")");
                        else
                            (*printer)(data, "]");
                        includes_positive_infinity = FALSE;
                      }
                    else
                      {
                        (*printer)(data, "]");
                      }
                  }
                else
                  {
                    if (in_enumeration)
                      {
                        (*printer)(data, ", ");
                      }
                    else
                      {
                        if (!first)
                            (*printer)(data, " | ");
                        (*printer)(data, "{");
                        in_enumeration = TRUE;
                      }

                    print_oi(lower_bound, printer, data);
                    if (!(oi_equal(lower_bound, upper_bound)))
                      {
                        (*printer)(data, ", ");
                        print_oi(upper_bound, printer, data);
                      }
                  }
              }

            if (includes_positive_infinity)
              {
                if (in_enumeration)
                  {
                    (*printer)(data, ", ");
                  }
                else
                  {
                    if (!first)
                        (*printer)(data, " | ");
                    (*printer)(data, "{");
                    in_enumeration = TRUE;
                  }

                print_oi(oi_positive_infinity, printer, data);
              }

            if (includes_unsigned_infinity)
              {
                if (in_enumeration)
                  {
                    (*printer)(data, ", ");
                  }
                else
                  {
                    if (!first)
                        (*printer)(data, " | ");
                    (*printer)(data, "{");
                    in_enumeration = TRUE;
                  }

                print_oi(oi_unsigned_infinity, printer, data);
              }

            if (includes_zero_zero)
              {
                if (in_enumeration)
                  {
                    (*printer)(data, ", ");
                  }
                else
                  {
                    if (!first)
                        (*printer)(data, " | ");
                    (*printer)(data, "{");
                    in_enumeration = TRUE;
                  }

                print_oi(oi_zero_zero, printer, data);
              }

            if (in_enumeration)
                (*printer)(data, "}");

            if (use_parens)
                (*printer)(data, ")");

            break;
          }
        case TK_RATIONAL_RANGES:
          {
            size_t component_count;
            rational_range_component *components;
            boolean includes_negative_infinity;
            boolean includes_positive_infinity;
            boolean includes_unsigned_infinity;
            boolean includes_zero_zero;
            boolean use_parens;
            size_t component_num;
            boolean in_enumeration;
            boolean first;

            component_count = the_type->u.rational_ranges.component_count;

            components = the_type->u.rational_ranges.components;

            includes_negative_infinity =
                    the_type->u.rational_ranges.includes_negative_infinity;
            includes_positive_infinity =
                    the_type->u.rational_ranges.includes_positive_infinity;
            includes_unsigned_infinity =
                    the_type->u.rational_ranges.includes_unsigned_infinity;
            includes_zero_zero =
                    the_type->u.rational_ranges.includes_zero_zero;

            if (precedence <= TEPP_OR)
              {
                use_parens = FALSE;
              }
            else
              {
                size_t component_num;

                use_parens = FALSE;

                for (component_num = 0; component_num < component_count;
                     ++component_num)
                  {
                    rational *lower_bound;
                    rational *upper_bound;

                    lower_bound = components[component_num].lower_bound;
                    upper_bound = components[component_num].upper_bound;

                    if (!(rationals_are_equal(lower_bound, upper_bound)))
                      {
                        use_parens =
                                ((component_num > 0) || (component_count > 1)
                                 || includes_unsigned_infinity ||
                                 includes_zero_zero ||
                                 (includes_negative_infinity &&
                                  (oi_kind(rational_numerator(lower_bound)) !=
                                   IIK_NEGATIVE_INFINITY)) ||
                                 (includes_positive_infinity &&
                                  (oi_kind(rational_numerator(upper_bound)) !=
                                   IIK_POSITIVE_INFINITY)));
                        break;
                      }
                  }
              }

            if (use_parens)
                (*printer)(data, "(");

            in_enumeration = FALSE;
            first = TRUE;

            if (includes_negative_infinity)
              {
                if ((component_count == 0) ||
                    (oi_kind(rational_numerator(components[0].lower_bound)) !=
                     IIK_NEGATIVE_INFINITY))
                  {
                    if (in_enumeration)
                      {
                        (*printer)(data, ", ");
                      }
                    else
                      {
                        if (!first)
                            (*printer)(data, " | ");
                        (*printer)(data, "{");
                        in_enumeration = TRUE;
                      }

                    print_oi(oi_negative_infinity, printer, data);
                  }
              }

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                rational *lower_bound;
                rational *upper_bound;

                lower_bound = components[component_num].lower_bound;
                upper_bound = components[component_num].upper_bound;

                if (rationals_are_equal(lower_bound, upper_bound))
                  {
                    assert(components[component_num].lower_is_inclusive);
                    assert(components[component_num].upper_is_inclusive);

                    if (in_enumeration)
                      {
                        (*printer)(data, ", ");
                      }
                    else
                      {
                        if (!first)
                            (*printer)(data, " | ");
                        (*printer)(data, "{");
                        in_enumeration = TRUE;
                      }

                    print_rational(lower_bound, printer, data);
                  }
                else
                  {
                    boolean lower_is_inclusive;
                    boolean upper_is_inclusive;

                    if (in_enumeration)
                      {
                        (*printer)(data, "}");
                        first = FALSE;
                      }
                    in_enumeration = FALSE;
                    if (!first)
                        (*printer)(data, " | ");
                    first = FALSE;

                    lower_is_inclusive =
                            components[component_num].lower_is_inclusive;
                    upper_is_inclusive =
                            components[component_num].upper_is_inclusive;

                    if (oi_kind(rational_numerator(lower_bound)) ==
                        IIK_NEGATIVE_INFINITY)
                      {
                        if (!includes_negative_infinity)
                            lower_is_inclusive = FALSE;
                      }
                    if (lower_is_inclusive)
                        (*printer)(data, "[");
                    else
                        (*printer)(data, "(");

                    print_rational(lower_bound, printer, data);
                    (*printer)(data, "....");
                    print_rational(upper_bound, printer, data);

                    if (oi_kind(rational_numerator(upper_bound)) ==
                        IIK_POSITIVE_INFINITY)
                      {
                        if (!includes_positive_infinity)
                            upper_is_inclusive = FALSE;
                        includes_positive_infinity = FALSE;
                      }
                    if (upper_is_inclusive)
                        (*printer)(data, "]");
                    else
                        (*printer)(data, ")");
                  }
              }

            if (includes_positive_infinity)
              {
                if (in_enumeration)
                  {
                    (*printer)(data, ", ");
                  }
                else
                  {
                    if (!first)
                        (*printer)(data, " | ");
                    (*printer)(data, "{");
                    in_enumeration = TRUE;
                  }

                print_oi(oi_positive_infinity, printer, data);
              }

            if (includes_unsigned_infinity)
              {
                if (in_enumeration)
                  {
                    (*printer)(data, ", ");
                  }
                else
                  {
                    if (!first)
                        (*printer)(data, " | ");
                    (*printer)(data, "{");
                    in_enumeration = TRUE;
                  }

                print_oi(oi_unsigned_infinity, printer, data);
              }

            if (includes_zero_zero)
              {
                if (in_enumeration)
                  {
                    (*printer)(data, ", ");
                  }
                else
                  {
                    if (!first)
                        (*printer)(data, " | ");
                    (*printer)(data, "{");
                    in_enumeration = TRUE;
                  }

                print_oi(oi_zero_zero, printer, data);
              }

            if (in_enumeration)
                (*printer)(data, "}");

            if (use_parens)
                (*printer)(data, ")");

            break;
          }
        case TK_POINTER:
          {
            if (precedence > TEPP_POINTER)
                (*printer)(data, "(");
            if (the_type->u.pointer.read_allowed)
                (*printer)(data, "*");
            if (the_type->u.pointer.write_allowed)
                (*printer)(data, "+");
            if (the_type->u.pointer.null_allowed)
                (*printer)(data, ".");
            print_type_with_override(the_type->u.pointer.base, printer, data,
                                     override, TEPP_POINTER);
            if (precedence > TEPP_POINTER)
                (*printer)(data, ")");
            break;
          }
        case TK_TYPE:
          {
            if (precedence > TEPP_TYPE)
                (*printer)(data, "(");
            (*printer)(data, "type ");
            print_type_with_override(the_type->u.type.base, printer, data,
                                     override, TEPP_TYPE);
            if (precedence > TEPP_TYPE)
                (*printer)(data, ")");
            break;
          }
        case TK_MAP:
          {
            if (precedence > TEPP_MAP)
                (*printer)(data, "(");
            print_type_with_override(the_type->u.map.key, printer, data,
                                     override, TEPP_MAP);
            (*printer)(data, " --> ");
            print_type_with_override(the_type->u.map.target, printer, data,
                                     override, TEPP_MAP + 1);
            if (precedence > TEPP_MAP)
                (*printer)(data, ")");
            break;
          }
        case TK_ROUTINE:
          {
            size_t argument_count;
            type **argument_types;
            char **argument_names;
            boolean *argument_has_defaults;
            size_t argument_num;

            argument_count = the_type->u.routine.argument_count;
            argument_types = the_type->u.routine.argument_types;
            argument_names = the_type->u.routine.argument_names;
            argument_has_defaults = the_type->u.routine.argument_has_defaults;

            if (precedence > TEPP_ROUTINE)
                (*printer)(data, "(");
            print_type_with_override(the_type->u.routine.return_type, printer,
                                     data, override, TEPP_ROUTINE);
            (*printer)(data, " <-- (");

            for (argument_num = 0; argument_num < argument_count;
                 ++argument_num)
              {
                assert(argument_types != NULL);
                assert(argument_names != NULL);
                assert(argument_has_defaults != NULL);

                assert(argument_types[argument_num] != NULL);

                if (argument_num > 0)
                    (*printer)(data, ", ");

                if (argument_names[argument_num] != NULL)
                    (*printer)(data, "%s : ", argument_names[argument_num]);

                print_type_with_override(argument_types[argument_num], printer,
                                         data, override, TEPP_TOP);

                if (argument_has_defaults[argument_num])
                    (*printer)(data, " := *");
              }

            if (the_type->u.routine.extra_arguments_allowed)
              {
                assert(!(the_type->u.routine.extra_arguments_unspecified));
                if (argument_count > 0)
                    (*printer)(data, ", ");
                (*printer)(data, "...");
              }
            else if (the_type->u.routine.extra_arguments_unspecified)
              {
                if (argument_count > 0)
                    (*printer)(data, ", ");
                (*printer)(data, "*");
              }

            (*printer)(data, ")");

            if (precedence > TEPP_ROUTINE)
                (*printer)(data, ")");

            break;
          }
        case TK_FIELDS:
          {
            (*printer)(data, "fields");
            print_field_type_info_with_override(
                    &(the_type->u.fields.field_info), NULL, FALSE, printer,
                    data, override);
            break;
          }
        case TK_LEPTON:
          {
            lepton_key_declaration *key_declaration;

            (*printer)(data, "lepton ");

            key_declaration =
                    lepton_key_instance_declaration(the_type->u.lepton.key);
            assert(key_declaration != NULL);

            if (lepton_key_declaration_name(key_declaration) != NULL)
              {
                (*printer)(data, "%s",
                           lepton_key_declaration_name(key_declaration));
              }
            else
              {
                (*printer)(data, "%p", the_type->u.lepton.key);
              }

            print_field_type_info_with_override(
                    &(the_type->u.lepton.field_info), NULL, FALSE, printer,
                    data, override);

            break;
          }
        case TK_MULTISET:
          {
            (*printer)(data, "multiset");
            print_field_type_info_with_override(
                    &(the_type->u.multiset.field_info), NULL, FALSE, printer,
                    data, override);
            break;
          }
        case TK_INTERFACE:
          {
            (*printer)(data, "interface");

            if (the_type->u.interface.null_allowed)
                (*printer)(data, ".");

            print_field_type_info_with_override(
                    &(the_type->u.interface.field_info),
                    the_type->u.interface.item_writing_alloweds, TRUE, printer,
                    data, override);

            break;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t element_count;
            type **element_types;
            char **element_names;
            size_t element_num;

            (*printer)(data, "[");

            element_count = the_type->u.semi_labeled_value_list.element_count;
            element_types = the_type->u.semi_labeled_value_list.element_types;
            element_names = the_type->u.semi_labeled_value_list.element_names;

            for (element_num = 0; element_num < element_count; ++element_num)
              {
                assert(element_types != NULL);
                assert(element_names != NULL);

                assert(element_types[element_num] != NULL);

                if (element_num > 0)
                    (*printer)(data, ", ");

                if (element_names[element_num] != NULL)
                    (*printer)(data, "%s : ", element_names[element_num]);

                print_type_with_override(element_types[element_num], printer,
                                         data, override, TEPP_TOP);
              }

            if (the_type->u.semi_labeled_value_list.extra_elements_allowed)
              {
                if (element_count > 0)
                    (*printer)(data, ", ");
                (*printer)(data, "...");
              }

            (*printer)(data, "]");

            break;
          }
        case TK_REGULAR_EXPRESSION:
          {
            const char *follow;

            (*printer)(data, "@");

            follow = regular_expression_pattern(
                    the_type->u.regular_expression.regular_expression);

            while (*follow != 0)
              {
                if (*follow == '\\')
                    (*printer)(data, "\\\\");
                else if (*follow == '@')
                    (*printer)(data, "\\@");
                else
                    (*printer)(data, "%c", *follow);

                ++follow;
              }

            (*printer)(data, "@");

            break;
          }
        case TK_CLASS:
          {
            routine_declaration *declaration;

            declaration =
                    routine_instance_declaration(the_type->u.class.routine);
            assert(declaration != NULL);

            if (routine_declaration_name(declaration) != NULL)
                (*printer)(data, "%s", routine_declaration_name(declaration));
            else
                (*printer)(data, "class_%p", the_type->u.class.routine);

            break;
          }
        case TK_TEST_ROUTINE:
          {
            routine_declaration *declaration;

            declaration = routine_instance_declaration(
                    the_type->u.test_routine.test_routine);
            assert(declaration != NULL);

            if (routine_declaration_name(declaration) != NULL)
              {
                (*printer)(data, "%s", routine_declaration_name(declaration));
              }
            else
              {
                (*printer)(data, "routine_%p",
                           the_type->u.test_routine.test_routine);
              }

            break;
          }
        case TK_TEST_ROUTINE_CHAIN:
          {
            routine_instance *instance;
            routine_declaration *declaration;

            instance = routine_instance_chain_instance(
                    the_type->u.test_routine_chain.routine_chain);
            assert(instance != NULL);

            declaration = routine_instance_declaration(instance);
            assert(declaration != NULL);

            if (routine_declaration_name(declaration) != NULL)
                (*printer)(data, "%s", routine_declaration_name(declaration));
            else
                (*printer)(data, "routine_%p", instance);

            break;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
          }
        default:
          {
            assert(FALSE);
          }
      }
  }

extern boolean type_is_subset(type *small, type *big, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper)
  {
    boolean equality_doubt;
    boolean are_equal;

    assert(small != NULL);
    assert(big != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(small)); /* VERIFIED */
    assert(type_is_valid(big)); /* VERIFIED */

    if (big->kind == TK_ANYTHING)
      {
        *doubt = FALSE;
        return TRUE;
      }

    if (small->kind == TK_NOTHING)
      {
        *doubt = FALSE;
        return TRUE;
      }

    assert(type_is_valid(small)); /* VERIFIED */
    assert(type_is_valid(big)); /* VERIFIED */
    are_equal =
            types_are_equal(small, big, &equality_doubt, location, the_jumper);
    if (!(jumper_flowing_forward(the_jumper)))
        return FALSE;
    if (are_equal && !equality_doubt)
      {
        *doubt = FALSE;
        return TRUE;
      }

    if (big->kind == TK_NOTHING)
      {
        assert(type_is_valid(small)); /* VERIFIED */
        if (possibly_nothing(small))
          {
            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate super-type is the empty type and %s is "
                    "unable to determine whether the candidate sub-type is "
                    "non-empty", interpreter_name());
          }
        else
          {
            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the candidate super-type is the empty type and the "
                    "candidate sub-type is non-empty");
          }
      }

    if (small->kind == TK_ENUMERATION)
      {
        size_t value_count;
        size_t value_num;

        *doubt = FALSE;

        value_count = small->u.enumeration.value_count;

        for (value_num = 0; value_num < value_count; ++value_num)
          {
            boolean local_doubt;
            char *local_why_not;
            boolean is_in;

            assert(type_is_valid(big)); /* VERIFIED */
            is_in = value_is_in_type(small->u.enumeration.values[value_num],
                    big, &local_doubt,
                    ((why_not == NULL) ? NULL : &local_why_not), location,
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                return FALSE;
              }
            if (local_doubt)
              {
                if (why_not != NULL)
                  {
                    if (!*doubt)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type is an enumeration "
                                "containing the value %U, and %s is unable to "
                                "determine whether that value is in the "
                                "candidate super-type because %s",
                                small->u.enumeration.values[value_num],
                                interpreter_name(), local_why_not);
                      }
                    free(local_why_not);
                    if (*why_not == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                  }
                *doubt = TRUE;
              }
            else if (!is_in)
              {
                boolean result;

                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type is an enumeration containing "
                        "the value %U, which is not in the candidate "
                        "super-type because %s",
                        small->u.enumeration.values[value_num], local_why_not);
                if (why_not != NULL)
                    free(local_why_not);
                return result;
              }
          }

        return TRUE;
      }

    if (small->kind == TK_INTEGER_RANGES)
      {
        size_t component_count;
        integer_range_component *components;
        size_t component_num;

        *doubt = FALSE;

        if (small->u.integer_ranges.includes_positive_infinity)
          {
            boolean do_return;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(oi_positive_infinity, big, doubt, why_not,
                    location, the_jumper, &do_return, "an integer");
            if (do_return)
                return FALSE;
          }

        if (small->u.integer_ranges.includes_negative_infinity)
          {
            boolean do_return;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(oi_negative_infinity, big, doubt, why_not,
                    location, the_jumper, &do_return, "an integer");
            if (do_return)
                return FALSE;
          }

        if (small->u.integer_ranges.includes_unsigned_infinity)
          {
            boolean do_return;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(oi_unsigned_infinity, big, doubt, why_not,
                    location, the_jumper, &do_return, "an integer");
            if (do_return)
                return FALSE;
          }

        if (small->u.integer_ranges.includes_zero_zero)
          {
            boolean do_return;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(oi_zero_zero, big, doubt, why_not, location,
                                  the_jumper, &do_return, "an integer");
            if (do_return)
                return FALSE;
          }

        component_count = small->u.integer_ranges.component_count;
        components = small->u.integer_ranges.components;

        for (component_num = 0; component_num < component_count;
             ++component_num)
          {
            o_integer lower_bound;
            o_integer upper_bound;
            boolean do_return;
            o_integer diff;
            boolean less;

            lower_bound = components[component_num].lower_bound;
            upper_bound = components[component_num].upper_bound;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(lower_bound, big, doubt, why_not, location,
                                  the_jumper, &do_return, "an integer");
            if (do_return)
                return FALSE;

            if (oi_equal(lower_bound, upper_bound))
                continue;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(upper_bound, big, doubt, why_not, location,
                                  the_jumper, &do_return, "an integer");
            if (do_return)
                return FALSE;

            oi_subtract(diff, upper_bound, lower_bound);
            if (oi_out_of_memory(diff))
              {
                jumper_do_abort(the_jumper);
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                return FALSE;
              }

            less = oi_less_than(oi_one, diff);
            oi_remove_reference(diff);
            if (less)
              {
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                break;
              }
          }

        if (component_count == component_num)
            return TRUE;
      }

    if (small->kind == TK_RATIONAL_RANGES)
      {
        size_t component_count;
        rational_range_component *components;
        size_t component_num;

        *doubt = FALSE;

        if (small->u.rational_ranges.includes_positive_infinity)
          {
            boolean do_return;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(oi_positive_infinity, big, doubt, why_not,
                    location, the_jumper, &do_return, "a rational");
            if (do_return)
                return FALSE;
          }

        if (small->u.rational_ranges.includes_negative_infinity)
          {
            boolean do_return;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(oi_negative_infinity, big, doubt, why_not,
                    location, the_jumper, &do_return, "a rational");
            if (do_return)
                return FALSE;
          }

        if (small->u.rational_ranges.includes_unsigned_infinity)
          {
            boolean do_return;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(oi_unsigned_infinity, big, doubt, why_not,
                    location, the_jumper, &do_return, "a rational");
            if (do_return)
                return FALSE;
          }

        if (small->u.rational_ranges.includes_zero_zero)
          {
            boolean do_return;

            assert(type_is_valid(big)); /* VERIFIED */
            check_integer_in_type(oi_zero_zero, big, doubt, why_not, location,
                                  the_jumper, &do_return, "a rational");
            if (do_return)
                return FALSE;
          }

        component_count = small->u.rational_ranges.component_count;
        components = small->u.rational_ranges.components;

        for (component_num = 0; component_num < component_count;
             ++component_num)
          {
            rational *lower_bound;
            rational *upper_bound;
            value *the_value;
            boolean local_doubt;
            char *local_why_not;
            boolean is_in;

            lower_bound = components[component_num].lower_bound;
            upper_bound = components[component_num].upper_bound;

            if (!(rationals_are_equal(lower_bound, upper_bound)))
              {
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                break;
              }

            the_value = create_rational_value(lower_bound);
            if (the_value == NULL)
              {
                jumper_do_abort(the_jumper);
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                return FALSE;
              }

            assert(type_is_valid(big)); /* VERIFIED */
            is_in = value_is_in_type(the_value, big, &local_doubt,
                    ((why_not == NULL) ? NULL : &local_why_not), location,
                    the_jumper);
            value_remove_reference(the_value,
                    ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                return FALSE;
              }
            if (local_doubt)
              {
                if (why_not != NULL)
                  {
                    if (!*doubt)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type is a rational type "
                                "containing the value %Y, and %s is unable to "
                                "determine whether that value is in the "
                                "candidate super-type because %s", lower_bound,
                                interpreter_name(), local_why_not);
                      }
                    free(local_why_not);
                    if (*why_not == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                  }
                *doubt = TRUE;
              }
            else if (!is_in)
              {
                boolean result;

                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type is a rational type containing "
                        "the value %Y, which is not in the candidate "
                        "super-type because %s", lower_bound, local_why_not);
                if (why_not != NULL)
                    free(local_why_not);
                return FALSE;
              }
          }

        if (component_count == component_num)
            return TRUE;
      }

    if ((big->kind == TK_TEST_ROUTINE) && (jumper_thread(the_jumper) != NULL))
      {
        type *wrapped_type;

        assert(type_is_valid(big)); /* VERIFIED */
        wrapped_type = find_wrapped_type(big, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            assert(wrapped_type == NULL);
            return FALSE;
          }

        if (wrapped_type != NULL)
          {
            salmon_thread *my_thread;
            boolean already_held;
            size_t provisional_count;
            size_t provisional_num;
            verdict the_verdict;
            boolean result;
            boolean was_flowing;

            my_thread = jumper_thread(the_jumper);
            if (my_thread == NULL)
              {
                *doubt = TRUE;
                return FALSE;
              }
            assert(my_thread != NULL);

            while (TRUE)
              {
                GRAB_SYSTEM_LOCK(provisional_subset_outer_lock);

                if (provisional_subset_owner == NULL)
                  {
                    already_held = FALSE;
                    provisional_subset_owner = my_thread;
                    GRAB_SYSTEM_LOCK(provisional_subset_inner_lock);
                    break;
                  }

                if (provisional_subset_owner == my_thread)
                  {
                    already_held = TRUE;
                    break;
                  }

                RELEASE_SYSTEM_LOCK(provisional_subset_outer_lock);

                GRAB_SYSTEM_LOCK(provisional_subset_inner_lock);
                RELEASE_SYSTEM_LOCK(provisional_subset_inner_lock);
              }
            RELEASE_SYSTEM_LOCK(provisional_subset_outer_lock);

            provisional_count =
                    big->u.test_routine.provisional_subsets.element_count;

            for (provisional_num = 0; provisional_num < provisional_count;
                 ++provisional_num)
              {
                if (big->u.test_routine.provisional_subsets.array[
                            provisional_num] == small)
                  {
                    type_remove_reference(wrapped_type, the_jumper);
                    *doubt = FALSE;
                    result = TRUE;
                    goto big_done;
                  }
              }

            the_verdict = type_aa_append(
                    &(big->u.test_routine.provisional_subsets), small);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                jumper_do_abort(the_jumper);
                type_remove_reference(wrapped_type, the_jumper);
                result = FALSE;
                goto big_done;
              }

            check_type_validity(wrapped_type, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(big->u.test_routine.provisional_subsets.element_count ==
                       (provisional_count + 1));
                big->u.test_routine.provisional_subsets.element_count =
                        provisional_count;
                type_remove_reference(wrapped_type, the_jumper);
                result = FALSE;
                goto big_done;
              }

            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(wrapped_type)); /* VERIFIED */
            result = type_is_subset(small, wrapped_type, doubt, why_not,
                                    location, the_jumper);
            was_flowing = jumper_flowing_forward(the_jumper);
            type_remove_reference(wrapped_type, the_jumper);
            if ((why_not != NULL) && was_flowing && ((*doubt) || (!result)) &&
                (!jumper_flowing_forward(the_jumper)))
              {
                free(*why_not);
              }

            assert(big->u.test_routine.provisional_subsets.element_count ==
                   (provisional_count + 1));
            big->u.test_routine.provisional_subsets.element_count =
                    provisional_count;

          big_done:
            assert(provisional_subset_owner == my_thread);
            if (!already_held)
              {
                GRAB_SYSTEM_LOCK(provisional_subset_outer_lock);
                provisional_subset_owner = NULL;
                RELEASE_SYSTEM_LOCK(provisional_subset_inner_lock);
                RELEASE_SYSTEM_LOCK(provisional_subset_outer_lock);
              }
            return result;
          }
      }

    if ((small->kind == TK_TEST_ROUTINE) &&
        (jumper_thread(the_jumper) != NULL))
      {
        type *wrapped_type;

        assert(type_is_valid(small)); /* VERIFIED */
        wrapped_type = find_wrapped_type(small, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            assert(wrapped_type == NULL);
            return FALSE;
          }

        if (wrapped_type != NULL)
          {
            salmon_thread *my_thread;
            boolean already_held;
            size_t provisional_count;
            size_t provisional_num;
            verdict the_verdict;
            boolean result;
            boolean was_flowing;

            my_thread = jumper_thread(the_jumper);
            if (my_thread == NULL)
              {
                *doubt = TRUE;
                return FALSE;
              }
            assert(my_thread != NULL);

            while (TRUE)
              {
                GRAB_SYSTEM_LOCK(provisional_subset_outer_lock);

                if (provisional_subset_owner == NULL)
                  {
                    already_held = FALSE;
                    provisional_subset_owner = my_thread;
                    GRAB_SYSTEM_LOCK(provisional_subset_inner_lock);
                    break;
                  }

                if (provisional_subset_owner == my_thread)
                  {
                    already_held = TRUE;
                    break;
                  }

                RELEASE_SYSTEM_LOCK(provisional_subset_outer_lock);

                GRAB_SYSTEM_LOCK(provisional_subset_inner_lock);
                RELEASE_SYSTEM_LOCK(provisional_subset_inner_lock);
              }
            RELEASE_SYSTEM_LOCK(provisional_subset_outer_lock);

            provisional_count =
                    small->u.test_routine.provisional_supersets.element_count;

            for (provisional_num = 0; provisional_num < provisional_count;
                 ++provisional_num)
              {
                if (small->u.test_routine.provisional_supersets.array[
                            provisional_num] == big)
                  {
                    type_remove_reference(wrapped_type, the_jumper);
                    *doubt = FALSE;
                    result = TRUE;
                    goto small_done;
                  }
              }

            the_verdict = type_aa_append(
                    &(small->u.test_routine.provisional_supersets), big);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                jumper_do_abort(the_jumper);
                type_remove_reference(wrapped_type, the_jumper);
                result = FALSE;
                goto small_done;
              }

            check_type_validity(wrapped_type, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(small->u.test_routine.provisional_supersets.
                               element_count == (provisional_count + 1));
                small->u.test_routine.provisional_supersets.element_count =
                        provisional_count;
                type_remove_reference(wrapped_type, the_jumper);
                result = FALSE;
                goto small_done;
              }

            assert(type_is_valid(big)); /* VERIFIED */
            assert(type_is_valid(wrapped_type)); /* VERIFIED */
            result = type_is_subset(wrapped_type, big, doubt, why_not,
                                    location, the_jumper);
            was_flowing = jumper_flowing_forward(the_jumper);
            type_remove_reference(wrapped_type, the_jumper);
            if ((why_not != NULL) && was_flowing && ((*doubt) || (!result)) &&
                (!jumper_flowing_forward(the_jumper)))
              {
                free(*why_not);
              }

            assert(small->u.test_routine.provisional_supersets.element_count ==
                   (provisional_count + 1));
            small->u.test_routine.provisional_supersets.element_count =
                    provisional_count;

          small_done:
            assert(provisional_subset_owner == my_thread);
            if (!already_held)
              {
                GRAB_SYSTEM_LOCK(provisional_subset_outer_lock);
                provisional_subset_owner = NULL;
                RELEASE_SYSTEM_LOCK(provisional_subset_inner_lock);
                RELEASE_SYSTEM_LOCK(provisional_subset_outer_lock);
              }
            return result;
          }
      }

    if (small->kind == big->kind)
      {
        switch (small->kind)
          {
            case TK_ANYTHING:
            case TK_NOTHING:
            case TK_INTEGER:
            case TK_RATIONAL:
            case TK_ANY_REGULAR_EXPRESSION:
            case TK_ANY_QUARK:
            case TK_ANY_LEPTON:
            case TK_LEPTON_KEY:
            case TK_JUMP_TARGET:
            case TK_ANY_CLASS:
            case TK_OBJECT:
            case TK_TAGALONG_KEY:
            case TK_LOCK:
            case TK_STRING:
            case TK_CHARACTER:
            case TK_ENUMERATION:
              {
                assert(FALSE);
                return FALSE;
              }
            case TK_NOT:
              {
                char *local_why_not;
                boolean result;

                assert(type_is_valid(big->u.not.base)); /* VERIFIED */
                assert(type_is_valid(small->u.not.base)); /* VERIFIED */
                result = type_is_subset(big->u.not.base, small->u.not.base,
                        doubt, ((why_not == NULL) ? NULL : &local_why_not),
                        location, the_jumper);
                if (jumper_flowing_forward(the_jumper) && (why_not != NULL))
                  {
                    if (*doubt)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type and the candidate "
                                "super-type are both negation types and %s is "
                                "unable to determine whether the base type of "
                                "the later is a sub-type of the base type of "
                                "the former because %s", interpreter_name(),
                                local_why_not);
                        free(local_why_not);
                        if (*why_not == NULL)
                            jumper_do_abort(the_jumper);
                      }
                    else if (!result)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type and the candidate "
                                "super-type are both negation types and the "
                                "base type of the later is not a sub-type of "
                                "the base type of the former because %s",
                                local_why_not);
                        free(local_why_not);
                        if (*why_not == NULL)
                            jumper_do_abort(the_jumper);
                      }
                  }
                return result;
              }
            case TK_INTERSECTION:
              {
                boolean left_is_subset;
                boolean left_doubt;
                boolean right_is_subset;
                boolean right_doubt;

                left_is_subset = type_is_subset(small->u.intersection.left,
                        big->u.intersection.left, &left_doubt, NULL, location,
                        the_jumper);

                right_is_subset = type_is_subset(small->u.intersection.right,
                        big->u.intersection.right, &right_doubt, NULL,
                        location, the_jumper);

                if ((!left_doubt) && (!right_doubt) && left_is_subset &&
                    right_is_subset)
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }

                break;
              }
            case TK_UNION:
              {
                goto small_union;
              }
            case TK_XOR:
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type and the candidate super-type "
                        "are both exclusive-or types and %s doesn't try to dig"
                        " deeper in such situations", interpreter_name());
              }
            case TK_ARRAY:
              {
                boolean base_doubt;
                char *base_why_not;
                boolean base_sub;
                int lower_order;
                int upper_order;

                assert(type_is_valid(small->u.array.base)); /* VERIFIED */
                assert(type_is_valid(big->u.array.base)); /* VERIFIED */
                base_sub = type_is_subset(small->u.array.base,
                        big->u.array.base, &base_doubt,
                        ((why_not == NULL) ? NULL : &base_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if ((!base_doubt) && !base_sub)
                  {
                    boolean result;

                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both array types and the base of "
                            "the former is not a sub-set of the base of the "
                            "later because %s", base_why_not);
                    if (why_not != NULL)
                        free(base_why_not);
                    return result;
                  }

                lower_order = oi_structural_order(small->u.array.lower_bound,
                                                  big->u.array.lower_bound);
                if (lower_order == -2)
                  {
                    jumper_do_abort(the_jumper);
                    if ((why_not != NULL) && base_doubt)
                        free(base_why_not);
                    return FALSE;
                  }

                upper_order = oi_structural_order(small->u.array.upper_bound,
                                                  big->u.array.upper_bound);
                if (upper_order == -2)
                  {
                    jumper_do_abort(the_jumper);
                    if ((why_not != NULL) && base_doubt)
                        free(base_why_not);
                    return FALSE;
                  }

                if ((lower_order < 0) || (upper_order > 0))
                  {
                    boolean result;

                    if ((why_not != NULL) && base_doubt)
                        free(base_why_not);
                    assert(type_is_valid(small->u.array.base)); /* VERIFIED */
                    if (!(possibly_nothing(small->u.array.base)))
                      {
                        result = type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both array types and the %s "
                                "bound of the former is %s than the %s bound "
                                "of the later, while the base of the former is"
                                " non-empty",
                                ((lower_order < 0) ? "lower" : "upper"),
                                ((lower_order < 0) ? "less" : "greater"),
                                ((lower_order < 0) ? "lower" : "upper"));
                      }
                    else
                      {
                        result = type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both array types and the %s "
                                "bound of the former is %s than the %s bound "
                                "of the later, while %s is unable to determine"
                                " whether the base of the former is non-empty",
                                ((lower_order < 0) ? "lower" : "upper"),
                                ((lower_order < 0) ? "less" : "greater"),
                                ((lower_order < 0) ? "lower" : "upper"),
                                interpreter_name());
                      }
                    return result;
                  }

                if ((why_not != NULL) && base_doubt)
                  {
                    *why_not = allocate_printf(
                            "the candidate sub-type and the candidate "
                            "super-type are both array types and %s is unable "
                            "to determine whether the base of the former is a "
                            "sub-set of the base of the later because %s",
                            interpreter_name(), base_why_not);
                    free(base_why_not);
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
                *doubt = base_doubt;
                return TRUE;
              }
            case TK_INTEGER_RANGES:
              {
                o_integer missing;
                boolean result;

                if (small->u.integer_ranges.includes_positive_infinity &&
                    !(big->u.integer_ranges.includes_positive_infinity))
                  {
                    missing = oi_positive_infinity;
                    oi_add_reference(missing);
                  }
                else if (small->u.integer_ranges.includes_negative_infinity &&
                         !(big->u.integer_ranges.includes_negative_infinity))
                  {
                    missing = oi_negative_infinity;
                    oi_add_reference(missing);
                  }
                else if (small->u.integer_ranges.includes_unsigned_infinity &&
                         !(big->u.integer_ranges.includes_unsigned_infinity))
                  {
                    missing = oi_unsigned_infinity;
                    oi_add_reference(missing);
                  }
                else if (small->u.integer_ranges.includes_zero_zero &&
                         !(big->u.integer_ranges.includes_zero_zero))
                  {
                    missing = oi_zero_zero;
                    oi_add_reference(missing);
                  }
                else
                  {
                    size_t small_component_count;
                    size_t big_component_count;
                    integer_range_component *small_components;
                    integer_range_component *big_components;
                    size_t big_component_num;
                    size_t small_component_num;

                    small_component_count =
                            small->u.integer_ranges.component_count;
                    big_component_count =
                            big->u.integer_ranges.component_count;
                    small_components = small->u.integer_ranges.components;
                    big_components = big->u.integer_ranges.components;

                    big_component_num = 0;
                    for (small_component_num = 0; TRUE; ++small_component_num)
                      {
                        integer_range_component *this_small_component;
                        o_integer big_upper;

                        if (small_component_num >= small_component_count)
                          {
                            *doubt = FALSE;
                            return TRUE;
                          }

                        this_small_component =
                                &(small_components[small_component_num]);
                        missing = this_small_component->lower_bound;

                        while ((big_component_num < big_component_count) &&
                               oi_less_than(
                                       big_components[big_component_num].
                                               upper_bound, missing))
                          {
                            ++big_component_num;
                          }

                        if (big_component_num >= big_component_count)
                          {
                            oi_add_reference(missing);
                            break;
                          }

                        if (oi_less_than(missing,
                                    big_components[big_component_num].
                                            lower_bound))
                          {
                            oi_add_reference(missing);
                            break;
                          }

                        big_upper =
                                big_components[big_component_num].upper_bound;
                        if (oi_less_than(big_upper,
                                         this_small_component->upper_bound))
                          {
                            oi_add(missing, big_upper, oi_one);
                            if (oi_out_of_memory(missing))
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                            break;
                          }
                      }
                  }

                result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type and the candidate super-type "
                        "are both integer types and the former includes %I "
                        "while the later does not", missing);
                oi_remove_reference(missing);
                return result;
              }
            case TK_RATIONAL_RANGES:
              {
                o_integer missing_integer;
                rational *missing_rational;
                boolean result;

                if (small->u.rational_ranges.includes_positive_infinity &&
                    !(big->u.rational_ranges.includes_positive_infinity))
                  {
                    missing_integer = oi_positive_infinity;
                    missing_rational = NULL;
                  }
                else if (small->u.rational_ranges.includes_negative_infinity &&
                         !(big->u.rational_ranges.includes_negative_infinity))
                  {
                    missing_integer = oi_negative_infinity;
                    missing_rational = NULL;
                  }
                else if (small->u.rational_ranges.includes_unsigned_infinity &&
                         !(big->u.rational_ranges.includes_unsigned_infinity))
                  {
                    missing_integer = oi_unsigned_infinity;
                    missing_rational = NULL;
                  }
                else if (small->u.rational_ranges.includes_zero_zero &&
                         !(big->u.rational_ranges.includes_zero_zero))
                  {
                    missing_integer = oi_zero_zero;
                    missing_rational = NULL;
                  }
                else
                  {
                    size_t small_component_count;
                    size_t big_component_count;
                    rational_range_component *small_components;
                    rational_range_component *big_components;
                    size_t big_component_num;
                    size_t small_component_num;

                    missing_integer = oi_null;

                    small_component_count =
                            small->u.rational_ranges.component_count;
                    big_component_count =
                            big->u.rational_ranges.component_count;
                    small_components = small->u.rational_ranges.components;
                    big_components = big->u.rational_ranges.components;

                    big_component_num = 0;
                    for (small_component_num = 0; TRUE; ++small_component_num)
                      {
                        rational_range_component *this_small_component;
                        rational *small_lower;
                        rational_range_component *this_big_component;
                        rational *big_lower;
                        boolean error;
                        boolean miss;
                        rational *big_upper;
                        rational *small_upper;

                        if (small_component_num >= small_component_count)
                          {
                            *doubt = FALSE;
                            return TRUE;
                          }

                        this_small_component =
                                &(small_components[small_component_num]);
                        small_lower = this_small_component->lower_bound;

                        while (big_component_num < big_component_count)
                          {
                            boolean error;
                            boolean too_low;

                            this_big_component =
                                    &(big_components[big_component_num]);
                            if (this_small_component->lower_is_inclusive &&
                                this_big_component->upper_is_inclusive)
                              {
                                too_low = rational_less_than(
                                        this_big_component->upper_bound,
                                        small_lower, &error);
                              }
                            else
                              {
                                too_low = !(rational_less_than(small_lower,
                                        this_big_component->upper_bound,
                                        &error));
                              }
                            if (error)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                            if (!too_low)
                                break;
                            ++big_component_num;
                          }

                        if (big_component_num >= big_component_count)
                          {
                            missing_rational = small_lower;
                            rational_add_reference(missing_rational);
                            break;
                          }

                        big_lower = this_big_component->lower_bound;
                        if (this_small_component->lower_is_inclusive &&
                            !(this_big_component->lower_is_inclusive))
                          {
                            miss = !(rational_less_than(big_lower, small_lower,
                                                        &error));
                          }
                        else
                          {
                            miss = rational_less_than(small_lower, big_lower,
                                                      &error);
                          }
                        if (error)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        if (miss)
                          {
                            if (oi_kind(rational_numerator(small_lower)) ==
                                IIK_FINITE)
                              {
                                rational *sum;
                                o_integer integer_two;
                                rational *rational_two;

                                sum = rational_add(small_lower, big_lower);
                                if (sum == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }

                                oi_create_from_size_t(integer_two, 2);
                                if (oi_out_of_memory(integer_two))
                                  {
                                    rational_remove_reference(sum);
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }

                                rational_two =
                                        create_rational(integer_two, oi_one);
                                oi_remove_reference(integer_two);
                                if (rational_two == NULL)
                                  {
                                    rational_remove_reference(sum);
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }

                                missing_rational =
                                        rational_divide(sum, rational_two);
                                rational_remove_reference(sum);
                                rational_remove_reference(rational_two);
                                if (missing_rational == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }
                              }
                            else
                              {
                                rational *rational_one;

                                rational_one = create_rational(oi_one, oi_one);
                                if (rational_one == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }

                                missing_rational = rational_subtract(big_lower,
                                        rational_one);
                                rational_remove_reference(rational_one);
                                if (missing_rational == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }
                              }

                            break;
                          }

                        big_upper = this_big_component->upper_bound;
                        small_upper = this_small_component->upper_bound;
                        if (this_small_component->upper_is_inclusive &&
                            !(this_big_component->upper_is_inclusive))
                          {
                            miss = !(rational_less_than(small_upper, big_upper,
                                                        &error));
                          }
                        else
                          {
                            miss = rational_less_than(big_upper, small_upper,
                                                      &error);
                          }
                        if (error)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        if (miss)
                          {
                            if (oi_kind(rational_numerator(small_upper)) ==
                                IIK_FINITE)
                              {
                                rational *sum;
                                o_integer integer_two;
                                rational *rational_two;

                                sum = rational_add(small_upper, big_upper);
                                if (sum == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }

                                oi_create_from_size_t(integer_two, 2);
                                if (oi_out_of_memory(integer_two))
                                  {
                                    jumper_do_abort(the_jumper);
                                    rational_remove_reference(sum);
                                    return FALSE;
                                  }

                                rational_two =
                                        create_rational(integer_two, oi_one);
                                oi_remove_reference(integer_two);
                                if (rational_two == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    rational_remove_reference(sum);
                                    return FALSE;
                                  }

                                missing_rational =
                                        rational_divide(sum, rational_two);
                                rational_remove_reference(sum);
                                rational_remove_reference(rational_two);
                                if (missing_rational == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }
                              }
                            else
                              {
                                rational *rational_one;

                                rational_one = create_rational(oi_one, oi_one);
                                if (rational_one == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }

                                missing_rational =
                                        rational_add(big_upper, rational_one);
                                rational_remove_reference(rational_one);
                                if (missing_rational == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }
                              }

                            break;
                          }
                      }
                  }

                if (!(oi_out_of_memory(missing_integer)))
                  {
                    assert(missing_rational == NULL);
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both rational types and the former"
                            " includes %I while the later does not",
                            missing_integer);
                  }
                else
                  {
                    assert(missing_rational != NULL);
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both rational types and the former"
                            " includes %Y while the later does not",
                            missing_rational);
                    rational_remove_reference(missing_rational);
                  }
                return result;
              }
            case TK_POINTER:
              {
                boolean base_result;

                if (small->u.pointer.null_allowed &&
                    !(big->u.pointer.null_allowed))
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both pointer types and the former "
                            "allows null while the later does not");
                  }

                assert(type_is_valid(small->u.pointer.base)); /* VERIFIED */
                assert(type_is_valid(big->u.pointer.base)); /* VERIFIED */
                if (big->u.pointer.read_allowed)
                  {
                    if (!(small->u.pointer.read_allowed))
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both pointer types and the "
                                "later requires reading be allowed while the "
                                "former does not");
                      }

                    if (big->u.pointer.write_allowed &&
                        (big->u.pointer.base->kind != TK_NOTHING))
                      {
                        if (!(small->u.pointer.write_allowed))
                          {
                            assert(type_is_valid(big->u.pointer.base));
                                    /* VERIFIED */
                            if (possibly_nothing(big->u.pointer.base))
                              {
                                return type_in_doubt(doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types and the later requires writing"
                                        " be allowed while the former does "
                                        "not, and %s is unable to determine "
                                        "whether the base type of the later "
                                        "might be the empty type",
                                        interpreter_name());
                              }
                            else
                              {
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types and the later requires writing"
                                        " be allowed while the former does "
                                        "not, and the base type of the later "
                                        "is non-empty");
                              }
                          }

                        assert(type_is_valid(small->u.pointer.base));
                                /* VERIFIED */
                        assert(type_is_valid(big->u.pointer.base));
                                /* VERIFIED */
                        base_result = types_are_equal(small->u.pointer.base,
                                big->u.pointer.base, doubt, location,
                                the_jumper);
                        if ((why_not != NULL) &&
                            jumper_flowing_forward(the_jumper) &&
                            (*doubt || !base_result))
                          {
                            if (*doubt)
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types that require both reading and "
                                        "writing be allowed and %s is unable "
                                        "to determine whether the base type of"
                                        " the former is equal to the base type"
                                        " of the later", interpreter_name());
                              }
                            else
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types that require both reading and "
                                        "writing be allowed and the base type "
                                        "of the former is not equal to the "
                                        "base type of the later");
                              }
                            if (*why_not == NULL)
                                jumper_do_abort(the_jumper);
                          }
                      }
                    else
                      {
                        char *base_why_not;

                        assert(type_is_valid(small->u.pointer.base));
                                /* VERIFIED */
                        assert(type_is_valid(big->u.pointer.base));
                                /* VERIFIED */
                        base_result = type_is_subset(small->u.pointer.base,
                                big->u.pointer.base, doubt,
                                ((why_not == NULL) ? NULL : &base_why_not),
                                location, the_jumper);
                        if ((why_not != NULL) &&
                            jumper_flowing_forward(the_jumper) &&
                            (*doubt || !base_result))
                          {
                            if (*doubt)
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types that require reading be "
                                        "allowed and %s is unable to determine"
                                        " whether the base type of the former "
                                        "is a sub-type of the base type of the"
                                        " later because %s",
                                        interpreter_name(), base_why_not);
                              }
                            else
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types that require reading be "
                                        "allowed and the base type of the "
                                        "former is not a sub-type of the base "
                                        "type of the later because %s",
                                        base_why_not);
                              }
                            free(base_why_not);
                            if (*why_not == NULL)
                                jumper_do_abort(the_jumper);
                          }
                      }
                  }
                else
                  {
                    if (big->u.pointer.write_allowed &&
                        (big->u.pointer.base->kind != TK_NOTHING))
                      {
                        char *base_why_not;

                        if (!(small->u.pointer.write_allowed))
                          {
                            assert(type_is_valid(big->u.pointer.base));
                                    /* VERIFIED */
                            if (possibly_nothing(big->u.pointer.base))
                              {
                                return type_in_doubt(doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types and the later requires writing"
                                        " be allowed while the former does "
                                        "not, and %s is unable to determine "
                                        "whether the base of the later is the "
                                        "empty type", interpreter_name());
                              }
                            else
                              {
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types and the later requires writing"
                                        " be allowed while the former does "
                                        "not, and the base of the later is not"
                                        " the empty type");
                              }
                          }

                        assert(type_is_valid(big->u.pointer.base));
                                /* VERIFIED */
                        assert(type_is_valid(small->u.pointer.base));
                                /* VERIFIED */
                        base_result = type_is_subset(big->u.pointer.base,
                                small->u.pointer.base, doubt,
                                ((why_not == NULL) ? NULL : &base_why_not),
                                location, the_jumper);
                        if ((why_not != NULL) &&
                            jumper_flowing_forward(the_jumper) &&
                            (*doubt || !base_result))
                          {
                            if (*doubt)
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types that require writing be "
                                        "allowed and %s is unable to determine"
                                        " whether the base type of the later "
                                        "is a sub-type of the base type of the"
                                        " former because %s",
                                        interpreter_name(), base_why_not);
                              }
                            else
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both pointer"
                                        " types that require writing be "
                                        "allowed and the base type of the "
                                        "later is not a sub-type of the base "
                                        "type of the former because %s",
                                        base_why_not);
                              }
                            free(base_why_not);
                            if (*why_not == NULL)
                                jumper_do_abort(the_jumper);
                          }
                      }
                    else
                      {
                        *doubt = FALSE;
                        return TRUE;
                      }
                  }
                return base_result;
              }
            case TK_TYPE:
              {
                char *base_why_not;
                boolean base_result;

                assert(type_is_valid(small->u.type.base)); /* VERIFIED */
                assert(type_is_valid(big->u.type.base)); /* VERIFIED */
                base_result = type_is_subset(small->u.type.base,
                        big->u.type.base, doubt,
                        ((why_not == NULL) ? NULL : &base_why_not), location,
                        the_jumper);
                if ((why_not != NULL) && jumper_flowing_forward(the_jumper) &&
                    (*doubt || !base_result))
                  {
                    if (*doubt)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type and the candidate "
                                "super-type are both type types and %s is "
                                "unable to determine whether the base type of "
                                "the former is a sub-type of the base type of "
                                "the later because %s", interpreter_name(),
                                base_why_not);
                      }
                    else
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type and the candidate "
                                "super-type are both type types and the base "
                                "type of the former is not a sub-type of the "
                                "base type of the later because %s",
                                base_why_not);
                      }
                    free(base_why_not);
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
                return base_result;
              }
            case TK_MAP:
              {
                boolean key_doubt;
                char *key_why_not;
                boolean key_subset;
                boolean target_doubt;
                char *target_why_not;
                boolean target_subset;

                if (small->u.map.target->kind == TK_NOTHING)
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }

                if (small->u.map.key->kind == TK_NOTHING)
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }

                assert(type_is_valid(small->u.map.key)); /* VERIFIED */
                assert(type_is_valid(big->u.map.key)); /* VERIFIED */
                key_subset = type_is_subset(small->u.map.key, big->u.map.key,
                        &key_doubt, ((why_not == NULL) ? NULL : &key_why_not),
                        location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if ((!key_doubt) && (!key_subset))
                  {
                    boolean result;

                    assert(type_is_valid(small->u.map.target)); /* VERIFIED */
                    if (possibly_nothing(small->u.map.target))
                      {
                        result = type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both map types, %s is unable "
                                "to determine whether the target of the former"
                                " is the empty type, and the key type of the "
                                "former is not a sub-type of the key type of "
                                "the later because %s", interpreter_name(),
                                key_why_not);
                      }
                    else
                      {
                        result = type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both map types, the target of "
                                "the former is not the empty type, and the key"
                                " type of the former is not a sub-type of the "
                                "key type of the later because %s",
                                key_why_not);
                      }
                    if (why_not != NULL)
                        free(key_why_not);
                    return result;
                  }

                assert(type_is_valid(small->u.map.target)); /* VERIFIED */
                assert(type_is_valid(big->u.map.target)); /* VERIFIED */
                target_subset = type_is_subset(small->u.map.target,
                        big->u.map.target, &target_doubt,
                        ((why_not == NULL) ? NULL : &target_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if ((why_not != NULL) && key_doubt)
                        free(key_why_not);
                    return FALSE;
                  }
                if ((!target_doubt) && (!target_subset))
                  {
                    boolean result;

                    if ((why_not != NULL) && key_doubt)
                        free(key_why_not);
                    assert(type_is_valid(small->u.map.key)); /* VERIFIED */
                    if (possibly_nothing(small->u.map.key))
                      {
                        result = type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both map types, %s is unable "
                                "to determine whether the key of the former is"
                                " the empty type, and the target type of the "
                                "former is not a sub-type of the target type "
                                "of the later because %s", interpreter_name(),
                                target_why_not);
                      }
                    else
                      {
                        result = type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both map types, the key of the"
                                " former is not the empty type, and the target"
                                " type of the former is not a sub-type of the "
                                "target type of the later because %s",
                                target_why_not);
                      }
                    if (why_not != NULL)
                        free(target_why_not);
                    return result;
                  }

                *doubt = (key_doubt || target_doubt);
                if (why_not != NULL)
                  {
                    if (key_doubt)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type and the candidate "
                                "super-type are both map types and %s is "
                                "unable to determine whether the key type of "
                                "the former is a sub-type of the key type of "
                                "the later because %s", interpreter_name(),
                                key_why_not);
                      }
                    else if (target_doubt)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type and the candidate "
                                "super-type are both map types and %s is "
                                "unable to determine whether the target type "
                                "of the former is a sub-type of the target "
                                "type of the later because %s",
                                interpreter_name(), target_why_not);
                      }
                    if (key_doubt)
                        free(key_why_not);
                    if (target_doubt)
                        free(target_why_not);
                    if ((*doubt) && (*why_not == NULL))
                        jumper_do_abort(the_jumper);
                  }
                return (key_subset && target_subset);
              }
            case TK_ROUTINE:
              {
                char *return_why_not;
                boolean return_subset;
                size_t small_arg_count;
                size_t big_arg_count;
                size_t max_arg_count;
                size_t arg_num;

                if (small->u.routine.extra_arguments_allowed &&
                    (!(big->u.routine.extra_arguments_allowed)) &&
                    (!(big->u.routine.extra_arguments_unspecified)))
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    if (possibly_nothing(small))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former requires that extra arguments be "
                                "allowed while the later does not allow extra "
                                "arguments, and %s is unable to determine "
                                "whether the former is the empty type",
                                interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former is not the empty type and requires "
                                "that extra arguments be allowed while the "
                                "later does not allow extra arguments");
                      }
                  }

                if (big->u.routine.extra_arguments_allowed &&
                    (!(small->u.routine.extra_arguments_allowed)) &&
                    (!(small->u.routine.extra_arguments_unspecified)))
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    if (possibly_nothing(small))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "later requires extra arguments be allowed "
                                "while the former does not allow extra "
                                "arguments, and %s is unable to determine "
                                "whether the former is the empty type",
                                interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former is not the empty type and the later "
                                "requires that extra arguments be allowed "
                                "while the former does not allow extra "
                                "arguments");
                      }
                  }

                if (small->u.routine.extra_arguments_unspecified &&
                    !(big->u.routine.extra_arguments_unspecified))
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    if (possibly_nothing(small))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former leaves extra arguments unspecified "
                                "while the later does not, and %s is unable to"
                                " determine whether the former is the empty "
                                "type", interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former is not the empty type and leaves extra"
                                " arguments unspecified while the later does "
                                "not");
                      }
                  }

                assert(type_is_valid(small->u.routine.return_type));
                        /* VERIFIED */
                assert(type_is_valid(big->u.routine.return_type));
                        /* VERIFIED */
                return_subset = type_is_subset(small->u.routine.return_type,
                        big->u.routine.return_type, doubt,
                        ((why_not == NULL) ? NULL : &return_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return FALSE;
                if (*doubt)
                  {
                    if (why_not != NULL)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and %s is "
                                "unable to determine whether the return type "
                                "of the former is a sub-type of the return "
                                "type of the later because %s",
                                interpreter_name(), return_why_not);
                        free(return_why_not);
                        if (*why_not == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                      }
                  }
                else if (!return_subset)
                  {
                    boolean result;

                    assert(type_is_valid(small)); /* VERIFIED */
                    if (possibly_nothing(small))
                      {
                        result = type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and %s is "
                                "unable to determine whether the former is the"
                                " empty type, and the former has a return type"
                                " that is not a sub-type of the return type of"
                                " the later because %s", interpreter_name(),
                                return_why_not);
                      }
                    else
                      {
                        result = type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former is not the empty type and has a return"
                                " type that is not a sub-type of the return "
                                "type of the later because %s",
                                return_why_not);
                      }
                    if (why_not != NULL)
                        free(return_why_not);
                    return result;
                  }

                small_arg_count = small->u.routine.argument_count;
                big_arg_count = big->u.routine.argument_count;
                max_arg_count = ((small_arg_count > big_arg_count) ?
                                 small_arg_count : big_arg_count);

                if (small_arg_count < big_arg_count)
                  {
                    if ((*doubt) && (why_not != NULL))
                        free(*why_not);
                    assert(type_is_valid(small)); /* VERIFIED */
                    if (possibly_nothing(small))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former allows routines with %lu argument%s "
                                "while the later only allows routines with at "
                                "least %lu argument%s, and %s is unable to "
                                "determine whether the former could be the "
                                "empty type", (unsigned long)small_arg_count,
                                ((small_arg_count == 1) ? "" : "s"),
                                (unsigned long)big_arg_count,
                                ((big_arg_count == 1) ? "" : "s"),
                                interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former is not empty and allows routines with "
                                "%lu argument%s while the later only allows "
                                "routines with at least %lu argument%s",
                                (unsigned long)small_arg_count,
                                ((small_arg_count == 1) ? "" : "s"),
                                (unsigned long)big_arg_count,
                                ((big_arg_count == 1) ? "" : "s"));
                      }
                  }

                if ((big_arg_count < small_arg_count) &&
                    !(big->u.routine.extra_arguments_unspecified))
                  {
                    if ((*doubt) && (why_not != NULL))
                        free(*why_not);
                    assert(type_is_valid(small)); /* VERIFIED */
                    if (possibly_nothing(small))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former allows routines with %lu argument%s "
                                "while the later only allows routines with %lu"
                                " argument%s, and %s is unable to determine "
                                "whether the former could be the empty type",
                                (unsigned long)small_arg_count,
                                ((small_arg_count == 1) ? "" : "s"),
                                (unsigned long)big_arg_count,
                                ((big_arg_count == 1) ? "" : "s"),
                                interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both routine types and the "
                                "former is not empty and allows routines with "
                                "%lu argument%s while the later only allows "
                                "routines with %lu argument%s",
                                (unsigned long)small_arg_count,
                                ((small_arg_count == 1) ? "" : "s"),
                                (unsigned long)big_arg_count,
                                ((big_arg_count == 1) ? "" : "s"));
                      }
                  }

                for (arg_num = 0; arg_num < big_arg_count; ++arg_num)
                  {
                    type *small_arg_type;
                    const char *small_name;
                    type *big_arg_type;
                    const char *big_name;
                    boolean arg_doubt;
                    char *arg_why_not;
                    boolean arg_subset;

                    assert(arg_num < small_arg_count);
                    small_arg_type =
                            small->u.routine.argument_types[arg_num];
                    small_name = small->u.routine.argument_names[arg_num];

                    big_arg_type = big->u.routine.argument_types[arg_num];
                    big_name = big->u.routine.argument_names[arg_num];

                    assert(type_is_valid(big_arg_type)); /* VERIFIED */
                    assert(type_is_valid(small_arg_type)); /* VERIFIED */
                    arg_subset = type_is_subset(big_arg_type, small_arg_type,
                            &arg_doubt,
                            ((why_not == NULL) ? NULL : &arg_why_not),
                            location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if ((*doubt) && (why_not != NULL))
                            free(*why_not);
                        return FALSE;
                      }
                    if (arg_doubt)
                      {
                        if (why_not != NULL)
                          {
                            if (!(*doubt))
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both routine"
                                        " types and %s is unable to determine "
                                        "whether argument type %lu of the "
                                        "former is a sub-type of argument type"
                                        " %lu of the later because %s",
                                        interpreter_name(),
                                        (unsigned long)arg_num,
                                        (unsigned long)arg_num, arg_why_not);
                              }
                            free(arg_why_not);
                            if (*why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                        *doubt = TRUE;
                      }
                    else if (!arg_subset)
                      {
                        boolean result;

                        if ((*doubt) && (why_not != NULL))
                            free(*why_not);
                        assert(type_is_valid(small)); /* VERIFIED */
                        if (possibly_nothing(small))
                          {
                            result = type_in_doubt(doubt, why_not, the_jumper,
                                    "the candidate sub-type and the candidate "
                                    "super-type are both routine types and %s "
                                    "is unable to determine whether the former"
                                    " is the empty type, and argument type %lu"
                                    " of the former is not a sub-type of "
                                    "argument type %lu of the later because "
                                    "%s", interpreter_name(),
                                    (unsigned long)arg_num,
                                    (unsigned long)arg_num, arg_why_not);
                          }
                        else
                          {
                            result = type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the candidate sub-type and the candidate "
                                    "super-type are both routine types and the"
                                    " former is not the empty type and "
                                    "argument type %lu of the former is not a "
                                    "sub-type of argument type %lu of the "
                                    "later because %s", (unsigned long)arg_num,
                                    (unsigned long)arg_num, arg_why_not);
                          }
                        if (why_not != NULL)
                            free(arg_why_not);
                        return result;
                      }

                    if (big_name != NULL)
                      {
                        if (small_name == NULL)
                          {
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            assert(type_is_valid(small)); /* VERIFIED */
                            if (possibly_nothing(small))
                              {
                                return type_in_doubt(doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both routine"
                                        " types and %s is unable to determine "
                                        "whether the former is the empty type,"
                                        " and the former requires no name for "
                                        "argument %lu while the later requires"
                                        " the name `%s' for this argument",
                                        interpreter_name(),
                                        (unsigned long)arg_num, big_name);
                              }
                            else
                              {
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both routine"
                                        " types and the former is not the "
                                        "empty type and the former requires no"
                                        " name for argument %lu while the "
                                        "later requires the name `%s' for this"
                                        " argument", (unsigned long)arg_num,
                                        big_name);
                              }
                          }
                        else
                          {
                            if (strcmp(small_name, big_name) != 0)
                              {
                                if ((*doubt) && (why_not != NULL))
                                    free(*why_not);
                                assert(type_is_valid(small)); /* VERIFIED */
                                if (possibly_nothing(small))
                                  {
                                    return type_in_doubt(doubt, why_not,
                                            the_jumper,
                                            "the candidate sub-type and the "
                                            "candidate super-type are both "
                                            "routine types and %s is unable to"
                                            " determine whether the former is "
                                            "the empty type, and the former "
                                            "requires the name `%s' for "
                                            "argument %lu while the later "
                                            "requires the name `%s' for this "
                                            "argument", interpreter_name(),
                                            small_name, (unsigned long)arg_num,
                                            big_name);
                                  }
                                else
                                  {
                                    return type_in_no_doubt(FALSE, doubt,
                                            why_not, the_jumper,
                                            "the candidate sub-type and the "
                                            "candidate super-type are both "
                                            "routine types and the former is "
                                            "not the empty type and the former"
                                            " requires the name `%s' for "
                                            "argument %lu while the later "
                                            "requires the name `%s' for this "
                                            "argument", small_name,
                                            (unsigned long)arg_num, big_name);
                                  }
                              }
                          }
                      }

                    if (big->u.routine.argument_has_defaults[arg_num] &&
                        !(small->u.routine.argument_has_defaults[arg_num]))
                      {
                        if ((*doubt) && (why_not != NULL))
                            free(*why_not);
                        assert(type_is_valid(small)); /* VERIFIED */
                        if (possibly_nothing(small))
                          {
                            return type_in_doubt(doubt, why_not, the_jumper,
                                    "the candidate sub-type and the candidate "
                                    "super-type are both routine types and %s "
                                    "is unable to determine whether the former"
                                    " is the empty type, and the later "
                                    "requires a default for argument %lu while"
                                    " the former does not",
                                    (unsigned long)arg_num);
                          }
                        else
                          {
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the candidate sub-type and the candidate "
                                    "super-type are both routine types and the"
                                    " former is not the empty type and the "
                                    "later requires a default for argument %lu"
                                    " while the former does not",
                                    (unsigned long)arg_num);
                          }
                      }
                  }

                return TRUE;
              }
            case TK_FIELDS:
              {
                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return unordered_named_field_rules_are_subset(
                        &(small->u.fields.field_info),
                        &(big->u.fields.field_info), doubt, why_not,
                        possibly_nothing(small), location, the_jumper);
              }
            case TK_LEPTON:
              {
                assert(lepton_key_instance_is_instantiated(
                               small->u.lepton.key)); /* VERIFIED */
                assert(lepton_key_instance_is_instantiated(big->u.lepton.key));
                        /* VERIFIED */
                assert(!(lepton_key_instance_scope_exited(
                                 small->u.lepton.key))); /* VERIFIED */
                assert(!(lepton_key_instance_scope_exited(big->u.lepton.key)));
                        /* VERIFIED */

                if (!(lepton_key_instances_are_equal(small->u.lepton.key,
                                                     big->u.lepton.key)))
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    if (possibly_nothing(small))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both lepton types but with "
                                "different keys (%s and %s), and %s is unable "
                                "to determine whether the former is the empty "
                                "type",
                                lepton_key_declaration_name(
                                        lepton_key_instance_declaration(
                                                small->u.lepton.key)),
                                lepton_key_declaration_name(
                                        lepton_key_instance_declaration(
                                                big->u.lepton.key)),
                                interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both lepton types but with "
                                "different keys (%s and %s), and the former is"
                                " not the empty type",
                                lepton_key_declaration_name(
                                        lepton_key_instance_declaration(
                                                small->u.lepton.key)),
                                lepton_key_declaration_name(
                                        lepton_key_instance_declaration(
                                                big->u.lepton.key)));
                      }
                  }

                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return unordered_named_field_rules_are_subset(
                        &(small->u.lepton.field_info),
                        &(big->u.lepton.field_info), doubt, why_not,
                        possibly_nothing(small), location, the_jumper);
              }
            case TK_MULTISET:
              {
                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return unordered_named_field_rules_are_subset(
                        &(small->u.multiset.field_info),
                        &(big->u.multiset.field_info), doubt, why_not,
                        possibly_nothing(small), location, the_jumper);
              }
            case TK_INTERFACE:
              {
                field_type_info *small_field_info;
                field_type_info *big_field_info;
                size_t small_item_count;
                size_t big_item_count;
                size_t small_item_num;
                size_t big_item_num;

                small_field_info = &(small->u.interface.field_info);
                big_field_info = &(big->u.interface.field_info);

                small_item_count = small_field_info->field_count;
                big_item_count = big_field_info->field_count;

                *doubt = FALSE;

                small_item_num = 0;
                big_item_num = 0;
                while (TRUE)
                  {
                    type *small_item_type;
                    const char *small_name;
                    type *big_item_type;
                    const char *big_name;
                    boolean item_doubt;
                    char *item_why_not;
                    boolean item_subset;

                    if (small_item_num >= small_item_count)
                      {
                        if (big_item_num >= big_item_count)
                            break;
                        small_item_type = NULL;
                        small_name = NULL;
                      }
                    else
                      {
                        small_item_type =
                                small_field_info->field_types[small_item_num];
                        assert(small_item_type != NULL);
                        assert(type_is_valid(small_item_type)); /* VERIFIED */
                        small_name =
                                small_field_info->field_names[small_item_num];
                        assert(small_name != NULL);
                      }

                    if (big_item_num >= big_item_count)
                      {
                        assert(small_item_num < small_item_count);
                        big_item_type = NULL;
                        big_name = NULL;
                      }
                    else
                      {
                        big_item_type =
                                big_field_info->field_types[big_item_num];
                        assert(big_item_type != NULL);
                        big_name = big_field_info->field_names[big_item_num];
                        assert(big_name != NULL);
                      }

                    if (small_name == NULL)
                      {
                        ++big_item_num;
                      }
                    else if (big_name == NULL)
                      {
                        ++small_item_num;
                      }
                    else
                      {
                        int name_order;

                        name_order =
                            utf8_string_lexicographical_order_by_code_point(
                                    small_name, big_name);
                        if (name_order == -2)
                          {
                            jumper_do_abort(the_jumper);
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            return FALSE;
                          }
                        else if (name_order < 0)
                          {
                            ++small_item_num;
                            big_item_type = NULL;
                          }
                        else if (name_order > 0)
                          {
                            ++big_item_num;
                            small_item_type = NULL;
                          }
                        else
                          {
                            if (small->u.interface.item_writing_alloweds[
                                        small_item_num] &&
                                !(big->u.interface.item_writing_alloweds[
                                          big_item_num]))
                              {
                                if ((*doubt) && (why_not != NULL))
                                    free(*why_not);
                                assert(type_is_valid(small)); /* VERIFIED */
                                if (possibly_nothing(small))
                                  {
                                    return type_in_doubt(doubt, why_not,
                                            the_jumper,
                                            "the candidate sub-type and the "
                                            "candidate super-type are both "
                                            "interface types and the former "
                                            "allows writing to field `%s' "
                                            "while the later does not and %s "
                                            "is unable to determine whether "
                                            "the former is the empty type",
                                            small_name, interpreter_name());
                                  }
                                else
                                  {
                                    return type_in_no_doubt(FALSE, doubt,
                                            why_not, the_jumper,
                                            "the candidate sub-type and the "
                                            "candidate super-type are both "
                                            "interface types and the former "
                                            "allows writing to field `%s' "
                                            "while the later does not and the "
                                            "former is not the empty type",
                                            small_name);
                                  }
                              }
                            ++small_item_num;
                            ++big_item_num;
                          }
                      }

                    if (small_item_type == NULL)
                      {
                        small_item_type = get_anything_type();
                        if (small_item_type == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            return FALSE;
                          }
                        small_name = big_name;
                        assert(small_name != NULL);
                      }
                    if (big_item_type == NULL)
                        continue;

                    assert(type_is_valid(small_item_type)); /* VERIFIED */
                    assert(type_is_valid(big_item_type)); /* VERIFIED */
                    item_subset = type_is_subset(small_item_type,
                            big_item_type, &item_doubt,
                            ((why_not == NULL) ? NULL : &item_why_not),
                            location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if ((*doubt) && (why_not != NULL))
                            free(*why_not);
                        return FALSE;
                      }
                    if ((!item_doubt) && !item_subset)
                      {
                        boolean result;

                        if ((*doubt) && (why_not != NULL))
                            free(*why_not);
                        assert(type_is_valid(small)); /* VERIFIED */
                        if (possibly_nothing(small))
                          {
                            result = type_in_doubt(doubt, why_not, the_jumper,
                                    "the candidate sub-type and the candidate "
                                    "super-type are both interface types and "
                                    "%s is unable to determine whether the "
                                    "former is the empty type and the type of "
                                    "the former for field `%s' is not a subset"
                                    " of the type of the later for that field "
                                    "because %s", interpreter_name(),
                                    small_name, item_why_not);
                          }
                        else
                          {
                            result = type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the candidate sub-type and the candidate "
                                    "super-type are both interface types and "
                                    "the former is not the empty type and the "
                                    "type of the former for field `%s' is not "
                                    "a subset of the type of the later for "
                                    "that field because %s", small_name,
                                    item_why_not);
                          }
                        if (why_not != NULL)
                            free(item_why_not);
                        return result;
                      }
                    if (item_doubt)
                      {
                        if (why_not != NULL)
                          {
                            if (!(*doubt))
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "interface types and %s is unable to "
                                        "determine whether the type of the "
                                        "former for field `%s' is a subset of "
                                        "the type of the later for that field "
                                        "because %s", interpreter_name(),
                                        small_name, item_why_not);
                              }
                            free(item_why_not);
                            if (*why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                        *doubt = TRUE;
                      }
                  }

                return TRUE;
              }
            case TK_SEMI_LABELED_VALUE_LIST:
              {
                size_t small_element_count;
                size_t big_element_count;
                size_t max_element_count;
                size_t element_num;

                if (small->u.semi_labeled_value_list.extra_elements_allowed &&
                    !(big->u.semi_labeled_value_list.extra_elements_allowed))
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    if (possibly_nothing(small))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both semi-labeled value list "
                                "types and the former allows arbitrary "
                                "additional elements while the later does not "
                                "and %s is unable to determine whether the "
                                "former is the empty type",
                                interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type and the candidate "
                                "super-type are both semi-labeled value list "
                                "types and the former allows arbitrary "
                                "additional elements while the later does not "
                                "and the former is not the empty type");
                      }
                  }

                *doubt = FALSE;

                small_element_count =
                        small->u.semi_labeled_value_list.element_count;
                big_element_count =
                        big->u.semi_labeled_value_list.element_count;
                max_element_count =
                        ((small_element_count > big_element_count) ?
                         small_element_count : big_element_count);

                for (element_num = 0; element_num < max_element_count;
                     ++element_num)
                  {
                    type *small_element_type;
                    const char *small_name;
                    type *big_element_type;
                    const char *big_name;
                    boolean element_doubt;
                    char *element_why_not;
                    boolean element_subset;

                    if (element_num >= small_element_count)
                      {
                        assert(element_num < big_element_count);
                        if (!(small->u.semi_labeled_value_list.
                                      extra_elements_allowed))
                          {
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            assert(type_is_valid(small)); /* VERIFIED */
                            if (possibly_nothing(small))
                              {
                                assert(small_element_count > 0);
                                assert(big_element_count >
                                       small_element_count);
                                assert(big_element_count > 1);
                                return type_in_doubt(doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and the"
                                        " former requires exactly %lu "
                                        "element%s while the later requires %s"
                                        " %lu elements and %s is unable to "
                                        "determine whether the former might be"
                                        " the empty type",
                                        (unsigned long)small_element_count,
                                        ((small_element_count == 1) ? "" :
                                         "s"),
                                        (big->u.semi_labeled_value_list.
                                                 extra_elements_allowed ?
                                         "at least" : "exactly"),
                                        (unsigned long)big_element_count,
                                        interpreter_name());
                              }
                            else
                              {
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and the"
                                        " former requires exactly %lu "
                                        "element%s while the later requires %s"
                                        " %lu element%s and the former is not "
                                        "the empty type",
                                        (unsigned long)small_element_count,
                                        ((small_element_count == 1) ? "" :
                                         "s"),
                                        (big->u.semi_labeled_value_list.
                                                 extra_elements_allowed ?
                                         "at least" : "exactly"),
                                        (unsigned long)big_element_count,
                                        ((big_element_count == 1) ? "" : "s"));
                              }
                          }
                        small_element_type = get_anything_type();
                        if (small_element_type == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            return FALSE;
                          }
                        small_name = NULL;
                      }
                    else
                      {
                        small_element_type = small->u.semi_labeled_value_list.
                                element_types[element_num];
                        small_name = small->u.semi_labeled_value_list.
                                element_names[element_num];
                      }

                    if (element_num >= big_element_count)
                      {
                        assert(element_num < small_element_count);
                        if (!(big->u.semi_labeled_value_list.
                                      extra_elements_allowed))
                          {
                            assert(!(small->u.semi_labeled_value_list.
                                             extra_elements_allowed));
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            assert(type_is_valid(small)); /* VERIFIED */
                            if (possibly_nothing(small))
                              {
                                return type_in_doubt(doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and the"
                                        " later requires exactly %lu element%s"
                                        " while the former requires exactly "
                                        "%lu element%s and %s is unable to "
                                        "determine whether the former might be"
                                        " the empty type",
                                        (unsigned long)big_element_count,
                                        ((big_element_count == 1) ? "" : "s"),
                                        (unsigned long)small_element_count,
                                        ((small_element_count == 1) ? "" :
                                         "s"), interpreter_name());
                              }
                            else
                              {
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and the"
                                        " later requires exactly %lu element%s"
                                        " while the former requires exactly "
                                        "%lu element%s and the former is not "
                                        "the empty type",
                                        (unsigned long)big_element_count,
                                        ((big_element_count == 1) ? "" : "s"),
                                        (unsigned long)small_element_count,
                                        ((small_element_count == 1) ? "" :
                                         "s"));
                              }
                          }
                        big_element_type = get_anything_type();
                        if (big_element_type == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            return FALSE;
                          }
                        big_name = NULL;
                      }
                    else
                      {
                        big_element_type = big->u.semi_labeled_value_list.
                                element_types[element_num];
                        big_name = big->u.semi_labeled_value_list.
                                element_names[element_num];
                      }

                    assert(type_is_valid(small_element_type)); /* VERIFIED */
                    assert(type_is_valid(big_element_type)); /* VERIFIED */
                    element_subset = type_is_subset(small_element_type,
                            big_element_type, &element_doubt,
                            ((why_not == NULL) ? NULL : &element_why_not),
                            location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if ((*doubt) && (why_not != NULL))
                            free(*why_not);
                        return FALSE;
                      }
                    if ((!element_doubt) && !element_subset)
                      {
                        boolean result;

                        if ((*doubt) && (why_not != NULL))
                            free(*why_not);
                        assert(type_is_valid(small)); /* VERIFIED */
                        if (possibly_nothing(small))
                          {
                            result = type_in_doubt(doubt, why_not, the_jumper,
                                    "the candidate sub-type and the candidate "
                                    "super-type are both semi-labeled value "
                                    "list types and %s is unable to determine "
                                    "whether the former is the empty type and "
                                    "the type of the former for element %lu is"
                                    " not a subset of the type of the later "
                                    "for that element because %s",
                                    interpreter_name(),
                                    (unsigned long)element_num,
                                    element_why_not);
                          }
                        else
                          {
                            result = type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the candidate sub-type and the candidate "
                                    "super-type are both semi-labeled value "
                                    "list types and the former is not the "
                                    "empty type and the type of the former for"
                                    " element %lu is not a subset of the type "
                                    "of the later for that element because %s",
                                    (unsigned long)element_num,
                                    element_why_not);
                          }
                        if (why_not != NULL)
                            free(element_why_not);
                        return result;
                      }
                    if (element_doubt)
                      {
                        if (why_not != NULL)
                          {
                            if (!(*doubt))
                              {
                                *why_not = allocate_printf(
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and %s "
                                        "is unable to determine whether the "
                                        "type of the former for element %lu is"
                                        " a subset of the type of the later "
                                        "for that element because %s",
                                        interpreter_name(),
                                        (unsigned long)element_num,
                                        element_why_not);
                              }
                            free(element_why_not);
                            if (*why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                        *doubt = TRUE;
                      }

                    if (small_name == NULL)
                      {
                        if (big_name != NULL)
                          {
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            assert(type_is_valid(small)); /* VERIFIED */
                            if (possibly_nothing(small))
                              {
                                return type_in_doubt(doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and the"
                                        " later specifies a name (`%s') for "
                                        "element %lu while the former does not"
                                        " and %s is unable to determine "
                                        "whether the former might be the empty"
                                        " type", big_name,
                                        (unsigned long)element_num,
                                        interpreter_name());
                              }
                            else
                              {
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and the"
                                        " later specifies a name (`%s') for "
                                        "element %lu while the former does not"
                                        " and the former is not the empty "
                                        "type", big_name,
                                        (unsigned long)element_num);
                              }
                          }
                      }
                    else if (big_name != NULL)
                      {
                        if (strcmp(small_name, big_name) != 0)
                          {
                            if ((*doubt) && (why_not != NULL))
                                free(*why_not);
                            assert(type_is_valid(small)); /* VERIFIED */
                            if (possibly_nothing(small))
                              {
                                return type_in_doubt(doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and the"
                                        " former specifies a name (`%s') for "
                                        "element %lu that is different from "
                                        "the name specified by the later "
                                        "(`%s') for that element and %s is "
                                        "unable to determine whether the "
                                        "former might be the empty type",
                                        small_name, (unsigned long)element_num,
                                        big_name, interpreter_name());
                              }
                            else
                              {
                                return type_in_no_doubt(FALSE, doubt, why_not,
                                        the_jumper,
                                        "the candidate sub-type and the "
                                        "candidate super-type are both "
                                        "semi-labeled value list types and the"
                                        " former specifies a name (`%s') for "
                                        "element %lu that is different from "
                                        "the name specified by the later "
                                        "(`%s') for that element and the "
                                        "former is not the empty type",
                                        small_name, (unsigned long)element_num,
                                        big_name);
                              }
                          }
                      }
                  }

                return TRUE;
              }
            case TK_REGULAR_EXPRESSION:
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type and the candidate super-type "
                        "are both regular expression types and %s doesn't try "
                        "to dig deeper in such situations",
                        interpreter_name());
              }
            case TK_CLASS:
              {
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type and the candidate super-type "
                        "are both class types but for different classes (%t "
                        "and %t)", small, big);
              }
            case TK_TEST_ROUTINE:
            case TK_TEST_ROUTINE_CHAIN:
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type and the candidate super-type "
                        "are both filter function types but with different "
                        "filter functions and %s doesn't try to dig deeper in "
                        "such situations", interpreter_name());
              }
            case TK_SEPARATOR:
              {
                assert(FALSE);
                break;
              }
            default:
              {
                assert(FALSE);
              }
          }
      }

    if (small->kind == TK_ANYTHING)
      {
        assert(type_is_valid(big)); /* VERIFIED */
        if (possibly_everything(big))
          {
            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type is the type containing all values "
                    "and %s is unable to determine whether the candidate "
                    "super-type is the type containing all values",
                    interpreter_name());
          }
        else
          {
            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the candidate sub-type is the type containing all values "
                    "and the candidate super-type does not contain all "
                    "values");
          }
      }

    if (big->kind == TK_UNION)
      {
        boolean result;

        if ((small == big->u.union_type.left) ||
            (small == big->u.union_type.right))
          {
            *doubt = FALSE;
            return TRUE;
          }

        result = type_is_subset(small, big->u.union_type.left, doubt, NULL,
                                location, the_jumper);
        if (result && !(*doubt))
            return TRUE;

        result = type_is_subset(small, big->u.union_type.right, doubt, NULL,
                                location, the_jumper);
        if (result && !(*doubt))
            return TRUE;
      }

    switch (small->kind)
      {
        case TK_NOT:
          {
            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type is a negation type and the "
                    "candidate super-type is not a negation type and %s "
                    "doesn't try to dig deeper in such situations",
                    interpreter_name());
          }
        case TK_INTERSECTION:
          {
            boolean left_doubt;
            char *left_why_not;
            boolean left_is_in;
            boolean right_doubt;
            char *right_why_not;
            boolean right_is_in;
            boolean result;

            assert(type_is_valid(small->u.intersection.left)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            left_is_in = type_is_subset(small->u.intersection.left, big,
                    &left_doubt, ((why_not == NULL) ? NULL : &left_why_not),
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            if ((!left_doubt) && left_is_in)
              {
                *doubt = FALSE;
                return TRUE;
              }

            assert(type_is_valid(small->u.intersection.right)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            right_is_in = type_is_subset(small->u.intersection.right, big,
                    &right_doubt, ((why_not == NULL) ? NULL : &right_why_not),
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if (why_not != NULL)
                    free(left_why_not);
                return FALSE;
              }
            if ((!right_doubt) && right_is_in)
              {
                if (why_not != NULL)
                    free(left_why_not);
                *doubt = FALSE;
                return TRUE;
              }

            result = type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type is an intersection type and %s was"
                    " unable to determine that either component of this "
                    "intersection type was in the candidate super-type (the "
                    "left component %s in the later because %s; and the right "
                    "component %s in the later because %s) and %s doesn't try "
                    "to dig deeper in such situations", interpreter_name(),
                    (left_doubt ? "might not be" : "is not"), left_why_not,
                    (right_doubt ? "might not be" : "is not"), right_why_not,
                    interpreter_name());
            if (why_not != NULL)
                free(left_why_not);
            if (why_not != NULL)
                free(right_why_not);
            return result;
          }
        case TK_UNION:
          {
            boolean left_doubt;
            char *left_why_not;
            boolean left_is_in;
            boolean right_doubt;
            char *right_why_not;
            boolean right_is_in;
            boolean result;

          small_union:
            assert(type_is_valid(small->u.union_type.left)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            left_is_in = type_is_subset(small->u.union_type.left, big,
                    &left_doubt, ((why_not == NULL) ? NULL : &left_why_not),
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            if ((!left_doubt) && (!left_is_in))
              {
                boolean result;

                result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type is a union type and the left "
                        "component of the union is not in the candidate "
                        "super-type because %s", left_why_not);
                if (why_not != NULL)
                    free(left_why_not);
                return result;
              }

            assert(type_is_valid(small->u.union_type.right)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            right_is_in = type_is_subset(small->u.union_type.right, big,
                    &right_doubt, ((why_not == NULL) ? NULL : &right_why_not),
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if ((why_not != NULL) && left_doubt)
                    free(left_why_not);
                return FALSE;
              }
            if ((!right_doubt) && (!right_is_in))
              {
                boolean result;

                if ((why_not != NULL) && left_doubt)
                    free(left_why_not);
                result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type is a union type and the right "
                        "component of the union is not in the candidate "
                        "super-type because %s", right_why_not);
                if (why_not != NULL)
                    free(right_why_not);
                return result;
              }

            *doubt = (left_doubt || right_doubt);
            result = (left_is_in && right_is_in);
            if (*doubt)
              {
                if (why_not != NULL)
                  {
                    *why_not = allocate_printf(
                            "the candidate sub-type is a union type and %s is "
                            "unable to determine whether the %s component of "
                            "the union is in the candidate super-type because "
                            "%s", interpreter_name(),
                            (left_doubt ? "left" : "right"),
                            (left_doubt ? left_why_not : right_why_not));
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
              }
            else
              {
                assert(result == TRUE);
              }
            if ((why_not != NULL) && left_doubt)
                free(left_why_not);
            if ((why_not != NULL) && right_doubt)
                free(right_why_not);
            return result;
          }
        case TK_XOR:
          {
            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type is an exclusive-or type and %s "
                    "doesn't try to dig deeper in such situations",
                    interpreter_name());
          }
        case TK_CLASS:
          {
            type *return_type;

            return_type = routine_instance_return_type(small->u.class.routine);
            if ((return_type != NULL) && type_is_valid(return_type) &&
                (return_type->kind != TK_CLASS))
              {
                boolean result;

                result = type_is_subset(return_type, big, doubt, NULL,
                                        location, the_jumper);
                if (result && !(*doubt))
                    return TRUE;
              }

            break;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type is a filter function type and %s "
                    "doesn't try to dig deeper in such situations",
                    interpreter_name());
          }
        default:
          {
            break;
          }
      }

    switch (big->kind)
      {
        case TK_UNION:
        case TK_NOT:
        case TK_INTERSECTION:
        case TK_XOR:
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            const char *super_kind;

            switch (big->kind)
              {
                case TK_NOT:
                    super_kind = " negation";
                    break;
                case TK_INTERSECTION:
                    super_kind = "n intersection";
                    break;
                case TK_UNION:
                    super_kind = " union";
                    break;
                case TK_XOR:
                    super_kind = "n exclusive-or";
                    break;
                case TK_TEST_ROUTINE:
                case TK_TEST_ROUTINE_CHAIN:
                    super_kind = " filter function";
                    break;
                default:
                    assert(FALSE);
              }

            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate super-type is a%s type and %s doesn't try "
                    "to dig deeper in such situations", super_kind,
                    interpreter_name());
          }
        case TK_ENUMERATION:
          {
            boolean local_doubt;
            size_t second_count;
            boolean error;
            boolean has_enumeration;
            value **small_values;
            size_t value_num;

            assert(type_is_valid(small)); /* VERIFIED */
            has_enumeration = type_has_finite_enumeration_within_limit(small,
                    big->u.enumeration.value_count, &local_doubt,
                    &second_count, &error);
            if (error)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
            if (local_doubt)
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate super-type is an enumeration type and "
                        "%s is unable to determine whether the candidate "
                        "sub-type has an enumeration of that size or smaller",
                        interpreter_name());
              }

            if (!has_enumeration)
              {
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate super-type is an enumeration type and "
                        "the candidate sub-type does not have an enumeration "
                        "of that size or smaller", interpreter_name());
              }

            assert(type_is_valid(small)); /* VERIFIED */
            small_values =
                    enumerate(small, second_count, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(small_values == NULL);
                return FALSE;
              }
            if (small_values == NULL)
              {
                assert(why_not == NULL);
                *doubt = TRUE;
                return FALSE;
              }
            assert(small_values != NULL);

            assert(type_is_valid(big)); /* VERIFIED */

            *doubt = FALSE;

            for (value_num = 0; value_num < second_count; ++value_num)
              {
                boolean local_doubt;
                char *local_why_not;
                boolean is_in;

                assert(type_is_valid(big)); /* VERIFIED */
                is_in = value_is_in_type(small_values[value_num], big,
                        &local_doubt,
                        ((why_not == NULL) ? NULL : &local_why_not), location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if ((why_not != NULL) && (*doubt))
                        free(*why_not);
                    delete_enumeration(small_values, second_count, the_jumper);
                    return FALSE;
                  }
                if (local_doubt)
                  {
                    if (why_not != NULL)
                      {
                        if (!*doubt)
                          {
                            *why_not = allocate_printf(
                                    "the candidate sub-type is an enumeration "
                                    "containing the value %U, and %s is unable"
                                    " to determine whether that value is in "
                                    "the candidate super-type because %s",
                                    small_values[value_num],
                                    interpreter_name(), local_why_not);
                          }
                        free(local_why_not);
                        if (*why_not == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            delete_enumeration(small_values, second_count,
                                               the_jumper);
                            return FALSE;
                          }
                      }
                    *doubt = TRUE;
                  }
                else if (!is_in)
                  {
                    boolean result;

                    if ((why_not != NULL) && (*doubt))
                        free(*why_not);
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is an enumeration "
                            "containing the value %U, which is not in the "
                            "candidate super-type because %s",
                            small_values[value_num], local_why_not);
                    if (why_not != NULL)
                        free(local_why_not);
                    delete_enumeration(small_values, second_count, the_jumper);
                    return result;
                  }
              }

            delete_enumeration(small_values, second_count, the_jumper);

            return TRUE;
          }
        default:
          {
            break;
          }
      }

    switch (small->kind)
      {
        case TK_ANYTHING:
            assert(FALSE);
            return FALSE;
        case TK_NOTHING:
            assert(FALSE);
            return FALSE;
        case TK_INTEGER:
            switch (big->kind)
              {
                case TK_RATIONAL:
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }
                case TK_INTEGER_RANGES:
                  {
                    o_integer missing;
                    boolean result;

                    if (!(big->u.integer_ranges.includes_positive_infinity))
                      {
                        missing = oi_positive_infinity;
                        oi_add_reference(missing);
                      }
                    else if (!(big->u.integer_ranges.
                                       includes_negative_infinity))
                      {
                        missing = oi_negative_infinity;
                        oi_add_reference(missing);
                      }
                    else if (!(big->u.integer_ranges.
                                       includes_unsigned_infinity))
                      {
                        missing = oi_unsigned_infinity;
                        oi_add_reference(missing);
                      }
                    else if (!(big->u.integer_ranges.includes_zero_zero))
                      {
                        missing = oi_zero_zero;
                        oi_add_reference(missing);
                      }
                    else
                      {
                        size_t component_count;

                        component_count =
                                big->u.integer_ranges.component_count;
                        if (component_count == 0)
                          {
                            missing = oi_zero;
                            oi_add_reference(missing);
                          }
                        else
                          {
                            integer_range_component *component0;

                            component0 =
                                    &(big->u.integer_ranges.components[0]);
                            if (oi_kind(component0->lower_bound) !=
                                IIK_NEGATIVE_INFINITY)
                              {
                                oi_subtract(missing, component0->lower_bound,
                                            oi_one);
                              }
                            else
                              {
                                assert(oi_kind(component0->upper_bound) !=
                                       IIK_POSITIVE_INFINITY);
                                oi_add(missing, component0->upper_bound,
                                       oi_one);
                              }
                            if (oi_out_of_memory(missing))
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                      }

                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is the type of all "
                            "integers and the candidate super-type is an "
                            "integer type that does not include %I", missing);
                    oi_remove_reference(missing);
                    return result;
                  }
                case TK_RATIONAL_RANGES:
                  {
                    o_integer missing;
                    boolean result;

                    if (!(big->u.rational_ranges.includes_positive_infinity))
                      {
                        missing = oi_positive_infinity;
                        oi_add_reference(missing);
                      }
                    else if (!(big->u.rational_ranges.
                                       includes_negative_infinity))
                      {
                        missing = oi_negative_infinity;
                        oi_add_reference(missing);
                      }
                    else if (!(big->u.rational_ranges.
                                       includes_unsigned_infinity))
                      {
                        missing = oi_unsigned_infinity;
                        oi_add_reference(missing);
                      }
                    else if (!(big->u.rational_ranges.includes_zero_zero))
                      {
                        missing = oi_zero_zero;
                        oi_add_reference(missing);
                      }
                    else
                      {
                        size_t component_count;

                        component_count =
                                big->u.rational_ranges.component_count;
                        if (component_count == 0)
                          {
                            missing = oi_zero;
                            oi_add_reference(missing);
                          }
                        else
                          {
                            rational_range_component *components;
                            size_t component_num;

                            components = big->u.rational_ranges.components;
                            for (component_num = 0;
                                 component_num < component_count;
                                 ++component_num)
                              {
                                rational_range_component *this_component;
                                o_integer lower_numerator;

                                this_component = &(components[component_num]);

                                lower_numerator = rational_numerator(
                                        this_component->lower_bound);
                                if ((component_num == 0) &&
                                    (oi_kind(lower_numerator) !=
                                     IIK_NEGATIVE_INFINITY))
                                  {
                                    if (oi_is_negative(lower_numerator))
                                      {
                                        oi_subtract(missing, lower_numerator,
                                                    oi_one);
                                      }
                                    else
                                      {
                                        oi_create_from_long_int(missing, -1);
                                      }
                                    if (oi_out_of_memory(missing))
                                      {
                                        jumper_do_abort(the_jumper);
                                        return FALSE;
                                      }
                                    break;
                                  }

                                if (component_num == (component_count - 1))
                                  {
                                    o_integer upper_numerator;

                                    upper_numerator = rational_numerator(
                                            this_component->upper_bound);
                                    if (oi_kind(upper_numerator) !=
                                        IIK_POSITIVE_INFINITY)
                                      {
                                        if (oi_is_negative(upper_numerator))
                                          {
                                            missing = oi_one;
                                            oi_add_reference(missing);
                                          }
                                        else
                                          {
                                            oi_add(missing, upper_numerator,
                                                   oi_one);
                                            if (oi_out_of_memory(missing))
                                              {
                                                jumper_do_abort(the_jumper);
                                                return FALSE;
                                              }
                                          }
                                      }
                                    else
                                      {
                                        *doubt = FALSE;
                                        return TRUE;
                                      }
                                  }
                                else
                                  {
                                    rational_range_component *next_component;
                                    boolean error;

                                    next_component =
                                            &(components[component_num + 1]);
                                    missing = integer_between_rationals(
                                            this_component->upper_bound,
                                            next_component->lower_bound,
                                            !(this_component->
                                                    upper_is_inclusive),
                                            !(next_component->
                                                    lower_is_inclusive),
                                            &error);
                                    if (error)
                                      {
                                        assert(oi_out_of_memory(missing));
                                        jumper_do_abort(the_jumper);
                                        return FALSE;
                                      }
                                    if (!(oi_out_of_memory(missing)))
                                        break;
                                  }
                              }
                          }
                      }

                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is the type of all "
                            "integers and the candidate super-type is a "
                            "rational type that does not include %I", missing);
                    oi_remove_reference(missing);
                    return result;
                  }
                default:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_because_value_kinds_different(small,
                            big, doubt, why_not, the_jumper);
                  }
              }
        case TK_RATIONAL:
            switch (big->kind)
              {
                case TK_INTEGER:
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type is the type of all "
                            "rationals and the candidate super-type is the "
                            "type of all integers, and the former includes "
                            "fractional values while the later does not");
                  }
                case TK_INTEGER_RANGES:
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type is the type of all "
                            "rationals and the candidate super-type is an "
                            "integer type, and the former includes fractional "
                            "values while the later does not");
                  }
                case TK_RATIONAL_RANGES:
                  {
                    o_integer missing_integer;
                    rational *missing_rational;
                    boolean result;

                    if (!(big->u.rational_ranges.includes_positive_infinity))
                      {
                        missing_integer = oi_positive_infinity;
                        missing_rational = NULL;
                      }
                    else if (!(big->u.rational_ranges.
                                       includes_negative_infinity))
                      {
                        missing_integer = oi_negative_infinity;
                        missing_rational = NULL;
                      }
                    else if (!(big->u.rational_ranges.
                                       includes_unsigned_infinity))
                      {
                        missing_integer = oi_unsigned_infinity;
                        missing_rational = NULL;
                      }
                    else if (!(big->u.rational_ranges.includes_zero_zero))
                      {
                        missing_integer = oi_zero_zero;
                        missing_rational = NULL;
                      }
                    else
                      {
                        size_t component_count;

                        component_count =
                                big->u.rational_ranges.component_count;
                        if (component_count == 0)
                          {
                            missing_integer = oi_zero;
                            missing_rational = NULL;
                          }
                        else
                          {
                            rational_range_component *component0;
                            rational *rational_one;

                            component0 =
                                    &(big->u.rational_ranges.components[0]);
                            rational_one = create_rational(oi_one, oi_one);
                            if (rational_one == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                            if (oi_kind(rational_numerator(
                                        component0->lower_bound)) !=
                                IIK_NEGATIVE_INFINITY)
                              {
                                missing_rational = rational_subtract(
                                        component0->lower_bound, rational_one);
                              }
                            else
                              {
                                assert(oi_kind(rational_numerator(
                                               component0->upper_bound)) !=
                                       IIK_POSITIVE_INFINITY);
                                missing_rational = rational_add(
                                        component0->upper_bound, rational_one);
                              }
                            rational_remove_reference(rational_one);
                            if (missing_rational == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                            missing_integer = oi_null;
                          }
                      }

                    if (!(oi_out_of_memory(missing_integer)))
                      {
                        assert(missing_rational == NULL);
                        result = type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type is the type of all "
                                "rationals and the candidate super-type is a "
                                "rational type that does not include %I",
                                missing_integer);
                      }
                    else
                      {
                        assert(missing_rational != NULL);
                        result = type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type is the type of all "
                                "rationals and the candidate super-type is a "
                                "rational type that does not include %Y",
                                missing_rational);
                        rational_remove_reference(missing_rational);
                      }
                    return result;
                  }
                default:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_because_value_kinds_different(small,
                            big, doubt, why_not, the_jumper);
                  }
              }
        case TK_ANY_REGULAR_EXPRESSION:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_because_value_kinds_different(small, big,
                    doubt, why_not, the_jumper);
        case TK_ANY_QUARK:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_because_value_kinds_different(small, big,
                    doubt, why_not, the_jumper);
        case TK_ANY_LEPTON:
        case TK_OBJECT:
            switch (big->kind)
              {
                case TK_FIELDS:
                  {
                    field_type_info *big_field_info;
                    size_t field_count;
                    size_t field_num;

                    *doubt = FALSE;

                    big_field_info = &(big->u.fields.field_info);

                    if (!(big_field_info->extra_fields_allowed))
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type is the type of all %ss"
                                " and the candidate super-type is a fields "
                                "type that doesn't allow fields beyond those "
                                "it explicitly specifies, so the later does "
                                "not include all %ss",
                                ((small->kind == TK_ANY_LEPTON) ? "lepton" :
                                 "object"),
                                ((small->kind == TK_ANY_LEPTON) ? "lepton" :
                                 "object"));
                      }

                    field_count = big_field_info->field_count;

                    for (field_num = 0; field_num < field_count; ++field_num)
                      {
                        type *field_type;

                        if (!(big_field_info->field_can_be_empty[field_num]))
                          {
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the candidate sub-type is the type of all"
                                    " %ss and the candidate super-type is a "
                                    "fields type that requires a field named "
                                    "`%s' exist",
                                    ((small->kind == TK_ANY_LEPTON) ? "lepton"
                                     : "object"),
                                    big_field_info->field_names[field_num]);
                          }

                        field_type = big_field_info->field_types[field_num];
                        assert(field_type != NULL);

                        if (field_type->kind == TK_ANYTHING)
                            continue;

                        assert(type_is_valid(field_type)); /* VERIFIED */
                        if (!(possibly_everything(field_type)))
                          {
                            if ((why_not != NULL) && (*doubt))
                                free(*why_not);
                            return type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the candidate sub-type is the type of all"
                                    " %ss and the candidate super-type is a "
                                    "fields type that has a required type for "
                                    "field `%s' that doesn't include all "
                                    "values, so the later does not include all"
                                    " %ss",
                                    ((small->kind == TK_ANY_LEPTON) ? "lepton"
                                     : "object"),
                                    big_field_info->field_names[field_num],
                                    ((small->kind == TK_ANY_LEPTON) ? "lepton"
                                     : "object"));
                          }

                        if ((why_not != NULL) && (!(*doubt)))
                          {
                            *why_not = allocate_printf(
                                    "the candidate sub-type is the type of all"
                                    " %ss and the candidate super-type is a "
                                    "fields type for which %s is unable to "
                                    "determine whether the required type for "
                                    "field `%s' includes all values",
                                    ((small->kind == TK_ANY_LEPTON) ? "lepton"
                                     : "object"), interpreter_name(),
                                    big_field_info->field_names[field_num]);
                            if (*why_not == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                          }
                        *doubt = TRUE;
                      }

                    return TRUE;
                  }
                case TK_INTERFACE:
                  {
                    return type_in_no_doubt(
                            (big->u.interface.field_info.field_count == 0),
                            doubt, why_not, the_jumper,
                            "the candidate sub-type is the type of all %ss and"
                            " the candidate super-type is an interface type "
                            "that makes requirements about certain fields, so "
                            "the later does not include all %ss",
                            ((small->kind == TK_ANY_LEPTON) ? "lepton" :
                             "object"),
                            ((small->kind == TK_ANY_LEPTON) ? "lepton" :
                             "object"));
                  }
                case TK_LEPTON:
                  {
                    if (small->kind == TK_ANY_LEPTON)
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type is the type of all "
                                "leptons and the candidate super-type is a "
                                "specific lepton type, and the former includes"
                                " all lepton values while the later only "
                                "includes those for one specific lepton key");
                      }
                    else
                      {
                        assert(type_is_valid(small)); /* VERIFIED */
                        assert(type_is_valid(big)); /* VERIFIED */
                        return type_not_subset_because_value_kinds_different(
                                small, big, doubt, why_not, the_jumper);
                      }
                  }
                case TK_CLASS:
                  {
                    if (small->kind == TK_OBJECT)
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type is the type of all "
                                "objects and the candidate super-type is a "
                                "class type, and the former includes all "
                                "object values while the later only includes "
                                "objects based on one specific class");
                      }
                    else
                      {
                        assert(type_is_valid(small)); /* VERIFIED */
                        assert(type_is_valid(big)); /* VERIFIED */
                        return type_not_subset_because_value_kinds_different(
                                small, big, doubt, why_not, the_jumper);
                      }
                  }
                default:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_because_value_kinds_different(small,
                            big, doubt, why_not, the_jumper);
                  }
              }
        case TK_LEPTON_KEY:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_because_value_kinds_different(small, big,
                    doubt, why_not, the_jumper);
        case TK_JUMP_TARGET:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_because_value_kinds_different(small, big,
                    doubt, why_not, the_jumper);
        case TK_ANY_CLASS:
            if (big->kind == TK_ROUTINE)
              {
                if (!(big->u.routine.extra_arguments_unspecified))
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type is the type of all classes"
                            " and the candidate super-type is a routine type "
                            "that doesn't leave extra arguments unspecified, "
                            "so the later does not include all possible "
                            "classes");
                  }

                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type is the type of all classes and"
                        " the candidate super-type is a routine type and %s "
                        "doesn't try to dig deeper in such situations",
                        interpreter_name());
              }
            else
              {
                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return type_not_subset_because_value_kinds_different(small,
                        big, doubt, why_not, the_jumper);
              }
        case TK_TAGALONG_KEY:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_because_value_kinds_different(small, big,
                    doubt, why_not, the_jumper);
        case TK_LOCK:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_because_value_kinds_different(small, big,
                    doubt, why_not, the_jumper);
        case TK_STRING:
            if (big->kind == TK_REGULAR_EXPRESSION)
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type is the type of all strings and"
                        " the candidate super-type is a regular expression "
                        "type, so the former is a sub-type if and only if the "
                        "regular expression of the later matches all strings "
                        "and %s doesn't try to analyze regular expressions to "
                        "see whether they match all strings",
                        interpreter_name());
              }
            else
              {
                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return type_not_subset_because_value_kinds_different(small,
                        big, doubt, why_not, the_jumper);
              }
        case TK_CHARACTER:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_because_value_kinds_different(small, big,
                    doubt, why_not, the_jumper);
        case TK_ENUMERATION:
            assert(FALSE);
            return FALSE;
        case TK_NOT:
            assert(FALSE);
            return FALSE;
        case TK_INTERSECTION:
            assert(FALSE);
            return FALSE;
        case TK_UNION:
            assert(FALSE);
            return FALSE;
        case TK_XOR:
            assert(FALSE);
            return FALSE;
        case TK_ARRAY:
            if (big->kind == TK_MAP)
              {
                type *small_map_type;
                boolean result;

                assert(type_is_valid(small)); /* VERIFIED */
                small_map_type = map_type_for_array_type(small);
                assert((small_map_type == NULL) ||
                       type_is_valid(small_map_type)); /* VERIFIED */
                if (small_map_type == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }

                assert(type_is_valid(small_map_type)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                result = type_is_subset(small_map_type, big, doubt, why_not,
                                        location, the_jumper);
                type_remove_reference(small_map_type,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                                                               the_jumper));
                return result;
              }
            else if (big->kind == TK_SEMI_LABELED_VALUE_LIST)
              {
                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return array_is_subset_of_semi_labeled_value_list(small, big,
                        doubt, why_not, location, the_jumper);
              }

            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_unless_empty_different_kinds(small, big,
                    doubt, why_not, the_jumper);
        case TK_INTEGER_RANGES:
            switch (big->kind)
              {
                case TK_INTEGER:
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }
                case TK_RATIONAL:
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }
                case TK_RATIONAL_RANGES:
                  {
                    o_integer missing;
                    boolean result;

                    if (small->u.integer_ranges.includes_positive_infinity &&
                        !(big->u.rational_ranges.includes_positive_infinity))
                      {
                        missing = oi_positive_infinity;
                        oi_add_reference(missing);
                      }
                    else if (small->u.integer_ranges.
                                     includes_negative_infinity &&
                             !(big->u.rational_ranges.
                                       includes_negative_infinity))
                      {
                        missing = oi_negative_infinity;
                        oi_add_reference(missing);
                      }
                    else if (small->u.integer_ranges.
                                     includes_unsigned_infinity &&
                             !(big->u.rational_ranges.
                                       includes_unsigned_infinity))
                      {
                        missing = oi_unsigned_infinity;
                        oi_add_reference(missing);
                      }
                    else if (small->u.integer_ranges.includes_zero_zero &&
                             !(big->u.rational_ranges.includes_zero_zero))
                      {
                        missing = oi_zero_zero;
                        oi_add_reference(missing);
                      }
                    else
                      {
                        size_t small_component_count;
                        size_t big_component_count;
                        integer_range_component *small_components;
                        rational_range_component *big_components;
                        size_t big_component_num;
                        size_t small_component_num;

                        small_component_count =
                                small->u.integer_ranges.component_count;
                        big_component_count =
                                big->u.rational_ranges.component_count;
                        small_components = small->u.integer_ranges.components;
                        big_components = big->u.rational_ranges.components;

                        big_component_num = 0;
                        for (small_component_num = 0; TRUE;
                             ++small_component_num)
                          {
                            integer_range_component *this_small_component;
                            o_integer small_lower_integer;
                            rational *small_lower_rational;
                            rational_range_component *this_big_component;
                            rational *big_lower;
                            boolean error;
                            boolean miss;
                            o_integer small_upper_integer;
                            rational *small_upper_rational;

                            if (small_component_num >= small_component_count)
                              {
                                *doubt = FALSE;
                                return TRUE;
                              }

                            this_small_component =
                                    &(small_components[small_component_num]);
                            small_lower_integer =
                                    this_small_component->lower_bound;
                            small_lower_rational = create_rational(
                                    small_lower_integer, oi_one);
                            if (small_lower_rational == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }

                            while (big_component_num < big_component_count)
                              {
                                boolean error;
                                boolean too_low;

                                this_big_component =
                                        &(big_components[big_component_num]);
                                if (this_big_component->upper_is_inclusive)
                                  {
                                    too_low = rational_less_than(
                                            this_big_component->upper_bound,
                                            small_lower_rational, &error);
                                  }
                                else
                                  {
                                    too_low = !(rational_less_than(
                                            small_lower_rational,
                                            this_big_component->upper_bound,
                                            &error));
                                  }
                                if (error)
                                  {
                                    jumper_do_abort(the_jumper);
                                    rational_remove_reference(
                                            small_lower_rational);
                                    return FALSE;
                                  }
                                if (!too_low)
                                    break;
                                ++big_component_num;
                              }

                            if (big_component_num >= big_component_count)
                              {
                                rational_remove_reference(
                                        small_lower_rational);
                                missing = small_lower_integer;
                                oi_add_reference(missing);
                                break;
                              }

                            big_lower = this_big_component->lower_bound;
                            if (!(this_big_component->lower_is_inclusive))
                              {
                                miss = !(rational_less_than(big_lower,
                                        small_lower_rational, &error));
                              }
                            else
                              {
                                miss = rational_less_than(small_lower_rational,
                                                          big_lower, &error);
                              }
                            rational_remove_reference(small_lower_rational);
                            if (error)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                            if (miss)
                              {
                                if (oi_kind(small_lower_integer) == IIK_FINITE)
                                  {
                                    missing = small_lower_integer;
                                    oi_add_reference(missing);
                                  }
                                else
                                  {
                                    o_integer big_lower_numerator;

                                    big_lower_numerator =
                                            rational_numerator(big_lower);
                                    if (oi_is_negative(big_lower_numerator))
                                      {
                                        oi_subtract(missing,
                                                big_lower_numerator, oi_one);
                                        if (oi_out_of_memory(missing))
                                          {
                                            jumper_do_abort(the_jumper);
                                            return FALSE;
                                          }
                                      }
                                    else
                                      {
                                        missing = oi_zero;
                                        oi_add_reference(missing);
                                      }
                                  }

                                break;
                              }

                            small_upper_integer =
                                    this_small_component->upper_bound;
                            small_upper_rational = create_rational(
                                    small_upper_integer, oi_one);
                            if (small_upper_rational == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }

                            while (TRUE)
                              {
                                rational *big_upper;
                                boolean miss;

                                big_upper = this_big_component->upper_bound;

                                if (!(this_big_component->upper_is_inclusive))
                                  {
                                    miss = !(rational_less_than(
                                            small_upper_rational, big_upper,
                                            &error));
                                  }
                                else
                                  {
                                    miss = rational_less_than(big_upper,
                                            small_upper_rational, &error);
                                  }
                                if (error)
                                  {
                                    jumper_do_abort(the_jumper);
                                    rational_remove_reference(
                                            small_upper_rational);
                                    return FALSE;
                                  }
                                if (!miss)
                                  {
                                    rational_remove_reference(
                                            small_upper_rational);
                                    break;
                                  }

                                ++big_component_num;
                                if (big_component_num < big_component_count)
                                  {
                                    rational_range_component *
                                            next_big_component;
                                    boolean error;

                                    next_big_component = &(big_components[
                                            big_component_num]);
                                    missing = integer_between_rationals(
                                            this_big_component->upper_bound,
                                            next_big_component->lower_bound,
                                            this_big_component->
                                                    upper_is_inclusive,
                                            next_big_component->
                                                    lower_is_inclusive,
                                            &error);
                                    if (error)
                                      {
                                        jumper_do_abort(the_jumper);
                                        rational_remove_reference(
                                                small_upper_rational);
                                        return FALSE;
                                      }
                                    if (oi_out_of_memory(missing))
                                      {
                                        rational_remove_reference(
                                                small_upper_rational);
                                        goto found_missing;
                                      }
                                    this_big_component = next_big_component;
                                    continue;
                                  }

                                rational_remove_reference(
                                        small_upper_rational);

                                if (oi_kind(small_upper_integer) == IIK_FINITE)
                                  {
                                    missing = small_upper_integer;
                                    oi_add_reference(missing);
                                  }
                                else
                                  {
                                    o_integer big_upper_numerator;

                                    big_upper_numerator =
                                            rational_numerator(big_upper);
                                    if (oi_is_negative(big_upper_numerator))
                                      {
                                        missing = oi_zero;
                                        oi_add_reference(missing);
                                      }
                                    else
                                      {
                                        oi_add(missing, big_upper_numerator,
                                               oi_one);
                                        if (oi_out_of_memory(missing))
                                          {
                                            jumper_do_abort(the_jumper);
                                            return FALSE;
                                          }
                                      }
                                  }

                                goto found_missing;
                              }
                          }
                      }

                  found_missing:
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is an integer type and the"
                            " candidate super-type is a rational types and the"
                            " former includes %I while the later does not",
                            missing);
                    oi_remove_reference(missing);
                    return result;
                  }
                default:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_because_value_kinds_different(small,
                            big, doubt, why_not, the_jumper);
                  }
              }
        case TK_RATIONAL_RANGES:
            switch (big->kind)
              {
                case TK_INTEGER:
                  {
                    size_t component_count;
                    rational_range_component *components;
                    size_t component_num;

                    *doubt = FALSE;

                    component_count = small->u.rational_ranges.component_count;
                    components = small->u.rational_ranges.components;

                    for (component_num = 0; component_num < component_count;
                         ++component_num)
                      {
                        rational *lower_bound;
                        rational *upper_bound;

                        lower_bound = components[component_num].lower_bound;
                        upper_bound = components[component_num].upper_bound;
                        if (!(rationals_are_equal(lower_bound, upper_bound) &&
                              rational_is_integer(lower_bound)))
                          {
                            rational *sum;
                            o_integer integer_two;
                            rational *rational_two;
                            rational *missing;
                            boolean result;

                            sum = rational_add(lower_bound, upper_bound);
                            if (sum == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }

                            oi_create_from_size_t(integer_two, 2);
                            if (oi_out_of_memory(integer_two))
                              {
                                jumper_do_abort(the_jumper);
                                rational_remove_reference(sum);
                                return FALSE;
                              }

                            rational_two =
                                    create_rational(integer_two, oi_one);
                            oi_remove_reference(integer_two);
                            if (rational_two == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                rational_remove_reference(sum);
                                return FALSE;
                              }

                            missing = rational_divide(sum, rational_two);
                            rational_remove_reference(sum);
                            rational_remove_reference(rational_two);
                            if (missing == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }

                            result = type_in_no_doubt(FALSE, doubt, why_not,
                                    the_jumper,
                                    "the candidate sub-type is a rational type"
                                    " and the candidate super-type is the type"
                                    " of all integers and the former includes "
                                    "%Y while the later does not", missing);
                            rational_remove_reference(missing);
                            return result;
                          }
                      }

                    return TRUE;
                  }
                case TK_RATIONAL:
                  {
                    *doubt = FALSE;
                    return TRUE;
                  }
                case TK_INTEGER_RANGES:
                  {
                    size_t small_component_count;
                    rational_range_component *small_components;
                    size_t big_component_count;
                    integer_range_component *big_components;
                    size_t big_component_num;
                    size_t small_component_num;
                    o_integer missing_integer;
                    rational *missing_rational;
                    boolean result;

                    *doubt = FALSE;

                    if (small->u.rational_ranges.includes_positive_infinity &&
                        !(big->u.integer_ranges.includes_positive_infinity))
                      {
                        missing_integer = oi_positive_infinity;
                        goto found_missing_integer;
                      }
                    if (small->u.rational_ranges.includes_negative_infinity &&
                        !(big->u.integer_ranges.includes_negative_infinity))
                      {
                        missing_integer = oi_negative_infinity;
                        goto found_missing_integer;
                      }
                    if (small->u.rational_ranges.includes_unsigned_infinity &&
                        !(big->u.integer_ranges.includes_unsigned_infinity))
                      {
                        missing_integer = oi_unsigned_infinity;
                        goto found_missing_integer;
                      }
                    if (small->u.rational_ranges.includes_zero_zero &&
                        !(big->u.integer_ranges.includes_zero_zero))
                      {
                        missing_integer = oi_zero_zero;
                        goto found_missing_integer;
                      }

                    small_component_count =
                            small->u.rational_ranges.component_count;
                    small_components = small->u.rational_ranges.components;

                    big_component_count =
                            big->u.integer_ranges.component_count;
                    big_components = big->u.integer_ranges.components;
                    big_component_num = 0;

                    for (small_component_num = 0;
                         small_component_num < small_component_count;
                         ++small_component_num)
                      {
                        rational *lower_bound;
                        rational *upper_bound;
                        o_integer numerator;

                        lower_bound = small_components[small_component_num].
                                lower_bound;
                        upper_bound = small_components[small_component_num].
                                upper_bound;
                        if (!(rationals_are_equal(lower_bound, upper_bound) &&
                              rational_is_integer(lower_bound)))
                          {
                            rational *sum;
                            o_integer integer_two;
                            rational *rational_two;

                            sum = rational_add(lower_bound, upper_bound);
                            if (sum == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }

                            oi_create_from_size_t(integer_two, 2);
                            if (oi_out_of_memory(integer_two))
                              {
                                jumper_do_abort(the_jumper);
                                rational_remove_reference(sum);
                                return FALSE;
                              }

                            rational_two =
                                    create_rational(integer_two, oi_one);
                            oi_remove_reference(integer_two);
                            if (rational_two == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                rational_remove_reference(sum);
                                return FALSE;
                              }

                            missing_rational =
                                    rational_divide(sum, rational_two);
                            rational_remove_reference(sum);
                            rational_remove_reference(rational_two);
                            if (missing_rational == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }

                            goto found_missing_rational;
                          }

                        assert(small_components[small_component_num].
                                       lower_is_inclusive);
                        assert(small_components[small_component_num].
                                       upper_is_inclusive);

                        numerator = rational_numerator(lower_bound);

                        while (TRUE)
                          {
                            if (big_component_num >= big_component_count)
                              {
                                missing_integer = numerator;
                                goto found_missing_integer;
                              }

                            if (oi_less_than(
                                        big_components[big_component_num].
                                                upper_bound, numerator))
                              {
                                ++big_component_num;
                                continue;
                              }

                            if (!(oi_less_than(numerator,
                                          big_components[big_component_num].
                                                  lower_bound)))
                              {
                                break;
                              }

                            missing_integer = numerator;
                            goto found_missing_integer;
                          }
                      }

                    return TRUE;

                  found_missing_integer:
                    missing_rational =
                            create_rational(missing_integer, oi_one);
                    if (missing_rational == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }

                  found_missing_rational:
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is a rational type and the"
                            " candidate super-type is an integer type and the "
                            "former includes %Y while the later does not",
                            missing_rational);
                    rational_remove_reference(missing_rational);
                    return result;
                  }
                default:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_because_value_kinds_different(small,
                            big, doubt, why_not, the_jumper);
                  }
              }
        case TK_POINTER:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_unless_empty_different_kinds(small, big,
                    doubt, why_not, the_jumper);
        case TK_TYPE:
            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_unless_empty_different_kinds(small, big,
                    doubt, why_not, the_jumper);
        case TK_MAP:
            if (big->kind == TK_ARRAY)
              {
                type *big_map_type;
                boolean result;

                assert(type_is_valid(big)); /* VERIFIED */
                big_map_type = map_type_for_array_type(big);
                assert((big_map_type == NULL) || type_is_valid(big_map_type));
                        /* VERIFIED */
                if (big_map_type == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }

                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big_map_type)); /* VERIFIED */
                result = type_is_subset(small, big_map_type, doubt, why_not,
                                        location, the_jumper);
                type_remove_reference(big_map_type,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                                                               the_jumper));
                return result;
              }
            else if (big->kind == TK_SEMI_LABELED_VALUE_LIST)
              {
                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return map_is_subset_of_semi_labeled_value_list(small, big,
                        doubt, why_not, location, the_jumper);
              }

            assert(type_is_valid(small)); /* VERIFIED */
            assert(type_is_valid(big)); /* VERIFIED */
            return type_not_subset_because_value_kinds_different(small, big,
                    doubt, why_not, the_jumper);
        case TK_ROUTINE:
            if (big->kind == TK_ANY_CLASS)
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type is a routine type and the "
                        "candidate super-type is the type of all classes and "
                        "%s doesn't try to dig deeper in such situations",
                        interpreter_name());
              }
            else
              {
                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return type_not_subset_because_value_kinds_different(small,
                        big, doubt, why_not, the_jumper);
              }
        case TK_FIELDS:
            switch (big->kind)
              {
                case TK_INTERFACE:
                  {
                    field_type_info *big_field_info;
                    size_t item_count;
                    size_t item_num;

                    big_field_info = &(big->u.interface.field_info);

                    item_count = big_field_info->field_count;
                    for (item_num = 0; item_num < item_count; ++item_num)
                      {
                        if (big->u.interface.item_writing_alloweds[item_num])
                          {
                            type *item_type;

                            item_type = big_field_info->field_types[item_num];
                            if (item_type->kind != TK_NOTHING)
                              {
                                assert(type_is_valid(item_type));
                                        /* VERIFIED */
                                assert(type_is_valid(small)); /* VERIFIED */
                                if (possibly_nothing(item_type))
                                  {
                                    return type_in_doubt(doubt, why_not,
                                            the_jumper,
                                            "the candidate sub-type is a "
                                            "fields type and the candidate "
                                            "super-type is an interface type "
                                            "and the later requires writing be"
                                            " allowed for a field named `%s' "
                                            "and %s is unable to determine "
                                            "whether the type specified by the"
                                            " later for that field is the "
                                            "empty type",
                                            big_field_info->field_names[
                                                    item_num],
                                            interpreter_name());
                                  }
                                else if (possibly_nothing(small))
                                  {
                                    return type_in_doubt(doubt, why_not,
                                            the_jumper,
                                            "the candidate sub-type is a "
                                            "fields type and the candidate "
                                            "super-type is an interface type "
                                            "and the later requires writing be"
                                            " allowed for a field named `%s' "
                                            "and specifies a non-empty type "
                                            "for that field, and %s is unable "
                                            "to determine whether the former "
                                            "is the empty type",
                                            big_field_info->field_names[
                                                    item_num],
                                            interpreter_name());
                                  }
                                else
                                  {
                                    return type_in_no_doubt(FALSE, doubt,
                                            why_not, the_jumper,
                                            "the candidate sub-type is a "
                                            "fields type and the candidate "
                                            "super-type is an interface type "
                                            "and the later requires writing be"
                                            " allowed for a field named `%s' "
                                            "and specifies a non-empty type "
                                            "for that field, and the former is"
                                            " not the empty type",
                                            big_field_info->field_names[
                                                    item_num]);
                                  }
                              }
                          }
                      }

                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return unordered_named_field_rules_are_subset(
                            &(small->u.fields.field_info),
                            &(big->u.interface.field_info), doubt, why_not,
                            possibly_nothing(small), location, the_jumper);
                  }
                case TK_ANY_LEPTON:
                case TK_ARRAY:
                case TK_MAP:
                case TK_LEPTON:
                case TK_MULTISET:
                case TK_SEMI_LABELED_VALUE_LIST:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return
                        type_not_subset_unless_empty_different_kinds_with_kind(
                                small, big, "object", doubt, why_not,
                                the_jumper);
                  }
                case TK_OBJECT:
                case TK_CLASS:
                default:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return
                        type_not_subset_unless_empty_different_kinds_with_kind(
                                small, big, "semi-labeled value list", doubt,
                                why_not, the_jumper);
                  }
              }
        case TK_LEPTON:
            switch (big->kind)
              {
                case TK_ANY_LEPTON:
                    *doubt = FALSE;
                    return TRUE;
                case TK_FIELDS:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return unordered_named_field_rules_are_subset(
                            &(small->u.lepton.field_info),
                            &(big->u.fields.field_info), doubt, why_not,
                            possibly_nothing(small), location, the_jumper);
                case TK_INTERFACE:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return unordered_named_field_rules_are_subset(
                            &(small->u.lepton.field_info),
                            &(big->u.interface.field_info), doubt, why_not,
                            possibly_nothing(small), location, the_jumper);
                default:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_unless_empty_different_kinds(small,
                            big, doubt, why_not, the_jumper);
              }
        case TK_MULTISET:
            switch (big->kind)
              {
                case TK_FIELDS:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return unordered_named_field_rules_are_subset(
                            &(small->u.multiset.field_info),
                            &(big->u.fields.field_info), doubt, why_not,
                            possibly_nothing(small), location, the_jumper);
                case TK_INTERFACE:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return unordered_named_field_rules_are_subset(
                            &(small->u.multiset.field_info),
                            &(big->u.interface.field_info), doubt, why_not,
                            possibly_nothing(small), location, the_jumper);
                default:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_unless_empty_different_kinds(small,
                            big, doubt, why_not, the_jumper);
              }
        case TK_INTERFACE:
            switch (big->kind)
              {
                case TK_FIELDS:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return unordered_named_field_rules_are_subset(
                            &(small->u.interface.field_info),
                            &(big->u.fields.field_info), doubt, why_not,
                            possibly_nothing(small), location, the_jumper);
                case TK_ANY_LEPTON:
                case TK_ARRAY:
                case TK_MAP:
                case TK_LEPTON:
                case TK_MULTISET:
                case TK_SEMI_LABELED_VALUE_LIST:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return
                        type_not_subset_unless_empty_different_kinds_with_kind(
                                small, big, "object", doubt, why_not,
                                the_jumper);
                case TK_OBJECT:
                case TK_CLASS:
                default:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return
                        type_not_subset_unless_empty_different_kinds_with_kind(
                                small, big, "semi-labeled value list", doubt,
                                why_not, the_jumper);
              }
        case TK_SEMI_LABELED_VALUE_LIST:
            switch (big->kind)
              {
                case TK_ARRAY:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return semi_labeled_value_list_is_subset_of_array(small,
                            big, doubt, why_not, location, the_jumper);
                  }
                case TK_MAP:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return semi_labeled_value_list_is_subset_of_map(small, big,
                            doubt, why_not, location, the_jumper);
                  }
                case TK_FIELDS:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return semi_labeled_value_list_is_subset_of_field_info(
                            small, &(big->u.fields.field_info), doubt, why_not,
                            location, the_jumper);
                  }
                case TK_INTERFACE:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return semi_labeled_value_list_is_subset_of_field_info(
                            small, &(big->u.interface.field_info), doubt,
                            why_not, location, the_jumper);
                  }
                default:
                  {
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_unless_empty_different_kinds(small,
                            big, doubt, why_not, the_jumper);
                  }
              }
        case TK_REGULAR_EXPRESSION:
            if (big->kind == TK_STRING)
              {
                *doubt = FALSE;
                return TRUE;
              }
            else
              {
                assert(type_is_valid(small)); /* VERIFIED */
                assert(type_is_valid(big)); /* VERIFIED */
                return type_not_subset_unless_empty_different_kinds(small, big,
                        doubt, why_not, the_jumper);
              }
        case TK_CLASS:
            switch (big->kind)
              {
                case TK_OBJECT:
                    *doubt = FALSE;
                    return TRUE;
                case TK_FIELDS:
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a class type and the "
                            "candidate super-type is a fields type, and %s "
                            "doesn't try to dig deeper in such situations",
                            interpreter_name());
                case TK_INTERFACE:
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a class type and the "
                            "candidate super-type is an interface type, and %s"
                            " doesn't try to dig deeper in such situations",
                            interpreter_name());
                default:
                    assert(type_is_valid(small)); /* VERIFIED */
                    assert(type_is_valid(big)); /* VERIFIED */
                    return type_not_subset_unless_empty_different_kinds(small,
                            big, doubt, why_not, the_jumper);
              }
        case TK_TEST_ROUTINE:
            assert(FALSE);
            return FALSE;
        case TK_TEST_ROUTINE_CHAIN:
            assert(FALSE);
            return FALSE;
        case TK_SEPARATOR:
            assert(FALSE);
            return FALSE;
        default:
            assert(FALSE);
            return FALSE;
      }
  }

extern type *map_target_type(type *base_type, value *key_value,
        lower_or_upper bound_direction, const source_location *location,
        jumper *the_jumper)
  {
    assert(base_type != NULL);
    assert(key_value != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(base_type)); /* VERIFIED */
    assert(value_is_valid(key_value)); /* VERIFIED */

    switch (base_type->kind)
      {
        case TK_ANYTHING:
          {
            type_add_reference(base_type);
            assert(type_is_valid(base_type)); /* VERIFIED */
            return base_type;
          }
        case TK_NOTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
          {
            type *result;

          definitely_nothing:
            result = get_nothing_type();
            if (result != NULL)
                type_add_reference(result);
            else
                jumper_do_abort(the_jumper);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ENUMERATION:
          {
            value_aa result_values;
            verdict the_verdict;
            size_t source_count;
            size_t source_num;
            type *result;

            the_verdict = value_aa_init(&result_values, 10);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            source_count = base_type->u.enumeration.value_count;

            for (source_num = 0; source_num < source_count; ++source_num)
              {
                value *this_value;
                value *target;
                verdict the_verdict;

                assert(type_is_valid(base_type)); /* VERIFIED */
                this_value = base_type->u.enumeration.values[source_num];
                assert(this_value != NULL);
                assert(value_is_valid(this_value)); /* VERIFIED */

                switch (get_value_kind(this_value))
                  {
                    case VK_MAP:
                      {
                        boolean doubt;

                        assert(map_value_all_keys_are_valid(this_value));
                                /* VERIFIED */
                        assert(value_is_valid(key_value)); /* VERIFIED */
                        target = map_value_lookup(this_value, key_value,
                                &doubt, location, the_jumper);
                        assert((target == NULL) || value_is_valid(target));
                                /* VERIFIED */
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            assert(target == NULL);
                            free(result_values.array);
                            return NULL;
                          }
                        if (doubt)
                          {
                            assert(target == NULL);
                            free(result_values.array);
                            goto unknown;
                          }
                        assert(target != NULL);
                        assert(value_is_valid(target)); /* VERIFIED */

                        break;
                      }
                    case VK_SEMI_LABELED_VALUE_LIST:
                      {
                        o_integer key_oi;
                        size_t component_count;
                        o_integer count_oi;
                        int order;
                        size_t component_num;
                        verdict the_verdict;

                        if (get_value_kind(key_value) != VK_INTEGER)
                            continue;

                        key_oi = integer_value_data(key_value);
                        assert(!(oi_out_of_memory(key_oi)));

                        if (oi_kind(key_oi) != IIK_FINITE)
                            continue;

                        if (oi_is_negative(key_oi))
                            continue;

                        component_count = value_component_count(this_value);
                        oi_create_from_size_t(count_oi, component_count);
                        if (oi_out_of_memory(count_oi))
                          {
                            jumper_do_abort(the_jumper);
                            free(result_values.array);
                            return NULL;
                          }

                        order = oi_structural_order(count_oi, key_oi);
                        oi_remove_reference(count_oi);
                        if (order == -2)
                          {
                            jumper_do_abort(the_jumper);
                            free(result_values.array);
                            return NULL;
                          }
                        if (order <= 0)
                            continue;

                        the_verdict =
                                oi_magnitude_to_size_t(key_oi, &component_num);
                        if (the_verdict != MISSION_ACCOMPLISHED)
                          {
                            jumper_do_abort(the_jumper);
                            free(result_values.array);
                            return NULL;
                          }
                        assert(component_num < component_count);

                        target = value_component_value(this_value,
                                                       component_num);
                        assert((target == NULL) || value_is_valid(target));
                                /* VERIFIED */
                        if (target == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            free(result_values.array);
                            return NULL;
                          }

                        assert(value_is_valid(target)); /* VERIFIED */

                        break;
                      }
                    default:
                      {
                        continue;
                      }
                  }

                assert(target != NULL);
                assert(value_is_valid(target)); /* VERIFIED */
                the_verdict = value_aa_append(&result_values, target);
                if (the_verdict != MISSION_ACCOMPLISHED)
                  {
                    jumper_do_abort(the_jumper);
                    free(result_values.array);
                    return NULL;
                  }
              }

            result = get_enumeration_type(result_values.element_count,
                                          result_values.array);
            free(result_values.array);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            return result;
          }
        case TK_NOT:
          {
            goto unknown;
          }
        case TK_INTERSECTION:
          {
            type *left_target;
            type *right_target;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.left));
                    /* VERIFIED */
            assert(value_is_valid(key_value)); /* VERIFIED */
            left_target = map_target_type(base_type->u.intersection.left,
                    key_value, bound_direction, location, the_jumper);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(left_target == NULL);
                return NULL;
              }
            assert(left_target != NULL);
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type->u.intersection.right));
                    /* VERIFIED */
            assert(value_is_valid(key_value)); /* VERIFIED */
            right_target = map_target_type(base_type->u.intersection.right,
                    key_value, bound_direction, location, the_jumper);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(right_target == NULL);
                type_remove_reference(left_target, the_jumper);
                return NULL;
              }
            assert(right_target != NULL);
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_intersection_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_target, the_jumper);
            type_remove_reference(right_target, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_UNION:
          {
            type *left_target;
            type *right_target;
            type *result;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.union_type.left)); /* VERIFIED */
            assert(value_is_valid(key_value)); /* VERIFIED */
            left_target = map_target_type(base_type->u.union_type.left,
                    key_value, bound_direction, location, the_jumper);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(left_target == NULL);
                return NULL;
              }
            assert(left_target != NULL);
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.union_type.right));
                    /* VERIFIED */
            assert(value_is_valid(key_value)); /* VERIFIED */
            right_target = map_target_type(base_type->u.union_type.right,
                    key_value, bound_direction, location, the_jumper);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(right_target == NULL);
                type_remove_reference(left_target, the_jumper);
                return NULL;
              }
            assert(right_target != NULL);
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_union_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_target, the_jumper);
            type_remove_reference(right_target, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_XOR:
          {
            type *left_target;
            type *right_target;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.xor.left)); /* VERIFIED */
            assert(value_is_valid(key_value)); /* VERIFIED */
            left_target = map_target_type(base_type->u.xor.left, key_value,
                    bound_direction, location, the_jumper);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(left_target == NULL);
                return NULL;
              }
            assert(left_target != NULL);
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.xor.right)); /* VERIFIED */
            assert(value_is_valid(key_value)); /* VERIFIED */
            right_target = map_target_type(base_type->u.xor.right, key_value,
                    bound_direction, location, the_jumper);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(right_target == NULL);
                type_remove_reference(left_target, the_jumper);
                return NULL;
              }
            assert(right_target != NULL);
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_union_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_target, the_jumper);
            type_remove_reference(right_target, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ARRAY:
          {
            o_integer key_oi;
            int order;
            type *result;

            if (get_value_kind(key_value) != VK_INTEGER)
                goto definitely_nothing;

            key_oi = integer_value_data(key_value);
            assert(!(oi_out_of_memory(key_oi)));

            order = oi_structural_order(key_oi,
                                        base_type->u.array.lower_bound);
            if (order == -2)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            if (order < 0)
                goto definitely_nothing;

            order = oi_structural_order(key_oi,
                                        base_type->u.array.upper_bound);
            if (order == -2)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            if (order > 0)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            result = base_type->u.array.base;
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            type_add_reference(result);
            return result;
          }
        case TK_INTEGER_RANGES:
        case TK_RATIONAL_RANGES:
        case TK_POINTER:
        case TK_TYPE:
          {
            goto definitely_nothing;
          }
        case TK_MAP:
          {
            boolean doubt;
            boolean is_in;
            type *result;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.map.key)); /* VERIFIED */
            is_in = value_is_in_type(key_value, base_type->u.map.key, &doubt,
                                     NULL, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;
            if (doubt)
              {
                if (bound_direction == LOU_LOWER)
                    goto definitely_nothing;
              }
            else
              {
                if (!is_in)
                    goto definitely_nothing;
              }

            assert(type_is_valid(base_type)); /* VERIFIED */
            result = base_type->u.map.target;
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            type_add_reference(result);
            return result;
          }
        case TK_ROUTINE:
        case TK_FIELDS:
        case TK_LEPTON:
        case TK_MULTISET:
        case TK_INTERFACE:
          {
            goto definitely_nothing;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            o_integer key_oi;
            size_t element_count;
            o_integer count_oi;
            int order;
            size_t component_num;
            verdict the_verdict;
            type *result;

            if (get_value_kind(key_value) != VK_INTEGER)
                goto definitely_nothing;

            key_oi = integer_value_data(key_value);
            assert(!(oi_out_of_memory(key_oi)));

            if (oi_kind(key_oi) != IIK_FINITE)
                goto definitely_nothing;

            if (oi_is_negative(key_oi))
                goto definitely_nothing;

            element_count = base_type->u.semi_labeled_value_list.element_count;
            oi_create_from_size_t(count_oi, element_count);
            if (oi_out_of_memory(count_oi))
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            order = oi_structural_order(count_oi, key_oi);
            oi_remove_reference(count_oi);
            if (order == -2)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            if (order <= 0)
              {
                type *result;

                if (!(base_type->u.semi_labeled_value_list.
                              extra_elements_allowed))
                  {
                    goto definitely_nothing;
                  }
                result = get_anything_type();
                if (result != NULL)
                    type_add_reference(result);
                assert((result == NULL) || type_is_valid(result));
                        /* VERIFIED */
                return result;
              }

            the_verdict = oi_magnitude_to_size_t(key_oi, &component_num);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            assert(component_num < element_count);

            assert(type_is_valid(base_type)); /* VERIFIED */
            result = base_type->u.semi_labeled_value_list.element_types[
                    component_num];
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            type_add_reference(result);
            return result;
          }
        case TK_REGULAR_EXPRESSION:
        case TK_CLASS:
          {
            goto definitely_nothing;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            type *result;

          unknown:
            if (bound_direction == LOU_LOWER)
                result = get_nothing_type();
            else
                result = get_anything_type();
            if (result != NULL)
                type_add_reference(result);
            else
                jumper_do_abort(the_jumper);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return NULL;
          }
        default:
          {
            assert(FALSE);
            return NULL;
          }
      }
  }

extern type *map_target_type_from_key_type(type *base_type, type *key_type,
        lower_or_upper bound_direction, const source_location *location,
        jumper *the_jumper)
  {
    assert(base_type != NULL);
    assert(key_type != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(base_type)); /* VERIFIED */
    assert(type_is_valid(key_type)); /* VERIFIED */

    switch (base_type->kind)
      {
        case TK_ANYTHING:
          {
            type_add_reference(base_type);
            assert(type_is_valid(base_type)); /* VERIFIED */
            return base_type;
          }
        case TK_NOTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
          {
            type *result;

          definitely_nothing:
            result = get_nothing_type();
            if (result != NULL)
                type_add_reference(result);
            else
                jumper_do_abort(the_jumper);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ENUMERATION:
          {
            type *result;
            size_t source_count;
            size_t source_num;

            result = get_nothing_type();
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            type_add_reference(result);
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */

            source_count = base_type->u.enumeration.value_count;

            for (source_num = 0; source_num < source_count; ++source_num)
              {
                value *this_value;

                assert(type_is_valid(base_type)); /* VERIFIED */
                this_value = base_type->u.enumeration.values[source_num];
                assert(this_value != NULL);
                assert(value_is_valid(this_value)); /* VERIFIED */

                switch (get_value_kind(this_value))
                  {
                    case VK_MAP:
                      {
                        size_t item_count;
                        size_t item_num;

                        item_count = map_value_item_count(this_value);

                        for (item_num = 0; item_num < item_count; ++item_num)
                          {
                            boolean definitely_touchable;
                            boolean doubt;
                            boolean is_in;
                            value *target_value;
                            value *target_values[1];
                            type *target_type;
                            type *new_result;

                            definitely_touchable =
                                    map_value_item_is_definitely_touchable(
                                            this_value, item_num, location,
                                            the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }
                            if ((bound_direction == LOU_LOWER) &&
                                (!definitely_touchable))
                              {
                                continue;
                              }

                            if (map_value_item_is_type(this_value, item_num))
                              {
                                type *filter_type;

                                if (bound_direction == LOU_LOWER)
                                    continue;

                                filter_type = map_value_item_key_type(
                                        this_value, item_num);
                                assert(filter_type != NULL);
                                assert(type_is_valid(filter_type));
                                        /* VERIFIED */

                                assert(type_is_valid(key_type)); /* VERIFIED */
                                is_in = !(intersection_empty(filter_type,
                                        key_type, &doubt, location,
                                        the_jumper));
                              }
                            else
                              {
                                value *key_value;

                                key_value = map_value_item_key_value(
                                        this_value, item_num);
                                assert(key_value != NULL);
                                assert(value_is_valid(key_value));
                                        /* VERIFIED */

                                assert(type_is_valid(key_type)); /* VERIFIED */
                                is_in = value_is_in_type(key_value, key_type,
                                        &doubt, NULL, location, the_jumper);
                              }

                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }

                            if (doubt)
                              {
                                if (bound_direction == LOU_LOWER)
                                    continue;
                              }
                            else
                              {
                                if (!is_in)
                                    continue;
                              }

                            target_value = map_value_item_target(this_value,
                                                                 item_num);
                            assert(target_value != NULL);
                            assert(value_is_valid(target_value));
                                    /* VERIFIED */

                            target_values[0] = target_value;
                            assert(value_is_valid(target_values[0]));
                                    /* VERIFIED */
                            target_type = get_enumeration_type(1,
                                    &(target_values[0]));
                            assert((target_type == NULL) ||
                                   type_is_valid(target_type)); /* VERIFIED */
                            if (target_type == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }

                            assert(type_is_valid(result)); /* VERIFIED */
                            assert(type_is_valid(target_type)); /* VERIFIED */
                            new_result = get_union_type(result, target_type);
                            assert((new_result == NULL) ||
                                   type_is_valid(new_result)); /* VERIFIED */
                            if (new_result == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                type_remove_reference(target_type, the_jumper);
                                return NULL;
                              }
                            assert(type_is_valid(new_result)); /* VERIFIED */
                            type_remove_reference(result, the_jumper);
                            type_remove_reference(target_type, the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                type_remove_reference(new_result, the_jumper);
                                return NULL;
                              }
                            result = new_result;
                            assert(result != NULL);
                            assert(type_is_valid(result)); /* VERIFIED */
                          }

                        break;
                      }
                    case VK_SEMI_LABELED_VALUE_LIST:
                      {
                        size_t component_count;
                        size_t component_num;

                        component_count = value_component_count(this_value);

                        for (component_num = 0;
                             component_num < component_count; ++component_num)
                          {
                            value *target_value;
                            o_integer key_oi;
                            value *key_value;
                            boolean doubt;
                            boolean is_in;
                            value *target_values[1];
                            type *target_type;
                            type *new_result;

                            target_value = value_component_value(this_value,
                                    component_num);
                            if (target_value == NULL)
                                continue;
                            assert(value_is_valid(target_value));
                                    /* VERIFIED */

                            oi_create_from_size_t(key_oi, component_num);
                            if (oi_out_of_memory(key_oi))
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }

                            key_value = create_integer_value(key_oi);
                            oi_remove_reference(key_oi);
                            if (key_value == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }

                            assert(type_is_valid(key_type)); /* VERIFIED */
                            is_in = value_is_in_type(key_value, key_type,
                                    &doubt, NULL, location, the_jumper);
                            value_remove_reference(key_value, the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }
                            if (doubt)
                              {
                                if (bound_direction == LOU_LOWER)
                                    continue;
                              }
                            else
                              {
                                if (!is_in)
                                    continue;
                              }

                            target_values[0] = target_value;
                            assert(value_is_valid(target_values[0]));
                                    /* VERIFIED */
                            target_type = get_enumeration_type(1,
                                    &(target_values[0]));
                            assert((target_type == NULL) ||
                                   type_is_valid(target_type)); /* VERIFIED */
                            if (target_type == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }

                            assert(type_is_valid(result)); /* VERIFIED */
                            assert(type_is_valid(target_type)); /* VERIFIED */
                            new_result = get_union_type(result, target_type);
                            assert((new_result == NULL) ||
                                   type_is_valid(new_result)); /* VERIFIED */
                            if (new_result == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                type_remove_reference(target_type, the_jumper);
                                return NULL;
                              }
                            assert(type_is_valid(new_result)); /* VERIFIED */
                            type_remove_reference(result, the_jumper);
                            type_remove_reference(target_type, the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                type_remove_reference(new_result, the_jumper);
                                return NULL;
                              }
                            result = new_result;
                            assert(result != NULL);
                            assert(type_is_valid(result)); /* VERIFIED */
                          }

                        break;
                      }
                    default:
                      {
                        continue;
                      }
                  }
              }

            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_NOT:
          {
            goto unknown;
          }
        case TK_INTERSECTION:
          {
            type *left_target;
            type *right_target;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.left));
                    /* VERIFIED */
            assert(type_is_valid(key_type)); /* VERIFIED */
            left_target = map_target_type_from_key_type(
                    base_type->u.intersection.left, key_type, bound_direction,
                    location, the_jumper);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(left_target == NULL);
                return NULL;
              }
            assert(left_target != NULL);
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.right));
                    /* VERIFIED */
            assert(type_is_valid(key_type)); /* VERIFIED */
            right_target = map_target_type_from_key_type(
                    base_type->u.intersection.right, key_type, bound_direction,
                    location, the_jumper);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(right_target == NULL);
                type_remove_reference(left_target, the_jumper);
                return NULL;
              }
            assert(right_target != NULL);
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_intersection_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_target, the_jumper);
            type_remove_reference(right_target, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_UNION:
          {
            type *left_target;
            type *right_target;
            type *result;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.union_type.left)); /* VERIFIED */
            assert(type_is_valid(key_type)); /* VERIFIED */
            left_target = map_target_type_from_key_type(
                    base_type->u.union_type.left, key_type, bound_direction,
                    location, the_jumper);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(left_target == NULL);
                return NULL;
              }
            assert(left_target != NULL);
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.union_type.right));
                    /* VERIFIED */
            assert(type_is_valid(key_type)); /* VERIFIED */
            right_target = map_target_type_from_key_type(
                    base_type->u.union_type.right, key_type, bound_direction,
                    location, the_jumper);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(right_target == NULL);
                type_remove_reference(left_target, the_jumper);
                return NULL;
              }
            assert(right_target != NULL);
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_union_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_target, the_jumper);
            type_remove_reference(right_target, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_XOR:
          {
            type *left_target;
            type *right_target;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.xor.left)); /* VERIFIED */
            assert(type_is_valid(key_type)); /* VERIFIED */
            left_target = map_target_type_from_key_type(base_type->u.xor.left,
                    key_type, bound_direction, location, the_jumper);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(left_target == NULL);
                return NULL;
              }
            assert(left_target != NULL);
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.xor.right)); /* VERIFIED */
            assert(type_is_valid(key_type)); /* VERIFIED */
            right_target = map_target_type_from_key_type(
                    base_type->u.xor.right, key_type, bound_direction,
                    location, the_jumper);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(right_target == NULL);
                type_remove_reference(left_target, the_jumper);
                return NULL;
              }
            assert(right_target != NULL);
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_union_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_target, the_jumper);
            type_remove_reference(right_target, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ARRAY:
          {
            type *range;
            boolean doubt;
            boolean no_match;
            type *result;

            range = get_integer_range_type(base_type->u.array.lower_bound,
                    base_type->u.array.upper_bound, TRUE, TRUE);
            if (range == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(type_is_valid(key_type)); /* VERIFIED */
            assert(type_is_valid(range)); /* VERIFIED */
            no_match = intersection_empty(key_type, range, &doubt, location,
                                          the_jumper);
            type_remove_reference(range, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;
            if (doubt)
              {
                if (bound_direction == LOU_LOWER)
                    goto definitely_nothing;
              }
            else
              {
                if (no_match)
                    goto definitely_nothing;
              }

            assert(type_is_valid(base_type)); /* VERIFIED */
            result = base_type->u.array.base;
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            type_add_reference(result);
            return result;
          }
        case TK_INTEGER_RANGES:
        case TK_RATIONAL_RANGES:
        case TK_POINTER:
        case TK_TYPE:
          {
            goto definitely_nothing;
          }
        case TK_MAP:
          {
            boolean doubt;
            boolean no_match;
            type *result;

            assert(type_is_valid(key_type)); /* VERIFIED */
            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.map.key)); /* VERIFIED */
            no_match = intersection_empty(key_type, base_type->u.map.key,
                                          &doubt, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;
            if (doubt)
              {
                if (bound_direction == LOU_LOWER)
                    goto definitely_nothing;
              }
            else
              {
                if (no_match)
                    goto definitely_nothing;
              }

            assert(type_is_valid(base_type)); /* VERIFIED */
            result = base_type->u.map.target;
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            type_add_reference(result);
            return result;
          }
        case TK_ROUTINE:
        case TK_FIELDS:
        case TK_LEPTON:
        case TK_MULTISET:
        case TK_INTERFACE:
          {
            goto definitely_nothing;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            type *result;
            size_t element_count;
            size_t element_num;

            result = get_nothing_type();
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            type_add_reference(result);
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */

            element_count = base_type->u.semi_labeled_value_list.element_count;

            for (element_num = 0; element_num < element_count; ++element_num)
              {
                o_integer key_oi;
                value *key_value;
                boolean doubt;
                boolean is_in;
                type *element_type;
                type *new_result;

                oi_create_from_size_t(key_oi, element_num);
                if (oi_out_of_memory(key_oi))
                  {
                    jumper_do_abort(the_jumper);
                    type_remove_reference(result, the_jumper);
                    return NULL;
                  }

                key_value = create_integer_value(key_oi);
                oi_remove_reference(key_oi);
                if (key_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    type_remove_reference(result, the_jumper);
                    return NULL;
                  }

                assert(type_is_valid(key_type)); /* VERIFIED */
                is_in = value_is_in_type(key_value, key_type, &doubt, NULL,
                                         location, the_jumper);
                value_remove_reference(key_value, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    jumper_do_abort(the_jumper);
                    type_remove_reference(result, the_jumper);
                    return NULL;
                  }
                if (doubt)
                  {
                    if (bound_direction == LOU_LOWER)
                        continue;
                  }
                else
                  {
                    if (!is_in)
                        continue;
                  }

                assert(type_is_valid(base_type)); /* VERIFIED */
                element_type = base_type->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);
                assert(type_is_valid(element_type)); /* VERIFIED */

                assert(type_is_valid(result)); /* VERIFIED */
                assert(type_is_valid(element_type)); /* VERIFIED */
                new_result = get_union_type(result, element_type);
                assert((new_result == NULL) || type_is_valid(new_result));
                        /* VERIFIED */
                if (new_result == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    type_remove_reference(result, the_jumper);
                    return NULL;
                  }

                type_remove_reference(result, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    type_remove_reference(new_result, the_jumper);
                    return NULL;
                  }

                result = new_result;
                assert(result != NULL);
                assert(type_is_valid(result)); /* VERIFIED */
              }

            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_REGULAR_EXPRESSION:
        case TK_CLASS:
          {
            goto definitely_nothing;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            type *result;

          unknown:
            if (bound_direction == LOU_LOWER)
                result = get_nothing_type();
            else
                result = get_anything_type();
            if (result != NULL)
                type_add_reference(result);
            else
                jumper_do_abort(the_jumper);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return NULL;
          }
        default:
          {
            assert(FALSE);
            return NULL;
          }
      }
  }

extern type *get_map_key_type(type *base_type, lower_or_upper bound_direction,
                              jumper *the_jumper)
  {
    assert(base_type != NULL);

    assert(type_is_valid(base_type)); /* VERIFIED */

    switch (base_type->kind)
      {
        case TK_ANYTHING:
          {
            type_add_reference(base_type);
            assert(type_is_valid(base_type)); /* VERIFIED */
            return base_type;
          }
        case TK_NOTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
          {
            type *result;

          definitely_nothing:
            result = get_nothing_type();
            if (result != NULL)
                type_add_reference(result);
            else
                jumper_do_abort(the_jumper);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ENUMERATION:
          {
            type *result;
            size_t source_count;
            size_t source_num;

            result = get_nothing_type();
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            type_add_reference(result);
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */

            source_count = base_type->u.enumeration.value_count;

            for (source_num = 0; source_num < source_count; ++source_num)
              {
                value *this_value;

                assert(type_is_valid(base_type)); /* VERIFIED */
                this_value = base_type->u.enumeration.values[source_num];
                assert(this_value != NULL);
                assert(value_is_valid(this_value)); /* VERIFIED */

                switch (get_value_kind(this_value))
                  {
                    case VK_MAP:
                      {
                        size_t item_count;
                        size_t item_num;

                        item_count = map_value_item_count(this_value);

                        for (item_num = 0; item_num < item_count; ++item_num)
                          {
                            type *key_type;
                            type *new_result;

                            if (map_value_item_is_type(this_value, item_num))
                              {
                                assert(value_is_valid(this_value));
                                        /* VERIFIED */
                                key_type = map_value_item_key_type(this_value,
                                                                   item_num);
                                assert(key_type != NULL);
                                assert(type_is_valid(key_type)); /* VERIFIED */
                                type_add_reference(key_type);
                              }
                            else
                              {
                                value *key_value;
                                value *key_values[1];

                                assert(value_is_valid(this_value));
                                        /* VERIFIED */
                                key_value = map_value_item_key_value(
                                        this_value, item_num);
                                assert(key_value != NULL);
                                assert(value_is_valid(key_value));
                                        /* VERIFIED */

                                key_values[0] = key_value;
                                assert(value_is_valid(key_values[0]));
                                        /* VERIFIED */
                                key_type = get_enumeration_type(1,
                                        &(key_values[0]));
                                assert((key_type == NULL) ||
                                       type_is_valid(key_type)); /* VERIFIED */
                                if (key_type == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    type_remove_reference(result, the_jumper);
                                    return NULL;
                                  }
                              }

                            assert(key_type != NULL);
                            assert(type_is_valid(result)); /* VERIFIED */
                            assert(type_is_valid(key_type)); /* VERIFIED */
                            new_result = get_union_type(result, key_type);
                            assert((new_result == NULL) ||
                                   type_is_valid(new_result)); /* VERIFIED */
                            if (new_result == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                type_remove_reference(key_type, the_jumper);
                                return NULL;
                              }
                            assert(new_result != NULL);
                            assert(type_is_valid(new_result)); /* VERIFIED */
                            type_remove_reference(result, the_jumper);
                            type_remove_reference(key_type, the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                                return NULL;
                            result = new_result;
                            assert(result != NULL);
                            assert(type_is_valid(result)); /* VERIFIED */
                          }

                        break;
                      }
                    case VK_SEMI_LABELED_VALUE_LIST:
                      {
                        size_t component_count;
                        size_t component_num;

                        component_count = value_component_count(this_value);

                        for (component_num = 0;
                             component_num < component_count; ++component_num)
                          {
                            o_integer key_oi;
                            value *key_value;
                            value *key_values[1];
                            type *key_type;
                            type *new_result;

                            if (value_component_value(this_value,
                                                      component_num) == NULL)
                              {
                                continue;
                              }

                            oi_create_from_size_t(key_oi, component_num);
                            if (oi_out_of_memory(key_oi))
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }

                            key_value = create_integer_value(key_oi);
                            oi_remove_reference(key_oi);
                            if (key_value == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }
                            assert(value_is_valid(key_value)); /* VERIFIED */

                            key_values[0] = key_value;
                            assert(value_is_valid(key_values[0]));
                                    /* VERIFIED */
                            key_type =
                                    get_enumeration_type(1, &(key_values[0]));
                            assert((key_type == NULL) ||
                                   type_is_valid(key_type)); /* VERIFIED */
                            if (key_type == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(key_value, the_jumper);
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }

                            value_remove_reference(key_value, the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                type_remove_reference(result, the_jumper);
                                return NULL;
                              }

                            assert(type_is_valid(result)); /* VERIFIED */
                            assert(type_is_valid(key_type)); /* VERIFIED */
                            new_result = get_union_type(result, key_type);
                            assert((new_result == NULL) ||
                                   type_is_valid(new_result)); /* VERIFIED */
                            if (new_result == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                type_remove_reference(result, the_jumper);
                                type_remove_reference(key_type, the_jumper);
                                return NULL;
                              }
                            assert(new_result != NULL);
                            assert(type_is_valid(new_result)); /* VERIFIED */
                            type_remove_reference(result, the_jumper);
                            type_remove_reference(key_type, the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                                return NULL;
                            result = new_result;
                            assert(result != NULL);
                            assert(type_is_valid(result)); /* VERIFIED */
                          }

                        break;
                      }
                    default:
                      {
                        continue;
                      }
                  }
              }

            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_NOT:
          {
            goto unknown;
          }
        case TK_INTERSECTION:
          {
            type *left_key;
            type *right_key;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.left));
                    /* VERIFIED */
            left_key = get_map_key_type(base_type->u.intersection.left,
                                        bound_direction, the_jumper);
            assert((left_key == NULL) || type_is_valid(left_key));
                    /* VERIFIED */
            if (left_key == NULL)
                return NULL;
            assert(type_is_valid(left_key)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.right));
                    /* VERIFIED */
            right_key = get_map_key_type(base_type->u.intersection.right,
                                         bound_direction, the_jumper);
            assert((right_key == NULL) || type_is_valid(right_key));
                    /* VERIFIED */
            if (right_key == NULL)
              {
                type_remove_reference(left_key, the_jumper);
                return NULL;
              }
            assert(type_is_valid(right_key)); /* VERIFIED */

            assert(type_is_valid(left_key)); /* VERIFIED */
            assert(type_is_valid(right_key)); /* VERIFIED */
            result = get_intersection_type(left_key, right_key);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_key, the_jumper);
            type_remove_reference(right_key, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_UNION:
          {
            type *left_key;
            type *right_key;
            type *result;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.union_type.left)); /* VERIFIED */
            left_key = get_map_key_type(base_type->u.union_type.left,
                                        bound_direction, the_jumper);
            assert((left_key == NULL) || type_is_valid(left_key));
                    /* VERIFIED */
            if (left_key == NULL)
                return NULL;
            assert(type_is_valid(left_key)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.union_type.right));
                    /* VERIFIED */
            right_key = get_map_key_type(base_type->u.union_type.right,
                                         bound_direction, the_jumper);
            assert((right_key == NULL) || type_is_valid(right_key));
                    /* VERIFIED */
            if (right_key == NULL)
              {
                type_remove_reference(left_key, the_jumper);
                return NULL;
              }
            assert(type_is_valid(right_key)); /* VERIFIED */

            assert(type_is_valid(left_key)); /* VERIFIED */
            assert(type_is_valid(right_key)); /* VERIFIED */
            result = get_union_type(left_key, right_key);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_key, the_jumper);
            type_remove_reference(right_key, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_XOR:
          {
            type *left_key;
            type *right_key;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.xor.left)); /* VERIFIED */
            left_key = get_map_key_type(base_type->u.xor.left, bound_direction,
                                        the_jumper);
            assert((left_key == NULL) || type_is_valid(left_key));
                    /* VERIFIED */
            if (left_key == NULL)
                return NULL;
            assert(type_is_valid(left_key)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.xor.right)); /* VERIFIED */
            right_key = get_map_key_type(base_type->u.xor.right,
                                         bound_direction, the_jumper);
            assert((right_key == NULL) || type_is_valid(right_key));
                    /* VERIFIED */
            if (right_key == NULL)
              {
                type_remove_reference(left_key, the_jumper);
                return NULL;
              }
            assert(type_is_valid(right_key)); /* VERIFIED */

            assert(type_is_valid(left_key)); /* VERIFIED */
            assert(type_is_valid(right_key)); /* VERIFIED */
            result = get_union_type(left_key, right_key);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if (result == NULL)
                jumper_do_abort(the_jumper);
            type_remove_reference(left_key, the_jumper);
            type_remove_reference(right_key, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ARRAY:
          {
            type *result;

            result = get_integer_range_type(base_type->u.array.lower_bound,
                    base_type->u.array.upper_bound, TRUE, TRUE);
            if (result == NULL)
                jumper_do_abort(the_jumper);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_INTEGER_RANGES:
        case TK_RATIONAL_RANGES:
        case TK_POINTER:
        case TK_TYPE:
          {
            goto definitely_nothing;
          }
        case TK_MAP:
          {
            type *result;

            assert(type_is_valid(base_type)); /* VERIFIED */
            result = base_type->u.map.key;
            assert(result != NULL);
            type_add_reference(result);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ROUTINE:
        case TK_FIELDS:
        case TK_LEPTON:
        case TK_MULTISET:
        case TK_INTERFACE:
          {
            goto definitely_nothing;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t element_count;
            o_integer upper_oi;
            type *result;
            size_t element_num;

            element_count = base_type->u.semi_labeled_value_list.element_count;

            if (base_type->u.semi_labeled_value_list.extra_elements_allowed)
              {
                upper_oi = oi_positive_infinity;
                oi_add_reference(upper_oi);
              }
            else
              {
                if (element_count == 0)
                    goto definitely_nothing;
                oi_create_from_size_t(upper_oi, element_count);
              }
            if (oi_out_of_memory(upper_oi))
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            result = get_integer_range_type(oi_zero, upper_oi, TRUE, FALSE);
            oi_remove_reference(upper_oi);
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            type_add_reference(result);
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */

            for (element_num = 0; element_num < element_count; ++element_num)
              {
                type *element_type;
                boolean exception;

                assert(type_is_valid(base_type)); /* VERIFIED */
                element_type = base_type->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);

                assert(type_is_valid(element_type)); /* VERIFIED */
                if (element_type->kind == TK_NOTHING)
                  {
                    exception = TRUE;
                  }
                else if (possibly_nothing(element_type))
                  {
                    if (bound_direction == LOU_LOWER)
                        exception = TRUE;
                    else
                        exception = FALSE;
                  }
                else
                  {
                    exception = FALSE;
                  }

                if (exception)
                  {
                    o_integer exception_oi;
                    value *exception_value;
                    value *exception_values[1];
                    type *enum_type;
                    type *not_type;
                    type *new_result;

                    oi_create_from_size_t(exception_oi, element_num);
                    if (oi_out_of_memory(exception_oi))
                      {
                        jumper_do_abort(the_jumper);
                        type_remove_reference(result, the_jumper);
                        return NULL;
                      }

                    exception_value = create_integer_value(exception_oi);
                    oi_remove_reference(exception_oi);
                    if (exception_value == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        type_remove_reference(result, the_jumper);
                        return NULL;
                      }

                    assert(value_is_valid(exception_value)); /* VERIFIED */
                    exception_values[0] = exception_value;
                    assert(value_is_valid(exception_values[0])); /* VERIFIED */
                    enum_type =
                            get_enumeration_type(1, &(exception_values[0]));
                    assert((enum_type == NULL) || type_is_valid(enum_type));
                            /* VERIFIED */
                    if (enum_type == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(exception_value, the_jumper);
                        type_remove_reference(result, the_jumper);
                        return NULL;
                      }

                    value_remove_reference(exception_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        type_remove_reference(result, the_jumper);
                        return NULL;
                      }

                    assert(type_is_valid(enum_type)); /* VERIFIED */
                    not_type = get_not_type(enum_type);
                    if (not_type == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        type_remove_reference(enum_type, the_jumper);
                        type_remove_reference(result, the_jumper);
                        return NULL;
                      }

                    type_remove_reference(enum_type, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        type_remove_reference(not_type, the_jumper);
                        type_remove_reference(result, the_jumper);
                        return NULL;
                      }

                    assert(type_is_valid(result)); /* VERIFIED */
                    assert(type_is_valid(not_type)); /* VERIFIED */
                    new_result = get_intersection_type(result, not_type);
                    assert((new_result == NULL) || type_is_valid(new_result));
                            /* VERIFIED */
                    if (new_result == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        type_remove_reference(not_type, the_jumper);
                        type_remove_reference(result, the_jumper);
                        return NULL;
                      }
                    assert(new_result != NULL);
                    assert(type_is_valid(new_result)); /* VERIFIED */

                    type_remove_reference(not_type, the_jumper);
                    type_remove_reference(result, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                        return NULL;

                    result = new_result;
                    assert(result != NULL);
                    assert(type_is_valid(result)); /* VERIFIED */
                  }
              }

            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_REGULAR_EXPRESSION:
        case TK_CLASS:
          {
            goto definitely_nothing;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            type *result;

          unknown:
            if (bound_direction == LOU_LOWER)
                result = get_nothing_type();
            else
                result = get_anything_type();
            if (result != NULL)
                type_add_reference(result);
            else
                jumper_do_abort(the_jumper);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return NULL;
          }
        default:
          {
            assert(FALSE);
            return NULL;
          }
      }
  }

extern type *type_field(type *base_type, const char *field_name,
                        lower_or_upper bound_direction)
  {
    assert(base_type != NULL);
    assert(field_name != NULL);

    assert(type_is_valid(base_type)); /* VERIFIED */

    switch (base_type->kind)
      {
        case TK_ANYTHING:
          {
            type_add_reference(base_type);
            assert(type_is_valid(base_type)); /* VERIFIED */
            return base_type;
          }
        case TK_NOTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
          {
            type *result;

          definitely_nothing:
            result = get_nothing_type();
            if (result != NULL)
                type_add_reference(result);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ANY_LEPTON:
          {
            type *result;

          definitely_anything:
            result = get_anything_type();
            if (result != NULL)
                type_add_reference(result);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
          {
            goto definitely_nothing;
          }
        case TK_OBJECT:
          {
            goto definitely_anything;
          }
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
          {
            goto definitely_nothing;
          }
        case TK_ENUMERATION:
          {
            value_aa result_values;
            verdict the_verdict;
            size_t source_count;
            size_t source_num;
            type *result;

            the_verdict = value_aa_init(&result_values, 10);
            if (the_verdict != MISSION_ACCOMPLISHED)
                return NULL;

            source_count = base_type->u.enumeration.value_count;

            for (source_num = 0; source_num < source_count; ++source_num)
              {
                value *this_value;
                value *target;
                verdict the_verdict;

                assert(type_is_valid(base_type)); /* VERIFIED */
                this_value = base_type->u.enumeration.values[source_num];
                assert(this_value != NULL);
                assert(value_is_valid(this_value)); /* VERIFIED */

                switch (get_value_kind(this_value))
                  {
                    case VK_SEMI_LABELED_VALUE_LIST:
                    case VK_SEMI_LABELED_MULTI_SET:
                    case VK_LEPTON:
                      {
                        target = value_get_field(field_name, this_value);
                        if (target == NULL)
                            continue;
                        assert(value_is_valid(target)); /* VERIFIED */
                        break;
                      }
                    case VK_OBJECT:
                      {
                        free(result_values.array);
                        goto unknown;
                      }
                    default:
                      {
                        continue;
                      }
                  }

                assert(target != NULL);
                assert(value_is_valid(target)); /* VERIFIED */
                the_verdict = value_aa_append(&result_values, target);
                if (the_verdict != MISSION_ACCOMPLISHED)
                  {
                    free(result_values.array);
                    return NULL;
                  }
              }

            result = get_enumeration_type(result_values.element_count,
                                          result_values.array);
            free(result_values.array);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_NOT:
          {
            goto unknown;
          }
        case TK_INTERSECTION:
          {
            type *left_target;
            type *right_target;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.left));
                    /* VERIFIED */
            left_target = type_field(base_type->u.intersection.left,
                                     field_name, bound_direction);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (left_target == NULL)
                return NULL;
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.right));
                    /* VERIFIED */
            right_target = type_field(base_type->u.intersection.right,
                                      field_name, bound_direction);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (right_target == NULL)
              {
                type_remove_reference(left_target, NULL);
                return NULL;
              }
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_intersection_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            type_remove_reference(left_target, NULL);
            type_remove_reference(right_target, NULL);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_UNION:
          {
            type *left_target;
            type *right_target;
            type *result;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.union_type.left)); /* VERIFIED */
            left_target = type_field(base_type->u.union_type.left, field_name,
                                     bound_direction);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (left_target == NULL)
                return NULL;
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.union_type.right));
                    /* VERIFIED */
            right_target = type_field(base_type->u.union_type.right,
                                      field_name, bound_direction);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (right_target == NULL)
              {
                type_remove_reference(left_target, NULL);
                return NULL;
              }
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_union_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            type_remove_reference(left_target, NULL);
            type_remove_reference(right_target, NULL);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_XOR:
          {
            type *left_target;
            type *right_target;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto definitely_nothing;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.xor.left)); /* VERIFIED */
            left_target = type_field(base_type->u.xor.left, field_name,
                                     bound_direction);
            assert((left_target == NULL) || type_is_valid(left_target));
                    /* VERIFIED */
            if (left_target == NULL)
                return NULL;
            assert(type_is_valid(left_target)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.xor.right)); /* VERIFIED */
            right_target = type_field(base_type->u.xor.right, field_name,
                                      bound_direction);
            assert((right_target == NULL) || type_is_valid(right_target));
                    /* VERIFIED */
            if (right_target == NULL)
              {
                type_remove_reference(left_target, NULL);
                return NULL;
              }
            assert(type_is_valid(right_target)); /* VERIFIED */

            assert(type_is_valid(left_target)); /* VERIFIED */
            assert(type_is_valid(right_target)); /* VERIFIED */
            result = get_union_type(left_target, right_target);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            type_remove_reference(left_target, NULL);
            type_remove_reference(right_target, NULL);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_ARRAY:
        case TK_INTEGER_RANGES:
        case TK_RATIONAL_RANGES:
        case TK_POINTER:
        case TK_TYPE:
        case TK_MAP:
        case TK_ROUTINE:
          {
            goto definitely_nothing;
          }
        case TK_FIELDS:
          {
            assert(type_is_valid(base_type)); /* VERIFIED */
            return field_info_field(&(base_type->u.fields.field_info),
                                    field_name, bound_direction);
          }
        case TK_LEPTON:
          {
            assert(type_is_valid(base_type)); /* VERIFIED */
            return field_info_field(&(base_type->u.lepton.field_info),
                                    field_name, bound_direction);
          }
        case TK_MULTISET:
          {
            assert(type_is_valid(base_type)); /* VERIFIED */
            return field_info_field(&(base_type->u.multiset.field_info),
                                    field_name, bound_direction);
          }
        case TK_INTERFACE:
          {
            assert(type_is_valid(base_type)); /* VERIFIED */
            return field_info_field(&(base_type->u.interface.field_info),
                                    field_name, bound_direction);
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t element_count;
            string_index *allowed_fields;
            size_t element_num;
            type *result;

            element_count = base_type->u.semi_labeled_value_list.element_count;

            allowed_fields =
                    base_type->u.semi_labeled_value_list.allowed_fields;
            assert(allowed_fields != NULL);

            if (!(exists_in_string_index(allowed_fields, field_name)))
              {
                type *result;
                size_t element_num;

                if (base_type->u.semi_labeled_value_list.
                            extra_elements_allowed)
                  {
                    goto definitely_anything;
                  }

                result = get_nothing_type();
                if (result == NULL)
                    return NULL;
                type_add_reference(result);
                assert(result != NULL);
                assert(type_is_valid(result)); /* VERIFIED */

                for (element_num = 0; element_num < element_count;
                     ++element_num)
                  {
                    type *element_type;
                    type *new_result;

                    if (base_type->u.semi_labeled_value_list.element_names[
                                element_num] != NULL)
                      {
                        continue;
                      }

                    assert(type_is_valid(base_type)); /* VERIFIED */
                    element_type = base_type->u.semi_labeled_value_list.
                            element_types[element_num];
                    assert(element_type != NULL);
                    assert(type_is_valid(result)); /* VERIFIED */
                    assert(type_is_valid(element_type)); /* VERIFIED */
                    new_result = get_union_type(result, element_type);
                    assert((new_result == NULL) || type_is_valid(new_result));
                            /* VERIFIED */
                    type_remove_reference(result, NULL);
                    if (new_result == NULL)
                        return NULL;
                    assert(type_is_valid(new_result)); /* VERIFIED */
                    result = new_result;
                    assert(result != NULL);
                    assert(type_is_valid(result)); /* VERIFIED */
                  }

                assert(result != NULL);
                assert(type_is_valid(result)); /* VERIFIED */
                return result;
              }

            element_num = (size_t)(lookup_in_string_index(allowed_fields,
                                                          field_name));
            assert(element_num < element_count);
            assert(base_type->u.semi_labeled_value_list.element_names[
                           element_num] != NULL);
            assert(strcmp(base_type->u.semi_labeled_value_list.element_names[
                                  element_num], field_name) == 0);

            assert(type_is_valid(base_type)); /* VERIFIED */
            result = base_type->u.semi_labeled_value_list.element_types[
                    element_num];
            assert(result != NULL);
            type_add_reference(result);
            assert(type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_REGULAR_EXPRESSION:
          {
            goto definitely_nothing;
          }
        case TK_CLASS:
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            type *result;

          unknown:
            if (bound_direction == LOU_LOWER)
                result = get_nothing_type();
            else
                result = get_anything_type();
            if (result != NULL)
                type_add_reference(result);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return NULL;
          }
        default:
          {
            assert(FALSE);
            return NULL;
          }
      }
  }

extern type *augment_write_type_from_read_type(type *write_type,
        type *read_type, const char *field_name,
        lower_or_upper bound_direction, variable_instance **base_variable)
  {
    assert(write_type != NULL);
    assert(read_type != NULL);
    assert(field_name != NULL);

    assert(type_is_valid(write_type)); /* VERIFIED */
    assert(type_is_valid(read_type)); /* VERIFIED */

    switch (read_type->kind)
      {
        case TK_ANYTHING:
        case TK_OBJECT:
          {
            type *result;

          do_anything:
            type_remove_reference(write_type, NULL);
          do_anything_no_ref:
            if (base_variable != NULL)
                *base_variable = NULL;
            result = get_anything_type();
            if (result != NULL)
                type_add_reference(result);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            return result;
          }
        case TK_NOTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
        case TK_ARRAY:
        case TK_INTEGER_RANGES:
        case TK_RATIONAL_RANGES:
        case TK_POINTER:
        case TK_TYPE:
        case TK_MAP:
        case TK_ROUTINE:
        case TK_LEPTON:
        case TK_MULTISET:
        case TK_SEMI_LABELED_VALUE_LIST:
        case TK_REGULAR_EXPRESSION:
          {
          do_nothing:
            assert(type_is_valid(write_type)); /* VERIFIED */
            return write_type;
          }
        case TK_ENUMERATION:
          {
            type *additional;
            object *object_seen;
            boolean non_object_possible;
            size_t value_count;
            size_t value_num;
            type *result;

            additional = NULL;
            object_seen = NULL;
            non_object_possible = FALSE;
            value_count = read_type->u.enumeration.value_count;

            for (value_num = 0; value_num < value_count; ++value_num)
              {
                value *this_value;
                object *this_object;
                size_t field_num;
                variable_instance *field_instance;
                type *field_type;

                this_value = read_type->u.enumeration.values[value_num];
                assert(value_is_valid(this_value)); /* VERIFIED */
                if (get_value_kind(this_value) != VK_OBJECT)
                  {
                  do_no_match:
                    non_object_possible = TRUE;
                    if (bound_direction == LOU_LOWER)
                      {
                        if (additional != NULL)
                            type_remove_reference(additional, NULL);
                        goto do_nothing;
                      }
                    continue;
                  }
                assert(value_is_valid(this_value)); /* VERIFIED */
                this_object = object_value_data(this_value);
                assert(this_object != NULL);
                assert(!(object_is_closed(this_object))); /* VERIFIED */

                field_num = object_field_lookup(this_object, field_name);
                if (field_num >= object_field_count(this_object))
                  {
                    if ((bound_direction == LOU_UPPER) &&
                        !(object_is_complete(this_object)))
                      {
                        if (additional != NULL)
                            type_remove_reference(additional, NULL);
                        goto do_anything_no_ref;
                      }
                    goto do_no_match;
                  }

                if (!(object_field_is_variable(this_object, field_num)))
                    goto do_no_match;

                field_instance = object_field_variable(this_object, field_num);
                assert(field_instance != NULL);

                if (variable_declaration_is_immutable(
                            variable_instance_declaration(field_instance)))
                  {
                    goto do_no_match;
                  }

                if ((!(variable_instance_is_instantiated(field_instance))) ||
                    (variable_instance_scope_exited(field_instance)))
                  {
                  do_unknown:
                    if (additional != NULL)
                        type_remove_reference(additional, NULL);
                    goto unknown;
                  }

                if (object_seen == NULL)
                  {
                    object_seen = this_object;
                    if (base_variable != NULL)
                        *base_variable = field_instance;
                  }
                else if ((object_seen != this_object) &&
                         (base_variable != NULL))
                  {
                    *base_variable = NULL;
                  }

                assert(variable_instance_is_instantiated(field_instance));
                        /* VERIFIED */
                assert(!(variable_instance_scope_exited(field_instance)));
                        /* VERIFIED */
                field_type = variable_instance_type(field_instance);
                assert(field_type != NULL);

                if (!(type_is_valid(field_type)))
                    goto do_unknown;

                if (additional == NULL)
                  {
                    type_add_reference(field_type);
                    additional = field_type;
                    assert(type_is_valid(additional)); /* VERIFIED */
                  }
                else
                  {
                    type *new_type;

                    assert(type_is_valid(additional)); /* VERIFIED */
                    assert(type_is_valid(field_type)); /* VERIFIED */
                    new_type = get_union_type(additional, field_type);
                    type_remove_reference(additional, NULL);
                    if (new_type == NULL)
                      {
                        type_remove_reference(write_type, NULL);
                        if (base_variable != NULL)
                            *base_variable = NULL;
                        return NULL;
                      }

                    assert(type_is_valid(new_type)); /* VERIFIED */
                    additional = new_type;
                    assert(type_is_valid(additional)); /* VERIFIED */
                  }
              }

            assert((additional == NULL) || type_is_valid(additional));

            if (non_object_possible && (base_variable != NULL))
                *base_variable = NULL;

            if (additional == NULL)
                goto do_nothing;

            assert(type_is_valid(write_type)); /* VERIFIED */
            assert(type_is_valid(additional)); /* VERIFIED */
            result = get_union_type(write_type, additional);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            type_remove_reference(write_type, NULL);
            type_remove_reference(additional, NULL);
            if ((result == NULL) && (base_variable != NULL))
                *base_variable = NULL;
            return result;
          }
        case TK_NOT:
        case TK_XOR:
        case TK_CLASS:
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
          unknown:
            if (bound_direction == LOU_LOWER)
              {
                goto do_nothing;
              }
            else
              {
                assert(bound_direction == LOU_UPPER);
                goto do_anything;
              }
          }
        case TK_INTERSECTION:
          {
            variable_instance *base_left;
            type *left;
            variable_instance *base_right;
            type *right;
            type *result;

            base_left = ((base_variable == NULL) ? NULL : *base_variable);
            type_add_reference(write_type);
            assert(type_is_valid(write_type)); /* VERIFIED */
            assert(type_is_valid(read_type->u.intersection.left));
                    /* VERIFIED */
            left = augment_write_type_from_read_type(write_type,
                    read_type->u.intersection.left, field_name,
                    bound_direction, &base_left);
            if (left == NULL)
              {
                type_remove_reference(write_type, NULL);
                if (base_variable != NULL)
                    *base_variable = NULL;
                return NULL;
              }
            assert(type_is_valid(left)); /* VERIFIED */

            base_right = ((base_variable == NULL) ? NULL : *base_variable);
            assert(type_is_valid(write_type)); /* VERIFIED */
            assert(type_is_valid(read_type->u.intersection.right));
                    /* VERIFIED */
            right = augment_write_type_from_read_type(write_type,
                    read_type->u.intersection.right, field_name,
                    bound_direction, &base_right);
            if (right == NULL)
              {
                type_remove_reference(left, NULL);
                if (base_variable != NULL)
                    *base_variable = NULL;
                return NULL;
              }
            assert(type_is_valid(right)); /* VERIFIED */

            if (base_variable != NULL)
              {
                if (base_left == base_right)
                    *base_variable = base_left;
                else
                    *base_variable = NULL;
              }

            if (bound_direction == LOU_LOWER)
              {
                assert(type_is_valid(left)); /* VERIFIED */
                assert(type_is_valid(right)); /* VERIFIED */
                result = get_intersection_type(left, right);
                assert((result == NULL) || type_is_valid(result));
                        /* VERIFIED */
              }
            else
              {
                assert(bound_direction == LOU_UPPER);
                assert(type_is_valid(left)); /* VERIFIED */
                assert(type_is_valid(right)); /* VERIFIED */
                result = get_union_type(left, right);
                assert((result == NULL) || type_is_valid(result));
                        /* VERIFIED */
              }
            type_remove_reference(left, NULL);
            type_remove_reference(right, NULL);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if ((result == NULL) && (base_variable != NULL))
                *base_variable = NULL;
            return result;
          }
        case TK_UNION:
          {
            variable_instance *base_left;
            type *left;
            variable_instance *base_right;
            type *right;
            type *result;

            base_left = ((base_variable == NULL) ? NULL : *base_variable);
            type_add_reference(write_type);
            assert(type_is_valid(write_type)); /* VERIFIED */
            assert(type_is_valid(read_type->u.union_type.left)); /* VERIFIED */
            left = augment_write_type_from_read_type(write_type,
                    read_type->u.union_type.left, field_name, bound_direction,
                    &base_left);
            if (left == NULL)
              {
                type_remove_reference(write_type, NULL);
                if (base_variable != NULL)
                    *base_variable = NULL;
                return NULL;
              }
            assert(type_is_valid(left)); /* VERIFIED */

            base_right = ((base_variable == NULL) ? NULL : *base_variable);
            assert(type_is_valid(write_type)); /* VERIFIED */
            assert(type_is_valid(read_type->u.union_type.right));
                    /* VERIFIED */
            right = augment_write_type_from_read_type(write_type,
                    read_type->u.union_type.right, field_name, bound_direction,
                    &base_right);
            if (right == NULL)
              {
                type_remove_reference(left, NULL);
                if (base_variable != NULL)
                    *base_variable = NULL;
                return NULL;
              }
            assert(type_is_valid(right)); /* VERIFIED */

            if (base_variable != NULL)
              {
                if (base_left == base_right)
                    *base_variable = base_left;
                else
                    *base_variable = NULL;
              }

            if (bound_direction == LOU_LOWER)
              {
                assert(type_is_valid(left)); /* VERIFIED */
                assert(type_is_valid(right)); /* VERIFIED */
                result = get_intersection_type(left, right);
                assert((result == NULL) || type_is_valid(result));
                        /* VERIFIED */
              }
            else
              {
                assert(bound_direction == LOU_UPPER);
                assert(type_is_valid(left)); /* VERIFIED */
                assert(type_is_valid(right)); /* VERIFIED */
                result = get_union_type(left, right);
                assert((result == NULL) || type_is_valid(result));
                        /* VERIFIED */
              }
            type_remove_reference(left, NULL);
            type_remove_reference(right, NULL);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            if ((result == NULL) && (base_variable != NULL))
                *base_variable = NULL;
            return result;
          }
        case TK_FIELDS:
        case TK_INTERFACE:
          {
            field_type_info *field_info;
            size_t field_num;
            type *result;

            if (bound_direction == LOU_LOWER)
                goto do_nothing;
            if (read_type->kind == TK_FIELDS)
              {
                field_info = &(read_type->u.fields.field_info);
              }
            else
              {
                assert(read_type->kind == TK_INTERFACE);
                field_info = &(read_type->u.interface.field_info);
              }

            if (!(exists_in_string_index(field_info->allowed_fields,
                                         field_name)))
              {
                if (!(field_info->extra_fields_allowed))
                    goto do_nothing;
                goto do_anything;
              }

            if (base_variable != NULL)
                *base_variable = NULL;

            field_num = (size_t)(lookup_in_string_index(
                    field_info->allowed_fields, field_name));
            assert(field_num < field_info->field_count);
            assert(strcmp(field_info->field_names[field_num], field_name) ==
                   0);

            assert(type_is_valid(write_type)); /* VERIFIED */
            assert(type_is_valid(field_info->field_types[field_num]));
                    /* VERIFIED */
            result = get_union_type(write_type,
                                    field_info->field_types[field_num]);
            assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
            type_remove_reference(write_type, NULL);
            if ((result == NULL) && (base_variable != NULL))
                *base_variable = NULL;
            return result;
          }
        case TK_SEPARATOR:
        default:
          {
            assert(FALSE);
            return NULL;
          }
      }
  }

extern boolean intersection_empty(type *type1, type *type2, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    assert(type1 != NULL);
    assert(type2 != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(type1)); /* VERIFIED */
    assert(type_is_valid(type2)); /* VERIFIED */

    if ((type1->possible_value_kinds & type2->possible_value_kinds) == 0)
      {
        *doubt = FALSE;
        return TRUE;
      }

    assert((type1->kind != TK_NOTHING) && (type2->kind != TK_NOTHING));

    if (type1->kind == TK_ANYTHING)
      {
        assert(type_is_valid(type2)); /* VERIFIED */
        *doubt = possibly_nothing(type2);
        return FALSE;
      }

    if (type2->kind == TK_ANYTHING)
      {
        assert(type_is_valid(type1)); /* VERIFIED */
        *doubt = possibly_nothing(type1);
        return FALSE;
      }

    if ((type1->kind == TK_TEST_ROUTINE) ||
        (type1->kind == TK_TEST_ROUTINE_CHAIN) ||
        (type2->kind == TK_TEST_ROUTINE) ||
        (type2->kind == TK_TEST_ROUTINE_CHAIN))
      {
        *doubt = TRUE;
        return FALSE;
      }

    if (type1->kind == TK_ENUMERATION)
      {
        size_t value_count;
        size_t value_num;

        *doubt = FALSE;

        value_count = type1->u.enumeration.value_count;

        for (value_num = 0; value_num < value_count; ++value_num)
          {
            boolean local_doubt;
            boolean is_in;

            assert(type_is_valid(type2)); /* VERIFIED */
            is_in = value_is_in_type(type1->u.enumeration.values[value_num],
                    type2, &local_doubt, NULL, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            if (local_doubt)
              {
                *doubt = TRUE;
              }
            else if (is_in)
              {
                *doubt = FALSE;
                return FALSE;
              }
          }

        return TRUE;
      }

    if (type2->kind == TK_ENUMERATION)
      {
        assert(type_is_valid(type2)); /* VERIFIED */
        assert(type_is_valid(type1)); /* VERIFIED */
        return intersection_empty(type2, type1, doubt, location, the_jumper);
      }

    if ((type1->kind == TK_NOT) || (type2->kind == TK_NOT))
      {
        *doubt = TRUE;
        return FALSE;
      }

    if ((type1->kind == TK_INTERSECTION) || (type2->kind == TK_INTERSECTION) ||
        (type1->kind == TK_UNION) || (type2->kind == TK_UNION) ||
        (type1->kind == TK_XOR) || (type2->kind == TK_XOR))
      {
        *doubt = TRUE;
        return FALSE;
      }

    switch (type1->kind)
      {
        case TK_INTEGER:
            switch (type2->kind)
              {
                case TK_INTEGER:
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
                case TK_RATIONAL:
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
                case TK_INTEGER_RANGES:
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
                case TK_RATIONAL_RANGES:
                  {
                    size_t component_count;
                    rational_range_component *components;
                    size_t component_num;

                    *doubt = FALSE;

                    if (type2->u.rational_ranges.includes_positive_infinity ||
                        type2->u.rational_ranges.includes_negative_infinity ||
                        type2->u.rational_ranges.includes_unsigned_infinity ||
                        type2->u.rational_ranges.includes_zero_zero)
                      {
                        return FALSE;
                      }

                    component_count = type2->u.rational_ranges.component_count;
                    components = type2->u.rational_ranges.components;

                    for (component_num = 0; component_num < component_count;
                         ++component_num)
                      {
                        rational_range_component *this_component;
                        boolean error;
                        o_integer between;

                        this_component = &(components[component_num]);
                        between = integer_between_rationals(
                                this_component->lower_bound,
                                this_component->upper_bound,
                                this_component->lower_is_inclusive,
                                this_component->upper_is_inclusive, &error);
                        if (error)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        if (!(oi_out_of_memory(between)))
                          {
                            oi_remove_reference(between);
                            return FALSE;
                          }
                      }

                    return TRUE;
                  }
                default:
                  {
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
                  }
              }
        case TK_RATIONAL:
            switch (type2->kind)
              {
                case TK_INTEGER:
                    *doubt = FALSE;
                    return FALSE;
                case TK_RATIONAL:
                    *doubt = FALSE;
                    return FALSE;
                case TK_INTEGER_RANGES:
                    *doubt = FALSE;
                    return FALSE;
                case TK_RATIONAL_RANGES:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_ANY_REGULAR_EXPRESSION:
            switch (type2->kind)
              {
                case TK_ANY_REGULAR_EXPRESSION:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_ANY_QUARK:
            switch (type2->kind)
              {
                case TK_ANY_QUARK:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_ANY_LEPTON:
            switch (type2->kind)
              {
                case TK_ANY_LEPTON:
                    *doubt = FALSE;
                    return FALSE;
                case TK_FIELDS:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = possibly_nothing(type2);
                    return FALSE;
                case TK_LEPTON:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = possibly_nothing(type2);
                    return FALSE;
                case TK_INTERFACE:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = possibly_nothing(type2);
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_LEPTON_KEY:
            switch (type2->kind)
              {
                case TK_LEPTON_KEY:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_JUMP_TARGET:
            switch (type2->kind)
              {
                case TK_JUMP_TARGET:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_ANY_CLASS:
            switch (type2->kind)
              {
                case TK_ANY_CLASS:
                    *doubt = FALSE;
                    return FALSE;
                case TK_ROUTINE:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2->u.routine.return_type));
                            /* VERIFIED */
                    return intersection_empty(type1,
                            type2->u.routine.return_type, doubt, location,
                            the_jumper);
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_OBJECT:
            switch (type2->kind)
              {
                case TK_OBJECT:
                    *doubt = FALSE;
                    return FALSE;
                case TK_FIELDS:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = possibly_nothing(type2);
                    return FALSE;
                case TK_INTERFACE:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = possibly_nothing(type2);
                    return FALSE;
                case TK_CLASS:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_TAGALONG_KEY:
            switch (type2->kind)
              {
                case TK_TAGALONG_KEY:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_LOCK:
            switch (type2->kind)
              {
                case TK_LOCK:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_STRING:
            switch (type2->kind)
              {
                case TK_STRING:
                    *doubt = FALSE;
                    return FALSE;
                case TK_REGULAR_EXPRESSION:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    *doubt = possibly_nothing(type2);
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_CHARACTER:
            switch (type2->kind)
              {
                case TK_CHARACTER:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_ARRAY:
            switch (type2->kind)
              {
                case TK_ARRAY:
                    *doubt = FALSE;
                    return FALSE;
                case TK_MAP:
                    *doubt = FALSE;
                    return FALSE;
                case TK_FIELDS:
                    *doubt = FALSE;
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return !(field_info_empty_allowed(
                                     &(type2->u.fields.field_info)));
                case TK_INTERFACE:
                    *doubt = FALSE;
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return !(field_info_empty_allowed(
                                     &(type2->u.interface.field_info)));
                case TK_SEMI_LABELED_VALUE_LIST:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    assert(type_is_valid(type1)); /* VERIFIED */
                    return semi_labeled_and_array_intersection_empty(type2,
                            type1, doubt, location, the_jumper);
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_INTEGER_RANGES:
            switch (type2->kind)
              {
                case TK_INTEGER:
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
                case TK_RATIONAL:
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
                case TK_INTEGER_RANGES:
                  {
                    size_t component_count1;
                    size_t component_count2;
                    integer_range_component *components1;
                    integer_range_component *components2;
                    size_t component_num2;
                    size_t component_num1;

                    *doubt = FALSE;

                    if (type1->u.integer_ranges.includes_positive_infinity &&
                        type2->u.integer_ranges.includes_positive_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.integer_ranges.includes_negative_infinity &&
                        type2->u.integer_ranges.includes_negative_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.integer_ranges.includes_unsigned_infinity &&
                        type2->u.integer_ranges.includes_unsigned_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.integer_ranges.includes_zero_zero &&
                        type2->u.integer_ranges.includes_zero_zero)
                      {
                        return FALSE;
                      }

                    component_count1 = type1->u.integer_ranges.component_count;
                    component_count2 = type2->u.integer_ranges.component_count;
                    components1 = type1->u.integer_ranges.components;
                    components2 = type2->u.integer_ranges.components;
                    component_num2 = 0;

                    for (component_num1 = 0; component_num1 < component_count1;
                         ++component_num1)
                      {
                        while ((component_num2 < component_count2) &&
                               oi_less_than(
                                       components2[component_num2].upper_bound,
                                       components1[component_num1].
                                               lower_bound))
                          {
                            ++component_num2;
                          }

                        if (component_num2 >= component_count2)
                            break;

                        if (!(oi_less_than(
                                      components1[component_num1].upper_bound,
                                      components2[component_num2].
                                              lower_bound)))
                          {
                            return FALSE;
                          }
                      }

                    return TRUE;
                  }
                case TK_RATIONAL_RANGES:
                  {
                    size_t component_count1;
                    size_t component_count2;
                    integer_range_component *components1;
                    rational_range_component *components2;
                    size_t component_num2;
                    size_t component_num1;

                    *doubt = FALSE;

                    if (type1->u.integer_ranges.includes_positive_infinity &&
                        type2->u.rational_ranges.includes_positive_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.integer_ranges.includes_negative_infinity &&
                        type2->u.rational_ranges.includes_negative_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.integer_ranges.includes_unsigned_infinity &&
                        type2->u.rational_ranges.includes_unsigned_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.integer_ranges.includes_zero_zero &&
                        type2->u.rational_ranges.includes_zero_zero)
                      {
                        return FALSE;
                      }

                    component_count1 = type1->u.integer_ranges.component_count;
                    component_count2 =
                            type2->u.rational_ranges.component_count;
                    components1 = type1->u.integer_ranges.components;
                    components2 = type2->u.rational_ranges.components;
                    component_num2 = 0;

                    for (component_num1 = 0; component_num1 < component_count1;
                         ++component_num1)
                      {
                        o_integer upper1;
                        rational *lower2;
                        boolean error;
                        boolean miss;

                        while (component_num2 < component_count2)
                          {
                            rational *upper2;
                            o_integer lower1;
                            boolean error;
                            boolean miss;

                            upper2 = components2[component_num2].upper_bound;
                            lower1 = components1[component_num1].lower_bound;
                            if (components2[component_num2].upper_is_inclusive)
                              {
                                miss = rational_less_than_integer(upper2,
                                        lower1, &error);
                              }
                            else
                              {
                                miss = !(integer_less_than_rational(lower1,
                                        upper2, &error));
                              }
                            if (error)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                            if (miss)
                                break;
                            ++component_num2;
                          }

                        if (component_num2 >= component_count2)
                            break;

                        upper1 = components1[component_num1].upper_bound;
                        lower2 = components2[component_num2].lower_bound;
                        if (components2[component_num2].lower_is_inclusive)
                          {
                            miss = !(integer_less_than_rational(upper1, lower2,
                                                                &error));
                          }
                        else
                          {
                            miss = rational_less_than_integer(lower2, upper1,
                                                              &error);
                          }
                        if (error)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        if (miss)
                            return FALSE;
                      }

                    return TRUE;
                  }
                default:
                  {
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
                  }
              }
        case TK_RATIONAL_RANGES:
            switch (type2->kind)
              {
                case TK_INTEGER:
                  {
                    return intersection_empty(type2, type1, doubt, location,
                                              the_jumper);
                  }
                case TK_RATIONAL:
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
                case TK_INTEGER_RANGES:
                  {
                    return intersection_empty(type2, type1, doubt, location,
                                              the_jumper);
                  }
                case TK_RATIONAL_RANGES:
                  {
                    size_t component_count1;
                    size_t component_count2;
                    rational_range_component *components1;
                    rational_range_component *components2;
                    size_t component_num2;
                    size_t component_num1;

                    *doubt = FALSE;

                    if (type1->u.rational_ranges.includes_positive_infinity &&
                        type2->u.rational_ranges.includes_positive_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.rational_ranges.includes_negative_infinity &&
                        type2->u.rational_ranges.includes_negative_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.rational_ranges.includes_unsigned_infinity &&
                        type2->u.rational_ranges.includes_unsigned_infinity)
                      {
                        return FALSE;
                      }
                    if (type1->u.rational_ranges.includes_zero_zero &&
                        type2->u.rational_ranges.includes_zero_zero)
                      {
                        return FALSE;
                      }

                    component_count1 =
                            type1->u.rational_ranges.component_count;
                    component_count2 =
                            type2->u.rational_ranges.component_count;
                    components1 = type1->u.rational_ranges.components;
                    components2 = type2->u.rational_ranges.components;
                    component_num2 = 0;

                    for (component_num1 = 0; component_num1 < component_count1;
                         ++component_num1)
                      {
                        rational_range_component *this_component1;
                        rational_range_component *this_component2;
                        boolean error;
                        boolean miss;

                        this_component1 = &(components1[component_num1]);
                        while (component_num2 < component_count2)
                          {
                            boolean error;
                            boolean miss;

                            this_component2 = &(components2[component_num2]);

                            if (this_component1->lower_is_inclusive &&
                                this_component2->upper_is_inclusive)
                              {
                                miss = rational_less_than(
                                        this_component2->upper_bound,
                                        this_component1->lower_bound, &error);
                              }
                            else
                              {
                                miss = !(rational_less_than(
                                       this_component1->lower_bound,
                                       this_component2->upper_bound, &error));
                              }
                            if (error)
                              {
                                jumper_do_abort(the_jumper);
                                return FALSE;
                              }
                            if (!miss)
                                break;

                            ++component_num2;
                          }

                        if (component_num2 >= component_count2)
                            break;

                        if (this_component1->upper_is_inclusive &&
                            this_component2->lower_is_inclusive)
                          {
                            miss = rational_less_than(
                                    this_component1->upper_bound,
                                    this_component2->lower_bound, &error);
                          }
                        else
                          {
                            miss = !(rational_less_than(
                                    this_component2->lower_bound,
                                    this_component1->upper_bound, &error));
                          }
                        if (error)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                        if (!miss)
                            return FALSE;
                      }

                    return TRUE;
                  }
                default:
                  {
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
                  }
              }
        case TK_POINTER:
            switch (type2->kind)
              {
                case TK_POINTER:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_TYPE:
            switch (type2->kind)
              {
                case TK_TYPE:
                    *doubt = FALSE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_MAP:
            switch (type2->kind)
              {
                case TK_ARRAY:
                    *doubt = FALSE;
                    return FALSE;
                case TK_MAP:
                    *doubt = FALSE;
                    return FALSE;
                case TK_FIELDS:
                    *doubt = FALSE;
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return !(field_info_empty_allowed(
                                     &(type2->u.fields.field_info)));
                case TK_INTERFACE:
                    *doubt = FALSE;
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return !(field_info_empty_allowed(
                                     &(type2->u.interface.field_info)));
                case TK_SEMI_LABELED_VALUE_LIST:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    assert(type_is_valid(type1)); /* VERIFIED */
                    return semi_labeled_and_map_intersection_empty(type2,
                            type1, doubt, location, the_jumper);
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_ROUTINE:
            switch (type2->kind)
              {
                case TK_ANY_CLASS:
                    assert(type_is_valid(type1->u.routine.return_type));
                            /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return intersection_empty(type1->u.routine.return_type,
                            type2, doubt, location, the_jumper);
                case TK_ROUTINE:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return routine_types_intersection_empty(type1, type2,
                            doubt, location, the_jumper);
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_FIELDS:
            switch (type2->kind)
              {
                case TK_ANY_LEPTON:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    *doubt = possibly_nothing(type1);
                    return FALSE;
                case TK_OBJECT:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    *doubt = possibly_nothing(type1);
                    return FALSE;
                case TK_ARRAY:
                    *doubt = FALSE;
                    assert(type_is_valid(type1)); /* VERIFIED */
                    return !(field_info_empty_allowed(
                                     &(type1->u.fields.field_info)));
                case TK_MAP:
                    *doubt = FALSE;
                    assert(type_is_valid(type1)); /* VERIFIED */
                    return !(field_info_empty_allowed(
                                     &(type1->u.fields.field_info)));
                case TK_FIELDS:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.fields.field_info),
                            &(type2->u.fields.field_info), doubt, location,
                            the_jumper);
                case TK_LEPTON:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.fields.field_info),
                            &(type2->u.lepton.field_info), doubt, location,
                            the_jumper);
                case TK_MULTISET:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.fields.field_info),
                            &(type2->u.multiset.field_info), doubt, location,
                            the_jumper);
                case TK_INTERFACE:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.fields.field_info),
                            &(type2->u.interface.field_info), doubt, location,
                            the_jumper);
                case TK_SEMI_LABELED_VALUE_LIST:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    assert(type_is_valid(type1)); /* VERIFIED */
                    return semi_labeled_and_field_info_intersection_empty(
                            type2, &(type1->u.fields.field_info), doubt,
                            location, the_jumper);
                case TK_CLASS:
                    *doubt = TRUE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_LEPTON:
            switch (type2->kind)
              {
                case TK_ANY_LEPTON:
                    *doubt = FALSE;
                    return FALSE;
                case TK_FIELDS:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.lepton.field_info),
                            &(type2->u.fields.field_info), doubt, location,
                            the_jumper);
                case TK_LEPTON:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    if (type1->u.lepton.key != type2->u.lepton.key)
                      {
                        *doubt = FALSE;
                        return TRUE;
                      }
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.lepton.field_info),
                            &(type2->u.lepton.field_info), doubt, location,
                            the_jumper);
                case TK_INTERFACE:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.lepton.field_info),
                            &(type2->u.interface.field_info), doubt, location,
                            the_jumper);
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_MULTISET:
            switch (type2->kind)
              {
                case TK_FIELDS:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.multiset.field_info),
                            &(type2->u.fields.field_info), doubt, location,
                            the_jumper);
                case TK_MULTISET:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.multiset.field_info),
                            &(type2->u.multiset.field_info), doubt, location,
                            the_jumper);
                case TK_INTERFACE:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.multiset.field_info),
                            &(type2->u.interface.field_info), doubt, location,
                            the_jumper);
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_INTERFACE:
            switch (type2->kind)
              {
                case TK_ANY_LEPTON:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    *doubt = possibly_nothing(type1);
                    return FALSE;
                case TK_OBJECT:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    *doubt = possibly_nothing(type1);
                    return FALSE;
                case TK_ARRAY:
                    *doubt = FALSE;
                    assert(type_is_valid(type1)); /* VERIFIED */
                    return !(field_info_empty_allowed(
                                     &(type1->u.interface.field_info)));
                case TK_MAP:
                    *doubt = FALSE;
                    assert(type_is_valid(type1)); /* VERIFIED */
                    return !(field_info_empty_allowed(
                                     &(type1->u.interface.field_info)));
                case TK_FIELDS:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.interface.field_info),
                            &(type2->u.fields.field_info), doubt, location,
                            the_jumper);
                case TK_LEPTON:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.interface.field_info),
                            &(type2->u.lepton.field_info), doubt, location,
                            the_jumper);
                case TK_MULTISET:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.interface.field_info),
                            &(type2->u.multiset.field_info), doubt, location,
                            the_jumper);
                case TK_INTERFACE:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return field_info_intersection_empty(
                            &(type1->u.interface.field_info),
                            &(type2->u.interface.field_info), doubt, location,
                            the_jumper);
                case TK_SEMI_LABELED_VALUE_LIST:
                    assert(type_is_valid(type2)); /* VERIFIED */
                    assert(type_is_valid(type1)); /* VERIFIED */
                    return semi_labeled_and_field_info_intersection_empty(
                            type2, &(type1->u.interface.field_info), doubt,
                            location, the_jumper);
                case TK_CLASS:
                    *doubt = TRUE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_SEMI_LABELED_VALUE_LIST:
            switch (type2->kind)
              {
                case TK_ARRAY:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return semi_labeled_and_array_intersection_empty(type1,
                            type2, doubt, location, the_jumper);
                case TK_MAP:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return semi_labeled_and_map_intersection_empty(type1,
                            type2, doubt, location, the_jumper);
                case TK_FIELDS:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return semi_labeled_and_field_info_intersection_empty(
                            type1, &(type2->u.fields.field_info), doubt,
                            location, the_jumper);
                case TK_INTERFACE:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return semi_labeled_and_field_info_intersection_empty(
                            type1, &(type2->u.interface.field_info), doubt,
                            location, the_jumper);
                case TK_SEMI_LABELED_VALUE_LIST:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return semi_labeled_value_lists_intersection_empty(type1,
                            type2, doubt, location, the_jumper);
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_REGULAR_EXPRESSION:
            switch (type2->kind)
              {
                case TK_STRING:
                    assert(type_is_valid(type1)); /* VERIFIED */
                    *doubt = possibly_nothing(type1);
                    return FALSE;
                case TK_REGULAR_EXPRESSION:
                    *doubt = TRUE;
                    return FALSE;
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        case TK_CLASS:
            switch (type2->kind)
              {
                case TK_OBJECT:
                    *doubt = FALSE;
                    return FALSE;
                case TK_FIELDS:
                    *doubt = TRUE;
                    return FALSE;
                case TK_INTERFACE:
                    *doubt = TRUE;
                    return FALSE;
                case TK_CLASS:
                    *doubt = FALSE;
                    assert(type_is_valid(type1)); /* VERIFIED */
                    assert(type_is_valid(type2)); /* VERIFIED */
                    return (type1->u.class.routine != type2->u.class.routine);
                default:
                    assert(FALSE);
                    *doubt = FALSE;
                    return TRUE;
              }
        default:
            assert(FALSE);
            return FALSE;
      }
  }

extern value *force_value_to_type(value *to_force, type *the_type,
        const source_location *location, jumper *the_jumper)
  {
    value *type_value;
    value *arguments[1];
    value *result;
    verdict the_verdict;

    assert(to_force != NULL);
    assert(the_type != NULL);
    assert(the_jumper != NULL);

    assert(value_is_valid(to_force)); /* VERIFIED */
    assert(type_is_valid(the_type)); /* VERIFIED */

    type_value = create_type_value(the_type);
    if (type_value == NULL)
      {
        jumper_do_abort(the_jumper);
        return NULL;
      }

    arguments[0] = type_value;
    the_verdict = try_overloading(to_force, "operator::", &result, 1,
                                  &(arguments[0]), NULL, the_jumper, location);
    if (!(jumper_flowing_forward(the_jumper)))
      {
        value_remove_reference(type_value, the_jumper);
        return NULL;
      }
    value_remove_reference(type_value, the_jumper);
    if (the_verdict == MISSION_ACCOMPLISHED)
        return result;

    switch (the_type->kind)
      {
        case TK_ANYTHING:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_NOTHING:
          {
            return NULL;
          }
        case TK_INTEGER:
          {
            if (get_value_kind(to_force) == VK_RATIONAL)
              {
                o_integer result_oi;
                value *result_value;

                result_oi = force_rational_value_to_integer(to_force);
                if (oi_out_of_memory(result_oi))
                  {
                    jumper_do_abort(the_jumper);
                    return NULL;
                  }

                result_value = create_integer_value(result_oi);
                oi_remove_reference(result_oi);
                if (result_value == NULL)
                    jumper_do_abort(the_jumper);
                return result_value;
              }

            return NULL;
          }
        case TK_RATIONAL:
          {
            return NULL;
          }
        case TK_ANY_REGULAR_EXPRESSION:
          {
            return NULL;
          }
        case TK_ANY_QUARK:
          {
            return NULL;
          }
        case TK_ANY_LEPTON:
          {
            return NULL;
          }
        case TK_LEPTON_KEY:
          {
            return NULL;
          }
        case TK_JUMP_TARGET:
          {
            return NULL;
          }
        case TK_ANY_CLASS:
          {
            return NULL;
          }
        case TK_OBJECT:
          {
            return NULL;
          }
        case TK_TAGALONG_KEY:
          {
            return NULL;
          }
        case TK_LOCK:
          {
            return NULL;
          }
        case TK_STRING:
          {
            return NULL;
          }
        case TK_CHARACTER:
          {
            return NULL;
          }
        case TK_ENUMERATION:
          {
            location_exception(the_jumper, location,
                    EXCEPTION_TAG(force_indeterminate),
                    "An attempt was made to force a value to an enumeration "
                    "type, and %s doesn't try to determine whether an "
                    "enumeration type is equivalent to a type for which a "
                    "forcing operation is legal.", interpreter_name());
            return NULL;
          }
        case TK_NOT:
          {
            location_exception(the_jumper, location,
                    EXCEPTION_TAG(force_indeterminate),
                    "An attempt was made to force a value to a type that is "
                    "the negation of another type, and %s doesn't try to "
                    "determine whether such a type is equivalent to a type for"
                    " which a forcing operation is legal.",
                    interpreter_name());
            return NULL;
          }
        case TK_INTERSECTION:
          {
            location_exception(the_jumper, location,
                    EXCEPTION_TAG(force_indeterminate),
                    "An attempt was made to force a value to a type that is "
                    "the intersection of other types, and %s doesn't try to "
                    "determine whether such a type is equivalent to a type for"
                    " which a forcing operation is legal.",
                    interpreter_name());
            return NULL;
          }
        case TK_UNION:
          {
            location_exception(the_jumper, location,
                    EXCEPTION_TAG(force_indeterminate),
                    "An attempt was made to force a value to a type that is "
                    "the union of other types, and %s doesn't try to determine"
                    " whether such a type is equivalent to a type for which a "
                    "forcing operation is legal.", interpreter_name());
            return NULL;
          }
        case TK_XOR:
          {
            location_exception(the_jumper, location,
                    EXCEPTION_TAG(force_indeterminate),
                    "An attempt was made to force a value to a type that is "
                    "the exclusive or of other types, and %s doesn't try to "
                    "determine whether such a type is equivalent to a type for"
                    " which a forcing operation is legal.",
                    interpreter_name());
            return NULL;
          }
        case TK_ARRAY:
          {
            type *range_type;
            value *result;

            range_type = get_integer_range_type(the_type->u.array.lower_bound,
                    the_type->u.array.upper_bound, TRUE, TRUE);
            if (range_type == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(range_type)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(type_is_valid(the_type->u.array.base)); /* VERIFIED */
            result = force_value_to_map(to_force, range_type,
                    the_type->u.array.base, location, the_jumper);

            type_remove_reference(range_type, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                value_remove_reference(result, the_jumper);
                return NULL;
              }

            return result;
          }
        case TK_INTEGER_RANGES:
          {
            integer_range_component *components;
            o_integer source_oi;
            o_integer normalized;
            o_integer gap;
            o_integer length;
            o_integer remainder;
            o_integer division;
            o_integer result_oi;
            value *result_value;

            if (the_type->u.integer_ranges.includes_positive_infinity ||
                the_type->u.integer_ranges.includes_negative_infinity ||
                the_type->u.integer_ranges.includes_unsigned_infinity ||
                the_type->u.integer_ranges.includes_zero_zero)
              {
                return NULL;
              }

            if (the_type->u.integer_ranges.component_count != 1)
                return NULL;

            components = &(the_type->u.integer_ranges.components[0]);

            if ((oi_kind(components->lower_bound) != IIK_FINITE) ||
                (oi_kind(components->upper_bound) != IIK_FINITE))
              {
                return NULL;
              }

            switch (get_value_kind(to_force))
              {
                case VK_INTEGER:
                  {
                    source_oi = integer_value_data(to_force);
                    assert(!(oi_out_of_memory(source_oi)));
                    oi_add_reference(source_oi);
                    break;
                  }
                case VK_RATIONAL:
                  {
                    source_oi = force_rational_value_to_integer(to_force);
                    if (oi_out_of_memory(source_oi))
                      {
                        jumper_do_abort(the_jumper);
                        return NULL;
                      }
                    break;
                  }
                default:
                  {
                    return NULL;
                  }
              }

            assert(!(oi_out_of_memory(source_oi)));

            oi_subtract(normalized, source_oi, components->lower_bound);
            oi_remove_reference(source_oi);
            if (oi_out_of_memory(normalized))
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            oi_subtract(gap, components->upper_bound, components->lower_bound);
            if (oi_out_of_memory(gap))
              {
                jumper_do_abort(the_jumper);
                oi_remove_reference(normalized);
                return NULL;
              }

            oi_add(length, gap, oi_one);
            oi_remove_reference(gap);
            if (oi_out_of_memory(length))
              {
                jumper_do_abort(the_jumper);
                oi_remove_reference(normalized);
                return NULL;
              }

            oi_divide(division, normalized, length, &remainder);
            oi_remove_reference(normalized);
            if (oi_out_of_memory(division))
              {
                jumper_do_abort(the_jumper);
                oi_remove_reference(length);
                return NULL;
              }
            assert(!(oi_out_of_memory(remainder)));
            oi_remove_reference(division);

            if (oi_is_negative(remainder))
              {
                o_integer new_remainder;

                oi_add(new_remainder, remainder, length);
                if (oi_out_of_memory(new_remainder))
                  {
                    jumper_do_abort(the_jumper);
                    oi_remove_reference(remainder);
                    oi_remove_reference(length);
                    return NULL;
                  }

                oi_remove_reference(remainder);
                remainder = new_remainder;

                assert(!(oi_is_negative(remainder)));
              }

            oi_remove_reference(length);

            assert(!(oi_is_negative(remainder)));

            oi_add(result_oi, remainder, components->lower_bound);
            oi_remove_reference(remainder);
            if (oi_out_of_memory(result_oi))
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            result_value = create_integer_value(result_oi);
            oi_remove_reference(result_oi);
            if (result_value == NULL)
                jumper_do_abort(the_jumper);
            return result_value;
          }
        case TK_RATIONAL_RANGES:
          {
            rational_range_component *components;
            rational *source;
            rational *normalized;
            rational *gap;
            rational *division;
            o_integer numerator;
            o_integer denominator;
            o_integer whole;
            o_integer remainder;
            rational *ranged;
            rational *filled;
            rational *result_rational;
            value *result_value;

            if (the_type->u.rational_ranges.includes_positive_infinity ||
                the_type->u.rational_ranges.includes_negative_infinity ||
                the_type->u.rational_ranges.includes_unsigned_infinity ||
                the_type->u.rational_ranges.includes_zero_zero)
              {
                return NULL;
              }

            if (the_type->u.rational_ranges.component_count != 1)
                return NULL;

            components = &(the_type->u.rational_ranges.components[0]);

            if ((oi_kind(rational_numerator(components->lower_bound)) !=
                 IIK_FINITE) ||
                (oi_kind(rational_numerator(components->upper_bound)) !=
                 IIK_FINITE))
              {
                return NULL;
              }

            if (components->lower_is_inclusive ==
                components->upper_is_inclusive)
              {
                return NULL;
              }

            switch (get_value_kind(to_force))
              {
                case VK_INTEGER:
                  {
                    source = create_rational(integer_value_data(to_force),
                                             oi_one);
                    if (source == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        return NULL;
                      }
                    break;
                  }
                case VK_RATIONAL:
                  {
                    source = rational_value_data(to_force);
                    assert(source != NULL);
                    rational_add_reference(source);
                    break;
                  }
                default:
                  {
                    return NULL;
                  }
              }

            assert(source != NULL);

            normalized = rational_subtract(source, components->lower_bound);
            rational_remove_reference(source);
            if (normalized == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            gap = rational_subtract(components->upper_bound,
                                    components->lower_bound);
            if (gap == NULL)
              {
                jumper_do_abort(the_jumper);
                rational_remove_reference(normalized);
                return NULL;
              }

            division = rational_divide(normalized, gap);
            rational_remove_reference(normalized);
            if (division == NULL)
              {
                jumper_do_abort(the_jumper);
                rational_remove_reference(gap);
                return NULL;
              }

            numerator = rational_numerator(division);
            denominator = rational_denominator(division);

            oi_divide(whole, numerator, denominator, &remainder);
            if (oi_out_of_memory(whole))
              {
                jumper_do_abort(the_jumper);
                rational_remove_reference(division);
                rational_remove_reference(gap);
                return NULL;
              }
            assert(!(oi_out_of_memory(remainder)));
            oi_remove_reference(whole);

            if (oi_is_negative(remainder))
              {
                o_integer new_remainder;

                oi_add(new_remainder, remainder, denominator);
                if (oi_out_of_memory(new_remainder))
                  {
                    jumper_do_abort(the_jumper);
                    oi_remove_reference(remainder);
                    rational_remove_reference(division);
                    rational_remove_reference(gap);
                    return NULL;
                  }

                oi_remove_reference(remainder);
                remainder = new_remainder;

                assert(!(oi_is_negative(remainder)));
              }

            assert(!(oi_is_negative(remainder)));

            if ((!(components->lower_is_inclusive)) &&
                !(oi_less_than(oi_zero, remainder)))
              {
                oi_add_reference(denominator);
                oi_remove_reference(remainder);
                remainder = denominator;
              }

            ranged = create_rational(remainder, denominator);
            oi_remove_reference(remainder);
            rational_remove_reference(division);
            if (ranged == NULL)
              {
                jumper_do_abort(the_jumper);
                rational_remove_reference(gap);
                return NULL;
              }

            filled = rational_multiply(ranged, gap);
            rational_remove_reference(ranged);
            rational_remove_reference(gap);
            if (filled == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            result_rational = rational_add(filled, components->lower_bound);
            rational_remove_reference(filled);
            if (result_rational == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            result_value = create_rational_value(result_rational);
            rational_remove_reference(result_rational);
            if (result_value == NULL)
                jumper_do_abort(the_jumper);
            return result_value;
          }
        case TK_POINTER:
          {
            return NULL;
          }
        case TK_TYPE:
          {
            return NULL;
          }
        case TK_MAP:
          {
            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(type_is_valid(the_type->u.map.key)); /* VERIFIED */
            assert(type_is_valid(the_type->u.map.target)); /* VERIFIED */
            return force_value_to_map(to_force, the_type->u.map.key,
                    the_type->u.map.target, location, the_jumper);
          }
        case TK_ROUTINE:
          {
            return NULL;
          }
        case TK_FIELDS:
          {
            value *result_value;
            verdict the_verdict;

            if (!value_has_fields(to_force))
                return NULL;

            result_value = create_similar_field_value(to_force);
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            the_verdict = filter_fields_through_field_info(result_value,
                    to_force, &(the_type->u.fields.field_info), location,
                    the_jumper);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                value_remove_reference(result_value, the_jumper);
                return NULL;
              }

            return result_value;
          }
        case TK_LEPTON:
          {
            value *result_value;
            verdict the_verdict;

            if (!value_has_fields(to_force))
                return NULL;

            assert(type_is_valid(the_type)); /* VERIFIED */
            result_value = create_lepton_value(the_type->u.lepton.key);
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            assert(value_is_valid(result_value)); /* VERIFIED */

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            the_verdict = filter_fields_through_field_info(result_value,
                    to_force, &(the_type->u.lepton.field_info), location,
                    the_jumper);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                value_remove_reference(result_value, the_jumper);
                return NULL;
              }

            return result_value;
          }
        case TK_MULTISET:
          {
            value *result_value;
            verdict the_verdict;

            if (!value_has_fields(to_force))
                return NULL;

            result_value = create_semi_labeled_multi_set_value();
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            the_verdict = filter_fields_through_field_info(result_value,
                    to_force, &(the_type->u.multiset.field_info), location,
                    the_jumper);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                value_remove_reference(result_value, the_jumper);
                return NULL;
              }

            return result_value;
          }
        case TK_INTERFACE:
          {
            value *result_value;
            verdict the_verdict;

            if (!value_has_fields(to_force))
                return NULL;

            result_value = create_similar_field_value(to_force);
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(the_type)); /* VERIFIED */
            the_verdict = filter_fields_through_field_info(result_value,
                    to_force, &(the_type->u.interface.field_info), location,
                    the_jumper);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                value_remove_reference(result_value, the_jumper);
                return NULL;
              }

            return result_value;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            value *result_value;
            size_t element_count;
            size_t element_num;

            switch (get_value_kind(to_force))
              {
                case VK_MAP:
                case VK_SEMI_LABELED_VALUE_LIST:
                case VK_SEMI_LABELED_MULTI_SET:
                case VK_LEPTON:
                case VK_OBJECT:
                    break;
                default:
                    return NULL;
              }

            result_value = create_semi_labeled_value_list_value();
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            element_count = the_type->u.semi_labeled_value_list.element_count;

            for (element_num = 0; element_num < element_count; ++element_num)
              {
                const char *field_name;
                value *field_value;
                type *element_type;
                value *munged_value;
                verdict the_verdict;

                field_name = the_type->u.semi_labeled_value_list.element_names[
                        element_num];

                if ((get_value_kind(to_force) == VK_SEMI_LABELED_VALUE_LIST) &&
                    (element_num < value_component_count(to_force)))
                  {
                    assert(value_is_valid(to_force)); /* VERIFIED */
                    field_value = value_component_value(to_force, element_num);
                    if (field_value == NULL)
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    value_add_reference(field_value);
                    assert(value_is_valid(field_value)); /* VERIFIED */
                  }
                else if (get_value_kind(to_force) == VK_MAP)
                  {
                    o_integer key_oi;
                    value *key_value;
                    boolean doubt;

                    oi_create_from_size_t(key_oi, element_num);
                    if (oi_out_of_memory(key_oi))
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }

                    key_value = create_integer_value(key_oi);
                    oi_remove_reference(key_oi);
                    if (key_value == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }

                    assert(value_is_valid(to_force)); /* VERIFIED */
                    assert(map_value_all_keys_are_valid(to_force));
                            /* VERIFIED */
                    assert(value_is_valid(key_value)); /* VERIFIED */
                    field_value = map_value_lookup(to_force, key_value, &doubt,
                                                   location, the_jumper);
                    value_remove_reference(key_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    assert(!doubt);
                    if (field_value == NULL)
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    value_add_reference(field_value);
                    assert(value_is_valid(field_value)); /* VERIFIED */
                  }
                else
                  {
                    if (field_name == NULL)
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }

                    if (get_value_kind(to_force) != VK_OBJECT)
                      {
                        assert(value_is_valid(to_force)); /* VERIFIED */
                        field_value = value_get_field(field_name, to_force);
                        if (field_value == NULL)
                          {
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }
                        value_add_reference(field_value);
                        assert(value_is_valid(field_value)); /* VERIFIED */
                      }
                    else
                      {
                        object *the_object;
                        size_t field_num;

                        assert(value_is_valid(to_force)); /* VERIFIED */
                        the_object = object_value_data(to_force);
                        assert(the_object != NULL);
                        assert(!(object_is_closed(the_object))); /* VERIFIED */

                        field_num =
                                object_field_lookup(the_object, field_name);
                        if (field_num >= object_field_count(the_object))
                          {
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }
                        assert(!(object_is_closed(the_object))); /* VERIFIED */
                        field_value = object_field_read_value(the_object,
                                field_num, location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            assert(field_value == NULL);
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }
                        if (field_value == NULL)
                          {
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }

                        check_value_validity(field_value, location,
                                             the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            value_remove_reference(field_value, the_jumper);
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }

                        assert(value_is_valid(field_value)); /* VERIFIED */
                      }
                  }

                assert(type_is_valid(the_type)); /* VERIFIED */
                element_type = the_type->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);
                assert(value_is_valid(field_value)); /* VERIFIED */
                assert(type_is_valid(element_type)); /* VERIFIED */
                munged_value = take_or_force_value_to_type(field_value,
                        element_type, location, the_jumper);
                value_remove_reference(field_value, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if (munged_value != NULL)
                         value_remove_reference(munged_value, the_jumper);
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }
                if (munged_value == NULL)
                  {
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }

                the_verdict =
                        add_field(result_value, field_name, munged_value);
                if (the_verdict != MISSION_ACCOMPLISHED)
                  {
                    jumper_do_abort(the_jumper);
                    value_remove_reference(munged_value, the_jumper);
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }

                value_remove_reference(munged_value, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }
              }

            if (the_type->u.semi_labeled_value_list.extra_elements_allowed)
              {
                switch (get_value_kind(to_force))
                  {
                    case VK_MAP:
                      {
                        while (TRUE)
                          {
                            o_integer key_oi;
                            value *key_value;
                            boolean doubt;
                            value *field_value;
                            verdict the_verdict;

                            oi_create_from_size_t(key_oi, element_num);
                            if (oi_out_of_memory(key_oi))
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(result_value,
                                                       the_jumper);
                                return NULL;
                              }

                            key_value = create_integer_value(key_oi);
                            oi_remove_reference(key_oi);
                            if (key_value == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(result_value,
                                                       the_jumper);
                                return NULL;
                              }

                            assert(map_value_all_keys_are_valid(to_force));
                                    /* VERIFIED */
                            assert(value_is_valid(key_value)); /* VERIFIED */
                            field_value = map_value_lookup(to_force, key_value,
                                    &doubt, location, the_jumper);
                            value_remove_reference(key_value, the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                value_remove_reference(result_value,
                                                       the_jumper);
                                if (field_value != NULL)
                                  {
                                    value_remove_reference(field_value,
                                                           the_jumper);
                                  }
                                return NULL;
                              }
                            assert(!doubt);
                            if (field_value == NULL)
                                break;

                            the_verdict =
                                    add_field(result_value, NULL, field_value);
                            if (the_verdict != MISSION_ACCOMPLISHED)
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(result_value,
                                                       the_jumper);
                                return NULL;
                              }

                            ++element_num;
                          }

                        break;
                      }
                    case VK_SEMI_LABELED_VALUE_LIST:
                      {
                        element_count = value_component_count(to_force);

                        for (; element_num < element_count; ++element_num)
                          {
                            value *field_value;
                            verdict the_verdict;

                            field_value = value_component_value(to_force,
                                                                element_num);
                            if (field_value == NULL)
                                break;

                            the_verdict = add_field(result_value,
                                    value_component_label(to_force,
                                            element_num), field_value);
                            if (the_verdict != MISSION_ACCOMPLISHED)
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(result_value,
                                                       the_jumper);
                                return NULL;
                              }
                          }

                        break;
                      }
                    case VK_SEMI_LABELED_MULTI_SET:
                      {
                        break;
                      }
                    case VK_LEPTON:
                      {
                        break;
                      }
                    case VK_OBJECT:
                      {
                        break;
                      }
                    default:
                      {
                        assert(FALSE);
                      }
                  }
              }

            return result_value;
          }
        case TK_REGULAR_EXPRESSION:
          {
            return NULL;
          }
        case TK_CLASS:
          {
            semi_labeled_value_list *arguments;
            verdict the_verdict;

            arguments = create_semi_labeled_value_list();
            if (arguments == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            the_verdict = append_value_to_semi_labeled_value_list(arguments,
                    NULL, to_force);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                jumper_do_abort(the_jumper);
                delete_semi_labeled_value_list(arguments, the_jumper);
                return NULL;
              }

            if (routine_instance_fits_actuals(the_type->u.class.routine,
                                              arguments, location, the_jumper))
              {
                value *base;
                value *result;

                base = create_routine_value(the_type->u.class.routine);
                if (base == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    delete_semi_labeled_value_list(arguments, the_jumper);
                    return NULL;
                  }

                result = execute_call_from_values(base, arguments, TRUE,
                                                  the_jumper, location);
                value_remove_reference(base, the_jumper);
                delete_semi_labeled_value_list(arguments, the_jumper);
                return result;
              }

            delete_semi_labeled_value_list(arguments, the_jumper);
            return NULL;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            location_exception(the_jumper, location,
                    EXCEPTION_TAG(force_indeterminate),
                    "An attempt was made to force a value to a type that is "
                    "defined by a filter function, and %s doesn't try to "
                    "determine whether such a type is equivalent to a type for"
                    " which a forcing operation is legal.",
                    interpreter_name());
            return NULL;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return NULL;
          }
        default:
          {
            assert(FALSE);
            return NULL;
          }
      }
  }

extern boolean type_always_forceable_to(type *source, type *target,
        boolean *doubt, const source_location *location, jumper *the_jumper)
  {
    boolean subset_doubt;
    boolean is_subset;

    assert(source != NULL);
    assert(target != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(source)); /* VERIFIED */
    assert(type_is_valid(target)); /* VERIFIED */

    *doubt = FALSE;

    is_subset = type_is_subset(source, target, &subset_doubt, NULL, location,
                               the_jumper);
    if (!(jumper_flowing_forward(the_jumper)))
        return FALSE;
    if (is_subset && !subset_doubt)
        return TRUE;

      {
        static const char *argument_names[1] = { NULL };
        static boolean argument_has_defaults[1] = { FALSE };
        static const char *item_names[1] = { "operator::" };
        static boolean item_writing_alloweds[1] = { FALSE };

        type *anything_type;
        value *target_value;
        value *target_values[1];
        type *target_singleton;
        type *argument_types[1];
        type *routine_type;
        type *item_types[1];
        type *test_interface;
        boolean subset_doubt;
        boolean is_subset;

        anything_type = get_anything_type();
        if (anything_type == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }

        target_value = create_type_value(target);
        if (target_value == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }

        target_values[0] = target_value;
        target_singleton = get_enumeration_type(1, &(target_values[0]));
        if (target_singleton == NULL)
          {
            jumper_do_abort(the_jumper);
            value_remove_reference(target_value, the_jumper);
            return FALSE;
          }

        value_remove_reference(target_value, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            type_remove_reference(target_singleton, the_jumper);
            return FALSE;
          }

        argument_types[0] = target_singleton;
        routine_type = get_routine_type(anything_type, 1, &(argument_types[0]),
                &(argument_names[0]), &(argument_has_defaults[0]), FALSE,
                FALSE);
        if (routine_type == NULL)
          {
            jumper_do_abort(the_jumper);
            type_remove_reference(target_singleton, the_jumper);
            return FALSE;
          }

        type_remove_reference(target_singleton, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            type_remove_reference(routine_type, the_jumper);
            return FALSE;
          }

        item_types[0] = routine_type;
        test_interface = get_interface_type(1, &(item_types[0]),
                &(item_names[0]), &(item_writing_alloweds[0]), FALSE);
        if (test_interface == NULL)
          {
            jumper_do_abort(the_jumper);
            type_remove_reference(routine_type, the_jumper);
            return FALSE;
          }

        type_remove_reference(routine_type, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            type_remove_reference(test_interface, the_jumper);
            return FALSE;
          }

        is_subset = type_is_subset(source, test_interface, &subset_doubt, NULL,
                                   location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            type_remove_reference(test_interface, the_jumper);
            return FALSE;
          }
        type_remove_reference(test_interface, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (is_subset && !subset_doubt)
          {
            *doubt = FALSE;
            return TRUE;
          }
        if (subset_doubt)
            *doubt = TRUE;
      }

    switch (target->kind)
      {
        case TK_ANYTHING:
          {
            assert(FALSE);
            return FALSE;
          }
        case TK_NOTHING:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_INTEGER:
          {
            type *rational_type;
            boolean rational_doubt;
            boolean in_rational;

          require_rational:
            rational_type = get_rational_type();
            if (rational_type == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }

            in_rational = type_is_subset(source, rational_type,
                    &rational_doubt, NULL, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            if (in_rational && !rational_doubt)
              {
                *doubt = FALSE;
                return TRUE;
              }
            if (rational_doubt)
                *doubt = TRUE;
            return FALSE;
          }
        case TK_RATIONAL:
          {
            return FALSE;
          }
        case TK_ANY_REGULAR_EXPRESSION:
          {
            return FALSE;
          }
        case TK_ANY_QUARK:
          {
            return FALSE;
          }
        case TK_ANY_LEPTON:
          {
            return FALSE;
          }
        case TK_LEPTON_KEY:
          {
            return FALSE;
          }
        case TK_JUMP_TARGET:
          {
            return FALSE;
          }
        case TK_ANY_CLASS:
          {
            return FALSE;
          }
        case TK_OBJECT:
          {
            return FALSE;
          }
        case TK_TAGALONG_KEY:
          {
            return FALSE;
          }
        case TK_LOCK:
          {
            return FALSE;
          }
        case TK_STRING:
          {
            return FALSE;
          }
        case TK_CHARACTER:
          {
            return FALSE;
          }
        case TK_ENUMERATION:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_NOT:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_INTERSECTION:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_UNION:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_XOR:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_ARRAY:
          {
            /* @@@ */
#if 0
            type *range_type;
            value *result;

            range_type = get_integer_range_type(target->u.array.lower_bound,
                    target->u.array.upper_bound, TRUE, TRUE);
            if (range_type == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(range_type)); /* VERIFIED */
            assert(type_is_valid(target)); /* VERIFIED */
            assert(type_is_valid(target->u.array.base)); /* VERIFIED */
            result = force_value_to_map(to_force, range_type,
                    target->u.array.base, location, the_jumper);

            type_remove_reference(range_type, the_jumper);
            if ((!(jumper_flowing_forward(the_jumper))) && (result != NULL))
              {
                value_remove_reference(result, the_jumper);
                return NULL;
              }

            return result;
#else
            *doubt = TRUE;
            return FALSE;
#endif
            /* @@@ */
          }
        case TK_INTEGER_RANGES:
          {
            integer_range_component *components;

            if (target->u.integer_ranges.includes_positive_infinity ||
                target->u.integer_ranges.includes_negative_infinity ||
                target->u.integer_ranges.includes_unsigned_infinity ||
                target->u.integer_ranges.includes_zero_zero)
              {
                return FALSE;
              }

            if (target->u.integer_ranges.component_count != 1)
                return FALSE;

            components = &(target->u.integer_ranges.components[0]);

            if ((oi_kind(components->lower_bound) != IIK_FINITE) ||
                (oi_kind(components->upper_bound) != IIK_FINITE))
              {
                return FALSE;
              }

            goto require_rational;
          }
        case TK_RATIONAL_RANGES:
          {
            rational_range_component *components;

            if (target->u.rational_ranges.includes_positive_infinity ||
                target->u.rational_ranges.includes_negative_infinity ||
                target->u.rational_ranges.includes_unsigned_infinity ||
                target->u.rational_ranges.includes_zero_zero)
              {
                return FALSE;
              }

            if (target->u.rational_ranges.component_count != 1)
                return FALSE;

            components = &(target->u.rational_ranges.components[0]);

            if ((oi_kind(rational_numerator(components->lower_bound)) !=
                 IIK_FINITE) ||
                (oi_kind(rational_numerator(components->upper_bound)) !=
                 IIK_FINITE))
              {
                return FALSE;
              }

            if (components->lower_is_inclusive ==
                components->upper_is_inclusive)
              {
                return FALSE;
              }

            goto require_rational;
          }
        case TK_POINTER:
          {
            return FALSE;
          }
        case TK_TYPE:
          {
            return FALSE;
          }
        case TK_MAP:
          {
            /* @@@ */
#if 0
            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(target)); /* VERIFIED */
            assert(type_is_valid(target->u.map.key)); /* VERIFIED */
            assert(type_is_valid(target->u.map.target)); /* VERIFIED */
            return force_value_to_map(to_force, target->u.map.key,
                    target->u.map.target, location, the_jumper);
#else
            *doubt = TRUE;
            return FALSE;
#endif
            /* @@@ */
          }
        case TK_ROUTINE:
          {
            return FALSE;
          }
        case TK_FIELDS:
          {
            /* @@@ */
#if 0
            value *result_value;
            verdict the_verdict;

            if (!value_has_fields(to_force))
                return NULL;

            result_value = create_similar_field_value(to_force);
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(target)); /* VERIFIED */
            the_verdict = filter_fields_through_field_info(result_value,
                    to_force, &(target->u.fields.field_info), location,
                    the_jumper);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                value_remove_reference(result_value, the_jumper);
                return NULL;
              }

            return result_value;
#else
            *doubt = TRUE;
            return FALSE;
#endif
            /* @@@ */
          }
        case TK_LEPTON:
          {
            /* @@@ */
#if 0
            value *result_value;
            verdict the_verdict;

            if (!value_has_fields(to_force))
                return NULL;

            assert(type_is_valid(target)); /* VERIFIED */
            result_value = create_lepton_value(target->u.lepton.key);
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            assert(value_is_valid(result_value)); /* VERIFIED */

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(target)); /* VERIFIED */
            the_verdict = filter_fields_through_field_info(result_value,
                    to_force, &(target->u.lepton.field_info), location,
                    the_jumper);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                value_remove_reference(result_value, the_jumper);
                return NULL;
              }

            return result_value;
#else
            *doubt = TRUE;
            return FALSE;
#endif
            /* @@@ */
          }
        case TK_MULTISET:
          {
            /* @@@ */
#if 0
            value *result_value;
            verdict the_verdict;

            if (!value_has_fields(to_force))
                return NULL;

            result_value = create_semi_labeled_multi_set_value();
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(target)); /* VERIFIED */
            the_verdict = filter_fields_through_field_info(result_value,
                    to_force, &(target->u.multiset.field_info), location,
                    the_jumper);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                value_remove_reference(result_value, the_jumper);
                return NULL;
              }

            return result_value;
#else
            *doubt = TRUE;
            return FALSE;
#endif
            /* @@@ */
          }
        case TK_INTERFACE:
          {
            /* @@@ */
#if 0
            value *result_value;
            verdict the_verdict;

            if (!value_has_fields(to_force))
                return NULL;

            result_value = create_similar_field_value(to_force);
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            assert(value_is_valid(to_force)); /* VERIFIED */
            assert(type_is_valid(target)); /* VERIFIED */
            the_verdict = filter_fields_through_field_info(result_value,
                    to_force, &(target->u.interface.field_info), location,
                    the_jumper);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                value_remove_reference(result_value, the_jumper);
                return NULL;
              }

            return result_value;
#else
            *doubt = TRUE;
            return FALSE;
#endif
            /* @@@ */
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            /* @@@ */
#if 0
            value *result_value;
            size_t element_count;
            size_t element_num;

            switch (get_value_kind(to_force))
              {
                case VK_MAP:
                case VK_SEMI_LABELED_VALUE_LIST:
                case VK_SEMI_LABELED_MULTI_SET:
                case VK_LEPTON:
                case VK_OBJECT:
                    break;
                default:
                    return NULL;
              }

            result_value = create_semi_labeled_value_list_value();
            if (result_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            element_count = target->u.semi_labeled_value_list.element_count;

            for (element_num = 0; element_num < element_count; ++element_num)
              {
                const char *field_name;
                value *field_value;
                type *element_type;
                value *munged_value;
                verdict the_verdict;

                field_name = target->u.semi_labeled_value_list.element_names[
                        element_num];

                if ((get_value_kind(to_force) == VK_SEMI_LABELED_VALUE_LIST) &&
                    (element_num < value_component_count(to_force)))
                  {
                    assert(value_is_valid(to_force)); /* VERIFIED */
                    field_value = value_component_value(to_force, element_num);
                    if (field_value == NULL)
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    value_add_reference(field_value);
                    assert(value_is_valid(field_value)); /* VERIFIED */
                  }
                else if (get_value_kind(to_force) == VK_MAP)
                  {
                    o_integer key_oi;
                    value *key_value;
                    boolean doubt;

                    oi_create_from_size_t(key_oi, element_num);
                    if (oi_out_of_memory(key_oi))
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }

                    key_value = create_integer_value(key_oi);
                    oi_remove_reference(key_oi);
                    if (key_value == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }

                    assert(value_is_valid(to_force)); /* VERIFIED */
                    assert(map_value_all_keys_are_valid(to_force));
                            /* VERIFIED */
                    assert(value_is_valid(key_value)); /* VERIFIED */
                    field_value = map_value_lookup(to_force, key_value, &doubt,
                                                   location, the_jumper);
                    value_remove_reference(key_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    assert(!doubt);
                    if (field_value == NULL)
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    value_add_reference(field_value);
                    assert(value_is_valid(field_value)); /* VERIFIED */
                  }
                else
                  {
                    if (field_name == NULL)
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }

                    if (get_value_kind(to_force) != VK_OBJECT)
                      {
                        assert(value_is_valid(to_force)); /* VERIFIED */
                        field_value = value_get_field(field_name, to_force);
                        if (field_value == NULL)
                          {
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }
                        value_add_reference(field_value);
                        assert(value_is_valid(field_value)); /* VERIFIED */
                      }
                    else
                      {
                        object *the_object;
                        size_t field_num;

                        assert(value_is_valid(to_force)); /* VERIFIED */
                        the_object = object_value_data(to_force);
                        assert(the_object != NULL);
                        assert(!(object_is_closed(the_object))); /* VERIFIED */

                        field_num =
                                object_field_lookup(the_object, field_name);
                        if (field_num >= object_field_count(the_object))
                          {
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }
                        assert(!(object_is_closed(the_object))); /* VERIFIED */
                        field_value = object_field_read_value(the_object,
                                field_num, location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            assert(field_value == NULL);
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }
                        if (field_value == NULL)
                          {
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }

                        check_value_validity(field_value, location,
                                             the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            value_remove_reference(field_value, the_jumper);
                            value_remove_reference(result_value, the_jumper);
                            return NULL;
                          }

                        assert(value_is_valid(field_value)); /* VERIFIED */
                      }
                  }

                assert(type_is_valid(target)); /* VERIFIED */
                element_type = target->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);
                assert(value_is_valid(field_value)); /* VERIFIED */
                assert(type_is_valid(element_type)); /* VERIFIED */
                munged_value = take_or_force_value_to_type(field_value,
                        element_type, location, the_jumper);
                value_remove_reference(field_value, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if (munged_value != NULL)
                         value_remove_reference(munged_value, the_jumper);
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }
                if (munged_value == NULL)
                  {
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }

                the_verdict =
                        add_field(result_value, field_name, munged_value);
                if (the_verdict != MISSION_ACCOMPLISHED)
                  {
                    jumper_do_abort(the_jumper);
                    value_remove_reference(munged_value, the_jumper);
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }

                value_remove_reference(munged_value, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }
              }

            if (target->u.semi_labeled_value_list.extra_elements_allowed)
              {
                switch (get_value_kind(to_force))
                  {
                    case VK_MAP:
                      {
                        while (TRUE)
                          {
                            o_integer key_oi;
                            value *key_value;
                            boolean doubt;
                            value *field_value;
                            verdict the_verdict;

                            oi_create_from_size_t(key_oi, element_num);
                            if (oi_out_of_memory(key_oi))
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(result_value,
                                                       the_jumper);
                                return NULL;
                              }

                            key_value = create_integer_value(key_oi);
                            oi_remove_reference(key_oi);
                            if (key_value == NULL)
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(result_value,
                                                       the_jumper);
                                return NULL;
                              }

                            assert(map_value_all_keys_are_valid(to_force));
                                    /* VERIFIED */
                            assert(value_is_valid(key_value)); /* VERIFIED */
                            field_value = map_value_lookup(to_force, key_value,
                                    &doubt, location, the_jumper);
                            value_remove_reference(key_value, the_jumper);
                            if (!(jumper_flowing_forward(the_jumper)))
                              {
                                value_remove_reference(result_value,
                                                       the_jumper);
                                if (field_value != NULL)
                                  {
                                    value_remove_reference(field_value,
                                                           the_jumper);
                                  }
                                return NULL;
                              }
                            assert(!doubt);
                            if (field_value == NULL)
                                break;

                            the_verdict =
                                    add_field(result_value, NULL, field_value);
                            if (the_verdict != MISSION_ACCOMPLISHED)
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(result_value,
                                                       the_jumper);
                                return NULL;
                              }

                            ++element_num;
                          }

                        break;
                      }
                    case VK_SEMI_LABELED_VALUE_LIST:
                      {
                        element_count = value_component_count(to_force);

                        for (; element_num < element_count; ++element_num)
                          {
                            value *field_value;
                            verdict the_verdict;

                            field_value = value_component_value(to_force,
                                                                element_num);
                            if (field_value == NULL)
                                break;

                            the_verdict = add_field(result_value,
                                    value_component_label(to_force,
                                            element_num), field_value);
                            if (the_verdict != MISSION_ACCOMPLISHED)
                              {
                                jumper_do_abort(the_jumper);
                                value_remove_reference(result_value,
                                                       the_jumper);
                                return NULL;
                              }
                          }

                        break;
                      }
                    case VK_SEMI_LABELED_MULTI_SET:
                      {
                        break;
                      }
                    case VK_LEPTON:
                      {
                        break;
                      }
                    case VK_OBJECT:
                      {
                        break;
                      }
                    default:
                      {
                        assert(FALSE);
                      }
                  }
              }

            return result_value;
#else
            *doubt = TRUE;
            return FALSE;
#endif
            /* @@@ */
          }
        case TK_REGULAR_EXPRESSION:
          {
            return FALSE;
          }
        case TK_CLASS:
          {
            static parameter_pattern_kind parameter_pattern_kinds[1] =
              { PPK_TYPE };
            static const char *parameter_names[1] = { NULL };

            type *parameter_types[1];
            boolean constructor_doubt;
            boolean constructor_fit;

            parameter_types[0] = source;
            constructor_fit = routine_instance_fits_pattern(
                    target->u.class.routine, 1, &(parameter_pattern_kinds[0]),
                    &(parameter_names[0]), NULL, &(parameter_types[0]),
                    &(parameter_types[0]), NULL, &constructor_doubt, location,
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;
            if (constructor_fit && !constructor_doubt)
              {
                *doubt = FALSE;
                return TRUE;
              }
            if (constructor_doubt)
                *doubt = TRUE;
            return FALSE;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return FALSE;
          }
        default:
          {
            assert(FALSE);
            return FALSE;
          }
      }
  }

extern void find_type_overload_type(type *base_type, size_t argument_count,
        parameter_pattern_kind *parameter_pattern_kinds,
        const char **parameter_names, value **exact_parameters,
        type **parameter_lower_types, type **parameter_upper_types,
        boolean is_write, type *write_lower_requirement,
        type *write_upper_requirement, type **result_lower,
        type **result_upper, boolean *always_hits, boolean *never_hits,
        const source_location *location, jumper *the_jumper)
  {
    find_type_overload_type_with_possible_map_result(base_type, argument_count,
            parameter_pattern_kinds, parameter_names, exact_parameters,
            parameter_lower_types, parameter_upper_types, is_write,
            write_lower_requirement, write_upper_requirement, argument_count,
            result_lower, result_upper, always_hits, never_hits, location,
            the_jumper);
  }

extern void find_type_overload_type_with_possible_map_result(type *base_type,
        size_t argument_count, parameter_pattern_kind *parameter_pattern_kinds,
        const char **parameter_names, value **exact_parameters,
        type **parameter_lower_types, type **parameter_upper_types,
        boolean is_write, type *write_lower_requirement,
        type *write_upper_requirement, size_t map_key_argument_number,
        type **result_lower, type **result_upper, boolean *always_hits,
        boolean *never_hits, const source_location *location,
        jumper *the_jumper)
  {
    assert(base_type != NULL);
    assert(result_lower != NULL);
    assert(result_upper != NULL);
    assert(always_hits != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(base_type)); /* VERIFIED */
    assert((write_lower_requirement == NULL) ||
           type_is_valid(write_lower_requirement)); /* VERIFIED */
    assert((write_upper_requirement == NULL) ||
           type_is_valid(write_upper_requirement)); /* VERIFIED */

    switch (base_type->kind)
      {
        case TK_ANYTHING:
          {
            assert(type_is_valid(base_type)); /* VERIFIED */
            type_add_reference(base_type);
            *result_lower = base_type;
            type_add_reference(base_type);
            *result_upper = base_type;
            *always_hits = FALSE;
            if (never_hits != NULL)
                *never_hits = FALSE;
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_NOTHING:
          {
            assert(type_is_valid(base_type)); /* VERIFIED */
            type_add_reference(base_type);
            *result_lower = base_type;
            type_add_reference(base_type);
            *result_upper = base_type;
            *always_hits = FALSE;
            if (never_hits != NULL)
                *never_hits = TRUE;
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
        case TK_ARRAY:
        case TK_INTEGER_RANGES:
        case TK_RATIONAL_RANGES:
        case TK_POINTER:
        case TK_TYPE:
        case TK_MAP:
        case TK_FIELDS:
        case TK_LEPTON:
        case TK_MULTISET:
        case TK_INTERFACE:
        case TK_SEMI_LABELED_VALUE_LIST:
        case TK_REGULAR_EXPRESSION:
        case TK_CLASS:
          {
            type *nothing_type;

            nothing_type = get_nothing_type();
            if (nothing_type == NULL)
              {
                jumper_do_abort(the_jumper);
                *result_lower = NULL;
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            type_add_reference(nothing_type);
            *result_lower = nothing_type;
            type_add_reference(nothing_type);
            *result_upper = nothing_type;
            *always_hits = FALSE;
            if (never_hits != NULL)
                *never_hits = TRUE;
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_ANY_CLASS:
          {
            type *nothing_type;
            type *anything_type;
            type *any_object_type;

            nothing_type = get_nothing_type();
            anything_type = get_anything_type();
            any_object_type = get_object_type();
            if ((nothing_type == NULL) || (anything_type == NULL) ||
                (any_object_type == NULL))
              {
                jumper_do_abort(the_jumper);
                *result_lower = NULL;
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            type_add_reference(nothing_type);
            *result_lower = nothing_type;
            assert(*result_lower != NULL); /* VERIFIED */
            assert(type_is_valid(*result_lower)); /* VERIFIED */

            if (!is_write)
              {
                type_add_reference(any_object_type);
                *result_upper = any_object_type;
                assert(*result_upper != NULL); /* VERIFIED */
                assert(type_is_valid(*result_upper)); /* VERIFIED */
              }
            else
              {
                if (write_upper_requirement == NULL)
                  {
                    type_add_reference(anything_type);
                    *result_upper = anything_type;
                    assert(*result_upper != NULL); /* VERIFIED */
                    assert(type_is_valid(*result_upper)); /* VERIFIED */
                  }
                else
                  {
                    boolean empty;
                    boolean doubt;

                    assert(type_is_valid(any_object_type)); /* VERIFIED */
                    assert(type_is_valid(write_upper_requirement));
                            /* VERIFIED */
                    empty = intersection_empty(any_object_type,
                            write_upper_requirement, &doubt, location,
                            the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        type_add_reference(*result_lower);
                        *result_lower = NULL;
                        *result_upper = NULL;
                        *always_hits = FALSE;
                        if (never_hits != NULL)
                            *never_hits = FALSE;
                        return;
                      }

                    if (empty && !doubt)
                      {
                        type_add_reference(nothing_type);
                        *result_upper = nothing_type;
                        assert(*result_upper != NULL); /* VERIFIED */
                        assert(type_is_valid(*result_upper)); /* VERIFIED */
                      }
                    else
                      {
                        type_add_reference(anything_type);
                        *result_upper = anything_type;
                        assert(*result_upper != NULL); /* VERIFIED */
                        assert(type_is_valid(*result_upper)); /* VERIFIED */
                      }
                  }
              }

            *always_hits = FALSE;
            if (never_hits != NULL)
                *never_hits = FALSE;

            assert(*result_lower != NULL); /* VERIFIED */
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(*result_upper != NULL); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_ENUMERATION:
          {
            size_t value_count;
            type *nothing_type;
            size_t value_num;

            value_count = base_type->u.enumeration.value_count;

            nothing_type = get_nothing_type();
            if (nothing_type == NULL)
              {
                jumper_do_abort(the_jumper);
                *result_lower = NULL;
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            type_add_reference(nothing_type);
            *result_lower = nothing_type;
            type_add_reference(nothing_type);
            *result_upper = nothing_type;
            if (value_count == 0)
                *always_hits = FALSE;
            else
                *always_hits = TRUE;
            if (never_hits != NULL)
                *never_hits = TRUE;

            assert(*result_lower != NULL); /* VERIFIED */
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(*result_upper != NULL); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */

            for (value_num = 0; value_num < value_count; ++value_num)
              {
                value *local_value;
                type *local_lower;
                type *local_upper;
                boolean local_always_hits;
                boolean local_never_hits;

                local_value = base_type->u.enumeration.values[value_num];
                assert(local_value != NULL);

                if ((get_value_kind(local_value) != VK_ROUTINE) &&
                    (get_value_kind(local_value) != VK_ROUTINE_CHAIN))
                  {
                    *always_hits = FALSE;
                    continue;
                  }

                find_overload_type_with_possible_map_result(local_value,
                        argument_count, parameter_pattern_kinds,
                        parameter_names, exact_parameters,
                        parameter_lower_types, parameter_upper_types, is_write,
                        write_lower_requirement, write_upper_requirement,
                        map_key_argument_number, &local_lower, &local_upper,
                        &local_always_hits, &local_never_hits, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    assert(local_lower == NULL);
                    assert(local_upper == NULL);
                    type_remove_reference(*result_lower, the_jumper);
                    type_remove_reference(*result_upper, the_jumper);
                    *result_lower = NULL;
                    *result_upper = NULL;
                    *always_hits = FALSE;
                    if (never_hits != NULL)
                        *never_hits = TRUE;
                    return;
                  }

                assert(local_lower != NULL);
                assert(local_upper != NULL);
                assert(type_is_valid(local_lower)); /* VERIFIED */
                assert(type_is_valid(local_upper)); /* VERIFIED */

                if (local_never_hits)
                  {
                    assert(!local_always_hits);
                    *always_hits = FALSE;
                  }
                else
                  {
                    type *new_type;

                    *never_hits = FALSE;

                    if (!local_always_hits)
                        *always_hits = FALSE;

                    assert(type_is_valid(*result_lower)); /* VERIFIED */
                    assert(type_is_valid(local_lower)); /* VERIFIED */
                    new_type = get_union_type(*result_lower, local_lower);
                    assert((new_type == NULL) || type_is_valid(new_type));
                            /* VERIFIED */
                    if (new_type == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        type_remove_reference(local_lower, the_jumper);
                        type_remove_reference(local_upper, the_jumper);
                        type_remove_reference(*result_lower, the_jumper);
                        type_remove_reference(*result_upper, the_jumper);
                        *result_lower = NULL;
                        *result_upper = NULL;
                        *always_hits = FALSE;
                        if (never_hits != NULL)
                            *never_hits = TRUE;
                        return;
                      }

                    type_remove_reference(*result_lower, the_jumper);
                    *result_lower = new_type;
                    assert(type_is_valid(*result_lower)); /* VERIFIED */
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        jumper_do_abort(the_jumper);
                        type_remove_reference(local_lower, the_jumper);
                        type_remove_reference(local_upper, the_jumper);
                        type_remove_reference(*result_lower, the_jumper);
                        type_remove_reference(*result_upper, the_jumper);
                        *result_lower = NULL;
                        *result_upper = NULL;
                        *always_hits = FALSE;
                        if (never_hits != NULL)
                            *never_hits = TRUE;
                        return;
                      }

                    assert(type_is_valid(*result_upper)); /* VERIFIED */
                    assert(type_is_valid(local_upper)); /* VERIFIED */
                    new_type = get_union_type(*result_upper, local_upper);
                    assert((new_type == NULL) || type_is_valid(new_type));
                            /* VERIFIED */
                    if (new_type == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        type_remove_reference(local_lower, the_jumper);
                        type_remove_reference(local_upper, the_jumper);
                        type_remove_reference(*result_lower, the_jumper);
                        type_remove_reference(*result_upper, the_jumper);
                        *result_lower = NULL;
                        *result_upper = NULL;
                        *always_hits = FALSE;
                        if (never_hits != NULL)
                            *never_hits = TRUE;
                        return;
                      }

                    type_remove_reference(*result_upper, the_jumper);
                    *result_upper = new_type;
                    assert(type_is_valid(*result_upper)); /* VERIFIED */
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        jumper_do_abort(the_jumper);
                        type_remove_reference(local_lower, the_jumper);
                        type_remove_reference(local_upper, the_jumper);
                        type_remove_reference(*result_lower, the_jumper);
                        type_remove_reference(*result_upper, the_jumper);
                        *result_lower = NULL;
                        *result_upper = NULL;
                        *always_hits = FALSE;
                        if (never_hits != NULL)
                            *never_hits = TRUE;
                        return;
                      }
                  }

                type_remove_reference(local_lower, the_jumper);
                type_remove_reference(local_upper, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    type_remove_reference(*result_lower, the_jumper);
                    type_remove_reference(*result_upper, the_jumper);
                    *result_lower = NULL;
                    *result_upper = NULL;
                    *always_hits = FALSE;
                    if (never_hits != NULL)
                        *never_hits = TRUE;
                    return;
                  }
              }

            assert(*result_lower != NULL); /* VERIFIED */
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(*result_upper != NULL); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_NOT:
        case TK_XOR:
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            type *nothing_type;
            type *anything_type;

            nothing_type = get_nothing_type();
            anything_type = get_anything_type();
            if ((nothing_type == NULL) || (anything_type == NULL))
              {
                jumper_do_abort(the_jumper);
                *result_lower = NULL;
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            type_add_reference(nothing_type);
            *result_lower = nothing_type;
            type_add_reference(anything_type);
            *result_upper = anything_type;
            *always_hits = FALSE;
            if (never_hits != NULL)
                *never_hits = FALSE;
            assert(*result_lower != NULL); /* VERIFIED */
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(*result_upper != NULL); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_INTERSECTION:
          {
            type *left_lower;
            type *left_upper;
            boolean left_always_hits;
            boolean left_never_hits;
            type *right_lower;
            type *right_upper;
            boolean right_always_hits;
            boolean right_never_hits;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.left));
                    /* VERIFIED */
            assert((write_lower_requirement == NULL) ||
                   type_is_valid(write_lower_requirement)); /* VERIFIED */
            assert((write_upper_requirement == NULL) ||
                   type_is_valid(write_upper_requirement)); /* VERIFIED */
            find_type_overload_type_with_possible_map_result(
                    base_type->u.intersection.left, argument_count,
                    parameter_pattern_kinds, parameter_names, exact_parameters,
                    parameter_lower_types, parameter_upper_types, is_write,
                    write_lower_requirement, write_upper_requirement,
                    map_key_argument_number, &left_lower, &left_upper,
                    &left_always_hits, &left_never_hits, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(left_lower == NULL);
                assert(left_upper == NULL);
                *result_lower = NULL;
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            assert(left_lower != NULL);
            assert(left_upper != NULL);
            assert(type_is_valid(left_lower)); /* VERIFIED */
            assert(type_is_valid(left_upper)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.right));
                    /* VERIFIED */
            assert((write_lower_requirement == NULL) ||
                   type_is_valid(write_lower_requirement)); /* VERIFIED */
            assert((write_upper_requirement == NULL) ||
                   type_is_valid(write_upper_requirement)); /* VERIFIED */
            find_type_overload_type_with_possible_map_result(
                    base_type->u.intersection.right, argument_count,
                    parameter_pattern_kinds, parameter_names, exact_parameters,
                    parameter_lower_types, parameter_upper_types, is_write,
                    write_lower_requirement, write_upper_requirement,
                    map_key_argument_number, &right_lower, &right_upper,
                    &right_always_hits, &right_never_hits, location,
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(right_lower == NULL);
                assert(right_upper == NULL);
                type_remove_reference(left_lower, the_jumper);
                type_remove_reference(left_upper, the_jumper);
                *result_lower = NULL;
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            assert(right_lower != NULL);
            assert(right_upper != NULL);
            assert(type_is_valid(right_lower)); /* VERIFIED */
            assert(type_is_valid(right_upper)); /* VERIFIED */

            *always_hits = (left_always_hits || right_always_hits);
            if (never_hits != NULL)
                *never_hits = (left_never_hits || right_never_hits);

            *result_lower = get_nothing_type();
            if (*result_lower == NULL)
                jumper_do_abort(the_jumper);
            else
                type_add_reference(*result_lower);
            assert((*result_lower == NULL) || type_is_valid(*result_lower));
                    /* VERIFIED */

            assert(type_is_valid(left_upper)); /* VERIFIED */
            assert(type_is_valid(right_upper)); /* VERIFIED */
            *result_upper = get_intersection_type(left_upper, right_upper);
            assert((*result_upper == NULL) || type_is_valid(*result_upper));
                    /* VERIFIED */
            if (*result_upper == NULL)
                jumper_do_abort(the_jumper);

            type_remove_reference(left_lower, the_jumper);
            type_remove_reference(left_upper, the_jumper);
            type_remove_reference(right_lower, the_jumper);
            type_remove_reference(right_upper, the_jumper);

            if (!(jumper_flowing_forward(the_jumper)))
              {
                if (*result_lower != NULL)
                    type_remove_reference(*result_lower, the_jumper);
                *result_lower = NULL;
                if (*result_upper != NULL)
                    type_remove_reference(*result_upper, the_jumper);
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            assert(*result_lower != NULL); /* VERIFIED */
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(*result_upper != NULL); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_UNION:
          {
            type *left_lower;
            type *left_upper;
            boolean left_always_hits;
            boolean left_never_hits;
            type *right_lower;
            type *right_upper;
            boolean right_always_hits;
            boolean right_never_hits;

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.left));
                    /* VERIFIED */
            assert((write_lower_requirement == NULL) ||
                   type_is_valid(write_lower_requirement)); /* VERIFIED */
            assert((write_upper_requirement == NULL) ||
                   type_is_valid(write_upper_requirement)); /* VERIFIED */
            find_type_overload_type_with_possible_map_result(
                    base_type->u.intersection.left, argument_count,
                    parameter_pattern_kinds, parameter_names, exact_parameters,
                    parameter_lower_types, parameter_upper_types, is_write,
                    write_lower_requirement, write_upper_requirement,
                    map_key_argument_number, &left_lower, &left_upper,
                    &left_always_hits, &left_never_hits, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(left_lower == NULL);
                assert(left_upper == NULL);
                *result_lower = NULL;
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            assert(left_lower != NULL);
            assert(left_upper != NULL);
            assert(type_is_valid(left_lower)); /* VERIFIED */
            assert(type_is_valid(left_upper)); /* VERIFIED */

            assert(type_is_valid(base_type)); /* VERIFIED */
            assert(type_is_valid(base_type->u.intersection.right));
                    /* VERIFIED */
            assert((write_lower_requirement == NULL) ||
                   type_is_valid(write_lower_requirement)); /* VERIFIED */
            assert((write_upper_requirement == NULL) ||
                   type_is_valid(write_upper_requirement)); /* VERIFIED */
            find_type_overload_type_with_possible_map_result(
                    base_type->u.intersection.right, argument_count,
                    parameter_pattern_kinds, parameter_names, exact_parameters,
                    parameter_lower_types, parameter_upper_types, is_write,
                    write_lower_requirement, write_upper_requirement,
                    map_key_argument_number, &right_lower, &right_upper,
                    &right_always_hits, &right_never_hits, location,
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(right_lower == NULL);
                assert(right_upper == NULL);
                type_remove_reference(left_lower, the_jumper);
                type_remove_reference(left_upper, the_jumper);
                *result_lower = NULL;
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            assert(right_lower != NULL);
            assert(right_upper != NULL);
            assert(type_is_valid(right_lower)); /* VERIFIED */
            assert(type_is_valid(right_upper)); /* VERIFIED */

            *always_hits = (left_always_hits && right_always_hits);
            if (never_hits != NULL)
                *never_hits = (left_never_hits && right_never_hits);

            assert(type_is_valid(left_lower)); /* VERIFIED */
            assert(type_is_valid(right_lower)); /* VERIFIED */
            *result_lower = get_union_type(left_lower, right_lower);
            assert((*result_lower == NULL) || type_is_valid(*result_lower));
                    /* VERIFIED */
            if (*result_lower == NULL)
                jumper_do_abort(the_jumper);

            assert(type_is_valid(left_upper)); /* VERIFIED */
            assert(type_is_valid(right_upper)); /* VERIFIED */
            *result_upper = get_union_type(left_upper, right_upper);
            assert((*result_upper == NULL) || type_is_valid(*result_upper));
                    /* VERIFIED */
            if (*result_upper == NULL)
                jumper_do_abort(the_jumper);

            type_remove_reference(left_lower, the_jumper);
            type_remove_reference(left_upper, the_jumper);
            type_remove_reference(right_lower, the_jumper);
            type_remove_reference(right_upper, the_jumper);

            if (!(jumper_flowing_forward(the_jumper)))
              {
                if (*result_lower != NULL)
                    type_remove_reference(*result_lower, the_jumper);
                *result_lower = NULL;
                if (*result_upper != NULL)
                    type_remove_reference(*result_upper, the_jumper);
                *result_upper = NULL;
                *always_hits = FALSE;
                if (never_hits != NULL)
                    *never_hits = TRUE;
                return;
              }

            assert(*result_lower != NULL); /* VERIFIED */
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(*result_upper != NULL); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_ROUTINE:
          {
            type **result_parameter_types;
            boolean matches;
            boolean doubt;
            type *result;

            *result_lower = NULL;
            *result_upper = NULL;
            *always_hits = FALSE;
            if (never_hits != NULL)
                *never_hits = TRUE;

            if (is_write)
              {
                parameter_pattern_kinds[argument_count] = PPK_ANY;
                parameter_names[argument_count] = NULL;
                exact_parameters[argument_count] = NULL;
                parameter_lower_types[argument_count] = NULL;
                parameter_upper_types[argument_count] = NULL;
                if (map_key_argument_number == argument_count)
                    ++map_key_argument_number;
                ++argument_count;
              }

            result_parameter_types = MALLOC_ARRAY(type *, argument_count + 1);
            if (result_parameter_types == NULL)
              {
                jumper_do_abort(the_jumper);
                return;
              }

            assert(type_is_valid(base_type)); /* VERIFIED */
            matches = routine_type_fits_pattern(base_type, argument_count,
                    parameter_pattern_kinds, parameter_names, exact_parameters,
                    parameter_lower_types, parameter_upper_types,
                    result_parameter_types, &doubt, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                free(result_parameter_types);
                return;
              }

            if ((matches || doubt) && is_write)
              {
                type *lower_return_match;
                type *upper_return_match;
                boolean return_matches;
                boolean return_doubt;

                if (write_lower_requirement != NULL)
                  {
                    assert(write_lower_requirement != NULL);
                    assert(write_upper_requirement != NULL);

                    lower_return_match = write_lower_requirement;
                    upper_return_match = write_upper_requirement;
                    assert(type_is_valid(lower_return_match)); /* VERIFIED */
                    assert(type_is_valid(upper_return_match)); /* VERIFIED */
                  }
                else
                  {
                    assert(write_lower_requirement == NULL);
                    assert(write_upper_requirement == NULL);

                    lower_return_match = get_nothing_type();
                    if (lower_return_match == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        free(result_parameter_types);
                        return;
                      }

                    upper_return_match = lower_return_match;
                    assert(type_is_valid(lower_return_match)); /* VERIFIED */
                    assert(type_is_valid(upper_return_match)); /* VERIFIED */
                  }

                assert(lower_return_match != NULL);
                assert(upper_return_match != NULL);
                assert(type_is_valid(lower_return_match)); /* VERIFIED */
                assert(type_is_valid(upper_return_match)); /* VERIFIED */

                assert(type_is_valid(base_type)); /* VERIFIED */
                assert(type_is_valid(base_type->u.routine.return_type));
                        /* VERIFIED */
                assert(type_is_valid(upper_return_match)); /* VERIFIED */
                return_matches = type_is_subset(
                        base_type->u.routine.return_type,
                        upper_return_match, &return_doubt, NULL, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    free(result_parameter_types);
                    return;
                  }

                if ((!return_matches) && (!return_doubt))
                  {
                    matches = FALSE;
                    doubt = FALSE;
                  }
                else if ((!return_matches) || return_doubt)
                  {
                    doubt = TRUE;
                  }

                assert(type_is_valid(base_type)); /* VERIFIED */
                assert(type_is_valid(base_type->u.routine.return_type));
                        /* VERIFIED */
                assert(type_is_valid(lower_return_match)); /* VERIFIED */
                return_matches = type_is_subset(
                        base_type->u.routine.return_type,
                        lower_return_match, &return_doubt, NULL, location,
                        the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    free(result_parameter_types);
                    return;
                  }

                if (matches && ((!return_matches) || return_doubt))
                    doubt = TRUE;
              }

            if ((!matches) && (!doubt))
              {
                free(result_parameter_types);

                *result_lower = get_nothing_type();
                if (*result_lower == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return;
                  }
                assert(type_is_valid(*result_lower)); /* VERIFIED */

                *result_upper = *result_lower;
                type_add_reference(*result_lower);
                type_add_reference(*result_upper);
                assert(*result_lower != NULL); /* VERIFIED */
                assert(type_is_valid(*result_lower)); /* VERIFIED */
                assert(*result_upper != NULL); /* VERIFIED */
                assert(type_is_valid(*result_upper)); /* VERIFIED */
                return;
              }

            if (never_hits != NULL)
                *never_hits = FALSE;

            if (is_write)
              {
                result = result_parameter_types[argument_count - 1];
                assert(result != NULL);
                assert(type_is_valid(result)); /* VERIFIED */

                if (map_key_argument_number < argument_count)
                  {
                    type *key_type;

                    key_type = result_parameter_types[map_key_argument_number];
                    assert(key_type != NULL);
                    assert(type_is_valid(key_type)); /* VERIFIED */

                    assert(type_is_valid(result)); /* VERIFIED */
                    result = get_map_type(key_type, result);
                    if (result == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        free(result_parameter_types);
                        *always_hits = FALSE;
                        *result_lower = NULL;
                        *result_upper = NULL;
                        return;
                      }
                    assert(type_is_valid(result)); /* VERIFIED */
                  }
                else
                  {
                    assert(result != NULL);
                    assert(type_is_valid(result)); /* VERIFIED */
                    type_add_reference(result);
                  }
                assert(result != NULL);
                assert(type_is_valid(result)); /* VERIFIED */
              }
            else
              {
                assert(type_is_valid(base_type)); /* VERIFIED */
                result = base_type->u.routine.return_type;
                assert(result != NULL);
                assert(type_is_valid(result)); /* VERIFIED */
                type_add_reference(result);
              }

            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */

            free(result_parameter_types);

            if (!doubt)
                *always_hits = TRUE;

            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            *result_lower = result;
            type_add_reference(result);
            *result_upper = result;

            assert(*result_lower != NULL); /* VERIFIED */
            assert(type_is_valid(*result_lower)); /* VERIFIED */
            assert(*result_upper != NULL); /* VERIFIED */
            assert(type_is_valid(*result_upper)); /* VERIFIED */
            return;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
          }
        default:
          {
            assert(FALSE);
          }
      }
  }

extern void find_type_integer_bounds(type *the_type, o_integer *minimum,
        o_integer *maximum, boolean *min_doubt, boolean *max_doubt,
        const source_location *location, jumper *the_jumper)
  {
    assert(the_type != NULL);
    assert(minimum != NULL);
    assert(maximum != NULL);
    assert(min_doubt != NULL);
    assert(max_doubt != NULL);
    assert(the_jumper != NULL);

    switch (the_type->kind)
      {
        case TK_ANYTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
          {
            *minimum = oi_negative_infinity;
            oi_add_reference(*minimum);
            *maximum = oi_positive_infinity;
            oi_add_reference(*maximum);
            *min_doubt = FALSE;
            *max_doubt = FALSE;
            return;
          }
        case TK_NOTHING:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
        case TK_ARRAY:
        case TK_POINTER:
        case TK_TYPE:
        case TK_MAP:
        case TK_ROUTINE:
        case TK_FIELDS:
        case TK_LEPTON:
        case TK_MULTISET:
        case TK_INTERFACE:
        case TK_SEMI_LABELED_VALUE_LIST:
        case TK_REGULAR_EXPRESSION:
        case TK_CLASS:
          {
            *minimum = oi_null;
            *maximum = oi_null;
            *min_doubt = FALSE;
            *max_doubt = FALSE;
            return;
          }
        case TK_ENUMERATION:
          {
            size_t value_count;
            size_t value_num;

            *minimum = oi_null;
            *maximum = oi_null;

            value_count = the_type->u.enumeration.value_count;

            for (value_num = 0; value_num < value_count; ++value_num)
              {
                value *this_value;
                o_integer this_oi;

                this_value = the_type->u.enumeration.values[value_num];
                assert(this_value != NULL);

                if (get_value_kind(this_value) != VK_INTEGER)
                    continue;

                this_oi = integer_value_data(this_value);
                assert(!(oi_out_of_memory(this_oi)));

                if ((oi_kind(this_oi) == IIK_UNSIGNED_INFINITY) ||
                    (oi_kind(this_oi) == IIK_ZERO_ZERO))
                  {
                    continue;
                  }

                if (oi_out_of_memory(*minimum))
                  {
                    assert(oi_out_of_memory(*maximum));
                    *minimum = this_oi;
                    *maximum = this_oi;
                  }
                else
                  {
                    assert(!(oi_out_of_memory(*maximum)));
                    if (oi_less_than(this_oi, *minimum))
                        *minimum = this_oi;
                    if (oi_less_than(*maximum, this_oi))
                        *maximum = this_oi;
                  }
              }

            if (!(oi_out_of_memory(*minimum)))
                oi_add_reference(*minimum);
            if (!(oi_out_of_memory(*maximum)))
                oi_add_reference(*maximum);

            *min_doubt = FALSE;
            *max_doubt = FALSE;
            return;
          }
        case TK_NOT:
          {
            find_type_integer_bounds(the_type->u.not.base, minimum, maximum,
                    min_doubt, max_doubt, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return;

            if ((!*min_doubt) && (!*max_doubt) && (oi_out_of_memory(*minimum))
                && (oi_out_of_memory(*maximum)))
              {
                *minimum = oi_negative_infinity;
                oi_add_reference(*minimum);
                *maximum = oi_positive_infinity;
                oi_add_reference(*maximum);
              }
            else
              {
                *minimum = oi_null;
                *maximum = oi_null;
                *min_doubt = TRUE;
                *max_doubt = TRUE;
              }

            return;
          }
        case TK_INTERSECTION:
          {
            o_integer left_minimum;
            o_integer left_maximum;
            boolean left_min_doubt;
            boolean left_max_doubt;
            o_integer right_minimum;
            o_integer right_maximum;
            boolean right_min_doubt;
            boolean right_max_doubt;

            find_type_integer_bounds(the_type->u.intersection.left,
                    &left_minimum, &left_maximum, &left_min_doubt,
                    &left_max_doubt, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return;

            find_type_integer_bounds(the_type->u.intersection.right,
                    &right_minimum, &right_maximum, &right_min_doubt,
                    &right_max_doubt, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if (!(oi_out_of_memory(left_minimum)))
                    oi_remove_reference(left_minimum);
                if (!(oi_out_of_memory(left_maximum)))
                    oi_remove_reference(left_maximum);
                return;
              }

            if ((!left_max_doubt) && oi_out_of_memory(left_maximum))
              {
                if (!(oi_out_of_memory(right_maximum)))
                    oi_remove_reference(right_maximum);
                *maximum = oi_null;
                *max_doubt = FALSE;
              }
            else if ((!right_max_doubt) && oi_out_of_memory(right_maximum))
              {
                if (!(oi_out_of_memory(left_maximum)))
                    oi_remove_reference(left_maximum);
                *maximum = oi_null;
                *max_doubt = FALSE;
              }
            else if (left_max_doubt)
              {
                assert(oi_out_of_memory(left_maximum));
                if (!(oi_out_of_memory(right_maximum)))
                    oi_remove_reference(right_maximum);
                *maximum = oi_null;
                *max_doubt = TRUE;
              }
            else if (right_max_doubt)
              {
                assert(oi_out_of_memory(right_maximum));
                if (!(oi_out_of_memory(left_maximum)))
                    oi_remove_reference(left_maximum);
                *maximum = oi_null;
                *max_doubt = TRUE;
              }
            else
              {
                assert(!(oi_out_of_memory(left_maximum)));
                assert(!(oi_out_of_memory(right_maximum)));
                if (oi_less_than(left_maximum, right_maximum))
                  {
                    oi_remove_reference(right_maximum);
                    *maximum = left_maximum;
                  }
                else
                  {
                    oi_remove_reference(left_maximum);
                    *maximum = right_maximum;
                  }
                *max_doubt = FALSE;
              }

            if ((!left_min_doubt) && oi_out_of_memory(left_minimum))
              {
                if (!(oi_out_of_memory(right_minimum)))
                    oi_remove_reference(right_minimum);
                *minimum = oi_null;
                *min_doubt = FALSE;
              }
            else if ((!right_min_doubt) && oi_out_of_memory(right_minimum))
              {
                if (!(oi_out_of_memory(left_minimum)))
                    oi_remove_reference(left_minimum);
                *minimum = oi_null;
                *min_doubt = FALSE;
              }
            else if (left_min_doubt)
              {
                assert(oi_out_of_memory(left_minimum));
                if (!(oi_out_of_memory(right_minimum)))
                    oi_remove_reference(right_minimum);
                *minimum = oi_null;
                *min_doubt = TRUE;
              }
            else if (right_min_doubt)
              {
                assert(oi_out_of_memory(right_minimum));
                if (!(oi_out_of_memory(left_minimum)))
                    oi_remove_reference(left_minimum);
                *minimum = oi_null;
                *min_doubt = TRUE;
              }
            else
              {
                assert(!(oi_out_of_memory(left_minimum)));
                assert(!(oi_out_of_memory(right_minimum)));
                if (oi_less_than(left_minimum, right_minimum))
                  {
                    oi_remove_reference(left_minimum);
                    *minimum = right_minimum;
                  }
                else
                  {
                    oi_remove_reference(right_minimum);
                    *minimum = left_minimum;
                  }
                *min_doubt = FALSE;
              }

            return;
          }
        case TK_UNION:
          {
            o_integer left_minimum;
            o_integer left_maximum;
            boolean left_min_doubt;
            boolean left_max_doubt;
            o_integer right_minimum;
            o_integer right_maximum;
            boolean right_min_doubt;
            boolean right_max_doubt;

            find_type_integer_bounds(the_type->u.union_type.left,
                    &left_minimum, &left_maximum, &left_min_doubt,
                    &left_max_doubt, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return;

            find_type_integer_bounds(the_type->u.union_type.right,
                    &right_minimum, &right_maximum, &right_min_doubt,
                    &right_max_doubt, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if (!(oi_out_of_memory(left_minimum)))
                    oi_remove_reference(left_minimum);
                if (!(oi_out_of_memory(left_maximum)))
                    oi_remove_reference(left_maximum);
                return;
              }

            if (left_max_doubt)
              {
                assert(oi_out_of_memory(left_maximum));
                if ((!right_max_doubt) && (!(oi_out_of_memory(right_maximum)))
                    && (oi_kind(right_maximum) == IIK_POSITIVE_INFINITY))
                  {
                    *maximum = right_maximum;
                    *max_doubt = FALSE;
                  }
                else
                  {
                    if (!(oi_out_of_memory(right_maximum)))
                        oi_remove_reference(right_maximum);
                    *maximum = oi_null;
                    *max_doubt = TRUE;
                  }
              }
            else
              {
                if (oi_out_of_memory(left_maximum))
                  {
                    *maximum = right_maximum;
                    *max_doubt = right_max_doubt;
                  }
                else
                  {
                    if (right_max_doubt)
                      {
                        assert(oi_out_of_memory(right_maximum));
                        if (oi_kind(left_maximum) == IIK_POSITIVE_INFINITY)
                          {
                            *maximum = left_maximum;
                            *max_doubt = FALSE;
                          }
                        else
                          {
                            oi_remove_reference(left_maximum);
                            *maximum = oi_null;
                            *max_doubt = TRUE;
                          }
                      }
                    else
                      {
                        if (oi_out_of_memory(right_maximum))
                          {
                            *maximum = left_maximum;
                          }
                        else
                          {
                            if (oi_less_than(left_maximum, right_maximum))
                              {
                                oi_remove_reference(left_maximum);
                                *maximum = right_maximum;
                              }
                            else
                              {
                                oi_remove_reference(right_maximum);
                                *maximum = left_maximum;
                              }
                          }
                        *max_doubt = FALSE;
                      }
                  }
              }

            if (left_min_doubt)
              {
                assert(oi_out_of_memory(left_minimum));
                if ((!right_min_doubt) && (!(oi_out_of_memory(right_minimum)))
                    && (oi_kind(right_minimum) == IIK_NEGATIVE_INFINITY))
                  {
                    *minimum = right_minimum;
                    *min_doubt = FALSE;
                  }
                else
                  {
                    if (!(oi_out_of_memory(right_minimum)))
                        oi_remove_reference(right_minimum);
                    *minimum = oi_null;
                    *min_doubt = TRUE;
                  }
              }
            else
              {
                if (oi_out_of_memory(left_minimum))
                  {
                    *minimum = right_minimum;
                    *min_doubt = right_min_doubt;
                  }
                else
                  {
                    if (right_min_doubt)
                      {
                        assert(oi_out_of_memory(right_minimum));
                        if (oi_kind(left_minimum) == IIK_NEGATIVE_INFINITY)
                          {
                            *minimum = left_minimum;
                            *min_doubt = FALSE;
                          }
                        else
                          {
                            oi_remove_reference(left_minimum);
                            *minimum = oi_null;
                            *min_doubt = TRUE;
                          }
                      }
                    else
                      {
                        if (oi_out_of_memory(right_minimum))
                          {
                            *minimum = left_minimum;
                          }
                        else
                          {
                            if (oi_less_than(left_minimum, right_minimum))
                              {
                                oi_remove_reference(right_minimum);
                                *minimum = left_minimum;
                              }
                            else
                              {
                                oi_remove_reference(left_minimum);
                                *minimum = right_minimum;
                              }
                          }
                        *min_doubt = FALSE;
                      }
                  }
              }

            return;
          }
        case TK_XOR:
          {
            o_integer left_minimum;
            o_integer left_maximum;
            boolean left_min_doubt;
            boolean left_max_doubt;
            o_integer right_minimum;
            o_integer right_maximum;
            boolean right_min_doubt;
            boolean right_max_doubt;

            find_type_integer_bounds(the_type->u.xor.left, &left_minimum,
                    &left_maximum, &left_min_doubt, &left_max_doubt, location,
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return;

            find_type_integer_bounds(the_type->u.xor.right, &right_minimum,
                    &right_maximum, &right_min_doubt, &right_max_doubt,
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                if (!(oi_out_of_memory(left_minimum)))
                    oi_remove_reference(left_minimum);
                if (!(oi_out_of_memory(left_maximum)))
                    oi_remove_reference(left_maximum);
                return;
              }

            if (left_max_doubt)
              {
                assert(oi_out_of_memory(left_maximum));
                if (!(oi_out_of_memory(right_maximum)))
                    oi_remove_reference(right_maximum);
                *maximum = oi_null;
                *max_doubt = TRUE;
              }
            else if (right_max_doubt)
              {
                assert(oi_out_of_memory(right_maximum));
                if (!(oi_out_of_memory(left_maximum)))
                    oi_remove_reference(left_maximum);
                *maximum = oi_null;
                *max_doubt = TRUE;
              }
            else if (oi_out_of_memory(left_maximum))
              {
                *maximum = right_maximum;
                *max_doubt = FALSE;
              }
            else if (oi_out_of_memory(right_maximum))
              {
                *maximum = left_maximum;
                *max_doubt = FALSE;
              }
            else if (oi_less_than(left_maximum, right_maximum))
              {
                oi_remove_reference(left_maximum);
                *maximum = right_maximum;
                *max_doubt = FALSE;
              }
            else if (oi_less_than(right_maximum, left_maximum))
              {
                oi_remove_reference(right_maximum);
                *maximum = left_maximum;
                *max_doubt = FALSE;
              }
            else
              {
                oi_remove_reference(left_maximum);
                oi_remove_reference(right_maximum);
                *maximum = oi_null;
                *max_doubt = TRUE;
              }

            if (left_min_doubt)
              {
                assert(oi_out_of_memory(left_minimum));
                if (!(oi_out_of_memory(right_minimum)))
                    oi_remove_reference(right_minimum);
                *minimum = oi_null;
                *min_doubt = TRUE;
              }
            else if (right_min_doubt)
              {
                assert(oi_out_of_memory(right_minimum));
                if (!(oi_out_of_memory(left_minimum)))
                    oi_remove_reference(left_minimum);
                *minimum = oi_null;
                *min_doubt = TRUE;
              }
            else if (oi_out_of_memory(left_minimum))
              {
                *minimum = right_minimum;
                *min_doubt = FALSE;
              }
            else if (oi_out_of_memory(right_minimum))
              {
                *minimum = left_minimum;
                *min_doubt = FALSE;
              }
            else if (oi_less_than(left_minimum, right_minimum))
              {
                oi_remove_reference(right_minimum);
                *minimum = left_minimum;
                *min_doubt = FALSE;
              }
            else if (oi_less_than(right_minimum, left_minimum))
              {
                oi_remove_reference(left_minimum);
                *minimum = right_minimum;
                *min_doubt = FALSE;
              }
            else
              {
                oi_remove_reference(left_minimum);
                oi_remove_reference(right_minimum);
                *minimum = oi_null;
                *min_doubt = TRUE;
              }

            return;
          }
        case TK_INTEGER_RANGES:
          {
            size_t component_count;

            component_count = the_type->u.integer_ranges.component_count;
            if (the_type->u.integer_ranges.includes_negative_infinity)
              {
                *minimum = oi_negative_infinity;
                oi_add_reference(*minimum);
              }
            else if (component_count > 0)
              {
                *minimum =
                        the_type->u.integer_ranges.components[0].lower_bound;
                oi_add_reference(*minimum);
              }
            else if (the_type->u.integer_ranges.includes_positive_infinity)
              {
                *minimum = oi_positive_infinity;
                oi_add_reference(*minimum);
              }
            else
              {
                *minimum = oi_null;
              }

            if (the_type->u.integer_ranges.includes_positive_infinity)
              {
                *maximum = oi_positive_infinity;
                oi_add_reference(*maximum);
              }
            else if (component_count > 0)
              {
                *maximum = the_type->u.integer_ranges.components[
                        component_count - 1].upper_bound;
                oi_add_reference(*maximum);
                assert(!(oi_out_of_memory(*minimum)));
              }
            else if (the_type->u.integer_ranges.includes_negative_infinity)
              {
                *maximum = oi_negative_infinity;
                oi_add_reference(*maximum);
                assert(!(oi_out_of_memory(*minimum)));
              }
            else
              {
                *maximum = oi_null;
                assert(oi_out_of_memory(*minimum));
              }

            *min_doubt = FALSE;
            *max_doubt = FALSE;
            return;
          }
        case TK_RATIONAL_RANGES:
          {
            size_t component_count;
            rational_range_component *components;

            *min_doubt = FALSE;
            *max_doubt = FALSE;

            component_count = the_type->u.rational_ranges.component_count;
            components = the_type->u.rational_ranges.components;

            if (the_type->u.rational_ranges.includes_negative_infinity)
              {
                *minimum = oi_negative_infinity;
                oi_add_reference(*minimum);
              }
            else
              {
                size_t component_num;

                *minimum = oi_null;
                for (component_num = 0; component_num < component_count;
                     ++component_num)
                  {
                    rational_range_component *this_component;
                    boolean error;

                    this_component = &(components[component_num]);
                    *minimum = minimum_integer_between_rationals(
                            this_component->lower_bound,
                            this_component->upper_bound,
                            this_component->lower_is_inclusive,
                            this_component->upper_is_inclusive, &error);
                    if (error)
                      {
                        jumper_do_abort(the_jumper);
                        return;
                      }
                    if (!(oi_out_of_memory(*minimum)))
                        break;
                  }
              }

            if (the_type->u.rational_ranges.includes_positive_infinity)
              {
                *maximum = oi_positive_infinity;
                oi_add_reference(*maximum);
              }
            else
              {
                size_t component_num;

                *maximum = oi_null;
                for (component_num = 0; component_num < component_count;
                     ++component_num)
                  {
                    rational_range_component *this_component;
                    boolean error;

                    this_component = &(components[
                            component_count - (component_num + 1)]);
                    *maximum = maximum_integer_between_rationals(
                            this_component->lower_bound,
                            this_component->upper_bound,
                            this_component->lower_is_inclusive,
                            this_component->upper_is_inclusive, &error);
                    if (error)
                      {
                        jumper_do_abort(the_jumper);
                        oi_remove_reference(*maximum);
                        return;
                      }
                    if (!(oi_out_of_memory(*maximum)))
                        break;
                  }
              }

            return;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            *minimum = oi_null;
            *maximum = oi_null;
            *min_doubt = TRUE;
            *max_doubt = TRUE;
            return;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return;
          }
        default:
          {
            assert(FALSE);
            return;
          }
      }
  }

extern type *shift_and_box_type(type *base, o_integer shift_amount,
        o_integer box_lower, o_integer box_upper,
        const source_location *location, jumper *the_jumper)
  {
    assert(base != NULL);
    assert(!(oi_out_of_memory(shift_amount)));
    assert(!(oi_out_of_memory(box_lower)));
    assert(!(oi_out_of_memory(box_upper)));
    assert(the_jumper != NULL);

    assert(type_is_valid(base)); /* VERIFIED */

    switch (base->kind)
      {
        case TK_ANYTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
          {
            type *result;

            result = get_integer_range_type(box_lower, box_upper, TRUE, TRUE);
            if (result == NULL)
                jumper_do_abort(the_jumper);
            return result;
          }
        case TK_NOTHING:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
        case TK_ARRAY:
        case TK_POINTER:
        case TK_TYPE:
        case TK_MAP:
        case TK_ROUTINE:
        case TK_FIELDS:
        case TK_LEPTON:
        case TK_MULTISET:
        case TK_INTERFACE:
        case TK_SEMI_LABELED_VALUE_LIST:
        case TK_REGULAR_EXPRESSION:
        case TK_CLASS:
          {
            type *result;

          do_nothing:
            result = get_nothing_type();
            if (result == NULL)
                jumper_do_abort(the_jumper);
            return result;
          }
        case TK_ENUMERATION:
          {
            size_t old_count;
            value **old_values;
            value **new_values;
            size_t new_count;
            size_t old_num;
            type *result;

            old_count = base->u.enumeration.value_count;
            if (old_count == 0)
                goto do_nothing;

            old_values = base->u.enumeration.values;
            new_values = MALLOC_ARRAY(value *, old_count);
            if (new_values == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            new_count = 0;

            for (old_num = 0; old_num < old_count; ++old_num)
              {
                value *old_value;
                o_integer old_oi;
                o_integer new_oi;
                value *new_value;

                old_value = old_values[old_num];
                assert(old_value != NULL);
                assert(value_is_valid(old_value)); /* VERIFIED */

                if (get_value_kind(old_value) != VK_INTEGER)
                    continue;

                old_oi = integer_value_data(old_value);
                assert(!(oi_out_of_memory(old_oi)));

                if ((oi_kind(old_oi) != IIK_FINITE) &&
                    (oi_kind(old_oi) != IIK_POSITIVE_INFINITY) &&
                    (oi_kind(old_oi) != IIK_NEGATIVE_INFINITY))
                  {
                    continue;
                  }

                oi_subtract(new_oi, old_oi, shift_amount);
                if (oi_out_of_memory(new_oi))
                  {
                    jumper_do_abort(the_jumper);
                    while (new_count > 0)
                      {
                        --new_count;
                        value_remove_reference(new_values[new_count],
                                               the_jumper);
                      }
                    free(new_values);
                    return NULL;
                  }

                if (oi_less_than(new_oi, box_lower) ||
                    oi_less_than(box_upper, new_oi))
                  {
                    oi_remove_reference(new_oi);
                    continue;
                  }

                new_value = create_integer_value(new_oi);
                oi_remove_reference(new_oi);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    while (new_count > 0)
                      {
                        --new_count;
                        value_remove_reference(new_values[new_count],
                                               the_jumper);
                      }
                    free(new_values);
                    return NULL;
                  }

                new_values[new_count] = new_value;
                ++new_count;
              }

            if (new_count == 0)
              {
                free(new_values);
                goto do_nothing;
              }

            result = get_enumeration_type(new_count, new_values);
            while (new_count > 0)
              {
                --new_count;
                value_remove_reference(new_values[new_count], the_jumper);
              }
            free(new_values);
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            return result;
          }
        case TK_NOT:
          {
            type *range;
            type *second;
            type *result;

            range = get_integer_range_type(box_lower, box_upper, TRUE, TRUE);
            if (range == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }

            second = shift_and_box_type(base->u.not.base, shift_amount,
                    box_lower, box_upper, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(range, the_jumper);
                return NULL;
              }
            assert(second != NULL);

            result = get_intersection_type(range, second);
            type_remove_reference(range, the_jumper);
            type_remove_reference(second, the_jumper);
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            return result;
          }
        case TK_INTERSECTION:
          {
            type *left;
            type *right;
            type *result;

            left = shift_and_box_type(base->u.intersection.left, shift_amount,
                    box_lower, box_upper, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;
            assert(left != NULL);

            right = shift_and_box_type(base->u.intersection.right,
                    shift_amount, box_lower, box_upper, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(left, the_jumper);
                return NULL;
              }
            assert(right != NULL);

            result = get_intersection_type(left, right);
            type_remove_reference(left, the_jumper);
            type_remove_reference(right, the_jumper);
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            return result;
          }
        case TK_UNION:
          {
            type *left;
            type *right;
            type *result;

            left = shift_and_box_type(base->u.union_type.left, shift_amount,
                    box_lower, box_upper, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;
            assert(left != NULL);

            right = shift_and_box_type(base->u.union_type.right, shift_amount,
                    box_lower, box_upper, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(left, the_jumper);
                return NULL;
              }
            assert(right != NULL);

            result = get_union_type(left, right);
            type_remove_reference(left, the_jumper);
            type_remove_reference(right, the_jumper);
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            return result;
          }
        case TK_XOR:
          {
            type *left;
            type *right;
            type *result;

            left = shift_and_box_type(base->u.xor.left, shift_amount,
                    box_lower, box_upper, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;
            assert(left != NULL);

            right = shift_and_box_type(base->u.xor.right, shift_amount,
                    box_lower, box_upper, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(left, the_jumper);
                return NULL;
              }
            assert(right != NULL);

            result = get_xor_type(left, right);
            type_remove_reference(left, the_jumper);
            type_remove_reference(right, the_jumper);
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            return result;
          }
        case TK_INTEGER_RANGES:
          {
            boolean new_includes_positive_infinity;
            boolean new_includes_negative_infinity;
            size_t old_component_count;
            integer_range_component *old_components;
            size_t new_component_count;
            integer_range_component *new_components;
            type *result;

            if (oi_kind(box_upper) != IIK_POSITIVE_INFINITY)
              {
                new_includes_positive_infinity = FALSE;
              }
            else
              {
                switch (oi_kind(shift_amount))
                  {
                    case IIK_FINITE:
                    case IIK_POSITIVE_INFINITY:
                        new_includes_positive_infinity =
                                base->u.integer_ranges.
                                        includes_positive_infinity;
                        break;
                    case IIK_NEGATIVE_INFINITY:
                    case IIK_UNSIGNED_INFINITY:
                    case IIK_ZERO_ZERO:
                        new_includes_positive_infinity =
                                base->u.integer_ranges.includes_zero_zero;
                        break;
                    default:
                        assert(FALSE);
                  }
              }

            if (oi_kind(box_lower) != IIK_NEGATIVE_INFINITY)
              {
                new_includes_negative_infinity = FALSE;
              }
            else
              {
                switch (oi_kind(shift_amount))
                  {
                    case IIK_FINITE:
                    case IIK_NEGATIVE_INFINITY:
                        new_includes_negative_infinity =
                                base->u.integer_ranges.
                                        includes_negative_infinity;
                        break;
                    case IIK_POSITIVE_INFINITY:
                    case IIK_UNSIGNED_INFINITY:
                    case IIK_ZERO_ZERO:
                        new_includes_negative_infinity =
                                base->u.integer_ranges.includes_zero_zero;
                        break;
                    default:
                        assert(FALSE);
                  }
              }

            old_component_count = base->u.integer_ranges.component_count;
            old_components = base->u.integer_ranges.components;
            if (old_component_count == 0)
              {
                assert(old_components == NULL);
                new_component_count = 0;
                new_components = NULL;
              }
            else
              {
                size_t old_component_num;

                new_component_count = 0;
                new_components = MALLOC_ARRAY(integer_range_component,
                                              old_component_count);
                if (new_components == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return NULL;
                  }

                for (old_component_num = 0;
                     old_component_num < old_component_count;
                     ++old_component_num)
                  {
                    o_integer new_lower;
                    o_integer new_upper;

                    oi_subtract(new_lower,
                            old_components[old_component_num].lower_bound,
                            shift_amount);
                    if (oi_out_of_memory(new_lower))
                      {
                        jumper_do_abort(the_jumper);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            oi_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            oi_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }

                    if (oi_less_than(new_lower, box_lower))
                      {
                        oi_add_reference(box_lower);
                        oi_remove_reference(new_lower);
                        new_lower = box_lower;
                      }

                    oi_subtract(new_upper,
                            old_components[old_component_num].upper_bound,
                            shift_amount);
                    if (oi_out_of_memory(new_upper))
                      {
                        jumper_do_abort(the_jumper);
                        oi_remove_reference(new_lower);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            oi_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            oi_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }

                    if (oi_less_than(box_upper, new_upper))
                      {
                        oi_add_reference(box_upper);
                        oi_remove_reference(new_upper);
                        new_upper = box_upper;
                      }

                    if (oi_less_than(new_upper, new_lower))
                      {
                        oi_remove_reference(new_lower);
                        oi_remove_reference(new_upper);
                        continue;
                      }

                    assert(new_component_count < old_component_count);
                    new_components[new_component_count].lower_bound =
                            new_lower;
                    new_components[new_component_count].upper_bound =
                            new_upper;
                    ++new_component_count;
                    assert(new_component_count <= old_component_count);
                  }

                if (new_component_count == 0)
                  {
                    free(new_components);
                    new_components = NULL;
                  }
                else if (new_component_count < old_component_count)
                  {
                    integer_range_component *compact_components;

                    compact_components = MALLOC_ARRAY(integer_range_component,
                                                      new_component_count);
                    if (compact_components == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            oi_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            oi_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }
                    memcpy(compact_components, new_components,
                           new_component_count *
                           sizeof(integer_range_component));
                    free(new_components);
                    new_components = compact_components;
                  }
              }

            if ((new_component_count == 0) &&
                (!new_includes_positive_infinity) &&
                (!new_includes_negative_infinity))
              {
                type *result;

                assert(new_components == NULL);
                result = get_nothing_type();
                if (result == NULL)
                    jumper_do_abort(the_jumper);
                else
                    type_add_reference(result);
                return result;
              }

            result = create_empty_type(TK_INTEGER_RANGES);
            if (result == NULL)
              {
                if (new_component_count > 0)
                  {
                    assert(new_components != NULL);
                    while (new_component_count > 0)
                      {
                        --new_component_count;
                        oi_remove_reference(
                                new_components[new_component_count].
                                        lower_bound);
                        oi_remove_reference(
                                new_components[new_component_count].
                                        upper_bound);
                      }
                    free(new_components);
                  }
                else
                  {
                    assert(new_components == NULL);
                  }
                jumper_do_abort(the_jumper);
                return NULL;
              }

            result->possible_value_kinds = VK_BIT(VK_INTEGER);

            result->u.integer_ranges.component_count = new_component_count;
            result->u.integer_ranges.components = new_components;
            result->u.integer_ranges.includes_positive_infinity =
                    new_includes_positive_infinity;
            result->u.integer_ranges.includes_negative_infinity =
                    new_includes_negative_infinity;
            result->u.integer_ranges.includes_unsigned_infinity = FALSE;
            result->u.integer_ranges.includes_zero_zero = FALSE;

            return result;
          }
        case TK_RATIONAL_RANGES:
          {
            boolean new_includes_positive_infinity;
            boolean new_includes_negative_infinity;
            size_t old_component_count;
            rational_range_component *old_components;
            size_t new_component_count;
            rational_range_component *new_components;
            boolean non_integer;
            type *result;

            if (oi_kind(box_upper) != IIK_POSITIVE_INFINITY)
              {
                new_includes_positive_infinity = FALSE;
              }
            else
              {
                switch (oi_kind(shift_amount))
                  {
                    case IIK_FINITE:
                    case IIK_POSITIVE_INFINITY:
                        new_includes_positive_infinity =
                                base->u.rational_ranges.
                                        includes_positive_infinity;
                        break;
                    case IIK_NEGATIVE_INFINITY:
                    case IIK_UNSIGNED_INFINITY:
                    case IIK_ZERO_ZERO:
                        new_includes_positive_infinity =
                                base->u.rational_ranges.includes_zero_zero;
                        break;
                    default:
                        assert(FALSE);
                  }
              }

            if (oi_kind(box_lower) != IIK_NEGATIVE_INFINITY)
              {
                new_includes_negative_infinity = FALSE;
              }
            else
              {
                switch (oi_kind(shift_amount))
                  {
                    case IIK_FINITE:
                    case IIK_NEGATIVE_INFINITY:
                        new_includes_negative_infinity =
                                base->u.rational_ranges.
                                        includes_negative_infinity;
                        break;
                    case IIK_POSITIVE_INFINITY:
                    case IIK_UNSIGNED_INFINITY:
                    case IIK_ZERO_ZERO:
                        new_includes_negative_infinity =
                                base->u.rational_ranges.includes_zero_zero;
                        break;
                    default:
                        assert(FALSE);
                  }
              }

            old_component_count = base->u.rational_ranges.component_count;
            old_components = base->u.rational_ranges.components;
            if (old_component_count == 0)
              {
                assert(old_components == NULL);
                new_component_count = 0;
                new_components = NULL;
                non_integer = FALSE;
              }
            else
              {
                size_t old_component_num;
                rational *rational_shift_amount;

                new_component_count = 0;
                new_components = MALLOC_ARRAY(rational_range_component,
                                              old_component_count);
                if (new_components == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return NULL;
                  }

                non_integer = FALSE;

                rational_shift_amount = create_rational(shift_amount, oi_one);
                if (rational_shift_amount == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    free(new_components);
                    return NULL;
                  }

                for (old_component_num = 0;
                     old_component_num < old_component_count;
                     ++old_component_num)
                  {
                    rational *new_lower;
                    boolean error;
                    boolean hits_lower;
                    boolean new_lower_is_inclusive;
                    rational *new_upper;
                    boolean hits_upper;
                    boolean new_upper_is_inclusive;
                    boolean empty;

                    new_lower = rational_subtract(
                            old_components[old_component_num].lower_bound,
                            rational_shift_amount);
                    if (new_lower == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        rational_remove_reference(rational_shift_amount);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }

                    hits_lower = rational_less_than_integer(new_lower,
                                                            box_lower, &error);
                    if (error)
                      {
                        jumper_do_abort(the_jumper);
                        rational_remove_reference(new_lower);
                        rational_remove_reference(rational_shift_amount);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }
                    if (hits_lower)
                      {
                        rational_remove_reference(new_lower);
                        new_lower = create_rational(box_lower, oi_one);
                        if (new_lower == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            rational_remove_reference(rational_shift_amount);
                            while (new_component_count > 0)
                              {
                                --new_component_count;
                                rational_remove_reference(
                                        new_components[new_component_count].
                                                lower_bound);
                                rational_remove_reference(
                                        new_components[new_component_count].
                                                upper_bound);
                              }
                            free(new_components);
                            return NULL;
                          }
                        new_lower_is_inclusive = TRUE;
                      }
                    else
                      {
                        new_lower_is_inclusive =
                                old_components[old_component_num].
                                        lower_is_inclusive;
                      }

                    new_upper = rational_subtract(
                            old_components[old_component_num].upper_bound,
                            rational_shift_amount);
                    if (new_upper == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        rational_remove_reference(new_lower);
                        rational_remove_reference(rational_shift_amount);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }

                    hits_upper = integer_less_than_rational(box_upper,
                                                            new_upper, &error);
                    if (error)
                      {
                        jumper_do_abort(the_jumper);
                        rational_remove_reference(new_upper);
                        rational_remove_reference(new_lower);
                        rational_remove_reference(rational_shift_amount);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }
                    if (hits_upper)
                      {
                        rational_remove_reference(new_upper);
                        new_upper = create_rational(box_upper, oi_one);
                        if (new_upper == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            rational_remove_reference(new_lower);
                            rational_remove_reference(rational_shift_amount);
                            while (new_component_count > 0)
                              {
                                --new_component_count;
                                rational_remove_reference(
                                        new_components[new_component_count].
                                                lower_bound);
                                rational_remove_reference(
                                        new_components[new_component_count].
                                                upper_bound);
                              }
                            free(new_components);
                            return NULL;
                          }
                        new_upper_is_inclusive = TRUE;
                      }
                    else
                      {
                        new_upper_is_inclusive =
                                old_components[old_component_num].
                                        upper_is_inclusive;
                      }

                    if (new_upper_is_inclusive && new_lower_is_inclusive)
                      {
                        empty = rational_less_than(new_upper, new_lower,
                                                   &error);
                      }
                    else
                      {
                        empty = !(rational_less_than(new_lower, new_upper,
                                                     &error));
                      }
                    if (error)
                      {
                        jumper_do_abort(the_jumper);
                        rational_remove_reference(new_upper);
                        rational_remove_reference(new_lower);
                        rational_remove_reference(rational_shift_amount);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }
                    if (empty)
                      {
                        rational_remove_reference(new_lower);
                        rational_remove_reference(new_upper);
                        continue;
                      }

                    if ((!non_integer) &&
                        !(rationals_are_equal(new_lower, new_upper) &&
                          rational_is_integer(new_lower)))
                      {
                        non_integer = TRUE;
                      }

                    assert(new_component_count < old_component_count);
                    new_components[new_component_count].lower_bound =
                            new_lower;
                    new_components[new_component_count].upper_bound =
                            new_upper;
                    new_components[new_component_count].lower_is_inclusive =
                            new_lower_is_inclusive;
                    new_components[new_component_count].upper_is_inclusive =
                            new_upper_is_inclusive;
                    ++new_component_count;
                    assert(new_component_count <= old_component_count);
                  }

                rational_remove_reference(rational_shift_amount);

                if (new_component_count == 0)
                  {
                    free(new_components);
                    new_components = NULL;
                  }
                else if (new_component_count < old_component_count)
                  {
                    rational_range_component *compact_components;

                    compact_components = MALLOC_ARRAY(rational_range_component,
                                                      new_component_count);
                    if (compact_components == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }
                    memcpy(compact_components, new_components,
                           new_component_count *
                           sizeof(rational_range_component));
                    free(new_components);
                    new_components = compact_components;
                  }
              }

            if ((new_component_count == 0) &&
                (!new_includes_positive_infinity) &&
                (!new_includes_negative_infinity))
              {
                type *result;

                assert(new_components == NULL);
                result = get_nothing_type();
                if (result == NULL)
                    jumper_do_abort(the_jumper);
                else
                    type_add_reference(result);
                return result;
              }

            if (!non_integer)
              {
                integer_range_component *integer_components;
                type *result;

                if (new_component_count > 0)
                  {
                    size_t component_num;

                    assert(new_components != NULL);
                    integer_components = MALLOC_ARRAY(integer_range_component,
                                                      new_component_count);
                    if (integer_components == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            lower_bound);
                            rational_remove_reference(
                                    new_components[new_component_count].
                                            upper_bound);
                          }
                        free(new_components);
                        return NULL;
                      }

                    for (component_num = 0;
                         component_num < new_component_count; ++component_num)
                      {
                        rational *rational_lower;
                        rational *rational_upper;
                        o_integer the_integer;

                        rational_lower =
                                new_components[component_num].lower_bound;
                        rational_upper =
                                new_components[component_num].upper_bound;

                        assert(rationals_are_equal(rational_lower,
                                                   rational_upper));
                        assert(rational_is_integer(rational_lower));
                        the_integer = rational_numerator(rational_lower);
                        oi_add_reference(the_integer);
                        oi_add_reference(the_integer);
                        integer_components[component_num].lower_bound =
                                the_integer;
                        integer_components[component_num].upper_bound =
                                the_integer;
                        rational_remove_reference(rational_lower);
                        rational_remove_reference(rational_upper);
                      }

                    free(new_components);
                  }
                else
                  {
                    assert(new_components == NULL);
                    integer_components = NULL;
                  }

                result = create_empty_type(TK_INTEGER_RANGES);
                if (result == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    if (new_component_count > 0)
                      {
                        assert(integer_components != NULL);
                        while (new_component_count > 0)
                          {
                            --new_component_count;
                            oi_remove_reference(
                                    integer_components[new_component_count].
                                            lower_bound);
                            oi_remove_reference(
                                    integer_components[new_component_count].
                                            upper_bound);
                          }
                        free(integer_components);
                      }
                    else
                      {
                        assert(integer_components == NULL);
                      }
                    return NULL;
                  }

                result->possible_value_kinds = VK_BIT(VK_INTEGER);

                result->u.integer_ranges.component_count = new_component_count;
                result->u.integer_ranges.components = integer_components;
                result->u.integer_ranges.includes_positive_infinity =
                        new_includes_positive_infinity;
                result->u.integer_ranges.includes_negative_infinity =
                        new_includes_negative_infinity;
                result->u.integer_ranges.includes_unsigned_infinity = FALSE;
                result->u.integer_ranges.includes_zero_zero = FALSE;

                return result;
              }

            result = create_empty_type(TK_RATIONAL_RANGES);
            if (result == NULL)
              {
                jumper_do_abort(the_jumper);
                if (new_component_count > 0)
                  {
                    assert(new_components != NULL);
                    while (new_component_count > 0)
                      {
                        --new_component_count;
                        rational_remove_reference(
                                new_components[new_component_count].
                                        lower_bound);
                        rational_remove_reference(
                                new_components[new_component_count].
                                        upper_bound);
                      }
                    free(new_components);
                  }
                else
                  {
                    assert(new_components == NULL);
                  }
                return NULL;
              }

            result->possible_value_kinds =
                    (VK_BIT(VK_INTEGER) | VK_BIT(VK_RATIONAL));

            result->u.rational_ranges.component_count = new_component_count;
            result->u.rational_ranges.components = new_components;
            result->u.rational_ranges.includes_positive_infinity =
                    new_includes_positive_infinity;
            result->u.rational_ranges.includes_negative_infinity =
                    new_includes_negative_infinity;
            result->u.rational_ranges.includes_unsigned_infinity = FALSE;
            result->u.rational_ranges.includes_zero_zero = FALSE;

            return result;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            static const char *actual_names[3] =
              { "base", "box", "shift_amount" };

            type *range_type;
            value *function_value;
            value *base_value;
            value *actual_values[3];
            value *range_value;
            value *shift_value;
            value *second_value;
            type *result;

            function_value = shift_type_function_value(the_jumper);
            if (function_value == NULL)
                return NULL;

            base_value = create_type_value(base);
            if (base_value == NULL)
              {
                jumper_do_abort(the_jumper);
                return NULL;
              }
            actual_values[0] = base_value;

            range_type =
                    get_integer_range_type(box_lower, box_upper, TRUE, TRUE);
            if (range_type == NULL)
              {
                jumper_do_abort(the_jumper);
                value_remove_reference(base_value, the_jumper);
                return NULL;
              }

            range_value = create_type_value(range_type);
            if (range_value == NULL)
              {
                jumper_do_abort(the_jumper);
                type_remove_reference(range_type, the_jumper);
                value_remove_reference(base_value, the_jumper);
                return NULL;
              }
            type_remove_reference(range_type, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                value_remove_reference(range_value, the_jumper);
                value_remove_reference(base_value, the_jumper);
                return NULL;
              }
            actual_values[1] = range_value;

            shift_value = create_integer_value(shift_amount);
            if (shift_value == NULL)
              {
                jumper_do_abort(the_jumper);
                value_remove_reference(range_value, the_jumper);
                value_remove_reference(base_value, the_jumper);
                return NULL;
              }
            actual_values[2] = shift_value;

            second_value = execute_call_from_arrays(function_value, 3,
                    &(actual_names[0]), &(actual_values[0]), TRUE, the_jumper,
                    location);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(second_value == NULL);
                value_remove_reference(shift_value, the_jumper);
                value_remove_reference(range_value, the_jumper);
                value_remove_reference(base_value, the_jumper);
                return NULL;
              }
            assert(second_value != NULL);

            value_remove_reference(shift_value, the_jumper);
            value_remove_reference(range_value, the_jumper);
            value_remove_reference(base_value, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                value_remove_reference(second_value, the_jumper);
                return NULL;
              }

            assert(value_is_valid(second_value)); /* VERIFIED */
            assert(get_value_kind(second_value) == VK_TYPE);
            result = type_value_data(second_value);
            assert(result != NULL);
            assert(type_is_valid(result)); /* VERIFIED */
            type_add_reference(result);
            value_remove_reference(second_value, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }

            return result;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return NULL;
          }
        default:
          {
            assert(FALSE);
            return NULL;
          }
      }
  }

extern boolean type_has_finite_element_count(type *base, boolean *doubt)
  {
    assert(base != NULL);
    assert(doubt != NULL);

    assert(type_is_valid(base)); /* VERIFIED */

    switch (base->kind)
      {
        case TK_ANYTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
        case TK_POINTER:
        case TK_ROUTINE:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_NOTHING:
        case TK_ENUMERATION:
          {
            *doubt = FALSE;
            return TRUE;
          }
        case TK_NOT:
          {
            boolean base_result;
            boolean base_doubt;

            base_result = type_has_finite_element_count(base->u.not.base,
                                                        &base_doubt);
            if (base_result && !base_doubt)
              {
                *doubt = FALSE;
                return FALSE;
              }

            *doubt = TRUE;
            return FALSE;
          }
        case TK_INTERSECTION:
          {
            boolean left_result;
            boolean left_doubt;
            boolean right_result;
            boolean right_doubt;

            left_result = type_has_finite_element_count(
                    base->u.intersection.left, &left_doubt);
            if (left_result && !left_doubt)
              {
                *doubt = FALSE;
                return TRUE;
              }

            right_result = type_has_finite_element_count(
                    base->u.intersection.right, &right_doubt);
            if (right_result && !right_doubt)
              {
                *doubt = FALSE;
                return TRUE;
              }

            if ((!left_doubt) && (!right_doubt))
              {
                if (left_result != right_result)
                    return FALSE;
              }

            *doubt = TRUE;
            return FALSE;
          }
        case TK_UNION:
          {
            boolean left_result;
            boolean left_doubt;
            boolean right_result;
            boolean right_doubt;

            left_result = type_has_finite_element_count(
                    base->u.union_type.left, &left_doubt);
            if ((!left_result) && !left_doubt)
              {
                *doubt = FALSE;
                return FALSE;
              }

            right_result = type_has_finite_element_count(
                    base->u.union_type.right, &right_doubt);
            if ((!right_result) && !right_doubt)
              {
                *doubt = FALSE;
                return FALSE;
              }

            if ((!left_doubt) && (!right_doubt))
              {
                *doubt = FALSE;
                return TRUE;
              }

            *doubt = TRUE;
            return FALSE;
          }
        case TK_XOR:
          {
            boolean left_result;
            boolean left_doubt;
            boolean right_result;
            boolean right_doubt;

            left_result = type_has_finite_element_count(base->u.xor.left,
                                                        &left_doubt);
            if (left_doubt)
              {
                *doubt = TRUE;
                return FALSE;
              }

            right_result = type_has_finite_element_count(base->u.xor.right,
                                                         &right_doubt);
            if (right_doubt)
              {
                *doubt = TRUE;
                return FALSE;
              }

            if (left_result && right_result)
              {
                *doubt = FALSE;
                return TRUE;
              }

            *doubt = TRUE;
            return FALSE;
          }
        case TK_ARRAY:
          {
            o_integer lower_bound;
            o_integer upper_bound;

            if (base->u.array.base->kind == TK_NOTHING)
              {
                *doubt = FALSE;
                return TRUE;
              }

            lower_bound = base->u.array.lower_bound;
            upper_bound = base->u.array.upper_bound;

            if (range_is_finite(lower_bound, upper_bound))
              {
                return type_has_finite_element_count(base->u.array.base,
                                                     doubt);
              }
            else
              {
                *doubt = possibly_nothing(base->u.array.base);
                return FALSE;
              }
          }
        case TK_INTEGER_RANGES:
          {
            size_t component_count;
            integer_range_component *components;
            size_t component_num;

            *doubt = FALSE;

            component_count = base->u.integer_ranges.component_count;
            components = base->u.integer_ranges.components;

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                if (!(range_is_finite(components[component_num].lower_bound,
                                      components[component_num].upper_bound)))
                  {
                    return FALSE;
                  }
              }

            return TRUE;
          }
        case TK_RATIONAL_RANGES:
          {
            size_t component_count;
            rational_range_component *components;
            size_t component_num;

            *doubt = FALSE;

            component_count = base->u.rational_ranges.component_count;
            components = base->u.rational_ranges.components;

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                if (!(rationals_are_equal(
                              components[component_num].lower_bound,
                              components[component_num].upper_bound)))
                  {
                    return FALSE;
                  }
              }

            return TRUE;
          }
        case TK_TYPE:
          {
            return type_has_finite_element_count(base->u.pointer.base, doubt);
          }
        case TK_MAP:
          {
            boolean key_result;
            boolean key_doubt;
            boolean target_result;
            boolean target_doubt;

            key_result =
                    type_has_finite_element_count(base->u.map.key, &key_doubt);
            target_result = type_has_finite_element_count(base->u.map.target,
                                                          &target_doubt);

            if ((!key_doubt) && (!target_doubt) && key_result && target_result)
              {
                *doubt = FALSE;
                return TRUE;
              }

            if ((!key_doubt) && (!key_result) &&
                !(possibly_nothing(base->u.map.target)))
              {
                *doubt = FALSE;
                return FALSE;
              }

            if ((!target_doubt) && (!target_result) &&
                !(possibly_nothing(base->u.map.key)))
              {
                *doubt = FALSE;
                return FALSE;
              }

            *doubt = TRUE;
            return FALSE;
          }
        case TK_FIELDS:
        case TK_LEPTON:
        case TK_INTERFACE:
          {
            *doubt = possibly_nothing(base);
            return FALSE;
          }
        case TK_MULTISET:
          {
            size_t field_num;

            if (base->u.multiset.field_info.extra_fields_allowed)
              {
                *doubt = possibly_nothing(base);
                return FALSE;
              }

            *doubt = FALSE;

            for (field_num = 0;
                 field_num < base->u.multiset.field_info.field_count;
                 ++field_num)
              {
                boolean local_doubt;
                boolean local_finite;

                if (base->u.multiset.field_info.field_names[field_num] == NULL)
                  {
                    *doubt = possibly_nothing(base);
                    return FALSE;
                  }

                local_finite = type_has_finite_element_count(
                        base->u.multiset.field_info.field_types[field_num],
                        &local_doubt);
                if (local_doubt)
                  {
                    *doubt = TRUE;
                  }
                else if (!local_finite)
                  {
                    *doubt = possibly_nothing(base);
                    return FALSE;
                  }
              }

            return TRUE;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t element_num;

            if (base->u.semi_labeled_value_list.extra_elements_allowed)
              {
                *doubt = possibly_nothing(base);
                return FALSE;
              }

            *doubt = FALSE;

            for (element_num = 0;
                 element_num < base->u.semi_labeled_value_list.element_count;
                 ++element_num)
              {
                boolean local_doubt;
                boolean local_finite;

                if (base->u.semi_labeled_value_list.element_names[element_num]
                    == NULL)
                  {
                    *doubt = possibly_nothing(base);
                    return FALSE;
                  }

                local_finite = type_has_finite_element_count(
                        base->u.semi_labeled_value_list.element_types[
                                element_num], &local_doubt);
                if (local_doubt)
                  {
                    *doubt = TRUE;
                  }
                else if (!local_finite)
                  {
                    *doubt = possibly_nothing(base);
                    return FALSE;
                  }
              }

            return TRUE;
          }
        case TK_REGULAR_EXPRESSION:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_CLASS:
          {
            *doubt = possibly_nothing(base);
            return FALSE;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return FALSE;
          }
        default:
          {
            assert(FALSE);
            return FALSE;
          }
      }
  }

extern void type_message_deallocate(char *message)
  {
    assert(message != NULL);

    free(message);
  }

extern verdict init_type_module(void)
  {
    all_possible_value_kinds =
            (VK_BIT(VK_TRUE) | VK_BIT(VK_FALSE) | VK_BIT(VK_INTEGER) |
             VK_BIT(VK_RATIONAL) | VK_BIT(VK_STRING) | VK_BIT(VK_CHARACTER) |
             VK_BIT(VK_REGULAR_EXPRESSION) |
             VK_BIT(VK_SEMI_LABELED_VALUE_LIST) |
             VK_BIT(VK_SEMI_LABELED_MULTI_SET) | VK_BIT(VK_MAP) |
             VK_BIT(VK_QUARK) | VK_BIT(VK_LEPTON) | VK_BIT(VK_LEPTON_KEY) |
             VK_BIT(VK_SLOT_LOCATION) | VK_BIT(VK_NULL) |
             VK_BIT(VK_JUMP_TARGET) | VK_BIT(VK_ROUTINE) |
             VK_BIT(VK_ROUTINE_CHAIN) | VK_BIT(VK_TYPE) | VK_BIT(VK_OBJECT) |
             VK_BIT(VK_TAGALONG_KEY) | VK_BIT(VK_LOCK));

    assert(anything_type == NULL);
    anything_type = create_empty_type(TK_ANYTHING);
    if (anything_type == NULL)
        goto anything_failure;
    anything_type->possible_value_kinds = all_possible_value_kinds;

    assert(nothing_type == NULL);
    nothing_type = create_empty_type(TK_NOTHING);
    if (nothing_type == NULL)
        goto nothing_failure;
    nothing_type->possible_value_kinds = 0;

    assert(integer_type == NULL);
    integer_type = create_empty_type(TK_INTEGER);
    if (integer_type == NULL)
        goto integer_failure;
    integer_type->possible_value_kinds = VK_BIT(VK_INTEGER);

    assert(finite_integer_type == NULL);
      {
        value *values[4];
        type *enumeration;
        type *not_type;

        assert(integer_type != NULL);

        values[0] = create_integer_value(oi_positive_infinity);
        if (values[0] == NULL)
            goto finite_integer_failure;

        values[1] = create_integer_value(oi_negative_infinity);
        if (values[1] == NULL)
            goto values1_failure;

        values[2] = create_integer_value(oi_unsigned_infinity);
        if (values[2] == NULL)
            goto values2_failure;

        values[3] = create_integer_value(oi_zero_zero);
        if (values[3] == NULL)
          {
            value_remove_reference(values[2], NULL);
          values2_failure:
            value_remove_reference(values[1], NULL);
          values1_failure:
            value_remove_reference(values[0], NULL);
            goto finite_integer_failure;
          }

        assert(value_is_valid(values[0])); /* VERIFIED */
        assert(value_is_valid(values[1])); /* VERIFIED */
        assert(value_is_valid(values[2])); /* VERIFIED */
        assert(value_is_valid(values[3])); /* VERIFIED */
        enumeration = get_enumeration_type(4, &(values[0]));
        assert((enumeration == NULL) || type_is_valid(enumeration));
                /* VERIFIED */
        value_remove_reference(values[0], NULL);
        value_remove_reference(values[1], NULL);
        value_remove_reference(values[2], NULL);
        value_remove_reference(values[3], NULL);
        if (enumeration == NULL)
            goto finite_integer_failure;

        not_type = get_not_type(enumeration);
        assert((not_type == NULL) || type_is_valid(not_type)); /* VERIFIED */
        type_remove_reference(enumeration, NULL);
        if (not_type == NULL)
            goto finite_integer_failure;

        assert(type_is_valid(integer_type)); /* VERIFIED */
        assert(type_is_valid(not_type)); /* VERIFIED */
        finite_integer_type = get_intersection_type(integer_type, not_type);
        type_remove_reference(not_type, NULL);
        if (finite_integer_type == NULL)
            goto finite_integer_failure;
      }

    assert(rational_type == NULL);
    rational_type = create_empty_type(TK_RATIONAL);
    if (rational_type == NULL)
        goto rational_failure;
    rational_type->possible_value_kinds =
            (VK_BIT(VK_INTEGER) | VK_BIT(VK_RATIONAL));

    assert(any_regular_expression_type == NULL);
    any_regular_expression_type = create_empty_type(TK_ANY_REGULAR_EXPRESSION);
    if (any_regular_expression_type == NULL)
        goto any_regular_expression_failure;
    any_regular_expression_type->possible_value_kinds =
            VK_BIT(VK_REGULAR_EXPRESSION);

    assert(any_quark_type == NULL);
    any_quark_type = create_empty_type(TK_ANY_QUARK);
    if (any_quark_type == NULL)
        goto any_quark_failure;
    any_quark_type->possible_value_kinds = VK_BIT(VK_QUARK);

    assert(any_lepton_type == NULL);
    any_lepton_type = create_empty_type(TK_ANY_LEPTON);
    if (any_lepton_type == NULL)
        goto any_lepton_failure;
    any_lepton_type->possible_value_kinds = VK_BIT(VK_LEPTON);

    assert(lepton_key_type == NULL);
    lepton_key_type = create_empty_type(TK_LEPTON_KEY);
    if (lepton_key_type == NULL)
        goto lepton_key_failure;
    lepton_key_type->possible_value_kinds = VK_BIT(VK_LEPTON_KEY);

    assert(jump_target_type == NULL);
    jump_target_type = create_empty_type(TK_JUMP_TARGET);
    if (jump_target_type == NULL)
        goto jump_target_failure;
    jump_target_type->possible_value_kinds = VK_BIT(VK_JUMP_TARGET);

    assert(any_class_type == NULL);
    any_class_type = create_empty_type(TK_ANY_CLASS);
    if (any_class_type == NULL)
        goto any_class_failure;
    any_class_type->possible_value_kinds =
            (VK_BIT(VK_ROUTINE) | VK_BIT(VK_ROUTINE_CHAIN));

    assert(object_type == NULL);
    object_type = create_empty_type(TK_OBJECT);
    if (object_type == NULL)
        goto object_failure;
    object_type->possible_value_kinds = VK_BIT(VK_OBJECT);

    assert(any_tagalong_key_type == NULL);
    any_tagalong_key_type = create_empty_type(TK_TAGALONG_KEY);
    if (any_tagalong_key_type == NULL)
        goto any_tagalong_key_failure;
    any_tagalong_key_type->possible_value_kinds = VK_BIT(VK_TAGALONG_KEY);

    assert(lock_type == NULL);
    lock_type = create_empty_type(TK_LOCK);
    if (lock_type == NULL)
        goto lock_failure;
    lock_type->possible_value_kinds = VK_BIT(VK_LOCK);

    assert(string_type == NULL);
    string_type = create_empty_type(TK_STRING);
    if (string_type == NULL)
        goto string_failure;
    string_type->possible_value_kinds = VK_BIT(VK_STRING);

    assert(character_type == NULL);
    character_type = create_empty_type(TK_CHARACTER);
    if (character_type == NULL)
        goto character_failure;
    character_type->possible_value_kinds = VK_BIT(VK_CHARACTER);

    assert(boolean_type == NULL);
      {
        value *values[2];

        values[0] = create_true_value();
        if (values[0] == NULL)
            goto boolean_failure;

        values[1] = create_false_value();
        if (values[1] == NULL)
          {
            value_remove_reference(values[0], NULL);
            goto boolean_failure;
          }

        assert(value_is_valid(values[0])); /* VERIFIED */
        assert(value_is_valid(values[1])); /* VERIFIED */
        boolean_type = get_enumeration_type(2, &(values[0]));
        assert((boolean_type == NULL) || type_is_valid(boolean_type));
                /* VERIFIED */
        value_remove_reference(values[0], NULL);
        value_remove_reference(values[1], NULL);
        if (boolean_type == NULL)
            goto boolean_failure;
      }

    INITIALIZE_SYSTEM_LOCK(saved_shift_type_function_expression_lock,
                           goto lock1_failure);
    INITIALIZE_SYSTEM_LOCK(saved_shift_type_function_value_lock,
                           goto lock2_failure);
    INITIALIZE_SYSTEM_LOCK(provisional_subset_outer_lock, goto lock3_failure);
    INITIALIZE_SYSTEM_LOCK(provisional_subset_inner_lock,
        DESTROY_SYSTEM_LOCK(provisional_subset_outer_lock);
      lock3_failure:
        DESTROY_SYSTEM_LOCK(saved_shift_type_function_value_lock);
      lock2_failure:
        DESTROY_SYSTEM_LOCK(saved_shift_type_function_expression_lock);
      lock1_failure:
        assert(boolean_type != NULL);
        type_remove_reference(boolean_type, NULL);
        boolean_type = NULL;
        goto boolean_failure);

    return MISSION_ACCOMPLISHED;

  boolean_failure:
    assert(character_type != NULL);
    type_remove_reference(character_type, NULL);
    character_type = NULL;

  character_failure:
    assert(string_type != NULL);
    type_remove_reference(string_type, NULL);
    string_type = NULL;

  string_failure:
    assert(lock_type != NULL);
    type_remove_reference(lock_type, NULL);
    lock_type = NULL;

  lock_failure:
    assert(any_tagalong_key_type != NULL);
    type_remove_reference(any_tagalong_key_type, NULL);
    any_tagalong_key_type = NULL;

  any_tagalong_key_failure:
    assert(object_type != NULL);
    type_remove_reference(object_type, NULL);
    object_type = NULL;

  object_failure:
    assert(any_class_type != NULL);
    type_remove_reference(any_class_type, NULL);
    any_class_type = NULL;

  any_class_failure:
    assert(jump_target_type != NULL);
    type_remove_reference(jump_target_type, NULL);
    jump_target_type = NULL;

  jump_target_failure:
    assert(lepton_key_type != NULL);
    type_remove_reference(lepton_key_type, NULL);
    lepton_key_type = NULL;

  lepton_key_failure:
    assert(any_lepton_type != NULL);
    type_remove_reference(any_lepton_type, NULL);
    any_lepton_type = NULL;

  any_lepton_failure:
    assert(any_quark_type != NULL);
    type_remove_reference(any_quark_type, NULL);
    any_quark_type = NULL;

  any_quark_failure:
    assert(any_regular_expression_type != NULL);
    type_remove_reference(any_regular_expression_type, NULL);
    any_regular_expression_type = NULL;

  any_regular_expression_failure:
    assert(rational_type != NULL);
    type_remove_reference(rational_type, NULL);
    rational_type = NULL;

  rational_failure:
    assert(finite_integer_type != NULL);
    type_remove_reference(finite_integer_type, NULL);
    finite_integer_type = NULL;

  finite_integer_failure:
    assert(integer_type != NULL);
    type_remove_reference(integer_type, NULL);
    integer_type = NULL;

  integer_failure:
    assert(nothing_type != NULL);
    type_remove_reference(nothing_type, NULL);
    nothing_type = NULL;

  nothing_failure:
    assert(anything_type != NULL);
    type_remove_reference(anything_type, NULL);
    anything_type = NULL;

  anything_failure:
    return MISSION_FAILED;
  }

extern void cleanup_type_module_instances(void)
  {
    if (saved_shift_type_function_value != NULL)
      {
        value_remove_reference(saved_shift_type_function_value, NULL);
        saved_shift_type_function_value = NULL;
      }
  }

extern void cleanup_type_module(void)
  {
    if (anything_type != NULL)
      {
        type *old_type;

        old_type = anything_type;
        anything_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (nothing_type != NULL)
      {
        type *old_type;

        old_type = nothing_type;
        nothing_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (integer_type != NULL)
      {
        type *old_type;

        old_type = integer_type;
        integer_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (finite_integer_type != NULL)
      {
        type *old_type;

        old_type = finite_integer_type;
        finite_integer_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (rational_type != NULL)
      {
        type *old_type;

        old_type = rational_type;
        rational_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (any_regular_expression_type != NULL)
      {
        type *old_type;

        old_type = any_regular_expression_type;
        any_regular_expression_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (any_quark_type != NULL)
      {
        type *old_type;

        old_type = any_quark_type;
        any_quark_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (any_lepton_type != NULL)
      {
        type *old_type;

        old_type = any_lepton_type;
        any_lepton_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (lepton_key_type != NULL)
      {
        type *old_type;

        old_type = lepton_key_type;
        lepton_key_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (jump_target_type != NULL)
      {
        type *old_type;

        old_type = jump_target_type;
        jump_target_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (any_class_type != NULL)
      {
        type *old_type;

        old_type = any_class_type;
        any_class_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (object_type != NULL)
      {
        type *old_type;

        old_type = object_type;
        object_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (any_tagalong_key_type != NULL)
      {
        type *old_type;

        old_type = any_tagalong_key_type;
        any_tagalong_key_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (lock_type != NULL)
      {
        type *old_type;

        old_type = lock_type;
        lock_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (string_type != NULL)
      {
        type *old_type;

        old_type = string_type;
        string_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (character_type != NULL)
      {
        type *old_type;

        old_type = character_type;
        character_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (boolean_type != NULL)
      {
        type *old_type;

        old_type = boolean_type;
        boolean_type = NULL;
        type_remove_reference(old_type, NULL);
      }

    if (saved_shift_type_function_expression != NULL)
      {
        delete_expression(saved_shift_type_function_expression);
        saved_shift_type_function_expression = NULL;
      }
    DESTROY_SYSTEM_LOCK(saved_shift_type_function_expression_lock);
    DESTROY_SYSTEM_LOCK(saved_shift_type_function_value_lock);
    DESTROY_SYSTEM_LOCK(provisional_subset_outer_lock);
    DESTROY_SYSTEM_LOCK(provisional_subset_inner_lock);
  }


static type *create_empty_type(type_kind kind)
  {
    type *result;

    result = MALLOC_ONE_OBJECT(type);
    if (result == NULL)
        return NULL;

    INITIALIZE_SYSTEM_LOCK(result->reference_lock, free(result); return NULL);

    result->kind = kind;
    result->reference_cluster = NULL;
    result->validator = get_trivial_validator();
    assert(result->validator != NULL);
    result->reference_count = 1;

    return result;
  }

static string_index *make_allowed_fields_index(size_t field_count,
                                               char **field_names)
  {
    string_index *result;
    size_t field_num;

    assert((field_count == 0) || (field_names != NULL));

    result = create_string_index();
    if (result == NULL)
        return result;

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        verdict the_verdict;

        if (field_names[field_num] == NULL)
            continue;

        the_verdict = enter_into_string_index(result, field_names[field_num],
                                              (void *)field_num);
        if (the_verdict != MISSION_ACCOMPLISHED)
          {
            destroy_string_index(result);
            return NULL;
          }
      }

    return result;
  }

static boolean compound_value_uses_banned_field(value *compound_value,
        string_index *allowed_fields, const char **bad_field_name)
  {
    size_t component_count;
    size_t component_num;

    assert(compound_value != NULL);
    assert(allowed_fields != NULL);
    assert(bad_field_name != NULL);

    assert((get_value_kind(compound_value) == VK_SEMI_LABELED_VALUE_LIST) ||
           (get_value_kind(compound_value) == VK_SEMI_LABELED_MULTI_SET) ||
           (get_value_kind(compound_value) == VK_LEPTON));

    component_count = value_component_count(compound_value);

    for (component_num = 0; component_num < component_count; ++component_num)
      {
        const char *label;

        label = value_component_label(compound_value, component_num);
        if (label == NULL)
          {
            *bad_field_name = NULL;
            return TRUE;
          }

        if (!(exists_in_string_index(allowed_fields, label)))
          {
            *bad_field_name = label;
            return TRUE;
          }
      }

    return FALSE;
  }

static boolean object_value_uses_banned_field(value *object_value,
        string_index *allowed_fields, const char **bad_field_name)
  {
    object *the_object;
    size_t field_count;
    size_t field_num;

    assert(object_value != NULL);
    assert(allowed_fields != NULL);

    assert(value_is_valid(object_value)); /* VERIFIED */

    assert(get_value_kind(object_value) == VK_OBJECT);

    the_object = object_value_data(object_value);
    assert(the_object != NULL);

    assert(!(object_is_closed(the_object))); /* VERIFIED */
    field_count = object_field_count(the_object);

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        const char *field_name;

        assert(!(object_is_closed(the_object))); /* VERIFIED */
        field_name = object_field_name(the_object, field_num);
        assert(field_name != NULL);

        if (!(exists_in_string_index(allowed_fields, field_name)))
          {
            *bad_field_name = field_name;
            return TRUE;
          }
      }

    return FALSE;
  }

static boolean test_value_with_function(value *the_value,
        value *function_base_value, const source_location *location,
        jumper *the_jumper)
  {
    value *result_value;

    assert(the_value != NULL);
    assert(function_base_value != NULL);
    assert(the_jumper != NULL);

    result_value = execute_call_from_arrays(function_base_value, 1, NULL,
            &the_value, TRUE, the_jumper, location);
    if (!(jumper_flowing_forward(the_jumper)))
      {
        if (result_value != NULL)
            value_remove_reference(result_value, the_jumper);
        return FALSE;
      }

    assert(result_value != NULL);

    switch (get_value_kind(result_value))
      {
        case VK_TRUE:
            value_remove_reference(result_value, the_jumper);
            assert(jumper_flowing_forward(the_jumper));
            return TRUE;
        case VK_FALSE:
            value_remove_reference(result_value, the_jumper);
            assert(jumper_flowing_forward(the_jumper));
            return FALSE;
        default:
            assert(FALSE);
            return FALSE;
      }
  }

static boolean routine_instance_chain_is_in_routine_type(
        routine_instance_chain *instance_chain, type *the_type, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper)
  {
    boolean result;

    assert(instance_chain != NULL);
    assert(the_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(routine_instance_chain_is_valid(instance_chain)); /* VERIFIED */
    assert(type_is_valid(the_type)); /* VERIFIED */

    assert(the_type->kind == TK_ROUTINE);

    result = check_for_routine_argument_and_return_type_match(instance_chain,
            the_type, 0, FALSE, doubt, why_not, location, the_jumper);

    if ((why_not != NULL) && ((!result) || (*doubt)) &&
        (jumper_flowing_forward(the_jumper)))
      {
        char *new_why_not;

        new_why_not = allocate_printf("the routine value is overloaded; %s",
                                      *why_not);
        free(*why_not);
        if (new_why_not == NULL)
            jumper_do_abort(the_jumper);
        *why_not = new_why_not;
      }

    return result;
  }

static boolean routine_always_matches_type_parameters(
        routine_instance *the_routine_instance, type *routine_type,
        boolean *doubt, char **why_not, const source_location *location,
        jumper *the_jumper)
  {
    assert(the_routine_instance != NULL);
    assert(routine_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(routine_instance_is_instantiated(the_routine_instance));
            /* VERIFIED */
    assert(!(routine_instance_scope_exited(the_routine_instance)));
            /* VERIFIED */
    assert(type_is_valid(routine_type)); /* VERIFIED */

    assert(routine_type->kind == TK_ROUTINE);

    return check_for_routine_argument_type_match(the_routine_instance,
            routine_type, 0, NULL, FALSE, NULL, doubt, NULL, why_not, location,
            the_jumper);
  }

static boolean check_for_routine_argument_type_match(
        routine_instance *the_routine_instance, type *routine_type,
        size_t routine_num, routine_instance_chain *next_instance_chain,
        boolean previous_doubt, boolean *local_match, boolean *doubt,
        boolean *local_doubt, char **why_not, const source_location *location,
        jumper *the_jumper)
  {
    routine_declaration *declaration;
    formal_arguments *formals;
    size_t type_argument_count;
    size_t routine_argument_count;
    size_t joint_argument_count;
    boolean have_doubt;
    char *doubt_why_not;
    size_t arg_num;
    char *later_why_not;
    boolean result;

    assert(the_routine_instance != NULL);
    assert(routine_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(routine_instance_is_instantiated(the_routine_instance));
            /* VERIFIED */
    assert(!(routine_instance_scope_exited(the_routine_instance)));
            /* VERIFIED */
    assert(type_is_valid(routine_type)); /* VERIFIED */
    assert((next_instance_chain == NULL) ||
           routine_instance_chain_is_valid(next_instance_chain));
            /* VERIFIED */

    assert(routine_type->kind == TK_ROUTINE);

    declaration = routine_instance_declaration(the_routine_instance);
    assert(declaration != NULL);

    formals = routine_declaration_formals(declaration);
    assert(formals != NULL);

    type_argument_count = routine_type->u.routine.argument_count;
    routine_argument_count = formal_arguments_argument_count(formals);

    joint_argument_count =
            ((type_argument_count < routine_argument_count) ?
             type_argument_count : routine_argument_count);

    have_doubt = FALSE;

    for (arg_num = 0; arg_num < joint_argument_count; ++arg_num)
      {
        variable_declaration *formal_declaration;
        const char *expected_argument_name;
        type *type_argument_type;
        type *routine_argument_type;
        boolean parameter_doubt;
        char *parameter_why_not;
        boolean is_subset;

        formal_declaration =
                formal_arguments_formal_by_number(formals, arg_num);
        assert(formal_declaration != NULL);

        expected_argument_name =
                routine_type->u.routine.argument_names[arg_num];
        if (expected_argument_name != NULL)
          {
            const char *formal_name;

            formal_name = variable_declaration_name(formal_declaration);
            if ((formal_name == NULL) ||
                (strcmp(expected_argument_name, formal_name) != 0))
              {
                if (have_doubt && (why_not != NULL))
                    free(doubt_why_not);
                *doubt = FALSE;
                if (why_not != NULL)
                  {
                    if (formal_name == NULL)
                      {
                        *why_not = allocate_printf(
                                "the routine type requires formal name `%s' "
                                "for parameter %lu but the value allows a "
                                "routine with no name for that parameter",
                                expected_argument_name,
                                (unsigned long)arg_num);
                      }
                    else
                      {
                        *why_not = allocate_printf(
                                "the routine type requires formal name `%s' "
                                "for parameter %lu but the value allows a "
                                "routine with formal name `%s' for that "
                                "parameter", expected_argument_name,
                                (unsigned long)arg_num, formal_name);
                      }
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
                goto no_match;
              }
          }

        if (routine_type->u.routine.argument_has_defaults[arg_num])
          {
            if (variable_declaration_initializer(formal_declaration) == NULL)
              {
                if (have_doubt && (why_not != NULL))
                    free(doubt_why_not);
                *doubt = FALSE;
                if (why_not != NULL)
                  {
                    *why_not = allocate_printf(
                            "the routine type requires a default value for "
                            "parameter %lu but the value allows a routine "
                            "without a default value for that parameter",
                            (unsigned long)arg_num);
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
                goto no_match;
              }
          }

        assert(routine_instance_is_instantiated(the_routine_instance));
                /* VERIFIED */
        assert(!(routine_instance_scope_exited(the_routine_instance)));
                /* VERIFIED */
        type_argument_type = routine_type->u.routine.argument_types[arg_num];
        routine_argument_type =
                routine_instance_argument_type(the_routine_instance, arg_num);
        assert(routine_argument_type != NULL);
        assert(type_is_valid(type_argument_type)); /* VERIFIED */
        assert(type_is_valid(routine_argument_type)); /* VERIFICATION NEEDED */
        is_subset = type_is_subset(type_argument_type, routine_argument_type,
                &parameter_doubt,
                ((why_not == NULL) ? NULL : &parameter_why_not), location,
                the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            if (have_doubt && (why_not != NULL))
                free(doubt_why_not);
            return FALSE;
          }

        if (parameter_doubt)
          {
            char *later_why_not;

            if (next_instance_chain != NULL)
              {
                type *remainder_type;
                boolean later_always_catches;
                boolean later_doubt;

                remainder_type = block_out_part_of_routine_type(routine_type,
                        arg_num, routine_argument_type);
                if (remainder_type == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    if (why_not != NULL)
                        free(parameter_why_not);
                    if (have_doubt && (why_not != NULL))
                        free(doubt_why_not);
                    return FALSE;
                  }
                assert(type_is_valid(remainder_type)); /* VERIFIED */

                assert(routine_instance_chain_is_valid(next_instance_chain));
                        /* VERIFIED */
                assert(type_is_valid(remainder_type)); /* VERIFIED */
                later_always_catches =
                        check_for_routine_argument_and_return_type_match(
                                next_instance_chain, remainder_type,
                                routine_num + 1, (*doubt || previous_doubt),
                                &later_doubt,
                                ((why_not == NULL) ? NULL : &later_why_not),
                                location, the_jumper);
                type_remove_reference(remainder_type,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                                                               the_jumper));
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if (why_not != NULL)
                        free(parameter_why_not);
                    if (have_doubt && (why_not != NULL))
                        free(doubt_why_not);
                    return FALSE;
                  }

                if (later_always_catches && !later_doubt)
                  {
                    if (why_not != NULL)
                        free(parameter_why_not);
                    continue;
                  }
              }

            if (why_not != NULL)
              {
                if (!have_doubt)
                  {
                    doubt_why_not = allocate_printf(
                            "the routine type requires type %t for parameter "
                            "%lu but the value allows a routine that has type "
                            "%t for that parameter and %s could not determine "
                            "whether the former is a subset of the later "
                            "because %s%s%s", type_argument_type,
                            (unsigned long)arg_num, routine_argument_type,
                            interpreter_name(), parameter_why_not,
                            ((next_instance_chain != NULL) ?
                             ", and it could not determine that later routines"
                             " on the chain would cover the potentially "
                             "missing argument lists because " : ""),
                            ((next_instance_chain != NULL) ? later_why_not :
                                                             ""));
                    if (doubt_why_not == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        if (next_instance_chain != NULL)
                            free(later_why_not);
                        free(parameter_why_not);
                        return FALSE;
                      }
                  }

                if (next_instance_chain != NULL)
                    free(later_why_not);

                free(parameter_why_not);
              }
            have_doubt = TRUE;
          }
        else if (!is_subset)
          {
            boolean later_always_catches;
            boolean later_doubt;
            char *later_why_not;
            char *new_why_not;

            if (next_instance_chain != NULL)
              {
                type *remainder_type;

                remainder_type = block_out_part_of_routine_type(routine_type,
                        arg_num, routine_argument_type);
                if (remainder_type == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    if (why_not != NULL)
                        free(parameter_why_not);
                    if (have_doubt && (why_not != NULL))
                        free(doubt_why_not);
                    return FALSE;
                  }
                assert(type_is_valid(remainder_type)); /* VERIFIED */

                assert(routine_instance_chain_is_valid(next_instance_chain));
                        /* VERIFIED */
                assert(type_is_valid(remainder_type)); /* VERIFIED */
                later_always_catches =
                        check_for_routine_argument_and_return_type_match(
                                next_instance_chain, remainder_type,
                                routine_num + 1, (*doubt || previous_doubt),
                                &later_doubt,
                                ((why_not == NULL) ? NULL : &later_why_not),
                                location, the_jumper);
                type_remove_reference(remainder_type,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                                                               the_jumper));
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if (why_not != NULL)
                        free(parameter_why_not);
                    if (have_doubt && (why_not != NULL))
                        free(doubt_why_not);
                    return FALSE;
                  }

                if (later_always_catches && !later_doubt)
                  {
                    if (why_not != NULL)
                        free(parameter_why_not);
                    continue;
                  }
                *doubt = later_doubt;
              }
            else
              {
                *doubt = FALSE;
              }

            if (why_not != NULL)
              {
                if (have_doubt)
                    free(doubt_why_not);
                *why_not = allocate_printf(
                        "the routine type requires type %t for parameter %lu "
                        "but the value allows a routine that has type %t for "
                        "that parameter and the former is not a subset of the "
                        "later because %s", type_argument_type,
                        (unsigned long)arg_num, routine_argument_type,
                        parameter_why_not);
                if (*why_not == NULL)
                    jumper_do_abort(the_jumper);
                free(parameter_why_not);
              }

            if (!(jumper_flowing_forward(the_jumper)))
                return FALSE;

            if (local_match != NULL)
                *local_match = FALSE;

            if (next_instance_chain == NULL)
              {
                if (local_doubt != NULL)
                    *local_doubt = FALSE;
                *doubt = previous_doubt;
                return FALSE;
              }

            if (why_not != NULL)
              {
                new_why_not =
                        allocate_printf("%s; %s", *why_not, later_why_not);
                free(*why_not);
                free(later_why_not);
                if (new_why_not == NULL)
                    jumper_do_abort(the_jumper);
                *why_not = new_why_not;
              }
            if (local_doubt != NULL)
                *local_doubt = FALSE;
            return later_always_catches;
          }
      }

    if (!(routine_type->u.routine.extra_arguments_unspecified))
      {
        for (arg_num = type_argument_count; arg_num < routine_argument_count;
             ++arg_num)
          {
            variable_declaration *formal_declaration;

            formal_declaration =
                    formal_arguments_formal_by_number(formals, arg_num);
            assert(formal_declaration != NULL);

            if (variable_declaration_initializer(formal_declaration) == NULL)
              {
                if (have_doubt && (why_not != NULL))
                    free(doubt_why_not);
                *doubt = FALSE;
                if (why_not != NULL)
                  {
                    *why_not = allocate_printf(
                            "the routine type requires a parameter list of "
                            "only %lu item%s be legal, but the value allows a "
                            "routine that takes a parameter %lu and doesn't "
                            "have an initializer for that parameter",
                            (unsigned long)type_argument_count,
                            ((type_argument_count == 1) ? "" : "s"),
                            (unsigned long)arg_num);
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
                goto no_match;
              }
          }
      }

    if (type_argument_count > routine_argument_count)
      {
        if (!(routine_declaration_extra_arguments_allowed(declaration)))
          {
            if (have_doubt && (why_not != NULL))
                free(doubt_why_not);
            *doubt = FALSE;
            if (why_not != NULL)
              {
                *why_not = allocate_printf(
                        "the routine type requires that an argument list of "
                        "%lu item%s be allowed but the value allows a routine "
                        "that takes only %lu argument%s",
                        (unsigned long)type_argument_count,
                        ((type_argument_count == 1) ? "" : "s"),
                        (unsigned long)routine_argument_count,
                        ((routine_argument_count == 1) ? "" : "s"));
                if (*why_not == NULL)
                    jumper_do_abort(the_jumper);
              }
            goto no_match;
          }

        for (arg_num = routine_argument_count; arg_num < type_argument_count;
             ++arg_num)
          {
            if (routine_type->u.routine.argument_names[arg_num] != NULL)
              {
                if (have_doubt && (why_not != NULL))
                    free(doubt_why_not);
                *doubt = FALSE;
                if (why_not != NULL)
                  {
                    *why_not = allocate_printf(
                            "the routine type requires that an argument list "
                            "with an argument with named `%s' for argument %lu"
                            " be allowed but the value allows a routine that "
                            "doesn't take a named argument in that position",
                            routine_type->u.routine.argument_names[arg_num],
                            (unsigned long)arg_num);
                    if (*why_not == NULL)
                        jumper_do_abort(the_jumper);
                  }
                goto no_match;
              }
          }
      }

    if (routine_type->u.routine.extra_arguments_allowed &&
        !(routine_declaration_extra_arguments_allowed(declaration)))
      {
        if (have_doubt && (why_not != NULL))
            free(doubt_why_not);
        *doubt = FALSE;
        if (why_not != NULL)
          {
            *why_not = allocate_printf(
                    "the routine type requires that any number of additional "
                    "arguments be allowed but the value allows a routine that "
                    "doesn't allow unlimited additional arguments");
            if (*why_not == NULL)
                jumper_do_abort(the_jumper);
          }
        goto no_match;
      }

    *doubt = have_doubt;
    if (have_doubt && (why_not != NULL))
        *why_not = doubt_why_not;
    if (!(jumper_flowing_forward(the_jumper)))
        return FALSE;

    if (local_match != NULL)
        *local_match = TRUE;

    if (local_doubt != NULL)
        *local_doubt = *doubt;

    if (next_instance_chain == NULL)
        return TRUE;

    if (*doubt)
      {
        boolean result;
        char *later_why_not;

        assert(routine_instance_chain_is_valid(next_instance_chain));
                /* VERIFIED */
        assert(type_is_valid(routine_type)); /* VERIFIED */
        result = check_for_routine_argument_and_return_type_match(
                next_instance_chain, routine_type, routine_num + 1, TRUE,
                doubt, ((why_not == NULL) ? NULL : &later_why_not), location,
                the_jumper);
        if (why_not != NULL)
          {
            if (((!result) || (*doubt)) &&
                (jumper_flowing_forward(the_jumper)))
              {
                char *new_why_not;

                new_why_not =
                        allocate_printf("%s; %s", *why_not, later_why_not);
                free(*why_not);
                free(later_why_not);
                if (new_why_not == NULL)
                    jumper_do_abort(the_jumper);
                *why_not = new_why_not;
              }
            else
              {
                free(*why_not);
              }
          }
        return result;
      }

    return TRUE;

no_match:
    if (!(jumper_flowing_forward(the_jumper)))
        return FALSE;

    if (local_match != NULL)
        *local_match = FALSE;

    if (local_doubt != NULL)
        *local_doubt = *doubt;

    if (next_instance_chain == NULL)
      {
        *doubt = (*doubt || previous_doubt);
        return FALSE;
      }

    assert(routine_instance_chain_is_valid(next_instance_chain));
            /* VERIFIED */
    assert(type_is_valid(routine_type)); /* VERIFIED */
    result = check_for_routine_argument_and_return_type_match(
            next_instance_chain, routine_type, routine_num + 1,
            (*doubt || previous_doubt), doubt,
            ((why_not == NULL) ? NULL : &later_why_not), location, the_jumper);
    if (why_not != NULL)
      {
        if (((!result) || (*doubt)) && (jumper_flowing_forward(the_jumper)))
          {
            char *new_why_not;

            new_why_not = allocate_printf("%s; %s", *why_not, later_why_not);
            free(*why_not);
            free(later_why_not);
            if (new_why_not == NULL)
                jumper_do_abort(the_jumper);
            *why_not = new_why_not;
          }
        else
          {
            free(*why_not);
          }
      }
    return result;
  }

static type *block_out_part_of_routine_type(type *routine_type, size_t arg_num,
                                            type *to_block)
  {
    size_t type_argument_count;
    type **new_argument_types;
    size_t new_arg_num;
    type *not_type;
    type *old_argument_type;
    type *and_type;
    type *remainder_type;

    assert(routine_type != NULL);
    assert(to_block != NULL);

    assert(type_is_valid(routine_type)); /* VERIFIED */
    assert(type_is_valid(to_block)); /* VERIFIED */

    type_argument_count = routine_type->u.routine.argument_count;
    assert(type_argument_count > 0);
    assert(arg_num < type_argument_count);

    new_argument_types = MALLOC_ARRAY(type *, type_argument_count);
    if (new_argument_types == NULL)
        return NULL;

    for (new_arg_num = 0; new_arg_num < type_argument_count; ++new_arg_num)
      {
        new_argument_types[new_arg_num] =
                routine_type->u.routine.argument_types[new_arg_num];
      }

    assert(type_is_valid(to_block)); /* VERIFIED */
    not_type = get_not_type(to_block);
    if (not_type == NULL)
      {
        free(new_argument_types);
        return NULL;
      }

    old_argument_type = routine_type->u.routine.argument_types[arg_num];

    assert(type_is_valid(old_argument_type)); /* VERIFIED */
    assert(type_is_valid(not_type)); /* VERIFIED */
    and_type = get_intersection_type(old_argument_type, not_type);
    if (and_type == NULL)
      {
        type_remove_reference(not_type, NULL);
        free(new_argument_types);
        return NULL;
      }
    assert(type_is_valid(and_type)); /* VERIFIED */

    type_remove_reference(not_type, NULL);

    new_argument_types[arg_num] = and_type;

    remainder_type = get_routine_type(routine_type->u.routine.return_type,
            type_argument_count, new_argument_types,
            (const char **)(routine_type->u.routine.argument_names),
            routine_type->u.routine.argument_has_defaults,
            routine_type->u.routine.extra_arguments_allowed,
            routine_type->u.routine.extra_arguments_unspecified);
    free(new_argument_types);
    if (remainder_type == NULL)
      {
        type_remove_reference(and_type, NULL);
        return NULL;
      }

    assert(type_is_valid(remainder_type)); /* VERIFIED */
    type_remove_reference(and_type, NULL);
    return remainder_type;
  }

static boolean check_for_routine_argument_and_return_type_match(
        routine_instance_chain *instance_chain, type *the_type,
        size_t routine_num, boolean previous_doubt, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper)
  {
    boolean local_previous_doubt;
    routine_instance *instance;
    routine_instance_chain *next_instance_chain;
    type *this_return_type;
    boolean parameter_doubt;
    boolean parameter_match;
    boolean result;

    assert(instance_chain != NULL);
    assert(the_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(routine_instance_chain_is_valid(instance_chain)); /* VERIFIED */
    assert(type_is_valid(the_type)); /* VERIFIED */

    local_previous_doubt = previous_doubt;

    assert(routine_instance_chain_is_valid(instance_chain)); /* VERIFIED */
    instance = routine_instance_chain_instance(instance_chain);
    assert(instance != NULL);

    next_instance_chain = routine_instance_chain_next(instance_chain);
    assert((next_instance_chain == NULL) ||
           routine_instance_chain_is_valid(next_instance_chain));
            /* VERIFIED */

    if (jumper_thread(the_jumper) == NULL)
      {
        assert(why_not == NULL);
        *doubt = TRUE;
        return FALSE;
      }

    assert(routine_instance_is_instantiated(instance)); /* VERIFIED */
    assert(!(routine_instance_scope_exited(instance))); /* VERIFIED */
    this_return_type = routine_instance_valid_return_type(instance,
            location, the_jumper);
    if (!(jumper_flowing_forward(the_jumper)))
      {
        assert(this_return_type == NULL);
        *doubt = TRUE;
        return FALSE;
      }

    assert(routine_instance_is_instantiated(instance)); /* VERIFIED */
    assert(!(routine_instance_scope_exited(instance))); /* VERIFIED */
    assert(type_is_valid(the_type)); /* VERIFIED */
    assert((next_instance_chain == NULL) ||
           routine_instance_chain_is_valid(next_instance_chain));
            /* VERIFIED */
    result = check_for_routine_argument_type_match(instance, the_type,
            routine_num, next_instance_chain, previous_doubt, &parameter_match,
            doubt, &parameter_doubt, why_not, location, the_jumper);
    if (!(jumper_flowing_forward(the_jumper)))
        return FALSE;

    if (parameter_doubt || !parameter_match)
      {
        if (parameter_doubt)
            local_previous_doubt = TRUE;

        if ((why_not != NULL) && ((!result) || (*doubt)) &&
            (jumper_flowing_forward(the_jumper)))
          {
            char *new_why_not;

            if (parameter_doubt)
              {
                new_why_not = allocate_printf(
                        "%s can't tell if routine %lu on the overload list "
                        "matches because %s", interpreter_name(),
                        (unsigned long)routine_num, *why_not);
              }
            else
              {
                assert(!parameter_match);
                new_why_not = allocate_printf(
                        "routine %lu on the overload list doesn't match "
                        "because %s", (unsigned long)routine_num, *why_not);
              }
            free(*why_not);
            if (new_why_not == NULL)
              {
                jumper_do_abort(the_jumper);
                *doubt = TRUE;
                return FALSE;
              }
            *why_not = new_why_not;
          }
      }

    if (result && (!(*doubt)) && jumper_flowing_forward(the_jumper))
      {
        boolean hit_doubt;
        boolean hits;
        boolean return_doubt;
        char *return_why_not;
        boolean return_match;

        assert(type_is_valid(the_type)); /* VERIFIED */
        assert(routine_instance_is_instantiated(instance)); /* VERIFIED */
        assert(!(routine_instance_scope_exited(instance))); /* VERIFIED */
        hits = routine_type_hits_routine(the_type, instance, &hit_doubt,
                                         location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;

        if ((!hits) && (!hit_doubt))
            return result;

        assert(type_is_valid(this_return_type)); /* VERIFIED */
        assert(type_is_valid(the_type)); /* VERIFIED */
        assert(type_is_valid(the_type->u.routine.return_type));
                /* VERIFIED */
        return_match = type_is_subset(this_return_type,
                the_type->u.routine.return_type, &return_doubt,
                ((why_not == NULL) ? NULL : &return_why_not), location,
                the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (return_doubt || !return_match)
          {
            *doubt = (return_doubt || local_previous_doubt || hit_doubt);
            if (why_not != NULL)
              {
                *why_not = allocate_printf(
                        "routine %lu on the overload list %s parameters, but "
                        "%s%s because %s", (unsigned long)routine_num,
                        ((!hit_doubt) ? "matches" : "might match"),
                        (return_doubt ? interpreter_name() : ""),
                        (return_doubt ?
                         " is unable to determine whether its return type "
                         "matches" :
                         "the return type of that routine does not match the "
                         "required return type"), return_why_not);
                if (*why_not == NULL)
                    jumper_do_abort(the_jumper);
                free(return_why_not);
              }
            return FALSE;
          }
      }

    return result;
  }

static boolean routine_type_hits_routine(type *routine_type,
        routine_instance *instance, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    typedef enum { BK_NORMAL, BK_NAMED, BK_DEFAULT } binding_kind;
    typedef struct
      {
        binding_kind kind;
        size_t routine_arg_num;
        boolean match_doubt;
      } binding_info;

    routine_declaration *declaration;
    formal_arguments *formals;
    size_t type_argument_count;
    size_t routine_argument_count;
    binding_info *bindings;
    boolean *formal_useds;
    size_t required_formal_unused_count;
    size_t routine_arg_num;
    size_t doubt_count;
    size_t definitely_not_no;
    size_t type_arg_num;
    boolean result;

    assert(routine_type != NULL);
    assert(instance != NULL);
    assert(doubt != NULL);

    assert(type_is_valid(routine_type)); /* VERIFIED */
    assert(routine_instance_is_instantiated(instance)); /* VERIFIED */
    assert(!(routine_instance_scope_exited(instance))); /* VERIFIED */

    declaration = routine_instance_declaration(instance);
    assert(declaration != NULL);

    formals = routine_declaration_formals(declaration);
    assert(formals != NULL);

    type_argument_count = routine_type->u.routine.argument_count;
    routine_argument_count = formal_arguments_argument_count(formals);

    if (type_argument_count == 0)
      {
        size_t arg_num;

        if (routine_type->u.routine.extra_arguments_allowed ||
            routine_type->u.routine.extra_arguments_unspecified)
          {
            *doubt = FALSE;
            return TRUE;
          }

        for (arg_num = 0; arg_num < routine_argument_count; ++arg_num)
          {
            variable_declaration *this_formal;

            this_formal = formal_arguments_formal_by_number(formals, arg_num);
            if (variable_declaration_initializer(this_formal) == NULL)
              {
                *doubt = FALSE;
                return FALSE;
              }
          }

        *doubt = FALSE;
        return TRUE;
      }

    if (routine_argument_count == 0)
      {
        size_t arg_num;

        if (routine_declaration_extra_arguments_allowed(declaration))
          {
            *doubt = FALSE;
            return TRUE;
          }

        for (arg_num = 0; arg_num < routine_argument_count; ++arg_num)
          {
            if (!(routine_type->u.routine.argument_has_defaults[arg_num]))
              {
                *doubt = FALSE;
                return FALSE;
              }
          }

        *doubt = FALSE;
        return TRUE;
      }

    bindings = MALLOC_ARRAY(binding_info, type_argument_count);
    if (bindings == NULL)
      {
        jumper_do_abort(the_jumper);
        return FALSE;
      }

    formal_useds = MALLOC_ARRAY(boolean, routine_argument_count);
    if (formal_useds == NULL)
      {
        jumper_do_abort(the_jumper);
        free(bindings);
        return FALSE;
      }

    required_formal_unused_count = 0;

    for (routine_arg_num = 0; routine_arg_num < routine_argument_count;
         ++routine_arg_num)
      {
        variable_declaration *this_formal;

        formal_useds[routine_arg_num] = FALSE;

        this_formal =
                formal_arguments_formal_by_number(formals, routine_arg_num);
        if (variable_declaration_initializer(this_formal) == NULL)
            ++required_formal_unused_count;
      }

    doubt_count = 0;
    definitely_not_no = FALSE;
    type_arg_num = 0;
    routine_arg_num = 0;
    bindings[0].kind = BK_NORMAL;

    while (TRUE)
      {
        variable_declaration *this_formal;
        boolean local_doubt;
        boolean empty;

        assert(type_arg_num < type_argument_count);
        assert(routine_arg_num < routine_argument_count);
        assert(!(formal_useds[routine_arg_num]));
        formal_useds[routine_arg_num] = TRUE;
        bindings[type_arg_num].routine_arg_num = routine_arg_num;

        this_formal =
                formal_arguments_formal_by_number(formals, routine_arg_num);
        if (variable_declaration_initializer(this_formal) == NULL)
          {
            assert(required_formal_unused_count > 0);
            --required_formal_unused_count;
          }

        empty = intersection_empty(
                routine_type->u.routine.argument_types[type_arg_num],
                routine_instance_argument_type(instance, routine_arg_num),
                &local_doubt, location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            result = FALSE;
            goto clean_up;
          }

        if ((empty && !local_doubt) || (definitely_not_no && local_doubt))
          {
            assert(formal_useds[routine_arg_num]);
            formal_useds[routine_arg_num] = FALSE;
            if (variable_declaration_initializer(this_formal) == NULL)
                ++required_formal_unused_count;

          do_mismatch:
            if (bindings[type_arg_num].kind == BK_NORMAL)
              {
                char *type_arg_name;
                size_t new_routine_arg_num;

                bindings[type_arg_num].kind = BK_NAMED;

                type_arg_name = routine_type->u.routine.argument_names[0];
                if (type_arg_name != NULL)
                  {
                    for (new_routine_arg_num = 0;
                         new_routine_arg_num < routine_argument_count;
                         ++new_routine_arg_num)
                      {
                        variable_declaration *this_formal;
                        const char *this_name;

                        this_formal = formal_arguments_formal_by_number(
                                formals, new_routine_arg_num);
                        this_name = variable_declaration_name(this_formal);
                        if ((this_name != NULL) &&
                            (strcmp(this_name, type_arg_name) == 0))
                          {
                            break;
                          }
                      }
                    if ((new_routine_arg_num < routine_argument_count) &&
                        (!(formal_useds[new_routine_arg_num])))
                      {
                        routine_arg_num = new_routine_arg_num;
                        continue;
                      }
                  }
              }

            if (bindings[type_arg_num].kind == BK_NAMED)
              {
                bindings[type_arg_num].kind = BK_DEFAULT;
                if (routine_type->u.routine.argument_has_defaults[
                            type_arg_num])
                  {
                    routine_arg_num = routine_argument_count;
                    local_doubt = possibly_nothing(
                            routine_type->u.routine.argument_types[
                                    type_arg_num]);
                    if ((!definitely_not_no) || !local_doubt)
                      {
                        bindings[type_arg_num].routine_arg_num =
                                routine_argument_count;
                        goto increment_type_num;
                      }
                  }
              }

            assert(bindings[type_arg_num].kind == BK_DEFAULT);

          backtrack:
            if (type_arg_num > 0)
              {
                --type_arg_num;
                if (bindings[type_arg_num].match_doubt)
                    --doubt_count;
                routine_arg_num = bindings[type_arg_num].routine_arg_num;
                assert(routine_arg_num <= routine_argument_count);
                if (routine_arg_num < routine_argument_count)
                  {
                    variable_declaration *this_formal;

                    assert(formal_useds[routine_arg_num]);
                    formal_useds[routine_arg_num] = FALSE;
                    this_formal = formal_arguments_formal_by_number(formals,
                            routine_arg_num);
                    if (variable_declaration_initializer(this_formal) == NULL)
                        ++required_formal_unused_count;
                  }
                goto do_mismatch;
              }

            *doubt = definitely_not_no;
            result = FALSE;
            goto clean_up;
          }

        ++routine_arg_num;

      increment_type_num:
        if (local_doubt)
            ++doubt_count;
        bindings[type_arg_num].match_doubt = local_doubt;

        ++type_arg_num;

        if (type_arg_num >= type_argument_count)
          {
            boolean need_named;

            if (required_formal_unused_count == 0)
              {
              tail_ok:
                if (doubt_count > 0)
                  {
                    assert(!definitely_not_no);
                    definitely_not_no = TRUE;
                    while (doubt_count > 0)
                      {
                        variable_declaration *this_formal;

                        assert(type_arg_num > 0);
                        --type_arg_num;
                        if (bindings[type_arg_num].match_doubt)
                            --doubt_count;
                        routine_arg_num =
                                bindings[type_arg_num].routine_arg_num;
                        assert(routine_arg_num <= routine_argument_count);
                        if (routine_arg_num < routine_argument_count)
                          {
                            assert(formal_useds[routine_arg_num]);
                            formal_useds[routine_arg_num] = FALSE;
                            this_formal = formal_arguments_formal_by_number(
                                    formals, routine_arg_num);
                            if (variable_declaration_initializer(this_formal)
                                == NULL)
                              {
                                ++required_formal_unused_count;
                              }
                          }
                      }
                    goto do_mismatch;
                  }

                *doubt = FALSE;
                result = TRUE;
                goto clean_up;
              }

            if ((!(routine_type->u.routine.extra_arguments_allowed)) &&
                (!(routine_type->u.routine.extra_arguments_unspecified)))
              {
                goto backtrack;
              }

            need_named = FALSE;
            while (routine_arg_num > 0)
              {
                --routine_arg_num;
                if (formal_useds[routine_arg_num])
                  {
                    if (need_named)
                      {
                        *doubt = FALSE;
                        result = FALSE;
                        goto clean_up;
                      }
                  }
                else
                  {
                    variable_declaration *this_formal;
                    boolean has_name;

                    this_formal = formal_arguments_formal_by_number(formals,
                            routine_arg_num);
                    has_name =
                            (variable_declaration_name(this_formal) != NULL);
                    if (need_named)
                      {
                        need_named = !has_name;
                      }
                    else
                      {
                        need_named =
                                ((!has_name) &&
                                 (variable_declaration_initializer(this_formal)
                                  == NULL));
                      }
                  }
              }
            if (need_named)
              {
                *doubt = FALSE;
                result = FALSE;
                goto clean_up;
              }

            goto tail_ok;
          }

        bindings[type_arg_num].kind = BK_NORMAL;

        if (routine_arg_num >= routine_argument_count)
            goto do_mismatch;
      }

  clean_up:
    free(formal_useds);
    free(bindings);
    return result;
  }

static int compare_generic_values(const void *left, const void *right)
  {
    assert(left != NULL);
    assert(right != NULL);

    assert(value_is_valid(*(value **)left)); /* VERIFIED */
    assert(value_is_valid(*(value **)right)); /* VERIFIED */
    return value_structural_order(*(value **)left, *(value **)right);
  }

static int compare_size_t_and_string(const void *left, const void *right)
  {
    const size_t_and_string *left_data;
    const size_t_and_string *right_data;
    int result;

    assert(left != NULL);
    assert(right != NULL);

    left_data = (const size_t_and_string *)left;
    right_data = (const size_t_and_string *)right;

    assert(left_data->string != NULL);
    assert(right_data->string != NULL);

    result = utf8_string_lexicographical_order_by_code_point(left_data->string,
            right_data->string);
    if (result != 0)
        return result;

    if (left_data->the_size_t < right_data->the_size_t)
        return -1;
    else if (left_data->the_size_t > right_data->the_size_t)
        return 1;
    else
        return 0;
  }

static int compare_o_integers(const void *left, const void *right)
  {
    const o_integer *left_oi;
    const o_integer *right_oi;

    assert(left != NULL);
    assert(right != NULL);

    left_oi = (const o_integer *)left;
    right_oi = (const o_integer *)right;

    if (oi_less_than(*left_oi, *right_oi))
        return -1;
    else if (oi_less_than(*right_oi, *left_oi))
        return 1;
    else
        return 0;
  }

static int compare_rationals(const void *left, const void *right)
  {
    rational * const *left_rational;
    rational * const *right_rational;
    boolean error;

    assert(left != NULL);
    assert(right != NULL);

    left_rational = (rational * const *)left;
    right_rational = (rational * const *)right;

    if (rational_less_than(*left_rational, *right_rational, &error))
        return -1;
    else if (rational_less_than(*right_rational, *left_rational, &error))
        return 1;
    else
        return 0;
  }

static boolean possibly_nothing(type *the_type)
  {
    assert(the_type != NULL);

    assert(type_is_valid(the_type)); /* VERIFIED */

    switch (the_type->kind)
      {
        case TK_ANYTHING:
          {
            return FALSE;
          }
        case TK_NOTHING:
          {
            return TRUE;
          }
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
          {
            return FALSE;
          }
        case TK_ENUMERATION:
          {
            return (the_type->u.enumeration.value_count == 0);
          }
        case TK_NOT:
          {
            assert(type_is_valid(the_type->u.not.base)); /* VERIFIED */
            return possibly_everything(the_type->u.not.base);
          }
        case TK_INTERSECTION:
          {
            return TRUE;
          }
        case TK_UNION:
          {
            assert(type_is_valid(the_type->u.union_type.left)); /* VERIFIED */
            assert(type_is_valid(the_type->u.union_type.right)); /* VERIFIED */
            return (possibly_nothing(the_type->u.union_type.left) &&
                    possibly_nothing(the_type->u.union_type.right));
          }
        case TK_XOR:
          {
            assert(type_is_valid(the_type->u.xor.left)); /* VERIFIED */
            assert(type_is_valid(the_type->u.xor.right)); /* VERIFIED */
            if (type_structural_order(the_type->u.xor.left,
                                      the_type->u.xor.right) == 0)
              {
                return TRUE;
              }
            else
              {
                return (type_is_slippery(the_type->u.xor.left) ||
                        type_is_slippery(the_type->u.xor.right));
              }
          }
        case TK_ARRAY:
          {
            return FALSE;
          }
        case TK_INTEGER_RANGES:
          {
            return FALSE;
          }
        case TK_RATIONAL_RANGES:
          {
            return FALSE;
          }
        case TK_POINTER:
          {
            assert(type_is_valid(the_type->u.pointer.base)); /* VERIFIED */
            return (possibly_nothing(the_type->u.pointer.base) &&
                    !(the_type->u.pointer.null_allowed));
          }
        case TK_TYPE:
          {
            assert(type_is_valid(the_type->u.type.base)); /* VERIFIED */
            return possibly_nothing(the_type->u.type.base);
          }
        case TK_MAP:
          {
            return FALSE;
          }
        case TK_ROUTINE:
          {
            return FALSE;
          }
        case TK_FIELDS:
          {
            assert(type_is_valid(the_type)); /* VERIFIED */
            return field_info_possibly_nothing(
                    &(the_type->u.fields.field_info));
          }
        case TK_LEPTON:
          {
            assert(type_is_valid(the_type)); /* VERIFIED */
            return field_info_possibly_nothing(
                    &(the_type->u.lepton.field_info));
          }
        case TK_MULTISET:
          {
            assert(type_is_valid(the_type)); /* VERIFIED */
            return field_info_possibly_nothing(
                    &(the_type->u.multiset.field_info));
          }
        case TK_INTERFACE:
          {
            assert(type_is_valid(the_type)); /* VERIFIED */
            return field_info_possibly_nothing(
                    &(the_type->u.interface.field_info));
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t element_count;
            size_t element_num;

            element_count = the_type->u.semi_labeled_value_list.element_count;
            for (element_num = 0; element_num < element_count; ++element_num)
              {
                type *element_type;

                element_type = the_type->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);
                assert(type_is_valid(element_type)); /* VERIFIED */
                if (possibly_nothing(element_type))
                    return TRUE;
              }
            return FALSE;
          }
        case TK_REGULAR_EXPRESSION:
          {
            return TRUE;
          }
        case TK_CLASS:
          {
            return FALSE;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            return TRUE;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return FALSE;
          }
        default:
          {
            assert(FALSE);
            return FALSE;
          }
      }
  }

static boolean possibly_everything(type *the_type)
  {
    assert(the_type != NULL);

    assert(type_is_valid(the_type)); /* VERIFIED */

    switch (the_type->kind)
      {
        case TK_ANYTHING:
          {
            return TRUE;
          }
        case TK_NOTHING:
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
        case TK_ENUMERATION:
          {
            return FALSE;
          }
        case TK_NOT:
          {
            assert(type_is_valid(the_type->u.not.base)); /* VERIFIED */
            return possibly_nothing(the_type->u.not.base);
          }
        case TK_INTERSECTION:
          {
            assert(type_is_valid(the_type->u.intersection.left));
                    /* VERIFIED */
            assert(type_is_valid(the_type->u.intersection.right));
                    /* VERIFIED */
            return (possibly_everything(the_type->u.intersection.left) &&
                    possibly_everything(the_type->u.intersection.right));
          }
        case TK_UNION:
          {
            return TRUE;
          }
        case TK_XOR:
          {
            assert(type_is_valid(the_type->u.xor.left)); /* VERIFIED */
            assert(type_is_valid(the_type->u.xor.right)); /* VERIFIED */
            return (type_structural_order(the_type->u.xor.left,
                                          the_type->u.xor.right) != 0);
          }
        case TK_ARRAY:
        case TK_INTEGER_RANGES:
        case TK_RATIONAL_RANGES:
        case TK_POINTER:
        case TK_TYPE:
        case TK_MAP:
        case TK_ROUTINE:
        case TK_FIELDS:
        case TK_LEPTON:
        case TK_MULTISET:
        case TK_INTERFACE:
        case TK_SEMI_LABELED_VALUE_LIST:
        case TK_REGULAR_EXPRESSION:
        case TK_CLASS:
          {
            return FALSE;
          }
        case TK_TEST_ROUTINE:
        case TK_TEST_ROUTINE_CHAIN:
          {
            return TRUE;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return FALSE;
          }
        default:
          {
            assert(FALSE);
            return FALSE;
          }
      }
  }

static boolean enumeration_has_only_string_values(type *the_type)
  {
    size_t value_count;
    value **values;
    size_t value_num;

    assert(the_type != NULL);
    assert(the_type->kind == TK_ENUMERATION);

    value_count = the_type->u.enumeration.value_count;
    values = the_type->u.enumeration.values;

    for (value_num = 0; value_num < value_count; ++value_num)
      {
        if (get_value_kind(values[value_num]) != VK_STRING)
            return FALSE;
      }

    return TRUE;
  }

static boolean array_and_map_are_equal(type *array_type, type *map_type,
        boolean *doubt, const source_location *location, jumper *the_jumper)
  {
    type *new_map_type;
    boolean result;

    assert(array_type != NULL);
    assert(map_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(array_type->kind == TK_ARRAY);
    assert(map_type->kind == TK_MAP);

    assert(type_is_valid(array_type)); /* VERIFIED */
    assert(type_is_valid(map_type)); /* VERIFIED */

    assert(type_is_valid(array_type)); /* VERIFIED */
    new_map_type = map_type_for_array_type(array_type);
    assert((new_map_type == NULL) || type_is_valid(new_map_type));
            /* VERIFIED */
    if (new_map_type == NULL)
      {
        jumper_do_abort(the_jumper);
        return FALSE;
      }

    assert(type_is_valid(new_map_type)); /* VERIFIED */
    assert(type_is_valid(map_type)); /* VERIFIED */
    result = types_are_equal(new_map_type, map_type, doubt, location,
                             the_jumper);
    type_remove_reference(new_map_type,
            ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
    return result;
  }

static boolean array_and_semi_labeled_value_list_are_equal(type *array_type,
        type *semi_labeled_value_list_type, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    int test_order;

    assert(array_type != NULL);
    assert(semi_labeled_value_list_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(array_type)); /* VERIFIED */
    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(array_type->kind == TK_ARRAY);
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);

    if (semi_labeled_value_list_type->u.semi_labeled_value_list.element_count >
        0)
      {
        *doubt = FALSE;
        return FALSE;
      }

    if (semi_labeled_value_list_type->u.semi_labeled_value_list.
                extra_elements_allowed)
      {
        *doubt = FALSE;
        return FALSE;
      }

    if (array_type->u.array.base->kind == TK_NOTHING)
      {
        *doubt = FALSE;
        return TRUE;
      }

    test_order = oi_structural_order(array_type->u.array.lower_bound,
                                     array_type->u.array.upper_bound);
    if (test_order == -2)
      {
        jumper_do_abort(the_jumper);
        return FALSE;
      }
    if (test_order <= 0)
      {
        assert(type_is_valid(array_type)); /* VERIFIED */
        assert(type_is_valid(array_type->u.array.base)); /* VERIFIED */
        *doubt = possibly_nothing(array_type->u.array.base);
        return FALSE;
      }
    else
      {
        *doubt = FALSE;
        return TRUE;
      }
  }

static boolean semi_labeled_value_list_and_map_are_equal(
        type *semi_labeled_value_list_type, type *map_type, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    size_t element_count;
    type **element_types;
    type *second_key_type;
    boolean key_doubt;
    boolean key_match;
    char **element_names;
    size_t element_num;

    assert(semi_labeled_value_list_type != NULL);
    assert(map_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(type_is_valid(map_type)); /* VERIFIED */
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);
    assert(map_type->kind == TK_MAP);

    element_count = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_count;

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    element_types = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_types;
    assert((element_count == 0) || (element_types != NULL));

    if (map_type->u.map.target->kind == TK_NOTHING)
      {
        size_t element_num;

        *doubt = FALSE;
        for (element_num = 0; element_num < element_count; ++element_num)
          {
            if (element_types[element_num]->kind != TK_NOTHING)
              {
                assert(type_is_valid(element_types[element_num]));
                        /* VERIFIED */
                if (!(possibly_nothing(element_types[element_num])))
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
                *doubt = TRUE;
              }
          }

        return TRUE;
      }

    *doubt = FALSE;

    if ((element_count == 0) &&
        !(semi_labeled_value_list_type->u.semi_labeled_value_list.
                  extra_elements_allowed))
      {
        second_key_type = get_nothing_type();
        if (second_key_type == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }
        type_add_reference(second_key_type);
      }
    else
      {
        o_integer upper_oi;

        if (semi_labeled_value_list_type->u.semi_labeled_value_list.
                    extra_elements_allowed)
          {
            if (map_type->u.map.target->kind != TK_ANYTHING)
              {
                assert(type_is_valid(map_type->u.map.target)); /* VERIFIED */
                if (!(possibly_everything(map_type->u.map.target)))
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
                *doubt = TRUE;
              }

            upper_oi = oi_positive_infinity;
            oi_add_reference(upper_oi);
          }
        else
          {
            oi_create_from_size_t(upper_oi, element_count);
          }
        if (oi_out_of_memory(upper_oi))
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }

        second_key_type =
                get_integer_range_type(oi_zero, upper_oi, TRUE, FALSE);
        oi_remove_reference(upper_oi);
        if (second_key_type == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }
      }

    assert(type_is_valid(map_type->u.map.key)); /* VERIFIED */
    assert(type_is_valid(second_key_type)); /* VERIFIED */
    key_match = types_are_equal(map_type->u.map.key, second_key_type,
                                &key_doubt, location, the_jumper);
    type_remove_reference(second_key_type,
            ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
    if (!(jumper_flowing_forward(the_jumper)))
        return FALSE;
    if ((!key_match) && (!key_doubt))
      {
        *doubt = FALSE;
        return FALSE;
      }
    if (key_doubt)
        *doubt = TRUE;

    element_names = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_names;
    assert((element_count == 0) || (element_names != NULL));

    for (element_num = 0; element_num < element_count; ++element_num)
      {
        type *this_element_type;
        boolean element_doubt;
        boolean elements_match;

        if (element_names[element_num] != NULL)
          {
            *doubt = TRUE;
            assert(type_is_valid(element_types[element_num])); /* VERIFIED */
            if (!(possibly_nothing(element_types[element_num])))
              {
                *doubt = FALSE;
                return FALSE;
              }
          }

        this_element_type = element_types[element_num];
        assert(type_is_valid(map_type->u.map.target)); /* VERIFIED */
        assert(type_is_valid(this_element_type)); /* VERIFIED */
        elements_match = types_are_equal(map_type->u.map.target,
                this_element_type, &element_doubt, location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (element_doubt)
          {
            *doubt = TRUE;
          }
        else if (!elements_match)
          {
            *doubt = TRUE;
            assert(type_is_valid(element_types[element_num])); /* VERIFIED */
            if (!(possibly_nothing(element_types[element_num])))
              {
                *doubt = FALSE;
                return FALSE;
              }
          }
      }

    return TRUE;
  }

static boolean array_is_subset_of_semi_labeled_value_list(type *array_type,
        type *semi_labeled_value_list_type, boolean *doubt, char **why_not,
        const source_location *location, jumper *the_jumper)
  {
    size_t element_count;
    int test_order;

    assert(array_type != NULL);
    assert(semi_labeled_value_list_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(array_type)); /* VERIFIED */
    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(array_type->kind == TK_ARRAY);
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);

    element_count = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_count;

    if (semi_labeled_value_list_type->u.semi_labeled_value_list.element_count >
        0)
      {
        return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                "the candidate sub-type is an array type and the candidate "
                "super-type is a semi-labeled value list type, and the later "
                "specifies more than zero elements, so it does not include the"
                " empty semi-labeled value list, while all array types include"
                " the empty semi-labeled value list");
      }

    if (array_type->u.array.base->kind == TK_NOTHING)
      {
        *doubt = FALSE;
        return TRUE;
      }

    if (!(semi_labeled_value_list_type->u.semi_labeled_value_list.
                  extra_elements_allowed))
      {
        int test_order;

        test_order = oi_structural_order(array_type->u.array.lower_bound,
                                         array_type->u.array.upper_bound);
        if (test_order == -2)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }
        if (test_order <= 0)
          {
            assert(type_is_valid(array_type->u.array.base)); /* VERIFIED */
            if (possibly_nothing(array_type->u.array.base))
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type is an array type and the "
                        "candidate super-type is a semi-labeled value list "
                        "type, and the later allows only zero-element values "
                        "and the former's bounds allow allow a non-zero number"
                        " of elements, and %s is unable to determine whether "
                        "the former's base type is empty", interpreter_name());
              }
            else
              {
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type is an array type and the "
                        "candidate super-type is a semi-labeled value list "
                        "type, and the later allows only zero-element values "
                        "and the former's bounds allow allow a non-zero number"
                        " of elements, and the former's base type is "
                        "non-empty");
              }
          }
        else
          {
            *doubt = FALSE;
            return TRUE;
          }
      }

    test_order = oi_structural_order(oi_zero, array_type->u.array.lower_bound);
    if (test_order == -2)
      {
        jumper_do_abort(the_jumper);
        return FALSE;
      }
    if (test_order > 0)
      {
        assert(type_is_valid(array_type->u.array.base)); /* VERIFIED */
        if (possibly_nothing(array_type->u.array.base))
          {
            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type is an array type and the candidate"
                    " super-type is a semi-labeled value list type, and the "
                    "former's lower bound allows values with elements with "
                    "negative indexes, and %s is unable to determine whether "
                    "the former's base type is empty", interpreter_name());
          }
        else
          {
            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the candidate sub-type is an array type and the candidate"
                    " super-type is a semi-labeled value list type, and the "
                    "former's lower bound allows values with elements with "
                    "negative indexes, and the former's base type is "
                    "non-empty");
          }
      }

    *doubt = FALSE;
    return TRUE;
  }

static boolean semi_labeled_value_list_is_subset_of_array(
        type *semi_labeled_value_list_type, type *array_type, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper)
  {
    size_t element_count;
    type **element_types;
    char **element_names;
    size_t element_num;

    assert(semi_labeled_value_list_type != NULL);
    assert(array_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(type_is_valid(array_type)); /* VERIFIED */
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);
    assert(array_type->kind == TK_ARRAY);

    element_count = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_count;

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    element_types = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_types;
    assert((element_count == 0) || (element_types != NULL));

    if (array_type->u.array.base->kind == TK_NOTHING)
      {
        size_t element_num;

        *doubt = FALSE;
        for (element_num = 0; element_num < element_count; ++element_num)
          {
            if (element_types[element_num]->kind != TK_NOTHING)
              {
                assert(type_is_valid(element_types[element_num]));
                        /* VERIFIED */
                if (!(possibly_nothing(element_types[element_num])))
                  {
                    if ((why_not != NULL) && (*doubt))
                        free(*why_not);
                    if (possibly_nothing(semi_labeled_value_list_type))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is an array type, and the later has an empty "
                                "base type while the former has a non-empty "
                                "type for element %lu, and %s is unable to "
                                "determine whether the former is the empty "
                                "type", (unsigned long)element_num,
                                interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is an array type, and the later has an empty "
                                "base type while the former has a non-empty "
                                "type for element %lu, and the former is not "
                                "the empty type", (unsigned long)element_num);
                      }
                  }
                if ((why_not != NULL) && (!(*doubt)))
                  {
                    *why_not = allocate_printf(
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and the later has an empty base type "
                            "while %s is unable to determine whether the "
                            "former's type for element %lu is non-empty",
                            interpreter_name(), (unsigned long)element_num);
                    if (*why_not == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                  }
                *doubt = TRUE;
              }
          }

        return TRUE;
      }

    *doubt = FALSE;

    if (semi_labeled_value_list_type->u.semi_labeled_value_list.
                extra_elements_allowed)
      {
        if (oi_kind(array_type->u.array.upper_bound) != IIK_POSITIVE_INFINITY)
          {
            if (possibly_nothing(semi_labeled_value_list_type))
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is an array type, "
                        "and the later has an upper bound less than positive "
                        "infinity while the former allows unlimited additional"
                        " elements, and %s is unable to determine whether the "
                        "former is the empty type", interpreter_name());
              }
            else
              {
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is an array type, "
                        "and the later has an upper bound less than positive "
                        "infinity while the former allows unlimited additional"
                        " elements, and the former is not the empty type");
              }
          }

        if (array_type->u.array.base->kind != TK_ANYTHING)
          {
            assert(type_is_valid(array_type)); /* VERIFIED */
            assert(type_is_valid(array_type->u.array.base)); /* VERIFIED */
            if (!(possibly_everything(array_type->u.array.base)))
              {
                if (possibly_nothing(semi_labeled_value_list_type))
                  {
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and the later has a base type that is"
                            " not the type of all values while the former "
                            "allows unlimited additional elements, and %s is "
                            "unable to determine whether the former is the "
                            "empty type", interpreter_name());
                  }
                else
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and the later has a base type that is"
                            " not the type of all values while the former "
                            "allows unlimited additional elements, and the "
                            "former is not the empty type");
                  }
              }
            if (why_not != NULL)
              {
                *why_not = allocate_printf(
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is an array type, "
                        "and %s is unable to determine whether the later's "
                        "base type is the type of all values, while the former"
                        " allows unlimited additional elements",
                        interpreter_name());
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }
      }

    element_names = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_names;
    assert((element_count == 0) || (element_names != NULL));

    for (element_num = 0; element_num < element_count; ++element_num)
      {
        type *base_type;
        boolean base_is_outside;
        o_integer index_oi;
        int order;
        type *element_type;
        boolean element_doubt;
        char *element_why_not;
        boolean element_subset;

        assert(type_is_valid(array_type)); /* VERIFIED */
        base_type = array_type->u.array.base;
        assert(type_is_valid(base_type)); /* VERIFIED */
        base_is_outside = FALSE;

        oi_create_from_size_t(index_oi, element_num);
        if (oi_out_of_memory(index_oi))
          {
            jumper_do_abort(the_jumper);
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            return FALSE;
          }

        order = oi_structural_order(index_oi, array_type->u.array.lower_bound);
        if (order == -2)
          {
            jumper_do_abort(the_jumper);
            oi_remove_reference(index_oi);
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            return FALSE;
          }
        if (order < 0)
          {
            base_is_outside = TRUE;
            base_type = get_nothing_type();
            if (base_type == NULL)
              {
                jumper_do_abort(the_jumper);
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                oi_remove_reference(index_oi);
                return FALSE;
              }
            assert(type_is_valid(base_type)); /* VERIFIED */
          }

        order = oi_structural_order(index_oi, array_type->u.array.upper_bound);
        if (order == -2)
          {
            jumper_do_abort(the_jumper);
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            oi_remove_reference(index_oi);
            return FALSE;
          }
        if (order > 0)
          {
            base_is_outside = TRUE;
            base_type = get_nothing_type();
            if (base_type == NULL)
              {
                jumper_do_abort(the_jumper);
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                oi_remove_reference(index_oi);
                return FALSE;
              }
            assert(type_is_valid(base_type)); /* VERIFIED */
          }

        oi_remove_reference(index_oi);

        element_type = element_types[element_num];

        if (element_names[element_num] != NULL)
          {
            assert(type_is_valid(element_type)); /* VERIFIED */
            if (!(possibly_nothing(element_type)))
              {
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                if (possibly_nothing(semi_labeled_value_list_type))
                  {
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and the former specifies a name "
                            "(`%s') for element %lu and specifies a non-empty "
                            "type for that element, and %s is unable to "
                            "determine whether the former is the empty type",
                            element_names[element_num],
                            (unsigned long)element_num, interpreter_name());
                  }
                else
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and the former specifies a name "
                            "(`%s') for element %lu and specifies a non-empty "
                            "type for that element, and the former is not the "
                            "empty type", element_names[element_num],
                            (unsigned long)element_num);
                  }
              }
            if ((why_not != NULL) && (!(*doubt)))
              {
                *why_not = allocate_printf(
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is an array type, "
                        "and the former specifies a name (`%s') for element "
                        "%lu and %s is unable to determine whether the type "
                        "that the former specifies for that element is the "
                        "empty type", element_names[element_num],
                        (unsigned long)element_num, interpreter_name());
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }

        assert(type_is_valid(element_type)); /* VERIFIED */
        assert(type_is_valid(base_type)); /* VERIFIED */
        element_subset = type_is_subset(element_type, base_type,
                &element_doubt, ((why_not == NULL) ? NULL : &element_why_not),
                location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            return FALSE;
          }
        if (element_doubt)
          {
            if (why_not != NULL)
              {
                if (!(*doubt))
                  {
                    if (base_is_outside)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is an array type, and %s is unable to "
                                "determine whether the type specified by the "
                                "former for element %lu is empty, but %lu is "
                                "outside the bounds of the later",
                                interpreter_name(), (unsigned long)element_num,
                                (unsigned long)element_num);
                      }
                    else
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is an array type, and %s is unable to "
                                "determine whether the type specified by the "
                                "former for element %lu is a subset of the "
                                "base type of the later because %s",
                                interpreter_name(), (unsigned long)element_num,
                                element_why_not);
                      }
                  }
                free(element_why_not);
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }
        else if (!element_subset)
          {
            boolean result;

            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            if (possibly_nothing(semi_labeled_value_list_type))
              {
                if (base_is_outside)
                  {
                    result = type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and %s is unable to determine whether"
                            " the former is the empty type, and the former "
                            "specifies a non-empty type for element %lu, but "
                            "%lu is outside the bounds of the later",
                            interpreter_name(), (unsigned long)element_num,
                            (unsigned long)element_num);
                  }
                else
                  {
                    result = type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and %s is unable to determine whether"
                            " the former is the empty type, and the former "
                            "specifies a type for element %lu which is not a "
                            "subset of the base type of the later because %s",
                            interpreter_name(), (unsigned long)element_num,
                            element_why_not);
                  }
              }
            else
              {
                if (base_is_outside)
                  {
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and the former is not the empty type,"
                            " and the former specifies a non-empty type for "
                            "element %lu, but %lu is outside the bounds of the"
                            " later", (unsigned long)element_num,
                            (unsigned long)element_num);
                  }
                else
                  {
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is an "
                            "array type, and the former is not the empty type,"
                            " and the former specifies a type for element %lu "
                            "which is not a subset of the base type of the "
                            "later because %s", (unsigned long)element_num,
                            element_why_not);
                  }
              }
            if (why_not != NULL)
                free(element_why_not);
            return result;
          }
      }

    return TRUE;
  }

static boolean semi_labeled_value_list_is_subset_of_map(
        type *semi_labeled_value_list_type, type *map_type, boolean *doubt,
        char **why_not, const source_location *location, jumper *the_jumper)
  {
    size_t element_count;
    type **element_types;
    char **element_names;
    size_t element_num;

    assert(semi_labeled_value_list_type != NULL);
    assert(map_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(type_is_valid(map_type)); /* VERIFIED */
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);
    assert(map_type->kind == TK_MAP);

    element_count = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_count;

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    element_types = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_types;
    assert((element_count == 0) || (element_types != NULL));

    if (map_type->u.map.target->kind == TK_NOTHING)
      {
        size_t element_num;

        *doubt = FALSE;
        for (element_num = 0; element_num < element_count; ++element_num)
          {
            if (element_types[element_num]->kind != TK_NOTHING)
              {
                assert(type_is_valid(element_types[element_num]));
                        /* VERIFIED */
                if (!(possibly_nothing(element_types[element_num])))
                  {
                    if ((why_not != NULL) && (*doubt))
                        free(*why_not);
                    if (possibly_nothing(semi_labeled_value_list_type))
                      {
                        return type_in_doubt(doubt, why_not, the_jumper,
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is a map type, and the later has an empty "
                                "target type while the former has a non-empty "
                                "type for element %lu, and %s is unable to "
                                "determine whether the former is the empty "
                                "type", (unsigned long)element_num,
                                interpreter_name());
                      }
                    else
                      {
                        return type_in_no_doubt(FALSE, doubt, why_not,
                                the_jumper,
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is a map type, and the later has an empty "
                                "target type while the former has a non-empty "
                                "type for element %lu, and the former is not "
                                "the empty type", (unsigned long)element_num);
                      }
                  }
                if ((why_not != NULL) && (!(*doubt)))
                  {
                    *why_not = allocate_printf(
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and the later has an empty target type "
                            "while %s is unable to determine whether the "
                            "former's type for element %lu is non-empty",
                            interpreter_name(), (unsigned long)element_num);
                    if (*why_not == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                  }
                *doubt = TRUE;
              }
          }

        return TRUE;
      }

    if ((element_count == 0) &&
        !(semi_labeled_value_list_type->u.semi_labeled_value_list.
                  extra_elements_allowed))
      {
        *doubt = FALSE;
        return TRUE;
      }

    *doubt = FALSE;

    if (semi_labeled_value_list_type->u.semi_labeled_value_list.
                extra_elements_allowed)
      {
        o_integer extra_lower;
        type *extra_index_type;
        boolean extra_doubt;
        char *extra_why_not;
        boolean extra_subset;

        oi_create_from_size_t(extra_lower, element_count);
        if (oi_out_of_memory(extra_lower))
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }

        extra_index_type = get_integer_range_type(extra_lower,
                oi_positive_infinity, FALSE, FALSE);
        oi_remove_reference(extra_lower);
        if (extra_index_type == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }

        assert(type_is_valid(extra_index_type)); /* VERIFIED */
        assert(type_is_valid(map_type)); /* VERIFIED */
        assert(type_is_valid(map_type->u.map.key)); /* VERIFIED */
        extra_subset = type_is_subset(extra_index_type, map_type->u.map.key,
                &extra_doubt, ((why_not == NULL) ? NULL : &extra_why_not),
                location, the_jumper);
        type_remove_reference(extra_index_type,
                ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (extra_doubt)
          {
            if (why_not != NULL)
              {
                if (!(*doubt))
                  {
                    *why_not = allocate_printf(
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and the former allows unlimited additional "
                            "elements and %s is unable to determine whether "
                            "the type of indexes for these extra elements is a"
                            " subset of the later's key type because %s",
                            interpreter_name(), extra_why_not);
                  }
                free(extra_why_not);
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }
        else if (!extra_subset)
          {
            boolean result;

            if (possibly_nothing(semi_labeled_value_list_type))
              {
                result = type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is a map type, and "
                        "%s is unable to determine whether the former is the "
                        "empty type, and the former allows unlimited "
                        "additional elements and the type of indexes for these"
                        " extra elements is not a subset of the later's key "
                        "type because %s", interpreter_name(), extra_why_not);
              }
            else
              {
                result = type_in_no_doubt(FALSE, doubt, why_not,
                        the_jumper,
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is a map type, and "
                        "the former is not the empty type, and the former "
                        "allows unlimited additional elements and the type of "
                        "indexes for these extra elements is not a subset of "
                        "the later's key type because %s", extra_why_not);
              }
            if (why_not != NULL)
                free(extra_why_not);
            return result;
          }

        if (map_type->u.map.target->kind != TK_ANYTHING)
          {
            assert(type_is_valid(map_type)); /* VERIFIED */
            assert(type_is_valid(map_type->u.map.target)); /* VERIFIED */
            if (!(possibly_everything(map_type->u.map.target)))
              {
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                if (possibly_nothing(semi_labeled_value_list_type))
                  {
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and %s is unable to determine whether the "
                            "former is the empty type, and the former allows "
                            "unlimited additional elements and the later's "
                            "target type is not the type containing all "
                            "values", interpreter_name());
                  }
                else
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and the former is not the empty type, and "
                            "the former allows unlimited additional elements "
                            "and the later's target type is not the type "
                            "containing all values");
                  }
              }
            if ((why_not != NULL) && (!(*doubt)))
              {
                *why_not = allocate_printf(
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and the former allows unlimited additional "
                            "elements and %s is unable to determine whether "
                            "the later's target type is the type containing "
                            "all values", interpreter_name());
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }
      }

    element_names = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_names;
    assert((element_count == 0) || (element_names != NULL));

    for (element_num = 0; element_num < element_count; ++element_num)
      {
        type *target_type;
        boolean target_is_outside;
        o_integer index_oi;
        value *index_value;
        boolean key_doubt;
        char *key_why_not;
        boolean key_match;
        type *element_type;
        boolean element_doubt;
        char *element_why_not;
        boolean element_subset;

        assert(type_is_valid(map_type)); /* VERIFIED */
        target_type = map_type->u.map.target;
        assert(target_type != NULL);
        assert(type_is_valid(target_type)); /* VERIFIED */
        target_is_outside = FALSE;

        oi_create_from_size_t(index_oi, element_num);
        if (oi_out_of_memory(index_oi))
          {
            jumper_do_abort(the_jumper);
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            return FALSE;
          }

        index_value = create_integer_value(index_oi);
        oi_remove_reference(index_oi);
        if (index_value == NULL)
          {
            jumper_do_abort(the_jumper);
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            return FALSE;
          }

        assert(type_is_valid(map_type)); /* VERIFIED */
        assert(type_is_valid(map_type->u.map.key)); /* VERIFIED */
        key_match = value_is_in_type(index_value, map_type->u.map.key,
                &key_doubt, ((why_not == NULL) ? NULL : &key_why_not),
                location, the_jumper);
        value_remove_reference(index_value,
                ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
        if (!(jumper_flowing_forward(the_jumper)))
          {
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            return FALSE;
          }
        if ((!key_match) && (!key_doubt))
          {
            if (why_not)
                free(key_why_not);
            target_is_outside = TRUE;
            target_type = get_nothing_type();
            if (target_type == NULL)
              {
                jumper_do_abort(the_jumper);
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                return FALSE;
              }
            assert(type_is_valid(target_type)); /* VERIFIED */
          }
        else if (key_doubt)
          {
            if (element_type->kind != TK_NOTHING)
              {
                if (why_not != NULL)
                  {
                    if (!(*doubt))
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is a map type, and the former specifies a "
                                "type for element %lu that %s is unable to "
                                "determine is the empty type and %s is unable "
                                "to determine whether %lu is in the key type "
                                "of the later because %s",
                                (unsigned long)element_num, interpreter_name(),
                                interpreter_name(), (unsigned long)element_num,
                                key_why_not);
                      }
                    free(key_why_not);
                    if (*why_not == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        return FALSE;
                      }
                  }
                *doubt = TRUE;
              }
            else if (why_not != NULL)
              {
                free(key_why_not);
              }
          }

        element_type = element_types[element_num];

        if (element_names[element_num] != NULL)
          {
            assert(type_is_valid(element_type)); /* VERIFIED */
            if (!(possibly_nothing(element_type)))
              {
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                if (possibly_nothing(semi_labeled_value_list_type))
                  {
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and the former specifies a name (`%s') for "
                            "element %lu and specifies a non-empty type for "
                            "that element, and %s is unable to determine "
                            "whether the former is the empty type",
                            element_names[element_num],
                            (unsigned long)element_num, interpreter_name());
                  }
                else
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and the former specifies a name (`%s') for "
                            "element %lu and specifies a non-empty type for "
                            "that element, and the former is not the empty "
                            "type", element_names[element_num],
                            (unsigned long)element_num);
                  }
              }
            if ((why_not != NULL) && (!(*doubt)))
              {
                *why_not = allocate_printf(
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is a map type, and "
                        "the former specifies a name (`%s') for element %lu "
                        "and %s is unable to determine whether the type that "
                        "the former specifies for that element is the empty "
                        "type", element_names[element_num],
                        (unsigned long)element_num, interpreter_name());
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }

        assert(type_is_valid(element_type)); /* VERIFIED */
        assert(type_is_valid(target_type)); /* VERIFIED */
        element_subset = type_is_subset(element_type, target_type,
                &element_doubt, ((why_not == NULL) ? NULL : &element_why_not),
                location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            return FALSE;
          }
        if (element_doubt)
          {
            if (why_not != NULL)
              {
                if (!(*doubt))
                  {
                    if (target_is_outside)
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is a map type, and %s is unable to determine "
                                "whether the type specified by the former for "
                                "element %lu is empty, but %lu is outside the "
                                "key type of the later", interpreter_name(),
                                (unsigned long)element_num,
                                (unsigned long)element_num);
                      }
                    else
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type is a semi-labeled "
                                "value list type and the candidate super-type "
                                "is a map type, and %s is unable to determine "
                                "whether the type specified by the former for "
                                "element %lu is a subset of the target type of"
                                " the later because %s", interpreter_name(),
                                (unsigned long)element_num, element_why_not);
                      }
                  }
                free(element_why_not);
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }
        else if (!element_subset)
          {
            boolean result;

            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            if (possibly_nothing(semi_labeled_value_list_type))
              {
                if (target_is_outside)
                  {
                    result = type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and %s is unable to determine whether the "
                            "former is the empty type, and the former "
                            "specifies a non-empty type for element %lu, but "
                            "%lu is outside the key type of the later",
                            interpreter_name(), (unsigned long)element_num,
                            (unsigned long)element_num);
                  }
                else
                  {
                    result = type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and %s is unable to determine whether the "
                            "former is the empty type, and the former "
                            "specifies a type for element %lu which is not a "
                            "subset of the target type of the later because "
                            "%s", interpreter_name(),
                            (unsigned long)element_num, element_why_not);
                  }
              }
            else
              {
                if (target_is_outside)
                  {
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and the former is not the empty type, and "
                            "the former specifies a non-empty type for element"
                            " %lu, but %lu is outside the key type of the "
                            "later", (unsigned long)element_num,
                            (unsigned long)element_num);
                  }
                else
                  {
                    result = type_in_no_doubt(FALSE, doubt, why_not,
                            the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a map "
                            "type, and the former is not the empty type, and "
                            "the former specifies a type for element %lu which"
                            " is not a subset of the target type of the later "
                            "because %s", (unsigned long)element_num,
                            element_why_not);
                  }
              }
            if (why_not != NULL)
                free(element_why_not);
            return result;
          }
      }

    return TRUE;
  }

static boolean semi_labeled_value_list_is_subset_of_field_info(
        type *semi_labeled_value_list_type, field_type_info *big_field_info,
        boolean *doubt, char **why_not, const source_location *location,
        jumper *the_jumper)
  {
    size_t field_count;
    boolean *field_used;
    size_t element_count;
    size_t element_num;
    size_t field_num;

    assert(semi_labeled_value_list_type != NULL);
    assert(big_field_info != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */

    if ((semi_labeled_value_list_type->u.semi_labeled_value_list.
                 extra_elements_allowed) &&
        (!(big_field_info->extra_fields_allowed)))
      {
        if (possibly_nothing(semi_labeled_value_list_type))
          {
            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type is a semi-labeled value list type "
                    "and the candidate super-type is a type that specifies "
                    "field information, and the former allows unlimited "
                    "additional elements while the later does not allow "
                    "anything beyond the finite number of fields it explicitly"
                    " specifies, and %s is unable to determine whether the "
                    "former is the empty type", interpreter_name());
          }
        else
          {
            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the candidate sub-type is a semi-labeled value list type "
                    "and the candidate super-type is a type that specifies "
                    "field information, and the former allows unlimited "
                    "additional elements while the later does not allow "
                    "anything beyond the finite number of fields it explicitly"
                    " specifies, and the former is not the empty type");
          }
      }

    field_count = big_field_info->field_count;

    if (field_count > 0)
      {
        int field_num;

        field_used = MALLOC_ARRAY(boolean, field_count);
        if (field_used == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }
        for (field_num = 0; field_num < field_count; ++field_num)
            field_used[field_num] = FALSE;
      }
    else
      {
        field_used = NULL;
      }

    *doubt = FALSE;

    element_count = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_count;

    for (element_num = 0; element_num < element_count; ++element_num)
      {
        const char *element_name;
        size_t field_num;
        type *field_type;
        type *element_type;
        boolean element_doubt;
        char *element_why_not;
        boolean element_is_subset;

        element_name = semi_labeled_value_list_type->u.semi_labeled_value_list.
                element_names[element_num];

        if ((element_name == NULL) ||
            (!(exists_in_string_index(big_field_info->allowed_fields,
                                      element_name))))
          {
            if (!(big_field_info->extra_fields_allowed))
              {
                if ((why_not != NULL) && (*doubt))
                    free(*why_not);
                if (field_count > 0)
                    free(field_used);
                if (possibly_nothing(semi_labeled_value_list_type))
                  {
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a type "
                            "that specifies field information, and the former "
                            "specifies %s%s%s, and the later does not allow "
                            "anything beyond the finite number of fields it "
                            "explicitly specifies, and %s is unable to "
                            "determine whether the former is the empty type",
                            ((element_name == NULL) ? "no name for a field" :
                             "a field with name `"),
                            ((element_name == NULL) ? "" : element_name),
                            ((element_name == NULL) ? "" :
                             "', which isn't specified by the later"),
                            interpreter_name());
                  }
                else
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a type "
                            "that specifies field information, and the former "
                            "specifies %s%s%s, and the later does not allow "
                            "anything beyond the finite number of fields it "
                            "explicitly specifies, and the former is not the "
                            "empty type",
                            ((element_name == NULL) ? "no name for a field" :
                             "a field with name `"),
                            ((element_name == NULL) ? "" : element_name),
                            ((element_name == NULL) ? "" :
                             "', which isn't specified by the later"));
                  }
              }

            continue;
          }

        field_num = (size_t)(lookup_in_string_index(
                big_field_info->allowed_fields, element_name));
        assert(field_num < field_count);
        assert(strcmp(element_name, big_field_info->field_names[field_num]) ==
               0);

        field_used[field_num] = TRUE;

        field_type = big_field_info->field_types[field_num];
        assert(type_is_valid(field_type)); /* VERIFIED */

        element_type = semi_labeled_value_list_type->u.semi_labeled_value_list.
                element_types[element_num];

        assert(type_is_valid(element_type)); /* VERIFIED */
        assert(type_is_valid(field_type)); /* VERIFIED */
        element_is_subset = type_is_subset(element_type, field_type,
                &element_doubt, ((why_not == NULL) ? NULL : &element_why_not),
                location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            if (field_count > 0)
                free(field_used);
            return FALSE;
          }
        if (element_doubt)
          {
            if (why_not != NULL)
              {
                if (!(*doubt))
                  {
                    *why_not = allocate_printf(
                            "the candidate sub-type is a semi-labeled value "
                            "list type and the candidate super-type is a type "
                            "that specifies field information, and %s is "
                            "unable to determine whether the type specified "
                            "for a field named `%s' by the former is a subset "
                            "of the type specified for a field of that name by"
                            " the later because %s", interpreter_name(),
                            element_name, element_why_not);
                  }
                free(element_why_not);
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }
        else if (!element_is_subset)
          {
            boolean result;

            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            if (field_count > 0)
                free(field_used);
            if (possibly_nothing(semi_labeled_value_list_type))
              {
                result = type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is a type that "
                        "specifies field information, and %s is unable to "
                        "determine whether the former is the empty type, and "
                        "the type specified for a field named `%s' by the "
                        "former is not a subset of the type specified for a "
                        "field of that name by the later because %s",
                        interpreter_name(), element_name, element_why_not);
              }
            else
              {
                result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is a type that "
                        "specifies field information, and the former is not "
                        "the empty type, and the type specified for a field "
                        "named `%s' by the former is not a subset of the type "
                        "specified for a field of that name by the later "
                        "because %s", element_name, element_why_not);
              }
            if (why_not != NULL)
                free(element_why_not);
            return result;
          }
      }

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        if (field_used[field_num])
            continue;

        if (!(big_field_info->field_can_be_empty[field_num]))
          {
            if ((why_not != NULL) && (*doubt))
                free(*why_not);
            if (field_count > 0)
                free(field_used);
            if (possibly_nothing(semi_labeled_value_list_type))
              {
                return type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is a type that "
                        "specifies field information, and the later specifies "
                        "a field named `%s', and specifies that it is not "
                        "optional, while the former does not specify a field "
                        "by that name, and %s is unable to determine whether "
                        "the former is the empty type",
                        big_field_info->field_names[field_num],
                        interpreter_name());
              }
            else
              {
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type is a semi-labeled value list "
                        "type and the candidate super-type is a type that "
                        "specifies field information, and the later specifies "
                        "a field named `%s', and specifies that it is not "
                        "optional, while the former does not specify a field "
                        "by that name, and the former is not the empty type",
                        big_field_info->field_names[field_num]);
              }
          }
      }

    if (field_count > 0)
        free(field_used);

    return TRUE;
  }

static boolean map_is_subset_of_semi_labeled_value_list(type *map_type,
        type *semi_labeled_value_list_type, boolean *doubt, char **why_not,
        const source_location *location, jumper *the_jumper)
  {
    type *second_key_type;
    boolean key_doubt;
    char *key_why_not;
    boolean key_subset;

    assert(map_type != NULL);
    assert(semi_labeled_value_list_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(map_type)); /* VERIFIED */
    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(map_type->kind == TK_MAP);
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);

    if (semi_labeled_value_list_type->u.semi_labeled_value_list.element_count >
        0)
      {
        return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                "the candidate sub-type is a map type and the candidate "
                "super-type is a semi-labeled value list type that specifies "
                "more than zero elements, so the former includes the empty map"
                " while the later does not");
      }

    if (map_type->u.map.target->kind == TK_NOTHING)
      {
        *doubt = FALSE;
        return TRUE;
      }

    if (!(semi_labeled_value_list_type->u.semi_labeled_value_list.
                  extra_elements_allowed))
      {
        second_key_type = get_nothing_type();
        if (second_key_type == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }
        type_add_reference(second_key_type);
      }
    else
      {
        second_key_type = get_integer_range_type(oi_zero, oi_positive_infinity,
                                                 TRUE, FALSE);
        if (second_key_type == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }
      }

    *doubt = FALSE;

    assert(type_is_valid(map_type)); /* VERIFIED */
    assert(type_is_valid(map_type->u.map.key)); /* VERIFIED */
    assert(type_is_valid(second_key_type)); /* VERIFIED */
    key_subset = type_is_subset(map_type->u.map.key, second_key_type,
            &key_doubt, ((why_not == NULL) ? NULL : &key_why_not), location,
            the_jumper);
    type_remove_reference(second_key_type,
            ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
    if (!(jumper_flowing_forward(the_jumper)))
        return FALSE;
    if ((!key_subset) && (!key_doubt))
      {
        boolean result;

        if (possibly_nothing(map_type->u.map.target))
          {
            result = type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type is a map type and the candidate "
                    "super-type is a semi-labeled value list type, and %s is "
                    "unable to determine whether the former's target type is "
                    "the empty type, and the former's key type is not a subset"
                    " the range of keys allowed by the later because %s",
                    interpreter_name(), key_why_not);
          }
        else
          {
            result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the candidate sub-type is a map type with a non-empty "
                    "target type and the candidate super-type is a "
                    "semi-labeled value list type, and the former's key type "
                    "is not a subset the range of keys allowed by the later "
                    "because %s", key_why_not);
          }
        if (why_not != NULL)
            free(key_why_not);
        return result;
      }
    if (key_doubt)
      {
        if (why_not != NULL)
          {
            *why_not = allocate_printf(
                    "the candidate sub-type is a map type and the candidate "
                    "super-type is a semi-labeled value list type, and %s is "
                    "unable to determine whether the former's key type is a "
                    "subset the range of keys allowed by the later because %s",
                    interpreter_name(), key_why_not);
            free(key_why_not);
            if (*why_not == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
          }
        *doubt = TRUE;
      }

    return TRUE;
  }

static type *map_type_for_array_type(type *array_type)
  {
    type *range_type;
    type *result;

    assert(array_type != NULL);
    assert(array_type->kind == TK_ARRAY);

    assert(type_is_valid(array_type)); /* VERIFIED */

    range_type = get_integer_range_type(array_type->u.array.lower_bound,
            array_type->u.array.upper_bound, TRUE, TRUE);
    if (range_type == NULL)
        return NULL;

    assert(type_is_valid(range_type)); /* VERIFIED */
    assert(type_is_valid(array_type->u.array.base)); /* VERIFIED */
    result = get_map_type(range_type, array_type->u.array.base);
    type_remove_reference(range_type, NULL);
    assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
    return result;
  }

static boolean type_has_finite_enumeration_within_limit(type *the_type,
        size_t maximum_elements, boolean *doubt, size_t *element_count,
        boolean *error)
  {
    assert(the_type != NULL);
    assert(doubt != NULL);
    assert(element_count != NULL);
    assert(error != NULL);

    assert(type_is_valid(the_type)); /* VERIFIED */

    *error = FALSE;

    switch (the_type->kind)
      {
        case TK_ANYTHING:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_NOTHING:
          {
            *doubt = FALSE;
            *element_count = 0;
            return TRUE;
          }
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_ENUMERATION:
          {
            *doubt = FALSE;
            *element_count = the_type->u.enumeration.value_count;
            return (the_type->u.enumeration.value_count <= maximum_elements);
          }
        case TK_NOT:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_INTERSECTION:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_UNION:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_XOR:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_ARRAY:
          {
            boolean base_doubt;
            size_t base_element_count;
            boolean base_fits;
            size_t slot_possibility_count;
            o_integer diff_oi;
            o_integer limit_oi;
            size_t exponent_remainder;
            verdict the_verdict;
            size_t result_count;

            if (maximum_elements == 0)
              {
                *doubt = FALSE;
                return FALSE;
              }

            if (oi_less_than(the_type->u.array.upper_bound,
                             the_type->u.array.lower_bound))
              {
                *doubt = FALSE;
                *element_count = 1;
                return TRUE;
              }

            assert(type_is_valid(the_type->u.array.base)); /* VERIFIED */
            base_fits = type_has_finite_enumeration_within_limit(
                    the_type->u.array.base, maximum_elements - 1, &base_doubt,
                    &base_element_count, error);
            if (*error)
                return FALSE;
            if ((!base_fits) || base_doubt)
              {
                *doubt = base_doubt;
                return FALSE;
              }

            *doubt = FALSE;

            assert(base_element_count < maximum_elements);

            if (base_element_count == 0)
              {
                *element_count = 1;
                return TRUE;
              }

            slot_possibility_count = base_element_count + 1;

            oi_subtract(diff_oi, the_type->u.array.upper_bound,
                        the_type->u.array.lower_bound);
            if (oi_out_of_memory(diff_oi))
              {
                *error = TRUE;
                return FALSE;
              }

            oi_create_from_size_t(limit_oi, maximum_elements);
            if (oi_out_of_memory(limit_oi))
              {
                oi_remove_reference(diff_oi);
                *error = TRUE;
                return FALSE;
              }

            if (oi_less_than(limit_oi, diff_oi))
              {
                oi_remove_reference(limit_oi);
                oi_remove_reference(diff_oi);
                return FALSE;
              }

            oi_remove_reference(limit_oi);

            the_verdict = oi_magnitude_to_size_t(diff_oi, &exponent_remainder);
            oi_remove_reference(diff_oi);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                *error = TRUE;
                return FALSE;
              }

            result_count = slot_possibility_count;
            while (exponent_remainder > 0)
              {
                if (result_count > (maximum_elements / slot_possibility_count))
                    return FALSE;
                result_count *= slot_possibility_count;
                --exponent_remainder;
              }

            assert(result_count <= maximum_elements);
            *element_count = result_count;
            return TRUE;
          }
        case TK_INTEGER_RANGES:
          {
            size_t result_count;
            size_t max_remainder;
            size_t component_count;
            integer_range_component *components;
            size_t component_num;

            *doubt = FALSE;

            result_count = 0;

            if (the_type->u.integer_ranges.includes_positive_infinity)
                ++result_count;
            if (the_type->u.integer_ranges.includes_negative_infinity)
                ++result_count;
            if (the_type->u.integer_ranges.includes_unsigned_infinity)
                ++result_count;
            if (the_type->u.integer_ranges.includes_zero_zero)
                ++result_count;

            if (result_count > maximum_elements)
                return FALSE;

            max_remainder = maximum_elements - result_count;

            component_count = the_type->u.integer_ranges.component_count;
            components = the_type->u.integer_ranges.components;

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                o_integer diff_oi;
                o_integer limit_oi;
                size_t local_result_count;
                verdict the_verdict;

                oi_subtract(diff_oi, components[component_num].upper_bound,
                            components[component_num].lower_bound);
                if (oi_out_of_memory(diff_oi))
                  {
                    *error = TRUE;
                    return FALSE;
                  }

                oi_create_from_size_t(limit_oi, max_remainder);
                if (oi_out_of_memory(limit_oi))
                  {
                    oi_remove_reference(diff_oi);
                    *error = TRUE;
                    return FALSE;
                  }

                if (!(oi_less_than(diff_oi, limit_oi)))
                  {
                    oi_remove_reference(limit_oi);
                    oi_remove_reference(diff_oi);
                    return FALSE;
                  }

                oi_remove_reference(limit_oi);

                the_verdict =
                        oi_magnitude_to_size_t(diff_oi, &local_result_count);
                oi_remove_reference(diff_oi);
                if (the_verdict != MISSION_ACCOMPLISHED)
                  {
                    *error = TRUE;
                    return FALSE;
                  }

                assert(local_result_count < max_remainder);
                result_count += local_result_count + 1;
                max_remainder -= local_result_count + 1;
              }

            *element_count = result_count;
            return TRUE;
          }
        case TK_RATIONAL_RANGES:
          {
            size_t component_count;
            size_t total_count;
            rational_range_component *components;
            size_t component_num;

            *doubt = FALSE;

            component_count = the_type->u.rational_ranges.component_count;
            total_count = component_count;
            if (the_type->u.rational_ranges.includes_positive_infinity)
                ++total_count;
            if (the_type->u.rational_ranges.includes_negative_infinity)
                ++total_count;
            if (the_type->u.rational_ranges.includes_unsigned_infinity)
                ++total_count;
            if (the_type->u.rational_ranges.includes_zero_zero)
                ++total_count;

            if (total_count > maximum_elements)
                return FALSE;

            components = the_type->u.rational_ranges.components;

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                if (!(rationals_are_equal(
                              components[component_num].lower_bound,
                              components[component_num].upper_bound)))
                  {
                    return FALSE;
                  }
                assert(components[component_num].lower_is_inclusive);
                assert(components[component_num].upper_is_inclusive);
              }

            *element_count = total_count;
            return TRUE;
          }
        case TK_POINTER:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_TYPE:
          {
            boolean base_doubt;
            size_t base_element_count;
            boolean base_fits;
            size_t result_count;

            if (maximum_elements == 0)
              {
                *doubt = FALSE;
                return FALSE;
              }

            assert(type_is_valid(the_type->u.type.base)); /* VERIFIED */
            base_fits = type_has_finite_enumeration_within_limit(
                    the_type->u.type.base, maximum_elements, &base_doubt,
                    &base_element_count, error);
            if (*error)
                return FALSE;
            if ((!base_fits) || base_doubt)
              {
                *doubt = base_doubt;
                return FALSE;
              }

            *doubt = FALSE;

            result_count = 1;
            while (base_element_count > 0)
              {
                if (result_count > (maximum_elements / 2))
                    return FALSE;
                result_count *= 2;
                --base_element_count;
              }

            assert(result_count <= maximum_elements);
            *element_count = result_count;
            return TRUE;
          }
        case TK_MAP:
          {
            boolean key_doubt;
            size_t key_element_count;
            boolean key_fits;
            boolean target_doubt;
            size_t target_element_count;
            boolean target_fits;
            size_t slot_possibility_count;
            size_t exponent_remainder;
            size_t result_count;

            if (maximum_elements == 0)
              {
                *doubt = FALSE;
                return FALSE;
              }

            assert(type_is_valid(the_type->u.map.key)); /* VERIFIED */
            key_fits = type_has_finite_enumeration_within_limit(
                    the_type->u.map.key, maximum_elements - 1, &key_doubt,
                    &key_element_count, error);
            if (*error)
                return FALSE;
            if ((!key_fits) || key_doubt)
              {
                *doubt = key_doubt;
                return FALSE;
              }

            if (key_element_count == 0)
              {
                *doubt = FALSE;
                *element_count = 1;
                return TRUE;
              }

            assert(type_is_valid(the_type->u.map.target)); /* VERIFIED */
            target_fits = type_has_finite_enumeration_within_limit(
                    the_type->u.map.target, maximum_elements - 1,
                    &target_doubt, &target_element_count, error);
            if (*error)
                return FALSE;
            if ((!target_fits) || target_doubt)
              {
                *doubt = target_doubt;
                return FALSE;
              }

            *doubt = FALSE;

            assert(target_element_count < maximum_elements);

            if (target_element_count == 0)
              {
                *element_count = 1;
                return TRUE;
              }

            slot_possibility_count = target_element_count + 1;

            exponent_remainder = key_element_count;

            result_count = 1;
            while (exponent_remainder > 0)
              {
                if (result_count > (maximum_elements / slot_possibility_count))
                    return FALSE;
                result_count *= slot_possibility_count;
                --exponent_remainder;
              }

            assert(result_count <= maximum_elements);
            *element_count = result_count;
            return TRUE;
          }
        case TK_ROUTINE:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_FIELDS:
          {
            assert(type_is_valid(the_type)); /* VERIFIED */
            *doubt = possibly_nothing(the_type);
            return FALSE;
          }
        case TK_LEPTON:
          {
            assert(type_is_valid(the_type)); /* VERIFIED */
            return field_info_has_finite_enumeration_within_limit(
                    &(the_type->u.lepton.field_info), maximum_elements, doubt,
                    element_count, error);
          }
        case TK_MULTISET:
          {
            assert(type_is_valid(the_type)); /* VERIFIED */
            return field_info_has_finite_enumeration_within_limit(
                    &(the_type->u.multiset.field_info), maximum_elements,
                    doubt, element_count, error);
          }
        case TK_INTERFACE:
          {
            assert(type_is_valid(the_type)); /* VERIFIED */
            *doubt = possibly_nothing(the_type);
            return FALSE;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            size_t type_element_count;
            size_t element_num;
            size_t result;

            if (maximum_elements == 0)
              {
                *doubt = FALSE;
                return FALSE;
              }

            if (the_type->u.semi_labeled_value_list.extra_elements_allowed)
              {
                *doubt = FALSE;
                return FALSE;
              }

            type_element_count =
                    the_type->u.semi_labeled_value_list.element_count;

            for (element_num = 0; element_num < type_element_count;
                 ++element_num)
              {
                if (the_type->u.semi_labeled_value_list.element_names[
                            element_num] == NULL)
                  {
                    *doubt = FALSE;
                    return FALSE;
                  }
              }

            result = 1;

            for (element_num = 0; element_num < type_element_count;
                 ++element_num)
              {
                type *element_type;
                boolean element_doubt;
                size_t element_element_count;
                boolean element_fits;

                element_type = the_type->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);
                assert(type_is_valid(element_type)); /* VERIFIED */
                element_fits = type_has_finite_enumeration_within_limit(
                        element_type, ((maximum_elements / result) - 1),
                        &element_doubt, &element_element_count, error);
                if (*error)
                    return FALSE;
                if ((!element_fits) || element_doubt)
                  {
                    *doubt = element_doubt;
                    return FALSE;
                  }

                assert(element_element_count <=
                       ((maximum_elements / result) - 1));
                result *= (element_element_count + 1);
              }

            assert(result <= maximum_elements);
            *doubt = FALSE;
            *element_count = result;
            return TRUE;
          }
        case TK_REGULAR_EXPRESSION:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_CLASS:
          {
            *doubt = FALSE;
            return FALSE;
          }
        case TK_TEST_ROUTINE:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_TEST_ROUTINE_CHAIN:
          {
            *doubt = TRUE;
            return FALSE;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return FALSE;
          }
        default:
          {
            assert(FALSE);
            return FALSE;
          }
      }
  }

static value **enumerate(type *the_type, size_t element_count,
        const source_location *location, jumper *the_jumper)
  {
    value **value_array;

    assert(the_type != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(the_type)); /* VERIFIED */

    assert(element_count > 0);

    value_array = MALLOC_ARRAY(value *, element_count);
    if (value_array == NULL)
      {
        jumper_do_abort(the_jumper);
        return NULL;
      }

    switch (the_type->kind)
      {
        case TK_ANYTHING:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_NOTHING:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_INTEGER:
        case TK_RATIONAL:
        case TK_ANY_REGULAR_EXPRESSION:
        case TK_ANY_QUARK:
        case TK_ANY_LEPTON:
        case TK_LEPTON_KEY:
        case TK_JUMP_TARGET:
        case TK_ANY_CLASS:
        case TK_OBJECT:
        case TK_TAGALONG_KEY:
        case TK_LOCK:
        case TK_STRING:
        case TK_CHARACTER:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_ENUMERATION:
          {
            size_t element_num;

            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(the_type->u.enumeration.value_count == element_count);

            for (element_num = 0; element_num < element_count; ++element_num)
              {
                value_array[element_num] =
                        the_type->u.enumeration.values[element_num];
                assert(value_array[element_num] != NULL);
                value_add_reference(value_array[element_num]);
              }

            return value_array;
          }
        case TK_NOT:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_INTERSECTION:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_UNION:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_XOR:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_ARRAY:
          {
            boolean base_doubt;
            size_t base_element_count;
            boolean error;
            boolean base_fits;
            size_t key_count;
            value **base_values;
            size_t *base_by_key;
            size_t key_num;
            size_t result_position;

            if (jumper_thread(the_jumper) == NULL)
              {
                free(value_array);
                return NULL;
              }

            assert(type_is_valid(the_type->u.array.base)); /* VERIFIED */
            base_fits = type_has_finite_enumeration_within_limit(
                    the_type->u.array.base, element_count - 1, &base_doubt,
                    &base_element_count, &error);
            if (error)
              {
                jumper_do_abort(the_jumper);
                free(value_array);
                return NULL;
              }
            assert(base_fits);
            assert(!base_doubt);

            assert(base_element_count < element_count);

            if (oi_less_than(the_type->u.array.upper_bound,
                             the_type->u.array.lower_bound))
              {
                key_count = 0;
              }
            else
              {
                o_integer diff_oi;
                verdict the_verdict;

                oi_subtract(diff_oi, the_type->u.array.upper_bound,
                            the_type->u.array.lower_bound);
                if (oi_out_of_memory(diff_oi))
                  {
                    jumper_do_abort(the_jumper);
                    free(value_array);
                    return NULL;
                  }

                the_verdict = oi_magnitude_to_size_t(diff_oi, &key_count);
                oi_remove_reference(diff_oi);
                if (the_verdict != MISSION_ACCOMPLISHED)
                  {
                    jumper_do_abort(the_jumper);
                    free(value_array);
                    return NULL;
                  }

                ++key_count;
              }

            assert(type_is_valid(the_type->u.array.base)); /* VERIFIED */
            base_values = enumerate(the_type->u.array.base, base_element_count,
                                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(base_values == NULL);
                free(value_array);
                return NULL;
              }
            if (base_values == NULL)
              {
                free(value_array);
                return NULL;
              }
            assert(base_values != NULL);

            base_by_key =
                    MALLOC_ARRAY(size_t, ((key_count == 0) ? 1 : key_count));
            if (base_by_key == NULL)
              {
                jumper_do_abort(the_jumper);
                delete_enumeration(base_values, base_element_count,
                                   the_jumper);
                free(value_array);
                return NULL;
              }

            for (key_num = 0; key_num < key_count; ++key_num)
                base_by_key[key_num] = 0;

            result_position = 0;

            while (TRUE)
              {
                value *new_value;
                size_t key_num;

                new_value = create_map_value();
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                  array_unwind:
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(base_by_key);
                    delete_enumeration(base_values, base_element_count,
                                       the_jumper);
                    free(value_array);
                    return NULL;
                  }
                assert(value_is_valid(new_value)); /* VERIFIED */

                for (key_num = 0; key_num < key_count; ++key_num)
                  {
                    size_t base_num;
                    o_integer index_oi;
                    o_integer key_oi;
                    value *key_value;
                    value *target_value;

                    base_num = base_by_key[key_num];
                    if (base_num == 0)
                        continue;

                    oi_create_from_size_t(index_oi, key_num);
                    if (oi_out_of_memory(index_oi))
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(new_value,
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                        goto array_unwind;
                      }

                    oi_add(key_oi, the_type->u.array.lower_bound, index_oi);
                    oi_remove_reference(index_oi);
                    if (oi_out_of_memory(key_oi))
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(new_value,
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                        goto array_unwind;
                      }

                    key_value = create_integer_value(key_oi);
                    oi_remove_reference(key_oi);
                    if (key_value == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(new_value,
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                        goto array_unwind;
                      }

                    target_value = base_values[base_num - 1];
                    assert(target_value != NULL);
                    assert(value_is_valid(new_value)); /* VERIFIED */
                    assert(map_value_all_keys_are_valid(new_value));
                            /* VERIFIED */
                    assert(value_is_valid(key_value)); /* VERIFIED */
                    assert(value_is_valid(target_value)); /* VERIFIED */
                    new_value = map_value_set(new_value, key_value,
                            target_value, location, the_jumper);
                    value_remove_reference(key_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if (new_value != NULL)
                            value_remove_reference(new_value, the_jumper);
                        goto array_unwind;
                      }
                    assert(new_value != NULL);
                    assert(value_is_valid(new_value)); /* VERIFIED */
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;

                key_num = 0;
                while (TRUE)
                  {
                    if (key_num == key_count)
                        break;

                    if (base_by_key[key_num] == base_element_count)
                      {
                        base_by_key[key_num] = 0;
                      }
                    else
                      {
                        assert(base_by_key[key_num] < base_element_count);
                        ++(base_by_key[key_num]);
                        break;
                      }
                  }
                if (key_num == key_count)
                    break;
              }

            assert(result_position == element_count);
            free(base_by_key);
            delete_enumeration(base_values, base_element_count, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                size_t value_num;

                for (value_num = 0; value_num < element_count; ++value_num)
                    value_remove_reference(value_array[value_num], the_jumper);
                free(value_array);
                return NULL;
              }
            return value_array;
          }
        case TK_INTEGER_RANGES:
          {
            size_t result_position;
            size_t component_count;
            integer_range_component *components;
            size_t component_num;

            result_position = 0;

            if (the_type->u.integer_ranges.includes_negative_infinity)
              {
                value *new_value;

                new_value = create_integer_value(oi_negative_infinity);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            component_count = the_type->u.integer_ranges.component_count;
            components = the_type->u.integer_ranges.components;

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                o_integer current_oi;

                current_oi = components[component_num].lower_bound;
                oi_add_reference(current_oi);

                while (TRUE)
                  {
                    value *new_value;
                    o_integer next_oi;

                    if (oi_less_than(components[component_num].upper_bound,
                                     current_oi))
                      {
                        break;
                      }

                    new_value = create_integer_value(current_oi);
                    if (new_value == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        oi_remove_reference(current_oi);
                        while (result_position > 0)
                          {
                            --result_position;
                            value_remove_reference(
                                    value_array[result_position],
                                    ((jumper_thread(the_jumper) == NULL) ?
                                     NULL : the_jumper));
                          }
                        free(value_array);
                        return NULL;
                      }

                    assert(value_is_valid(new_value)); /* VERIFIED */
                    value_array[result_position] = new_value;
                    assert(value_is_valid(value_array[result_position]));
                            /* VERIFIED */
                    ++result_position;

                    oi_add(next_oi, current_oi, oi_one);
                    oi_remove_reference(current_oi);
                    if (oi_out_of_memory(next_oi))
                      {
                        jumper_do_abort(the_jumper);
                        while (result_position > 0)
                          {
                            --result_position;
                            value_remove_reference(
                                    value_array[result_position],
                                    ((jumper_thread(the_jumper) == NULL) ?
                                     NULL : the_jumper));
                          }
                        free(value_array);
                        return NULL;
                      }
                    current_oi = next_oi;
                  }

                oi_remove_reference(current_oi);
              }

            if (the_type->u.integer_ranges.includes_positive_infinity)
              {
                value *new_value;

                new_value = create_integer_value(oi_positive_infinity);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            if (the_type->u.integer_ranges.includes_unsigned_infinity)
              {
                value *new_value;

                new_value = create_integer_value(oi_unsigned_infinity);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            if (the_type->u.integer_ranges.includes_zero_zero)
              {
                value *new_value;

                new_value = create_integer_value(oi_zero_zero);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            assert(result_position == element_count);
            return value_array;
          }
        case TK_RATIONAL_RANGES:
          {
            size_t result_position;
            size_t component_count;
            rational_range_component *components;
            size_t component_num;

            result_position = 0;

            if (the_type->u.rational_ranges.includes_negative_infinity)
              {
                value *new_value;

                new_value = create_integer_value(oi_negative_infinity);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            component_count = the_type->u.rational_ranges.component_count;
            components = the_type->u.rational_ranges.components;

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                value *new_value;
                rational *the_rational;

                the_rational = components[component_num].lower_bound;
                assert(rationals_are_equal(the_rational,
                        components[component_num].upper_bound));
                assert(components[component_num].lower_is_inclusive);
                assert(components[component_num].upper_is_inclusive);

                if (rational_is_integer(the_rational))
                  {
                    new_value = create_integer_value(
                            rational_numerator(the_rational));
                  }
                else
                  {
                    new_value = create_rational_value(the_rational);
                  }
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            if (the_type->u.rational_ranges.includes_positive_infinity)
              {
                value *new_value;

                new_value = create_integer_value(oi_positive_infinity);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            if (the_type->u.rational_ranges.includes_unsigned_infinity)
              {
                value *new_value;

                new_value = create_integer_value(oi_unsigned_infinity);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            if (the_type->u.rational_ranges.includes_zero_zero)
              {
                value *new_value;

                new_value = create_integer_value(oi_zero_zero);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;
              }

            assert(result_position == element_count);
            return value_array;
          }
        case TK_POINTER:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_TYPE:
          {
            boolean base_doubt;
            size_t base_element_count;
            boolean error;
            boolean base_fits;
            value **base_values;
            boolean *value_included;
            size_t base_num;
            value **values_for_element;
            size_t result_position;

            assert(type_is_valid(the_type->u.type.base)); /* VERIFIED */
            base_fits = type_has_finite_enumeration_within_limit(
                    the_type->u.type.base, element_count, &base_doubt,
                    &base_element_count, &error);
            if (error)
              {
                jumper_do_abort(the_jumper);
                free(value_array);
                return NULL;
              }
            assert(base_fits);
            assert(!base_doubt);

            assert(type_is_valid(the_type->u.type.base)); /* VERIFIED */
            base_values = enumerate(the_type->u.type.base, base_element_count,
                                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(base_values == NULL);
                free(value_array);
                return NULL;
              }
            if (base_values == NULL)
              {
                free(value_array);
                return NULL;
              }
            assert(base_values != NULL);

            value_included = MALLOC_ARRAY(boolean,
                    ((base_element_count == 0) ? 1 : base_element_count));
            if (value_included == NULL)
              {
                jumper_do_abort(the_jumper);
                delete_enumeration(base_values, base_element_count,
                                   the_jumper);
                free(value_array);
                return NULL;
              }

            for (base_num = 0; base_num < base_element_count; ++base_num)
                value_included[base_num] = FALSE;

            values_for_element = MALLOC_ARRAY(value *,
                    ((base_element_count == 0) ? 1 : base_element_count));
            if (values_for_element == NULL)
              {
                jumper_do_abort(the_jumper);
                free(value_included);
                delete_enumeration(base_values, base_element_count,
                                   the_jumper);
                free(value_array);
                return NULL;
              }

            result_position = 0;

            while (TRUE)
              {
                size_t element_value_count;
                size_t base_num;
                type *new_type;
                value *new_value;

                element_value_count = 0;

                for (base_num = 0; base_num < base_element_count; ++base_num)
                  {
                    if (!(value_included[base_num]))
                        continue;

                    assert(element_value_count < base_element_count);
                    assert(value_is_valid(base_values[base_num]));
                            /* VERIFIED */
                    values_for_element[element_value_count] =
                            base_values[base_num];
                    assert(value_is_valid(
                                   values_for_element[element_value_count]));
                            /* VERIFIED */
                    ++element_value_count;
                  }

                new_type = get_enumeration_type(element_value_count,
                                                values_for_element);
                assert((new_type == NULL) || type_is_valid(new_type));
                        /* VERIFIED */
                if (new_type == NULL)
                  {
                    jumper_do_abort(the_jumper);
                  type_unwind:
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(values_for_element);
                    free(value_included);
                    delete_enumeration(base_values, base_element_count,
                                       the_jumper);
                    free(value_array);
                    return NULL;
                  }

                assert(type_is_valid(new_type)); /* VERIFIED */
                new_value = create_type_value(new_type);
                if (new_value == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    type_remove_reference(new_type,
                            ((jumper_thread(the_jumper) == NULL) ? NULL :
                             the_jumper));
                    goto type_unwind;
                  }
                assert(value_is_valid(new_value)); /* VERIFIED */

                type_remove_reference(new_type,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                         the_jumper));
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    value_remove_reference(new_value,
                            ((jumper_thread(the_jumper) == NULL) ? NULL :
                             the_jumper));
                    goto type_unwind;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;

                base_num = 0;
                while (TRUE)
                  {
                    if (base_num == base_element_count)
                        break;

                    if (value_included[base_num])
                      {
                        value_included[base_num] = FALSE;
                      }
                    else
                      {
                        value_included[base_num] = TRUE;
                        break;
                      }
                  }
                if (base_num == base_element_count)
                    break;
              }

            assert(result_position == element_count);
            free(values_for_element);
            free(value_included);
            delete_enumeration(base_values, base_element_count, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                size_t value_num;

                for (value_num = 0; value_num < element_count; ++value_num)
                  {
                    value_remove_reference(value_array[value_num],
                            ((jumper_thread(the_jumper) == NULL) ? NULL :
                             the_jumper));
                  }
                free(value_array);
                return NULL;
              }
            return value_array;
          }
        case TK_MAP:
          {
            boolean key_doubt;
            size_t key_element_count;
            boolean error;
            boolean key_fits;
            boolean target_doubt;
            size_t target_element_count;
            boolean target_fits;
            value **key_values;
            value **target_values;
            size_t *target_by_key;
            size_t key_num;
            size_t result_position;

            if (jumper_thread(the_jumper) == NULL)
              {
                free(value_array);
                return NULL;
              }

            assert(type_is_valid(the_type->u.map.key)); /* VERIFIED */
            key_fits = type_has_finite_enumeration_within_limit(
                    the_type->u.map.key, element_count - 1, &key_doubt,
                    &key_element_count, &error);
            if (error)
              {
                jumper_do_abort(the_jumper);
                free(value_array);
                return NULL;
              }
            assert(key_fits);
            assert(!key_doubt);

            assert(key_element_count < element_count);

            assert(type_is_valid(the_type->u.map.target)); /* VERIFIED */
            target_fits = type_has_finite_enumeration_within_limit(
                    the_type->u.map.target, element_count - 1, &target_doubt,
                    &target_element_count, &error);
            if (error)
              {
                jumper_do_abort(the_jumper);
                free(value_array);
                return NULL;
              }
            assert(target_fits);
            assert(!target_doubt);

            assert(target_element_count < element_count);

            assert(type_is_valid(the_type->u.map.key)); /* VERIFIED */
            key_values = enumerate(the_type->u.map.key, key_element_count,
                                   location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(key_values == NULL);
                free(value_array);
                return NULL;
              }
            if (key_values == NULL)
              {
                free(value_array);
                return NULL;
              }
            assert(key_values != NULL);

            assert(type_is_valid(the_type->u.map.target)); /* VERIFIED */
            target_values = enumerate(the_type->u.map.target,
                    target_element_count, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                assert(target_values == NULL);
                delete_enumeration(key_values, key_element_count, the_jumper);
                free(value_array);
                return NULL;
              }
            if (target_values == NULL)
              {
                delete_enumeration(key_values, key_element_count, the_jumper);
                free(value_array);
                return NULL;
              }
            assert(target_values != NULL);

            target_by_key = MALLOC_ARRAY(size_t,
                    ((key_element_count == 0) ? 1 : key_element_count));
            if (target_by_key == NULL)
              {
                jumper_do_abort(the_jumper);
                delete_enumeration(target_values, target_element_count,
                                   the_jumper);
                delete_enumeration(key_values, key_element_count, the_jumper);
                free(value_array);
                return NULL;
              }

            for (key_num = 0; key_num < key_element_count; ++key_num)
                target_by_key[key_num] = 0;

            result_position = 0;

            while (TRUE)
              {
                value *new_value;
                size_t key_num;

                new_value = create_map_value();
                if (new_value == NULL)
                  {
                  map_unwind:
                    jumper_do_abort(the_jumper);
                    while (result_position > 0)
                      {
                        --result_position;
                        value_remove_reference(value_array[result_position],
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    free(target_by_key);
                    delete_enumeration(target_values, target_element_count,
                                       the_jumper);
                    delete_enumeration(key_values, key_element_count,
                                       the_jumper);
                    free(value_array);
                    return NULL;
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */

                for (key_num = 0; key_num < key_element_count; ++key_num)
                  {
                    size_t target_num;
                    value *new_key;
                    value *new_target;

                    target_num = target_by_key[key_num];
                    if (target_num == 0)
                        continue;

                    new_key = key_values[key_num];
                    assert(new_key != NULL);
                    assert(value_is_valid(new_key)); /* VERIFIED */

                    new_target = target_values[target_num - 1];
                    assert(new_target != NULL);
                    assert(value_is_valid(new_target)); /* VERIFIED */

                    assert(value_is_valid(new_value)); /* VERIFIED */
                    assert(map_value_all_keys_are_valid(new_value));
                            /* VERIFIED */
                    new_value = map_value_set(new_value, new_key, new_target,
                                              location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if (new_value != NULL)
                            value_remove_reference(new_value, the_jumper);
                        goto map_unwind;
                      }
                    assert(new_value != NULL);
                    assert(value_is_valid(new_value)); /* VERIFIED */
                  }

                assert(value_is_valid(new_value)); /* VERIFIED */
                value_array[result_position] = new_value;
                assert(value_is_valid(value_array[result_position]));
                        /* VERIFIED */
                ++result_position;

                key_num = 0;
                while (TRUE)
                  {
                    if (key_num == key_element_count)
                        break;

                    if (target_by_key[key_num] == target_element_count)
                      {
                        target_by_key[key_num] = 0;
                      }
                    else
                      {
                        assert(target_by_key[key_num] < target_element_count);
                        ++(target_by_key[key_num]);
                        break;
                      }
                  }
                if (key_num == key_element_count)
                    break;
              }

            assert(result_position == element_count);
            free(target_by_key);
            delete_enumeration(target_values, target_element_count,
                               the_jumper);
            delete_enumeration(key_values, key_element_count, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                size_t value_num;

                for (value_num = 0; value_num < element_count; ++value_num)
                    value_remove_reference(value_array[value_num], the_jumper);
                free(value_array);
                return NULL;
              }
            return value_array;
          }
        case TK_ROUTINE:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_FIELDS:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_LEPTON:
          {
            field_type_info *field_info;

            field_info = &(the_type->u.lepton.field_info);

            assert(!(field_info->extra_fields_allowed));

            assert(type_is_valid(the_type)); /* VERIFIED */
            assert(lepton_key_instance_is_instantiated(
                           the_type->u.lepton.key)); /* VERIFIED */
            assert(!(lepton_key_instance_scope_exited(
                             the_type->u.lepton.key))); /* VERIFIED */
            convert_components_to_enumeration(field_info->field_count,
                    field_info->field_types, field_info->field_names,
                    &lepton_value_builder, the_type->u.lepton.key,
                    element_count, value_array, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                free(value_array);
                return NULL;
              }

            return value_array;
          }
        case TK_MULTISET:
          {
            field_type_info *field_info;

            field_info = &(the_type->u.multiset.field_info);

            assert(!(field_info->extra_fields_allowed));

            assert(type_is_valid(the_type)); /* VERIFIED */
            convert_components_to_enumeration(field_info->field_count,
                    field_info->field_types, field_info->field_names,
                    &multiset_value_builder, NULL, element_count, value_array,
                    location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                free(value_array);
                return NULL;
              }

            return value_array;
          }
        case TK_INTERFACE:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_SEMI_LABELED_VALUE_LIST:
          {
            assert(!(the_type->u.semi_labeled_value_list.
                             extra_elements_allowed));

            assert(type_is_valid(the_type)); /* VERIFIED */
            convert_components_to_enumeration(
                    the_type->u.semi_labeled_value_list.element_count,
                    the_type->u.semi_labeled_value_list.element_types,
                    the_type->u.semi_labeled_value_list.element_names,
                    &semi_labeled_value_list_value_builder, NULL,
                    element_count, value_array, location, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                free(value_array);
                return NULL;
              }

            return value_array;
          }
        case TK_REGULAR_EXPRESSION:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_CLASS:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_TEST_ROUTINE:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_TEST_ROUTINE_CHAIN:
          {
            assert(FALSE);
            return NULL;
          }
        case TK_SEPARATOR:
          {
            assert(FALSE);
            return NULL;
          }
        default:
          {
            assert(FALSE);
            return NULL;
          }
      }
  }

static void convert_components_to_enumeration(size_t field_count,
        type **field_types, char **field_names,
        value *(*value_builder)(void *data), void *data, size_t element_count,
        value **value_array, const source_location *location,
        jumper *the_jumper)
  {
    size_t *value_num_by_field_num;
    size_t *field_value_counts;
    value ***field_enumerations;
    size_t field_num;
    size_t result_position;

    assert((field_count == 0) || (field_types != NULL));
    assert((field_count == 0) || (field_names != NULL));
    assert(value_builder != NULL);
    assert(value_array != NULL);
    assert(the_jumper != NULL);

    value_num_by_field_num =
            MALLOC_ARRAY(size_t, ((field_count == 0) ? 1 : field_count));
    if (value_num_by_field_num == NULL)
      {
        jumper_do_abort(the_jumper);
        return;
      }

    field_value_counts =
            MALLOC_ARRAY(size_t, ((field_count == 0) ? 1 : field_count));
    if (field_value_counts == NULL)
      {
        jumper_do_abort(the_jumper);
        free(value_num_by_field_num);
        return;
      }

    field_enumerations =
            MALLOC_ARRAY(value **, ((field_count == 0) ? 1 : field_count));
    if (field_enumerations == NULL)
      {
        jumper_do_abort(the_jumper);
        free(field_value_counts);
        free(value_num_by_field_num);
        return;
      }

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        boolean field_doubt;
        size_t field_element_count;
        boolean error;
        boolean field_fits;
        value **field_values;

        value_num_by_field_num[field_num] = 0;

        assert(type_is_valid(field_types[field_num])); /* VERIFIED */
        field_fits = type_has_finite_enumeration_within_limit(
                field_types[field_num], element_count - 1, &field_doubt,
                &field_element_count, &error);
        if (error)
          {
            jumper_do_abort(the_jumper);
            while (field_num > 0)
              {
                --field_num;
                delete_enumeration(field_enumerations[field_num],
                                   field_value_counts[field_num], the_jumper);
              }
            free(field_enumerations);
            free(field_value_counts);
            free(value_num_by_field_num);
            return;
          }
        assert(field_fits);
        assert(!field_doubt);

        assert(field_element_count < element_count);

        field_value_counts[field_num] = field_element_count;

        assert(type_is_valid(field_types[field_num])); /* VERIFIED */
        field_values = enumerate(field_types[field_num], field_element_count,
                                 location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            assert(field_values == NULL);
            while (field_num > 0)
              {
                --field_num;
                delete_enumeration(field_enumerations[field_num],
                                   field_value_counts[field_num], the_jumper);
              }
            free(field_enumerations);
            free(field_value_counts);
            free(value_num_by_field_num);
            return;
          }
        if (field_values == NULL)
          {
            while (field_num > 0)
              {
                --field_num;
                delete_enumeration(field_enumerations[field_num],
                                   field_value_counts[field_num], the_jumper);
              }
            free(field_enumerations);
            free(field_value_counts);
            free(value_num_by_field_num);
            free(*value_array);
            *value_array = NULL;
            return;
          }

        field_enumerations[field_num] = field_values;
      }

    result_position = 0;

    while (TRUE)
      {
        value *new_value;
        size_t field_num;

        new_value = (*value_builder)(data);
        if (new_value == NULL)
          {
            jumper_do_abort(the_jumper);
            goto unwind;
          }
        assert(value_is_valid(new_value)); /* VERIFIED */

        for (field_num = 0; field_num < field_count; ++field_num)
          {
            size_t field_element_num;
            value *field_value;
            verdict the_verdict;

            field_element_num = value_num_by_field_num[field_num];
            if (field_element_num == 0)
                continue;

            field_value = field_enumerations[field_num][field_element_num - 1];
            assert(value_is_valid(new_value)); /* VERIFIED */
            assert(value_is_valid(field_value)); /* VERIFIED */
            the_verdict =
                    add_field(new_value, field_names[field_num], field_value);
            if (the_verdict != MISSION_ACCOMPLISHED)
              {
                jumper_do_abort(the_jumper);
                value_remove_reference(new_value,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                                                               the_jumper));
                goto unwind;
              }
            assert(value_is_valid(new_value)); /* VERIFIED */
          }

        assert(value_is_valid(new_value)); /* VERIFIED */
        value_array[result_position] = new_value;
        assert(value_is_valid(value_array[result_position])); /* VERIFIED */
        ++result_position;

        field_num = 0;
        while (TRUE)
          {
            if (field_num == field_count)
                break;

            if (value_num_by_field_num[field_num] ==
                field_value_counts[field_num])
              {
                value_num_by_field_num[field_num] = 0;
              }
            else
              {
                assert(value_num_by_field_num[field_num] <
                       field_value_counts[field_num]);
                ++(value_num_by_field_num[field_num]);
                break;
              }
          }
        if (field_num == field_count)
            break;
      }

    assert(result_position == element_count);

  unwind:
    for (field_num = 0; field_num < field_count; ++field_num)
      {
        delete_enumeration(field_enumerations[field_num],
                           field_value_counts[field_num], the_jumper);
      }
    free(field_enumerations);
    free(field_value_counts);
    free(value_num_by_field_num);
    if (!(jumper_flowing_forward(the_jumper)))
      {
        while (result_position > 0)
          {
            --result_position;
            value_remove_reference(value_array[result_position],
                    ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
          }
      }
  }

static void delete_enumeration(value **values, size_t count,
                               jumper *the_jumper)
  {
    size_t num;

    assert(values != NULL);
    assert(count > 0);

    for (num = 0; num < count; ++num)
      {
        assert(values[num] != NULL);
        value_remove_reference(values[num],
                ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
      }

    free(values);
  }

static value *lepton_value_builder(void *data)
  {
    lepton_key_instance *key;

    assert(data != NULL);

    key = (lepton_key_instance *)data;

    assert(lepton_key_instance_is_instantiated(key)); /* VERIFIED */
    assert(!(lepton_key_instance_scope_exited(key))); /* VERIFIED */
    return create_lepton_value(key);
  }

static value *multiset_value_builder(void *data)
  {
    assert(data == NULL);

    return create_semi_labeled_multi_set_value();
  }

static value *semi_labeled_value_list_value_builder(void *data)
  {
    assert(data == NULL);

    return create_semi_labeled_value_list_value();
  }

static boolean unordered_named_field_rules_are_subset(
        field_type_info *small_field_info, field_type_info *big_field_info,
        boolean *doubt, char **why_not, boolean small_possibly_nothing,
        const source_location *location, jumper *the_jumper)
  {
    size_t small_field_count;
    type **small_field_types;
    char **small_field_names;
    boolean *small_field_can_be_empty;
    boolean small_extra_fields_allowed;
    size_t big_field_count;
    type **big_field_types;
    char **big_field_names;
    boolean *big_field_can_be_empty;
    boolean big_extra_fields_allowed;
    size_t small_field_num;
    size_t big_field_num;

    assert(small_field_info != NULL);
    assert(big_field_info != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    small_field_count = small_field_info->field_count;
    small_field_types = small_field_info->field_types;
    small_field_names = small_field_info->field_names;
    small_field_can_be_empty = small_field_info->field_can_be_empty;
    small_extra_fields_allowed = small_field_info->extra_fields_allowed;
    big_field_count = big_field_info->field_count;
    big_field_types = big_field_info->field_types;
    big_field_names = big_field_info->field_names;
    big_field_can_be_empty = big_field_info->field_can_be_empty;
    big_extra_fields_allowed = big_field_info->extra_fields_allowed;

    assert((small_field_count == 0) || (small_field_types != NULL));
    assert((small_field_count == 0) || (small_field_names != NULL));
    assert((big_field_count == 0) || (big_field_types != NULL));
    assert((big_field_count == 0) || (big_field_names != NULL));

    if (small_extra_fields_allowed && !big_extra_fields_allowed)
      {
        if (small_possibly_nothing)
          {
            return type_in_doubt(doubt, why_not, the_jumper,
                    "the candidate sub-type and the candidate super-type are "
                    "both types with fields and the former allows additional "
                    "fields beyond those explicitly specified while the later "
                    "does not and %s is unable to determine whether the former"
                    " might be the empty type", interpreter_name());
          }
        else
          {
            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the candidate sub-type and the candidate super-type are "
                    "both types with fields and the former allows additional "
                    "fields beyond those explicitly specified while the later "
                    "does not and the former is not the empty type");
          }
      }

    *doubt = FALSE;

    small_field_num = 0;
    big_field_num = 0;
    while (TRUE)
      {
        type *small_field_type;
        const char *small_name;
        type *big_field_type;
        const char *big_name;
        boolean field_doubt;
        char *field_why_not;
        boolean field_subset;

        if (small_field_num >= small_field_count)
          {
            if (big_field_num >= big_field_count)
                break;
            small_field_type = NULL;
            small_name = NULL;
          }
        else
          {
            small_field_type = small_field_types[small_field_num];
            assert(small_field_type != NULL);
            assert(type_is_valid(small_field_type)); /* VERIFIED */
            small_name = small_field_names[small_field_num];
            assert(small_name != NULL);
          }

        if (big_field_num >= big_field_count)
          {
            assert(small_field_num < small_field_count);
            big_field_type = NULL;
            big_name = NULL;
          }
        else
          {
            big_field_type = big_field_types[big_field_num];
            assert(big_field_type != NULL);
            assert(type_is_valid(big_field_type)); /* VERIFIED */
            big_name = big_field_names[big_field_num];
            assert(big_name != NULL);
          }

        if (small_name == NULL)
          {
            ++big_field_num;
          }
        else if (big_name == NULL)
          {
            ++small_field_num;
          }
        else
          {
            int name_order;

            name_order = utf8_string_lexicographical_order_by_code_point(
                    small_name, big_name);
            if (name_order == -2)
              {
                jumper_do_abort(the_jumper);
                if ((*doubt) && (why_not != NULL))
                    free(*why_not);
                return FALSE;
              }
            else if (name_order < 0)
              {
                ++small_field_num;
                big_field_type = NULL;
              }
            else if (name_order > 0)
              {
                ++big_field_num;
                small_field_type = NULL;
              }
            else
              {
                ++small_field_num;
                ++big_field_num;
              }
          }

        if ((small_field_type != NULL) && (big_field_type != NULL))
          {
            assert(small_field_num > 0);
            assert(big_field_num > 0);
            assert(small_name != NULL);
            assert(big_name != NULL);
            assert(strcmp(small_name, big_name) == 0);
            if (small_field_can_be_empty[small_field_num - 1] &&
                (!(big_field_can_be_empty[big_field_num - 1])))
              {
                if ((*doubt) && (why_not != NULL))
                    free(*why_not);
                if (small_possibly_nothing)
                  {
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both types with fields and the "
                            "former allows field `%s' to be empty while the "
                            "later does not and %s is unable to determine "
                            "whether the former might be the empty type",
                            small_name, interpreter_name());
                  }
                else
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both types with fields and the "
                            "former allows field `%s' to be empty while the "
                            "later does not and the former is not the empty "
                            "type", small_name);
                  }
              }
          }

        if (small_field_type == NULL)
          {
            assert(big_field_type != NULL);
            assert(big_field_num > 0);
            assert(big_name != NULL);
            if (!big_field_can_be_empty[big_field_num - 1])
              {
                if ((*doubt) && (why_not != NULL))
                    free(*why_not);
                if (small_possibly_nothing)
                  {
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both types with fields and the "
                            "former doesn't specify field `%s' while the later"
                            " requires such a field and %s is unable to "
                            "determine whether the former might be the empty "
                            "type", big_name, interpreter_name());
                  }
                else
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both types with fields and the "
                            "former doesn't specify field `%s' while the later"
                            " requires such a field and the former is not the "
                            "empty type", big_name);
                  }
              }
            if (!small_extra_fields_allowed)
                continue;
            small_field_type = get_anything_type();
            if (small_field_type == NULL)
              {
                jumper_do_abort(the_jumper);
                if ((*doubt) && (why_not != NULL))
                    free(*why_not);
                return FALSE;
              }
            assert(type_is_valid(small_field_type)); /* VERIFIED */
            small_name = big_name;
            assert(small_name != NULL);
          }
        if (big_field_type == NULL)
          {
            assert(small_field_type != NULL);
            assert(small_name != NULL);
            if (!big_extra_fields_allowed)
              {
                if (small_field_type->kind == TK_NOTHING)
                    continue;
                assert(type_is_valid(small_field_type)); /* VERIFIED */
                if (possibly_nothing(small_field_type))
                  {
                    if ((!(*doubt)) && (why_not != NULL))
                      {
                        *why_not = allocate_printf(
                                "the candidate sub-type and the candidate "
                                "super-type are both types with fields and the"
                                " former specifies field `%s' while the later "
                                "doesn't specify a field by that name and "
                                "doesn't allow additional fields, and %s is "
                                "unable to determine whether the former's type"
                                " for this field might be the empty type",
                                small_name, interpreter_name());
                        if (*why_not == NULL)
                          {
                            jumper_do_abort(the_jumper);
                            return FALSE;
                          }
                      }
                    *doubt = TRUE;
                    continue;
                  }
                if ((*doubt) && (why_not != NULL))
                    free(*why_not);
                if (small_possibly_nothing)
                  {
                    return type_in_doubt(doubt, why_not, the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both types with fields, %s is "
                            "unable to determine whether the former is the "
                            "empty type, and the former specifies field `%s' "
                            "while the later doesn't specify a field by that "
                            "name and doesn't allow additional fields, and the"
                            " former's type for this field is not the empty "
                            "type", interpreter_name(), small_name);
                  }
                else
                  {
                    return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                            "the candidate sub-type and the candidate "
                            "super-type are both types with fields, the former"
                            " is not the empty type, and the former specifies "
                            "field `%s' while the later doesn't specify a "
                            "field by that name and doesn't allow additional "
                            "fields, and the former's type for this field is "
                            "not the empty type", small_name);
                  }
              }
            big_field_type = get_anything_type();
            if (big_field_type == NULL)
              {
                jumper_do_abort(the_jumper);
                if ((*doubt) && (why_not != NULL))
                    free(*why_not);
                return FALSE;
              }
            assert(type_is_valid(big_field_type)); /* VERIFIED */
            big_name = small_name;
            assert(big_name != NULL);
          }

        assert(small_name != NULL);
        assert(big_name != NULL);
        assert(strcmp(small_name, big_name) == 0);

        assert(type_is_valid(small_field_type)); /* VERIFIED */
        assert(type_is_valid(big_field_type)); /* VERIFIED */
        field_subset = type_is_subset(small_field_type, big_field_type,
                &field_doubt, ((why_not == NULL) ? NULL : &field_why_not),
                location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            if ((*doubt) && (why_not != NULL))
                free(*why_not);
            return FALSE;
          }
        if ((!field_doubt) && !field_subset)
          {
            boolean result;

            if ((*doubt) && (why_not != NULL))
                free(*why_not);
            if (small_possibly_nothing)
              {
                result = type_in_doubt(doubt, why_not, the_jumper,
                        "the candidate sub-type and the candidate super-type "
                        "are both types with fields, %s cannot determine "
                        "whether the former might be the empty type, and the "
                        "type allowed by the former for field `%s' is not a "
                        "subset of the type allowed by the later for that "
                        "field because %s", interpreter_name(), small_name,
                        field_why_not);
              }
            else
              {
                result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the candidate sub-type and the candidate super-type "
                        "are both types with fields, the former is not the "
                        "empty type, and the type allowed by the former for "
                        "field `%s' is not a subset of the type allowed by the"
                        " later for that field because %s", small_name,
                        field_why_not);
              }
            if (why_not != NULL)
                free(field_why_not);
            return result;
          }
        if (field_doubt)
          {
            if (why_not != NULL)
              {
                if (!(*doubt))
                  {
                    *why_not = allocate_printf(
                            "the candidate sub-type and the candidate "
                            "super-type are both types with fields and %s is "
                            "unable to determine whether the type allowed by "
                            "the former for field `%s' is a subset of the type"
                            " allowed by the later for that field because %s",
                            interpreter_name(), small_name, field_why_not);
                  }
                free(field_why_not);
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }
      }

    return TRUE;
  }

static verdict initialize_field_info(field_type_info *field_info,
        size_t field_count, type **field_types, const char **field_names,
        boolean extra_fields_allowed, boolean fields_can_be_empty,
        boolean *item_writing_alloweds_in, boolean **item_writing_alloweds_out,
        reference_cluster **cluster)
  {
    reference_cluster *local_cluster;

    assert(field_info != NULL);
    assert((field_count == 0) || (field_types != NULL));
    assert((field_count == 0) || (field_names != NULL));

    if (cluster != NULL)
        local_cluster = *cluster;
    else
        local_cluster = NULL;

    field_info->field_count = field_count;
    field_info->extra_fields_allowed = extra_fields_allowed;

    field_info->slippery = FALSE;

    if (field_count == 0)
      {
        field_info->field_types = NULL;
        field_info->field_names = NULL;
        field_info->field_can_be_empty = NULL;
        if (item_writing_alloweds_out != NULL)
            (*item_writing_alloweds_out) = NULL;
      }
    else
      {
        size_t_and_string *order_array;
        size_t field_num;

        assert(field_types != NULL);
        assert(field_names != NULL);

        order_array = MALLOC_ARRAY(size_t_and_string, field_count);
        if (order_array == NULL)
            return MISSION_FAILED;

        for (field_num = 0; field_num < field_count; ++field_num)
          {
            order_array[field_num].string = field_names[field_num];
            order_array[field_num].the_size_t = field_num;
          }

        qsort(order_array, field_count, sizeof(size_t_and_string),
              &compare_size_t_and_string);

        field_info->field_types = MALLOC_ARRAY(type *, field_count);
        if (field_info->field_types == NULL)
          {
            free(order_array);
            return MISSION_FAILED;
          }

        field_info->field_names = MALLOC_ARRAY(char *, field_count);
        if (field_info->field_names == NULL)
          {
            free(field_info->field_types);
            free(order_array);
            return MISSION_FAILED;
          }
        field_info->field_can_be_empty = MALLOC_ARRAY(boolean, field_count);
        if (field_info->field_can_be_empty == NULL)
          {
            free(field_info->field_names);
            free(field_info->field_types);
            free(order_array);
            return MISSION_FAILED;
          }

        if (item_writing_alloweds_out != NULL)
          {
            (*item_writing_alloweds_out) = MALLOC_ARRAY(boolean, field_count);
            if ((*item_writing_alloweds_out) == NULL)
              {
                free(field_info->field_can_be_empty);
                free(field_info->field_names);
                free(field_info->field_types);
                free(order_array);
                return MISSION_FAILED;
              }
          }

        for (field_num = 0; field_num < field_count; ++field_num)
          {
            size_t element_num;
            char *name_copy;

            element_num = order_array[field_num].the_size_t;

            if ((cluster != NULL) && (local_cluster == NULL))
                local_cluster = field_types[element_num]->reference_cluster;

            assert(type_is_valid(field_types[element_num]));
                    /* VERIFICATION NEEDED */
            type_add_reference_with_reference_cluster(field_types[element_num],
                                                      local_cluster);
            field_info->field_types[field_num] = field_types[element_num];

            if ((!(field_info->slippery)) &&
                (type_is_slippery(field_types[element_num])))
              {
                field_info->slippery = TRUE;
              }

            if (field_names[element_num] == NULL)
              {
                name_copy = NULL;
              }
            else
              {
                name_copy = MALLOC_ARRAY(char,
                                         strlen(field_names[element_num]) + 1);
                if (name_copy == NULL)
                  {
                    type_remove_reference_with_reference_cluster(
                            field_types[element_num], NULL, local_cluster);

                    while (field_num > 0)
                      {
                        --field_num;
                        type_remove_reference_with_reference_cluster(
                                field_info->field_types[field_num], NULL,
                                local_cluster);
                        if (field_info->field_names[field_num] != NULL)
                            free(field_info->field_names[field_num]);
                      }

                    if (item_writing_alloweds_out != NULL)
                        free((*item_writing_alloweds_out));
                    free(field_info->field_can_be_empty);
                    free(field_info->field_names);
                    free(field_info->field_types);

                    free(order_array);

                    return MISSION_FAILED;
                  }
                strcpy(name_copy, field_names[element_num]);
              }

            field_info->field_names[field_num] = name_copy;

            field_info->field_can_be_empty[field_num] = fields_can_be_empty;

            if (item_writing_alloweds_out != NULL)
              {
                (*item_writing_alloweds_out)[field_num] =
                        item_writing_alloweds_in[element_num];
              }
          }

        free(order_array);
      }

    field_info->allowed_fields =
            make_allowed_fields_index(field_count, field_info->field_names);
    if (field_info->allowed_fields == NULL)
      {
        size_t field_num;

        field_num = field_count;

        while (field_num > 0)
          {
            --field_num;
            type_remove_reference_with_reference_cluster(
                    field_info->field_types[field_num], NULL, local_cluster);
            if (field_info->field_names[field_num] != NULL)
                free(field_info->field_names[field_num]);
          }

        if (item_writing_alloweds_out != NULL)
            free((*item_writing_alloweds_out));
        free(field_info->field_can_be_empty);
        free(field_info->field_names);
        free(field_info->field_types);

        return MISSION_FAILED;
      }

    if (cluster != NULL)
      {
        *cluster = local_cluster;
        if (local_cluster != NULL)
            reference_cluster_add_reference(local_cluster);
      }

    return MISSION_ACCOMPLISHED;
  }

static void deallocate_field_info(field_type_info *field_info,
        jumper *the_jumper, reference_cluster *cluster)
  {
    size_t field_count;
    size_t field_num;

    assert(field_info != NULL);

    field_count = field_info->field_count;

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        type_remove_reference_with_reference_cluster(
                field_info->field_types[field_num], the_jumper, cluster);
        if (field_info->field_names[field_num] != NULL)
            free(field_info->field_names[field_num]);
      }

    if (field_count > 0)
      {
        free(field_info->field_types);
        free(field_info->field_names);
        free(field_info->field_can_be_empty);
      }

    if (field_info->allowed_fields != NULL)
        destroy_string_index(field_info->allowed_fields);
  }

static boolean value_fits_field_info(value *the_value,
        field_type_info *field_info, boolean *doubt, char **why_not,
        const source_location *location, jumper *the_jumper)
  {
    size_t field_count;
    size_t field_num;
    const char *bad_field_name;

    assert(the_value != NULL);
    assert(field_info != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(value_is_valid(the_value)); /* VERIFIED */

    *doubt = FALSE;

    field_count = field_info->field_count;

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        const char *field_name;
        type *field_type;
        value *field_value;
        boolean local_doubt;
        char *local_why_not;
        boolean ok;

        field_name = field_info->field_names[field_num];
        field_type = field_info->field_types[field_num];

        assert(field_type != NULL);
        assert(type_is_valid(field_type)); /* VERIFIED */

        if (get_value_kind(the_value) != VK_OBJECT)
          {
            assert(value_is_valid(the_value)); /* VERIFIED */
            field_value = value_get_field(field_name, the_value);
            assert((field_value == NULL) || value_is_valid(field_value));
                    /* VERIFIED */
          }
        else
          {
            object *the_object;
            size_t object_field_num;

            assert(value_is_valid(the_value)); /* VERIFIED */
            the_object = object_value_data(the_value);
            assert(the_object != NULL);
            assert(!(object_is_closed(the_object))); /* VERIFIED */

            object_field_num = object_field_lookup(the_object, field_name);
            if (object_field_num >= object_field_count(the_object))
              {
                field_value = NULL;
              }
            else
              {
                if (jumper_thread(the_jumper) == NULL)
                  {
                    assert(why_not == NULL);
                    *doubt = TRUE;
                    return FALSE;
                  }

                assert(!(object_is_closed(the_object))); /* VERIFIED */
                if (object_field_is_variable(the_object, object_field_num))
                  {
                    variable_instance *field_instance;
                    variable_declaration *field_declaration;

                    field_instance = object_field_variable(the_object,
                                                           object_field_num);
                    assert(field_instance != NULL);

                    field_declaration =
                            variable_instance_declaration(field_instance);
                    assert(field_declaration != NULL);

                    if (!(variable_declaration_is_immutable(
                                  field_declaration)))
                      {
                        type *variable_type;
                        boolean local_doubt;
                        char *local_why_not;
                        boolean ok;

                        instance_check_validity(
                                variable_instance_instance(field_instance),
                                location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (*doubt && (why_not != NULL))
                                free(*why_not);
                            return FALSE;
                          }

                        assert(variable_instance_is_instantiated(
                                       field_instance)); /* VERIFIED */
                        assert(!(variable_instance_scope_exited(
                                         field_instance))); /* VERIFIED */
                        variable_type = variable_instance_type(field_instance);

                        check_type_validity(variable_type, location,
                                            the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (*doubt && (why_not != NULL))
                                free(*why_not);
                            return FALSE;
                          }

                        assert(type_is_valid(variable_type)); /* VERIFIED */
                        assert(type_is_valid(field_type)); /* VERIFIED */
                        ok = type_is_subset(variable_type, field_type,
                                &local_doubt,
                                ((why_not == NULL) ? NULL : &local_why_not),
                                location, the_jumper);
                        if (!(jumper_flowing_forward(the_jumper)))
                          {
                            if (*doubt && (why_not != NULL))
                                free(*why_not);
                            return FALSE;
                          }
                        if (local_doubt)
                          {
                            if (why_not != NULL)
                              {
                                if (!*doubt)
                                  {
                                    *why_not = allocate_printf(
                                            "the type requires that the field "
                                            "named `%s' have type %t, but the "
                                            "value is an object with a "
                                            "variable field of that name with "
                                            "type %t, and %s is unable to "
                                            "determine whether the variable "
                                            "field's type is a subset of the "
                                            "required type because %s",
                                            field_name, field_type,
                                            variable_type, interpreter_name(),
                                            local_why_not);
                                  }
                                free(local_why_not);
                                if (*why_not == NULL)
                                  {
                                    jumper_do_abort(the_jumper);
                                    return FALSE;
                                  }
                              }
                            *doubt = TRUE;
                          }
                        else if (!ok)
                          {
                            if (why_not != NULL)
                              {
                                if (*doubt)
                                    free(*why_not);
                                *why_not = allocate_printf(
                                        "the type requires that the field "
                                        "named `%s' have type %t, but the "
                                        "value is an object with a variable "
                                        "field of that name with type %t, and "
                                        "the variable field's type is not a "
                                        "subset of the required type because "
                                        "%s", field_name, field_type,
                                        variable_type, local_why_not);
                                free(local_why_not);
                                if (*why_not == NULL)
                                    jumper_do_abort(the_jumper);
                              }
                            *doubt = FALSE;
                            return FALSE;
                          }

                        continue;
                      }
                  }

                assert(!(object_is_closed(the_object))); /* VERIFIED */
                field_value = object_field_read_value(the_object,
                        object_field_num, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    assert(field_value == NULL);
                    if (*doubt && (why_not != NULL))
                        free(*why_not);
                    return FALSE;
                  }
              }
          }
        if (field_value == NULL)
          {
            if (field_info->field_can_be_empty[field_num])
              {
                continue;
              }
            else
              {
                if (*doubt && (why_not != NULL))
                    free(*why_not);
                return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                        "the type requires that a field named `%s' exist, but "
                        "the value has no such field", field_name);
              }
          }

        assert(type_is_valid(field_type)); /* VERIFIED */
        ok = value_is_in_type(field_value, field_type, &local_doubt,
                ((why_not == NULL) ? NULL : &local_why_not), location,
                the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            if (get_value_kind(the_value) == VK_OBJECT)
              {
                value_remove_reference(field_value,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                                                               the_jumper));
              }
            if (*doubt && (why_not != NULL))
                free(*why_not);
            return FALSE;
          }
        if (local_doubt)
          {
            if (why_not != NULL)
              {
                if (!*doubt)
                  {
                    *why_not = allocate_printf(
                            "the type requires that the field named `%s' have "
                            "type %t, but the value has a field of that name "
                            "with value %U and %s is unable to determine "
                            "whether that field value is in the required type "
                            "because %s", field_name, field_type, field_value,
                            interpreter_name(), local_why_not);
                  }
                free(local_why_not);
                if (*why_not == NULL)
                  {
                    jumper_do_abort(the_jumper);
                    if (get_value_kind(the_value) == VK_OBJECT)
                      {
                        value_remove_reference(field_value,
                                ((jumper_thread(the_jumper) == NULL) ? NULL :
                                 the_jumper));
                      }
                    return FALSE;
                  }
              }
            *doubt = TRUE;
          }
        else if (!ok)
          {
            if (why_not != NULL)
              {
                if (*doubt)
                    free(*why_not);
                *why_not = allocate_printf(
                        "the type requires that the field named `%s' have type"
                        " %t, but the value has a field of that name with "
                        "value %U and that field value is not in the required "
                        "type because %s", field_name, field_type, field_value,
                        local_why_not);
                free(local_why_not);
                if (*why_not == NULL)
                    jumper_do_abort(the_jumper);
              }
            *doubt = FALSE;
            if (get_value_kind(the_value) == VK_OBJECT)
              {
                value_remove_reference(field_value,
                        ((jumper_thread(the_jumper) == NULL) ? NULL :
                                                               the_jumper));
              }
            return FALSE;
          }
        if (get_value_kind(the_value) == VK_OBJECT)
          {
            value_remove_reference(field_value,
                    ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
          }
      }

    assert(value_is_valid(the_value)); /* VERIFIED */
    if ((!(field_info->extra_fields_allowed)) &&
        ((get_value_kind(the_value) == VK_OBJECT) ?
         object_value_uses_banned_field(the_value, field_info->allowed_fields,
                                        &bad_field_name) :
         compound_value_uses_banned_field(the_value,
                 field_info->allowed_fields, &bad_field_name)))
      {
        if (*doubt && (why_not != NULL))
            free(*why_not);
        if (bad_field_name != NULL)
          {
            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the value has a field named `%s' and the type disallows "
                    "such a field", bad_field_name);
          }
        else
          {
            return type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                    "the value has an unnamed field and the type disallows "
                    "such a field");
          }
      }

    return TRUE;
  }

static boolean field_info_is_equal(field_type_info *left_field_info,
        field_type_info *right_field_info, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    size_t left_field_count;
    size_t right_field_count;
    size_t left_field_num;
    size_t right_field_num;

    assert(left_field_info != NULL);
    assert(right_field_info != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    if (left_field_info->extra_fields_allowed !=
        right_field_info->extra_fields_allowed)
      {
        *doubt = FALSE;
        return FALSE;
      }

    left_field_count = left_field_info->field_count;
    right_field_count = right_field_info->field_count;

    *doubt = FALSE;

    left_field_num = 0;
    right_field_num = 0;
    while (TRUE)
      {
        type *left_field_type;
        const char *left_name;
        type *right_field_type;
        const char *right_name;
        boolean left_field_can_be_empty;
        boolean right_field_can_be_empty;
        boolean field_doubt;
        boolean field_match;

        if (left_field_num >= left_field_count)
          {
            if (right_field_num >= right_field_count)
                break;
            left_field_type = NULL;
            left_name = NULL;
          }
        else
          {
            left_field_type = left_field_info->field_types[left_field_num];
            assert(left_field_type != NULL);
            assert(type_is_valid(left_field_type)); /* VERIFIED */
            left_name = left_field_info->field_names[left_field_num];
            assert(left_name != NULL);
          }
        assert((left_field_type == NULL) || type_is_valid(left_field_type));
                /* VERIFIED */

        if (right_field_num >= right_field_count)
          {
            assert(left_field_num < left_field_count);
            right_field_type = NULL;
            right_name = NULL;
          }
        else
          {
            right_field_type = right_field_info->field_types[right_field_num];
            assert(right_field_type != NULL);
            assert(type_is_valid(right_field_type)); /* VERIFIED */
            right_name = right_field_info->field_names[right_field_num];
            assert(right_name != NULL);
          }
        assert((right_field_type == NULL) || type_is_valid(right_field_type));
                /* VERIFIED */

        if (left_name == NULL)
          {
            left_field_can_be_empty = TRUE;
            right_field_can_be_empty =
                    right_field_info->field_can_be_empty[right_field_num];
            ++right_field_num;
          }
        else if (right_name == NULL)
          {
            left_field_can_be_empty =
                    left_field_info->field_can_be_empty[left_field_num];
            right_field_can_be_empty = TRUE;
            ++left_field_num;
          }
        else
          {
            int name_order;

            name_order = utf8_string_lexicographical_order_by_code_point(
                    left_name, right_name);
            if (name_order == -2)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
            else if (name_order < 0)
              {
                left_field_can_be_empty =
                        left_field_info->field_can_be_empty[left_field_num];
                right_field_can_be_empty = TRUE;
                ++left_field_num;
                right_field_type = NULL;
              }
            else if (name_order > 0)
              {
                left_field_can_be_empty = TRUE;
                right_field_can_be_empty =
                        right_field_info->field_can_be_empty[right_field_num];
                ++right_field_num;
                left_field_type = NULL;
              }
            else
              {
                left_field_can_be_empty =
                        left_field_info->field_can_be_empty[left_field_num];
                right_field_can_be_empty =
                        right_field_info->field_can_be_empty[right_field_num];
                ++left_field_num;
                ++right_field_num;
              }
          }

        assert((left_field_type == NULL) || type_is_valid(left_field_type));
                /* VERIFIED */
        assert((right_field_type == NULL) || type_is_valid(right_field_type));
                /* VERIFIED */

        if (left_field_can_be_empty != right_field_can_be_empty)
          {
            *doubt = FALSE;
            return FALSE;
          }

        if (left_field_type == NULL)
          {
            if (!(left_field_info->extra_fields_allowed))
              {
                *doubt = FALSE;
                return FALSE;
              }
            left_field_type = get_anything_type();
            if (left_field_type == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
            assert(type_is_valid(left_field_type)); /* VERIFIED */
          }
        if (right_field_type == NULL)
          {
            if (!(right_field_info->extra_fields_allowed))
              {
                *doubt = FALSE;
                return FALSE;
              }
            right_field_type = get_anything_type();
            if (right_field_type == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
            assert(type_is_valid(right_field_type)); /* VERIFIED */
          }

        assert(type_is_valid(left_field_type)); /* VERIFIED */
        assert(type_is_valid(right_field_type)); /* VERIFIED */
        field_match = types_are_equal(left_field_type,
                right_field_type, &field_doubt, location,
                the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if ((!field_doubt) && !field_match)
          {
            *doubt = FALSE;
            return FALSE;
          }
        if (field_doubt)
            *doubt = TRUE;
      }

    return TRUE;
  }

static int field_info_structural_order(field_type_info *left_field_info,
                                       field_type_info *right_field_info)
  {
    size_t left_count;
    size_t right_count;
    size_t field_num;

    left_count = left_field_info->field_count;
    right_count = right_field_info->field_count;

    field_num = 0;
    while (TRUE)
      {
        int test_order;
        type *left_field_type;
        type *right_field_type;

        if (field_num >= left_count)
          {
            if (field_num < right_count)
                return -1;
            break;
          }

        if (field_num >= right_count)
            return 1;

        test_order = utf8_string_lexicographical_order_by_code_point(
                left_field_info->field_names[field_num],
                right_field_info->field_names[field_num]);
        if (test_order != 0)
            return test_order;

        left_field_type = left_field_info->field_types[field_num];
        right_field_type = right_field_info->field_types[field_num];
        assert(left_field_type != NULL);
        assert(right_field_type != NULL);
        assert(type_is_valid(left_field_type)); /* VERIFIED */
        assert(type_is_valid(right_field_type)); /* VERIFIED */
        test_order = type_structural_order(left_field_type, right_field_type);
        if (test_order != 0)
            return test_order;

        if (left_field_info->field_can_be_empty[field_num] !=
            right_field_info->field_can_be_empty[field_num])
          {
            return (left_field_info->extra_fields_allowed ? 1 : -1);
          }

        ++field_num;
      }

    if (left_field_info->extra_fields_allowed !=
        right_field_info->extra_fields_allowed)
      {
        return (left_field_info->extra_fields_allowed ? 1 : -1);
      }

    return 0;
  }

static boolean field_info_possibly_nothing(field_type_info *field_info)
  {
    size_t field_count;
    size_t field_num;

    field_count = field_info->field_count;
    for (field_num = 0; field_num < field_count; ++field_num)
      {
        if (field_info->field_can_be_empty[field_num])
            continue;

        assert(type_is_valid(field_info->field_types[field_num]));
                /* VERIFIED */
        if (possibly_nothing(field_info->field_types[field_num]))
            return TRUE;
      }
    return FALSE;
  }

static type *field_info_field(field_type_info *field_info,
        const char *field_name, lower_or_upper bound_direction)
  {
    string_index *allowed_fields;
    size_t field_num;
    type *result;

    allowed_fields = field_info->allowed_fields;
    assert(allowed_fields != NULL);

    if (!(exists_in_string_index(allowed_fields, field_name)))
      {
        type *result;

        if (field_info->extra_fields_allowed)
          {
            if ((!(field_info_possibly_nothing(field_info))) ||
                (bound_direction != LOU_LOWER))
              {
                type *result;

                result = get_anything_type();
                if (result != NULL)
                    type_add_reference(result);
                assert((result == NULL) || type_is_valid(result));
                        /* VERIFIED */
                return result;
              }
          }

        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
        return result;
      }

    field_num = (size_t)(lookup_in_string_index(allowed_fields, field_name));
    assert(field_num < field_info->field_count);
    assert(strcmp(field_info->field_names[field_num], field_name) == 0);

    result = field_info->field_types[field_num];
    assert(result != NULL);
    type_add_reference(result);
    assert(type_is_valid(result)); /* VERIFIED */
    return result;
  }

static boolean field_info_has_finite_enumeration_within_limit(
        field_type_info *field_info, size_t maximum_elements, boolean *doubt,
        size_t *element_count, boolean *error)
  {
    size_t field_count;
    size_t result;
    size_t field_num;

    if (maximum_elements == 0)
      {
        *doubt = FALSE;
        return FALSE;
      }

    if (field_info->extra_fields_allowed)
      {
        *doubt = FALSE;
        return FALSE;
      }

    field_count = field_info->field_count;

    result = 1;

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        boolean field_doubt;
        size_t field_element_count;
        boolean field_fits;

        assert(type_is_valid(field_info->field_types[field_num]));
                /* VERIFIED */
        field_fits = type_has_finite_enumeration_within_limit(
                field_info->field_types[field_num],
                ((maximum_elements / result) - 1), &field_doubt,
                &field_element_count, error);
        if (*error)
            return FALSE;
        if ((!field_fits) || field_doubt)
          {
            *doubt = field_doubt;
            return FALSE;
          }

        assert(field_element_count <= ((maximum_elements / result) - 1));
        result *= (field_element_count + 1);
      }

    assert(result <= maximum_elements);
    *doubt = FALSE;
    *element_count = result;
    return TRUE;
  }

static boolean intersection_definitely_empty(type *left, type *right,
                                             boolean *error)
  {
    jumper *test_jumper;
    boolean doubt;
    boolean result;

    test_jumper = create_test_jumper();
    if (test_jumper == NULL)
      {
        *error = TRUE;
        return FALSE;
      }

    result = intersection_empty(left, right, &doubt, NULL, test_jumper);
    *error = !(jumper_flowing_forward(test_jumper));
    delete_jumper(test_jumper);
    return (result && !doubt);
  }

static boolean field_info_intersection_empty(field_type_info *left_field_info,
        field_type_info *right_field_info, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    size_t left_field_count;
    size_t right_field_count;
    size_t left_field_num;
    size_t right_field_num;

    assert(left_field_info != NULL);
    assert(right_field_info != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    left_field_count = left_field_info->field_count;
    right_field_count = right_field_info->field_count;

    *doubt = FALSE;

    left_field_num = 0;
    right_field_num = 0;
    while (TRUE)
      {
        type *left_field_type;
        const char *left_name;
        type *right_field_type;
        const char *right_name;
        boolean left_field_can_be_empty;
        boolean right_field_can_be_empty;
        boolean field_doubt;
        boolean field_intersection_empty;

        if (left_field_num >= left_field_count)
          {
            if (right_field_num >= right_field_count)
                break;
            left_field_type = NULL;
            left_name = NULL;
          }
        else
          {
            left_field_type = left_field_info->field_types[left_field_num];
            assert(left_field_type != NULL);
            assert(type_is_valid(left_field_type)); /* VERIFIED */
            left_name = left_field_info->field_names[left_field_num];
            assert(left_name != NULL);
          }
        assert((left_field_type == NULL) || type_is_valid(left_field_type));
                /* VERIFIED */

        if (right_field_num >= right_field_count)
          {
            assert(left_field_num < left_field_count);
            right_field_type = NULL;
            right_name = NULL;
          }
        else
          {
            right_field_type = right_field_info->field_types[right_field_num];
            assert(right_field_type != NULL);
            assert(type_is_valid(right_field_type)); /* VERIFIED */
            right_name = right_field_info->field_names[right_field_num];
            assert(right_name != NULL);
          }
        assert((right_field_type == NULL) || type_is_valid(right_field_type));
                /* VERIFIED */

        if (left_name == NULL)
          {
            left_field_can_be_empty = TRUE;
            right_field_can_be_empty =
                    right_field_info->field_can_be_empty[right_field_num];
            ++right_field_num;
          }
        else if (right_name == NULL)
          {
            left_field_can_be_empty =
                    left_field_info->field_can_be_empty[left_field_num];
            right_field_can_be_empty = TRUE;
            ++left_field_num;
          }
        else
          {
            int name_order;

            name_order = utf8_string_lexicographical_order_by_code_point(
                    left_name, right_name);
            if (name_order == -2)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
            else if (name_order < 0)
              {
                left_field_can_be_empty =
                        left_field_info->field_can_be_empty[left_field_num];
                right_field_can_be_empty = TRUE;
                ++left_field_num;
                right_field_type = NULL;
              }
            else if (name_order > 0)
              {
                left_field_can_be_empty = TRUE;
                right_field_can_be_empty =
                        right_field_info->field_can_be_empty[right_field_num];
                ++right_field_num;
                left_field_type = NULL;
              }
            else
              {
                left_field_can_be_empty =
                        left_field_info->field_can_be_empty[left_field_num];
                right_field_can_be_empty =
                        right_field_info->field_can_be_empty[right_field_num];
                ++left_field_num;
                ++right_field_num;
              }
          }

        assert((left_field_type == NULL) || type_is_valid(left_field_type));
                /* VERIFIED */
        assert((right_field_type == NULL) || type_is_valid(right_field_type));
                /* VERIFIED */

        if (left_field_can_be_empty && right_field_can_be_empty)
            continue;

        if (left_field_type == NULL)
          {
            if (right_field_can_be_empty)
                continue;
            if (!(left_field_info->extra_fields_allowed))
              {
                *doubt = FALSE;
                return TRUE;
              }
            left_field_type = get_anything_type();
            if (left_field_type == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
            assert(type_is_valid(left_field_type)); /* VERIFIED */
          }
        if (right_field_type == NULL)
          {
            if (left_field_can_be_empty)
                continue;
            if (!(right_field_info->extra_fields_allowed))
              {
                *doubt = FALSE;
                return TRUE;
              }
            right_field_type = get_anything_type();
            if (right_field_type == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }
            assert(type_is_valid(right_field_type)); /* VERIFIED */
          }

        assert(type_is_valid(left_field_type)); /* VERIFIED */
        assert(type_is_valid(right_field_type)); /* VERIFIED */
        field_intersection_empty = intersection_empty(left_field_type,
                right_field_type, &field_doubt, location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if ((!field_doubt) && field_intersection_empty)
          {
            *doubt = FALSE;
            return TRUE;
          }
        if (field_doubt)
            *doubt = TRUE;
      }

    return FALSE;
  }

static verdict field_info_intersection(field_type_info *result_field_info,
        field_type_info *left_field_info, field_type_info *right_field_info,
        boolean *empty, reference_cluster **cluster)
  {
    return field_info_intersection_with_writing_alloweds(result_field_info,
            left_field_info, right_field_info, empty, cluster, NULL, NULL,
            NULL, NULL);
  }

static verdict field_info_intersection_with_writing_alloweds(
        field_type_info *result_field_info, field_type_info *left_field_info,
        field_type_info *right_field_info, boolean *empty,
        reference_cluster **cluster, boolean *left_item_writing_alloweds,
        boolean *right_item_writing_alloweds,
        boolean **result_item_writing_alloweds, boolean *unknown)
  {
    reference_cluster *local_cluster;
    size_t left_field_count;
    size_t right_field_count;
    size_t max_result_field_count;
    type **result_field_types;
    char **result_field_names;
    boolean *result_field_can_be_empty;
    size_t left_field_num;
    size_t right_field_num;
    size_t result_field_num;

    assert(result_field_info != NULL);
    assert(left_field_info != NULL);
    assert(right_field_info != NULL);
    assert(empty != NULL);
    if ((left_item_writing_alloweds != NULL) ||
        (right_item_writing_alloweds != NULL))
      {
        assert(result_item_writing_alloweds != NULL);
        assert(unknown != NULL);
        *unknown = FALSE;
      }

    if (cluster != NULL)
        local_cluster = *cluster;
    else
        local_cluster = NULL;

    result_field_info->extra_fields_allowed =
            (left_field_info->extra_fields_allowed &&
             right_field_info->extra_fields_allowed);
    result_field_info->slippery = FALSE;

    left_field_count = left_field_info->field_count;
    right_field_count = right_field_info->field_count;

    max_result_field_count = left_field_count + right_field_count;
    if (max_result_field_count == 0)
      {
      zero_fields:
        *empty = FALSE;
        result_field_info->field_count = 0;
        result_field_info->field_types = NULL;
        result_field_info->field_names = NULL;
        result_field_info->field_can_be_empty = NULL;
        result_field_info->allowed_fields = create_string_index();
        if (result_field_info->allowed_fields == NULL)
            return MISSION_FAILED;
        return MISSION_ACCOMPLISHED;
      }

    result_field_types = MALLOC_ARRAY(type *, max_result_field_count);
    if (result_field_types == NULL)
        return MISSION_FAILED;

    result_field_names = MALLOC_ARRAY(char *, max_result_field_count);
    if (result_field_names == NULL)
      {
        free(result_field_types);
        return MISSION_FAILED;
      }

    result_field_can_be_empty = MALLOC_ARRAY(boolean, max_result_field_count);
    if (result_field_can_be_empty == NULL)
      {
        free(result_field_names);
        free(result_field_types);
        return MISSION_FAILED;
      }

    if (result_item_writing_alloweds != NULL)
      {
        *result_item_writing_alloweds =
                MALLOC_ARRAY(boolean, max_result_field_count);
        if (result_field_can_be_empty == NULL)
          {
            free(result_field_can_be_empty);
            free(result_field_names);
            free(result_field_names);
            free(result_field_types);
            return MISSION_FAILED;
          }
      }

    left_field_num = 0;
    right_field_num = 0;
    result_field_num = 0;
    while (TRUE)
      {
        type *left_field_type;
        const char *left_name;
        boolean left_item_writing_allowed;
        type *right_field_type;
        const char *right_name;
        boolean right_item_writing_allowed;
        boolean left_field_can_be_empty;
        boolean right_field_can_be_empty;
        const char *result_field_name;
        char *name_copy;

        if (left_field_num >= left_field_count)
          {
            if (right_field_num >= right_field_count)
                break;
            left_field_type = NULL;
            left_name = NULL;
          }
        else
          {
            left_field_type = left_field_info->field_types[left_field_num];
            assert(left_field_type != NULL);
            assert(type_is_valid(left_field_type)); /* VERIFIED */
            left_name = left_field_info->field_names[left_field_num];
            assert(left_name != NULL);
            left_item_writing_allowed =
                    ((left_item_writing_alloweds != NULL) ?
                     left_item_writing_alloweds[left_field_num] : FALSE);
          }
        assert((left_field_type == NULL) || type_is_valid(left_field_type));
                /* VERIFIED */

        if (right_field_num >= right_field_count)
          {
            assert(left_field_num < left_field_count);
            right_field_type = NULL;
            right_name = NULL;
          }
        else
          {
            right_field_type = right_field_info->field_types[right_field_num];
            assert(right_field_type != NULL);
            assert(type_is_valid(right_field_type)); /* VERIFIED */
            right_name = right_field_info->field_names[right_field_num];
            assert(right_name != NULL);
            right_item_writing_allowed =
                    ((right_item_writing_alloweds != NULL) ?
                     right_item_writing_alloweds[right_field_num] : FALSE);
          }
        assert((right_field_type == NULL) || type_is_valid(right_field_type));
                /* VERIFIED */

        if (left_name == NULL)
          {
            left_field_can_be_empty = TRUE;
            right_field_can_be_empty =
                    right_field_info->field_can_be_empty[right_field_num];
            ++right_field_num;
          }
        else if (right_name == NULL)
          {
            left_field_can_be_empty =
                    left_field_info->field_can_be_empty[left_field_num];
            right_field_can_be_empty = TRUE;
            ++left_field_num;
          }
        else
          {
            int name_order;

            name_order = utf8_string_lexicographical_order_by_code_point(
                    left_name, right_name);
            if (name_order == -2)
              {
                while (result_field_num > 0)
                  {
                    --result_field_num;
                    free(result_field_names[result_field_num]);
                    type_remove_reference_with_reference_cluster(
                            result_field_types[result_field_num], NULL,
                            local_cluster);
                  }
                if (result_item_writing_alloweds != NULL)
                    free(*result_item_writing_alloweds);
                free(result_field_can_be_empty);
                free(result_field_names);
                free(result_field_types);
                return MISSION_FAILED;
              }
            else if (name_order < 0)
              {
                left_field_can_be_empty =
                        left_field_info->field_can_be_empty[left_field_num];
                right_field_can_be_empty = TRUE;
                ++left_field_num;
                right_field_type = NULL;
              }
            else if (name_order > 0)
              {
                left_field_can_be_empty = TRUE;
                right_field_can_be_empty =
                        right_field_info->field_can_be_empty[right_field_num];
                ++right_field_num;
                left_field_type = NULL;
              }
            else
              {
                left_field_can_be_empty =
                        left_field_info->field_can_be_empty[left_field_num];
                right_field_can_be_empty =
                        right_field_info->field_can_be_empty[right_field_num];
                ++left_field_num;
                ++right_field_num;
              }
          }

        result_field_can_be_empty[result_field_num] =
                (left_field_can_be_empty && right_field_can_be_empty);

        if (left_field_type == NULL)
          {
            assert(right_field_type != NULL);
            if (!(left_field_info->extra_fields_allowed))
              {
                if (right_field_can_be_empty)
                    continue;
                *empty = TRUE;
                while (result_field_num > 0)
                  {
                    --result_field_num;
                    free(result_field_names[result_field_num]);
                    type_remove_reference_with_reference_cluster(
                            result_field_types[result_field_num], NULL,
                            local_cluster);
                  }
                if (result_item_writing_alloweds != NULL)
                    free(*result_item_writing_alloweds);
                free(result_field_can_be_empty);
                free(result_field_names);
                free(result_field_types);
                return MISSION_ACCOMPLISHED;
              }

            if ((cluster != NULL) && (local_cluster == NULL))
                local_cluster = right_field_type->reference_cluster;

            result_field_name = right_name;
            type_add_reference_with_reference_cluster(right_field_type,
                                                      local_cluster);
            result_field_types[result_field_num] = right_field_type;

            if (result_item_writing_alloweds != NULL)
              {
                (*result_item_writing_alloweds)[result_field_num] =
                        right_item_writing_allowed;
              }
          }
        else if (right_field_type == NULL)
          {
            if (!(right_field_info->extra_fields_allowed))
              {
                if (left_field_can_be_empty)
                    continue;
                *empty = TRUE;
                while (result_field_num > 0)
                  {
                    --result_field_num;
                    free(result_field_names[result_field_num]);
                    type_remove_reference_with_reference_cluster(
                            result_field_types[result_field_num], NULL,
                            local_cluster);
                  }
                if (result_item_writing_alloweds != NULL)
                    free(*result_item_writing_alloweds);
                free(result_field_can_be_empty);
                free(result_field_names);
                free(result_field_types);
                return MISSION_ACCOMPLISHED;
              }

            if ((cluster != NULL) && (local_cluster == NULL))
                local_cluster = left_field_type->reference_cluster;

            result_field_name = left_name;
            type_add_reference_with_reference_cluster(left_field_type,
                                                      local_cluster);
            result_field_types[result_field_num] = left_field_type;

            if (result_item_writing_alloweds != NULL)
              {
                (*result_item_writing_alloweds)[result_field_num] =
                        left_item_writing_allowed;
              }
          }
        else
          {
            type *result_field_type;

            if (left_item_writing_allowed || right_item_writing_allowed)
              {
                jumper *test_jumper;
                boolean doubt;
                boolean match;
                boolean abort;

                assert(unknown != NULL);

                test_jumper = create_test_jumper();
                if (test_jumper == NULL)
                    goto do_failure;

                if (left_item_writing_allowed && right_item_writing_allowed)
                  {
                    match = types_are_equal(left_field_type, right_field_type,
                                            &doubt, NULL, test_jumper);
                  }
                else if (left_item_writing_allowed)
                  {
                    match = type_is_subset(left_field_type, right_field_type,
                                           &doubt, NULL, NULL, test_jumper);
                  }
                else
                  {
                    assert(right_item_writing_allowed);
                    match = type_is_subset(right_field_type, left_field_type,
                                           &doubt, NULL, NULL, test_jumper);
                  }

                abort = !(jumper_flowing_forward(test_jumper));
                delete_jumper(test_jumper);

                if (abort)
                    goto do_failure;

                if ((!match) || doubt)
                  {
                    *unknown = TRUE;
                    while (result_field_num > 0)
                      {
                        --result_field_num;
                        free(result_field_names[result_field_num]);
                        type_remove_reference_with_reference_cluster(
                                result_field_types[result_field_num], NULL,
                                local_cluster);
                      }
                    if (result_item_writing_alloweds != NULL)
                        free(*result_item_writing_alloweds);
                    free(result_field_can_be_empty);
                    free(result_field_names);
                    free(result_field_types);
                    return MISSION_ACCOMPLISHED;
                  }
              }

            result_field_name = right_name;

            assert(type_is_valid(left_field_type)); /* VERIFIED */
            assert(type_is_valid(right_field_type)); /* VERIFIED */
            result_field_type =
                    get_intersection_type(left_field_type, right_field_type);
            assert((result_field_type == NULL) ||
                   type_is_valid(result_field_type)); /* VERIFIED */
            if (result_field_type == NULL)
              {
              do_failure:
                while (result_field_num > 0)
                  {
                    --result_field_num;
                    free(result_field_names[result_field_num]);
                    type_remove_reference_with_reference_cluster(
                            result_field_types[result_field_num], NULL,
                            local_cluster);
                  }
                if (result_item_writing_alloweds != NULL)
                    free(*result_item_writing_alloweds);
                free(result_field_can_be_empty);
                free(result_field_names);
                free(result_field_types);
                return MISSION_FAILED;
              }

            if ((cluster != NULL) && (local_cluster == NULL))
                local_cluster = result_field_type->reference_cluster;
            if (local_cluster != NULL)
              {
                type_add_reference_with_reference_cluster(result_field_type,
                                                          local_cluster);
                type_remove_reference(result_field_type, NULL);
              }

            result_field_types[result_field_num] = result_field_type;

            if ((!(result_field_info->slippery)) &&
                type_is_slippery(result_field_type))
              {
                result_field_info->slippery = TRUE;
              }

            if (result_item_writing_alloweds != NULL)
              {
                (*result_item_writing_alloweds)[result_field_num] =
                        (left_item_writing_allowed ||
                         right_item_writing_allowed);
              }
          }

        assert(result_field_name != NULL);
        name_copy = MALLOC_ARRAY(char, strlen(result_field_name) + 1);
        if (name_copy == NULL)
          {
            type_remove_reference_with_reference_cluster(
                    result_field_types[result_field_num], NULL, local_cluster);
            while (result_field_num > 0)
              {
                --result_field_num;
                free(result_field_names[result_field_num]);
                type_remove_reference_with_reference_cluster(
                        result_field_types[result_field_num], NULL,
                        local_cluster);
              }
            if (result_item_writing_alloweds != NULL)
                free(*result_item_writing_alloweds);
            free(result_field_can_be_empty);
            free(result_field_names);
            free(result_field_types);
            return MISSION_FAILED;
          }

        strcpy(name_copy, result_field_name);
        result_field_names[result_field_num] = name_copy;

        ++result_field_num;
      }

    if (result_field_num == 0)
      {
        if (result_item_writing_alloweds != NULL)
            free(*result_item_writing_alloweds);
        free(result_field_can_be_empty);
        free(result_field_names);
        free(result_field_types);
        goto zero_fields;
      }

    *empty = FALSE;
    result_field_info->field_count = result_field_num;
    result_field_info->field_types = result_field_types;
    result_field_info->field_names = result_field_names;
    result_field_info->field_can_be_empty = result_field_can_be_empty;
    result_field_info->allowed_fields =
            make_allowed_fields_index(result_field_num, result_field_names);
    if (result_field_info->allowed_fields == NULL)
      {
        while (result_field_num > 0)
          {
            --result_field_num;
            free(result_field_names[result_field_num]);
            type_remove_reference_with_reference_cluster(
                    result_field_types[result_field_num], NULL, local_cluster);
          }
        if (result_item_writing_alloweds != NULL)
            free(*result_item_writing_alloweds);
        free(result_field_can_be_empty);
        free(result_field_names);
        free(result_field_types);
        return MISSION_FAILED;
      }

    if (cluster != NULL)
      {
        *cluster = local_cluster;
        if (local_cluster != NULL)
            reference_cluster_add_reference(local_cluster);
      }

    return MISSION_ACCOMPLISHED;
  }

static boolean field_info_empty_allowed(field_type_info *field_info)
  {
    size_t field_count;
    size_t field_num;

    assert(field_info != NULL);

    field_count = field_info->field_count;

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        if (!(field_info->field_can_be_empty[field_num]))
            return FALSE;
      }

    return TRUE;
  }

static type *lepton_fields_intersection(type *lepton_type,
                                        field_type_info *field_info)
  {
    type *result;
    boolean empty;
    verdict the_verdict;

    assert(lepton_type != NULL);
    assert(field_info != NULL);

    assert(type_is_valid(lepton_type)); /* VERIFIED */

    assert(lepton_type->kind == TK_LEPTON);

    result = create_empty_type(TK_LEPTON);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_LEPTON);

    assert(type_is_valid(lepton_type)); /* VERIFIED */
    the_verdict = field_info_intersection(&(result->u.lepton.field_info),
            &(lepton_type->u.lepton.field_info), field_info, &empty,
            &(result->reference_cluster));
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }
    if (empty)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
        return result;
      }

    if (result->reference_cluster == NULL)
      {
        result->reference_cluster = lepton_key_instance_reference_cluster(
                lepton_type->u.lepton.key);
        if (result->reference_cluster != NULL)
            reference_cluster_add_reference(result->reference_cluster);
      }
    lepton_key_instance_add_reference_with_cluster(lepton_type->u.lepton.key,
                                                   result->reference_cluster);
    result->u.lepton.key = lepton_type->u.lepton.key;

    result->validator = validator_add_instance(result->validator,
            lepton_key_instance_instance(lepton_type->u.lepton.key));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    result->validator = validator_add_field_type_info(result->validator,
            &(result->u.lepton.field_info));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    assert(type_is_valid(result)); /* VERIFICATION NEEDED */
    return result;
  }

static type *multiset_fields_intersection(type *multiset_type,
                                          field_type_info *field_info)
  {
    type *result;
    boolean empty;
    verdict the_verdict;

    assert(multiset_type != NULL);
    assert(field_info != NULL);

    assert(type_is_valid(multiset_type)); /* VERIFIED */

    assert(multiset_type->kind == TK_MULTISET);

    result = create_empty_type(TK_MULTISET);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_SEMI_LABELED_MULTI_SET);

    assert(type_is_valid(multiset_type)); /* VERIFIED */
    the_verdict = field_info_intersection(&(result->u.multiset.field_info),
            &(multiset_type->u.multiset.field_info), field_info, &empty,
            &(result->reference_cluster));
    if (the_verdict != MISSION_ACCOMPLISHED)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        return NULL;
      }
    if (empty)
      {
        validator_remove_reference(result->validator);
        DESTROY_SYSTEM_LOCK(result->reference_lock);
        free(result);
        result = get_nothing_type();
        if (result != NULL)
            type_add_reference(result);
        assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
        return result;
      }

    result->validator = validator_add_field_type_info(result->validator,
            &(result->u.multiset.field_info));
    if (result->validator == NULL)
      {
        type_remove_reference(result, NULL);
        return NULL;
      }

    assert(type_is_valid(result)); /* VERIFICATION NEEDED */
    return result;
  }

static verdict field_info_from_lepton_key(field_type_info *result_field_info,
                                          lepton_key_instance *key_instance)
  {
    lepton_key_declaration *declaration;
    size_t field_count;
    type **field_types;
    const char **field_names;
    verdict result;

    assert(result_field_info != NULL);
    assert(key_instance != NULL);

    assert(lepton_key_instance_is_instantiated(key_instance)); /* VERIFIED */
    assert(!(lepton_key_instance_scope_exited(key_instance))); /* VERIFIED */

    declaration = lepton_key_instance_declaration(key_instance);
    assert(declaration != NULL);

    field_count = lepton_key_field_count(declaration);

    if (field_count == 0)
      {
        field_types = NULL;
        field_names = NULL;
      }
    else
      {
        size_t field_num;

        field_types = MALLOC_ARRAY(type *, field_count);
        if (field_types == NULL)
            return MISSION_FAILED;

        field_names = MALLOC_ARRAY(const char *, field_count);
        if (field_names == NULL)
          {
            free(field_types);
            return MISSION_FAILED;
          }

        for (field_num = 0; field_num < field_count; ++field_num)
          {
            assert(lepton_key_instance_is_instantiated(key_instance));
                    /* VERIFIED */
            assert(!(lepton_key_instance_scope_exited(key_instance)));
                    /* VERIFIED */

            field_types[field_num] =
                    lepton_key_instance_field_type(key_instance, field_num);
            assert(field_types[field_num] != NULL);
            assert(type_is_valid(field_types[field_num]));
                    /* VERIFICATION NEEDED */

            field_names[field_num] =
                    lepton_key_field_name(declaration, field_num);
            assert(field_names[field_num] != NULL);
          }
      }

    result = initialize_field_info(result_field_info, field_count, field_types,
            field_names,
            lepton_key_declaration_additional_fields_allowed(declaration),
            TRUE, NULL, NULL, NULL);
    if (field_count > 0)
      {
        free(field_types);
        free(field_names);
      }
    return result;
  }

static boolean semi_labeled_and_field_info_intersection_empty(
        type *semi_labeled_value_list_type, field_type_info *field_info,
        boolean *doubt, const source_location *location, jumper *the_jumper)
  {
    size_t field_count;
    boolean *field_used;
    size_t element_count;
    size_t element_num;

    assert(semi_labeled_value_list_type != NULL);
    assert(field_info != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);

    *doubt = FALSE;

    field_count = field_info->field_count;

    if (field_count > 0)
      {
        field_used = MALLOC_ARRAY(boolean, field_count);
        if (field_used == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }
      }
    else
      {
        field_used = NULL;
      }

    element_count = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_count;

    for (element_num = 0; element_num < element_count; ++element_num)
      {
        const char *element_name;
        size_t field_num;
        type *field_type;
        type *element_type;
        boolean element_doubt;
        boolean element_intersection_empty;

        element_name = semi_labeled_value_list_type->u.semi_labeled_value_list.
                element_names[element_num];
        if ((element_name == NULL) ||
            (!(exists_in_string_index(field_info->allowed_fields,
                                      element_name))))
          {
            if (field_info->extra_fields_allowed)
                continue;
            *doubt = FALSE;
            if (field_count > 0)
                free(field_used);
            return TRUE;
          }

        field_num = (size_t)(lookup_in_string_index(field_info->allowed_fields,
                                                    element_name));
        assert(field_num < field_count);
        assert(strcmp(element_name, field_info->field_names[field_num]) == 0);

        field_used[field_num] = TRUE;

        field_type = field_info->field_types[field_num];

        assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
        element_type = semi_labeled_value_list_type->u.semi_labeled_value_list.
                element_types[element_num];

        assert(type_is_valid(element_type)); /* VERIFIED */
        assert(type_is_valid(field_type)); /* VERIFIED */
        element_intersection_empty = intersection_empty(element_type,
                field_type, &element_doubt, location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            if (field_count > 0)
                free(field_used);
            return FALSE;
          }
        if (element_doubt)
          {
            *doubt = TRUE;
          }
        else if (element_intersection_empty)
          {
            *doubt = FALSE;
            if (field_count > 0)
                free(field_used);
            return TRUE;
          }
      }

    if (!(semi_labeled_value_list_type->u.semi_labeled_value_list.
                  extra_elements_allowed))
      {
        size_t field_num;

        for (field_num = 0; field_num < field_count; ++field_num)
          {
            if (field_used[field_num])
                continue;

            if (!(field_info->field_can_be_empty[field_num]))
              {
                *doubt = FALSE;
                if (field_count > 0)
                    free(field_used);
                return TRUE;
              }
          }
      }

    if (field_count > 0)
        free(field_used);

    return FALSE;
  }

static boolean semi_labeled_and_map_intersection_empty(
        type *semi_labeled_value_list_type, type *map_type, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    size_t element_count;
    size_t element_num;

    assert(semi_labeled_value_list_type != NULL);
    assert(map_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(type_is_valid(map_type)); /* VERIFIED */
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);
    assert(map_type->kind == TK_MAP);

    *doubt = FALSE;

    element_count = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_count;

    for (element_num = 0; element_num < element_count; ++element_num)
      {
        o_integer element_num_oi;
        value *element_num_value;
        boolean element_doubt;
        boolean key_fits;
        type *element_type;
        boolean element_intersection_empty;

        oi_create_from_size_t(element_num_oi, element_num);
        if (oi_out_of_memory(element_num_oi))
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }

        element_num_value = create_integer_value(element_num_oi);
        oi_remove_reference(element_num_oi);
        if (element_num_value == NULL)
          {
            jumper_do_abort(the_jumper);
            return FALSE;
          }

        assert(type_is_valid(map_type)); /* VERIFIED */
        assert(type_is_valid(map_type->u.map.key)); /* VERIFIED */
        key_fits = value_is_in_type(element_num_value, map_type->u.map.key,
                &element_doubt, NULL, location, the_jumper);
        value_remove_reference(element_num_value, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (element_doubt)
          {
            *doubt = TRUE;
          }
        else if (!key_fits)
          {
            *doubt = FALSE;
            return TRUE;
          }

        if (semi_labeled_value_list_type->u.semi_labeled_value_list.
                    element_names[element_num] != NULL)
          {
            *doubt = FALSE;
            return TRUE;
          }

        assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
        element_type = semi_labeled_value_list_type->u.semi_labeled_value_list.
                element_types[element_num];
        assert(element_type != NULL);
        assert(type_is_valid(element_type)); /* VERIFIED */
        assert(type_is_valid(map_type)); /* VERIFIED */
        assert(type_is_valid(map_type->u.map.target)); /* VERIFIED */
        element_intersection_empty = intersection_empty(element_type,
                map_type->u.map.target, &element_doubt, location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (element_doubt)
          {
            *doubt = TRUE;
          }
        else if (element_intersection_empty)
          {
            *doubt = FALSE;
            return TRUE;
          }
      }

    return FALSE;
  }

static boolean semi_labeled_and_array_intersection_empty(
        type *semi_labeled_value_list_type, type *array_type, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    size_t element_count;
    int order;
    o_integer element_count_oi;
    size_t element_num;

    assert(semi_labeled_value_list_type != NULL);
    assert(array_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
    assert(type_is_valid(array_type)); /* VERIFIED */
    assert(semi_labeled_value_list_type->kind == TK_SEMI_LABELED_VALUE_LIST);
    assert(array_type->kind == TK_ARRAY);

    *doubt = FALSE;

    element_count = semi_labeled_value_list_type->u.semi_labeled_value_list.
            element_count;

    if (element_count == 0)
        return FALSE;

    order = oi_structural_order(oi_zero, array_type->u.array.lower_bound);
    if (order == -2)
      {
        jumper_do_abort(the_jumper);
        return FALSE;
      }
    if (order < 0)
      {
        *doubt = FALSE;
        return TRUE;
      }

    oi_create_from_size_t(element_count_oi, element_count - 1);
    if (oi_out_of_memory(element_count_oi))
      {
        jumper_do_abort(the_jumper);
        return FALSE;
      }

    order = oi_structural_order(element_count_oi,
                                array_type->u.array.upper_bound);
    oi_remove_reference(element_count_oi);
    if (order == -2)
      {
        jumper_do_abort(the_jumper);
        return FALSE;
      }
    if (order > 0)
      {
        *doubt = FALSE;
        return TRUE;
      }

    for (element_num = 0; element_num < element_count; ++element_num)
      {
        type *element_type;
        boolean element_doubt;
        boolean element_intersection_empty;

        if (semi_labeled_value_list_type->u.semi_labeled_value_list.
                    element_names[element_num] != NULL)
          {
            *doubt = FALSE;
            return TRUE;
          }

        assert(type_is_valid(semi_labeled_value_list_type)); /* VERIFIED */
        element_type = semi_labeled_value_list_type->u.semi_labeled_value_list.
                element_types[element_num];
        assert(element_type != NULL);
        assert(type_is_valid(element_type)); /* VERIFIED */
        assert(type_is_valid(array_type)); /* VERIFIED */
        assert(type_is_valid(array_type->u.array.base)); /* VERIFIED */
        element_intersection_empty = intersection_empty(element_type,
                array_type->u.array.base, &element_doubt, location,
                the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (element_doubt)
          {
            *doubt = TRUE;
          }
        else if (element_intersection_empty)
          {
            *doubt = FALSE;
            return TRUE;
          }
      }

    return FALSE;
  }

static boolean semi_labeled_value_lists_intersection_empty(type *left_type,
        type *right_type, boolean *doubt, const source_location *location,
        jumper *the_jumper)
  {
    size_t left_element_count;
    size_t right_element_count;
    size_t element_num;

    assert(left_type != NULL);
    assert(right_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(left_type)); /* VERIFIED */
    assert(type_is_valid(right_type)); /* VERIFIED */
    assert(left_type->kind == TK_SEMI_LABELED_VALUE_LIST);
    assert(right_type->kind == TK_SEMI_LABELED_VALUE_LIST);

    *doubt = FALSE;

    left_element_count = left_type->u.semi_labeled_value_list.element_count;
    right_element_count = right_type->u.semi_labeled_value_list.element_count;

    element_num = 0;
    while (TRUE)
      {
        const char *left_name;
        const char *right_name;
        type *left_element_type;
        type *right_element_type;
        boolean element_doubt;
        boolean element_intersection_empty;

        if (element_num >= left_element_count)
          {
            if (element_num >= right_element_count)
                return FALSE;
            if (!(left_type->u.semi_labeled_value_list.extra_elements_allowed))
              {
                *doubt = FALSE;
                return TRUE;
              }

            if (*doubt)
                return FALSE;

            while (element_num < right_element_count)
              {
                type *element_type;

                assert(type_is_valid(right_type)); /* VERIFIED */
                element_type = right_type->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);
                assert(type_is_valid(element_type)); /* VERIFIED */
                if (possibly_nothing(element_type))
                  {
                    *doubt = TRUE;
                    return FALSE;
                  }
                ++element_num;
              }

            return FALSE;
          }

        if (element_num >= right_element_count)
          {
            if (!(right_type->u.semi_labeled_value_list.
                          extra_elements_allowed))
              {
                *doubt = FALSE;
                return TRUE;
              }

            if (*doubt)
                return FALSE;

            while (element_num < left_element_count)
              {
                type *element_type;

                assert(type_is_valid(left_type)); /* VERIFIED */
                element_type = left_type->u.semi_labeled_value_list.
                        element_types[element_num];
                assert(element_type != NULL);
                assert(type_is_valid(element_type)); /* VERIFIED */
                if (possibly_nothing(element_type))
                  {
                    *doubt = TRUE;
                    return FALSE;
                  }
                ++element_num;
              }

            return FALSE;
          }

        left_name = left_type->u.semi_labeled_value_list.element_names[
                element_num];
        right_name = right_type->u.semi_labeled_value_list.element_names[
                element_num];

        if ((left_name != NULL) && (right_name != NULL) &&
            (strcmp(left_name, right_name) != 0))
          {
            *doubt = FALSE;
            return TRUE;
          }

        assert(type_is_valid(left_type)); /* VERIFIED */
        left_element_type = left_type->u.semi_labeled_value_list.element_types[
                element_num];
        assert(type_is_valid(right_type)); /* VERIFIED */
        right_element_type = right_type->u.semi_labeled_value_list.
                element_types[element_num];
        assert(left_element_type != NULL);
        assert(right_element_type != NULL);
        assert(type_is_valid(left_element_type)); /* VERIFIED */
        assert(type_is_valid(right_element_type)); /* VERIFIED */
        element_intersection_empty = intersection_empty(left_element_type,
                right_element_type, &element_doubt, location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (element_doubt)
          {
            *doubt = TRUE;
          }
        else if (element_intersection_empty)
          {
            *doubt = FALSE;
            return TRUE;
          }

        ++element_num;
      }
  }

static boolean routine_types_intersection_empty(type *left_type,
        type *right_type, boolean *doubt, const source_location *location,
        jumper *the_jumper)
  {
    size_t left_argument_count;
    size_t right_argument_count;
    size_t argument_num;

    assert(left_type != NULL);
    assert(right_type != NULL);
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(left_type)); /* VERIFIED */
    assert(type_is_valid(right_type)); /* VERIFIED */
    assert(left_type->kind == TK_ROUTINE);
    assert(right_type->kind == TK_ROUTINE);

    *doubt = FALSE;

    left_argument_count = left_type->u.routine.argument_count;
    right_argument_count = right_type->u.routine.argument_count;

    argument_num = 0;
    while (TRUE)
      {
        const char *left_name;
        const char *right_name;
        type *left_argument_type;
        type *right_argument_type;
        boolean argument_doubt;
        boolean argument_intersection_empty;

        if (argument_num >= left_argument_count)
          {
            if (argument_num >= right_argument_count)
                return FALSE;
            if ((!(left_type->u.routine.extra_arguments_allowed)) &&
                (!(left_type->u.routine.extra_arguments_unspecified)))
              {
                *doubt = FALSE;
                return TRUE;
              }

            if (*doubt)
                return FALSE;

            return FALSE;
          }

        if (argument_num >= right_argument_count)
          {
            if ((!(right_type->u.routine.extra_arguments_allowed)) &&
                (!(right_type->u.routine.extra_arguments_unspecified)))
              {
                *doubt = FALSE;
                return TRUE;
              }

            if (*doubt)
                return FALSE;

            return FALSE;
          }

        left_name = left_type->u.routine.argument_names[argument_num];
        right_name = right_type->u.routine.argument_names[argument_num];

        if ((left_name != NULL) && (right_name != NULL) &&
            (strcmp(left_name, right_name) != 0))
          {
            *doubt = FALSE;
            return TRUE;
          }

        assert(type_is_valid(left_type)); /* VERIFIED */
        left_argument_type = left_type->u.routine.argument_types[argument_num];
        assert(type_is_valid(right_type)); /* VERIFIED */
        right_argument_type =
                right_type->u.routine.argument_types[argument_num];
        assert(left_argument_type != NULL);
        assert(right_argument_type != NULL);
        assert(type_is_valid(left_argument_type)); /* VERIFIED */
        assert(type_is_valid(right_argument_type)); /* VERIFIED */
        argument_intersection_empty = intersection_empty(left_argument_type,
                right_argument_type, &argument_doubt, location, the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return FALSE;
        if (argument_doubt)
          {
            *doubt = TRUE;
          }
        else if (argument_intersection_empty)
          {
            *doubt = FALSE;
            return TRUE;
          }

        ++argument_num;
      }
  }

static o_integer force_rational_value_to_integer(value *to_force)
  {
    rational *the_rational;
    o_integer numerator;
    o_integer denominator;
    o_integer remainder;
    o_integer result_oi;

    assert(to_force != NULL);

    assert(get_value_kind(to_force) == VK_RATIONAL);

    the_rational = rational_value_data(to_force);
    assert(the_rational != NULL);

    numerator = rational_numerator(the_rational);
    assert(!(oi_out_of_memory(numerator)));

    denominator = rational_denominator(the_rational);
    assert(!(oi_out_of_memory(denominator)));

    oi_divide(result_oi, numerator, denominator, &remainder);
    if (oi_out_of_memory(result_oi))
        return oi_null;
    assert(!(oi_out_of_memory(remainder)));
    oi_remove_reference(remainder);
    return result_oi;
  }

static value *force_value_to_map(value *to_force, type *key_type,
        type *target_type, const source_location *location, jumper *the_jumper)
  {
    value *result;

    assert(to_force != NULL);
    assert(key_type != NULL);
    assert(target_type != NULL);
    assert(the_jumper != NULL);

    assert(value_is_valid(to_force)); /* VERIFIED */
    assert(type_is_valid(key_type)); /* VERIFIED */
    assert(type_is_valid(target_type)); /* VERIFIED */

    result = force_value_to_map_by_morph(to_force, key_type, target_type,
                                         location, the_jumper);
    if (!(jumper_flowing_forward(the_jumper)))
      {
        assert(result == NULL);
        return NULL;
      }
    if (result != NULL)
        return result;

    assert(value_is_valid(to_force)); /* VERIFIED */
    assert(type_is_valid(key_type)); /* VERIFIED */
    assert(type_is_valid(target_type)); /* VERIFIED */
    return force_value_to_map_by_cloning(to_force, key_type, target_type,
                                         location, the_jumper);
  }

static value *force_value_to_map_by_morph(value *to_force, type *key_type,
        type *target_type, const source_location *location, jumper *the_jumper)
  {
    value *result_value;

    assert(to_force != NULL);
    assert(key_type != NULL);
    assert(target_type != NULL);
    assert(the_jumper != NULL);

    assert(value_is_valid(to_force)); /* VERIFIED */
    assert(type_is_valid(key_type)); /* VERIFIED */
    assert(type_is_valid(target_type)); /* VERIFIED */

    switch (get_value_kind(to_force))
      {
        case VK_MAP:
            break;
        case VK_SEMI_LABELED_VALUE_LIST:
            break;
        default:
            return NULL;
      }

    result_value = create_map_value();
    if (result_value == NULL)
      {
        jumper_do_abort(the_jumper);
        return NULL;
      }
    assert(map_value_all_keys_are_valid(result_value)); /* VERIFIED */

    switch (get_value_kind(to_force))
      {
        case VK_MAP:
          {
            size_t item_count;
            size_t item_num;

            item_count = map_value_item_count(to_force);

            for (item_num = 0; item_num < item_count; ++item_num)
              {
                if (map_value_item_is_type(to_force, item_num))
                  {
                    type *filter_type;
                    type *intersection_type;
                    value *target_value;

                    assert(value_is_valid(to_force)); /* VERIFIED */
                    filter_type = map_value_item_key_type(to_force, item_num);
                    assert(filter_type != NULL);
                    assert(type_is_valid(filter_type)); /* VERIFIED */

                    assert(type_is_valid(key_type)); /* VERIFIED */
                    intersection_type =
                            get_intersection_type(filter_type, key_type);
                    assert((intersection_type == NULL) ||
                           type_is_valid(intersection_type)); /* VERIFIED */
                    if (intersection_type == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }

                    assert(type_is_valid(intersection_type)); /* VERIFIED */

                    if (intersection_type->kind == TK_NOTHING)
                      {
                        type_remove_reference(intersection_type, the_jumper);
                        continue;
                      }

                    assert(value_is_valid(to_force)); /* VERIFIED */
                    target_value = map_value_item_target(to_force, item_num);
                    assert(value_is_valid(target_value)); /* VERIFIED */
                    assert(type_is_valid(target_type)); /* VERIFIED */
                    target_value = take_or_force_value_to_type(target_value,
                            target_type, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        type_remove_reference(intersection_type, the_jumper);
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    if (target_value == NULL)
                      {
                        type_remove_reference(intersection_type, the_jumper);
                        continue;
                      }

                    assert(map_value_all_keys_are_valid(result_value));
                            /* VERIFIED */
                    assert(type_is_valid(intersection_type)); /* VERIFIED */
                    result_value = map_value_set_filter(result_value,
                            intersection_type, target_value, location,
                            the_jumper);
                    type_remove_reference(intersection_type, the_jumper);
                    value_remove_reference(target_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if (result_value != NULL)
                            value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    assert(result_value != NULL);
                    assert(map_value_all_keys_are_valid(result_value));
                            /* VERIFIED */
                  }
                else
                  {
                    value *key_value;
                    boolean doubt;
                    boolean key_is_in;
                    value *target_value;

                    assert(value_is_valid(to_force)); /* VERIFIED */
                    key_value = map_value_item_key_value(to_force, item_num);
                    assert(key_value != NULL);
                    assert(value_is_valid(key_value)); /* VERIFIED */

                    assert(type_is_valid(key_type)); /* VERIFIED */
                    key_is_in = value_is_in_type(key_value, key_type, &doubt,
                                                 NULL, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    if (doubt)
                      {
                        location_exception(the_jumper, location,
                                EXCEPTION_TAG(force_match_indeterminate),
                                "While attempting to force a value to a type, "
                                "%s could not determine whether there was a "
                                "match or not.", interpreter_name());
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }

                    if (!key_is_in)
                        continue;

                    assert(value_is_valid(to_force)); /* VERIFIED */
                    target_value = map_value_item_target(to_force, item_num);
                    assert(value_is_valid(target_value)); /* VERIFIED */
                    assert(type_is_valid(target_type)); /* VERIFIED */
                    target_value = take_or_force_value_to_type(target_value,
                            target_type, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    if (target_value == NULL)
                        continue;

                    assert(map_value_all_keys_are_valid(result_value));
                            /* VERIFIED */
                    assert(value_is_valid(key_value)); /* VERIFIED */
                    result_value = map_value_set(result_value, key_value,
                            target_value, location, the_jumper);
                    value_remove_reference(target_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        if (result_value != NULL)
                            value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    assert(result_value != NULL);
                    assert(map_value_all_keys_are_valid(result_value));
                            /* VERIFIED */
                  }
              }

            break;
          }
        case VK_SEMI_LABELED_VALUE_LIST:
          {
            size_t component_count;
            size_t component_num;

            component_count = value_component_count(to_force);

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                o_integer key_oi;
                value *key_value;
                boolean doubt;
                boolean key_is_in;
                value *target_value;

                oi_create_from_size_t(key_oi, component_num);
                if (oi_out_of_memory(key_oi))
                  {
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }

                key_value = create_integer_value(key_oi);
                oi_remove_reference(key_oi);
                if (key_value == NULL)
                  {
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }
                assert(value_is_valid(key_value)); /* VERIFIED */

                assert(type_is_valid(key_type)); /* VERIFIED */
                key_is_in = value_is_in_type(key_value, key_type, &doubt, NULL,
                                             location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    value_remove_reference(key_value, the_jumper);
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }
                assert(!doubt);

                if (!key_is_in)
                  {
                    value_remove_reference(key_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    continue;
                  }

                assert(value_is_valid(to_force)); /* VERIFIED */
                target_value = value_component_value(to_force, component_num);
                assert(value_is_valid(target_value)); /* VERIFIED */
                assert(type_is_valid(target_type)); /* VERIFIED */
                target_value = take_or_force_value_to_type(target_value,
                        target_type, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    value_remove_reference(key_value, the_jumper);
                    value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }
                if (target_value == NULL)
                  {
                    value_remove_reference(key_value, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        value_remove_reference(result_value, the_jumper);
                        return NULL;
                      }
                    continue;
                  }

                assert(map_value_all_keys_are_valid(result_value));
                        /* VERIFIED */
                assert(value_is_valid(key_value)); /* VERIFIED */
                result_value = map_value_set(result_value, key_value,
                        target_value, location, the_jumper);
                value_remove_reference(key_value, the_jumper);
                value_remove_reference(target_value, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    if (result_value != NULL)
                        value_remove_reference(result_value, the_jumper);
                    return NULL;
                  }
                assert(result_value != NULL);
                assert(map_value_all_keys_are_valid(result_value));
                        /* VERIFIED */
              }

            break;
          }
        default:
          {
            assert(FALSE);
          }
      }

    return result_value;
  }

static value *force_value_to_map_by_cloning(value *to_force, type *key_type,
        type *target_type, const source_location *location, jumper *the_jumper)
  {
    value *clone_value;
    value *result_value;

    assert(to_force != NULL);
    assert(key_type != NULL);
    assert(target_type != NULL);
    assert(the_jumper != NULL);

    assert(value_is_valid(to_force)); /* VERIFIED */
    assert(type_is_valid(key_type)); /* VERIFIED */
    assert(type_is_valid(target_type)); /* VERIFIED */

    assert(value_is_valid(to_force)); /* VERIFIED */
    assert(type_is_valid(target_type)); /* VERIFIED */
    clone_value = take_or_force_value_to_type(to_force, target_type, location,
                                              the_jumper);
    if (clone_value == NULL)
        return NULL;

    result_value = create_map_value();
    if (result_value == NULL)
      {
        jumper_do_abort(the_jumper);
        value_remove_reference(clone_value, the_jumper);
        return NULL;
      }

    assert(map_value_all_keys_are_valid(result_value)); /* VERIFIED */
    assert(type_is_valid(key_type)); /* VERIFIED */
    result_value = map_value_set_filter(result_value, key_type, clone_value,
                                        location, the_jumper);
    if (!(jumper_flowing_forward(the_jumper)))
      {
        if (result_value != NULL)
            value_remove_reference(result_value, the_jumper);
        value_remove_reference(clone_value, the_jumper);
        return NULL;
      }
    assert(result_value != NULL);
    assert(map_value_all_keys_are_valid(result_value)); /* VERIFIED */

    value_remove_reference(clone_value, the_jumper);
    if (!(jumper_flowing_forward(the_jumper)))
      {
        value_remove_reference(result_value, the_jumper);
        return NULL;
      }
    return result_value;
  }

static value *take_or_force_value_to_type(value *to_force, type *the_type,
        const source_location *location, jumper *the_jumper)
  {
    boolean doubt;
    char *why_not;
    boolean is_in;

    assert(to_force != NULL);
    assert(the_type != NULL);
    assert(the_jumper != NULL);

    assert(value_is_valid(to_force)); /* VERIFIED */
    assert(type_is_valid(the_type)); /* VERIFIED */

    assert(type_is_valid(the_type)); /* VERIFIED */
    is_in = value_is_in_type(to_force, the_type, &doubt, &why_not, location,
                             the_jumper);
    if (!(jumper_flowing_forward(the_jumper)))
        return NULL;
    if (doubt)
      {
        location_exception(the_jumper, location,
                EXCEPTION_TAG(force_match_indeterminate),
                "While attempting to force a value to a type, %s could not "
                "determine whether there was a match or not because %s.",
                interpreter_name(), why_not);
        free(why_not);
        return NULL;
      }

    if (is_in)
      {
        value_add_reference(to_force);
        return to_force;
      }

    free(why_not);

    assert(value_is_valid(to_force)); /* VERIFIED */
    assert(type_is_valid(the_type)); /* VERIFIED */
    return force_value_to_type(to_force, the_type, location, the_jumper);
  }

static boolean value_has_fields(value *the_value)
  {
    assert(the_value != NULL);

    switch (get_value_kind(the_value))
      {
        case VK_SEMI_LABELED_VALUE_LIST:
        case VK_SEMI_LABELED_MULTI_SET:
        case VK_LEPTON:
        case VK_OBJECT:
            return TRUE;
        default:
            return FALSE;
      }
  }

static value *create_similar_field_value(value *source)
  {
    assert(source != NULL);

    switch (get_value_kind(source))
      {
        case VK_SEMI_LABELED_VALUE_LIST:
            return create_semi_labeled_value_list_value();
        case VK_SEMI_LABELED_MULTI_SET:
            return create_semi_labeled_multi_set_value();
        case VK_LEPTON:
            return create_lepton_value(value_lepton_key(source));
        case VK_OBJECT:
            return create_semi_labeled_multi_set_value();
        default:
            assert(FALSE);
            return NULL;
      }
  }

static verdict filter_fields_through_field_info(value *target, value *source,
        field_type_info *field_info, const source_location *location,
        jumper *the_jumper)
  {
    size_t field_count;
    size_t field_num;

    assert(target != NULL);
    assert(source != NULL);
    assert(field_info != NULL);
    assert(the_jumper != NULL);

    assert(value_is_valid(source)); /* VERIFIED */

    switch (get_value_kind(source))
      {
        case VK_SEMI_LABELED_VALUE_LIST:
        case VK_SEMI_LABELED_MULTI_SET:
        case VK_LEPTON:
          {
            size_t component_count;
            size_t component_num;

            component_count = value_component_count(source);

            for (component_num = 0; component_num < component_count;
                 ++component_num)
              {
                value *field_value;

                assert(value_is_valid(source)); /* VERIFIED */
                field_value = value_component_value(source, component_num);
                assert(value_is_valid(field_value)); /* VERIFIED */
                filter_field_through_field_info(target,
                        value_component_label(source, component_num),
                        field_value, field_info, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return MISSION_FAILED;
              }

            break;
          }
        case VK_OBJECT:
          {
            object *the_object;
            size_t field_count;
            size_t field_num;

            assert(value_is_valid(source)); /* VERIFIED */
            the_object = object_value_data(source);
            assert(the_object != NULL);
            assert(!(object_is_closed(the_object))); /* VERIFIED */

            assert(!(object_is_closed(the_object))); /* VERIFIED */
            field_count = object_field_count(the_object);

            for (field_num = 0; field_num < field_count; ++field_num)
              {
                value *field_value;

                assert(!(object_is_closed(the_object))); /* VERIFIED */
                field_value = object_field_read_value(the_object, field_num,
                                                      location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    assert(field_value == NULL);
                    return MISSION_FAILED;
                  }
                if (field_value == NULL)
                    continue;

                check_value_validity(field_value, location, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                  {
                    value_remove_reference(field_value, the_jumper);
                    return MISSION_FAILED;
                  }

                assert(!(object_is_closed(the_object))); /* VERIFIED */
                assert(value_is_valid(field_value)); /* VERIFIED */
                filter_field_through_field_info(target,
                        object_field_name(the_object, field_num), field_value,
                        field_info, location, the_jumper);
                value_remove_reference(field_value, the_jumper);
                if (!(jumper_flowing_forward(the_jumper)))
                    return MISSION_FAILED;
              }

            break;
          }
        default:
          {
            assert(FALSE);
            return MISSION_FAILED;
          }
      }

    field_count = field_info->field_count;

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        if (field_info->field_can_be_empty[field_num])
            continue;

        if (value_get_field(field_info->field_names[field_num], target) ==
            NULL)
          {
            return MISSION_FAILED;
          }
      }

    return MISSION_ACCOMPLISHED;
  }

static void filter_field_through_field_info(value *target,
        const char *field_name, value *field_value,
        field_type_info *field_info, const source_location *location,
        jumper *the_jumper)
  {
    value *munged_value;
    verdict the_verdict;

    assert(target != NULL);
    assert(field_value != NULL);
    assert(field_info != NULL);
    assert(the_jumper != NULL);

    assert(value_is_valid(field_value)); /* VERIFIED */

    if ((field_name == NULL) ||
        (!(exists_in_string_index(field_info->allowed_fields, field_name))))
      {
        if (!(field_info->extra_fields_allowed))
          {
            remove_value_field_ordering(target);
            return;
          }
        value_add_reference(field_value);
        munged_value = field_value;
      }
    else
      {
        size_t field_num;

        field_num = (size_t)(lookup_in_string_index(field_info->allowed_fields,
                                                    field_name));
        assert(field_num < field_info->field_count);
        assert(strcmp(field_name, field_info->field_names[field_num]) == 0);

        assert(value_is_valid(field_value)); /* VERIFIED */
        assert(type_is_valid(field_info->field_types[field_num]));
                /* VERIFIED */
        munged_value = take_or_force_value_to_type(field_value,
                field_info->field_types[field_num], location, the_jumper);
        if (munged_value == NULL)
          {
            remove_value_field_ordering(target);
            return;
          }
      }

    the_verdict = add_field(target, field_name, munged_value);
    if (the_verdict != MISSION_ACCOMPLISHED)
        jumper_do_abort(the_jumper);
    value_remove_reference(munged_value, the_jumper);
  }

static void remove_value_field_ordering(value *the_value)
  {
    assert(the_value != NULL);

    switch (get_value_kind(the_value))
      {
        case VK_SEMI_LABELED_VALUE_LIST:
            convert_semi_labeled_value_list_value_to_multi_set(the_value);
        case VK_SEMI_LABELED_MULTI_SET:
            return;
        case VK_LEPTON:
            return;
        default:
            assert(FALSE);
      }
  }

static type *find_wrapped_type(type *test_routine_type, jumper *the_jumper)
  {
    routine_instance *the_routine_instance;
    context *the_context;
    routine_declaration *the_routine_declaration;
    formal_arguments *formals;
    variable_declaration *first_formal;
    statement_block *body;
    statement *the_statement;
    expression *the_expression;
    expression *base_expression;
    type_expression *the_type_expression;
    expression *name_expression;
    variable_declaration *name_variable_declaration;
    variable_instance *name_variable_instance;
    routine_declaration *name_routine_declaration;
    routine_instance *name_routine_instance;
    lepton_key_declaration *key_declaration;
    lepton_key_instance *key_instance;

    assert(test_routine_type != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(test_routine_type)); /* VERIFIED */
    assert(test_routine_type->kind == TK_TEST_ROUTINE);

    the_routine_instance = test_routine_type->u.test_routine.test_routine;
    assert(the_routine_instance != NULL);

    assert(routine_instance_is_instantiated(the_routine_instance));
            /* VERIFIED */
    assert(!(routine_instance_scope_exited(the_routine_instance)));
            /* VERIFIED */
    the_context = routine_instance_context(the_routine_instance);
    assert(the_context != NULL);

    the_routine_declaration =
            routine_instance_declaration(the_routine_instance);
    assert(the_routine_declaration != NULL);

    formals = routine_declaration_formals(the_routine_declaration);
    assert(formals != NULL);

    if (formal_arguments_argument_count(formals) < 1)
        return NULL;

    first_formal = formal_arguments_formal_by_number(formals, 0);
    assert(first_formal != NULL);

    body = routine_declaration_body(the_routine_declaration);
    assert(body != NULL);

    if (statement_block_statement_count(body) != 1)
        return NULL;

    the_statement = statement_block_statement(body, 0);
    assert(the_statement != NULL);

    if (get_statement_kind(the_statement) != SK_RETURN)
        return NULL;

    the_expression = return_statement_return_value(the_statement);
    assert(the_expression != NULL);

    if (get_expression_kind(the_expression) != EK_IN)
        return NULL;

    base_expression = in_expression_expression(the_expression);
    assert(base_expression != NULL);

    if (get_expression_kind(base_expression) != EK_VARIABLE_REFERENCE)
        return NULL;

    if (variable_reference_expression_declaration(base_expression) !=
        first_formal)
      {
        return NULL;
      }

    the_type_expression = in_expression_type(the_expression);
    assert(the_type_expression != NULL);

    if (get_type_expression_kind(the_type_expression) != TEK_NAME)
        return NULL;

    name_expression =
            name_type_expression_name_expression(the_type_expression);
    assert(name_expression != NULL);

    switch (get_expression_kind(name_expression))
      {
        case EK_VARIABLE_REFERENCE:
          {
            value *the_value;
            type *result;

            name_variable_declaration =
                    variable_reference_expression_declaration(name_expression);
            assert(name_variable_declaration != NULL);

            name_variable_instance = find_variable_instance(the_context,
                    name_variable_declaration);
            assert(name_variable_instance != NULL);

          handle_variable:
            if (!(variable_declaration_is_immutable(
                          name_variable_declaration)))
              {
                return NULL;
              }

            if (!(variable_instance_is_instantiated(name_variable_instance)))
                return NULL;
            if (variable_instance_scope_exited(name_variable_instance))
                return NULL;

            the_value = read_variable_value(name_variable_instance, NULL,
                    get_expression_location(name_expression), the_jumper);
            if (the_value == NULL)
                return NULL;

            if (get_value_kind(the_value) != VK_TYPE)
              {
                value_remove_reference(the_value, the_jumper);
                return NULL;
              }

            result = type_value_data(the_value);
            assert(result != NULL);
            type_add_reference(result);
            value_remove_reference(the_value, the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
              {
                type_remove_reference(result, the_jumper);
                return NULL;
              }
            return result;
          }
        case EK_ROUTINE_REFERENCE:
          {
            routine_declaration_chain *name_chain;

            name_chain = routine_reference_expression_chain(name_expression);
            assert(name_chain != NULL);

            name_routine_declaration =
                    routine_declaration_chain_declaration(name_chain);
            assert(name_routine_declaration != NULL);

            name_routine_instance = find_routine_instance(the_context,
                    name_routine_declaration);
            assert(name_routine_instance != NULL);

            goto handle_chain;
          }
        case EK_LEPTON_KEY_REFERENCE:
          {
            type *result;

            key_declaration = lepton_key_reference_expression_declaration(
                    name_expression);
            assert(key_declaration != NULL);

            key_instance =
                    find_lepton_key_instance(the_context, key_declaration);
            assert(key_instance != NULL);

          handle_lepton_key:
            if (!(lepton_key_instance_is_instantiated(key_instance)))
                return NULL;
            if (lepton_key_instance_scope_exited(key_instance))
                return NULL;

            assert(lepton_key_instance_is_instantiated(key_instance));
                    /* VERIFICATION NEEDED */
            assert(!(lepton_key_instance_scope_exited(key_instance)));
                    /* VERIFICATION NEEDED */
            result = get_lepton_type(key_instance, 0, NULL, NULL, TRUE);
            if (result == NULL)
                jumper_do_abort(the_jumper);
            return result;
          }
        case EK_USE_REFERENCE:
          {
            instance *the_instance;
            routine_instance_chain *chain;
            jump_target *the_jump_target;

            find_instance_from_use_statement(
                    use_reference_expression_use_statement(name_expression),
                    use_reference_expression_used_for_num(name_expression),
                    routine_instance_context(the_routine_instance), FALSE,
                    &the_instance, &chain, &the_jump_target,
                    get_expression_location(name_expression), the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;

            if (the_instance != NULL)
              {
                assert(chain == NULL);
                assert(the_jump_target == NULL);

                switch (instance_kind(the_instance))
                  {
                    case NK_VARIABLE:
                        name_variable_instance =
                                instance_variable_instance(the_instance);
                        assert(name_variable_instance != NULL);

                        name_variable_declaration =
                                variable_instance_declaration(
                                        name_variable_instance);
                        assert(name_variable_declaration != NULL);

                        goto handle_variable;
                    case NK_ROUTINE:
                        name_routine_instance =
                                instance_routine_instance(the_instance);
                        assert(name_routine_instance != NULL);

                        name_routine_declaration =
                                routine_instance_declaration(
                                        name_routine_instance);
                        assert(name_routine_declaration != NULL);

                        goto handle_chain;
                    case NK_TAGALONG:
                        return NULL;
                    case NK_LEPTON_KEY:
                        key_instance =
                                instance_lepton_key_instance(the_instance);
                        assert(key_instance != NULL);

                        key_declaration =
                                lepton_key_instance_declaration(key_instance);
                        assert(key_declaration != NULL);

                        goto handle_lepton_key;
                    case NK_QUARK:
                        return NULL;
                    case NK_LOCK:
                        return NULL;
                    case NK_JUMP_TARGET:
                        return NULL;
                    default:
                        assert(FALSE);
                        return NULL;
                  }
              }

            if (chain != NULL)
              {
                assert(the_jump_target == NULL);

                name_routine_instance = routine_instance_chain_instance(chain);
                assert(name_routine_instance != NULL);

                name_routine_declaration =
                        routine_instance_declaration(name_routine_instance);
                assert(name_routine_declaration != NULL);

                goto handle_chain;
              }

            assert(the_jump_target != NULL);
            return NULL;
          }
        default:
          {
            return NULL;
          }
      }

      {
        type *boolean_type;
        type *routine_return_type;
        boolean doubt;
        boolean is_subset;
        formal_arguments *formals;
        size_t formal_count;
        type *result;

      handle_chain:
        if (!(routine_instance_is_instantiated(name_routine_instance)))
            return NULL;
        if (routine_instance_scope_exited(name_routine_instance))
            return NULL;

        if (routine_declaration_is_class(name_routine_declaration))
          {
            type *result;

            assert(routine_instance_is_instantiated(name_routine_instance));
                    /* VERIFIED */
            assert(!(routine_instance_scope_exited(name_routine_instance)));
                    /* VERIFIED */
            result = get_class_type(name_routine_instance);
            if (result == NULL)
                jumper_do_abort(the_jumper);
            return result;
          }

        if (!(routine_declaration_is_pure(name_routine_declaration)))
            return NULL;

        boolean_type = get_boolean_type();
        if (boolean_type == NULL)
          {
            jumper_do_abort(the_jumper);
            return NULL;
          }

        assert(routine_instance_is_instantiated(name_routine_instance));
                /* VERIFIED */
        assert(!(routine_instance_scope_exited(name_routine_instance)));
                /* VERIFIED */
        routine_return_type = routine_instance_valid_return_type(
                name_routine_instance,
                get_expression_location(name_expression), the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
          {
            assert(routine_return_type == NULL);
            return NULL;
          }

        assert(type_is_valid(routine_return_type)); /* VERIFIED */
        assert(type_is_valid(boolean_type)); /* VERIFIED */
        is_subset = type_is_subset(routine_return_type, boolean_type, &doubt,
                NULL, get_expression_location(name_expression), the_jumper);
        if (!(jumper_flowing_forward(the_jumper)))
            return NULL;
        if (doubt)
            return NULL;
        if (!is_subset)
            return NULL;

        formals = routine_declaration_formals(name_routine_declaration);
        assert(formals != NULL);

        formal_count = formal_arguments_argument_count(formals);
        if (formal_count == 0)
          {
            if (!(routine_declaration_extra_arguments_allowed(
                          name_routine_declaration)))
              {
                return NULL;
              }
          }
        else
          {
            type *first_formal_type;
            type *anything_type;
            boolean is_subset;
            boolean doubt;
            size_t formal_num;

            assert(routine_instance_is_instantiated(name_routine_instance));
                    /* VERIFIED */
            assert(!(routine_instance_scope_exited(name_routine_instance)));
                    /* VERIFIED */
            first_formal_type =
                    routine_instance_argument_type(name_routine_instance, 0);
            assert(first_formal_type != NULL);

            check_type_validity(first_formal_type,
                    get_expression_location(name_expression), the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;

            anything_type = get_anything_type();

            assert(type_is_valid(anything_type)); /* VERIFIED */
            assert(type_is_valid(first_formal_type)); /* VERIFIED */
            is_subset = type_is_subset(anything_type, first_formal_type,
                    &doubt, NULL, get_expression_location(name_expression),
                    the_jumper);
            if (!(jumper_flowing_forward(the_jumper)))
                return NULL;
            if (doubt)
                return NULL;
            if (!is_subset)
                return NULL;

            for (formal_num = 1; formal_num < formal_count; ++formal_num)
              {
                if (variable_declaration_initializer(
                            formal_arguments_formal_by_number(formals,
                                    formal_num)) == NULL)
                  {
                    return NULL;
                  }
              }
          }

        assert(routine_instance_is_instantiated(name_routine_instance));
                /* VERIFIED */
        assert(!(routine_instance_scope_exited(name_routine_instance)));
                /* VERIFIED */
        result = get_test_routine_type(name_routine_instance);
        if (result == NULL)
            jumper_do_abort(the_jumper);
        return result;
      }
  }

static boolean routine_type_fits_pattern(type *the_routine_type,
        size_t parameter_count,
        parameter_pattern_kind *parameter_pattern_kinds,
        const char **parameter_names, value **exact_parameters,
        type **parameter_lower_types, type **parameter_upper_types,
        type **result_parameter_types, boolean *doubt,
        const source_location *location, jumper *the_jumper)
  {
    size_t explicit_argument_count;
    boolean error;
    size_t post_order_count;
    size_t duplicate_formal_argument_num;
    size_t bad_name_actual_argument_num;
    size_t *post_order_array;
    size_t post_order_num;

    assert(the_routine_type != NULL);
    if (parameter_count > 0)
      {
        assert(parameter_pattern_kinds != NULL);
        assert(parameter_names != NULL);
      }
    assert(doubt != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(the_routine_type)); /* VERIFIED */
    assert(the_routine_type->kind == TK_ROUTINE);

    *doubt = FALSE;

    explicit_argument_count = the_routine_type->u.routine.argument_count;

    post_order_array = resolve_type_parameter_ordering_from_name_array(
            the_routine_type, parameter_count, parameter_names, &error,
            &post_order_count, &duplicate_formal_argument_num,
            &bad_name_actual_argument_num);
    if (error)
      {
        assert(post_order_array == NULL);
        jumper_do_abort(the_jumper);
        return FALSE;
      }

    if ((post_order_array == NULL) && (parameter_count > 0))
      {
        *doubt = TRUE;
        if (result_parameter_types != NULL)
          {
            type *anything_type;
            size_t actual_num;

            anything_type = get_anything_type();
            if (anything_type == NULL)
              {
                jumper_do_abort(the_jumper);
                return FALSE;
              }

            for (actual_num = 0; actual_num < parameter_count; ++actual_num)
              {
                assert(type_is_valid(anything_type)); /* VERIFIED */
                result_parameter_types[actual_num] = anything_type;
              }
          }
        return TRUE;
      }

    if (post_order_count > explicit_argument_count)
      {
        assert(post_order_array != NULL);
        if ((!(the_routine_type->u.routine.extra_arguments_allowed)) &&
            (!(the_routine_type->u.routine.extra_arguments_unspecified)))
          {
            *doubt = TRUE;
          }
      }

    for (post_order_num = 0; post_order_num < post_order_count;
         ++post_order_num)
      {
        size_t actual_num;

        assert(post_order_array != NULL);
        actual_num = post_order_array[post_order_num];
        assert(actual_num <= parameter_count);

        if (actual_num == parameter_count)
          {
            assert(post_order_num < explicit_argument_count);

            if (!(the_routine_type->u.routine.argument_has_defaults[
                          post_order_num]))
              {
                *doubt = TRUE;
              }
          }
        else if (post_order_num < explicit_argument_count)
          {
            type *formal_type;

            assert(type_is_valid(the_routine_type)); /* VERIFIED */
            formal_type =
                    the_routine_type->u.routine.argument_types[post_order_num];
            assert(formal_type != NULL);
            assert(type_is_valid(formal_type)); /* VERIFIED */

            if (result_parameter_types != NULL)
              {
                assert(type_is_valid(formal_type)); /* VERIFIED */
                result_parameter_types[actual_num] = formal_type;
              }

            assert(parameter_pattern_kinds != NULL);
            switch (parameter_pattern_kinds[actual_num])
              {
                case PPK_EXACT:
                  {
                    value *actual_value;
                    boolean local_doubt;
                    boolean is_in;

                    assert(exact_parameters != NULL);
                    actual_value = exact_parameters[actual_num];
                    assert(actual_value != NULL);
                    assert(value_is_valid(actual_value)); /* VERIFIED */

                    assert(type_is_valid(formal_type)); /* VERIFIED */
                    is_in = value_is_in_type(actual_value, formal_type,
                            &local_doubt, NULL, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        free(post_order_array);
                        return FALSE;
                      }

                    if (local_doubt || (!is_in))
                        *doubt = TRUE;

                    break;
                  }
                case PPK_ANY:
                  {
                    type *anything_type;
                    boolean is_in;
                    boolean local_doubt;

                    anything_type = get_anything_type();
                    if (anything_type == NULL)
                      {
                        jumper_do_abort(the_jumper);
                        free(post_order_array);
                        return FALSE;
                      }

                    assert(type_is_valid(anything_type)); /* VERIFIED */
                    assert(type_is_valid(formal_type)); /* VERIFIED */
                    is_in = type_is_subset(anything_type, formal_type,
                            &local_doubt, NULL, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        free(post_order_array);
                        return FALSE;
                      }

                    if (local_doubt || (!is_in))
                        *doubt = TRUE;

                    break;
                  }
                case PPK_TYPE:
                  {
                    type *upper_type;
                    boolean is_in;
                    boolean local_doubt;

                    assert(parameter_upper_types != NULL);
                    upper_type = parameter_upper_types[actual_num];
                    assert(upper_type != NULL);
                    assert(type_is_valid(upper_type));
                            /* VERIFICATION NEEDED */

                    assert(type_is_valid(upper_type));
                            /* VERIFICATION NEEDED */
                    assert(type_is_valid(formal_type)); /* VERIFIED */
                    is_in = type_is_subset(upper_type, formal_type,
                            &local_doubt, NULL, location, the_jumper);
                    if (!(jumper_flowing_forward(the_jumper)))
                      {
                        free(post_order_array);
                        return FALSE;
                      }

                    if (local_doubt || (!is_in))
                        *doubt = TRUE;

                    break;
                  }
                default:
                  {
                    assert(FALSE);
                  }
              }
          }
        else if (result_parameter_types != NULL)
          {
            type *anything_type;

            anything_type = get_anything_type();
            if (anything_type == NULL)
              {
                jumper_do_abort(the_jumper);
                free(post_order_array);
                return FALSE;
              }

            assert(type_is_valid(anything_type)); /* VERIFIED */
            result_parameter_types[actual_num] = anything_type;
          }
      }

    for (; post_order_num < explicit_argument_count; ++post_order_num)
      {
        if (!(the_routine_type->u.routine.argument_has_defaults[
                      post_order_num]))
          {
            *doubt = TRUE;
          }
      }

    if (post_order_array != NULL)
        free(post_order_array);

    return TRUE;
  }

static size_t *resolve_type_parameter_ordering_from_name_array(
        type *the_routine_type, size_t pre_order_count,
        const char **pre_order_actual_names, boolean *error,
        size_t *post_order_count, size_t *duplicate_formal_argument_num,
        size_t *bad_name_actual_argument_num)
  {
    size_t formal_count;
    size_t *result;
    size_t local_post_order_count;
    size_t post_order_num;
    size_t pre_order_num;

    assert(the_routine_type != NULL);
    assert((pre_order_count == 0) || (pre_order_actual_names != NULL));
    assert(error != NULL);
    assert(post_order_count != NULL);
    assert(duplicate_formal_argument_num != NULL);
    assert(bad_name_actual_argument_num != NULL);

    if (pre_order_count == 0)
      {
        *error = FALSE;
        *post_order_count = 0;
        return NULL;
      }

    formal_count = the_routine_type->u.routine.argument_count;

    result = MALLOC_ARRAY(size_t, pre_order_count + formal_count);
    if (result == NULL)
      {
        *error = TRUE;
        return NULL;
      }

    local_post_order_count = 0;
    post_order_num = 0;

    for (pre_order_num = 0; pre_order_num < pre_order_count; ++pre_order_num)
      {
        const char *label;

        label = pre_order_actual_names[pre_order_num];

        if (label != NULL)
          {
            size_t formal_num;

            for (formal_num = 0; formal_num < formal_count; ++formal_num)
              {
                const char *this_formal_name;

                this_formal_name =
                        the_routine_type->u.routine.argument_names[formal_num];
                if ((this_formal_name != NULL) &&
                    (strcmp(label, this_formal_name) == 0))
                  {
                    post_order_num = formal_num;
                    break;
                  }
              }

            if (formal_num >= formal_count)
              {
                free(result);
                *error = FALSE;
                *duplicate_formal_argument_num = formal_count;
                *bad_name_actual_argument_num = pre_order_num;
                return NULL;
              }
          }

        assert(post_order_num < pre_order_count + formal_count);

        while (local_post_order_count <= post_order_num)
          {
            assert(local_post_order_count < pre_order_count + formal_count);
            result[local_post_order_count] = pre_order_count;
            ++local_post_order_count;
          }

        if (result[post_order_num] != pre_order_count)
          {
            assert(post_order_num < formal_count);
            free(result);
            *error = FALSE;
            *duplicate_formal_argument_num = post_order_num;
            return NULL;
          }

        result[post_order_num] = pre_order_num;

        ++post_order_num;
      }

    assert(local_post_order_count <= pre_order_count + formal_count);
    *post_order_count = local_post_order_count;

    *error = FALSE;
    return result;
  }

static void print_field_type_info_with_override(field_type_info *field_info,
        boolean *item_writing_alloweds, boolean elipsis_implied,
        void (*printer)(void *data, const char *format, ...), void *data,
        void (*override)(value *the_value,
                void (*printer)(void *data, const char *format, ...),
                void *data))
  {
    size_t field_count;
    type **field_types;
    char **field_names;
    size_t field_num;

    field_count = field_info->field_count;
    field_types = field_info->field_types;
    field_names = field_info->field_names;

    (*printer)(data, "[");

    for (field_num = 0; field_num < field_count; ++field_num)
      {
        assert(field_types != NULL);
        assert(field_names != NULL);

        assert(field_types[field_num] != NULL);

        if (field_num > 0)
            (*printer)(data, ", ");

        if (field_names[field_num] != NULL)
          {
            (*printer)(data, "%s :", field_names[field_num]);
            if ((item_writing_alloweds != NULL) &&
                (!(item_writing_alloweds[field_num])))
              {
                (*printer)(data, "-");
              }
            (*printer)(data, " ");
          }

        print_type_with_override(field_types[field_num], printer, data,
                                 override, TEPP_TOP);
      }

    if (field_info->extra_fields_allowed && !elipsis_implied)
      {
        if (field_count > 0)
            (*printer)(data, ", ");
        (*printer)(data, "...");
      }

    (*printer)(data, "]");
  }

static boolean type_in_doubt(boolean *doubt_pointer, char **why_not,
                             jumper *the_jumper, const char *format, ...)
  {
    assert(doubt_pointer != NULL);
    assert(the_jumper != NULL);
    assert(format != NULL);

    *doubt_pointer = TRUE;

    if (why_not != NULL)
      {
        va_list ap;

        va_start(ap, format);
        *why_not = vallocate_printf(format, ap);
        va_end(ap);
        if (*why_not == NULL)
            jumper_do_abort(the_jumper);
      }

    return FALSE;
  }

static boolean type_in_no_doubt(boolean is_in, boolean *doubt_pointer,
        char **why_not, jumper *the_jumper, const char *format, ...)
  {
    assert(doubt_pointer != NULL);
    assert(the_jumper != NULL);
    assert(is_in || (format != NULL));

    *doubt_pointer = FALSE;

    if ((!is_in) && (why_not != NULL))
      {
        va_list ap;

        va_start(ap, format);
        *why_not = vallocate_printf(format, ap);
        va_end(ap);
        if (*why_not == NULL)
            jumper_do_abort(the_jumper);
      }

    return is_in;
  }

static validator *validator_add_field_type_info(validator *base,
                                                field_type_info *field_info)
  {
    validator *result;
    size_t field_count;
    size_t field_num;

    assert(base != NULL);
    assert(field_info != NULL);

    result = base;

    field_count = field_info->field_count;
    for (field_num = 0; field_num < field_count; ++field_num)
      {
        result = validator_add_validator(result,
                type_validator(field_info->field_types[field_num]));
        if (result == NULL)
            return NULL;
      }

    return result;
  }

static expression *shift_type_function_expression(void)
  {
    GRAB_SYSTEM_LOCK(saved_shift_type_function_expression_lock);

    if (saved_shift_type_function_expression != NULL)
      {
        RELEASE_SYSTEM_LOCK(saved_shift_type_function_expression_lock);
        return saved_shift_type_function_expression;
      }

    saved_shift_type_function_expression =
             parse_stand_alone_immediate_expression(
        "function(ageless base, ageless box, ageless shift_amount)\n"
        "  (type <<pure function(x) returns {1 == 1, 1 == 0}\n"
        "            ((x in box) && ((x + shift_amount) in base))>>)");

    RELEASE_SYSTEM_LOCK(saved_shift_type_function_expression_lock);

    return saved_shift_type_function_expression;
  }

static value *shift_type_function_value(jumper *the_jumper)
  {
    expression *the_expression;

    assert(the_jumper != NULL);

    GRAB_SYSTEM_LOCK(saved_shift_type_function_value_lock);
    if (saved_shift_type_function_value != NULL)
      {
        RELEASE_SYSTEM_LOCK(saved_shift_type_function_value_lock);
        return saved_shift_type_function_value;
      }

    the_expression = shift_type_function_expression();
    if (the_expression == NULL)
      {
        RELEASE_SYSTEM_LOCK(saved_shift_type_function_value_lock);
        jumper_do_abort(the_jumper);
        return NULL;
      }

    saved_shift_type_function_value =
            evaluate_expression_without_context(the_expression, the_jumper);

    RELEASE_SYSTEM_LOCK(saved_shift_type_function_value_lock);

    return saved_shift_type_function_value;
  }

static boolean range_is_finite(o_integer lower_bound, o_integer upper_bound)
  {
    assert(!(oi_out_of_memory(lower_bound)));
    assert(!(oi_out_of_memory(upper_bound)));

    switch (oi_kind(lower_bound))
      {
        case IIK_FINITE:
            switch (oi_kind(upper_bound))
              {
                case IIK_FINITE:
                    return TRUE;
                case IIK_POSITIVE_INFINITY:
                    return FALSE;
                case IIK_NEGATIVE_INFINITY:
                    assert(FALSE);
                    return FALSE;
                case IIK_UNSIGNED_INFINITY:
                case IIK_ZERO_ZERO:
                default:
                    assert(FALSE);
                    return FALSE;
              }
        case IIK_POSITIVE_INFINITY:
            switch (oi_kind(upper_bound))
              {
                case IIK_FINITE:
                    assert(FALSE);
                    return FALSE;
                case IIK_POSITIVE_INFINITY:
                    return TRUE;
                case IIK_NEGATIVE_INFINITY:
                    assert(FALSE);
                    return FALSE;
                case IIK_UNSIGNED_INFINITY:
                case IIK_ZERO_ZERO:
                default:
                    assert(FALSE);
                    return FALSE;
              }
        case IIK_NEGATIVE_INFINITY:
            switch (oi_kind(upper_bound))
              {
                case IIK_FINITE:
                    return FALSE;
                case IIK_POSITIVE_INFINITY:
                    return FALSE;
                case IIK_NEGATIVE_INFINITY:
                    return TRUE;
                case IIK_UNSIGNED_INFINITY:
                case IIK_ZERO_ZERO:
                default:
                    assert(FALSE);
                    return FALSE;
              }
        case IIK_UNSIGNED_INFINITY:
        case IIK_ZERO_ZERO:
        default:
            assert(FALSE);
            return FALSE;
      }
  }

static boolean type_not_subset_because_value_kinds_different(type *small,
        type *big, boolean *doubt_pointer, char **why_not, jumper *the_jumper)
  {
    assert(small != NULL);
    assert(big != NULL);
    assert(doubt_pointer != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(small)); /* VERIFIED */
    assert(type_is_valid(big)); /* VERIFIED */

    return type_in_no_doubt(FALSE, doubt_pointer, why_not, the_jumper,
            "the candidate sub-type is %s and the candidate super-type is %s, "
            "and the former includes %s values while the later does not",
            type_brief_description(small), type_brief_description(big),
            type_value_kind_description(small));
  }

static const char *type_brief_description(type *the_type)
  {
    switch (the_type->kind)
      {
        case TK_INTEGER:
            return "the type of all integers";
        case TK_RATIONAL:
            return "the type of all rationals";
        case TK_ANY_REGULAR_EXPRESSION:
            return "the type of all regular expressions";
        case TK_ANY_QUARK:
            return "the type of all quarks";
        case TK_ANY_LEPTON:
            return "the type of all leptons";
        case TK_LEPTON_KEY:
            return "the type of all lepton keys";
        case TK_JUMP_TARGET:
            return "the type of all jump targets";
        case TK_ANY_CLASS:
            return "the type of all classes";
        case TK_OBJECT:
            return "the type of all objects";
        case TK_TAGALONG_KEY:
            return "the type of all tagalong keys";
        case TK_LOCK:
            return "the type of all locks";
        case TK_STRING:
            return "the type of all strings";
        case TK_CHARACTER:
            return "the type of all characters";
        case TK_ARRAY:
            return "an array type";
        case TK_INTEGER_RANGES:
            return "an integer type";
        case TK_RATIONAL_RANGES:
            return "a rational type";
        case TK_POINTER:
            return "a pointer type";
        case TK_TYPE:
            return "a type type";
        case TK_MAP:
            return "a map type";
        case TK_ROUTINE:
            return "a routine type";
        case TK_FIELDS:
            return "a fields type";
        case TK_LEPTON:
            return "a lepton type";
        case TK_MULTISET:
            return "a multi-set type";
        case TK_INTERFACE:
            return "an interface type";
        case TK_SEMI_LABELED_VALUE_LIST:
            return "a semi-labeled value list type";
        case TK_REGULAR_EXPRESSION:
            return "a regular expression type";
        case TK_CLASS:
            return "a class type";
        default:
            assert(FALSE);
            return NULL;
      }
  }

static const char *type_value_kind_description(type *the_type)
  {
    switch (the_type->kind)
      {
        case TK_INTEGER:
            return "integer";
        case TK_RATIONAL:
            return "rational";
        case TK_ANY_REGULAR_EXPRESSION:
            return "regular expression";
        case TK_ANY_QUARK:
            return "quark";
        case TK_ANY_LEPTON:
            return "lepton";
        case TK_LEPTON_KEY:
            return "lepton key";
        case TK_JUMP_TARGET:
            return "jump target";
        case TK_ANY_CLASS:
            return "class";
        case TK_OBJECT:
            return "object";
        case TK_TAGALONG_KEY:
            return "tagalong key";
        case TK_LOCK:
            return "lock";
        case TK_STRING:
            return "string";
        case TK_CHARACTER:
            return "character";
        case TK_ARRAY:
            return "map";
        case TK_INTEGER_RANGES:
            return "integer";
        case TK_RATIONAL_RANGES:
            return "rational";
        case TK_POINTER:
            return "pointer";
        case TK_TYPE:
            return "type";
        case TK_MAP:
            return "map";
        case TK_ROUTINE:
            return "routine";
        case TK_FIELDS:
            return "semi-labeled value list";
        case TK_LEPTON:
            return "lepton";
        case TK_MULTISET:
            return "multi-set";
        case TK_INTERFACE:
            return "semi-labeled value list";
        case TK_SEMI_LABELED_VALUE_LIST:
            return "semi-labeled value list";
        case TK_REGULAR_EXPRESSION:
            return "string";
        case TK_CLASS:
            return "object";
        default:
            assert(FALSE);
            return NULL;
      }
  }

static boolean type_not_subset_unless_empty_different_kinds(type *small,
        type *big, boolean *doubt_pointer, char **why_not, jumper *the_jumper)
  {
    assert(small != NULL);
    assert(big != NULL);
    assert(doubt_pointer != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(small)); /* VERIFIED */
    assert(type_is_valid(big)); /* VERIFIED */

    return type_not_subset_unless_empty_different_kinds_with_kind(small, big,
            type_value_kind_description(small), doubt_pointer, why_not,
            the_jumper);
  }

static boolean type_not_subset_unless_empty_different_kinds_with_kind(
        type *small, type *big, const char *missing_value_kind_description,
        boolean *doubt_pointer, char **why_not, jumper *the_jumper)
  {
    assert(small != NULL);
    assert(big != NULL);
    assert(missing_value_kind_description != NULL);
    assert(doubt_pointer != NULL);
    assert(the_jumper != NULL);

    assert(type_is_valid(small)); /* VERIFIED */
    assert(type_is_valid(big)); /* VERIFIED */

    assert(type_is_valid(small)); /* VERIFIED */
    if (possibly_nothing(small))
      {
        return type_in_doubt(doubt_pointer, why_not, the_jumper,
                "the candidate sub-type is %s and the candidate super-type is "
                "%s, and if the former is non-empty it includes %s values "
                "while the later does not, but %s is unable to determine "
                "whether the former is empty", type_brief_description(small),
                type_brief_description(big), missing_value_kind_description,
                interpreter_name());
      }
    else
      {
        return type_in_no_doubt(FALSE, doubt_pointer, why_not, the_jumper,
                "the candidate sub-type is %s and the candidate super-type is "
                "%s, and the former includes %s values while the later does "
                "not", type_brief_description(small),
                type_brief_description(big), missing_value_kind_description);
      }
  }

static void print_rational(rational *to_print,
        void (*printer)(void *data, const char *format, ...), void *data)
  {
    print_oi(rational_numerator(to_print), printer, data);
    if (!(rational_is_integer(to_print)))
      {
        (*printer)(data, "/");
        print_oi(rational_denominator(to_print), printer, data);
      }
  }

static o_integer integer_between_rationals(rational *lower, rational *upper,
        boolean lower_inclusive, boolean upper_inclusive, boolean *error)
  {
    return minimum_integer_between_rationals(lower, upper, lower_inclusive,
                                             upper_inclusive, error);
  }

static o_integer minimum_integer_between_rationals(rational *lower,
        rational *upper, boolean lower_inclusive, boolean upper_inclusive,
        boolean *error)
  {
    o_integer lower_numerator;
    o_integer result;
    boolean ok;

    assert(lower != NULL);
    assert(upper != NULL);
    assert(error != NULL);

    lower_numerator = rational_numerator(lower);

    if (rational_is_integer(lower))
      {
        if (lower_inclusive)
          {
            oi_add_reference(lower_numerator);
            *error = FALSE;
            return lower_numerator;
          }

        oi_add(result, lower_numerator, oi_one);
      }
    else
      {
        boolean is_negative;
        o_integer remainder;
        o_integer divisor;

        is_negative = oi_is_negative(lower_numerator);

        if (is_negative)
          {
            oi_negate(lower_numerator, lower_numerator);
            if (oi_out_of_memory(lower_numerator))
              {
                *error = TRUE;
                return oi_null;
              }
          }
        else
          {
            oi_add_reference(lower_numerator);
          }

        oi_divide(divisor, lower_numerator, rational_denominator(lower),
                  &remainder);
        oi_remove_reference(lower_numerator);
        if (oi_out_of_memory(divisor))
          {
            *error = TRUE;
            return oi_null;
          }

        oi_remove_reference(remainder);

        if (is_negative)
          {
            oi_negate(result, divisor);
          }
        else
          {
            oi_add(result, divisor, oi_one);
          }
        oi_remove_reference(divisor);
      }

    if (oi_out_of_memory(result))
      {
        *error = TRUE;
        return oi_null;
      }

    if (upper_inclusive)
        ok = !(rational_less_than_integer(upper, result, error));
    else
        ok = integer_less_than_rational(result, upper, error);
    if (*error)
      {
        oi_remove_reference(result);
        return oi_null;
      }
    if (!ok)
      {
        oi_remove_reference(result);
        return oi_null;
      }

    return result;
  }

static o_integer maximum_integer_between_rationals(rational *lower,
        rational *upper, boolean lower_inclusive, boolean upper_inclusive,
        boolean *error)
  {
    o_integer upper_numerator;
    o_integer result;
    boolean ok;

    assert(lower != NULL);
    assert(upper != NULL);
    assert(error != NULL);

    upper_numerator = rational_numerator(upper);

    if (rational_is_integer(upper))
      {
        if (upper_inclusive)
          {
            oi_add_reference(upper_numerator);
            *error = FALSE;
            return upper_numerator;
          }

        oi_subtract(result, upper_numerator, oi_one);
      }
    else
      {
        result = non_integer_rational_ceiling(upper);
      }

    if (oi_out_of_memory(result))
      {
        *error = TRUE;
        return oi_null;
      }

    if (lower_inclusive)
        ok = !(integer_less_than_rational(result, lower, error));
    else
        ok = rational_less_than_integer(lower, result, error);
    if (*error)
      {
        oi_remove_reference(result);
        return oi_null;
      }
    if (!ok)
      {
        oi_remove_reference(result);
        return oi_null;
      }

    return result;
  }

static o_integer non_integer_rational_ceiling(rational *the_rational)
  {
    o_integer numerator;
    boolean is_negative;
    o_integer denominator;
    o_integer remainder;
    o_integer divisor;
    o_integer sum;
    o_integer result;

    numerator = rational_numerator(the_rational);

    is_negative = oi_is_negative(numerator);

    if (is_negative)
      {
        oi_negate(numerator, numerator);
        if (oi_out_of_memory(numerator))
            return oi_null;
      }
    else
      {
        oi_add_reference(numerator);
      }

    denominator = rational_denominator(the_rational);
    oi_divide(divisor, numerator, denominator, &remainder);
    oi_remove_reference(numerator);
    if (oi_out_of_memory(divisor))
        return oi_null;

    oi_remove_reference(remainder);

    if (!is_negative)
        return divisor;

    oi_add(sum, divisor, oi_one);
    oi_remove_reference(divisor);
    if (oi_out_of_memory(sum))
        return oi_null;

    oi_negate(result, sum);
    oi_remove_reference(sum);
    return result;
  }

static boolean rational_less_than_integer(rational *left, o_integer right,
                                          boolean *error)
  {
    rational *rational_right;
    boolean result;

    rational_right = create_rational(right, oi_one);
    if (rational_right == NULL)
      {
        *error = TRUE;
        return FALSE;
      }

    result = rational_less_than(left, rational_right, error);
    rational_remove_reference(rational_right);
    return result;
  }

static boolean integer_less_than_rational(o_integer left, rational *right,
                                          boolean *error)
  {
    rational *rational_left;
    boolean result;

    rational_left = create_rational(left, oi_one);
    if (rational_left == NULL)
      {
        *error = TRUE;
        return FALSE;
      }

    result = rational_less_than(rational_left, right, error);
    rational_remove_reference(rational_left);
    return result;
  }

static void check_integer_in_type(o_integer to_check, type *big,
        boolean *doubt, char **why_not, const source_location *location,
        jumper *the_jumper, boolean *do_return, const char *which_type)
  {
    value *the_value;
    boolean local_doubt;
    char *local_why_not;
    boolean is_in;

    assert(!(oi_out_of_memory(to_check)));
    assert(big != NULL);
    assert(do_return != NULL);

    the_value = create_integer_value(to_check);
    if (the_value == NULL)
      {
        jumper_do_abort(the_jumper);
        if ((why_not != NULL) && (*doubt))
            free(*why_not);
        *do_return = TRUE;
        return;
      }

    assert(type_is_valid(big)); /* VERIFIED */
    is_in = value_is_in_type(the_value, big, &local_doubt,
            ((why_not == NULL) ? NULL : &local_why_not), location, the_jumper);
    value_remove_reference(the_value,
            ((jumper_thread(the_jumper) == NULL) ? NULL : the_jumper));
    if (!(jumper_flowing_forward(the_jumper)))
      {
        if ((why_not != NULL) && (*doubt))
            free(*why_not);
        *do_return = TRUE;
        return;
      }
    if (local_doubt)
      {
        if (why_not != NULL)
          {
            if (!*doubt)
              {
                *why_not = allocate_printf(
                        "the candidate sub-type is %s type containing the "
                        "value %I, and %s is unable to determine whether that "
                        "value is in the candidate super-type because %s",
                        which_type, to_check, interpreter_name(),
                        local_why_not);
              }
            free(local_why_not);
            if (*why_not == NULL)
              {
                jumper_do_abort(the_jumper);
                *do_return = TRUE;
                return;
              }
          }
        *doubt = TRUE;
      }
    else if (!is_in)
      {
        boolean result;

        if ((why_not != NULL) && (*doubt))
            free(*why_not);
        result = type_in_no_doubt(FALSE, doubt, why_not, the_jumper,
                "the candidate sub-type is %s type containing the value %I, "
                "which is not in the candidate super-type because %s",
                which_type, to_check, local_why_not);
        if (why_not != NULL)
            free(local_why_not);
        *do_return = TRUE;
        return;
      }
    *do_return = FALSE;
  }

static void blot_out_integer_overlapping_rational_range(
        integer_range_component *new_integer_components,
        size_t *new_integer_component_num,
        rational_range_component *new_rational_components,
        size_t *new_rational_component_num, rational_range_component *to_add,
        boolean *error)
  {
    integer_range_component *old_component;
    boolean miss;
    o_integer cut_min;
    o_integer cut_max;
    boolean lower_untouched;
    boolean upper_untouched;
    o_integer new_lower;

    assert(new_integer_components != NULL);
    assert(new_integer_component_num != NULL);
    assert(to_add != NULL);
    assert(error != NULL);

    if (*new_integer_component_num == 0)
      {
        *error = FALSE;
        return;
      }

    old_component = &(new_integer_components[*new_integer_component_num - 1]);

    miss = rational_less_than_integer(to_add->lower_bound,
                                      old_component->upper_bound, error);
    if (*error)
        return;
    if (miss)
        return;

    miss = integer_less_than_rational(old_component->lower_bound,
                                      to_add->upper_bound, error);
    if (*error)
        return;
    if (miss)
        return;

    cut_min = minimum_integer_between_rationals(to_add->lower_bound,
            to_add->upper_bound, to_add->lower_is_inclusive,
            to_add->upper_is_inclusive, error);
    if (*error)
        return;
    if (oi_out_of_memory(cut_min))
        return;

    cut_max = maximum_integer_between_rationals(to_add->lower_bound,
            to_add->upper_bound, to_add->lower_is_inclusive,
            to_add->upper_is_inclusive, error);
    if (*error)
      {
        oi_remove_reference(cut_min);
        return;
      }
    assert(!(oi_out_of_memory(cut_max)));

    if (oi_less_than(cut_max, old_component->lower_bound) ||
        oi_less_than(old_component->upper_bound, cut_min))
      {
        oi_remove_reference(cut_min);
        oi_remove_reference(cut_max);
        return;
      }

    lower_untouched = oi_less_than(old_component->lower_bound, cut_min);
    upper_untouched = oi_less_than(cut_max, old_component->upper_bound);

    if (upper_untouched)
      {
        oi_add(new_lower, cut_max, oi_one);
        if (oi_out_of_memory(new_lower))
          {
            oi_remove_reference(cut_min);
            oi_remove_reference(cut_max);
            *error = TRUE;
            return;
          }
      }

    oi_remove_reference(cut_max);

    if (lower_untouched)
      {
        o_integer new_upper;

        oi_subtract(new_upper, cut_min, oi_one);
        if (oi_out_of_memory(new_upper))
          {
            if (upper_untouched)
                oi_remove_reference(new_lower);
            oi_remove_reference(cut_min);
            *error = TRUE;
            return;
          }

        if (upper_untouched)
          {
            integer_range_component *next_component;

            if (oi_equal(new_upper, old_component->lower_bound))
              {
                add_rational_to_ranges(new_upper, new_rational_components,
                                       new_rational_component_num, error);
                oi_remove_reference(new_upper);
                oi_remove_reference(old_component->lower_bound);
                next_component = old_component;
              }
            else
              {
                o_integer new_upper_minus_one;

                oi_subtract(new_upper_minus_one, new_upper, oi_one);
                if (oi_out_of_memory(new_upper_minus_one))
                  {
                    *error = TRUE;
                    oi_remove_reference(new_lower);
                    oi_remove_reference(new_upper);
                    oi_remove_reference(cut_min);
                    return;
                  }

                if (oi_equal(new_upper_minus_one, old_component->lower_bound))
                  {
                    add_rational_to_ranges(new_upper, new_rational_components,
                                           new_rational_component_num, error);
                    if (!(*error))
                      {
                        add_rational_to_ranges(new_upper_minus_one,
                                new_rational_components,
                                new_rational_component_num, error);
                      }
                    oi_remove_reference(new_upper);
                    oi_remove_reference(old_component->lower_bound);
                    next_component = old_component;
                  }
                else
                  {
                    next_component = &(new_integer_components[
                            *new_integer_component_num]);
                    ++(*new_integer_component_num);
                    next_component->upper_bound = old_component->upper_bound;
                    old_component->upper_bound = new_upper;
                  }
                oi_remove_reference(new_upper_minus_one);
              }

            if (oi_equal(next_component->upper_bound, new_lower))
              {
                if (!(*error))
                  {
                    add_rational_to_ranges(new_lower, new_rational_components,
                                           new_rational_component_num, error);
                  }
                oi_remove_reference(next_component->upper_bound);
                oi_remove_reference(new_lower);
                --(*new_integer_component_num);
              }
            else
              {
                o_integer new_lower_plus_one;

                oi_add(new_lower_plus_one, new_lower, oi_one);
                if (oi_out_of_memory(new_lower_plus_one))
                  {
                    *error = TRUE;
                    oi_remove_reference(next_component->upper_bound);
                    oi_remove_reference(new_lower);
                    --(*new_integer_component_num);
                    oi_remove_reference(cut_min);
                    return;
                  }

                if (oi_equal(next_component->upper_bound, new_lower_plus_one))
                  {
                    if (!(*error))
                      {
                        add_rational_to_ranges(new_lower,
                                new_rational_components,
                                new_rational_component_num, error);
                      }
                    if (!(*error))
                      {
                        add_rational_to_ranges(new_lower_plus_one,
                                new_rational_components,
                                new_rational_component_num, error);
                      }
                    oi_remove_reference(next_component->upper_bound);
                    oi_remove_reference(new_lower);
                    --(*new_integer_component_num);
                  }
                else
                  {
                    next_component->lower_bound = new_lower;
                  }
                oi_remove_reference(new_lower_plus_one);
              }
          }
        else
          {
            oi_remove_reference(old_component->upper_bound);
            if (oi_equal(new_upper, old_component->lower_bound))
              {
                add_rational_to_ranges(new_upper, new_rational_components,
                                       new_rational_component_num, error);
                oi_remove_reference(new_upper);
                oi_remove_reference(old_component->lower_bound);
                --(*new_integer_component_num);
              }
            else
              {
                o_integer new_upper_minus_one;

                oi_subtract(new_upper_minus_one, new_upper, oi_one);
                if (oi_out_of_memory(new_upper_minus_one))
                  {
                    *error = TRUE;
                    oi_remove_reference(new_upper);
                    oi_remove_reference(old_component->lower_bound);
                    --(*new_integer_component_num);
                    oi_remove_reference(cut_min);
                    return;
                  }

                if (oi_equal(new_upper_minus_one, old_component->lower_bound))
                  {
                    add_rational_to_ranges(new_upper_minus_one,
                            new_rational_components,
                            new_rational_component_num, error);
                    if (!(*error))
                      {
                        add_rational_to_ranges(new_upper,
                                new_rational_components,
                                new_rational_component_num, error);
                      }
                    oi_remove_reference(new_upper);
                    oi_remove_reference(old_component->lower_bound);
                    --(*new_integer_component_num);
                  }
                else
                  {
                    old_component->upper_bound = new_upper;
                  }
                oi_remove_reference(new_upper_minus_one);
              }
          }
      }
    else
      {
        oi_remove_reference(old_component->lower_bound);
        if (upper_untouched)
          {
            if (oi_equal(new_lower, old_component->upper_bound))
              {
                add_rational_to_ranges(new_lower, new_rational_components,
                                       new_rational_component_num, error);
                oi_remove_reference(new_lower);
                oi_remove_reference(old_component->upper_bound);
                --(*new_integer_component_num);
              }
            else
              {
                o_integer new_lower_plus_one;

                oi_add(new_lower_plus_one, new_lower, oi_one);
                if (oi_out_of_memory(new_lower_plus_one))
                  {
                    *error = TRUE;
                    oi_remove_reference(new_lower);
                    oi_remove_reference(old_component->upper_bound);
                    --(*new_integer_component_num);
                    oi_remove_reference(cut_min);
                    return;
                  }

                if (oi_equal(new_lower_plus_one, old_component->upper_bound))
                  {
                    add_rational_to_ranges(new_lower, new_rational_components,
                                           new_rational_component_num, error);
                    if (!(*error))
                      {
                        add_rational_to_ranges(new_lower_plus_one,
                                new_rational_components,
                                new_rational_component_num, error);
                      }
                    oi_remove_reference(new_lower);
                    oi_remove_reference(old_component->upper_bound);
                    --(*new_integer_component_num);
                  }
                else
                  {
                    old_component->lower_bound = new_lower;
                  }
                oi_remove_reference(new_lower_plus_one);
              }
          }
        else
          {
            oi_remove_reference(old_component->upper_bound);
            --(*new_integer_component_num);
          }
      }

    oi_remove_reference(cut_min);
  }

static type *get_intersection_of_enumeration_and_integer(type *the_enum)
  {
    size_t old_value_count;
    value **old_values;
    size_t new_value_count;
    value **new_values;
    size_t old_value_num;
    type *result;

    assert(the_enum != NULL);

    assert(type_is_valid(the_enum)); /* VERIFIED */
    assert(the_enum->kind == TK_ENUMERATION);

    old_value_count = the_enum->u.enumeration.value_count;
    old_values = the_enum->u.enumeration.values;

    new_value_count = 0;

    assert(old_value_count > 0);
    new_values = MALLOC_ARRAY(value *, old_value_count);
    if (new_values == NULL)
        return NULL;

    for (old_value_num = 0; old_value_num < old_value_count; ++old_value_num)
      {
        if (get_value_kind(old_values[old_value_num]) == VK_INTEGER)
          {
            new_values[new_value_count] = old_values[old_value_num];
            ++new_value_count;
          }
      }

    result = get_enumeration_type(new_value_count, new_values);
    free(new_values);
    return result;
  }

static type *get_intersection_of_enumeration_and_rational(type *the_enum)
  {
    size_t old_value_count;
    value **old_values;
    size_t new_value_count;
    value **new_values;
    size_t old_value_num;
    type *result;

    assert(the_enum != NULL);

    assert(type_is_valid(the_enum)); /* VERIFIED */
    assert(the_enum->kind == TK_ENUMERATION);

    old_value_count = the_enum->u.enumeration.value_count;
    old_values = the_enum->u.enumeration.values;

    new_value_count = 0;

    assert(old_value_count > 0);
    new_values = MALLOC_ARRAY(value *, old_value_count);
    if (new_values == NULL)
        return NULL;

    for (old_value_num = 0; old_value_num < old_value_count; ++old_value_num)
      {
        value_kind kind;

        kind = get_value_kind(old_values[old_value_num]);
        if ((kind == VK_INTEGER) || (kind == VK_RATIONAL))
          {
            new_values[new_value_count] = old_values[old_value_num];
            ++new_value_count;
          }
      }

    result = get_enumeration_type(new_value_count, new_values);
    free(new_values);
    return result;
  }

static type *get_intersection_of_integer_ranges(type *left, type *right)
  {
    type *result;
    size_t left_component_count;
    size_t right_component_count;
    integer_range_component *left_components;
    integer_range_component *right_components;
    integer_range_component *new_components;
    size_t left_component_num;
    size_t right_component_num;
    size_t new_component_num;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_INTEGER_RANGES);
    assert(right->kind == TK_INTEGER_RANGES);

    result = create_empty_type(TK_INTEGER_RANGES);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_INTEGER);

    result->u.integer_ranges.includes_positive_infinity =
            (left->u.integer_ranges.includes_positive_infinity &&
             right->u.integer_ranges.includes_positive_infinity);
    result->u.integer_ranges.includes_negative_infinity =
            (left->u.integer_ranges.includes_negative_infinity &&
             right->u.integer_ranges.includes_negative_infinity);
    result->u.integer_ranges.includes_unsigned_infinity =
            (left->u.integer_ranges.includes_unsigned_infinity &&
             right->u.integer_ranges.includes_unsigned_infinity);
    result->u.integer_ranges.includes_zero_zero =
            (left->u.integer_ranges.includes_zero_zero &&
             right->u.integer_ranges.includes_zero_zero);

    left_component_count = left->u.integer_ranges.component_count;
    right_component_count = right->u.integer_ranges.component_count;

    left_components = left->u.integer_ranges.components;
    right_components = right->u.integer_ranges.components;

    if ((left_component_count == 0) && (right_component_count == 0))
      {
        new_components = NULL;
      }
    else
      {
        new_components = MALLOC_ARRAY(integer_range_component,
                left_component_count + right_component_count);
        if (new_components == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }
      }

    left_component_num = 0;
    right_component_num = 0;
    new_component_num = 0;

    while ((left_component_num < left_component_count) &&
           (right_component_num < right_component_count))
      {
        o_integer left_lower;
        o_integer right_lower;
        o_integer new_lower;
        o_integer left_upper;
        o_integer right_upper;
        o_integer new_upper;

        left_lower = left_components[left_component_num].lower_bound;
        right_lower = right_components[right_component_num].lower_bound;

        if (oi_less_than(left_lower, right_lower))
            new_lower = right_lower;
        else
            new_lower = left_lower;

        left_upper = left_components[left_component_num].upper_bound;
        right_upper = right_components[right_component_num].upper_bound;

        if (oi_less_than(left_upper, right_upper))
          {
            new_upper = left_upper;
            ++left_component_num;
          }
        else if (oi_equal(left_upper, right_upper))
          {
            new_upper = left_upper;
            ++left_component_num;
            ++right_component_num;
          }
        else
          {
            new_upper = right_upper;
            ++right_component_num;
          }

        if (oi_less_than(new_upper, new_lower))
            continue;

        assert(new_component_num <
               left_component_count + right_component_count);
        oi_add_reference(new_lower);
        oi_add_reference(new_upper);
        new_components[new_component_num].lower_bound = new_lower;
        new_components[new_component_num].upper_bound = new_upper;
        ++new_component_num;
      }

    assert(new_component_num <= left_component_count + right_component_count);
    result->u.integer_ranges.component_count = new_component_num;

    if (new_component_num == left_component_count + right_component_count)
      {
        result->u.integer_ranges.components = new_components;
      }
    else
      {
        integer_range_component *compact_components;

        assert(new_component_num <
               left_component_count + right_component_count);
        assert(new_component_num > 0);
        compact_components =
                MALLOC_ARRAY(integer_range_component, new_component_num);
        if (compact_components == NULL)
          {
            result->u.integer_ranges.components = new_components;
            type_remove_reference(result, NULL);
            return NULL;
          }

        memcpy(compact_components, new_components,
               new_component_num * sizeof(integer_range_component));
        free(new_components);
        result->u.integer_ranges.components = compact_components;
      }

    return result;
  }

static type *get_intersection_of_integer_and_rational_ranges(type *left,
                                                             type *right)
  {
    type *result;
    size_t left_component_count;
    size_t right_component_count;
    integer_range_component *left_components;
    rational_range_component *right_components;
    integer_range_component *new_components;
    size_t left_component_num;
    size_t right_component_num;
    size_t new_component_num;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_INTEGER_RANGES);
    assert(right->kind == TK_RATIONAL_RANGES);

    result = create_empty_type(TK_INTEGER_RANGES);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_INTEGER);

    result->u.integer_ranges.includes_positive_infinity =
            (left->u.integer_ranges.includes_positive_infinity &&
             right->u.rational_ranges.includes_positive_infinity);
    result->u.integer_ranges.includes_negative_infinity =
            (left->u.integer_ranges.includes_negative_infinity &&
             right->u.rational_ranges.includes_negative_infinity);
    result->u.integer_ranges.includes_unsigned_infinity =
            (left->u.integer_ranges.includes_unsigned_infinity &&
             right->u.rational_ranges.includes_unsigned_infinity);
    result->u.integer_ranges.includes_zero_zero =
            (left->u.integer_ranges.includes_zero_zero &&
             right->u.rational_ranges.includes_zero_zero);

    left_component_count = left->u.integer_ranges.component_count;
    right_component_count = right->u.rational_ranges.component_count;

    left_components = left->u.integer_ranges.components;
    right_components = right->u.rational_ranges.components;

    if ((left_component_count == 0) && (right_component_count == 0))
      {
        new_components = NULL;
      }
    else
      {
        new_components = MALLOC_ARRAY(integer_range_component,
                left_component_count + right_component_count);
        if (new_components == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }
      }

    left_component_num = 0;
    right_component_num = 0;
    new_component_num = 0;

    while ((left_component_num < left_component_count) &&
           (right_component_num < right_component_count))
      {
        o_integer left_lower;
        o_integer left_upper;
        rational *right_lower_rational;
        rational *right_upper_rational;
        boolean right_lower_is_inclusive;
        boolean right_upper_is_inclusive;
        boolean error;
        o_integer right_lower_integer;
        o_integer right_upper_integer;
        o_integer new_lower;
        o_integer new_upper;

        left_lower = left_components[left_component_num].lower_bound;
        left_upper = left_components[left_component_num].upper_bound;

        right_lower_rational =
                right_components[right_component_num].lower_bound;
        right_upper_rational =
                right_components[right_component_num].upper_bound;
        right_lower_is_inclusive =
                right_components[right_component_num].lower_is_inclusive;
        right_upper_is_inclusive =
                right_components[right_component_num].upper_is_inclusive;

        right_lower_integer = minimum_integer_between_rationals(
                right_lower_rational, right_upper_rational,
                right_lower_is_inclusive, right_upper_is_inclusive, &error);
        if (error)
          {
            result->u.integer_ranges.component_count = new_component_num;
            if (new_component_num == 0)
              {
                result->u.integer_ranges.components = NULL;
                free(new_components);
              }
            else
              {
                result->u.integer_ranges.components = new_components;
              }
            type_remove_reference(result, NULL);
            return NULL;
          }
        if (oi_out_of_memory(right_lower_integer))
          {
            ++right_component_num;
            continue;
          }

        right_upper_integer = maximum_integer_between_rationals(
                right_lower_rational, right_upper_rational,
                right_lower_is_inclusive, right_upper_is_inclusive, &error);
        if (error)
          {
            oi_remove_reference(right_lower_integer);
            result->u.integer_ranges.component_count = new_component_num;
            if (new_component_num == 0)
              {
                result->u.integer_ranges.components = NULL;
                free(new_components);
              }
            else
              {
                result->u.integer_ranges.components = new_components;
              }
            type_remove_reference(result, NULL);
            return NULL;
          }
        assert(!(oi_out_of_memory(right_upper_integer)));

        if (oi_less_than(left_lower, right_lower_integer))
          {
            new_lower = right_lower_integer;
          }
        else
          {
            oi_add_reference(left_lower);
            oi_remove_reference(right_lower_integer);
            new_lower = left_lower;
          }

        if (oi_less_than(right_upper_integer, left_upper))
          {
            new_upper = right_upper_integer;
            ++right_component_num;
          }
        else
          {
            oi_add_reference(left_upper);
            oi_remove_reference(right_upper_integer);
            new_upper = left_upper;
            ++left_component_num;
            if (oi_equal(left_upper, right_upper_integer))
                ++right_component_num;
          }

        if (oi_less_than(new_upper, new_lower))
          {
            oi_remove_reference(new_lower);
            oi_remove_reference(new_upper);
            continue;
          }

        assert(new_component_num <
               left_component_count + right_component_count);
        new_components[new_component_num].lower_bound = new_lower;
        new_components[new_component_num].upper_bound = new_upper;
        ++new_component_num;
      }

    assert(new_component_num <= left_component_count + right_component_count);
    result->u.integer_ranges.component_count = new_component_num;

    if (new_component_num == left_component_count + right_component_count)
      {
        result->u.integer_ranges.components = new_components;
      }
    else
      {
        integer_range_component *compact_components;

        assert(new_component_num <
               left_component_count + right_component_count);
        assert(new_component_num > 0);
        compact_components =
                MALLOC_ARRAY(integer_range_component, new_component_num);
        if (compact_components == NULL)
          {
            result->u.integer_ranges.components = new_components;
            type_remove_reference(result, NULL);
            return NULL;
          }

        memcpy(compact_components, new_components,
               new_component_num * sizeof(integer_range_component));
        free(new_components);
        result->u.integer_ranges.components = compact_components;
      }

    return result;
  }

static type *get_intersection_of_rational_ranges(type *left, type *right)
  {
    type *result;
    size_t left_component_count;
    size_t right_component_count;
    rational_range_component *left_components;
    rational_range_component *right_components;
    rational_range_component *new_components;
    size_t left_component_num;
    size_t right_component_num;
    size_t new_component_num;
    boolean is_all_integer;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_RATIONAL_RANGES);
    assert(right->kind == TK_RATIONAL_RANGES);

    result = create_empty_type(TK_RATIONAL_RANGES);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = (VK_BIT(VK_INTEGER) | VK_BIT(VK_RATIONAL));

    result->u.rational_ranges.includes_positive_infinity =
            (left->u.rational_ranges.includes_positive_infinity &&
             right->u.rational_ranges.includes_positive_infinity);
    result->u.rational_ranges.includes_negative_infinity =
            (left->u.rational_ranges.includes_negative_infinity &&
             right->u.rational_ranges.includes_negative_infinity);
    result->u.rational_ranges.includes_unsigned_infinity =
            (left->u.rational_ranges.includes_unsigned_infinity &&
             right->u.rational_ranges.includes_unsigned_infinity);
    result->u.rational_ranges.includes_zero_zero =
            (left->u.rational_ranges.includes_zero_zero &&
             right->u.rational_ranges.includes_zero_zero);

    left_component_count = left->u.rational_ranges.component_count;
    right_component_count = right->u.rational_ranges.component_count;

    left_components = left->u.rational_ranges.components;
    right_components = right->u.rational_ranges.components;

    if ((left_component_count == 0) && (right_component_count == 0))
      {
        new_components = NULL;
      }
    else
      {
        new_components = MALLOC_ARRAY(rational_range_component,
                left_component_count + right_component_count);
        if (new_components == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }
      }

    left_component_num = 0;
    right_component_num = 0;
    new_component_num = 0;

    is_all_integer = TRUE;

    while ((left_component_num < left_component_count) &&
           (right_component_num < right_component_count))
      {
        rational *left_lower;
        rational *right_lower;
        boolean error;
        boolean left_lower_is_less;
        rational *new_lower;
        boolean lower_is_inclusive;
        rational *left_upper;
        rational *right_upper;
        boolean left_upper_is_less;
        rational *new_upper;
        boolean upper_is_inclusive;
        boolean empty;

        left_lower = left_components[left_component_num].lower_bound;
        right_lower = right_components[right_component_num].lower_bound;
        left_lower_is_less =
                rational_less_than(left_lower, right_lower, &error);
        if (error)
          {
            result->u.rational_ranges.component_count = new_component_num;
            if (new_component_num == 0)
              {
                result->u.rational_ranges.components = NULL;
                free(new_components);
              }
            else
              {
                result->u.rational_ranges.components = new_components;
              }
            type_remove_reference(result, NULL);
            return NULL;
          }

        if (left_lower_is_less)
          {
            new_lower = right_lower;
            lower_is_inclusive =
                    right_components[right_component_num].lower_is_inclusive;
          }
        else if (rationals_are_equal(left_lower, right_lower))
          {
            new_lower = left_lower;
            lower_is_inclusive =
                    (left_components[left_component_num].lower_is_inclusive &&
                     right_components[right_component_num].lower_is_inclusive);
          }
        else
          {
            new_lower = left_lower;
            lower_is_inclusive =
                    left_components[left_component_num].lower_is_inclusive;
          }

        left_upper = left_components[left_component_num].upper_bound;
        right_upper = right_components[right_component_num].upper_bound;
        left_upper_is_less =
                rational_less_than(left_upper, right_upper, &error);
        if (error)
          {
            result->u.rational_ranges.component_count = new_component_num;
            if (new_component_num == 0)
              {
                result->u.rational_ranges.components = NULL;
                free(new_components);
              }
            else
              {
                result->u.rational_ranges.components = new_components;
              }
            type_remove_reference(result, NULL);
            return NULL;
          }

        if (left_upper_is_less)
          {
            new_upper = left_upper;
            upper_is_inclusive =
                    left_components[left_component_num].upper_is_inclusive;
            ++left_component_num;
          }
        else if (rationals_are_equal(left_upper, right_upper))
          {
            new_upper = left_upper;
            upper_is_inclusive =
                    (left_components[left_component_num].upper_is_inclusive &&
                     right_components[right_component_num].upper_is_inclusive);
            ++left_component_num;
            ++right_component_num;
          }
        else
          {
            new_upper = right_upper;
            upper_is_inclusive =
                    right_components[right_component_num].upper_is_inclusive;
            ++right_component_num;
          }

        empty = rational_less_than(new_upper, new_lower, &error);
        if (error)
          {
            result->u.rational_ranges.component_count = new_component_num;
            if (new_component_num == 0)
              {
                result->u.rational_ranges.components = NULL;
                free(new_components);
              }
            else
              {
                result->u.rational_ranges.components = new_components;
              }
            type_remove_reference(result, NULL);
            return NULL;
          }

        if (empty ||
            ((!(lower_is_inclusive && upper_is_inclusive)) &&
             (rationals_are_equal(new_upper, new_lower))))
          {
            continue;
          }

        if (is_all_integer &&
            ((!(rationals_are_equal(new_upper, new_lower))) ||
             (!(rational_is_integer(new_upper)))))
          {
            is_all_integer = FALSE;
          }

        assert(new_component_num <
               left_component_count + right_component_count);
        rational_add_reference(new_lower);
        rational_add_reference(new_upper);
        new_components[new_component_num].lower_bound = new_lower;
        new_components[new_component_num].upper_bound = new_upper;
        new_components[new_component_num].lower_is_inclusive =
                lower_is_inclusive;
        new_components[new_component_num].upper_is_inclusive =
                upper_is_inclusive;
        ++new_component_num;
      }

    assert(new_component_num <= left_component_count + right_component_count);
    result->u.rational_ranges.component_count = new_component_num;

    if (is_all_integer)
      {
        value **values;
        size_t value_num;
        type *enumeration_result;

        if (new_component_num == 0)
          {
            result->u.rational_ranges.components = NULL;
            free(new_components);
          }
        else
          {
            result->u.rational_ranges.components = new_components;
          }

        values = MALLOC_ARRAY(value *, new_component_num + 5);
        if (values == NULL)
          {
            type_remove_reference(result, NULL);
            return NULL;
          }

        for (value_num = 0; value_num < new_component_num; ++value_num)
          {
            values[value_num] = create_integer_value(rational_numerator(
                    new_components[value_num].lower_bound));
            if (values[value_num] == NULL)
              {
                type_remove_reference(result, NULL);
                while (value_num > 0)
                  {
                    --value_num;
                    value_remove_reference(values[value_num], NULL);
                  }
                free(values);
                return NULL;
              }
          }

        if (result->u.rational_ranges.includes_positive_infinity)
          {
            values[new_component_num] =
                    create_integer_value(oi_positive_infinity);
            if (values[new_component_num] == NULL)
              {
                type_remove_reference(result, NULL);
                for (value_num = 0; value_num < new_component_num; ++value_num)
                    value_remove_reference(values[value_num], NULL);
                free(values);
                return NULL;
              }
            ++new_component_num;
          }

        if (result->u.rational_ranges.includes_negative_infinity)
          {
            values[new_component_num] =
                    create_integer_value(oi_negative_infinity);
            if (values[new_component_num] == NULL)
              {
                type_remove_reference(result, NULL);
                for (value_num = 0; value_num < new_component_num; ++value_num)
                    value_remove_reference(values[value_num], NULL);
                free(values);
                return NULL;
              }
            ++new_component_num;
          }

        if (result->u.rational_ranges.includes_unsigned_infinity)
          {
            values[new_component_num] =
                    create_integer_value(oi_unsigned_infinity);
            if (values[new_component_num] == NULL)
              {
                type_remove_reference(result, NULL);
                for (value_num = 0; value_num < new_component_num; ++value_num)
                    value_remove_reference(values[value_num], NULL);
                free(values);
                return NULL;
              }
            ++new_component_num;
          }

        if (result->u.rational_ranges.includes_zero_zero)
          {
            values[new_component_num] = create_integer_value(oi_zero_zero);
            if (values[new_component_num] == NULL)
              {
                type_remove_reference(result, NULL);
                for (value_num = 0; value_num < new_component_num; ++value_num)
                    value_remove_reference(values[value_num], NULL);
                free(values);
                return NULL;
              }
            ++new_component_num;
          }

        type_remove_reference(result, NULL);

        enumeration_result = get_enumeration_type(new_component_num, values);
        for (value_num = 0; value_num < new_component_num; ++value_num)
            value_remove_reference(values[value_num], NULL);
        free(values);
        return enumeration_result;
      }

    if (new_component_num == left_component_count + right_component_count)
      {
        result->u.rational_ranges.components = new_components;
      }
    else
      {
        rational_range_component *compact_components;

        assert(new_component_num <
               left_component_count + right_component_count);
        assert(new_component_num > 0);
        compact_components =
                MALLOC_ARRAY(rational_range_component, new_component_num);
        if (compact_components == NULL)
          {
            result->u.rational_ranges.components = new_components;
            type_remove_reference(result, NULL);
            return NULL;
          }

        memcpy(compact_components, new_components,
               new_component_num * sizeof(rational_range_component));
        free(new_components);
        result->u.rational_ranges.components = compact_components;
      }

    return result;
  }

static type *get_intersection_of_rational_ranges_and_integer(
        type *rational_type)
  {
    type *result;
    size_t source_component_count;
    rational_range_component *source_components;
    integer_range_component *new_components;
    size_t new_component_num;
    size_t source_component_num;

    assert(rational_type != NULL);

    assert(type_is_valid(rational_type)); /* VERIFIED */

    assert(rational_type->kind == TK_RATIONAL_RANGES);

    result = create_empty_type(TK_INTEGER_RANGES);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_INTEGER);

    result->u.integer_ranges.includes_positive_infinity =
            rational_type->u.rational_ranges.includes_positive_infinity;
    result->u.integer_ranges.includes_negative_infinity =
            rational_type->u.rational_ranges.includes_negative_infinity;
    result->u.integer_ranges.includes_unsigned_infinity =
            rational_type->u.rational_ranges.includes_unsigned_infinity;
    result->u.integer_ranges.includes_zero_zero =
            rational_type->u.rational_ranges.includes_zero_zero;

    source_component_count = rational_type->u.rational_ranges.component_count;
    source_components = rational_type->u.rational_ranges.components;

    if (source_component_count == 0)
      {
        new_components = NULL;
      }
    else
      {
        new_components =
                MALLOC_ARRAY(integer_range_component, source_component_count);
        if (new_components == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }
      }

    new_component_num = 0;

    for (source_component_num = 0;
         source_component_num < source_component_count; ++source_component_num)
      {
        rational *lower_rational;
        rational *upper_rational;
        boolean lower_is_inclusive;
        boolean upper_is_inclusive;
        boolean error;
        o_integer lower_integer;
        o_integer upper_integer;

        lower_rational = source_components[source_component_num].lower_bound;
        upper_rational = source_components[source_component_num].upper_bound;
        lower_is_inclusive =
                source_components[source_component_num].lower_is_inclusive;
        upper_is_inclusive =
                source_components[source_component_num].upper_is_inclusive;

        lower_integer = minimum_integer_between_rationals(lower_rational,
                upper_rational, lower_is_inclusive, upper_is_inclusive,
                &error);
        if (error)
          {
            result->u.integer_ranges.component_count = new_component_num;
            if (new_component_num == 0)
              {
                result->u.integer_ranges.components = NULL;
                free(new_components);
              }
            else
              {
                result->u.integer_ranges.components = new_components;
              }
            type_remove_reference(result, NULL);
            return NULL;
          }
        if (oi_out_of_memory(lower_integer))
            continue;

        upper_integer = maximum_integer_between_rationals(lower_rational,
                upper_rational, lower_is_inclusive, upper_is_inclusive,
                &error);
        if (error)
          {
            oi_remove_reference(lower_integer);
            result->u.integer_ranges.component_count = new_component_num;
            if (new_component_num == 0)
              {
                result->u.integer_ranges.components = NULL;
                free(new_components);
              }
            else
              {
                result->u.integer_ranges.components = new_components;
              }
            type_remove_reference(result, NULL);
            return NULL;
          }
        assert(!(oi_out_of_memory(upper_integer)));

        if (oi_less_than(upper_integer, lower_integer))
          {
            oi_remove_reference(lower_integer);
            oi_remove_reference(upper_integer);
            continue;
          }

        if (new_component_num > 0)
          {
            o_integer diff;
            boolean greater_than_one;

            oi_subtract(diff, lower_integer,
                        new_components[new_component_num - 1].upper_bound);
            if (oi_out_of_memory(diff))
              {
                oi_remove_reference(lower_integer);
                oi_remove_reference(upper_integer);
                result->u.integer_ranges.component_count = new_component_num;
                result->u.integer_ranges.components = new_components;
                type_remove_reference(result, NULL);
                return NULL;
              }

            greater_than_one = oi_less_than(oi_one, diff);
            oi_remove_reference(diff);
            if (!greater_than_one)
              {
                oi_remove_reference(lower_integer);
                oi_remove_reference(
                        new_components[new_component_num - 1].upper_bound);
                new_components[new_component_num - 1].upper_bound =
                        upper_integer;
                continue;
              }
          }

        assert(new_component_num < source_component_count);
        new_components[new_component_num].lower_bound = lower_integer;
        new_components[new_component_num].upper_bound = upper_integer;
        ++new_component_num;
      }

    assert(new_component_num <= source_component_count);
    result->u.integer_ranges.component_count = new_component_num;

    if (new_component_num == source_component_count)
      {
        result->u.integer_ranges.components = new_components;
      }
    else
      {
        integer_range_component *compact_components;

        assert(new_component_num < source_component_count);
        assert(new_component_num > 0);
        compact_components =
                MALLOC_ARRAY(integer_range_component, new_component_num);
        if (compact_components == NULL)
          {
            result->u.integer_ranges.components = new_components;
            type_remove_reference(result, NULL);
            return NULL;
          }

        memcpy(compact_components, new_components,
               new_component_num * sizeof(integer_range_component));
        free(new_components);
        result->u.integer_ranges.components = compact_components;
      }

    return result;
  }

static type *split_intersection_of_union(type *union_type, type *other)
  {
    type *left_intersection;
    type *right_intersection;
    type *result;

    assert(union_type != NULL);
    assert(other != NULL);

    assert(type_is_valid(union_type)); /* VERIFIED */
    assert(type_is_valid(other)); /* VERIFIED */

    assert(union_type->kind == TK_UNION);

    left_intersection =
            get_intersection_type(union_type->u.union_type.left, other);
    if (left_intersection == NULL)
        return NULL;

    right_intersection =
            get_intersection_type(union_type->u.union_type.right, other);
    if (right_intersection == NULL)
      {
        type_remove_reference(left_intersection, NULL);
        return NULL;
      }

    result = get_union_type(left_intersection, right_intersection);
    type_remove_reference(left_intersection, NULL);
    type_remove_reference(right_intersection, NULL);
    return result;
  }

static type *get_union_of_enumerated_types(type *left, type *right)
  {
    size_t left_count;
    size_t right_count;
    value **all_values;
    type *result;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_ENUMERATION);
    assert(right->kind == TK_ENUMERATION);

    left_count = left->u.enumeration.value_count;
    right_count = right->u.enumeration.value_count;
    assert(left_count > 0);
    assert(right_count > 0);

    all_values = MALLOC_ARRAY(value *, left_count + right_count);
    if (all_values == NULL)
        return NULL;

    memcpy(all_values, left->u.enumeration.values,
           left_count * sizeof(value *));
    memcpy(&(all_values[left_count]), right->u.enumeration.values,
           right_count * sizeof(value *));

    result = get_enumeration_type(left_count + right_count, all_values);
    free(all_values);
    assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
    return result;
  }

static type *get_union_of_enumeration_and_integer_ranges(type *left,
        type *right, boolean *error)
  {
    size_t component_count;
    integer_range_component *components;
    size_t right_count;
    size_t component_num;
    size_t left_count;
    value **all_values;
    size_t position;
    type *result;

    assert(left != NULL);
    assert(right != NULL);
    assert(error != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_ENUMERATION);
    assert(right->kind == TK_INTEGER_RANGES);

    component_count = right->u.integer_ranges.component_count;
    components = right->u.integer_ranges.components;

    right_count = component_count;

    for (component_num = 0; component_num < component_count; ++component_num)
      {
        o_integer lower;
        o_integer upper;
        o_integer diff;
        boolean do_enum;

        lower = components[component_num].lower_bound;
        upper = components[component_num].upper_bound;

        if (oi_equal(lower, upper))
            continue;

        oi_subtract(diff, upper, lower);
        if (oi_out_of_memory(diff))
          {
            *error = TRUE;
            return NULL;
          }

        do_enum = !(oi_less_than(oi_one, diff));
        oi_remove_reference(diff);
        if (!do_enum)
          {
            *error = FALSE;
            return NULL;
          }

        ++right_count;
      }

    if (right->u.integer_ranges.includes_positive_infinity)
        ++right_count;
    if (right->u.integer_ranges.includes_negative_infinity)
        ++right_count;
    if (right->u.integer_ranges.includes_unsigned_infinity)
        ++right_count;
    if (right->u.integer_ranges.includes_zero_zero)
        ++right_count;

    left_count = left->u.enumeration.value_count;
    assert(left_count > 0);
    assert(right_count > 0);

    all_values = MALLOC_ARRAY(value *, left_count + right_count);
    if (all_values == NULL)
      {
        *error = TRUE;
        return NULL;
      }

    memcpy(all_values, left->u.enumeration.values,
           left_count * sizeof(value *));

    position = left_count;

    if (right->u.integer_ranges.includes_positive_infinity)
      {
        all_values[position] = create_integer_value(oi_positive_infinity);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }
    if (right->u.integer_ranges.includes_negative_infinity)
      {
        all_values[position] = create_integer_value(oi_negative_infinity);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }
    if (right->u.integer_ranges.includes_unsigned_infinity)
      {
        all_values[position] = create_integer_value(oi_unsigned_infinity);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }
    if (right->u.integer_ranges.includes_zero_zero)
      {
        all_values[position] = create_integer_value(oi_zero_zero);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }

    for (component_num = 0; component_num < component_count; ++component_num)
      {
        o_integer lower;
        o_integer upper;

        lower = components[component_num].lower_bound;
        upper = components[component_num].upper_bound;

        all_values[position] = create_integer_value(lower);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;

        if (oi_equal(lower, upper))
            continue;

        all_values[position] = create_integer_value(upper);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }

    assert(position == left_count + right_count);

    result = get_enumeration_type(left_count + right_count, all_values);

    for (position = left_count; position < left_count + right_count;
         ++position)
      {
        value_remove_reference(all_values[position], NULL);
      }

    free(all_values);
    assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
    *error = FALSE;
    return result;

  error_out:
    while (position > left_count)
      {
        --position;
        value_remove_reference(all_values[position], NULL);
      }
    free(all_values);
    *error = TRUE;
    return NULL;
  }

static type *get_union_of_enumeration_and_rational_ranges(type *left,
        type *right, boolean *error)
  {
    size_t component_count;
    rational_range_component *components;
    size_t component_num;
    size_t right_count;
    size_t left_count;
    value **all_values;
    size_t position;
    type *result;

    assert(left != NULL);
    assert(right != NULL);
    assert(error != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_ENUMERATION);
    assert(right->kind == TK_RATIONAL_RANGES);

    component_count = right->u.rational_ranges.component_count;
    components = right->u.rational_ranges.components;

    for (component_num = 0; component_num < component_count; ++component_num)
      {
        if (!(rationals_are_equal(components[component_num].lower_bound,
                                  components[component_num].upper_bound)))
          {
            *error = FALSE;
            return NULL;
          }
      }

    right_count = component_count;

    if (right->u.rational_ranges.includes_positive_infinity)
        ++right_count;
    if (right->u.rational_ranges.includes_negative_infinity)
        ++right_count;
    if (right->u.rational_ranges.includes_unsigned_infinity)
        ++right_count;
    if (right->u.rational_ranges.includes_zero_zero)
        ++right_count;

    left_count = left->u.enumeration.value_count;
    assert(left_count > 0);
    assert(right_count > 0);

    all_values = MALLOC_ARRAY(value *, left_count + right_count);
    if (all_values == NULL)
      {
        *error = TRUE;
        return NULL;
      }

    memcpy(all_values, left->u.enumeration.values,
           left_count * sizeof(value *));

    position = left_count;

    if (right->u.rational_ranges.includes_positive_infinity)
      {
        all_values[position] = create_integer_value(oi_positive_infinity);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }
    if (right->u.rational_ranges.includes_negative_infinity)
      {
        all_values[position] = create_integer_value(oi_negative_infinity);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }
    if (right->u.rational_ranges.includes_unsigned_infinity)
      {
        all_values[position] = create_integer_value(oi_unsigned_infinity);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }
    if (right->u.rational_ranges.includes_zero_zero)
      {
        all_values[position] = create_integer_value(oi_zero_zero);
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }

    for (component_num = 0; component_num < component_count; ++component_num)
      {
        rational *lower;

        lower = components[component_num].lower_bound;

        assert(rationals_are_equal(lower,
                                   components[component_num].upper_bound));

        if (rational_is_integer(lower))
          {
            all_values[position] =
                    create_integer_value(rational_numerator(lower));
          }
        else
          {
            all_values[position] = create_rational_value(lower);
          }
        if (all_values[position] == NULL)
            goto error_out;
        ++position;
      }

    assert(position == left_count + right_count);

    result = get_enumeration_type(left_count + right_count, all_values);

    for (position = left_count; position < left_count + right_count;
         ++position)
      {
        value_remove_reference(all_values[position], NULL);
      }

    free(all_values);
    assert((result == NULL) || type_is_valid(result)); /* VERIFIED */
    *error = FALSE;
    return result;

  error_out:
    while (position > left_count)
      {
        --position;
        value_remove_reference(all_values[position], NULL);
      }
    free(all_values);
    *error = TRUE;
    return NULL;
  }

static type *get_union_of_integer_ranges(type *left, type *right)
  {
    type *result;
    size_t left_component_count;
    size_t right_component_count;
    integer_range_component *left_components;
    integer_range_component *right_components;
    integer_range_component *new_components;
    size_t left_component_num;
    size_t right_component_num;
    size_t new_component_num;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_INTEGER_RANGES);
    assert(right->kind == TK_INTEGER_RANGES);

    result = create_empty_type(TK_INTEGER_RANGES);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = VK_BIT(VK_INTEGER);

    result->u.integer_ranges.includes_positive_infinity =
            (left->u.integer_ranges.includes_positive_infinity ||
             right->u.integer_ranges.includes_positive_infinity);
    result->u.integer_ranges.includes_negative_infinity =
            (left->u.integer_ranges.includes_negative_infinity ||
             right->u.integer_ranges.includes_negative_infinity);
    result->u.integer_ranges.includes_unsigned_infinity =
            (left->u.integer_ranges.includes_unsigned_infinity ||
             right->u.integer_ranges.includes_unsigned_infinity);
    result->u.integer_ranges.includes_zero_zero =
            (left->u.integer_ranges.includes_zero_zero ||
             right->u.integer_ranges.includes_zero_zero);

    left_component_count = left->u.integer_ranges.component_count;
    right_component_count = right->u.integer_ranges.component_count;

    left_components = left->u.integer_ranges.components;
    right_components = right->u.integer_ranges.components;

    if ((left_component_count == 0) && (right_component_count == 0))
      {
        new_components = NULL;
      }
    else
      {
        new_components = MALLOC_ARRAY(integer_range_component,
                left_component_count + right_component_count);
        if (new_components == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }
      }

    left_component_num = 0;
    right_component_num = 0;
    new_component_num = 0;

    while ((left_component_num < left_component_count) ||
           (right_component_num < right_component_count))
      {
        boolean use_left;
        integer_range_component *to_add;
        boolean mergeable;

        if (left_component_num >= left_component_count)
          {
            use_left = FALSE;
          }
        else if (right_component_num >= right_component_count)
          {
            use_left = TRUE;
          }
        else
          {
            use_left = oi_less_than(
                    left_components[left_component_num].lower_bound,
                    right_components[right_component_num].lower_bound);
          }

        if (use_left)
          {
            to_add = &(left_components[left_component_num]);
            ++left_component_num;
          }
        else
          {
            to_add = &(right_components[right_component_num]);
            ++right_component_num;
          }

        if (new_component_num == 0)
          {
            mergeable = FALSE;
          }
        else
          {
            o_integer diff;

            oi_subtract(diff, to_add->lower_bound,
                        new_components[new_component_num - 1].upper_bound);
            if (oi_out_of_memory(diff))
              {
                while (new_component_num > 0)
                  {
                    --new_component_num;
                    oi_remove_reference(
                            new_components[new_component_num].lower_bound);
                    oi_remove_reference(
                            new_components[new_component_num].upper_bound);
                  }
                free(new_components);
                validator_remove_reference(result->validator);
                DESTROY_SYSTEM_LOCK(result->reference_lock);
                free(result);
                return NULL;
              }

            mergeable = !(oi_less_than(oi_one, diff));
            oi_remove_reference(diff);
          }

        if (mergeable)
          {
            o_integer old_upper;

            old_upper = new_components[new_component_num - 1].upper_bound;
            if (oi_less_than(old_upper, to_add->upper_bound))
              {
                oi_add_reference(to_add->upper_bound);
                oi_remove_reference(old_upper);
                new_components[new_component_num - 1].upper_bound =
                        to_add->upper_bound;
              }
          }
        else
          {
            assert(new_component_num <
                   left_component_count + right_component_count);
            oi_add_reference(to_add->lower_bound);
            oi_add_reference(to_add->upper_bound);
            new_components[new_component_num].lower_bound =
                    to_add->lower_bound;
            new_components[new_component_num].upper_bound =
                    to_add->upper_bound;
            ++new_component_num;
          }
      }

    assert(new_component_num <= left_component_count + right_component_count);
    result->u.integer_ranges.component_count = new_component_num;
    if (new_component_num == left_component_count + right_component_count)
      {
        result->u.integer_ranges.components = new_components;
      }
    else
      {
        integer_range_component *compact_components;

        assert(new_component_num <
               left_component_count + right_component_count);
        assert(new_component_num > 0);
        compact_components =
                MALLOC_ARRAY(integer_range_component, new_component_num);
        if (compact_components == NULL)
          {
            result->u.integer_ranges.components = new_components;
            type_remove_reference(result, NULL);
            return NULL;
          }

        memcpy(compact_components, new_components,
               new_component_num * sizeof(integer_range_component));
        free(new_components);
        result->u.integer_ranges.components = compact_components;
      }

    if ((new_component_num == 1) &&
        (oi_kind(new_components[0].lower_bound) == IIK_NEGATIVE_INFINITY) &&
        (oi_kind(new_components[0].upper_bound) == IIK_POSITIVE_INFINITY) &&
        result->u.integer_ranges.includes_positive_infinity &&
        result->u.integer_ranges.includes_negative_infinity &&
        result->u.integer_ranges.includes_unsigned_infinity &&
        result->u.integer_ranges.includes_zero_zero)
      {
        type_remove_reference(result, NULL);
        return get_integer_type();
      }

    return result;
  }

static type *get_union_of_integer_and_rational_ranges(type *left, type *right)
  {
    type *rational_result;
    size_t left_component_count;
    size_t right_component_count;
    integer_range_component *left_components;
    rational_range_component *right_components;
    rational_range_component *new_rational_components;
    integer_range_component *new_integer_components;
    size_t left_component_num;
    size_t right_component_num;
    size_t new_rational_component_num;
    size_t new_integer_component_num;
    type *integer_result;
    int order;
    type *final_result;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_INTEGER_RANGES);
    assert(right->kind == TK_RATIONAL_RANGES);

    rational_result = create_empty_type(TK_RATIONAL_RANGES);
    if (rational_result == NULL)
        return NULL;

    rational_result->possible_value_kinds =
            (VK_BIT(VK_INTEGER) | VK_BIT(VK_RATIONAL));

    rational_result->u.rational_ranges.includes_positive_infinity =
            (left->u.integer_ranges.includes_positive_infinity ||
             right->u.rational_ranges.includes_positive_infinity);
    rational_result->u.rational_ranges.includes_negative_infinity =
            (left->u.integer_ranges.includes_negative_infinity ||
             right->u.rational_ranges.includes_negative_infinity);
    rational_result->u.rational_ranges.includes_unsigned_infinity =
            (left->u.integer_ranges.includes_unsigned_infinity ||
             right->u.rational_ranges.includes_unsigned_infinity);
    rational_result->u.rational_ranges.includes_zero_zero =
            (left->u.integer_ranges.includes_zero_zero ||
             right->u.rational_ranges.includes_zero_zero);

    left_component_count = left->u.integer_ranges.component_count;
    right_component_count = right->u.rational_ranges.component_count;

    left_components = left->u.integer_ranges.components;
    right_components = right->u.rational_ranges.components;

    if ((left_component_count == 0) && (right_component_count == 0))
      {
        new_rational_components = NULL;
        new_integer_components = NULL;
      }
    else
      {
        new_rational_components = MALLOC_ARRAY(rational_range_component,
                (left_component_count * 4) + right_component_count);
        if (new_rational_components == NULL)
          {
            validator_remove_reference(rational_result->validator);
            DESTROY_SYSTEM_LOCK(rational_result->reference_lock);
            free(rational_result);
            return NULL;
          }

        new_integer_components = MALLOC_ARRAY(integer_range_component,
                (left_component_count * 4) + right_component_count);
        if (new_integer_components == NULL)
          {
            free(new_rational_components);
            validator_remove_reference(rational_result->validator);
            DESTROY_SYSTEM_LOCK(rational_result->reference_lock);
            free(rational_result);
            return NULL;
          }
      }

    left_component_num = 0;
    right_component_num = 0;
    new_rational_component_num = 0;
    new_integer_component_num = 0;

    while ((left_component_num < left_component_count) ||
           (right_component_num < right_component_count))
      {
        boolean use_left;

        if (left_component_num >= left_component_count)
          {
            use_left = FALSE;
          }
        else if (right_component_num >= right_component_count)
          {
            use_left = TRUE;
          }
        else
          {
            boolean error;

            use_left = integer_less_than_rational(
                    left_components[left_component_num].lower_bound,
                    right_components[right_component_num].lower_bound, &error);
            if (error)
              {
                rational_result->u.rational_ranges.component_count =
                        new_rational_component_num;
                if (new_rational_component_num == 0)
                  {
                    rational_result->u.rational_ranges.components = NULL;
                    free(new_rational_components);
                  }
                else
                  {
                    rational_result->u.rational_ranges.components =
                            new_rational_components;
                  }
                type_remove_reference(rational_result, NULL);
                while (new_integer_component_num > 0)
                  {
                    --new_integer_component_num;
                    oi_remove_reference(new_integer_components[
                            new_integer_component_num].lower_bound);
                    oi_remove_reference(new_integer_components[
                            new_integer_component_num].upper_bound);
                  }
                free(new_integer_components);
                return NULL;
              }
          }

        if (use_left)
          {
            integer_range_component *to_add;
            o_integer to_add_upper;
            o_integer to_add_lower;

            to_add = &(left_components[left_component_num]);
            ++left_component_num;

            to_add_upper = to_add->upper_bound;
            to_add_lower = to_add->lower_bound;

            assert((new_integer_component_num == 0) ||
                   oi_less_than(
                           new_integer_components[
                                   new_integer_component_num - 1].upper_bound,
                           to_add_lower));

            if (new_rational_component_num == 0)
              {
                oi_add_reference(to_add_lower);
              }
            else
              {
                rational_range_component *old_component;
                boolean error;
                boolean contained;
                boolean disjoint;

                old_component = &(new_rational_components[
                        new_rational_component_num - 1]);

                if ((!(old_component->lower_is_inclusive)) &&
                    rational_is_integer(old_component->lower_bound) &&
                    oi_equal(rational_numerator(old_component->lower_bound),
                             to_add_lower))
                  {
                    old_component->lower_is_inclusive = TRUE;
                  }

                contained = !(rational_less_than_integer(
                        old_component->upper_bound, to_add_upper, &error));
                if (error)
                  {
                  do_error:
                    rational_result->u.rational_ranges.component_count =
                            new_rational_component_num;
                    if (new_rational_component_num == 0)
                      {
                        rational_result->u.rational_ranges.components = NULL;
                        free(new_rational_components);
                      }
                    else
                      {
                        rational_result->u.rational_ranges.components =
                                new_rational_components;
                      }
                    type_remove_reference(rational_result, NULL);
                    while (new_integer_component_num > 0)
                      {
                        --new_integer_component_num;
                        oi_remove_reference(new_integer_components[
                                new_integer_component_num].lower_bound);
                        oi_remove_reference(new_integer_components[
                                new_integer_component_num].upper_bound);
                      }
                    free(new_integer_components);
                    return NULL;
                  }
                if (contained)
                  {
                    if ((!(old_component->upper_is_inclusive)) &&
                        rational_is_integer(old_component->upper_bound) &&
                        oi_equal(
                                rational_numerator(old_component->upper_bound),
                                to_add_upper))
                      {
                        old_component->upper_is_inclusive = TRUE;
                      }

                    continue;
                  }

                disjoint = rational_less_than_integer(
                        old_component->upper_bound, to_add_lower, &error);
                if (error)
                    goto do_error;
                if (disjoint)
                  {
                    oi_add_reference(to_add_lower);
                  }
                else
                  {
                    if (rational_is_integer(old_component->upper_bound))
                      {
                        if (!(old_component->upper_is_inclusive))
                            old_component->upper_is_inclusive = TRUE;

                        oi_add(to_add_lower,
                               rational_numerator(old_component->upper_bound),
                               oi_one);
                      }
                    else
                      {
                        to_add_lower = non_integer_rational_ceiling(
                                old_component->upper_bound);
                      }
                    if (oi_out_of_memory(to_add_lower))
                        goto do_error;
                  }
              }

            if (oi_equal(to_add_lower, to_add_upper))
              {
                rational *to_add_rational;

                to_add_rational = create_rational(to_add_lower, oi_one);
                oi_remove_reference(to_add_lower);
                if (to_add_rational == NULL)
                    goto do_error;

                assert(new_rational_component_num <
                       (left_component_count * 4) + right_component_count);
                rational_add_reference(to_add_rational);
                new_rational_components[new_rational_component_num].lower_bound
                        = to_add_rational;
                new_rational_components[new_rational_component_num].upper_bound
                        = to_add_rational;
                new_rational_components[new_rational_component_num].
                        lower_is_inclusive = TRUE;
                new_rational_components[new_rational_component_num].
                        upper_is_inclusive = TRUE;
                ++new_rational_component_num;
              }
            else
              {
                o_integer diff;
                boolean adjacent;

                oi_subtract(diff, to_add_lower, to_add_upper);
                if (oi_out_of_memory(diff))
                  {
                    oi_remove_reference(to_add_lower);
                    goto do_error;
                  }

                adjacent = oi_equal(diff, oi_one);
                oi_remove_reference(diff);
                if (adjacent)
                  {
                    rational *to_add_lower_rational;
                    rational *to_add_upper_rational;

                    to_add_lower_rational =
                            create_rational(to_add_lower, oi_one);
                    oi_remove_reference(to_add_lower);
                    if (to_add_lower_rational == NULL)
                        goto do_error;

                    assert(new_rational_component_num <
                           (left_component_count * 4) + right_component_count);
                    rational_add_reference(to_add_lower_rational);
                    new_rational_components[new_rational_component_num].
                            lower_bound = to_add_lower_rational;
                    new_rational_components[new_rational_component_num].
                            upper_bound = to_add_lower_rational;
                    new_rational_components[new_rational_component_num].
                            lower_is_inclusive = TRUE;
                    new_rational_components[new_rational_component_num].
                            upper_is_inclusive = TRUE;
                    ++new_rational_component_num;

                    to_add_upper_rational =
                            create_rational(to_add_upper, oi_one);
                    if (to_add_upper_rational == NULL)
                        goto do_error;

                    assert(new_rational_component_num <
                           (left_component_count * 4) + right_component_count);
                    rational_add_reference(to_add_upper_rational);
                    new_rational_components[new_rational_component_num].
                            lower_bound = to_add_upper_rational;
                    new_rational_components[new_rational_component_num].
                            upper_bound = to_add_upper_rational;
                    new_rational_components[new_rational_component_num].
                            lower_is_inclusive = TRUE;
                    new_rational_components[new_rational_component_num].
                            upper_is_inclusive = TRUE;
                    ++new_rational_component_num;
                  }
                else
                  {
                    assert(new_integer_component_num <
                           (left_component_count * 4) + right_component_count);
                    oi_add_reference(to_add_upper);
                    new_integer_components[new_integer_component_num].
                            lower_bound = to_add_lower;
                    new_integer_components[new_integer_component_num].
                            upper_bound = to_add_upper;
                    ++new_integer_component_num;
                  }
              }
          }
        else
          {
            rational_range_component *to_add;
            boolean error;
            size_t merge_position;

            to_add = &(right_components[right_component_num]);
            ++right_component_num;

            blot_out_integer_overlapping_rational_range(new_integer_components,
                    &new_integer_component_num, new_rational_components,
                    &new_rational_component_num, to_add, &error);
            if (error)
                goto do_error;

            merge_position = new_rational_component_num;

            while (merge_position > 0)
              {
                rational_range_component *old_component;
                boolean mergeable;
                boolean error;

                assert(new_rational_component_num - merge_position <= 3);

                old_component = &(new_rational_components[merge_position - 1]);
                if (old_component->upper_is_inclusive ||
                    to_add->lower_is_inclusive)
                  {
                    mergeable = !(rational_less_than(
                            old_component->upper_bound, to_add->lower_bound,
                            &error));
                  }
                else
                  {
                    mergeable = rational_less_than(to_add->lower_bound,
                            old_component->upper_bound, &error);
                  }
                if (error)
                    goto do_error;
                if (!mergeable)
                    break;
                --merge_position;
              }

            assert(merge_position <= new_rational_component_num);
            assert(new_rational_component_num - merge_position <= 3);

            if (merge_position < new_rational_component_num)
              {
                rational_range_component *old_component;
                boolean error;
                boolean disjoint;

                old_component = &(new_rational_components[merge_position]);

                if (old_component->lower_is_inclusive ||
                    to_add->upper_is_inclusive)
                  {
                    disjoint = rational_less_than(to_add->upper_bound,
                            old_component->lower_bound, &error);
                  }
                else
                  {
                    disjoint = !(rational_less_than(old_component->lower_bound,
                            to_add->upper_bound, &error));
                  }
                if (error)
                    goto do_error;

                if (disjoint)
                  {
                    size_t move_place;

                    assert(new_rational_component_num <
                           (left_component_count * 4) + right_component_count);

                    for (move_place = new_rational_component_num;
                         move_place > merge_position; --move_place)
                      {
                        new_rational_components[move_place] =
                                new_rational_components[move_place - 1];
                      }

                    ++new_rational_component_num;

                    rational_add_reference(to_add->lower_bound);
                    rational_add_reference(to_add->upper_bound);
                    old_component->lower_bound = to_add->lower_bound;
                    old_component->upper_bound = to_add->upper_bound;
                    old_component->lower_is_inclusive =
                            to_add->lower_is_inclusive;
                    old_component->upper_is_inclusive =
                            to_add->upper_is_inclusive;
                  }
                else
                  {
                    rational *old_upper;
                    boolean error;
                    boolean less_than;

                    old_upper = old_component->upper_bound;
                    less_than = rational_less_than(old_upper,
                            to_add->upper_bound, &error);
                    if (error)
                        goto do_error;

                    if (less_than)
                      {
                        rational_add_reference(to_add->upper_bound);
                        rational_remove_reference(old_upper);
                        old_component->upper_bound = to_add->upper_bound;
                        old_component->upper_is_inclusive =
                                to_add->upper_is_inclusive;
                      }
                    else if (rationals_are_equal(old_upper,
                                                 to_add->upper_bound))
                      {
                        if (to_add->upper_is_inclusive)
                            old_component->upper_is_inclusive = TRUE;
                      }

                    ++merge_position;
                    assert(merge_position <= new_rational_component_num);
                    assert((new_rational_component_num - merge_position) <= 2);
                    while (merge_position < new_rational_component_num)
                      {
                        rational_range_component *next_component;
                        rational *next_lower;
                        boolean error;
                        boolean no_touch;
                        rational *next_upper;
                        boolean less_than;

                        old_upper = old_component->upper_bound;
                        next_component =
                                &(new_rational_components[merge_position]);
                        next_lower = next_component->lower_bound;

                        if (old_component->upper_is_inclusive ||
                            next_component->lower_is_inclusive)
                          {
                            no_touch = rational_less_than(old_upper,
                                                          next_lower, &error);
                          }
                        else
                          {
                            no_touch = !(rational_less_than(next_lower,
                                    old_upper, &error));
                          }
                        if (error)
                            goto do_error;
                        if (no_touch)
                            break;

                        rational_remove_reference(next_lower);

                        next_upper = next_component->upper_bound;

                        less_than = rational_less_than(old_upper, next_upper,
                                                       &error);
                        if (error)
                            goto do_error;
                        if (less_than)
                          {
                            rational_remove_reference(old_upper);
                            old_component->upper_bound = next_upper;
                            old_component->upper_is_inclusive =
                                    next_component->upper_is_inclusive;
                          }
                        else if (rationals_are_equal(old_upper, next_upper))
                          {
                            rational_remove_reference(next_upper);
                            if (next_component->upper_is_inclusive)
                                old_component->upper_is_inclusive = TRUE;
                          }
                        else
                          {
                            rational_remove_reference(next_upper);
                          }

                        --new_rational_component_num;
                        assert((new_rational_component_num - merge_position) <=
                               1);

                        if (merge_position < new_rational_component_num)
                          {
                            *next_component = new_rational_components[
                                    new_rational_component_num];
                          }
                      }
                  }
              }
            else
              {
                assert(merge_position == new_rational_component_num);
                assert(new_rational_component_num <
                       (left_component_count * 4) + right_component_count);
                rational_add_reference(to_add->lower_bound);
                rational_add_reference(to_add->upper_bound);
                new_rational_components[new_rational_component_num].lower_bound
                        = to_add->lower_bound;
                new_rational_components[new_rational_component_num].upper_bound
                        = to_add->upper_bound;
                new_rational_components[new_rational_component_num].
                        lower_is_inclusive = to_add->lower_is_inclusive;
                new_rational_components[new_rational_component_num].
                        upper_is_inclusive = to_add->upper_is_inclusive;
                ++new_rational_component_num;
              }
          }
      }

    assert(new_rational_component_num <=
           (left_component_count * 4) + right_component_count);
    rational_result->u.rational_ranges.component_count =
            new_rational_component_num;
    if (new_rational_component_num ==
        (left_component_count * 4) + right_component_count)
      {
        rational_result->u.rational_ranges.components =
                new_rational_components;
      }
    else
      {
        rational_range_component *compact_components;

        assert(new_rational_component_num <
               (left_component_count * 4) + right_component_count);
        assert(new_rational_component_num > 0);
        compact_components = MALLOC_ARRAY(rational_range_component,
                                          new_rational_component_num);
        if (compact_components == NULL)
          {
            rational_result->u.rational_ranges.components =
                    new_rational_components;
            type_remove_reference(rational_result, NULL);
            while (new_integer_component_num > 0)
              {
                --new_integer_component_num;
                oi_remove_reference(new_integer_components[
                        new_integer_component_num].lower_bound);
                oi_remove_reference(new_integer_components[
                        new_integer_component_num].upper_bound);
              }
            free(new_integer_components);
            return NULL;
          }

        memcpy(compact_components, new_rational_components,
               new_rational_component_num * sizeof(rational_range_component));
        free(new_rational_components);
        rational_result->u.rational_ranges.components = compact_components;
      }

    if ((new_integer_component_num == 0) &&
        (new_rational_component_num == 1) &&
        (oi_kind(rational_numerator(new_rational_components[0].lower_bound)) ==
         IIK_NEGATIVE_INFINITY) &&
        (oi_kind(rational_numerator(new_rational_components[0].upper_bound)) ==
         IIK_POSITIVE_INFINITY) &&
        rational_result->u.rational_ranges.includes_positive_infinity &&
        rational_result->u.rational_ranges.includes_negative_infinity &&
        rational_result->u.rational_ranges.includes_unsigned_infinity &&
        rational_result->u.rational_ranges.includes_zero_zero)
      {
        type_remove_reference(rational_result, NULL);
        free(new_integer_components);
        return get_rational_type();
      }

    assert(new_integer_component_num <=
           (left_component_count * 4) + right_component_count);
    if (new_integer_component_num == 0)
      {
        free(new_integer_components);
        return rational_result;
      }

    integer_result = create_empty_type(TK_INTEGER_RANGES);
    if (integer_result == NULL)
      {
        type_remove_reference(rational_result, NULL);
        while (new_integer_component_num > 0)
          {
            --new_integer_component_num;
            oi_remove_reference(new_integer_components[
                    new_integer_component_num].lower_bound);
            oi_remove_reference(new_integer_components[
                    new_integer_component_num].upper_bound);
          }
        free(new_integer_components);
        return NULL;
      }

    integer_result->possible_value_kinds = VK_BIT(VK_INTEGER);

    integer_result->u.integer_ranges.component_count =
            new_integer_component_num;
    integer_result->u.integer_ranges.components = new_integer_components;
    integer_result->u.integer_ranges.includes_positive_infinity = FALSE;
    integer_result->u.integer_ranges.includes_negative_infinity = FALSE;
    integer_result->u.integer_ranges.includes_unsigned_infinity = FALSE;
    integer_result->u.integer_ranges.includes_zero_zero = FALSE;

    assert(new_integer_component_num <=
           (left_component_count * 4) + right_component_count);
    if (new_integer_component_num <
        (left_component_count * 4) + right_component_count)
      {
        integer_range_component *compact_components;

        assert(new_integer_component_num > 0);
        compact_components = MALLOC_ARRAY(integer_range_component,
                                          new_integer_component_num);
        if (compact_components == NULL)
          {
            type_remove_reference(rational_result, NULL);
            type_remove_reference(integer_result, NULL);
            return NULL;
          }

        memcpy(compact_components, new_integer_components,
               new_integer_component_num * sizeof(integer_range_component));
        free(new_integer_components);
        integer_result->u.integer_ranges.components = compact_components;
      }

    order = type_structural_order(rational_result, integer_result);
    if (order == -2)
      {
        type_remove_reference(rational_result, NULL);
        type_remove_reference(integer_result, NULL);
        return NULL;
      }
    assert(order != 0);

    final_result = create_empty_type(TK_UNION);
    if (final_result == NULL)
      {
        type_remove_reference(rational_result, NULL);
        type_remove_reference(integer_result, NULL);
        return NULL;
      }

    final_result->possible_value_kinds =
            (rational_result->possible_value_kinds |
             integer_result->possible_value_kinds);

    if (order < 0)
      {
        final_result->u.union_type.left = rational_result;
        final_result->u.union_type.right = integer_result;
      }
    else
      {
        final_result->u.union_type.left = integer_result;
        final_result->u.union_type.right = rational_result;
      }

    return final_result;
  }

static type *get_union_of_rational_ranges(type *left, type *right)
  {
    type *result;
    size_t left_component_count;
    size_t right_component_count;
    rational_range_component *left_components;
    rational_range_component *right_components;
    rational_range_component *new_components;
    size_t left_component_num;
    size_t right_component_num;
    size_t new_component_num;

    assert(left != NULL);
    assert(right != NULL);

    assert(type_is_valid(left)); /* VERIFIED */
    assert(type_is_valid(right)); /* VERIFIED */

    assert(left->kind == TK_RATIONAL_RANGES);
    assert(right->kind == TK_RATIONAL_RANGES);

    result = create_empty_type(TK_RATIONAL_RANGES);
    if (result == NULL)
        return NULL;

    result->possible_value_kinds = (VK_BIT(VK_INTEGER) | VK_BIT(VK_RATIONAL));

    result->u.rational_ranges.includes_positive_infinity =
            (left->u.rational_ranges.includes_positive_infinity ||
             right->u.rational_ranges.includes_positive_infinity);
    result->u.rational_ranges.includes_negative_infinity =
            (left->u.rational_ranges.includes_negative_infinity ||
             right->u.rational_ranges.includes_negative_infinity);
    result->u.rational_ranges.includes_unsigned_infinity =
            (left->u.rational_ranges.includes_unsigned_infinity ||
             right->u.rational_ranges.includes_unsigned_infinity);
    result->u.rational_ranges.includes_zero_zero =
            (left->u.rational_ranges.includes_zero_zero ||
             right->u.rational_ranges.includes_zero_zero);

    left_component_count = left->u.rational_ranges.component_count;
    right_component_count = right->u.rational_ranges.component_count;

    left_components = left->u.rational_ranges.components;
    right_components = right->u.rational_ranges.components;

    if ((left_component_count == 0) && (right_component_count == 0))
      {
        new_components = NULL;
      }
    else
      {
        new_components = MALLOC_ARRAY(rational_range_component,
                left_component_count + right_component_count);
        if (new_components == NULL)
          {
            validator_remove_reference(result->validator);
            DESTROY_SYSTEM_LOCK(result->reference_lock);
            free(result);
            return NULL;
          }
      }

    left_component_num = 0;
    right_component_num = 0;
    new_component_num = 0;

    while ((left_component_num < left_component_count) ||
           (right_component_num < right_component_count))
      {
        boolean use_left;
        rational_range_component *to_add;
        boolean mergeable;

        if (left_component_num >= left_component_count)
          {
            use_left = FALSE;
          }
        else if (right_component_num >= right_component_count)
          {
            use_left = TRUE;
          }
        else
          {
            boolean error;

            use_left = rational_less_than(
                    left_components[left_component_num].lower_bound,
                    right_components[right_component_num].lower_bound, &error);
            if (error)
              {
                result->u.rational_ranges.component_count = new_component_num;
                if (new_component_num == 0)
                  {
                    result->u.rational_ranges.components = NULL;
                    free(new_components);
                  }
                else
                  {
                    result->u.rational_ranges.components = new_components;
                  }
                type_remove_reference(result, NULL);
                return NULL;
              }
          }

        if (use_left)
          {
            to_add = &(left_components[left_component_num]);
            ++left_component_num;
          }
        else
          {
            to_add = &(right_components[right_component_num]);
            ++right_component_num;
          }

        if (new_component_num == 0)
          {
            mergeable = FALSE;
          }
        else
          {
            rational_range_component *old_component;
            boolean error;

            old_component = &(new_components[new_component_num - 1]);
            if (old_component->upper_is_inclusive ||
                to_add->lower_is_inclusive)
              {
                mergeable = !(rational_less_than(old_component->upper_bound,
                                                 to_add->lower_bound, &error));
              }
            else
              {
                mergeable = rational_less_than(to_add->lower_bound,
                        old_component->upper_bound, &error);
              }
            if (error)
              {
                result->u.rational_ranges.component_count = new_component_num;
                if (new_component_num == 0)
                  {
                    result->u.rational_ranges.components = NULL;
                    free(new_components);
                  }
                else
                  {
                    result->u.rational_ranges.components = new_components;
                  }
                type_remove_reference(result, NULL);
                return NULL;
              }
          }

        if (mergeable)
          {
            rational_range_component *old_component;
            rational *old_upper;
            boolean error;
            boolean less_than;

            old_component = &(new_components[new_component_num - 1]);
            old_upper = old_component->upper_bound;
            less_than =
                    rational_less_than(old_upper, to_add->upper_bound, &error);
            if (error)
              {
                result->u.rational_ranges.component_count = new_component_num;
                if (new_component_num == 0)
                  {
                    result->u.rational_ranges.components = NULL;
                    free(new_components);
                  }
                else
                  {
                    result->u.rational_ranges.components = new_components;
                  }
                type_remove_reference(result, NULL);
                return NULL;
              }

            if (less_than)
              {
                rational_add_reference(to_add->upper_bound);
                rational_remove_reference(old_upper);
                old_component->upper_bound = to_add->upper_bound;
                old_component->upper_is_inclusive = to_add->upper_is_inclusive;
              }
            else if (rationals_are_equal(old_upper, to_add->upper_bound))
              {
                if (to_add->upper_is_inclusive)
                    old_component->upper_is_inclusive = TRUE;
              }
          }
        else
          {
            assert(new_component_num <
                   left_component_count + right_component_count);
            rational_add_reference(to_add->lower_bound);
            rational_add_reference(to_add->upper_bound);
            new_components[new_component_num].lower_bound =
                    to_add->lower_bound;
            new_components[new_component_num].upper_bound =
                    to_add->upper_bound;
            new_components[new_component_num].lower_is_inclusive =
                    to_add->lower_is_inclusive;
            new_components[new_component_num].upper_is_inclusive =
                    to_add->upper_is_inclusive;
            ++new_component_num;
          }
      }

    assert(new_component_num <= left_component_count + right_component_count);
    result->u.rational_ranges.component_count = new_component_num;
    if (new_component_num == left_component_count + right_component_count)
      {
        result->u.rational_ranges.components = new_components;
      }
    else
      {
        rational_range_component *compact_components;

        assert(new_component_num <
               left_component_count + right_component_count);
        assert(new_component_num > 0);
        compact_components =
                MALLOC_ARRAY(rational_range_component, new_component_num);
        if (compact_components == NULL)
          {
            result->u.rational_ranges.components = new_components;
            type_remove_reference(result, NULL);
            return NULL;
          }

        memcpy(compact_components, new_components,
               new_component_num * sizeof(rational_range_component));
        free(new_components);
        result->u.rational_ranges.components = compact_components;
      }

    if ((new_component_num == 1) &&
        (oi_kind(rational_numerator(new_components[0].lower_bound)) ==
         IIK_NEGATIVE_INFINITY) &&
        (oi_kind(rational_numerator(new_components[0].upper_bound)) ==
         IIK_POSITIVE_INFINITY) &&
        result->u.rational_ranges.includes_positive_infinity &&
        result->u.rational_ranges.includes_negative_infinity &&
        result->u.rational_ranges.includes_unsigned_infinity &&
        result->u.rational_ranges.includes_zero_zero)
      {
        type_remove_reference(result, NULL);
        return get_rational_type();
      }

    return result;
  }

static void add_rational_to_ranges(o_integer to_add,
        rational_range_component *new_rational_components,
        size_t *new_rational_component_num, boolean *error)
  {
    rational *rational_to_add;
    size_t position;
    boolean fits;
    size_t move;

    assert(!(oi_out_of_memory(to_add)));
    assert(new_rational_components != NULL);
    assert(new_rational_component_num != NULL);
    assert(error != NULL);

    rational_to_add = create_rational(to_add, oi_one);
    if (rational_to_add == NULL)
      {
        *error = TRUE;
        return;
      }

    position = *new_rational_component_num;

    while (position > 0)
      {
        boolean less_than;

        less_than = rational_less_than(
                new_rational_components[position].upper_bound, rational_to_add,
                error);
        if (*error)
          {
            rational_remove_reference(rational_to_add);
            return;
          }
        if (less_than)
            break;
        --position;
      }

    fits = !(rational_less_than(new_rational_components[position].lower_bound,
                                rational_to_add, error));
    if (*error)
      {
        rational_remove_reference(rational_to_add);
        return;
      }
    if (fits)
      {
        if ((!(new_rational_components[position].lower_is_inclusive)) &&
            rationals_are_equal(new_rational_components[position].lower_bound,
                                rational_to_add))
          {
            new_rational_components[position].lower_is_inclusive = TRUE;
          }

        if ((!(new_rational_components[position].upper_is_inclusive)) &&
            rationals_are_equal(new_rational_components[position].upper_bound,
                                rational_to_add))
          {
            new_rational_components[position].upper_is_inclusive = TRUE;
          }

        rational_remove_reference(rational_to_add);
        *error = FALSE;
        return;
      }

    for (move = *new_rational_component_num; move > position; --move)
        new_rational_components[move] = new_rational_components[move - 1];

    ++(*new_rational_component_num);
    rational_add_reference(rational_to_add);
    new_rational_components[position].lower_bound = rational_to_add;
    new_rational_components[position].lower_is_inclusive = TRUE;
    new_rational_components[position].upper_bound = rational_to_add;
    new_rational_components[position].upper_is_inclusive = TRUE;
    *error = FALSE;
  }
