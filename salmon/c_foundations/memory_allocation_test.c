/* file "memory_allocation_test.c" */

/*
 *  This file contains the implementation of code to help test the dynamic
 *  memory allocation and deallocation of other pieces of software.
 *
 *  Written by Chris Wilson.
 *
 *  This file is hearby placed in the public domain by its author.
 */


#include "memory_allocation_test.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "code_point.h"


/*
 *      Data Structures
 *
 *  There are two primary dynamic data structures in this module.  The first of
 *  these is a pair of linked lists of structures where each element of the
 *  list records information about one user-allocated block of memory.  One of
 *  these lists is for allocated and not-yet freed blocks and the other is for
 *  freed blocks.  Note that no memory is actually ever freed by this module --
 *  freed blocks are kept allocated so the memory isn't reused, to guarantee
 *  that if a pointer to a freed block is re-used we can catch it.
 *
 *  The other primary dynamic data structure is a tree to allow fast lookup of
 *  elements in these two lists by the pointer to the user-visible block of
 *  memory each represents.  The nodes in the tree are objects of type
 *  lookup_tree.
 *
 *  The elements of the two linked lists use the allocated_block_t structure
 *  type.  These are doubly-linked, NULL terminated lists and the heads of the
 *  two lists are the allocated_blocks and deallocated_blocks globals.  The
 *  element structure has ten fields.
 *
 *  The user_specified_size field, as the name implies, contains the number of
 *  bytes that the user specified for the block.  This module actually
 *  allocates a block that is larger than the user specified -- 32 bytes
 *  larger, in fact, so that it can use 16 bytes at either end of the block as
 *  padding.  This module sets those blocks to particular bit patterns and then
 *  later checks to make sure that the padding has not been disturbed.
 *
 *  The raw_data field points to the block including the padding -- in other
 *  words, it is 16 bytes before the pointer that the client of this code gets.
 *
 *  The next five fields contain information about where the block was
 *  allocated, whether it's been deallocated, and, if it has been deallocated,
 *  where it was deallocated.  The allocation_file_name and
 *  allocation_line_number fields contains the file name and line number of the
 *  call to test_malloc() that allocated the block.  The is_free field is a
 *  boolean that is set if and only if the client code has made a call to
 *  deallocate the block.  If the block has been deallocated, the
 *  freeing_file_name and freeing_line_number fields contain the file name and
 *  line number of the call to test_free() that deallocated the block.  Note
 *  that the two file name pointers point to the string passed by the client
 *  code, not a local copy of the string.  So this code assumes that the
 *  strings for file names it is given are never de-allocated and never
 *  changed.  This works fine because the strings come from string literals
 *  generated by macro invocations that give the source file names.
 *
 *  The next two fields are the ``next'' and ``previous'' pointers.  The
 *  ``next'' field always points to the next element in the linked list
 *  containing this element.  The ``previous'' field points to the pointer in
 *  the list that points to this element.  Note that its type is a pointer to a
 *  pointer to an allocated_block_t, not just a pointer to an
 *  allocated_block_t.  So if the element is first in the allocated list, it
 *  will point to allocated_blocks; if it is first in the de-allocated list, it
 *  will point to deallocated_blocks; and otherwise it will point to the next
 *  pointer of the previous element in the list.  This allows elements to be
 *  remove from the list without special-case code to handle the head of the
 *  list differently from the non-head case.
 *
 *  The final field of the allocated_block_t structure is the next_for_tree
 *  field.  This field is related to the lookup_tree type, so we'll postpone
 *  discussion of this field until we've discussed the lookup_tree type.
 *
 *  The lookup_tree structure is used to make finding the allocated_block_t
 *  object for a given raw block pointer (the raw_data field of the
 *  allocated_block_t object) efficient.  Without the lookup tree, to find the
 *  element by raw pointer value it would be necessary to walk through both
 *  linked lists in their entirities in some cases, and in many cases on
 *  average it would require walking over about half the elements in the lists.
 *  So lookup time would be linear in the number of allocated and deallocated
 *  blocks.  With the lookup_tree objects, this lookup is done in linear time.
 *
 *  Each lookup_tree object represents four bits of the raw pointer value.  The
 *  top of the tree is always pointed to by the tree_top global.  To look up a
 *  given raw pointer value, start with the most most significant four bits and
 *  the top of the tree.  Use those four bits as an index to select one element
 *  of the ``u'' field array of the lookup_tree object.  If there are
 *  CHUNKS_TO_SKIP times four more bits in the pointer, use the ``block'' field
 *  of the union.  Otherwise, use the lookup_tree field to get to the next
 *  element and go on to the next least significant four bits of the pointer.
 *  If you hit NULL anywhere along the way, it means there is no
 *  allocated_block_t object for that raw pointer value.
 *
 *  Note that we don't use the final CHUNKS_TO_SKIP time four bits of the
 *  pointer, so it is possible that more than one pointer will map to the same
 *  place through this process.  That's where the next_for_tree field of the
 *  allocated_block_t structure comes in.  The pointer we get from the lookup
 *  tree is the head of a singly-linked list of allocated_block_t structures,
 *  where the next_for_tree field is the link pointer.  So once we're done with
 *  the tree, we may still need to follow next_for_tree links until we find the
 *  right block.  Note that the CHUNKS_TO_SKIP macro is constant that can be
 *  changed to tune performance, as the comments above its definition discuss.
 *
 *  There are a few other pieces of global data besides the allocated_blocks,
 *  deallocated_blocks, and tree_top pointers.  The unfreed_block_count global
 *  keeps track of the number of blocks that have been allocated by the client
 *  code but not yet freed.  This is redundant information because it is always
 *  equal to the length of the allocated_blocks linked list, but since this is
 *  a piece of information that is made available to to the client code through
 *  the unfreed_blocks() interface, it is kept here in a global to make the
 *  unfreed_blocks() function fast.
 *
 *  Note that the type of the unfreed_block_count global, size_t (which is also
 *  the return type of the unfreed_blocks() function interface), isn't
 *  guaranteed to be large enough to hold a count of the number of allocated
 *  blocks.  There is no standard C type which is guaranteed to be big enough
 *  for that.  But size_t is as close as we can get.  The size_t type is
 *  guaranteed to be big enough to hold the size of any one allocated object,
 *  so on many systems it is likely to have the same number of bits as a
 *  pointer and be guaranteed large enough to hold the count of all memory
 *  locations.  But some systems with segmented architectures might have
 *  smaller limits on the size of any one object than on the size of all
 *  objects put together.  For these reasons, the unfreed_block_count global
 *  and the result of the unfreed_blocks() function is defined as not exactly
 *  the count of blocks but rather it is defined as follows.  If the number of
 *  unfreed blocks is less than the maximum value representable by size_t, the
 *  value used is equal to the true count.  If the true count is greater than
 *  or equal to the maximum representable value, the value used is the maximum
 *  representable value.  In practice, this limit is unlikely to ever be
 *  reached, but it can't be guaranteed that it won't in some unusual
 *  situation.  This code is written to correctly handle that situation.
 *
 *  The next two pieces of global data that are kept are the
 *  memory_allocation_limit_enabled and memory_allocation_limit globals.  These
 *  implement the memory allocation limit state, as set by the client code
 *  through the set_memory_allocation_limit() and
 *  clear_memory_allocation_limit() functions.  The memory_allocation_limit
 *  variable has integer type but is used as a boolean flag to indicate whether
 *  or not limiting allocations is enabled at all.  If the flag is zero, the
 *  value of memory_allocation_limit doesn't matter and is ignored.  If the
 *  flag is non-zero, the memory_allocation_limit global indicates how many
 *  more successful allocation calls will be allowed before a failure is
 *  returned by the allocation function.  The type size_t is used for this
 *  count because that is what the interface allows the client code to specify.
 *
 *  The next global is the memory_allocation_count variable.  This variable is
 *  a free-running count of the total number of allocations that have been made
 *  through this module.  If it overflows, it simply wraps around.
 *
 *  The final global variable is the ``padding'' array.  This is an array that
 *  is never changed and is used to specify the padding to put at the start and
 *  end of each client-allocated block to try to catch writes beyond the start
 *  or end of a block.  When a block is allocated, this pattern is copied to
 *  the start and end of the block and whenever else the block is seen by this
 *  code (such as when it is freed), this array is compared with the padding in
 *  the block.
 *
 *  And that completes the detailed explanation of the data structures used by
 *  this module.
 *
 *
 *      Functions
 *
 *  If I've been successful, I've marked every basic block with one use of the
 *  code_point() macro and each one uses a different integer value as the
 *  argument.  In addition to one per basic block, I've added ``else'' blocks
 *  to ``if'' statements where they would not otherwise be necessary just for
 *  the code_point() macros.  This is to make it easier to check that the tests
 *  cover all the code in this file.
 *
 *      test_malloc_implementation()
 *
 *  The first function is test_malloc_implementation(), the replacement for the
 *  malloc() function  This function will allocate a block that is larger than
 *  the client code requested, put padding at the start and end of the block,
 *  and add an entry in the linked list for allocated and not freed blocks for
 *  this new block.  It will also update the lookup tree structure as
 *  appropriate and increment the count of allocated blocks if that count
 *  hasn't already reached its limit and check and give an error if the user
 *  attempts to allocate a block of zero size -- ANSI C defines this as legal
 *  but leaves it up to the implementation whether it returns NULL or a unique
 *  pointer, so at best code that does this is likely to behave differently on
 *  different systems and since it's useless to do this, even more likely this
 *  indicates a bug in the program trying to allocate a block of size zero.
 *
 *  The memory allocation limit is implemented here, between code points 4 and
 *  10.  Note also that when checking whether to increment the
 *  unfreed_block_count global, we compare against the value ~(size_t)0.  We
 *  know this has to be the largest representable value for type size_t because
 *  that type is an unsigned integer type (section 7.1.6 of ANSI/ISO 9899-1990)
 *  and the definition of the ~ operator (section 6.3.3.3) makes it clear that
 *  for each unsigned integral type, the result of the operator is equal to the
 *  maximum representable value for that type minus the operand.
 *
 *  Right after code point 10, the memory_allocation_count variable is
 *  incremented.  Note that this means that it is incremented only in the case
 *  that the allocation wasn't aborted because the size of the allocation was
 *  zero or the memory allocation limit was reached.  But if allocation fails
 *  because of insufficient memory, this variable will still be incremented.
 *  It's done that way because we don't want to count alloations that will be
 *  guaranteed to fail, but we do want to count the cases where the allocation
 *  might succeed in theory if more memory were available.
 *
 *  The code between code points 10 and 13 after the incrementing of the
 *  memory_allocation_count variable implements a check on the size to make
 *  sure the addition of 32 bytes to the size doesn't overflow.  If the check
 *  weren't there, a very large size being requested could cause an overflow
 *  and an allocation of a very small block, but with the client code being
 *  returned a non-NULL pointer, indicating success.  If such overflow is
 *  detected, this code simply returns NULL to the client (code point 11).
 *  That's because it's too large a value for this module to support, and size
 *  values that are too large are expected to cause malloc() to return NULL.
 *  On nearly any system, doing a malloc() with a size so close to the limit of
 *  size_t is sure to fail anyway, so this is the behavior the client code
 *  would be very likely to get if calling malloc() directly.
 *
 *      test_free_implementation()
 *
 *  The next function, test_free_implementation(), is the replacement for the
 *  free() function.  This does some testing for various kinds of errors, but
 *  it is still quite straightforward.
 *
 *  This function starts (code point 39) by testing to see if the pointer being
 *  freed is NULL.  If it is NULL, an error message is printed and the program
 *  exits.  Note that this is stricter than ANSI C, which explicitly allows
 *  free(NULL) and states that it has no effect.  The reason I put in this
 *  stricter rule is purely a personal preference.  I find it more useful for
 *  my own code to stick to the rule that I never free NULL pointers, and if my
 *  code does ever free NULL, then something is going on I didn't expect and I
 *  likely have a bug.  When freeing a pointer that is allowed to be NULL or
 *  non-NULL, I put in an explicit check and call free() only if it is
 *  non-NULL.  It is convenient sometimes to just call free() on a pointer that
 *  may or may not be NULL, so not everyone will like my stricter rule.  I
 *  personally choose a little less convenience for a little more rigorous
 *  checking in this case.
 *
 *  Next, from code point 42, this code tries to find the allocated_block_t
 *  instance for the block being de-allocated.  It does this by calling
 *  find_record(), which uses the lookup tree to find the instance if it exists
 *  or return NULL if if does not exist.  Note that it needs to do the lookup
 *  not with the pointer supplied by the user but with the address 16 bytes
 *  before that, which is the pointer to the padded block that contains the
 *  block the user is given.  The outer_block pointer is set to this point 16
 *  bytes before the pointer that the user supplies.
 *
 *  If block is not found (code point 43), this function prints a message
 *  saying that the block being freed doesn't match any block ever allocated.
 *  If it finds a match but the block has already been freed (code point 45),
 *  it prints a message indicating that the block was freed twice.
 *
 *  Next (code point 46), we set the is_free, freeing_file_name, and
 *  freeing_line_number fields to indicate the de-allocation.  Then, we set the
 *  user-visible part of the block to all 0xff bytes.  This is to help detect
 *  read-after-free and write-after-free bugs.  On a read-after-free, the 0xff
 *  bytes are unlikely to be reasonable values, so the program is likely to hit
 *  an assertion failure or do something else to quickly indicate something is
 *  wrong, like following a bad pointer.  This won't catch all read-after-free
 *  bugs, but it will catch a lot of them.  On a write-after-free, the value
 *  written is unlikely to be 0xff, so later, when the client code calls
 *  check_blocks(), the bytes are likely to be something other than 0xff and
 *  check_blocks() will notice and print an error message.  Again, it won't
 *  catch all bugs of this sort -- write-after-free -- but it is likely to
 *  catch a lot of them.
 *
 *  Next, we call the private check_padding() function to check the padding
 *  before and after the block and issue an error if any of it has been
 *  changed.
 *
 *  After that, we remove the element from the allocated_blocks list and put it
 *  at the head of the deallocated_blocks list.  Then we update the
 *  unfreed_block_count global.  Note that in the case that this value starts
 *  at something less than its maximum (code point 53), this is trivial.  The
 *  other case (code point 54) is unlikely to ever come up in real life, but it
 *  is handled here correctly, though not efficiently.  The way it is handled
 *  is to walk over the entire allocated_blocks list and count how many
 *  elements it has, until either the maximum representable value is reached or
 *  the end of the list is reached.
 *
 *      assert_is_malloced_block_implementation()
 *      assert_is_malloced_block_with_minimum_size_implementation()
 *      assert_is_malloced_block_with_exact_size_implementation()
 *
 *  The next three functions -- assert_is_malloced_block_implementation(),
 *  assert_is_malloced_block_with_minimum_size_implementation(), and
 *  assert_is_malloced_block_with_exact_size_implementation() -- share so much
 *  functionality that their implementation is combined into one private
 *  function, internal_assert_is_malloced_block().  These three functions then
 *  are just wrappers that pass the appropriate arguments to
 *  internal_assert_is_malloced_block().  The
 *  assert_is_malloced_block_with_exact_size_implementation() function has one
 *  bit of additional code, just to issue an error if the ``size'' parameter is
 *  zero.  This allows a zero size parameter to the
 *  internal_assert_is_malloced_block() function to mean that no exact size is
 *  specified and still catch the error if the user tries to specify an exact
 *  size of zero.  It has to be an error if the user claims an exact size of
 *  zero, since the test_malloc_implementation() function disallows zero-sized
 *  allocations.
 *
 *      unfreed_blocks()
 *
 *  The unfreed_blocks() function is just about the most trivial function
 *  imaginable, doing nothing but returning the value of the
 *  unfreed_block_count global.
 *
 *      check_blocks()
 *
 *  The check_blocks() function walks over both the list of still-allocated
 *  blocks and the list of de-allocated blocks.  For still-allocated blocks, it
 *  checks that the padding before and after is still intact and issues an
 *  error message if it is not.  For de-allocated blocks, it does this same
 *  padding check, but in addition it checks that each byte of the user-data
 *  section of the block is still the 0xff value that was placed in it by
 *  test_free_implementation().  If any byte is wrong, it issues an error
 *  message and exists.
 *
 *      describe_unfreed_blocks()
 *
 *  The describe_unfreed_blocks() function simply walks over the list of blocks
 *  that are currently unfree and for each prints an error message describing
 *  that block as a leaked memory block.
 *
 *      set_memory_allocation_limit()
 *      clear_memory_allocation_limit()
 *
 *  The set_memory_allocation_limit() and clear_memory_allocation_limit()
 *  functions are also pretty trivial, simply setting the
 *  memory_allocation_limit_enabled flag and, in the case of the
 *  set_memory_allocation_limit() function, the memory_allocation_limit global.
 *
 *      get_memory_allocation_count()
 *
 *  The get_memory_allocation_count() function returns to the client code the
 *  total number of allocations that have been done so far, as recorded in the
 *  memory_allocation_count global.
 *
 *      internal_assert_is_malloced_block()
 *
 *  Next is the internal_assert_is_malloced_block() function, which is used to
 *  implement the three interfaces that allow the user to specify that a given
 *  pointer is an allocated block and optionally that it either has some exact
 *  size or some minimum size.  The ``pointer'' parameter is the user's handle
 *  for the block, the minimum_size parameter is the size the user specified as
 *  the minimum size of the block (zero if the user didn't specify a minimum
 *  size), and the exact_size parameter is the size the user specified as the
 *  exact size of the block, or zero if the user didn't specify an exact size.
 *
 *  The first thing this function does (code point 77) is check for a NULL
 *  pointer and issue the appropriate error message if it is found (code point
 *  78).  Next, at code point 79, it sets outer_block to the begining of what
 *  should be the padded block and uses find_record() to find the record for
 *  that block.
 *
 *  If no matching block is found (code point 80), an appropriate error message
 *  is issued and the program exits.  If a match is found but it is for a block
 *  that has already been de-allocated (code point 82), again an error message
 *  is issued and the program exists.
 *
 *  Next (code point 83), the check_padding() function is used to verify that
 *  the padding has not been disturbed and if it has exit with the appropriate
 *  error message.
 *
 *  After that, the code checks the size of the block, in the
 *  user_specified_size field, against the minium size that the client code is
 *  now claiming.  Note that if minimum_size is zero, the check automatically
 *  passes.  If the check fails (code point 84), the appropriate error message
 *  is issued and the program exits.
 *
 *  Then, at code point 85, it makes a similar check of the exact_size field,
 *  but only if the exact_size field is non-zero.  Again, if the check fails
 *  (code point 86), the appropriate error message is issued and the program
 *  exits.
 *
 *      check_padding()
 *
 *  Next comes the check_padding() function.  This function checks the padding
 *  at the start and end of a block to make sure there haven't been writes
 *  beyond the start or end of the block.  It assumes that the linked list
 *  element for this block has already been found and passed to this function
 *  in the block_data parameter.  Note that the pointer to the block itself
 *  doesn't need to be passed because it's already available in the
 *  block_data->raw_data field.
 *
 *  The first thing this function does (code point 88) is to use memcmp() to
 *  compare the padding before the user's block to the expected pattern.  If
 *  the comparison fails (code point 89), an appropriate error message is
 *  printed.  The address of the padding as well as the expected and actual
 *  values in the padding are also printed to help in tracking down the bug.
 *
 *  Then, at code point 94, this code does the same thing with the tail
 *  padding.  It uses the user_specified_size field to find out where the tail
 *  padding should start.
 *
 *      find_record()
 *
 *  Finally, there is the find_record() function.  This function walks the
 *  lookup tree, as described in the ``Data Structures'' section, to find the
 *  allocated_block_t object, if it exists, for a given raw block pointer.
 *
 *  And that's the last of the code in this module.
 *
 *
 *      History
 *
 *  This code was written by me, Chris Wilson, in 2003, 2004, and 2008 and
 *  placed in the public domain at that time.  It's entirely new code and isn't
 *  based on anything I or anyone else has written in the past.
 *
 *  I modified this code in 2008 to keep track of callsite source file name and
 *  line number information and use it in diagnostic messages.
 *
 *  In January of 2009 I added the describe_unfreed_blocks() function.  I also
 *  fixed the text of some diagnostic messages to use the plural only when
 *  appropriate.
 *
 *  On July 1, 2009, I further modified this code for performance.  I changed
 *  it from walking the entire list of allocation records every time a block is
 *  freed or a check is done on a block to instead using a tree structure to
 *  speed such lookups.  This trades some space for time.  Before this change,
 *  performance didn't scale well with total number of allocations, and with
 *  CWX1 Interpreter Zero testing I was getting performance slow enough to
 *  distract me from my work (more than one minute to run my test suite).
 *
 *  On August 25, 2009, I made further changes to clean up and document the
 *  recent changes I made and to fix some bugs in error messages in them.
 *
 *
 *      Legal Issues
 *
 *  I've written this code from scratch, without using or refering to any other
 *  code, on my own equipment and not for hire for anyone else, so I have full
 *  legal rights to place it in the public domain.
 *
 *  I've chosen to put this software in the public domain rather than
 *  copyrighting it and using the FSF's GPL or a Berkeley-style ``vanity''
 *  license because my personal opinion is that making it public domain
 *  maximizes its potential usefulness to others.  Anyone can feel free to use
 *  it for any purpose, including with their own proprietary code or with GPL
 *  code, without fear of intellectual property issues.  I have no desire to
 *  stop anyone else from making money on this code or getting any other
 *  advantages they can from it.
 *
 *  I do request that anyone who finds this software useful let me know about
 *  it.  You can drop me e-mail at "Chris Wilson" <chris@chriswilson.info> to
 *  let me know how you are using it and what is good and bad about it for you.
 *  Bug reports are also appreciated.  Also, if you release a product or
 *  software package of some sort that includes this software, I would like you
 *  to give me credit in the documentation as appropriate for the importance of
 *  my code in your product.  These are requests, not requirements, so you are
 *  not legally bound to do them, they're just a nice way to show appreciation.
 *
 *  Note that even though this software is public domain and there are no
 *  copyright laws that limit what you can do with it, other laws may apply.
 *  For example, if you lie and claim that you wrote this code when you did
 *  not, or you claim that I endorse a product of yours when I do not, that
 *  could be fraud and you could be legally liable.
 *
 *  There is absolutely no warranty for this software!  I am warning you now
 *  that it may or may not work.  It may have bugs that cause you a lot of
 *  problems.  I disclaim any implied warranties for merchantability or fitness
 *  for a particular purpose.  The fact that I have written some documentation
 *  on what I intended this software for should not be taken as any kind of
 *  warranty that it will actually behave that way.  I am providing this
 *  software as-is in the hope that it will be useful.
 *
 *          Chris Wilson, 2003-2004, 2008, 2009
 */


/*
 *  CHUNKS_TO_SKIP is a performance tuning parameter.  It specifies how many
 *  layers of lookup_tree blocks are skipped.  If memory blocks are sparsely
 *  allocated, it's good to skip more.  If they're densely allocated, it's good
 *  to skip fewer.  I experimented using the CWX1 Interpreter Zero code running
 *  on "mult.cwx1", which does enough allocations and de-allocations that
 *  performance is a serious issue.  I found that the value 3 worked best for
 *  that code, so that's what I'm using here.
 */
#define CHUNKS_TO_SKIP 3

typedef struct allocated_block_t allocated_block_t;

struct allocated_block_t
  {
    void *raw_data;
    size_t user_specified_size;
    const char *allocation_file_name;
    size_t allocation_line_number;
    size_t is_free;
    const char *freeing_file_name;
    size_t freeing_line_number;
    allocated_block_t *next;
    allocated_block_t **previous;
    allocated_block_t *next_for_tree;
  };

typedef struct lookup_tree lookup_tree;

struct lookup_tree
  {
    union
      {
        lookup_tree *lookup_tree;
        allocated_block_t *block;
      } u[16];
  };


#ifdef MULTI_THREADED

#include <pthread.h>

static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

#endif /* MULTI_THREADED */


static allocated_block_t *allocated_blocks = NULL;
static allocated_block_t *deallocated_blocks = NULL;
static lookup_tree *tree_top = NULL;
static size_t unfreed_block_count = 0;


static int memory_allocation_limit_enabled = 0;
static size_t memory_allocation_limit = 0;
static size_t memory_allocation_count = 0;
static const unsigned char padding[16] =
  {
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5
  };


static void internal_assert_is_malloced_block(void *pointer,
        size_t minimum_size, size_t exact_size, const char *file_name,
        size_t line_number);
static void check_padding(allocated_block_t *block_data, const char *file_name,
                          size_t line_number);
static allocated_block_t *find_record(void *raw_data);


extern void *test_malloc_implementation(size_t size, const char *file_name,
                                        size_t line_number)
  {
#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    code_point(1);
    if (size == 0)
      {
        code_point(2);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: An attempt was made to"
                " allocate 0 bytes.\n", file_name, (unsigned long)line_number);
        exit(1);
      }
    else
      {
        code_point(3);
      }
    code_point(4);

    if (memory_allocation_limit_enabled != 0)
      {
        code_point(5);
        if (memory_allocation_limit == 0)
          {
            code_point(6);
#ifdef MULTI_THREADED
            pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
            return NULL;
          }
        else
          {
            code_point(7);
          }
        code_point(8);
        --memory_allocation_limit;
      }
    else
      {
        code_point(9);
      }
    code_point(10);

    ++memory_allocation_count;

    if (size > (~(size_t)0) - 32)
      {
        code_point(11);
#ifdef MULTI_THREADED
        pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
        return NULL;
      }
    else
      {
        code_point(12);
      }
    code_point(13);

    void *block = malloc(size + 32);
    if (block == NULL)
      {
        code_point(14);
#ifdef MULTI_THREADED
        pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
        return NULL;
      }
    else
      {
        code_point(15);
      }
    code_point(16);
    allocated_block_t *new_entry =
            (allocated_block_t *)(malloc(sizeof(allocated_block_t)));
    if (new_entry == NULL)
      {
        code_point(17);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: An attempt to allocate"
                " %lu byte%s failed.\n", file_name, (unsigned long)line_number,
                (unsigned long)size, ((size == 1) ? "" : "s"));
        exit(1);
      }
    code_point(18);
    memset(block, 0xa5, 16);
    memset(((char *)block) + (size + 16), 0xa5, 16);
    new_entry->raw_data = block;
    new_entry->user_specified_size = size;
    new_entry->allocation_file_name = file_name;
    new_entry->allocation_line_number = line_number;
    new_entry->is_free = 0;
    new_entry->freeing_file_name = NULL;
    new_entry->freeing_line_number = 0;
    new_entry->next = allocated_blocks;
    new_entry->previous = &allocated_blocks;
    new_entry->next_for_tree = NULL;
    if (allocated_blocks != NULL)
      {
        code_point(19);
        assert(allocated_blocks->previous == &allocated_blocks);
        allocated_blocks->previous = &(new_entry->next);
      }
    else
      {
        code_point(20);
      }
    code_point(21);
    allocated_blocks = new_entry;
    if (unfreed_block_count < ~(size_t)0)
      {
        code_point(22);
        ++unfreed_block_count;
      }
    else
      {
        code_point(23);
      }
    code_point(24);

    lookup_tree **follow_tree = &tree_top;
    size_t chunk_num = 0;
    while (1)
      {
        lookup_tree *node;
        size_t block_num;

        code_point(25);
        node = *follow_tree;

        if (node == NULL)
          {
            size_t init_num;

            code_point(26);
            node = (lookup_tree *)(malloc(sizeof(lookup_tree)));
            if (node == NULL)
              {
                code_point(27);
                fprintf(stderr,
                        "[\"%s\", %lu] Memory allocation error: An attempt to "
                        "allocate %lu byte%s failed.\n", file_name,
                        (unsigned long)line_number, (unsigned long)size,
                        ((size == 1) ? "" : "s"));
                exit(1);
              }
            code_point(28);

            for (init_num = 0; init_num < 16; ++init_num)
              {
                code_point(29);
                if ((chunk_num + CHUNKS_TO_SKIP + 1) == (sizeof(void *) * 2))
                  {
                    code_point(30);
                    node->u[init_num].block = NULL;
                  }
                else
                  {
                    code_point(31);
                    node->u[init_num].lookup_tree = NULL;
                  }
                code_point(32);
              }
            code_point(33);
            *follow_tree = node;
          }
        else
          {
            code_point(34);
          }
        code_point(35);

        block_num = ((((size_t)block) >>
                      (((sizeof(void *) * 2) - (chunk_num + 1)) * 4)) & 0xf);
        if ((chunk_num + CHUNKS_TO_SKIP + 1) == (sizeof(void *) * 2))
          {
            code_point(36);
            new_entry->next_for_tree = node->u[block_num].block;
            node->u[block_num].block = new_entry;
            break;
          }
        code_point(37);

        follow_tree = &(node->u[block_num].lookup_tree);

        ++chunk_num;
      }
    code_point(38);

    memset(((char *)block) + 16, 0xff, size);

#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
    return ((char *)block) + 16;
  }

extern void test_free_implementation(void *ptr, const char *file_name,
                                     size_t line_number)
  {
    unsigned char *outer_block;
    allocated_block_t *block_data;

#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    code_point(39);
    if (ptr == NULL)
      {
        code_point(40);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: An attempt was made to"
                " free a NULL pointer.\n", file_name,
                (unsigned long)line_number);
        exit(1);
      }
    else
      {
        code_point(41);
      }
    code_point(42);

    outer_block = ((unsigned char *)ptr) - 16;
    block_data = find_record(outer_block);
    if (block_data == NULL)
      {
        code_point(43);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: A block with address "
                "%p was freed, but that address doesn't match the address of "
                "any block that was ever allocated.\n", file_name,
                (unsigned long)line_number, ptr);
        exit(1);
      }
    code_point(44);

    if (block_data->is_free)
      {
        code_point(45);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: A block with address "
                "%p was freed twice.\n", file_name, (unsigned long)line_number,
                ptr);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was freed the first"
                " time here.\n", block_data->freeing_file_name,
                (unsigned long)(block_data->freeing_line_number));
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was allocated "
                "here.\n", block_data->allocation_file_name,
                (unsigned long)(block_data->allocation_line_number));
        exit(1);
      }
    code_point(46);

    block_data->is_free = 1;
    block_data->freeing_file_name = file_name;
    block_data->freeing_line_number = line_number;

    memset(ptr, 0xff, block_data->user_specified_size);

    check_padding(block_data, file_name, line_number);

    assert(block_data->previous != NULL);
    assert(*(block_data->previous) == block_data);
    *(block_data->previous) = block_data->next;
    if (block_data->next != NULL)
      {
        code_point(47);
        assert(block_data->next->previous == &(block_data->next));
        block_data->next->previous = block_data->previous;
      }
    else
      {
        code_point(48);
      }
    code_point(49);
    block_data->next = deallocated_blocks;
    if (deallocated_blocks != NULL)
      {
        code_point(50);
        assert(deallocated_blocks->previous == &deallocated_blocks);
        deallocated_blocks->previous = &(block_data->next);
      }
    else
      {
        code_point(51);
      }
    code_point(52);
    deallocated_blocks = block_data;
    block_data->previous = &deallocated_blocks;

    if (unfreed_block_count < ~(size_t)0)
      {
        code_point(53);
        assert(unfreed_block_count > 0);
        --unfreed_block_count;
      }
    else
      {
        allocated_block_t *follow_unfreed;

        code_point(54);
        unfreed_block_count = 0;
        follow_unfreed = allocated_blocks;
        while ((follow_unfreed != NULL) && (unfreed_block_count < ~(size_t)0))
          {
            code_point(55);
            follow_unfreed = follow_unfreed->next;
            ++unfreed_block_count;
          }
        code_point(56);
      }
    code_point(57);
#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
  }

extern void assert_is_malloced_block_implementation(void *pointer,
        const char *file_name, size_t line_number)
  {
#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    code_point(58);
    internal_assert_is_malloced_block(pointer, 0, 0, file_name, line_number);
#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
  }

extern void assert_is_malloced_block_with_minimum_size_implementation(
        void *pointer, size_t size, const char *file_name, size_t line_number)
  {
#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    code_point(59);
    internal_assert_is_malloced_block(pointer, size, 0, file_name,
                                      line_number);
#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
  }

extern void assert_is_malloced_block_with_exact_size_implementation(
        void *pointer, size_t size, const char *file_name, size_t line_number)
  {
#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    code_point(60);
    if (size == 0)
      {
        code_point(61);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: "
                "assert_is_malloced_block_with_exact_size() was called with "
                "size zero specified.\n", file_name,
                (unsigned long)line_number);
        exit(1);
      }
    code_point(62);

    internal_assert_is_malloced_block(pointer, 0, size, file_name,
                                      line_number);
#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
  }

extern size_t unfreed_blocks(void)
  {
    code_point(63);
    return unfreed_block_count;
  }

extern void check_blocks(void)
  {
#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    allocated_block_t *follow;

    code_point(64);
    follow = allocated_blocks;
    while (follow != NULL)
      {
        code_point(65);
        check_padding(follow, __FILE__, __LINE__);
        follow = (follow->next);
      }
    code_point(66);

    follow = deallocated_blocks;
    while (follow != NULL)
      {
        unsigned char *user_data;
        size_t character_num;

        code_point(67);
        check_padding(follow, __FILE__, __LINE__);
        user_data = ((unsigned char *)(follow->raw_data)) + 16;
        for (character_num = 0; character_num < follow->user_specified_size;
             ++character_num)
          {
            if (user_data[character_num] != 0xff)
              {
                code_point(68);
                fprintf(stderr,
                        "Memory allocation error: The memory in a deallocated "
                        "block was written after it was deallocated.\n");
                fprintf(stderr,
                        "Memory allocation error: Address with error: %p\n",
                        &(user_data[character_num]));
                fprintf(stderr,
                        "Memory allocation error: Expected value:     "
                        "0xff.\n");
                fprintf(stderr,
                        "Memory allocation error: Actual value:       "
                        "0x%02x.\n", user_data[character_num]);
                fprintf(stderr,
                        "[\"%s\", %lu] Memory allocation error: It was "
                        "allocated here.\n", follow->allocation_file_name,
                        (unsigned long)(follow->allocation_line_number));
                fprintf(stderr,
                        "Memory allocation error: This is %lu bytes into a "
                        "block of %lu bytes starting at address %p.\n",
                        (unsigned long)character_num,
                        (unsigned long)(follow->user_specified_size),
                        user_data);
                exit(1);
              }
            code_point(69);
          }
        follow = (follow->next);
      }
    code_point(70);
#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
  }

extern void describe_unfreed_blocks(void)
  {
#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    allocated_block_t *follow;

    code_point(71);
    follow = allocated_blocks;
    while (follow != NULL)
      {
        code_point(72);
        fprintf(stderr,
                "[\"%s\", %lu] Memory leak: A block of %lu byte%s allocated "
                "here was never freed.\n", follow->allocation_file_name,
                (unsigned long)(follow->allocation_line_number),
                (unsigned long)(follow->user_specified_size),
                ((follow->user_specified_size == 1) ? "" : "s"));
        follow = (follow->next);
      }
    code_point(73);
#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
  }

extern void set_memory_allocation_limit(size_t allocation_count)
  {
#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    code_point(74);
    memory_allocation_limit_enabled = 1;
    memory_allocation_limit = allocation_count;
#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
  }

extern void clear_memory_allocation_limit(void)
  {
#ifdef MULTI_THREADED
    pthread_mutex_lock(&mutex);
#endif /* MULTI_THREADED */
    code_point(75);
    memory_allocation_limit_enabled = 0;
#ifdef MULTI_THREADED
    pthread_mutex_unlock(&mutex);
#endif /* MULTI_THREADED */
  }

extern size_t get_memory_allocation_count(void)
  {
    code_point(76);
    return memory_allocation_count;
  }


static void internal_assert_is_malloced_block(void *pointer,
        size_t minimum_size, size_t exact_size, const char *file_name,
        size_t line_number)
  {
    unsigned char *outer_block;
    allocated_block_t *block_data;

    code_point(77);
    if (pointer == NULL)
      {
        code_point(78);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was asserted that "
                "NULL was a valid allocated block.\n", file_name,
                (unsigned long)line_number);
        exit(1);
      }
    code_point(79);

    outer_block = ((unsigned char *)pointer) - 16;
    block_data = find_record(outer_block);
    if (block_data == NULL)
      {
        code_point(80);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was asserted that a"
                " block with address %p was a valid allocated block, but that "
                "address doesn't match the address of any block that was ever "
                "allocated.\n", file_name, (unsigned long)line_number,
                pointer);
        exit(1);
      }
    code_point(81);

    if (block_data->is_free)
      {
        code_point(82);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was asserted that "
                "freed block %p was a valid allocated block.\n", file_name,
                (unsigned long)line_number, pointer);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was freed here.\n",
                block_data->freeing_file_name,
                (unsigned long)(block_data->freeing_line_number));
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was allocated "
                "here.\n", block_data->allocation_file_name,
                (unsigned long)(block_data->allocation_line_number));
        exit(1);
      }
    code_point(83);

    check_padding(block_data, file_name, line_number);

    if (block_data->user_specified_size < minimum_size)
      {
        code_point(84);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was asserted that a"
                " block with address %p had at least size %lu, but that block "
                "actually had size %lu.\n", file_name,
                (unsigned long)line_number, pointer,
                (unsigned long)minimum_size,
                (unsigned long)(block_data->user_specified_size));
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was allocated "
                "here.\n", block_data->allocation_file_name,
                (unsigned long)(block_data->allocation_line_number));
        exit(1);
      }
    code_point(85);

    if ((exact_size != 0) && (block_data->user_specified_size != exact_size))
      {
        code_point(86);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was asserted that a"
                " block with address %p had size %lu, but that block actually "
                "had size %lu.\n", file_name, (unsigned long)line_number,
                pointer, (unsigned long)exact_size,
                (unsigned long)(block_data->user_specified_size));
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was allocated "
                "here.\n", block_data->allocation_file_name,
                (unsigned long)(block_data->allocation_line_number));
        exit(1);
      }
    code_point(87);
  }

static void check_padding(allocated_block_t *block_data, const char *file_name,
                          size_t line_number)
  {
    unsigned char *tail_padding;
    unsigned char *outer_block;

    code_point(88);
    outer_block = block_data->raw_data;
    if (memcmp(outer_block, padding, 16) != 0)
      {
        size_t byte_num;

        code_point(89);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: The memory before an "
                "allocated block was written.\n", file_name,
                (unsigned long)line_number);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: Address with error: "
                "%p\n", file_name, (unsigned long)line_number, outer_block);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: Expected value:     "
                "0x", file_name, (unsigned long)line_number);
        for (byte_num = 0; byte_num < 16; ++byte_num)
          {
            code_point(90);
            fprintf(stderr, "%02x", (unsigned)(padding[byte_num]));
          }
        code_point(91);
        fprintf(stderr, "\n");
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: Actual value:       "
                "0x", file_name, (unsigned long)line_number);
        for (byte_num = 0; byte_num < 16; ++byte_num)
          {
            code_point(92);
            fprintf(stderr, "%02x", (unsigned)(outer_block[byte_num]));
          }
        code_point(93);
        fprintf(stderr, "\n");
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was allocated "
                "here.\n", block_data->allocation_file_name,
                (unsigned long)(block_data->allocation_line_number));
        exit(1);
      }
    code_point(94);

    tail_padding = outer_block + block_data->user_specified_size + 16;
    if (memcmp(tail_padding, padding, 16) != 0)
      {
        size_t byte_num;

        code_point(95);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: The memory after an "
                "allocated block was written.\n", file_name,
                (unsigned long)line_number);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: Address with error: "
                "%p\n", file_name, (unsigned long)line_number, tail_padding);
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: Expected value:     "
                "0x", file_name, (unsigned long)line_number);
        for (byte_num = 0; byte_num < 16; ++byte_num)
          {
            code_point(96);
            fprintf(stderr, "%02x", (unsigned)(padding[byte_num]));
          }
        code_point(97);
        fprintf(stderr, "\n");
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: Actual value:       "
                "0x", file_name, (unsigned long)line_number);
        for (byte_num = 0; byte_num < 16; ++byte_num)
          {
            code_point(98);
            fprintf(stderr, "%02x", (unsigned)(tail_padding[byte_num]));
          }
        code_point(99);
        fprintf(stderr, "\n");
        fprintf(stderr,
                "[\"%s\", %lu] Memory allocation error: It was allocated "
                "here.\n", block_data->allocation_file_name,
                (unsigned long)(block_data->allocation_line_number));
        exit(1);
      }
    code_point(100);
  }

static allocated_block_t *find_record(void *raw_data)
  {
    lookup_tree *node;
    size_t chunk_num;

    code_point(101);
    node = tree_top;
    chunk_num = 0;

    while (1)
      {
        size_t block_num;

        code_point(102);
        if (node == NULL)
          {
            code_point(103);
            return NULL;
          }
        code_point(104);

        block_num = ((((size_t)raw_data) >>
                      (((sizeof(void *) * 2) - (chunk_num + 1)) * 4)) & 0xf);
        if ((chunk_num + CHUNKS_TO_SKIP + 1) == (sizeof(void *) * 2))
          {
            allocated_block_t *result;

            code_point(105);
            result = node->u[block_num].block;
            while ((result != NULL) && (result->raw_data != raw_data))
              {
                code_point(106);
                result = result->next_for_tree;
              }
            code_point(107);
            return result;
          }
        code_point(108);

        node = node->u[block_num].lookup_tree;

        ++chunk_num;
      }
  }
