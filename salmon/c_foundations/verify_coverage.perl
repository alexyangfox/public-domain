#!/usr/bin/perl

#
#   This file contains some Perl code to implement part of a simple code
#   coverage testing system.
#
#   Written by Chris Wilson.
#
#   This file is hearby placed in the public domain by its author.
#


#
#       Usage
#
#   This program is part of a very simple code coverage testing system.  I use
#   this system to make sure that my tests for a given source file actually
#   cover all the code in the file that I'm interested in.  The things in this
#   file are fairly self-explanatory.
#
#   This program requires that code_point() macros be placed in the source file
#   being tested, and that the test be run with the source file compiled so
#   that the code_point() macro causes a line to be printed each time it is
#   called.  The line that is printed should be of the form
#
#       Code point <num> reached.
#
#   where <num> is the argument to the code_point() macro.  There should be no
#   duplication of code point numbers within the file being tested (if there
#   is, this program will catch that and report it as an error).
#
#   This program scans the source file for all the uses of the code_point()
#   macro to compile its list of code points.  It then reports an error if the
#   trace file generated by running the test doesn't indicate that all the code
#   points it has found have been reached.
#
#   The command-line of this program should look like
#
#       verify_coverage.perl <log-file> <source-file>
#
#   where <log-file> is the output from all the code_point() calls when running
#   the tests and <source-file> is the name of the C source file whose coverage
#   is being tested.
#
#   Note that this program will not work for all source files!  No attempt has
#   been made to really parse the source file; instead, a crude -- but
#   effective for the source files I care about, namely my own -- parsing
#   algorithm is used to find the calls to the code_point() macro.  It would be
#   easy to write source files that would confuse this program.  One way to
#   confuse this program would be by including something else on the same line
#   as a code_point() macro call.  This program assumes the line consists only
#   of whitespace, then the word code_point, then the opening parenthesis, the
#   argument, the close parenthesis, and a semicolon.  Any other format will
#   confuse this program.  Another way to confuse this program would be using
#   the word code_point in some other context, such as in a comment, in a
#   string literal, or as a local variable.  This code does filter out lines
#   with `#' in them so it won't be confused by preprocessing lines that aren't
#   continued (so that definitions of the code_point() macro don't confuse it)
#   and lines with empty parentheses (so that references in comments to the
#   code_point() macro itself, without arguments specified, are caught), but
#   there are still plenty of ways left to confuse this program.
#
#
#       Requirements
#
#   This program was written using only some of the basic Perl functionality.
#   It was developed using Perl version 5.8.0, but it likely will run under any
#   dialect of Perl 5.  It also uses these basic Unix/Linux command-line
#   utilities: grep, sed, rm, sort, uniq, and diff.  It also uses some basic
#   shell piping characters: `|' and `>'.  The shell syntax this program uses
#   should be applicable to any of the most commonly-used shells: sh, csh,
#   tcsh, bash, etc.  So it is likely to run fine on any Linux system or any
#   modern (1990's or later) flavor of Unix.  It is not likely to run on any
#   version of MS Windows unless Cygwin or some other Unix-like utility package
#   has been installed on that system.
#
#
#       Design Goals
#
#   To understand the usage of this program, it is necessary to understand much
#   about the design goals, so the design goals are largely explained in the
#   ``Usage'' section and will not be repeated here.  It is worth adding here
#   that this was written as a Perl script that has a lot of limitations (on
#   the format of the usage of ``code_point()'' in the source file being
#   tested) because it was not worth the effort of writing something more
#   complete and robust for my present circumstances.  It would take much, much
#   more effort to develop a tool that really parses C, for example, or uses
#   some other method to do code coverage.  I intend to write such tools
#   someday, as part of my multi-lingual compiler, but I have an immediate need
#   that doesn't warrant the huge amount of time better tools would take right
#   now and that in fact is a step toward the infrastructure to develop such
#   tools.  I could also have taken some pre-existing solution instead, but I'd
#   rather have something I can fully own and distribute as public domain with
#   the code that this tool is testing.  I also like knowing that I can fully
#   understand this limited tool because I created it and that I don't have to
#   spend time to learn someone else's tool, which could quite likely take me
#   longer than it took me to create this one.  Those considerations made it
#   worth my while, in my opinion, to put in the limited effort to create this
#   limited tool.  Most immediately, I'm using it for two file, string_index.c
#   and memory_allocation_test.c, and I may use it for a few more files, but
#   only for a limited number of files, and files that I will be creating and
#   fully controlling myself, so the formatting restrictions will be something
#   I can live with.
#
#   Given that this was going to be a limited tool, writing it using Perl and
#   utilities like grep made sense -- it doesn't have enough complexity to need
#   language features to better handle complexity and it already has a lot of
#   limitations.  So Perl adds few drawbacks while giving the advantages of
#   making it take less time to write and have less chance (in my opinion) for
#   bugs (because the operations that it needs to do fit the operations
#   available in Perl and utilities like grep and sed well).
#
#
#       History
#
#   This code was written by me, Chris Wilson, in 2004 and placed in the public
#   domain at that time.  I first implemented much of this in a Makefile in
#   2003 and 2004, then translated it into this Perl script to better allow it
#   to work on more than one source file and to simplify a Makefile that was
#   getting too complicated.  The Makefile was also written by me and placed in
#   the public domain.  All of it is original to me and it is not based on
#   anyone else's work
#
#
#       Legal Issues
#
#   I wrote the original version of this code in Makefile format from scratch,
#   without using or refering to any other code, and I used only that previous
#   version in writing the present one.  Both the original and this version
#   were produced for my own use on my own equipment, not for hire for anyone
#   else, so I have full legal rights to place this code in the public domain.
#
#   I've chosen to put this software in the public domain rather than
#   copyrighting it and using the FSF's GPL or a Berkeley-style ``vanity''
#   license because my personal opinion is that making it public domain
#   maximizes its potential usefulness to others.  Anyone can feel free to use
#   it for any purpose, including with their own proprietary code or with GPL
#   code, without fear of intellectual property issues.  I have no desire to
#   stop anyone else from making money on this code or getting any other
#   advantages they can from it.
#
#   I do request that anyone who finds this software useful let me know about
#   it.  You can drop me e-mail at "Chris Wilson" <chris@chriswilson.info> to
#   let me know how you are using it and what is good and bad about it for you.
#   Bug reports are also appreciated.  Also, if you release a product or
#   software package of some sort that includes this software, I would like you
#   to give me credit in the documentation as appropriate for the importance of
#   my code in your product.  These are requests, not requirements, so you are
#   not legally bound to do them, they're just a nice way to show appreciation.
#
#   Note that even though this software is public domain and there are no
#   copyright laws that limit what you can do with it, other laws may apply.
#   For example, if you lie and claim that you wrote this code when you did
#   not, or you claim that I endorse a product of yours when I do not, that
#   could be fraud and you could be legally liable.
#
#   There is absolutely no warranty for this software!  I am warning you now
#   that it may or may not work.  It may have bugs that cause you a lot of
#   problems.  I disclaim any implied warranties for merchantability or fitness
#   for a particular purpose.  The fact that I have written some documentation
#   on what I intended this software for should not be taken as any kind of
#   warranty that it will actually behave that way.  I am providing this
#   software as-is in the hope that it will be useful.
#
#           Chris Wilson, 2004
#


if ($#ARGV != 1)
  {
    print STDERR "Usage: verify_coverage.perl <log-file> <source-file>\n";
    exit 1;
  }

my $log_file = $ARGV[0];
my $source_file = $ARGV[1];

system("rm -f code_points.txt sorted_code_points.txt " .
       "unique_sorted_code_points.txt tested_code_points.txt " .
       "sorted_tested_code_points.txt unique_sorted_tested_code_points.txt");

my $run_result = system(
        "grep '^Code point ' $log_file | sed 's/^Code point //' | " .
        "sed 's/ reached.\$//' > tested_code_points.txt");
if ($run_result != 0)
  {
    print STDERR "Failed trying to filter code points.\n";
    exit 1;
  }

$run_result = system(
        "sort -n tested_code_points.txt > sorted_tested_code_points.txt");
if ($run_result != 0)
  {
    print STDERR "Failed trying to sort code points.\n";
    exit 1;
  }

$run_result = system(
        "uniq sorted_tested_code_points.txt > " .
        "unique_sorted_tested_code_points.txt");
if ($run_result != 0)
  {
    print STDERR "Failed trying to sort out duplicate code points.\n";
    exit 1;
  }

$run_result = system(
        "grep code_point $source_file | grep -v '\#' | grep -v '()' | " .
        "grep ');' | sed 's/^ *code_point(//' | sed 's/); \\\\//' | " .
        "sed 's/);//' > code_points.txt");
if ($run_result != 0)
  {
    print STDERR "Failed trying to find code points in source file " .
                 "$source_file.\n";
    exit 1;
  }

$run_result = system("sort -n code_points.txt > sorted_code_points.txt");
if ($run_result != 0)
  {
    print STDERR "Failed trying to sort code points from source file " .
                 "$source_file.\n";
    exit 1;
  }

$run_result = system(
        "uniq sorted_code_points.txt > unique_sorted_code_points.txt");
if ($run_result != 0)
  {
    print STDERR "Failed trying to sort out duplicate code points from " .
                 "source file $source_file.\n";
    exit 1;
  }

$run_result = system(
        "diff sorted_code_points.txt unique_sorted_code_points.txt");
if ($run_result != 0)
  {
    print STDERR "Error: Code points in $source_file are not all unique.\n";
    exit 1;
  }

$run_result = system(
        "diff unique_sorted_code_points.txt " .
        "unique_sorted_tested_code_points.txt");
if ($run_result != 0)
  {
    print STDERR "Error: Not all code points of $source_file are tested.\n";
    exit 1;
  }

print STDOUT "Coverage test of $source_file passed.\n";
exit 0;
