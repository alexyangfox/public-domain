/* file "string_aam.c" */

/*
 *  This file contains the implementation of the string_aam type and supporting
 *  functions.
 *
 *  Written by Chris Wilson.
 *
 *  This file is hearby placed in the public domain by its author.
 */


#include <stdlib.h>
#include <stddef.h>
#include <assert.h>
#include "string_aam.h"
#include "memory_allocation.h"
#include "auto_array.h"
#include "auto_array_implementation.h"
#include "try.h"
#include "code_point.h"


/*
 *      Data Structures
 *
 *  After comments and include files, we get to the first real code, a call to
 *  the AUTO_ARRAY_IMPLEMENTATION() macro.  This macro generates the function
 *  definitions to match the function prototypes generated by AUTO_ARRAY(), so
 *  AUTO_ARRAY() needs to be invoked in the header file while
 *  AUTO_ARRAY_IMPLEMENTATION() needs to be invoked in the C file.  Its first
 *  two parameters are the two parameters to AUTO_ARRAY() in the header file --
 *  the name of the type, string_aam, and the element time, pointer to
 *  character.  The third parameter to this macro specifies how much extra
 *  space the implementation needs to maintain after the last element in the
 *  array.  There's no need for our purposes to maintain extra space, so we use
 *  zero for this third parameter value.
 *
 *
 *      Functions
 *
 *  If I've been successful, I've marked every basic block with one use of the
 *  code_point() macro and each one uses a different integer value as the
 *  argument.  In addition to one per basic block, I've added ``else'' blocks
 *  to ``if'' statements where they would not otherwise be necessary just for
 *  the code_point() macros.  This is to make it easier to check that the tests
 *  cover all the code in this file.
 *
 *      deallocate_string_aam_and_elements()
 *
 *  The first function is deallocate_string_aam_and_elements().  The
 *  implementation of this function is entirely straightforward.  At code point
 *  1, we check that the parameter isn't a NULL pointer.  Then, we loop through
 *  the elements of the array, and for each element (code point 2) deallocate
 *  the memory for the string pointed to by that element.  After that (code
 *  point 3), we deallocate the memory for the array itself and we are done.
 *
 *      duplicate_string_and_add_to_string_aam()
 *
 *  The other function is duplicate_string_and_add_to_string_aam().  It, too is
 *  straightforward.  It starts, at code point 4, by checking that both
 *  parameter pointers are non-NULL.  Then, it tries allocating space for the
 *  copy of the string.  If this fails (code point 5) it jumps to the abort
 *  code, defined by the DO_ABORT() macro.  Otherwise (code point 6) it copies
 *  the data from the original string into the copy.
 *
 *  Next, it calls string_aam_append() to append the new string pointer to the
 *  array.  It uses the TRY() macro to check the return value for errors and
 *  jump to the abort code if there is an error.  Then, it returns
 *  MISSION_ACCOMPLISHED to signify success.  Immediately after this success
 *  return comes the DO_ABORT() macro, to generate the code to handle the
 *  failure cases.
 *
 *
 *      History
 *
 *  See the history discussion in string_aam.h for the history of this code.
 *
 *
 *      Legal Issues
 *
 *  I've written this code from scratch, without using or refering to any other
 *  code.  I've written it on my own equipment and not for hire for anyone
 *  else, so I have full legal rights to place it in the public domain.
 *
 *  I've chosen to put this software in the public domain rather than
 *  copyrighting it and using the FSF's GPL or a Berkeley-style ``vanity''
 *  license because my personal opinion is that making it public domain
 *  maximizes its potential usefulness to others.  Anyone can feel free to use
 *  it for any purpose, including with their own proprietary code or with GPL
 *  code, without fear of intellectual property issues.  I have no desire to
 *  stop anyone else from making money on this code or getting any other
 *  advantages they can from it.
 *
 *  I do request that anyone who finds this software useful let me know about
 *  it.  You can drop me e-mail at "Chris Wilson" <chris@chriswilson.info> to
 *  let me know how you are using it and what is good and bad about it for you.
 *  Bug reports are also appreciated.  Also, if you release a product or
 *  software package of some sort that includes this software, I would like you
 *  to give me credit in the documentation as appropriate for the importance of
 *  my code in your product.  These are requests, not requirements, so you are
 *  not legally bound to do them, they're just a nice way to show appreciation.
 *
 *  Note that even though this software is public domain and there are no
 *  copyright laws that limit what you can do with it, other laws may apply.
 *  For example, if you lie and claim that you wrote this code when you did
 *  not, or you claim that I endorse a product of yours when I do not, that
 *  could be fraud and you could be legally liable.
 *
 *  There is absolutely no warranty for this software!  I am warning you now
 *  that it may or may not work.  It may have bugs that cause you a lot of
 *  problems.  I disclaim any implied warranties for merchantability or fitness
 *  for a particular purpose.  The fact that I have written some documentation
 *  on what I intended this software for should not be taken as any kind of
 *  warranty that it will actually behave that way.  I am providing this
 *  software as-is in the hope that it will be useful.
 *
 *          Chris Wilson, 2003-2004, 2008
 */


AUTO_ARRAY_IMPLEMENTATION(string_aam, char *, 0);


extern void deallocate_string_aam_and_elements(string_aam *the_string_aam)
  {
    size_t element_count;
    size_t element_num;

    code_point(1);
    assert(the_string_aam != NULL);

    element_count = the_string_aam->element_count;
    for (element_num = 0; element_num < element_count; ++element_num)
      {
        code_point(2);
        free(the_string_aam->array[element_num]);
      }
    code_point(3);
    free(the_string_aam->array);
  }

extern verdict duplicate_string_and_add_to_string_aam(const char *to_add,
                                                      string_aam *array)
  {
    char *duplicate;

    code_point(4);
    assert(to_add != NULL);
    assert(array != NULL);

    duplicate = MALLOC_ARRAY(char, strlen(to_add) + 1);
    if (duplicate == NULL)
      {
        code_point(5);
        goto abort;
      }

    code_point(6);
    strcpy(duplicate, to_add);
    TRY(abort, string_aam_append(array, duplicate));

    return MISSION_ACCOMPLISHED;

    DO_ABORT(MISSION_FAILED);
  }
