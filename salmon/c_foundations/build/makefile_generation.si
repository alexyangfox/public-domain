/* file "makefile_generation.si" */

/*
 *  This file contains the interface to a module to assist in the generation of
 *  Makefiles.
 *
 *  Written by Chris Wilson.
 *
 *  This file is hearby placed in the public domain by its author.
 */


/*
 *      Usage
 *
 *  This file contains the interface to a module to assist in the generation of
 *  Makefiles.  It takes care of some of the lower-level details so that client
 *  code can be written at a slightly higher level.
 *
 *  The heart of this interface is a procedure, generate_rule(), that client
 *  code calls to generate rules in the Makefile.  Each call generates one
 *  rule.  Along with some information that is printed out in the rule (the
 *  targets, the dependences, and the command to build the target) the client
 *  code passes information to generate_rule() that specifies whether the
 *  target is a concrete or a virtual target.  A concrete target is one that
 *  generate a real file with the same name as the target.  A virtual target is
 *  one that does not generate such a file.  Then, when all those rules have
 *  been generated, the client code can call two procedures to generate two
 *  special rules: one for a ``clean'' target and one for a ``.PHONY'' target.
 *  The clean target is generated to remove all the files from all the concrete
 *  targets for which generate_rule() was called.  Then ``make clean'' will
 *  remove all files generated by the Makefile.  The .PHONY target is a special
 *  target name that means something to GNU make -- that the dependences on
 *  this target are virtual targets not real targets.  So this code generates a
 *  rule for the .PHONY target that includes as dependences all the virtual
 *  targets used in generate_rule() calls.  If GNU make is used, this
 *  communicates extra information to the make utility.  If some non-GNU make
 *  utility is used, it may not understand this rule's special meaning, but it
 *  will be harmless.
 *
 *  This interface consists of one type and nine procedures.
 *
 *  The type declaration is for the target_kind enumerated type.  This type is
 *  used to communicate whether a given target is concrete or virtual.
 *
 *  The first procedure is the init_makefile_generation() procedure.  This
 *  procedure must be called before any of the other procedures in this module
 *  is called.  It will set up some internal datastructures for the rest of the
 *  module.
 *
 *  Next is the deinit_makefile_generation() procedure.  This procedure may,
 *  but need not, be called after all the other calls to procedures in this
 *  module, to deallocate the datastructures used internally by this module.
 *  This might be useful when checking for memory leaks or to free up memory
 *  for something else after this module is no longer going to be used.
 *
 *  The generate_rule() procedure comes next.  This is the procedure that's
 *  called to actually generate a single rule.  The first parameter, ``fp'',
 *  specifies the output into which the rules should be generated.  The next
 *  parameter, ``target'', is a string specifying the primary target of the
 *  rule.  The ``dependences'' parameter specifies a list of strings
 *  representing the dependences of the rules.  The ``command'' parameter
 *  specifies the command to be executed to create the target.  The ``command''
 *  parameter is allowed to be null, in which case the generate_rule()
 *  procedure doesn't generate a command line, only a target line for the rule,
 *  which implies that no action is needed to generate the target from the
 *  sources.  The the_target_kind parameter specifies whether the primary
 *  target is virtual or physical.  Finally, the extra_targets and extra_kinds
 *  parameters specify additional targets, if any, for the rule.  The
 *  extra_targets array's elements are strings specifying the targets.  The
 *  extra_kinds array specifies the kind (virtual or physical) associated with
 *  each of these extra targets.
 *
 *  The generate_command() procedure is used to generate a command for a rule.
 *  It is used by the generate_rule() procedure to generate the specified rule,
 *  so it doesn't have to be called separately for rules that require just one
 *  command.  But for rules that have more than one command, first
 *  generate_rule() should be called with the first command and then
 *  generate_command() should be called for each additional command for that
 *  rule.  It takes two parameters, the output stream specifier and the string
 *  specifying the command.
 *
 *  The register_extra_files_to_clean() procedure specifies a list of
 *  additional file names for files that should be removed by the ``clean''
 *  target.  Since any files that are targets for physical rules generated by
 *  the generate_rule() procedure are already on the list of files for the
 *  clean target, this procedure only needs to be called if there are
 *  additional special files that need to be removed.  It takes one parameter,
 *  which is an array of strings specifying the file names.
 *
 *  The generate_clean_rule() procedure actually generates the ``clean'' target
 *  rule.  It takes only a stream specifying where to write the rule, as the
 *  list of files to be removed comes from prior calls to generate_rule() and
 *  register_extra_files_to_clean().
 *
 *  The generate_phony_rule() procedure generates the ``.PHONY'' target rule.
 *  It also takes only a stream specifying where to write the rule, getting the
 *  list of targets to be considered phony from prior calls to generate_rule().
 *
 *  The generate_list_sources_rule() procedure generates a rule called
 *  ``list_sources''.  When this rule is made, it lists to standard output all
 *  the source files used by other rules that don't in turn have rules to build
 *  them.  These are the files that must be provided to build all the targets.
 *  The files are printed out one per line.  This module figures out the list
 *  of files to print based on the calls it has seen to generate_rule().
 *
 *  Finally, the mark_directory_as_module() procedure modifies the behavior of
 *  the generate_list_sources_rule() procedure.  It specifies that a particular
 *  directory is a module directory.  If a directory is a module directory,
 *  then any dependences on any files in that directory will lead to the
 *  directory itself being listed as a source instead of any of the files
 *  within it.
 *
 *
 *      Error Handling
 *
 *  Any error conditions encountered by this module lead to an exception being
 *  raised.
 *
 *
 *      Requirements
 *
 *  This module requires only an implementation of the Salmon Programming
 *  Language, including the standard runtime library.
 *
 *
 *      History
 *
 *  This code was written by me, Chris Wilson, in C in 2008 and placed in the
 *  public domain at that time.  I first created the code in this interface
 *  file within the "generate_makefile.c" file for use within that file, but
 *  with the idea that if I found it useful I might pull it out into a header
 *  file to be used elsewhere in the future, and that's exactly what happened.
 *
 *  In September 2009, I ported this file from C to Salmon.
 *
 *
 *      Legal Issues
 *
 *  I've written this code from scratch, without using or refering to any other
 *  code.  I've written it on my own equipment and not for hire for anyone
 *  else, so I have full legal rights to place it in the public domain.
 *
 *  I've chosen to put this software in the public domain rather than
 *  copyrighting it and using the FSF's GPL or a Berkeley-style ``vanity''
 *  license because my personal opinion is that making it public domain
 *  maximizes its potential usefulness to others.  Anyone can feel free to use
 *  it for any purpose, including with their own proprietary code or with GPL
 *  code, without fear of intellectual property issues.  I have no desire to
 *  stop anyone else from making money on this code or getting any other
 *  advantages they can from it.
 *
 *  I do request that anyone who finds this software useful let me know about
 *  it.  You can drop me e-mail at "Chris Wilson" <chris@chriswilson.info> to
 *  let me know how you are using it and what is good and bad about it for you.
 *  Bug reports are also appreciated.  Also, if you release a product or
 *  software package of some sort that includes this software, I would like you
 *  to give me credit in the documentation as appropriate for the importance of
 *  my code in your product.  These are requests, not requirements, so you are
 *  not legally bound to do them, they're just a nice way to show appreciation.
 *
 *  Note that even though this software is public domain and there are no
 *  copyright laws that limit what you can do with it, other laws may apply.
 *  For example, if you lie and claim that you wrote this code when you did
 *  not, or you claim that I endorse a product of yours when I do not, that
 *  could be fraud and you could be legally liable.
 *
 *  There is absolutely no warranty for this software!  I am warning you now
 *  that it may or may not work.  It may have bugs that cause you a lot of
 *  problems.  I disclaim any implied warranties for merchantability or fitness
 *  for a particular purpose.  The fact that I have written some documentation
 *  on what I intended this software for should not be taken as any kind of
 *  warranty that it will actually behave that way.  I am providing this
 *  software as-is in the hope that it will be useful.
 *
 *          Chris Wilson, 2003, 2008, 2009
 */

TK_CONCRETE :- any_quark,
TK_VIRTUAL :- any_quark,
target_kind :- {type {TK_CONCRETE, TK_VIRTUAL}},


init_makefile_generation :- {} <-- (),
deinit_makefile_generation :- {} <-- (),
rule :- {} <-- (target : string, dependences : array[string] := *,
        command : string | {null} := *, kind : target_kind,
        extra_targets : array[string] := *,
        extra_kinds : array[target_kind] := *),
command :- {} <-- (command : string),
register_extra_files_to_clean :- {} <-- (extra_file_names : array[string]),
register_extra_clean_command :- {} <-- (command : string),
generate_clean_rule :- {} <-- (),
generate_phony_rule :- {} <-- (),
generate_list_sources_rule :- {} <-- (),
mark_directory_as_module :- {} <-- (directory_name : string)
