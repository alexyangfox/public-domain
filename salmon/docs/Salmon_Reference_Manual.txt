
           The Salmon Programming Language Reference Manual

                            Version 0.18.1


                           by Chris Wilson



        Chapter 1: Introduction
        =======================

The Salmon Programming Language is a general purpose, strongly-typed
programming language.  It may be used with either dynamic or static
typing or a combination of the two.  Salmon supports object-oriented,
imperitive, and functional programming styles.

Salmon is designed specifically to scale well to large programming
projects with contributions from different people, and to a long
lifetime of maintenance and change.  But it is also designed to be
appropriate for scripting, quick little programs, and prototyping.
The intention is to support growing from a small prototype to a
modular, mature production program while staying in the same language.

Salmon is intended to allow programming at a high level, a low level,
or a combination of the two.

Salmon is designed to allow implementation by either an interpreter or
a compiler.  Some of the higher-level constructs in Salmon can require
inefficient code to be generated by a compiler, but often if more
information is given to the compiler in the form of assertions the
compiler can do a better job.

Salmon generally uses C-style syntax as a basis.  There are also some
elements of C++, Pascal, and Perl syntax in Salmon, plus elements of
syntax that are not drawn from any other progamming language.



    Section 1.1: Error Checking Models
    ----------------------------------

Salmon is intended to allow several models for checking of types,
assertions, dererencing null pointers, and various other error
conditions.

One model is completely dynamic, where nothing is checked statically
and an exception occurs if a dynamic check fails.  This checking model
can be appropriate for prototyping.

A second model is to require that all dynamic checks be proven
statically to succeed.  If the compiler or interpreter can't prove
statically that a particular check will succeed, more assertions,
proofs, and explicit checks must be added to the code until the
compiler or interpreter is satisfied that all checks will succeed.  In
this model, more work is required by the programmer and at compile
time, but there is a payoff in more efficient execution and also a
payoff in knowing before a program goes into production use that
certain kinds of failures will never happen.

A third model is to simply assume that checks will succeed and let the
program behave in strange ways if it turns out that the checks don't
hold.

Implementations of other programming languages often use implicit
mixtures of these various models.  For example, what happens if you
follow a null pointer in C is left undefined by the standard, and some
implementations will corrupt random memory, while others will do a
form of dynamic checking in the form of a segmentation fault causing
the program to die.  And assertions in C are typically implemented
with a switch to choose between dynamic checks and the third model,
where failures are ignored.  Salmon is different in being explicit
about the three models and being designed to allow the second model,
with assertions and proofs added by the programmer allowing this
model.

In addition, a mixture of the first and second models can be used,
where a compiler does as much static checking as it can and only
leaves dynamic checks for what it couldn't prove statically.  If this
mode also informs the programmer at compile time about what remains to
be checked dynamically, it can assist the programmer in moving toward
the second model.


    Section 1.2: Implementations
    ----------------------------

The first implementation of Salmon is SalmonEye.  This is a basic
interpreter that doesn't do any static type checking or other many
other static checks.  SalmonEye is designed to get a full
implementation of Salmon up and running quickly and correctly.
SalmonEye is not intended to be a particularly efficient
implementation.

Salmon is designed to allow for efficent compilers, but none yet exist.


    Section 1.3: Terminology
    ------------------------

In Salmon the word ``function'' is used only when a value is being
returned.  The word ``procedure'' is used when no value is being
returned.  The term ``routine'' is used to mean either a function or a
procedure.


        Chapter 2: Values
        =================

Values are central to the execution of a Salmon program.  Values are
computed by evaluating expressions, stored in variables, and passed
around and used in many places.

A value in Salmon is one of the following:

  * A boolean
  * An integer
  * A rational
  * A string
  * A character
  * A regular expression
  * A semi-labeled value list
  * A semi-labeled multi-set
  * A map
  * A quark
  * A lepton
  * A lepton key
  * A slot location
  * Null
  * A jump target
  * A routine
  * A type
  * An object
  * A tagalong key reference
  * A lock reference


    Section 2.1: Tagalongs
    ----------------------

Salmon has a concept called tagalongs that allow arbitrary additional
data to be added to a value without disturbing how that value would be
used if the additional data were not there.

A tagalong is a key, value pair.  Any given value can have arbitrarily
many tagalongs, but the tagalongs will never duplicate keys on the
same value, so the tagalongs can be looked up by key.

The keys are special entities called tagalong keys.  A tagalong key
can be declared in any scope, just like a variable, and the key will
come into existence when the scope begins and go out of existence when
the scope is exited.  This allows tagalongs to be private to
particular scopes, whether that scope is a single function, a class, a
module, or a whole program.

Tagalongs are accessed with the ".." operator and are analagous to
fields in a structure, except that instead of using names as keys,
they use the more general tagalong keys.

Here's an example:

    variable x;
    tagalong t;

    x := 1;

    x..t := 5;

    print(x..t);

This will print "5".

The tagalongs move with the values and are copied with them.  If we
extend the previous example with

    variable y;

    y := x;

    print("x..t is ", x..t, " and y..t is ", y..t);

then we will get "x..t is 5 and y..t is 5" printed.

Tagalongs are intended primarily to allow one module to extend the
data structures of another module without changing that other module.

Tagalongs declarations can also specify types, to allow better static
type checking when working with tagalongs.


    Section 2.2: Boolean Values
    ---------------------------

There are two boolean values, true and false.


    Section 2.3: Integer Values
    ---------------------------

Salmon integer values include all the finite integers plus four
special non-finite values.

Since Salmon has no built-in limits on the size of finite integers,
bugs from overflow of fixed-size integers can be avoided.  Of course,
more memory will be needed for larger integers, in proportion to the
log of the magnitude of the integer.  So at some point, working with
really, really large integers will blow out the memory available for a
program.  For example trying to compute (1 << (1 << 100000)) is nearly
certain to cause memory to run out.

The Salmon type system allows more limited ranges of finite integers
to be used as variable and other types, so for example, values can be
limited to 32-bit unsigned or 32-bit twos-complement ranges, for
example.  This will allow a compiler to generate more efficient code,
but at the expense of the programmer making sure the available ranges
are sufficient.  The programmer can either add assertions to inform
the compiler where values are already in limited ranges or modify the
code to keep values in more limited ranges -- either way, the compiler
can use this information to generate efficient code.

Also, note that a good Salmon compiler will often be able to figure
out that the range of a given variable or other value is limited.  For
example, when iterating over an array, the index into the array cannot
exceed the addressable size of the machine.  The compiler will be able
to use such information to generate more efficient code.

The four special non-finite values that are included as integers in
Salmon are positive infinity, negative infinity, unsigned infinity,
and zero-zero.  Positive infinity can be used as a limiting value
greater than all finite integers and negative infinity can be used as
a limiting value less than all finite integers.  Unsigned infinity can
be used to represent a limiting value with magnitude greater than all
other integers, whether positive or negative.  And zero-zero
represents a sort of ``unknown'' integer value that results from
dividing zero by zero.

These four special values are used to close Salmon arithmetic under
the usual arithmetic operations like addition, subtraction,
multiplication, and division.  The result of dividing one (or any
other non-zero finite integer) by zero is unsigned infinity.  That's
because 1/x as x gets closer and closer to 0 from above and below
tends towards a larger and larger magnitude but either sign.  The
result of 0/0 is zero-zero, a value that is not limited in any way
because x/y as both x and y approach zero doesn't have any limit.  If
you define x/y as the value z such that z*y == x, then if x and y are
zero, any value at all will work for z, so in a sense zero-zero
represents any possible rational value, or ``unknown''.

Outside of Salmon, some floating-point arithmetic systems include
special values including NaN or ``not a number'' and positive and
negative infinity.  zero-zero is the Salmon analog in integers to NaN.


    Section 2.4: Rational Values
    ----------------------------

Any finite rational value in mathematics is a rational value in
Salmon.  In fact, any Salmon integer value is also a rational value,
including the four special non-finite values.  The non-integer
rational values in Salmon are irreducible fractions with a denominator
other than one.

Note that rational values that are mathematically equal are equal in
Salmon.  So 1/3 and 2/6 are the same value in Salmon.  Also, any
rational value that happens to be a mathematical integer is also a
Salmon integer, so the Salmon integer values are a subset of Salmon
rational values.

Salmon does not have built-in floating-point arithmetic.  That's to
keep the core language free of any dependence on floating-point
implementations and multiple incompatible floating-point types
available on the same hardware.  Instead, particular floating-point
types can be imported as modules and used by Salmon programs and they
are considered to be special subsets of the rationals.  So constants
in scientific notation in Salmon such as 6.714e-10 are considered
rationals when they appear by themselves and are converted to
particular floating-point values when they are forced into variables
that use floating-point types.


    Section 2.5: String Values
    --------------------------

Salmon uses Unicode for its strings, and any sequence of non-null
Unicode characters is a string.  The programmer doesn't have to worry
about allocating and de-allocating storage for variable-sized strings.

Note that while conceptually the whole string is passed around as a
value, a typical implementation won't actually copy the string data
but instead copy around multiple pointers to the same string.
SalmonEye uses reference counting to handle de-allocation of string
data.  A good compiler will often be able to eliminate many of the
reference counting steps based on how a string value is used -- for
example, if it is just passed into a function and never stored
anyplace where it will live after the function returns, all that needs
to be passed to the function is a pointer to the data and no reference
counts need to be updated within that function.  Also, the compiler
may be able to figure out limits on string sizes that allow fixed-size
memory buffers to be used for some strings.

Note also that while Salmon specifies that strings are Unicode, how
they are stored in memory is not specified, so a given implementation
may store strings in UTF-8, UTF-16, or UTF-32 encodings in memory, or
use different encodings in different places in the same program.

Unlike C, C++, and many other programming languages, strings are not
the same as arrays of characters.  Standard library functions can be
used to convert between character arrays and strings, but they are not
the same.


    Section 2.6: Character Values
    -----------------------------

In Salmon, a character value is a Unicode character.

Note that unlike C, C++, and some other programming languages,
character values are different from integer values.  They are not
8-bit integers, 16-bit integers, 32-bit integers, or any other
integers.  Standard library functions can be used to convert between
characters and integers, but they are not the same.  Note also that
the conversion must specify UTF-8, UTF-16, or UTF-32 encodings -- one
character doesn't necessarily fit in one 8-bit integer.


    Section 2.7: Regular Expression Values
    --------------------------------------

Unlike C or C++ but like Perl and some other scripting languages,
regular expressions are built-in to Salmon.  In particular, regular
expressions can be specified as literals in a Salmon program and there
are standard library routines for dealing with them and matching
strings with them.


    Section 2.8: Semi-Labeled Value List Values
    -------------------------------------------

A semi-labeled value list is a value constructed from other values.
It consists of a finite list of values.  In addition, some of those
values may, but need not, have labels associated with them.  Labels
are strings, and no two labels in a single semi-labeled value list can
be identical.

A semi-labeled value list is like a cross between an array and an
anonymous structure in C or C++ or a record in Pascal.  It has
ordering information like an array.  And it can have field names
associated with the values, like a structure.  In fact, in the special
case where there are no labels, a semi-labeled value list is an array
in Salmon.  However, not all arrays in Salmon are semi-labeled value
lists, because Salmon also supports sparse arrays and arrays that
start somewhere other than zero.  See Section 2.10 on map values for
full details on arrays in Salmon.


    Section 2.9: Semi-Labeled Multi-Set Values
    ------------------------------------------

A semi-labeled multi-set value is like a semi-labeled value list value
except with the ordering information removed.  So two semi-labeled
multi-set values are identical if they have the same set of values and
the same labels associated with those values without regard to
ordering.  A semi-labeled multi-set with labels on all values in
Salmon is more analagous to an anonymous structure in C or C++ than
any other Salmon value is.


    Section 2.10: Map Values
    ------------------------

A map value in Salmon is a set of key, value pairs, where each of the
key and value can be any value.  No two pairs can share the same key.

In the special case where all the keys are finite integers, this is an
array.  In fact the term ``array'' in Salmon is used to refer to maps
with only finite integers as keys.

In the special case where all the keys are strings, this is analagous
to hash values in Perl.

Map values in Salmon are generally used to lookup values by key.  A
typical implementation of Salmon will make maps with only string keys
efficient for getting and setting values, and will make maps with only
a specific dense range of integer values as keys even more efficient
for getting and setting values.  Using key values other than integers
and strings with large maps may not be efficient.

Note that the set of key, value pairs does not have to be finite.  In
Salmon, it is possible to create a map that maps all odd integers to
the value 17 and all even integers to the value 23.  This is done with
syntax that allows a map to be created where all the key values in a
given type map to a specified value.


    Section 2.11: Quark Values
    --------------------------

In Salmon, a quark is a special value that is distinguishable from all
other values.  It has no particular properties other than the fact
that it is different from all other values.

This is somewhat analagous to enumeration constants in C and even
moreso in C++, which better separates enumeration constants and
integer values.  Unlike C++, in Salmon, quarks can be created and
destroyed dynamically.  For example, a quark can be declared locally
in a function and will exist only within that call to the function.
If the function is called recursively, each instantition of the
function will have its own version of that quark distinguishable from
the others.  As with local variables, when the scope that declares it
exits, a quark disappears, and it is illegal to use it after that
point.  Quarks can also be created and destroyed dynamically using
quark declaration expressions -- the equivalent of heap allocation of
memory.

This helps avoid conflicts and confusion between different modules
that happen to use the same name for enumeration constants for
different purposes.

A good compiler will often be able to use simple integer constants to
implement quarks in most cases.


    Section 2.12: Lepton Values
    ---------------------------

A lepton is a lepton key paired with a set of fields, each with a name
and value.

This is a generalization of named structure types in C and C++.  The
lepton key serves as a name, distinguishing two different values that
happen to have the same field names but different meanings.  But using
a lepton key as the tag instead of a name makes the concept more
general, for example allowing different instances of a class to keep
their structures distinct from one another.  A lepton key is like a
quark in that it can be declared in a scope or dynamically.


    Section 2.13: Lepton Key Values
    -------------------------------

A lepton key by itself can be used as a value.  This allows lepton
keys to be passed around to be used to construct leptons without the
code that constructs the lepton having to be hard-coded to using a
particular lepton key.


    Section 2.14: Slot Location Values
    ----------------------------------

A slot location value in Salmon is a generalized pointer.  It is a
handle that can be used to read or write values to or from memory.  It
can be used to access a variable, space allocated on the heap, or
sub-components of values in variables or on the heap.  For example, if
x is a variable containing an array of 10 elements, one slot location
will access all of x and another will access element 3 of x.  The term
``slot'' is used because a slot is someplace something can be stuck in
or pulled out.  In Salmon, values can be stuck in slots or pulled out
of them, and a slot location is a handle to a slot.

It is illegal to use a slot value after the space it is refering to is
de-allocated.  Such de-allocation happens when the scope containing a
local variable exits or heap-allocated memory is de-allocated
explicitly.

Note that null is not a slot location value, it is a separate value.


    Section 2.15: Null Values
    -------------------------

Null is a single value that is distinct from all other values.  It is
usually used to indicate no valid value of another sort, such as a
slot location, is appropriate.


    Section 2.16: Jump Target Values
    --------------------------------

A jump target is a particular place that control can jump to.  This is
a generalization of a label in C or C++.  But unlike C or C++,
non-local jumps are allowed, and label references can be stored and
passed around like any other value.

Note that like a pointer to a variable, a jump target is more than
just a reference to a particular static instance.  It includes the
information about the instance of the scope it is in.  If a routine
calls itself recursively, each call has a different jump target for
the same label.

When a scope exits, any jump targets associated with that instance
cease to exist.  It is illegal to use a jump target after this, just
as it is illegal to follow a pointer to a local variable after the
local variable's scope has exited.

Since jump targets cease to exist when their enclosing scopes exit,
jumps can be used to move around within the local scope or to jump
back up to an enclosing scope, potentially through many procedure
calls.  In this sense, they are are analagous to C's
setjump()/longjump().  But while jumping out to an enclosing scope,
some cleanup is done while unwinding the stack.  This includes calling
destructors for local variables in the parts of the stack being
unwound.  It also includes executing explicit ``cleanup'' code that
may be specified for any scope.  In this sense, it is parly analagous
to C++'s exception handling.

While doing stack unwinding, arbitrarily complex code can be executed
in cleanup sections and local variable destructors.  This code can
also do its own jumps within the destructor or cleanup scopes.  But if
it tries to jump out of the destructor or cleanup scopes, then there
are two conflicting stack unwinds going on at the same time.  In that
case, stack unwinding continues, potentially with even more pending
jumps being added.  If the unwinding reaches a scope with one or more
of the pending jump targets but not all of them, those pending jump
targets are ignored and unwinding continues until a scope is reached
that contains all the remaining pending jump targets.  At that point,
the most recently added pending jump target takes precedence and the
others are ignored.


    Section 2.17: Routine Values
    ----------------------------

In Salmon, a routine is a first-class object and may be stored and
passed around.  This is a little like function pointers in C or C++,
except that since there are functions at non-global scope, a routine
value needs to include both information about the code to execute and
information about the context of that routine.

In addition, in Salmon anonymous routines can be created on the fly
and passed around.  But they still include context information as they
are passed around.  For example, if an anonymous routine is created
inside a function and refers to a local variable in that function, and
that routine is then passed through a recursive call to the same
function, the reference must be to the local variable in the context
in which the routine was created, not the one in which it was called.
Since anonymous routines have local scope information, it is illegal
to call them after the scope in which they were created exits.

Note that thanks to overloading, a routine value can actually be an
ordered list of routines.  This is called a routine chain.  Which
routine is actually called depends on the actual arguments at call
time.  Two routine values are considered equal if and only if they
consist of exactly the same list of routine instances in the same
order.


    Section 2.18: Type Values
    -------------------------

Types are first-class objects in Salmon, so they can be used as
values.  See Chapter 3 for complete information on types.


    Section 2.19: Object Values
    ---------------------------

An object value in Salmon is an instantiation of a class.


    Section 2.20: Tagalong Key Values
    ---------------------------------

A tagalong key in Salmon can be passed around and used to access
tagalong fields of other values.


    Section 2.21: Lock Reference Values
    -----------------------------------

In Salmon, locks are used for synchronization when doing
multi-threading.  Locks can be declared in any scope and, like local
variables, appear when the scope is entered and disappear when it is
exited.  They can also be dynamically generated and destroyed through
lock declaration expressions.  A lock value in Salmon refers to a
particular instance of a lock.

Locks can be used to ensure that only one thread does particular
things at particular times.  The programmer can use library routines
to explicitly grab and release a lock, or special syntax can be used
to specify that before particular actions are taken a lock is grabbed
and after those actions that lock is released.


        Chapter 3: Types
        ================

In Salmon, a type is simply a set of values.  For a given type, every
value is either in that type or it is not.

Unlike C, C++, and many other programming languages, values don't
carry types with them.  In C++, for example, the char 12 is different
from the long 12 and one must be converted to the other, either
explicitly or implicitly.  In C++, it is the type, not the value, that
is used for overloading resolution.

Salmon is different.  Any given value is simultaneously in many
different types.  The value itself is used for overloading
resolution.  At run time, the list of candidate functions is traversed
until one is found whose types fit with the values being passed.  Note
that while conceptually this happens at run time, in practice, when
decent type information is provided to the compiler, a decent compiler
should usually be able to resolve overloading at compile time and
generate more efficient code.

In Salmon, new types can be constructed by taking unions and
intersections of any existing types.  A finite list of values can be
specified to form a type.  In fact, in theory, any finite or infinite
set of Salmon values is a type.

In practice, types are constructed using type expressions and some
standard library functions and immutables.  See Section 5.4, on type
expressions, for details on forming types in Salmon.


        Chapter 4: Tokens
        =================

In Salmon, as in many programming languages, the meaning of text in
the language is specified as a two-step process.  In the first step,
the input text is broken up into a sequence of tokens and in the
second step that sequence of tokens is parsed into language
constructs.  This two-step process is a concept used to specify the
meaning of an input text -- an implementation, of course, is free to
combine the steps in any way it wishes as long as it gets the same
meaning.  This chapter is about the first of these two steps: breaking
the input into a sequence of tokens.

Input programs in Salmon are in Unicode.  Further, while Salmon
programs may use non-ASCII Unicode characters, there are always
equivalent Salmon programs that use only the ASCII character set, so
only ASCII is necessary to write Salmon programs.  Non-ASCII Unicode
characters may be used within comments and within string, character,
regular expression, and backtick literals.  When used within literal
tokens they are used as data to help the program handle arbitary
Unicode, but Salmon also supports escape sequences to ASCII characters
to specify arbitary Unicode characters, so the non-ASCII characters
need not appear in the source code.

Between tokens, any amount of whitespace and/or comments may appear.
Such whitespace and comments do not affect the meaning of the
program or the sequence of tokens.  Whitespace is not allowed within
tokens except in a few kinds of tokens where the description of the
token below explicitly mentions it.  If not explicitly mentioned, no
whitespace or comments are allowed within tokens.

There are three forms of comments in Salmon:

  * C-style /* ... */ comments.  Such comments start with a "/"
    character followed by a "*" character with nothing in between and
    end with a "*" followed by a "/" with nothing else in between.
    Unlike C, such comments in Salmon may be nested.  So if there are
    several occurances of "/*", the comment doesn't end until all of
    them have matching "*/" sequences.

  * //.  Two forward-slash characters in a row mean that everything
    else until the end of the line is a comment.  Either a carriage
    return or a line feed character is considered the end of a line,
    so either Unix-style (CR) or DOS-style (CR-LF) text files may be
    used.

  * #.  Everything after a "#" character (pound, number sign, sharp,
    octothorp, or whatever else you want to call this character) that
    is not part of a token until the end of the line is a comment.
    This means that text files containing Salmon programs can be made
    directly executable on UNIX/Linux style systems where a program
    that starts with a line like this:

        #!/usr/local/bin/salmoneye

    is used to specify which interpreter to use to run an executable
    script.

Note that a "/*", "//", or "#" sequence is not considered to start a
comment if it can be interpreteed as part of a legal token.  These
sequences can legally appear in string literals, regular expression
literals, backtick expression literals, and, in the case of "#",
character literals.

Tokenization is defined as being greedy -- the longest possible
sequence that could be considered a single token is taken as the next
token.  For example, "12" is considered the single token representing
the integer twelve, not two tokens representing one and two.

There are ten kinds of tokens in Salmon:

  * punctuation
  * identifiers
  * string literals
  * character literals
  * decimal integer literals
  * hexadecimal integer literals
  * infinite integer literals
  * scientific notation literals
  * regular expression literals
  * backtick expression literals


    Section 4.1: Punctuation
    ------------------------

There are 57 punctuation tokens in Salmon.  Each consists of from one
to three ASCII punctuation characters.  Here are the 56 punctuation
tokens, with some notes on how Salmon uses them:

  * "(" -- Used to indication the start of a grouping, and always
           matched with a corresponding ")" or "]" token to end the
           grouping.

  * ")" -- Used to indicate the end of a grouping, and always matched
           with a corresponding "(" or "[" token that started the
           grouping.

  * "[" -- Used to indicate the start of arguments to a lookup or
           lepton expression; the start of a semi-labeled value list
           expression; the start of a range expression; the start of a
           compound basket; the start of arguments to an array,
           fields, lepton, multi-set, or interface type expression;
           the start of a range type expression; the start of a
           semi-labeled value list type expression; and the start of
           arguments to a lepton declaration.  It is always matched
           with a correpsonding "]" or ")" token that follows.

  * "]" -- Used to indicate the end of a syntactic unit whose start
           was indicated by an earlier "[" or "(" token.

  * "{" -- Used to indicate the start of a block of statements; the
           start of a list of enumeration values; and the start of a
           list of proof step items.  It is always matched with a
           correpsonding "}" token that follows.

  * "}" -- Used to indicate the end of a syntactic unit whose start
           was indicated by an earlier "{" token.

  * ":" -- Used as part of the syntax of lookup expression elements
           that specify filter types; as part of the syntax of map
           list expression elements that specify filter types; as part
           of the syntax of conditional expressions; to indicate a
           statement is a label statement; and to indicate the type of
           a data declaration, use statement, lepton field item of a
           lepton declaration, interface type declaration item, field
           type declaration item, and routine parameter item.

  * ";" -- Used to indicate the end of a statement for most kinds of
           statements; as part of the internal syntax of for and
           iterate statements; and to indicate the end of a proof
           item.

  * "," -- Used to separate the items in various kinds of lists.

  * "." -- Used to indicate a field reference and that a pointer or
           interface type allows null.

  * ".." -- Used to indicat a tagalong field reference.

  * "..." -- Used to separate the lower from upper bounds in an
             integer range and at the end of a list to indicate
             arbitary additional elements are allowed.

  * "...." -- Used to separate the lower from upper bounds in a
              rational range.

  * ":=" -- Used to indicate simple assignment of a value.

  * "::=" -- Used to indicate assignment that forces a value to the
             required type if necessary.

  * "*=" -- Used to indicate a multiply-and-assign operation.

  * "/=" -- Used to indicate a divide-and-assign operation.

  * "/::=" -- Used to indicate a divide-force-and-assign operation.

  * "%=" -- Used to indicate a remainder-and-assign operation.

  * "+=" -- Used to indicate an add-and-assign operation.

  * "-=" -- Used to indicate a subtract-and-assign operation.

  * "<<=" -- Used to indicate a left-shift-and-assign operation.

  * ">>=" -- Used to indicate a right-shift-and-assign operation.

  * "&=" -- Used to indicate a bitwise-and-and-assign operation.

  * "^=" -- Used to indicate a bitwise-exclusive-or-and-assign
            operation.

  * "|=" -- Used to indicate a bitwise-inclusive-or-and-assign
            operation.

  * "&&=" -- Used to indicate a logical-and-and-assign operation.

  * "||=" -- Used to indicate a logical-or-and-assign operation.

  * "~=" -- Used to indicate a concatenate-and-assign operation.

  * "++" -- Used to indicate an increment operation.

  * "--" -- Used to indicate a decrement operation.

  * "*" -- Used to indicate a multi-key item in lookup and map list
           expressions; to indicate a dereference operation as a unary
           prefix operator; to indicate multiplication as a binary
           operator; to indicate a readable pointer type expression;
           to indicate that a parameter list can include arbitrary
           additional items in a routine type argument list; and, in
           conjunction with a ":=" token, that an item in a routine
           type argument list requires a default expression.

  * "/" -- Used to indicate division as a binary operator and to
           specify a dynamic type for a return type or parameter type
           in a routine declaration.

  * "/::" -- Used to indicate a divide operation followed by a force
             operation to force the result to an integer.

  * "%" -- Used to indicate indicate a remainder operation as a binary
           operator.

  * "+" -- Used as the counterpart to "-" as a unary operator; to
           indicate addition as a binary operator; and to indicate a
           pointer type requires the pointer to be writable.

  * "-" -- Used to indicate negation as a unary prefix operator; to
           indicate subtraction as a binary operator; and to indicate
           that a field need not be writable in a fields type
           expression.

  * "<<" -- Used to indicate the start of a map list expression; to
            indicate left shift as a binary operator; and to indicate
            the start of an expression type expression.

  * ">>" -- Used to indicate the end of a map list expression; to
            indicate right shift as a binary operator; and to indicate
            the end of an expression type expression.

  * "&" -- Used to indicate a location-of expression as a unary prefix
           operator; to indicate bitwise-and as a binary operator; and
           to indicate union as a binary type operator.

  * "^" -- Used to indicate bitwise-exclusive-or as a binary operator
           and to indicate type exclusive or as a binary type
           operator.

  * "|" -- Used to indicate bitwise-inclusive-or as a binary operator
           and to indicate intersection as a binary type operator.

  * "&&" -- Used to indicate logical-and as a binary operator.

  * "||" -- Used to indicate logical-or as a binary operator.

  * "==" -- Used to indicate "is equal to" as a binary operator.

  * "!=" -- Used to indicate "is not equal to" as a binary operator.

  * "<" -- Used to indicate "is less than" as a binary operator.

  * ">" -- Used to indicate "is greater than" as a binary operator.

  * "<=" -- Used to indicate "is less than or equal to" as a binary
            operator.

  * ">=" -- Used to indicate "is greater than or equal to" as a binary
            operator.

  * "!" -- Used to indicate logical not as a unary prefix operator;
           to indicate type complement as a unary prefix type
           operator; and as the end of a print line statement.

  * "?" -- Used as part of the syntax of conditional expressions.

  * "->" -- Used to indicate a pointer field reference.

  * "~" -- Used to indicate bitwise not as a unary prefix operator and
           to indicate concatenation as a binary operator.

  * "<--" -- Used to separate the return type from the parameter type
             list in a routine type expression.

  * "-->" -- Used to separate the key specification from the target
             value specification in a map expression item and to
             separate the key type from the target type in a map type
             expression.

  * "::" -- Used to indicate forcing a specified value to a specified
            type.


    Section 4.2: Identifiers
    ------------------------

In Salmon, an identifier starts with one of the 26 lower-case English
letters, one of the 26 upper-case English letters, or an underscore.
It continues with any number of additional characters that are one of
the characters that can start an identifier or one of the ten decimal
digits.

In addition, there are 23 special identifiers consisting of the string
"operator" followed by one to three puctuation characters.  The
identifiers are intended to allow operator overloading, and
declarations with these names can affect how the corresponding
operators work, but they can be used anywhere any other identifier
could be used.  These are the 23 sequences of punctuation characters
that can be used for form these special identifiers.

  * "()"

  * "[]"

  * "::"

  * "*"

  * "/::"

  * "/"

  * "%"

  * "+"

  * "->"

  * "-"

  * "<<"

  * "<="

  * "<"

  * ">>"

  * ">="

  * ">"

  * "&"

  * "^"

  * "|"

  * "=="

  * "!="

  * "!"

  * "~"


    Section 4.3: String Literals
    ----------------------------

A string literal specifies a particular string value.  It consists of
a double quote character, any number of character specifiers
(including zero), and then ends with another double quote character.

A character specifier specifies exactly one character of the string
value, but it may consist of more than one character in the source
code.  A character specifier is one of the following:

  * Any single unicode character other than newline, double quote, or
    backslash.  In this case, the character specified is simply that
    character in the source.

  * Two backslash characters.  In this case, the character specified
    is a single backslash character.

  * A backslash followed by a single quote character.  In this case,
    the character specified is a single quote character.

  * A backslash followed by a double quote character.  In this case,
    the character specified is a double quote character.

  * A backslash followed by a question mark character.  In this case,
    the character specified is the question mark character.

  * A backslash followed by the lower-case letter "a".  In this case,
    the character specified is a bell character (a non-printing
    character).

  * A backslash followed by the lower-case letter "b".  In this case,
    the character specified is a backspace character.

  * A backslash followed by the lower-case letter "f".  In this case,
    the character specified is a formfeed character.

  * A backslash followed by the lower-case letter "n".  In this case,
    the character specified is a newline character.

  * A backslash followed by the lower-case letter "r".  In this case,
    the character specified is a carriage return character.

  * A backslash followed by the lower-case letter "t".  In this case,
    the character specified is a horizontal tab character.

  * A backslash followed by the lower-case letter "v".  In this case,
    the character specified is a vertical tab character.

  * A backslash followed by 1, 2, or 3 octal digits (0-7).  In this
    case, the character specified is the Unicode character with index
    specified by the digits taken as an octal representation.  At
    least one of the digits is required to be non-zero, since the null
    character is not allowed in Salmon string and character values.

    The largest possible such sequence is assumed to be the character
    specifier -- so \34 is always taken as a single character
    specifier, not the character specifier \3 followed by the
    character specifier 4, for example.

    Note that not all Unicode characters may be specified with this
    form.  It is allowed for compatibility with C's string literal
    specification.

  * A backslash followed by the lower-case letter "x" and then a
    sequence of one or more hexadecimal digits (each is one of: the
    decimal digit 0-9, the upper-case letters A-F, or the lower-case
    letters a-f).  The largest possible such sequence is assumed to be
    the character specifier.  In this case, the character specified is
    the Unicode character with index specified by the hexadecimal
    digits.  It is an error if the index is zero, since the null
    character is not allowed in Salmon string and character values, or
    greater than 0x1fffff, as that is the largest index allowed for in
    the Unicode character encoding scheme.

    Note that any Unicode character may be specified this way.  It is
    legal to do so regardless of whether the specified Unicode
    character is reserved or unassigned in any particular version of
    the Unicode standard.


    Section 4.4: Character Literals
    -------------------------------

A character literal specifies a particular character value.  It
consists of a single quote character, exactly one character specifier,
and then ends with another single quote character.  The rules for the
character specifier are the same as those listed in Section 4.3 for
string literal character specifiers, except that a double quote
character by itself is allowed as a character specifier and a single
quote character by itself is not.


    Section 4.5: Decimal Integer Literals
    -------------------------------------

A sequence of one or more consecutive decimal digits (0-9) is a
decimal integer literal token.  The value it represents is the usual
decimal interpretation of a sequence of digits.

Note that only non-negative integers can be represented by decimal
integer literals.  Negative integers can be generated by applying a
minus sign before the integer literal, but this is two different
tokens, not a single literal token.


    Section 4.6: Hexadecimal Integer Literals
    -----------------------------------------

The prefix "0x" or "0X" (a zero character followed by either an upper-
or lower-case letter X) followed by one or more hexadecimal digits is
a hexadecimal integer literal token.  A hexadecimal digit is a decimal
digit (0-9), one of the lower-case letters "a" through "f", or one of
the upper-case letters "A" through "F".  The value it represents is
the usual hexadecimal interpretation of a sequence of hexadecimal
digits.


    Section 4.7: Infinite Integer Literals
    --------------------------------------

There are exactly two strings that form infinite integer literal
tokens: "+oo" and "-oo".  The former represents the value positive
infinity and the later represents the value negative infinity.


    Section 4.8: Scientific Notation Literals
    -----------------------------------------

A sequence of one or more consecutive decimal digits followed by
one of a decimal fractional part, an exponent part, or a decimal
fractional part followed by an exponent part is a scientific notation
literal token.  A decimal fractional part is a dot character followed
by a sequence of one or more decimal digits.  An exponent part is the
upper- or lower-case letter E, optionally followed by a plus or minus
sign character, followed by a sequence of one or more decimal digits.

If the decimal fractional part is present, the dot character is taken
as a decimal point and the following digits are interpreted in the
usual way for the digits following a decimal point.  In this case, the
mantissa is defined as the rational value of the initial digits plus
the fraction specified by the decimal part.

If the decimal fractional part is not present, the mantissa is defined
as the integer value specified by the initial decimal digits.

If the exponent part is not present, the value of the token is the
mantissa value.  If the exponent part is present, the value of the
token is the mantissa times ten to the power of the exponent, where
the exponent is defined by the digits of the exponent part interpreted
in the usual way as a decimal integer, modified by the sign character
in the exponent part, if present (a minus sign means to negate the
exponent value).

Note that only non-negative rationals can be represented by scientific
notation literal tokens.  Negative rationals can be generated by
applying a minus sign in front, but this is considered two tokens,
with the minus sign being a unary negation operator that is applied to
the non-negative value of the literal token.


    Section 4.9: Regular Expression Literals
    ----------------------------------------

A regular expression literal starts and ends with an at-sign character
("@"), with the characters in between forming a regular expression
pattern.

Regular expression literals specify regular expressions that match
strings of Unicode characters.  The set of regular expressions allowed
in Salmon exactly matches the definition of a regular expression in
programming language theory, unlike some languages, such as Perl, that
have "regex" pattern matching that includes extensions beyond the
standard linguistic definition of a regular expression.  Because the
scope is limited to true regular expressions, these patterns can be
used to do matching with strict limits on the amount of time taken to
do matches.

The regular expression between the at-sign characters is specified
recursively as follows:

  * The empty string is a regular expression pattern that matches only
    the empty string.

  * Any character other than "@", "(", ")", "\", "|", "*", "+", "?",
    "{", "[", ".", "^", and "$" is a regular expression pattern that
    matches only the single character string that is that character.
    Note that this not only ASCII characters but any Unicode
    characters.

  * Any two regular expression patterns concatenated together is a
    regular expression pattern.  It matches those strings that are the
    concatenation of two strings, with the first string matching the
    first pattern and the second string matching the second pattern.

  * An open parenthesis character ("("), then a regular expression
    pattern, then a close parenthesis character (")") is a regular
    expression pattern that matches exactly what its component regular
    expression matches.

  * A backslash followed by any character other than one of the 26
    English lower-case letters or one of the 26 English upper-case
    letters is a regular expression pattern that matches only the
    single character string that is the character folowing the
    backslash.  Note that this includes the at sign character ("@"),
    so this character can be embedded within a regular expression
    literal, so an at sign character only indicates the end of the
    regular expression literal if it is not part of such an escape
    sequence.

  * A backslash followed by the lower-case letter "a" is a regular
    expression pattern that matches only the single-character string
    that has the bell character as its one element.

  * A backslash followed by the lower-case letter "b" is a regular
    expression pattern that matches only the single-character string
    that has the backslash character as its one element.

  * A backslash followed by the lower-case letter "f" is a regular
    expression pattern that matches only the single-character string
    that has the formfeed character as its one element.

  * A backslash followed by the lower-case letter "n" is a regular
    expression pattern that matches only the single-character string
    that has the newline character as its one element.

  * A backslash followed by the lower-case letter "r" is a regular
    expression pattern that matches only the single-character string
    that has the carriage return character as its one element.

  * A backslash followed by the lower-case letter "t" is a regular
    expression pattern that matches only the single-character string
    that has the horizontal tab character as its one element.

  * A backslash followed by the lower-case letter "v" is a regular
    expression pattern that matches only the single-character string
    that has the vertical tab character as its one element.

  * A backslash followed by the lower-case letter "s" is a regular
    expression pattern that matches only the six single-character
    strings whose single characters are whitespace characters.  Those
    characters are the space, horizontal tab, vertical tab, newline,
    carriage return, and formfeed characters.

  * A backslash followed by the lower-case letter "d" is a regular
    expression pattern that matches only the ten single-character
    strings whose single characters are decimal digit characters.

  * A backslash followed by the lower-case letter "h" is a regular
    expression pattern that matches only the twenty-two
    single-character strings whose single characters are hexadecimal
    digit characters (0-9, a-f, and A-F).

  * A backslash followed by the upper- or lower-case letter X followed
    by one or more hexadecimal digits (0-9, a-f, and A-F) is a regular
    expression pattern that matches only the single-character string
    that has as its one character the Unicode character with code
    point specified by the hexadecimal digits.  It is illegal if the
    value is zero, greater than 0x10ffff, or in the range 0xd800
    through 0xdfff (inclusive), as those are not valid Unicode code
    points.

  * A regular expression pattern followed by the character "|"
    followed by another regular expression pattern is a regular
    expression pattern.  The set of strings it matches is the set of
    strings the first pattern matches plus the set of strings the
    second pattern matches.

  * A regular expression pattern followed by a "*" character is a
    regular expression pattern.  The set of strings it matches is the
    set of strings made up by concatenating zero or more component
    strings where each component matches the pattern that is the
    argument of this pattern.

  * A regular expression pattern followed by a "+" character is a
    regular expression pattern.  The set of strings it matches is the
    set of strings made up by concatenating one or more component
    strings where each component matches the pattern that is the
    argument of this pattern.

  * A regular expression pattern followed by a "?" character is a
    regular expression pattern.  The set of strings it matches is the
    set of strings that match the component pattern of this pattern
    plus the empty string.

  * A regular expression pattern followed by a "{" character followed
    by zero or more decimal digits (0-9) followed by a comma followed
    by zero or more additional decimal digits followed by a "}"
    character is a regular expression pattern.  The first set of
    digits specifies a lower bound integer and the second set of
    digits specifies an upper bound integer.  If the first set of
    digits is zero length, the lower bound is zero.  If the second set
    of digits is zero length, there is no upper bound.  This regular
    expression matches all strings which are the concatenation of some
    number of strings where each component string matches the base
    pattern and the number of components is greater than or equal to
    the lower bound and, if there is an upper bound, the number of
    components is less than or equal to the upper bound.

  * The character "[" followed optionally by the character "^"
    followed by zero or more character specifiers followed by the
    character "]" is a regular expression pattern.  Each character
    specifier is either a basic character specifier or a basic
    character specifier followed by a dash followed by another basic
    character specifier.  A basic character specifier is one of the
    following:

      + A single character other than backslash, "^", "-", "@", or
        "]".

      + Any of the escape sequences listed above as atomic regular
        expressions starting with a slash.

    The set of strings this pattern matches is a set of
    single-character strings.  If the optional "^" character is
    present after the "[", it is the set of single-character strings
    whose characters do not match any of the character specifiers;
    otherwise, it is the set of single-character strings whose
    characters do match at least one of the character specifiers.

    A basic character specifier matches the characters that the
    corresponding regular expression pattern would match.  A character
    specifier consisting of a basic character specifier followed by a
    dash followed by another basic character specifier is only legal
    if both basic character specifiers specify a single character
    each, and in that case the compound character specifier matches
    all characters with Unicode code points greater than or equal to
    the Unicode code point of the character for the first basic
    character specifier and less than or equal to the Unicode code
    point of the character for the second basic character specifier.

  * The character "." by itself is a regular expression pattern.  It
    matches all strings of length one.

  * The character "^" by itself is a regular expression pattern.  It
    matches only zero-length strings that are at the start of the
    original string being matched.  So the pattern "^a" will match the
    string "a" but the pattern "a(^b)" will not match the string "ab".

  * The character "$" by itself is a regular expression pattern.  It
    matches only zero-length strings that are at the end of the
    original string being matched.  So the pattern "a$" will match the
    string "a" but the pattern "(a$)b" will not match the string "ab".


    Section 4.10: Backtick Expression Literals
    ------------------------------------------

A backtick expression literal consists of a backtick character
followed by a body followed by a final backtick character.  The body
consists of a sequence of zero or more body items where each body item
is a character specifier.  The rules for a character specifier in a
backtick expression literal are the same as those listed in Section
4.3 for string literal character specifiers except that a backtick
character by itself is not a character specifier but a double quote
character by itself is a character specifier.

The body of a backtick expression is evaluated to form a string where
each character specifier evaluates to one of the characters in the
string just as with a string literal token.  But then the backtick
expression string is further processed to form a sequence of
expressions.  To start with, the list of expressions is empty and a
current literal string is maintained that starts off empty.
Processing continues from left to right.  If the next character to be
processed is not a dollar sign, it is added to the current literal
string and processing moves to the next character.  If the next
character is a dollar sign, it must have one of the following forms:

  * Two consecutive dollar signs.  In this case, a single dollar sign
    is added to the current string literal and processing continues
    with the character after the second dollar sign.

  * A dollar sign followed by an identifier.  The longest possible
    identifier is assumed.  In this case, if the current string
    literal is not empty it is taken as a string literal expression
    and added to the end of the result expression list.  Then the
    empty string becomes the new current string literal and the
    identifier is taken as an expression and added to the end of the
    result expression list.  Processing continues with the character
    after the last character of the identifer.

  * A dollar sign followed by a "(" character followed by an
    expression (see Section 5.1) followed by a ")" character.  In this
    case, if the current string literal is not empty it is taken as a
    string literal expression and added to the end of the result
    expression list.  Then the empty string becomes the new current
    string literal and the expression between the "(" and ")"
    characters is added to te end fo the result expression list.
    Processing continues with the character after the ")" character.

When the end of the body is reached, if the current string literal is
not empty it is taken as a string literal expression and added to the
end of the result expression list.

The backtick expression literal is processed into a call to a routine
named "system" with the expression list formed by processing the body
as the call arguments.

For example, `abc` is equivalent to system("abc").  `abc$def+hij` is
equivalent to system("abc", def, "+hij").  `abc$(def+hij)` is
equivalent to system("abc", def + hij).


        Chapter 5: Syntax
        =================

This chapter covers the constructs that are formed out of the tokens
that are produced by the rules in Chapter 4.  BNF is used to specify
the grammar rules.  Note that the BNF used here is ambiguous in places
-- the text specifies how the ambiguity is resolved.

This chapter also describes the semantics of the constructs formed by
this syntax.


    Section 5.1: Expressions
    ------------------------

    <expression> :
        <constant-expression> |
        <name-reference-expression> |
        <lookup-expression> |
        <lepton-expression> |
        <field-reference-expression> |
        <pointer-field-reference-expression> |
        <tagalong-field-reference-expression> |
        <statement-block-expression> |
        <new-expression> |
        <routine-expression> |
        <tagalong-expression> |
        <lepton-key-expression> |
        <quark-expression> |
        <lock-expression> |
        <construct-expression> |
        <type-value-expression> |
        <map-list-expression> |
        <semi-labeled-expression-list-expression> |
        <range-expression> |
        <call-expression> |
        <conditional-expression> |
        <unary-expression> |
        <binary-expression> |
        <arguments-expression> |
        <this-expression> |
        <in-expression> |
        <force-expression> |
        <break-expression> |
        <continue-expression> |
        <comprehend-expression> |
        <backtick-expression> |
        <forall-expression> |
        <exists-expression> |
        "(" <expression> ")"

An expression is a piece of Salmon code that can be evaluated to
produce a value.  Evaluating an expression may have side effects.  The
evaluation of an expression may cause control to jump to another
location so that no value is actually returned, for example if an
exception is thrown during the expression evaluation and control jumps
to an enclosing try-catch block.

Note that the BNF for expressions is ambiguous.  This ambiguity is
resolved using precedence rules.  Salmon's precedence rules follow C's
precedence rules where there is an analog in C.

First, there is a precedence order for Salmon expressions that might
be part of an ambiguous construct.  Here is that ordering:

  * forall and exists expressions

  * force expressions ("::" operator)

  * conditional expressions ("?" - ":" operator)

  * logical-or expressions (binary "||" operator)

  * logical-and expressions (binary "&&" operator)

  * bitwise or expressions (binary "|" operator)

  * bitwise xor expressions (binary "^" operator)

  * bitwise and expressions (binary "&" operator)

  * equality operator expressions (binary "==" and "!=" operators)

  * relational operator expressions (binary "<", ">", "<=", and ">="
    operators)

  * shift operator expressions (binary "<<" and ">>" operators)

  * concatenate operator expressions (binary "~" operator)

  * additive operator expressions (binary "+" and "-" operators)

  * multiplicative operator expressions (binary "*", "/", "/::", and
    "%" operators)

  * unary prefix expressions (dereference ("*"), location of ("&"),
    negate ("-"), unary plus ("+"), bitwise not ("~"), and logical not
    ("!") expressions")

  * postfix expressions (lookup, lepton, field reference, pointer
    field reference, call, and in expressions and the left-hand
    operands of tagalong field reference expressions)

  * the right-hand operands of tagalong field reference expressions

The lower the item on this list, the more tightly it binds.

So, for example, 3 * 4 - 7 < 5 is equivalent to (((3 * 4) - 7) < 5).

If there is a conflict among expressions at the same level in this
list, left associativity applies.  So, for example, 16 / 4 / 2 is
equivalent to ((16 / 4) / 2).


    Section 5.1.1: Constant Expressions
    -----------------------------------

    <constant-expression> :
        <string-constant-expression> |
        <character-constant-expression> |
        <integer-constant-expression> |
        <rational-constant-expression> |
        <regular-expression-constant-expression>

Evaluating a constant expression always results in exactly the same
value every time it is evaluated.


    Section 5.1.1.1: String Constant Expressions
    --------------------------------------------

    <string-constant-expression> :
        <string-literal-token>

Evaluating a string constant expression results in a string value with
the string literal token specifying the string.

EXAMPLE:

  * "hello" is a string constant expression resulting in the string
    value with "hello" as the string.


    Section 5.1.1.2: Character Constant Expressions
    -----------------------------------------------

    <character-constant-expression> :
        <character-literal-token>

Evaluating a character constant expression results in a character
value with the character literal token specifying the character.

EXAMPLES:

  * 'h' is a character constant expression resulting in the character
    value with "h" as the character.

  * '\n' is a character constant expression resulting in the character
    value with a newline as the character.


    Section 5.1.1.3: Integer Constant Expressions
    ---------------------------------------------

    <integer-constant-expression> :
        <decimal-integer-literal-token> |
        <hexadecimal-integer-literal-token> |
        "+oo" |
        "-oo"

Evaluating an integer constant expression results in an integer value
with the integer literal token specifying the integer.  The value
``+oo'' stands for the value positive infinity and ``-oo'' stands for
the value negative infinity.

Note that only non-negative finite integers, positive infinity, and
negative infinity can be specified through integer constant
expressions.  A negate expression can be use with an integer constant
expression to get any finite negative integer.  The remaining two
integer values are unsigned infinity and zero-zero.  Unsigned infinity
can be produced with the expression 1/0 and zero-zero can be produced
with the expression 0/0.

EXAMPLES:

  * 10 is an integer constant expression resulting in the integer
    value with 10 as the integer.

  * 0x10 is an integer constant expression resulting in the integer
    value with 16 as the integer.


    Section 5.1.1.4: Rational Constant Expressions
    ----------------------------------------------

    <rational-constant-expression> :
        <scientific-notation-literal-token>

Evaluating a rational constant expression results in a rational value
with the scientific notation literal token specifying the rational.

EXAMPLES:

  * 1.5 is a rational constant expression resulting in the rational
    value with 1.5 as the rational.

  * 1.5e-6 is a rational constant expression resulting in the rational
    value with 0.0000015 as the rational.


    Section 5.1.1.5: Regular Expression Constant Expressions
    --------------------------------------------------------

    <regular-expression-constant-expression> :
        <regular-expression-literal-token>

Evaluating a regular expression constant expression results in a
regular expression value with the regular expression literal token
specifying the regular expression.

EXAMPLES:

  * @hi@ is a regular expression constant expression resulting in the
    regular expression that matches the string "hi".

  * @hi|low@ is a regular expression constant expression resulting in
    the regular expression that matches the strings "hi" and "low".


    Section 5.1.2: Name Reference Expressions
    -----------------------------------------

    <name-reference-expression> :
        <identifier>

A name reference expression refers to a name in an enclosing scope.
Depending on what the name is bound to, it will be one of the
following:

  * A variable reference expression if the name is bound to a variable
    or immutable declaration.  Evaluating a variable reference
    expression results in the value currently contained in the
    variable.  An exception occurs if the variable is not currently
    allocated and defined.

  * A routine reference expression if the name is bound to a routine
    declaration.  Evaluating a routine reference expression results in
    a routine value.  An exception occurs if the routine is not
    currently allocated.

  * A label reference expression if the name is bound to a code
    label.  Evaluating a label reference expression results in a jump
    target value with that label as the target.

  * A lepton key reference expression if the name is bound to a lepton
    declaration.  Evaluating a lepton key reference expression results
    in a lepton key value refering to the key of the current instance
    of the lepton specified by the declaration.

  * A tagalong key reference expression if the name is bound to a
    tagalong declaration.  Evaluating a tagalong key reference
    expression results in a tagalong key value refering to the key of
    the current instance of the tagalong specified by the declaration.

  * A quark reference expression if the name is bound to a quark
    declaration.  Evaluating a quark reference expression results in a
    quark value refering to the quark specified by the declaration.
    An exception occurs if the quark is not currently allocated.

  * A lock reference expression if the name is bound to a lock
    declaration.  Evaluating a lock reference expression results in a
    lock value refering to the lock specified by the declaration.  An
    exception occurs if the lock is not currently allocated.

To remove ambiguity in some cases, improve readability even when there
wouldn't be ambiguity otherwise, and make parsing simpler for tools,
the identifier for a name reference expression is not allowed to be
"single", "routine", "function", "procedure", "class", "variable",
"immutable", "tagalong", "lepton", "quark", "lock", "static",
"virtual", "pure", "construct", "type", "arguments", "this", "break",
"continue", "forall", or "exists".

EXAMPLES:

  * variable x := 1;
    print(x);

    is a statement list that prints the string "1".  The argument to
    the print() call is a variable reference expression.

  * procedure a(x)
      {
        print(x);
      };
    a(1);

    is a statement list that prints the string "1".  In the call to
    a(), the base expression is ``a'', a routine reference expression.

  * loopback:
    b(x);
    ++x;
    if (x < 100)
        goto loopback;

    is a statement list that keeps calling the procedure b() and
    incrementing the variable x as long as x is less than 100.  The
    argument to the goto statement is a label reference expression.

  * quark a;
    b(a);

    is a statement list that declares a quark and passes a value
    refering to that quark to the procedure b().  The argument to the
    b() call is a quark reference expression.

  * lock a;
    b(a);

    is a statement list that declares a lock and passes a value
    refering to that lock to the procedure b().  The argument to the
    b() call is a lock reference expression.


    Section 5.1.3: Lookup Expressions
    ---------------------------------

    <lookup-expression> :
        <expression> "[" <lookup-element-list> "]"

    <lookup-element-list> :
        <lookup-element> |
        <lookup-element> "," <lookup-element-list>

    <lookup-element> :
        <expression> |
        <expression> "..." <expression> |
        "*" { ":" <type-expression> }?

A lookup expression looks up elements by key value in a map.  In the
special case of maps that are arrays, it can specify multiple
dimensions of element lookup and can grab whole slices of the array.

The first expression in a lookup expression is the base expression.
Evaluating the lookup expression starts with evaluating the base
expression to give the base value.  After that, all the expressions
and type expressions in the <lookup-element-list> are evaluated in
order.  Then, if any of the expressions or type expression in the
<lookup-element-list> returned an invalid value or type, an exception
occurs.

A lookup expression is defined as a simple lookup expression if the
lookup element list consists of only a single element and that element
is a single expression, "*", or "*" followed by ":" and a type
expression; not two expressions separated by "...".

First, we consider the case of a simple lookup expression.

In this case, the next step is to do a check for overloading, and if
an overloading match is found, overloading is used instead of a normal
lookup operation.  The first step in checking for overloading is to
see if the name "operator[]" resolves at this point in the code.  If
so, "operator[]" is evaluated as a name reference expression.  The
value returned from the evaluation of "operator[]" is the overload
base value.  If the overload base value is invalid, an exception
occurs.  Otherwise, if the overload base value is a routine value, an
attempt is made to find a call match.  The argument list for the call
match is exactly two items.  The first of these two is always an
unnamed item consisting of the base value.  The second item depends on
the specific form of the simple lookup expression.  If the lookup
element is a single expression, then the second item is the value from
the lookup element with the name "key".  If the lookup element is a
"*" by itself, then the second item is the string value "*" with the
name "star".  If the lookup element is a "*" followed by ":" and a
type expression, then the second item is a type value formed from the
result of evaluating the type expression with the name "filter".  If
there is a match, the matched routine is called and the return value
is the result of evaluating the simple lookup expression and the
evaluation is done.  Otherwise, evaluation continues with the next
step of overloading checking.

The next step of overloading checking is to see if the base value has
a field with the name "operator[]" -- that is, if applying
".operator[]" to the value would produce a value.  If so, that value
is the field base value.  If the field base value is invalid, an
exception occurs.  Otherwise, if the field base value is a routine
value, an attempt is made to find a call match.  The argument list for
the call match is a single item which is the same as specified for the
second item in the call match argument list for the first step of
overload checking (i.e. it is named "key", "star", or "filter").  If
there is a match, the matched routine is called and the return value
is the result of evaluating the simple lookup expression and the
evaluation is done.  Otherwise, there is no overloading and evaluation
continues as a normal simple lookup operation.

The next step for a simple lookup expression is to check that the base
value is valid.  If it is invalid, an exception occurs.  Also, if the
value of the base expression is not a map or a semi-labeled value
list, an exception occurs.

In the case of a simple lookup expression with a map base value, the
base value map may have any key values.  There are three cases -- the
lookup element is a "*" by itself; the lookup element is a "*"
followed by a ":" and a type expression; or the lookup element is a
single expression.

In the case of a "*" by itself, the result is simply the entire map
value if the base value is a map value.  If the base value is a
semi-labeled value list, the result is the semi-labeled value list
with any labels stripped off.

In the case of a "*" followed by a ":" and a type expression, if the
base value is a map then the result is a new map consisting of all
key/value pairs in the base map for which the key is in that type.  If
the base value is a semi-labeled value list, then the result is the
same as if the base value had been a map with integer keys from zero
to one less than the number of elements where each key has as its
target value the element value corresponding to that key in the
semi-labeled value list (the labels are dropped).

In the case of a single expression for the lookup element, if the base
value is map then the lookup element value is used as a key to look up
the associated value in the base map, and that associated value is the
result of evaluating the lookup expression.  In that case, if that key
is not associated with a value, an exception occurs.  If the base
value is a semi-labeled value list and the key value is not an
integer, is not finite, is an integer less than zero, or is an integer
greater than or equal to the number of elements in the base value, an
exception occurs.  Otherwise, the result value is the component value
in the base value indexed by the key.

That completes the discussion for the case of a simple lookup
expression.  Everything from here on in this section applies to the
case of a non-simple lookup expression (i.e. it has more than one
element in the lookup element list or two expressions separated by
"..." as one of the elements in the lookup element list).

In this case, a check is made of all the values that resulted from
evaluating the expressions in the lookup element list.  If any of
these values is not a finite integer value, an exception occurs.

At this point, we have a list of index elements generated from the
lookup element list, where each element is one of four things:

  * a finite integer if the lookup element was a single expression;

  * a range bounded by two finite integers if the lookup element was
    two expressions separated by "...", with the lower bound specified
    by the first expression and the upper bound specified by the
    second expression;

  * a "*" by itself.

  * a type if the lookup element was a "*" followed by a ":" and a
    type expression.

We now do an operation called indexing that takes as input the base
array and the list of index elements.

The indexing operation is defined by recursion on the length of the
list of index elements.  The indexing operation takes a base value and
a list of index elements.

To start off the indexing operation, we do an overload check using the
base value for this indexing operation and the first element of the
list of index elements.  If this first element is a single finite
integer value, a "*" by itself, or a type, then the overload check is
exactly the same check that would have been done if this were a simple
lookup operation with that base value and that first element of the
list of index elements as its argument.  If this first element is a
range, then the overload check is the same except that each argument
list for a call match is one item longer and the last two items are
the lower and upper bound integers respectively, with the names
"lower" and "upper" attached.  If either of the two steps finds a
match, the result of the overload call is used as the next base
value.  If the first element was a range or a "*" by itself, the next
base value is forced to be an array -- if it was a semi-labeled value
list, any labels are removed, and if it was a map, all non-integers
keys are removed, and if it's some other value, an exception occurs.
If the list of index elements is only one element long, this next base
value is the result of the indexing operation and we're done.  If the
list of index elements is more than one element long, the result of
the indexing operation is defined recursively as the result of
applying the indexing operation to the next base value and the list of
index elements minus the first one.  In either case, if an overload
match was found, we're done with this indexing operation.

If no overload match was found, then the base value must be either a
map or a semi-labeled value list.  If it is a map, all keys in the map
must be valid or an exception occurs.

Further, if the base value is a map, then that map must be an array.
If it is not an array, an exception occurs.  That is, all the keys in
the map must be integers.

Now we consider several cases for the next step.

First, we have the base case when the list of index elements consists
of a single element.  If that element is a finite integer, the result
is the element of the array associated with that integer.  If that
element is a range, then the result is an array of all the elements in
the range, inclusive.  This result array is zero-based.  So if the
range is 5...7, then the result is an array with three elements,
indexed by 0, 1, and 2.  If the lower bound is greater than the upper
bound, the result is an empty array.  If the element in the list of
index elements is a "*" by itself, then the result is the entire map
array.  And finally if the element in the list of index elements is a
type for "*" followed by a ":" and type expression, then the result is
a new map that contains only those key/value pairs from the base array
whose keys are in the type.

Now, we have the recursive case.  We recurse from the left-most
element of the index element list.

If the left-most element of the index element list is a single
integer, then the result of the indexing operation is the indexing
operation applied to the element of the array specified by that
left-most element and with the remainder of the index element list
after the left-most as the recursive index element list.

If the left-most element of the index element list is a range defined
by two integers, then the result of the indexing operation is an array
with number of elements equal to the size of the range and elements
formed by applying the operation recursively to the elements of the
base array in the range and the remainder of the index list.

If the left-most element of the index element list is a "*" by itself,
then the result of the indexing operation is an array with the same
number of elements and indexes as the base array with elements formed
by recursively applying the operation to the elements of the array and
the remainder of the list.

If the left-most element of the index element list is a type for a "*"
followed by a ":" and type expression, then the result of the indexing
operation is an array with an element for each element of the base
array whose index is in the type and each of whose elements has the
same index as the corresponding element in the base array and whose
element value is formed by recursively applying the operation to the
corresponding element value of the base array and the remainder of the
list.

That completes the recursive definition of the indexing operation.

Note that in the absence of overloading the base array must have
arrays nested as deeply as the number of elements in the indexing
array.  If at any point the indexing operation is applied to a base
that is not an array, an exception occurs.

Note also that the overloading check is part of the recursive
definition of the indexing operation, so a check for overloading is
done at each level for multi-dimensional lookup operations.

EXAMPLES:

  * x[5] is an expression that evaluates to element number five in the
    array variable x.

  * x["winter"] is an expression that looks up the string "winter" in
    the map variable x and returns the associated value.

  * x[5, 7] is an expression that evaluates to element in row five,
    column seven in the two-dimensional array variable x.

  * x[*] is an expression that evaluates to the entire array in array
    variable x.

  * x[*, 7] is an expression that evaluates to column seven in the
    two-dimensional array variable x.

  * x[5, *] is an expression that evaluates to row five in the
    two-dimensional array variable x.

  * x[a][b] is equivalent to x[a, b].

  * x[a, *][b] is equivalent to x[a, b].

  * x[*, a][b] is equivalent to x[b, a].

  * x[5...7] is an expression that evaluates to an array of three
    elements, which are elements 5, 6, and 7 of x.

  * x[5...7][1] is equivalent to x[6].

  * x[5...5, 7] is not equivalent to x[5, 7].  The former evaluates to
    an array of one element where that one element is the value of
    x[5, 7].

  * ["a", "b", "c", "d", "e"][2...3] is an expression that evaluates
    to an array with two elements, "c" and "d", with indexes 0 and 1
    respectively.

  * ["a", "b", "c", "d", "e"][* : [2...3]] is an expression that
    evaluates to an array with two elements, "c" and "d", with indexes
    2 and 3 respectively.

  * (["a", bb := "b", "c"][*])!

    is a statement list that prints:

        ["a", "b", "c"]

    when executed.

  * function operator[](...)
      {
        return [arguments];
      };
    "telephone"[5]!
    "telephone"[*]!
    "telephone"[* : integer]!
    "telephone"[5...7]!
    "telephone"[5...7, 8...9]!

    is a statement list that prints:

        [["telephone", key := 5]]
        [["telephone", star := "*"]]
        [["telephone", filter := type integer]]
        [["telephone", lower := 5, upper := 7]]
        [[[["telephone", lower := 5, upper := 7], lower := 8, upper := 9]]]

    when executed.


    Section 5.1.4: Lepton Expressions
    ---------------------------------

    <lepton-expression> :
        <expression> "[" <lepton-element-list> "]"

    <lepton-element-list> :
        <empty> |
        <non-empty-lepton-element-list>

    <non-empty-lepton-element-list> :
        <lepton-element> |
        <lepton-element> "," <non-empty-lepton-element-list>

    <lepton-element> :
        <identifier> { ":=" | "::=" } <expression>

A lepton expression builds a lepton on the fly.

Evaluating a lepton expression involves first evaluating its first
argument.  This is the base expression.  It must evaluate to a lepton
key value or an exception will occur.  If the base expression
evaluates to a lepton key, a lepton value is built using that lepton
key as the key and initially with no field values.

Next each of the expressions in the lepton element list is evaluated
from left to right.  As each is evaluated, the lepton value has a
field assigned with the name specified by the identifier for each
lepton element and the value specified by evaluating the expression of
that lepton element.  If the optional "::=" is used instead of ":="
for a particular lepton element that means the value is forced into
the type specified for a field of that name for the relevant lepton
key, just as if the "::" operator had been used.  Note that if ":=" is
used and the value doesn't match the type required for a field of that
name for the lepton key, an exception occurs; if "::=" is used and the
value can't be forced to the type required an exception occurs.  Note
that if the lepton declaration for the lepton key being used doesn't
specify a type for the given field name, the type is implicitly the
type of all values, so ":=" and "::=" have the same effect in this
case.

When that is done, the final lepton that has been constructed is the
result of evaluating the lepton expression.

Note that the lepton element list is allowed to be empty.  In this
case, a lepton is created with no field values set.

Note also that names are allowed to repeat.  If the same name occurs
more than once in the lepton element list, the right-most one will
overwrite all the others, but all the expressions will still be
evaluated, so any side effects of evaluating expressions whose values
are overwritten will still occur.

EXAMPLES:

  * lepton a;
    variable x := a[]

    is a statement list that creates a variable x with the value that
    is a lepton with lepton key a as its key and no field values.

  * lepton a[b : [0...16], ...];
    variable x := a[b := 5, c := 6]

    is a statement list that creates a variable x with the value that
    is a lepton with lepton key a as its key and two fields, ``b''
    with a value of 5 and ``c'' with a value of 6.

  * lepton a[b : [0...15], ...];
    variable x := a[b ::= 25, c := 6]

    is a statement list that creates a variable x with the value that
    is a lepton with lepton key a as its key and two fields, ``b''
    with a value of 9 and ``c'' with a value of 6.


    Section 5.1.5: Field Reference Expressions
    ------------------------------------------

    <field-reference-expression> :
        <expression> "." <identifier>

A field reference expression grabs a field value by name from a
semi-labeled value list, semi-labeled multi-set, lepton, or object.

Evaluating a field reference expression starts with evaluating its
first argument expression.  This is the base expression.  The value
that results from evaluating the base expression must be a
semi-labeled value list, a semi-labeled multi-set, a lepton, or an
object.  Otherwise, an exception occurs.

The identifier specifies a field name.  Evaluating this expression
results in the value associated with that field in that semi-labeled
value list, semi-labeled multi-set, lepton, or object.  If the base
value doesn't have a value set for that field name, an exception
occurs.

EXAMPLES:

  * [a := 5, b := 6].a is an expression that evaluates to 5.

  * a[b := 7, d := 9].d is an expression that evaluates to 9.


    Section 5.1.6: Pointer Field Reference Expressions
    --------------------------------------------------

    <pointer-field-reference-expression> :
        <expression> "->" <identifier>

A pointer field reference expression grabs a field value by name from
a pointer to a semi-labeled value list, semi-labeled multi-set,
lepton, or object.

Evaluating a pointer field reference expression starts with evaluating
its first argument expression.  This is the base expression.  The
value that results from evaluating the base expression is the base
value.

The next step is to do an overloading check, and if an overloading
match is found, overloading is used instead of a normal pointer field
reference operation.  The first step in checking for overloading is to
see if the name "operator->" resolves at this point in the code.  If
so, "operator->" is evaluated as a name reference expression.  The
value returned from the evaluation of "operator->" is the overload
base value.  If the overload base value is invalid, an exception
occurs.  Otherwise, if the overload base value is a routine value, an
attempt is made to find a call match.  The argument list for the call
match is exactly two items, both unnamed.  The first item is the base
value.  The second item is a string value whose string is the
identifier from the pointer field reference expression.  If there is a
match, the matched routine is called and the return value is the
result of evaluating the pointer field reference expression and the
evaluation is done.  Otherwise, evaluation continues with the next
step of overloading checking.

The next step of overloading checking is to see if the base value has
a field with the name "operator->" -- that is, if applying
".operator->" to the value would produce a value.  If so, that value
is the field base value.  If the field base value is invalid, an
exception occurs.  Otherwise, if the field base value is a routine
value, an attempt is made to find a call match.  The argument list for
the call match is a single unnamed item whose value is a string value
whose string is the identifier from the pointer field reference
expression.  If there is a match, the matched routine is called and
the return value is the result of evaluating the pointer field
reference expression and the evaluation is done.  Otherwise, there is
no overloading and evaluation continues as a normal pointer field
reference operation.

At this point, the base value must be a valid slot location value or
an exception occurs.  This slot location must currently contain a
semi-labeled value list, a semi-labeled multi-set, a lepton, or an
object.  Otherwise, an exception occurs.

The identifier specifies a field name.  Evaluating the pointer field
reference expression results in the value associated with that field
in the semi-labeled value list, semi-labeled multi-set, lepton, or
object in the slot.  If the value in the base slot doesn't have a
value set for that field name, an exception occurs.

EXAMPLES:

  * variable x := [a := 5, b := 6];
    (&x)->a!

    is a statement list that prints

        5

    when executed.

  * function operator->(...) (arguments);
    "tulip"->pedal!

    is a statement list that prints

        ["tulip", "pedal"]

    when executed.


    Section 5.1.7: Tagalong Field Reference Expressions
    ---------------------------------------------------

    <tagalong-field-reference-expression> :
        <expression> ".." <expression>

A tagalong field reference expression grabs the value for a given
tagalong key on a particular value.

Evaluating a tagalong field reference expression starts with
evaluating its first argument expression and then its second argument
expression.  The first expression is the base expression and the
result of evaluating it is the base value.  The second expression is
the key expression and the result of evaluating it is the key value.
If the key value is invalid or if the key value is not a lepton key,
an exception occurs.

The base value is then tested to see if it is in the ``on'' type for
the lepton key.  If it is not, an exception occurs.  If it is in the
``on'' type and a value has been assigned for that key for the base
value, that value is the result of evaluating the tagalong field
reference expression.  Otherwise, if the tagalong key has a default
value, that default value for the key is the result of evaluating the
tagalong field reference expression.  Otherwise, an exception occurs.

EXAMPLES:

  * variable v1 := 12;
    tagalong t1 := 5;
    v1.t1!
    v1.t1 := 33;
    v1.t1!

    is a statement list that prints "5" on the first line and then
    "33" on the second line when executed.

  * variable v1 := 12;
    tagalong t1;
    v1.t1!

    is a statement list that throws an exception when executed.


    Section 5.1.8: Statement Block Expressions
    ------------------------------------------

    <statement-block-expression> :
        <braced-statement-block>

A statement block expression allows a sequence of statements to be
executed to calculate a value.

Evaluating the statement block expression consists of executing the
statement block.  That includes creating a new context, creating new
instances for variable, routine, and other declarations within the
block, executing statements of the block, and shutting down the
context when control exits the scope.

To return a value, control should exit the statement block through the
execution of a return statement with the value to be returned as the
result of executing its argument.  If control falls out of the
statement block without a return statement or returns with a return
statement without a value, an exception occurs.  Control can also exit
the statement block through the execution of a non-local jump out of
the context of the statement block, in which case no value is returned
because control doesn't return to whatever caused the expression to be
evaluated.

EXAMPLE:

  * print(
      {
        variable x := 2;
        for (i; 0; i < 5)
            x *= x;;
        return x;
      });

    is a statement list that prints 4294967296 (2^32) when executed.


    Section 5.1.9: New Expressions
    ------------------------------

    <new-expression> :
        <unnamed-data-declaration>

A new expression creates a dynamically-allocated variable and returns
a slot location pointing to it.  It is simply a data declaration
(variable or immutable) without a name.  Evaluating this statement
causes an instance to be allocated for the data declaration and then
causes that instance to immediately be instantiated.

EXAMPLES:

  * variable : integer is an expression that creates a new variable
    that can hold any value of type integer and returns a pointer to
    that integer variable.

  * immutable := 17 is an expression that creates a new immutable that
    holds the value 17 and returns a pointer to that immutable.

  * immutable i1 := (variable : integer);
    *i1 := 12;
    *i1!
    *i1 := 13;
    *i1!

    is a statement list that prints 12 on the first line, then 13 on
    the second line when executed.

  * *(immutable := 17)!

    is a statement list that prints 17 on a line by itself when
    executed.


    Section 5.1.10: Routine Expressions
    -----------------------------------

    <routine-expression> :
        <unnamed-routine-declaration>

A routine expression creates a dynamically-allocated routine and
returns a routine instance value for that routine.  It is simply a
routine declaration without a name.  Evaluating this statement causes
an instance to be allocated for the routine declaration and then
causes that instance to immediately be instantiated.

A routine expression can be used for a function or a procedure.  When
used for a function, it's a form of lambda operator.

EXAMPLE:

  * function apply(process, input)
      {
        variable result := [];
        iterate(x; input)
            result ~= [process(x)];;
        return result;
      };
    apply(function(y) (y + y), [1, 2, 3])!
    apply(function(y) (y * y), [1, 2, 3])!

    is a statement list that prints:

        [2, 4, 6]
        [1, 4, 9]

    when executed.  The first argument to each call to apply() is a
    routine expression.  In the first call to apply(), the routine
    expression creates a function that doubles its argument, and in
    the second call to apply(), the routine expression creates a
    function that squares its argument.


    Section 5.1.11: Tagalong Expressions
    ------------------------------------

    <tagalong-expression> :
        <unnamed-tagalong-declaration>

A tagalong expression creates a dynamically-allocated tagalong key and
returns a tagalong key instance value for that key.  It is simply a
tagalong declaration without a name.  Evaluating this statement causes
an instance to be allocated for the tagalong declaration and then
causes that instance to immediately be instantiated.

EXAMPLES:

  * tagalong : integer := 5 on string is an expression that creates
    a tagalong key that can be used on any string value and can have
    as data any integer value, with 5 being its default value.

  * immutable i2 := tagalong : integer := 5 on string;
    variable v2 := "hello";
    v2..i2!
    v2..i2 := 157;
    v2..i2!

    is a statement list that prints:

        5
        157

    when executed.


    Section 5.1.12: Lepton Key Expressions
    --------------------------------------

    <lepton-key-expression> :
        <unnamed-lepton-declaration>

A lepton key expression creates a dynamically-allocated lepton key and
returns a lepton key instance value for that key.  It is simply a
lepton declaration without a name.  Evaluating this statement causes
an instance to be allocated for the lepton declaration and then causes
that instance to immediately be instantiated.

EXAMPLES:

  * lepton[a : integer, b : string] is an expression that creates a
    lepton key with two fields.

  * immutable i3 := lepton[a : integer, b : string];
    immutable i4 := i3[a := 5, b := "five"];
    i4.b!

    is a statement list that prints:

        five

    when executed.


    Section 5.1.13: Quark Expressions
    ---------------------------------

    <quark-expression> :
        <unnamed-quark-declaration>

A quark expression creates a dynamically-allocated quark and returns a
quark instance value for that quark.  It is simply a quark declaration
without a name.  Evaluating this statement causes an instance to be
allocated for the quark declaration and then causes that instance to
immediately be instantiated.

EXAMPLES:

  * quark is an expression that creates a quark and returns it.

  * variable v1 : any_quark[0...5];
    for (i; 0; i <= 5)
        v1[i] := quark;;
    v1[2] == v1[3]!
    v1[2] == v1[2]!

    is a statement list that prints:

        false
        true

    when executed.  Note that the single quark expression in the for
    loop is executed six times and that quarks from different
    iterations of the loop are distinct from one another.


    Section 5.1.14: Lock Expressions
    --------------------------------

    <lock-expression> :
        <unnamed-lock-declaration>

A lock expression creates a dynamically-allocated lock and returns a
lock instance value for that lock.  It is simply a lock declaration
without a name.  Evaluating this statement causes an instance to be
allocated for the lock declaration and then causes that instance to
immediately be instantiated.

EXAMPLES:

  * lock is an expression that creates a lock and returns it.

  * single(lock) procedure p1()
      { "p1()"! };
    p1();
    p1();

    is a statement list that prints:

        p1()
        p1()

    when executed.  Note that the use of the lock expression in the
    single() modifier means that every time p1() is instantiated, it
    gets a new lock specifically for that instance and that lock is
    locked whenever that instance of p1() is called.


    Section 5.1.15: Construct Expressions
    -------------------------------------

    <construct-expression> :
        { <single-prefix> }? "construct" <call>

A construct expression is a short-hand way to create a dynamically
allocated immutable and set its value to the result returned by a
call.  This call may be to a class or to another function.

EXAMPLES:

  * construct c1(5, 7) is an expression that has the same effect as
    immutable := c1(5, 7).

  * class c1(xx, yy)
      {
        immutable x := xx, y := yy;
      };
    immutable i5 := construct c1(5, 7);
    i5->y!

    is a statement list that prints:

        7

    when executed.


    Section 5.1.16: Type Value Expressions
    --------------------------------------

    <type-value-expression> :
        "type" <type-expression>

A type value expression is used to create a type value by executing a
type expression.  The result is a type value whose data is the type
returned by evaluating the type expression.

EXAMPLES:

  * type integer --> string is an expression that returns a type value
    for the type of maps from integers to strings.

  * immutable i6 := type integer --> string;
    (["hello", "goodbye"] in i6)!
    <<("blue" --> "red")>> in i6!

    is a statement list that prints:

        true
        false

    when executed.


    Section 5.1.17: Map List Expressions
    ------------------------------------

    <map-list-expression> :
        "<<" <map-item-list> ">>"

    <map-item-list> :
        <empty> |
        <non-empty-map-item-list>

    <non-empty-map-item-list> :
        <map-item> |
        <map-item> "," <non-empty-map-item-list>

    <map-item> :
        "(" <expression> "-->" <expression> ")" |
        "(" "*" { ":" <type-expression> }? "-->" <expression> ")"

A map list expression creates a map value.  Evaluating a map list
expression starts by creating an empty map value to contain the
result.  Then, each map item is evaluated to determine what to add to
the map.  The map items are evaluated from left to right, and as each
is evaluated, the result value is updated.  When there are no more
items, the final map value is the result of evaluating the map list
expression.

If the map list item is in the form of two expressions separated by
"-->", then the map list item represents a single key value pair.  In
this case, both expressions are evaluated.  The first is the key
expression and the second is the target expression.  Evaluating these
expressions creates the key and target values respectively.  If the
key value is not valid, an exception occurs.  Otherwise, the result
map is modified to add this key value pair.  If this key was already
in the map, the new target value overrides the existing target value
for that key.

If the map list item is in the form that starts with a "*", then it
represents a set of keys defined by the type.  If the type expression
is present, it is evaluated and the type is the key type.  If the key
type is invalid, an exception occurs.  If the optional type expression
is not present, the type is that of all values.  The other expression
is the target expression and it is evaluated to create the target
value.  The map is modified so that all keys in the key type are
associated with the target value.  If some or all of the keys in the
type were already associated with target values, the new target value
overrides the old one or ones for those key values only.

EXAMPLE:

  * immutable i1 :=
      <<(* --> "default"), (* : integer --> "integer"), (15 --> "fifteen"),
        ("blue" --> "red")>>;
    i1["blue"]!
    i1["red"]!
    i1[15]!
    i1[16]!

    is a statement list that prints:

        red
        default
        fifteen
        integer

    when executed.


    Section 5.1.18: Semi-Labeled Expression List Expressions
    --------------------------------------------------------

    <semi-labeled-expression-list-expression> :
        "[" <semi-labeled-expression-list> "]"

    <semi-labeled-expression-list> :
        <empty> |
        <non-empty-semi-labeled-expression-list>

    <non-empty-semi-labeled-expression-list> :
        <semi-labeled-expression> |
        <semi-labeled-expression> ","
                <non-empty-semi-labeled-expression-list>

    <semi-labeled-expression> :
        { <identifier> ":=" }? { <expression> }?

A semi-labeled expression list expression creates a semi-labeled value
list value.  Evaluating a semi-labeled expression list expression
starts by creating an empty semi-labeled value list value to contain
the result.  Then, each semi-labeled expression in the list is
evaluated to determine what to add to the value.  The semi-labeled
expressions are evaluated from left to right, and as each is
evaluated, the result value is updated.  When there are no more
semi-labeled expressions, the final value is the result of evaluating
the semi-labeled expression list expression.

Evaluating each semi-labeled expression starts with evaluating the
expression.  If the result is invalid, an exception occurs.
Otherwise, it is appended to the result semi-labled value list value.
If the semi-labeled expression has the optional <identifier> ":="
part, then when the value is added to the result, the <identifier> is
used as the label for that item in the list.  Otherwise, that item in
the list has no label.

EXAMPLE:

  * immutable i1 := [5 + 10, bbb := "taxi" ~ "cab"];
    i1[0]!
    i1[1]!
    i1.bbb!

    is a statement list that prints:

        15
        taxicab
        taxicab

    when executed.


    Section 5.1.19: Range Expressions
    ---------------------------------

    <range-expression> :
        { "[" | "(" } <expression> "..." <expression> { "]" | ")" }

Evaluating a range expression expression gives a value that can be
iterated over with an iterate statement or comprehend expression to
give all the integers within a range in ascending order.  The first
expression gives the lower bound and the second gives the upper
bound.  If square brackets are used in conjunction with a bound, the
bound is included in the range and otherwise it is not.

A range expression is equivalent to a call to a function named
"integer_range" with the same interface as specified by the standard
library version of this function.  The functionality of a range
expression can be over-ridden by defining a new function with this
name.  If it is not over-ridden, it references the version from the
standard library and has the standard behavior.


    Section 5.1.20: Call Expressions
    --------------------------------

    <call-expression> :
        <call>

    <call> :
        <expression> "(" <semi-labeled-expression-list> ")"

Evaluating a call expression starts by evaluating the expression
before the "(".  This is the base expression.  The resulting value is
the base value.  If the base value is not valid, an exception occurs.

Next, all the expressions in the semi-labeled expression list are
evaluated in order from left to right.  The results of these
evaluations are put in a list in the same order as the items in the
semi-labeled expression list they were generated from.  This is the
raw argument list.

Next, a check is done for overloading, and if an overloading match is
found, overloading is used instead of a normal routine call.  The
first step in checking for overloading is to see if the name
"operator()" resolves at this point in the code.  If so, "operator()"
is evaluated as a name reference expression.  The value returned from
the evaluation of "operator()" is the overload base value.  If the
overload base value is invalid, an exception occurs.  Otherwise, if
the overload base value is a routine value, an attempt is made to find
a call match.  The argument list for the call match is exactly two
items, both unnamed.  The first item is the base value.  The second
item is a semi-labeled value list.  That semi-labeled value list is
the raw argument list with labels where they appear in the
semi-labeled expression list.  If there is a match, the matched
routine is called and the return value is the result of evaluating the
call expression and the evaluation is done.  Otherwise, evaluation
continues with the next step of overloading checking.

The next step of overloading checking is to see if the base value has
a field with the name "operator()" -- that is, if applying
".operator()" to the value would produce a value.  If so, that value
is the field base value.  If the field base value is invalid, an
exception occurs.  Otherwise, if the field base value is a routine
value, an attempt is made to find a call match.  The argument list for
the call match is a single unnamed item whose value is a semi-labeled
value list.  That semi-labeled value list is the raw argument list
with labels where they appear in the semi-labeled expression list.  If
there is a match, the matched routine is called and the return value
is the result of evaluating the call expression and the evaluation is
done.  Otherwise, there is no overloading and evaluation continues as
a normal routine call.

Evaluation of a normal routine call starts by checking that the base
value is a routine value.  If it is not, an exception occurs.
Otherwise, the base value gives a list of potential routines to be
called (which may be a single routine if the value isn't a routine
chain).  At this point an attempt is made to find a call match using
as argument list the list of raw arguments with names as specified in
the semi-labeled expression list.  If a match is found, the matched
routine is called.  If no match is found, an exception occurs.

An attempt to find a call match is an operation that requires an
ordered list of routines and a semi-labeled list of values as the raw
argument list.  The operation goes through the list of routines in
order from first to last until a match is found.  For each routine on
the list, the following operation is performed to create a munged
argument list for that routine from the raw argument list.  An integer
specifying the current munged argument number is also maintained.  To
start, the munged argument list is empty and the current munged
argument number is zero.  Then, the operation goes through the raw
argument list in order.  For each item in the raw argument list, the
following operation is performed.  First of all, if the raw argument
list item has a name, that name is looked up from among the names of
formal arguments in the routine.  If there is a match, the current
munged argument number becomes the number of the matched formal
argument.  Otherwise, if the current argument number is less than the
number of formal arguments, or if the routine doesn't allow additional
arguments beyond those specified by formal parameters, the matching
operation fails.  Then a check is made to see if there is already a
value in the munged argument list at the index specified by the
current munged argument number.  If so, the matching operation fails.
Otherwise, the value for the raw argument list item is placed in the
munged argument list at the index specified by the current munged
argument number.  Then, the current munged argument number is
incremented.

When that is done, if matching didn't fail, we have a munged argument
list of values that potentially has some values missing.  At this
point, the type checking and default value filling operation happens.
This operation goes through the formal arguments to the routine in
order from left to right.  For each, if the corresponding item in the
munged argument list doesn't have a value, then a check is made for a
default value expression for that formal parameter.  If there isn't
one, the matching operation fails.  If there is, the default value
expression for that formal parameter is evaluated.  That value is
placed in the munged argument list.  At this point, if the match
hasn't failed, whether there was originally a value in that position
of the munged argument list or not, now there is.  This value is then
checked to see if it is in the static type specified for that formal
parameter, if a type was specified.  If not, the matching operation
fails.  Otherwise, the operation moves on to the next item in the
formal parameter list.

If that finishes and there have been no matching failures, we have
found the routine to be called and we have a munged argument list for
the call.  Now we start the call processing.  First, every formal
parameter is allocated.  Then, we go through the formal parameter list
in order from left to right again.  The formal is instantiated and
given the value in the corresponding position in the munged argument
list.  Then, if the formal has a dynamic type expression, that dynamic
type expression is evaluated and the formal's value is checked to see
if it is in that type.  If not, an exception occurs.  When this
process is complete, all the formals have been instantiated and
assigned values.

Next, the full arguments value is set for this call.  This is a
semi-labeled value ist consisting of the munged argument list with
labels added for each formal parameter where each label name is the
name of the corresponding formal.  For items in the list beyond the
formal parameters, if the value was generated from an item in the raw
argument list with a name, that name is given to that item in the full
arguments value, and otherwise that item is given no label.

After that, the body of the routine is executed.  If the body is a
braced statement block, the statement block is executed.  If control
falls out of the braced statement block without a return or ends with
a return to this routine without a value, an exception occurs.  If
control returns to this point through a return with a value, that
value is the return value.  If the body is an expression, that
expression is evaluated to get the return value.  Either way, that
return value is then checked against the static return type of the
routine, if there is one.  If it is not in that type, an exception
occurs.  Then, if there is a dynamic return type for the routine, the
dynamic return type expression is evaluated.  Then the return value is
checked against this type.  If the value isn't in that type, an
exception occurs.  Otherwise, the scope of the formal parameters exits
and the return value is the result value for the evaluation of the
call expression.

Note that while the base value is not allowed to be invalid (or an
exception occurs), the argument values are in some cases allowed to be
invalid.  If argument type checking requires checking to see if a
given argument is in a type other than the type of every value, this
type checking may generate an exception if the value is invalid.  But
if the routine specifies the type of all values for a given argument,
that argument need not be valid for the call to go through.

Similarly, a routine can return an invalid value without generating an
exception as long as there isn't a type that is not the type of all
values as either a static or dynamic return type for the routine.

EXAMPLES:

  * function f1(x) (x + 12);
    f1(8)!

    is a statement list that prints:

        20

    when executed.

  * (function(x) (x + 12))(18)!

    is a statement that prints:

        30

    when executed.

  * immutable i1 := [operator() := function(...) (arguments)];
    i1()!
    i1(12, "beach")!
    i1(12, c := "beach")!

    is a statement list that prints:

        [[]]
        [[12, "beach"]]
        [[12, c := "beach"]]

    when executed.

  * class c1()
      {
        function operator()(...) (arguments);
      };
    immutable i1 := c1();
    i1(18, tree := "oak")!

    is a statement list that prints:

        [[18, tree := "oak"]]

    when executed.

  * function operator()(...) (arguments);
    "soap"(23, car := "Sentra")!

    is a statement list that prints:

        ["soap", [23, car := "Sentra"]]

    when executed.

  * function show(...) (arguments);
    show(23, car := "Sentra")!

    is a statement list that prints:

        [23, car := "Sentra"]

    when executed.

  * function show(a : integer, car : string) (arguments);
    show(23, car := "Sentra")!

    is a statement list that prints:

        [a := 23, car := "Sentra"]

    when executed.

  * function show(a : integer, car : string) (arguments);
    show(car := "Sentra", a := 23)!

    is a statement list that prints:

        [a := 23, car := "Sentra"]

    when executed.


    Section 5.1.21: Conditional Expressions
    ---------------------------------------

    <conditional-expression> :
        <expression> "?" <expression> ":" <expression>

A conditional expression evaluates one of two expressions depending on
the value of another expression.

Evaluating a conditional expression consists of first evaluating its
first argument.  If the first argument is invalid, an exception
occurs.  If this first argument value is not a boolean, an exception
occurs.  If the value is true, then the second argument is evaluated
and its result is the result of the conditional expression.  If the
value of the first argument is false, then the third argument is
evaluated and its result is the result of the conditional expression.

Note that evaluating the conditional expression involves evaluating
the first expression and either the second or third expressions, but
not both.

EXAMPLES:

  * (a < b) ? b : a is a conditional expression that evaluates to the
    maximum of numeric variables a or b.

  * (1 < 0) ? a() : b() is a conditional expression that calls the
    function b() and the return value of the call is the result of
    evaluating the expression.  a() is not called.


    Section 5.1.22: Unary Expressions
    ---------------------------------

    <unary-expression> :
        <dereference-expression> |
        <location-of-expression> |
        <negate-expression> |
        <unary-plus-expression> |
        <bitwise-not-expression> |
        <logical-not-expression>

Unary expressions each consist of a punctuation token followed by an
expression.

Location-of expressions are special.  All other unary expressions have
certain similarities, including how overloading works for them.

Evaluating a non-location-of unary expression consists of first
evaluating its argument.  If the argument value is invalid, an
exception occurs.

Next, an overloading check occurs.  If overloading applies, an
overloading call is done and the result of that call is the result of
evaluating the unary expression, and that's the end of it.

Overloading checking uses what's called the overloading name.  The
overloading name is the string "operator" followed by the punctuation
character for the unary operator.  For example, for dereference
expressions, the overloading name is "operator*".

To see if overloading applies, the first step is to see if the
overloading name resolves at this point in the code.  If so, the
overloading name is evaluated as a name reference expression.  The
value returned from the evaluation of the overloading name is the
overload base value.  If the overload base value is invalid, an
exception occurs.  Otherwise, if the overload base value is a routine
value, an attempt is made to find a call match.  The argument list for
the call match is exactly one unnamed item: the argument value.  If
there is a match, the matched routine is called and the return value
is the result of evaluating the unary expression and the evaluation is
done.  Otherwise, evaluation continues with the next step of
overloading checking.

The next step of overloading checking is to see if the argument value
has a field whose name is the overloading name -- that is, if applying
the "." operator with the overloading name as the second argument to
the argument value would produce a value.  If so, that value is the
field base value.  If the field base value is invalid, an exception
occurs.  Otherwise, if the field base value is a routine value, an
attempt is made to find a call match.  The argument list for the call
match is the empty list.  If there is a match, the matched routine is
called and the return value is the result of evaluating the unary
expression and the evaluation is done.  Otherwise, there is no
overloading and evaluation continues as a non-overloaded unary
expression.

EXAMPLES:

  * immutable i1 := [operator+ := function(...) (arguments)];
    +i1!

    is a statement list that prints:

        []

    when executed.

  * function operator+(...) (arguments);
    +15!

    is a statement list that prints:

        [15]

    when executed.


    Section 5.1.22.1: Dereference Expressions
    -----------------------------------------

    <dereference-expression> :
        "*" <expression>

A dereference expression follows a pointer.

If the argument value is not a slot location, an exception occurs.  If
the value is a slot location, the result of the dereference expression
is the value currently in that slot location.

EXAMPLES:

  * *x is an expression that follows the pointer contained in the
    variable x.

  * *&x is an expression that evaluates to the value in the variable
     x.


    Section 5.1.22.2: Location-Of Expressions
    -----------------------------------------

    <location-of-expression> :
        "&" <expression>

A location-of expression takes the address of something.

The argument expression to a location-of expression is special.  It
must be of a special restricted form, and it is not evaluated as an
expression.  Expressions in this special form are called addressable
expressions.  Obtaining the location of an addressable expression
results in a slot location.  Evaluating a location-of expression
consists of obtaining the location of its argument.

The intention is that the slot returned is such that dereferencing
that slot results in the value that would have resulted from
evaluating the expression.

Here are the expressions that are addressable expressions and the slot
location that results from from obtaining the location of each.  Any
other expression is illegal as an addressable expression.

  * A variable reference expression is an addressable expression.
    Taking the location of a variable reference expression results in
    the slot location of the variable.  Getting the value through this
    slot location gives the value of the variable and setting the
    value through this slot location sets the value of the variable.

  * A lookup expression is an addressable expression if and only if
    its base expression is addressable.  Taking the location of a
    lookup expression starts with taking the location of the base
    expression.  The resulting slot location is the base slot
    location.

    Next, a check is made to see if the name "operator[]" resolves at
    this point in the code.  If so, "operator[]" is evaluated as a
    name reference expression.  The value returned from the evaluation
    of "operator[]" is the overload base value.

    Next, the expressions and type expressions in the lookup element
    list are all evaluated.  The base slot location, the overload base
    value, and all the values and types generated by evaluating the
    lookup element list items are stashed away as part of the result
    slot location.  Nothing further happens at the time of the
    evaluation of the location of this expression.

    When the time comes to read or write through the resulting slot
    location, the process parallels the process of evaluating a lookup
    expression.

    A read through the slot location starts with a read through the
    base slot location, resulting in the base value.  Then, a read
    through the slot location is exactly the same as if a lookup
    expression were being evaluated that had the same base value,
    overload base value, and element list values and types.

    So the only case left is a write through such a slot location.

    Writing through such a slot location starts with doing a read
    through the base slot location, resulting in the base value.

    @@@@
    If it is a simple lookup expression with an expression index, writing
    through the slot location sets the value associated with the
    given key, even if no value was previously associated with that
    key.

    If the value in this location is not a map value, an
    exception occurs.

    If it is a simple lookup expression with "*" by itself as the
    index, the result is the base slot value.

    If it is a simple lookup expression with "*" followed by ":" and a
    type expression as the index, the base slot value is required to
    be a map slot value.  The result is the base slot value but with
    the keys that aren't in the specified type removed.  So writing
    through that slot location will set elements with keys matching
    the type but no other keys.

    All that remains is the case of a lookup expression that is not
    simple.  In this case, the base slot's current value must be an
    array or an exception occurs.

    Next, all the expressions in the lookup element list are
    evaluated.  As with the case of evaluating a lookup expression, if
    any exprssion in the lookup element list does not evaluate to a
    finite integer value, an exception occurs.  This gives the same
    list of index elements that would be obtained in the process of
    evaluating a lookup expression.

    We now do an operation called address indexing that takes as input
    the base array slot and the list of index elements.

    The address indexing operation is defined by recursion on the
    length of the list of index elements.

    First, we have the base case when the list of index elements
    consists of a single element.  If that element is a finite
    integer, the result is a slot accessing the element of the array
    associated with that integer.  If that element is a range, then
    the result is an array slot with the elements accessing all the
    elements in the range, inclusive, of the base array slot.  This
    result array slot is zero-based.  So if the range is 5...7, then
    the result is an array slot with three elements, indexed by 0, 1,
    and 2.  If the lower bound is greater than the upper bound, the
    result is an array slot with zero elements.  If the element in the
    list of index elements is a "*" by itself, then the result is
    simply the base array slot.  And finally if the element in the
    list of index elements is a "*" followed by a ":" and a type
    expression, then the base array slot is required to be a map slot
    and the result is the base array slot with keys that aren't in the
    specified type removed.

    Now, we have the recursive case.  We recurse from the left-most
    element of the index element list.

    If the left-most element of the index element list is a single
    integer, then the result of the address indexing operation is the
    address indexing operation applied to the element of the base
    array slot specified by that left-most element and with the
    remainder of the index element list after the left-most as the
    recursive index element list.

    If the left-most element of the index element list is a range
    defined by two integers, then the result of the address indexing
    operation is a slot array with number of elements equal to the
    size of the range and elements formed by applying the operation
    recursively to the elements of the base array in the range and the
    remainder of the index list.

    If the left-most element of the index element list is a "*" by
    itself, then the result of the address indexing operation is a
    slot array with the same number of elements and indexes as the
    base slot array with elements formed by recursively applying the
    operation to the elements of the array and the remainder of the
    list.

    If the left-most element of the index element list is a "*"
    followed by ":" and a type expression, then the result of the
    address indexing operation is a slot array with an element for
    each element of the base slot array whose key is in the specified
    type.  For each such element, the result slot array has the same
    key and an element formed by recursively applying the operation to
    the corresponding element of the base array and the remainder of
    the list.

    That completes the recursive definition of the address indexing
    operation.

    Note that the base slot array must have a value with arrays nested
    as deeply as the number of elements in the indexing array.  If at
    any point the address indexing operation is applied to a base slot
    that has a value that is not an array, an exception occurs.
    @@@@

  * A field reference expression is an addressable expression if and
    only if its base expression is addressable.  Taking the location
    of a field reference expression starts with taking the location of
    its base expression.  That must result in a slot location that is
    called the base slot location.  This base slot location and the
    field name from the field reference expression are stashed away to
    form the result slot location and that is the end of the
    location-taking operation.

    When it comes time to read through the resulting slot location,
    the read operation is first applied recursively to the base slot
    location.  This results in a value called the base value.  The
    base value must be a semi-labeled value list, a semi-labeled
    multi-set, a lepton, or a class value.  Otherwise, an exception
    occurs.  Then, a field access is performed on the base value with
    the field name from the slot location, just as if a "." operator
    had been applied to that value with that name.  If the base value
    doesn't have a field with that name, an exception occurs.
    Otherwise, the value of that field is the result of the read
    operation.

    When it comes time to write through the resulting slot location,
    the read operation is first applied to the base slot location.
    This results in a value called the base value.  The next step
    depends on what sort of value the base value is.

      + If the base value is an object the following rules apply.  If
        the object does not have a field with that name or has a field
        of that name which is not a variable, an exception occurs.  If
        the object has a variable field with that name, that variable
        instance is set to the new value and the write operation is
        complete.  Note that assigning the variable instance the new
        value involves a type check, and if that type check fails, an
        exception occurs and the value of that variable is not
        updated.

      + If the base value is a semi-labeled value list, the followling
        rules apply.  A new value called the updated value is
        created.  If the semi-labeled value list has a field whose
        name matches the field name from the slot list, the updated
        value is a semi-labeled value list identical to the base value
        except that the component with the matching name has its value
        replaced by the value being written.  Otherwise, the updated
        value is a semi-labeled multi-set with all the same fields as
        the base value plus a new field whose name is the field name
        from the slot location and whose value is the value being
        written.  Then, the write operation is used recursively using
        the base slot location and the updated value.

      + If the base value is a semi-labeled multi-set, the following
        rules apply.  A new value called the updated value is
        created.  The updated value is a semi-labeled multi-set with
        all the same fields as the base value except that if the base
        value had a field whose name matched the name from the slot
        location, that field is deleted; and whether or not the base
        value had a field of that name, a field of that name is added
        to the updated value with the value to be written as its
        value.  Then, the write operation is used recursively using
        the base slot location and the updated value.

      + If the base value is a lepton, the following rules apply.
        First, a type check is done to see if a field with the name
        specified by the slot location's field name is allowed with
        the value being written as its value.  If not, then an
        exception occurs.  Otherwise, a new value called the updated
        value is created.  This is a lepton value with the same key
        and all the same fields as the base value except that if the
        base value had a field whose name matched the name from the
        slot location, that field is deleted; and whether or not the
        base value had a field of that name, a field of that name is
        added to the updated value with the value to be written as its
        value.  Then, the write operation is used recursively using
        the base slot location and the updated value.

      + If the base value is any other kind of value, the following
        rules apply.  A new value called the updated value is
        created.  This updated value is a semi-labeled multi-set value
        with a single field whose name is given by the slot location's
        field name and whose value is the value to be written.  Then,
        the write operation is used recursively using the base slot
        location and the updated value.

  * A pointer field reference expression is an addressable
    expression.  Taking the location of a pointer field reference
    expression starts with evaluating its base expression.  The
    resulting value is the base value.

    Next, a check is made to see if the name "operator->" resolves at
    this point in the code.  If so, "operator->" is evaluated as a
    name reference expression.  The value returned from the evaluation
    of "operator->" is the overload base value.  This overloaded base
    value and the base value are both stashed away as part of the
    result slot location.  If the overloaded base value is not
    present, then the base value must be valid and contain a slot
    location or else an exception occurs.  Nothing further happens at
    the time of the evaluation of the location-of expression.

    When it comes time to read through the slot location produced this
    way, the first step is to check for overloading, and if an
    overloading match is found, overloading is used instead of a
    normal slot access.  First, if the overload base value is present,
    a check is done to see if overloading should be done using it.  In
    this case, the overload base value is checked to see if it is
    valid, and if it is not, an exception occurs.  Otherwise, if the
    overload base value is a routine value, an attempt is made to find
    a call match.  The argument list for the call match is exactly two
    items.  The first item is unnamed with the base value as its
    value.  The second item is named "field" and has as its value a
    string constant value with the string matching the field name of
    the slot location.  If there is a match, the matched routine is
    called and the return value is the result of reading through the
    slot location and the operation is done.  Otherwise, the reading
    operation continues with the next step of overloading checking.

    The next step of overloading checking is to see if the base value
    has a field with the name "operator->" -- that is, if applying
    ".operator->" to the value would produce a value.  If so, that
    value is the field base value.  If the field base value is
    invalid, an exception occurs.  Otherwise, if the field base value
    is a routine value, an attempt is made to find a call match.  The
    argument list for the call match is exactly one item.  This item
    is named "field" and has as its value a string constant value with
    the string matching the field name of the slot location.  If there
    is a match, the matched routine is called and the return value is
    the result of reading through the slot location and the operation
    is done.  Otherwise, there is no overloading and the reading
    operation continues as a normal slot location read operation.

    At this point, if the base value is invalid or is not a slot
    location, an exception occurs.  If the value is a slot location,
    the slot location reading operation is applied recursively to this
    slot location and the result is called the core value.

    The core value must be a semi-labeled value list, a semi-labeled
    multi-set, a lepton, or a class value.  Otherwise, an exception
    occurs.  Then, a field access is performed on the core value with
    the field name from the slot location, just as if a "." operator
    had been applied to that value with that name.  If the core value
    doesn't have a field with that name, an exception occurs.
    Otherwise, the value of that field is the result of the read
    operation.

    When it comes time to write through the slot location produced
    this way, the first step is to check for overloading, and if an
    overloading match is found, overloading is used instead of a
    normal slot access.  First, if the overload base value is present,
    a check is done to see if overloading should be done using it.  In
    this case, the overload base value is checked to see if it is
    valid, and if it is not, an exception occurs.  Otherwise, if the
    overload base value is a routine value, an attempt is made to find
    a call match.  The argument list for the call match is exactly
    three items.  The first item is an unnamed item whose value is the
    base value.  The second item has the name "field" and as a value
    has the string value whose string is that specified by the slot
    location as the field name.  The third item is an unnamed item
    whose value is the value being written.  If there is a match, the
    matched routine is called and the write operation is done.
    Otherwise, the writing operation continues with the next step of
    overloading checking.

    The next step of overloading checking is to see if the base value
    has a field with the name "operator->" -- that is, if applying
    ".operator->" to the value would produce a value.  If so, that
    value is the field base value.  If the field base value is
    invalid, an exception occurs.  Otherwise, if the field base value
    is a routine value, an attempt is made to find a call match.  The
    argument list for the call match is exactly two items.  The first
    item has the name "field" and as a value has the string value
    whose string is that specified byt he slot location as the field
    name.  The second item is an unnamed item whose value is the value
    being written.  If there is a match, the matched routine is called
    and the write operation is done.  Otherwise, there is no
    overloading and the writing operation continues as a normal
    pointer field write operation.

    At this point, if the base value is invalid or is not a slot
    location, an exception occurs.  If the value is a slot location,
    the read operation is applied through that slot location and the
    result is a value called the core value.

    The core value is then handled as if it were the base value in a
    write through a slot location created by taking the address of a
    field reference expression.  If the core value is not a class,
    this results in the write operation being used recursively with an
    updated value.  This recursive use of the write operation uses the
    slot location from the base value as its slot location.

  * A tagalong field reference expression is an addressable expression
    if and only if its base expression is addressable.  Taking the
    location of a tagalong field reference expression starts with
    taking the location of its base expression.  That must result in a
    slot location called the base slot location.  Otherwise, an
    exception occurs.  Then, the key expression is evaluated to give
    the key value.  If the key value is invalid, an exception occurs.
    If the key value is not a tagalong key value, an exception occurs.
    The key is the tagalong key instance for the key value.  The base
    slot location and the tagalong key are both slashed away as part
    of the result slot location.  This is the end of the address
    taking operation.

    When it comes time to read through the resulting slot location,
    the read operation is first applied recursively to the base slot
    location.  This results in a value called the base value.  A
    tagalong lookup is then performed on the base value using the key
    from the slot location, just as if a ".." expression were being
    evaluated with that base value and tagalong key.  If there is no
    value associated with that key on that base value and no default
    value for the key, an exception occurs.  Otherwise, the result of
    the read operation is the value returned by the tagalong lookup.

    When it comes time to write through the resulting slot location,
    the read operation is first applied to the base slot location.
    This results in a value called the base value.  Then, a tagalong
    value is set for the base value for the key from the slot location
    using the value being written.  If the base value doesn't match
    the "on" type of the key or the value being written isn't in the
    type of the key, an exception occurs and the tagalong value is not
    set for that key on that value.

  * A dereference expression is an addressable expression.  Taking the
    location of a dereference expression consists of first evaluating
    the argument expression of the dereference expression.  This is
    the base value.

    Next, a check is made to see if the name "operator*" resolves at
    this point in the code.  If so, "operator*" is evaluated as a name
    reference expression.  The value returned from the evaluation of
    "operator*" is the overload base value.  This overloaded base
    value and the base value are both stashed away as part of the
    result slot location.  If the overloaded base value is not
    present, then the base value must be valid and contain a slot
    location or else an exception occurs.  Nothing further happens at
    the time of the evaluation of the location-of expression.

    When it comes time to read through the slot location produced this
    way, the first step is to check for overloading, and if an
    overloading match is found, overloading is used instead of a
    normal slot access.  First, if the overload base value is present,
    a check is done to see if overloading should be done using it.  In
    this case, the overload base value is checked to see if it is
    valid, and if it is not, an exception occurs.  Otherwise, if the
    overload base value is a routine value, an attempt is made to find
    a call match.  The argument list for the call match is exactly one
    unnamed item.  That item's value is the base value.  If there is a
    match, the matched routine is called and the return value is the
    result of reading through the slot location and the operation is
    done.  Otherwise, the reading operation continues with the next
    step of overloading checking.

    The next step of overloading checking is to see if the base value
    has a field with the name "operator*" -- that is, if applying
    ".operator*" to the value would produce a value.  If so, that
    value is the field base value.  If the field base value is
    invalid, an exception occurs.  Otherwise, if the field base value
    is a routine value, an attempt is made to find a call match.  The
    argument list for the call match is the empty list.  If there is a
    match, the matched routine is called and the return value is the
    result of reading through the slot location and the operation is
    done.  Otherwise, there is no overloading and the reading
    operation continues as a normal slot location read operation.

    At this point, if the base value is invalid or is not a slot
    location, an exception occurs.  If the value is a slot location,
    the slot location reading operation is applied recursively to this
    slot location and the result is the result of the slot location
    reading operation.

    When it comes time to write through the slot location produced
    this way, the first step is to check for overloading, and if an
    overloading match is found, overloading is used instead of a
    normal slot access.  First, if the overload base value is present,
    a check is done to see if overloading should be done using it.  In
    this case, the overload base value is checked to see if it is
    valid, and if it is not, an exception occurs.  Otherwise, if the
    overload base value is a routine value, an attempt is made to find
    a call match.  The argument list for the call match is exactly two
    unnamed items.  The first item's value is the base value.  The
    second item's value is the value being written.  If there is a
    match, the matched routine is called and the write operation is
    done.  Otherwise, the writing operation continues with the next
    step of overloading checking.

    The next step of overloading checking is to see if the base value
    has a field with the name "operator*" -- that is, if applying
    ".operator*" to the value would produce a value.  If so, that
    value is the field base value.  If the field base value is
    invalid, an exception occurs.  Otherwise, if the field base value
    is a routine value, an attempt is made to find a call match.  The
    argument list for the call match is exactly one unnamed item.
    That item's value is the value being written.  If there is a
    match, the matched routine is called and the write operation is
    done.  Otherwise, there is no overloading and the writing
    operation continues as a normal slot location write operation.

    At this point, if the base value is invalid or is not a slot
    location, an exception occurs.  If the value is a slot location,
    the slot location writing operation is applied recursively to this
    slot location with the value being written.

EXAMPLES:

  * &*x is an expression that evaluates to the slot location value in
    x at the time the location-of expression is evaluated.

  * &(x.y) is an expression that evaluates to a slot location giving
    access to a field in the variable x with the field name ``y''.
    Note that it doesn't matter what value x contains at the time the
    location-of expression is evaluated, or even if x has a value or
    is even instantiated.  That only matters if and when an access is
    made through the slot location that results from evaluating this
    expression.

  * &(x[3]) is an expression that evaluates to a slot location giving
    access to element number three of the array variable x.

  * variable x := "yesterday";
    variable i1 :=
      {
        ageless function operator*(...) (arguments);
        return &*x;
      };
    *i1!

    is a statement list that prints:

        ["yesterday"]

    when executed.

  * variable x := "yesterday";
    variable i1 :=
      {
        ageless procedure operator*(...)
          { print("operator* arguments: ", arguments, "\n"); };
        return &*x;
      };
    *i1 := 15;

    is a statement list that prints:

        operator* arguments: ["yesterday", 15]

    when executed.

  * immutable i1 := [operator* := function(...) (arguments)];
    immutable i2 := &*i1;
    *i2!

    is a statement list that prints:

        []

    when executed.

  * immutable i1 :=
      [
        operator* := procedure(...)
          { print("operator* arguments: ", arguments, "\n"); }
      ];
    immutable i2 := &*i1;
    *i2 := 17;

    is a statement list that prints:

        operator* arguments: [17]

    when executed.

  * variable v1 := [b := 2, a := 1];
    v1!
    v1[0]!
    v1.b := 3;
    v1!
    v1[0]!
    v1.c := 4;
    v1!

    is a statement list that prints:

        [b := 2, a := 1]
        2
        [b := 3, a := 1]
        3
        [b := 3, a := 1, c := 4]

    when executed.

  * variable x := "yesterday";
    variable i1 :=
      {
        ageless function operator->(...) (arguments);
        return &x->a;
      };
    *i1!

    is a statement list that prints:

        ["yesterday", field := "a"]

    when executed.

  * variable x := "yesterday";
    variable i1 :=
      {
        ageless procedure operator->(...)
          { print("operator-> arguments: ", arguments, "\n"); };
        return &x->a;
      };
    *i1 := 15;

    is a statement list that prints:

        operator-> arguments: ["yesterday", field := "a", 15]

    when executed.

  * immutable i1 := [operator-> := function(...) (arguments)];
    immutable i2 := &i1->a;
    *i2!

    is a statement list that prints:

        [field := "a"]

    when executed.

  * immutable i1 :=
      [
        operator-> := procedure(...)
          { print("operator-> arguments: ", arguments, "\n"); }
      ];
    immutable i2 := &i1->a;
    *i2 := 17;

    is a statement list that prints:

        operator-> arguments: [field := "a", 17]

    when executed.


    Section 5.1.22.3: Negate Expressions
    ------------------------------------

    <negate-expression> :
        "-" <expression>

A negate expression negates a numeric value.

If the argument value is not an integer or rational, an exception
occurs.  If the value is an integer or rational, the result of the
negate expression is the negation of the value.  The following are the
results of negating non-finite numeric values:

  * The negation of positive infinity is negative infinity.

  * The negation of negative infinity is positive infinity.

  * The negation of unsigned infinity is itself.

  * The negation of zero-zero is itself.

EXAMPLES:

  * -10 is an expression resulting in the integer value with -10 as
    the integer.


    Section 5.1.22.4: Unary Plus Expressions
    ----------------------------------------

    <unary-plus-expression> :
        "+" <expression>

The unary plus expression is the counterpart to the negate
expression.  It is equivalent to applying the negate operator twice.
It has no effect except to require that its operand is a numeric
value.

If the argument value is not an integer or rational, an exception
occurs.  If the value is an integer or rational, the result of the
negate expression is the argument value itself.

EXAMPLES:

  * +10 is an expression resulting in the integer value with 10 as the
    integer.


    Section 5.1.22.5: Bitwise Not Expressions
    -----------------------------------------

    <bitwise-not-expression> :
        "~" <expression>

A bitwise not expression takes an integer value, considers it as an
infinite bit sequence, reverses all those bits, and takes that as a
numeric value.  The expression ~a is equivalent to -(a + 1).

If the argument value is not an integer, an exception occurs.  If the
value is an integer, the result of the bitwise not expression is the
the value minus one and then negated.

EXAMPLES:

  * ~0 is an expression resulting in the integer value with -1 as the
    integer.

  * ~7 is an expression resulting in the integer value with -8 as the
    integer.


    Section 5.1.22.6: Logical Not Expressions
    -----------------------------------------

    <logical-not-expression> :
        "!" <expression>

A logical not expression takes a boolean value and reverses it.  If
the operand is true, the result is false, and if the operand is false,
the result is true.

If the argument value is not a boolean, an exception occurs.  If the
argument value is true, the result of the logical not expression is
false.  If the argument value is false, the result of the logical not
expression is true.

EXAMPLES:

  * ~true is an expression resulting in the value false;

  * ~(a < b) is an expression resulting in the value true if and only
    if a is greater than or equal to b.


    Section 5.1.23: Binary Expressions
    ----------------------------------

    <binary-expression> :
        <expression> <binary-operator> <expression>

    <binary-operator> :
        "+" |
        "-" |
        "*" |
        "/" |
        "/::" |
        "%" |
        "<<" |
        ">>" |
        "<" |
        ">" |
        "<=" |
        ">=" |
        "==" |
        "!=" |
        "&" |
        "|" |
        "^" |
        "&&" |
        "||" |
        "~"

A binary expression uses two operand expressions, the left operand
expression and the right operand expression.  The punctuation token in
between the two expressions determines how the two expressions are
used.

The two operators "&&" and "||" are special -- they are called
short-circuiting operators.  These operators may or may not evaluate
their right operand expressions depending on the values of their left
operand expressions.  There is never overloading on short-circuiting
operators.  All other operators are called non-short-circuiting
operators.

For all non-short-circuiting operators, evaluation starts with the
evaluation of the left operand expression and then evaluation of the
right operand expression.  This produces the left value and the right
value respectively.  Then, if either the left or the right value is
invalid, an exception occurs.

Next for non-short-circuiting operators, an overloading check occurs.
If overloading applies, an overloading call is done and the result of
that call is the result of evaluating the binary expression, and
that's the end of it.

Overloading checking uses what's called the overloading name.  The
overloading name is the string "operator" followed by the punctuation
characters for the binary operator.  For example, for the "!="
operator, the overloading name is "operator!=".

To see if overloading applies, the first step is to see if the
overloading name resolves at this point in the code.  If so, the
overloading name is evaluated as a name reference expression.  The
value returned from the evaluation of the overloading name is the
overload base value.  If the overload base value is invalid, an
exception occurs.  Otherwise, if the overload base value is a routine
value, an attempt is made to find a call match.  The argument list for
the call match contains exactly two unnamed items: first the left
value, then the right value.  If there is a match, the matched routine
is called and the return value is the result of evaluating the binary
expression and the evaluation is done.  Otherwise, evaluation
continues with the next step of overloading checking.

The next step of overloading checking is to see if the left
value has a field whose name is the overloading name -- that is, if
applying the "." operator with the overloading name as the second
argument to the left value would produce a value.  If so, that value
is the field base value.  If the field base value is invalid, an
exception occurs.  Otherwise, if the field base value is a routine
value, an attempt is made to find a call match.  The argument list for
the call match contains exactly two items: first the right value
without a name, and then the false value with the name ``reversed''.
If there is a match, the matched routine is called and the return
value is the result of evaluating the binary expression and the
evaluation is done.  Otherwise, evaluation continues with the next
step of overloading checking.

The final step of overload checking is the same as the previous step
except looking for a field whose name is the overloading name in the
right value, and with the first argument value changed to the left
value and the second argument value changed from the false value to
the true value.  If there is no match, there is no overloading and
evaluation continues as a non-overloaded binary expression.

EXAMPLES:

  * immutable i1 := [operator+ := function(...)
      (arguments == [12, reversed := false])];
    i1 + 12!

    is a statement list that prints:

        true

    when executed.

  * function operator+(...) (arguments);
    15 + 16!

    is a statement list that prints:

        [15, 16]

    when executed.


    Section 5.1.23.1: Add Expressions
    ---------------------------------

Binary expressions using the "+" operator are add expressions.  The
operand values for an add expression must be one of the following or
an exception occurs:

  * both rational values.  In this case, the result is the rational
    value that is the result of adding the two rational operand
    values.

  * one slot location value and one integer value (in either order).
    In this case, if the integer is zero, the result is the operand
    slot location value unchanged.  Otherwise, the operand slot
    location must be the result of taking the location of a lookup
    slot location or the result of an add or subtract of a slot
    location and an integer or an exception occurs.  If the integer is
    unsigned infinity or zero-zero, an exception occurs.  If the final
    dimension of the lookup is a filter function rather than a single
    key value or a range, an exception occurs.  If the final dimension
    of the lookup is a non-integer key value, an exception occurs.  So
    if no exception has occurred, the final dimension of the lookup
    must be either a single integer key or a range from one integer to
    another integer.  In the first case, the result is a slot location
    with all dimensions the same except the final dimension whose
    single value is replaced by the old value plus the integer.  In
    the second case, the result is a slot location with all dimensions
    the same except the final dimension whose range is replaced by a
    new range with the integer added to both the lower and upper
    bounds of the range.

EXAMPLES:

  * 15 + 16!

    is a statement list that prints:

        31

    when executed.

  * immutable i1 := ["a", "b", "c", "d", "e"];
    immutable i2 := &i1[2];
    *i2!
    *(i2 + 2)!

    is a statement list that prints:

        c
        e

    when executed.

  * immutable i1 := ["a", "b", "c", "d", "e"];
    immutable i2 := &i1[1...2];
    *i2!
    *(i2 + 2)!

    is a statement list that prints:

        ["b", "c"]
        ["d", "e"]

    when executed.


    Section 5.1.23.2: Subtract Expressions
    --------------------------------------

Binary expressions using the "-" operator are subtract expressions.
The operand values for a subtract expression must be one of the
following or an exception occurs:

  * both rational values.  In this case, the result is the rational
    value that is the result of subtracting the right from the left
    operand value.

  * a slot location value as the left operand and an integer value as
    the right operand.  In this case, the result is the same as if it
    were an add expression with the same left value and a right value
    that was an integer value with the negation of the integer as its
    integer.

  * both slot location values.  In this case, if the slot locations
    are equal, the result is the integer value zero.  Otherwise, the
    operand slot locations must both be the result of taking the
    location of a lookup slot location or the result of an add or
    subtract of a slot location and an integer or an exception
    occurs.  If the two slot locations don't have the same base slot
    location, an exception occurs.  If the two slot locations don't
    have the same number of dimensions or aren't identical in all but
    the final dimension, an exception occurs.  If the final dimension
    of either is a filter, an exception occurs.  If the final
    dimension of either is a single value that is not an integer, an
    exception occurs.  If the final dimension of one is a range and
    the other is not, an exception occurs.  Otherwise, the final
    dimensions are either both single integer keys or both integer
    ranges.  If the final dimensions are both single integer keys, the
    result is the integer value that is the difference between the two
    integer keys in the final dimension.  Otherwise, the final
    dimensions are both ranges.  The two upper bounds are subtracted
    to get an upper bound difference integer and the two lower bounds
    are subtracted to get a lower bound difference integer.  If the
    upper and lower bound difference integers are not identical, an
    exception occurs.  Otherwise, the result is the integer value
    equal to both the upper and lower bound difference integers.

EXAMPLES:

  * 15 - 16!

    is a statement list that prints:

        -1

    when executed.

  * immutable i1 := ["a", "b", "c", "d", "e"];
    immutable i2 := &i1[4];
    *i2!
    *(i2 - 2)!

    is a statement list that prints:

        e
        c

    when executed.

  * immutable i1 := ["a", "b", "c", "d", "e"];
    immutable i2 := &i1[3...4];
    *i2!
    *(i2 - 2)!

    is a statement list that prints:

        ["d", "e"]
        ["b", "c"]

    when executed.

  * immutable i1 := ["a", "b", "c", "d", "e"];
    immutable i2 := &i1[3];
    immutable i3 := &i1[0];
    (i2 - i3)!

    is a statement list that prints:

        3

    when executed.

  * immutable i1 := ["a", "b", "c", "d", "e"];
    immutable i2 := &i1[3...4];
    immutable i3 := &i1[1...2];
    (i2 - i3)!

    is a statement list that prints:

        2

    when executed.


    Section 5.1.23.3: Multiply Expressions
    --------------------------------------

Binary expressions using the "*" operator are multiply expressions.
The operand values for a multiply expression must both be rational
values or an exception occurs.  The result is the rational value that
is the result of multiplying the two operand values.

EXAMPLE:

  * 8 * 8!

    is a statement list that prints:

        64

    when executed.


    Section 5.1.23.4: Divide Expressions
    ------------------------------------

Binary expressions using the "/" operator are divide expressions.  The
operand values for a divide expression must both be rational values or
an exception occurs.  The result is the rational value that is the
result of dividing the left operand value by the right operand value.

Note that unlike many programming languages, dividing an integer by an
integer in Salmon gives the exact rational result, not a result that
is truncated or rounded to an integer.  For integer division that
truncates to an integer, use the a divide-force expression (the "/::"
operator).

EXAMPLES:

  * 18 / 3!

    is a statement list that prints:

        6

    when executed.

  * 17 / 3!

    is a statement list that prints:

        17/3

    when executed.


    Section 5.1.23.5: Divide-Force Expressions
    ------------------------------------------

Binary expressions using the "/::" operator are divide-force
expressions.  The operand values for a divide-force expression must
both be integer values or an exception occurs.  The result is the
integer value that is the result of dividing the left operand value by
the right operand value and then truncating to the next integer in the
direction of zero if the result is not an integer, or simply the
integer result of division if that was already an integer.  That is,
if the result of the division is non-negative, it is the floor of the
result and if the result of the division is negative it is the ceiling
of the result.

EXAMPLES:

  * 18 /:: 3!

    is a statement list that prints:

        6

    when executed.

  * 17 /:: 3!

    is a statement list that prints:

        5

    when executed.

  * (-17) /:: 3!

    is a statement list that prints:

        -5

    when executed.


    Section 5.1.23.6: Remainder Expressions
    ---------------------------------------

Binary expressions using the "%" operator are remainder expressions.
The operand values for a remainder expression must both be integer
values or an exception occurs.  The result is the integer value that
is the remainder when doing integer division of the left operand value
by the right operand value.  In other words, the "%" operator is
defined such that

    (a /:: b) + (a % b) == 0

holds for all integers a and b.

EXAMPLES:

  * 18 % 3!

    is a statement list that prints:

        0

    when executed.

  * 17 % 3!

    is a statement list that prints:

        2

    when executed.

  * (-17) % 3!

    is a statement list that prints:

        -2

    when executed.


    Section 5.1.23.7: Left Shift Expressions
    ----------------------------------------

Binary expressions using the "<<" operator are left shift
expressions.  The operand values for a left shift expression must both
be integer values or an exception occurs.  The result is the integer
value result of taking the floor of multiplying two to the power of
the right value by the left value.

EXAMPLES:

  * 3 << 2!

    is a statement list that prints:

        12

    when executed.

  * (-3) << 2!

    is a statement list that prints:

        -12

    when executed.

  * 3 << -1!

    is a statement list that prints:

        1

    when executed.

  * (-3) << -1!

    is a statement list that prints:

        -2

    when executed.


    Section 5.1.23.8: Right Shift Expressions
    -----------------------------------------

Binary expressions using the ">>" operator are right shift
expressions.  The operand values for a right shift expression must both
be integer values or an exception occurs.  The result is the integer
value result of taking the floor of multiplying two to the power of
the negation of the right value by the left value.

EXAMPLES:

  * 3 >> -2!

    is a statement list that prints:

        12

    when executed.

  * (-3) >> -2!

    is a statement list that prints:

        -12

    when executed.

  * 3 >> 1!

    is a statement list that prints:

        1

    when executed.

  * (-3) >> 1!

    is a statement list that prints:

        -2

    when executed.


    Section 5.1.23.9: Less-Than Expressions
    ---------------------------------------

Binary expressions using the "<" operator are less-than expressions.
The operand values for a less-than expression must either both be
rational values or both be slot location values or else an exception
occurs.  The result value is always either true or false.

If the operand values are both finite rational values, then the result
is true if and only if the left value is less than the right value.
If the left is finite and the right is positive infinity, the result
true.  If the left is finite and the right is negative infinity, the
result is false.  If the left is negative infinity and the right is
finite, the result is true.  If the left is positive infinity and the
right is finite, the result is false.  If the left is positive
infinity and the right is negative infinity the result is false.  If
the result is negative infinity and the right is positive infinity,
the result is true.  If both the left and right are negative infinity,
the result is false.  If both the left and right are positive
infinity, the result is false.  Otherwise, if both values are
rationals the result is false.

If the operands are both slot locations, then if subtracting the two
operands would cause an exception, an exception occurs.  Otherwise, if
the result of the subtraction is a negative integer, the result is
true, otherwise the result is false.

EXAMPLES:

  * 3 < 4!

    is a statement list that prints:

        true

    when executed.

  * 4 < 4!

    is a statement list that prints:

        false

    when executed.

  * 5 < 4!

    is a statement list that prints:

        false

    when executed.

  * immutable i1 := ["a", "b", "c", "d", "e"];
    immutable i2 := &i1[3];
    immutable i3 := &i1[0];
    (i2 < i3)!
    (i3 < i2)!

    is a statement list that prints:

        false
        true

    when executed.


    Section 5.1.23.10: Greater-Than Expressions
    -------------------------------------------

Binary expressions using the ">" operator are greater-than
expressions.  The result of evaluating a greater-than expression is
the same as the result of evaluating a less-than expression with the
operands swapped except for the order of evaluation of the operands.

EXAMPLES:

  * 3 > 4!

    is a statement list that prints:

        false

    when executed.

  * 4 > 4!

    is a statement list that prints:

        false

    when executed.

  * 5 > 4!

    is a statement list that prints:

        true

    when executed.


    Section 5.1.23.11: Less-Than-Or-Equal Expressions
    -------------------------------------------------

Binary expressions using the "<=" operator are less-than-or-equal
expressions.  The operand values for a less-than-or-equal expression
must either both be rational values or both be slot location values or
else an exception occurs.  The result value is always either true or
false.

If the operand values are equal, the result is true.  Otherwise, the
result is the same as it would have been for a less-than expression
with the same values.

EXAMPLES:

  * 3 <= 4!

    is a statement list that prints:

        true

    when executed.

  * 4 <= 4!

    is a statement list that prints:

        true

    when executed.

  * 5 <= 4!

    is a statement list that prints:

        false

    when executed.


    Section 5.1.23.12: Greater-Than-Or-Equal Expressions
    ----------------------------------------------------

Binary expressions using the ">=" operator are greater-than-or-equal
expressions.  The operand values for a greater-than-or-equal
expression must either both be rational values or both be slot
location values or else an exception occurs.  The result value is
always either true or false.

If the operand values are equal, the result is true.  Otherwise, the
result is the same as it would have been for a greater-than expression
with the same values.

EXAMPLES:

  * 3 >= 4!

    is a statement list that prints:

        false

    when executed.

  * 4 >= 4!

    is a statement list that prints:

        true

    when executed.

  * 5 >= 4!

    is a statement list that prints:

        true

    when executed.


    Section 5.1.23.13: Equal Expressions
    ------------------------------------

Binary expressions using the "==" operator are equal expressions.  The
operand values are allowed to be any kind of values.  The result is
true if the values are equal and false otherwise.

EXAMPLES:

  * ([17, 18] == [17, 18])!

    is a statement list that prints:

        true

    when executed.

  * ([17, 18] == "blue")!

    is a statement list that prints:

        false

    when executed.


    Section 5.1.23.14: Not-Equal Expressions
    ----------------------------------------

Binary expressions using the "!=" operator are not-equal expressions.
The operand values are allowed to be any kind of values.  The result
is false if the values are equal and true otherwise.

EXAMPLES:

  * ([17, 18] != [17, 18])!

    is a statement list that prints:

        false

    when executed.

  * ([17, 18] != "blue")!

    is a statement list that prints:

        true

    when executed.


    Section 5.1.23.15: Bitwise And Expressions
    ------------------------------------------

Binary expressions using the "&" operator are bitwise and
expressions.  The operand values for a bitwise and expression must
both be integer values or an exception occurs.  The result is computed
by considering each integer operand to be an infinitely long bit array
corresponding to the unlimited-length two's complement bit
representation of that integer.  Then, the result bit array is
generated by setting each bit only if the corresponding bits in both
the left and right bit arrays are set.  The result value is the
integer value generated by taking the result bit array as a two's
complement representation of an integer.

EXAMPLES:

  * 0x3f & 0xf3!

    is a statement list that prints:

        51

    when executed.

  * (-1) & (-4)!

    is a statement list that prints:

        -4

    when executed.


    Section 5.1.23.16: Bitwise Or Expressions
    -----------------------------------------

Binary expressions using the "|" operator are bitwise or expressions.
The operand values for a bitwise or expression must both be integer
values or an exception occurs.  The result is computed by considering
each integer operand to be an infinitely long bit array corresponding
to the unlimited-length two's complement bit representation of that
integer.  Then, the result bit array is generated by setting each bit
only if either of the corresponding bits in the left and right bit
arrays is set.  The result value is the integer value generated by
taking the result bit array as a two's complement representation of an
integer.

EXAMPLES:

  * 0x3f | 0xf3!

    is a statement list that prints:

        255

    when executed.

  * (-1) | (-4)!

    is a statement list that prints:

        -1

    when executed.


    Section 5.1.23.17: Bitwise Xor Expressions
    ------------------------------------------

Binary expressions using the "^" operator are bitwise xor
expressions.  The operand values for a bitwise xor expression must
both be integer values or an exception occurs.  The result is computed
by considering each integer operand to be an infinitely long bit array
corresponding to the unlimited-length two's complement bit
representation of that integer.  Then, the result bit array is
generated by setting each bit only if one or the other but not both of
the corresponding bits in the left and right bit arrays is set.  The
result value is the integer value generated by taking the result bit
array as a two's complement representation of an integer.

EXAMPLES:

  * 0x3f ^ 0xf3!

    is a statement list that prints:

        204

    when executed.

  * (-1) ^ (-4)!

    is a statement list that prints:

        3

    when executed.


    Section 5.1.23.18: Logical-And Expressions
    ------------------------------------------

Binary expressions using the "&&" operator are logical-and
expressions.  The first step in evaluating a logical-and expression is
to evaluate its left operand expression to give the left value.  If
the left value is invalid, an exception occurs.  If the left value is
not a boolean, an exception occurs.  If the left value is false, then
the right operand is never evaluated and the result of evaluating the
logical-and expression is false.  Otherwise, the right operand is
evaluated to give the right value.  If the right value is invalid an
exception occurs.  If the right value is not a boolean, an exception
occurs.  The result of evaluating the logical-and expression is the
right value.

EXAMPLE:

  * function f1()  { "f1()"!; return true; };
    function f2()  { "f2()"!; return false; };
    (f1() && f1())!
    (f1() && f2())!
    (f2() && f1())!
    (f2() && f2())!

    is a statement list that prints:

        f1()
        f1()
        true
        f1()
        f2()
        false
        f2()
        false
        f2()
        false

    when executed.


    Section 5.1.23.19: Logical-Or Expressions
    -----------------------------------------

Binary expressions using the "||" operator are logical-or
expressions.  The first step in evaluating a logical-or expression is
to evaluate its left operand expression to give the left value.  If
the left value is invalid, an exception occurs.  If the left value is
not a boolean, an exception occurs.  If the left value is true, then
the right operand is never evaluated and the result of evaluating the
logical-or expression is true.  Otherwise, the right operand is
evaluated to give the right value.  If the right value is invalid an
exception occurs.  If the right value is not a boolean, an exception
occurs.  The result of evaluating the logical-or expression is the
right value.

EXAMPLE:

  * function f1()  { "f1()"!; return true; };
    function f2()  { "f2()"!; return false; };
    (f1() || f1())!
    (f1() || f2())!
    (f2() || f1())!
    (f2() || f2())!

    is a statement list that prints:

        f1()
        true
        f1()
        true
        f2()
        f1()
        true
        f2()
        f2()
        false

    when executed.


    Section 5.1.23.20: Concatenate Expressions
    ------------------------------------------

Binary expressions using the "~" operator are concatenate expressions.
The operand values for a concatenate expression must either both be
string or character values or both be map or semi-labeled value list
values.

If the values are string or character values, then the result is a
string value.  If both values are character values, the result string
is the two-character value consisting of first the left character and
then the right character.  If the left value is a character value and
the right value is a string, then the result is the string consisting
of first the left character value and then the characters in the right
string in order.  If both values are string values, then the result is
the concatenation of the two strings.  If the left is a string value
and the right is a character value, the result is the left string with
the right character appended.

If either value is a map, it must be a finite dense array based at
zero.  That is, all the keys must be integers in the range from zero
to some finite integer value, inclusive, and every integer in that
range must map to a target value.  The result is a semi-labeled value
list formed by concatenating the two values treated as semi-labeled
value lists.  If either is a map, the corresponding semi-labeled value
list that is used is the semi-labeled value list with as many elements
as there are integer value keys in the map plus one, with no labels,
and with each element containing the value that the map targets for
the key that is the index of that element of the semi-labeled value
list.

EXAMPLES:

  * 'a' ~ 'b'!
    'a' ~ "bc"!
    "ab" ~ 'c'!
    "ab" ~ "cd"!

    is a statement list that prints:

        ab
        abc
        abc
        abcd

    when executed.

  * ([1, 2, 3] ~ [4, 5, 6])!
    ([a := 1, 2, 3] ~ [4, 5, 6])!
    ([a := 1, 2, 3] ~ [b := 4, 5, 6])!
    ([a := 1, 2, 3] ~ <<(0 --> 4), (1 --> 5), (2 --> 6)>>)!
    ([a := 1, 2, 3] ~ <<(* : [0...2] --> 4)>>)!

    is a statement list that prints:

        [1, 2, 3, 4, 5, 6]
        [a := 1, 2, 3, 4, 5, 6]
        [a := 1, 2, 3, b := 4, 5, 6]
        [a := 1, 2, 3, 4, 5, 6]
        [a := 1, 2, 3, 4, 4, 4]

    when executed.


    Section 5.1.24: Arguments Expressions
    -------------------------------------

    <arguments-expression> :
        "arguments" { "of" <identifier> }?

An arguments expression gives all the actual arguments to a routine.
It is used when there are a variable number of arguments.  The result
of evaluating an arguments expression is the full arguments value for
an enclosing routine.  The full arguments value was determined as part
of the call start process (see Section 5.1.20).

If the ``of'' section is omitted, this expression gives the arguments
of the nearest enclosing routine, or the command-line arguments to the
progam, when used at the top level.  If the optional ``of'' syntax is
used, the name of the routine whose actual arguments are to be
obtained is specified.  It must be the name of a routine whose scope
encloses the expression.  This can be used within nested routines to
get the arguments of outer routines.

When used at the top level, the semi-labeled value list returned will
have no labels and will consist of all string values, where the
strings are those used on the command line that invoked the program.

EXAMPLES:

  * procedure p1(...)  { arguments! };
    p1();
    p1(13, "purple");
    p1(a := 13, "purple");

    is a statement list that prints:

        []
        [13, "purple"]
        [a := 13, "purple"]

    when executed.

  * procedure p1(...)
      {
        procedure p2(...)  { arguments of p1! arguments of p2! };
        p2("gold");
      };
    p1(a := 13, "purple");

    is a statement list that prints:

        [a := 13, "purple"]
        ["gold"]

    when executed.


    Section 5.1.25: This Expressions
    --------------------------------

    <this-expression> :
        "this" { "of" <identifier> }?

A ``this'' expression gives access to an enclosing object.  It is only
legal from within a class declaration.  Without the optional ``of''
syntax, it refers to the nearest enclosing class.  With the optional
``of'' syntax, the identifier specified must match the name of an
enclosing class declaration and the expression refers to the nearest
such enclosing class declaration with a matching name.

The ``this'' expression returns a values which is an object value
referring to the object that is the instance of the specified class in
which the expression is running.

EXAMPLES:

  * class c1(xx)
      {
        immutable x := xx;
        this.x!
      };
    [] := [c1(12)];
    [] := [c1("swallow")];

    is a statement list that prints:

        12
        swallow

    when executed.

  * class c1(xx)
      {
        immutable x := xx;
        class c2(yy)
          {
            immutable x := yy;
            this of c1.x!
            this of c2.x!
          };
        [] := [c2(xx + 12)];
      };
    [] := [c1(50)];

    is a statement list that prints:

        50
        62

    when executed.


    Section 5.1.26: In Expressions
    ------------------------------

    <in-expression> :
        <expression> "in" <type-expression>

An ``in'' expression tests whether or not a given value is in a given
type.

To evaluate an in expression, first the expression is evaluated to
give the test value and then the type expression is evaluated to give
the type.  Then, if the type is not valid, an exception occurs.  After
that, the value is tested to see whether it's in the type.  If it is,
the result of evaluating the in expression is true, and otherwise the
result of evaluating the in expression is false.

EXAMPLE:

  * 5 in integer!
    5.5 in integer!

    is a statement list that prints:

        true
        false

    when executed.


    Section 5.1.27: Force Expressions
    ---------------------------------

    <force-expression> :
        <expression> "::" <type-expression>

A force expression forces a value into a given type.  If the value is
already in that type, the result is that value.  If the value is not
in the type, the behavior varies.  Some values cannot be forced into
some types, and when such a combination occurs while evaluating a
force expression, an exception occurs.

Evaluating a force expression starts with evaluating the expression,
then proceeds with evaluating the type expression.  Then results from
both are checked for validity -- if either the value or the type is
invalid, an exception occurs.  The value is called the base value and
the type is called the target type.

Next, a check is done for overloading, and if an overloading match is
found, overloading is used instead of a normal type forcing
operation.  The first step in checking for overloading is to see if
the name "operator::" resolves at this point in the code.  If so,
"operator::" is evaluated as a name reference expression.  The value
returned from the evaluation of "operator::" is the overload base
value.  If the overload base value is invalid, an exception occurs.
Otherwise, if the overload base value is a routine value, an attempt
is made to find a call match.  The argument list for the call match is
exactly two items, both unnamed.  The first item is the base value.
The second is a type value whose type is the target type.  If there is
a match, the matched routine is called and the return value is the
result of evaluating the force expression and the evaluation is done.
Otherwise, evaluation continues with the next step of overloading
checking.

The next step of overloading checking is to see if the base value has
a field with the name "operator::" -- that is, if applying
".operator::" to the value would produce a value.  If so, that value
is the field base value.  If the field base value is invalid, an
exception occurs.  Otherwise, if the field base value is a routine
value, an attempt is made to find a call match.  The argument list for
the call match is a single unnamed item whose value is a type value
whose type is the target type.  If there is a match, the matched
routine is called and the return value is the result of evaluating the
call expression and the evaluation is done.  Otherwise, there is no
overloading and evaluation continues as a normal type forcing
operation.

Next, a check is made to determine whether the base value is in the
target type.  If it is, then the operation is complete and the result
of evaluating the force expression is the base value.

Otherwise, the following cases are checked for, in this order, and if
they apply, the following rules apply:

  * If the base value is a non-integer rational value and the target
    type is the type of all integers, then the result is the next
    integer value closer to zero.

  * If the base value is a rational value and the target type is an
    integer range type with both bounds finite, then the following
    process is used.  First, if the rational value is not an integer,
    the preceeding rule is used to force it to an integer.  Then, the
    integer value has the lower bound of the range subtracted from it.
    Then a modulo operation is performed on this integer with
    denominator the upper bound of the range minus the lower bound of
    the range plus one.  The result of this modulo operation is added
    to the lower bound to produce the result.  In other words for an
    integer x,

        x :: [a...b]

    is equivalent to

        mod((x - a), ((b - a) + 1)) + a

    where mod(c, d) gives the non-negative modulo of c by d.

  * If the base value is a rational value and the target type is a
    rational range with both bounds finite and one bound inclusive and
    the other bound exclusive, then the following process is used.
    First, the rational value has the lower bound of the range
    subtracted from it.  Then the value is divided by the upper bound
    of the range minus the lower bound of the range.  Then the floor
    of this value is subtracted from this value to get a fractional
    part in the range [0....1).  If this value is zero and the lower
    bound is exclusive, then this value is changed to one.  This is
    multiplied by the upper bound minus the lower bound.  Finally, the
    lower bound is added to produce the final result.  In other words,
    for a rational x,

        x :: [a....b)

    is equivalent to

        (((x - a) / (a - b)) - floor((x - a) / (a - b))) * (a - b) + a

    and x :: (a....b]

    is equivalent to -((-x) :: [-b....-a))

  * If the target type is an array type and the base value is a map or
    semi-labeled value list value, then the base value is converted to
    a map (if it's a semi-labeled value list, the labels are dropped
    and it becomes a map whose keys are the integers from zero to one
    minus the number of elements where each key targets the value
    indexed by that key in the semi-labeled value list).  Then, any
    keys that aren't in the range of keys allowed by the array type
    for an index are dropped.  For each remaining key, if the target
    value is in the element type of the array, it is retained
    unchanged.  Otherwise, an attempt is made to force it to the
    element type using the normal type forcing operation recursively
    (no overloading).  If the target can't be forced into the type,
    the key, target pair for that target is dropped.  The resulting
    map is the result of the forcing operation.

  * If the target type is an array, an attempt is made to use the type
    forcing operation recursively (no overloading) on the base value
    and the element type of the array.  If that doesn't produce a
    value, this rule doesn't apply.  If it does produce a value, then
    the result is a new map value with a filter key of type equal to
    the range of allowed keys for the array type and target value of
    the result of applying the forcing operation recursively.

  * If the target type is a map type and the base value is a map or
    semi-labeled value list value, then the base value is converted to
    a map (if it's a semi-labeled value list, the labels are dropped
    and it becomes a map whose keys are the integers from zero to one
    minus the number of elements where each key targets the value
    indexed by that key in the semi-labeled value list).  Then, any
    keys that aren't in the key type of target type are dropped.  For
    each remaining key, if the target value is in the target type of
    the target map type, it is retained unchanged.  Otherwise, an
    attempt is made to force it to the target type of the target map
    type using the normal type forcing operation recursively (no
    overloading).  If the target can't be forced into the type, the
    key, target pair for that target is dropped.  The resulting map is
    the result of the forcing operation.

  * If the target type is a map type, an attempt is made to use the
    type forcing operation recursively (no overloading) on the base
    value and the target type of the map.  If that doesn't produce a
    value, this rule doesn't apply.  If it does produce a value, then
    the result is a new map value with a filter key of type equal to
    the key type of the target map type and target value of the result
    of applying the forcing operation recursively.

  * If the target type is a fields type and the base value is a
    semi-labeled value list, semi-labeled multi-set, lepton, or object
    value, the following rules apply.  First of all, if the base value
    is a class, it becomes a semi-labeled multi-set with a field for
    each exported name from the object, where each of those fields has
    its name as the export name from the object and as value the value
    of that field in the object -- reading from the immutable or
    variable if it's an immutable or variable instance being exported
    or getting a routine, quark, tagalong key, lepton key, or lock
    value respectively if the exported instance is a routine, quark,
    tagalong key, lepton key, or lock instance.  Next, if the target
    type doesn't allow additional fields beyond those explicitly
    specified, all unnamed fields of the base value and all fields
    with names not specified by the target type are removed.  After
    that, for fields with names that are specified in the target type,
    the values of those fields in the base value are, if present,
    recursively run through the forcing operation with the type
    specified by the field type of the target type.  For any such
    recursive calls that fail to return a value, the corresponding
    field is removed.  For those where the recursive call succeeds,
    the corresponding field has its value changed to the result of the
    recursive call.  Note that if the base value was originally a
    semi-labeled value list and any of its fields were removed, it
    becomes a semi-labeled multi-set (i.e. the ordering information
    goes away and it becomes an un-ordered list of items).  Next, if
    any of the fields required by the target type are not present in
    the new base value, the operation fails and this rule doesn't
    apply.  Otherwise, this rule applies and the final result of the
    forcing operation is the resulting base value.

  * If the target type is an interface type and the base value is a
    semi-labeled value list, semi-labeled multi-set, lepton, or object
    value, the previous rule applies.

  * If the target type is a lepton type and the base value is a
    semi-labeled value list, semi-labeled multi-set, lepton, or object
    value, the following rules apply.  First of all, the base value is
    converted into a lepton with the same key as the target lepton
    type.  If the base value is a class, it becomes a lepton with a
    field for each exported name from the object, where each of those
    fields has its name as the export name from the object and as
    value the value of that field in the object -- reading from the
    immutable or variable if it's an immutable or variable instance
    being exported or getting a routine, quark, tagalong key, lepton
    key, or lock value respectively if the exported instance is a
    routine, quark, tagalong key, lepton key, or lock instance.  If
    the base value was already a lepton, the key is just changed to
    match the target lepton type's key.  If the base value was a
    semi-labeled value list or semi-labeled multi-set, all the fields
    remain but it becomes a lepton value with the target lepton type's
    key.  Since unnamed fields aren't allowed for leptons, all unnamed
    fields are removed.  Next, if the target type doesn't allow
    additional fields beyond those explicitly specified, all fields
    with names not specified by the target type are removed.  After
    that, for fields with names that are specified in the target type,
    the values of those fields in the base value are, if present,
    recursively run through the forcing operation with the type
    specified by the field type of the target type.  For any such
    recursive calls that fail to return a value, the corresponding
    field is removed.  For those where the recursive call succeeds,
    the corresponding field has its value changed to the result of the
    recursive call.  Next, the final result of the forcing operation
    is the resulting base value.

  * If the target type is a lepton type and the base value is a
    semi-labeled value list, semi-labeled multi-set, lepton, or object
    value, the previous rule applies except that instead of the base
    value being converted to a lepton value it is converted to a
    semi-labeled multi-set and its unnamed fields are only removed if
    the target type doesn't allow fields beyond those explicitly
    named.

  * If the target type is a semi-labeled value list type and the base
    value is a map, semi-labeled value list, semi-labeled multi-set,
    lepton, or object value, the following rule applies.  First a
    result semi-labeled value list is created.  Then, each explicitly
    listed component of the target type is handled, with each adding a
    component to the result, or failing to, causing this rule to
    fail.  The label or lack thereof on each element of the result
    comes from the label or lack thereof on the corresponding
    component of the target type.  The value for each element is
    determined as follows.  If the base value is a semi-labeled value
    list and the index of the element is less than the number of
    elements in the base value, the corresponding element of the base
    value is used.  Otherwise, if the base value is a map value, the
    index of the element is used as a key to do a lookup in the map
    value and if there is a target value for that key, that is the
    value used for the element value.  Otherwise, if the target type
    specifies a name for this element and the base value is not a map
    and has a field by that name, that field value is used as the
    element value.  If none of these rules yields an element value,
    this rule fails.  Then the element value and the component type of
    the target type corresponding to this element are used in a
    recursive use of this forcing operation to yield a value that is
    in the appropriate type.  If the forcing operation fails to
    produce a value, this rule fails.  If the value is produced, it
    goes into the appropriate position in the result value.  After
    that has been done for all the elements, if the target type allows
    additional fields and the base value is a map, additional unnamed
    elements are added to the result value as long as the map has a
    target for the index of the new elements.  If the target type
    allows additional fields and the base value is semi-labeled value
    list with more elements than specified by the target type, then
    the elements beyond the number in the target type are appended to
    the end of the result value, with the same names and values as in
    the base value.  Then, the result value is the result of the
    forcing operation.

  * If the target type is a class type, then a check is made to see if the
    class can be called with a single unnamed argument whose value is the base
    value.  If so, then the class is called with the base value as the only
    argument, and with that argument unnamed.  The result value is the object
    value created by the call.

If none of these cases applies, an exception occurs.

EXAMPLES:

  * 15.5 :: integer!

    is a statement list that prints:

        15

    when executed.

  * -15.5 :: integer!

    is a statement list that prints:

        -15

    when executed.

  * 5 :: [0...4]!
    6 :: [0...4]!
    6.5 :: [0...4]!
    -1 :: [0...4]!
    5 :: [2...4]!
    6 :: [2...4]!
    6.5 :: [2...4]!
    -1 :: [2...4]!

    is a statement list that prints:

        0
        1
        1
        4
        2
        3
        3
        2

    when executed.

  * <<(* --> "blue")>> :: string[5]!
    <<(1 --> "blue"), (2 --> "red"), ("pole" --> "white")>> :: string[5]!
    (["a", 5, "b", "c", "d", "e"] :: string[5])!

    is a statement list that prints:

        <<(*: [0...4] --> "blue")>>
        <<(1 --> "blue"), (2 --> "red")>>
        <<(0 --> "a"), (2 --> "b"), (3 --> "c"), (4 --> "d")>>

    when executed.

  * "green" :: string[5]!

    is a statement list that prints:

        <<(*: [0...4] --> "green")>>

    when executed.

  * <<(* --> "blue")>> :: integer --> string!
    <<(1 --> "blue"), (2 --> "red"),
      ("pole" --> "white")>> :: integer --> string!
    (["a", 5, "b", "c", "d", "e"] :: {1, 2, 4} --> string)!

    is a statement list that prints:

        <<(*: integer --> "blue")>>
        <<(1 --> "blue"), (2 --> "red")>>
        <<(2 --> "b"), (4 --> "d")>>

    when executed.

  * 9 :: integer --> [0...5]!

    is a statement list that prints:

        <<(*: integer --> 3)>>

    when executed.

  * (<<(5 --> [a := 9])>> :: {5} --> fields[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello"])>> ::
     {5} --> fields[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := 17])>> :: {5} --> fields[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello", c := 17])>> ::
     {5} --> fields[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello", c := 17])>> ::
     {5} --> fields[a : [0...5], b : string, ...])!

    is a statement list that prints:

        <<>>
        <<(5 --> [a := 3, b := "hello"])>>
        <<>>
        <<(5 --> [a := 3, b := "hello"])>>
        <<(5 --> [a := 3, b := "hello", c := 17])>>

    when executed.

  * (<<(5 --> [a := 9])>> :: {5} --> interface[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello"])>> ::
     {5} --> interface[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := 17])>> ::
     {5} --> interface[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello", c := 17])>> ::
     {5} --> interface[a : [0...5], b : string])!

    is a statement list that prints:

        <<>>
        <<(5 --> [a := 3, b := "hello"])>>
        <<>>
        <<(5 --> [a := 3, b := "hello", c := 17])>>

    when executed.

  * lepton l1;
    (<<(5 --> [a := 9])>> :: {5} --> lepton l1[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello"])>> ::
     {5} --> lepton l1[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := 17])>> ::
     {5} --> lepton l1[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello", c := 17])>> ::
     {5} --> lepton l1[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello", c := 17])>> ::
     {5} --> lepton l1[a : [0...5], b : string, ...])!

    is a statement list that prints:

        <<(5 --> l1[a := 3])>>
        <<(5 --> l1[a := 3, b := "hello"])>>
        <<(5 --> l1[a := 3])>>
        <<(5 --> l1[a := 3, b := "hello"])>>
        <<(5 --> l1[a := 3, b := "hello", c := 17])>>

    when executed.

  * (<<(5 --> [a := 9])>> :: {5} --> multiset[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello"])>> ::
     {5} --> multiset[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := 17])>> ::
     {5} --> multiset[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello", c := 17])>> ::
     {5} --> multiset[a : [0...5], b : string])!
    (<<(5 --> [a := 9, b := "hello", c := 17])>> ::
     {5} --> multiset[a : [0...5], b : string, ...])!

    is a statement list that prints:

        <<(5 --> [a := 3])>>
        <<(5 --> [a := 3, b := "hello"])>>
        <<(5 --> [a := 3])>>
        <<(5 --> [a := 3, b := "hello"])>>
        <<(5 --> [a := 3, b := "hello", c := 17])>>

    when executed.

  * ([1, 2, 3] :: [integer, integer])!
    ([1, 2, c := 3] :: [integer, integer])!
    ([11, 2, 3] :: [[0...9], integer, ...])!
    ([11, 2, c := 3] :: [[0...9], integer, ...])!
    ([11, 2, 3] :: [[0...9], integer, integer])!
    ([11, b := 2, 3] :: [[0...9], integer, integer])!
    ([11, 2, 3] :: [[0...9], b : integer, integer])!
    <<(* --> 11)>> :: [[0...9], b : integer, integer]!
    ([11, b := 2, 3] :: [[0...9], integer, integer, b : integer])!
    lepton l1;
    l1[a := 1, b := 2, c := 3] :: [b : integer, c : integer]!

    is a statement list that prints:

        [1, 2]
        [1, 2]
        [1, 2, 3]
        [1, 2, c := 3]
        [1, 2, 3]
        [1, 2, 3]
        [1, b := 2, 3]
        [1, b := 11, 11]
        [1, 2, 3, b := 2]
        [b := 2, c := 3]

    when executed.

  * immutable i1 := [operator:: := function(...) (arguments)];
    i1 :: integer!

    is a statement list that prints:

        [type integer]

    when executed.

  * function operator::(...) (arguments);
    15.5 :: integer!

    is a statement list that prints:

        [31/2, type integer]

    when executed.


    Section 5.1.28: Break Expressions
    ---------------------------------

    <break-expression> :
        "break" { "from" <identifier> }?

A break expression returns a jump target that breaks out of the loop
it refers to.

The break expression must be within the body of a for, iterate, while,
or do-while statement or within the body or test expression of a
comprehend expression.  If the "from" clause is not used, the loop
this expression refers to is the nearest enclosing for, iterate,
while, or do-while statement or comprehend expression.  If the "from"
clause is used, the identifier from that clause specifies the loop.
In that case, the referenced loop is the nearest enclosing loop
statement that has a matching name, where a loop has a given name if
and only if there is a label statement with that name immediately
before it or with only other label statements in between.  There is a
binding-time error if no matching enclosing loop is found.  Note that
comprehend expressions never have names.

EXAMPLES:

  * variable result := "";
    for (i; 0; i < 10)
        result ~= sprint(i);;
    result!

    result := "";
    for (i; 0; i < 10)
      {
        if (i == 5)
            goto break;;
        result ~= sprint(i);
      };
    result!

    is a statement list that prints:

        0123456789
        01234

    when executed.

  * variable result := "";
    procedure p1(i, target)
      {
        if (i == 7)
            goto target;;
      };
    for (i; 0; i < 10)
      {
        p1(i, break);
        result ~= sprint(i);
      };
    result!

    is a statement list that prints:

        0123456

    when executed.

  * variable result := "";
  outer:
    for (i; 0; i < 4)
      {
        for (j; 0; j < 4)
          {
            if ((i == 1) && (j == 2))
                goto break from outer;;
            result ~= sprint([i, j]);
          };
      };
    result!

    is a statement list that prints:

        [0, 0][0, 1][0, 2][0, 3][1, 0][1, 1]

    when executed.

  * variable result := "";
    iterate (x; ["a", "b", "c", "d"])
      { result ~= x; };
    result!

    result := "";
    iterate (x; ["a", "b", "c", "d"])
      {
        if (x == "c")
            goto break;;
        result ~= x;
      };
    result!

    is a statement list that prints:

        abcd
        ab

    when executed.

  * variable result := "";
    variable i := 0;
    while (i < 10)
      { result ~= sprint(i); }
    step
      { ++i; };
    result!

    result := "";
    i := 0;
    while (i < 10)
      {
        if (i == 5)
            goto break;;
        result ~= sprint(i);
      }
    step
      { ++i; };
    result!

    is a statement list that prints:

        0123456789
        01234

    when executed.

  * variable result := "";
    variable i := 0;
    do
      { result ~= sprint(i); }
    while (i < 10)
    step
      { ++i; };
    result!

    result := "";
    i := 0;
    do
      {
        if (i == 5)
            goto break;;
        result ~= sprint(i);
      }
    while (i < 10)
    step
      { ++i; };
    result!

    is a statement list that prints:

        0123456789
        01234

    when executed.


    Section 5.1.29: Continue Expressions
    ------------------------------------

    <continue-expression> :
        "continue" { "with" <identifier> }?

A continue expression returns a jump target that ends the current
iteration of the loop it refers to.

The continue expression must be within the body of a for, iterate, while,
or do-while statement or within the body or test expression of a
comprehend expression.  If the "with" clause is not used, the loop
this expression refers to is the nearest enclosing for, iterate,
while, or do-while statement or comprehend expression.  If the "with"
clause is used, the identifier from that clause specifies the loop.
In that case, the referenced loop is the nearest enclosing loop
statement that has a matching name, where a loop has a given name if
and only if there is a label statement with that name immediately
before it or with only other label statements in between.  There is a
binding-time error if no matching enclosing loop is found.  Note that
comprehend expressions never have names.

EXAMPLES:

  * variable result := "";
    for (i; 0; i < 10)
        result ~= sprint(i);;
    result!

    result := "";
    for (i; 0; i < 10)
      {
        if (i == 5)
            goto continue;;
        result ~= sprint(i);
      };
    result!

    is a statement list that prints:

        0123456789
        012346789

    when executed.

  * variable result := "";
    procedure p1(i, target)
      {
        if (i == 7)
            goto target;;
      };
    for (i; 0; i < 10)
      {
        p1(i, continue);
        result ~= sprint(i);
      };
    result!

    is a statement list that prints:

        012345689

    when executed.

  * variable result := "";
  outer:
    for (i; 0; i < 4)
      {
        for (j; 0; j < 4)
          {
            if (j == 2)
                goto continue with outer;;
            result ~= sprint([i, j]);
          };
      };
    result!

    is a statement list that prints:

        [0, 0][0, 1][1, 0][1, 1][2, 0][2, 1][3, 0][3, 1]

    when executed.

  * variable result := "";
    iterate (x; ["a", "b", "c", "d"])
      { result ~= x; };
    result!

    result := "";
    iterate (x; ["a", "b", "c", "d"])
      {
        if (x == "c")
            goto continue;;
        result ~= x;
      };
    result!

    is a statement list that prints:

        abcd
        abd

    when executed.

  * variable result := "";
    variable i := 0;
    while (i < 10)
      { result ~= sprint(i); }
    step
      { ++i; };
    result!

    result := "";
    i := 0;
    while (i < 10)
      {
        if (i == 5)
            goto continue;;
        result ~= sprint(i);
      }
    step
      { ++i; };
    result!

    is a statement list that prints:

        0123456789
        012346789

    when executed.

  * variable result := "";
    variable i := 0;
    do
      { result ~= sprint(i); }
    while (i < 10)
    step
      { ++i; };
    result!

    result := "";
    i := 0;
    do
      {
        if (i == 5)
            goto continue;;
        result ~= sprint(i);
      }
    while (i < 10)
    step
      { ++i; };
    result!

    is a statement list that prints:

        0123456789
        012346789

    when executed.


    Section 5.1.30: Comprehend Expressions
    --------------------------------------

    <comprehend-expression> :
        "comprehend" "(" <identifier> ";" <expression>
                { ";" <expression> }? ")" <expression>

A comprehend expression is used to do a list comprehension.  The
identifier specifies its element name, the first expression is the
base expression, the optional second expression is the test
expression, and the final expression is the body expression.  The base
expression specifies a list of elements and the result is another list
of elements produced by evaluating the body on each element of the
base, with those elements the test expression returns false for being
omitted.

Evaluating a comprehend expression starts with evaluating its base
expression.  The value this produces is the base value.  The base
value must be valid except for map value target values and
semi-labeled value list component values, otherwise, an exception
occurs.

What happens next is one of two things, Process A or Process B,
depending on the base value.  If the base value is a semi-labeled
value list or map, Process A is used.  Otherwise, if the base value
has a field named "iterator" that is a routine that can be called with
no arguments, Process B is used.  If the base value doesn't fit either
of those categories, an exception occurs.

Process A starts by creating a value called the result value.  This is
a semi-labeled value list value that starts out empty and has unnamed
elements added to it during the process.  When Process A finishes, the
result value is the result of evaluating the comprehend expression.

Next, a three-step process is repeated until something causes it to
stop.  In the first of these three steps, an immutable instance called
the element immutable is allocated and instantiated.  The name of the
element immutable is the element name.  Its type is the type of all
values.  Its initial value depends on the base value.

If the base value is a semi-labeled value list, then the three-step
process is repeated once for each element of the semi-labeled value
list.  On each iteration, the initial value of the element immutable
is one of the component values of the semi-labeled value list.  The
values are used in the order they appear in the semi-labeled value
list.  When there are no more values, the evaluation of the comprehend
expression is complete and the result value is returned.

If the base value is a map, then all the keys of the map must be
finite integers or an exception occurs.  Evaluation starts with the
lowest integer key in the map and finishes after the highester integer
key in the map has been used.  After each iteration the key is
incremented.  For each iteration, the initial value of the element
immutable is the target for that key.  If any keys between the highest
and lowest in the map are not associated with target values, an
exception occurs.

The element immutable is visible and can be bound from within the
body and test expressions, but not from within the base expression.
The element immutable is de-allocated after the evaluation of the body
for each iteration.

Next, the second step of the repeating process happens.  This second
step starts with evaluating the test expression to give the test
value.  From within the test expression, break and continue
expressions and statements can be bound to this comprehend expression
and can cause control to jump to the break or continue target of this
instance of the comprehend expression.  If control jumps to the break
target, the evaluation of the comprehend expression is complete and
the result value is returned.  If control jumps to the continue
target, the second step is complete and evaluation of the comprehend
expression continues with the first step.  If the test expression
isn't provided, the test value is always true.  Then, if the test
value is false, the second step is complete.  If the test value is
true, then the body expression is evaluated to give the body value.
The body value is then appended as a new, unnamed element to the
result value.  If the test value is neither true nor false, an
exception occurs.

After that, the process goes back to the first step and continues.
This completes Process A.

In Process B, the result is an iteratable object that is returned
immediately.  By iteratable object, we mean an object that can be used
as the base of another comprehend expression or an iterate statement.
It will have a field named "iterator" that is a routine that can be
called with no arguments.  Calling this "iterator" routine returns
another new object.  This second object, called the result iterator
object, will have three fields, named "is_done", "current", and
"step", each of which will have as a value a routine that can be
called with no arguments.  The "iterator" routine of the first object
will call the "iterator" routine of the base object.  The result is
called the base iterator.  A refrerence to this base iterator will be
kept by the result iterator object until it is done.  The result
iterator object will also keep two more pieces of state: an internal
flag indicating whether or not it's done and a current item value.
Initially, when the result iterator object is created by the call to
"iterator", the done flag is set to false, the current item value is
uninitialized, and then the "step" method of this result iterator
object is called.

Calling the "is_done" routine of the result iterator object always
simply returns the done flag.

Calling the "current" routine of the result iterator object first
causes the value of the done flag to be checked.  If it is true, an
exception occurs.  Otherwise, the current item value is returned.

Calling the "step" routine of the result iterator object first causes
the value of the done flag to be checked.  If it is true, an exception
occurs.  Then, an attempt is made to read a field from the base
iterator called "is_done".  That field must have as a value a routine
that can be called with no arguments, or else an exception occurs.
That routine value is then called.  The resulting value must be either
true or false or else an exception occurs.  If it is true, then the
value of the done flag is set to true, the value of the current item
value is made undefined (and the reference to it is removed, possibly
causing it to be de-allocated), and the "step" routine returns.
Otherwise, an attempt is made to read a field from the base iterator
value called "current".  That field must have as a value a routine
that can be called with no arguments, or else an exception occurs.
That routine is then called.  If it doesn't return a value, an
exception occurs.  The current item value is then set to the result of
the call to "current" on the base iterator.  Finally, an attempt is
made to read a field from the base iterator value called "step".  That
field must have as a value a routine that can be called with no
arguments, or else an exception occurs.  That routine is then called.
If it returns a value, an exception occurs.  Then, the "step" routine
returns.

This completes the description of Process B.

EXAMPLE:

  * immutable through_ten := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    comprehend(x; through_ten) (x * x)!
    comprehend(x; through_ten; x % 3 == 0) (x * x)!
    comprehend(x; through_ten; x % 2 == 0)
      {
        if (x == 4)
            continue;;
        if (x == 8)
            break;;
        return x * x;
      }!

    is a statement list that prints:

        [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
        [0, 9, 36, 81]
        [0, 4, 36]

    when executed.


    Section 5.1.31: Backtick Expressions
    ------------------------------------

    <backtick-expression> :
        <backtick-expression-literal-token>

@@@


    Section 5.1.32: Forall Expressions
    ----------------------------------

    <forall-expression> :
        "forall" "(" <formal-argument-list> ")" <expression>

A forall expression is one that evaluates to true if and only if every
legal assignment of values to a list of formal arguments results in
the body expression evaluating to true.  Otherwise, it evaluates to
false.  It is equivalent to the mathematical upside-down ``A'' symbol.

Note that forall expressions are intended primarily for theorems and
proofs -- they are not intended to actually be evaluated.  Determining
whether a given forall expression would evaluate to true is in general
undecidable.  So trying to evaluate a forall expression results in an
exception, unless the implementation happens to be able to figure out
whether the expression is true or false.  While the implementation is
allowed to return a true or false value when an attempt is made to
evaluate a forall expression, it may also choose to throw an exception
every time such an attempt is made.


    Section 5.1.33: Exists Expressions
    ----------------------------------

    <exists-expression> :
        "exists" "(" <formal-argument-list> ")" <expression>

An ``exists'' expression is one that evaluates to true if and only if
there exists a legal assignment of values to a list of formal
arguments which results in the body expression evaluating to true.
Otherwise, it evaluates to false.  It is equivalent to the
mathematical backwards ``E'' symbol.

Note that ``exists'' expressions are intended primarily for theorems
and proofs -- they are not intended to actually be evaluated.
Determining whether a given ``exists'' expression would evaluate to
true is in general undecidable.  So trying to evaluate an ``exists''
expression results in an exception, unless the implementation happens
to be able to figure out whether the expression is true or false.
While the implementation is allowed to return a true or false value
when an attempt is made to evaluate an ``exists'' expression, it may
also choose to throw an exception every time such an attempt is made.


    Section 5.2: Statements
    -----------------------

    <statement> :
        <non-block-non-if-statement> |
        <statement-block-statement> |
        <if-statement>

    <non-block-non-if-statement> :
        <assign-statement> |
        <increment-statement> |
        <decrement-statement> |
        <call-statement> |
        <variable-declaration-statement> |
        <routine-declaration-statement> |
        <tagalong-declaration-statement> |
        <lepton-declaration-statement> |
        <quark-declaration-statement> |
        <lock-declaration-statement> |
        <switch-statement> |
        <goto-statement> |
        <return-statement> |
        <for-statement> |
        <iterate-statement> |
        <while-statement> |
        <do-while-statement> |
        <break-statement> |
        <continue-statement> |
        <label-statement> |
        <single-statement> |
        <try-catch-statement> |
        <try-handle-statement> |
        <cleanup-statement> |
        <export-statement> |
        <hide-statement> |
        <use-statement> |
        <include-statement> |
        <quark-enumeration-statement> |
        <theorem-statement> |
        <alias-statement> |
        <print-line-statement> |
        <backtick-statement>

A statement is a piece of Salmon code that can be executed to produce
side effects.  Unlike an expression, executing a statement does not
produce a side effect.

To aid readability as well as parsing by tools, the grammar for
statement has some additional constraints beyond those specified by
the BNF:

  * Only declaration statements (variable declaration, routine
    declaration, tagalong declaration, lepton declaration, quark
    declaration, lock declaration, and quark enumeration statements)
    are allowed to start with any of the identifier tokens "routine",
    "function", "procedure", "class", "variable", "immutable",
    "tagalong", "lepton", "quark", "lock", "static", "ageless",
    "virtual", or "pure".

  * Only single statements and declaration statements are allowed to
    start with the identifier token "single".

  * Only cleanup statements are allowed to start with the identifier
    token "cleanup".

  * Only if statements are allowed to start with the identifier token
    "if".

  * Only switch statements are allowed to start with the identifier
    token "switch".

  * Only goto statements are allowed to start with the identifier
    token "goto".

  * Only return statements are allowed to start with the identifier
    token "return".

  * Only for and iterate statements are allowed to start with the
    identifier token "parallel".

  * Only for statements are allowed to start with the identifier token
    "for".

  * Only iterate statements are allowed to start with the identifier
    token "iterate".

  * Only while statements are allowed to start with the identifier
    token "while".

  * Only do-while statements are allowed to start with the identifier
    token "do".

  * Only break statements are allowed to start with the identifier
    token "break".

  * Only continue statements are allowed to start with the identifier
    token "continue".

  * Only try-catch and try-handle statements are allowed to start with
    the identifier token "try".

  * Only export statements are allowed to start with the identifier
    token "export".

  * Only hide statements are allowed to start with the identifier
    token "hide".

  * Only use statements are allowed to start with the identifier token
    "use".

  * Only include statements are allowed to start with the identifier
    token "include".

  * Only theorem statements are allowed to start with the identifier
    token "theorem".

  * Only alias statements are allowed to start with the identifier
    token "alias".

  * Only assign statements are allowed to start with the punctuation
    token "[".  Call and printline statements that this rule outlaws
    which would otherwise be legal can be modified by adding
    parentheses to avoid having "[" as the first token of the
    statement.

  * Only statement block statements are allowed to start with the
    punctuation token "{".  Call and printline statements that this
    rule outlaws which would otherwise be legal can be modified by
    adding parentheses to avoid having "{" as the first token of the
    statement.


    Section 5.2.1: Assign Statements
    --------------------------------

    <assign-statement> :
        <basket> <assign-operator> <expression> ";"

    <basket> :
        <expression> |
        "[" <basket-item-list> "]"

    <basket-item-list> :
        <empty> |
        <non-empty-basket-item-list>

    <non-empty-basket-item-list> :
        <basket-item> |
        <basket-item> "," <non-empty-basket-item-list>

    <basket-item> :
        { <basket> }? { { ":=" | "::=" } <identifier> }?

    <assign-operator> :
        ":=" |
        "::=" |
        "*=" |
        "/=" |
        "/::=" |
        "%=" |
        "+=" |
        "-=" |
        "<<=" |
        ">>=" |
        "&=" |
        "^=" |
        "|=" |
        "&&=" |
        "||=" |
        "~="

An assign statement is used to evaluate an expression and use the
resulting value to update zero or more values stored in variables.

If the <assign-operator> is ":=", the assignment is a simple
assignment, and otherwise it is a non-simple assignment.

The basket determines what is to be done with the resulting value.  If
the basket is an expression, that expression must be addressable, as
defined in Section 5.1.22.2.  A basket that is addressable is a simple
basket.  A basket that starts with the "[" token is a compound basket.
Note that since semi-labeled expression list expression are not
addressable, there is no ambiguity between compound and simple
baskets.

Executing an assign statement starts by evaluating its basket.
Evaluating a simple basket consists of evaluating the address of its
expression, just as in the case of a location-of expression.  This
results in a slot location.  Evaluating a compound basket consists of
evaluating each of its components from left to right.  This produces a
basket instance.

Next, if the <assign-operator> is anything but ":=" or "::=", a read
operation is performed on the basket instance.  The read operation for
a simple basket instance consists of simply applying the read
operation for the slot location for that basket instance, as defined
in Section 5.1.22.2.  The resulting value from that read operation is
the result of the read operation on that simple basket instance.

The read operation for a compound basket instance results in a
semi-labeled value list with as many components as there are
components of the basket.  Each component of the semi-labeled value
list has a label if and only if the corresponding component of the
compound basket has an identifer following a ":=" or "::=" token, and
if it has a label, that label is the identifier following the ":=" or
"::=" token.  The value for each component of the semi-labeled value
list is the result of applying the read operation recursively on the
basket instances for the components of the compound basket instance,
in order from left to right.  If any component of the compound basket
instance doesn't have a component basket instance, an exception occurs
when trying to do the read operation.

The result of the read operation, if it is performed, on the basket
instance is a value called the left-hand side value.

The next step in executing an assign statement is to evaluate its
expression.  The resulting value is the right-hand side value.

Next, a value called the new value is produced.  How it is produced
depends on the <assign-operator>:

  * If the assign operator is ":=", the new value is simply the
    right-hand side value.

  * If the assign operator is "*=", "/=", "/::=", "%=", "+=", "-=",
    "<<=", ">>=", "&=", "^=", "|=", "&&=", "||=", or "~=", then the
    new value is generated as it would be for a binary expression with
    "*", "/", "/::", "%", "+", "-", "<<", ">>", "&", "^", "|", "&&",
    "||", or "~" respectively as the <binary-operator> with the
    left-hand and right-hand side values as operand values.  Note that
    this includes overloading -- for example, a function named
    "operator+" would affect "+=" assign statements as well as "+"
    binary expressions.

  * If the assign operator is "::=", then the new value is generated
    by applying the type forcing operation, as defined in Section
    5.1.26 to the right-hand side value and using as type the write
    type of the basket.  The write type of the basket instance is
    defined as the type of values that could currently be legally
    written through the basket instance.  If the type forcing
    operation fails, an exception occurs.

Finally, the new value is written to the basket instance.  The write
operation on a basket instance with a new value is defined recursively
as follows:

  * For a simple basket instance, the write operation on that basket
    instance consists of applying the write operation on the slot
    location for that basket instance, as defined in Section 5.1.22.2.

  * For a compound basket instance, the following process is applied.
    A next index integer is maintained and started with the value
    zero.  Then, the process walks through the components of the
    basket instance in order from left to right.  For each component,
    the following process applies:

      * If the component has a ":=" or "::=" followed by an
        identifier, then the identifier is taken as a field name and a
        field value for that name is extracted from the value being
        written as it would be with the "." operator.  If no such
        field value exists and ":=" is the token used by this
        component, an exception occurs.  If no such field exists and
        forcing is being done and the value being written is a
        semi-labeled value list, semi-labeled multi-set, lepton, map,
        or object value, an exception occurs.  Otherwise, if no such
        field exists the value being written itself is taken as the
        field value.  Then, if there is a component basket instance
        for this component and the token is "::=" or type forcing was
        implied by some outer operation, the type forcing operation as
        defined in Section 5.1.27 is applied to the field value and
        the write type of the component basket instance to yield the
        new field value.  Then, if there is a component basket
        instance for this component, the write operation is applied to
        the component basket instance and the field value.  Finally,
        the next index is updated.  If the value being written was a
        semi-labeled value list, the next index is the index of the
        component with the label that was used plus one.  Otherwise,
        the next index is simply incremented by one.

      * If the component does not have a ":=" or "::=" followed by an
        identifier, the following applies.  If the value being written
        is a map value, the next index is taken as a key value and
        looked up in the map value being written.  If there is a
        match, the match value is the new component value, otherwise
        an exception occurs.  If the value being written is a
        semi-labeled value list, then if the next index is less than
        the number of components in the value being written, the value
        of the component indexed by the next index is the new
        component value.  If the number of components is greater than
        or equal to the next index, an exception occurs.  If the value
        being written is a semi-labeled multi-set, lepton, or object
        value, an exception occurs.  If the value is not a map,
        semi-labeled value list, semi-labeled multi-set, lepton, or
        object value, then if forcing is being done the new component
        value is the value being written itself and if forcing is not
        being done then an exception occurs.  Then, if there is a
        component basket instance for this component and forcing is
        being done, the type forcing operation as defined in Section
        5.1.26 is applied to the new component value and the write
        type of the component basket instance to yield an updated new
        component value.  Then, if there is a component basket
        instance for this component, the write operation is applied to
        the component basket instance and the new component value.
        Finally, the next index is incremented by one.

Note that component values beyond those specified in a compound basket
instance and those correponding to components without a component
basket instance are simply dropped.  So a simple assignment with an
empty compound basket can be used to evaluate an expression and then
throw away the resulting value, to generate any side effects from the
evaluation of the expression.

Note also that [x, y] := [y, x]; is a statement that swaps the values
of x and y without a need for a temporary variable.

EXAMPLES:

  * variable x := 5;
    x!
    x := 17;
    x!

    is a statement list that prints:

        5
        17

    when executed.

  * variable x := 5;
    x!
    x += 17;
    x!

    is a statement list that prints:

        5
        22

    when executed.

  * variable x : [0...9] := 5;
    x!
    x ::= 17;
    x!

    is a statement list that prints:

        5
        7

    when executed.

  * variable x := 5, y := 6;
    x!
    y!
    [x, y] := [17, 18];
    x!
    y!

    is a statement list that prints:

        5
        6
        17
        18

    when executed.

  * variable x := 5, y := 6;
    x!
    y!
    [x, y] := [y, x];
    x!
    y!

    is a statement list that prints:

        5
        6
        6
        5

    when executed.

  * variable x := 5, y := 6;
    x!
    y!
    [x, y] := [a := 17, b := 18, c := 19];
    x!
    y!

    is a statement list that prints:

        5
        6
        17
        18

    when executed.

  * variable x := 5, y := 6;
    x!
    y!
    [x := b, y] := [a := 17, b := 18, c := 19];
    x!
    y!

    is a statement list that prints:

        5
        6
        18
        19

    when executed.

  * variable x := 5, y := 6;
    x!
    y!
    [x := b, y := a] := [a := 17, b := 18, c := 19];
    x!
    y!

    is a statement list that prints:

        5
        6
        18
        17

    when executed.

  * variable x := 5, y := 6;
    x!
    y!
    [:= b, y] := [a := 17, b := 18, c := 19];
    x!
    y!

    is a statement list that prints:

        5
        6
        5
        19

    when executed.

  * function f1(x)  { x! return x + 17; };
    [] := [f1(18)];

    is a statement list that prints:

        18

    when executed.

  * function operator+(...) (arguments);
    variable x := 5;
    x += 17;
    x!

    is a statement list that prints:

        [5, 17]

    when executed.


    Section 5.2.2: Increment Statements
    -----------------------------------

    <increment-statement> :
        "++" <basket> ";"

An increment statement adds one to a value.  It is shorthand for an
assign statement with the same basket, "+=" as the operator, and the
integer constant 1 as the right-hand side expression.

Note that this equivalence to an assign statement extends to
overloading -- a function named "operator+" will affect an increment
statement just as it would affect the equivalent assign statement with
the "+=" operator.

EXAMPLES:

  * variable x := 5;
    x!
    ++x;
    x!

    is a statement list that prints:

        5
        6

    when executed.

  * function operator+(...) (arguments);
    variable x := 5;
    x!
    ++x;
    x!

    is a statement list that prints:

        5
        [5, 1]

    when executed.


    Section 5.2.3: Decrement Statements
    -----------------------------------

    <decrement-statement> :
        "--" <basket> ";"

A decrement statement subtracts one from a value.  It is shorthand for
an assign statement with the same basket, "-=" as the operator, and
the integer constant 1 as the right-hand side expression.

Note that this equivalence to an assign statement extends to
overloading -- a function named "operator-" will affect an decrement
statement just as it would affect the equivalent assign statement with
the "-=" operator.

EXAMPLES:

  * variable x := 5;
    x!
    --x;
    x!

    is a statement list that prints:

        5
        4

    when executed.

  * function operator-(...) (arguments);
    variable x := 5;
    x!
    --x;
    x!

    is a statement list that prints:

        5
        [5, 1]

    when executed.


    Section 5.2.4: Call Statements
    ------------------------------

    <call-statement> :
        <call> ";"

A call statement is used to call a routine that does not return a
value.

Executing a call statement is the same as executing a call expression
with the same <call> exception that at the point where the call
returns no exception occurs if no value is returned and instead an
exception occurs if a value is returned.

EXAMPLE:

  * procedure p1(...) { arguments! };
    p1();
    p1(13);
    p1(13, 15);
    p1(13, b := 15);

    is a statement list that prints:

        []
        [13]
        [13, 15]
        [13, b := 15]

    when executed.


    Section 5.2.5: Variable Declaration Statements
    ----------------------------------------------

    <variable-declaration-statement> :
        <named-data-declaration> ";"

A variable declaration statement declares a variable or immutable in
the local scope.  Executing the variable declaration statement
consists of instantiating the variable or immutable instance for that
declaration if the declaration is non-static, or has no effect if the
declaration is static.  See Section 5.5.1 for details on the meaning
of executing a data declaration.


    Section 5.2.6: Routine Declaration Statements
    ---------------------------------------------

    <routine-declaration-statement> :
        <named-routine-declaration> ";"

A routine declaration statement declares a routine in the local
scope.  Executing the routine declaration statement consists of
instantiating the routine instance for that declaration if the
declaration is non-static, or has no effect if the declaration is
static.  See Section 5.5.2 for details on the meaning of executing a
routine declaration.


    Section 5.2.7: Tagalong Declaration Statements
    ----------------------------------------------

    <tagalong-declaration-statement> :
        <named-tagalong-declaration> ";"

A tagalong declaration statement declares a tagalong key in the local
scope.  Executing the tagalong declaration statement consists of
instantiating the tagalong key instance for that declaration if the
declaration is non-static, or has no effect if the declaration is
static.  See Section 5.5.3 for details on the meaning of executing a
tagalong declaration.


    Section 5.2.8: Lepton Declaration Statements
    --------------------------------------------

    <lepton-declaration-statement> :
        <named-lepton-declaration> ";"

A lepton declaration statement declares a lepton key in the local
scope.  Executing the lepton declaration statement consists of
instantiating the lepton key instance for that declaration if the
declaration is non-static, or has no effect if the declaration is
static.  See Section 5.5.4 for details on the meaning of executing a
lepton declaration.


    Section 5.2.9: Quark Declaration Statements
    -------------------------------------------

    <quark-declaration-statement> :
        <named-quark-declaration> ";"

A quark declaration statement declares a quark in the local scope.
Executing the quark declaration statement consists of instantiating
the quark instance for that declaration if the declaration is
non-static, or has no effect if the declaration is static.  See
Section 5.5.5 for details on the meaning of executing a quark
declaration.


    Section 5.2.10: Lock Declaration Statements
    -------------------------------------------

    <lock-declaration-statement> :
        <named-lock-declaration> ";"

A lock declaration statement declares a lock in the local scope.
Executing the lock declaration statement consists of instantiating the
lock instance for that declaration if the declaration is non-static,
or has no effect if the declaration is static.  See Section 5.5.6 for
details on the meaning of executing a lock declaration.


    Section 5.2.11: If Statements
    -----------------------------

    <if-statement> :
        "if" "(" <expression> ")" <statement-block>
                { <else-if-clause-list> }?
                { "else" <non-if-statement-block> }? ";"

    <else-if-clause-list> :
        <else-if-clause> |
        <else-if-clause> | <else-if-clause-list>

    <else-if-clause> :
        "else" "if" "(" <expression> ")" <statement-block>

An if statement is used to conditionally execute some code.

Executing an if statement consists of first evaluating the first
expression (this is the test expression).  The resulting value is the
test value.  If the test value is not a boolean value, an exception
occurs.  If the value is true, then the first statement block is
executed and then execution of the if statement is complete.

If the test value is false, then execution continues.  If the
<else-if-clause-list> is non-empty, then execution proceeds one-by-one
through the <else-if-clause>s in the order they appear.  For each, the
expression is evaluated to get a new test value.  If the test value is
not true or false, an exception occurs.  If the test value is true,
then the statement block for that <else-if-clause> is executed and
execution of the if statement is done.  Otherwise, execution of the if
statement continues.

Finally, if the optional "else" part appears, the
<non-if-statement-block> for that part is executed.  Then, execution
of the if statement is complete.

EXAMPLES:

  * if (3 == 4)
      {
        "yes"!
      };
    "done"!

    is a statement list that prints:

        done

    when executed.

  * if (3 != 4)
      {
        "yes"!
      };
    "done"!

    is a statement list that prints:

        yes
        done

    when executed.

  * if (3 == 4)
      {
        "yes"!
      }
    else
      {
        "no"!
      };
    "done"!

    is a statement list that prints:

        no
        done

    when executed.

  * if (3 != 4)
      {
        "yes"!
      }
    else
      {
        "no"!
      };
    "done"!

    is a statement list that prints:

        yes
        done

    when executed.

  * if (3 != 4)
        "yes"!
    else
        "no"!;
    "done"!

    is a statement list that prints:

        yes
        done

    when executed.

  * if (3 != 4)
        "yes"!;
    "done"!

    is a statement list that prints:

        yes
        done

    when executed.

  * if (3 == 4)
        "yes"!
    else if (5 == 7)
        "maybe"!
    else
        "no"!;
    "done"!

    is a statement list that prints:

        no
        done

    when executed.

  * if (3 != 4)
        "yes"!
    else if (5 == 7)
        "maybe"!
    else
        "no"!;
    "done"!

    is a statement list that prints:

        yes
        done

    when executed.

  * if (3 == 4)
        "yes"!
    else if (5 != 7)
        "maybe"!
    else
        "no"!;
    "done"!

    is a statement list that prints:

        maybe
        done

    when executed.

  * if (3 == 4)
        "yes"!
    else if (5 != 7)
        "maybe"!;
    "done"!

    is a statement list that prints:

        maybe
        done

    when executed.

  * if (3 == 4)
        "yes"!
    else if (5 == 7)
        "maybe"!;
    "done"!

    is a statement list that prints:

        done

    when executed.


    Section 5.2.12: Switch Statements
    ---------------------------------

    <switch-statement> :
        "switch" "(" <expression> ")" <case-list> ";"

    <case-list> :
        <empty> |
        <case> | <case-list>

    <case> :
        "case" "(" <type-expression> ")" <statement-block>

Executing a switch statement starts with evaluating its first
expression to get a value called the test value.  Then, execution
proceeds through all the cases in the case list in order until a match
is found.

For each case that is tried, the type expression for that case is
evaluated to give the case type.  Then, the test value is tested to
see if it is in the case type.  If it is, a match has been found and
the statement block for that case is executed and then the execution
of the switch statement is done.  Otherwise, the statement block for
that case is not executed and the next case is tried.

If no cases match, execution of the switch statement is done.

Note that case type expressions beyond the matching one are not
evaluated, and at most one of the statement blocks is executed on a
given execution of the switch statement.

EXAMPLE:

  * procedure p1(x)
      {
        pure function positive_odd(y) returns boolean
            ((y in integer) && (y > 0) && ((y % 2) == 1));
        print(x, ": ");
        switch (x)
        case ({0})
          { "zero"! }
        case ({1})
          { "one"! }
        case ({2, 3})
          { "two or three"! }
        case ([0...5])
          { "zero through 5"! }
        case (positive_odd)
          { "positive_odd"! }
        case (integer)
          { "integer"! }
        case (!{})
          { "something else"! };
      };
    p1(0);
    p1(1);
    p1(2);
    p1(3);
    p1(4);
    p1(5);
    p1(6);
    p1(7);
    p1(8);
    p1(9);
    p1(10);
    p1(-1);
    p1(-2);
    p1(5.3);
    p1([5.3]);

    is a statement list that prints:

        0: zero
        1: one
        2: two or three
        3: two or three
        4: zero through 5
        5: zero through 5
        6: integer
        7: positive_odd
        8: integer
        9: positive_odd
        10: integer
        -1: integer
        -2: integer
        53/10: something else
        [53/10]: something else

    when executed.


    Section 5.2.13: Goto Statements
    -------------------------------

    <goto-statement> :
        "goto" <expression> ";"

@@@


    Section 5.2.14: Return Statements
    ---------------------------------

    <return-statement> :
        "return" { <expression> }? { "from" <identifier> }? ";"

@@@


    Section 5.2.15: For Statements
    ------------------------------

    <for-statement> :
        { "parallel" }? "for" "(" <identifier> ";" <expression> ";"
                <expression> { ";" <expression> }? ")"
                <statement-block> ";"

A for statement is a loop statement that executes its body some number
of times.  The statement block is the body.

Executing a for statement starts with executing the first and the
third of its expressions, in that order.  The values this produces are
the initial value and increment value respectively.  If the optional
third expression is not present, the increment value is one.

Next, an immutable instance called the index is allocated and
instantiated.  The name of the index is the identifier from the for
statement.  Its type is the type of all values and its initial value
is the initial value.  The index is visible and can be bound from
within the second expression and the body, but not from within the
first or third expressions.  The index is de-allocated when the for
statement's execution is done.

Next, a three-step process is repeated until something causes it to
stop.  The first of these three steps is to evaluate the second
expression of the for statement.  This results in the test value.  If
the test value is not true or false, an exception occurs.  If the test
value is false, the execution of the for statement is done.

Otherwise, the second step of the repeating process happens.  This
second step is to execute the body statement block.  From within the
body statement block, break and continue expressions and statements
can be bound to this loop and can cause control to jump to the break
or continue target of this instance of the for statement.  If control
jumps to the break target, the for statement's execution is done.  If
control jumps to the continue target, execution of the for statement
continues with the third step of the repeating process, just as it
does if control exits the body simply by executing the last statement
of the block without jumping anywhere else.

The third step of the repeating process is to increment the index
immutable.  This actually replaces the index immutable with another
immutable with the new value.  The new value is what would be produced
by a binary expression with "+" as the operator, the old index value
as the left-hand operand, the and the increment value as the
right-hand operand.  But note that the increment expression is not
re-evaluated each time through the loop -- it is evaluated once before
the body ever executes and the same increment value is used every time
the third step of the repeating process happens.  Note also that no
overloading is involved with the increment operation -- routines named
"operator+" do not affect it.

After the third step, the process goes back to the first step and
continues.

The optional "parallel" prefix on a for statement means that it is
legal for the implementation to run different iterations of the loop
body in parallel.  The implementation would have to be able to
determine based on the initial value, increment, and test expression
that a later iteration would be run even though it hadn't yet
completed a previous iteration for the implementation to actually take
advantage of this and run iterations out of order or in parallel.
Note that the implementation is never required to run the iterations
in parallel or out of order -- the "parallel" directive simply informs
the implementation that it is allowed to.  It's up to the developer to
make sure that running multiple iterations of the body in parallel
wouldn't give undesired behavior -- if it would, the "parallel"
directive should not be used.

It is illegal to bind a break expression or statement to a for
statement with the "parallel" prefix.

EXAMPLE:

  * for (i; 17; i < 25; 3)
      { i! };

    is a statement list that prints:

        17
        20
        23

    when executed.


    Section 5.2.16: Iterate Statements
    ----------------------------------

    <iterate-statement> :
        { "parallel" }? "iterate" "(" <identifier> ";" <expression>
                { ";" <expression> }? ")" <statement-block> ";"

An iterate statement is a loop statement that executes its body once
for each element of a list of values.  The identifier specifies its
element name, the first expression is the base expression, the
optional second expression is the test expression, and the statement
block is the body.  The base expression specifies a list of elements
and the body is executed on each element of the base, with those
elements the test expression returns false for being omitted.

Executing an iterate statement starts with evaluating its base
expression.  The value this produces is the list value.  The list
value must be valid except for map value target values and
semi-labeled value list component values, otherwise, an exception
occurs.

Next, a two-step process is repeated until something causes it to
stop.  In the first of these two steps, an immutable instance called
the element immutable is allocated and instantiated.  The name of the
element immutable is the identifier from the iterate statement.  Its
type is the type of all values.  Its initial value depends on the list
value.

If the list value is a semi-labeled value list, then the two-step
process is repeated once for each element of the semi-labeled value
list.  On each iteration, the initial value of the element immutable
is one of the component values of the semi-labeled value list.  The
values are used in the order they appear in the semi-labeled value
list.  When there are no more values, the execution of the iterate
statement is complete.

If the list value is a map, then all the keys of the map must be
finite integers or an exception occurs.  Execution starts with the
lowest integer key in the map and finishes after the highester integer
key in the map has been used.  After each iteration the key is
incremented.  For each iteration, the initial value of the element
immutable is the target for that key.  If any keys between the highest
and lowest in the map are not associated with target values, an
exception occurs.

Otherwise, if the list value has a field named "iterator" that is a
routine that can be called with no arguments, that routine is called
once before any iterations of the loop.  It is expected to return a
value and that value is called the iterator value.  Then, at the start
of each iteration, an attempt is made to read a field from the
iterator value called "is_done".  That field must have as a value a
routine that can be called with no arguments, or else an exception
occurs.  That routine value is then called.  The resulting value must
be either true or false or else an exception occurs.  If it is true,
the execution of the iterate statement is done.  Otherwise, an attempt
is made to read a field from the iterator value called "current".
That field must have as a value a routine that can be called with no
arguments, or else an exception occurs.  That routine is then called.
The resulting value is the initial value of the element immutable for
that iteration.

If the list value doesn't have any of these forms, an exception
occurs.

The element immutable is visible and can be bound from within the body
and the test expression, but not from within the base expression.  The
element immutable is de-allocated after the execution of the body for
each iteration.

Next, the second step of the repeating process happens.  This second
step starts with evaluating the test expression, if it is present, to
give the test value.  If the test expression is not present, it is
treated as if it were a test expression that always evaluates to true
with no side effects.  From within the test expression, break and
continue expressions and statements can be bound to this iterate
statement and can cause control to jump to the break or continue
target of this instance of the iterate statement.  If control jumps to
the break target, the execution of the iterate statement is complete.
If control jumps to the continue target, the second step is complete
and execution of the iterate statement continues with the first step.
Then, if the test value is false, the second step is complete.  If the
test value is true, then the body statement block is executed.  If the
test value is neither true nor false, an exception occurs.

From within the body statement block, break and continue expressions
and statements can be bound to this loop and can cause control to jump
to the break or continue target of this instance of the iterate
statement.  If control jumps to the break target, the iterate
statement's execution is done.  If control jumps to the continue
target, execution of the iterate statement continues, just as it does
if control exits the body simply by executing the last statement of
the block without jumping anywhere else.

After the body has been iterated, if an iterator is being used, then
an attempt is made to read a field from the iterator value called
"step".  That field must have as a value a routine that can be called
with no arguments, or else an exception occurs.  That routine is then
called.  If it returns a value, an exception occurs.

After that, the process goes back to the first step and continues.

The optional "parallel" prefix on an iterate statement means that it
is legal for the implementation to run different iterations of the
loop body in parallel.  The implementation would have to be able to
determine based on the list value that a later iteration would be run
even though it hadn't yet completed a previous iteration for the
implementation to actually take advantage of this and run iterations
out of order or in parallel.  Note that the implementation is never
required to run the iterations in parallel or out of order -- the
"parallel" directive simply informs the implementation that it is
allowed to.  It's up to the developer to make sure that running
multiple iterations of the body in parallel wouldn't give undesired
behavior -- if it would, the "parallel" directive should not be used.

It is illegal to bind a break expression or statement to an iterate
statement with the "parallel" prefix.

EXAMPLES:

  * iterate (x; ["a", q := "b", "c"])
      { x! };

    is a statement list that prints:

        a
        b
        c

    when executed.

  * iterate (x; <<(-2 --> "a"), (-1 --> "b"), (0 --> "c"), (1 --> "d")>>)
      { x! };

    is a statement list that prints:

        a
        b
        c
        d

    when executed.

  * class c1()
      {
        function iterator()
          {
            return class()
              {
                variable i := 0;
                function current() (i);
                function is_done() (i > 10);
                procedure step() { i += 3; };
              }();
          };
      };
    iterate (x; c1())
      { x! };

    is a statement list that prints:

        0
        3
        6
        9

    when executed.

  * iterate (x; [1, 2, 3, 4, 5, 6]; (x % 2) == 1)
      { x! };

    is a statement list that prints:

        1
        3
        5

    when executed.


    Section 5.2.17: While Statements
    --------------------------------

    <while-statement> :
        "while" "(" <expression> ")" <optional-step> <statement-block>
                <optional-step> ";"

    <optional-step> :
        <empty> |
        "step" <statement-block>

A while statement is a loop statement that executes its body as long
as some condition holds.  The statement block is the body.

Note that while the <optional-step> appears both before and after the
body in the BNF, it is allowed to appear in at most one of those two
places.  It is also allowed to be omitted.

Executing a while statement involves repeating a three-step process
until something causes it to stop.  The first of these three steps is
to evaluate the expression of the while statement.  This results in
the test value.  If the test value is not true or false, an exception
occurs.  If the test value is false, the execution of the while
statement is done.

Otherwise, the second step of the repeating process happens.  This
second step is to execute the body statement block.  From within the
body statement block, break and continue expressions and statements
can be bound to this loop and can cause control to jump to the break
or continue target of this instance of the while statement.  If
control jumps to the break target, the while statement's execution is
done.  If control jumps to the continue target, execution of the while
statement continues with the third step of the repeating process, just
as it does if control exits the body simply by executing the last
statement of the block without jumping anywhere else.

The third step of the repeating process is to execute the statement
block of the <optional-step>, if an <optional-step> appears.  If there
is no such statement block, nothing happens in this step.  Note that
it doesn't matter whether the <optional-step> appears before or after
the body; either way, it is executed after the body and before the
test.

After the third step, the process goes back to the first step and
continues.

EXAMPLES:

  * variable result := "";
    variable i := 0;
    while (i < 10)
      {
        result ~= sprint(i);
        ++i;
      };
    result!

    is a statement list that prints:

        0123456789

    when executed.

  * variable result := "";
    variable i := 0;
    while (i < 10)
      { result ~= sprint(i); }
    step
      { ++i; };
    result!

    is a statement list that prints:

        0123456789

    when executed.

  * variable result := "";
    variable i := 0;
    while (i < 10)
    step
      { ++i; }
      { result ~= sprint(i); };
    result!

    is a statement list that prints:

        0123456789

    when executed.


    Section 5.2.18: Do-While Statements
    -----------------------------------

    <do-while-statement> :
        "do" <statement-block> "while" "(" <expression> ")"
                <optional-step> ";"

A do-while statement is a loop statement that executes its body until
some condition is no longer true.  The statement block is the body.

Executing a do-while statement involves repeating a three-step process
until something causes it to stop.  The first of these three steps is
to execute the body statement block.  From within the body statement
block, break and continue expressions and statements can be bound to
this loop and can cause control to jump to the break or continue
target of this instance of the do-while statement.  If control jumps
to the break target, the do-while statement's execution is done.  If
control jumps to the continue target, execution of the do-while
statement continues with the second step of the repeating process,
just as it does if control exits the body simply by executing the last
statement of the block without jumping anywhere else.

The second step of the repeating process is to evaluate the expression
of the do-while statement.  This results in the test value.  If the
test value is not true or false, an exception occurs.  If the test
value is false, the execution of the do-while statement is done.

Otherwise, execution continues with the third step.  This third step
is to execute the statement block of the <optional-step>.  If there is
no such statement block, nothing happens in this step.

After the third step, the process goes back to the first step and
continues.

EXAMPLES:

  * variable result := "";
    variable i := 0;
    do
      {
        result ~= sprint(i);
        ++i;
      }
    while (i < 10);
    result!

    is a statement list that prints:

        0123456789

    when executed.

  * variable result := "";
    variable i := 0;
    do
      { result ~= sprint(i); }
    while (i < 10)
    step
      { ++i; };
    result!

    is a statement list that prints:

        0123456789

    when executed.

  * do
      { "yes!"! }
    while (false);

    is a statement list that prints:

        yes!

    when executed.


    Section 5.2.19: Break Statements
    --------------------------------

    <break-statement> :
        "break" { "from" <identifier> }? ";"

A break statement is shorthand for a goto statement whose argument is
a break expression of the same form as the break statement.

EXAMPLE:

  * variable result := "";
    for (i; 0; i < 10)
      {
        if (i == 5)
            break;;
        result ~= sprint(i);
      };
    result!

    is a statement list that prints:

        01234

    when executed.


    Section 5.2.20: Continue Statements
    -----------------------------------

    <continue-statement> :
        "continue" { "with" <identifier> }? ";"

A continue statement is shorthand for a goto statement whose argument
is a continue expression of the same form as the continue statement.

EXAMPLE:

  * variable result := "";
    for (i; 0; i < 10)
      {
        if (i == 5)
            continue;;
        result ~= sprint(i);
      };
    result!

    is a statement list that prints:

        012346789

    when executed.


    Section 5.2.21: Label Statements
    --------------------------------

    <label-statement> :
        <identifier> ":"

Label statements serve two functions, but executing a label statement
never has an effect.

The first function of a label statement is as a sort of declaration
statement for jump targets.  When the scope of the label statement is
entered, a jump target associated that this label and the current
scope is instantiated.  When the scope exits, the jump target is
de-allocated.  Name reference expressions that are bound to this label
get a jump target value for this label's jump target when they are
executed.

The second function of a label statement is to give a name to a loop
statement (a for, iterate, while, or do-while statement) to allow
break and continue statements and expressions to reference an outer
loop.  Any label statement that is immediately before a loop statement
in a statement list, or that only has other label statements between
it and the loop statement, applies the name of the label to the loop.

EXAMPLES:

  * variable result := "";
    variable i := 0;
  loop:
    if (i >= 10)
        goto done;;
    result ~= sprint(i);
    ++i;
    goto loop;
  done:
    result!

    is a statement list that prints:

        0123456789

    when executed.

  * procedure p1(x, target := null)
      {
        print("Entering p1(", x, ").\n");
        if (target == null)
            p1(x * x, exit);
        else
            goto target;;
      exit:
        print("Leaving p1(", x, ").\n");
      };
    p1(5);

    is a statement list that prints:

        Entering p1(5).
        Entering p1(25).
        Leaving p1(5).

    when executed.

  * variable result := "";
  my_loop1:
  my_loop2:
    for (i; 0; i < 10)
      {
        if (i == 5)
            continue with my_loop1;;
        if (i == 7)
            continue with my_loop2;;
        result ~= sprint(i);
      };
    result!

    is a statement list that prints:

        01234689

    when executed.


    Section 5.2.22: Statement Block Statements
    ------------------------------------------

    <statement-block-statement> :
        <braced-statement-block> ";"

A statement block statement is a way to provide a nested scope within
a larger statement block.

Executing a statement block statement consists of executing its
statement block.


    Section 5.2.23: Single Statements
    ---------------------------------

    <single-statement> :
        <single-prefix> <braced-statement-block> ";"

    <single-prefix> :
        "single" { "(" <expression> ")" }?

@@@


    Section 5.2.24: Try-Catch Statements
    ------------------------------------

    <try-catch-statement> :
        "try" <statement-block> { <catch-tagged-list> }?
                { "catch" <statement-block> }? ";"

    <catch-tagged-list> :
        <catch-tagged-item> |
        <catch-tagged-item-list> "," <catch-tagged-item>

    <catch-tagged-item> :
        "catch" "(" <identifier> { "tagged" <type-expression> }? ")"
                <statement-block>

@@@


    Section 5.2.25: Try-Handle Statements
    -------------------------------------

    <try-handle-statement> :
        "try" <statement-block> "handle" <expression> ";"

@@@


    Section 5.2.26: Cleanup Statements
    ----------------------------------

    <cleanup-statement> :
        "cleanup" <statement-block> ";"

A cleanup statement is used to specify something that should be done
with the current scope exits.

Executing a cleanup statement appends its statement block to the list
of cleanup statement blocks of the statement block it appears in, so
that it will be executed when the scope exits.  The statement block is
not executed at the time the cleanup statement is executed, it is
saved for later.  See Section 5.3 on statement blocks for more
details.

Note that if jumps cause the same statement block to be executed
multiple times in the same scope, its cleanup block can appear in the
list for that scope multiple times.

Note also that scopes for classes don't exit until the object produced
by the call to the class is closed.

EXAMPLES:

  * "A"!
    cleanup
      { "B"! };
    "C"!

    is a statement list that prints:

        A
        C
        B

    when executed.

  * "A"!
    variable done := false;
  repeat:
    cleanup
      { "B"! };
    if (!done)
      {
        done := true;
        goto repeat;
      };
    "C"!

    is a statement list that prints:

        A
        C
        B
        B

    when executed.

  * class c1()
      {
        cleanup
          { "B"! };
      };
    "A"!
    immutable i1 := c1();
    "C"!
    delete(i1);
    "D"!

    is a statement list that prints:

        A
        C
        B
        D

    when executed.


    Section 5.2.27: Export Statements
    ---------------------------------

    <export-statement> :
        "export" { <export-item-list> }? { "from" <identifier> }? ";"

    <export-item-list> :
        <export-item> |
        <export-item-list> "," <export-item>

    <export-item> :
        <identifier> { "as" <identifier> }?

@@@


    Section 5.2.28: Hide Statements
    -------------------------------

    <hide-statement> :
        "hide" { <hide-item-list> }? { "from" <identifier> }? ";"

    <hide-item-list> :
        <hide-item> |
        <hide-item-list> "," <hide-item>

    <hide-item> :
        <identifier>

@@@


    Section 5.2.29: Use Statements
    ------------------------------

    <use-statement> :
        "use" { <identifier> ":=" }?
                { <expression> | <string-literal-token> }
                { ":"
                  { <type-expression> | <string-literal-token> } }?
                { <use-suffix> }? ";"

    <use-suffix> :
        "for" <export-item-list> |
        "except" <hide-item-list>

@@@


    Section 5.2.30: Include Statements
    ----------------------------------

    <include-statement> :
        "include" <string-literal-token> ";"

In include statement grabs functionality from outside and places at
this point in the program.

How the string literal token is interpreted is left up to the
implementation.  In a typical implementation, the string literal is
expected to be interpreted as a file name in the local file system,
and if the file name ends with ".salm", it is expected to be used as a
source file with Salmon code.  When the include statement is parsed,
the Salmon code from the source file is parsed as a list of statements
that are then inserted into the current statement block at the point
where the include statement occurs.  Everything that is left unbound
in the included source file is bound as if it occurred in the position
of the include statement.  Active alias statements apply to the
contents of the included file too.

The implementation may also allow local files in other formats to be
used by an include statement, such a binary files that give access to
native code routines or source files in other programming languages.
In any case, additional functionality is added at the point in the
Salmon code where the include statement occurs.  If the included
functionality includes the equivalent of data or routine declarations,
the scope of their names is the scope local to the include statement.

Note that some implementations may choose not to allow include
statements to access local files at all.  For example, an
implementation set up to run untrusted code downloading over the
network might be set up to disallow all local file access through
include statements.  Instead, such an implementation might allow the
string literal of an include statement to specify a URL for
downloading code from the internet.  That downloaded code could itself
include further code from the internet through its own include
statements.

Note also that any loading of outside functionality by an include
statement happens at parse time, before program execution has begun.
If the implementation is a compiler, this will be at compile time,
which may be very long before execution begins.

EXAMPLE:

  * include "other.salm";

    is a statement list that on some implementations will include the
    contents of a file called "other.salm".


    Section 5.2.31: Quark Enumeration Statements
    --------------------------------------------

    <quark-enumeration-statement> :
        <data-prefix> "quark" "enumeration" <identifier>
                "{" <quark-name-list> "}" ";"

    <quark-name-list> :
        <identifier> |
        <identifier> <quark-name-list>

Quark enumeration statements provide a shorthand way of declaring both
a list of quarks and an enumeration type containing all the quarks
without having to list all the quark names twice.  A quark enumeration
statement is equivalent to an immutable declaration with the first
identifier specifying the name of the immutable and initializer a type
value consisting of an enumeration of all the quarks in the quark name
list, followed by a declaration of all the quarks in the list.  If
there are ``static'' or ``virtual'' qualifiers in the data prefix,
they apply to both the immutable declaration and to all the quark
declarations.  If there is a ``single'' qualifier, it applies only to
the immutable declaration.

EXAMPLE:

  * quark enumeration abc { aaa, bbb, ccc};

    is entirely equivalent to:

    immutable abc : type any_quark := { aaa, bbb, ccc};
    quark aaa, bbb, ccc;


    Section 5.2.32: Theorem Statements
    ----------------------------------

    <theorem-statement> :
        "theorem" "(" <expression> ")"
                { "proof" "{" <proof-item-list> "}" }? ";"

    <proof-item-list> :
        <proof-item> |
        <proof-item> <proof-item-list>

Theorem statements are used to specify things that the programmer
believes to be true but does not want explicitly checked at run time.
A theorem is a statement by the programmer that the expression of the
theorem would have given the value true if it had been evaluated at
the time the theorem statement was executed.

Executing a theorem statement has no effect at all.  Theorem
statements exist so that they can be statically checked before
runtime.  An implementation of Salmon is not required to do anything
at all with theorem statements, but it is expected that some
implementations will provide a theorem checking feature.  If the
implementation does theorem checking, it can try to see which theorems
it can determine are definitely true and communicate that information
to the user.  The developer can add proof information to help the
theorem checker.  One model would be to make sure the every theorem in
the program can be proven by the theorem checker and consider it an
error if any cannot.  This can eliminate certain classes of bugs
without any runtime overhead.

Theorems can also potentially be used by the implementation for
optimization.  After a theorem has been proven by a theorem checker,
for example, a compiler is free to generate code using the information
in the theorems.  Alternatively, a compiler might have an option for
the user to tell the compiler to go ahead and assume all theorems are
true.  This can save the developer the trouble of proving all the
theorems while still producing better-optimized code, but it will be
code that can fail in strange ways if it turns out the developer was
wrong about one or more of the theorems always holding.


    Section 5.2.33: Alias Statements
    --------------------------------

    <alias-statement> :
        "alias" <identifier> <identifier> ";"

An alias statement provides an alternative identifier that can be used
in place of another identifier.  The first identifer is the new name
and the second is the old name.  In all the statements after the alias
statement until the end of the statement block, the new name can be
used to refer to the same thing as the old name.  This can include
keywords as well as references to declared entities.

Note that an alias does not affect identifiers specifying field names,
routine formal parameter names, or the names of entities being
declared in a declaration.  For example, in this code fragment:

    alias a b;
    p1(a := 3);
    v1 := [a := 5];
    v1 := l1[a := 7];
    variable a := 5;

the alias statement doesn't have any effect on any of the following
four lines.  Note, however, that while the final line declares a
variable with the name ``a'', not ``b'', use of the name ``a'' to try
to access that variable will map to something by the name of ``b'',
not the variable declared there.  If ``b'' doesn't resolve to
anything, a reference such as ``f(a)'' will result in a parse-time
error.


    Section 5.2.34: Print Line Statements
    -------------------------------------

    <print-line-statement> :
        <expression> "!"

A print line statement is equivalent to a call statement with "print"
as the base expression and two arguments, the first being the
expression from the print line statement and the second being the
string literal "\n".

In the standard case, this causes the expression to be evaluated and
then printed to standard output, followed by a newline.  But note that
if print has been over-ridden in the context for this statement, the
overridden print procedure will be used instead.


    Section 5.2.35: Backtick Statements
    -----------------------------------

    <backtick-statement> :
        <backtick-expression-literal-token> ";"

@@@


    Section 5.3: Statement Blocks
    -----------------------------

    <statement-block> :
        <non-if-statement-block> |
        <if-statement>

    <non-if-statement-block> :
        <braced-statement-block> |
        <non-block-non-if-statement>

    <braced-statement-block> :
        "{" <statement-list> "}"

    <statement-list> :
        <empty> |
        <statement> <statement-list>

A statement block can consist of either a single statement or a list
of statements with braces around them.  The braces around a list of
statements form a scope.

If the statement block is a single statement, executing the statement
block consists of simply executing that statement.

If the statement block is a braced statement block, executing the
statement block starts by allocating instances for all non-static
declaration statements directly appearing in the statement list (but
not those appearing nested somewhere under something in the list).
Static declaration statements (i.e. those that use the modifier
"static" in their declarations) are allocated at a different time and
not included here.  Next, a list is set up of cleanup blocks for this
scope.  The list of cleanup blocks starts out empty, and items are
added when cleanup statements that appear directly in the statement
list are executed.  When that has been done, execution of the
statement list begins with the first statement.  Execution continues
from one statement to the next in the list unless and until the flow
of control is changed by a jump.  If the jump is to somewhere else in
the statement block, execution continues with that part of the
statement block and again proceeds in order from one statement to the
next.

Once control exits the statement list, either through a jump out of
the block or through the completion of the execution of the last
statement in the block without a jump, unless this statement block is
the body of a class, all the cleanup blocks in the cleanup block list
are executed in reverse order, from most recently added to first
added.  Then, unless this statement block is the body of a class, all
instances that were allocated on entry to the block are de-allocated
except those instances from declarations with the "ageless" modifier.
Then, execution of the statement block is complete.


    Section 5.4: Type Expressions
    -----------------------------

    <type-expression> :
        <name-type-expression> |
        <enumeration-type-expression> |
        <not-type-expression> |
        <intersection-type-expression> |
        <union-type-expression> |
        <xor-type-expression> |
        <expression-type-expression> |
        <array-type-expression> |
        <range-type-expression> |
        <pointer-type-expression> |
        <type-type-expression> |
        <map-type-expression> |
        <routine-type-expression> |
        <fields-type-expression> |
        <lepton-type-expression> |
        <multiset-type-expression> |
        <interface-type-expression> |
        <semi-labeled-value-list-type-expression> |
        <regular-expression-type-expression> |
        <lazy-type-expression> |
        "(" <type-expression> ")"

A type expression is a piece of code that can be evaluated to yield a
type.


    Section 5.4.1: Name Type Expressions
    ------------------------------------

    <name-type-expression> :
        <identifier>

A name type expression is used to reference a type by name.  The
identifier is treated as a name reference expression and evaluated as
an expression.  An exception occurs if the value produced by
evaluating that expression is not a type, a lepton key, a class, a
regular expression, or a pure function.  If it is a type, the result
of evaluating the name type expression is that type.  If it is a
lepton key, the result of evaluating the name type expression is the
set of all lepton values whose keys are that lepton key.  If it is a
class, the result of evaluating the name type expression is the set of
all objects that are instances of that class.  If it is a regular
expression, the result of evaluating the name type expression is the
set of all strings that contain a match with that regular expression.
If it is a pure function, the function must always return true or
false when given one value as an argument, and the type is the set of
all values for which the function returns true.

EXAMPLES:

  * immutable t := type { 1, 3, 5, 7};
    variable x : t;
    variable y : t;

    is a statement list that creates an immutable named t that holds a
    value that is the type consisting of the values 1, 3, 5, and 7,
    then declares two variables, x and y, that each have that type.

  * variable t := type { 1, 3, 5, 7};
    variable x : t;
    t := type { 1, 3, 5};
    variable y : t;

    is a statement list that creates a variable named t and two
    variables, x and y.  The variable x is allowed to take any of the
    values 1, 3, 5, or 7, but the variable y is only allowed to take
    one of the values 1, 3, or 5.  Note that the value of t at the
    time the declaration of x is executed is the type of x, and when t
    changes later, it doesn't affect the type of x.

  * lepton v;
    variable x : v;

    is a statement list that creates a variable named x which is only
    allowed to take values that are leptons with lepton key ``v'' as
    their key.


    Section 5.4.2: Enumeration Type Expressions
    -------------------------------------------

    <enumeration-type-expression> :
        "{" <expression-list> "}"

    <expression-list> :
        <empty> |
        <non-empty-expression-list>

    <non-empty-expression-list> :
        <expression> |
        <expression> "," <non-empty-expression-list>

An enumeration type expression is used to specify a type consisting of
a finite number of values.  The values may be any values at all, but
the values in the list for a given enumeration type expression must
all be different.

Evaluating an enumeration type expression consists of evaluating all
the expressions in its list.  If any two of the expressions in the
list evaluate to the same value, an exception occurs.  Otherwise, the
result is the type containing exactly those values and no others.

EXAMPLES:

  * {5, 7, 13} is a type expression that evaluates to the type
    consisting of three values -- 5, 7, and 13.

  * {} is a type expression that evaluates to a type containing no
    values at all.


    Section 5.4.3: Not Type Expressions
    -----------------------------------

    <not-type-expression> :
        "!" <type-expression>

A ``not'' type expression specifies a type consisting of exactly those
values that are not in a specified other type.

Evaluating a ``not'' type expression consists of first evaluating its
argument type expression.  Then, the result is the type that consists
of all the values that are not in that type and none of the ones that
are in that type.

EXAMPLES:

  * !{123, 237} is a type expression evaluating to the type containing
    every value except the values 123 and 237.

  * !{} is a type expression evaluating to the type containing every
    possible value.

  * !!{57, 82} is a type expression evaluating to the type containing
    exactly two values, 57 and 82.


    Section 5.4.4: Intersection Type Expressions
    --------------------------------------------

    <intersection-type-expression> :
        <type-expression> "&" <type-expression>

An intersection type expression specifies a type that consists of all
the values that are in both of two other types.

Evaluating an intersection type expression consists of evaluating both
of its argument type expressions.  The result is the type consisting
only of values that are in both of the two argument types.

EXAMPLES:

  * {1, 3, 5, 7} & {4, 5, 6} is a type expression evaluating to the
    type containing exactly one value, 5.

  * {5, 7} & {13, 17, 19} is a type expression evaluating to the type
    containing no values at all.


    Section 5.4.5: Union Type Expressions
    -------------------------------------

    <union-type-expression> :
        <type-expression> "|" <type-expression>

A union type expression specifies a type that consists of all the
values that are in either of two other types.

Evaluating a union type expression consists of evaluating both of its
argument type expressions.  The result is the type consisting values
that are in either of the two argument types.

EXAMPLES:

  * {1, 3, 5, 7} | {4, 5, 6} is a type expression evaluating to the
    type containing the values 1, 3, 4, 5, 6, and 7.

  * (!{5, 7}) | {7, 17, 19} is a type expression evaluating to the
    type containing every value except 5.


    Section 5.4.6: Xor Type Expressions
    -----------------------------------

    <xor-type-expression> :
        <type-expression> "^" <type-expression>

An xor type expression specifies a type that consists of all the
values that are in one or the other but not both of two other types.

Evaluating an xor type expression consists of evaluating both of its
argument type expressions.  The result is the type consisting values
that are in one or the other of the two argument types but not those
values that are in both.

EXAMPLES:

  * {1, 3, 5, 7} ^ {4, 5, 6} is a type expression evaluating to the
    type containing the values 1, 3, 4, 6, and 7.

  * (!{5, 7}) | {7, 17, 19} is a type expression evaluating to the
    type containing every value except 5, 17, and 19.


    Section 5.4.7: Expression Type Expressions
    ------------------------------------------

    <expression-type-expression> :
        "<<" <expression> ">>"

An expression type expression is one that specifies an ordinary value
expression is to be evaluated to give the type.

Evaluating an expression type expression starts with evaluating its
argument expression.  If this evaluates to any value other than a
type, a lepton key, a class, a regular expression, or a pure function,
an exception occurs.  If it evaluates to a type value, that type is
the result of evaluating the expression type expression.  If it
evaluates to a lepton key, the set of all lepton values whose keys are
that lepton key is the result of evaluating the expression type
expression.  If it evaluates to a class, the set of all objects that
are instances of that class is the result.  If it evaluates to a
regular expression, the type of all strings that contain a match with
that regular expression is the result.  If it evaluates to a pure
function, the function must always return true or false when given one
value as an argument, and the set of all values for which the function
returns true is the result.

Note that there is ambiguity in the BNF here since the ">>" token that
marks the end of the expression type expression could also be taken as
a right-shift binary operator within the expression.  This ambiguity
is resolved with a precedence rule that says the expression is parsed
as if it were the second argument to a left-shift operator (so, in
particular, a right shift within the expression needs to have
parentheses around it).

EXAMPLES:

  * <<f()>> is a type expression that is evaluated by calling the
    function f() and using the type returned by f() as the type.

  * <<type {5, 7}>> is a type expression evaluating to the type
    containing exactly two values, 5 and 7.


    Section 5.4.8: Array Type Expressions
    -------------------------------------

    <array-type-expression> :
        "array" |
        "array" "[" <type-expression> "]" |
        <type-expression> "[" <expression> "]" |
        <type-expression> "[" <expression> "..." <expression> "]"

An array type expression specifies a type consisting of specific array
values.

The first form, the word ``array'' by itself, evaluates to the type
consisting of all array values.

The second form, the word ``array'' followed by a type expression in
square brackets, is evaluated by first evaluating its argument type
expression.  The result type is the type consisting of all arrays
which consist entirely of elements in the argument type.

The third form is evaluated by first evaluating its type expression
argument.  This is the type of the elements.  Then, the expression
between the square brackets is evalatuated.  If this expression does
not evaluated to an integer value, an exception occurs.  If it does
evaluated to an integer value, then the result is the type consisting
of all arrays that, first of all, only have elements of the type
specified by the element type, and secondly only have elements with
keys that are integers greater than or equal to zero and less than the
integer found by evaluating the argument between the square brackets.

The fourth and final form is evaluated by first evaluating its type
expression argument.  As with the third form, this is the element
type.  Then, the two arguments within the square brackets are
evaluated.  Both must evaluate to integer values or an exception
occurs.  If they evaluate to integer values, the left-hand
expression's value is the lower bound and the right-hand value is the
upper bound.  The result is the type consisting of all arrays with all
elements in the element type and all keys greater than or equal to the
lower bound and less than or equal to the upper bound.

EXAMPLES:

  * array is a type expression evaluating to the type consisting of
    all arrays.

  * array[{5, 7, 13}] is a type expression evaluating to the type
    consisting of all arrays whose elements are all one of the values
    5, 7, or 13.

  * {17, 87, 132}[15] is a type expression evaluating to the type
    consisting of all arrays whose elements are all one of the values
    17, 87, or 132 and whose keys are all in the range zero through 14
    inclusive.

  * {17, 87, 132}[18...21] is a type expression evaluating to the type
    consisting of all arrays whose elements are all one of the values
    17, 87, or 132 and whose keys are all one of the values 18, 19,
    20, or 21.

  * array and array !{} are two type expressions that evaluate to the
    same type.


    Section 5.4.9: Range Type Expressions
    -------------------------------------

    <range-type-expression> :
        { "[" | "(" } <expression> { "..." | "...." } <expression>
                { "]" | ")" }

A range type expression is one that specifies all the integers or
rationals in a range.  If "..." (three dots) is used, it is an integer
range and if "...." (four dots) is used, it is a rational range.

Each end of the range can be either inclusive or exclusive.  A square
bracket on that end indicates inclusive while a parenthesis indicates
exclusive.  One end can be inclusive while the other is exclusive, or
they can both be either inclusive or exclusive.

Evaluating a range type expression starts with evaluating its two
argument expressions.  If it's an integer range, each argument
expression must evaluate to an integer value or an exception occurs.
If it's a rational range, each argument expression must evaluate to a
rational value or an exception occurs.  If either expression evaluates
to unsigned infinity or zero-zero, an exception occurs.  If it's an
integer range, the resulting type is that consisting of all integers
greater than the left-hand expression and less than the right-hand
expression.  If it's a rational range, the resulting type is that
consisting of all rationals greater than the left-hand expression and
less than the right-hand expression.  If either end is inclusive, it
also includes the bound on that end, unless the upper bound is less
than the lower bound, in which case the type is the empty type.

EXAMPLES:

  * [12...17] is a type expression evaluating to the type consisting
    of the values 12, 13, 14, 15, 16, and 17.

  * [17...12] is a type expression evaluating to the type containing
    no values at all.

  * [4...7] is a type expression evaluating to the type consisting of
    the values 4, 5, 6, and 7.

  * [4...7) is a type expression evaluating to the type consisting of
    the values 4, 5, and 6.

  * (4...7] is a type expression evaluating to the type consisting of
    the values 5, 6, and 7.

  * (4...7) is a type expression evaluating to the type consisting of
    the values 5 and 6.

  * [0....1] is a type expression evaluating to the type consisting of
    all rational values >= 0 and <= 1.

  * [0....1) is a type expression evaluating to the type consisting of
    all rational values >= 0 and < 1.

  * (0....1] is a type expression evaluating to the type consisting of
    all rational values > 0 and <= 1.

  * (0....1) is a type expression evaluating to the type consisting of
    all rational values > 0 and < 1.

  * (12.37....19.95] is a type expression evaluating to the type
    consisting of all rational values > 12.37 and <= 19.95.


    Section 5.4.10: Pointer Type Expressions
    ----------------------------------------

    <pointer-type-expression> :
        "*" <type-expression> |
        "*" "." <type-expression> |
        "+" <type-expression> |
        "+" "." <type-expression> |
        "*" "+" <type-expression> |
        "*" "+" "." <type-expression>

First of all, it bears noting that in the Salmon type system, a
distinction is made between pointers that can be used for reading and
pointers that can be used for writing.  The asterix prefix is used to
specify pointers that can be used for reading.  The plus prefix is
used to specify pointers that can be used for writing.  And the
asterix followed by the plus is used to specify pointers that may be
used for either reading or writing.

Secondly, in the Salmon system, when specifying a pointer type, one
explicitly specifies whether or not null is allowed.  If a dot is
appended to the asterix or plus prefix, null is allowed and if a dot
is not appended, null is not allowed.

Evaluating a pointer type expression starts with evaluating its
argument type expression.  The resulting type then depends on which of
the six forms of pointer expression was used, as follows:

  * In the "*" <type-expression> case, the resulting type is that
    consisting of all slot location values whose slots are limited to
    only values in the argument type and no other values.  Note that
    the slot is allowed to be even more limited, to some subset of the
    argument type, but it is not allowed to include anything not in
    the argument type.  So reading a value by deferencing a value of
    this type is guaranteed to give a value in the type specified by
    the argument.

  * In the "*" "." <type-expression> case, the resulting type is what
    it would be for the previous case plus the value null.

  * In the "+" <type-expression> case, the resulting type is that
    consisting of all slot location values whose slots are allowed to
    be written with any value in the argument type.  Note that the
    slot is allowed to be written with more values that aren't in the
    argument type, it's just required to allow all those in the
    argument type.  So writing any value in the argument type to a
    value in this pointer type is guaranteed to be allowed.

  * In the "+" "." <type-expression> case, the resulting type is what
    it would be for the previous case plus the value null.

  * In the "*" "+" <type-expression> case, the resulting type is the
    intersection of what it would be for the first and third cases.
    That is, the type consists of all slot location values whose slots
    are allowed to be written with any value in the argument type and
    which, when read, may contain only values in the argument type.
    So such pointer values may be used to read and write values of the
    argument type.

  * In the "*" "+" "." <type-expression> case, the resulting type is
    what it would be for the previous case plus the value null.

Note that in the C language non-const pointers are equivalent to the
``*+.'' form in Salmon and const pointers are equivalent to the ``*.''
form.  There are no equivalents in C to the ``*'', ``+'', ``+.'', and
``*+'' forms in Salmon.

EXAMPLES:

  * *{17, 18, 19} is a type expression evaluating to the set of all
    slot location values whose slots are limited to never containing
    any values other than 17, 18, or 19.

  * *.{17, 18, 19} is a type expression evaluating to the set
    containing the value null and all slot location values whose slots
    are limited to never containing any values other than 17, 18, or
    19.

  * +{17, 18, 19} is a type expression evaluating to the set of all
    slot location values whose slots can be written and which are
    allowed to contain all three of the values 17, 18, and 19 -- and
    possibly more values.

  * +.{17, 18, 19} is a type expression evaluating to the set
    containing the value null and all slot location values whose slots
    can be written and which are allowed to contain all three of the
    values 17, 18, and 19 -- and possibly more values.

  * *+{17, 18, 19} is a type expression evaluating to the set of all
    slot location values whose slots can be written and which are
    allowed to contain all three of the values 17, 18, and 19, and
    which are limited to never containing any other values.

  * *+.{17, 18, 19} is a type expression evaluating to the set
    containing the value null and all slot location values whose slots
    can be written and which are allowed to contain all three of the
    values 17, 18, and 19, and which are limited to never containing
    any other values.

  * immutable t := {17, 18, 19};
    variable p1 : *t;
    variable p2 : *.t;
    variable p3 : +t;
    variable p4 : +.t;
    variable p5 : *+t;
    variable p6 : *+.t;
    variable x1 : t;
    immutable x2 : t;
    variable x3 : {17, 18};
    immutable x4 : {17, 18};
    variable x5 : {17, 18, 19, 20};
    immutable x6 : {17, 18, 19, 20};

    In this example, the variables p2, p4, and p6 may be assigned the
    value null but p1, p3, and p5 may not.  All of p1, p2, p3, p4, p5,
    and p6 may be assigned &x1.  The variables p1 and p2 may be
    assigned &x2 but p3, p4, p5, and p6 may not because they require
    the ability to write through the pointer they contain.  The
    variables p1 and p2 may be assigned &x3 because the value read
    through that pointer is guaranteed to be 17 or 18, which is a
    subset of t.  But p3, p4, p5, and p6 may not be assigned &x3,
    because the value 19 is allowed to be written through any of those
    pointers when it is not null, and 19 may not be written to x3.
    Only the variables p1 and p2 may be assigned &x4.  The variables
    p3, p4, p5, and p6 may not be assigned &x4 because no values are
    allowed to be written to x4.  The variables p3 and p4 may be
    assigned the value &x5 because x5 may be assigned any of the
    values 17, 18, or 19.  The variables p1, p2, p5, and p6 may not be
    assigned &x5 because x5 may contain the values 20, and reading
    through one of those pointers is not allowed to return the value
    20.  None of p1, p2, p3, p4, p5, or p6 may be assigned &x6 -- p1,
    p2, p5, and p6 because the value 20 may be read when reading
    through &x6 and p3, p4, p5, and p6 because x6 may not be written
    to.


    Section 5.4.11: Type Type Expressions
    -------------------------------------

    <type-type-expression> :
        "type" <type-expression>

A type type expression specifies a type which consists of values which
are themselves all types.

Evaluating a type type expression starts with evaluating its argument
type expression.  The result is the set of all values which are types
where the type of each value must be a subset of the argument type.

Note that unlike with all other type expressions, with type type
expressions it's not guaranteed that the implementation will be able
to decide if a given value is in a type formed by evaluating a type
type expression.  In fact, since Salmon allows types to be formed with
arbitrary filter functions, it's undecidable in general whether a
given value is in a given type formed by evaluating a type type
expression.  The problem is that if X is a type formed from a type
type expression with Y as its base, deciding whether the value that is
the type Z is in X is equivalent to deciding whether type Z is a
subset of type Y, where Y and Z can be any types at all.  If Y and Z
are formed by arbitrary filter functions, this problem is
undecidable.  So using type type expressions is dangerous.

It's left implementation-defined in which cases it can be deterimined
whether a given type value is in a given type formed by a type type
expression.  There are many basic cases that most implementations can
be expected to be able to handle.  If at run time the implementation
can't decide when its checking types (for example when setting a
variable or checking a function return value's type), an exception
occurs.

So this combination of allowing type type expressions and allowing
types formed by user-defined filter functions opens up a significant
hole in Salmon.  To deal with this issue, a decent compiler should be
able to give a warning if it's possible for this to happen, and the
programmer should be able to add proof information to convince the
compiler that type checking will always succeed.  Since the static
type checking model requires one to be somewhat conservative to prove
that all dynamic type checks will succeed, this really isn't an issue
when using a static type checking model.  It's more of an issue when
leaving type checking for run time, because in that case the behavior
can vary from one implementation of Salmon to another.  Very little
else in Salmon is left implementation-defined, so it's unfortunate
that this hole remains, but it's allowed for the sake of the benefits
of types formed by user-defined filter functions (which allows
arbitrary extension of the type system) and type type expressions.

Another way to avoid leaving this implementation-defined would be to
set out a subset of forms of type type expressions and types that are
guaranteed to work and make all others illegal.  But this would limit
all implementations.  Instead, implementations are allowed to be as
useful as they can be in allowing type type expressions.

EXAMPLES:

  * type !{} is a type expression evaluating to the type consisting of
    all values that are themselves types.

  * type [12...17] is a type expression evaluating to the type
    consisting of all values that are types that are subsets of the
    type [12...17].  So the value consisting of the type {12, 15} is
    in this type because {12, 15} is a subset of [12...17], but the
    value consisting of the type {12, 18} is not in this type because
    the value 18 is in {12, 18} but not [12...17].


    Section 5.4.12: Map Type Expressions
    ------------------------------------

    <map-type-expression> :
        <type-expression> "-->" <type-expression>

A map type expression specifies a type consisting of maps with keys
and elements of specified types.

Evaluating a map type expression starts with evaluating its two
argument type expressions.  The left-hand argument type expression
evaluates to the key type and the right-hand argument type expression
evaluates to the element type.  The result type is the type consisting
of all map values where all the keys are in the key type and all the
elements are in the result type.

Note that all array type expressions have equivalent map type
expressions:

  * The type expression ``array'' is equivalent to
    ``integer --> !{}'', where ``integer'' is the standard library
    immutable specifying the type containing all integers.

  * For any type expression TTT, ``array[TTT]'' is equivalent to
    ``integer --> TTT''.

  * For any type expression TTT and expression XXX, ``TTT[XXX]'' is
    equivalent to ``[0...((XXX) - 1)] --> TTT''.

  * For any type expression TTT and expressions XXX and YYY,
    ``TTT[XXX...YYY]'' is equivalent to ``[XXX...YYY] --> TTT''.

EXAMPLE:

  * {"snow", "wind"} --> {1, 4, 17} is a type expression evaluating to
    the set of all map values whose keys are all either the string
    "snow" or the string "wind" and whose elements are all one of 1,
    4, or 17.


    Section 5.4.13: Routine Type Expressions
    ----------------------------------------

    <routine-type-expression> :
        <type-expression> "<--" "(" <formal-type-list> ")"

    <formal-type-list> :
        <empty> |
        <non-empty-formal-type-list>

    <non-empty-formal-type-list> :
        "..." |
        "*" |
        <formal-type> |
        <formal-type> "," <non-empty-formal-type-list>

    <formal-type> :
        { <identifier> ":" }? <type-expression> { ":=" "*" }?

A routine type expression specifies a type that consists of routine
values, with limits specified on the types of arguments and the return
value, if any.

Evaluating a routine expression begins with evaluating the type
expression of its first argument and all the type expressions in the
formal types of its formal type list argument.  The first argument is
the return type.  The types in the formal type list specify argument
types.

The return type specifies that the value returned by the routine must
be in that type.  The type consisting of no values as a return type
specifies that the routine does not ever return a value and must be
used as a procedure.

The formal list specifies a list of argument types that the routine
must take.  The routine must take arguments of the specified types in
the order specified.  Further, each formal that has an identifier
attached specifies that the routine must have a formal parameter of
that name in that position.  If the identifier is left off, there is
no limitation on the formal parameter name for that position of the
routine.  Formal parameter names may be specified in the type to allow
type checking to work when calls are of the form that use formal names
to bind actual arguments at the call site.  Even further, if the
optional ``:= *'' suffix is applied to a particular formal, than the
routine is required to have a default value for that parameter.
Again, this may be specified in the type because it affects what is
allowed at a call site, though what the default value is does not
affect what is allowed at a call site, just whether or not there is a
default value for a particular formal parameter.

Further, if "..." appears in the formal list, that specifies that in
addition to the specified parameters, if any, the routine must accept
any number and combination of additional unnamed arguments beyond
those specified.  If "*" appears in the formal list, that specifies
that there is no limitation on what requirements the routine may place
on additional arguments, if any, beyond those explicitly listed for
the type.  If neither "..." nor "*" appears in the formal list, then
the routine must accept argument lists that only include the specified
arguments.

EXAMPLES:

  * {} <-- () is a type expression evaluating to the set of all values
    that are routines that never return values and may be called with
    an empty parameter list.

  * {18, 37, 41} <-- ({17, 18, 19}, {53}) is a type expression
    evaluating to the set of all values that are routines that always
    return one of the values 18, 37, or 41 and can be used with the
    actual argument combinations (17, 53), (18, 53), and (19, 53).

  * {18, 37, 41} <-- ({17, 18, 19}, b := {53}) is a type expression
    evaluating to the set of all values that are routines that always
    return one of the values 18, 37, or 41 and can be used with any
    two-argument calls where the first is the value 17, 18, or 19 and
    the second is the value 53 and the second argument can be
    specified with either the name ``b'' or with no name.


    Section 5.4.14: Fields Type Expressions
    ---------------------------------------

    <fields-type-expression> :
        "fields" "[" <field-type-list> "]"

    <field-type-list> :
        <empty> |
        <non-empty-field-type-list>

    <non-empty-field-type-list> :
        "..." |
        <field-type> |
        <field-type> "," <non-empty-field-type-list>

    <field-type> :
        <identifier> ":" <type-expression>

A fields type expression specifies a type consisting of semi-labeled
value lists, semi-labeled multi-sets, leptons, and objects in which
particular named fields are required to exist and have values in
specified types.

Evaluating a fields type expression starts with evaluating the types
in the field type list.  Each such type is associated with an
identifier giving the name of the field being specified.  It is
illegal for the same identifier to appear more than once in the same
field type list.  The resulting type is the set of all semi-labeled
value lists, semi-labeled multi-sets, leptons, and objects which have
all the named fields and for which the value in each of the named
fields is in the corresponding type.  Further, if "..." appears in the
fields list then the value is allowed to have other fields and/or
unnamed elements, but if "..." does not appear then the value is not
allowed to have any elements other than the fields named by the field
type list.

Note that fields type expressions are normally used for pointer type
expressions or parameter type expressions, to make sure that
particular fields will exist that are going to be read, or, in the
case of pointers used for writing, that particular fields will exist
and are allowed to be set to a given range of values.  For those
purposes, we don't care whether the value is a semi-labeled value
list, semi-labeled multi-set, lepton, or object, we just care that we
can read or write a particular field.  For variables, instead of a
fields type expression, a lepton, multiset, semi-labeled value list,
or named type expression refering to a class would normally be used.

EXAMPLES:

  * fields[a : {17, 19, 20}, b : {23, 27}] is a type expression
    evaluating to the set of all semi-labeled value lists,
    semi-labeled multi-sets, and leptons containing exactly two
    fields, named ``a'' and ``b'', with the value of field ``a'' being
    one of 17, 19, and 20 and the value of field ``b'' being 23 or 27.

  * fields[a : {17, 19, 20}, b : {23, 27}, ...] is a type expression
    evaluating to the set of all semi-labeled value lists,
    semi-labeled multi-sets, and leptons containing at least two
    fields, named ``a'' and ``b'', with the value of field ``a'' being
    one of 17, 19, and 20 and the value of field ``b'' being 23 or
    27.


    Section 5.4.15: Lepton Type Expressions
    ---------------------------------------

    <lepton-type-expression> :
        "lepton" <expression> "[" <field-type-list> "]"

A lepton type expression specifies a type consisting of leptons in
which particular named fields, if they exist, are required to have
values in specified types.

A lepton type expression differs from a fields type expression in two
ways.  First of all, semi-labeled value lists, semi-labeled
multi-sets, and objects are disallowed and leptons are required to
have a particular specified lepton key.  Secondly, the named fields
are not required to exist in the value.  It is only if they exist that
they are required to have the specified types.

Evaluating a lepton type expression starts with evaluating the
expression parameter.  This expression must evaluate to a lepton key
or an exception occurs.  Next, the type expressions in the field type
list are evaluated.  Each such type is associated with an identifier
giving the name of the field being specified.  It is illegal for the
same identifier to appear more than once in the same field type list.
The resulting type is the set of all leptons for which each of the
named fields is either undefined or has a value in the corresponding
type.  Further, if "..." appears in the fields list then the value is
allowed to have other fields, but if "..." does not appear then the
value is not allowed to have any elements other than the fields named
by the field type list.

Note that the BNF for a lepton type expression is ambiguous.  This
ambiguity is resolved by the rule that the expression that comes after
the "lepton" keyword is parsed as if it were the expression after the
".." of a tagalong field reference expression.  So, for example, to
use a lookup expression as the base of a lepton type expression would
require parentheses around the lookup expression.

EXAMPLES:

  * lepton v[a : {17, 19, 20}, b : {23, 27}] is a type expression
    evaluating to the set of all leptons with v as their key and
    containing no more than two fields, named ``a'' and ``b'', with
    the value of field ``a'' being undefined or one of 17, 19, and 20
    and the value of field ``b'' being undefined or one of 23 or 27.

  * lepton v[a : {17, 19, 20}, b : {23, 27}, ...] is a type expression
    evaluating to the set of all leptons with v as their key and, if
    they contain a field named ``a'' then the value of that field is
    one of 17, 19, or 20 and if they contain a field named ``b'' then
    the value of that field is one of 23 or 27.


    Section 5.4.16: Multiset Type Expressions
    -----------------------------------------

    <multiset-type-expression> :
        "multiset" "[" <field-type-list> "]"

A multiset type expression specifies a type consisting of semi-labeled
multi-sets in which particular named fields, if they exist, are
required to have values in specified types.

A multiset type expression differs from a fields type expression in
two ways.  First of all, semi-labeled value lists, leptons, and
objects are disallowed.  Secondly, the named fields are not required
to exist in the value.  It is only if they exist that they are
required to have the specified types.

Evaluating a multiset type expression starts with evaluating the type
expressions in the field type list.  Each such type is associated with
an identifier giving the name of the field being specified.  It is
illegal for the same identifier to appear more than once in the same
field type list.  The resulting type is the set of all semi-labeled
multi-set values for which each of the named fields is either
undefined or has a value in the corresponding type.  Further, if "..."
appears in the fields list then the value is allowed to have other
fields, but if "..." does not appear then the value is not allowed to
have any elements other than the fields named by the field type list.

EXAMPLES:

  * multiset[a : {17, 19, 20}, b : {23, 27}] is a type expression
    evaluating to the set of all semi-labeled multi-sets containing no
    more than two fields, named ``a'' and ``b'', with the value of
    field ``a'' being undefined or one of 17, 19, and 20 and the value
    of field ``b'' being undefined or one of 23 or 27.

  * multiset[a : {17, 19, 20}, b : {23, 27}, ...] is a type expression
    evaluating to the set of all semi-labeled multi-sets that if they
    contain a field named ``a'' then the value of that field is one of
    17, 19, or 20 and if they contain a field named ``b'' then the
    value of that field is one of 23 or 27.


    Section 5.4.17: Interface Type Expressions
    ------------------------------------------

    <interface-type-expression> :
        "interface" { "." }? "[" <interface-item-list> "]"

    <interface-item-list> :
        <empty> |
        <non-empty-interface-item-list>

    <non-empty-interface-item-list> :
        <interface-item> |
        <interface-item> "," <non-empty-interface-item-list>

    <interface-item> :
        <identifier> ":" { "-" }? <type-expression> |
        "include" <string-literal-token>

An interface type expression specifies a set of values on which
particular pointer field reference expressions may be used.  The
values allowed are slot locations that can only contain semi-labeled
value lists, semi-labeled multi-sets, leptons, or objects.  As with
pointer types, an optional dot is used to specify that null is also
allowed in addition to the other values allowed for this type.

Note that include items are allowed in the interface item list.  Each
<interface-item> that is the token "include" followed by a string
literal specifies that additional interface items are to be included
from some external source.  The string literal specifies the external
source, but the meaning of that string is up to the implementation,
just as with include statements.  In a typical implementation this is
expected to give access to text files in the standard system file
structure.  The included file must consist of an
<interface-item-list>, and the items in that list are included as if
they appeared directly in the list with the include.  Note that
included files can themselves include other files and included files
can also be empty.  Files included this way are called Salmon
Interface files.  The file name extension ".si" is suggested for such
files.

Evaluating an interface type expression starts with evaluating the
type expressions of all the items in its interface item list.  Each is
associated with a field name.  The optional ``-'' part of the
interface item means that the specified field is only guaranteed to be
available for reading, not for writing.

Values in the resulting type that are pointers must point to slots
that always have values whose fields, if defined, have the specified
field types.  Those items without the optional ``-'' part specify that
the slots must allow all values of the corresponding type to be
written to that field.  Those items with the optional ``-'' allow
values in the slot that are objects with ``immutable'' fields of the
specified name or methods of the specified name, but when the optional
``-'' is not specified, objects with ``immutable'' fields or methods
with the specified field name are not allowed.

EXAMPLE:

  * immutable t := interface[p :- {} <-- ({3, 5, 7}) ];
    class a(x)
      {
        p(a : [1...10])
          {
            print(x, a);
          };
      };
    procedure b(a : [2...8])
      {
        print(a);
      };
    lepton v[p : {} <-- ([2...8])];
    variable y : a := a("Value: ");
    variable z : v := v[p := b];

    In this example, both &y and &z are in t.  In one case, the ``p''
    of the interface binds to a field in a lepton and in the other it
    binds to a method in an object.


    Section 5.4.18: Semi-Labeled Value List Type Expressions
    --------------------------------------------------------

    <semi-labeled-value-list-type-expression> :
        "[" <formal-type-list> "]"

A semi-labeled value list type expression specifies a type containing
only semi-labeled value lists in a particular form.

The optional ``:= *'' on elements of a formal type list is not allowed
for the formal type list of a semi-labeled value list type
expression.  Neither is the ``*'' at the end of the list.

Evaluating a semi-labeled value list type expression begins with
evaluating all the type expressions in the formal types of its formal
type list argument.  The types in the formal type list specify element
types.

The formal list specifies a list of element types that the
semi-labeled value lists must have.  If there are <n> items in the
list, then the semi-labeled value list must have at least <n> items
and its first <n> items must match the correponding items in the
semi-labeled value list type expression, and in the same order.
Further, each formal that has an identifier attached specifies that
the semi-labeled value list must also have a tag attached to the
element in the same position, and that that tag must be the same as
the identifier specified for the type.  If the identifier is left off,
then the corresponding position in the semi-labeled value list is
allowed to either have or not have a tag.

Further, if "..." appears in the formal list, that specifies that in
addition to the specified elements, if any, the semi-labeled value
list may have any number of additional elements beyond those
specified.  If "..." does not appear in the formal list, then the
semi-labeled value list must not have any more elements than those
specified in the semi-labeled value list type expression.

EXAMPLES:

  * [...] is a type expression evaluating to the set of all
    semi-labeled value lists.

  * [{17, 18, 19}, {53}] is a type expression evaluating to the set of
    all values that are semi-labeled value lists with exactly two
    elements, with the first element as 17, 18, or 19 and the second
    as 53.

  * [{17, 18, 19}, b := {53}] is a type expression evaluating to the
    set of all values that are semi-labeled value lists with exactly
    two elements, with the first element as 17, 18, or 19 and the
    second with the label ``b'' and with the value 53.

  * [{17, 18, 19}, b := {53}, ...] is a type expression evaluating to
    the set of all values that are semi-labeled value lists with at
    least two elements, with the first element as 17, 18, or 19 and
    the second with the label ``b'' and with the value 53.


    Section 5.4.19: Regular Expression Type Expressions
    ---------------------------------------------------

    <regular-expression-type-expression> :
        <regular-expression-literal-token>

A regular expression type expression evaluates to the set of all
string values that contain a match with the specified regular
expression.

EXAMPLE:

  * @hi|low@ is a type expression evaluating to the set of all strings
    containing the sub-string "hi" or the sub-string "low".


    Section 5.4.20: Lazy Type Expressions
    -------------------------------------

    <lazy-type-expression> :
        "lazy" <identifier>

A lazy type expression is used to delay evaluation of an identifier
used to specify a type within a type.  This is useful for recursively
defining types, either using direct or mutual recursion.

In a lazy type expression, the identifier must be bound to either a
variable name or a lepton key name.  If it is bound to a variable
name, that variable must be immutable.  Unlike when a name is directly
used as a type expression, when a name is used in a lazy type
expression, the type is not evaluated at the time the type expression
is evaluated.  So it's OK for the immutable or lepton key declaration
not to have been executed at the time the type expression is
evaluated.  What is required is that at the time the resulting type is
evaluated the name refers to something that has been declared.  If
it's an immutable, then the immutable declaration needs to have been
executed and the value in the immutable must be a type value.  In this
case, a value is in the lazy type expression if it is in the type
which is the value of the immutable.  If the name refers to a lepton
key, then at the time the lazy type is used, the lepton key must have
had its declaration executed.  A value is in the type if and only if
it is a lepton with the specified key.

Note that lazy type expressions don't provide any additional
expressive power in the type system because the same functionality can
be obtained using an expression type expression evaluating to a pure
function to specify a filter function.  Specifically, the type
expression

    lazy XXX

is equivalent to

    <<pure function(x) returns boolean  { return (x in XXX); }>>

Lazy type expressions make this particular idiom much more terse,
however, which is why they are provided in Salmon.

EXAMPLE:

  * immutable aaa := interface
      [
        b : *.bbb;
      ];
    immutable bbb := interface
      [
        a : *.aaa;
      ];

    declares two interface types, aaa and bbb, each of which has a
    field containing a pointer to the other.


    Section 5.5: Declarations
    -------------------------

Declarations are templates for things that are created at runtime.
They can appear either as expressions, where they are not named, or as
statements, where they are named.

The things created based on the templates of declarations are called
instances.  For example, variable instances are created from variable
declarations.

For declarations that occur as statements, when the scope of that
statement is entered, instances are allocated for all the non-static
declarations in that scope.  Then, when the non-static declaration
statement is executed, the instance is instantiated.  When the scope
exits, the instance is de-allocated unless it is declared "ageless".
If it is declared "ageless", the instance is de-allocated when the
last refrerence to it disappears if garbage collection is being used
or when the standard library delete() procedure is called on it.

For static declarations that occur as statements, allocation and
de-allocation occur differently.  If a static declaration statement
appears within the body of a routine, then it is allocated and
instantiated when the nearest enclosing routine itself is
instantiated.  When the routine is de-allocated, the instance for the
static declaration is de-allocated unless it was declared "ageless".
When the routine is being allocated, all static declarations are first
allocated, then they are instantiated in the order that they appear in
the code.

For static declarations that occur outside of all routines, they are
all allocated at the start of program execution, then they are
instantiated in the order they appear in the code.  Only after they
have all been instantiated does program execution commence with the
execution of the top-level statement block.

Executing a static declaration statement has no effect.

All binding of references from static declarations takes place in the
context in which the declarations are instantiated.  So for static
declarations that are within routines the binding takes place at the
level of the routine declaration itself.  That is, binding of
references from within the static declaration can't see non-static
things in the body of the routine.  Binding is what determines what
name references; break, continue, and return statements; and
arguments, break, and continue expressions refer to.  So, for example,
a reference to "x" in the initializer to a static variable declaration
would not bind to any non-static declarations within the routine, but
would bind to any "x" in the scope enclosing the routine declaration.
They can also bind to any static declarations in the same scope within
the routine or outer scopes within the routine.  For static
declarations not enclosed within any routine, only other static
declarations not enclosed within any routine are visible for purposes
of binding.

Note that it's legal to have a static declaration within a static
routine within another static routine within another static routine.
In that case, all the static declarations would be instantiated when
the outermost routine declaration was instantiated.

For declarations that occur as expressions, when the expression is
evaluated, an instance is allocated and immediately instantiated.  The
instance is de-allocated when the last reference to it disappears if
garbage collection is being used or when the standard library delete()
procedure is called on it.


    Section 5.5.1: Data Declarations
    --------------------------------

    <named-data-declaration> :
        <data-prefix> <data-keyword> <data-declaration-item-list>

    <data-declaration-item-list> :
        <data-declaration-item> |
        <data-declaration-item> "," <data-declaration-item-list>

    <data-declaration-item> :
        <identifier> <anonymous-data-declaration>

    <unnamed-data-declaration> :
        <data-prefix> <data-keyword> <anonymous-data-declaration>

    <data-prefix> :
        "static" <data-prefix> |
        "ageless" <data-prefix> |
        "virtual" <data-prefix> |
        <single-prefix> <data-prefix> |
        <empty>

    <data-keyword> :
        "variable" |
        "immutable"

    <anonymous-data-declaration> :
        { ":" <type-expression> }? { { ":=" | "::=" } <expression> }?

@@@


    Section 5.5.2: Routine Declarations
    -----------------------------------

    <named-routine-declaration> :
        <routine-prefix> <routine-keyword>
                <routine-declaration-item-list>

    <routine-declaration-item-list> :
        <routine-declaration-item> |
        <routine-declaration-item> "," <routine-declaration-item-list>

    <routine-declaration-item> :
        <identifier> <anonymous-routine-declaration>

    <unnamed-routine-declaration> :
        <routine-prefix> <routine-keyword>
                <anonymous-routine-declaration>

    <routine-prefix> :
        "static" <routine-prefix> |
        "ageless" <routine-prefix> |
        "virtual" <routine-prefix> |
        <single-prefix> <routine-prefix> |
        "pure" <routine-prefix> |
        <empty>

    <routine-keyword> :
        "routine" |
        "function" |
        "procedure" |
        "class"

    <anonymous-routine-declaration> :
        "(" <formal-argument-list> ")"
                { "returns" <type-expression>
                  { "/" <type-expression> }? }? <routine-body>

    <routine-body> :
        <braced-statement-block> |
        "(" <expression> ")" |
        ":=" <alternate-body>

    <alternate-body> :
        "null" | <implementation-specific-alternate-body>

    <formal-argument-list> :
        <empty> |
        <non-empty-formal-argument-list>

    <non-empty-formal-argument-list> :
        "..." |
        <formal-argument> |
        <formal-argument> "," <non-empty-formal-argument-list>

    <formal-argument> :
        <data-prefix> <identifier>
                { ":" <type-expression> { "/" <type-expression> }? }?
                { { ":=" | "::=" } <expression> }?

@@@

The "pure" modifier on a routine declaration specifies that the
routine is forbidden to have side effects and must do exactly the same
thing every time it is called.  This applies even if other routines,
including routines not declared pure, are called from within the pure
routine.  The pure routine is never allowed to have side effects or
change its behavior based on state outside itself.  It may, however,
read state from outside itself as long as that state is guaranteed not
to be changeable.  A pure routine may also cause control flow to jump
outside itself, either through throwing an exception or in some other
way.  It may return a value some times that it is called and throw an
exception at other times if the outside state it uses becomes invalid,
but any time it returns a value, it must do exactly the same thing.

The rules for pure routines use the concept of an execution purity
level.  Outside all calls to pure routines, the execution purity level
is zero.  When a call to a pure routine is started, the execution
purity level is incremented, and when the call to the pure routine is
complete, the execution purity level is decremented.  So if A() calls
B() calls C() and all three are pure functions, the execution purity
level within C() is 3.

Each instance of a declaration and each object also has an associated
purity level.  When the instance is allocated or the object created,
the purity level of that instance or object is the current execution
purity level.  When a pure call finishes and the execution purity
level decrements, the purity level of all instances and objects that
were at the old execution purity level are also decremented.  So the
maximum purity level of any instance or object at any given time is
the current execution purity level.  Within a pure call, the only
instances and objects that can have a purity level equal to the
current execution purity level are those that were allocated after all
the currently executing pure calls began.

With this concept of purity level, we can define the rules for pure
routine calls.  When one of the rules is violated, it is called a
purity violation, and the purity violation has a purity level lower
than the current execution purity level.  When a purity violation
happens, an exception occurs, but the way the exception is handled is
different from normal.  All try-catch and try-handle blocks executing
with a purity level greater than the purity violation's purity level
are ignored when doing exception handling.  This prevents code within
a pure function from using exception handling to do things differently
based on whether outside state is valid.

Here are the rules that enforce the "pure" modifier on routines:

  * When the current execution purity level is greater than zero, if a
    built-in routine is called which may have external side-effects or
    read the state of the world outside the program, a purity
    violation occurs with level zero.

  * If an attempt is made to read or write a non-immutable variable
    with a purity level lower than the current execution purity level,
    a purity violation occurs with level equal to that of the
    variable.

  * If an attempt is made to delete an instance or object with a
    purity level lower than the current execution purity level, a
    purity violation occurs with level equal to that of the instance
    or object.

  * If an attempt is made to use an instance or object with a purity
    level lower than the current execution purity level and that
    instance or object has not yet been instantiated or has been
    deleted, a purity violation occurs with level equal to that of the
    instance or object.

  * If an attempt is made to read or set a tagalong field on an object
    with a lower purity level than the current execution purity level,
    a purity violation occurs with level equal to that of the object.

Note that a static declaration is instantiated outside of any calls to
the routine it is in, so it would have a lower purity level than the
routine it was in if the routine was pure.  So a static variable in a
pure function could not be used.  A static immutable, however, could
be used, though its contents could, of course, hold something that
couldn't be used, such as a pointer to an outside variable.

Note also that a pointer to a variable of lower purity level could not
be read from or written to, but the pointer itself could be passed
around and put in data structures.  Also, a pure function may allocate
variables, procedures, etc, and pass back references to the instances
it created in its return value.  For example, a pure function could
take a string as an argument, parse that string into a parse tree for
a programming language, and pass back the whole parse tree as a return
value.

If <alternate-body> is "null", then the routine must have the
"virtual" tag and not the "static" tag, and it is considered a pure
virtual routine.  The class that uses such a pure virtual routine is
only allowed to be instantiated in a "use" statement that overrides
that name so there is an actual body provided for the routine.

Note that <implementation-specific-alternate-body> is not defined
here.  It is up to each implementation to define its own alternate
body formats, or allow none.  This is intended to allow routines to be
called that are defined elsewhere, such as in machine code in a
dynamically-linked library or in some other programming language.
Each format that an implementation allows should start with an
identifier token that determines the format being used.  The idea is
that if different implementation allow incompatible formats to be
used, they will use different identifiers so the two will not be
confused, but different implementations can share the same formats by
using the same identifiers to allow them to be recognized.

@@@


    Section 5.5.3: Tagalong Declarations
    ------------------------------------

    <named-tagalong-declaration> :
        <data-prefix> "tagalong" <tagalong-declaration-item-list>

    <tagalong-declaration-item-list> :
        <tagalong-declaration-item> |
        <tagalong-declaration-item> "," <tagalong-declaration-item-list>

    <tagalong-declaration-item> :
        <identifier> <anonymous-data-declaration>
                { "on" { "object" }? <type-expression> }?

    <unnamed-tagalong-declaration> :
        <data-prefix> "tagalong" <anonymous-data-declaration>
                { "on" { "object" }? <type-expression> }?

A tagalong declaration can have more that one item in its declaration
item list.  Each item will have its own instance.  The modifiers in
the <data-prefix> apply to all the instances.

Executing the tagalong declaration starts with executing the
<data-prefix>, which is executed just as it is for a data
declaration.  Then, each item in the <tagalong-declaration-item-list>
is executed.  They are executed in the order they appear from left to
right in the list.

Executing a <tagalong-declaration-item> starts with evaluating the
type expression from the <anonymous-data-declaration> if it is
present.  If this type expression is present, evaluating it yields the
tagalong base type.  If this type expression is not present, the
tagalong base type is the type of all values.

Next, if the anonymous data declaration has an expression, it is
evaluated to give the default value of the tagalong.  If it is not
present, there is no default value.  If the expression is present and
the "::=" token preceeds it instead of the ":=" token, then the type
forcing operation is performed on the default value with the tagalong
base type as the type.  If this fails to yield a value, an exception
occurs.  If the ":=" token was used instead, then a check is done to
see if the default value is in the tagalong base type, and if it is
not, an exception occurs.

After that, if the "on" clause is used, the type expression from that
clause is evaluated to get the on type.  If the "on" clause is not
used, the on type is the type of all values.

At this point, the tagalong key instance is instantiated with the
tagalong base type, default value, and on type attached.  The tagalong
base type specifies what values are allowed to be associated by this
tagalong key.  The default value specifies what value, if any, will be
read when looking up the value for a tagalong key on a value for which
that key has not been set.  And the on type specifies which values are
allowed to have values attached to them with this tagalong key.

The optional "object" modifier specifies that the tagalong is to be
associated with objects, not values.  If this is used, then the
tagalong key may only be used on object values and when a tagalong
value is set for a key on an object value, it means this value applies
to all values for this object, not just the particular value to which
it was applied.

Executing an <unnamed-tagalong-declaration> constists of first
executing the <data-prefix> and then executing the part after the
"tagalong" keyword as if it were a <tagalong-declaration-item>.

To aid readability, there is an additional syntax rule beyond what the
BNF requires: if the optional "on" clause is present but the optional
"object" keyword is not used, then the type expression of the "on"
clause may not begin with the identifier token "object".

EXAMPLE:

  * class c1() { };
    tagalong t1 : integer := 2 on c1;
    tagalong t2 : integer := 2 on object c1;
    variable v1 := c1();
    ([t1 := v1..t1, t2 := v1..t2])!
    v1..t1 := 3;
    v1..t2 := 4;
    ([t1 := v1..t1, t2 := v1..t2])!
    variable v2 := v1;
    ([t1 := v2..t1, t2 := v2..t2])!
    v2..t1 := 5;
    v2..t2 := 6;
    ([t1 := v1..t1, t2 := v1..t2])!
    ([t1 := v2..t1, t2 := v2..t2])!

    is a statement list that prints:

        [t1 := 2, t2 := 2]
        [t1 := 3, t2 := 4]
        [t1 := 3, t2 := 4]
        [t1 := 3, t2 := 6]
        [t1 := 5, t2 := 6]

    when executed.


    Section 5.5.4: Lepton Declarations
    ----------------------------------

    <named-lepton-declaration> :
        <lepton-prefix> "lepton" <lepton-declaration-item-list>

    <lepton-declaration-item-list> :
        <lepton-declaration-item> |
        <lepton-declaration-item> "," <lepton-declaration-item-list>

    <lepton-declaration-item> :
        <identifier> { "[" <lepton-field-list> "]" }?

    <unnamed-lepton-declaration> :
        <lepton-prefix> "lepton" { "[" <lepton-field-list> "]" }?

    <lepton-prefix> :
        "static" <lepton-prefix> |
        "ageless" <lepton-prefix> |
        "virtual" <lepton-prefix> |
        <empty>

    <lepton-field-list> :
        <empty> |
        <non-empty-lepton-field-list>

    <non-empty-lepton-field-list>
        "..." |
        <lepton-field-item> |
        <lepton-field-item> "," <non-empty-lepton-field-list>

    <lepton-field-item> :
        <identifier> { ":" <type-expression> }?

@@@


    Section 5.5.5: Quark Declarations
    ---------------------------------

    <named-quark-declaration> :
        <quark-prefix> "quark" <quark-declaration-item-list>

    <quark-declaration-item-list> :
        <quark-declaration-item> |
        <quark-declaration-item> "," <quark-declaration-item-list>

    <quark-declaration-item> :
        <identifier>

    <unnamed-quark-declaration> :
        <quark-prefix> "quark"

    <quark-prefix> :
        "static" <quark-prefix> |
        "ageless" <quark-prefix> |
        "virtual" <quark-prefix> |
        <empty>

@@@


    Section 5.5.6: Lock Declarations
    --------------------------------

    <named-lock-declaration> :
        <data-prefix> "lock" <lock-declaration-item-list>

    <lock-declaration-item-list> :
        <lock-declaration-item> |
        <lock-declaration-item> "," <lock-declaration-item-list>

    <lock-declaration-item> :
        <identifier>

    <unnamed-lock-declaration> :
        <data-prefix> "lock"

@@@


    Section 5.6: Proof Items
    ------------------------

    <proof-item> :
        <expression> { <reason> }? ";"

    <reason> :
        To Be Determined

A proof item is a step in a proof.  It consists of an expression that
is expected to always evaluate to true at that point in the program
and optionally a reason why.  The reason why can be left off if the
developer believes it is easy to see why the expression's truth
follows from earlier steps in the proof or for some other reason.  If
the developer thinks either an automated theorem checker or a human
reader would not be able to see why the expression must be true, the
developer can provide a reason.

The details of reasons have not yet been fleshed out.  They are left
to a future version of this document.


        Chapter 6: Standard Library
        ===========================


    Section 6.1: Core
    -----------------

There is a set of library routines and globals that is considered a
standard library for Salmon.  There may be some implementations of
Salmon for special purposes that don't include the standard library,
but in most cases the standard library should be available.

Here is what's available in the standard library:

  * immutable u8 := type [0 ... (1 << 8));
  * immutable u16 := type [0 ... (1 << 16));
  * immutable u32 := type [0 ... (1 << 32));
  * immutable u64 := type [0 ... (1 << 64));
  * immutable u128 := type [0 ... (1 << 128));

These five types represent what can fit in an 8-, 16-, 32-, 64-, and
128-bit unsigned integer, respectively.  If you want to work with
types that correspond to various external types -- hardware types,
types used in external file formats, types used in networking
protocols, types used by external programs or libraries, etc. -- you
might want to use one or more of these.

  * immutable s8 := type [(-(1 << 7)) ... (1 << 7));
  * immutable s16 := type [(-(1 << 15)) ... (1 << 15));
  * immutable s32 := type [(-(1 << 31)) ... (1 << 31));
  * immutable s64 := type [(-(1 << 63)) ... (1 << 63));
  * immutable s128 := type [(-(1 << 127)) ... (( << 127));

These five types represent what can fit in an 8-, 16-, 32-, 64-, and
128-bit signed two's complement integer, respectively.  These types
might be useful in the same kinds of situations that the u8, u16, u32,
u64, and u128 types might be useful.

  * immutable integer;

This type is the type consisting of all integer values, including the
special non-finite integer values.

  * immutable rational;

This type is the type consisting of all rational values, including
integers.

  * immutable string;

This type is the type consisting of all string values.

  * immutable boolean := type { true, false };

This gives a name to the type consisting of the values true and false.

  * immutable character;

This type is the type consisting of all character values.

  * immutable regular_expression;

This type consists of all regular expression values.

  * immutable any_quark;

This type consists of all quark values;

  * immutable any_lepton;

This type consists of all lepton values;

  * immutable lepton_key;

This type consists of all lepton key values;

  * immutable jump_target;

This type consists of all jump target values;

  * immutable any_class;

This type consists of all class values;

  * immutable object;

This type consists of all object values;

  * immutable tagalong_key;

This type consists of all tagalong key values;

  * immutable any_lock;

This type consists of all lock values;

  * immutable null;

This gives a name to the null value.

  * immutable true;
  * immutable false;

This gives names to the true and false values.

  * immutable negative_infinity := -oo;
  * immutable positive_infinity := +oo;
  * immutable unsigned_infinity := 1/0;
  * immutable zero_zero := 0/0;

These four give names to the special non-finite integer values.

  * function characters(: string) returns array[character];

This function converts from a string to an array of characters with
the characters of the string in the same order.

  * function make_string(: array[character]) returns string;

This function converts from an array of characters to a string with
the same characters in the same order.

  * immutable unicode_code_point :=
            type [0 ... 0xd7ff] | [0xe000 ... 0x10ffff];

This type specifies the range of legal values for Unicode code points.

  * function from_utf8(: u8[4]) returns character;
  * function from_utf16(: u16[2]) returns character;
  * function from_utf32(: unicode_code_point) returns character;
  * function to_utf8(: character) returns u8[4];
  * function to_utf16(: character) returns u16[2];
  * function to_utf32(: character) returns unicode_code_point;

These six functions convert between characters and their UTF-8,
UTF-16, or UTF-32 representations.  The from_*() functions convert
from the UTF-* representation to a character while the to_*()
functions convert the other way.  The UTF-8 representation of a
character requires from 1 to 4 8-bit integer values, which is why an
array of 4 u8 values is used.  If a particular character doesn't
require all four u8's, the array might be shorter than 4 elements.

  * function string_from_utf8(: array[u8]) returns string;
  * function string_from_utf16(: array[u16]) returns string;
  * function string_from_utf32(: array[unicode_code_point]) returns
            string;
  * function to_utf8(: string) returns array[u8];
  * function to_utf16(: string) returns array[u16];
  * function to_utf32(: string) returns array[unicode_code_point];

These six functions convert between strings and sequences of bits in
UTF-8, UTF-16, or UTF-32 formats.

  * procedure delete(: (*!{}) | ((!{}) <-- (*)) | tagalong_key |
                       lepton_key | any_quark | any_lock | object);

This procedure takes a reference to anything dynamically allocated and
de-allocates it.  If the argument is a pointer, it must be the
location of a variable instance that was created by a new expression
or by a declaration statement with an ``ageless'' modifer.  If the
argument is a routine, it must be a routine that was created by a
routine declaration expression or by a declaration statement with an
``ageless'' modifier.  If the argument is a tagalong key, it must be
one that was created by a tagalong declaration expression or by a
declaration statement with an ``ageless'' modifier.  If the argument
is a lepton key, it must be one that was created by a lepton
declaration expression or by a declaration statement with an
``ageless'' modifier.  If the argument is a quark, it must be one that
was created by a quark declaration expression or by a declaration
statement with an ``ageless'' modifier.  If the argument is a lock, it
must be one that was created by a lock declaration expression or by a
declaration statement with an ``ageless'' modifier.  If the argument
is an object, that object is deleted and it's illegal to use that
object in the future.

  * function matches(: regular_expression, : string) returns boolean;

This function tests to see whether any part of a given string matches
a given regular expression.

  * function split(: regular_expression, : string) returns
            array[string];

This function finds all matches of the given regular expression in the
given string, removes the matching text, and splits up the remaining
string into the sections between the matches.  Those remaining
sections are put in the result array.

For example, split(@\n@, mystring) splits mystring into lines.  As
another example, split(@,@, "aaa,bbb,ccc") returns the array
["aaa", "bbb", "ccc"].

  * function join(: array[string], : string) returns string;

This function does the reverse of what the split() function does -- it
takes an array of strings and joins them into a single string, putting
its second argument in between elements in the array.

For example, join(["aaa", "bbb", "ccc"], ", ") returns
"aaa, bbb, ccc".

  * function join(: array[string], : string <-- ()) returns string;

This function takes an array of string and joins them into a single
string, putting the result of calling its second argument in between
elements in the array.  The second argument will be called once for
each place between elements in the array.  So if there is only one
element in the array, the function will not be called at all while if
there are five elements in the array the function will be called four
times.

  * function filter(: regular_expression, : array[string]) returns
            array[string];

This function filters an array of strings, returning an array
consisting only of those strings that match the specified regular
expression.

  * function filter(: type !{}, : array) returns array;

This function filters an array, returning an array consisting only of
those values that match the specified type.

  * function substitute(: regular_expression, base : string,
                        replacement : string) returns string;

This function substitutes all non-overlapping matches to the regular
expression in ``base'' with the string ``replacement''.

  * function substitute(: regular_expression, base : string,
            replacement : string <-- (string)) returns string;

This function finds all non-overlapping matches to the regular
expression and for each one calls the ``replacement'' function and
replaces the matching text with the string returned by
``replacement''.

  * function pattern(: regular_expression) returns string;

This function returns a pattern string that generates the specified
regular expression.  For example, pattern(@aab*c@) might return the
string "aab*c" or it might return "(aa)b*c", since both of those are
patterns that generate the same regular expression.

  * function parse_regular_expression(pattern : string) returns
            regular_expression;

This function creates a regular expression from a pattern string.  The
pattern string has the same syntax and semantics as the characters
between the at signs in a literal regular expression.  So, for
example,

    x := @aab*c@;

and

    x := parse_regular_expression("aab*c");

are equivalent.  Note, however, that the argument to
parse_regular_expression doesn't have to be a literal string, it can
be a string generated by any means, allowing data-dependent regular
expressions to be produced.

  * function exact_string(: string) returns regular_expression;
  * function exact_character(: character) returns regular_expression;
  * function character_set(: array[character]) returns
            regular_expression;
  * function character_range(lower : character, upper : character)
            returns regular_expression;
  * function concatenate(: regular_expression, : regular_expression)
            returns regular_expression;
  * function or(: regular_expression, : regular_expression) returns
            regular_expression;
  * function repeat_zero_or_more(: regular_expression) returns
            regular_expression;
  * function repeat_one_or_more(: regular_expression) returns
            regular_expression;

These eight functions allow regular expressions to be built up from
other regular expressions on the fly.  They provide the same
constructs that pattern strings do, but may be applied to other
regular expressions directly.

The exact_string() function returns a regular expression that matches
the function's argument string and only that string.  The
exact_character() function returns a regular expression that matches
the string consisting of exactly one character, the argument
character, and only that string.  Note that the exact_string() and
exact_character() functions provide the equivalent of non-special
characters in a pattern.  For example, @abc@ is equivalent to
exact_string("abc") and @a@ is equivalent to exact_character('a').

The character_set() function returns a regular expression that matches
any string consisting of exactly one character and for which that one
character is in the array argument to character_set().  Note that this
is equivalent to the square bracket notation for regular expression
patterns.  For example, @[aeiou]@ is equivalent to
character_set(['a', 'e', 'i', 'o', 'u']).

The character_range() function returns a regular expression that
matches any string consisting of exactly one character and for which
that character's code point is greater than or equal to ``lower'' and
less than or equal to ``upper''.  Note that this is equivalent to the
character range notation within square brackets for regular expression
patterns.  For example, @a-z@ is equivalent to character_range('a',
'z').

The concatenate() function returns a regular expression that matches a
string if and only if that string can be split into two parts at some
point such that the first part matches the first argument to the
function and the second part matches the second argument to the
function.  Note that this is equivalent to one pattern following
another for regular expression patterns.  For example, @a*b*@ is
equivalent to concatenate(@a*@, @b*@).

The or() function returns a regular expression that matches a string
if and only if either one of its arguments matches that string.  Note
that this is equivalent to the ``|'' operator in regular expression
patterns.  For example, @a*|b*@ is equivalent to or(@a*@, @b*@).

The repeat_zero_or_more() function returns a regular expression that
matches a string if and only if there is some partitioning of the
string such that each member of the partition matches the argument
regular expression.  This includes the degenerate case of an empty
string, which matches as an empty partition.  Note that this is
equivalent to the ``*'' operator in regular expression patterns.  For
example, @(ab)*@ is equivalent to repeat_zero_or_more(@ab@).

The repeat_one_or_more() function returns a regular expression that
matches a string if and only if there is a partition containing at
least one element of the string such that each member of the partition
matches the argument regular expression.  Note that this is equivalent
to the ``+'' operator in regular expression patterns.  For example,
@(ab)+@ is equivalent to repeat_one_or_more(@ab@).

  * function operator~(left : regular_expression,\n"
            right : regular_expression) returns regular_expression\n"
      (concatenate(left, right));"),
  * function operator|(left : regular_expression,\n"
            right : regular_expression) returns regular_expression\n"
      (or(left, right));"),
  * function operator*(to_repeat : regular_expression)\n"
            returns regular_expression\n"
      (repeat_zero_or_more(to_repeat));"),
  * function operator+(to_repeat : regular_expression)\n"
            returns regular_expression\n"
      (repeat_one_or_more(to_repeat));"),

The standard library provides four operator functions on regular
expressions.  These functions, for the operators ``~'', ``|'', ``*'',
and ``+'' are aliases for the functions concatenate(), or(),
repeat_zero_or_more(), and repeat_one_or_more() respectively.  They
provide a nicer syntax for building regular expressions out of other
regular expressions -- syntax that is similar to the syntax used
within regular expression literals.

  * immutable regular_expression_follower := type interface
      [
        transit :- {} <-- (character | {end_of_input}),
        is_in_accepting_state :- boolean <-- (),
        more_possible :- boolean <-- ()
      ];

The regular_expression_follower interface type provides three methods.
It is intended to allow a regular expression to be tested against a
given bit of text where the text is supplied one character at a time
instead of as a string.  An object of this type is expected to keep
the state of the parsing of the text given to it so far.

The transit() procedure adds to the text that is being tested.  It may
be given either a character or the value end_of_input.  The
end_of_input is needed to match the ``$'' directive in regular
expressions that only matches the end of the text being tested.

The is_in_accepting_state() function tells whether the text given up
until the current point matches the regular expression exactly.

The more_possible() function is used to communicate when it's time to
give up because the text given so far already guarantees that there
will be no further match.  Note that just because more_possible()
returns true doesn't guarantee there is any possible string with the
given prefix that will match -- the only guarantee is that if
more_possible() returns false then no string with the prefix given so
far will be an exact match.

  * function create_follower(
            the_regular_expression : regular_expression) returns
                    regular_expression_follower;

The create_follower() function creates an object of type
regular_expression_follower given a regular expression.  The result
will be initialized for the start of input and can be used to test
whether a given sequence of characters matches the regular expression.

  * function length(: string) returns [0 ... +oo);
  * function length(: array) returns [0 ... +oo);

The function length() on a string returns the number of characters in
the string.  The function length() on an array returns one plus the
difference between the key with the highest key and that with the
lowest key for a map value and the number of elements for a
semi-labeled value list array.

  * function tag(value, label : string) returns [!{}] / [{value}];

The tag function allows a tag on a semi-labeled value list item to be
set based on a dynamic string.  The result is a semi-labeled value
list with a single item with value specified by the ``value''
parameter and tag specified by the ``label'' paramter.

EXAMPLE:

      + tag(17, "abc") returns [abc := 17].

  * function call(to_call : (!{}) <-- (*), arguments : [...])
            returns !{};

This routine calls its first argument with its second argument as its
arguments.  This allows calls that don't explicitly list the arguments
at the call site but instead use a list of arguments constructed as a
semi-labeled value list elsewhere and then passed to the call site.

Note that call() may be used as either or function or a procedure.

  * function internal_call(to_call : (!{}) <-- (*), arguments : [...])
            returns !{};

This routine is identical in effect to the call() routine, except that
if there is an exception generated by the callee, the source location
information attached to the exception will be for the call site to the
routine that calls internal_call().

This is useful for a wrapper routine that calls another routine where
if there are problems that might generate exceptions it's more useful
to look at the call site of the wrapper than within the wrapper
itself.  This is particularly true when calling a private routine
within a module, to make sure errors in the use of the module cause
exceptions pointing to the call sites for the entry points to the
module.

  * function return_value_expected(: jump_target) returns boolean;

This function returns true if the routine most closely surrounding the
jump target passed as an argument is expected to return a value
(i.e. if it was used as a function) and false if that routine is not
expected to return a value.  If called on a target outside all
routines, it returns true because at the top level a value may be
returned.

  * function integer_range(lower_bound : [-oo...+oo],
            upper_bound : [-oo...+oo], lower_is_inclusive : boolean,
            upper_is_inclusive : boolean);

This function returns a value that can be iterated over with an
iterate statement or comprehend expression to give all the integers
within a range in ascending order.  The range is from lower_bound to
upper_bound.  If lower_bound is greater than upper_bound, the range is
empty and iterating over it find zero elements.  If lower_is_inclusive
is true, lower_bound is taken as part of the range, otherwise the
range starts with lower_bound plus one.  If upper_is_inclusive is
true, upper_bound is taken as part of the range, otherwise the range
ends with the last element before upper_bound is hit.  Note that
unending iteration can be specified by using infinite values for one
of the bounds.

  * quark end_of_input;

The end_of_input quark is used by input streams to indicate that there
is no more input available from the stream.

  * lepton io_error[message : string];

The io_error lepton is used by I/O functions to indicate that there is
an error.  On an error, an io_error value is sent with the ``message''
field set to indicate what the problem was.

  * immutable output_text_stream := type interface
      [
        print :- {} <-- (...),
        printf :- {} <-- (format : string, ...),
        close :- {} <-- (),
        have_error :- boolean,
        which_error :- io_error
      ];

The output_text_stream interface type is one that provides three
function fields -- print(), printf(), and close() -- and two data
fields -- have_error and which_error.  It is used as the interface to
streams for writing out characters, such as to a file.

The print() function takes any list of arguments at all and prints
that data as text to this stream.  For character arguments, those
characters are sent out to the stream.  For string arguments, all the
characters in the string are sent out, in order.  For finite integer
values, the values are printed out as decimal values, with a leading
minus sign if the value is negative and a single zero character for
the value zero and no other leading zeros.
@@@ -- specify how other values are printed

The printf() function takes a format string, plus, optionally, a list
of additional values.  The format string contains the specification of
how the additional arguments are to be used to produce the output.

The format string consists of plain text characters and format
specifiers.  The format specifiers are deliminated by percent signs
(``%'').  Each format specifier starts and ends with a percent sign.
If there are an odd number of percent signs in a format string, an
exception occurs.  Each character that is preceeded by an even number
of percent signs is a plain text character and each character this is
preceeded by an odd number of percent signs is part of a format
specifier.

The printf() function's output consists of first the plain text
characters, in order, before the first format specifier, then the
characters, if any, generated by handling the first specifier (to be
described shortly), then the next batch of plain text, then the
characters, if any, generated by handling the second specifier, and so
on.

There are two kinds of format specifiers: empty format specifiers and
value format specifiers.  A format specifier with no characters
between the two percent signs is an empty format specifier.  All other
format specifiers are value format specifiers.  Handling an empty
format specifier generates exactly one character in the output, a
percent sign.  This allows literal percent signs to be specified by
the format string.

Handling a value format specifier uses exactly one of the additional
argument values to printf() beyond the format.  The characters in the
format specifier not including the two percent sign characters have
the following form:

    <format-specifier> :
        <optional-argument-specifier> <optional-flags>
                <optional-width> <optional-precision>
                <value-specific-specifier>

    <optional-argument-specifier> :
        <empty> |
        <digits> ":" |
        <identifier> ":"

    <optional-flags> :
        <empty> |
        <flags>

    <flags> :
        <empty> |
        <flag> |
        <flag> <flags>

    <flag> :
        "-" | "+" | " " | "#" | "0"

    <optional-width> :
        <empty> |
        <non-zero-digit> |
        <non-zero-digit> <digits>

    <optional-precision> :
        <empty> |
        "." |
        "." <digits>

    <value-specific-specifier> :
        <empty> |
        <characters>

    <digits> :
        <digit> |
        <digit> <digits>

    <non-zero-digit> :
        "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

    <digit> :
        "0" | <non-zero-digit>

    <characters> :
        <character> |
        <character> <characters>

Note that in the above <character> represents any Unicode character at
all (though of course a percent character can't occur here because it
would have been considered the end of the specifier).  Note also that
<identifier> represents the same thing as it does in the grammar of
the Salmon language itself.

Note also that the context-free grammar shown here is ambiguous in
that the <value-specific-specifier> can always grab characters away
from whatever comes before it that is non-empty.  For example, if the
format specifier is "2:v", then there are two intepreterations: with
"2:" as the <optional-argument-specifier> and "v" as the
<value-specific-specifier> and with "" as the
<optional-argument-specifier> and "2:v" as the
<value-specific-specifier>.  This ambiguity is resolved with the
additional rule that the interpretation that assigns the fewest
characters to the <value-specific-specifier> is the one used.

If the <optional-argument-specifier> is non-empty and contains only
digits, then the digits are interpreted as a decimal integer
specifying which of the additional argument values is to be used by
this specifier.  The first additional argument is number one, the
second is number two, and so on.  If the specified argument number is
zero or greater than the number of arguments, an exception occurs.

If the <optional-argument-specifier> is non-empty and contains an
identifier, then the identifier must match the name of one of the
additional arguments as specified at the call site.  The value of this
additional argument is the one to be used by this specifier.

If the <optional-argument-specifier> is empty, then the value to be
used is the one after the one used in the previous specifier, or the
first one if this is the first specifier.  If there aren't enough
additional values for this, an exception occurs.

There are five possible one-character flags that can be present, in
any combination, in the <optional-flags> section.  If the same
character occurs more than once in the flags section, the effect is
the same as if it had only occurred once, and the order of the
characters in the flags section has no effect, so it only matters
whether each of the five possible flag characters appears in the flags
section or not.

The effects of the flags characters are as follows:

      + "-" -- This flag specifies that if spaces are to be added
               because of the width specification, the spaces should
               be added after the other characters instead of before
               (i.e. the field will be left-justified instead of
               right-justified).  This flag has no effect if the
               <optional-width> is empty or if the width is small
               enough that no spaces need to be added to meet the
               width requirement.

      + "+" -- The interpretation of this flag depends on the value
               being converted.  If the value being converted is an
               integer and it is being printed in straight decimal,
               octal, or hexadecimal notation, a plus sign will be
               added before the first digit if the integer is
               non-negative, corresponding to where a minus sign would
               be printed if the integer had been negative.  If the
               value being converted is a rational and it is being
               printed with fractional notation, a plus sign will be
               added before the first digit of the numerator if the
               rational is non-negative, corresponding to where a
               minus sign would be printed if the rational had been
               negative (no plus sign is printed for the
               denominator).  If the value being converted is a
               rational and it is being printed in decimal-point
               decimal, octal, or hexadecimal notation, a plus sign
               will be added before the first digit of the rational if
               the rational is non-negative, corresponding to where a
               minus sign would be printed if the rational had been
               negative.  If the value being converted is a rational
               and it is being printed in scientific notation, a plus
               sign will be added before the first digit of the
               mantissa, if there is one before the decimal point, or
               before the decimal point, if there is no digit before
               the decimal point if the rational is non-negative,
               corresponding to where a minus sign would be printed.
               Note that this does not affect the printing of a plus
               or minus sign for the exponent, which is always printed
               in scientific notation.  If the value being converted
               has a ``sprint'' field that is being used to do the
               conversion, then the argument list to the sprint()
               function will have a component added with the name
               ``plus'' and the value ``true''.  Otherwise, this flag
               has no effect.

      + " " -- If the "+" flag is also present, this flag has no
               effect.  Otherwise it has the same effect as the "+"
               would have had except that the chacter possibly added
               would be a space instead of a plus sign and the name of
               the component added to the argument list for a sprint()
               field call will have the name ``space'' instead of
               ``plus''.

      + "#" -- The interpretation of this flag depends on the value
               being converted.

               If the value being converted is a finite integer and
               the <value-specific-specifier> is "o", "of", "oe",
               "oE", "og", or "oG", then a leading zero will be
               printed before any other digits, if any, if the leading
               digit wouldn't otherwise have been zero.  Note that
               this added zero comes after the minus sign, if any.

               If the value being converted is a finite integer and
               the <value-specific-specifier> is "x", "X", "xf", "Xf",
               "xe", "Xe", "xE", "XE", "xg", "Xg", "xG", or "XG", then
               a leading "0x" or "0X" will be added before any digits
               but after the minus sign, if any.  The "0x" prefix will
               be used for <value-specific-specifier> values starting
               with ``x'' and the "0X" prefix will be used for
               <value-specific-specifier> values starting with ``X''.

               If the value being converted is a finite rational and
               the <value-specific-specifier> is "f", "of", "xf",
               "Xf", "e", "oe", "xe", "Xe", "E", "oE", "xE", "XE",
               "g", "og", "xg", "Xg", "G", "oG", "xG", or "XG", then
               the decimal point is retained even if it would
               otherwise have been omitted.

               If the value being converted is a finite rational and
               the <value-specific-specifier> is "g", "og", "xg",
               "Xg", "G", "oG", "xG", or "XG", then trailing zeros, if
               any, are not omitted as they otherwise would have been.

               If the value being converted has a ``sprint'' field
               that is being used to do the conversion, then the
               argument list to the sprint() function will have a
               component added with the name ``hash'' and the value
               ``true''.

               Otherwise, this flag has no effect.

      + "0" -- If the "-" flag is also present, this flag has no
               effect.  Otherwise, if the <optional-width> is empty,
               this flag has no effect.  Otherwise, if the value being
               converted is a finite rational and
               <value-specific-specifier> is not empty or "v" or the
               value being converted is a finite integer, then leading
               zeros will be added to meet the width requirement,
               instead of spaces, if necessary.  The leading zeros
               will come after the minus sign, if any, and after the
               "0x" or "0X" prefix.

               If the <optional-width> is non-empty and the value
               being converted has a ``sprint'' field that is being
               used to do the conversion, then the argument list to
               the sprint() function will have a component added with
               the name ``zero_width'' and an integer value of the
               width.

               Otherwise, this flag has no effect.

If the <optional-width> is non-empty, it specifies a minimum width in
decimal for the result.  If the result would otherwise be fewer
characters than this width, spaces are added to the start of the
string until it is equal to the width.  If the string would already be
greater than or equal in size to the width, there is no effect.  Note
that the "-" and "0" flags can affect how the width is interpreted.

The <optional-precision>, if present, specifies a finite non-negative
integer value as the precision.  The digits after the "." are taken as
a decimal representation of the precision value.  The effects of the
precision value, if any, are different for different
<value-specific-specifier> strings, and such effects are described
below for the specific <value-specific-specifier> cases.

The <value-specific-specifier> is a string that specifies how the
value is to be printed.  Here are the rules for specific
<value-specific-specifier> strings:

      + "s" -- The value to be printed must be either a string or a
               character value.  The result is that string if it is a
               string value or the string consisting of one character
               as specified by the value if the value is a character
               value.  If the precision is specified, the number of
               characters of the string is limited to the precision.
               If the number of characters is less than or equal to
               the precision, the whole string is printed; otherwise,
               it is truncated to the number of characters specified
               by the precsion.  If the precision is not specified,
               all the characters in the string are printed.

      + "d" -- If the value to be printed is a finite integer, the
               result is the value in decimal notation.  If the
               integer is negative, the digits are preceeded by a
               minus sign.  The minimum number of digits used is
               specified by the precision, if the precision is
               specified, or 1 if the precision is not explicitly
               specified.  Leading zeros are added until the number of
               digits hits the minimum, if necessary.  Note that the
               minus sign, if any, is not counted when adding leading
               digits to hit the minimum, and the leading zeros come
               after the minus sign, if any.  If the value to be
               printed is positive infinity, the result is "+oo".  If
               the value to be printed is negative infinity, the
               result is "-oo".  If the value to be printed is
               unsigned infinity, the result is "1/0".  If the value
               to be printed is zero-zero, the result is "0/0".  Note
               that the precision does not affect the printing of
               these non-finite integer values.

      + "i" -- The effect is the same as that listed for "d" above.

      + "o" -- If the value to be printed is an integer, the result is
               the same as it would be for the "d" case above except
               that octal instead of decimal is used to determine the
               digits for the finite case.  Also note that the "#"
               flag can cause a leading zero to be added in this case,
               unlike in the "d" case.

      + "x" -- If the value to be printed is an integer, the result is
               the same as it would be for the "d" case above except
               that hexadecimal instead of decimal is used to
               determine the digits for the finite case, with the
               lower-case letters ``a'' through ``f'' used for digit
               values 10 through 15.  Also note that the "#" flag can
               cause a leading "0x" to be added before the digits in
               this case, unlike in the "d" case.

      + "X" -- The effect is the same as that listed for "x" above,
               except that the capital letters ``A'' through ``F'' are
               used for digit values 10 through 15 and, if the "#"
               flag is present, the prefix is "0X" instead of "0x".

      + "f" -- If the value to be printed is a non-finite integer, the
               result is the same as it would be for the "d" case
               above.  If the value to be printed is a finite integer
               or rational, the value will be printed in decimal
               decimal-point notation.  That is, the integer part of
               the value will be printed in decimal, followed by a "."
               and then some number of additional decimal digits.  If
               the <optional-precision> is non-empty, the precision it
               specifies is the number of digits after the decimal
               point.  Otherwise, the number of digits after the
               decimal point is 6.  The number printed is the one
               closest to the argument value that can be represented
               with  that number of decimal places, or the one farther
               from from zero if it is equally distant from the next
               higher and the next lower representable value.  If the
               precision is zero the decimal point is omitted unless
               the "#" flag is present.

      + "of" -- The effect is the same as that listed for "f" above,
               except that octal is used instead of decimal for the
               finite case.  Note that this applies to digits both
               before and after the decimal point, which is really an
               ``octal point'' in this case.  Note also that the "#"
               flag will potentially add a leading zero in this case.

      + "xf" -- The effect is the same as that listed for "f" above,
               except that hexadecimal is used instead of decimal,
               with ``a'' through ``f'' used as digits.  Note that
               this applies to digits both before and after the
               decimal point, which is really a ``hexadecimal point''
               in this case.  Note also that the "#" flag will add a
               "0x" prefix in this case.

      + "Xf" -- The effect is the same as that listed for "xf" above,
               except that the capital letters ``A'' through ``F'' are
               used for digit values 10 through 15 and, if the "#"
               flag is present, the prefix is "0X" instead of "0x".

      + "e" -- If the value to be printed is a non-finite integer, the
               result is the same as it would be for the "d" case
               above.  If the value to be printed is a finite integer
               or rational, the value will be printed in decimal
               scientific notation.  That is, a value in decimal-point
               notation will be written, followed by the letter "e",
               then a plus or minus sign, then two or more decimal
               digits.  The sign and digits following the "e" are a
               decimal representation of an exponent.  The
               interpretation of the result is as the value specified
               by the decimal-point notation multiplied by ten to the
               power of the exponent.  If the value is zero, the
               exponent is taken as zero.  Otherwise, the exponent is
               chosen so that exactly one digit appears before the
               decimal point and that one digit is non-zero.  The
               decimal-point notation portion (the mantissa) is
               generated as it would be for the "f"
               <value-specific-specifier>, including rounding and the
               precision specifying the number of digits after the
               decimal point.  The exponent is written with only the
               leading zeros necessary to make it at least two digits.

      + "oe" -- The effect is the same as that listed for "e" above,
               except that octal is used instead of decimal for the
               finite case.  Note that this applies to digits both
               before and after the decimal point, which is really an
               ``octal point'' in this case, in the mantissa; it
               applies to the digits of the exponent; and it implies
               that the value is the mantissa times eight to the power
               of the exponent, not 10 to the power of the exponent.
               Note also that the "#" flag will potentially add a
               leading zero to the mantissa in this case.

      + "xe" -- The effect is the same as that listed for "e" above,
               except that hexadecimal is used instead of decimal for
               the finite case and the letter "x" is used instead of
               the letter "e" to separate the exponent from the
               mantissa because the letter "e" is a hexadecimal digit.
               Note that this applies to digits both before and after
               the decimal point, which is really a ``hexadecimal
               point'' in this case, in the mantissa; it applies to
               the digits of the exponent; and it implies that the
               value is the mantissa times 16 to the power of the
               exponent, not 10 to the power of the exponent.  Note
               also that the "#" flag will add a "0x" prefix to the
               mantissa in this case.  The lower-case letters ``a''
               through ``f'' are used for hexadecimal digits.

      + "Xe" -- The effect is the same as that listed for "xe" above,
               except that the capital letters ``A'' through ``F'' are
               used for digit values 10 through 15 and, if the "#"
               flag is present, the prefix is "0X" instead of "0x".

      + "E" -- The effect is the same as that listed for "e" above,
               except that the capital letter "E" is used instead of
               "e" to separate the mantissa and exponent.

      + "oE" -- The effect is the same as that listed for "oe" above,
               except that the capital letter "E" is used instead of
               "e" to separate the mantissa and exponent.

      + "xE" -- The effect is the same as that listed for "xe" above,
               except that the capital letter "X" is used instead of
               "x" to separate the mantissa and exponent.

      + "XE" -- The effect is the same as that listed for "Xe" above,
               except that the capital letter "X" is used instead of
               "x" to separate the mantissa and exponent.

      + "g" -- The effect is the same as that listed for either "f" or
               "e", depending on the value, with a few modifications.
               It will be the same as the "e" case, with
               modifications, if and only if the exponent that would
               be used is less than -4 or greater than or equal to
               either the precision, if the <optional-precision> is
               non-empty and non-zero, or 1, if the
               <optional-precision> is empty or zero.  Otherwise, it
               will be the same as the "f" case, with modifications.
               One modification is that the precision specifies the
               total number of significant digits, not the number of
               digits after the decimal place.  It includes the digits
               before the decimal point except for leading zeros, and
               doesn't include zeros immediately following the decimal
               point unless there is a non-zero digit before the
               decimal point.  Another modification is that if the
               precision is not specified or is zero then instead the
               precision is taken to be 1.  And another modification
               is that trailing zeros are removed after the decimal
               point and the decimal point itself is omitted if no
               digits follow it (after the removal of trailing zeros).
               Note, however, that the "#" flag reverses this omission
               of trailing zeros and the decimal point.

      + "og" -- The effect is the same as that listed for "g" above,
               except that it is the "of" or "oe" rules that are used,
               instead of the "f" or "e" rules.

      + "xg" -- The effect is the same as that listed for "g" above,
               except that it is the "xf" or "xe" rules that are used,
               instead of the "f" or "e" rules.

      + "Xg" -- The effect is the same as that listed for "g" above,
               except that it is the "Xf" or "Xe" rules that are used,
               instead of the "f" or "e" rules.

      + "G" -- The effect is the same as that listed for "g" above,
               except that the capital letter "E" is used instead of
               "e" to separate the mantissa and exponent, if
               scientific notation is used.

      + "oG" -- The effect is the same as that listed for "og" above,
               except that the capital letter "E" is used instead of
               "e" to separate the mantissa and exponent, if
               scientific notation is used.

      + "xG" -- The effect is the same as that listed for "xg" above,
               except that the capital letter "X" is used instead of
               "x" to separate the mantissa and exponent, if
               scientific notation is used.

      + "XG" -- The effect is the same as that listed for "Xg" above,
               except that the capital letter "X" is used instead of
               "x" to separate the mantissa and exponent, if
               scientific notation is used.

In addition to the above-listed set of specifier strings, for each
string in the above list there is a specifier string that is the same
except that a "c" is prepended -- "cd", "ci", "co", "cx", ..., "cxG",
and "cXG".  These strings have the same meaning as the ones without
the "c" prefix except that if the value is negative, it is printed in
``complement'' form.  Complement form is analagous to two's-complement
representations of binary numbers but extended to other bases -- 10,
8, and 16 in this case.  In complement form, negative numbers
implicitly have an infinite string of leading (base - 1) digits.  For
decimal, this is a string of leading "9" digits, for octal this is a
string of leading "7" digits, and for hexadeciaml this is a string of
leading "f" digits.  Just as leading zeros can be omitted in ordinary
decimal, octal, and hexadecimal formats, leading "9", "7", and "f"
digits can be removed in complement form -- the minus sign implies all
leading digits are "9", "7", or "f" respectively.  The other digits
are chosen so that if they are added to the absolute value of the
number being represented, the result will be all zeros, with a carry
going infinitely up the leading digits.  For example, minus 1 in
complement decimal will be ...99999, minus 2 will be ...99998, and
minus 2.45 will be ...99997.55.  With the minus sign standing in for
leading "9" digits, we can represent these as "-9", "-8", and "-7.55"
in complement format.  In complement format, leading "9", "7", or "f"
digits respectively take the place of leading zeros for negative
numbers, so the "0" flag and the precision for "cd" specifier strings,
for example, will lead to additional leading "9" digits instead of "0"
digits for negative numbers, if necessary.

If none of the above rules applies and the value has a field named
``sprint'' and that field has a routine value, then that routine will
be called as a function to generate the string that is the result of
handling the specifer.  The first argument of the call will be the
<value-specific-specifier> in the form of a string value, unless the
<value-specific-specifier> is empty or "v", in which case this
argument will be omitted.  This argument, if present, will be unnamed.
Next in the actual argument list will be any arguments generated by
flags "+", " ", "#", and, "0", as specified in the descriptions of the
individual flags (the "-" flag will not affect the argument list, as
it is used to add spaces to the string returned by the call, if
necessary).  The order of the arguments for these flags, if any, will
be those for the "+", " ", "#", and "0" flags, in that order.  Next,
if the <optional-precision> is non-empty, there will be an argument
named ``precision'' with an integer value specifying the precision.
An attempt will be made to call the ``sprint'' routine with that
argument list.  If this argument list doesn't match what's required
for the sprint() field, an exception occurs.  If the sprint() function
doesn't return a string value, an exception occurs.

Otherwise, the <value-specific-specifier> is required to be either
empty or the single character "v".  In this case, the result is the
string that would be generated by the print() function, as specified
above, for that value, unless the <optional-precision> is non-empty
and the specified precision is less than the number of characters in
that string.  In that case, the result will be what print() would
generate, but truncated to the number of characters specified by the
precision.

EXAMPLES:

      + printf("abc") sends the string "abc" to the output.

      + printf("100%%") sends the string "100%" to the output.

      + printf("%v%, %v%, %v%", 1, 2, 3) sends the string "1, 2, 3" to
        the output.

      + printf("%2:v%, %v%, %1:v%", 1, 2, 3) sends the string
        "2, 3, 1" to the output.

      + printf("%2:%, %v%, %1:%", 1, 2, 3) also sends the string
        "2, 3, 1" to the output.

      + printf("%last:v%, %first:v%, %v%", first := 1, 2, last := 3)
        sends the string "3, 1, 2" to the output.

The close() function shuts down the stream.  It is illegal to use any
functions of the stream after that point.  There can be other effects
that are specific to specific kinds of streams -- for example, a
buffered file output stream might force all of its buffered output to
the file on a close() call.

  * immutable input_text_stream := type interface
      [
        read_character :- (character | {end_of_input}) <-- (),
        read_string :- (string | {end_of_input}) <-- (
                count : [0...+oo], minimum : [0...+oo] := *),
        read_line :- (string | {end_of_input}) <-- (),
        is_end_of_input :- boolean,
        close :- {} <-- (),
        have_error :- boolean,
        which_error :- io_error
      ];

@@@

  * immutable look_ahead_stream := type interface
      [
        next_character :- (character | {end_of_input}) <-- (),
        look_ahead :- (character | {end_of_input}) <-- ([0...+oo))
      ];

@@@

  * immutable output_bit_stream := type interface
      [
        write :- {} <-- (bits : [1...+oo),
                         [0...+oo) | array[[0...+oo)]),
        close :- {} <-- (),
        have_error :- boolean,
        which_error :- io_error
      ];

@@@

  * immutable input_bit_stream := type interface
      [
        read :- (array[[0...+oo)] | {end_of_input}) <-- (
                bits : [1...+oo), count : [0...+oo),
                minimum : [0...+oo) := *),
        is_end_of_input :- boolean,
        close :- {} <-- (),
        have_error :- boolean,
        which_error :- io_error
      ];

@@@

  * immutable seekable_stream := type interface
      [
        tell :- [0...+oo) <-- (),
        seek :- {} <-- ([0...+oo)),
        seek_end :- {} <-- ()
      ];

@@@

  * function add_text_look_ahead_buffer(stream : input_text_stream)
            returns input_text_stream & look_ahead_stream;

The add_text_look_ahead_buffer() function adds look-ahead
functionality to a in input text stream.  It returns an object that
adds buffering to give the original input_text_stream interface plus
the look_ahead_stream interface.

  * variable standard_input : input_text_stream & look_ahead_stream;
  * variable standard_output : output_text_stream;
  * variable standard_error : output_text_stream;

The standard_input, standard_output, and standard_error variables give
three streams that are always available for text I/O.  They normally
come pre-set when the program starts, but can be changed by the Salmon
program.

  * quark enumeration utf_choice
      {utf_8, utf_16_le, utf_16_be, utf_32_le, utf_32_be};

The utf_choice type specifies one among the three Unicode encoding
formats, UTF-8, UTF-16, and UTF-32, and, for the UTF-16 and UTF-32
encoding formats, whether little-endian or big-endian byte order is
used.

  * quark enumeration endianness {big_endian, little_endian};

The endianness type specifies either bit-endian or little-endian byte
order.

  * function open_input_text_file(file_name : string,
                                  format : utf_choice := utf_8)
            returns (input_text_stream & seekable_stream);

This function attempts to open the file named by file_name for text
reading.  If successful, it returns a stream handle that can be used
to read text from the file.  If unsuccessful, it generates an
exception.  The ``format'' parameter specifies which Unicode encoding
is used for the file.

  * function open_output_text_file(file_name : string,
            format : utf_choice := utf_8,
            append : boolean := false)
                    returns (output_text_stream & seekable_stream);

This function attempts to open the file named by file_name for text
writing.  If successful, it returns a stream handle that can be used
to write text to the file.  If unsuccessful, it generates an
exception.  The ``format'' parameter specifies which Unicode encoding
is to be used when writing the file.  The ``append'' parameter
specifies whether, if the file already exists, new data is appended to
that or if the file is truncated to zero length when it is opened.

  * function open_input_output_text_file(file_name : string,
                                         format : utf_choice := utf_8)
            returns (input_text_stream & output_text_stream &
                     seekable_stream);

This function attempts to open the file named by file_name for text
reading and writing.  If successful, it returns a stream handle that
can be used to read text from the file and write text to the file.  If
unsuccessful, it generates an exception.  The ``format'' parameter
specifies which Unicode encoding is used for the file.

  * function open_input_bit_file(file_name : string,
            which_endian : endianness) returns
                    (input_bit_stream & seekable_stream);

This function attempts to open the file named by file_name for reading
raw bits.  If successful, it returns a stream handle that can be used
to read bits from the file.  If unsuccessful, it generates an
exception.

  * function open_output_bit_file(file_name : string,
            which_endian : endianness) returns
                    (output_bit_stream & seekable_stream);

This function attempts to open the file named by file_name for writing
raw bits.  If successful, it returns a stream handle that can be used
to write bits to the file.  If unsuccessful, it generates an
exception.

  * function open_input_output_bit_file(file_name : string,
            which_endian : endianness) returns
                    (input_bit_stream & output_bit_stream &
                     seekable_stream);

This function attempts to open the file named by file_name for reading
and writing raw bits.  If successful, it returns a stream handle that
can be used to read bits from and write bits to the file.  If
unsuccessful, it generates an exception.

  * function open_input_string(base : string) returns
            input_text_stream & look_ahead_stream;

This function creates a stream handle that can be used for reading
text from the string that is its argument.  The stream behaves as if a
file had been opened and the contents of that file are the string.

  * function open_output_string(location : +string) returns
            output_text_stream;

This function creates a stream handle that can be used for writing
text into a string.  The parameter is a slot location into which the
string is written.  As more is written to the stream, it is appended
to the string in the specified slot.

  * function scanf(stream : input_text_stream & look_ahead_stream,
                   format : string) returns [...];

The scanf() function reads text from its ``stream'' argument and
produces values from that text as specified by its ``format''
argument.  It returns an array containing those values if successful,
or generates an exception if the text doesn't match the specified
format.

The ``format'' argument is similar to the format argument of the
printf() procedure.  As with the printf() format, the format argument
for the scanf() function may have conversion specifiers enclosed in
percent signs in addition to plain text outside the percent signs.
But unlike the printf() case, for scanf() there may also be regular
expressions enclosed in either pairs of at signs (``@'') or pairs of
pound signs (``#'').

The text in the format outside of pairs of percent signs, at signs, or
pound signs is literal text that must exactly match the text read from
the stream.  If the text does not match exactly, an exception is
generated.  A pair of percent signs with nothing in between represents
a literal single percent sign; similarly a pair of at signs or pair of
pound signs with nothing in between represents a literal single at
sign or pound sign respectively.

A regular expression enclosed in at signs specifies a regular
expression that must be matched by the input text.  The longest
possible match of input text that exactly matches the regular
expression will be read and returned as a string value in the result
array.  The syntax for regular expressions between the at signs is the
same as that for literal regular expression tokens in Salmon.

A regular expression enclosed in pound signs is treated that same as a
regular expression enclosed in at signs except that in the pound sign
case it will use the shortest possible string that matches the
expression.  As in the at sign case, the matching string will be
returned in the result array.

A format specifier between percent signs will match some amount of
input text to produce a single value that will be placed in the result
array.  The final result array will have a number of elements equal to
the number of items between pairs of percent signs, at signs, and
pound signs, and they will be in the same order as the parts of the
format that produced the values.

The text of the specifier between percent signs consists of two parts:
a specifier base preceeded by an optional label prefix.  The label
prefix may either be empty or may be an identifier followed by a
colon, just like the identifier case of the
<optional-argument-specifier> of the printf() procedure.  If the
prefix is non-empty, it specifies a label for the corresponding
element in the output semi-ordered value list.  If the prefix is
empty, the corresponding element in the output semi-ordered value list
will be unlabeled.

The text of the specifier base must be one of the following:

      + "d" -- The value generated will be an integer.  The input text
               must be either a sequence of one or more decimal digits
               with an optional "+" or "-" prefix; or one of "+oo",
               "+infinity", "-oo", "-infinity", "oo", and "infinity".
               In the case of a digit sequence, the longest possible
               sequence of digits will be taken as the match.  In the
               digit sequence case, the digits will be taken as the
               decimal representation of the magnitude of the finite
               integer, with the sign being negative if there is a "-"
               prefix and positive otherwise.  In the "+oo" and
               "+infinity" cases, the generated value will be positive
               infinity.  In the "-oo" and "-infinity" cases, the
               generated value will be negative infinity.  In the "oo"
               and "infinity" cases, the generated value will be
               unsigned infinity.

      + "ud" -- This will be treated like the "d" case except that the
               non-finite values will not be allowed and the sign
               prefix will not be allowed.  That is, only sequences of
               decimal digits will be allowed, which will produce only
               finite, non-negative integer values.

      + "cd" -- This will be treated like the "d" case except that if
               the sign is "-" then the number will be taken to be in
               decimal complement form, as if it had been printed with
               the "cd" specifier using the printf() procedure.

      + "o"
      + "uo"
      + "co" -- These three mean the same thing as the "d", "ud", and
               "cd" format specifiers respectively except that the
               digit sequences, if used, will be taken as octal
               instead of decimal.  The digits "8" and "9" will not be
               considered part of the digit sequence.

      + "x"
      + "ux"
      + "cx" -- These three mean the same thing as the "d", "ud", and
               "cd" format specifiers respectively except that the
               digit sequences, if used, will be taken as hexadecimal
               instead of decimal.  The lower-case letters "a" through
               "f" will be taken as the digits for the values 10
               through 15, and the upper-case letters "A" through "F"
               will also be taken as the digits for those values.
               Upper- and lower-case letters may be mixed in the same
               digit sequence.

      + "i"
      + "ui"
      + "ci" -- These three mean the same thing as the "d", "ud", and
               "cd" format specifiers respectively except that if the
               first two characters in the input stream are "0" and
               either "x" or "X", or if one of those two-character
               sequences follows a "+" or "-" sign then the input is
               considered to be a finite integer specified with a
               hexadecimal digit sequence.

      + "df" -- The value generated will be a rational.  The input
               text must either be one of the non-finite cases listed
               for the "d" case above or a sequence of decimal digits
               with a "+" or "-" prefix and an optional dot (".")
               followed by an optional further digit sequence.  In the
               absence of the dot, or if there are no digits after the
               dot, the result will be an integer, just as in the "d"
               case.  If there is a dot and there are digits after it,
               the dot is taken as a decimal point and the digits
               after it as a decimal point notation fractional part,
               generating a finite rational that is not an integer if
               and only if any of the digits following the decimal
               point is non-zero.

      + "cdf" -- This will be treated like the "df" case except that
               if the sign is "-" then the number will be taken to be
               in decimal complement form, as if it had been printed
               with the "cf" specifier using the printf() procedure.

      + "of"
      + "cof" -- These means the same thing as the "df" and "cdf"
               format specifiers respectively except that the digits
               sequences, if used, will be taken as octal instead of
               decimal.  The dot, if present, will be an octal point
               instead of a decimal point.  The digits "8" and "9"
               will not be considered part of the digit sequence,
               either before or after the octal point.

      + "xf"
      + "cxf" -- These means the same thing as the "df" and "cdf"
               format specifiers respectively except that the digits
               sequences, if used, will be taken as hexadecimal
               instead of decimal.  The dot, if present, will be a
               hexadecimal point instead of a decimal point.  The
               lower-case letters "a" through "f" will be taken as the
               digits for the values 10 through 15, and the upper-case
               letters "A" through "F" will also be taken as the
               digits for those values.  Upper- and lower-case letters
               may be mixed in the same digit sequence.

      + "f"
      + "cf" -- These mean the same thing as the "df" and "cdf" format
               specifiers respectively except that if the first two
               characters in the input stream are "0" and either "x"
               or "X", or if one of those two-character sequences
               follows a "+" or "-" sign then the input is considered
               to be a finite integer specified with a hexadecimal
               digit sequence.

      + "de"
      + "cde" -- These mean the same thing as the "df" and "cdf"
               format specifiers respectively except that except in
               the non-finite cases, an exponent part must follow the
               digit sequence and optional decimal point and digits.
               The exponent part must start with an "e" or "E".  Then,
               it may optionally continue with a "+" or "-".  After
               that, there must be a sequence of one or more decimal
               digits.  These digits are taken as the exponent
               magnitude, with the "+" or "-", if present, specifying
               the sign (the sign is positive if there is no sign
               character).  The resulting value will be the value
               specified before the "e" or "E" times ten raised to the
               power of the exponent.  Note that in the "cde" case if
               the exponent is negative it will be in complement form.

      + "oe"
      + "coe" -- These mean the same as the "de" and "cde" format
               specifiers respectively except that everything is in
               octal instead of decimal.  Both the mantissa (the part
               before the "e" or "E") and the exponent are in octal
               and the value is the mantissa times the eight to the
               power of the exponent.  The digits in both the mantissa
               and exponent may not include the digits "8" or "9".

      + "xe"
      + "cxe" -- These mean the same as the "de" and "cde" format
               specifiers respectively except that everything is in
               hexadecimal instead of decimal and the letters "x" or
               "X" are used to separate the exponent from the mantissa
               instead of "e" or "E" (because "e" and "E" are
               hexadecimal digits).  Both the mantissa and the
               exponent are in hexadecimal and the value is the
               mantissa times sixteen to the power of the exponent.
               The letters "a" through "f" and "A" through "F" are
               allowed as digits for the values 10 through 15 in the
               mantissa and exponent.

      + "e"
      + "ce" -- These mean the same as the "de" and "cde" format
               specifiers respectively except that either decimal or
               hexadecimal formats may be used.  Hexadecimal is used
               if there is a "0x" or "0X" prefix, either before or
               after the sign of the mantissa; otherwise, decimal is
               used.  In the hexadecimal case both the mantissa and
               exponent are in hexadecimal and the resulting value is
               the mantissa times sixteen raised to the power of the
               exponent.

      + "dg"
      + "cdg" -- These two will act as either the "de" and "cde"
               format specifiers respectively or the "df" and "cdf"
               format specifiers respectively.  If the input matches
               the requirements for the "de"/"cde" version, that will
               be used and otherwise the "df"/"cdf" version will be
               used.  In other words, the exponent part is optional.

      + "og"
      + "cog" -- These two mean the same as the "dg" and "cdg" format
               specifiers respectively except that octal is used
               instead of decimal throughout.

      + "xg"
      + "cxg" -- These two mean the same as the "dg" and "cdf" format
               specifiers respectively except that hexadecimal is used
               instead of decimal throughout, with "x" or "X" instead
               of "e" or "E" to separate the mantissa from the
               exponent.

      + "g"
      + "cg" -- These two will act as either the "e" and "ce" format
               specifiers respectively or the "f" and "cf" format
               specifiers respectively.  If the input matches the
               requirements for the "e"/"ce" version, that will be
               used and otherwise the "f"/"cf" version will be used.
               In other words, the exponent part is optional.

      + "dr" -- This format specifier means that the input is either in
               the form expected by the "d" format specifier or is in
               fraction (``ratio'') form -- two strings in the "d"
               format with a forward slash character in between.  The
               generated value is the rational value that is created
               by dividing the integer produced by the part before the
               slash by the integer produced by the part after the
               slash.

      + "cdr" -- This has the same meaning as the "dr" format
               specifier except using the "cd" instead of the "d"
               format specifer for the components.

      + "or" -- This has the same meaning as the "dr" format
               specifier except using the "o" instead of the "d"
               format specifer for the components.

      + "cor" -- This has the same meaning as the "dr" format
               specifier except using the "co" instead of the "d"
               format specifer for the components.

      + "xr" -- This has the same meaning as the "dr" format
               specifier except using the "x" instead of the "d"
               format specifer for the components.

      + "cxr" -- This has the same meaning as the "dr" format
               specifier except using the "cx" instead of the "d"
               format specifer for the components.

      + "r" -- This has the same meaning as the "dr" format
               specifier except using the "i" instead of the "d"
               format specifer for the components.

      + "cr" -- This has the same meaning as the "dr" format
               specifier except using the "ci" instead of the "d"
               format specifer for the components.

      + "v" -- This format specifier is used to read any of a wide
               range of possible values.  The rules are as follows:

                 - If the input matches the requirements for the "r"
                   format specifier with a slash character included,
                   the result will be a rational just as in the case
                   of the "r" format specifier.  Otherwise, if the
                   input matches the requirements for the "g" format
                   specifier, the result will be a rational just as in
                   the case of the "g" format specifier.

                 - If the next input is "true", then that input is
                   read and the generated value is the true value.

                 - If the next input is "false", then that input is
                   read and the generated value is the false value.

                 - If the next input is "null", then that input is
                   read and the generated value is the null value.

                 - If the first input character is a double quote
                   character, the result is a string value.  The
                   string value is read from the input using the same
                   rules as for a string literal token in the Salmon
                   source code, including escape sequences and the
                   closing double quote character.

                 - If the first input character is an apostrophe
                   character, the result is a character value.  The
                   character value is read from the input using the
                   same rules as for a character literal token in the
                   Salmon source code, including escape sequences and
                   the closing apostrophe character.

                 - If the first input character is an at sign, the
                   result is a regular expression value.  The regular
                   expression value is read from the input using the
                   same rules as for a regular expression literal
                   token in the Salmon source code, including escape
                   sequences and the closing at sign.

                 - If the first input character is a left square
                   bracket, the result a semi-labeled value list.  The
                   matching input must be in the form of the left
                   square bracket, followed by a comma-separated
                   (possibly empty) sequence of values each of which
                   recursively follows the rules for the "v" format
                   specifier, followed by a right square bracket.
                   Optionally, any item in the list may contain an
                   identifier followed by ":=" immediately before the
                   value.  The identifier follows the rules for an
                   identifier in the Salmon source code.  White space
                   is allowed after the left square bracket, before
                   and after the commas in the list, before the right
                   square bracket, and before and after the ":=" for
                   any item for which that syntax appears.  The
                   resulting semi-labeled value list has the values in
                   the order listed, with labels on those with the
                   ":=" syntax, with the identifier before the ":="
                   specifying the name of the label.

                 - If the first two input characters are "<<", then
                   the result is a map.  The matching input must be in
                   the form of the opening "<<", followed by a
                   comma-separated sequences of items, followed by a
                   ">>".  Any amount of white space is optionally
                   allowed after the "<<", before the ">>", and before
                   and after each comma in the list.  Each item in the
                   list must consist of a left parenthesis, a key
                   item, the three-character sequence "-->", a target
                   item, and a right parenthesis.  Optionally, any
                   amount of white space may appear after the left
                   parenthesis, before the right parenthesis, and
                   before and after the "-->".  Each key item may
                   either be "*" or a value recursively using the
                   rules of the "v" format specifier.  Each target
                   item must be a value recursively using the rules of
                   the "v" format specifier.  At most one item in the
                   list may use "*" for its key value.  The result is
                   a map value that is the same as would be created by
                   a similar <map-list-expression> in the source code:
                   for each item with a value key, an item will appear
                   in the result map value with the specified key and
                   target.  If there is an item with "*" as the key,
                   it specifies that the corresponding value is to be
                   used as the default value for the map.

                 - If the first input character is a left curly brace,
                   the result is a type.  The matching input must be
                   in the form of the left curly brace, followed by a
                   comma-separated (possibly empty) sequence of values
                   each of which recursively follows the rules for the
                   "v" format specifier, followed by a right curly
                   brace.  The resulting type value is the type
                   consisting of the enumeration of the values in the
                   list.  White space is allowed after the left curly
                   brace, before and after the commas in the list, and
                   before the right curly brace.

      + "cv" -- This means the same as the "v" format specifier except
               that when handling any negative rational values
               complement form will be assumed, as with "cr", "cd",
               "cf", etc.  This applies when a rational is the overall
               result of handling the format specifier as well as with
               any rational values appear as components within
               compound values.

  * function file_exists(file_name : string) returns boolean;

This function checks to see whether the named file exists, and returns
true if it does and false if it does not.

  * function directory_exists(name : string) returns boolean;

This function checks to see whether the named directory exists, and
returns true if it does and false if it does not.

  * function directory_contents(name : string) returns array[string];

This function reads a directory and returns an array of strings
containing the names of the contents of the directory.  If the
directory does not exist or cannot be read, it returns an empty
array.

  * procedure remove(file_name : string);

This function removes the specified file.  An exception occurs if the
file doesn't exist or for some other reason can't be removed.

  * procedure rename(old_name : string, new_name : string);

This function changes the name of a file.  An exception occurs if it
can't be renamed.

  * procedure print(...);

The print() function is equivalent to standard_output.print().

  * function sprint(...);

The sprint() function is similar to print() except that instead of
sending its output to the standard output stream, it creates a string
value consisting of that output and returns that string value.

  * procedure printf(format : string, ...);

The printf() function is equivalent to standard_output.printf().

  * function sprintf(format : string, ...);

The sprintf() function is similar to printf() except that instead of
sending its output to the standard output stream, it creates a string
value consisting of that output and returns that string value.

  * function read_character() returns (character | {end_of_input});

The read_character() function is equivalent to
standard_input.read_character().

  * function read_string(count : [0...+oo],
            minimum : [0...+oo] := count)
                    returns (string | {end_of_input});

The read_string() function is equivalent to
standard_input.read_string().

  * function read_line() returns (string | {end_of_input});

The read_line() function is equivalent to standard_input.read_line().

  * function scanf(format : string) returns [...];

The scanf() function without a stream specified is equivalent to
scanf(standard_input, format).

  * function system(: string, capture_standard_out : boolean := false,
                    capture_standard_error : boolean := false) returns
            [return_code : integer, standard_out : string,
             standard_error : string];

The system() function is used to call other commands external to the
Salmon program.  How commands are executed is system-dependent.  The
first parameter is a string specifying the command line to execute.
This command is typically sent to the default shell on the operating
system running the Salmon program.  For example, on a Linux system it
might be sent to bash for execution and on Windows it might be sent to
a DOS command shell for execution.

The optional capture_standard_out and capture_standard_error
parameters specify whether or not standard output and standard error
of the command should be captured.  If either one or both is not
captured, it flows to standard out or standard error of the Salmon
program.  If standard out is captured, the resulting string is the
second component of the return value of the system() function.  If
standard error is captured, the resulting string is the third
component of the return value.  If either isn't captured, the
corresponding component of the return value is the empty string.

The first component of the result of the system() call is an integer
return code that is returned by the operating system by the execution
of the command line.  What this code means is system-dependent.

  * procedure assert(: boolean);

@@@

  * function why_not_in(the_value : {}, the_type : type !{}) returns string;

The why_not_in() function returns a string describing in English text
why the value specified by the first argument is not in the type
specified by the second argument, or why the implementation cannot
determine whther or not the value is in the type.  The result should
be in the form of a sentence fragment that can fill in the XXX of the
sentence ``A is not in type B becuase XXX.''.

  * lock context_switching;

@@@

  * quark enumeration months
      {
        January, February, March, April, May, June, July, August,
        September, October, November, December
      };

The ``months'' enumeration provides one quark for each month of the
year.

  * quark enumeration days_of_week
      {
        Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
      };

The days_of_week enumeration provides one quark for each day of the
week.

  * immutable time_type := type
      [
        year : integer,
        month : months,
        day_of_month : [1...31],
        day_of_week : days_of_week,
        hours : [0...24),
        minutes : [0...60),
        seconds : [0....60),
        zone : string | {null},
        is_daylight_savings : boolean | {null},
        seconds_ahead_of_utc :
                [-12 * 60 * 60... 12 * 60 * 60] | {null},
        ...
      ];

The time_type immutable provides a type in which information about a
particular date and time can be put.  The ``year'' field is the full
year, such as 2009, not just a two-digit value.  The ``zone'' field
provides a string specifying the time zone for which the date and time
information apply, or null if the time zone isn't known.  The string
will typically be a three-letter abbreviation, such as "GMT" or
"PDT".  The is_daylight_savings field will be true if daylight savings
is in effect for the specified date and time, false if it is not in
effect, and null if it is not known whether daylight savings is in
effect.  The seconds_ahead_of_utc will specify how many seconds away
from UTC the information in this value is, or null if this is not
known.

  * function local_time_and_date() returns time_type;

The local_time_and_date() function returns information about the
current time and date in the local time zone.

  * function utc_time_and_date() returns time_type;

The utc_time_and_date() function returns information about the current
time and date in UTC (Coordinated Universal Time, also known as Zulu
Time and close to GMT or Greenwich Mean Time).

  * function translate(: string, ...) returns string;

@@@

  * lepton source_region
      [
        file_name : string,
        start_line : [1...+oo) | { 0/0 },
        start_column : [1...+oo) | { 0/0 },
        end_line : [1...+oo) | { 0/0 },
        end_column : [1...+oo) | { 0/0 }
      ];

The source_region lepton is used to specify a portion of the text
source specifying some construct.  This allows an exception object to
specify where the exception was generated and in similar situation.

The file_name field contains the name of the source file containing
the code being referenced.  If the source file name is not known, it
is the empty string.

The start_line, start_column, end_line, and end_column fields contain
information about the position in the source file of the code being
referenced.  If any piece of this information is not available, the
corresponding field will contain zero-zero.

  * lepton exception
      [
        tag : any_quark,
        message : string,
        source : source_region,
        ...
      ];

The ``exception'' lepton is used to communicate information about an
exception.  It is the type of the value passed to the handler function
of a try-handle statement.

The ``tag'' field contains a quark that tells what sort of exception
happened.  If the exception came from the base implementation of
Salmon, then the tag will be one of the quarks provided in the
standard library that starts with the prefix ``exception_tag''.  If
the exception was generated by the user code through the throw()
procedure, the tag might be any quark.  The idea of this field is to
allow a handler to test for certain kinds of exceptions without having
to parse the error message and thus being dependent on the exact
wording or natural language of the message.

The ``message'' field contains a message in human-readable form
explaining the exception.  This message should already have been
translated into the current output language before being placed in
this field, so no translation should be necessary on this field.  Note
that this means that code that is capable of supporting multiple human
languages should use translate() to get a message into the proper
language before calling throw() with that message.

The source_region field specifies the source of the construct that
generated this exception.

Note that the exception value is allowed to have additional fields
that provide additional information that is specific to particular
kinds of exceptions.

  * procedure throw(
        tag : any_quark,
        message : string,
        source_file_name : string := "",
        source_start_line_number : [1...+oo) | { 0/0 } := 0/0,
        source_start_column_number : [1...+oo) | { 0/0 } := 0/0,
        source_end_line_number : [1...+oo) | { 0/0 } := 0/0,
        source_end_column_number : [1...+oo) | { 0/0 } := 0/0,
        other : [...] := []
      );

This version of the throw() procedure generates an exception.  The
parameters to this routine other than ``other'' correspond to the
fields of the ``exception'' lepton and have the same meanings.  The
``other'' parameter takes a semi-ordered value list that contains
additional fields to add to the exception object.  It is an error to
have unnamed fields in the ``other'' parameter.

  * procedure throw(to_throw : exception);

This version of the throw() procedure throws an existing exception.
It can be used to re-throw an exception that has been caught but for
which the handler decides to have something else do the handling.

  * function current_exceptions() returns array[exception];

This may be used only during the execution of the ``catch'' part of a
try-catch statement.  It doesn't have to be directly in the ``catch''
statement block -- it can be in some routine that is indirectly called
from the ``catch'' part, for example.  But at the time it is called
the ``catch'' part must have begun execution and not finished
execution.  If there are multiple ``catch'' parts active at the same
time, this function applies to the most recently started ``catch''
part.

This function returns a value that is an array of at least one value
of type ``exception''.  How many values are in the array depends on
how many exceptions were caught by the try-catch block.  It will
contain one element for each exception that occurred while executing
the ``try'' block that wasn't handled by another try-catch block or a
try-handle block.  The earliest exception will be first in the array,
the second earliest will be next, and so on.  Each element of the
array will contain the information about the corresponding exception.

  * function numerator(base : rational) returns integer;

This function returns the numerator of its argument.  If the argument
is non-finite, this is just the argument itself.  If the argument is
finite, it is the numerator of the reduced fraction representing the
argument.

EXAMPLE:

      + numerator(-4/10) is an expression that returns -2.

  * function denominator(base : rational) returns (-oo...+oo);

This function returns the denominator of its argument.  If the argument
is non-finite, this is one.  If the argument is finite, it is the
denominator of the reduced fraction representing the argument.

EXAMPLE:

      + denominator(-4/10) is an expression that returns 5.

  * function power(base : rational, exponent : integer)
            returns rational;

This function returns the base raised to the power of the exponent.

  * immutable environment : interface
      [ operator[] :- (string | {null} | u8[0...+oo]) <-- (string)];

This immutable gives access to environment variables from the outside
system.  These environment variables can be read by using
``environment'' as a map and using a lookup expression with the name
of the environment variable as the key.  The result is the string
representing the value of that environment variable, or null if there
is no such environment variable.

Note that environment variables come from the outside system.  The
rules for legal environment variable name and value strings may vary
from platform to platform.  If the outside system allows environment
variables to have values that are byte strings that aren't in UTF-8
format, then trying to read such an environment variable will return
an array of 8-bit unsigned integers instead of a string, because
Salmon strings are always strings of valid Unicode characters.

EXAMPLE:

      + environment["PATH"] is an expression that returns a string
        representing the value of the PATH environment variable, or
        null if there is no PATH environment variable.


    Section 6.2: Exceptions
    -----------------------

This section lists all of the exception tags that are used for
exceptions generated by the core Salmon functionality or by anything
in the standard runtime library.

  * quark exception_tag_pure_virtual_no_override;

An exception with this tag is generated when control enters a
statement block that contains the declaration of a pure virtual
routine in a context that doesn't provide an override for that routine
declaration.

EXAMPLE:

      + [] := [{ virtual procedure p1() := null; return 0; }];

  * quark exception_tag_call_class_return_value;

An exception with this tag is generated when the body of a class
executes a return statement with a value.  Since the return value of
calling the class as a function is implicitly an object which is an
instance of that class, it makes no sense for the class body to return
an explicit value.

EXAMPLE:

      + class myclass()  { return 5; };
        [] := myclass();

  * quark exception_tag_call_function_no_return_value;

An exception with this tag is generated when a routine is called as a
function but the routine returns without a return value.

EXAMPLES:

      + procedure p1()  { };
        [] := p1();

      + procedure p1()  { return; };
        [] := p1();

  * quark exception_tag_call_return_type_mismatch;

An exception with this tag is generated when a function returns a
value that fails to match its static return type or fails to match its
dynamic return type.

EXAMPLES:

      + function f1() returns integer  ("five");
        [] := f1();

      + function f1(x) returns integer/{x}  (x + 1);
        [] := f1(5);

  * quark exception_tag_call_return_type_match_indeterminate;

An exception with this tag is generated when the Salmon implementation
cannot determine whether the value returned from a function matches
that function's return type, whether that return type is static or
dynamic.

EXAMPLES:

      + pure function a(x) returns boolean  ((x % 4) == 3);
        pure function b(x) returns boolean  ((x % 3) == 2);
        function f1() returns type a  (type type b);
        [] := f1();

      + pure function a(x) returns boolean  ((x % 4) == 3);
        pure function b(x) returns boolean  ((x % 3) == 2);
        function f1(x) returns !{}/type x  (type b);
        [] := f1(a);

  * quark exception_tag_call_two_return_values;

An exception with this tag is generated when a second return with a
value is executed after one has already been executed for a particular
context.  That context can be the top-level, a function, or a
statement block expression.

EXAMPLES:

      + function f1()
          {
            cleanup { return 5; };
            return 6;
          };
        [] := f1();

      + print(
          {
            cleanup { return 5; };
            return 6;
          }, ".\n");

      + /* At top level. */
        cleanup { return 1; };
        return 0;

  * quark exception_tag_call_procedure_return_value;

An exception with this tag is generated when a routine that is called
as a procedure returns a value.

EXAMPLES:

      + function f1(x)  (x + 2);
        f1(3);

      + length([15, 57]);

  * quark exception_tag_variable_use_before_instantiation;

An exception with this tag is generated when a value or type that
includes a reference to a variable is used in certain ways before that
variable has been instantiated.

The ways that a value can be used that can trigger this exception are
as one of the operands of a binary expression other than a logical-and
or logical-or expression and as the argument to an ``in'' expression.

The way that a type can be used that can trigger this exception is as
the type argument to an ``in'' expression.

EXAMPLES:

      + [] := [&v1 == 7];
        variable v1;

      + v1 := "spleen";
        variable v1;

      + v1[1] := "spleen";
        variable v1 := ["ankle", "wrist", "head"];

  * quark exception_tag_routine_use_before_instantiation;

An exception with this tag is generated when a value or type that uses
a routine is used in certain ways before that routine has been
instantiated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLE:

      + [] := [p1 == 7];
        procedure p1()  { };

  * quark exception_tag_tagalong_use_before_instantiation;

An exception with this tag is generated when a value or type that uses
a tagalong is used in certain ways before that tagalong has been
instantiated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLE:

      + [] := [t1 == 7];
        tagalong t1;

  * quark exception_tag_lepton_key_use_before_instantiation;

An exception with this tag is generated when a value or type that uses
a lepton key is used in certain ways before that lepton key has been
instantiated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLE:

      + [] := [l1 == 7];
        lepton l1;

  * quark exception_tag_quark_use_before_instantiation;

An exception with this tag is generated when a value or type that uses
a quark is used in certain ways before that quark has been
instantiated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLE:

      + [] := [q1 == 7];
        quark q1;

  * quark exception_tag_lock_use_before_instantiation;

An exception with this tag is generated when a value or type that uses
a lock is used in certain ways before that lock has been instantiated.
The ways that a value or type can be used that can trigger this
exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLE:

      + [] := [l1 == 7];
        lock l1;

  * quark exception_tag_variable_use_after_deallocation;

An exception with this tag is generated when a value or type that
includes a reference to a variable is used in certain ways after that
variable has been de-allocated.  The ways that a value or type can be
used that can trigger this exception are the same as those that can
trigger an exception_tag_variable_use_before_instantiation exception.

EXAMPLES:

      + variable v1;
          {
            variable v2;
            v1 := &v2;
            [] := [v1 == 7];
          };
        [] := [v1 == 7];

      + immutable i1 := variable;
        [] := [i1 == 7];
        delete(i1);
        [] := [i1 == 7];

      + variable p1 : *integer;
          {
            variable v1 : integer := 17;
            p1 := &v1;
          };
        *p1 := 18;

      + variable p1 : *integer := variable : integer := 17;
        delete(p1);
        *p1 := 18;

      + variable p1 : *array[string] :=
                variable : array[string] := ["ankle", "wrist", "head"];
        delete(p1);
        (*p1)[1] := "spleen";

  * quark exception_tag_routine_use_after_deallocation;

An exception with this tag is generated when a value or type that uses
a routine is used in certain ways after that routine has been
de-allocated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLES:

      + variable v1;
          {
            procedure p1()  { };
            v1 := p1;
            [] := [v1 == 7];
          };
        [] := [v1 == 7];

      + immutable i1 := procedure()  { };
        [] := [i1 == 7];
        delete(i1);
        [] := [i1 == 7];

  * quark exception_tag_tagalong_use_after_deallocation;

An exception with this tag is generated when a value or type that uses
a tagalong is used in certain ways after that tagalong has been
de-allocated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLES:

      + variable v1;
          {
            tagalong t1;
            v1 := t1;
            [] := [v1 == 7];
          };
        [] := [v1 == 7];

      + immutable i1 := tagalong;
        [] := [i1 == 7];
        delete(i1);
        [] := [i1 == 7];

  * quark exception_tag_lepton_key_use_after_deallocation;

An exception with this tag is generated when a value or type that uses
a lepton key is used in certain ways after that lepton key has been
de-allocated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLES:

      + variable v1;
          {
            lepton l1;
            v1 := l1;
            [] := [v1 == 7];
          };
        [] := [v1 == 7];

      + immutable i1 := lepton;
        [] := [i1 == 7];
        delete(i1);
        [] := [i1 == 7];

      + function expired_key()
          {
            lepton my_key[a : integer, b : string];
            return my_key;
          };
        [] := [expired_key()[a := 12, b := "fifteen"]];

      + immutable my_key := lepton[a : integer, b : string];
        variable v1;
        [] := [my_key[a := 12, b := "fifteen"]];
        delete(my_key);
        [] := [my_key[a := 12, b := "fifteen"]];

  * quark exception_tag_quark_use_after_deallocation;

An exception with this tag is generated when a value or type that uses
a quark is used in certain ways after that quark has been
de-allocated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLES:

      + variable v1;
          {
            quark q1;
            v1 := q1;
            [] := [v1 == 7];
          };
        [] := [v1 == 7];

      + immutable i1 := quark;
        [] := [i1 == 7];
        delete(i1);
        [] := [i1 == 7];

  * quark exception_tag_lock_use_after_deallocation;

An exception with this tag is generated when a value or type that uses
a lock is used in certain ways after that lock has been de-allocated.
The ways that a value or type can be used that can trigger this
exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLES:

      + variable v1;
          {
            lock l1;
            v1 := l1;
            [] := [v1 == 7];
          };
        [] := [v1 == 7];

      + immutable i1 := lock;
        [] := [i1 == 7];
        delete(i1);
        [] := [i1 == 7];

  * quark exception_tag_jump_target_use_after_deallocation;

An exception with this tag is generated when a value or type that uses
a jump target is used in certain ways after that jump target has been
de-allocated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLE:

      + variable v1;
          {
          l1:
            v1 := l1;
            [] := [v1 == 7];
          };
        [] := [v1 == 7];

  * quark exception_tag_object_use_after_deallocation;

An exception with this tag is generated when a value or type that uses
an object is used in certain ways after that object has been
de-allocated.  The ways that a value or type can be used that can
trigger this exception are the same as those that can trigger an
exception_tag_variable_use_before_instantiation exception.

EXAMPLE:

      + class c1()  { };
        immutable i1 := c1();
        [] := [i1 == 7];
        delete(i1);
        [] := [i1 == 7];

  * quark exception_tag_unbound_name_reference;

An exception with this tag is generated if an attempt is made to
evaluate an expression that consists of an unbound name.  Note,
however, that it is legal for an implementation to give an error
message and refuse to even start running a program if it can tell at
parse time that an identifier used as an expression is unbound.  It is
also legal for an implementation to give an exception at the execution
of a ``use'' statement if that statement was the last chance to bind a
name used as an expression and the execution of the ``use'' statement
failed to bind it.  Implementations that do both of those checks will
never generate an exception with this tag because they will stop when
the binding step fails.  This exception is provided just in case an
implementation chooses for some reason to let the user execute code
that is known to have unbound references.

  * quark exception_tag_lepton_bad_key;

An exception with this tag is generated when a lepton expression is
evaluated and the key expression evaluates to something other than a
lepton key value.

EXAMPLE:

      + immutable bad_key := 17;
        [] := [bad_key[a := 12, b := 15]];

  * quark exception_tag_lepton_key_deleted_in_expression;

An exception with this tag is generated when a lepton expression is
evaluated and the key expression evaluates to a valid lepton key but
then while other sub-expressions of the lepton expression are
evaluated that key is deleted.

EXAMPLE:

      + immutable key := lepton[...];
        [] := [key[a := 12, b := { delete(key); return 15; }]];

  * quark exception_tag_lepton_field_type_cant_force;

An exception with this tag is generated when a lepton expression is
evaluated and the value assigned to one of the fields with a ``::=''
operator can't be forced to the type required for that field by the
key.

EXAMPLE:

      + lepton my_key[a : integer, b : string];
        [] := [my_key[a := 12, b ::= 15]];

  * quark exception_tag_lepton_field_type_mismatch;

An exception with this tag is generated when a lepton expression is
evaluated and the value assigned to one of the fields doesn't match
the type required for that field by the key.

EXAMPLE:

      + lepton my_key[a : integer, b : string];
        [] := [my_key[a := 12, b := 15]];

  * quark exception_tag_lepton_field_type_match_indeterminate;

An exception with this tag is generated when a lepton expression is
evaluated and the implementation is unable to determine whether the
value assigned to one of the fields matches the type required for that
field by the key.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        lepton my_key[a : integer, b : type filter_a];
        [] := [my_key[a := 12, b := type filter_b]];

  * quark exception_tag_lepton_field_disallowed;

An exception with this tag is generated when a lepton expression is
evaluated and it contains a field name that is not allowed by the key.

EXAMPLE:

      + lepton my_key[a : integer, b : integer];
        [] := [my_key[a := 12, b := 15, c := 17]];

  * quark exception_tag_pointer_field_reference_bad_base;

An exception with this tag is generated when a pointer field reference
expression is evaluated or has its address taken and the base is not a
pointer and overloading doesn't apply.

EXAMPLES:

      + [] := [13->a];

      + [] := [&(13->a)];

  * quark exception_tag_tagalong_reference_bad_key;

An exception with this tag is generated when the key expression of a
tagalong field reference expression evaluates to something other than
a tagalong key.

EXAMPLES:

      + [] := [13..5];

      + variable v1;
        [] := [&(v1..5)];

  * quark exception_tag_tagalong_reference_undefined;

An exception with this tag is generated when a tagalong field
reference expression is used with a key that doesn't have a default
value on a value that doesn't have a value associated with that
tagalong key.

EXAMPLE:

      + variable v1 := 15;
        tagalong t1;
        [] := [v1..t1];

  * quark exception_tag_statement_block_expression_no_value;

An exception with this tag is generated when executing a statement
block expression doesn't result in a value being returned because no
return statement is executed.

EXAMPLE:

      + [] := [{}];

  * quark exception_tag_statement_block_expression_return_no_value;

An exception with this tag is generated when a return statement
without a value is executed with that return statement referencing a
statement block expression.

EXAMPLE:

      + [] := [{ return; }];

  * quark exception_tag_semi_labeled_expression_list_duplicate_label;

An exception with this tag is generated when a semi-labeled expression
list expression is execute with the same label showing up more than
once in the expression.  The exception is taken after the value
corresponding to the first duplicate label has been evaluated.

EXAMPLE:

      + [] := [["fish", c := "bird", c := "lizard"]];

  * quark exception_tag_conditional_bad_test;

An exception with this tag is generated when a conditional expression
is being evaluated and the test expression evaluates to a value other
than true or false.

EXAMPLE:

      + [] := ["hello" ? 1 : 2];

  * quark exception_tag_dereference_bad_base;

An exception with this tag is generated when a pointer dereference
expression is evaluated or has its address taken and the base is not a
pointer and overloading doesn't apply.

EXAMPLE:

      + [] := [*237];

  * quark exception_tag_in_indeterminate;

An exception with this tag is generated when an ``in'' expression is
evaluated and the implementation is unable to determine whether the
value is in the type.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [type filter_a in type filter_b];

  * quark exception_tag_force_indeterminate;

An exception with this tag is generated when a force expression is
evaluated and the implementation is unable to determine whether the
type is one that the value can be forced to.

EXAMPLES:

      + [] := [7 :: {3, 5, 18, "blue"}];

      + [] := [7 :: !{3, 5, 7, 18, "blue"}];

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [7 :: filter_a & !{7}];

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [7 :: filter_a | !{7}];

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [7 :: filter_a ^ !{7}];

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [7 :: filter_a];

      + immutable filter_a := pure function (x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [7 :: filter_a];

  * quark exception_tag_force_cant_force;

An exception with this tag is generated when a force expression is
evaluated with a value which cannot be forced into the specified type.

EXAMPLE:

      + [] := ["horse" :: integer];

  * quark exception_tag_comprehend_bad_test;

An exception with this tag is generated when the test expression of a
comprehend expression evaluates to something other than a boolean
value.

EXAMPLE:

      + [] := [comprehend (x; [1, 2, 3]; "plumb") (x*x)];

  * quark exception_tag_forall_executed;

An exception with this tag is generated when a forall expression is
evaluated.

EXAMPLE:

      + [] := [forall(x : boolean) (x || !x)];

  * quark exception_tag_exists_executed;

An exception with this tag is generated when an exists expression is
evaluated.

EXAMPLE:

      + [] := [exists(x : integer) (x + 17 == 57)];

  * quark exception_tag_pointer_subtraction_indeterminate;

An exception with this tag is generated when a subtraction expression
is being evaluated with pointer arguments and the implementation is
unable to determine whether the pointers are equal.  This can happen
when each pointer is the address of a lookup and the arguments to the
lookup are values for which the implementation cannot tell whether
they are equal.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 := <<(* --> 15)>>;
        [] := [&(v1[type filter_a]) - &(v1[type filter_b])];

  * quark exception_tag_pointer_subtraction_non_lookup;

An exception with this tag is generated when a subtraction expression
is being evaluated with pointer arguments and the two pointers are not
equal but at least one of them is not the location of a lookup.

EXAMPLE:

      + variable v1 := <<(* --> 15)>>;
        [] := [&v1 - &(v1[15])];

  * quark exception_tag_pointer_subtraction_overload_mismatch;

An exception with this tag is generated when a subtraction expression
is being evaluated with pointer arguments that are both locations of
lookups and the two pointers don't use the same overloading of the
lookup operator ("operator[]").

EXAMPLE:

      + variable v1 := <<(* --> 15)>>;
        immutable p1 := &(v1[82]);
          {
            function operator[](x, key : integer)  (key * 5);
            [] := [p1 - &(v1[84])];
          };

  * quark exception_tag_pointer_subtraction_base_indeterminate;

An exception with this tag is generated when a subtraction expression
is being evaluated with pointer arguments that are both locations of
lookups and the implementation is unable to determine whether or not
the bases of the two lookups are equal.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 := <<(* --> 15)>>;
        [] := [&(v1[type filter_a][15]) - &(v1[type filter_b][17])];

  * quark exception_tag_pointer_subtraction_base_mismatch;

An exception with this tag is generated when a subtraction expression
is being evaluated with pointer arguments that are both locations of
lookups and the bases of the two lookups are not equal.

EXAMPLE:

      + variable v1 := <<(* --> 15)>>;
        variable v2 := <<(* --> 15)>>;
        [] := [&(v1[15]) - &(v2[17])];

  * quark exception_tag_divide_force_rational;

An exception with this tag is generated when a divide-force expression
is evaluated and one of its operands is a non-integer rational value.

EXAMPLES:

      + [] := [17.2 /:: 5];

      + [] := [17 /:: 5.2];

  * quark exception_tag_remainder_rational;

An exception with this tag is generated when a remainder expression is
evaluated and one of its operands is a non-integer rational value.

EXAMPLES:

      + [] := [17.2 % 5];

      + [] := [17 % 5.2];

  * quark exception_tag_left_shift_rational;

An exception with this tag is generated when a left shift expression
is evaluated and one of its operands is a non-integer rational value.

EXAMPLES:

      + [] := [17.2 << 5];

      + [] := [17 << 5.2];

  * quark exception_tag_right_shift_rational;

An exception with this tag is generated when a right shift expression
is evaluated and one of its operands is a non-integer rational value.

EXAMPLES:

      + [] := [17.2 >> 5];

      + [] := [17 >> 5.2];

  * quark exception_tag_pointer_comparison_indeterminate;

An exception with this tag is generated when an order comparison
expression is being evaluated with pointer arguments and the
implementation is unable to determine whether the pointers are equal.
This can happen when each pointer is the address of a lookup and the
arguments to the lookup are values for which the implementation cannot
tell whether they are equal.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 := <<(* --> 15)>>;
        [] := [&(v1[type filter_a]) < &(v1[type filter_b])];

  * quark exception_tag_pointer_comparison_non_lookup;

An exception with this tag is generated when an order comparison
expression is being evaluated with pointer arguments and the two
pointers are not equal but at least one of them is not the location of
a lookup.

EXAMPLE:

      + variable v1 := <<(* --> 15)>>;
        [] := [&v1 < &(v1[15])];

  * quark exception_tag_pointer_comparison_overload_mismatch;

An exception with this tag is generated when an order comparison
expression is being evaluated with pointer arguments that are both
locations of lookups and the two pointers don't use the same
overloading of the lookup operator ("operator[]").

EXAMPLE:

      + variable v1 := <<(* --> 15)>>;
        immutable p1 := &(v1[82]);
          {
            function operator[](x, key : integer)  (key * 5);
            [] := [p1 > &(v1[84])];
          };

  * quark exception_tag_pointer_comparison_base_indeterminate;

An exception with this tag is generated when an order comparison
expression is being evaluated with pointer arguments that are both
locations of lookups and the implementation is unable to determine
whether or not the bases of the two lookups are equal.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 := <<(* --> 15)>>;
        [] := [&(v1[type filter_a][15]) <= &(v1[type filter_b][17])];

  * quark exception_tag_pointer_comparison_base_mismatch;

An exception with this tag is generated when an order comparison
expression is being evaluated with pointer arguments that are both
locations of lookups and the bases of the two lookups are not equal.

EXAMPLE:

      + variable v1 := <<(* --> 15)>>;
        variable v2 := <<(* --> 15)>>;
        [] := [&(v1[15]) >= &(v2[17])];

  * quark exception_tag_binary_bad_operands;

An exception with this tag is generated when a binary expression is
evaluated with operand values that individually could be legal in
those positions but are illegal in that combination.  Such an
exception is also generated for any illegal value in the case of
concatenation.

EXAMPLES:

      + variable v1 := <<(* --> 15)>>;
        [] := [&(v1[15]) >= 17];

      + [] := ["tree" ~ 17];

      + [] := ["tree" ~ [17]];

  * quark exception_tag_equality_test_indeterminate;

An exception with this tag is generated when an equality or inequality
comparison expression is being evaluated and the implementation is
unable to determine whether or not the two argument values are equal.

EXAMPLES:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [type filter_a == type filter_b];

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [type filter_a != type filter_b];

  * quark exception_tag_array_type_bad_lower;

An exception with this tag is generated when an array type expression
is being evaluated and the lower bound expression evaluates to a
non-integer value or the value zero-zero or unsigned infinity.

EXAMPLES:

      + variable v1 : integer["five"...17];

      + variable v1 : integer[0/0...17];

      + variable v1 : integer[1/0...17];

  * quark exception_tag_array_type_bad_upper;

An exception with this tag is generated when an array type expression
is being evaluated and the upper bound expression evaluates to a
non-integer value or the value zero-zero or unsigned infinity.

EXAMPLES:

      + variable v1 : integer[17..."five"];

      + variable v1 : integer[17...0/0];

      + variable v1 : integer[17...1/0];

  * quark exception_tag_range_type_bad_lower;

An exception with this tag is generated when a range type expression
is being evaluated and the lower bound expression evaluates to a
non-integer value or the value zero-zero or unsigned infinity.

EXAMPLES:

      + variable v1 : ["five"...17];

      + variable v1 : [0/0...17];

      + variable v1 : [1/0...17];

  * quark exception_tag_range_type_bad_upper;

An exception with this tag is generated when a range type expression
is being evaluated and the upper bound expression evaluates to a
non-integer value or the value zero-zero or unsigned infinity.

EXAMPLES:

      + variable v1 : [17..."five"];

      + variable v1 : [17...0/0];

      + variable v1 : [17...1/0];

  * quark exception_tag_lepton_type_bad_key;

An exception with this tag is generated when a lepton type expression
is being evaluated and the key expression evaluates to a value that is
not a lepton key.

EXAMPLE:

      + variable v1 : lepton 37[a : string, b : integer];

  * quark exception_tag_routine_addressed;

An exception with this tag is generated when the address of an
expression is being evaluated and that expression is an identifier
that is bound to a routine or a chain of routines through a ``use''
statement.  Note that if the address of an identifier expression is
taken and that identifier is directly bound to a routine or routine
chain then this exception does not apply because such problems are
found at parse time, so the implementation should generate an error
message at parse time and exit without even starting to execute the
program.

EXAMPLES:

      + use class()
          {
            function f1(x)  (x + 3);
          }();
        [] := [&f1];

      + use class()
          {
            function f1(x)  (x + 3);
            function f1(x, y)  (x + y);
          }();
        [] := [&f1];

  * quark exception_tag_label_addressed;

An exception with this tag is generated when the address of an
expression is being evaluated and that expression is an identifier
that is bound to a jump target label but only after a possible binding
of that identifier through a ``use'' statement fails to bind it to
something else.  Note that if the address of an identifier expression
is taken and that identifier is directly bound to a jump target label
then this exception does not apply because such problems are found at
parse time, so the implementation should generate an error message at
parse time and exit without even starting to execute the program.  And
a ``use'' statement cannot bind an identifier to a jump target label
because a jump target label may not be exported from an object.  So
the only case that is left for this except is when the ``use''
statement might have bound the identifier to something else but at
runtime it turns out not to do so.

EXAMPLE:

      + l1:
            {
              use class()  {}();
              [] := [&l1];
            };

  * quark exception_tag_tagalong_key_addressed;

An exception with this tag is generated when the address of an
expression is being evaluated and that expression is an identifier
that is bound to a tagalong key through a ``use'' statement.  Note
that if the address of an identifier expression is taken and that
identifier is directly bound to a tagalong key then this exception
does not apply because such problems are found at parse time, so the
implementation should generate an error message at parse time and exit
without even starting to execute the program.

EXAMPLE:

      + use class()
          {
            tagalong t1;
          }();
        [] := [&t1];

  * quark exception_tag_lepton_key_addressed;

An exception with this tag is generated when the address of an
expression is being evaluated and that expression is an identifier
that is bound to a lepton key through a ``use'' statement.  Note that
if the address of an identifier expression is taken and that
identifier is directly bound to a lepton key then this exception does
not apply because such problems are found at parse time, so the
implementation should generate an error message at parse time and exit
without even starting to execute the program.

EXAMPLE:

      + use class()
          {
            lepton l1;
          }();
        [] := [&l1];

  * quark exception_tag_quark_addressed;

An exception with this tag is generated when the address of an
expression is being evaluated and that expression is an identifier
that is bound to a quark through a ``use'' statement.  Note that if
the address of an identifier expression is taken and that identifier
is directly bound to a quark then this exception does not apply
because such problems are found at parse time, so the implementation
should generate an error message at parse time and exit without even
starting to execute the program.

EXAMPLE:

      + use class()
          {
            quark q1;
          }();
        [] := [&q1];

  * quark exception_tag_lock_addressed;

An exception with this tag is generated when the address of an
expression is being evaluated and that expression is an identifier
that is bound to a lock through a ``use'' statement.  Note that if the
address of an identifier expression is taken and that identifier is
directly bound to a lock then this exception does not apply because
such problems are found at parse time, so the implementation should
generate an error message at parse time and exit without even starting
to execute the program.

EXAMPLE:

      + use class()
          {
            lock l1;
          }();
        [] := [&l1];

  * quark exception_tag_tagalong_unset;

An exception with this tag is generated when a pointer is being
dereferenced and the pointer is the location of a tagalong field
reference expression for which the key doesn't have a default value
and the base value that doesn't have a value associated with that
tagalong key.

EXAMPLE:

      + variable v1 := 15;
        tagalong t1;
        [] := [*&(v1..t1)];

  * quark exception_tag_tagalong_base_undefined;

An exception with this tag is generated when an assignment is being
done that attempts to set a tagalong field value but the base value
onto which the tagalong field is to be set is undefined.

EXAMPLE:

      + variable v1;
        tagalong t1;
        v1..t1 := 15;

  * quark exception_tag_tagalong_type_mismatch;

An exception with this tag is generated when an assignment is being
done that attempts to set a tagalong field value for which the base
value onto which the tagalong field is not in the type that is allowed
as the base for that tagalong.

EXAMPLE:

      + variable v1 := "apple";
        tagalong t1 : integer on integer;
        v1..t1 := 15;

  * quark exception_tag_tagalong_type_match_indeterminate;

An exception with this tag is generated when an assignment is being
done that attempts to set a tagalong field value for which the
implementation is unable to determine whether the base value onto
which the tagalong field is being set is in the type that is allowed
as the base for that tagalong.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 := type filter_a;
        tagalong t1 : integer on type filter_b;
        v1..t1 := 15;

  * quark exception_tag_non_pointer_no_overloaded_match;

An exception with this tag is generated when either a read or a write
is being done through a pointer and that pointer is the location of an
overloaded pointer dereference or field access operation and there is
no match on the possible overloaded routines for that base and new
value.

Note that simple assignment cases that could lead to an exception of
this tag being generated won't necessarily do so because the problem
could be caught as a type error with a type error exception being
generated at an earlier point, before an exception with this tag would
come in.  That's because an implementation will typically keep some
type information on pointers to keep track of what values are legal to
assign to those pointers.  In simple cases, a lack of an overloading
match for particular values will be reflected in the type
information.  This exception will only come in when the situation is
complicated enough that the implementation's analysis of the pointer's
type information can't catch the problem earlier.  That's why in the
examples here the overloading of the pointer dereference or field
access is combined with overloading of a lookup, so that it's
complicated enough for the implementation not to be able to figure out
ahead of time that the assignment will fail.  Of course, a more
sophisticated implementation could figure this out and reflect it in
the pointer type information, but that's true of any example we could
come up with.  These examples reflect cases where an implementation is
likely to generate an exception with this tag, though some
implementations may generate an assignment type exception instead.  In
any case, some exception will be generated for each of these examples.

EXAMPLES:

      + function operator*(x : [1...14])  (x * 15);
        [] := [*&*15];

      + function operator->(x : [1...14], field : string)  (x * 15);
        [] := [*&(15->a)];

      + function operator*(base : [1...15])  (base);
        procedure operator*(base : [1...1500], new_value : [12...93])  { };
        function operator[](base : integer, key : integer, new_value : integer)
          (base + key + new_value);
        (*4)[3] := 87;

      + function operator->(base : [1...15], field : string)  (base);
        procedure operator->(base : [1...1500], field : string,
                             new_value : [12...93])  { };
        function operator[](base : integer, key : integer, new_value : integer)
          (base + key + new_value);
        (4->b)[3] := 87;

  * quark exception_tag_multi_lookup_bad_key;

An exception with this tag is generated when a multi-dimensional
lookup expression is being evaluated or having its address taken and
one of its keys evaluates to a non-integer value.

EXAMPLE:

      + variable v1 := <<(* --> 15)>>;
        [] := [v1["hello", 15]];

  * quark exception_tag_lookup_bad_lower;

An exception with this tag is generated when a lookup expression is
being evaluated or having its address taken and one of its elements is
a range and the lower bound expression of that range evaluates to a
non-integer value or to unsigned infinity or zero-zero.

EXAMPLES:

      + variable v1 := <<(* --> 15)>>;
        [] := [v1["hello"...15]];

      + variable v1 := <<(* --> 15)>>;
        [] := [v1[1/0...15]];

      + variable v1 := <<(* --> 15)>>;
        [] := [v1[0/0...15]];

  * quark exception_tag_lookup_bad_upper;

An exception with this tag is generated when a lookup expression is
being evaluated or having its address taken and one of its elements is
a range and the upper bound expression of that range evaluates to a
non-integer value or to unsigned infinity or zero-zero.

EXAMPLES:

      + variable v1 := <<(* --> 15)>>;
        [] := [v1[1..."hello"]];

      + variable v1 := <<(* --> 15)>>;
        [] := [v1[1...1/0]];

      + variable v1 := <<(* --> 15)>>;
        [] := [v1[1...0/0]];

  * quark exception_tag_overloading_resolution_no_match;

An exception with this tag is generated when the actual arguments for
a routine call don't match any of the routines that overloading allows
as possibilities for that call site.

EXAMPLES:

      + procedure p1(x : integer)  { };
        procedure p1(x : string)  { };
        p1(5.7);

      + (procedure(x : integer)  { })();

  * quark exception_tag_stack_overflow;

An exception with this tag may be generated when there is insufficient
space on the call stack to complete a call.

Note that implementations are not required to generate an exception
with this tag.  Implementations are permitted to let the program crash
or have undefined behavior if the call depth exceeds the limits of the
platform.

  * quark exception_tag_call_no_routine;

An exception with this tag is generated when a call site is being
evaluated and the routine expression for the call site evaluates to a
value that is not a routine or a chain of routines.

EXAMPLE:

      + 57(17);

  * quark exception_tag_call_class_procedure;

An exception with this tag is generated when a procedure call site
uses a class as the routine to call.

EXAMPLE:

      + class c1()  {};
        c1();

  * quark exception_tag_call_argument_type_mismatch;

An exception with this tag is generated when the value assigned to a
formal parameter for a call site does not match that parameter's
static type.

Note that if the value is provided in the actual arguments at the call
site and it doesn't match the parameter's type, the parameter list
won't be considered a match to that routine, so a different routine
will be selected by overloading or another kind of exception will
occur if none of the overloading candidates matches.  So the only way
this exception can occur is if the parameter has a default expression
and when that default expression is evaluated for that call the value
doesn't match the required static type.

EXAMPLES:

      + procedure p1(x : integer := 17.2)  { };
        p1();

      + procedure p1(: integer := 17.2)  { };
        p1();

  * quark exception_tag_call_argument_type_match_indeterminate;

An exception with this tag is generated when the implementation is
unable to determine whether the value assigned to a formal parameter
for a call site matches that parameter's static type.

Note that if the value is provided in the actual arguments at the call
site and the implementation can't figure out whether it matches the
parameter's type, a different kind of exception will occur earlier
because overloading resolution will fail if there is an overloading
chain or the check that the actual arguments matches the routine will
fail.  So the only way this exception can occur is if the parameter
has a default expression and when that default expression is evaluated
for that call the failure to determine whether the type matches
occurs.

EXAMPLES:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        procedure p1(x : type filter_a := type filter_b)  { };
        p1();

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        procedure p1(: type filter_a := type filter_b)  { };
        p1();

  * quark exception_tag_call_dynamic_parameter_type_mismatch;

An exception with this tag is generated when the actual argument at a
routine call site fails to match that parameter's dynamic type.

EXAMPLE:

      + procedure p1(x : integer,
                y : integer / <<pure function(z) returns boolean
                                  (z < x)>>)  { };
        p1(10, 15);

  * quark exception_tag_call_dynamic_parameter_type_match_indeterminate;

An exception with this tag is generated when the implementation can't
determine whether the actual argument at a routine call site matches
that parameter's dynamic type.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        procedure p1(x : integer, y : type !{} / type filter_a)  { };
        p1(10, type filter_b);

  * quark exception_tag_call_side_effect_external_from_pure;

An exception with this tag is generated when an external routine that
is not guaranteed to be safe for a pure context is called from within
a call to a pure routine.  An external routine is one whose body is
defined outside of Salmon.  Many external routines have external side
effects or read modifiable external state, making them unsuitable for
use within pure routines.  How external routines are specified is
implementation-dependent.

EXAMPLE:

      + [] := [pure function() { print("Something.\n"); }()];

  * quark exception_tag_if_bad_test;

An exception with this tag is generated when the test expression of an
if statement evaluates to something other than true or false.  Such an
exception is also generated when the test expression for an ``else
if'' clause of an if statement has this problem.

EXAMPLES:

      + if (15)
          { };

      + if (false)
          { }
        else if (15)
          { };

  * quark exception_tag_switch_indeterminate;

An exception with this tag is generated when the implementation is
unable to determine whether the test value of a switch statement is in
one of the case types of the switch.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        switch (type filter_a)
        case (type filter_b)
          { };

  * quark exception_tag_goto_bad_target;

An exception with this tag is generated when the target expression of
a goto statement evaluates to something other than a jump target
value.

EXAMPLE:

      + goto 1955;

  * quark exception_tag_goto_target_deallocated;

An exception with this tag is generated when a goto statement is
executed and the target expression evaluates to a jump target whose
scope has already been exited.

EXAMPLES:

      + variable v1;
          {
          l1:
            v1 := l1;
          };
        goto v1;

      + variable v1;
        variable v2;
          {
          l1:
            v1 := l1;
            v2 := function(x)(x*x);
          };
        goto v1;

  * quark exception_tag_return_target_deallocated;

An exception with this tag is generated when a return statement is
executed and the target of the return has already exited.

EXAMPLE:

      + variable v1;
        routine f1()
          { v1 := procedure() { return from f1; }; };
        f1();
        v1();

  * quark exception_tag_for_bad_initial;

An exception with this tag is generated when the initial expression of
a for statement evaluates to something other than an integer value.

EXAMPLE:

      + for (x; [10]; x < 50)
          { };

  * quark exception_tag_for_bad_step;

An exception with this tag is generated when the step expression of a
for statement evaluates to something other than an integer value.

EXAMPLE:

      + for (x; 10; x < 50; [1])
          { };

  * quark exception_tag_for_bad_test;

An exception with this tag is generated when the test expression of a
for statement evaluates to something other than a boolean value.

EXAMPLE:

      + for (x; 10; [x < 50])
          { };

  * quark exception_tag_iteration_base_array_indeterminate;

An exception with this tag is generated when the base expression of an
iterate statement or comprehend expression evaluates to a map and the
implementation is unable to determine whether all the keys are
integers.  An exception with this tag is also generated when the base
expression of an iterate statement or comprehend expression evaluates
to a map and the implementation is unable to determine either the
minimum or maximum key of that map.

EXAMPLES:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        iterate (x; <<(* : filter_a --> 10)>>)
          { };

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        iterate (x; <<(* : ([0...8] & filter_a) --> 10)>>)
          { };

  * quark exception_tag_iteration_bad_base;

An exception with this tag is generated when the base expression of an
iterate statement or comprehend expression evaluates to a map with at
least one non-integer key; a sparse array; or a value that is not a
map, semi-labeled value list, or value with fields with a field named
`iterate' containing a function that accepts an empty parameter list.

EXAMPLES:

      + iterate (x; 10)
          { };

      + iterate (x; <<("apple" --> 15)>>)
          { };

      + iterate (x; <<(0 --> "first"), (3 --> "second")>>)
          { };

  * quark exception_tag_iterator_bad_is_done;

An exception with this tag is generated when the base expression of an
iterate statement or comprehend expression has an iterator() function
field but the value returned by that function either doesn't have an
is_done() function field that accepts an empty argument list or it has
such a function but calling that function returns a value other than
true or false.

EXAMPLES:

      + class c1()
          {
            function iterator()  (16);
          };
        iterate (x; c1())
          { };

      + class square(count : integer)
          {
            hide position;
            variable position := 0;
            function is_done()  (position);
            function current() returns integer  (position * position);
            procedure step()  { ++position; };
          };
        class c1()
          {
            function iterator()  (square(16));
          };
        iterate (x; c1())
          { print(x, ".\n"); };

  * quark exception_tag_iterator_bad_current;

An exception with this tag is generated when the base expression of an
iterate statement or comprehend expression has an iterator() function
field but the value returned by that function doesn't have a current()
function field that accepts an empty argument list.

EXAMPLE:

      + class square(count : integer)
          {
            hide position;
            variable position := 0;
            function is_done() returns boolean  (position >= count);
            procedure step()  { ++position; };
          };
        class c1()
          {
            function iterator()  (square(16));
          };
        iterate (x; c1())
          { print(x, ".\n"); };

  * quark exception_tag_iterator_bad_step;

An exception with this tag is generated when the base expression of an
iterate statement or comprehend expression has an iterator() function
field but the value returned by that function doesn't have a step()
procedure field that accepts an empty argument list.

EXAMPLE:

      + class square(count : integer)
          {
            hide position;
            variable position := 0;
            function is_done() returns boolean  (position >= count);
            function current() returns integer  (position * position);
          };
        class c1()
          {
            function iterator()  (square(16));
          };
        iterate (x; c1())
          { };

  * quark exception_tag_iterate_bad_test;

An exception with this tag is generated when the test expression of an
iterate statement evaluates to something other than a boolean value.

EXAMPLE:

      + iterate (x; [1, 2, 3]; "clams")
          { };

  * quark exception_tag_while_bad_test;

An exception with this tag is generated when the test expression of a
while statement evaluates to something other than a boolean value.

EXAMPLE:

      + while ("clams")
          { };

  * quark exception_tag_do_while_bad_test;

An exception with this tag is generated when the test expression of a
do-while statement evaluates to something other than a boolean value.

EXAMPLE:

      + do
          { } while (57);

  * quark exception_tag_single_lock_not_lock;

An exception with this tag is generated when the lock expression of a
``single'' statement evaluates to something other than a lock value.

EXAMPLE:

      + single (38) { };

  * quark exception_tag_try_handle_bad_handler;

An exception with this tag is generated when the handler expression of
a try-handle statement evaluates to something other than a routine.

EXAMPLE:

      + try {}
        handle "clock";

  * quark exception_tag_export_label;

An exception with this tag is generated when an export statement is
execute that specifies a name that binds to a jump target label.

EXAMPLES:

      + class c1()
          {
          l1:
            export l1;
          };
        [] := [c1()];

      + l1:
          class c1()
            {
              use class() {}();
              export l1;
            };
          [] := [c1()];

  * quark exception_tag_use_type_match_indeterminate;

An exception with this tag is generated when the expression of a
``use'' statement is executed and the implementation is unable to
determine whether the value is in the type.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 4) == 1));
        use class()
          {
            function f1() returns filter_b (1);
          }() : interface [f1 :- filter_a <-- ()];

  * quark exception_tag_use_type_mismatch;

An exception with this tag is generated when the expression of a
``use'' statement evaluates to a value that is not in its type.

EXAMPLE:

      + use class(){}() : integer;

  * quark exception_tag_use_bad_base;

An exception with this tag is generated when the expression of a
``use'' statement evaluates to something other than an object.

EXAMPLE:

      + use 118;

  * quark exception_tag_use_missing_field;

An exception with this tag is generated when a ``use'' statement is
executed within a class while exporting is enabled and the use
statement explicitly names a field that is not present in the object.

EXAMPLE:

      + class c2()
          {
          };
        class c1()
          {
            use c2() for practice;
          };
        [] := [c1()];

  * quark exception_tag_use_not_executed;

An exception with this tag is generated when a name that might be
bound by a ``use'' statement is accessed before that ``use'' statement
is executed.

EXAMPLE:

      + p1();
        use class() {}();

  * quark exception_tag_use_multiply_instantiated;

An exception with this tag is generated when a ``use'' statement is
executed a second time in the same instance of the same scope.

EXAMPLE:

      + loop:
          use class() {}();
          goto loop;

  * quark exception_tag_use_unbound_remains;

An exception with this tag is generated when a ``use'' statement is
executed that might have bound a reference to an identifier but does
not bind it and it was the last chance to bind that reference.

EXAMPLE:

      + use class(){}();
        p1();

  * quark exception_tag_cleanup_jump;

An exception with this tag is generated when a jump is attempted out
of a cleanup statement to a jump target label within the statement
block containing the cleanup statement.

Note that such an exception will not be generated if the stack is
already in the process of being unwound because of a jump out of the
scope containing the cleanup statement because that jump takes
precedence and the new jump will be ignored because it is more
shallow.

Note also that the exception is generated when the attempted jump
reaches the point were control would normally actually arrive at the
target.  If any stack unwinding is to be done within the cleanup
statement after the issuance of the jump, that stack unwinding, which
can include executing other cleanup statements from within the context
of the main cleanup statement, takes place before the exception
occurs.

EXAMPLES:

      + l1:
          cleanup
            { goto l1; };

      + class c1()
          {
          l1:
            cleanup
              { goto l1; };
          };
        [] := [c1()];

  * quark exception_tag_variable_lock_not_lock;

An exception with this tag is generated when the lock expression for a
single modifier on a variable declaration evaluates to a value that is
not a lock.

EXAMPLE:

      + single (15) variable v1;

  * quark exception_tag_routine_lock_not_lock;

An exception with this tag is generated when the lock expression for a
single modifier on a routine declaration evaluates to a value that is
not a lock.

EXAMPLES:

      + single ("Pluto") procedure p1()  { };

      + single ("Pluto") function f1()  ("Charon");

  * quark exception_tag_tagalong_lock_not_lock;

An exception with this tag is generated when the lock expression for a
single modifier on a tagalong declaration evaluates to a value that is
not a lock.

EXAMPLE:

      + single (5.7) tagalong t1;

  * quark exception_tag_lock_single_lock_not_lock;

An exception with this tag is generated when the lock expression for a
single modifier on a lock declaration evaluates to a value that is not
a lock.

EXAMPLE:

      + single ([]) lock l1;

  * quark exception_tag_initialize_variable_mismatch;

An exception with this tag is generated when the initialization
expression for a variable or immutable declaration yields a value that
is not in the type of the variable or immutable.

EXAMPLES:

      + variable v1 : string := 1066;

      + [] := [variable : string := 1066];

  * quark exception_tag_initialize_variable_match_indeterminate;

An exception with this tag is generated when the implementation is
unable to determine whether the initialization expression for a
variable or immutable declaration yields a value that is in the type
of the variable or immutable.

EXAMPLES:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 : type filter_a := type filter_b;

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [variable : type filter_a := type filter_b];

  * quark exception_tag_tagalong_default_mismatch;

An exception with this tag is generated when the default value
expression for a tagalong evaluates to a value that is not in the type
of the tagalong.

EXAMPLES:

      + tagalong t1 : string := 1066;

      + [] := [tagalong : string := 1066];

  * quark exception_tag_tagalong_default_match_indeterminate;

An exception with this tag is generated when the default value
expression for a tagalong evaluates to a value for which the
implementation is unable to determine whether that value is in the
type of the tagalong.

EXAMPLES:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        tagalong t1 : type filter_a := type filter_b;

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [tagalong : type filter_a := type filter_b];

  * quark exception_tag_variable_declaration_re_executed;

An exception with this tag is generated when a variable declaration
statement is re-executed for the same variable instance.

EXAMPLE:

      + loop:
          variable v1;
          goto loop;

  * quark exception_tag_routine_declaration_re_executed;

An exception with this tag is generated when a routine declaration
statement is re-executed for the same routine instance.

EXAMPLE:

      + loop:
          function f1(x)  (x + 17);
          goto loop;

  * quark exception_tag_tagalong_declaration_re_executed;

An exception with this tag is generated when a tagalong declaration
statement is re-executed for the same tagalong instance.

EXAMPLE:

      + loop:
          tagalong t1;
          goto loop;

  * quark exception_tag_lepton_key_declaration_re_executed;

An exception with this tag is generated when a lepton key declaration
statement is re-executed for the same lepton key instance.

EXAMPLE:

      + loop:
          lepton my_lepton;
          goto loop;

  * quark exception_tag_quark_declaration_re_executed;

An exception with this tag is generated when a quark declaration
statement is re-executed for the same quark instance.

EXAMPLE:

      + loop:
          quark q1;
          goto loop;

  * quark exception_tag_lock_declaration_re_executed;

An exception with this tag is generated when a lock declaration
statement is re-executed for the same lock instance.

EXAMPLE:

      + loop:
          lock l1;
          goto loop;

  * quark exception_tag_read_variable_uninstantiated;

An exception with this tag is generated when an attempt is made to
read the value of a variable before that variable's declaration has
been executed.

EXAMPLE:

      + [] := [v1];
        variable v1 := "13";

  * quark exception_tag_read_variable_deallocated;

An exception with this tag is generated when an attempt is made to
read the value of a variable after that variable has been de-alloced,
either because the variable's scope exited in the case of a variable
with a lifetime bound to its scope, or because an explicit delete()
call was made on that variable.

Note that there is a third way that a variable can be de-allocated --
by garbage collection of some sort after it has been determined that
it can no longer be accessed.  But a variable de-allocated by garbage
collect can't be the cause for an exception with this tag because if
it were possible for that variable to be read, it wouldn't have been
eligible for garbage collection in the first place.

EXAMPLES:

      + alias operator* undefined;
        variable p1 : *integer;
          {
            variable v1 : integer := 17;
            p1 := &v1;
          };
        [] := [*p1];

      + alias operator* undefined;
        variable p1 : *integer := variable : integer := 17;
        delete(p1);
        [] := [*p1];

  * quark exception_tag_read_variable_undefined;

An exception with this tag is generated when an attempt is made to
read the value of a variable before a value has been assigned to that
variable.

EXAMPLE:

      + variable v1;
        [] := [v1];

  * quark exception_tag_bad_operands;

An exception with this tag is generated when an operand expression
evaluates to the wrong kind of value for any one of a number of cases
of values and expressions, and where overloading does not provide a
resolution.  These are the cases:

      + A negate or unary plus expression whose operands evaluates to
        a value that is not a rational.

      + An add, subtract, multiply, divide, divide-force, remainder,
        left shift, or right shift expression with either a left-hand
        or right-hand operand that evaluates to a value that is not a
        rational.

      + A bitwise ``not'' expression whose operand evaluates to a
        value that is not an integer.

      + A bitwise ``and'', bitwise ``or'', or bitwise exclusive ``or''
        expression with either a left-hand or right-hand operand that
        evaluates to a value that is not an integer.

      + A logical ``not'' expression whose operand evaluates to a
        value that is not a boolean.

      + A logical ``and'' or logical ``or'' expression with either a
        left-hand or right-hand operand that evaluates to a value that
        is not a boolean.

      + A less than, greater than, less than or equal to, or greater
        than or equal to expression with either a left-hand or
        right-hand operand that evaluates to a value that is neither a
        rational nor a pointer.

EXAMPLES:

      + [] := [-"tulip"];

      + [] := [+"tulip"];

      + [] := [12 + "red"];

      + [] := ["red" + 12];

      + [] := [12 - "red"];

      + [] := ["red" - 12];

      + [] := [12 * "red"];

      + [] := ["red" * 12];

      + [] := [12 / "red"];

      + [] := ["red" / 12];

      + [] := [12 /:: "red"];

      + [] := ["red" /:: 12];

      + [] := [12 % "red"];

      + [] := ["red" % 12];

      + [] := [12 << "red"];

      + [] := ["red" << 12];

      + [] := [12 >> "red"];

      + [] := ["red" >> 12];

      + [] := [~"smile"];

      + [] := [0xfe & "wall"];

      + [] := ["wall" & 0xfe];

      + [] := [0xfe | "wall"];

      + [] := ["wall" | 0xfe];

      + [] := [0xfe ^ "wall"];

      + [] := ["wall" ^ 0xfe];

      + [] := [!"smile"];

      + [] := [true && "wall"];

      + [] := ["wall" && true];

      + [] := [false || "wall"];

      + [] := ["wall" || false];

      + [] := [12 < "red"];

      + [] := ["red" < 12];

      + [] := [12 > "red"];

      + [] := ["red" > 12];

      + [] := [12 <= "red"];

      + [] := ["red" <= 12];

      + [] := [12 >= "red"];

      + [] := ["red" >= 12];

  * quark exception_tag_field_undefined;

An exception with this tag is generated when an attempt is made to
read the value of a named field from a semi-labeled value list,
lepton, or semi-labeled multi-set value which doesn't have a field
with that name.

EXAMPLES:

      + [] := [[a := "train", b := "car"].c];

      + lepton my_lepton;
        [] := [my_lepton[a := "train", b := "car"].c];

      + variable v1;
        v1.a := "train";
        v1.b := "car";
        [] := [v1.c];

  * quark exception_tag_object_no_field;

An exception with this tag is generated when an attempt is made to
read or update the value of a named field from an object which doesn't
have a field with that name.

Note that the object case is different from the semi-labeled value
list, lepton, and semi-labeled multi-set cases because in each of
those other cases an update can be handled by creating a new field.
With objects, new fields can never be created through this kind of
update, so missing fields on updates and reads are handled by this
single exception tag.

EXAMPLES:

      + class c1()
          {
            immutable a := "train";
            immutable b := "car";
          };
        [] := [c1().c];

      + class c1()
          {
            immutable a := "train";
            immutable b := "car";
          };
        variable v1 := c1();
        v1.c[15] := 8;

  * quark exception_tag_object_write_non_data_field;

An exception with this tag is generated when an attempt is made to
modify a field of an object that isn't a variable field.  In other
words, this happens when there is an attempt to modify a routine,
tagalong, lepton, quark, or lock field of an object.

EXAMPLES:

      + class c1()
          {
            function f1(x)  (x * 3);
          };
        variable v1 := c1();
        v1.f1 := 8;

      + class c1()
          {
            tagalong t1;
          };
        variable v1 := c1();
        v1.t1 := 8;

      + class c1()
          {
            lepton l1;
          };
        variable v1 := c1();
        v1.l1 := 8;

      + class c1()
          {
            quark q1;
          };
        variable v1 := c1();
        v1.q1 := 8;

      + class c1()
          {
            lock l1;
          };
        variable v1 := c1();
        v1.l1 := 8;

  * quark exception_tag_field_read_bad_base;

An exception with this tag is generated when an attempt is made to
read the value of a named field from a value that is not a
semi-labeled value list, lepton, semi-labeled multi-set, or object
value.

EXAMPLE:

      + [] := ["sandwich".c];

  * quark exception_tag_basket_read_no_component;

An exception with this tag is generated when an attempt is made to
read through a compound basket instance that doesn't have component
basket instances for all its components.

EXAMPLE:

      + [, ] += 3;

  * quark exception_tag_immutable_modification;

An exception with this tag is generated when an attempt is made to
modify the value of an immutable.  This can happen through attempting
to directly assign to the immutable, by trying to modify a component
of the immutable, or by trying to modify a field of an object where
the field is an immutable.

EXAMPLES:

      + immutable i1 := 8;
        i1 := 9;

      + immutable i1 := [8, 9, 10];
        i1[1] := 9.5;

      + class c1()
          {
            immutable i1 := 8;
          };
        variable v1 := c1();
        v1.i1 := 9;

  * quark exception_tag_write_variable_uninstantiated;

An exception with this tag is generated when an attempt is made to
modify the value of a variable before that variable's declaration has
been executed.  This can happen through attempting to directly assign
to the variable, by trying to modify a component of the variable, or
by trying to modify a field of an object where the field is a
variable.

EXAMPLE:

      + class c1()
          {
            export v1;
            variable my_this := this;
              {
                cleanup
                  { my_this := null; };
                my_this.v1 := "spleen";
              };
            variable v1;
          };
        immutable i1 := c1();

  * quark exception_tag_write_variable_deallocated;

An exception with this tag is generated when an attempt is made to
modify the value of a variable after that variable has been
de-alloced, either because the variable's scope exited in the case of
a variable with a lifetime bound to its scope, or because an explicit
delete() call was made on that variable.  This can happen through
attempting to directly assign to the variable, by trying to modify a
component of the variable, or by trying to modify a field of an object
where the field is a variable.

EXAMPLE:

      + class c1()
          {
            export v1;
            ageless variable v1;
            variable my_this := this;
              {
                cleanup
                  { my_this := null; };
                delete(&v1);
                my_this.v1 := "spleen";
              };
          };
        immutable i1 := c1();

  * quark exception_tag_assign_multiple_too_few;

An exception with this tag is generated when an attempt is made to
assign through a multi-item basket from an array with too few values.

EXAMPLE:

      + variable v1, v2;
        [v1, v2] := [13];

  * quark exception_tag_assign_multiple_undefined;

An exception with this tag is generated when an attempt is made to
assign through a multi-item basket from a map where one of the values
needed is undefined.

EXAMPLE:

      + variable v1, v2, v3;
        [v1, v2, v3] := <<(0 --> 12), (2 --> 13)>>;

  * quark exception_tag_assign_multiple_unordered;

An exception with this tag is generated when an attempt is made to
assign through a multi-item basket from a value with multiple
components that doesn't include ordering information -- in other
words, from a semi-labeled multi-set, lepton, or class instance
object.

EXAMPLES:

      + variable v1, v2;
        v1.puppy := "bed";
        [v2] := v1;

      + lepton l1;
        immutable i1 := l1[puppy := "bed"];
        variable v1;
        [v1] := i1;

      + class c1(x)
          {
            export puppy;
            variable puppy := x;
          };
        immutable i1 := c1("bed");
        variable v1;
        [v1] := i1;

  * quark exception_tag_assign_multiple_not_compound;

An exception with this tag is generated when an attempt is made to
assign through a multi-item basket from a value that is not a compound
value -- in other words, from a value that is one of the following:

      + a boolean
      + an integer
      + a rational
      + a string
      + a character
      + a regular expression
      + a quark
      + a lepton key
      + a slot location
      + null
      + a jump target
      + a routine
      + a type
      + a tagalong key reference
      + a lock reference

EXAMPLE:

      + variable v1;
        [v1] := 15;

  * quark exception_tag_write_by_name_missing_field;

An exception with this tag is generated when an attempt is made to
assign through a multi-item basket with an item with a name for which
the value being assigned has no field with that name.  This can happen
if the value being assigned is a map (which never has field names) or
if the value being assigned is a semi-labeled value list, semi-labeled
multi-set, or lepton which doesn't happen to contain a field with the
required name.

EXAMPLES:

      + variable v1;
        [v1 := cat] := [dog := 15];

      + variable v1;
        v1.dog := 15;
        variable v2;
        [v2 := cat] := v1;

      + lepton l1;
        immutable i1 := l1[dog := 15];
        variable v1;
        [v1 := cat] := i1;

      + variable v1;
        [v1 := cat] := <<(0 --> 12), (2 --> 13)>>;

  * quark exception_tag_assignment_type_mismatch;

An exception with this tag is generated when an attempt is made to
assign a value that is not in the type required by the slot being
assigned to.

EXAMPLE:

      + variable v1 : string;
        v1 := 12;

  * quark exception_tag_assignment_type_match_indeterminate;

An exception with this tag is generated when an attempt is made to
assign a value to a slot and the implementation is unable to determine
whether the value is the the type required by the slot.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 : type filter_a;
        v1 := type filter_b;

  * quark exception_tag_concatenation_array_indeterminate;

An exception with this tag is generated when an attempt is made to do
array concatenation where one of the values being concatenated is a
map and the implementation is unable to determine whether that map has
a non-integer key.

EXAMPLES:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [<<(* : filter_a --> 10)>> ~ [0]];

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [<<(* : ([0...8] & filter_a) --> 10)>> ~ [0]];

  * quark exception_tag_concatenation_non_array_map;

An exception with this tag is generated when an attempt is made to do
array concatenation where one of the values being concatenated is a
map with at least one non-integer key.

EXAMPLE:

      + [] := [<<(0 --> "blue")>> ~ <<("zero" --> "red")>>];

  * quark exception_tag_concatenation_sparse_array;

An exception with this tag is generated when an attempt is made to do
array concatenation where one of the values being concatenated is a
map that is not a dense array starting from zero.  To be a map that is
a dense array starting from zero, all keys must be integers, every key
must be greater than or equal to zero, and for every key that is
greater than zero, every other integer greater than or equal to zero
and less than that key must also be a key in that map.

EXAMPLE:

      + [] := [<<(0 --> "blue")>> ~ <<(0 --> "red"), (2 --> "green")>>];

  * quark exception_tag_routine_type_uninstantiated;

An exception with this tag is generated when an attempt is made to use
a routine as a filter type before that instance of that routine has
been instantiated by executing its declaration; or when an attempt is
made to use a routine chain as a filter type before all of the items
in the chain has been instantiated, unless the un-instantiated items
are all known by the implementation not to possibly be used when the
routine is called with a single argument value.

EXAMPLE:

      + variable v1 : type filter_a;
        pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_a(x, y) returns boolean
          ((x in integer) && ((x % y) == 1));

  * quark exception_tag_routine_type_deallocated;

An exception with this tag is generated when an attempt is made to use
a routine as a filter type when that instance of that routine has been
de-allocated; or when an attempt is made to use a routine chain as a
filter type when at least one of the items in the chain has been
de-allocated, unless the de-allocated items are all known by the
implementation not to possibly be used when the routine is called with
a single argument value.

EXAMPLES:

      + variable v1;
          {
            pure function filter_a(x) returns boolean
              ((x in integer) && ((x % 5) == 1));
            pure function filter_a(x, y) returns boolean
              ((x in integer) && ((x % y) == 1));
            v1 := filter_a;
          };
        variable v2 : type v1;

      + variable v1 := pure function(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        delete(v1);
        variable v2 : type v1;

  * quark exception_tag_function_type_non_pure;

An exception with this tag is generated when an attempt is made to use
a routine as a filter type when that routine has not been declared
with the ``pure'' keyword; or when an attempt is made to use a routine
chain as a filter type when at least one of the items in the chain has
not been declared with the ``pure'' keyword, unless the non-pure items
are all known by the implementation not to possibly be used when the
routine is called with a single argument value.

EXAMPLES:

      + function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_a(x : {5, 15}) returns boolean  (true);
        variable v1 : type filter_a;

      + immutable i1 := function(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 : type i1;

  * quark exception_tag_function_type_return_type_mismatch;

An exception with this tag is generated when an attempt is made to use
a routine as a filter type when that routine has not been declared
with a return type that is boolean or a subset of boolean; or when an
attempt is made to use a routine chain as a filter type when at least
one of the items in the chain has not been declared with a return type
that is boolean or a subset of boolean, unless the non-boolean items
are all known by the implementation not to possibly be used when the
routine is called with a single argument value.

EXAMPLES:

      + pure function filter_a(x) returns boolean | {5}
          ((x in integer) && ((x % 5) == 1));
        pure function filter_a(x : {5, 15}) returns boolean  (true);
        variable v1 : type filter_a;

      + immutable i1 := pure function(x) returns boolean | {5}
          ((x in integer) && ((x % 5) == 1));
        variable v1 : type i1;

  * quark exception_tag_function_type_return_type_match_indeterminate;

An exception with this tag is generated when an attempt is made to use
a routine or routine chain as a filter type and the implementation
cannot determine whether the conditions for an exception with tag
exception_tag_function_type_return_type_mismatch are met.  That is,
the routine, or, in the case of a chain, one of the routines which the
implementation cannot determine will not be used when the chain is
called with one argument, has a specified return type that the
implementation is unable to determine whether it is a subset of the
boolean type or not.

EXAMPLES:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns filter_a
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x : {5, 15}) returns boolean  (true);
        variable v1 : type filter_b;

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        immutable i1 := pure function(x) returns filter_a
          ((x in integer) && ((x % 5) == 1));
        variable v1 : type i1;

  * quark exception_tag_function_type_no_arguments;

An exception with this tag is generated when an attempt is made to use
a routine as a filter type and the routine was declared as taking no
arguments.

EXAMPLE:

      + immutable i1 := pure function() returns boolean  (true);
        variable v1 : type i1;

  * quark exception_tag_function_type_argument_type_mismatch;

An exception with this tag is generated when an attempt is made to use
a routine as a filter type and the routine does not accept a single
value as its argument list for every possible value; or, when an
attempt is made to use a routine chain as a filter type and there is
at least one value such that calling that chain with an argument list
of that single value will not hit on any of the items in the chain.

EXAMPLE:

      + immutable i1 := pure function(x : rational) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 : type i1;

  * quark exception_tag_function_type_argument_type_match_indeterminate;

An exception with this tag is generated when an attempt is made to use
a routine as a filter type and the implementation is unable to
determine whether the conditions for generating an exception with tag
exception_tag_function_type_argument_type_mismatch are met.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        immutable i1 := pure function(x : filter_a) returns boolean
          ((x in integer) && ((x % 5) == 1));
        variable v1 : type i1;

  * quark exception_tag_function_type_too_many_arguments;

An exception with this tag is generated when an attempt is made to use
a routine as a filter type and the routine requires more than a single
argument.

EXAMPLE:

      + immutable i1 := pure function(x, y) returns boolean
          ((x in integer) && ((x % y) == 1));
        variable v1 : type i1;

  * quark exception_tag_function_type_resolution_indeterminate;

An exception with this tag is generated when an attempt is made to use
a routine chain as a filter type and the implementation is unabled to
determine whether every value, which used as a single value argument
list in a call to the routine chain, will hit in the chain.

EXAMPLE:

      + pure function filter_a(x : rational) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_a(x : {5, 15}) returns boolean  (true);
        variable v1 : type filter_a;

  * quark exception_tag_type_bad_value;

An exception with this tag is generated when an attempt is made to use
a value as a type and the value is not a type, routine, routine chain,
or lepton key value.

EXAMPLES:

      + immutable i1 := 12.3;
        variable v1 : type i1;

      + variable v1 : <<12.3>>;

  * quark exception_tag_lepton_key_uninstantiated;

An exception with this tag is generated when an attempt is made to use
a lepton key as a type and the lepton key has not yet been
instantiated by executing its declaration.

EXAMPLE:

      + variable v1 : l1;
        lepton l1;

  * quark exception_tag_lepton_key_deallocated;

An exception with this tag is generated when an attempt is made to use
a lepton key as a type and the lepton key has already been
de-allocated.

EXAMPLE:

      + ageless lepton l1;
        delete(l1);
        variable v1 : l1;

  * quark exception_tag_pointer_subtraction_dimension_mismatch;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between lookup slot locations where the two lookup
slot locations have different numbers of dimensions.

EXAMPLE:

      + variable v1;
        [] := [&v1[1] - &v1[2, 3]];

  * quark exception_tag_pointer_subtraction_lower_dimension_mismatch;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between multi-dimensional lookup slot locations
where the two lookup slot locations have different values for some
dimension other than the final one.

EXAMPLE:

      + variable v1;
        [] := [&v1[1, 2] - &v1[3, 4]];

  * quark exception_tag_pointer_subtraction_lower_dimension_doubt;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between multi-dimensional lookup slot locations
where the implementation is unabled to determine whether the two
lookup slot locations have different values for some dimension other
than the final one.

Note that currently multi-dimensional lookups require all dimensions
to have finite integer values, so there will never been any doubt
about whether they match, so currently an exception with this tag will
never be generated.  This exception tag is a placeholder in case in
the future multi-dimensional lookups are allowed with non-integer
values.

  * quark exception_tag_pointer_subtraction_star_non_star;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between lookup slot locations where a star in one
of the lookups corresponds to a value in the other.

EXAMPLE:

      + variable v1;
        [] := [&v1[*] - &v1[3]];

  * quark exception_tag_pointer_subtraction_star_difference;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between lookup slot locations where a star in one
of the lookups corresponds to a star in the other with a different
filter type.

EXAMPLE:

      + variable v1;
        [] := [&v1[* : integer] - &v1[* : rational]];

  * quark exception_tag_pointer_subtraction_range_non_range;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between lookup slot locations where a range in one
of the lookups corresponds to a single value in the other.

EXAMPLE:

      + variable v1;
        [] := [&v1[3...5] - &v1[3]];

  * quark exception_tag_pointer_subtraction_incompatible_ranges;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between lookup slot locations with ranges in
corresponding positions where these ranges are not the same.

EXAMPLE:

      + variable v1;
        [] := [&v1[3...5] - &v1[3...6]];

  * quark exception_tag_pointer_subtraction_final_match_doubt;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between lookup slot locations with values in the
final dimensions where the implementation is unable to determine
whether the values in the final dimension are the same.

Note that currently exceptions with this tag are never generated
because any pointer subtraction with a non-integer final dimension
causes the generation of an
exception_tag_pointer_subtraction_final_non_integer exception, and the
implementation can always tell if two integers are equal or not.

  * quark exception_tag_pointer_subtraction_final_non_integer;

An exception with this tag is generated when an attempt is made to do
pointer subtraction between lookup slot locations where the value in
the final dimension of at least one of the lookups is not an integer.

EXAMPLE:

      + variable v1;
        [] := [&v1[3] - &v1["sheep"]];

  * quark exception_tag_pointer_integer_addition_non_lookup;

An exception with this tag is generated when an attempt is made to add
a slot location to an integer and the slot location is not a lookup
slot location.

EXAMPLE:

      + variable v1;
        [] := [&(v1.c) + 5];

  * quark exception_tag_pointer_integer_addition_unsigned_infinity;

An exception with this tag is generated when an attempt is made to add
a slot location to an integer and the integer is unsigned infinity.

EXAMPLE:

      + variable v1;
        [] := [&(v1[5]) + 1/0];

  * quark exception_tag_pointer_integer_addition_zero_zero;

An exception with this tag is generated when an attempt is made to add
a slot location to an integer and the integer is zero-zero.

EXAMPLE:

      + variable v1;
        [] := [&(v1[5]) + 0/0];

  * quark exception_tag_pointer_integer_addition_star;

An exception with this tag is generated when an attempt is made to add
a slot location to an integer and the slot location is a lookup slot
location with a star in the final dimension.

EXAMPLE:

      + variable v1;
        [] := [&(v1[*]) + 5];

  * quark exception_tag_pointer_integer_addition_non_integer;

An exception with this tag is generated when an attempt is made to add
a slot location to an integer and the slot location is a lookup slot
location with a single value in the final dimension but that value is
not an integer.

EXAMPLE:

      + variable v1;
        [] := [&(v1["snake"]) + 5];

  * quark exception_tag_pointer_comparison_dimension_mismatch;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between lookup slot locations where the two
lookup slot locations have different numbers of dimensions.

EXAMPLE:

      + variable v1;
        [] := [&(v1[3, 5]) < &(v1[7])];

  * quark exception_tag_pointer_comparison_lower_dimension_mismatch;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between multi-dimensional lookup slot locations
where the two lookup slot locations have different values for some
dimension other than the final one.

EXAMPLE:

      + variable v1;
        [] := [&(v1[3, 5]) < &(v1[4, 2])];

  * quark exception_tag_pointer_comparison_lower_dimension_doubt;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between multi-dimensional lookup slot locations
where the implementation is unabled to determine whether the two
lookup slot locations have different values for some dimension other
than the final one.

Note that currently multi-dimensional lookups require all dimensions
to have finite integer values, so there will never been any doubt
about whether they match, so currently an exception with this tag will
never be generated.  This exception tag is a placeholder in case in
the future multi-dimensional lookups are allowed with non-integer
values.

  * quark exception_tag_pointer_comparison_star_non_star;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between lookup slot locations where a star in one
of the lookups corresponds to a value in the other.

EXAMPLE:

      + variable v1;
        [] := [&(v1[*]) < &(v1[4])];

  * quark exception_tag_pointer_comparison_star_difference;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between lookup slot locations where a star in one
of the lookups corresponds to a star in the other with a different
filter type.

EXAMPLE:

      + variable v1;
        [] := [&(v1[* : integer]) < &(v1[* : rational])];

  * quark exception_tag_pointer_comparison_range_non_range;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between lookup slot locations where a range in
one of the lookups corresponds to a single value in the other.

EXAMPLE:

      + variable v1;
        [] := [&(v1[5]) < &(v1[4...6])];

  * quark exception_tag_pointer_comparison_incompatible_ranges;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between lookup slot locations with ranges in
corresponding positions where these ranges are not the same.

EXAMPLE:

      + variable v1;
        [] := [&(v1[3...5]) < &(v1[3...6])];

  * quark exception_tag_pointer_comparison_undecidable_order;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between lookup slot locations where the ordering
of the values in the final dimension is undecidable -- i.e., an
ordering comparison of these two values is illegal.

EXAMPLE:

      + variable v1;
        [] := [&(v1[1/0]) < &(v1[3])];

  * quark exception_tag_pointer_comparison_final_match_doubt;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between lookup slot locations with values in the
final dimensions where the implementation is unable to determine
whether the values in the final dimension are the same.

Note that currently exceptions with this tag are never generated
because any pointer comparison with a non-integer final dimension
causes the generation of an
exception_tag_pointer_comparison_final_non_integer exception, and the
implementation can always tell if two integers are equal or not.

  * quark exception_tag_pointer_comparison_final_non_integer;

An exception with this tag is generated when an attempt is made to do
a pointer comparison between lookup slot locations where the value in
the final dimension of at least one of the lookups is not an integer.

EXAMPLE:

      + variable v1;
        [] := [&(v1["Chuck"]) < &(v1["Sarah"])];

  * quark exception_tag_lookup_overloaded_range_bad_value;

An exception with this tag is generated when an attempt is made to
read through a range in a lookup slot location where the lookup is
overloaded, the overload hits, and the result returned by the
operator[] call is not a map or semi-labeled value list but the lookup
has at least one additional dimension or a field lookup.

EXAMPLES:

      + immutable i1 := 17;
        function operator[](value : integer, lower : integer, upper : integer)
          { return "Silicon Spice"; };
        [] := [i1[3...4, 22]];

      + variable v1 := 17;
        function operator[](value : integer, lower : integer, upper : integer)
          { return "Broadcom"; };
        v1[3...4].a := [18, 19];

  * quark exception_tag_lookup_overloaded_star_bad_value;

An exception with this tag is generated when an attempt is made to
read through a star in a lookup slot location where the lookup is
overloaded, the overload hits, and the result returned by the
operator[] call is not a map or semi-labeled value list but the lookup
has at least one additional dimension or a field lookup.

EXAMPLES:

      + immutable i1 := 17;
        function operator[](value : integer, star : {"*"})
          { return "Agricola"; };
        [] := [i1[*, 33]];

      + variable v1 := 17;
        function operator[](value : integer, star : {"*"})
          { return "Settlers of Catan"; };
        v1[*].a := [18, 19];

  * quark exception_tag_lookup_non_integer_non_map;

An exception with this tag is generated when an attempt is made to
read through a lookup with a non-integer value when the base value is
not a map.

EXAMPLE:

      + immutable i1 := [18, 19];
        [] := [i1["flower"]];

  * quark exception_tag_lookup_match_indeterminate;

An exception with this tag is generated when an attempt is made to
read through a lookup with a single value for a dimension and a map as
the base value and the implementation is unable to determine whether
or not the value in the dimension matches one of the keys in the map.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 3) == 1));
        immutable i1 := <<((type filter_a) --> 12)>>;
        [] := [i1[type filter_b]];

  * quark exception_tag_lookup_filter_indeterminate;

An exception with this tag is generated when an attempt is made to
read through a lookup with a filter for a dimension and a map as the
base value and the implementation is unable to determine whether or
not the filter matches one of the keys in the map.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 3) == 1));
        immutable i1 := <<((type filter_a) --> 12)>>;
        [] := [i1[* : type filter_b]];

  * quark exception_tag_lookup_undefined;

An exception with this tag is generated when an attempt is made to
read through a lookup with a single value for a dimension and either
the base value is a map for which that key is not defined and there is
no default or the base value is a semi-labeled value list and the key
is not an integer, is less than zero, or is greater than or equal to
the number of items in the semi-labeled value list.

EXAMPLES:

      + [] := [[12, 13][-1]];

      + [] := [[12, 13][3]];

      + [] := [<<(5 --> 12), (7 --> 13)>>[6]];

  * quark exception_tag_lookup_bad_base;

An exception with this tag is generated when an attempt is made to
read through a lookup and the base value is not a semi-labeled value
list or a map.

EXAMPLES:

      + [] := [5[3]];

      + [] := [5[3...7]];

      + [] := [5[*]];

  * quark exception_tag_lookup_write_match_indeterminate;

An exception with this tag is generated when an attempt is made to
write through a lookup with a single value for a dimension and a map
as the base value and the implementation is unable to determine
whether or not the value in the dimension matches one of the existing
keys in the map.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 3) == 1));
        variable v1 := <<((type filter_a) --> 12)>>;
        v1[type filter_b].b := 13;

  * quark exception_tag_lookup_write_range_not_array;

An exception with this tag is generated when an attempt is made to
write through a lookup with a range for a dimension and the value
being assigned is not an array.

EXAMPLES:

      + variable v1;
        v1[15...18] := 18;

      + variable v1;
        v1[15...18].f1 := 18;

      + function operator[](value, lower : integer, upper : integer)
          { return [f1 := "Broadcom"]; };
        function operator[](value, new_value)
          { return ["Broadcom", new_value]; };
        variable v1 := 17;
        v1[15...18].f1 := 18;

  * quark exception_tag_lookup_write_star_not_array;

An exception with this tag is generated when an attempt is made to
write through a lookup with a star for a dimension and the value being
assigned is not an array or map.

EXAMPLES:

      + variable v1;
        v1[*] := 18;

      + variable v1;
        v1[*].f1 := 18;

      + function operator[](value, star : {"*"})
          { return [f1 := "Broadcom"]; };
        variable v1 := 17;
        v1[*].f1 := 18;

  * quark exception_tag_overloading_resolution_uninstantiated;

An exception with this tag is generated when an attempt is made to
call a routine where the base of the routine is a routine instance
chain and at least one of the items on the chain has not yet been
instantiated by executing its declaration and the overloading cannot
be resolved before reaching that item on the chain.

Note that the call in question can be due to overloading instead of
being an explicit call.

EXAMPLES:

      + procedure p1(x : {3, 5})
          { print("a.\n"); };
        p1(7);
        procedure p1(x : {7, 9})
          { print("b.\n"); };

      + [] := [3 + 2];
        function operator+(x : integer, y : integer)
          { return x - y; };

  * quark exception_tag_overloading_resolution_deallocated;

An exception with this tag is generated when an attempt is made to
call a routine where the base of the routine is a routine instance
chain and at least one of the items on the chain has been de-allocated
and the overloading cannot be resolved before reaching that item on
the chain.

Note that the call in question can be due to overloading instead of
being an explicit call.

EXAMPLES:

      + variable v1;
          {
            procedure p1(x : {3, 5})
              { print("a.\n"); };
            procedure p1(x : {7, 9})
              { print("b.\n"); };
            v1 := p1;
          };
        v1(7);

      + variable v1;
          {
            function operator+(x : integer, y : integer)
              { return x - y; };
            v1 := procedure() { [] := [3 + 2]; };
          };
        v1();

  * quark exception_tag_overloading_resolution_indeterminate;

An exception with this tag is generated when an attempt is made to
call a routine where the base of the routine is a routine instance
chain and the implementation is unable to determine whether the
argument list matches that required for one of the items on the chain
and overloading wasn't resolved before reaching that item on the
chain.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        procedure p1(x)
          { print("a.\n"); };
        procedure p1(x : type filter_a)
          { print("b.\n"); };
        p1(type filter_b);

  * quark exception_tag_assertion_failure;

An exception with this tag is generated when a call is made to the
standard library assert() function and the argument value is false.

EXAMPLE:

      + assert(false);

  * quark exception_tag_make_string_undefined;

An exception with this tag is generated when a call is made to the
standard library make_string() function and the argument is a
non-dense array -- that is, it is a map with a value for an integer
key greater than zero but not for another integer key greater than or
equal to zero and less than that key.

EXAMPLE:

      + immutable i1 := <<(0 --> 'H'), (2 --> 'i')>>;
        [] := [make_string(i1)];

  * quark exception_tag_from_utf8_undefined;

An exception with this tag is generated when a call is made to the
standard library from_utf8() function and the argument is a non-dense
array -- that is, it is a map with a value for an integer key greater
than zero but not for another integer key greater than or equal to
zero and less than that key.

EXAMPLE:

      + immutable i1 := <<(0 --> 0xfe), (2 --> 0xa2)>>;
        [] := [from_utf8(i1)];

  * quark exception_tag_from_utf8_more_than_one;

An exception with this tag is generated when a call is made to the
standard library from_utf8() function and the argument contains more
than a single UTF-8 character.

EXAMPLE:

      + immutable i1 := <<(0 --> 0x28), (1 --> 0x24)>>;
        [] := [from_utf8(i1)];

  * quark exception_tag_from_utf16_undefined;

An exception with this tag is generated when a call is made to the
standard library from_utf16() function and the argument is a non-dense
array -- that is, it is a map with a value for an integer key greater
than zero but not for another integer key greater than or equal to
zero and less than that key.

EXAMPLE:

      + immutable i1 := <<(1 --> 0xfe87)>>;
        [] := [from_utf16(i1)];

  * quark exception_tag_from_utf16_more_than_one;

An exception with this tag is generated when a call is made to the
standard library from_utf16() function and the argument contains more
than a single UTF-16 character.

EXAMPLE:

      + immutable i1 := <<(0 --> 0x28), (1 --> 0x24)>>;
        [] := [from_utf16(i1)];

  * quark exception_tag_string_from_utf8_undefined;

An exception with this tag is generated when a call is made to the
standard library string_from_utf8() function and the argument is a
non-dense array -- that is, it is a map with a value for an integer
key greater than zero but not for another integer key greater than or
equal to zero and less than that key.

EXAMPLE:

      + immutable i1 := <<(0 --> 0xfe), (2 --> 0xa2)>>;
        [] := [string_from_utf8(i1)];

  * quark exception_tag_string_from_utf16_undefined;

An exception with this tag is generated when a call is made to the
standard library string_from_utf16() function and the argument is a
non-dense array -- that is, it is a map with a value for an integer
key greater than zero but not for another integer key greater than or
equal to zero and less than that key.

EXAMPLE:

      + immutable i1 := <<(1 --> 0xfe87)>>;
        [] := [string_from_utf16(i1)];

  * quark exception_tag_string_from_utf32_undefined;

An exception with this tag is generated when a call is made to the
standard library string_from_utf32() function and the argument is a
non-dense array -- that is, it is a map with a value for an integer
key greater than zero but not for another integer key greater than or
equal to zero and less than that key.

EXAMPLE:

      + immutable i1 := <<(1 --> 0xfe87)>>;
        [] := [string_from_utf32(i1)];

  * quark exception_tag_delete_variable_component;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a slot
location specifying a part of a variable or immutable instead of just
a single variable or immutable.  This occurs when the slot location is
a lookup, field reference, or tagalong field reference slot location.

EXAMPLES:

      + variable v1;
        delete(&(v1[3]));

      + variable v1;
        delete(&(v1.a));

      + variable v1;
        tagalong t1;
        delete(&(v1..t1));

  * quark exception_tag_delete_variable_overloaded;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a slot
location that maps to a call because of overloading.

EXAMPLES:

      + function operator*(base : [1...15])  (base);
        delete(&(*7));

      + variable v1 := 5;
        function operator*(base : [1...15])  (base);
        delete(&(*&v1));

  * quark exception_tag_delete_variable_automatic;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a slot
location specifying a variable or immutable with automatic allocation
and de-allocation.

EXAMPLE:

      + variable v1;
        delete(&v1);

  * quark exception_tag_delete_routine_automatic;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a routine with
automatic allocation and de-allocation.

EXAMPLE:

      + procedure p1() { };
        delete(p1);

  * quark exception_tag_delete_routine_active;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a routine that
is currently executing.  A routine is considered to be executing if a
default argument expression or dynamic parameter type or dynamic
return type expression is being evaluated for that routine, as well as
during the execution of the body of that routine.

Note that this applies no matter how many other routines are also
running.  Note also that this only applies to the same instance of a
routine; an exception with this tag will not be generated if a
different instance of the routine is executing but not the same
instance, even if they share the same declaration.

EXAMPLES:

      + ageless procedure p1(x := {delete(p1); return 5;}, y)
          {
          };
        p1(y := 7);

      + ageless procedure p1()
          {
            delete(p1);
          };
        p1();

  * quark exception_tag_delete_tagalong_key_automatic;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a tagalong key
with automatic allocation and de-allocation.

EXAMPLE:

      + tagalong t1;
        delete(t1);

  * quark exception_tag_delete_lepton_key_automatic;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a lepton key
with automatic allocation and de-allocation.

EXAMPLE:

      + lepton l1;
        delete(l1);

  * quark exception_tag_delete_quark_automatic;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a quark with
automatic allocation and de-allocation.

EXAMPLE:

      + quark q1;
        delete(q1);

  * quark exception_tag_delete_lock_automatic;

An exception with this tag is generated when a call is made to the
standard library delete() procedure and the argument is a lock with
automatic allocation and de-allocation.

EXAMPLE:

      + lock l1;
        delete(l1);

  * quark exception_tag_delete_object_incomplete;

An exception with this tag is generated when an attempt is made to
delete an object that is incomplete.  An object becomes complete when
the call to its class successfully returns the object value.  While
the class body is still executing, the object is incomplete.  If
control jumps out the body so that the object is never returned, it is
never completed -- it might have been stored somewhere and still be
accessible, but it will never be complete.

EXAMPLE:

      + class c1()
          {
            delete(this);
            immutable i1 := 53;
          };
        [] := [c1()];

  * quark exception_tag_split_null_match;

An exception with this tag is generated when a call is made to the
standard library split() function and the null string matches the
pattern.

EXAMPLE:

      + [] := [split(@@, "abc")];

  * quark exception_tag_join_undefined;

An exception with this tag is generated when a call is made to the
standard library join() function and the first argument is a non-dense
array -- that is, it is a map with a value for an integer key greater
than zero but not for another integer key greater than or equal to
zero and less than that key.

EXAMPLES:

      + [] := [join(<<(0 --> "ab"), (2 --> "cd")>>, ",")];

      + [] := [join(<<(0 --> "ab"), (2 --> "cd")>>,
                    function() returns string (","))];

  * quark exception_tag_filter_undefined;

An exception with this tag is generated when a call is made to the
standard library filter() function and the second argument is a
non-dense array -- that is, it is a map with a value for an integer
key greater than zero but not for another integer key greater than or
equal to zero and less than that key.

EXAMPLES:

      + [] := [filter(@a@, <<(0 --> "ab"), (2 --> "cd")>>)];

      + [] := [filter(type string, <<(0 --> "ab"), (2 --> "cd")>>)];

  * quark exception_tag_filter_doubt;

An exception with this tag is generated when a call is made to the
standard library filter() function with a type as the first argument
and the second argument contains an element for which the
implementation is unable to determine whether that element is in that
type.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [filter(type type filter_a, [type filter_b])];

  * quark exception_tag_substitute_null_match;

An exception with this tag is generated when a call is made to the
standard library substitute() function and the null string matches the
pattern.

EXAMPLES:

      + [] := [substitute(@@, "abc", ",")];

      + [] := [substitute(@@, "abc",
                          function(x : string) returns string ("-" ~ x))];

  * quark exception_tag_parse_regular_expression_bad_pattern;

An exception with this tag is generated when a call is made to the
standard library parse_regular_expression() function and the argument
is a string that doesn't follow the rules required for a regular
expression (the same rules required of the text between the ``@''
characters in a regular expression literal token).

EXAMPLES:

      + [] := [parse_regular_expression(")")];

      + [] := [parse_regular_expression("(")];

      + [] := [parse_regular_expression("*")];

      + [] := [parse_regular_expression("+")];

      + [] := [parse_regular_expression("?")];

      + [] := [parse_regular_expression("{}")];

      + [] := [parse_regular_expression("[a-z")];

      + [] := [parse_regular_expression("\\xQ")];

      + [] := [parse_regular_expression("\\x")];

      + [] := [parse_regular_expression("\\x0")];

      + [] := [parse_regular_expression("\\xd800")];

      + [] := [parse_regular_expression("\\x110000")];

      + [] := [parse_regular_expression("\\w")];

      + [] := [parse_regular_expression("[\\s-z]")];

      + [] := [parse_regular_expression("[a-\\s]")];

      + [] := [parse_regular_expression("a{5}")];

      + [] := [parse_regular_expression("a{5,7")];

      + [] := [parse_regular_expression("a{7,5}")];

  * quark exception_tag_character_set_undefined;

An exception with this tag is generated when a call is made to the
standard library character_set() function and the argument is a
non-dense array -- that is, it is a map with a value for an integer
key greater than zero but not for another integer key greater than or
equal to zero and less than that key.

EXAMPLE:

      + [] := [character_set(<<(0 --> 'a'), (2 --> 'b')>>)];

  * quark exception_tag_array_length_indeterminate;

An exception with this tag is generated what a call is made to the
standard library length() function or to the write() method of a file
stream opened through the standard library and the array in question
has a length that the implementation cannot determine.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [length(<<(* : ([0...8] & filter_a) --> 10)>>)];

  * quark exception_tag_call_undefined;

An exception with this tag is generated when a call is made to the
standard library call() function and the second argument is a
non-dense array -- that is, it is a map with a value for an integer
key greater than zero but not for another integer key greater than or
equal to zero and less than that key.

EXAMPLE:

      + procedure p1(...)  { print("arguments: ", arguments, ".\n"); };
        call(p1, <<(0 --> 'a'), (2 --> 'b')>>);

  * quark exception_tag_closed_stream_used;

An exception with this tag is generated when a stream created by the
standard library for file access has one of its methods called after
its close() method has been called.

  * quark exception_tag_file_tell_failed;

An exception with this tag is generated when a stream created by the
standard library for file access has its tell() method called and the
tell() fails because of an interaction with the outside world, such as
a disk I/O failure.

  * quark exception_tag_file_seek_failed;

An exception with this tag is generated when a stream created by the
standard library for file access has its seek() method called and the
seek() fails because of an interaction with the outside world, such as
a disk I/O failure.

  * quark exception_tag_file_open_failed;

An exception with this tag is generated when a request to the standard
library to open a file fails because of an interaction with the
outside world, such as a disk I/O failure or an operating system
permission failure.

  * quark exception_tag_file_io_failure;

An exception with this tag is generated when an attempt to read or
write data through a stream created by the standard library for file
access fails because of an interaction with the outside world, such
as a disk I/O failure or an operating system permission failure.

  * quark exception_tag_directory_read_failed;

An exception with this tag is generated when a call is made to the
standard library directory_contents() function and it fails because of
an interaction with the outside world, such as a disk I/O failure or
an operating system permission failure.

  * quark exception_tag_remove_failed;

An exception with this tag is generated when a call is made to the
standard library remove() function and it fails because of an
interaction with the outside world, such as a disk I/O failure or an
operating system permission failure.

  * quark exception_tag_rename_failed;

An exception with this tag is generated when a call is made to the
standard library rename() function and it fails because of an
interaction with the outside world, such as a disk I/O failure or an
operating system permission failure.

  * quark exception_tag_throw_unnamed_extra;

An exception with this tag is generated when a call is made to the
standard library throw() function and the ``other'' parameter to the
call contains an unnamed field.

EXAMPLE:

      + throw(quark, "Test", other := [17]);

  * quark exception_tag_current_exceptions_no_exception;

An exception with this tag is generated when a call is made to the
standard library current_exceptions() function and there are no
current exceptions because it is called outside the ``catch'' block of
a try-catch statement.

EXAMPLE:

      + [] := [current_exceptions()];

  * quark exception_tag_bad_utf8;

An exception with this tag is generated when the standard library is
converting from bits in UTF-8 format to characters or strings and the
bits aren't valid UTF-8.  This can happen in the from_utf8() and
string_from_utf8() functions and while reading from an input file
opened as a text file with UTF-8 specified as the file format.

EXAMPLES:

      + [] := [string_from_utf8([0x80, 0x80])];

      + [] := [string_from_utf8([0xf8, 0x80])];

      + [] := [string_from_utf8([0xc0])];

      + [] := [string_from_utf8([0xc0, 0x08])];

      + [] := [string_from_utf8([0xed, 0xa0, 0x80])];

      + [] := [string_from_utf8([0xf4, 0x90, 0x80, 0x80])];

      + [] := [string_from_utf8([0xc0, 0x85])];

      + [] := [string_from_utf8([0xe0, 0x80, 0x85])];

      + [] := [string_from_utf8([0xf0, 0x80, 0x80, 0x85])];

  * quark exception_tag_bad_utf16;

An exception with this tag is generated when the standard library is
converting from bits in UTF-16 format to characters or strings and the
bits aren't valid UTF-16.  This can happen in the from_utf16() and
string_from_utf16() functions and while reading from an input file
opened as a text file with UTF-16 specified as the file format.

EXAMPLES:

      + [] := [string_from_utf16([0xdc00, 0x8000])];

      + [] := [string_from_utf16([0xd800])];

      + [] := [string_from_utf16([0xd800, 0x0000])];

  * quark exception_tag_bad_utf32;

An exception with this tag is generated when the standard library is
converting from bits in UTF-32 format to characters or strings and the
bits aren't valid UTF-32.  This can happen while reading from an input
file opened as a text file with UTF-32 specified as the file format.

  * quark exception_tag_read_count_too_big;

An exception with this tag is generated when reading data from a file
through the standard library and the number of items to be read is so
large it exceeds the addressable size of the system.

  * quark exception_tag_read_bit_count_not_8_divisible;

An exception with this tag is generated when reading data from a file
as bits through the standard library and the number of bits specified
to be read is not a multiple of 8.

  * quark exception_tag_write_count_too_big;

An exception with this tag is generated when writing data to a file
through the standard library and the number of items to be written is
so large it exceeds the addressable size of the system.

  * quark exception_tag_write_bit_count_not_8_divisible;

An exception with this tag is generated when writing data to a file as
bits through the standard library and the number of bits specified to
be written is not a multiple of 8.

  * quark exception_tag_write_missing_element;

An exception with this tag is generated when writing data to a file
through the standard library and the array of data being written is a
non-dense array -- that is, it is a map with a value for an integer
key greater than zero but not for another integer key greater than or
equal to zero and less than that key.

  * quark exception_tag_write_element_too_big;

An exception with this tag is generated when writing data to a file as
bits through the standard library and one of the items in the array
being written does not fit in the number of bits per item specified.

  * quark exception_tag_array_too_large;

An exception with this tag is generated when the array passed to the
standard library routine make_string(), string_from_utf8(),
string_from_utf16(), string_from_utf32(), join(), filter(),
character_set(), or call() is too large.  In this context, too large
means a map with a key value so large the implementation can't handle
iterating through to all the keys from zero to that large key value.
Exactly how large a key value must be to cause this exception is
implementation-specific, but it's intended to be large enough to
accomodate the addressable memory size.  If a semi-labeled value list
of a particular element count could be created in an implementation,
then a map with a key of the number of elements in the semi-labeled
value list minus one should not cause this exception to be generated.

EXAMPLES:

      + [] := [make_string(<<(0 --> 'A'), (1 << 1000 --> 'B')>>)];

      + [] := [string_from_utf8(<<(0 --> 32), (1 << 1000 --> 32)>>)];

      + [] := [string_from_utf16(<<(0 --> 32), (1 << 1000 --> 32)>>)];

      + [] := [string_from_utf32(<<(0 --> 32), (1 << 1000 --> 32)>>)];

      + [] := [join(<<(0 --> "A"), (1 << 1000 --> "B")>>, " + ")];

      + [] := [join(<<(0 --> "A"), (1 << 1000 --> "B")>>,
                    function() returns string (" + "))];

      + [] := [filter(@AB@, <<(0 --> "A"), (1 << 1000 --> "B")>>)];

      + [] := [filter(type integer, <<(0 --> 17), (1 << 1000 --> 18)>>)];

      + [] := [character_set(<<(0 --> 'A'), (1 << 1000 --> 'B')>>)];

      + call(procedure(x) { }, <<(0 --> 'A'), (1 << 1000 --> 'B')>>);

  * quark exception_tag_sprint_not_string;

An exception with this tag is generated when a call is made to one of
the standard library non-formatted printing routines to print an
object with a sprint() method taking no arguments and that object's
sprint() routine returns a non-string value.

EXAMPLE:

      + class c1(x)
          {
            function sprint() (x);
          };
        print(c1(5));

  * quark exception_tag_printf_unclosed_specifier;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines and the format string
contains an un-closed specifier (i.e. an odd number of percent sign
characters).

EXAMPLE:

      + printf("%a");

  * quark exception_tag_printf_too_few_arguments;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines and the format string
contains a specifier which requires an argument whose index
corresponds to something beyond the end of the arguments given.

EXAMPLES:

      + [] := [sprintf("%f%")];

      + [] := [sprintf("%20:f%", 12)];

  * quark exception_tag_printf_zero_argument;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines and the format string
contains a specifier which specified the argument at index zero.

EXAMPLE:

      + [] := [sprintf("%0:f%", 12)];

  * quark exception_tag_printf_bad_argument_name;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines and the format string
contains a specifier which specified an argument by name but the
actual arguments to the call do not include an argument by that name.

EXAMPLE:

      + [] := [sprintf("%b:f%", a := 12)];

  * quark exception_tag_printf_sprint_not_string;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines to print an object
with a sprint() method and that object's sprint() routine returns a
non-string value.

EXAMPLE:

      + class c1(x)
          {
            function sprint() (x);
          };
        printf("%v%", c1(5));

  * quark exception_tag_printf_bad_specifier;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines and the format string
contains a specifier which is not in the form of a valid specifier.

EXAMPLE:

      + printf("%q%", 87);

  * quark exception_tag_printf_not_string;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines and the format string
contains an "s" specifier but the corresponding value is not a string
or character value.

EXAMPLE:

      + printf("%s%", 57);

  * quark exception_tag_printf_not_integer;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines and the format string
contains a specifier requiring an integer but the corresponding value
is a non-integer value.

EXAMPLE:

      + printf("%i%", "tomato");

  * quark exception_tag_printf_not_rational;

An exception with this tag is generated when a call is made to one of
the standard library formatted printing routines and the format string
contains a specifier requiring a rational but the corresponding value
is a non-rational value.

EXAMPLE:

      + printf("%f%", "tomato");

  * quark exception_tag_force_match_indeterminate;

An exception with this tag is generated when an attempt is made to
force a value to a type and the implementation is unable to determine
whether the value is already in the type.

EXAMPLES:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [type filter_a :: type filter_b];

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        pure function filter_b(x) returns boolean
          ((x in integer) && ((x % 3) == 1));
        [] := [<<(18 --> "something"), ((type filter_a) --> 3)>> ::
               (type filter_b) --> string];

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [[12, <<(* --> "default")>>] :: [[0...4], filter_a --> string]];

  * quark exception_tag_type_for_invalid_nothing_indeterminate;

An exception with this tag is generated when an attempt is made to
test whether or not an invalid value is in a type and the
implementation is unable to determine whether the type can be the
empty type.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [(&i1) in filter_a];
        immutable i1 := 5;

  * quark exception_tag_type_for_invalid_everything_indeterminate;

An exception with this tag is generated when an attempt is made to
test whether or not an invalid value is in a type and the
implementation is unable to determine whether the type can be the type
of all values.

EXAMPLE:

      + pure function filter_a(x) returns boolean
          ((x in integer) && ((x % 5) == 1));
        [] := [(&i1) in (integer | filter_a)];
        immutable i1 := 5;

  * quark exception_tag_lock_grab_uninstantiated;

An exception with this tag is generated when an attempt is made to
grab a lock before that lock has been instantiated by executing its
declaration.

EXAMPLE:

      + single(l1) { };
        lock l1;

  * quark exception_tag_lock_grab_deallocated;

An exception with this tag is generated when an attempt is made to
grab a lock after that lock has been de-allocated.

EXAMPLE:

      + variable v1;
          {
            lock l1;
            v1 := single(l1) procedure() { };
          };
        v1();

  * quark exception_tag_lock_release_uninstantiated;

An exception with this tag is generated when an attempt is made to
release a lock before that lock has been instantiated by executing its
declaration.

Note that with the core Salmon language and the standard library there
is no way this can happen since it is impossible to release a lock
without first grabbing that same lock, and if the lock wasn't
instantiated at release time it wasn't instantiated when it was
grabbed, which would have caused an exception at lock grabbing time,
so the release never would have been reached.  However, other
libraries may be made available which could allow an attempt to
release a lock that hadn't been grabbed, so using such an external
library may cause an exception with this tag to be generated.

  * quark exception_tag_lock_release_deallocated;

An exception with this tag is generated when an attempt is made to
release a lock after that lock has been de-allocated.

EXAMPLE:

      + variable v1 := lock;
        single (v1)
          {
            delete(v1);
          };

  * quark exception_tag_lock_release_not_held;

An exception with this tag is generated when an attempt is made to
release a lock when that lock is not currently held.

Note that with the core Salmon language and the standard library there
is no way this can happen since it is impossible to release a lock
without first grabbing that same lock.  However, other libraries may
be made available which could allow an attempt to release a lock that
hadn't been grabbed, so using such an external library may cause an
exception with this tag to be generated.

  * quark exception_tag_tagalong_reference_scope_exited;

An exception with this tag is generated when an attempt is made to use
a tagalong key to access a tagalong after that tagalong key has been
de-allocated.

EXAMPLE:

      + variable v1;
          {
            tagalong ta1;
            v1 := procedure() { v1..ta1 := 5; };
          };
        v1();

  * quark exception_tag_object_tagalong_read_non_object;

An exception with this tag is generated when an attempt is made to
read a tagalong value from a non-object value with a key that was
declared using the "object" option.

EXAMPLE:

      + class c1() { };
        tagalong t1 := 8 on object !{};
        variable v1 := 5;
        [] := [v1..t1];

  * quark exception_tag_object_tagalong_write_non_object;

An exception with this tag is generated when an attempt is made to
write a tagalong value to a non-object value with a key that was
declared using the "object" option.

EXAMPLE:

      + class c1() { };
        tagalong t1 on object !{};
        variable v1 := 5;
        v1..t1 := 7;

  * quark exception_tag_try_catch_tag_match_indeterminate;

An exception with this tag is generated when an exception has been
generated and the implementation is testing to see if it is in the
type for a ``catch'' clause for a try-catch statement but the
implementation is unable to determine whether the tag is in the type
for that clause.

  * quark exception_tag_deadlock;

An exception with this tag may be generated when the implementation
detects that threads are blocked in such a way that deadlock has
occurred and the threads involved would not come out of the deadlock
situation on their own.  For example, if Thread 1 held lock A and was
blocked trying to grab lock B while Thread 2 held B and was blocked
trying to grab lock C and Thread 3 helad C and tried to grab A,
deadlock occurs.  In this situation, the implementation may give an
exception to one or more of these three threads, causing their lock
grabbing operations to fail.

The implementation is not required to ever detect deadlock, so an
implementation can instead just let the threads that are deadlocked
wait indefinitely.


        Chapter 7: Optional Language Extensions
        =======================================

This chapter is for extensions to the standard Salmon language that
may optionally be supported by a Salmon implementation.  An
implementation need not support any such extensions.


    Section 7.1: Fully-General Continuations
    ----------------------------------------

Salmon's label statements and goto statements give the functionality
of escape continuations.  This optional extension gives fully-general
continuation functionality to Salmon.

In this extension, the identifier token "ageless" may optionally be
added as a prefix to label statements.  When this prefix is used, it
changes when the jump target associated with that label becomes
invalid.

Normally, when a scope exits, all jump targets associated with that
scope become invalid.  But in this extension, jump targets associated
with ageless labels do not automatically become invalid when their
scopes exit.  Instead, when a scope would normally exit, a check is
done to see if any ageless jump targets within the scope still have
references from outside the scope.  If they do, the scope doesn't exit
when control leaves it.  The scope remains active, local instances are
not de-allocated, and ageless jump targets may still be used.  It is
only when all the references from outside the scope to all the ageless
jump targets within a scope have been removed that the scope finally
exits.

So, with ageless labels, one can jump back into a previous point of
execution, even if that was within various routine calls, loops,
nested scopes, etc.  All the local instances remain and are accessable
when control jumps back, though data values may have changed.

Note that this allows jumping back into the body of a for statement,
for example, after the for statement is finished, but it does not
allow jumping into the body without ever having started execution of
the for statement in the first place, because the label isn't visible
outside the body of the for statement.  Control must enter the body
normally once in order to grab the ageless jump target and being to go
back to it.


        Chapter 8: Future Directions
        ============================

The biggest feature that is intended for a future version of Salmon
but that is not in the present version of Salmon is the ability to let
the user specify arbitrary mathematical proofs of various properties.
This feature has been intended for Salmon from the very beginning.
Proofs can be used to prove assertions and that other run-time
properties hold.  This is useful in two ways -- to catch all possible
assertion failures and other kinds of run-time failures at compile
time, and to allow the generation of better code.

I left proofs out of this early version of Salmon so that I could have
a working version of Salmon to use to experiment with various
potential proof syntax and semantics choices using real, working
Salmon programs.  I have some ideas about proofs, but I would like to
see what kinds of proofs I need for my real programs before choosing
among them.

Leaving out proofs shouldn't affect the evaluation of the non-proof
portions of Salmon's syntax and semantics, since any program written
with the language extended with proofs would likely be strutured the
same way, but potentially with proofs added.  I have enough idea how
proof syntax is likely to work to know that the syntax of proofs is
unlikely to be overly constrained by the syntax choices for the rest
of the language.
