/* file "thread.si" */

/*
 *  This file gives the interface to a thread module for Salmon.
 *
 *  Written by Chris Wilson.
 *
 *  This file is hearby placed in the public domain by its author.
 */


/*
 *  This is a flag that is set to true on platforms on which Salmon supports
 *  multi-threading and set to false on platforms on which Salmon does not
 *  support multi-threading.
 */
multi_threading_works :- boolean,

running :- any_quark,
finished :- any_quark,
blocked :- any_quark,
sleeping :- any_quark,
suspended :- any_quark,

status :- { type { running, finished, blocked, sleeping, suspended } },

exit_normal :- any_quark,
exit_exceptions :- any_quark,
exit_killed :- any_quark,
exit_died :- any_quark,
exit_jumped_out :- any_quark,

exit_status :- { type
  { exit_normal, exit_exceptions, exit_killed, exit_died, exit_jumped_out } },

thread :- { type interface
  [
    name :- string <-- (),
    is_done :- boolean <-- (),
    interrupt :- {} <-- (tag : any_quark, message : string,
                         other : [...] := *),
    kill :- {} <-- (),
    wait_for_termination :- {} <-- (),
    get_status :- status <-- (),
    suspend :- {} <-- (),
    resume :- {} <-- (),
    get_source_position :- source_region <-- (),
    get_exit_status :- exit_status <-- (),
    get_exit_exceptions :- array[exception] <-- (),
    get_exit_jump_target :- jump_target <-- ()
  ] },

create_thread :- thread <-- (body : {} <-- (), name : string := *),

semaphore :- { type interface
  [
    /*
     * Semaphores have two core operations, the first of which increments the
     * counter and the second of which decrements it, waiting if necessary
     * until that is possible without going below zero.  The use of semaphores
     * has a long history, and different names have been used over the years
     * for these same two operations.  According to Wikipedia's "Semaphore
     * (programming)" article (as accessed on Tuesday, March 15, 2011), common
     * names for the first operation are "V", "signal", "up", "release",
     * "post", and "vacate".  Common names for the second operation are "P",
     * "wait", "down", "acquire", "pend", and "procure".  In the interest of
     * allowing users to use the names they are already familiar with, and
     * following the convention in this interface that only lower-case letters
     * are used in identifiers, the lower-case versions of all of these names
     * are provided in this interface as aliases to the two core operations.
     *
     * The optional integer parameter is the amount by which the semaphore
     * value is to be increased or decreased.  It defaults to one if this
     * parameter is not provided.
     */

    v :- {} <-- ([1...+oo] := *),
    signal :- {} <-- ([1...+oo] := *),
    up :- {} <-- ([1...+oo] := *),
    release :- {} <-- ([1...+oo] := *),
    post :- {} <-- ([1...+oo] := *),
    vacate :- {} <-- ([1...+oo] := *),

    p :- {} <-- ([1...+oo] := *),
    wait :- {} <-- ([1...+oo] := *),
    down :- {} <-- ([1...+oo] := *),
    acquire :- {} <-- ([1...+oo] := *),
    pend :- {} <-- ([1...+oo] := *),
    procure :- {} <-- ([1...+oo] := *),

    current :- [0...+oo] <-- (),

    /*
     * The try_p() method is a variant on p() that has a time limit.  If the
     * p() operation can complete in the time specified by the "seconds"
     * parameter, it acts like p() and returns true.  Otherwise, it leaves the
     * semaphore unchanged and returns false.  The default value of "seconds"
     * is zero, so if "seconds" is not provided, try_p() is non-blocking and
     * will always return immediately one was or the other.  If "seconds" is
     * "+oo", the effect is the same as p() and it will never return false.
     */
    try_p :- boolean <-- ([1...+oo] := *, seconds : [0....+oo] := *)
  ] },

/*
 * The default value of "start" is false for boolean_semaphore() and zero for
 * integer_semaphore().
 */
boolean_semaphore :- semaphore <-- (start : boolean := *),
integer_semaphore :- semaphore <-- (limit : [1...+oo], start : [0...+oo] := *),

wait_for_all_threads :- {} <-- (),
all_threads :- array[thread] <-- (),
current_thread :- thread <-- (),
sleep :- {} <-- (seconds : [0....+oo]),
yield :- {} <-- (),

/*
 * The following are exception tags for exceptions that can be generated by
 * this module.
 */

/*
 *  An exception with this tag is generated if the create_thread() function
 *  fails.  It can fail for system-specific reasons, such as if the maximum
 *  number of threads allowed by the underlying system already exist.
 */
et_thread_creation_failed :- any_quark,

/*
 *  An exception with this tag is generated if the `seconds' parameter to a
 *  semaphore try_p() call specifies a finite value so big that the current
 *  time plus this value in seconds is farther in the future than the
 *  underlying system's clock mechanism can handle.  For example, many
 *  operating systems do their timekeeping based on a signed 32-bit number of
 *  seconds since the start of 1970.  Such a system cannot represent times
 *  beyond January 19, 2038.  So, if such operating systems do their thread
 *  scheduling based on this system, it is usually not possible to specify that
 *  a thread be awoken at a time after this date.  A Salmon implementation
 *  relying on the native thread support in such an operating system would
 *  throw an exception with this tag if the `seconds' value specified a time
 *  beyond January 19, 2038.
 */
et_time_too_far :- any_quark,

/*
 *  An exception with this tag is generated if up() is called on a semaphore
 *  when the current value of the semaphore plus the amount being added by up()
 *  is greater than the limit for that semaphore.
 */
et_semaphore_up_beyond_limit :- any_quark,

/*
 *  An exception with this tag is generated when a thread other than the root
 *  thread calls wait_for_all_threads(), because otherwise it would be waiting
 *  for itself to finish, so it would wait forever.
 */
et_wait_all_not_root :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's
 *  interrupt() method is made with an "other" parameter that isn't a
 *  semi-labeled value list without any unnamed fields.
 */
et_interrupt_unnamed_extra :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's
 *  interrupt() method is made after the thread has finished executing.
 */
et_interrupt_finished :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's suspend()
 *  method is made after the thread has finished executing.
 */
et_suspend_finished :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's suspend()
 *  method is made while the thread is already suspended.
 */
et_suspend_suspended :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's resume()
 *  method is made while the thread is not suspended.
 */
et_resume_not_suspended :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's
 *  get_exit_status() method is made before the thread has finished.
 */
et_get_exit_status_not_finished :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's
 *  get_exit_exceptions() method is made before the thread has finished.
 */
et_get_exit_exceptions_not_finished :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's
 *  get_exit_exceptions() method is made on a thread whose exit status is not
 *  exit_exceptions.
 */
et_get_exit_exceptions_no_exception :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's
 *  get_exit_jump_target() method is made before the thread has finished.
 */
et_get_exit_jump_target_not_finished :- any_quark,

/*
 *  An exception with this tag is generated when a call to a thread's
 *  get_exit_jump_target() method is made on a thread whose exit status is not
 *  exit_jumped_out.
 */
et_get_exit_jump_target_no_jump :- any_quark
